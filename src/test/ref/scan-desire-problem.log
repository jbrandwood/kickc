Warning! Adding boolean cast to non-boolean condition *((byte*) strcpy::src)
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call (byte~) init::$3 ← call toD018 (byte*) screen (byte*) charset 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) @7
Culled Empty Block (label) @8
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) @12
Culled Empty Block (label) @13
Culled Empty Block (label) memset::@7
Culled Empty Block (label) memset::@6
Culled Empty Block (label) memset::@8
Culled Empty Block (label) memset::@9
Culled Empty Block (label) memset::@3
Culled Empty Block (label) @14
Culled Empty Block (label) @15
Culled Empty Block (label) mul8u::@5
Culled Empty Block (label) mul8u::@6
Culled Empty Block (label) mul8u::@8
Culled Empty Block (label) mul8u::@9
Culled Empty Block (label) @16
Culled Empty Block (label) @17
Culled Empty Block (label) @18
Culled Empty Block (label) @19
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@12
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@8
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@10
Culled Empty Block (label) main::@14
Culled Empty Block (label) @21
Culled Empty Block (label) init::toD0181_@1
Culled Empty Block (label) @22
Culled Empty Block (label) @23

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) SPRITES_XMSB#0 ← ((byte*)) (number) $d010
  (byte*) SPRITES_ENABLE#0 ← ((byte*)) (number) $d015
  (byte*) SPRITES_EXPAND_Y#0 ← ((byte*)) (number) $d017
  (byte*) SPRITES_MC#0 ← ((byte*)) (number) $d01c
  (byte*) SPRITES_EXPAND_X#0 ← ((byte*)) (number) $d01d
  (byte*) BORDERCOL#0 ← ((byte*)) (number) $d020
  (byte*) BGCOL1#0 ← ((byte*)) (number) $d021
  (byte*) BGCOL2#0 ← ((byte*)) (number) $d022
  (byte*) BGCOL3#0 ← ((byte*)) (number) $d023
  (byte*) BGCOL4#0 ← ((byte*)) (number) $d024
  (byte*) SPRITES_COLS#0 ← ((byte*)) (number) $d027
  (byte*) D018#0 ← ((byte*)) (number) $d018
  (byte) BLACK#0 ← (number) 0
  (byte) WHITE#0 ← (number) 1
  (byte) RED#0 ← (number) 2
  (byte) GREEN#0 ← (number) 5
  (byte) BLUE#0 ← (number) 6
  (byte) YELLOW#0 ← (number) 7
  to:@20

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from init::@2 init::@3
  (byte) memset::c#5 ← phi( init::@2/(byte) memset::c#0 init::@3/(byte) memset::c#1 )
  (void*) memset::str#4 ← phi( init::@2/(void*) memset::str#0 init::@3/(void*) memset::str#1 )
  (word) memset::num#2 ← phi( init::@2/(word) memset::num#0 init::@3/(word) memset::num#1 )
  (bool~) memset::$0 ← (word) memset::num#2 > (number) 0
  (bool~) memset::$1 ← ! (bool~) memset::$0
  if((bool~) memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@4
  (void*) memset::str#2 ← phi( memset/(void*) memset::str#4 memset::@4/(void*) memset::str#5 )
  (void*) memset::return#0 ← (void*) memset::str#2
  to:memset::@return
memset::@2: scope:[memset]  from memset
  (byte) memset::c#4 ← phi( memset/(byte) memset::c#5 )
  (word) memset::num#3 ← phi( memset/(word) memset::num#2 )
  (void*) memset::str#3 ← phi( memset/(void*) memset::str#4 )
  (byte*~) memset::$2 ← ((byte*)) (void*) memset::str#3
  (byte*~) memset::$3 ← (byte*~) memset::$2 + (word) memset::num#3
  (byte*) memset::end#0 ← (byte*~) memset::$3
  (byte*) memset::dst#0 ← ((byte*)) (void*) memset::str#3
  to:memset::@4
memset::@4: scope:[memset]  from memset::@2 memset::@5
  (byte) memset::c#3 ← phi( memset::@2/(byte) memset::c#4 memset::@5/(byte) memset::c#2 )
  (void*) memset::str#5 ← phi( memset::@2/(void*) memset::str#3 memset::@5/(void*) memset::str#6 )
  (byte*) memset::end#1 ← phi( memset::@2/(byte*) memset::end#0 memset::@5/(byte*) memset::end#2 )
  (byte*) memset::dst#2 ← phi( memset::@2/(byte*) memset::dst#0 memset::@5/(byte*) memset::dst#1 )
  (bool~) memset::$4 ← (byte*) memset::dst#2 != (byte*) memset::end#1
  if((bool~) memset::$4) goto memset::@5
  to:memset::@1
memset::@5: scope:[memset]  from memset::@4
  (void*) memset::str#6 ← phi( memset::@4/(void*) memset::str#5 )
  (byte*) memset::end#2 ← phi( memset::@4/(byte*) memset::end#1 )
  (byte*) memset::dst#3 ← phi( memset::@4/(byte*) memset::dst#2 )
  (byte) memset::c#2 ← phi( memset::@4/(byte) memset::c#3 )
  *((byte*) memset::dst#3) ← (byte) memset::c#2
  (byte*) memset::dst#1 ← ++ (byte*) memset::dst#3
  to:memset::@4
memset::@return: scope:[memset]  from memset::@1
  (void*) memset::return#4 ← phi( memset::@1/(void*) memset::return#0 )
  (void*) memset::return#1 ← (void*) memset::return#4
  return 
  to:@return

(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
mul8u: scope:[mul8u]  from draw_block
  (byte) mul8u::a#5 ← phi( draw_block/(byte) mul8u::a#1 )
  (byte) mul8u::b#1 ← phi( draw_block/(byte) mul8u::b#0 )
  (word) mul8u::res#0 ← (number) 0
  (word) mul8u::mb#0 ← (byte) mul8u::b#1
  to:mul8u::@1
mul8u::@1: scope:[mul8u]  from mul8u mul8u::@4
  (word) mul8u::mb#5 ← phi( mul8u/(word) mul8u::mb#0 mul8u::@4/(word) mul8u::mb#1 )
  (word) mul8u::res#4 ← phi( mul8u/(word) mul8u::res#0 mul8u::@4/(word) mul8u::res#6 )
  (byte) mul8u::a#2 ← phi( mul8u/(byte) mul8u::a#5 mul8u::@4/(byte) mul8u::a#0 )
  (bool~) mul8u::$0 ← (byte) mul8u::a#2 != (number) 0
  if((bool~) mul8u::$0) goto mul8u::@2
  to:mul8u::@3
mul8u::@2: scope:[mul8u]  from mul8u::@1
  (word) mul8u::res#5 ← phi( mul8u::@1/(word) mul8u::res#4 )
  (word) mul8u::mb#4 ← phi( mul8u::@1/(word) mul8u::mb#5 )
  (byte) mul8u::a#3 ← phi( mul8u::@1/(byte) mul8u::a#2 )
  (number~) mul8u::$1 ← (byte) mul8u::a#3 & (number) 1
  (bool~) mul8u::$2 ← (number~) mul8u::$1 != (number) 0
  (bool~) mul8u::$3 ← ! (bool~) mul8u::$2
  if((bool~) mul8u::$3) goto mul8u::@4
  to:mul8u::@7
mul8u::@3: scope:[mul8u]  from mul8u::@1
  (word) mul8u::res#2 ← phi( mul8u::@1/(word) mul8u::res#4 )
  (word) mul8u::return#0 ← (word) mul8u::res#2
  to:mul8u::@return
mul8u::@4: scope:[mul8u]  from mul8u::@2 mul8u::@7
  (word) mul8u::res#6 ← phi( mul8u::@2/(word) mul8u::res#5 mul8u::@7/(word) mul8u::res#1 )
  (word) mul8u::mb#2 ← phi( mul8u::@2/(word) mul8u::mb#4 mul8u::@7/(word) mul8u::mb#3 )
  (byte) mul8u::a#4 ← phi( mul8u::@2/(byte) mul8u::a#3 mul8u::@7/(byte) mul8u::a#6 )
  (byte~) mul8u::$5 ← (byte) mul8u::a#4 >> (number) 1
  (byte) mul8u::a#0 ← (byte~) mul8u::$5
  (word~) mul8u::$6 ← (word) mul8u::mb#2 << (number) 1
  (word) mul8u::mb#1 ← (word~) mul8u::$6
  to:mul8u::@1
mul8u::@7: scope:[mul8u]  from mul8u::@2
  (byte) mul8u::a#6 ← phi( mul8u::@2/(byte) mul8u::a#3 )
  (word) mul8u::mb#3 ← phi( mul8u::@2/(word) mul8u::mb#4 )
  (word) mul8u::res#3 ← phi( mul8u::@2/(word) mul8u::res#5 )
  (word~) mul8u::$4 ← (word) mul8u::res#3 + (word) mul8u::mb#3
  (word) mul8u::res#1 ← (word~) mul8u::$4
  to:mul8u::@4
mul8u::@return: scope:[mul8u]  from mul8u::@3
  (word) mul8u::return#3 ← phi( mul8u::@3/(word) mul8u::return#0 )
  (word) mul8u::return#1 ← (word) mul8u::return#3
  return 
  to:@return
@20: scope:[]  from @begin
  (byte*) screen#0 ← ((byte*)) (number) $400
  (byte*) charset#0 ← ((byte*)) (number) $2000
  (byte*) tileset#0 ← ((byte*)) (number) $2800
  (byte*) colors#0 ← ((byte*)) (number) $d800
  (byte*) level_address#0 ← ((byte*)) (number) $3000
  to:@24

(void()) main()
main: scope:[main]  from @24
  call init 
  to:main::@15
main::@15: scope:[main]  from main
  (byte) main::x#0 ← (number) 0
  to:main::@1
main::@1: scope:[main]  from main::@15 main::@6
  (byte) main::x#2 ← phi( main::@15/(byte) main::x#0 main::@6/(byte) main::x#1 )
  (bool~) main::$1 ← (byte) main::x#2 < (number) $10
  if((bool~) main::$1) goto main::@2
  to:main::@13
main::@2: scope:[main]  from main::@1
  (byte) main::x#7 ← phi( main::@1/(byte) main::x#2 )
  (byte) main::y#0 ← (number) 0
  to:main::@4
main::@4: scope:[main]  from main::@16 main::@2
  (byte) main::x#5 ← phi( main::@16/(byte) main::x#6 main::@2/(byte) main::x#7 )
  (byte) main::y#2 ← phi( main::@16/(byte) main::y#1 main::@2/(byte) main::y#0 )
  (bool~) main::$2 ← (byte) main::y#2 < (number) 9
  if((bool~) main::$2) goto main::@5
  to:main::@6
main::@5: scope:[main]  from main::@4
  (byte) main::y#3 ← phi( main::@4/(byte) main::y#2 )
  (byte) main::x#3 ← phi( main::@4/(byte) main::x#5 )
  (byte~) main::$3 ← (byte) main::x#3 + (byte) main::y#3
  (byte) main::z#0 ← (byte~) main::$3
  (byte) main::tile#0 ← *((byte*) level_address#0 + (byte) main::z#0)
  (byte) draw_block::tileno#0 ← (byte) main::tile#0
  (byte) draw_block::x#0 ← (byte) main::x#3
  (byte) draw_block::y#0 ← (byte) main::y#3
  (byte) draw_block::color#0 ← (byte) YELLOW#0
  call draw_block 
  to:main::@16
main::@16: scope:[main]  from main::@5
  (byte) main::x#6 ← phi( main::@5/(byte) main::x#3 )
  (byte) main::y#4 ← phi( main::@5/(byte) main::y#3 )
  (byte) main::y#1 ← ++ (byte) main::y#4
  to:main::@4
main::@6: scope:[main]  from main::@4
  (byte) main::x#4 ← phi( main::@4/(byte) main::x#5 )
  (byte) main::x#1 ← ++ (byte) main::x#4
  to:main::@1
main::@13: scope:[main]  from main::@1 main::@13
  if(true) goto main::@13
  to:main::@return
main::@return: scope:[main]  from main::@13
  return 
  to:@return

(void()) init()
init: scope:[init]  from main
  call init_sprites 
  to:init::@2
init::@2: scope:[init]  from init
  (void*) memset::str#0 ← (void*)(byte*) screen#0
  (byte) memset::c#0 ← (number) 0
  (word) memset::num#0 ← (number) $3e8
  call memset 
  (void*) memset::return#2 ← (void*) memset::return#1
  to:init::@3
init::@3: scope:[init]  from init::@2
  (void*) memset::str#1 ← (void*)(byte*) colors#0
  (byte) memset::c#1 ← (byte) BLACK#0
  (word) memset::num#1 ← (number) $3e8
  call memset 
  (void*) memset::return#3 ← (void*) memset::return#1
  to:init::@4
init::@4: scope:[init]  from init::@3
  (byte*) init::toD0181_screen#0 ← (byte*) screen#0
  (byte*) init::toD0181_gfx#0 ← (byte*) charset#0
  to:init::toD0181
init::toD0181: scope:[init]  from init::@4
  (byte*) init::toD0181_gfx#1 ← phi( init::@4/(byte*) init::toD0181_gfx#0 )
  (byte*) init::toD0181_screen#1 ← phi( init::@4/(byte*) init::toD0181_screen#0 )
  (word~) init::toD0181_$0#0 ← ((word)) (byte*) init::toD0181_screen#1
  (number~) init::toD0181_$1#0 ← (word~) init::toD0181_$0#0 & (number) $3fff
  (number~) init::toD0181_$2#0 ← (number~) init::toD0181_$1#0 * (number) 4
  (number~) init::toD0181_$3#0 ← > (number~) init::toD0181_$2#0
  (word~) init::toD0181_$4#0 ← ((word)) (byte*) init::toD0181_gfx#1
  (byte~) init::toD0181_$5#0 ← > (word~) init::toD0181_$4#0
  (number~) init::toD0181_$6#0 ← (byte~) init::toD0181_$5#0 / (number) 4
  (number~) init::toD0181_$7#0 ← (number~) init::toD0181_$6#0 & (number) $f
  (number~) init::toD0181_$8#0 ← (number~) init::toD0181_$3#0 | (number~) init::toD0181_$7#0
  (byte) init::toD0181_return#0 ← (number~) init::toD0181_$8#0
  to:init::toD0181_@return
init::toD0181_@return: scope:[init]  from init::toD0181
  (byte) init::toD0181_return#2 ← phi( init::toD0181/(byte) init::toD0181_return#0 )
  (byte) init::toD0181_return#1 ← (byte) init::toD0181_return#2
  to:init::@1
init::@1: scope:[init]  from init::toD0181_@return
  (byte) init::toD0181_return#3 ← phi( init::toD0181_@return/(byte) init::toD0181_return#1 )
  (byte~) init::$3 ← (byte) init::toD0181_return#3
  *((byte*) D018#0) ← (byte~) init::$3
  asm { lda#$5b sta$d011  }
  *((byte*) BORDERCOL#0) ← (byte) BLACK#0
  *((byte*) BGCOL1#0) ← (byte) BLACK#0
  *((byte*) BGCOL2#0) ← (byte) RED#0
  *((byte*) BGCOL3#0) ← (byte) BLUE#0
  *((byte*) BGCOL4#0) ← (byte) GREEN#0
  to:init::@return
init::@return: scope:[init]  from init::@1
  return 
  to:@return

(void()) init_sprites()
init_sprites: scope:[init_sprites]  from init
  *((byte*) SPRITES_ENABLE#0) ← (number) 1
  *((byte*) SPRITES_EXPAND_X#0) ← (number) 0
  *((byte*) SPRITES_EXPAND_Y#0) ← (number) 0
  *((byte*) SPRITES_XMSB#0) ← (number) 0
  *((byte*) SPRITES_COLS#0) ← (byte) WHITE#0
  *((byte*) SPRITES_MC#0) ← (number) 0
  to:init_sprites::@return
init_sprites::@return: scope:[init_sprites]  from init_sprites
  return 
  to:@return

(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
draw_block: scope:[draw_block]  from main::@5
  (byte) draw_block::y#2 ← phi( main::@5/(byte) draw_block::y#0 )
  (byte) draw_block::x#1 ← phi( main::@5/(byte) draw_block::x#0 )
  (byte) draw_block::tileno#2 ← phi( main::@5/(byte) draw_block::tileno#0 )
  (byte~) draw_block::$0 ← (byte) draw_block::tileno#2 << (number) 2
  (byte) draw_block::tileno#1 ← (byte~) draw_block::$0
  (byte~) draw_block::$1 ← (byte) draw_block::x#1 << (number) 1
  (word) draw_block::x1#0 ← (byte~) draw_block::$1
  (byte~) draw_block::$2 ← (byte) draw_block::y#2 << (number) 1
  (byte) draw_block::y#1 ← (byte~) draw_block::$2
  (byte) mul8u::a#1 ← (byte) draw_block::y#1
  (byte) mul8u::b#0 ← (number) $28
  call mul8u 
  (word) mul8u::return#2 ← (word) mul8u::return#1
  to:draw_block::@1
draw_block::@1: scope:[draw_block]  from draw_block
  (byte) draw_block::tileno#3 ← phi( draw_block/(byte) draw_block::tileno#1 )
  (word) draw_block::x1#1 ← phi( draw_block/(word) draw_block::x1#0 )
  (word) mul8u::return#4 ← phi( draw_block/(word) mul8u::return#2 )
  (word~) draw_block::$3 ← (word) mul8u::return#4
  (word) draw_block::z#0 ← (word~) draw_block::$3
  (word~) draw_block::$4 ← (word) draw_block::z#0 + (word) draw_block::x1#1
  (word) draw_block::z#1 ← (word~) draw_block::$4
  (byte) draw_block::drawtile#0 ← *((byte*) tileset#0 + (byte) draw_block::tileno#3)
  *((byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0
  *((byte*) colors#0 + (word) draw_block::z#1) ← (byte) YELLOW#0
  (number~) draw_block::$5 ← (word) draw_block::z#1 + (number) 1
  *((byte*) screen#0 + (number~) draw_block::$5) ← (number) 1
  (number~) draw_block::$6 ← (word) draw_block::z#1 + (number) 1
  *((byte*) colors#0 + (number~) draw_block::$6) ← (byte) YELLOW#0
  (number~) draw_block::$7 ← (word) draw_block::z#1 + (number) $28
  *((byte*) screen#0 + (number~) draw_block::$7) ← (number) 2
  (number~) draw_block::$8 ← (word) draw_block::z#1 + (number) $28
  *((byte*) colors#0 + (number~) draw_block::$8) ← (byte) YELLOW#0
  (number~) draw_block::$9 ← (word) draw_block::z#1 + (number) $29
  *((byte*) screen#0 + (number~) draw_block::$9) ← (number) 3
  (number~) draw_block::$10 ← (word) draw_block::z#1 + (number) $29
  *((byte*) colors#0 + (number~) draw_block::$10) ← (byte) YELLOW#0
  to:draw_block::@return
draw_block::@return: scope:[draw_block]  from draw_block::@1
  return 
  to:@return
@24: scope:[]  from @20
  call main 
  to:@25
@25: scope:[]  from @24
  to:@end
@end: scope:[]  from @25

SYMBOL TABLE SSA
(label) @20
(label) @24
(label) @25
(label) @begin
(label) @end
(byte*) BGCOL1
(byte*) BGCOL1#0
(byte*) BGCOL2
(byte*) BGCOL2#0
(byte*) BGCOL3
(byte*) BGCOL3#0
(byte*) BGCOL4
(byte*) BGCOL4#0
(byte) BLACK
(byte) BLACK#0
(byte) BLUE
(byte) BLUE#0
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte*) D018
(byte*) D018#0
(byte) GREEN
(byte) GREEN#0
(byte) RED
(byte) RED#0
(byte*) SPRITES_COLS
(byte*) SPRITES_COLS#0
(byte*) SPRITES_ENABLE
(byte*) SPRITES_ENABLE#0
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_X#0
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_EXPAND_Y#0
(byte*) SPRITES_MC
(byte*) SPRITES_MC#0
(byte*) SPRITES_XMSB
(byte*) SPRITES_XMSB#0
(byte) WHITE
(byte) WHITE#0
(byte) YELLOW
(byte) YELLOW#0
(byte*) charset
(byte*) charset#0
(byte*) colors
(byte*) colors#0
(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
(byte~) draw_block::$0
(byte~) draw_block::$1
(number~) draw_block::$10
(byte~) draw_block::$2
(word~) draw_block::$3
(word~) draw_block::$4
(number~) draw_block::$5
(number~) draw_block::$6
(number~) draw_block::$7
(number~) draw_block::$8
(number~) draw_block::$9
(label) draw_block::@1
(label) draw_block::@return
(byte) draw_block::color
(byte) draw_block::color#0
(byte) draw_block::drawtile
(byte) draw_block::drawtile#0
(byte) draw_block::tileno
(byte) draw_block::tileno#0
(byte) draw_block::tileno#1
(byte) draw_block::tileno#2
(byte) draw_block::tileno#3
(byte) draw_block::x
(byte) draw_block::x#0
(byte) draw_block::x#1
(word) draw_block::x1
(word) draw_block::x1#0
(word) draw_block::x1#1
(byte) draw_block::y
(byte) draw_block::y#0
(byte) draw_block::y#1
(byte) draw_block::y#2
(word) draw_block::z
(word) draw_block::z#0
(word) draw_block::z#1
(void()) init()
(byte~) init::$3
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@return
(label) init::toD0181
(word~) init::toD0181_$0
(word~) init::toD0181_$0#0
(number~) init::toD0181_$1
(number~) init::toD0181_$1#0
(number~) init::toD0181_$2
(number~) init::toD0181_$2#0
(number~) init::toD0181_$3
(number~) init::toD0181_$3#0
(word~) init::toD0181_$4
(word~) init::toD0181_$4#0
(byte~) init::toD0181_$5
(byte~) init::toD0181_$5#0
(number~) init::toD0181_$6
(number~) init::toD0181_$6#0
(number~) init::toD0181_$7
(number~) init::toD0181_$7#0
(number~) init::toD0181_$8
(number~) init::toD0181_$8#0
(label) init::toD0181_@return
(byte*) init::toD0181_gfx
(byte*) init::toD0181_gfx#0
(byte*) init::toD0181_gfx#1
(byte) init::toD0181_return
(byte) init::toD0181_return#0
(byte) init::toD0181_return#1
(byte) init::toD0181_return#2
(byte) init::toD0181_return#3
(byte*) init::toD0181_screen
(byte*) init::toD0181_screen#0
(byte*) init::toD0181_screen#1
(void()) init_sprites()
(label) init_sprites::@return
(byte*) level_address
(byte*) level_address#0
(void()) main()
(bool~) main::$1
(bool~) main::$2
(byte~) main::$3
(label) main::@1
(label) main::@13
(label) main::@15
(label) main::@16
(label) main::@2
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@return
(byte) main::tile
(byte) main::tile#0
(byte) main::x
(byte) main::x#0
(byte) main::x#1
(byte) main::x#2
(byte) main::x#3
(byte) main::x#4
(byte) main::x#5
(byte) main::x#6
(byte) main::x#7
(byte) main::y
(byte) main::y#0
(byte) main::y#1
(byte) main::y#2
(byte) main::y#3
(byte) main::y#4
(byte) main::z
(byte) main::z#0
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(bool~) memset::$0
(bool~) memset::$1
(byte*~) memset::$2
(byte*~) memset::$3
(bool~) memset::$4
(label) memset::@1
(label) memset::@2
(label) memset::@4
(label) memset::@5
(label) memset::@return
(byte) memset::c
(byte) memset::c#0
(byte) memset::c#1
(byte) memset::c#2
(byte) memset::c#3
(byte) memset::c#4
(byte) memset::c#5
(byte*) memset::dst
(byte*) memset::dst#0
(byte*) memset::dst#1
(byte*) memset::dst#2
(byte*) memset::dst#3
(byte*) memset::end
(byte*) memset::end#0
(byte*) memset::end#1
(byte*) memset::end#2
(word) memset::num
(word) memset::num#0
(word) memset::num#1
(word) memset::num#2
(word) memset::num#3
(void*) memset::return
(void*) memset::return#0
(void*) memset::return#1
(void*) memset::return#2
(void*) memset::return#3
(void*) memset::return#4
(void*) memset::str
(void*) memset::str#0
(void*) memset::str#1
(void*) memset::str#2
(void*) memset::str#3
(void*) memset::str#4
(void*) memset::str#5
(void*) memset::str#6
(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
(bool~) mul8u::$0
(number~) mul8u::$1
(bool~) mul8u::$2
(bool~) mul8u::$3
(word~) mul8u::$4
(byte~) mul8u::$5
(word~) mul8u::$6
(label) mul8u::@1
(label) mul8u::@2
(label) mul8u::@3
(label) mul8u::@4
(label) mul8u::@7
(label) mul8u::@return
(byte) mul8u::a
(byte) mul8u::a#0
(byte) mul8u::a#1
(byte) mul8u::a#2
(byte) mul8u::a#3
(byte) mul8u::a#4
(byte) mul8u::a#5
(byte) mul8u::a#6
(byte) mul8u::b
(byte) mul8u::b#0
(byte) mul8u::b#1
(word) mul8u::mb
(word) mul8u::mb#0
(word) mul8u::mb#1
(word) mul8u::mb#2
(word) mul8u::mb#3
(word) mul8u::mb#4
(word) mul8u::mb#5
(word) mul8u::res
(word) mul8u::res#0
(word) mul8u::res#1
(word) mul8u::res#2
(word) mul8u::res#3
(word) mul8u::res#4
(word) mul8u::res#5
(word) mul8u::res#6
(word) mul8u::return
(word) mul8u::return#0
(word) mul8u::return#1
(word) mul8u::return#2
(word) mul8u::return#3
(word) mul8u::return#4
(byte*) screen
(byte*) screen#0
(byte*) tileset
(byte*) tileset#0

Adding number conversion cast (unumber) 0 in (byte) BLACK#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) WHITE#0 ← (number) 1
Adding number conversion cast (unumber) 2 in (byte) RED#0 ← (number) 2
Adding number conversion cast (unumber) 5 in (byte) GREEN#0 ← (number) 5
Adding number conversion cast (unumber) 6 in (byte) BLUE#0 ← (number) 6
Adding number conversion cast (unumber) 7 in (byte) YELLOW#0 ← (number) 7
Adding number conversion cast (unumber) 0 in (bool~) memset::$0 ← (word) memset::num#2 > (number) 0
Adding number conversion cast (unumber) 0 in (word) mul8u::res#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (bool~) mul8u::$0 ← (byte) mul8u::a#2 != (number) 0
Adding number conversion cast (unumber) 1 in (number~) mul8u::$1 ← (byte) mul8u::a#3 & (number) 1
Adding number conversion cast (unumber) mul8u::$1 in (number~) mul8u::$1 ← (byte) mul8u::a#3 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) mul8u::$2 ← (unumber~) mul8u::$1 != (number) 0
Adding number conversion cast (unumber) 1 in (byte~) mul8u::$5 ← (byte) mul8u::a#4 >> (number) 1
Adding number conversion cast (unumber) 1 in (word~) mul8u::$6 ← (word) mul8u::mb#2 << (number) 1
Adding number conversion cast (unumber) 0 in (byte) main::x#0 ← (number) 0
Adding number conversion cast (unumber) $10 in (bool~) main::$1 ← (byte) main::x#2 < (number) $10
Adding number conversion cast (unumber) 0 in (byte) main::y#0 ← (number) 0
Adding number conversion cast (unumber) 9 in (bool~) main::$2 ← (byte) main::y#2 < (number) 9
Adding number conversion cast (unumber) 0 in (byte) memset::c#0 ← (number) 0
Adding number conversion cast (unumber) $3e8 in (word) memset::num#0 ← (number) $3e8
Adding number conversion cast (unumber) $3e8 in (word) memset::num#1 ← (number) $3e8
Adding number conversion cast (unumber) $3fff in (number~) init::toD0181_$1#0 ← (word~) init::toD0181_$0#0 & (number) $3fff
Adding number conversion cast (unumber) init::toD0181_$1#0 in (number~) init::toD0181_$1#0 ← (word~) init::toD0181_$0#0 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) init::toD0181_$2#0 ← (unumber~) init::toD0181_$1#0 * (number) 4
Adding number conversion cast (unumber) init::toD0181_$2#0 in (number~) init::toD0181_$2#0 ← (unumber~) init::toD0181_$1#0 * (unumber)(number) 4
Adding number conversion cast (unumber) init::toD0181_$3#0 in (number~) init::toD0181_$3#0 ← > (unumber~) init::toD0181_$2#0
Adding number conversion cast (unumber) 4 in (number~) init::toD0181_$6#0 ← (byte~) init::toD0181_$5#0 / (number) 4
Adding number conversion cast (unumber) init::toD0181_$6#0 in (number~) init::toD0181_$6#0 ← (byte~) init::toD0181_$5#0 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) init::toD0181_$7#0 ← (unumber~) init::toD0181_$6#0 & (number) $f
Adding number conversion cast (unumber) init::toD0181_$7#0 in (number~) init::toD0181_$7#0 ← (unumber~) init::toD0181_$6#0 & (unumber)(number) $f
Adding number conversion cast (unumber) init::toD0181_$8#0 in (number~) init::toD0181_$8#0 ← (unumber~) init::toD0181_$3#0 | (unumber~) init::toD0181_$7#0
Adding number conversion cast (unumber) 1 in *((byte*) SPRITES_ENABLE#0) ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte*) SPRITES_EXPAND_X#0) ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*) SPRITES_EXPAND_Y#0) ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*) SPRITES_XMSB#0) ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*) SPRITES_MC#0) ← (number) 0
Adding number conversion cast (unumber) 2 in (byte~) draw_block::$0 ← (byte) draw_block::tileno#2 << (number) 2
Adding number conversion cast (unumber) 1 in (byte~) draw_block::$1 ← (byte) draw_block::x#1 << (number) 1
Adding number conversion cast (unumber) 1 in (byte~) draw_block::$2 ← (byte) draw_block::y#2 << (number) 1
Adding number conversion cast (unumber) $28 in (byte) mul8u::b#0 ← (number) $28
Adding number conversion cast (unumber) 1 in (number~) draw_block::$5 ← (word) draw_block::z#1 + (number) 1
Adding number conversion cast (unumber) draw_block::$5 in (number~) draw_block::$5 ← (word) draw_block::z#1 + (unumber)(number) 1
Adding number conversion cast (unumber) 1 in *((byte*) screen#0 + (unumber~) draw_block::$5) ← (number) 1
Adding number conversion cast (unumber) 1 in (number~) draw_block::$6 ← (word) draw_block::z#1 + (number) 1
Adding number conversion cast (unumber) draw_block::$6 in (number~) draw_block::$6 ← (word) draw_block::z#1 + (unumber)(number) 1
Adding number conversion cast (unumber) $28 in (number~) draw_block::$7 ← (word) draw_block::z#1 + (number) $28
Adding number conversion cast (unumber) draw_block::$7 in (number~) draw_block::$7 ← (word) draw_block::z#1 + (unumber)(number) $28
Adding number conversion cast (unumber) 2 in *((byte*) screen#0 + (unumber~) draw_block::$7) ← (number) 2
Adding number conversion cast (unumber) $28 in (number~) draw_block::$8 ← (word) draw_block::z#1 + (number) $28
Adding number conversion cast (unumber) draw_block::$8 in (number~) draw_block::$8 ← (word) draw_block::z#1 + (unumber)(number) $28
Adding number conversion cast (unumber) $29 in (number~) draw_block::$9 ← (word) draw_block::z#1 + (number) $29
Adding number conversion cast (unumber) draw_block::$9 in (number~) draw_block::$9 ← (word) draw_block::z#1 + (unumber)(number) $29
Adding number conversion cast (unumber) 3 in *((byte*) screen#0 + (unumber~) draw_block::$9) ← (number) 3
Adding number conversion cast (unumber) $29 in (number~) draw_block::$10 ← (word) draw_block::z#1 + (number) $29
Adding number conversion cast (unumber) draw_block::$10 in (number~) draw_block::$10 ← (word) draw_block::z#1 + (unumber)(number) $29
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) SPRITES_XMSB#0 ← (byte*)(number) $d010
Inlining cast (byte*) SPRITES_ENABLE#0 ← (byte*)(number) $d015
Inlining cast (byte*) SPRITES_EXPAND_Y#0 ← (byte*)(number) $d017
Inlining cast (byte*) SPRITES_MC#0 ← (byte*)(number) $d01c
Inlining cast (byte*) SPRITES_EXPAND_X#0 ← (byte*)(number) $d01d
Inlining cast (byte*) BORDERCOL#0 ← (byte*)(number) $d020
Inlining cast (byte*) BGCOL1#0 ← (byte*)(number) $d021
Inlining cast (byte*) BGCOL2#0 ← (byte*)(number) $d022
Inlining cast (byte*) BGCOL3#0 ← (byte*)(number) $d023
Inlining cast (byte*) BGCOL4#0 ← (byte*)(number) $d024
Inlining cast (byte*) SPRITES_COLS#0 ← (byte*)(number) $d027
Inlining cast (byte*) D018#0 ← (byte*)(number) $d018
Inlining cast (byte) BLACK#0 ← (unumber)(number) 0
Inlining cast (byte) WHITE#0 ← (unumber)(number) 1
Inlining cast (byte) RED#0 ← (unumber)(number) 2
Inlining cast (byte) GREEN#0 ← (unumber)(number) 5
Inlining cast (byte) BLUE#0 ← (unumber)(number) 6
Inlining cast (byte) YELLOW#0 ← (unumber)(number) 7
Inlining cast (byte*~) memset::$2 ← (byte*)(void*) memset::str#3
Inlining cast (byte*) memset::dst#0 ← (byte*)(void*) memset::str#3
Inlining cast (word) mul8u::res#0 ← (unumber)(number) 0
Inlining cast (byte*) screen#0 ← (byte*)(number) $400
Inlining cast (byte*) charset#0 ← (byte*)(number) $2000
Inlining cast (byte*) tileset#0 ← (byte*)(number) $2800
Inlining cast (byte*) colors#0 ← (byte*)(number) $d800
Inlining cast (byte*) level_address#0 ← (byte*)(number) $3000
Inlining cast (byte) main::x#0 ← (unumber)(number) 0
Inlining cast (byte) main::y#0 ← (unumber)(number) 0
Inlining cast (byte) memset::c#0 ← (unumber)(number) 0
Inlining cast (word) memset::num#0 ← (unumber)(number) $3e8
Inlining cast (word) memset::num#1 ← (unumber)(number) $3e8
Inlining cast (word~) init::toD0181_$0#0 ← (word)(byte*) init::toD0181_screen#1
Inlining cast (word~) init::toD0181_$4#0 ← (word)(byte*) init::toD0181_gfx#1
Inlining cast *((byte*) SPRITES_ENABLE#0) ← (unumber)(number) 1
Inlining cast *((byte*) SPRITES_EXPAND_X#0) ← (unumber)(number) 0
Inlining cast *((byte*) SPRITES_EXPAND_Y#0) ← (unumber)(number) 0
Inlining cast *((byte*) SPRITES_XMSB#0) ← (unumber)(number) 0
Inlining cast *((byte*) SPRITES_MC#0) ← (unumber)(number) 0
Inlining cast (byte) mul8u::b#0 ← (unumber)(number) $28
Inlining cast *((byte*) screen#0 + (unumber~) draw_block::$5) ← (unumber)(number) 1
Inlining cast *((byte*) screen#0 + (unumber~) draw_block::$7) ← (unumber)(number) 2
Inlining cast *((byte*) screen#0 + (unumber~) draw_block::$9) ← (unumber)(number) 3
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53264
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53271
Simplifying constant pointer cast (byte*) 53276
Simplifying constant pointer cast (byte*) 53277
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53281
Simplifying constant pointer cast (byte*) 53282
Simplifying constant pointer cast (byte*) 53283
Simplifying constant pointer cast (byte*) 53284
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (byte*) 53272
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 5
Simplifying constant integer cast 6
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 8192
Simplifying constant pointer cast (byte*) 10240
Simplifying constant pointer cast (byte*) 55296
Simplifying constant pointer cast (byte*) 12288
Simplifying constant integer cast 0
Simplifying constant integer cast $10
Simplifying constant integer cast 0
Simplifying constant integer cast 9
Simplifying constant integer cast 0
Simplifying constant integer cast $3e8
Simplifying constant integer cast $3e8
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $28
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $28
Simplifying constant integer cast 2
Simplifying constant integer cast $28
Simplifying constant integer cast $29
Simplifying constant integer cast 3
Simplifying constant integer cast $29
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $29
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $29
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) mul8u::$1 ← (byte) mul8u::a#3 & (byte) 1
Inferred type updated to word in (unumber~) init::toD0181_$1#0 ← (word~) init::toD0181_$0#0 & (word) $3fff
Inferred type updated to word in (unumber~) init::toD0181_$2#0 ← (word~) init::toD0181_$1#0 * (byte) 4
Inferred type updated to byte in (unumber~) init::toD0181_$3#0 ← > (word~) init::toD0181_$2#0
Inferred type updated to byte in (unumber~) init::toD0181_$6#0 ← (byte~) init::toD0181_$5#0 / (byte) 4
Inferred type updated to byte in (unumber~) init::toD0181_$7#0 ← (byte~) init::toD0181_$6#0 & (byte) $f
Inferred type updated to byte in (unumber~) init::toD0181_$8#0 ← (byte~) init::toD0181_$3#0 | (byte~) init::toD0181_$7#0
Inferred type updated to word in (unumber~) draw_block::$5 ← (word) draw_block::z#1 + (byte) 1
Inferred type updated to word in (unumber~) draw_block::$6 ← (word) draw_block::z#1 + (byte) 1
Inferred type updated to word in (unumber~) draw_block::$7 ← (word) draw_block::z#1 + (byte) $28
Inferred type updated to word in (unumber~) draw_block::$8 ← (word) draw_block::z#1 + (byte) $28
Inferred type updated to word in (unumber~) draw_block::$9 ← (word) draw_block::z#1 + (byte) $29
Inferred type updated to word in (unumber~) draw_block::$10 ← (word) draw_block::z#1 + (byte) $29
Inversing boolean not [20] (bool~) memset::$1 ← (word) memset::num#2 <= (byte) 0 from [19] (bool~) memset::$0 ← (word) memset::num#2 > (byte) 0
Inversing boolean not [47] (bool~) mul8u::$3 ← (byte~) mul8u::$1 == (byte) 0 from [46] (bool~) mul8u::$2 ← (byte~) mul8u::$1 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (void*) memset::return#0 = (void*) memset::str#2 (void*) memset::return#4 (void*) memset::return#1 
Alias (void*) memset::str#3 = (void*) memset::str#4 
Alias (word) memset::num#2 = (word) memset::num#3 
Alias (byte) memset::c#4 = (byte) memset::c#5 
Alias (byte*) memset::end#0 = (byte*~) memset::$3 
Alias (byte) memset::c#2 = (byte) memset::c#3 
Alias (byte*) memset::dst#2 = (byte*) memset::dst#3 
Alias (byte*) memset::end#1 = (byte*) memset::end#2 
Alias (void*) memset::str#5 = (void*) memset::str#6 
Alias (word) mul8u::mb#0 = (byte) mul8u::b#1 
Alias (byte) mul8u::a#2 = (byte) mul8u::a#3 (byte) mul8u::a#6 
Alias (word) mul8u::mb#3 = (word) mul8u::mb#4 (word) mul8u::mb#5 
Alias (word) mul8u::res#2 = (word) mul8u::res#5 (word) mul8u::res#4 (word) mul8u::return#0 (word) mul8u::res#3 (word) mul8u::return#3 (word) mul8u::return#1 
Alias (byte) mul8u::a#0 = (byte~) mul8u::$5 
Alias (word) mul8u::mb#1 = (word~) mul8u::$6 
Alias (word) mul8u::res#1 = (word~) mul8u::$4 
Alias (byte) main::x#2 = (byte) main::x#7 
Alias (byte) main::x#3 = (byte) main::x#5 (byte) main::x#6 (byte) main::x#4 
Alias (byte) main::y#2 = (byte) main::y#3 (byte) main::y#4 
Alias (byte) main::z#0 = (byte~) main::$3 
Alias (byte*) init::toD0181_screen#0 = (byte*) init::toD0181_screen#1 
Alias (byte*) init::toD0181_gfx#0 = (byte*) init::toD0181_gfx#1 
Alias (byte) init::toD0181_return#0 = (byte~) init::toD0181_$8#0 (byte) init::toD0181_return#2 (byte) init::toD0181_return#1 (byte) init::toD0181_return#3 (byte~) init::$3 
Alias (byte) draw_block::tileno#1 = (byte~) draw_block::$0 (byte) draw_block::tileno#3 
Alias (word) draw_block::x1#0 = (byte~) draw_block::$1 (word) draw_block::x1#1 
Alias (byte) draw_block::y#1 = (byte~) draw_block::$2 
Alias (word) mul8u::return#2 = (word) mul8u::return#4 
Alias (word) draw_block::z#0 = (word~) draw_block::$3 
Alias (word) draw_block::z#1 = (word~) draw_block::$4 
Successful SSA optimization Pass2AliasElimination
Alias (byte) mul8u::a#2 = (byte) mul8u::a#4 
Alias (word) mul8u::mb#2 = (word) mul8u::mb#3 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte*) memset::end#1 (byte*) memset::end#0
Identical Phi Values (void*) memset::str#5 (void*) memset::str#3
Identical Phi Values (byte) memset::c#2 (byte) memset::c#4
Identical Phi Values (word) mul8u::mb#0 (byte) mul8u::b#0
Identical Phi Values (byte) mul8u::a#5 (byte) mul8u::a#1
Identical Phi Values (byte) main::x#3 (byte) main::x#2
Identical Phi Values (byte) draw_block::tileno#2 (byte) draw_block::tileno#0
Identical Phi Values (byte) draw_block::x#1 (byte) draw_block::x#0
Identical Phi Values (byte) draw_block::y#2 (byte) draw_block::y#0
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (void*) memset::return#0 (void*) memset::str#3
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) memset::$1 [21] if((word) memset::num#2<=(byte) 0) goto memset::@1
Simple Condition (bool~) memset::$4 [31] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@5
Simple Condition (bool~) mul8u::$0 [43] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2
Simple Condition (bool~) mul8u::$3 [48] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@4
Simple Condition (bool~) main::$1 [71] if((byte) main::x#2<(byte) $10) goto main::@2
Simple Condition (bool~) main::$2 [76] if((byte) main::y#2<(byte) 9) goto main::@5
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) SPRITES_XMSB#0 = (byte*) 53264
Constant (const byte*) SPRITES_ENABLE#0 = (byte*) 53269
Constant (const byte*) SPRITES_EXPAND_Y#0 = (byte*) 53271
Constant (const byte*) SPRITES_MC#0 = (byte*) 53276
Constant (const byte*) SPRITES_EXPAND_X#0 = (byte*) 53277
Constant (const byte*) BORDERCOL#0 = (byte*) 53280
Constant (const byte*) BGCOL1#0 = (byte*) 53281
Constant (const byte*) BGCOL2#0 = (byte*) 53282
Constant (const byte*) BGCOL3#0 = (byte*) 53283
Constant (const byte*) BGCOL4#0 = (byte*) 53284
Constant (const byte*) SPRITES_COLS#0 = (byte*) 53287
Constant (const byte*) D018#0 = (byte*) 53272
Constant (const byte) BLACK#0 = 0
Constant (const byte) WHITE#0 = 1
Constant (const byte) RED#0 = 2
Constant (const byte) GREEN#0 = 5
Constant (const byte) BLUE#0 = 6
Constant (const byte) YELLOW#0 = 7
Constant (const word) mul8u::res#0 = 0
Constant (const byte*) screen#0 = (byte*) 1024
Constant (const byte*) charset#0 = (byte*) 8192
Constant (const byte*) tileset#0 = (byte*) 10240
Constant (const byte*) colors#0 = (byte*) 55296
Constant (const byte*) level_address#0 = (byte*) 12288
Constant (const byte) main::x#0 = 0
Constant (const byte) main::y#0 = 0
Constant (const byte) memset::c#0 = 0
Constant (const word) memset::num#0 = $3e8
Constant (const word) memset::num#1 = $3e8
Constant (const byte) mul8u::b#0 = $28
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) draw_block::color#0 = YELLOW#0
Constant (const byte) memset::c#1 = BLACK#0
Constant (const byte*) init::toD0181_screen#0 = screen#0
Constant (const byte*) init::toD0181_gfx#0 = charset#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (void*)screen#0 in [93] (void*) memset::str#0 ← (void*)(const byte*) screen#0
Constant value identified (void*)colors#0 in [98] (void*) memset::str#1 ← (void*)(const byte*) colors#0
Constant value identified (word)init::toD0181_screen#0 in [106] (word~) init::toD0181_$0#0 ← (word)(const byte*) init::toD0181_screen#0
Constant value identified (word)init::toD0181_gfx#0 in [110] (word~) init::toD0181_$4#0 ← (word)(const byte*) init::toD0181_gfx#0
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [90] if(true) goto main::@13
Successful SSA optimization Pass2ConstantIfs
De-inlining pointer[w] to *(pointer+w)   [152] *((const byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0
De-inlining pointer[w] to *(pointer+w)   [153] *((const byte*) colors#0 + (word) draw_block::z#1) ← (const byte) YELLOW#0
De-inlining pointer[w] to *(pointer+w)   [155] *((const byte*) screen#0 + (word~) draw_block::$5) ← (byte) 1
De-inlining pointer[w] to *(pointer+w)   [157] *((const byte*) colors#0 + (word~) draw_block::$6) ← (const byte) YELLOW#0
De-inlining pointer[w] to *(pointer+w)   [159] *((const byte*) screen#0 + (word~) draw_block::$7) ← (byte) 2
De-inlining pointer[w] to *(pointer+w)   [161] *((const byte*) colors#0 + (word~) draw_block::$8) ← (const byte) YELLOW#0
De-inlining pointer[w] to *(pointer+w)   [163] *((const byte*) screen#0 + (word~) draw_block::$9) ← (byte) 3
De-inlining pointer[w] to *(pointer+w)   [165] *((const byte*) colors#0 + (word~) draw_block::$10) ← (const byte) YELLOW#0
Successful SSA optimization Pass2DeInlineWordDerefIdx
Eliminating unused variable (void*) memset::return#2 and assignment [36] (void*) memset::return#2 ← (void*) memset::str#3
Eliminating unused variable (void*) memset::return#3 and assignment [39] (void*) memset::return#3 ← (void*) memset::str#3
Eliminating unused constant (const byte) draw_block::color#0
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Constant (const void*) memset::str#0 = (void*)screen#0
Constant (const void*) memset::str#1 = (void*)colors#0
Constant (const word) init::toD0181_$0#0 = (word)init::toD0181_screen#0
Constant (const word) init::toD0181_$4#0 = (word)init::toD0181_gfx#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [35] (word~) init::toD0181_$1#0 ← (const word) init::toD0181_$0#0 & (word) $3fff
Constant right-side identified [38] (byte~) init::toD0181_$5#0 ← > (const word) init::toD0181_$4#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) init::toD0181_$1#0 = init::toD0181_$0#0&$3fff
Constant (const byte) init::toD0181_$5#0 = >init::toD0181_$4#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [35] (word~) init::toD0181_$2#0 ← (const word) init::toD0181_$1#0 * (byte) 4
Constant right-side identified [37] (byte~) init::toD0181_$6#0 ← (const byte) init::toD0181_$5#0 / (byte) 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) init::toD0181_$2#0 = init::toD0181_$1#0*4
Constant (const byte) init::toD0181_$6#0 = init::toD0181_$5#0/4
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [35] (byte~) init::toD0181_$3#0 ← > (const word) init::toD0181_$2#0
Constant right-side identified [36] (byte~) init::toD0181_$7#0 ← (const byte) init::toD0181_$6#0 & (byte) $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) init::toD0181_$3#0 = >init::toD0181_$2#0
Constant (const byte) init::toD0181_$7#0 = init::toD0181_$6#0&$f
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [35] (byte) init::toD0181_return#0 ← (const byte) init::toD0181_$3#0 | (const byte) init::toD0181_$7#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) init::toD0181_return#0 = init::toD0181_$3#0|init::toD0181_$7#0
Successful SSA optimization Pass2ConstantIdentification
Inlining Noop Cast [2] (byte*~) memset::$2 ← (byte*)(void*) memset::str#3 keeping memset::str#3
Inlining Noop Cast [4] (byte*) memset::dst#0 ← (byte*)(void*) memset::str#3 keeping memset::str#3
Successful SSA optimization Pass2NopCastInlining
Inlining constant with var siblings (const byte) memset::c#0
Inlining constant with var siblings (const word) memset::num#0
Inlining constant with var siblings (const word) memset::num#1
Inlining constant with var siblings (const byte) memset::c#1
Inlining constant with var siblings (const void*) memset::str#0
Inlining constant with var siblings (const void*) memset::str#1
Inlining constant with var siblings (const word) mul8u::res#0
Inlining constant with var siblings (const byte) main::x#0
Inlining constant with var siblings (const byte) main::y#0
Constant inlined init::toD0181_gfx#0 = (const byte*) charset#0
Constant inlined memset::str#1 = (void*)(const byte*) colors#0
Constant inlined memset::str#0 = (void*)(const byte*) screen#0
Constant inlined init::toD0181_$0#0 = (word)(const byte*) screen#0
Constant inlined init::toD0181_$2#0 = (word)(const byte*) screen#0&(word) $3fff*(byte) 4
Constant inlined init::toD0181_$1#0 = (word)(const byte*) screen#0&(word) $3fff
Constant inlined init::toD0181_$4#0 = (word)(const byte*) charset#0
Constant inlined init::toD0181_$3#0 = >(word)(const byte*) screen#0&(word) $3fff*(byte) 4
Constant inlined init::toD0181_$6#0 = >(word)(const byte*) charset#0/(byte) 4
Constant inlined memset::num#1 = (word) $3e8
Constant inlined main::x#0 = (byte) 0
Constant inlined init::toD0181_$5#0 = >(word)(const byte*) charset#0
Constant inlined memset::num#0 = (word) $3e8
Constant inlined main::y#0 = (byte) 0
Constant inlined init::toD0181_$7#0 = >(word)(const byte*) charset#0/(byte) 4&(byte) $f
Constant inlined mul8u::res#0 = (byte) 0
Constant inlined memset::c#0 = (byte) 0
Constant inlined memset::c#1 = (const byte) BLACK#0
Constant inlined init::toD0181_screen#0 = (const byte*) screen#0
Successful SSA optimization Pass2ConstantInlining
Consolidated constant in assignment draw_block::$13
Consolidated constant in assignment draw_block::$14
Consolidated constant in assignment draw_block::$15
Consolidated constant in assignment draw_block::$16
Consolidated constant in assignment draw_block::$17
Consolidated constant in assignment draw_block::$18
Successful SSA optimization Pass2ConstantAdditionElimination
Alias (word) draw_block::z#1 = (word~) draw_block::$5 (word~) draw_block::$6 (word~) draw_block::$7 (word~) draw_block::$8 (word~) draw_block::$9 (word~) draw_block::$10 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (word) memset::num#2 (word) $3e8
Successful SSA optimization Pass2IdenticalPhiElimination
if() condition always false - eliminating [1] if((word) $3e8<=(byte) 0) goto memset::@1
Successful SSA optimization Pass2ConstantIfs
Added new block during phi lifting mul8u::@10(between mul8u::@2 and mul8u::@4)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @20
Adding NOP phi() at start of @24
Adding NOP phi() at start of @25
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of mul8u::@3
Adding NOP phi() at start of init
Adding NOP phi() at start of init::@2
Adding NOP phi() at start of init::@3
Adding NOP phi() at start of init::@4
Adding NOP phi() at start of init::toD0181
Adding NOP phi() at start of init::toD0181_@return
Adding NOP phi() at start of memset::@1
CALL GRAPH
Calls in [] to main:3 
Calls in [main] to init:7 draw_block:22 
Calls in [draw_block] to mul8u:29 
Calls in [init] to init_sprites:68 memset:70 memset:72 

Created 9 initial phi equivalence classes
Coalesced [16] main::x#8 ← main::x#1
Coalesced [24] main::y#5 ← main::y#1
Coalesced [51] mul8u::a#7 ← mul8u::a#1
Coalesced [59] mul8u::res#9 ← mul8u::res#1
Coalesced [63] mul8u::a#8 ← mul8u::a#0
Coalesced [64] mul8u::res#7 ← mul8u::res#6
Coalesced [65] mul8u::mb#6 ← mul8u::mb#1
Coalesced (already) [66] mul8u::res#8 ← mul8u::res#2
Coalesced [93] memset::dst#5 ← memset::dst#1
Coalesced down to 8 phi equivalence classes
Culled Empty Block (label) @20
Culled Empty Block (label) @25
Culled Empty Block (label) main::@15
Culled Empty Block (label) main::@2
Culled Empty Block (label) mul8u::@3
Culled Empty Block (label) mul8u::@10
Culled Empty Block (label) init::@4
Culled Empty Block (label) init::toD0181_@return
Culled Empty Block (label) memset::@1
Renumbering block @24 to @1
Renumbering block memset::@2 to memset::@1
Renumbering block memset::@4 to memset::@2
Renumbering block memset::@5 to memset::@3
Renumbering block mul8u::@4 to mul8u::@3
Renumbering block mul8u::@7 to mul8u::@4
Renumbering block main::@4 to main::@2
Renumbering block main::@5 to main::@3
Renumbering block main::@6 to main::@4
Renumbering block main::@13 to main::@5
Renumbering block main::@16 to main::@6
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of mul8u
Adding NOP phi() at start of init
Adding NOP phi() at start of init::@2
Adding NOP phi() at start of init::@3
Adding NOP phi() at start of init::toD0181

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  [5] call init 
  to:main::@1
main::@1: scope:[main]  from main main::@4
  [6] (byte) main::x#2 ← phi( main/(byte) 0 main::@4/(byte) main::x#1 )
  [7] if((byte) main::x#2<(byte) $10) goto main::@2
  to:main::@5
main::@5: scope:[main]  from main::@1 main::@5
  [8] phi()
  to:main::@5
main::@2: scope:[main]  from main::@1 main::@6
  [9] (byte) main::y#2 ← phi( main::@6/(byte) main::y#1 main::@1/(byte) 0 )
  [10] if((byte) main::y#2<(byte) 9) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@2
  [11] (byte) main::x#1 ← ++ (byte) main::x#2
  to:main::@1
main::@3: scope:[main]  from main::@2
  [12] (byte) main::z#0 ← (byte) main::x#2 + (byte) main::y#2
  [13] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0)
  [14] (byte) draw_block::tileno#0 ← (byte) main::tile#0
  [15] (byte) draw_block::x#0 ← (byte) main::x#2
  [16] (byte) draw_block::y#0 ← (byte) main::y#2
  [17] call draw_block 
  to:main::@6
main::@6: scope:[main]  from main::@3
  [18] (byte) main::y#1 ← ++ (byte) main::y#2
  to:main::@2

(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
draw_block: scope:[draw_block]  from main::@3
  [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2
  [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1
  [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1
  [22] (byte) mul8u::a#1 ← (byte) draw_block::y#1
  [23] call mul8u 
  [24] (word) mul8u::return#2 ← (word) mul8u::res#2
  to:draw_block::@1
draw_block::@1: scope:[draw_block]  from draw_block
  [25] (word) draw_block::z#0 ← (word) mul8u::return#2
  [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0
  [27] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1)
  [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1
  [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0
  [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1
  [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0
  [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1
  [33] *((byte*~) draw_block::$13) ← (byte) 1
  [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1
  [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0
  [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1
  [37] *((byte*~) draw_block::$15) ← (byte) 2
  [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1
  [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0
  [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1
  [41] *((byte*~) draw_block::$17) ← (byte) 3
  [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1
  [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0
  to:draw_block::@return
draw_block::@return: scope:[draw_block]  from draw_block::@1
  [44] return 
  to:@return

(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
mul8u: scope:[mul8u]  from draw_block
  [45] phi()
  to:mul8u::@1
mul8u::@1: scope:[mul8u]  from mul8u mul8u::@3
  [46] (word) mul8u::mb#2 ← phi( mul8u/(const byte) mul8u::b#0 mul8u::@3/(word) mul8u::mb#1 )
  [46] (word) mul8u::res#2 ← phi( mul8u/(byte) 0 mul8u::@3/(word) mul8u::res#6 )
  [46] (byte) mul8u::a#2 ← phi( mul8u/(byte) mul8u::a#1 mul8u::@3/(byte) mul8u::a#0 )
  [47] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2
  to:mul8u::@return
mul8u::@return: scope:[mul8u]  from mul8u::@1
  [48] return 
  to:@return
mul8u::@2: scope:[mul8u]  from mul8u::@1
  [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1
  [50] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@3
  to:mul8u::@4
mul8u::@4: scope:[mul8u]  from mul8u::@2
  [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2
  to:mul8u::@3
mul8u::@3: scope:[mul8u]  from mul8u::@2 mul8u::@4
  [52] (word) mul8u::res#6 ← phi( mul8u::@2/(word) mul8u::res#2 mul8u::@4/(word) mul8u::res#1 )
  [53] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte) 1
  [54] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte) 1
  to:mul8u::@1

(void()) init()
init: scope:[init]  from main
  [55] phi()
  [56] call init_sprites 
  to:init::@2
init::@2: scope:[init]  from init
  [57] phi()
  [58] call memset 
  to:init::@3
init::@3: scope:[init]  from init::@2
  [59] phi()
  [60] call memset 
  to:init::toD0181
init::toD0181: scope:[init]  from init::@3
  [61] phi()
  to:init::@1
init::@1: scope:[init]  from init::toD0181
  [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0
  asm { lda#$5b sta$d011  }
  [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0
  [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0
  [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0
  [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0
  [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0
  to:init::@return
init::@return: scope:[init]  from init::@1
  [69] return 
  to:@return

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from init::@2 init::@3
  [70] (byte) memset::c#4 ← phi( init::@2/(byte) 0 init::@3/(const byte) BLACK#0 )
  [70] (void*) memset::str#3 ← phi( init::@2/(void*)(const byte*) screen#0 init::@3/(void*)(const byte*) colors#0 )
  to:memset::@1
memset::@1: scope:[memset]  from memset
  [71] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) $3e8
  [72] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3
  to:memset::@2
memset::@2: scope:[memset]  from memset::@1 memset::@3
  [73] (byte*) memset::dst#2 ← phi( memset::@1/(byte*~) memset::dst#4 memset::@3/(byte*) memset::dst#1 )
  [74] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3
  to:memset::@return
memset::@return: scope:[memset]  from memset::@2
  [75] return 
  to:@return
memset::@3: scope:[memset]  from memset::@2
  [76] *((byte*) memset::dst#2) ← (byte) memset::c#4
  [77] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  to:memset::@2

(void()) init_sprites()
init_sprites: scope:[init_sprites]  from init
  [78] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1
  [79] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0
  [80] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0
  [81] *((const byte*) SPRITES_XMSB#0) ← (byte) 0
  [82] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0
  [83] *((const byte*) SPRITES_MC#0) ← (byte) 0
  to:init_sprites::@return
init_sprites::@return: scope:[init_sprites]  from init_sprites
  [84] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte*) BGCOL1
(byte*) BGCOL2
(byte*) BGCOL3
(byte*) BGCOL4
(byte) BLACK
(byte) BLUE
(byte*) BORDERCOL
(byte*) D018
(byte) GREEN
(byte) RED
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_MC
(byte*) SPRITES_XMSB
(byte) WHITE
(byte) YELLOW
(byte*) charset
(byte*) colors
(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
(byte*~) draw_block::$11 4.0
(byte*~) draw_block::$12 4.0
(byte*~) draw_block::$13 4.0
(byte*~) draw_block::$14 4.0
(byte*~) draw_block::$15 4.0
(byte*~) draw_block::$16 4.0
(byte*~) draw_block::$17 4.0
(byte*~) draw_block::$18 4.0
(byte) draw_block::color
(byte) draw_block::drawtile
(byte) draw_block::drawtile#0 2.0
(byte) draw_block::tileno
(byte) draw_block::tileno#0 34.33333333333333
(byte) draw_block::tileno#1 0.5
(byte) draw_block::x
(byte) draw_block::x#0 34.33333333333333
(word) draw_block::x1
(word) draw_block::x1#0 0.6666666666666666
(byte) draw_block::y
(byte) draw_block::y#0 34.33333333333333
(byte) draw_block::y#1 4.0
(word) draw_block::z
(word) draw_block::z#0 4.0
(word) draw_block::z#1 1.125
(void()) init()
(word~) init::toD0181_$0
(number~) init::toD0181_$1
(number~) init::toD0181_$2
(number~) init::toD0181_$3
(word~) init::toD0181_$4
(byte~) init::toD0181_$5
(number~) init::toD0181_$6
(number~) init::toD0181_$7
(number~) init::toD0181_$8
(byte*) init::toD0181_gfx
(byte) init::toD0181_return
(byte*) init::toD0181_screen
(void()) init_sprites()
(byte*) level_address
(void()) main()
(byte) main::tile
(byte) main::tile#0 202.0
(byte) main::x
(byte) main::x#1 22.0
(byte) main::x#2 21.363636363636363
(byte) main::y
(byte) main::y#1 202.0
(byte) main::y#2 63.125
(byte) main::z
(byte) main::z#0 202.0
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(byte) memset::c
(byte) memset::c#4 1.5714285714285714
(byte*) memset::dst
(byte*) memset::dst#1 22.0
(byte*) memset::dst#2 15.333333333333332
(byte*~) memset::dst#4 4.0
(byte*) memset::end
(byte*) memset::end#0 2.1666666666666665
(word) memset::num
(void*) memset::return
(void*) memset::str
(void*) memset::str#3
(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
(byte~) mul8u::$1 2002.0
(byte) mul8u::a
(byte) mul8u::a#0 1001.0
(byte) mul8u::a#1 2.0
(byte) mul8u::a#2 667.6666666666667
(byte) mul8u::b
(word) mul8u::mb
(word) mul8u::mb#1 2002.0
(word) mul8u::mb#2 429.0
(word) mul8u::res
(word) mul8u::res#1 2002.0
(word) mul8u::res#2 500.83333333333337
(word) mul8u::res#6 1001.0
(word) mul8u::return
(word) mul8u::return#2 4.0
(byte*) screen
(byte*) tileset

Initial phi equivalence classes
[ main::x#2 main::x#1 ]
[ main::y#2 main::y#1 ]
[ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
[ mul8u::res#2 mul8u::res#6 mul8u::res#1 ]
[ mul8u::mb#2 mul8u::mb#1 ]
[ memset::str#3 ]
[ memset::c#4 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
Added variable main::z#0 to zero page equivalence class [ main::z#0 ]
Added variable main::tile#0 to zero page equivalence class [ main::tile#0 ]
Added variable draw_block::tileno#0 to zero page equivalence class [ draw_block::tileno#0 ]
Added variable draw_block::x#0 to zero page equivalence class [ draw_block::x#0 ]
Added variable draw_block::y#0 to zero page equivalence class [ draw_block::y#0 ]
Added variable draw_block::tileno#1 to zero page equivalence class [ draw_block::tileno#1 ]
Added variable draw_block::x1#0 to zero page equivalence class [ draw_block::x1#0 ]
Added variable draw_block::y#1 to zero page equivalence class [ draw_block::y#1 ]
Added variable mul8u::return#2 to zero page equivalence class [ mul8u::return#2 ]
Added variable draw_block::z#0 to zero page equivalence class [ draw_block::z#0 ]
Added variable draw_block::z#1 to zero page equivalence class [ draw_block::z#1 ]
Added variable draw_block::drawtile#0 to zero page equivalence class [ draw_block::drawtile#0 ]
Added variable draw_block::$11 to zero page equivalence class [ draw_block::$11 ]
Added variable draw_block::$12 to zero page equivalence class [ draw_block::$12 ]
Added variable draw_block::$13 to zero page equivalence class [ draw_block::$13 ]
Added variable draw_block::$14 to zero page equivalence class [ draw_block::$14 ]
Added variable draw_block::$15 to zero page equivalence class [ draw_block::$15 ]
Added variable draw_block::$16 to zero page equivalence class [ draw_block::$16 ]
Added variable draw_block::$17 to zero page equivalence class [ draw_block::$17 ]
Added variable draw_block::$18 to zero page equivalence class [ draw_block::$18 ]
Added variable mul8u::$1 to zero page equivalence class [ mul8u::$1 ]
Added variable memset::end#0 to zero page equivalence class [ memset::end#0 ]
Complete equivalence classes
[ main::x#2 main::x#1 ]
[ main::y#2 main::y#1 ]
[ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
[ mul8u::res#2 mul8u::res#6 mul8u::res#1 ]
[ mul8u::mb#2 mul8u::mb#1 ]
[ memset::str#3 ]
[ memset::c#4 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
[ main::z#0 ]
[ main::tile#0 ]
[ draw_block::tileno#0 ]
[ draw_block::x#0 ]
[ draw_block::y#0 ]
[ draw_block::tileno#1 ]
[ draw_block::x1#0 ]
[ draw_block::y#1 ]
[ mul8u::return#2 ]
[ draw_block::z#0 ]
[ draw_block::z#1 ]
[ draw_block::drawtile#0 ]
[ draw_block::$11 ]
[ draw_block::$12 ]
[ draw_block::$13 ]
[ draw_block::$14 ]
[ draw_block::$15 ]
[ draw_block::$16 ]
[ draw_block::$17 ]
[ draw_block::$18 ]
[ mul8u::$1 ]
[ memset::end#0 ]
Allocated zp ZP_BYTE:2 [ main::x#2 main::x#1 ]
Allocated zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Allocated zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
Allocated zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ]
Allocated zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ]
Allocated zp ZP_WORD:9 [ memset::str#3 ]
Allocated zp ZP_BYTE:11 [ memset::c#4 ]
Allocated zp ZP_WORD:12 [ memset::dst#2 memset::dst#4 memset::dst#1 ]
Allocated zp ZP_BYTE:14 [ main::z#0 ]
Allocated zp ZP_BYTE:15 [ main::tile#0 ]
Allocated zp ZP_BYTE:16 [ draw_block::tileno#0 ]
Allocated zp ZP_BYTE:17 [ draw_block::x#0 ]
Allocated zp ZP_BYTE:18 [ draw_block::y#0 ]
Allocated zp ZP_BYTE:19 [ draw_block::tileno#1 ]
Allocated zp ZP_WORD:20 [ draw_block::x1#0 ]
Allocated zp ZP_BYTE:22 [ draw_block::y#1 ]
Allocated zp ZP_WORD:23 [ mul8u::return#2 ]
Allocated zp ZP_WORD:25 [ draw_block::z#0 ]
Allocated zp ZP_WORD:27 [ draw_block::z#1 ]
Allocated zp ZP_BYTE:29 [ draw_block::drawtile#0 ]
Allocated zp ZP_WORD:30 [ draw_block::$11 ]
Allocated zp ZP_WORD:32 [ draw_block::$12 ]
Allocated zp ZP_WORD:34 [ draw_block::$13 ]
Allocated zp ZP_WORD:36 [ draw_block::$14 ]
Allocated zp ZP_WORD:38 [ draw_block::$15 ]
Allocated zp ZP_WORD:40 [ draw_block::$16 ]
Allocated zp ZP_WORD:42 [ draw_block::$17 ]
Allocated zp ZP_WORD:44 [ draw_block::$18 ]
Allocated zp ZP_BYTE:46 [ mul8u::$1 ]
Allocated zp ZP_WORD:47 [ memset::end#0 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Illustrates a problem with a missing fragment - pbuc1_derefidx_vwuz1=vbuz2
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XMSB = $d010
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label BORDERCOL = $d020
  .label BGCOL1 = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label BGCOL4 = $d024
  .label SPRITES_COLS = $d027
  .label D018 = $d018
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  .const BLUE = 6
  .const YELLOW = 7
  .label screen = $400
  .label charset = $2000
  .label tileset = $2800
  .label colors = $d800
  .label level_address = $3000
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label z = $e
    .label tile = $f
    .label y = 3
    .label x = 2
    // [5] call init 
    // [55] phi from main to init [phi:main->init]
  init_from_main:
    jsr init
    // [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    // [6] phi (byte) main::x#2 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    jmp b1
    // main::@1
  b1:
    // [7] if((byte) main::x#2<(byte) $10) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z x
    cmp #$10
    bcc b2_from_b1
    // [8] phi from main::@1 main::@5 to main::@5 [phi:main::@1/main::@5->main::@5]
  b5_from_b1:
  b5_from_b5:
    jmp b5
    // main::@5
  b5:
    jmp b5_from_b5
    // [9] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    // [9] phi (byte) main::y#2 = (byte) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp b2
    // main::@2
  b2:
    // [10] if((byte) main::y#2<(byte) 9) goto main::@3 -- vbuz1_lt_vbuc1_then_la1 
    lda.z y
    cmp #9
    bcc b3
    jmp b4
    // main::@4
  b4:
    // [11] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [6] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  b1_from_b4:
    // [6] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@4->main::@1#0] -- register_copy 
    jmp b1
    // main::@3
  b3:
    // [12] (byte) main::z#0 ← (byte) main::x#2 + (byte) main::y#2 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z x
    clc
    adc.z y
    sta.z z
    // [13] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z z
    lda level_address,y
    sta.z tile
    // [14] (byte) draw_block::tileno#0 ← (byte) main::tile#0 -- vbuz1=vbuz2 
    lda.z tile
    sta.z draw_block.tileno
    // [15] (byte) draw_block::x#0 ← (byte) main::x#2 -- vbuz1=vbuz2 
    lda.z x
    sta.z draw_block.x
    // [16] (byte) draw_block::y#0 ← (byte) main::y#2 -- vbuz1=vbuz2 
    lda.z y
    sta.z draw_block.y
    // [17] call draw_block 
    jsr draw_block
    jmp b6
    // main::@6
  b6:
    // [18] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [9] phi from main::@6 to main::@2 [phi:main::@6->main::@2]
  b2_from_b6:
    // [9] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@6->main::@2#0] -- register_copy 
    jmp b2
}
  // draw_block
// draw_block(byte zeropage($10) tileno, byte zeropage($11) x, byte zeropage($12) y)
draw_block: {
    .label tileno = $10
    .label x = $11
    .label y = $12
    .label tileno_1 = $13
    .label x1 = $14
    .label y_1 = $16
    .label z = $19
    .label z_1 = $1b
    .label drawtile = $1d
    .label _11 = $1e
    .label _12 = $20
    .label _13 = $22
    .label _14 = $24
    .label _15 = $26
    .label _16 = $28
    .label _17 = $2a
    .label _18 = $2c
    // [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 -- vbuz1=vbuz2_rol_2 
    lda.z tileno
    asl
    asl
    sta.z tileno_1
    // [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 -- vwuz1=vbuz2_rol_1 
    lda.z x
    asl
    sta.z x1
    lda #0
    rol
    sta.z x1+1
    // [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z y
    asl
    sta.z y_1
    // [22] (byte) mul8u::a#1 ← (byte) draw_block::y#1 -- vbuz1=vbuz2 
    lda.z y_1
    sta.z mul8u.a
    // [23] call mul8u 
    // [45] phi from draw_block to mul8u [phi:draw_block->mul8u]
  mul8u_from_draw_block:
    jsr mul8u
    // [24] (word) mul8u::return#2 ← (word) mul8u::res#2 -- vwuz1=vwuz2 
    lda.z mul8u.res
    sta.z mul8u.return
    lda.z mul8u.res+1
    sta.z mul8u.return+1
    jmp b1
    // draw_block::@1
  b1:
    // [25] (word) draw_block::z#0 ← (word) mul8u::return#2 -- vwuz1=vwuz2 
    lda.z mul8u.return
    sta.z z
    lda.z mul8u.return+1
    sta.z z+1
    // [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 -- vwuz1=vwuz2_plus_vwuz3 
    lda.z z
    clc
    adc.z x1
    sta.z z_1
    lda.z z+1
    adc.z x1+1
    sta.z z_1+1
    // [27] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z tileno_1
    lda tileset,y
    sta.z drawtile
    // [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen
    sta.z _11
    lda.z z_1+1
    adc #>screen
    sta.z _11+1
    // [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 -- _deref_pbuz1=vbuz2 
    lda.z drawtile
    ldy #0
    sta (_11),y
    // [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors
    sta.z _12
    lda.z z_1+1
    adc #>colors
    sta.z _12+1
    // [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_12),y
    // [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen+1
    sta.z _13
    lda.z z_1+1
    adc #>screen+1
    sta.z _13+1
    // [33] *((byte*~) draw_block::$13) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (_13),y
    // [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors+1
    sta.z _14
    lda.z z_1+1
    adc #>colors+1
    sta.z _14+1
    // [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_14),y
    // [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen+$28
    sta.z _15
    lda.z z_1+1
    adc #>screen+$28
    sta.z _15+1
    // [37] *((byte*~) draw_block::$15) ← (byte) 2 -- _deref_pbuz1=vbuc1 
    lda #2
    ldy #0
    sta (_15),y
    // [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors+$28
    sta.z _16
    lda.z z_1+1
    adc #>colors+$28
    sta.z _16+1
    // [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_16),y
    // [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen+$29
    sta.z _17
    lda.z z_1+1
    adc #>screen+$29
    sta.z _17+1
    // [41] *((byte*~) draw_block::$17) ← (byte) 3 -- _deref_pbuz1=vbuc1 
    lda #3
    ldy #0
    sta (_17),y
    // [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors+$29
    sta.z _18
    lda.z z_1+1
    adc #>colors+$29
    sta.z _18+1
    // [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_18),y
    jmp breturn
    // draw_block::@return
  breturn:
    // [44] return 
    rts
}
  // mul8u
// Perform binary multiplication of two unsigned 8-bit bytes into a 16-bit unsigned word
// mul8u(byte zeropage(4) a)
mul8u: {
    .const b = $28
    .label _1 = $2e
    .label a = 4
    .label mb = 7
    .label res = 5
    .label return = $17
    // [46] phi from mul8u to mul8u::@1 [phi:mul8u->mul8u::@1]
  b1_from_mul8u:
    // [46] phi (word) mul8u::mb#2 = (const byte) mul8u::b#0 [phi:mul8u->mul8u::@1#0] -- vwuz1=vbuc1 
    lda #<b
    sta.z mb
    lda #>b
    sta.z mb+1
    // [46] phi (word) mul8u::res#2 = (byte) 0 [phi:mul8u->mul8u::@1#1] -- vwuz1=vbuc1 
    lda #<0
    sta.z res
    lda #>0
    sta.z res+1
    // [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#1 [phi:mul8u->mul8u::@1#2] -- register_copy 
    jmp b1
    // mul8u::@1
  b1:
    // [47] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2 -- vbuz1_neq_0_then_la1 
    lda.z a
    cmp #0
    bne b2
    jmp breturn
    // mul8u::@return
  breturn:
    // [48] return 
    rts
    // mul8u::@2
  b2:
    // [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and.z a
    sta.z _1
    // [50] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@3 -- vbuz1_eq_0_then_la1 
    lda.z _1
    cmp #0
    beq b3_from_b2
    jmp b4
    // mul8u::@4
  b4:
    // [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 -- vwuz1=vwuz1_plus_vwuz2 
    lda.z res
    clc
    adc.z mb
    sta.z res
    lda.z res+1
    adc.z mb+1
    sta.z res+1
    // [52] phi from mul8u::@2 mul8u::@4 to mul8u::@3 [phi:mul8u::@2/mul8u::@4->mul8u::@3]
  b3_from_b2:
  b3_from_b4:
    // [52] phi (word) mul8u::res#6 = (word) mul8u::res#2 [phi:mul8u::@2/mul8u::@4->mul8u::@3#0] -- register_copy 
    jmp b3
    // mul8u::@3
  b3:
    // [53] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr.z a
    // [54] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z mb
    rol.z mb+1
    // [46] phi from mul8u::@3 to mul8u::@1 [phi:mul8u::@3->mul8u::@1]
  b1_from_b3:
    // [46] phi (word) mul8u::mb#2 = (word) mul8u::mb#1 [phi:mul8u::@3->mul8u::@1#0] -- register_copy 
    // [46] phi (word) mul8u::res#2 = (word) mul8u::res#6 [phi:mul8u::@3->mul8u::@1#1] -- register_copy 
    // [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#0 [phi:mul8u::@3->mul8u::@1#2] -- register_copy 
    jmp b1
}
  // init
init: {
    .const toD0181_return = (>(screen&$3fff)*4)|(>charset)/4&$f
    // [56] call init_sprites 
    jsr init_sprites
    // [57] phi from init to init::@2 [phi:init->init::@2]
  b2_from_init:
    jmp b2
    // init::@2
  b2:
    // [58] call memset 
    // [70] phi from init::@2 to memset [phi:init::@2->memset]
  memset_from_b2:
    // [70] phi (byte) memset::c#4 = (byte) 0 [phi:init::@2->memset#0] -- vbuz1=vbuc1 
    lda #0
    sta.z memset.c
    // [70] phi (void*) memset::str#3 = (void*)(const byte*) screen#0 [phi:init::@2->memset#1] -- pvoz1=pvoc1 
    lda #<screen
    sta.z memset.str
    lda #>screen
    sta.z memset.str+1
    jsr memset
    // [59] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
    jmp b3
    // init::@3
  b3:
    // [60] call memset 
    // [70] phi from init::@3 to memset [phi:init::@3->memset]
  memset_from_b3:
    // [70] phi (byte) memset::c#4 = (const byte) BLACK#0 [phi:init::@3->memset#0] -- vbuz1=vbuc1 
    lda #BLACK
    sta.z memset.c
    // [70] phi (void*) memset::str#3 = (void*)(const byte*) colors#0 [phi:init::@3->memset#1] -- pvoz1=pvoc1 
    lda #<colors
    sta.z memset.str
    lda #>colors
    sta.z memset.str+1
    jsr memset
    // [61] phi from init::@3 to init::toD0181 [phi:init::@3->init::toD0181]
  toD0181_from_b3:
    jmp toD0181
    // init::toD0181
  toD0181:
    jmp b1
    // init::@1
  b1:
    // [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // asm { lda#$5b sta$d011  }
    lda #$5b
    sta $d011
    // [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BGCOL1
    // [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BGCOL2
    // [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL3
    // [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL4
    jmp breturn
    // init::@return
  breturn:
    // [69] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zeropage(9) str, byte zeropage($b) c)
memset: {
    .label end = $2f
    .label dst = $c
    .label str = 9
    .label c = $b
    jmp b1
    // memset::@1
  b1:
    // [71] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [72] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3 -- pbuz1=pbuz2 
    lda.z str
    sta.z dst
    lda.z str+1
    sta.z dst+1
    // [73] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  b2_from_b1:
  b2_from_b3:
    // [73] phi (byte*) memset::dst#2 = (byte*~) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp b2
    // memset::@2
  b2:
    // [74] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne b3
    lda.z dst
    cmp.z end
    bne b3
    jmp breturn
    // memset::@return
  breturn:
    // [75] return 
    rts
    // memset::@3
  b3:
    // [76] *((byte*) memset::dst#2) ← (byte) memset::c#4 -- _deref_pbuz1=vbuz2 
    lda.z c
    ldy #0
    sta (dst),y
    // [77] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp b2_from_b3
}
  // init_sprites
init_sprites: {
    // [78] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta SPRITES_ENABLE
    // [79] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // one sprite enabled
    lda #0
    sta SPRITES_EXPAND_X
    // [80] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_EXPAND_Y
    // [81] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_XMSB
    // [82] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta SPRITES_COLS
    // [83] *((const byte*) SPRITES_MC#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    jmp breturn
    // init_sprites::@return
  breturn:
    // [84] return 
    rts
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [12] (byte) main::z#0 ← (byte) main::x#2 + (byte) main::y#2 [ main::x#2 main::y#2 main::z#0 ] ( main:2 [ main::x#2 main::y#2 main::z#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::x#2 main::x#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Statement [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 [ draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:17 [ draw_block::x#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:18 [ draw_block::y#0 ]
Statement [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 [ draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:19 [ draw_block::tileno#1 ]
Statement [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 [ draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ) always clobbers reg byte a 
Statement [24] (word) mul8u::return#2 ← (word) mul8u::res#2 [ draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ) always clobbers reg byte a 
Statement [25] (word) draw_block::z#0 ← (word) mul8u::return#2 [ draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ) always clobbers reg byte a 
Statement [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 [ draw_block::tileno#1 draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::drawtile#0 draw_block::$11 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::drawtile#0 draw_block::$11 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:29 [ draw_block::drawtile#0 ]
Statement [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:2 [ main::x#2 main::x#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Statement [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$12 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$12 ] ) always clobbers reg byte a 
Statement [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$13 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$13 ] ) always clobbers reg byte a 
Statement [33] *((byte*~) draw_block::$13) ← (byte) 1 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$14 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$14 ] ) always clobbers reg byte a 
Statement [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$15 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$15 ] ) always clobbers reg byte a 
Statement [37] *((byte*~) draw_block::$15) ← (byte) 2 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$16 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$16 ] ) always clobbers reg byte a 
Statement [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$17 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$17 ] ) always clobbers reg byte a 
Statement [41] *((byte*~) draw_block::$17) ← (byte) 3 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 [ draw_block::$18 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::$18 ] ) always clobbers reg byte a 
Statement [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 [ ] ( main:2::draw_block:17 [ main::x#2 main::y#2 ] ) always clobbers reg byte a reg byte y 
Statement [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 [ mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ( main:2::draw_block:17::mul8u:23 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
Statement [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement asm { lda#$5b sta$d011  } always clobbers reg byte a 
Statement [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [71] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) $3e8 [ memset::str#3 memset::c#4 memset::end#0 ] ( main:2::init:5::memset:58 [ memset::str#3 memset::c#4 memset::end#0 ] main:2::init:5::memset:60 [ memset::str#3 memset::c#4 memset::end#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:11 [ memset::c#4 ]
Statement [72] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3 [ memset::c#4 memset::end#0 memset::dst#4 ] ( main:2::init:5::memset:58 [ memset::c#4 memset::end#0 memset::dst#4 ] main:2::init:5::memset:60 [ memset::c#4 memset::end#0 memset::dst#4 ] ) always clobbers reg byte a 
Statement [74] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 [ memset::c#4 memset::end#0 memset::dst#2 ] ( main:2::init:5::memset:58 [ memset::c#4 memset::end#0 memset::dst#2 ] main:2::init:5::memset:60 [ memset::c#4 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a 
Statement [76] *((byte*) memset::dst#2) ← (byte) memset::c#4 [ memset::c#4 memset::end#0 memset::dst#2 ] ( main:2::init:5::memset:58 [ memset::c#4 memset::end#0 memset::dst#2 ] main:2::init:5::memset:60 [ memset::c#4 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:11 [ memset::c#4 ]
Statement [78] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [79] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [80] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [81] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [82] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [83] *((const byte*) SPRITES_MC#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [12] (byte) main::z#0 ← (byte) main::x#2 + (byte) main::y#2 [ main::x#2 main::y#2 main::z#0 ] ( main:2 [ main::x#2 main::y#2 main::z#0 ] ) always clobbers reg byte a 
Statement [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 [ draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ) always clobbers reg byte a 
Statement [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 [ draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ) always clobbers reg byte a 
Statement [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 [ draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ) always clobbers reg byte a 
Statement [24] (word) mul8u::return#2 ← (word) mul8u::res#2 [ draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ) always clobbers reg byte a 
Statement [25] (word) draw_block::z#0 ← (word) mul8u::return#2 [ draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ) always clobbers reg byte a 
Statement [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 [ draw_block::tileno#1 draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::drawtile#0 draw_block::$11 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::drawtile#0 draw_block::$11 ] ) always clobbers reg byte a 
Statement [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$12 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$12 ] ) always clobbers reg byte a 
Statement [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$13 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$13 ] ) always clobbers reg byte a 
Statement [33] *((byte*~) draw_block::$13) ← (byte) 1 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$14 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$14 ] ) always clobbers reg byte a 
Statement [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$15 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$15 ] ) always clobbers reg byte a 
Statement [37] *((byte*~) draw_block::$15) ← (byte) 2 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$16 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$16 ] ) always clobbers reg byte a 
Statement [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$17 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 draw_block::$17 ] ) always clobbers reg byte a 
Statement [41] *((byte*~) draw_block::$17) ← (byte) 3 [ draw_block::z#1 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 [ draw_block::$18 ] ( main:2::draw_block:17 [ main::x#2 main::y#2 draw_block::$18 ] ) always clobbers reg byte a 
Statement [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 [ ] ( main:2::draw_block:17 [ main::x#2 main::y#2 ] ) always clobbers reg byte a reg byte y 
Statement [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1 [ mul8u::res#2 mul8u::a#2 mul8u::mb#2 mul8u::$1 ] ( main:2::draw_block:17::mul8u:23 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::res#2 mul8u::a#2 mul8u::mb#2 mul8u::$1 ] ) always clobbers reg byte a 
Statement [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 [ mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ( main:2::draw_block:17::mul8u:23 [ main::x#2 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ) always clobbers reg byte a 
Statement [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement asm { lda#$5b sta$d011  } always clobbers reg byte a 
Statement [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [71] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) $3e8 [ memset::str#3 memset::c#4 memset::end#0 ] ( main:2::init:5::memset:58 [ memset::str#3 memset::c#4 memset::end#0 ] main:2::init:5::memset:60 [ memset::str#3 memset::c#4 memset::end#0 ] ) always clobbers reg byte a 
Statement [72] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3 [ memset::c#4 memset::end#0 memset::dst#4 ] ( main:2::init:5::memset:58 [ memset::c#4 memset::end#0 memset::dst#4 ] main:2::init:5::memset:60 [ memset::c#4 memset::end#0 memset::dst#4 ] ) always clobbers reg byte a 
Statement [74] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 [ memset::c#4 memset::end#0 memset::dst#2 ] ( main:2::init:5::memset:58 [ memset::c#4 memset::end#0 memset::dst#2 ] main:2::init:5::memset:60 [ memset::c#4 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a 
Statement [76] *((byte*) memset::dst#2) ← (byte) memset::c#4 [ memset::c#4 memset::end#0 memset::dst#2 ] ( main:2::init:5::memset:58 [ memset::c#4 memset::end#0 memset::dst#2 ] main:2::init:5::memset:60 [ memset::c#4 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a reg byte y 
Statement [78] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [79] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [80] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [81] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [82] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [83] *((const byte*) SPRITES_MC#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::x#2 main::x#1 ] : zp ZP_BYTE:2 , reg byte x , 
Potential registers zp ZP_BYTE:3 [ main::y#2 main::y#1 ] : zp ZP_BYTE:3 , reg byte x , 
Potential registers zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] : zp ZP_WORD:5 , 
Potential registers zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] : zp ZP_WORD:7 , 
Potential registers zp ZP_WORD:9 [ memset::str#3 ] : zp ZP_WORD:9 , 
Potential registers zp ZP_BYTE:11 [ memset::c#4 ] : zp ZP_BYTE:11 , reg byte x , 
Potential registers zp ZP_WORD:12 [ memset::dst#2 memset::dst#4 memset::dst#1 ] : zp ZP_WORD:12 , 
Potential registers zp ZP_BYTE:14 [ main::z#0 ] : zp ZP_BYTE:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:15 [ main::tile#0 ] : zp ZP_BYTE:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:16 [ draw_block::tileno#0 ] : zp ZP_BYTE:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:17 [ draw_block::x#0 ] : zp ZP_BYTE:17 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:18 [ draw_block::y#0 ] : zp ZP_BYTE:18 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:19 [ draw_block::tileno#1 ] : zp ZP_BYTE:19 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:20 [ draw_block::x1#0 ] : zp ZP_WORD:20 , 
Potential registers zp ZP_BYTE:22 [ draw_block::y#1 ] : zp ZP_BYTE:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:23 [ mul8u::return#2 ] : zp ZP_WORD:23 , 
Potential registers zp ZP_WORD:25 [ draw_block::z#0 ] : zp ZP_WORD:25 , 
Potential registers zp ZP_WORD:27 [ draw_block::z#1 ] : zp ZP_WORD:27 , 
Potential registers zp ZP_BYTE:29 [ draw_block::drawtile#0 ] : zp ZP_BYTE:29 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:30 [ draw_block::$11 ] : zp ZP_WORD:30 , 
Potential registers zp ZP_WORD:32 [ draw_block::$12 ] : zp ZP_WORD:32 , 
Potential registers zp ZP_WORD:34 [ draw_block::$13 ] : zp ZP_WORD:34 , 
Potential registers zp ZP_WORD:36 [ draw_block::$14 ] : zp ZP_WORD:36 , 
Potential registers zp ZP_WORD:38 [ draw_block::$15 ] : zp ZP_WORD:38 , 
Potential registers zp ZP_WORD:40 [ draw_block::$16 ] : zp ZP_WORD:40 , 
Potential registers zp ZP_WORD:42 [ draw_block::$17 ] : zp ZP_WORD:42 , 
Potential registers zp ZP_WORD:44 [ draw_block::$18 ] : zp ZP_WORD:44 , 
Potential registers zp ZP_BYTE:46 [ mul8u::$1 ] : zp ZP_BYTE:46 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:47 [ memset::end#0 ] : zp ZP_WORD:47 , 

REGISTER UPLIFT SCOPES
Uplift Scope [mul8u] 3,503.83: zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] 2,431: zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] 2,002: zp ZP_BYTE:46 [ mul8u::$1 ] 1,670.67: zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ] 4: zp ZP_WORD:23 [ mul8u::return#2 ] 
Uplift Scope [main] 265.12: zp ZP_BYTE:3 [ main::y#2 main::y#1 ] 202: zp ZP_BYTE:14 [ main::z#0 ] 202: zp ZP_BYTE:15 [ main::tile#0 ] 43.36: zp ZP_BYTE:2 [ main::x#2 main::x#1 ] 
Uplift Scope [draw_block] 34.33: zp ZP_BYTE:16 [ draw_block::tileno#0 ] 34.33: zp ZP_BYTE:17 [ draw_block::x#0 ] 34.33: zp ZP_BYTE:18 [ draw_block::y#0 ] 4: zp ZP_BYTE:22 [ draw_block::y#1 ] 4: zp ZP_WORD:25 [ draw_block::z#0 ] 4: zp ZP_WORD:30 [ draw_block::$11 ] 4: zp ZP_WORD:32 [ draw_block::$12 ] 4: zp ZP_WORD:34 [ draw_block::$13 ] 4: zp ZP_WORD:36 [ draw_block::$14 ] 4: zp ZP_WORD:38 [ draw_block::$15 ] 4: zp ZP_WORD:40 [ draw_block::$16 ] 4: zp ZP_WORD:42 [ draw_block::$17 ] 4: zp ZP_WORD:44 [ draw_block::$18 ] 2: zp ZP_BYTE:29 [ draw_block::drawtile#0 ] 1.12: zp ZP_WORD:27 [ draw_block::z#1 ] 0.67: zp ZP_WORD:20 [ draw_block::x1#0 ] 0.5: zp ZP_BYTE:19 [ draw_block::tileno#1 ] 
Uplift Scope [memset] 41.33: zp ZP_WORD:12 [ memset::dst#2 memset::dst#4 memset::dst#1 ] 2.17: zp ZP_WORD:47 [ memset::end#0 ] 1.57: zp ZP_BYTE:11 [ memset::c#4 ] 0: zp ZP_WORD:9 [ memset::str#3 ] 
Uplift Scope [init] 
Uplift Scope [init_sprites] 
Uplift Scope [] 

Uplifting [mul8u] best 92896 combination zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] reg byte a [ mul8u::$1 ] reg byte x [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ] zp ZP_WORD:23 [ mul8u::return#2 ] 
Uplifting [main] best 91896 combination zp ZP_BYTE:3 [ main::y#2 main::y#1 ] reg byte a [ main::z#0 ] reg byte a [ main::tile#0 ] zp ZP_BYTE:2 [ main::x#2 main::x#1 ] 
Uplifting [draw_block] best 90987 combination reg byte a [ draw_block::tileno#0 ] reg byte y [ draw_block::x#0 ] reg byte x [ draw_block::y#0 ] reg byte a [ draw_block::y#1 ] zp ZP_WORD:25 [ draw_block::z#0 ] zp ZP_WORD:30 [ draw_block::$11 ] zp ZP_WORD:32 [ draw_block::$12 ] zp ZP_WORD:34 [ draw_block::$13 ] zp ZP_WORD:36 [ draw_block::$14 ] zp ZP_WORD:38 [ draw_block::$15 ] zp ZP_WORD:40 [ draw_block::$16 ] zp ZP_WORD:42 [ draw_block::$17 ] zp ZP_WORD:44 [ draw_block::$18 ] zp ZP_BYTE:29 [ draw_block::drawtile#0 ] zp ZP_WORD:27 [ draw_block::z#1 ] zp ZP_WORD:20 [ draw_block::x1#0 ] zp ZP_BYTE:19 [ draw_block::tileno#1 ] 
Limited combination testing to 100 combinations of 1296 possible.
Uplifting [memset] best 90971 combination zp ZP_WORD:12 [ memset::dst#2 memset::dst#4 memset::dst#1 ] zp ZP_WORD:47 [ memset::end#0 ] reg byte x [ memset::c#4 ] zp ZP_WORD:9 [ memset::str#3 ] 
Uplifting [init] best 90971 combination 
Uplifting [init_sprites] best 90971 combination 
Uplifting [] best 90971 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Uplifting [main] best 90971 combination zp ZP_BYTE:3 [ main::y#2 main::y#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ main::x#2 main::x#1 ]
Uplifting [main] best 90971 combination zp ZP_BYTE:2 [ main::x#2 main::x#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:29 [ draw_block::drawtile#0 ]
Uplifting [draw_block] best 90967 combination reg byte x [ draw_block::drawtile#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:19 [ draw_block::tileno#1 ]
Uplifting [draw_block] best 90967 combination zp ZP_BYTE:19 [ draw_block::tileno#1 ] 
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] ] with [ zp ZP_WORD:23 [ mul8u::return#2 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:9 [ memset::str#3 ] ] with [ zp ZP_WORD:12 [ memset::dst#2 memset::dst#4 memset::dst#1 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:20 [ draw_block::x1#0 ] ] with [ zp ZP_WORD:27 [ draw_block::z#1 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 ] ] with [ zp ZP_WORD:25 [ draw_block::z#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:20 [ draw_block::x1#0 draw_block::z#1 ] ] with [ zp ZP_WORD:44 [ draw_block::$18 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:9 [ memset::str#3 memset::dst#2 memset::dst#4 memset::dst#1 ] ] with [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 ] ]
Coalescing zero page register [ zp ZP_WORD:30 [ draw_block::$11 ] ] with [ zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] ]
Coalescing zero page register [ zp ZP_WORD:47 [ memset::end#0 ] ] with [ zp ZP_WORD:20 [ draw_block::x1#0 draw_block::z#1 draw_block::$18 ] ]
Allocated (was zp ZP_WORD:9) zp ZP_WORD:4 [ memset::str#3 memset::dst#2 memset::dst#4 memset::dst#1 mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 ]
Allocated (was zp ZP_BYTE:19) zp ZP_BYTE:6 [ draw_block::tileno#1 ]
Allocated (was zp ZP_WORD:30) zp ZP_WORD:7 [ draw_block::$11 mul8u::mb#2 mul8u::mb#1 ]
Allocated (was zp ZP_WORD:32) zp ZP_WORD:9 [ draw_block::$12 ]
Allocated (was zp ZP_WORD:34) zp ZP_WORD:11 [ draw_block::$13 ]
Allocated (was zp ZP_WORD:36) zp ZP_WORD:13 [ draw_block::$14 ]
Allocated (was zp ZP_WORD:38) zp ZP_WORD:15 [ draw_block::$15 ]
Allocated (was zp ZP_WORD:40) zp ZP_WORD:17 [ draw_block::$16 ]
Allocated (was zp ZP_WORD:42) zp ZP_WORD:19 [ draw_block::$17 ]
Allocated (was zp ZP_WORD:47) zp ZP_WORD:21 [ memset::end#0 draw_block::x1#0 draw_block::z#1 draw_block::$18 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Illustrates a problem with a missing fragment - pbuc1_derefidx_vwuz1=vbuz2
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XMSB = $d010
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label BORDERCOL = $d020
  .label BGCOL1 = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label BGCOL4 = $d024
  .label SPRITES_COLS = $d027
  .label D018 = $d018
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  .const BLUE = 6
  .const YELLOW = 7
  .label screen = $400
  .label charset = $2000
  .label tileset = $2800
  .label colors = $d800
  .label level_address = $3000
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label y = 3
    .label x = 2
    // [5] call init 
    // [55] phi from main to init [phi:main->init]
  init_from_main:
    jsr init
    // [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    // [6] phi (byte) main::x#2 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    jmp b1
    // main::@1
  b1:
    // [7] if((byte) main::x#2<(byte) $10) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z x
    cmp #$10
    bcc b2_from_b1
    // [8] phi from main::@1 main::@5 to main::@5 [phi:main::@1/main::@5->main::@5]
  b5_from_b1:
  b5_from_b5:
    jmp b5
    // main::@5
  b5:
    jmp b5_from_b5
    // [9] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    // [9] phi (byte) main::y#2 = (byte) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp b2
    // main::@2
  b2:
    // [10] if((byte) main::y#2<(byte) 9) goto main::@3 -- vbuz1_lt_vbuc1_then_la1 
    lda.z y
    cmp #9
    bcc b3
    jmp b4
    // main::@4
  b4:
    // [11] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [6] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  b1_from_b4:
    // [6] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@4->main::@1#0] -- register_copy 
    jmp b1
    // main::@3
  b3:
    // [12] (byte) main::z#0 ← (byte) main::x#2 + (byte) main::y#2 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z y
    // [13] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0) -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda level_address,y
    // [14] (byte) draw_block::tileno#0 ← (byte) main::tile#0
    // [15] (byte) draw_block::x#0 ← (byte) main::x#2 -- vbuyy=vbuz1 
    ldy.z x
    // [16] (byte) draw_block::y#0 ← (byte) main::y#2 -- vbuxx=vbuz1 
    ldx.z y
    // [17] call draw_block 
    jsr draw_block
    jmp b6
    // main::@6
  b6:
    // [18] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [9] phi from main::@6 to main::@2 [phi:main::@6->main::@2]
  b2_from_b6:
    // [9] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@6->main::@2#0] -- register_copy 
    jmp b2
}
  // draw_block
// draw_block(byte register(A) tileno, byte register(Y) x, byte register(X) y)
draw_block: {
    .label tileno = 6
    .label x1 = $15
    .label z = 4
    .label z_1 = $15
    .label _11 = 7
    .label _12 = 9
    .label _13 = $b
    .label _14 = $d
    .label _15 = $f
    .label _16 = $11
    .label _17 = $13
    .label _18 = $15
    // [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 -- vbuz1=vbuaa_rol_2 
    asl
    asl
    sta.z tileno
    // [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 -- vwuz1=vbuyy_rol_1 
    tya
    asl
    sta.z x1
    lda #0
    rol
    sta.z x1+1
    // [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [22] (byte) mul8u::a#1 ← (byte) draw_block::y#1 -- vbuxx=vbuaa 
    tax
    // [23] call mul8u 
    // [45] phi from draw_block to mul8u [phi:draw_block->mul8u]
  mul8u_from_draw_block:
    jsr mul8u
    // [24] (word) mul8u::return#2 ← (word) mul8u::res#2
    jmp b1
    // draw_block::@1
  b1:
    // [25] (word) draw_block::z#0 ← (word) mul8u::return#2
    // [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 -- vwuz1=vwuz2_plus_vwuz1 
    lda.z z_1
    clc
    adc.z z
    sta.z z_1
    lda.z z_1+1
    adc.z z+1
    sta.z z_1+1
    // [27] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z tileno
    ldx tileset,y
    // [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen
    sta.z _11
    lda.z z_1+1
    adc #>screen
    sta.z _11+1
    // [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (_11),y
    // [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors
    sta.z _12
    lda.z z_1+1
    adc #>colors
    sta.z _12+1
    // [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_12),y
    // [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen+1
    sta.z _13
    lda.z z_1+1
    adc #>screen+1
    sta.z _13+1
    // [33] *((byte*~) draw_block::$13) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (_13),y
    // [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors+1
    sta.z _14
    lda.z z_1+1
    adc #>colors+1
    sta.z _14+1
    // [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_14),y
    // [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen+$28
    sta.z _15
    lda.z z_1+1
    adc #>screen+$28
    sta.z _15+1
    // [37] *((byte*~) draw_block::$15) ← (byte) 2 -- _deref_pbuz1=vbuc1 
    lda #2
    ldy #0
    sta (_15),y
    // [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors+$28
    sta.z _16
    lda.z z_1+1
    adc #>colors+$28
    sta.z _16+1
    // [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_16),y
    // [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen+$29
    sta.z _17
    lda.z z_1+1
    adc #>screen+$29
    sta.z _17+1
    // [41] *((byte*~) draw_block::$17) ← (byte) 3 -- _deref_pbuz1=vbuc1 
    lda #3
    ldy #0
    sta (_17),y
    // [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z _18
    adc #<colors+$29
    sta.z _18
    lda.z _18+1
    adc #>colors+$29
    sta.z _18+1
    // [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_18),y
    jmp breturn
    // draw_block::@return
  breturn:
    // [44] return 
    rts
}
  // mul8u
// Perform binary multiplication of two unsigned 8-bit bytes into a 16-bit unsigned word
// mul8u(byte register(X) a)
mul8u: {
    .const b = $28
    .label mb = 7
    .label res = 4
    .label return = 4
    // [46] phi from mul8u to mul8u::@1 [phi:mul8u->mul8u::@1]
  b1_from_mul8u:
    // [46] phi (word) mul8u::mb#2 = (const byte) mul8u::b#0 [phi:mul8u->mul8u::@1#0] -- vwuz1=vbuc1 
    lda #<b
    sta.z mb
    lda #>b
    sta.z mb+1
    // [46] phi (word) mul8u::res#2 = (byte) 0 [phi:mul8u->mul8u::@1#1] -- vwuz1=vbuc1 
    lda #<0
    sta.z res
    lda #>0
    sta.z res+1
    // [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#1 [phi:mul8u->mul8u::@1#2] -- register_copy 
    jmp b1
    // mul8u::@1
  b1:
    // [47] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b2
    jmp breturn
    // mul8u::@return
  breturn:
    // [48] return 
    rts
    // mul8u::@2
  b2:
    // [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [50] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b3_from_b2
    jmp b4
    // mul8u::@4
  b4:
    // [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 -- vwuz1=vwuz1_plus_vwuz2 
    lda.z res
    clc
    adc.z mb
    sta.z res
    lda.z res+1
    adc.z mb+1
    sta.z res+1
    // [52] phi from mul8u::@2 mul8u::@4 to mul8u::@3 [phi:mul8u::@2/mul8u::@4->mul8u::@3]
  b3_from_b2:
  b3_from_b4:
    // [52] phi (word) mul8u::res#6 = (word) mul8u::res#2 [phi:mul8u::@2/mul8u::@4->mul8u::@3#0] -- register_copy 
    jmp b3
    // mul8u::@3
  b3:
    // [53] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte) 1 -- vbuxx=vbuxx_ror_1 
    txa
    lsr
    tax
    // [54] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z mb
    rol.z mb+1
    // [46] phi from mul8u::@3 to mul8u::@1 [phi:mul8u::@3->mul8u::@1]
  b1_from_b3:
    // [46] phi (word) mul8u::mb#2 = (word) mul8u::mb#1 [phi:mul8u::@3->mul8u::@1#0] -- register_copy 
    // [46] phi (word) mul8u::res#2 = (word) mul8u::res#6 [phi:mul8u::@3->mul8u::@1#1] -- register_copy 
    // [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#0 [phi:mul8u::@3->mul8u::@1#2] -- register_copy 
    jmp b1
}
  // init
init: {
    .const toD0181_return = (>(screen&$3fff)*4)|(>charset)/4&$f
    // [56] call init_sprites 
    jsr init_sprites
    // [57] phi from init to init::@2 [phi:init->init::@2]
  b2_from_init:
    jmp b2
    // init::@2
  b2:
    // [58] call memset 
    // [70] phi from init::@2 to memset [phi:init::@2->memset]
  memset_from_b2:
    // [70] phi (byte) memset::c#4 = (byte) 0 [phi:init::@2->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [70] phi (void*) memset::str#3 = (void*)(const byte*) screen#0 [phi:init::@2->memset#1] -- pvoz1=pvoc1 
    lda #<screen
    sta.z memset.str
    lda #>screen
    sta.z memset.str+1
    jsr memset
    // [59] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
    jmp b3
    // init::@3
  b3:
    // [60] call memset 
    // [70] phi from init::@3 to memset [phi:init::@3->memset]
  memset_from_b3:
    // [70] phi (byte) memset::c#4 = (const byte) BLACK#0 [phi:init::@3->memset#0] -- vbuxx=vbuc1 
    ldx #BLACK
    // [70] phi (void*) memset::str#3 = (void*)(const byte*) colors#0 [phi:init::@3->memset#1] -- pvoz1=pvoc1 
    lda #<colors
    sta.z memset.str
    lda #>colors
    sta.z memset.str+1
    jsr memset
    // [61] phi from init::@3 to init::toD0181 [phi:init::@3->init::toD0181]
  toD0181_from_b3:
    jmp toD0181
    // init::toD0181
  toD0181:
    jmp b1
    // init::@1
  b1:
    // [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // asm { lda#$5b sta$d011  }
    lda #$5b
    sta $d011
    // [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BGCOL1
    // [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BGCOL2
    // [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL3
    // [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL4
    jmp breturn
    // init::@return
  breturn:
    // [69] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zeropage(4) str, byte register(X) c)
memset: {
    .label end = $15
    .label dst = 4
    .label str = 4
    jmp b1
    // memset::@1
  b1:
    // [71] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [72] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3
    // [73] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  b2_from_b1:
  b2_from_b3:
    // [73] phi (byte*) memset::dst#2 = (byte*~) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp b2
    // memset::@2
  b2:
    // [74] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne b3
    lda.z dst
    cmp.z end
    bne b3
    jmp breturn
    // memset::@return
  breturn:
    // [75] return 
    rts
    // memset::@3
  b3:
    // [76] *((byte*) memset::dst#2) ← (byte) memset::c#4 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // [77] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp b2_from_b3
}
  // init_sprites
init_sprites: {
    // [78] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta SPRITES_ENABLE
    // [79] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // one sprite enabled
    lda #0
    sta SPRITES_EXPAND_X
    // [80] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_EXPAND_Y
    // [81] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_XMSB
    // [82] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta SPRITES_COLS
    // [83] *((const byte*) SPRITES_MC#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    jmp breturn
    // init_sprites::@return
  breturn:
    // [84] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b5
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp b6
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b4
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp toD0181
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction lda #>0
Removing instruction lda #BLACK
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b5_from_b5 with b5
Replacing label b3_from_b2 with b3
Replacing label b2_from_b3 with b2
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b5_from_b1:
Removing instruction b5_from_b5:
Removing instruction b3_from_b2:
Removing instruction b3_from_b4:
Removing instruction b2_from_init:
Removing instruction memset_from_b2:
Removing instruction b3_from_b2:
Removing instruction memset_from_b3:
Removing instruction toD0181_from_b3:
Removing instruction toD0181:
Removing instruction b2_from_b1:
Removing instruction b2_from_b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction init_from_main:
Removing instruction b1_from_main:
Removing instruction b4:
Removing instruction b1_from_b4:
Removing instruction b6:
Removing instruction b2_from_b6:
Removing instruction mul8u_from_draw_block:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_mul8u:
Removing instruction breturn:
Removing instruction b4:
Removing instruction b1_from_b3:
Removing instruction b2:
Removing instruction b3:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Relabelling long label b2_from_b1 to b4
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) BGCOL1
(const byte*) BGCOL1#0 BGCOL1 = (byte*) 53281
(byte*) BGCOL2
(const byte*) BGCOL2#0 BGCOL2 = (byte*) 53282
(byte*) BGCOL3
(const byte*) BGCOL3#0 BGCOL3 = (byte*) 53283
(byte*) BGCOL4
(const byte*) BGCOL4#0 BGCOL4 = (byte*) 53284
(byte) BLACK
(const byte) BLACK#0 BLACK = (byte) 0
(byte) BLUE
(const byte) BLUE#0 BLUE = (byte) 6
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = (byte*) 53280
(byte*) D018
(const byte*) D018#0 D018 = (byte*) 53272
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte) 5
(byte) RED
(const byte) RED#0 RED = (byte) 2
(byte*) SPRITES_COLS
(const byte*) SPRITES_COLS#0 SPRITES_COLS = (byte*) 53287
(byte*) SPRITES_ENABLE
(const byte*) SPRITES_ENABLE#0 SPRITES_ENABLE = (byte*) 53269
(byte*) SPRITES_EXPAND_X
(const byte*) SPRITES_EXPAND_X#0 SPRITES_EXPAND_X = (byte*) 53277
(byte*) SPRITES_EXPAND_Y
(const byte*) SPRITES_EXPAND_Y#0 SPRITES_EXPAND_Y = (byte*) 53271
(byte*) SPRITES_MC
(const byte*) SPRITES_MC#0 SPRITES_MC = (byte*) 53276
(byte*) SPRITES_XMSB
(const byte*) SPRITES_XMSB#0 SPRITES_XMSB = (byte*) 53264
(byte) WHITE
(const byte) WHITE#0 WHITE = (byte) 1
(byte) YELLOW
(const byte) YELLOW#0 YELLOW = (byte) 7
(byte*) charset
(const byte*) charset#0 charset = (byte*) 8192
(byte*) colors
(const byte*) colors#0 colors = (byte*) 55296
(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
(byte*~) draw_block::$11 $11 zp ZP_WORD:7 4.0
(byte*~) draw_block::$12 $12 zp ZP_WORD:9 4.0
(byte*~) draw_block::$13 $13 zp ZP_WORD:11 4.0
(byte*~) draw_block::$14 $14 zp ZP_WORD:13 4.0
(byte*~) draw_block::$15 $15 zp ZP_WORD:15 4.0
(byte*~) draw_block::$16 $16 zp ZP_WORD:17 4.0
(byte*~) draw_block::$17 $17 zp ZP_WORD:19 4.0
(byte*~) draw_block::$18 $18 zp ZP_WORD:21 4.0
(label) draw_block::@1
(label) draw_block::@return
(byte) draw_block::color
(byte) draw_block::drawtile
(byte) draw_block::drawtile#0 reg byte x 2.0
(byte) draw_block::tileno
(byte) draw_block::tileno#0 reg byte a 34.33333333333333
(byte) draw_block::tileno#1 tileno zp ZP_BYTE:6 0.5
(byte) draw_block::x
(byte) draw_block::x#0 reg byte y 34.33333333333333
(word) draw_block::x1
(word) draw_block::x1#0 x1 zp ZP_WORD:21 0.6666666666666666
(byte) draw_block::y
(byte) draw_block::y#0 reg byte x 34.33333333333333
(byte) draw_block::y#1 reg byte a 4.0
(word) draw_block::z
(word) draw_block::z#0 z zp ZP_WORD:4 4.0
(word) draw_block::z#1 z#1 zp ZP_WORD:21 1.125
(void()) init()
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@return
(label) init::toD0181
(word~) init::toD0181_$0
(number~) init::toD0181_$1
(number~) init::toD0181_$2
(number~) init::toD0181_$3
(word~) init::toD0181_$4
(byte~) init::toD0181_$5
(number~) init::toD0181_$6
(number~) init::toD0181_$7
(number~) init::toD0181_$8
(byte*) init::toD0181_gfx
(byte) init::toD0181_return
(const byte) init::toD0181_return#0 toD0181_return = >(word)(const byte*) screen#0&(word) $3fff*(byte) 4|>(word)(const byte*) charset#0/(byte) 4&(byte) $f
(byte*) init::toD0181_screen
(void()) init_sprites()
(label) init_sprites::@return
(byte*) level_address
(const byte*) level_address#0 level_address = (byte*) 12288
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(byte) main::tile
(byte) main::tile#0 reg byte a 202.0
(byte) main::x
(byte) main::x#1 x zp ZP_BYTE:2 22.0
(byte) main::x#2 x zp ZP_BYTE:2 21.363636363636363
(byte) main::y
(byte) main::y#1 y zp ZP_BYTE:3 202.0
(byte) main::y#2 y zp ZP_BYTE:3 63.125
(byte) main::z
(byte) main::z#0 reg byte a 202.0
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(label) memset::@1
(label) memset::@2
(label) memset::@3
(label) memset::@return
(byte) memset::c
(byte) memset::c#4 reg byte x 1.5714285714285714
(byte*) memset::dst
(byte*) memset::dst#1 dst zp ZP_WORD:4 22.0
(byte*) memset::dst#2 dst zp ZP_WORD:4 15.333333333333332
(byte*~) memset::dst#4 dst zp ZP_WORD:4 4.0
(byte*) memset::end
(byte*) memset::end#0 end zp ZP_WORD:21 2.1666666666666665
(word) memset::num
(void*) memset::return
(void*) memset::str
(void*) memset::str#3 str zp ZP_WORD:4
(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
(byte~) mul8u::$1 reg byte a 2002.0
(label) mul8u::@1
(label) mul8u::@2
(label) mul8u::@3
(label) mul8u::@4
(label) mul8u::@return
(byte) mul8u::a
(byte) mul8u::a#0 reg byte x 1001.0
(byte) mul8u::a#1 reg byte x 2.0
(byte) mul8u::a#2 reg byte x 667.6666666666667
(byte) mul8u::b
(const byte) mul8u::b#0 b = (byte) $28
(word) mul8u::mb
(word) mul8u::mb#1 mb zp ZP_WORD:7 2002.0
(word) mul8u::mb#2 mb zp ZP_WORD:7 429.0
(word) mul8u::res
(word) mul8u::res#1 res zp ZP_WORD:4 2002.0
(word) mul8u::res#2 res zp ZP_WORD:4 500.83333333333337
(word) mul8u::res#6 res zp ZP_WORD:4 1001.0
(word) mul8u::return
(word) mul8u::return#2 return zp ZP_WORD:4 4.0
(byte*) screen
(const byte*) screen#0 screen = (byte*) 1024
(byte*) tileset
(const byte*) tileset#0 tileset = (byte*) 10240

zp ZP_BYTE:2 [ main::x#2 main::x#1 ]
zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
reg byte x [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
zp ZP_WORD:4 [ memset::str#3 memset::dst#2 memset::dst#4 memset::dst#1 mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 ]
reg byte x [ memset::c#4 ]
reg byte a [ main::z#0 ]
reg byte a [ main::tile#0 ]
reg byte a [ draw_block::tileno#0 ]
reg byte y [ draw_block::x#0 ]
reg byte x [ draw_block::y#0 ]
zp ZP_BYTE:6 [ draw_block::tileno#1 ]
reg byte a [ draw_block::y#1 ]
reg byte x [ draw_block::drawtile#0 ]
zp ZP_WORD:7 [ draw_block::$11 mul8u::mb#2 mul8u::mb#1 ]
zp ZP_WORD:9 [ draw_block::$12 ]
zp ZP_WORD:11 [ draw_block::$13 ]
zp ZP_WORD:13 [ draw_block::$14 ]
zp ZP_WORD:15 [ draw_block::$15 ]
zp ZP_WORD:17 [ draw_block::$16 ]
zp ZP_WORD:19 [ draw_block::$17 ]
reg byte a [ mul8u::$1 ]
zp ZP_WORD:21 [ memset::end#0 draw_block::x1#0 draw_block::z#1 draw_block::$18 ]


FINAL ASSEMBLER
Score: 75798

  // File Comments
// Illustrates a problem with a missing fragment - pbuc1_derefidx_vwuz1=vbuz2
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XMSB = $d010
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label BORDERCOL = $d020
  .label BGCOL1 = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label BGCOL4 = $d024
  .label SPRITES_COLS = $d027
  .label D018 = $d018
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  .const BLUE = 6
  .const YELLOW = 7
  .label screen = $400
  .label charset = $2000
  .label tileset = $2800
  .label colors = $d800
  .label level_address = $3000
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label y = 3
    .label x = 2
    // init()
    // [5] call init 
    // [55] phi from main to init [phi:main->init]
    jsr init
    // [6] phi from main to main::@1 [phi:main->main::@1]
    // [6] phi (byte) main::x#2 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    // main::@1
  b1:
    // for (byte x = 0; x < 16; x++ )
    // [7] if((byte) main::x#2<(byte) $10) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z x
    cmp #$10
    bcc b4
    // [8] phi from main::@1 main::@5 to main::@5 [phi:main::@1/main::@5->main::@5]
    // main::@5
  b5:
    jmp b5
    // [9] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b4:
    // [9] phi (byte) main::y#2 = (byte) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // main::@2
  b2:
    // for (byte y = 0; y < 9; y++)
    // [10] if((byte) main::y#2<(byte) 9) goto main::@3 -- vbuz1_lt_vbuc1_then_la1 
    lda.z y
    cmp #9
    bcc b3
    // main::@4
    // for (byte x = 0; x < 16; x++ )
    // [11] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [6] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
    // [6] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@4->main::@1#0] -- register_copy 
    jmp b1
    // main::@3
  b3:
    // z = x+y
    // [12] (byte) main::z#0 ← (byte) main::x#2 + (byte) main::y#2 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z y
    // tile = level_address[z]
    // [13] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0) -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda level_address,y
    // draw_block(tile,x,y,YELLOW)
    // [14] (byte) draw_block::tileno#0 ← (byte) main::tile#0
    // [15] (byte) draw_block::x#0 ← (byte) main::x#2 -- vbuyy=vbuz1 
    ldy.z x
    // [16] (byte) draw_block::y#0 ← (byte) main::y#2 -- vbuxx=vbuz1 
    ldx.z y
    // [17] call draw_block 
    jsr draw_block
    // main::@6
    // for (byte y = 0; y < 9; y++)
    // [18] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [9] phi from main::@6 to main::@2 [phi:main::@6->main::@2]
    // [9] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@6->main::@2#0] -- register_copy 
    jmp b2
}
  // draw_block
// draw_block(byte register(A) tileno, byte register(Y) x, byte register(X) y)
draw_block: {
    .label tileno = 6
    .label x1 = $15
    .label z = 4
    .label z_1 = $15
    .label _11 = 7
    .label _12 = 9
    .label _13 = $b
    .label _14 = $d
    .label _15 = $f
    .label _16 = $11
    .label _17 = $13
    .label _18 = $15
    // tileno = tileno << 2
    // [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 -- vbuz1=vbuaa_rol_2 
    asl
    asl
    sta.z tileno
    // x1 = x << 1
    // [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 -- vwuz1=vbuyy_rol_1 
    tya
    asl
    sta.z x1
    lda #0
    rol
    sta.z x1+1
    // y = y << 1
    // [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // mul8u(y,40)
    // [22] (byte) mul8u::a#1 ← (byte) draw_block::y#1 -- vbuxx=vbuaa 
    tax
    // [23] call mul8u 
    // [45] phi from draw_block to mul8u [phi:draw_block->mul8u]
    jsr mul8u
    // mul8u(y,40)
    // [24] (word) mul8u::return#2 ← (word) mul8u::res#2
    // draw_block::@1
    // z = mul8u(y,40)
    // [25] (word) draw_block::z#0 ← (word) mul8u::return#2
    // z = z + x1
    // [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 -- vwuz1=vwuz2_plus_vwuz1 
    lda.z z_1
    clc
    adc.z z
    sta.z z_1
    lda.z z_1+1
    adc.z z+1
    sta.z z_1+1
    // drawtile = tileset[tileno]
    // [27] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z tileno
    ldx tileset,y
    // screen[z] = drawtile
    // [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen
    sta.z _11
    lda.z z_1+1
    adc #>screen
    sta.z _11+1
    // [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (_11),y
    // colors[z] = YELLOW
    // [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors
    sta.z _12
    lda.z z_1+1
    adc #>colors
    sta.z _12+1
    // [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    sta (_12),y
    // screen[z+1] = 1
    // [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen+1
    sta.z _13
    lda.z z_1+1
    adc #>screen+1
    sta.z _13+1
    // [33] *((byte*~) draw_block::$13) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    sta (_13),y
    // colors[z+1] = YELLOW
    // [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors+1
    sta.z _14
    lda.z z_1+1
    adc #>colors+1
    sta.z _14+1
    // [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    sta (_14),y
    // screen[z+40] = 2
    // [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen+$28
    sta.z _15
    lda.z z_1+1
    adc #>screen+$28
    sta.z _15+1
    // [37] *((byte*~) draw_block::$15) ← (byte) 2 -- _deref_pbuz1=vbuc1 
    lda #2
    sta (_15),y
    // colors[z+40] = YELLOW
    // [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<colors+$28
    sta.z _16
    lda.z z_1+1
    adc #>colors+$28
    sta.z _16+1
    // [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    sta (_16),y
    // screen[z+41] = 3
    // [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z z_1
    clc
    adc #<screen+$29
    sta.z _17
    lda.z z_1+1
    adc #>screen+$29
    sta.z _17+1
    // [41] *((byte*~) draw_block::$17) ← (byte) 3 -- _deref_pbuz1=vbuc1 
    lda #3
    sta (_17),y
    // colors[z+41] = YELLOW
    // [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z _18
    adc #<colors+$29
    sta.z _18
    lda.z _18+1
    adc #>colors+$29
    sta.z _18+1
    // [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    sta (_18),y
    // draw_block::@return
    // }
    // [44] return 
    rts
}
  // mul8u
// Perform binary multiplication of two unsigned 8-bit bytes into a 16-bit unsigned word
// mul8u(byte register(X) a)
mul8u: {
    .const b = $28
    .label mb = 7
    .label res = 4
    .label return = 4
    // [46] phi from mul8u to mul8u::@1 [phi:mul8u->mul8u::@1]
    // [46] phi (word) mul8u::mb#2 = (const byte) mul8u::b#0 [phi:mul8u->mul8u::@1#0] -- vwuz1=vbuc1 
    lda #<b
    sta.z mb
    lda #>b
    sta.z mb+1
    // [46] phi (word) mul8u::res#2 = (byte) 0 [phi:mul8u->mul8u::@1#1] -- vwuz1=vbuc1 
    lda #<0
    sta.z res
    sta.z res+1
    // [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#1 [phi:mul8u->mul8u::@1#2] -- register_copy 
    // mul8u::@1
  b1:
    // while(a!=0)
    // [47] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b2
    // mul8u::@return
    // }
    // [48] return 
    rts
    // mul8u::@2
  b2:
    // a&1
    // [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if( (a&1) != 0)
    // [50] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b3
    // mul8u::@4
    // res = res + mb
    // [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 -- vwuz1=vwuz1_plus_vwuz2 
    lda.z res
    clc
    adc.z mb
    sta.z res
    lda.z res+1
    adc.z mb+1
    sta.z res+1
    // [52] phi from mul8u::@2 mul8u::@4 to mul8u::@3 [phi:mul8u::@2/mul8u::@4->mul8u::@3]
    // [52] phi (word) mul8u::res#6 = (word) mul8u::res#2 [phi:mul8u::@2/mul8u::@4->mul8u::@3#0] -- register_copy 
    // mul8u::@3
  b3:
    // a = a>>1
    // [53] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte) 1 -- vbuxx=vbuxx_ror_1 
    txa
    lsr
    tax
    // mb = mb<<1
    // [54] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z mb
    rol.z mb+1
    // [46] phi from mul8u::@3 to mul8u::@1 [phi:mul8u::@3->mul8u::@1]
    // [46] phi (word) mul8u::mb#2 = (word) mul8u::mb#1 [phi:mul8u::@3->mul8u::@1#0] -- register_copy 
    // [46] phi (word) mul8u::res#2 = (word) mul8u::res#6 [phi:mul8u::@3->mul8u::@1#1] -- register_copy 
    // [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#0 [phi:mul8u::@3->mul8u::@1#2] -- register_copy 
    jmp b1
}
  // init
init: {
    .const toD0181_return = (>(screen&$3fff)*4)|(>charset)/4&$f
    // init_sprites()
    // [56] call init_sprites 
    jsr init_sprites
    // [57] phi from init to init::@2 [phi:init->init::@2]
    // init::@2
    // memset(screen, 0, 1000)
    // [58] call memset 
    // [70] phi from init::@2 to memset [phi:init::@2->memset]
    // [70] phi (byte) memset::c#4 = (byte) 0 [phi:init::@2->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [70] phi (void*) memset::str#3 = (void*)(const byte*) screen#0 [phi:init::@2->memset#1] -- pvoz1=pvoc1 
    lda #<screen
    sta.z memset.str
    lda #>screen
    sta.z memset.str+1
    jsr memset
    // [59] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
    // init::@3
    // memset(colors, BLACK, 1000)
    // [60] call memset 
    // [70] phi from init::@3 to memset [phi:init::@3->memset]
    // [70] phi (byte) memset::c#4 = (const byte) BLACK#0 [phi:init::@3->memset#0] -- vbuxx=vbuc1 
    ldx #BLACK
    // [70] phi (void*) memset::str#3 = (void*)(const byte*) colors#0 [phi:init::@3->memset#1] -- pvoz1=pvoc1 
    lda #<colors
    sta.z memset.str
    lda #>colors
    sta.z memset.str+1
    jsr memset
    // [61] phi from init::@3 to init::toD0181 [phi:init::@3->init::toD0181]
    // init::toD0181
    // init::@1
    // *D018 = toD018(screen, charset)
    // [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // asm
    // asm { lda#$5b sta$d011  }
    lda #$5b
    sta $d011
    // *BORDERCOL = BLACK
    // [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // *BGCOL1 = BLACK
    // [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    sta BGCOL1
    // *BGCOL2 = RED
    // [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BGCOL2
    // *BGCOL3 = BLUE
    // [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL3
    // *BGCOL4 = GREEN
    // [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL4
    // init::@return
    // }
    // [69] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zeropage(4) str, byte register(X) c)
memset: {
    .label end = $15
    .label dst = 4
    .label str = 4
    // memset::@1
    // end = (char*)str + num
    // [71] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [72] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3
    // [73] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
    // [73] phi (byte*) memset::dst#2 = (byte*~) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    // memset::@2
  b2:
    // for(char* dst = str; dst!=end; dst++)
    // [74] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne b3
    lda.z dst
    cmp.z end
    bne b3
    // memset::@return
    // }
    // [75] return 
    rts
    // memset::@3
  b3:
    // *dst = c
    // [76] *((byte*) memset::dst#2) ← (byte) memset::c#4 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [77] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp b2
}
  // init_sprites
init_sprites: {
    // *SPRITES_ENABLE = %00000001
    // [78] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta SPRITES_ENABLE
    // *SPRITES_EXPAND_X = 0
    // [79] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // one sprite enabled
    lda #0
    sta SPRITES_EXPAND_X
    // *SPRITES_EXPAND_Y = 0
    // [80] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    sta SPRITES_EXPAND_Y
    // *SPRITES_XMSB = 0
    // [81] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    sta SPRITES_XMSB
    // *SPRITES_COLS = WHITE
    // [82] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta SPRITES_COLS
    // *SPRITES_MC = 0
    // [83] *((const byte*) SPRITES_MC#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    // init_sprites::@return
    // }
    // [84] return 
    rts
}
  // File Data

