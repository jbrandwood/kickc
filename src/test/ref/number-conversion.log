Resolved forward reference idx to (byte) idx
Resolved forward reference idx to (byte) idx
Resolved forward reference idx to (byte) idx
Adding pointer type conversion cast (byte*) SCREEN in (byte*) SCREEN ← (word) $400
Adding pointer type conversion cast (byte*) COLS in (byte*) COLS ← (word) $d800

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@1
main: scope:[main]  from @2
  (byte) idx#0 ← (byte) 0
  (number~) main::$0 ← (signed byte) $c + (number) $c
  (byte~) main::$1 ← typeid  (number~) main::$0
  (byte) assertType::t1#0 ← (byte~) main::$1
  (byte) assertType::t2#0 ← (const byte) TYPEID_SIGNED_BYTE
  call assertType 
  to:main::@1
main::@1: scope:[main]  from main
  (byte) idx#43 ← phi( main/(byte) idx#41 )
  (byte) idx#1 ← (byte) idx#43
  (number~) main::$3 ← (signed byte) $c + (number) $82
  (byte~) main::$4 ← typeid  (number~) main::$3
  (byte) assertType::t1#1 ← (byte~) main::$4
  (byte) assertType::t2#1 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) idx#44 ← phi( main::@1/(byte) idx#41 )
  (byte) idx#2 ← (byte) idx#44
  (number~) main::$6 ← (signed byte) $c + (number) $80e8
  (byte~) main::$7 ← typeid  (number~) main::$6
  (byte) assertType::t1#2 ← (byte~) main::$7
  (byte) assertType::t2#2 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte) idx#45 ← phi( main::@2/(byte) idx#41 )
  (byte) idx#3 ← (byte) idx#45
  (number~) main::$9 ← (signed word) $c + (number) $c
  (byte~) main::$10 ← typeid  (number~) main::$9
  (byte) assertType::t1#3 ← (byte~) main::$10
  (byte) assertType::t2#3 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:main::@4
main::@4: scope:[main]  from main::@3
  (byte) idx#46 ← phi( main::@3/(byte) idx#41 )
  (byte) idx#4 ← (byte) idx#46
  (number~) main::$12 ← (signed word) $c + (number) $82
  (byte~) main::$13 ← typeid  (number~) main::$12
  (byte) assertType::t1#4 ← (byte~) main::$13
  (byte) assertType::t2#4 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:main::@5
main::@5: scope:[main]  from main::@4
  (byte) idx#47 ← phi( main::@4/(byte) idx#41 )
  (byte) idx#5 ← (byte) idx#47
  (number~) main::$15 ← (signed word) $c + (number) $186a0
  (byte~) main::$16 ← typeid  (number~) main::$15
  (byte) assertType::t1#5 ← (byte~) main::$16
  (byte) assertType::t2#5 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@6
main::@6: scope:[main]  from main::@5
  (byte) idx#48 ← phi( main::@5/(byte) idx#41 )
  (byte) idx#6 ← (byte) idx#48
  (number~) main::$18 ← (signed dword) $c + (number) $c
  (byte~) main::$19 ← typeid  (number~) main::$18
  (byte) assertType::t1#6 ← (byte~) main::$19
  (byte) assertType::t2#6 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@7
main::@7: scope:[main]  from main::@6
  (byte) idx#49 ← phi( main::@6/(byte) idx#41 )
  (byte) idx#7 ← (byte) idx#49
  (number~) main::$21 ← (signed dword) $c + (number) $82
  (byte~) main::$22 ← typeid  (number~) main::$21
  (byte) assertType::t1#7 ← (byte~) main::$22
  (byte) assertType::t2#7 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@8
main::@8: scope:[main]  from main::@7
  (byte) idx#50 ← phi( main::@7/(byte) idx#41 )
  (byte) idx#8 ← (byte) idx#50
  (number~) main::$24 ← (signed dword) $c + (number) $186a0
  (byte~) main::$25 ← typeid  (number~) main::$24
  (byte) assertType::t1#8 ← (byte~) main::$25
  (byte) assertType::t2#8 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@9
main::@9: scope:[main]  from main::@8
  (byte) idx#51 ← phi( main::@8/(byte) idx#41 )
  (byte) idx#9 ← (byte) idx#51
  (byte) idx#10 ← (byte) $28
  (number~) main::$27 ← (byte) $c + (number) $c
  (byte~) main::$28 ← typeid  (number~) main::$27
  (byte) assertType::t1#9 ← (byte~) main::$28
  (byte) assertType::t2#9 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@10
main::@10: scope:[main]  from main::@9
  (byte) idx#52 ← phi( main::@9/(byte) idx#41 )
  (byte) idx#11 ← (byte) idx#52
  (number~) main::$30 ← (byte) $c + (number) $fa
  (byte~) main::$31 ← typeid  (number~) main::$30
  (byte) assertType::t1#10 ← (byte~) main::$31
  (byte) assertType::t2#10 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@11
main::@11: scope:[main]  from main::@10
  (byte) idx#53 ← phi( main::@10/(byte) idx#41 )
  (byte) idx#12 ← (byte) idx#53
  (number~) main::$33 ← (byte) $c + (number) $12c
  (byte~) main::$34 ← typeid  (number~) main::$33
  (byte) assertType::t1#11 ← (byte~) main::$34
  (byte) assertType::t2#11 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@12
main::@12: scope:[main]  from main::@11
  (byte) idx#54 ← phi( main::@11/(byte) idx#41 )
  (byte) idx#13 ← (byte) idx#54
  (number~) main::$36 ← (byte) $c + (number) $fffe
  (byte~) main::$37 ← typeid  (number~) main::$36
  (byte) assertType::t1#12 ← (byte~) main::$37
  (byte) assertType::t2#12 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@13
main::@13: scope:[main]  from main::@12
  (byte) idx#55 ← phi( main::@12/(byte) idx#41 )
  (byte) idx#14 ← (byte) idx#55
  (number~) main::$39 ← (byte) $c + (number) $101d0
  (byte~) main::$40 ← typeid  (number~) main::$39
  (byte) assertType::t1#13 ← (byte~) main::$40
  (byte) assertType::t2#13 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@14
main::@14: scope:[main]  from main::@13
  (byte) idx#56 ← phi( main::@13/(byte) idx#41 )
  (byte) idx#15 ← (byte) idx#56
  (number~) main::$42 ← (word) $c + (number) $c
  (byte~) main::$43 ← typeid  (number~) main::$42
  (byte) assertType::t1#14 ← (byte~) main::$43
  (byte) assertType::t2#14 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@15
main::@15: scope:[main]  from main::@14
  (byte) idx#57 ← phi( main::@14/(byte) idx#41 )
  (byte) idx#16 ← (byte) idx#57
  (number~) main::$45 ← (word) $c + (number) $82
  (byte~) main::$46 ← typeid  (number~) main::$45
  (byte) assertType::t1#15 ← (byte~) main::$46
  (byte) assertType::t2#15 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@16
main::@16: scope:[main]  from main::@15
  (byte) idx#58 ← phi( main::@15/(byte) idx#41 )
  (byte) idx#17 ← (byte) idx#58
  (number~) main::$48 ← (word) $c + (number) $101d0
  (byte~) main::$49 ← typeid  (number~) main::$48
  (byte) assertType::t1#16 ← (byte~) main::$49
  (byte) assertType::t2#16 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@17
main::@17: scope:[main]  from main::@16
  (byte) idx#59 ← phi( main::@16/(byte) idx#41 )
  (byte) idx#18 ← (byte) idx#59
  (number~) main::$51 ← (dword) $c + (number) $c
  (byte~) main::$52 ← typeid  (number~) main::$51
  (byte) assertType::t1#17 ← (byte~) main::$52
  (byte) assertType::t2#17 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@18
main::@18: scope:[main]  from main::@17
  (byte) idx#60 ← phi( main::@17/(byte) idx#41 )
  (byte) idx#19 ← (byte) idx#60
  (number~) main::$54 ← (dword) $c + (number) $82
  (byte~) main::$55 ← typeid  (number~) main::$54
  (byte) assertType::t1#18 ← (byte~) main::$55
  (byte) assertType::t2#18 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@19
main::@19: scope:[main]  from main::@18
  (byte) idx#61 ← phi( main::@18/(byte) idx#41 )
  (byte) idx#20 ← (byte) idx#61
  (number~) main::$57 ← (dword) $c + (number) $101d0
  (byte~) main::$58 ← typeid  (number~) main::$57
  (byte) assertType::t1#19 ← (byte~) main::$58
  (byte) assertType::t2#19 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@20
main::@20: scope:[main]  from main::@19
  (byte) idx#62 ← phi( main::@19/(byte) idx#41 )
  (byte) idx#21 ← (byte) idx#62
  (number~) main::$60 ← (byte) $c + (number) $b2d05e00
  (byte~) main::$61 ← typeid  (number~) main::$60
  (byte) assertType::t1#20 ← (byte~) main::$61
  (byte) assertType::t2#20 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@21
main::@21: scope:[main]  from main::@20
  (byte) idx#63 ← phi( main::@20/(byte) idx#41 )
  (byte) idx#22 ← (byte) idx#63
  (byte) idx#23 ← (byte) $50
  (number~) main::$63 ← - (number) $c
  (number~) main::$64 ← (byte) $c + (number~) main::$63
  (byte~) main::$65 ← typeid  (number~) main::$64
  (byte) assertType::t1#21 ← (byte~) main::$65
  (byte) assertType::t2#21 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@22
main::@22: scope:[main]  from main::@21
  (byte) idx#64 ← phi( main::@21/(byte) idx#41 )
  (byte) idx#24 ← (byte) idx#64
  (number~) main::$67 ← - (number) $78
  (number~) main::$68 ← (byte) $c + (number~) main::$67
  (byte~) main::$69 ← typeid  (number~) main::$68
  (byte) assertType::t1#22 ← (byte~) main::$69
  (byte) assertType::t2#22 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@23
main::@23: scope:[main]  from main::@22
  (byte) idx#65 ← phi( main::@22/(byte) idx#41 )
  (byte) idx#25 ← (byte) idx#65
  (number~) main::$71 ← - (number) $fa
  (number~) main::$72 ← (byte) $c + (number~) main::$71
  (byte~) main::$73 ← typeid  (number~) main::$72
  (byte) assertType::t1#23 ← (byte~) main::$73
  (byte) assertType::t2#23 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@24
main::@24: scope:[main]  from main::@23
  (byte) idx#66 ← phi( main::@23/(byte) idx#41 )
  (byte) idx#26 ← (byte) idx#66
  (number~) main::$75 ← - (number) $104
  (number~) main::$76 ← (byte) $c + (number~) main::$75
  (byte~) main::$77 ← typeid  (number~) main::$76
  (byte) assertType::t1#24 ← (byte~) main::$77
  (byte) assertType::t2#24 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@25
main::@25: scope:[main]  from main::@24
  (byte) idx#67 ← phi( main::@24/(byte) idx#41 )
  (byte) idx#27 ← (byte) idx#67
  (number~) main::$79 ← - (number) $fde8
  (number~) main::$80 ← (byte) $c + (number~) main::$79
  (byte~) main::$81 ← typeid  (number~) main::$80
  (byte) assertType::t1#25 ← (byte~) main::$81
  (byte) assertType::t2#25 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@26
main::@26: scope:[main]  from main::@25
  (byte) idx#68 ← phi( main::@25/(byte) idx#41 )
  (byte) idx#28 ← (byte) idx#68
  (number~) main::$83 ← - (number) $101d0
  (number~) main::$84 ← (byte) $c + (number~) main::$83
  (byte~) main::$85 ← typeid  (number~) main::$84
  (byte) assertType::t1#26 ← (byte~) main::$85
  (byte) assertType::t2#26 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@27
main::@27: scope:[main]  from main::@26
  (byte) idx#69 ← phi( main::@26/(byte) idx#41 )
  (byte) idx#29 ← (byte) idx#69
  (number~) main::$87 ← - (number) $c
  (number~) main::$88 ← (word) $c + (number~) main::$87
  (byte~) main::$89 ← typeid  (number~) main::$88
  (byte) assertType::t1#27 ← (byte~) main::$89
  (byte) assertType::t2#27 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@28
main::@28: scope:[main]  from main::@27
  (byte) idx#70 ← phi( main::@27/(byte) idx#41 )
  (byte) idx#30 ← (byte) idx#70
  (number~) main::$91 ← - (number) $82
  (number~) main::$92 ← (word) $c + (number~) main::$91
  (byte~) main::$93 ← typeid  (number~) main::$92
  (byte) assertType::t1#28 ← (byte~) main::$93
  (byte) assertType::t2#28 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@29
main::@29: scope:[main]  from main::@28
  (byte) idx#71 ← phi( main::@28/(byte) idx#41 )
  (byte) idx#31 ← (byte) idx#71
  (number~) main::$95 ← - (number) $fde8
  (number~) main::$96 ← (word) $c + (number~) main::$95
  (byte~) main::$97 ← typeid  (number~) main::$96
  (byte) assertType::t1#29 ← (byte~) main::$97
  (byte) assertType::t2#29 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@30
main::@30: scope:[main]  from main::@29
  (byte) idx#72 ← phi( main::@29/(byte) idx#41 )
  (byte) idx#32 ← (byte) idx#72
  (number~) main::$99 ← - (number) $101d0
  (number~) main::$100 ← (word) $c + (number~) main::$99
  (byte~) main::$101 ← typeid  (number~) main::$100
  (byte) assertType::t1#30 ← (byte~) main::$101
  (byte) assertType::t2#30 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@31
main::@31: scope:[main]  from main::@30
  (byte) idx#73 ← phi( main::@30/(byte) idx#41 )
  (byte) idx#33 ← (byte) idx#73
  (number~) main::$103 ← - (number) $c
  (number~) main::$104 ← (dword) $c + (number~) main::$103
  (byte~) main::$105 ← typeid  (number~) main::$104
  (byte) assertType::t1#31 ← (byte~) main::$105
  (byte) assertType::t2#31 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@32
main::@32: scope:[main]  from main::@31
  (byte) idx#74 ← phi( main::@31/(byte) idx#41 )
  (byte) idx#34 ← (byte) idx#74
  (number~) main::$107 ← - (number) $82
  (number~) main::$108 ← (dword) $c + (number~) main::$107
  (byte~) main::$109 ← typeid  (number~) main::$108
  (byte) assertType::t1#32 ← (byte~) main::$109
  (byte) assertType::t2#32 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@33
main::@33: scope:[main]  from main::@32
  (byte) idx#75 ← phi( main::@32/(byte) idx#41 )
  (byte) idx#35 ← (byte) idx#75
  (number~) main::$111 ← - (number) $101d0
  (number~) main::$112 ← (dword) $c + (number~) main::$111
  (byte~) main::$113 ← typeid  (number~) main::$112
  (byte) assertType::t1#33 ← (byte~) main::$113
  (byte) assertType::t2#33 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@34
main::@34: scope:[main]  from main::@33
  (byte) idx#76 ← phi( main::@33/(byte) idx#41 )
  (byte) idx#36 ← (byte) idx#76
  (number~) main::$115 ← - (number) $7d2b7500
  (number~) main::$116 ← (signed byte) $c + (number~) main::$115
  (byte~) main::$117 ← typeid  (number~) main::$116
  (byte) assertType::t1#34 ← (byte~) main::$117
  (byte) assertType::t2#34 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@35
main::@35: scope:[main]  from main::@34
  (byte) idx#77 ← phi( main::@34/(byte) idx#41 )
  (byte) idx#37 ← (byte) idx#77
  to:main::@return
main::@return: scope:[main]  from main::@35
  (byte) idx#78 ← phi( main::@35/(byte) idx#37 )
  (byte) idx#38 ← (byte) idx#78
  return 
  to:@return
@1: scope:[]  from @begin
  (byte) RED#0 ← (byte) 2
  (byte) GREEN#0 ← (byte) 5
  (word) $0 ← (word) $400
  (byte*) SCREEN#0 ← ((byte*)) (word) $0
  (word) $1 ← (word) $d800
  (byte*) COLS#0 ← ((byte*)) (word) $1
  (byte) idx#39 ← (byte) 0
  to:@2
assertType: scope:[assertType]  from main main::@1 main::@10 main::@11 main::@12 main::@13 main::@14 main::@15 main::@16 main::@17 main::@18 main::@19 main::@2 main::@20 main::@21 main::@22 main::@23 main::@24 main::@25 main::@26 main::@27 main::@28 main::@29 main::@3 main::@30 main::@31 main::@32 main::@33 main::@34 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  (byte) idx#84 ← phi( main/(byte) idx#0 main::@1/(byte) idx#1 main::@10/(byte) idx#11 main::@11/(byte) idx#12 main::@12/(byte) idx#13 main::@13/(byte) idx#14 main::@14/(byte) idx#15 main::@15/(byte) idx#16 main::@16/(byte) idx#17 main::@17/(byte) idx#18 main::@18/(byte) idx#19 main::@19/(byte) idx#20 main::@2/(byte) idx#2 main::@20/(byte) idx#21 main::@21/(byte) idx#23 main::@22/(byte) idx#24 main::@23/(byte) idx#25 main::@24/(byte) idx#26 main::@25/(byte) idx#27 main::@26/(byte) idx#28 main::@27/(byte) idx#29 main::@28/(byte) idx#30 main::@29/(byte) idx#31 main::@3/(byte) idx#3 main::@30/(byte) idx#32 main::@31/(byte) idx#33 main::@32/(byte) idx#34 main::@33/(byte) idx#35 main::@34/(byte) idx#36 main::@4/(byte) idx#4 main::@5/(byte) idx#5 main::@6/(byte) idx#6 main::@7/(byte) idx#7 main::@8/(byte) idx#8 main::@9/(byte) idx#10 )
  (byte) assertType::t2#35 ← phi( main/(byte) assertType::t2#0 main::@1/(byte) assertType::t2#1 main::@10/(byte) assertType::t2#10 main::@11/(byte) assertType::t2#11 main::@12/(byte) assertType::t2#12 main::@13/(byte) assertType::t2#13 main::@14/(byte) assertType::t2#14 main::@15/(byte) assertType::t2#15 main::@16/(byte) assertType::t2#16 main::@17/(byte) assertType::t2#17 main::@18/(byte) assertType::t2#18 main::@19/(byte) assertType::t2#19 main::@2/(byte) assertType::t2#2 main::@20/(byte) assertType::t2#20 main::@21/(byte) assertType::t2#21 main::@22/(byte) assertType::t2#22 main::@23/(byte) assertType::t2#23 main::@24/(byte) assertType::t2#24 main::@25/(byte) assertType::t2#25 main::@26/(byte) assertType::t2#26 main::@27/(byte) assertType::t2#27 main::@28/(byte) assertType::t2#28 main::@29/(byte) assertType::t2#29 main::@3/(byte) assertType::t2#3 main::@30/(byte) assertType::t2#30 main::@31/(byte) assertType::t2#31 main::@32/(byte) assertType::t2#32 main::@33/(byte) assertType::t2#33 main::@34/(byte) assertType::t2#34 main::@4/(byte) assertType::t2#4 main::@5/(byte) assertType::t2#5 main::@6/(byte) assertType::t2#6 main::@7/(byte) assertType::t2#7 main::@8/(byte) assertType::t2#8 main::@9/(byte) assertType::t2#9 )
  (byte) assertType::t1#35 ← phi( main/(byte) assertType::t1#0 main::@1/(byte) assertType::t1#1 main::@10/(byte) assertType::t1#10 main::@11/(byte) assertType::t1#11 main::@12/(byte) assertType::t1#12 main::@13/(byte) assertType::t1#13 main::@14/(byte) assertType::t1#14 main::@15/(byte) assertType::t1#15 main::@16/(byte) assertType::t1#16 main::@17/(byte) assertType::t1#17 main::@18/(byte) assertType::t1#18 main::@19/(byte) assertType::t1#19 main::@2/(byte) assertType::t1#2 main::@20/(byte) assertType::t1#20 main::@21/(byte) assertType::t1#21 main::@22/(byte) assertType::t1#22 main::@23/(byte) assertType::t1#23 main::@24/(byte) assertType::t1#24 main::@25/(byte) assertType::t1#25 main::@26/(byte) assertType::t1#26 main::@27/(byte) assertType::t1#27 main::@28/(byte) assertType::t1#28 main::@29/(byte) assertType::t1#29 main::@3/(byte) assertType::t1#3 main::@30/(byte) assertType::t1#30 main::@31/(byte) assertType::t1#31 main::@32/(byte) assertType::t1#32 main::@33/(byte) assertType::t1#33 main::@34/(byte) assertType::t1#34 main::@4/(byte) assertType::t1#4 main::@5/(byte) assertType::t1#5 main::@6/(byte) assertType::t1#6 main::@7/(byte) assertType::t1#7 main::@8/(byte) assertType::t1#8 main::@9/(byte) assertType::t1#9 )
  (bool~) assertType::$0 ← (byte) assertType::t1#35 == (byte) assertType::t2#35
  if((bool~) assertType::$0) goto assertType::@1
  to:assertType::@3
assertType::@1: scope:[assertType]  from assertType
  (byte) assertType::t1#37 ← phi( assertType/(byte) assertType::t1#35 )
  (byte) idx#79 ← phi( assertType/(byte) idx#84 )
  *((byte*) COLS#0 + (byte) idx#79) ← (byte) GREEN#0
  to:assertType::@2
assertType::@3: scope:[assertType]  from assertType
  (byte) assertType::t1#38 ← phi( assertType/(byte) assertType::t1#35 )
  (byte) idx#80 ← phi( assertType/(byte) idx#84 )
  *((byte*) COLS#0 + (byte) idx#80) ← (byte) RED#0
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  (byte) idx#81 ← phi( assertType::@1/(byte) idx#79 assertType::@3/(byte) idx#80 )
  (byte) assertType::t1#36 ← phi( assertType::@1/(byte) assertType::t1#37 assertType::@3/(byte) assertType::t1#38 )
  *((byte*) SCREEN#0 + (byte) idx#81) ← (byte) assertType::t1#36
  (byte) idx#40 ← ++ (byte) idx#81
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  (byte) idx#82 ← phi( assertType::@2/(byte) idx#40 )
  (byte) idx#41 ← (byte) idx#82
  return 
  to:@return
@2: scope:[]  from @1
  (byte) idx#85 ← phi( @1/(byte) idx#39 )
  call main 
  to:@3
@3: scope:[]  from @2
  (byte) idx#83 ← phi( @2/(byte) idx#38 )
  (byte) idx#42 ← (byte) idx#83
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(word) $0
(word) $1
(label) @1
(label) @2
(label) @3
(label) @begin
(label) @end
(byte*) COLS
(byte*) COLS#0
(byte) GREEN
(byte) GREEN#0
(byte) RED
(byte) RED#0
(byte*) SCREEN
(byte*) SCREEN#0
(const byte) TYPEID_BYTE = (number) 1
(const byte) TYPEID_DWORD = (number) 5
(const byte) TYPEID_SIGNED_BYTE = (number) 2
(const byte) TYPEID_SIGNED_DWORD = (number) 6
(const byte) TYPEID_SIGNED_WORD = (number) 4
(const byte) TYPEID_WORD = (number) 3
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(bool~) assertType::$0
(label) assertType::@1
(label) assertType::@2
(label) assertType::@3
(label) assertType::@return
(byte) assertType::t1
(byte) assertType::t1#0
(byte) assertType::t1#1
(byte) assertType::t1#10
(byte) assertType::t1#11
(byte) assertType::t1#12
(byte) assertType::t1#13
(byte) assertType::t1#14
(byte) assertType::t1#15
(byte) assertType::t1#16
(byte) assertType::t1#17
(byte) assertType::t1#18
(byte) assertType::t1#19
(byte) assertType::t1#2
(byte) assertType::t1#20
(byte) assertType::t1#21
(byte) assertType::t1#22
(byte) assertType::t1#23
(byte) assertType::t1#24
(byte) assertType::t1#25
(byte) assertType::t1#26
(byte) assertType::t1#27
(byte) assertType::t1#28
(byte) assertType::t1#29
(byte) assertType::t1#3
(byte) assertType::t1#30
(byte) assertType::t1#31
(byte) assertType::t1#32
(byte) assertType::t1#33
(byte) assertType::t1#34
(byte) assertType::t1#35
(byte) assertType::t1#36
(byte) assertType::t1#37
(byte) assertType::t1#38
(byte) assertType::t1#4
(byte) assertType::t1#5
(byte) assertType::t1#6
(byte) assertType::t1#7
(byte) assertType::t1#8
(byte) assertType::t1#9
(byte) assertType::t2
(byte) assertType::t2#0
(byte) assertType::t2#1
(byte) assertType::t2#10
(byte) assertType::t2#11
(byte) assertType::t2#12
(byte) assertType::t2#13
(byte) assertType::t2#14
(byte) assertType::t2#15
(byte) assertType::t2#16
(byte) assertType::t2#17
(byte) assertType::t2#18
(byte) assertType::t2#19
(byte) assertType::t2#2
(byte) assertType::t2#20
(byte) assertType::t2#21
(byte) assertType::t2#22
(byte) assertType::t2#23
(byte) assertType::t2#24
(byte) assertType::t2#25
(byte) assertType::t2#26
(byte) assertType::t2#27
(byte) assertType::t2#28
(byte) assertType::t2#29
(byte) assertType::t2#3
(byte) assertType::t2#30
(byte) assertType::t2#31
(byte) assertType::t2#32
(byte) assertType::t2#33
(byte) assertType::t2#34
(byte) assertType::t2#35
(byte) assertType::t2#4
(byte) assertType::t2#5
(byte) assertType::t2#6
(byte) assertType::t2#7
(byte) assertType::t2#8
(byte) assertType::t2#9
(byte) idx
(byte) idx#0
(byte) idx#1
(byte) idx#10
(byte) idx#11
(byte) idx#12
(byte) idx#13
(byte) idx#14
(byte) idx#15
(byte) idx#16
(byte) idx#17
(byte) idx#18
(byte) idx#19
(byte) idx#2
(byte) idx#20
(byte) idx#21
(byte) idx#22
(byte) idx#23
(byte) idx#24
(byte) idx#25
(byte) idx#26
(byte) idx#27
(byte) idx#28
(byte) idx#29
(byte) idx#3
(byte) idx#30
(byte) idx#31
(byte) idx#32
(byte) idx#33
(byte) idx#34
(byte) idx#35
(byte) idx#36
(byte) idx#37
(byte) idx#38
(byte) idx#39
(byte) idx#4
(byte) idx#40
(byte) idx#41
(byte) idx#42
(byte) idx#43
(byte) idx#44
(byte) idx#45
(byte) idx#46
(byte) idx#47
(byte) idx#48
(byte) idx#49
(byte) idx#5
(byte) idx#50
(byte) idx#51
(byte) idx#52
(byte) idx#53
(byte) idx#54
(byte) idx#55
(byte) idx#56
(byte) idx#57
(byte) idx#58
(byte) idx#59
(byte) idx#6
(byte) idx#60
(byte) idx#61
(byte) idx#62
(byte) idx#63
(byte) idx#64
(byte) idx#65
(byte) idx#66
(byte) idx#67
(byte) idx#68
(byte) idx#69
(byte) idx#7
(byte) idx#70
(byte) idx#71
(byte) idx#72
(byte) idx#73
(byte) idx#74
(byte) idx#75
(byte) idx#76
(byte) idx#77
(byte) idx#78
(byte) idx#79
(byte) idx#8
(byte) idx#80
(byte) idx#81
(byte) idx#82
(byte) idx#83
(byte) idx#84
(byte) idx#85
(byte) idx#9
(void()) main()
(number~) main::$0
(byte~) main::$1
(byte~) main::$10
(number~) main::$100
(byte~) main::$101
(number~) main::$103
(number~) main::$104
(byte~) main::$105
(number~) main::$107
(number~) main::$108
(byte~) main::$109
(number~) main::$111
(number~) main::$112
(byte~) main::$113
(number~) main::$115
(number~) main::$116
(byte~) main::$117
(number~) main::$12
(byte~) main::$13
(number~) main::$15
(byte~) main::$16
(number~) main::$18
(byte~) main::$19
(number~) main::$21
(byte~) main::$22
(number~) main::$24
(byte~) main::$25
(number~) main::$27
(byte~) main::$28
(number~) main::$3
(number~) main::$30
(byte~) main::$31
(number~) main::$33
(byte~) main::$34
(number~) main::$36
(byte~) main::$37
(number~) main::$39
(byte~) main::$4
(byte~) main::$40
(number~) main::$42
(byte~) main::$43
(number~) main::$45
(byte~) main::$46
(number~) main::$48
(byte~) main::$49
(number~) main::$51
(byte~) main::$52
(number~) main::$54
(byte~) main::$55
(number~) main::$57
(byte~) main::$58
(number~) main::$6
(number~) main::$60
(byte~) main::$61
(number~) main::$63
(number~) main::$64
(byte~) main::$65
(number~) main::$67
(number~) main::$68
(byte~) main::$69
(byte~) main::$7
(number~) main::$71
(number~) main::$72
(byte~) main::$73
(number~) main::$75
(number~) main::$76
(byte~) main::$77
(number~) main::$79
(number~) main::$80
(byte~) main::$81
(number~) main::$83
(number~) main::$84
(byte~) main::$85
(number~) main::$87
(number~) main::$88
(byte~) main::$89
(number~) main::$9
(number~) main::$91
(number~) main::$92
(byte~) main::$93
(number~) main::$95
(number~) main::$96
(byte~) main::$97
(number~) main::$99
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@22
(label) main::@23
(label) main::@24
(label) main::@25
(label) main::@26
(label) main::@27
(label) main::@28
(label) main::@29
(label) main::@3
(label) main::@30
(label) main::@31
(label) main::@32
(label) main::@33
(label) main::@34
(label) main::@35
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return

Adding number conversion cast (signed byte) $c in (number~) main::$0 ← (signed byte) $c + (number) $c
Adding number conversion cast (signed word) $c in (number~) main::$3 ← (signed byte) $c + (number) $82
Adding number conversion cast (signed word) $82 in (number~) main::$3 ← (signed word)(signed byte) $c + (number) $82
Adding number conversion cast (signed dword) $c in (number~) main::$6 ← (signed byte) $c + (number) $80e8
Adding number conversion cast (signed dword) $80e8 in (number~) main::$6 ← (signed dword)(signed byte) $c + (number) $80e8
Adding number conversion cast (signed word) $c in (number~) main::$9 ← (signed word) $c + (number) $c
Adding number conversion cast (signed word) $82 in (number~) main::$12 ← (signed word) $c + (number) $82
Adding number conversion cast (signed dword) $c in (number~) main::$15 ← (signed word) $c + (number) $186a0
Adding number conversion cast (signed dword) $186a0 in (number~) main::$15 ← (signed dword)(signed word) $c + (number) $186a0
Adding number conversion cast (signed dword) $c in (number~) main::$18 ← (signed dword) $c + (number) $c
Adding number conversion cast (signed dword) $82 in (number~) main::$21 ← (signed dword) $c + (number) $82
Adding number conversion cast (signed dword) $186a0 in (number~) main::$24 ← (signed dword) $c + (number) $186a0
Adding number conversion cast (byte) $c in (number~) main::$27 ← (byte) $c + (number) $c
Adding number conversion cast (byte) $fa in (number~) main::$30 ← (byte) $c + (number) $fa
Adding number conversion cast (word) $c in (number~) main::$33 ← (byte) $c + (number) $12c
Adding number conversion cast (word) $12c in (number~) main::$33 ← (word)(byte) $c + (number) $12c
Adding number conversion cast (word) $c in (number~) main::$36 ← (byte) $c + (number) $fffe
Adding number conversion cast (word) $fffe in (number~) main::$36 ← (word)(byte) $c + (number) $fffe
Adding number conversion cast (dword) $c in (number~) main::$39 ← (byte) $c + (number) $101d0
Adding number conversion cast (dword) $101d0 in (number~) main::$39 ← (dword)(byte) $c + (number) $101d0
Adding number conversion cast (word) $c in (number~) main::$42 ← (word) $c + (number) $c
Adding number conversion cast (word) $82 in (number~) main::$45 ← (word) $c + (number) $82
Adding number conversion cast (dword) $c in (number~) main::$48 ← (word) $c + (number) $101d0
Adding number conversion cast (dword) $101d0 in (number~) main::$48 ← (dword)(word) $c + (number) $101d0
Adding number conversion cast (dword) $c in (number~) main::$51 ← (dword) $c + (number) $c
Adding number conversion cast (dword) $82 in (number~) main::$54 ← (dword) $c + (number) $82
Adding number conversion cast (dword) $101d0 in (number~) main::$57 ← (dword) $c + (number) $101d0
Adding number conversion cast (dword) $c in (number~) main::$60 ← (byte) $c + (number) $b2d05e00
Adding number conversion cast (dword) $b2d05e00 in (number~) main::$60 ← (dword)(byte) $c + (number) $b2d05e00
Inferred type updated to signed byte in (number~) main::$0 ← (signed byte) $c + (signed byte)(number) $c
Inferred type updated to signed word in (number~) main::$3 ← (signed word)(signed byte) $c + (signed word)(number) $82
Inferred type updated to signed dword in (number~) main::$6 ← (signed dword)(signed byte) $c + (signed dword)(number) $80e8
Inferred type updated to signed word in (number~) main::$9 ← (signed word) $c + (signed word)(number) $c
Inferred type updated to signed word in (number~) main::$12 ← (signed word) $c + (signed word)(number) $82
Inferred type updated to signed dword in (number~) main::$15 ← (signed dword)(signed word) $c + (signed dword)(number) $186a0
Inferred type updated to signed dword in (number~) main::$18 ← (signed dword) $c + (signed dword)(number) $c
Inferred type updated to signed dword in (number~) main::$21 ← (signed dword) $c + (signed dword)(number) $82
Inferred type updated to signed dword in (number~) main::$24 ← (signed dword) $c + (signed dword)(number) $186a0
Inferred type updated to byte in (number~) main::$27 ← (byte) $c + (byte)(number) $c
Inferred type updated to byte in (number~) main::$30 ← (byte) $c + (byte)(number) $fa
Inferred type updated to word in (number~) main::$33 ← (word)(byte) $c + (word)(number) $12c
Inferred type updated to word in (number~) main::$36 ← (word)(byte) $c + (word)(number) $fffe
Inferred type updated to dword in (number~) main::$39 ← (dword)(byte) $c + (dword)(number) $101d0
Inferred type updated to word in (number~) main::$42 ← (word) $c + (word)(number) $c
Inferred type updated to word in (number~) main::$45 ← (word) $c + (word)(number) $82
Inferred type updated to dword in (number~) main::$48 ← (dword)(word) $c + (dword)(number) $101d0
Inferred type updated to dword in (number~) main::$51 ← (dword) $c + (dword)(number) $c
Inferred type updated to dword in (number~) main::$54 ← (dword) $c + (dword)(number) $82
Inferred type updated to dword in (number~) main::$57 ← (dword) $c + (dword)(number) $101d0
Inferred type updated to dword in (number~) main::$60 ← (dword)(byte) $c + (dword)(number) $b2d05e00
Resolving typeid() (byte~) main::$1 ← typeid  (signed byte~) main::$0
Resolving typeid() (byte~) main::$4 ← typeid  (signed word~) main::$3
Resolving typeid() (byte~) main::$7 ← typeid  (signed dword~) main::$6
Resolving typeid() (byte~) main::$10 ← typeid  (signed word~) main::$9
Resolving typeid() (byte~) main::$13 ← typeid  (signed word~) main::$12
Resolving typeid() (byte~) main::$16 ← typeid  (signed dword~) main::$15
Resolving typeid() (byte~) main::$19 ← typeid  (signed dword~) main::$18
Resolving typeid() (byte~) main::$22 ← typeid  (signed dword~) main::$21
Resolving typeid() (byte~) main::$25 ← typeid  (signed dword~) main::$24
Resolving typeid() (byte~) main::$28 ← typeid  (byte~) main::$27
Resolving typeid() (byte~) main::$31 ← typeid  (byte~) main::$30
Resolving typeid() (byte~) main::$34 ← typeid  (word~) main::$33
Resolving typeid() (byte~) main::$37 ← typeid  (word~) main::$36
Resolving typeid() (byte~) main::$40 ← typeid  (dword~) main::$39
Resolving typeid() (byte~) main::$43 ← typeid  (word~) main::$42
Resolving typeid() (byte~) main::$46 ← typeid  (word~) main::$45
Resolving typeid() (byte~) main::$49 ← typeid  (dword~) main::$48
Resolving typeid() (byte~) main::$52 ← typeid  (dword~) main::$51
Resolving typeid() (byte~) main::$55 ← typeid  (dword~) main::$54
Resolving typeid() (byte~) main::$58 ← typeid  (dword~) main::$57
Resolving typeid() (byte~) main::$61 ← typeid  (dword~) main::$60
Successful SSA optimization PassNTypeIdSimplification
Alias (byte) assertType::t1#0 = (byte~) main::$1 
Alias (byte) idx#1 = (byte) idx#43 
Alias (byte) assertType::t1#1 = (byte~) main::$4 
Alias (byte) idx#2 = (byte) idx#44 
Alias (byte) assertType::t1#2 = (byte~) main::$7 
Alias (byte) idx#3 = (byte) idx#45 
Alias (byte) assertType::t1#3 = (byte~) main::$10 
Alias (byte) idx#4 = (byte) idx#46 
Alias (byte) assertType::t1#4 = (byte~) main::$13 
Alias (byte) idx#47 = (byte) idx#5 
Alias (byte) assertType::t1#5 = (byte~) main::$16 
Alias (byte) idx#48 = (byte) idx#6 
Alias (byte) assertType::t1#6 = (byte~) main::$19 
Alias (byte) idx#49 = (byte) idx#7 
Alias (byte) assertType::t1#7 = (byte~) main::$22 
Alias (byte) idx#50 = (byte) idx#8 
Alias (byte) assertType::t1#8 = (byte~) main::$25 
Alias (byte) idx#51 = (byte) idx#9 
Alias (byte) assertType::t1#9 = (byte~) main::$28 
Alias (byte) idx#11 = (byte) idx#52 
Alias (byte) assertType::t1#10 = (byte~) main::$31 
Alias (byte) idx#12 = (byte) idx#53 
Alias (byte) assertType::t1#11 = (byte~) main::$34 
Alias (byte) idx#13 = (byte) idx#54 
Alias (byte) assertType::t1#12 = (byte~) main::$37 
Alias (byte) idx#14 = (byte) idx#55 
Alias (byte) assertType::t1#13 = (byte~) main::$40 
Alias (byte) idx#15 = (byte) idx#56 
Alias (byte) assertType::t1#14 = (byte~) main::$43 
Alias (byte) idx#16 = (byte) idx#57 
Alias (byte) assertType::t1#15 = (byte~) main::$46 
Alias (byte) idx#17 = (byte) idx#58 
Alias (byte) assertType::t1#16 = (byte~) main::$49 
Alias (byte) idx#18 = (byte) idx#59 
Alias (byte) assertType::t1#17 = (byte~) main::$52 
Alias (byte) idx#19 = (byte) idx#60 
Alias (byte) assertType::t1#18 = (byte~) main::$55 
Alias (byte) idx#20 = (byte) idx#61 
Alias (byte) assertType::t1#19 = (byte~) main::$58 
Alias (byte) idx#21 = (byte) idx#62 
Alias (byte) assertType::t1#20 = (byte~) main::$61 
Alias (byte) idx#22 = (byte) idx#63 
Alias (byte) assertType::t1#21 = (byte~) main::$65 
Alias (byte) idx#24 = (byte) idx#64 
Alias (byte) assertType::t1#22 = (byte~) main::$69 
Alias (byte) idx#25 = (byte) idx#65 
Alias (byte) assertType::t1#23 = (byte~) main::$73 
Alias (byte) idx#26 = (byte) idx#66 
Alias (byte) assertType::t1#24 = (byte~) main::$77 
Alias (byte) idx#27 = (byte) idx#67 
Alias (byte) assertType::t1#25 = (byte~) main::$81 
Alias (byte) idx#28 = (byte) idx#68 
Alias (byte) assertType::t1#26 = (byte~) main::$85 
Alias (byte) idx#29 = (byte) idx#69 
Alias (byte) assertType::t1#27 = (byte~) main::$89 
Alias (byte) idx#30 = (byte) idx#70 
Alias (byte) assertType::t1#28 = (byte~) main::$93 
Alias (byte) idx#31 = (byte) idx#71 
Alias (byte) assertType::t1#29 = (byte~) main::$97 
Alias (byte) idx#32 = (byte) idx#72 
Alias (byte) assertType::t1#30 = (byte~) main::$101 
Alias (byte) idx#33 = (byte) idx#73 
Alias (byte) assertType::t1#31 = (byte~) main::$105 
Alias (byte) idx#34 = (byte) idx#74 
Alias (byte) assertType::t1#32 = (byte~) main::$109 
Alias (byte) idx#35 = (byte) idx#75 
Alias (byte) assertType::t1#33 = (byte~) main::$113 
Alias (byte) idx#36 = (byte) idx#76 
Alias (byte) assertType::t1#34 = (byte~) main::$117 
Alias (byte) idx#37 = (byte) idx#77 (byte) idx#78 (byte) idx#38 
Alias (byte) idx#79 = (byte) idx#84 (byte) idx#80 
Alias (byte) assertType::t1#35 = (byte) assertType::t1#37 (byte) assertType::t1#38 
Alias (byte) idx#40 = (byte) idx#82 (byte) idx#41 
Alias (byte) idx#39 = (byte) idx#85 
Alias (byte) idx#42 = (byte) idx#83 
Successful SSA optimization Pass2AliasElimination
Alias (byte) assertType::t1#35 = (byte) assertType::t1#36 
Alias (byte) idx#79 = (byte) idx#81 
Successful SSA optimization Pass2AliasElimination
Redundant Phi (byte) idx#1 (byte) idx#40
Redundant Phi (byte) idx#2 (byte) idx#40
Redundant Phi (byte) idx#3 (byte) idx#40
Redundant Phi (byte) idx#4 (byte) idx#40
Redundant Phi (byte) idx#47 (byte) idx#40
Redundant Phi (byte) idx#48 (byte) idx#40
Redundant Phi (byte) idx#49 (byte) idx#40
Redundant Phi (byte) idx#50 (byte) idx#40
Redundant Phi (byte) idx#51 (byte) idx#40
Redundant Phi (byte) idx#11 (byte) idx#40
Redundant Phi (byte) idx#12 (byte) idx#40
Redundant Phi (byte) idx#13 (byte) idx#40
Redundant Phi (byte) idx#14 (byte) idx#40
Redundant Phi (byte) idx#15 (byte) idx#40
Redundant Phi (byte) idx#16 (byte) idx#40
Redundant Phi (byte) idx#17 (byte) idx#40
Redundant Phi (byte) idx#18 (byte) idx#40
Redundant Phi (byte) idx#19 (byte) idx#40
Redundant Phi (byte) idx#20 (byte) idx#40
Redundant Phi (byte) idx#21 (byte) idx#40
Redundant Phi (byte) idx#22 (byte) idx#40
Redundant Phi (byte) idx#24 (byte) idx#40
Redundant Phi (byte) idx#25 (byte) idx#40
Redundant Phi (byte) idx#26 (byte) idx#40
Redundant Phi (byte) idx#27 (byte) idx#40
Redundant Phi (byte) idx#28 (byte) idx#40
Redundant Phi (byte) idx#29 (byte) idx#40
Redundant Phi (byte) idx#30 (byte) idx#40
Redundant Phi (byte) idx#31 (byte) idx#40
Redundant Phi (byte) idx#32 (byte) idx#40
Redundant Phi (byte) idx#33 (byte) idx#40
Redundant Phi (byte) idx#34 (byte) idx#40
Redundant Phi (byte) idx#35 (byte) idx#40
Redundant Phi (byte) idx#36 (byte) idx#40
Redundant Phi (byte) idx#37 (byte) idx#40
Redundant Phi (byte) idx#42 (byte) idx#37
Successful SSA optimization Pass2RedundantPhiElimination
Simple Condition (bool~) assertType::$0 [274] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [1] (signed byte~) main::$0 ← (signed byte) $c + (signed byte)(number) $c
Constant right-side identified [8] (signed word~) main::$3 ← (signed word)(signed byte) $c + (signed word)(number) $82
Constant right-side identified [15] (signed dword~) main::$6 ← (signed dword)(signed byte) $c + (signed dword)(number) $80e8
Constant right-side identified [22] (signed word~) main::$9 ← (signed word) $c + (signed word)(number) $c
Constant right-side identified [29] (signed word~) main::$12 ← (signed word) $c + (signed word)(number) $82
Constant right-side identified [36] (signed dword~) main::$15 ← (signed dword)(signed word) $c + (signed dword)(number) $186a0
Constant right-side identified [43] (signed dword~) main::$18 ← (signed dword) $c + (signed dword)(number) $c
Constant right-side identified [50] (signed dword~) main::$21 ← (signed dword) $c + (signed dword)(number) $82
Constant right-side identified [57] (signed dword~) main::$24 ← (signed dword) $c + (signed dword)(number) $186a0
Constant right-side identified [65] (byte~) main::$27 ← (byte) $c + (byte)(number) $c
Constant right-side identified [72] (byte~) main::$30 ← (byte) $c + (byte)(number) $fa
Constant right-side identified [79] (word~) main::$33 ← (word)(byte) $c + (word)(number) $12c
Constant right-side identified [86] (word~) main::$36 ← (word)(byte) $c + (word)(number) $fffe
Constant right-side identified [93] (dword~) main::$39 ← (dword)(byte) $c + (dword)(number) $101d0
Constant right-side identified [100] (word~) main::$42 ← (word) $c + (word)(number) $c
Constant right-side identified [107] (word~) main::$45 ← (word) $c + (word)(number) $82
Constant right-side identified [114] (dword~) main::$48 ← (dword)(word) $c + (dword)(number) $101d0
Constant right-side identified [121] (dword~) main::$51 ← (dword) $c + (dword)(number) $c
Constant right-side identified [128] (dword~) main::$54 ← (dword) $c + (dword)(number) $82
Constant right-side identified [135] (dword~) main::$57 ← (dword) $c + (dword)(number) $101d0
Constant right-side identified [142] (dword~) main::$60 ← (dword)(byte) $c + (dword)(number) $b2d05e00
Constant right-side identified [150] (number~) main::$63 ← - (number) $c
Constant right-side identified [158] (number~) main::$67 ← - (number) $78
Constant right-side identified [166] (number~) main::$71 ← - (number) $fa
Constant right-side identified [174] (number~) main::$75 ← - (number) $104
Constant right-side identified [182] (number~) main::$79 ← - (number) $fde8
Constant right-side identified [190] (number~) main::$83 ← - (number) $101d0
Constant right-side identified [198] (number~) main::$87 ← - (number) $c
Constant right-side identified [206] (number~) main::$91 ← - (number) $82
Constant right-side identified [214] (number~) main::$95 ← - (number) $fde8
Constant right-side identified [222] (number~) main::$99 ← - (number) $101d0
Constant right-side identified [230] (number~) main::$103 ← - (number) $c
Constant right-side identified [238] (number~) main::$107 ← - (number) $82
Constant right-side identified [246] (number~) main::$111 ← - (number) $101d0
Constant right-side identified [254] (number~) main::$115 ← - (number) $7d2b7500
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) idx#0 = 0
Constant (const signed byte) main::$0 = $c+(signed byte)$c
Constant (const byte) assertType::t1#0 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t2#0 = TYPEID_SIGNED_BYTE
Constant (const signed word) main::$3 = (signed word)$c+(signed word)$82
Constant (const byte) assertType::t1#1 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#1 = TYPEID_SIGNED_WORD
Constant (const signed dword) main::$6 = (signed dword)$c+(signed dword)$80e8
Constant (const byte) assertType::t1#2 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#2 = TYPEID_SIGNED_DWORD
Constant (const signed word) main::$9 = $c+(signed word)$c
Constant (const byte) assertType::t1#3 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#3 = TYPEID_SIGNED_WORD
Constant (const signed word) main::$12 = $c+(signed word)$82
Constant (const byte) assertType::t1#4 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#4 = TYPEID_SIGNED_WORD
Constant (const signed dword) main::$15 = (signed dword)$c+(signed dword)$186a0
Constant (const byte) assertType::t1#5 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#5 = TYPEID_SIGNED_DWORD
Constant (const signed dword) main::$18 = $c+(signed dword)$c
Constant (const byte) assertType::t1#6 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#6 = TYPEID_SIGNED_DWORD
Constant (const signed dword) main::$21 = $c+(signed dword)$82
Constant (const byte) assertType::t1#7 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#7 = TYPEID_SIGNED_DWORD
Constant (const signed dword) main::$24 = $c+(signed dword)$186a0
Constant (const byte) assertType::t1#8 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#8 = TYPEID_SIGNED_DWORD
Constant (const byte) idx#10 = $28
Constant (const byte) main::$27 = $c+(byte)$c
Constant (const byte) assertType::t1#9 = TYPEID_BYTE
Constant (const byte) assertType::t2#9 = TYPEID_BYTE
Constant (const byte) main::$30 = $c+(byte)$fa
Constant (const byte) assertType::t1#10 = TYPEID_BYTE
Constant (const byte) assertType::t2#10 = TYPEID_BYTE
Constant (const word) main::$33 = (word)$c+(word)$12c
Constant (const byte) assertType::t1#11 = TYPEID_WORD
Constant (const byte) assertType::t2#11 = TYPEID_WORD
Constant (const word) main::$36 = (word)$c+(word)$fffe
Constant (const byte) assertType::t1#12 = TYPEID_WORD
Constant (const byte) assertType::t2#12 = TYPEID_WORD
Constant (const dword) main::$39 = (dword)$c+(dword)$101d0
Constant (const byte) assertType::t1#13 = TYPEID_DWORD
Constant (const byte) assertType::t2#13 = TYPEID_DWORD
Constant (const word) main::$42 = $c+(word)$c
Constant (const byte) assertType::t1#14 = TYPEID_WORD
Constant (const byte) assertType::t2#14 = TYPEID_WORD
Constant (const word) main::$45 = $c+(word)$82
Constant (const byte) assertType::t1#15 = TYPEID_WORD
Constant (const byte) assertType::t2#15 = TYPEID_WORD
Constant (const dword) main::$48 = (dword)$c+(dword)$101d0
Constant (const byte) assertType::t1#16 = TYPEID_DWORD
Constant (const byte) assertType::t2#16 = TYPEID_DWORD
Constant (const dword) main::$51 = $c+(dword)$c
Constant (const byte) assertType::t1#17 = TYPEID_DWORD
Constant (const byte) assertType::t2#17 = TYPEID_DWORD
Constant (const dword) main::$54 = $c+(dword)$82
Constant (const byte) assertType::t1#18 = TYPEID_DWORD
Constant (const byte) assertType::t2#18 = TYPEID_DWORD
Constant (const dword) main::$57 = $c+(dword)$101d0
Constant (const byte) assertType::t1#19 = TYPEID_DWORD
Constant (const byte) assertType::t2#19 = TYPEID_DWORD
Constant (const dword) main::$60 = (dword)$c+(dword)$b2d05e00
Constant (const byte) assertType::t1#20 = TYPEID_DWORD
Constant (const byte) assertType::t2#20 = TYPEID_DWORD
Constant (const byte) idx#23 = $50
Constant (const number) main::$63 = -$c
Constant (const byte) assertType::t2#21 = TYPEID_BYTE
Constant (const number) main::$67 = -$78
Constant (const byte) assertType::t2#22 = TYPEID_BYTE
Constant (const number) main::$71 = -$fa
Constant (const byte) assertType::t2#23 = TYPEID_BYTE
Constant (const number) main::$75 = -$104
Constant (const byte) assertType::t2#24 = TYPEID_WORD
Constant (const number) main::$79 = -$fde8
Constant (const byte) assertType::t2#25 = TYPEID_WORD
Constant (const number) main::$83 = -$101d0
Constant (const byte) assertType::t2#26 = TYPEID_DWORD
Constant (const number) main::$87 = -$c
Constant (const byte) assertType::t2#27 = TYPEID_WORD
Constant (const number) main::$91 = -$82
Constant (const byte) assertType::t2#28 = TYPEID_WORD
Constant (const number) main::$95 = -$fde8
Constant (const byte) assertType::t2#29 = TYPEID_WORD
Constant (const number) main::$99 = -$101d0
Constant (const byte) assertType::t2#30 = TYPEID_DWORD
Constant (const number) main::$103 = -$c
Constant (const byte) assertType::t2#31 = TYPEID_DWORD
Constant (const number) main::$107 = -$82
Constant (const byte) assertType::t2#32 = TYPEID_DWORD
Constant (const number) main::$111 = -$101d0
Constant (const byte) assertType::t2#33 = TYPEID_DWORD
Constant (const number) main::$115 = -$7d2b7500
Constant (const byte) assertType::t2#34 = TYPEID_DWORD
Constant (const byte) RED#0 = 2
Constant (const byte) GREEN#0 = 5
Constant (const word) $0 = $400
Constant (const word) $1 = $d800
Constant (const byte) idx#39 = 0
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant (const signed byte) main::$0
Eliminating unused constant (const signed word) main::$3
Eliminating unused constant (const signed dword) main::$6
Eliminating unused constant (const signed word) main::$9
Eliminating unused constant (const signed word) main::$12
Eliminating unused constant (const signed dword) main::$15
Eliminating unused constant (const signed dword) main::$18
Eliminating unused constant (const signed dword) main::$21
Eliminating unused constant (const signed dword) main::$24
Eliminating unused constant (const byte) main::$27
Eliminating unused constant (const byte) main::$30
Eliminating unused constant (const word) main::$33
Eliminating unused constant (const word) main::$36
Eliminating unused constant (const dword) main::$39
Eliminating unused constant (const word) main::$42
Eliminating unused constant (const word) main::$45
Eliminating unused constant (const dword) main::$48
Eliminating unused constant (const dword) main::$51
Eliminating unused constant (const dword) main::$54
Eliminating unused constant (const dword) main::$57
Eliminating unused constant (const dword) main::$60
Eliminating unused constant (const byte) idx#39
Successful SSA optimization PassNEliminateUnusedVars
Eliminating Noop Cast (byte*) SCREEN#0 ← ((byte*)) (const word) $0
Eliminating Noop Cast (byte*) COLS#0 ← ((byte*)) (const word) $1
Successful SSA optimization Pass2NopCastElimination
Adding number conversion cast (byte) main::$63 in (number~) main::$64 ← (byte) $c + (const number) main::$63
Adding number conversion cast (byte) main::$67 in (number~) main::$68 ← (byte) $c + (const number) main::$67
Adding number conversion cast (byte) main::$71 in (number~) main::$72 ← (byte) $c + (const number) main::$71
Adding number conversion cast (word) $c in (number~) main::$76 ← (byte) $c + (const number) main::$75
Adding number conversion cast (word) main::$75 in (number~) main::$76 ← (word)(byte) $c + (const number) main::$75
Adding number conversion cast (word) $c in (number~) main::$80 ← (byte) $c + (const number) main::$79
Adding number conversion cast (word) main::$79 in (number~) main::$80 ← (word)(byte) $c + (const number) main::$79
Adding number conversion cast (dword) $c in (number~) main::$84 ← (byte) $c + (const number) main::$83
Adding number conversion cast (dword) main::$83 in (number~) main::$84 ← (dword)(byte) $c + (const number) main::$83
Adding number conversion cast (word) main::$87 in (number~) main::$88 ← (word) $c + (const number) main::$87
Adding number conversion cast (word) main::$91 in (number~) main::$92 ← (word) $c + (const number) main::$91
Adding number conversion cast (word) main::$95 in (number~) main::$96 ← (word) $c + (const number) main::$95
Adding number conversion cast (dword) $c in (number~) main::$100 ← (word) $c + (const number) main::$99
Adding number conversion cast (dword) main::$99 in (number~) main::$100 ← (dword)(word) $c + (const number) main::$99
Adding number conversion cast (dword) main::$103 in (number~) main::$104 ← (dword) $c + (const number) main::$103
Adding number conversion cast (dword) main::$107 in (number~) main::$108 ← (dword) $c + (const number) main::$107
Adding number conversion cast (dword) main::$111 in (number~) main::$112 ← (dword) $c + (const number) main::$111
Adding number conversion cast (signed dword) $c in (number~) main::$116 ← (signed byte) $c + (const number) main::$115
Adding number conversion cast (signed dword) main::$115 in (number~) main::$116 ← (signed dword)(signed byte) $c + (const number) main::$115
Inferred type updated to byte in (number~) main::$64 ← (byte) $c + (byte)(const number) main::$63
Inferred type updated to byte in (number~) main::$68 ← (byte) $c + (byte)(const number) main::$67
Inferred type updated to byte in (number~) main::$72 ← (byte) $c + (byte)(const number) main::$71
Inferred type updated to word in (number~) main::$76 ← (word)(byte) $c + (word)(const number) main::$75
Inferred type updated to word in (number~) main::$80 ← (word)(byte) $c + (word)(const number) main::$79
Inferred type updated to dword in (number~) main::$84 ← (dword)(byte) $c + (dword)(const number) main::$83
Inferred type updated to word in (number~) main::$88 ← (word) $c + (word)(const number) main::$87
Inferred type updated to word in (number~) main::$92 ← (word) $c + (word)(const number) main::$91
Inferred type updated to word in (number~) main::$96 ← (word) $c + (word)(const number) main::$95
Inferred type updated to dword in (number~) main::$100 ← (dword)(word) $c + (dword)(const number) main::$99
Inferred type updated to dword in (number~) main::$104 ← (dword) $c + (dword)(const number) main::$103
Inferred type updated to dword in (number~) main::$108 ← (dword) $c + (dword)(const number) main::$107
Inferred type updated to dword in (number~) main::$112 ← (dword) $c + (dword)(const number) main::$111
Inferred type updated to signed dword in (number~) main::$116 ← (signed dword)(signed byte) $c + (signed dword)(const number) main::$115
Resolving typeid() (byte) assertType::t1#21 ← typeid  (byte~) main::$64
Resolving typeid() (byte) assertType::t1#22 ← typeid  (byte~) main::$68
Resolving typeid() (byte) assertType::t1#23 ← typeid  (byte~) main::$72
Resolving typeid() (byte) assertType::t1#24 ← typeid  (word~) main::$76
Resolving typeid() (byte) assertType::t1#25 ← typeid  (word~) main::$80
Resolving typeid() (byte) assertType::t1#26 ← typeid  (dword~) main::$84
Resolving typeid() (byte) assertType::t1#27 ← typeid  (word~) main::$88
Resolving typeid() (byte) assertType::t1#28 ← typeid  (word~) main::$92
Resolving typeid() (byte) assertType::t1#29 ← typeid  (word~) main::$96
Resolving typeid() (byte) assertType::t1#30 ← typeid  (dword~) main::$100
Resolving typeid() (byte) assertType::t1#31 ← typeid  (dword~) main::$104
Resolving typeid() (byte) assertType::t1#32 ← typeid  (dword~) main::$108
Resolving typeid() (byte) assertType::t1#33 ← typeid  (dword~) main::$112
Resolving typeid() (byte) assertType::t1#34 ← typeid  (signed dword~) main::$116
Successful SSA optimization PassNTypeIdSimplification
Culled Empty Block (label) main::@35
Culled Empty Block (label) @1
Culled Empty Block (label) @3
Successful SSA optimization Pass2CullEmptyBlocks
Constant right-side identified [21] (byte~) main::$64 ← (byte) $c + (byte)(const number) main::$63
Constant right-side identified [24] (byte~) main::$68 ← (byte) $c + (byte)(const number) main::$67
Constant right-side identified [27] (byte~) main::$72 ← (byte) $c + (byte)(const number) main::$71
Constant right-side identified [30] (word~) main::$76 ← (word)(byte) $c + (word)(const number) main::$75
Constant right-side identified [33] (word~) main::$80 ← (word)(byte) $c + (word)(const number) main::$79
Constant right-side identified [36] (dword~) main::$84 ← (dword)(byte) $c + (dword)(const number) main::$83
Constant right-side identified [39] (word~) main::$88 ← (word) $c + (word)(const number) main::$87
Constant right-side identified [42] (word~) main::$92 ← (word) $c + (word)(const number) main::$91
Constant right-side identified [45] (word~) main::$96 ← (word) $c + (word)(const number) main::$95
Constant right-side identified [48] (dword~) main::$100 ← (dword)(word) $c + (dword)(const number) main::$99
Constant right-side identified [51] (dword~) main::$104 ← (dword) $c + (dword)(const number) main::$103
Constant right-side identified [54] (dword~) main::$108 ← (dword) $c + (dword)(const number) main::$107
Constant right-side identified [57] (dword~) main::$112 ← (dword) $c + (dword)(const number) main::$111
Constant right-side identified [60] (signed dword~) main::$116 ← (signed dword)(signed byte) $c + (signed dword)(const number) main::$115
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::$64 = $c+(byte)main::$63
Constant (const byte) assertType::t1#21 = TYPEID_BYTE
Constant (const byte) main::$68 = $c+(byte)main::$67
Constant (const byte) assertType::t1#22 = TYPEID_BYTE
Constant (const byte) main::$72 = $c+(byte)main::$71
Constant (const byte) assertType::t1#23 = TYPEID_BYTE
Constant (const word) main::$76 = (word)$c+(word)main::$75
Constant (const byte) assertType::t1#24 = TYPEID_WORD
Constant (const word) main::$80 = (word)$c+(word)main::$79
Constant (const byte) assertType::t1#25 = TYPEID_WORD
Constant (const dword) main::$84 = (dword)$c+(dword)main::$83
Constant (const byte) assertType::t1#26 = TYPEID_DWORD
Constant (const word) main::$88 = $c+(word)main::$87
Constant (const byte) assertType::t1#27 = TYPEID_WORD
Constant (const word) main::$92 = $c+(word)main::$91
Constant (const byte) assertType::t1#28 = TYPEID_WORD
Constant (const word) main::$96 = $c+(word)main::$95
Constant (const byte) assertType::t1#29 = TYPEID_WORD
Constant (const dword) main::$100 = (dword)$c+(dword)main::$99
Constant (const byte) assertType::t1#30 = TYPEID_DWORD
Constant (const dword) main::$104 = $c+(dword)main::$103
Constant (const byte) assertType::t1#31 = TYPEID_DWORD
Constant (const dword) main::$108 = $c+(dword)main::$107
Constant (const byte) assertType::t1#32 = TYPEID_DWORD
Constant (const dword) main::$112 = $c+(dword)main::$111
Constant (const byte) assertType::t1#33 = TYPEID_DWORD
Constant (const signed dword) main::$116 = (signed dword)$c+(signed dword)main::$115
Constant (const byte) assertType::t1#34 = TYPEID_SIGNED_DWORD
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant (const byte) main::$64
Eliminating unused constant (const byte) main::$68
Eliminating unused constant (const byte) main::$72
Eliminating unused constant (const word) main::$76
Eliminating unused constant (const word) main::$80
Eliminating unused constant (const dword) main::$84
Eliminating unused constant (const word) main::$88
Eliminating unused constant (const word) main::$92
Eliminating unused constant (const word) main::$96
Eliminating unused constant (const dword) main::$100
Eliminating unused constant (const dword) main::$104
Eliminating unused constant (const dword) main::$108
Eliminating unused constant (const dword) main::$112
Eliminating unused constant (const signed dword) main::$116
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const number) main::$63
Eliminating unused constant (const number) main::$67
Eliminating unused constant (const number) main::$71
Eliminating unused constant (const number) main::$75
Eliminating unused constant (const number) main::$79
Eliminating unused constant (const number) main::$83
Eliminating unused constant (const number) main::$87
Eliminating unused constant (const number) main::$91
Eliminating unused constant (const number) main::$95
Eliminating unused constant (const number) main::$99
Eliminating unused constant (const number) main::$103
Eliminating unused constant (const number) main::$107
Eliminating unused constant (const number) main::$111
Eliminating unused constant (const number) main::$115
Successful SSA optimization PassNEliminateUnusedVars
Inlining constant with var siblings (const byte) assertType::t1#0
Inlining constant with var siblings (const byte) assertType::t2#0
Inlining constant with var siblings (const byte) assertType::t1#1
Inlining constant with var siblings (const byte) assertType::t2#1
Inlining constant with var siblings (const byte) assertType::t1#2
Inlining constant with var siblings (const byte) assertType::t2#2
Inlining constant with var siblings (const byte) assertType::t1#3
Inlining constant with var siblings (const byte) assertType::t2#3
Inlining constant with var siblings (const byte) assertType::t1#4
Inlining constant with var siblings (const byte) assertType::t2#4
Inlining constant with var siblings (const byte) assertType::t1#5
Inlining constant with var siblings (const byte) assertType::t2#5
Inlining constant with var siblings (const byte) assertType::t1#6
Inlining constant with var siblings (const byte) assertType::t2#6
Inlining constant with var siblings (const byte) assertType::t1#7
Inlining constant with var siblings (const byte) assertType::t2#7
Inlining constant with var siblings (const byte) assertType::t1#8
Inlining constant with var siblings (const byte) assertType::t2#8
Inlining constant with var siblings (const byte) assertType::t1#9
Inlining constant with var siblings (const byte) assertType::t2#9
Inlining constant with var siblings (const byte) assertType::t1#10
Inlining constant with var siblings (const byte) assertType::t2#10
Inlining constant with var siblings (const byte) assertType::t1#11
Inlining constant with var siblings (const byte) assertType::t2#11
Inlining constant with var siblings (const byte) assertType::t1#12
Inlining constant with var siblings (const byte) assertType::t2#12
Inlining constant with var siblings (const byte) assertType::t1#13
Inlining constant with var siblings (const byte) assertType::t2#13
Inlining constant with var siblings (const byte) assertType::t1#14
Inlining constant with var siblings (const byte) assertType::t2#14
Inlining constant with var siblings (const byte) assertType::t1#15
Inlining constant with var siblings (const byte) assertType::t2#15
Inlining constant with var siblings (const byte) assertType::t1#16
Inlining constant with var siblings (const byte) assertType::t2#16
Inlining constant with var siblings (const byte) assertType::t1#17
Inlining constant with var siblings (const byte) assertType::t2#17
Inlining constant with var siblings (const byte) assertType::t1#18
Inlining constant with var siblings (const byte) assertType::t2#18
Inlining constant with var siblings (const byte) assertType::t1#19
Inlining constant with var siblings (const byte) assertType::t2#19
Inlining constant with var siblings (const byte) assertType::t1#20
Inlining constant with var siblings (const byte) assertType::t2#20
Inlining constant with var siblings (const byte) assertType::t2#21
Inlining constant with var siblings (const byte) assertType::t2#22
Inlining constant with var siblings (const byte) assertType::t2#23
Inlining constant with var siblings (const byte) assertType::t2#24
Inlining constant with var siblings (const byte) assertType::t2#25
Inlining constant with var siblings (const byte) assertType::t2#26
Inlining constant with var siblings (const byte) assertType::t2#27
Inlining constant with var siblings (const byte) assertType::t2#28
Inlining constant with var siblings (const byte) assertType::t2#29
Inlining constant with var siblings (const byte) assertType::t2#30
Inlining constant with var siblings (const byte) assertType::t2#31
Inlining constant with var siblings (const byte) assertType::t2#32
Inlining constant with var siblings (const byte) assertType::t2#33
Inlining constant with var siblings (const byte) assertType::t2#34
Inlining constant with var siblings (const byte) assertType::t1#21
Inlining constant with var siblings (const byte) assertType::t1#22
Inlining constant with var siblings (const byte) assertType::t1#23
Inlining constant with var siblings (const byte) assertType::t1#24
Inlining constant with var siblings (const byte) assertType::t1#25
Inlining constant with var siblings (const byte) assertType::t1#26
Inlining constant with var siblings (const byte) assertType::t1#27
Inlining constant with var siblings (const byte) assertType::t1#28
Inlining constant with var siblings (const byte) assertType::t1#29
Inlining constant with var siblings (const byte) assertType::t1#30
Inlining constant with var siblings (const byte) assertType::t1#31
Inlining constant with var siblings (const byte) assertType::t1#32
Inlining constant with var siblings (const byte) assertType::t1#33
Inlining constant with var siblings (const byte) assertType::t1#34
Inlining constant with var siblings (const byte) idx#0
Inlining constant with var siblings (const byte) idx#10
Inlining constant with var siblings (const byte) idx#23
Constant inlined assertType::t2#5 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#6 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#7 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#8 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#9 = (const byte) TYPEID_BYTE
Constant inlined $0 = (word) $400
Constant inlined $1 = (word) $d800
Constant inlined assertType::t2#31 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#30 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#33 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#21 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#20 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#32 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#23 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#34 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#22 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#25 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#24 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#27 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#0 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t1#26 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#1 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t1#29 = (const byte) TYPEID_WORD
Constant inlined idx#0 = (byte) 0
Constant inlined assertType::t2#2 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#28 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#3 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#4 = (const byte) TYPEID_SIGNED_WORD
Constant inlined idx#23 = (byte) $50
Constant inlined assertType::t2#20 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#10 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#22 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#21 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#12 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#24 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#11 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#23 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#14 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#26 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#13 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#25 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#16 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#28 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#15 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#27 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#18 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#17 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#29 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#19 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#6 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined idx#10 = (byte) $28
Constant inlined assertType::t1#7 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#8 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#9 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#11 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#10 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#13 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#12 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#15 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#14 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#0 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t2#17 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#1 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#16 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#2 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#19 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#3 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#18 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#4 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t1#5 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#30 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#32 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#31 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#34 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#33 = (const byte) TYPEID_DWORD
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@9
Adding NOP phi() at start of main::@21
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to assertType:5 assertType:7 assertType:9 assertType:11 assertType:13 assertType:15 assertType:17 assertType:19 assertType:21 assertType:23 assertType:25 assertType:27 assertType:29 assertType:31 assertType:33 assertType:35 assertType:37 assertType:39 assertType:41 assertType:43 assertType:45 assertType:47 assertType:49 assertType:51 assertType:53 assertType:55 assertType:57 assertType:59 assertType:61 assertType:63 assertType:65 assertType:67 assertType:69 assertType:71 assertType:73 

Created 3 initial phi equivalence classes
Coalesced [6] idx#86 ← idx#40
Coalesced (already) [8] idx#97 ← idx#40
Coalesced (already) [10] idx#107 ← idx#40
Coalesced (already) [12] idx#113 ← idx#40
Coalesced (already) [14] idx#114 ← idx#40
Coalesced (already) [16] idx#115 ← idx#40
Coalesced (already) [18] idx#116 ← idx#40
Coalesced (already) [20] idx#117 ← idx#40
Coalesced (already) [24] idx#87 ← idx#40
Coalesced (already) [26] idx#88 ← idx#40
Coalesced (already) [28] idx#89 ← idx#40
Coalesced (already) [30] idx#90 ← idx#40
Coalesced (already) [32] idx#91 ← idx#40
Coalesced (already) [34] idx#92 ← idx#40
Coalesced (already) [36] idx#93 ← idx#40
Coalesced (already) [38] idx#94 ← idx#40
Coalesced (already) [40] idx#95 ← idx#40
Coalesced (already) [42] idx#96 ← idx#40
Coalesced (already) [44] idx#98 ← idx#40
Coalesced (already) [48] idx#99 ← idx#40
Coalesced (already) [50] idx#100 ← idx#40
Coalesced (already) [52] idx#101 ← idx#40
Coalesced (already) [54] idx#102 ← idx#40
Coalesced (already) [56] idx#103 ← idx#40
Coalesced (already) [58] idx#104 ← idx#40
Coalesced (already) [60] idx#105 ← idx#40
Coalesced (already) [62] idx#106 ← idx#40
Coalesced (already) [64] idx#108 ← idx#40
Coalesced (already) [66] idx#109 ← idx#40
Coalesced (already) [68] idx#110 ← idx#40
Coalesced (already) [70] idx#111 ← idx#40
Coalesced (already) [72] idx#112 ← idx#40
Coalesced down to 3 phi equivalence classes
Renumbering block @2 to @1
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@9
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@12
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@16
Adding NOP phi() at start of main::@17
Adding NOP phi() at start of main::@18
Adding NOP phi() at start of main::@19
Adding NOP phi() at start of main::@20
Adding NOP phi() at start of main::@21
Adding NOP phi() at start of main::@22
Adding NOP phi() at start of main::@23
Adding NOP phi() at start of main::@24
Adding NOP phi() at start of main::@25
Adding NOP phi() at start of main::@26
Adding NOP phi() at start of main::@27
Adding NOP phi() at start of main::@28
Adding NOP phi() at start of main::@29
Adding NOP phi() at start of main::@30
Adding NOP phi() at start of main::@31
Adding NOP phi() at start of main::@32
Adding NOP phi() at start of main::@33
Adding NOP phi() at start of main::@34

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  [5] call assertType 
  to:main::@1
main::@1: scope:[main]  from main
  [6] phi()
  [7] call assertType 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] phi()
  [9] call assertType 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [10] phi()
  [11] call assertType 
  to:main::@4
main::@4: scope:[main]  from main::@3
  [12] phi()
  [13] call assertType 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [14] phi()
  [15] call assertType 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [16] phi()
  [17] call assertType 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [18] phi()
  [19] call assertType 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [20] phi()
  [21] call assertType 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [22] phi()
  [23] call assertType 
  to:main::@10
main::@10: scope:[main]  from main::@9
  [24] phi()
  [25] call assertType 
  to:main::@11
main::@11: scope:[main]  from main::@10
  [26] phi()
  [27] call assertType 
  to:main::@12
main::@12: scope:[main]  from main::@11
  [28] phi()
  [29] call assertType 
  to:main::@13
main::@13: scope:[main]  from main::@12
  [30] phi()
  [31] call assertType 
  to:main::@14
main::@14: scope:[main]  from main::@13
  [32] phi()
  [33] call assertType 
  to:main::@15
main::@15: scope:[main]  from main::@14
  [34] phi()
  [35] call assertType 
  to:main::@16
main::@16: scope:[main]  from main::@15
  [36] phi()
  [37] call assertType 
  to:main::@17
main::@17: scope:[main]  from main::@16
  [38] phi()
  [39] call assertType 
  to:main::@18
main::@18: scope:[main]  from main::@17
  [40] phi()
  [41] call assertType 
  to:main::@19
main::@19: scope:[main]  from main::@18
  [42] phi()
  [43] call assertType 
  to:main::@20
main::@20: scope:[main]  from main::@19
  [44] phi()
  [45] call assertType 
  to:main::@21
main::@21: scope:[main]  from main::@20
  [46] phi()
  [47] call assertType 
  to:main::@22
main::@22: scope:[main]  from main::@21
  [48] phi()
  [49] call assertType 
  to:main::@23
main::@23: scope:[main]  from main::@22
  [50] phi()
  [51] call assertType 
  to:main::@24
main::@24: scope:[main]  from main::@23
  [52] phi()
  [53] call assertType 
  to:main::@25
main::@25: scope:[main]  from main::@24
  [54] phi()
  [55] call assertType 
  to:main::@26
main::@26: scope:[main]  from main::@25
  [56] phi()
  [57] call assertType 
  to:main::@27
main::@27: scope:[main]  from main::@26
  [58] phi()
  [59] call assertType 
  to:main::@28
main::@28: scope:[main]  from main::@27
  [60] phi()
  [61] call assertType 
  to:main::@29
main::@29: scope:[main]  from main::@28
  [62] phi()
  [63] call assertType 
  to:main::@30
main::@30: scope:[main]  from main::@29
  [64] phi()
  [65] call assertType 
  to:main::@31
main::@31: scope:[main]  from main::@30
  [66] phi()
  [67] call assertType 
  to:main::@32
main::@32: scope:[main]  from main::@31
  [68] phi()
  [69] call assertType 
  to:main::@33
main::@33: scope:[main]  from main::@32
  [70] phi()
  [71] call assertType 
  to:main::@34
main::@34: scope:[main]  from main::@33
  [72] phi()
  [73] call assertType 
  to:main::@return
main::@return: scope:[main]  from main::@34
  [74] return 
  to:@return
assertType: scope:[assertType]  from main main::@1 main::@10 main::@11 main::@12 main::@13 main::@14 main::@15 main::@16 main::@17 main::@18 main::@19 main::@2 main::@20 main::@21 main::@22 main::@23 main::@24 main::@25 main::@26 main::@27 main::@28 main::@29 main::@3 main::@30 main::@31 main::@32 main::@33 main::@34 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  [75] (byte) idx#79 ← phi( main/(byte) 0 main::@1/(byte) idx#40 main::@10/(byte) idx#40 main::@11/(byte) idx#40 main::@12/(byte) idx#40 main::@13/(byte) idx#40 main::@14/(byte) idx#40 main::@15/(byte) idx#40 main::@16/(byte) idx#40 main::@17/(byte) idx#40 main::@18/(byte) idx#40 main::@19/(byte) idx#40 main::@2/(byte) idx#40 main::@20/(byte) idx#40 main::@21/(byte) $50 main::@22/(byte) idx#40 main::@23/(byte) idx#40 main::@24/(byte) idx#40 main::@25/(byte) idx#40 main::@26/(byte) idx#40 main::@27/(byte) idx#40 main::@28/(byte) idx#40 main::@29/(byte) idx#40 main::@3/(byte) idx#40 main::@30/(byte) idx#40 main::@31/(byte) idx#40 main::@32/(byte) idx#40 main::@33/(byte) idx#40 main::@34/(byte) idx#40 main::@4/(byte) idx#40 main::@5/(byte) idx#40 main::@6/(byte) idx#40 main::@7/(byte) idx#40 main::@8/(byte) idx#40 main::@9/(byte) $28 )
  [75] (byte) assertType::t2#35 ← phi( main/(const byte) TYPEID_SIGNED_BYTE main::@1/(const byte) TYPEID_SIGNED_WORD main::@10/(const byte) TYPEID_BYTE main::@11/(const byte) TYPEID_WORD main::@12/(const byte) TYPEID_WORD main::@13/(const byte) TYPEID_DWORD main::@14/(const byte) TYPEID_WORD main::@15/(const byte) TYPEID_WORD main::@16/(const byte) TYPEID_DWORD main::@17/(const byte) TYPEID_DWORD main::@18/(const byte) TYPEID_DWORD main::@19/(const byte) TYPEID_DWORD main::@2/(const byte) TYPEID_SIGNED_DWORD main::@20/(const byte) TYPEID_DWORD main::@21/(const byte) TYPEID_BYTE main::@22/(const byte) TYPEID_BYTE main::@23/(const byte) TYPEID_BYTE main::@24/(const byte) TYPEID_WORD main::@25/(const byte) TYPEID_WORD main::@26/(const byte) TYPEID_DWORD main::@27/(const byte) TYPEID_WORD main::@28/(const byte) TYPEID_WORD main::@29/(const byte) TYPEID_WORD main::@3/(const byte) TYPEID_SIGNED_WORD main::@30/(const byte) TYPEID_DWORD main::@31/(const byte) TYPEID_DWORD main::@32/(const byte) TYPEID_DWORD main::@33/(const byte) TYPEID_DWORD main::@34/(const byte) TYPEID_DWORD main::@4/(const byte) TYPEID_SIGNED_WORD main::@5/(const byte) TYPEID_SIGNED_DWORD main::@6/(const byte) TYPEID_SIGNED_DWORD main::@7/(const byte) TYPEID_SIGNED_DWORD main::@8/(const byte) TYPEID_SIGNED_DWORD main::@9/(const byte) TYPEID_BYTE )
  [75] (byte) assertType::t1#35 ← phi( main/(const byte) TYPEID_SIGNED_BYTE main::@1/(const byte) TYPEID_SIGNED_WORD main::@10/(const byte) TYPEID_BYTE main::@11/(const byte) TYPEID_WORD main::@12/(const byte) TYPEID_WORD main::@13/(const byte) TYPEID_DWORD main::@14/(const byte) TYPEID_WORD main::@15/(const byte) TYPEID_WORD main::@16/(const byte) TYPEID_DWORD main::@17/(const byte) TYPEID_DWORD main::@18/(const byte) TYPEID_DWORD main::@19/(const byte) TYPEID_DWORD main::@2/(const byte) TYPEID_SIGNED_DWORD main::@20/(const byte) TYPEID_DWORD main::@21/(const byte) TYPEID_BYTE main::@22/(const byte) TYPEID_BYTE main::@23/(const byte) TYPEID_BYTE main::@24/(const byte) TYPEID_WORD main::@25/(const byte) TYPEID_WORD main::@26/(const byte) TYPEID_DWORD main::@27/(const byte) TYPEID_WORD main::@28/(const byte) TYPEID_WORD main::@29/(const byte) TYPEID_WORD main::@3/(const byte) TYPEID_SIGNED_WORD main::@30/(const byte) TYPEID_DWORD main::@31/(const byte) TYPEID_DWORD main::@32/(const byte) TYPEID_DWORD main::@33/(const byte) TYPEID_DWORD main::@34/(const byte) TYPEID_SIGNED_DWORD main::@4/(const byte) TYPEID_SIGNED_WORD main::@5/(const byte) TYPEID_SIGNED_DWORD main::@6/(const byte) TYPEID_SIGNED_DWORD main::@7/(const byte) TYPEID_SIGNED_DWORD main::@8/(const byte) TYPEID_SIGNED_DWORD main::@9/(const byte) TYPEID_BYTE )
  [76] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1
  to:assertType::@3
assertType::@3: scope:[assertType]  from assertType
  [77] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) RED#0
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  [78] *((byte*)(word) $400 + (byte) idx#79) ← (byte) assertType::t1#35
  [79] (byte) idx#40 ← ++ (byte) idx#79
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  [80] return 
  to:@return
assertType::@1: scope:[assertType]  from assertType
  [81] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) GREEN#0
  to:assertType::@2


VARIABLE REGISTER WEIGHTS
(byte*) COLS
(byte) GREEN
(byte) RED
(byte*) SCREEN
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(byte) assertType::t1
(byte) assertType::t1#35 1.0
(byte) assertType::t2
(byte) assertType::t2#35 2.0
(byte) idx
(byte) idx#40 0.9999999999999993
(byte) idx#79 14.400000000000007
(void()) main()

Initial phi equivalence classes
[ assertType::t1#35 ]
[ assertType::t2#35 ]
[ idx#79 idx#40 ]
Complete equivalence classes
[ assertType::t1#35 ]
[ assertType::t2#35 ]
[ idx#79 idx#40 ]
Allocated zp ZP_BYTE:2 [ assertType::t1#35 ]
Allocated zp ZP_BYTE:3 [ assertType::t2#35 ]
Allocated zp ZP_BYTE:4 [ idx#79 idx#40 ]

INITIAL ASM
//SEG0 File Comments
// Tests conversion of numbers to correct int types
// See https://gitlab.com/camelot/kickc/issues/181
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_SIGNED_DWORD = 6
  .const TYPEID_BYTE = 1
  .const TYPEID_WORD = 3
  .const TYPEID_DWORD = 5
  .const RED = 2
  .const GREEN = 5
  .label idx = 4
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
  //SEG11 [5] call assertType 
  //SEG12 [75] phi from main to assertType [phi:main->assertType]
  assertType_from_main:
  //SEG13 [75] phi (byte) idx#79 = (byte) 0 [phi:main->assertType#0] -- vbuz1=vbuc1 
    lda #0
    sta idx
  //SEG14 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t2
  //SEG15 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t1
    jsr assertType
  //SEG16 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG17 main::@1
  b1:
  //SEG18 [7] call assertType 
  //SEG19 [75] phi from main::@1 to assertType [phi:main::@1->assertType]
  assertType_from_b1:
  //SEG20 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@1->assertType#0] -- register_copy 
  //SEG21 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG22 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t1
    jsr assertType
  //SEG23 [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    jmp b2
  //SEG24 main::@2
  b2:
  //SEG25 [9] call assertType 
  //SEG26 [75] phi from main::@2 to assertType [phi:main::@2->assertType]
  assertType_from_b2:
  //SEG27 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@2->assertType#0] -- register_copy 
  //SEG28 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG29 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t1
    jsr assertType
  //SEG30 [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  b3_from_b2:
    jmp b3
  //SEG31 main::@3
  b3:
  //SEG32 [11] call assertType 
  //SEG33 [75] phi from main::@3 to assertType [phi:main::@3->assertType]
  assertType_from_b3:
  //SEG34 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@3->assertType#0] -- register_copy 
  //SEG35 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG36 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t1
    jsr assertType
  //SEG37 [12] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  b4_from_b3:
    jmp b4
  //SEG38 main::@4
  b4:
  //SEG39 [13] call assertType 
  //SEG40 [75] phi from main::@4 to assertType [phi:main::@4->assertType]
  assertType_from_b4:
  //SEG41 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@4->assertType#0] -- register_copy 
  //SEG42 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG43 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t1
    jsr assertType
  //SEG44 [14] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  b5_from_b4:
    jmp b5
  //SEG45 main::@5
  b5:
  //SEG46 [15] call assertType 
  //SEG47 [75] phi from main::@5 to assertType [phi:main::@5->assertType]
  assertType_from_b5:
  //SEG48 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@5->assertType#0] -- register_copy 
  //SEG49 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG50 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t1
    jsr assertType
  //SEG51 [16] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  b6_from_b5:
    jmp b6
  //SEG52 main::@6
  b6:
  //SEG53 [17] call assertType 
  //SEG54 [75] phi from main::@6 to assertType [phi:main::@6->assertType]
  assertType_from_b6:
  //SEG55 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@6->assertType#0] -- register_copy 
  //SEG56 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG57 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t1
    jsr assertType
  //SEG58 [18] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  b7_from_b6:
    jmp b7
  //SEG59 main::@7
  b7:
  //SEG60 [19] call assertType 
  //SEG61 [75] phi from main::@7 to assertType [phi:main::@7->assertType]
  assertType_from_b7:
  //SEG62 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@7->assertType#0] -- register_copy 
  //SEG63 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG64 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t1
    jsr assertType
  //SEG65 [20] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  b8_from_b7:
    jmp b8
  //SEG66 main::@8
  b8:
  //SEG67 [21] call assertType 
  //SEG68 [75] phi from main::@8 to assertType [phi:main::@8->assertType]
  assertType_from_b8:
  //SEG69 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@8->assertType#0] -- register_copy 
  //SEG70 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG71 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t1
    jsr assertType
  //SEG72 [22] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
  b9_from_b8:
    jmp b9
  //SEG73 main::@9
  b9:
  //SEG74 [23] call assertType 
  //SEG75 [75] phi from main::@9 to assertType [phi:main::@9->assertType]
  assertType_from_b9:
  //SEG76 [75] phi (byte) idx#79 = (byte) $28 [phi:main::@9->assertType#0] -- vbuz1=vbuc1 
    lda #$28
    sta idx
  //SEG77 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG78 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t1
    jsr assertType
  //SEG79 [24] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  b10_from_b9:
    jmp b10
  //SEG80 main::@10
  b10:
  //SEG81 [25] call assertType 
  //SEG82 [75] phi from main::@10 to assertType [phi:main::@10->assertType]
  assertType_from_b10:
  //SEG83 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@10->assertType#0] -- register_copy 
  //SEG84 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG85 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t1
    jsr assertType
  //SEG86 [26] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  b11_from_b10:
    jmp b11
  //SEG87 main::@11
  b11:
  //SEG88 [27] call assertType 
  //SEG89 [75] phi from main::@11 to assertType [phi:main::@11->assertType]
  assertType_from_b11:
  //SEG90 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@11->assertType#0] -- register_copy 
  //SEG91 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG92 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG93 [28] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  b12_from_b11:
    jmp b12
  //SEG94 main::@12
  b12:
  //SEG95 [29] call assertType 
  //SEG96 [75] phi from main::@12 to assertType [phi:main::@12->assertType]
  assertType_from_b12:
  //SEG97 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@12->assertType#0] -- register_copy 
  //SEG98 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG99 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG100 [30] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
  b13_from_b12:
    jmp b13
  //SEG101 main::@13
  b13:
  //SEG102 [31] call assertType 
  //SEG103 [75] phi from main::@13 to assertType [phi:main::@13->assertType]
  assertType_from_b13:
  //SEG104 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@13->assertType#0] -- register_copy 
  //SEG105 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG106 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG107 [32] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
  b14_from_b13:
    jmp b14
  //SEG108 main::@14
  b14:
  //SEG109 [33] call assertType 
  //SEG110 [75] phi from main::@14 to assertType [phi:main::@14->assertType]
  assertType_from_b14:
  //SEG111 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@14->assertType#0] -- register_copy 
  //SEG112 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG113 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG114 [34] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  b15_from_b14:
    jmp b15
  //SEG115 main::@15
  b15:
  //SEG116 [35] call assertType 
  //SEG117 [75] phi from main::@15 to assertType [phi:main::@15->assertType]
  assertType_from_b15:
  //SEG118 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@15->assertType#0] -- register_copy 
  //SEG119 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG120 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG121 [36] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
  b16_from_b15:
    jmp b16
  //SEG122 main::@16
  b16:
  //SEG123 [37] call assertType 
  //SEG124 [75] phi from main::@16 to assertType [phi:main::@16->assertType]
  assertType_from_b16:
  //SEG125 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@16->assertType#0] -- register_copy 
  //SEG126 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG127 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG128 [38] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
  b17_from_b16:
    jmp b17
  //SEG129 main::@17
  b17:
  //SEG130 [39] call assertType 
  //SEG131 [75] phi from main::@17 to assertType [phi:main::@17->assertType]
  assertType_from_b17:
  //SEG132 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@17->assertType#0] -- register_copy 
  //SEG133 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG134 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG135 [40] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  b18_from_b17:
    jmp b18
  //SEG136 main::@18
  b18:
  //SEG137 [41] call assertType 
  //SEG138 [75] phi from main::@18 to assertType [phi:main::@18->assertType]
  assertType_from_b18:
  //SEG139 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@18->assertType#0] -- register_copy 
  //SEG140 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG141 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG142 [42] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  b19_from_b18:
    jmp b19
  //SEG143 main::@19
  b19:
  //SEG144 [43] call assertType 
  //SEG145 [75] phi from main::@19 to assertType [phi:main::@19->assertType]
  assertType_from_b19:
  //SEG146 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@19->assertType#0] -- register_copy 
  //SEG147 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG148 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG149 [44] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  b20_from_b19:
    jmp b20
  //SEG150 main::@20
  b20:
  //SEG151 [45] call assertType 
  //SEG152 [75] phi from main::@20 to assertType [phi:main::@20->assertType]
  assertType_from_b20:
  //SEG153 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@20->assertType#0] -- register_copy 
  //SEG154 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG155 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG156 [46] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
  b21_from_b20:
    jmp b21
  //SEG157 main::@21
  b21:
  //SEG158 [47] call assertType 
  //SEG159 [75] phi from main::@21 to assertType [phi:main::@21->assertType]
  assertType_from_b21:
  //SEG160 [75] phi (byte) idx#79 = (byte) $50 [phi:main::@21->assertType#0] -- vbuz1=vbuc1 
    lda #$50
    sta idx
  //SEG161 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG162 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t1
    jsr assertType
  //SEG163 [48] phi from main::@21 to main::@22 [phi:main::@21->main::@22]
  b22_from_b21:
    jmp b22
  //SEG164 main::@22
  b22:
  //SEG165 [49] call assertType 
  //SEG166 [75] phi from main::@22 to assertType [phi:main::@22->assertType]
  assertType_from_b22:
  //SEG167 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@22->assertType#0] -- register_copy 
  //SEG168 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG169 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t1
    jsr assertType
  //SEG170 [50] phi from main::@22 to main::@23 [phi:main::@22->main::@23]
  b23_from_b22:
    jmp b23
  //SEG171 main::@23
  b23:
  //SEG172 [51] call assertType 
  //SEG173 [75] phi from main::@23 to assertType [phi:main::@23->assertType]
  assertType_from_b23:
  //SEG174 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@23->assertType#0] -- register_copy 
  //SEG175 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG176 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t1
    jsr assertType
  //SEG177 [52] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
  b24_from_b23:
    jmp b24
  //SEG178 main::@24
  b24:
  //SEG179 [53] call assertType 
  //SEG180 [75] phi from main::@24 to assertType [phi:main::@24->assertType]
  assertType_from_b24:
  //SEG181 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@24->assertType#0] -- register_copy 
  //SEG182 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG183 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG184 [54] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
  b25_from_b24:
    jmp b25
  //SEG185 main::@25
  b25:
  //SEG186 [55] call assertType 
  //SEG187 [75] phi from main::@25 to assertType [phi:main::@25->assertType]
  assertType_from_b25:
  //SEG188 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@25->assertType#0] -- register_copy 
  //SEG189 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG190 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG191 [56] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
  b26_from_b25:
    jmp b26
  //SEG192 main::@26
  b26:
  //SEG193 [57] call assertType 
  //SEG194 [75] phi from main::@26 to assertType [phi:main::@26->assertType]
  assertType_from_b26:
  //SEG195 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@26->assertType#0] -- register_copy 
  //SEG196 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG197 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG198 [58] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
  b27_from_b26:
    jmp b27
  //SEG199 main::@27
  b27:
  //SEG200 [59] call assertType 
  //SEG201 [75] phi from main::@27 to assertType [phi:main::@27->assertType]
  assertType_from_b27:
  //SEG202 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@27->assertType#0] -- register_copy 
  //SEG203 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG204 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG205 [60] phi from main::@27 to main::@28 [phi:main::@27->main::@28]
  b28_from_b27:
    jmp b28
  //SEG206 main::@28
  b28:
  //SEG207 [61] call assertType 
  //SEG208 [75] phi from main::@28 to assertType [phi:main::@28->assertType]
  assertType_from_b28:
  //SEG209 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@28->assertType#0] -- register_copy 
  //SEG210 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG211 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG212 [62] phi from main::@28 to main::@29 [phi:main::@28->main::@29]
  b29_from_b28:
    jmp b29
  //SEG213 main::@29
  b29:
  //SEG214 [63] call assertType 
  //SEG215 [75] phi from main::@29 to assertType [phi:main::@29->assertType]
  assertType_from_b29:
  //SEG216 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@29->assertType#0] -- register_copy 
  //SEG217 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG218 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG219 [64] phi from main::@29 to main::@30 [phi:main::@29->main::@30]
  b30_from_b29:
    jmp b30
  //SEG220 main::@30
  b30:
  //SEG221 [65] call assertType 
  //SEG222 [75] phi from main::@30 to assertType [phi:main::@30->assertType]
  assertType_from_b30:
  //SEG223 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@30->assertType#0] -- register_copy 
  //SEG224 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG225 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG226 [66] phi from main::@30 to main::@31 [phi:main::@30->main::@31]
  b31_from_b30:
    jmp b31
  //SEG227 main::@31
  b31:
  //SEG228 [67] call assertType 
  //SEG229 [75] phi from main::@31 to assertType [phi:main::@31->assertType]
  assertType_from_b31:
  //SEG230 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@31->assertType#0] -- register_copy 
  //SEG231 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG232 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG233 [68] phi from main::@31 to main::@32 [phi:main::@31->main::@32]
  b32_from_b31:
    jmp b32
  //SEG234 main::@32
  b32:
  //SEG235 [69] call assertType 
  //SEG236 [75] phi from main::@32 to assertType [phi:main::@32->assertType]
  assertType_from_b32:
  //SEG237 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@32->assertType#0] -- register_copy 
  //SEG238 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG239 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG240 [70] phi from main::@32 to main::@33 [phi:main::@32->main::@33]
  b33_from_b32:
    jmp b33
  //SEG241 main::@33
  b33:
  //SEG242 [71] call assertType 
  //SEG243 [75] phi from main::@33 to assertType [phi:main::@33->assertType]
  assertType_from_b33:
  //SEG244 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@33->assertType#0] -- register_copy 
  //SEG245 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG246 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG247 [72] phi from main::@33 to main::@34 [phi:main::@33->main::@34]
  b34_from_b33:
    jmp b34
  //SEG248 main::@34
  b34:
  //SEG249 [73] call assertType 
  //SEG250 [75] phi from main::@34 to assertType [phi:main::@34->assertType]
  assertType_from_b34:
  //SEG251 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@34->assertType#0] -- register_copy 
  //SEG252 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@34->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG253 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@34->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t1
    jsr assertType
    jmp breturn
  //SEG254 main::@return
  breturn:
  //SEG255 [74] return 
    rts
}
//SEG256 assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte zeropage(2) t1, byte zeropage(3) t2)
assertType: {
    .label t1 = 2
    .label t2 = 3
  //SEG257 [76] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1 -- vbuz1_eq_vbuz2_then_la1 
    lda t1
    cmp t2
    beq b1
    jmp b3
  //SEG258 assertType::@3
  b3:
  //SEG259 [77] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) RED#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #RED
    ldy idx
    sta $d800,y
    jmp b2
  //SEG260 assertType::@2
  b2:
  //SEG261 [78] *((byte*)(word) $400 + (byte) idx#79) ← (byte) assertType::t1#35 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda t1
    ldy idx
    sta $400,y
  //SEG262 [79] (byte) idx#40 ← ++ (byte) idx#79 -- vbuz1=_inc_vbuz1 
    inc idx
    jmp breturn
  //SEG263 assertType::@return
  breturn:
  //SEG264 [80] return 
    rts
  //SEG265 assertType::@1
  b1:
  //SEG266 [81] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy idx
    sta $d800,y
    jmp b2
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [77] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) RED#0 [ assertType::t1#35 idx#79 ] ( main:2::assertType:5 [ assertType::t1#35 idx#79 ] main:2::assertType:7 [ assertType::t1#35 idx#79 ] main:2::assertType:9 [ assertType::t1#35 idx#79 ] main:2::assertType:11 [ assertType::t1#35 idx#79 ] main:2::assertType:13 [ assertType::t1#35 idx#79 ] main:2::assertType:15 [ assertType::t1#35 idx#79 ] main:2::assertType:17 [ assertType::t1#35 idx#79 ] main:2::assertType:19 [ assertType::t1#35 idx#79 ] main:2::assertType:21 [ assertType::t1#35 idx#79 ] main:2::assertType:23 [ assertType::t1#35 idx#79 ] main:2::assertType:25 [ assertType::t1#35 idx#79 ] main:2::assertType:27 [ assertType::t1#35 idx#79 ] main:2::assertType:29 [ assertType::t1#35 idx#79 ] main:2::assertType:31 [ assertType::t1#35 idx#79 ] main:2::assertType:33 [ assertType::t1#35 idx#79 ] main:2::assertType:35 [ assertType::t1#35 idx#79 ] main:2::assertType:37 [ assertType::t1#35 idx#79 ] main:2::assertType:39 [ assertType::t1#35 idx#79 ] main:2::assertType:41 [ assertType::t1#35 idx#79 ] main:2::assertType:43 [ assertType::t1#35 idx#79 ] main:2::assertType:45 [ assertType::t1#35 idx#79 ] main:2::assertType:47 [ assertType::t1#35 idx#79 ] main:2::assertType:49 [ assertType::t1#35 idx#79 ] main:2::assertType:51 [ assertType::t1#35 idx#79 ] main:2::assertType:53 [ assertType::t1#35 idx#79 ] main:2::assertType:55 [ assertType::t1#35 idx#79 ] main:2::assertType:57 [ assertType::t1#35 idx#79 ] main:2::assertType:59 [ assertType::t1#35 idx#79 ] main:2::assertType:61 [ assertType::t1#35 idx#79 ] main:2::assertType:63 [ assertType::t1#35 idx#79 ] main:2::assertType:65 [ assertType::t1#35 idx#79 ] main:2::assertType:67 [ assertType::t1#35 idx#79 ] main:2::assertType:69 [ assertType::t1#35 idx#79 ] main:2::assertType:71 [ assertType::t1#35 idx#79 ] main:2::assertType:73 [ assertType::t1#35 idx#79 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ assertType::t1#35 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ idx#79 idx#40 ]
Statement [78] *((byte*)(word) $400 + (byte) idx#79) ← (byte) assertType::t1#35 [ idx#79 ] ( main:2::assertType:5 [ idx#79 ] main:2::assertType:7 [ idx#79 ] main:2::assertType:9 [ idx#79 ] main:2::assertType:11 [ idx#79 ] main:2::assertType:13 [ idx#79 ] main:2::assertType:15 [ idx#79 ] main:2::assertType:17 [ idx#79 ] main:2::assertType:19 [ idx#79 ] main:2::assertType:21 [ idx#79 ] main:2::assertType:23 [ idx#79 ] main:2::assertType:25 [ idx#79 ] main:2::assertType:27 [ idx#79 ] main:2::assertType:29 [ idx#79 ] main:2::assertType:31 [ idx#79 ] main:2::assertType:33 [ idx#79 ] main:2::assertType:35 [ idx#79 ] main:2::assertType:37 [ idx#79 ] main:2::assertType:39 [ idx#79 ] main:2::assertType:41 [ idx#79 ] main:2::assertType:43 [ idx#79 ] main:2::assertType:45 [ idx#79 ] main:2::assertType:47 [ idx#79 ] main:2::assertType:49 [ idx#79 ] main:2::assertType:51 [ idx#79 ] main:2::assertType:53 [ idx#79 ] main:2::assertType:55 [ idx#79 ] main:2::assertType:57 [ idx#79 ] main:2::assertType:59 [ idx#79 ] main:2::assertType:61 [ idx#79 ] main:2::assertType:63 [ idx#79 ] main:2::assertType:65 [ idx#79 ] main:2::assertType:67 [ idx#79 ] main:2::assertType:69 [ idx#79 ] main:2::assertType:71 [ idx#79 ] main:2::assertType:73 [ idx#79 ] ) always clobbers reg byte a 
Statement [81] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) GREEN#0 [ assertType::t1#35 idx#79 ] ( main:2::assertType:5 [ assertType::t1#35 idx#79 ] main:2::assertType:7 [ assertType::t1#35 idx#79 ] main:2::assertType:9 [ assertType::t1#35 idx#79 ] main:2::assertType:11 [ assertType::t1#35 idx#79 ] main:2::assertType:13 [ assertType::t1#35 idx#79 ] main:2::assertType:15 [ assertType::t1#35 idx#79 ] main:2::assertType:17 [ assertType::t1#35 idx#79 ] main:2::assertType:19 [ assertType::t1#35 idx#79 ] main:2::assertType:21 [ assertType::t1#35 idx#79 ] main:2::assertType:23 [ assertType::t1#35 idx#79 ] main:2::assertType:25 [ assertType::t1#35 idx#79 ] main:2::assertType:27 [ assertType::t1#35 idx#79 ] main:2::assertType:29 [ assertType::t1#35 idx#79 ] main:2::assertType:31 [ assertType::t1#35 idx#79 ] main:2::assertType:33 [ assertType::t1#35 idx#79 ] main:2::assertType:35 [ assertType::t1#35 idx#79 ] main:2::assertType:37 [ assertType::t1#35 idx#79 ] main:2::assertType:39 [ assertType::t1#35 idx#79 ] main:2::assertType:41 [ assertType::t1#35 idx#79 ] main:2::assertType:43 [ assertType::t1#35 idx#79 ] main:2::assertType:45 [ assertType::t1#35 idx#79 ] main:2::assertType:47 [ assertType::t1#35 idx#79 ] main:2::assertType:49 [ assertType::t1#35 idx#79 ] main:2::assertType:51 [ assertType::t1#35 idx#79 ] main:2::assertType:53 [ assertType::t1#35 idx#79 ] main:2::assertType:55 [ assertType::t1#35 idx#79 ] main:2::assertType:57 [ assertType::t1#35 idx#79 ] main:2::assertType:59 [ assertType::t1#35 idx#79 ] main:2::assertType:61 [ assertType::t1#35 idx#79 ] main:2::assertType:63 [ assertType::t1#35 idx#79 ] main:2::assertType:65 [ assertType::t1#35 idx#79 ] main:2::assertType:67 [ assertType::t1#35 idx#79 ] main:2::assertType:69 [ assertType::t1#35 idx#79 ] main:2::assertType:71 [ assertType::t1#35 idx#79 ] main:2::assertType:73 [ assertType::t1#35 idx#79 ] ) always clobbers reg byte a 
Statement [77] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) RED#0 [ assertType::t1#35 idx#79 ] ( main:2::assertType:5 [ assertType::t1#35 idx#79 ] main:2::assertType:7 [ assertType::t1#35 idx#79 ] main:2::assertType:9 [ assertType::t1#35 idx#79 ] main:2::assertType:11 [ assertType::t1#35 idx#79 ] main:2::assertType:13 [ assertType::t1#35 idx#79 ] main:2::assertType:15 [ assertType::t1#35 idx#79 ] main:2::assertType:17 [ assertType::t1#35 idx#79 ] main:2::assertType:19 [ assertType::t1#35 idx#79 ] main:2::assertType:21 [ assertType::t1#35 idx#79 ] main:2::assertType:23 [ assertType::t1#35 idx#79 ] main:2::assertType:25 [ assertType::t1#35 idx#79 ] main:2::assertType:27 [ assertType::t1#35 idx#79 ] main:2::assertType:29 [ assertType::t1#35 idx#79 ] main:2::assertType:31 [ assertType::t1#35 idx#79 ] main:2::assertType:33 [ assertType::t1#35 idx#79 ] main:2::assertType:35 [ assertType::t1#35 idx#79 ] main:2::assertType:37 [ assertType::t1#35 idx#79 ] main:2::assertType:39 [ assertType::t1#35 idx#79 ] main:2::assertType:41 [ assertType::t1#35 idx#79 ] main:2::assertType:43 [ assertType::t1#35 idx#79 ] main:2::assertType:45 [ assertType::t1#35 idx#79 ] main:2::assertType:47 [ assertType::t1#35 idx#79 ] main:2::assertType:49 [ assertType::t1#35 idx#79 ] main:2::assertType:51 [ assertType::t1#35 idx#79 ] main:2::assertType:53 [ assertType::t1#35 idx#79 ] main:2::assertType:55 [ assertType::t1#35 idx#79 ] main:2::assertType:57 [ assertType::t1#35 idx#79 ] main:2::assertType:59 [ assertType::t1#35 idx#79 ] main:2::assertType:61 [ assertType::t1#35 idx#79 ] main:2::assertType:63 [ assertType::t1#35 idx#79 ] main:2::assertType:65 [ assertType::t1#35 idx#79 ] main:2::assertType:67 [ assertType::t1#35 idx#79 ] main:2::assertType:69 [ assertType::t1#35 idx#79 ] main:2::assertType:71 [ assertType::t1#35 idx#79 ] main:2::assertType:73 [ assertType::t1#35 idx#79 ] ) always clobbers reg byte a 
Statement [78] *((byte*)(word) $400 + (byte) idx#79) ← (byte) assertType::t1#35 [ idx#79 ] ( main:2::assertType:5 [ idx#79 ] main:2::assertType:7 [ idx#79 ] main:2::assertType:9 [ idx#79 ] main:2::assertType:11 [ idx#79 ] main:2::assertType:13 [ idx#79 ] main:2::assertType:15 [ idx#79 ] main:2::assertType:17 [ idx#79 ] main:2::assertType:19 [ idx#79 ] main:2::assertType:21 [ idx#79 ] main:2::assertType:23 [ idx#79 ] main:2::assertType:25 [ idx#79 ] main:2::assertType:27 [ idx#79 ] main:2::assertType:29 [ idx#79 ] main:2::assertType:31 [ idx#79 ] main:2::assertType:33 [ idx#79 ] main:2::assertType:35 [ idx#79 ] main:2::assertType:37 [ idx#79 ] main:2::assertType:39 [ idx#79 ] main:2::assertType:41 [ idx#79 ] main:2::assertType:43 [ idx#79 ] main:2::assertType:45 [ idx#79 ] main:2::assertType:47 [ idx#79 ] main:2::assertType:49 [ idx#79 ] main:2::assertType:51 [ idx#79 ] main:2::assertType:53 [ idx#79 ] main:2::assertType:55 [ idx#79 ] main:2::assertType:57 [ idx#79 ] main:2::assertType:59 [ idx#79 ] main:2::assertType:61 [ idx#79 ] main:2::assertType:63 [ idx#79 ] main:2::assertType:65 [ idx#79 ] main:2::assertType:67 [ idx#79 ] main:2::assertType:69 [ idx#79 ] main:2::assertType:71 [ idx#79 ] main:2::assertType:73 [ idx#79 ] ) always clobbers reg byte a 
Statement [81] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) GREEN#0 [ assertType::t1#35 idx#79 ] ( main:2::assertType:5 [ assertType::t1#35 idx#79 ] main:2::assertType:7 [ assertType::t1#35 idx#79 ] main:2::assertType:9 [ assertType::t1#35 idx#79 ] main:2::assertType:11 [ assertType::t1#35 idx#79 ] main:2::assertType:13 [ assertType::t1#35 idx#79 ] main:2::assertType:15 [ assertType::t1#35 idx#79 ] main:2::assertType:17 [ assertType::t1#35 idx#79 ] main:2::assertType:19 [ assertType::t1#35 idx#79 ] main:2::assertType:21 [ assertType::t1#35 idx#79 ] main:2::assertType:23 [ assertType::t1#35 idx#79 ] main:2::assertType:25 [ assertType::t1#35 idx#79 ] main:2::assertType:27 [ assertType::t1#35 idx#79 ] main:2::assertType:29 [ assertType::t1#35 idx#79 ] main:2::assertType:31 [ assertType::t1#35 idx#79 ] main:2::assertType:33 [ assertType::t1#35 idx#79 ] main:2::assertType:35 [ assertType::t1#35 idx#79 ] main:2::assertType:37 [ assertType::t1#35 idx#79 ] main:2::assertType:39 [ assertType::t1#35 idx#79 ] main:2::assertType:41 [ assertType::t1#35 idx#79 ] main:2::assertType:43 [ assertType::t1#35 idx#79 ] main:2::assertType:45 [ assertType::t1#35 idx#79 ] main:2::assertType:47 [ assertType::t1#35 idx#79 ] main:2::assertType:49 [ assertType::t1#35 idx#79 ] main:2::assertType:51 [ assertType::t1#35 idx#79 ] main:2::assertType:53 [ assertType::t1#35 idx#79 ] main:2::assertType:55 [ assertType::t1#35 idx#79 ] main:2::assertType:57 [ assertType::t1#35 idx#79 ] main:2::assertType:59 [ assertType::t1#35 idx#79 ] main:2::assertType:61 [ assertType::t1#35 idx#79 ] main:2::assertType:63 [ assertType::t1#35 idx#79 ] main:2::assertType:65 [ assertType::t1#35 idx#79 ] main:2::assertType:67 [ assertType::t1#35 idx#79 ] main:2::assertType:69 [ assertType::t1#35 idx#79 ] main:2::assertType:71 [ assertType::t1#35 idx#79 ] main:2::assertType:73 [ assertType::t1#35 idx#79 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ assertType::t1#35 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ assertType::t2#35 ] : zp ZP_BYTE:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ idx#79 idx#40 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 15.4: zp ZP_BYTE:4 [ idx#79 idx#40 ] 
Uplift Scope [assertType] 2: zp ZP_BYTE:3 [ assertType::t2#35 ] 1: zp ZP_BYTE:2 [ assertType::t1#35 ] 
Uplift Scope [main] 

Uplifting [] best 739 combination reg byte x [ idx#79 idx#40 ] 
Uplifting [assertType] best 632 combination zp ZP_BYTE:3 [ assertType::t2#35 ] reg byte y [ assertType::t1#35 ] 
Uplifting [main] best 632 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ assertType::t2#35 ]
Uplifting [assertType] best 632 combination zp ZP_BYTE:3 [ assertType::t2#35 ] 
Allocated (was zp ZP_BYTE:3) zp ZP_BYTE:2 [ assertType::t2#35 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Tests conversion of numbers to correct int types
// See https://gitlab.com/camelot/kickc/issues/181
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_SIGNED_DWORD = 6
  .const TYPEID_BYTE = 1
  .const TYPEID_WORD = 3
  .const TYPEID_DWORD = 5
  .const RED = 2
  .const GREEN = 5
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
  //SEG11 [5] call assertType 
  //SEG12 [75] phi from main to assertType [phi:main->assertType]
  assertType_from_main:
  //SEG13 [75] phi (byte) idx#79 = (byte) 0 [phi:main->assertType#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG14 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t2
  //SEG15 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    jsr assertType
  //SEG16 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG17 main::@1
  b1:
  //SEG18 [7] call assertType 
  //SEG19 [75] phi from main::@1 to assertType [phi:main::@1->assertType]
  assertType_from_b1:
  //SEG20 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@1->assertType#0] -- register_copy 
  //SEG21 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG22 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
  //SEG23 [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    jmp b2
  //SEG24 main::@2
  b2:
  //SEG25 [9] call assertType 
  //SEG26 [75] phi from main::@2 to assertType [phi:main::@2->assertType]
  assertType_from_b2:
  //SEG27 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@2->assertType#0] -- register_copy 
  //SEG28 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG29 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
  //SEG30 [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  b3_from_b2:
    jmp b3
  //SEG31 main::@3
  b3:
  //SEG32 [11] call assertType 
  //SEG33 [75] phi from main::@3 to assertType [phi:main::@3->assertType]
  assertType_from_b3:
  //SEG34 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@3->assertType#0] -- register_copy 
  //SEG35 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG36 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
  //SEG37 [12] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  b4_from_b3:
    jmp b4
  //SEG38 main::@4
  b4:
  //SEG39 [13] call assertType 
  //SEG40 [75] phi from main::@4 to assertType [phi:main::@4->assertType]
  assertType_from_b4:
  //SEG41 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@4->assertType#0] -- register_copy 
  //SEG42 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG43 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
  //SEG44 [14] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  b5_from_b4:
    jmp b5
  //SEG45 main::@5
  b5:
  //SEG46 [15] call assertType 
  //SEG47 [75] phi from main::@5 to assertType [phi:main::@5->assertType]
  assertType_from_b5:
  //SEG48 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@5->assertType#0] -- register_copy 
  //SEG49 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG50 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
  //SEG51 [16] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  b6_from_b5:
    jmp b6
  //SEG52 main::@6
  b6:
  //SEG53 [17] call assertType 
  //SEG54 [75] phi from main::@6 to assertType [phi:main::@6->assertType]
  assertType_from_b6:
  //SEG55 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@6->assertType#0] -- register_copy 
  //SEG56 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG57 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
  //SEG58 [18] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  b7_from_b6:
    jmp b7
  //SEG59 main::@7
  b7:
  //SEG60 [19] call assertType 
  //SEG61 [75] phi from main::@7 to assertType [phi:main::@7->assertType]
  assertType_from_b7:
  //SEG62 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@7->assertType#0] -- register_copy 
  //SEG63 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG64 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
  //SEG65 [20] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  b8_from_b7:
    jmp b8
  //SEG66 main::@8
  b8:
  //SEG67 [21] call assertType 
  //SEG68 [75] phi from main::@8 to assertType [phi:main::@8->assertType]
  assertType_from_b8:
  //SEG69 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@8->assertType#0] -- register_copy 
  //SEG70 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG71 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
  //SEG72 [22] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
  b9_from_b8:
    jmp b9
  //SEG73 main::@9
  b9:
  //SEG74 [23] call assertType 
  //SEG75 [75] phi from main::@9 to assertType [phi:main::@9->assertType]
  assertType_from_b9:
  //SEG76 [75] phi (byte) idx#79 = (byte) $28 [phi:main::@9->assertType#0] -- vbuxx=vbuc1 
    ldx #$28
  //SEG77 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG78 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
  //SEG79 [24] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  b10_from_b9:
    jmp b10
  //SEG80 main::@10
  b10:
  //SEG81 [25] call assertType 
  //SEG82 [75] phi from main::@10 to assertType [phi:main::@10->assertType]
  assertType_from_b10:
  //SEG83 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@10->assertType#0] -- register_copy 
  //SEG84 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG85 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
  //SEG86 [26] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  b11_from_b10:
    jmp b11
  //SEG87 main::@11
  b11:
  //SEG88 [27] call assertType 
  //SEG89 [75] phi from main::@11 to assertType [phi:main::@11->assertType]
  assertType_from_b11:
  //SEG90 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@11->assertType#0] -- register_copy 
  //SEG91 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG92 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG93 [28] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  b12_from_b11:
    jmp b12
  //SEG94 main::@12
  b12:
  //SEG95 [29] call assertType 
  //SEG96 [75] phi from main::@12 to assertType [phi:main::@12->assertType]
  assertType_from_b12:
  //SEG97 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@12->assertType#0] -- register_copy 
  //SEG98 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG99 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG100 [30] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
  b13_from_b12:
    jmp b13
  //SEG101 main::@13
  b13:
  //SEG102 [31] call assertType 
  //SEG103 [75] phi from main::@13 to assertType [phi:main::@13->assertType]
  assertType_from_b13:
  //SEG104 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@13->assertType#0] -- register_copy 
  //SEG105 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG106 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG107 [32] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
  b14_from_b13:
    jmp b14
  //SEG108 main::@14
  b14:
  //SEG109 [33] call assertType 
  //SEG110 [75] phi from main::@14 to assertType [phi:main::@14->assertType]
  assertType_from_b14:
  //SEG111 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@14->assertType#0] -- register_copy 
  //SEG112 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG113 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG114 [34] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  b15_from_b14:
    jmp b15
  //SEG115 main::@15
  b15:
  //SEG116 [35] call assertType 
  //SEG117 [75] phi from main::@15 to assertType [phi:main::@15->assertType]
  assertType_from_b15:
  //SEG118 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@15->assertType#0] -- register_copy 
  //SEG119 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG120 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG121 [36] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
  b16_from_b15:
    jmp b16
  //SEG122 main::@16
  b16:
  //SEG123 [37] call assertType 
  //SEG124 [75] phi from main::@16 to assertType [phi:main::@16->assertType]
  assertType_from_b16:
  //SEG125 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@16->assertType#0] -- register_copy 
  //SEG126 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG127 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG128 [38] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
  b17_from_b16:
    jmp b17
  //SEG129 main::@17
  b17:
  //SEG130 [39] call assertType 
  //SEG131 [75] phi from main::@17 to assertType [phi:main::@17->assertType]
  assertType_from_b17:
  //SEG132 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@17->assertType#0] -- register_copy 
  //SEG133 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG134 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG135 [40] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  b18_from_b17:
    jmp b18
  //SEG136 main::@18
  b18:
  //SEG137 [41] call assertType 
  //SEG138 [75] phi from main::@18 to assertType [phi:main::@18->assertType]
  assertType_from_b18:
  //SEG139 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@18->assertType#0] -- register_copy 
  //SEG140 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG141 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG142 [42] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  b19_from_b18:
    jmp b19
  //SEG143 main::@19
  b19:
  //SEG144 [43] call assertType 
  //SEG145 [75] phi from main::@19 to assertType [phi:main::@19->assertType]
  assertType_from_b19:
  //SEG146 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@19->assertType#0] -- register_copy 
  //SEG147 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG148 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG149 [44] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  b20_from_b19:
    jmp b20
  //SEG150 main::@20
  b20:
  //SEG151 [45] call assertType 
  //SEG152 [75] phi from main::@20 to assertType [phi:main::@20->assertType]
  assertType_from_b20:
  //SEG153 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@20->assertType#0] -- register_copy 
  //SEG154 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG155 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG156 [46] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
  b21_from_b20:
    jmp b21
  //SEG157 main::@21
  b21:
  //SEG158 [47] call assertType 
  //SEG159 [75] phi from main::@21 to assertType [phi:main::@21->assertType]
  assertType_from_b21:
  //SEG160 [75] phi (byte) idx#79 = (byte) $50 [phi:main::@21->assertType#0] -- vbuxx=vbuc1 
    ldx #$50
  //SEG161 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG162 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
  //SEG163 [48] phi from main::@21 to main::@22 [phi:main::@21->main::@22]
  b22_from_b21:
    jmp b22
  //SEG164 main::@22
  b22:
  //SEG165 [49] call assertType 
  //SEG166 [75] phi from main::@22 to assertType [phi:main::@22->assertType]
  assertType_from_b22:
  //SEG167 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@22->assertType#0] -- register_copy 
  //SEG168 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG169 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
  //SEG170 [50] phi from main::@22 to main::@23 [phi:main::@22->main::@23]
  b23_from_b22:
    jmp b23
  //SEG171 main::@23
  b23:
  //SEG172 [51] call assertType 
  //SEG173 [75] phi from main::@23 to assertType [phi:main::@23->assertType]
  assertType_from_b23:
  //SEG174 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@23->assertType#0] -- register_copy 
  //SEG175 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG176 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
  //SEG177 [52] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
  b24_from_b23:
    jmp b24
  //SEG178 main::@24
  b24:
  //SEG179 [53] call assertType 
  //SEG180 [75] phi from main::@24 to assertType [phi:main::@24->assertType]
  assertType_from_b24:
  //SEG181 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@24->assertType#0] -- register_copy 
  //SEG182 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG183 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG184 [54] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
  b25_from_b24:
    jmp b25
  //SEG185 main::@25
  b25:
  //SEG186 [55] call assertType 
  //SEG187 [75] phi from main::@25 to assertType [phi:main::@25->assertType]
  assertType_from_b25:
  //SEG188 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@25->assertType#0] -- register_copy 
  //SEG189 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG190 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG191 [56] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
  b26_from_b25:
    jmp b26
  //SEG192 main::@26
  b26:
  //SEG193 [57] call assertType 
  //SEG194 [75] phi from main::@26 to assertType [phi:main::@26->assertType]
  assertType_from_b26:
  //SEG195 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@26->assertType#0] -- register_copy 
  //SEG196 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG197 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG198 [58] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
  b27_from_b26:
    jmp b27
  //SEG199 main::@27
  b27:
  //SEG200 [59] call assertType 
  //SEG201 [75] phi from main::@27 to assertType [phi:main::@27->assertType]
  assertType_from_b27:
  //SEG202 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@27->assertType#0] -- register_copy 
  //SEG203 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG204 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG205 [60] phi from main::@27 to main::@28 [phi:main::@27->main::@28]
  b28_from_b27:
    jmp b28
  //SEG206 main::@28
  b28:
  //SEG207 [61] call assertType 
  //SEG208 [75] phi from main::@28 to assertType [phi:main::@28->assertType]
  assertType_from_b28:
  //SEG209 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@28->assertType#0] -- register_copy 
  //SEG210 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG211 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG212 [62] phi from main::@28 to main::@29 [phi:main::@28->main::@29]
  b29_from_b28:
    jmp b29
  //SEG213 main::@29
  b29:
  //SEG214 [63] call assertType 
  //SEG215 [75] phi from main::@29 to assertType [phi:main::@29->assertType]
  assertType_from_b29:
  //SEG216 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@29->assertType#0] -- register_copy 
  //SEG217 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG218 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG219 [64] phi from main::@29 to main::@30 [phi:main::@29->main::@30]
  b30_from_b29:
    jmp b30
  //SEG220 main::@30
  b30:
  //SEG221 [65] call assertType 
  //SEG222 [75] phi from main::@30 to assertType [phi:main::@30->assertType]
  assertType_from_b30:
  //SEG223 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@30->assertType#0] -- register_copy 
  //SEG224 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG225 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG226 [66] phi from main::@30 to main::@31 [phi:main::@30->main::@31]
  b31_from_b30:
    jmp b31
  //SEG227 main::@31
  b31:
  //SEG228 [67] call assertType 
  //SEG229 [75] phi from main::@31 to assertType [phi:main::@31->assertType]
  assertType_from_b31:
  //SEG230 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@31->assertType#0] -- register_copy 
  //SEG231 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG232 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG233 [68] phi from main::@31 to main::@32 [phi:main::@31->main::@32]
  b32_from_b31:
    jmp b32
  //SEG234 main::@32
  b32:
  //SEG235 [69] call assertType 
  //SEG236 [75] phi from main::@32 to assertType [phi:main::@32->assertType]
  assertType_from_b32:
  //SEG237 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@32->assertType#0] -- register_copy 
  //SEG238 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG239 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG240 [70] phi from main::@32 to main::@33 [phi:main::@32->main::@33]
  b33_from_b32:
    jmp b33
  //SEG241 main::@33
  b33:
  //SEG242 [71] call assertType 
  //SEG243 [75] phi from main::@33 to assertType [phi:main::@33->assertType]
  assertType_from_b33:
  //SEG244 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@33->assertType#0] -- register_copy 
  //SEG245 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG246 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG247 [72] phi from main::@33 to main::@34 [phi:main::@33->main::@34]
  b34_from_b33:
    jmp b34
  //SEG248 main::@34
  b34:
  //SEG249 [73] call assertType 
  //SEG250 [75] phi from main::@34 to assertType [phi:main::@34->assertType]
  assertType_from_b34:
  //SEG251 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@34->assertType#0] -- register_copy 
  //SEG252 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@34->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG253 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@34->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    jmp breturn
  //SEG254 main::@return
  breturn:
  //SEG255 [74] return 
    rts
}
//SEG256 assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(Y) t1, byte zeropage(2) t2)
assertType: {
    .label t2 = 2
  //SEG257 [76] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp t2
    beq b1
    jmp b3
  //SEG258 assertType::@3
  b3:
  //SEG259 [77] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) RED#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta $d800,x
    jmp b2
  //SEG260 assertType::@2
  b2:
  //SEG261 [78] *((byte*)(word) $400 + (byte) idx#79) ← (byte) assertType::t1#35 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta $400,x
  //SEG262 [79] (byte) idx#40 ← ++ (byte) idx#79 -- vbuxx=_inc_vbuxx 
    inx
    jmp breturn
  //SEG263 assertType::@return
  breturn:
  //SEG264 [80] return 
    rts
  //SEG265 assertType::@1
  b1:
  //SEG266 [81] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta $d800,x
    jmp b2
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b6
Removing instruction jmp b7
Removing instruction jmp b8
Removing instruction jmp b9
Removing instruction jmp b10
Removing instruction jmp b11
Removing instruction jmp b12
Removing instruction jmp b13
Removing instruction jmp b14
Removing instruction jmp b15
Removing instruction jmp b16
Removing instruction jmp b17
Removing instruction jmp b18
Removing instruction jmp b19
Removing instruction jmp b20
Removing instruction jmp b21
Removing instruction jmp b22
Removing instruction jmp b23
Removing instruction jmp b24
Removing instruction jmp b25
Removing instruction jmp b26
Removing instruction jmp b27
Removing instruction jmp b28
Removing instruction jmp b29
Removing instruction jmp b30
Removing instruction jmp b31
Removing instruction jmp b32
Removing instruction jmp b33
Removing instruction jmp b34
Removing instruction jmp breturn
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing instruction ldy #TYPEID_SIGNED_BYTE with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_main:
Removing instruction assertType_from_b1:
Removing instruction b2_from_b1:
Removing instruction assertType_from_b2:
Removing instruction b3_from_b2:
Removing instruction assertType_from_b3:
Removing instruction b4_from_b3:
Removing instruction assertType_from_b4:
Removing instruction b5_from_b4:
Removing instruction assertType_from_b5:
Removing instruction b6_from_b5:
Removing instruction assertType_from_b6:
Removing instruction b7_from_b6:
Removing instruction assertType_from_b7:
Removing instruction b8_from_b7:
Removing instruction assertType_from_b8:
Removing instruction b9_from_b8:
Removing instruction assertType_from_b9:
Removing instruction b10_from_b9:
Removing instruction assertType_from_b10:
Removing instruction b11_from_b10:
Removing instruction assertType_from_b11:
Removing instruction b12_from_b11:
Removing instruction assertType_from_b12:
Removing instruction b13_from_b12:
Removing instruction assertType_from_b13:
Removing instruction b14_from_b13:
Removing instruction assertType_from_b14:
Removing instruction b15_from_b14:
Removing instruction assertType_from_b15:
Removing instruction b16_from_b15:
Removing instruction assertType_from_b16:
Removing instruction b17_from_b16:
Removing instruction assertType_from_b17:
Removing instruction b18_from_b17:
Removing instruction assertType_from_b18:
Removing instruction b19_from_b18:
Removing instruction assertType_from_b19:
Removing instruction b20_from_b19:
Removing instruction assertType_from_b20:
Removing instruction b21_from_b20:
Removing instruction assertType_from_b21:
Removing instruction b22_from_b21:
Removing instruction assertType_from_b22:
Removing instruction b23_from_b22:
Removing instruction assertType_from_b23:
Removing instruction b24_from_b23:
Removing instruction assertType_from_b24:
Removing instruction b25_from_b24:
Removing instruction assertType_from_b25:
Removing instruction b26_from_b25:
Removing instruction assertType_from_b26:
Removing instruction b27_from_b26:
Removing instruction assertType_from_b27:
Removing instruction b28_from_b27:
Removing instruction assertType_from_b28:
Removing instruction b29_from_b28:
Removing instruction assertType_from_b29:
Removing instruction b30_from_b29:
Removing instruction assertType_from_b30:
Removing instruction b31_from_b30:
Removing instruction assertType_from_b31:
Removing instruction b32_from_b31:
Removing instruction assertType_from_b32:
Removing instruction b33_from_b32:
Removing instruction assertType_from_b33:
Removing instruction b34_from_b33:
Removing instruction assertType_from_b34:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction assertType_from_main:
Removing instruction b1:
Removing instruction b2:
Removing instruction b3:
Removing instruction b4:
Removing instruction b5:
Removing instruction b6:
Removing instruction b7:
Removing instruction b8:
Removing instruction b9:
Removing instruction b10:
Removing instruction b11:
Removing instruction b12:
Removing instruction b13:
Removing instruction b14:
Removing instruction b15:
Removing instruction b16:
Removing instruction b17:
Removing instruction b18:
Removing instruction b19:
Removing instruction b20:
Removing instruction b21:
Removing instruction b22:
Removing instruction b23:
Removing instruction b24:
Removing instruction b25:
Removing instruction b26:
Removing instruction b27:
Removing instruction b28:
Removing instruction b29:
Removing instruction b30:
Removing instruction b31:
Removing instruction b32:
Removing instruction b33:
Removing instruction b34:
Removing instruction breturn:
Removing instruction b3:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) COLS
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte) 5
(byte) RED
(const byte) RED#0 RED = (byte) 2
(byte*) SCREEN
(const byte) TYPEID_BYTE TYPEID_BYTE = (number) 1
(const byte) TYPEID_DWORD TYPEID_DWORD = (number) 5
(const byte) TYPEID_SIGNED_BYTE TYPEID_SIGNED_BYTE = (number) 2
(const byte) TYPEID_SIGNED_DWORD TYPEID_SIGNED_DWORD = (number) 6
(const byte) TYPEID_SIGNED_WORD TYPEID_SIGNED_WORD = (number) 4
(const byte) TYPEID_WORD TYPEID_WORD = (number) 3
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(label) assertType::@1
(label) assertType::@2
(label) assertType::@3
(label) assertType::@return
(byte) assertType::t1
(byte) assertType::t1#35 reg byte y 1.0
(byte) assertType::t2
(byte) assertType::t2#35 t2 zp ZP_BYTE:2 2.0
(byte) idx
(byte) idx#40 reg byte x 0.9999999999999993
(byte) idx#79 reg byte x 14.400000000000007
(void()) main()
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@22
(label) main::@23
(label) main::@24
(label) main::@25
(label) main::@26
(label) main::@27
(label) main::@28
(label) main::@29
(label) main::@3
(label) main::@30
(label) main::@31
(label) main::@32
(label) main::@33
(label) main::@34
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return

reg byte y [ assertType::t1#35 ]
zp ZP_BYTE:2 [ assertType::t2#35 ]
reg byte x [ idx#79 idx#40 ]


FINAL ASSEMBLER
Score: 506

//SEG0 File Comments
// Tests conversion of numbers to correct int types
// See https://gitlab.com/camelot/kickc/issues/181
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_SIGNED_DWORD = 6
  .const TYPEID_BYTE = 1
  .const TYPEID_WORD = 3
  .const TYPEID_DWORD = 5
  .const RED = 2
  .const GREEN = 5
//SEG3 @begin
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
//SEG5 @1
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
//SEG9 @end
//SEG10 main
main: {
  //SEG11 [5] call assertType 
  //SEG12 [75] phi from main to assertType [phi:main->assertType]
  //SEG13 [75] phi (byte) idx#79 = (byte) 0 [phi:main->assertType#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG14 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t2
  //SEG15 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG16 [6] phi from main to main::@1 [phi:main->main::@1]
  //SEG17 main::@1
  //SEG18 [7] call assertType 
  //SEG19 [75] phi from main::@1 to assertType [phi:main::@1->assertType]
  //SEG20 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@1->assertType#0] -- register_copy 
  //SEG21 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG22 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG23 [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  //SEG24 main::@2
  //SEG25 [9] call assertType 
  //SEG26 [75] phi from main::@2 to assertType [phi:main::@2->assertType]
  //SEG27 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@2->assertType#0] -- register_copy 
  //SEG28 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG29 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG30 [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  //SEG31 main::@3
  //SEG32 [11] call assertType 
  //SEG33 [75] phi from main::@3 to assertType [phi:main::@3->assertType]
  //SEG34 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@3->assertType#0] -- register_copy 
  //SEG35 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG36 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG37 [12] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  //SEG38 main::@4
  //SEG39 [13] call assertType 
  //SEG40 [75] phi from main::@4 to assertType [phi:main::@4->assertType]
  //SEG41 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@4->assertType#0] -- register_copy 
  //SEG42 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG43 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG44 [14] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  //SEG45 main::@5
  //SEG46 [15] call assertType 
  //SEG47 [75] phi from main::@5 to assertType [phi:main::@5->assertType]
  //SEG48 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@5->assertType#0] -- register_copy 
  //SEG49 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG50 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG51 [16] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  //SEG52 main::@6
  //SEG53 [17] call assertType 
  //SEG54 [75] phi from main::@6 to assertType [phi:main::@6->assertType]
  //SEG55 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@6->assertType#0] -- register_copy 
  //SEG56 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG57 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG58 [18] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  //SEG59 main::@7
  //SEG60 [19] call assertType 
  //SEG61 [75] phi from main::@7 to assertType [phi:main::@7->assertType]
  //SEG62 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@7->assertType#0] -- register_copy 
  //SEG63 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG64 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG65 [20] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  //SEG66 main::@8
  //SEG67 [21] call assertType 
  //SEG68 [75] phi from main::@8 to assertType [phi:main::@8->assertType]
  //SEG69 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@8->assertType#0] -- register_copy 
  //SEG70 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG71 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG72 [22] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
  //SEG73 main::@9
  //SEG74 [23] call assertType 
  //SEG75 [75] phi from main::@9 to assertType [phi:main::@9->assertType]
  //SEG76 [75] phi (byte) idx#79 = (byte) $28 [phi:main::@9->assertType#0] -- vbuxx=vbuc1 
    ldx #$28
  //SEG77 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG78 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG79 [24] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  //SEG80 main::@10
  //SEG81 [25] call assertType 
  //SEG82 [75] phi from main::@10 to assertType [phi:main::@10->assertType]
  //SEG83 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@10->assertType#0] -- register_copy 
  //SEG84 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG85 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG86 [26] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  //SEG87 main::@11
  //SEG88 [27] call assertType 
  //SEG89 [75] phi from main::@11 to assertType [phi:main::@11->assertType]
  //SEG90 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@11->assertType#0] -- register_copy 
  //SEG91 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG92 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG93 [28] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  //SEG94 main::@12
  //SEG95 [29] call assertType 
  //SEG96 [75] phi from main::@12 to assertType [phi:main::@12->assertType]
  //SEG97 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@12->assertType#0] -- register_copy 
  //SEG98 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG99 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG100 [30] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
  //SEG101 main::@13
  //SEG102 [31] call assertType 
  //SEG103 [75] phi from main::@13 to assertType [phi:main::@13->assertType]
  //SEG104 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@13->assertType#0] -- register_copy 
  //SEG105 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG106 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG107 [32] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
  //SEG108 main::@14
  //SEG109 [33] call assertType 
  //SEG110 [75] phi from main::@14 to assertType [phi:main::@14->assertType]
  //SEG111 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@14->assertType#0] -- register_copy 
  //SEG112 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG113 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG114 [34] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  //SEG115 main::@15
  //SEG116 [35] call assertType 
  //SEG117 [75] phi from main::@15 to assertType [phi:main::@15->assertType]
  //SEG118 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@15->assertType#0] -- register_copy 
  //SEG119 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG120 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG121 [36] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
  //SEG122 main::@16
  //SEG123 [37] call assertType 
  //SEG124 [75] phi from main::@16 to assertType [phi:main::@16->assertType]
  //SEG125 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@16->assertType#0] -- register_copy 
  //SEG126 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG127 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG128 [38] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
  //SEG129 main::@17
  //SEG130 [39] call assertType 
  //SEG131 [75] phi from main::@17 to assertType [phi:main::@17->assertType]
  //SEG132 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@17->assertType#0] -- register_copy 
  //SEG133 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG134 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG135 [40] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  //SEG136 main::@18
  //SEG137 [41] call assertType 
  //SEG138 [75] phi from main::@18 to assertType [phi:main::@18->assertType]
  //SEG139 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@18->assertType#0] -- register_copy 
  //SEG140 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG141 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG142 [42] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  //SEG143 main::@19
  //SEG144 [43] call assertType 
  //SEG145 [75] phi from main::@19 to assertType [phi:main::@19->assertType]
  //SEG146 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@19->assertType#0] -- register_copy 
  //SEG147 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG148 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG149 [44] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  //SEG150 main::@20
  //SEG151 [45] call assertType 
  //SEG152 [75] phi from main::@20 to assertType [phi:main::@20->assertType]
  //SEG153 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@20->assertType#0] -- register_copy 
  //SEG154 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG155 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG156 [46] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
  //SEG157 main::@21
  //SEG158 [47] call assertType 
  //SEG159 [75] phi from main::@21 to assertType [phi:main::@21->assertType]
  //SEG160 [75] phi (byte) idx#79 = (byte) $50 [phi:main::@21->assertType#0] -- vbuxx=vbuc1 
    ldx #$50
  //SEG161 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG162 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG163 [48] phi from main::@21 to main::@22 [phi:main::@21->main::@22]
  //SEG164 main::@22
  //SEG165 [49] call assertType 
  //SEG166 [75] phi from main::@22 to assertType [phi:main::@22->assertType]
  //SEG167 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@22->assertType#0] -- register_copy 
  //SEG168 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG169 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG170 [50] phi from main::@22 to main::@23 [phi:main::@22->main::@23]
  //SEG171 main::@23
  //SEG172 [51] call assertType 
  //SEG173 [75] phi from main::@23 to assertType [phi:main::@23->assertType]
  //SEG174 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@23->assertType#0] -- register_copy 
  //SEG175 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG176 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG177 [52] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
  //SEG178 main::@24
  //SEG179 [53] call assertType 
  //SEG180 [75] phi from main::@24 to assertType [phi:main::@24->assertType]
  //SEG181 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@24->assertType#0] -- register_copy 
  //SEG182 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG183 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG184 [54] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
  //SEG185 main::@25
  //SEG186 [55] call assertType 
  //SEG187 [75] phi from main::@25 to assertType [phi:main::@25->assertType]
  //SEG188 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@25->assertType#0] -- register_copy 
  //SEG189 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG190 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG191 [56] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
  //SEG192 main::@26
  //SEG193 [57] call assertType 
  //SEG194 [75] phi from main::@26 to assertType [phi:main::@26->assertType]
  //SEG195 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@26->assertType#0] -- register_copy 
  //SEG196 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG197 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG198 [58] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
  //SEG199 main::@27
  //SEG200 [59] call assertType 
  //SEG201 [75] phi from main::@27 to assertType [phi:main::@27->assertType]
  //SEG202 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@27->assertType#0] -- register_copy 
  //SEG203 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG204 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG205 [60] phi from main::@27 to main::@28 [phi:main::@27->main::@28]
  //SEG206 main::@28
  //SEG207 [61] call assertType 
  //SEG208 [75] phi from main::@28 to assertType [phi:main::@28->assertType]
  //SEG209 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@28->assertType#0] -- register_copy 
  //SEG210 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG211 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG212 [62] phi from main::@28 to main::@29 [phi:main::@28->main::@29]
  //SEG213 main::@29
  //SEG214 [63] call assertType 
  //SEG215 [75] phi from main::@29 to assertType [phi:main::@29->assertType]
  //SEG216 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@29->assertType#0] -- register_copy 
  //SEG217 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG218 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG219 [64] phi from main::@29 to main::@30 [phi:main::@29->main::@30]
  //SEG220 main::@30
  //SEG221 [65] call assertType 
  //SEG222 [75] phi from main::@30 to assertType [phi:main::@30->assertType]
  //SEG223 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@30->assertType#0] -- register_copy 
  //SEG224 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG225 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG226 [66] phi from main::@30 to main::@31 [phi:main::@30->main::@31]
  //SEG227 main::@31
  //SEG228 [67] call assertType 
  //SEG229 [75] phi from main::@31 to assertType [phi:main::@31->assertType]
  //SEG230 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@31->assertType#0] -- register_copy 
  //SEG231 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG232 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG233 [68] phi from main::@31 to main::@32 [phi:main::@31->main::@32]
  //SEG234 main::@32
  //SEG235 [69] call assertType 
  //SEG236 [75] phi from main::@32 to assertType [phi:main::@32->assertType]
  //SEG237 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@32->assertType#0] -- register_copy 
  //SEG238 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG239 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG240 [70] phi from main::@32 to main::@33 [phi:main::@32->main::@33]
  //SEG241 main::@33
  //SEG242 [71] call assertType 
  //SEG243 [75] phi from main::@33 to assertType [phi:main::@33->assertType]
  //SEG244 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@33->assertType#0] -- register_copy 
  //SEG245 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG246 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG247 [72] phi from main::@33 to main::@34 [phi:main::@33->main::@34]
  //SEG248 main::@34
  //SEG249 [73] call assertType 
  //SEG250 [75] phi from main::@34 to assertType [phi:main::@34->assertType]
  //SEG251 [75] phi (byte) idx#79 = (byte) idx#40 [phi:main::@34->assertType#0] -- register_copy 
  //SEG252 [75] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@34->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG253 [75] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@34->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
  //SEG254 main::@return
  //SEG255 [74] return 
    rts
}
//SEG256 assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(Y) t1, byte zeropage(2) t2)
assertType: {
    .label t2 = 2
  //SEG257 [76] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp t2
    beq b1
  //SEG258 assertType::@3
  //SEG259 [77] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) RED#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta $d800,x
  //SEG260 assertType::@2
  b2:
  //SEG261 [78] *((byte*)(word) $400 + (byte) idx#79) ← (byte) assertType::t1#35 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta $400,x
  //SEG262 [79] (byte) idx#40 ← ++ (byte) idx#79 -- vbuxx=_inc_vbuxx 
    inx
  //SEG263 assertType::@return
  //SEG264 [80] return 
    rts
  //SEG265 assertType::@1
  b1:
  //SEG266 [81] *((byte*)(word) $d800 + (byte) idx#79) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta $d800,x
    jmp b2
}

