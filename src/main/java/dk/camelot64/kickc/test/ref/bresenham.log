byte STAR = 81;
byte[40*25] SCREEN = $0400;
byte x0 = 0;
byte y0 = 0;
byte x1 = 39;
byte y1 = 24;
byte xd = x1-x0;
byte yd = y1-y0;
byte x = x0;
byte y = y0;
byte e = yd/2;
byte *cursor = SCREEN+y*40+x;
do  {
    *cursor = STAR;
    x = x + 1;
    cursor = cursor + 1;
    e = e+yd;
    if(xd<e) {
        y = y+1;
        cursor = cursor + 40;
        e = e - xd;
    }
}  while (x<(x1+1))

PROGRAM
  (byte) STAR ← (byte) 81
  (byte[1000]) SCREEN ← (word) 1024
  (byte) x0 ← (byte) 0
  (byte) y0 ← (byte) 0
  (byte) x1 ← (byte) 39
  (byte) y1 ← (byte) 24
  (byte~) $0 ← (byte) x1 - (byte) x0
  (byte) xd ← (byte~) $0
  (byte~) $1 ← (byte) y1 - (byte) y0
  (byte) yd ← (byte~) $1
  (byte) x ← (byte) x0
  (byte) y ← (byte) y0
  (byte~) $2 ← (byte) yd / (byte) 2
  (byte) e ← (byte~) $2
  (byte~) $3 ← (byte) y * (byte) 40
  (byte*~) $4 ← (byte[1000]) SCREEN + (byte~) $3
  (byte*~) $5 ← (byte*~) $4 + (byte) x
  (byte*) cursor ← (byte*~) $5
@1:
  *((byte*) cursor) ← (byte) STAR
  (byte~) $6 ← (byte) x + (byte) 1
  (byte) x ← (byte~) $6
  (byte*~) $7 ← (byte*) cursor + (byte) 1
  (byte*) cursor ← (byte*~) $7
  (byte~) $8 ← (byte) e + (byte) yd
  (byte) e ← (byte~) $8
  (boolean~) $9 ← (byte) xd < (byte) e
  if((boolean~) $9) goto @2
  goto @3
@2:
  (byte~) $10 ← (byte) y + (byte) 1
  (byte) y ← (byte~) $10
  (byte*~) $11 ← (byte*) cursor + (byte) 40
  (byte*) cursor ← (byte*~) $11
  (byte~) $12 ← (byte) e - (byte) xd
  (byte) e ← (byte~) $12
@3:
  (byte~) $13 ← (byte) x1 + (byte) 1
  (boolean~) $14 ← (byte) x < (byte~) $13
  if((boolean~) $14) goto @1

SYMBOLS
(byte~) $0
(byte~) $1
(byte~) $10
(byte*~) $11
(byte~) $12
(byte~) $13
(boolean~) $14
(byte~) $2
(byte~) $3
(byte*~) $4
(byte*~) $5
(byte~) $6
(byte*~) $7
(byte~) $8
(boolean~) $9
(label) @1
(label) @2
(label) @3
(byte[1000]) SCREEN
(byte) STAR
(byte*) cursor
(byte) e
(byte) x
(byte) x0
(byte) x1
(byte) xd
(byte) y
(byte) y0
(byte) y1
(byte) yd

INITIAL CONTROL FLOW GRAPH
@BEGIN: from
  (byte) STAR ← (byte) 81
  (byte[1000]) SCREEN ← (word) 1024
  (byte) x0 ← (byte) 0
  (byte) y0 ← (byte) 0
  (byte) x1 ← (byte) 39
  (byte) y1 ← (byte) 24
  (byte~) $0 ← (byte) x1 - (byte) x0
  (byte) xd ← (byte~) $0
  (byte~) $1 ← (byte) y1 - (byte) y0
  (byte) yd ← (byte~) $1
  (byte) x ← (byte) x0
  (byte) y ← (byte) y0
  (byte~) $2 ← (byte) yd / (byte) 2
  (byte) e ← (byte~) $2
  (byte~) $3 ← (byte) y * (byte) 40
  (byte*~) $4 ← (byte[1000]) SCREEN + (byte~) $3
  (byte*~) $5 ← (byte*~) $4 + (byte) x
  (byte*) cursor ← (byte*~) $5
  to:@1
@1: from @3 @BEGIN
  *((byte*) cursor) ← (byte) STAR
  (byte~) $6 ← (byte) x + (byte) 1
  (byte) x ← (byte~) $6
  (byte*~) $7 ← (byte*) cursor + (byte) 1
  (byte*) cursor ← (byte*~) $7
  (byte~) $8 ← (byte) e + (byte) yd
  (byte) e ← (byte~) $8
  (boolean~) $9 ← (byte) xd < (byte) e
  if((boolean~) $9) goto @2
  to:@4
@2: from @1 @5
  (byte~) $10 ← (byte) y + (byte) 1
  (byte) y ← (byte~) $10
  (byte*~) $11 ← (byte*) cursor + (byte) 40
  (byte*) cursor ← (byte*~) $11
  (byte~) $12 ← (byte) e - (byte) xd
  (byte) e ← (byte~) $12
  to:@3
@4: from @1
  to:@3
@3: from @2 @4
  (byte~) $13 ← (byte) x1 + (byte) 1
  (boolean~) $14 ← (byte) x < (byte~) $13
  if((boolean~) $14) goto @1
  to:@6
@5: from
  to:@2
@6: from @3
  to:@END
@END: from @6

Removing empty block @4
Removing empty block @5
Removing empty block @6
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) STAR ← (byte) 81
  (byte[1000]) SCREEN ← (word) 1024
  (byte) x0 ← (byte) 0
  (byte) y0 ← (byte) 0
  (byte) x1 ← (byte) 39
  (byte) y1 ← (byte) 24
  (byte~) $0 ← (byte) x1 - (byte) x0
  (byte) xd ← (byte~) $0
  (byte~) $1 ← (byte) y1 - (byte) y0
  (byte) yd ← (byte~) $1
  (byte) x ← (byte) x0
  (byte) y ← (byte) y0
  (byte~) $2 ← (byte) yd / (byte) 2
  (byte) e ← (byte~) $2
  (byte~) $3 ← (byte) y * (byte) 40
  (byte*~) $4 ← (byte[1000]) SCREEN + (byte~) $3
  (byte*~) $5 ← (byte*~) $4 + (byte) x
  (byte*) cursor ← (byte*~) $5
  to:@1
@1: from @3 @BEGIN
  *((byte*) cursor) ← (byte) STAR
  (byte~) $6 ← (byte) x + (byte) 1
  (byte) x ← (byte~) $6
  (byte*~) $7 ← (byte*) cursor + (byte) 1
  (byte*) cursor ← (byte*~) $7
  (byte~) $8 ← (byte) e + (byte) yd
  (byte) e ← (byte~) $8
  (boolean~) $9 ← (byte) xd < (byte) e
  if((boolean~) $9) goto @2
  to:@3
@2: from @1
  (byte~) $10 ← (byte) y + (byte) 1
  (byte) y ← (byte~) $10
  (byte*~) $11 ← (byte*) cursor + (byte) 40
  (byte*) cursor ← (byte*~) $11
  (byte~) $12 ← (byte) e - (byte) xd
  (byte) e ← (byte~) $12
  to:@3
@3: from @1 @2
  (byte~) $13 ← (byte) x1 + (byte) 1
  (boolean~) $14 ← (byte) x < (byte~) $13
  if((boolean~) $14) goto @1
  to:@END
@END: from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@BEGIN: from
  (byte) STAR ← (byte) 81
  (byte[1000]) SCREEN ← (word) 1024
  (byte) x0 ← (byte) 0
  (byte) y0 ← (byte) 0
  (byte) x1 ← (byte) 39
  (byte) y1 ← (byte) 24
  (byte~) $0 ← (byte) x1 - (byte) x0
  (byte) xd ← (byte~) $0
  (byte~) $1 ← (byte) y1 - (byte) y0
  (byte) yd ← (byte~) $1
  (byte) x ← (byte) x0
  (byte) y ← (byte) y0
  (byte~) $2 ← (byte) yd / (byte) 2
  (byte) e ← (byte~) $2
  (byte~) $3 ← (byte) y * (byte) 40
  (byte*~) $4 ← (byte[1000]) SCREEN + (byte~) $3
  (byte*~) $5 ← (byte*~) $4 + (byte) x
  (byte*) cursor ← (byte*~) $5
  to:@1
@1: from @3 @BEGIN
  *((byte*) cursor) ← (byte) STAR
  (byte~) $6 ← (byte) x + (byte) 1
  (byte) x ← (byte~) $6
  (byte*~) $7 ← (byte*) cursor + (byte) 1
  (byte*) cursor ← (byte*~) $7
  (byte~) $8 ← (byte) e + (byte) yd
  (byte) e ← (byte~) $8
  (boolean~) $9 ← (byte) xd < (byte) e
  if((boolean~) $9) goto @2
  to:@3
@2: from @1
  (byte~) $10 ← (byte) y + (byte) 1
  (byte) y ← (byte~) $10
  (byte*~) $11 ← (byte*) cursor + (byte) 40
  (byte*) cursor ← (byte*~) $11
  (byte~) $12 ← (byte) e - (byte) xd
  (byte) e ← (byte~) $12
  to:@3
@3: from @1 @2
  (byte~) $13 ← (byte) x1 + (byte) 1
  (boolean~) $14 ← (byte) x < (byte~) $13
  if((boolean~) $14) goto @1
  to:@END
@END: from @3

Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@BEGIN: from
  (byte) STAR#0 ← (byte) 81
  (byte[1000]) SCREEN#0 ← (word) 1024
  (byte) x0#0 ← (byte) 0
  (byte) y0#0 ← (byte) 0
  (byte) x1#0 ← (byte) 39
  (byte) y1#0 ← (byte) 24
  (byte~) $0 ← (byte) x1#0 - (byte) x0#0
  (byte) xd#0 ← (byte~) $0
  (byte~) $1 ← (byte) y1#0 - (byte) y0#0
  (byte) yd#0 ← (byte~) $1
  (byte) x#0 ← (byte) x0#0
  (byte) y#0 ← (byte) y0#0
  (byte~) $2 ← (byte) yd#0 / (byte) 2
  (byte) e#0 ← (byte~) $2
  (byte~) $3 ← (byte) y#0 * (byte) 40
  (byte*~) $4 ← (byte[1000]) SCREEN#0 + (byte~) $3
  (byte*~) $5 ← (byte*~) $4 + (byte) x#0
  (byte*) cursor#0 ← (byte*~) $5
  to:@1
@1: from @3 @BEGIN
  (byte) x1#2 ← phi( @3/(byte) x1#1 @BEGIN/(byte) x1#0 )
  (byte) y#3 ← phi( @3/(byte) y#4 @BEGIN/(byte) y#0 )
  (byte) xd#1 ← phi( @3/(byte) xd#3 @BEGIN/(byte) xd#0 )
  (byte) yd#1 ← phi( @3/(byte) yd#2 @BEGIN/(byte) yd#0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#3 @BEGIN/(byte) x#0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  (byte) STAR#1 ← phi( @3/(byte) STAR#2 @BEGIN/(byte) STAR#0 )
  *((byte*) cursor#3) ← (byte) STAR#1
  (byte~) $6 ← (byte) x#2 + (byte) 1
  (byte) x#1 ← (byte~) $6
  (byte*~) $7 ← (byte*) cursor#3 + (byte) 1
  (byte*) cursor#1 ← (byte*~) $7
  (byte~) $8 ← (byte) e#3 + (byte) yd#1
  (byte) e#1 ← (byte~) $8
  (boolean~) $9 ← (byte) xd#1 < (byte) e#1
  if((boolean~) $9) goto @2
  to:@3
@2: from @1
  (byte) yd#3 ← phi( @1/(byte) yd#1 )
  (byte) STAR#3 ← phi( @1/(byte) STAR#1 )
  (byte) x#4 ← phi( @1/(byte) x#1 )
  (byte) x1#3 ← phi( @1/(byte) x1#2 )
  (byte) xd#2 ← phi( @1/(byte) xd#1 )
  (byte) e#4 ← phi( @1/(byte) e#1 )
  (byte*) cursor#4 ← phi( @1/(byte*) cursor#1 )
  (byte) y#2 ← phi( @1/(byte) y#3 )
  (byte~) $10 ← (byte) y#2 + (byte) 1
  (byte) y#1 ← (byte~) $10
  (byte*~) $11 ← (byte*) cursor#4 + (byte) 40
  (byte*) cursor#2 ← (byte*~) $11
  (byte~) $12 ← (byte) e#4 - (byte) xd#2
  (byte) e#2 ← (byte~) $12
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#3 @2/(byte) y#1 )
  (byte) xd#3 ← phi( @1/(byte) xd#1 @2/(byte) xd#2 )
  (byte) yd#2 ← phi( @1/(byte) yd#1 @2/(byte) yd#3 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte) STAR#2 ← phi( @1/(byte) STAR#1 @2/(byte) STAR#3 )
  (byte) x#3 ← phi( @1/(byte) x#1 @2/(byte) x#4 )
  (byte) x1#1 ← phi( @1/(byte) x1#2 @2/(byte) x1#3 )
  (byte~) $13 ← (byte) x1#1 + (byte) 1
  (boolean~) $14 ← (byte) x#3 < (byte~) $13
  if((boolean~) $14) goto @1
  to:@END
@END: from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@BEGIN: from
  (byte) STAR#0 ← (byte) 81
  (byte[1000]) SCREEN#0 ← (word) 1024
  (byte) x0#0 ← (byte) 0
  (byte) y0#0 ← (byte) 0
  (byte) x1#0 ← (byte) 39
  (byte) y1#0 ← (byte) 24
  (byte~) $0 ← (byte) x1#0 - (byte) x0#0
  (byte) xd#0 ← (byte~) $0
  (byte~) $1 ← (byte) y1#0 - (byte) y0#0
  (byte) yd#0 ← (byte~) $1
  (byte) x#0 ← (byte) x0#0
  (byte) y#0 ← (byte) y0#0
  (byte~) $2 ← (byte) yd#0 / (byte) 2
  (byte) e#0 ← (byte~) $2
  (byte~) $3 ← (byte) y#0 * (byte) 40
  (byte*~) $4 ← (byte[1000]) SCREEN#0 + (byte~) $3
  (byte*~) $5 ← (byte*~) $4 + (byte) x#0
  (byte*) cursor#0 ← (byte*~) $5
  to:@1
@1: from @3 @BEGIN
  (byte) x1#2 ← phi( @3/(byte) x1#1 @BEGIN/(byte) x1#0 )
  (byte) y#3 ← phi( @3/(byte) y#4 @BEGIN/(byte) y#0 )
  (byte) xd#1 ← phi( @3/(byte) xd#3 @BEGIN/(byte) xd#0 )
  (byte) yd#1 ← phi( @3/(byte) yd#2 @BEGIN/(byte) yd#0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#3 @BEGIN/(byte) x#0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  (byte) STAR#1 ← phi( @3/(byte) STAR#2 @BEGIN/(byte) STAR#0 )
  *((byte*) cursor#3) ← (byte) STAR#1
  (byte~) $6 ← (byte) x#2 + (byte) 1
  (byte) x#1 ← (byte~) $6
  (byte*~) $7 ← (byte*) cursor#3 + (byte) 1
  (byte*) cursor#1 ← (byte*~) $7
  (byte~) $8 ← (byte) e#3 + (byte) yd#1
  (byte) e#1 ← (byte~) $8
  (boolean~) $9 ← (byte) xd#1 < (byte) e#1
  if((boolean~) $9) goto @2
  to:@3
@2: from @1
  (byte) yd#3 ← phi( @1/(byte) yd#1 )
  (byte) STAR#3 ← phi( @1/(byte) STAR#1 )
  (byte) x#4 ← phi( @1/(byte) x#1 )
  (byte) x1#3 ← phi( @1/(byte) x1#2 )
  (byte) xd#2 ← phi( @1/(byte) xd#1 )
  (byte) e#4 ← phi( @1/(byte) e#1 )
  (byte*) cursor#4 ← phi( @1/(byte*) cursor#1 )
  (byte) y#2 ← phi( @1/(byte) y#3 )
  (byte~) $10 ← (byte) y#2 + (byte) 1
  (byte) y#1 ← (byte~) $10
  (byte*~) $11 ← (byte*) cursor#4 + (byte) 40
  (byte*) cursor#2 ← (byte*~) $11
  (byte~) $12 ← (byte) e#4 - (byte) xd#2
  (byte) e#2 ← (byte~) $12
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#3 @2/(byte) y#1 )
  (byte) xd#3 ← phi( @1/(byte) xd#1 @2/(byte) xd#2 )
  (byte) yd#2 ← phi( @1/(byte) yd#1 @2/(byte) yd#3 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte) STAR#2 ← phi( @1/(byte) STAR#1 @2/(byte) STAR#3 )
  (byte) x#3 ← phi( @1/(byte) x#1 @2/(byte) x#4 )
  (byte) x1#1 ← phi( @1/(byte) x1#2 @2/(byte) x1#3 )
  (byte~) $13 ← (byte) x1#1 + (byte) 1
  (boolean~) $14 ← (byte) x#3 < (byte~) $13
  if((boolean~) $14) goto @1
  to:@END
@END: from @3

Constant (byte) STAR#0 (byte) 81
Constant (byte[1000]) SCREEN#0 (word) 1024
Constant (byte) x0#0 (byte) 0
Constant (byte) y0#0 (byte) 0
Constant (byte) x1#0 (byte) 39
Constant (byte) y1#0 (byte) 24
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  (byte~) $0 ← (byte) 39 - (byte) 0
  (byte) xd#0 ← (byte~) $0
  (byte~) $1 ← (byte) 24 - (byte) 0
  (byte) yd#0 ← (byte~) $1
  (byte) x#0 ← (byte) 0
  (byte) y#0 ← (byte) 0
  (byte~) $2 ← (byte) yd#0 / (byte) 2
  (byte) e#0 ← (byte~) $2
  (byte~) $3 ← (byte) y#0 * (byte) 40
  (byte*~) $4 ← (word) 1024 + (byte~) $3
  (byte*~) $5 ← (byte*~) $4 + (byte) x#0
  (byte*) cursor#0 ← (byte*~) $5
  to:@1
@1: from @3 @BEGIN
  (byte) x1#2 ← phi( @3/(byte) x1#1 @BEGIN/(byte) 39 )
  (byte) y#3 ← phi( @3/(byte) y#4 @BEGIN/(byte) y#0 )
  (byte) xd#1 ← phi( @3/(byte) xd#3 @BEGIN/(byte) xd#0 )
  (byte) yd#1 ← phi( @3/(byte) yd#2 @BEGIN/(byte) yd#0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#3 @BEGIN/(byte) x#0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  (byte) STAR#1 ← phi( @3/(byte) STAR#2 @BEGIN/(byte) 81 )
  *((byte*) cursor#3) ← (byte) STAR#1
  (byte~) $6 ← (byte) x#2 + (byte) 1
  (byte) x#1 ← (byte~) $6
  (byte*~) $7 ← (byte*) cursor#3 + (byte) 1
  (byte*) cursor#1 ← (byte*~) $7
  (byte~) $8 ← (byte) e#3 + (byte) yd#1
  (byte) e#1 ← (byte~) $8
  (boolean~) $9 ← (byte) xd#1 < (byte) e#1
  if((boolean~) $9) goto @2
  to:@3
@2: from @1
  (byte) yd#3 ← phi( @1/(byte) yd#1 )
  (byte) STAR#3 ← phi( @1/(byte) STAR#1 )
  (byte) x#4 ← phi( @1/(byte) x#1 )
  (byte) x1#3 ← phi( @1/(byte) x1#2 )
  (byte) xd#2 ← phi( @1/(byte) xd#1 )
  (byte) e#4 ← phi( @1/(byte) e#1 )
  (byte*) cursor#4 ← phi( @1/(byte*) cursor#1 )
  (byte) y#2 ← phi( @1/(byte) y#3 )
  (byte~) $10 ← (byte) y#2 + (byte) 1
  (byte) y#1 ← (byte~) $10
  (byte*~) $11 ← (byte*) cursor#4 + (byte) 40
  (byte*) cursor#2 ← (byte*~) $11
  (byte~) $12 ← (byte) e#4 - (byte) xd#2
  (byte) e#2 ← (byte~) $12
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#3 @2/(byte) y#1 )
  (byte) xd#3 ← phi( @1/(byte) xd#1 @2/(byte) xd#2 )
  (byte) yd#2 ← phi( @1/(byte) yd#1 @2/(byte) yd#3 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte) STAR#2 ← phi( @1/(byte) STAR#1 @2/(byte) STAR#3 )
  (byte) x#3 ← phi( @1/(byte) x#1 @2/(byte) x#4 )
  (byte) x1#1 ← phi( @1/(byte) x1#2 @2/(byte) x1#3 )
  (byte~) $13 ← (byte) x1#1 + (byte) 1
  (boolean~) $14 ← (byte) x#3 < (byte~) $13
  if((boolean~) $14) goto @1
  to:@END
@END: from @3

Multiple usages for variable. Not optimizing sub-constant (byte) x1#1
Alias (byte) xd#0 = (byte~) $0 
Alias (byte) yd#0 = (byte~) $1 
Alias (byte) e#0 = (byte~) $2 
Alias (byte*) cursor#0 = (byte*~) $5 
Alias (byte) x#1 = (byte~) $6 (byte) x#4 
Alias (byte*) cursor#1 = (byte*~) $7 (byte*) cursor#4 
Alias (byte) e#1 = (byte~) $8 (byte) e#4 
Alias (byte) y#2 = (byte) y#3 
Alias (byte) xd#1 = (byte) xd#2 
Alias (byte) x1#2 = (byte) x1#3 
Alias (byte) STAR#1 = (byte) STAR#3 
Alias (byte) yd#1 = (byte) yd#3 
Alias (byte) y#1 = (byte~) $10 
Alias (byte*) cursor#2 = (byte*~) $11 
Alias (byte) e#2 = (byte~) $12 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) xd#0 ← (byte) 39 - (byte) 0
  (byte) yd#0 ← (byte) 24 - (byte) 0
  (byte) x#0 ← (byte) 0
  (byte) y#0 ← (byte) 0
  (byte) e#0 ← (byte) yd#0 / (byte) 2
  (byte~) $3 ← (byte) y#0 * (byte) 40
  (byte*~) $4 ← (word) 1024 + (byte~) $3
  (byte*) cursor#0 ← (byte*~) $4 + (byte) x#0
  to:@1
@1: from @3 @BEGIN
  (byte) x1#2 ← phi( @3/(byte) x1#1 @BEGIN/(byte) 39 )
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) y#0 )
  (byte) xd#1 ← phi( @3/(byte) xd#3 @BEGIN/(byte) xd#0 )
  (byte) yd#1 ← phi( @3/(byte) yd#2 @BEGIN/(byte) yd#0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#3 @BEGIN/(byte) x#0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  (byte) STAR#1 ← phi( @3/(byte) STAR#2 @BEGIN/(byte) 81 )
  *((byte*) cursor#3) ← (byte) STAR#1
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) yd#1
  (boolean~) $9 ← (byte) xd#1 < (byte) e#1
  if((boolean~) $9) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) xd#1
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) xd#3 ← phi( @1/(byte) xd#1 @2/(byte) xd#1 )
  (byte) yd#2 ← phi( @1/(byte) yd#1 @2/(byte) yd#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte) STAR#2 ← phi( @1/(byte) STAR#1 @2/(byte) STAR#1 )
  (byte) x#3 ← phi( @1/(byte) x#1 @2/(byte) x#1 )
  (byte) x1#1 ← phi( @1/(byte) x1#2 @2/(byte) x1#2 )
  (byte~) $13 ← (byte) x1#1 + (byte) 1
  (boolean~) $14 ← (byte) x#3 < (byte~) $13
  if((boolean~) $14) goto @1
  to:@END
@END: from @3

Redundant Phi (byte) x1#1 (byte) x1#2
Redundant Phi (byte) x#3 (byte) x#1
Redundant Phi (byte) STAR#2 (byte) STAR#1
Redundant Phi (byte) yd#2 (byte) yd#1
Redundant Phi (byte) xd#3 (byte) xd#1
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) xd#0 ← (byte) 39 - (byte) 0
  (byte) yd#0 ← (byte) 24 - (byte) 0
  (byte) x#0 ← (byte) 0
  (byte) y#0 ← (byte) 0
  (byte) e#0 ← (byte) yd#0 / (byte) 2
  (byte~) $3 ← (byte) y#0 * (byte) 40
  (byte*~) $4 ← (word) 1024 + (byte~) $3
  (byte*) cursor#0 ← (byte*~) $4 + (byte) x#0
  to:@1
@1: from @3 @BEGIN
  (byte) x1#2 ← phi( @3/(byte) x1#2 @BEGIN/(byte) 39 )
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) y#0 )
  (byte) xd#1 ← phi( @3/(byte) xd#1 @BEGIN/(byte) xd#0 )
  (byte) yd#1 ← phi( @3/(byte) yd#1 @BEGIN/(byte) yd#0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) x#0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  (byte) STAR#1 ← phi( @3/(byte) STAR#1 @BEGIN/(byte) 81 )
  *((byte*) cursor#3) ← (byte) STAR#1
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) yd#1
  (boolean~) $9 ← (byte) xd#1 < (byte) e#1
  if((boolean~) $9) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) xd#1
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte~) $13 ← (byte) x1#2 + (byte) 1
  (boolean~) $14 ← (byte) x#1 < (byte~) $13
  if((boolean~) $14) goto @1
  to:@END
@END: from @3

Self Phi Eliminated (byte) STAR#1
Self Phi Eliminated (byte) yd#1
Self Phi Eliminated (byte) xd#1
Self Phi Eliminated (byte) x1#2
Succesful SSA optimization Pass2SelfPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) xd#0 ← (byte) 39 - (byte) 0
  (byte) yd#0 ← (byte) 24 - (byte) 0
  (byte) x#0 ← (byte) 0
  (byte) y#0 ← (byte) 0
  (byte) e#0 ← (byte) yd#0 / (byte) 2
  (byte~) $3 ← (byte) y#0 * (byte) 40
  (byte*~) $4 ← (word) 1024 + (byte~) $3
  (byte*) cursor#0 ← (byte*~) $4 + (byte) x#0
  to:@1
@1: from @3 @BEGIN
  (byte) x1#2 ← phi( @BEGIN/(byte) 39 )
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) y#0 )
  (byte) xd#1 ← phi( @BEGIN/(byte) xd#0 )
  (byte) yd#1 ← phi( @BEGIN/(byte) yd#0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) x#0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  (byte) STAR#1 ← phi( @BEGIN/(byte) 81 )
  *((byte*) cursor#3) ← (byte) STAR#1
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) yd#1
  (boolean~) $9 ← (byte) xd#1 < (byte) e#1
  if((boolean~) $9) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) xd#1
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte~) $13 ← (byte) x1#2 + (byte) 1
  (boolean~) $14 ← (byte) x#1 < (byte~) $13
  if((boolean~) $14) goto @1
  to:@END
@END: from @3

Simple Condition (boolean~) $9 if((byte) xd#1<(byte) e#1) goto @2
Simple Condition (boolean~) $14 if((byte) x#1<(byte~) $13) goto @1
Succesful SSA optimization Pass2ConditionalJumpSimplification
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) xd#0 ← (byte) 39 - (byte) 0
  (byte) yd#0 ← (byte) 24 - (byte) 0
  (byte) x#0 ← (byte) 0
  (byte) y#0 ← (byte) 0
  (byte) e#0 ← (byte) yd#0 / (byte) 2
  (byte~) $3 ← (byte) y#0 * (byte) 40
  (byte*~) $4 ← (word) 1024 + (byte~) $3
  (byte*) cursor#0 ← (byte*~) $4 + (byte) x#0
  to:@1
@1: from @3 @BEGIN
  (byte) x1#2 ← phi( @BEGIN/(byte) 39 )
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) y#0 )
  (byte) xd#1 ← phi( @BEGIN/(byte) xd#0 )
  (byte) yd#1 ← phi( @BEGIN/(byte) yd#0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) x#0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  (byte) STAR#1 ← phi( @BEGIN/(byte) 81 )
  *((byte*) cursor#3) ← (byte) STAR#1
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) yd#1
  if((byte) xd#1<(byte) e#1) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) xd#1
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte~) $13 ← (byte) x1#2 + (byte) 1
  if((byte) x#1<(byte~) $13) goto @1
  to:@END
@END: from @3

Constant (byte) xd#0 (byte) 39
Constant (byte) yd#0 (byte) 24
Constant (byte) x#0 (byte) 0
Constant (byte) y#0 (byte) 0
Constant (byte) STAR#1 (byte) 81
Constant (byte) x1#2 (byte) 39
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) e#0 ← (byte) 24 / (byte) 2
  (byte~) $3 ← (byte) 0 * (byte) 40
  (byte*~) $4 ← (word) 1024 + (byte~) $3
  (byte*) cursor#0 ← (byte*~) $4 + (byte) 0
  to:@1
@1: from @3 @BEGIN
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) 0 )
  (byte) xd#1 ← phi( @BEGIN/(byte) 39 )
  (byte) yd#1 ← phi( @BEGIN/(byte) 24 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) 0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  *((byte*) cursor#3) ← (byte) 81
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) yd#1
  if((byte) xd#1<(byte) e#1) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) xd#1
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte~) $13 ← (byte) 39 + (byte) 1
  if((byte) x#1<(byte~) $13) goto @1
  to:@END
@END: from @3

Consolidated constant in assignment cursor#0
Multiple usages for variable. Not optimizing sub-constant (byte) y#2
Multiple usages for variable. Not optimizing sub-constant (byte*) cursor#1
Succesful SSA optimization Pass2ConstantAdditionElimination
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) e#0 ← (byte) 24 / (byte) 2
  (byte~) $3 ← (byte) 0 * (byte) 40
  (byte*~) $4 ← (byte~) $3
  (byte*) cursor#0 ← (byte*~) $4 + (word) 1024
  to:@1
@1: from @3 @BEGIN
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) 0 )
  (byte) xd#1 ← phi( @BEGIN/(byte) 39 )
  (byte) yd#1 ← phi( @BEGIN/(byte) 24 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) 0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  *((byte*) cursor#3) ← (byte) 81
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) yd#1
  if((byte) xd#1<(byte) e#1) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) xd#1
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte~) $13 ← (byte) 39 + (byte) 1
  if((byte) x#1<(byte~) $13) goto @1
  to:@END
@END: from @3

Alias (byte~) $3 = (byte*~) $4 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) e#0 ← (byte) 24 / (byte) 2
  (byte~) $3 ← (byte) 0 * (byte) 40
  (byte*) cursor#0 ← (byte~) $3 + (word) 1024
  to:@1
@1: from @3 @BEGIN
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) 0 )
  (byte) xd#1 ← phi( @BEGIN/(byte) 39 )
  (byte) yd#1 ← phi( @BEGIN/(byte) 24 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) 0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  *((byte*) cursor#3) ← (byte) 81
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) yd#1
  if((byte) xd#1<(byte) e#1) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) xd#1
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte~) $13 ← (byte) 39 + (byte) 1
  if((byte) x#1<(byte~) $13) goto @1
  to:@END
@END: from @3

Redundant Phi (byte) yd#1 (byte) 24
Redundant Phi (byte) xd#1 (byte) 39
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) e#0 ← (byte) 24 / (byte) 2
  (byte~) $3 ← (byte) 0 * (byte) 40
  (byte*) cursor#0 ← (byte~) $3 + (word) 1024
  to:@1
@1: from @3 @BEGIN
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) 0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) e#0 )
  (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) 0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  *((byte*) cursor#3) ← (byte) 81
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) 24
  if((byte) 39<(byte) e#1) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) 39
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  (byte~) $13 ← (byte) 39 + (byte) 1
  if((byte) x#1<(byte~) $13) goto @1
  to:@END
@END: from @3

Constant (byte) e#0 (byte) 12
Constant (byte~) $3 (byte) 0
Constant (byte~) $13 (byte) 40
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  (byte*) cursor#0 ← (byte) 0 + (word) 1024
  to:@1
@1: from @3 @BEGIN
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) 0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) 12 )
  (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) 0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(byte*) cursor#0 )
  *((byte*) cursor#3) ← (byte) 81
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) 24
  if((byte) 39<(byte) e#1) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) 39
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  if((byte) x#1<(byte) 40) goto @1
  to:@END
@END: from @3

Multiple usages for variable. Not optimizing sub-constant (byte) y#2
Multiple usages for variable. Not optimizing sub-constant (byte*) cursor#1
Constant (byte*) cursor#0 (word) 1024
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  to:@1
@1: from @3 @BEGIN
  (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) 0 )
  (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) 12 )
  (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) 0 )
  (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(word) 1024 )
  *((byte*) cursor#3) ← (byte) 81
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) 24
  if((byte) 39<(byte) e#1) goto @2
  to:@3
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) 39
  to:@3
@3: from @1 @2
  (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 )
  (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 )
  (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 )
  if((byte) x#1<(byte) 40) goto @1
  to:@END
@END: from @3

Multiple usages for variable. Not optimizing sub-constant (byte) y#2
Multiple usages for variable. Not optimizing sub-constant (byte*) cursor#1
Multiple usages for variable. Not optimizing sub-constant (byte) y#2
Multiple usages for variable. Not optimizing sub-constant (byte*) cursor#1
Block Sequence Planned @BEGIN @1 @3 @END @2 
Added new block during phi lifting @7(between @3 and @1)
Added new block during phi lifting @8(between @1 and @3)
Block Sequence Planned @BEGIN @1 @8 @3 @END @7 @2 
CONTROL FLOW GRAPH - PHI LIFTED
@BEGIN: from
  to:@1
@1: from @7 @BEGIN
  (byte) y#2 ← phi( @7/(byte~) y#5 @BEGIN/(byte) 0 )
  (byte) e#3 ← phi( @7/(byte~) e#6 @BEGIN/(byte) 12 )
  (byte) x#2 ← phi( @7/(byte~) x#5 @BEGIN/(byte) 0 )
  (byte*) cursor#3 ← phi( @7/(byte*~) cursor#6 @BEGIN/(word) 1024 )
  *((byte*) cursor#3) ← (byte) 81
  (byte) x#1 ← (byte) x#2 + (byte) 1
  (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1
  (byte) e#1 ← (byte) e#3 + (byte) 24
  if((byte) 39<(byte) e#1) goto @2
  to:@8
@8: from @1
  (byte*~) cursor#7 ← (byte*) cursor#1
  (byte~) e#7 ← (byte) e#1
  (byte~) y#6 ← (byte) y#2
  to:@3
@3: from @2 @8
  (byte) y#4 ← phi( @8/(byte~) y#6 @2/(byte~) y#7 )
  (byte) e#5 ← phi( @8/(byte~) e#7 @2/(byte~) e#8 )
  (byte*) cursor#5 ← phi( @8/(byte*~) cursor#7 @2/(byte*~) cursor#8 )
  if((byte) x#1<(byte) 40) goto @7
  to:@END
@END: from @3
@7: from @3
  (byte*~) cursor#6 ← (byte*) cursor#5
  (byte~) x#5 ← (byte) x#1
  (byte~) e#6 ← (byte) e#5
  (byte~) y#5 ← (byte) y#4
  to:@1
@2: from @1
  (byte) y#1 ← (byte) y#2 + (byte) 1
  (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40
  (byte) e#2 ← (byte) e#1 - (byte) 39
  (byte*~) cursor#8 ← (byte*) cursor#2
  (byte~) e#8 ← (byte) e#2
  (byte~) y#7 ← (byte) y#1
  to:@3

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@BEGIN: from
  to:@1
@1: from @7 @BEGIN
  [0] (byte) y#2 ← phi( @7/(byte~) y#5 @BEGIN/(byte) 0 ) [ cursor#3 x#2 e#3 y#2 ]
  [0] (byte) e#3 ← phi( @7/(byte~) e#6 @BEGIN/(byte) 12 ) [ cursor#3 x#2 e#3 y#2 ]
  [0] (byte) x#2 ← phi( @7/(byte~) x#5 @BEGIN/(byte) 0 ) [ cursor#3 x#2 e#3 y#2 ]
  [0] (byte*) cursor#3 ← phi( @7/(byte*~) cursor#6 @BEGIN/(word) 1024 ) [ cursor#3 x#2 e#3 y#2 ]
  [1] *((byte*) cursor#3) ← (byte) 81 [ cursor#3 x#2 e#3 y#2 ]
  [2] (byte) x#1 ← (byte) x#2 + (byte) 1 [ cursor#3 e#3 y#2 x#1 ]
  [3] (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1 [ e#3 cursor#1 y#2 x#1 ]
  [4] (byte) e#1 ← (byte) e#3 + (byte) 24 [ e#1 cursor#1 y#2 x#1 ]
  [5] if((byte) 39<(byte) e#1) goto @2 [ e#1 cursor#1 y#2 x#1 ]
  to:@8
@8: from @1
  [6] (byte*~) cursor#7 ← (byte*) cursor#1 [ e#1 y#2 cursor#7 x#1 ]
  [7] (byte~) e#7 ← (byte) e#1 [ y#2 cursor#7 e#7 x#1 ]
  [8] (byte~) y#6 ← (byte) y#2 [ cursor#7 e#7 y#6 x#1 ]
  to:@3
@3: from @2 @8
  [9] (byte) y#4 ← phi( @8/(byte~) y#6 @2/(byte~) y#7 ) [ x#1 cursor#5 e#5 y#4 ]
  [9] (byte) e#5 ← phi( @8/(byte~) e#7 @2/(byte~) e#8 ) [ x#1 cursor#5 e#5 y#4 ]
  [9] (byte*) cursor#5 ← phi( @8/(byte*~) cursor#7 @2/(byte*~) cursor#8 ) [ x#1 cursor#5 e#5 y#4 ]
  [10] if((byte) x#1<(byte) 40) goto @7 [ x#1 cursor#5 e#5 y#4 ]
  to:@END
@END: from @3
@7: from @3
  [11] (byte*~) cursor#6 ← (byte*) cursor#5 [ cursor#6 x#1 e#5 y#4 ]
  [12] (byte~) x#5 ← (byte) x#1 [ cursor#6 x#5 e#5 y#4 ]
  [13] (byte~) e#6 ← (byte) e#5 [ cursor#6 x#5 e#6 y#4 ]
  [14] (byte~) y#5 ← (byte) y#4 [ cursor#6 x#5 e#6 y#5 ]
  to:@1
@2: from @1
  [15] (byte) y#1 ← (byte) y#2 + (byte) 1 [ e#1 cursor#1 x#1 y#1 ]
  [16] (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40 [ e#1 x#1 cursor#2 y#1 ]
  [17] (byte) e#2 ← (byte) e#1 - (byte) 39 [ x#1 cursor#2 e#2 y#1 ]
  [18] (byte*~) cursor#8 ← (byte*) cursor#2 [ cursor#8 x#1 e#2 y#1 ]
  [19] (byte~) e#8 ← (byte) e#2 [ cursor#8 e#8 x#1 y#1 ]
  [20] (byte~) y#7 ← (byte) y#1 [ cursor#8 e#8 y#7 x#1 ]
  to:@3

Created 7 initial phi equivalence classes
Coalesced [6] cursor#7 ← cursor#1
Coalesced [7] e#7 ← e#1
Coalesced [8] y#6 ← y#2
Coalesced [11] cursor#6 ← cursor#5
Coalesced [12] x#5 ← x#1
Coalesced [13] e#6 ← e#5
Coalesced (already) [14] y#5 ← y#4
Coalesced [18] cursor#8 ← cursor#2
Coalesced [19] e#8 ← e#2
Coalesced [20] y#7 ← y#1
Coalesced down to 4 phi equivalence classes
Culled Empty Block (label) @8
Culled Empty Block (label) @7
Block Sequence Planned @BEGIN @1 @3 @END @2 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@BEGIN: from
  to:@1
@1: from @3 @BEGIN
  [0] (byte) y#2 ← phi( @3/(byte) y#4 @BEGIN/(byte) 0 ) [ cursor#3 x#2 e#3 y#2 ]
  [0] (byte) e#3 ← phi( @3/(byte) e#5 @BEGIN/(byte) 12 ) [ cursor#3 x#2 e#3 y#2 ]
  [0] (byte) x#2 ← phi( @3/(byte) x#1 @BEGIN/(byte) 0 ) [ cursor#3 x#2 e#3 y#2 ]
  [0] (byte*) cursor#3 ← phi( @3/(byte*) cursor#5 @BEGIN/(word) 1024 ) [ cursor#3 x#2 e#3 y#2 ]
  [1] *((byte*) cursor#3) ← (byte) 81 [ cursor#3 x#2 e#3 y#2 ]
  [2] (byte) x#1 ← (byte) x#2 + (byte) 1 [ x#1 cursor#3 e#3 y#2 ]
  [3] (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1 [ x#1 e#3 cursor#1 y#2 ]
  [4] (byte) e#1 ← (byte) e#3 + (byte) 24 [ x#1 e#1 cursor#1 y#2 ]
  [5] if((byte) 39<(byte) e#1) goto @2 [ x#1 e#1 cursor#1 y#2 ]
  to:@3
@3: from @1 @2
  [6] (byte) y#4 ← phi( @1/(byte) y#2 @2/(byte) y#1 ) [ cursor#5 x#1 e#5 y#4 ]
  [6] (byte) e#5 ← phi( @1/(byte) e#1 @2/(byte) e#2 ) [ cursor#5 x#1 e#5 y#4 ]
  [6] (byte*) cursor#5 ← phi( @1/(byte*) cursor#1 @2/(byte*) cursor#2 ) [ cursor#5 x#1 e#5 y#4 ]
  [7] if((byte) x#1<(byte) 40) goto @1 [ cursor#5 x#1 e#5 y#4 ]
  to:@END
@END: from @3
@2: from @1
  [8] (byte) y#1 ← (byte) y#2 + (byte) 1 [ x#1 e#1 cursor#1 y#1 ]
  [9] (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40 [ x#1 e#1 cursor#2 y#1 ]
  [10] (byte) e#2 ← (byte) e#1 - (byte) 39 [ x#1 cursor#2 e#2 y#1 ]
  to:@3

CALL GRAPH

DOMINATORS
@BEGIN dominated by  @BEGIN 
@1 dominated by  @1 @BEGIN 
@3 dominated by  @1 @BEGIN @3 
@END dominated by  @1 @BEGIN @3 @END 
@2 dominated by  @1 @BEGIN @2 

Found back edge: Loop head: @1 tails: @3 blocks: null
Populated: Loop head: @1 tails: @3 blocks: @3 @1 @2 
NATURAL LOOPS
Loop head: @1 tails: @3 blocks: @3 @1 @2 

Found 1 loops in scope []
  Loop head: @1 tails: @3 blocks: @3 @1 @2 
NATURAL LOOPS WITH DEPTH
Loop head: @1 tails: @3 blocks: @3 @1 @2  depth: 1


VARIABLE REGISTER WEIGHTS
(byte[1000]) SCREEN
(byte) STAR
(byte*) cursor
(byte*) cursor#1 8.25
(byte*) cursor#2 11.0
(byte*) cursor#3 11.0
(byte*) cursor#5 16.5
(byte) e
(byte) e#1 11.0
(byte) e#2 22.0
(byte) e#3 5.5
(byte) e#5 16.5
(byte) x
(byte) x#1 3.666666666666667
(byte) x#2 11.0
(byte) x0
(byte) x1
(byte) xd
(byte) y
(byte) y#1 7.333333333333333
(byte) y#2 5.5
(byte) y#4 16.5
(byte) y0
(byte) y1
(byte) yd

Initial phi equivalence classes
[ cursor#3 cursor#5 cursor#1 cursor#2 ]
[ x#2 x#1 ]
[ e#3 e#5 e#1 e#2 ]
[ y#2 y#4 y#1 ]
Complete equivalence classes
[ cursor#3 cursor#5 cursor#1 cursor#2 ]
[ x#2 x#1 ]
[ e#3 e#5 e#1 e#2 ]
[ y#2 y#4 y#1 ]
Allocated zp ptr byte:2 to zp ptr byte:2 [ cursor#3 cursor#5 cursor#1 cursor#2 ]
Allocated zp byte:4 to zp byte:4 [ x#2 x#1 ]
Allocated zp byte:5 to zp byte:5 [ e#3 e#5 e#1 e#2 ]
Allocated zp byte:6 to zp byte:6 [ y#2 y#4 y#1 ]
INITIAL ASM
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] phi from @BEGIN to @1
B1_from_BBEGIN:
//SEG2 [0] phi (byte) y#2 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 6
//SEG3 [0] phi (byte) e#3 = (byte) 12 -- zpby1=coby1 
  lda #12
  sta 5
//SEG4 [0] phi (byte) x#2 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 4
//SEG5 [0] phi (byte*) cursor#3 = (word) 1024 -- zpptrby1=cowo1 
  lda #<1024
  sta 2
  lda #>1024
  sta 2+1
  jmp B1
//SEG6 [0] phi from @3 to @1
B1_from_B3:
//SEG7 [0] phi (byte) y#2 = (byte) y#4 -- register_copy 
//SEG8 [0] phi (byte) e#3 = (byte) e#5 -- register_copy 
//SEG9 [0] phi (byte) x#2 = (byte) x#1 -- register_copy 
//SEG10 [0] phi (byte*) cursor#3 = (byte*) cursor#5 -- register_copy 
  jmp B1
//SEG11 @1
B1:
//SEG12 [1] *((byte*) cursor#3) ← (byte) 81 [ cursor#3 x#2 e#3 y#2 ] -- _star_zpptrby1=coby1 
  ldy #0
  lda #81
  sta (2),y
//SEG13 [2] (byte) x#1 ← (byte) x#2 + (byte) 1 [ x#1 cursor#3 e#3 y#2 ] -- zpby1=zpby1_plus_1 
  inc 4
//SEG14 [3] (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1 [ x#1 e#3 cursor#1 y#2 ] -- zpptrby1=zpptrby1_plus_1 
  inc 2
  bne !+
  inc 2+1
!:
//SEG15 [4] (byte) e#1 ← (byte) e#3 + (byte) 24 [ x#1 e#1 cursor#1 y#2 ] -- zpby1=zpby1_plus_coby1 
  lda 5
  clc
  adc #24
  sta 5
//SEG16 [5] if((byte) 39<(byte) e#1) goto @2 [ x#1 e#1 cursor#1 y#2 ] -- coby1_lt_zpby1_then_la1 
  lda #39
  cmp 5
  bcc B2
//SEG17 [6] phi from @1 to @3
B3_from_B1:
//SEG18 [6] phi (byte) y#4 = (byte) y#2 -- register_copy 
//SEG19 [6] phi (byte) e#5 = (byte) e#1 -- register_copy 
//SEG20 [6] phi (byte*) cursor#5 = (byte*) cursor#1 -- register_copy 
  jmp B3
//SEG21 @3
B3:
//SEG22 [7] if((byte) x#1<(byte) 40) goto @1 [ cursor#5 x#1 e#5 y#4 ] -- zpby1_lt_coby1_then_la1 
  lda 4
  cmp #40
  bcc B1_from_B3
  jmp BEND
//SEG23 @END
BEND:
//SEG24 @2
B2:
//SEG25 [8] (byte) y#1 ← (byte) y#2 + (byte) 1 [ x#1 e#1 cursor#1 y#1 ] -- zpby1=zpby1_plus_1 
  inc 6
//SEG26 [9] (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40 [ x#1 e#1 cursor#2 y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
  lda 2
  clc
  adc #40
  sta 2
  bcc !+
  inc 2+1
!:
//SEG27 [10] (byte) e#2 ← (byte) e#1 - (byte) 39 [ x#1 cursor#2 e#2 y#1 ] -- zpby1=zpby1_minus_coby1 
  lda 5
  sec
  sbc #39
  sta 5
//SEG28 [6] phi from @2 to @3
B3_from_B2:
//SEG29 [6] phi (byte) y#4 = (byte) y#1 -- register_copy 
//SEG30 [6] phi (byte) e#5 = (byte) e#2 -- register_copy 
//SEG31 [6] phi (byte*) cursor#5 = (byte*) cursor#2 -- register_copy 
  jmp B3

Statement [1] *((byte*) cursor#3) ← (byte) 81 [ cursor#3 x#2 e#3 y#2 ] always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp byte:4 [ x#2 x#1 ]
Removing always clobbered register reg byte y as potential for zp byte:4 [ x#2 x#1 ]
Removing always clobbered register reg byte a as potential for zp byte:5 [ e#3 e#5 e#1 e#2 ]
Removing always clobbered register reg byte y as potential for zp byte:5 [ e#3 e#5 e#1 e#2 ]
Removing always clobbered register reg byte a as potential for zp byte:6 [ y#2 y#4 y#1 ]
Removing always clobbered register reg byte y as potential for zp byte:6 [ y#2 y#4 y#1 ]
Statement [4] (byte) e#1 ← (byte) e#3 + (byte) 24 [ x#1 e#1 cursor#1 y#2 ] always clobbers reg byte a 
Statement [9] (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40 [ x#1 e#1 cursor#2 y#1 ] always clobbers reg byte a 
Statement [10] (byte) e#2 ← (byte) e#1 - (byte) 39 [ x#1 cursor#2 e#2 y#1 ] always clobbers reg byte a 
Statement [1] *((byte*) cursor#3) ← (byte) 81 [ cursor#3 x#2 e#3 y#2 ] always clobbers reg byte a reg byte y 
Statement [4] (byte) e#1 ← (byte) e#3 + (byte) 24 [ x#1 e#1 cursor#1 y#2 ] always clobbers reg byte a 
Statement [9] (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40 [ x#1 e#1 cursor#2 y#1 ] always clobbers reg byte a 
Statement [10] (byte) e#2 ← (byte) e#1 - (byte) 39 [ x#1 cursor#2 e#2 y#1 ] always clobbers reg byte a 
REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp ptr byte:2 [ cursor#3 cursor#5 cursor#1 cursor#2 ] : zp ptr byte:2 , 
Potential registers zp byte:4 [ x#2 x#1 ] : zp byte:4 , reg byte x , 
Potential registers zp byte:5 [ e#3 e#5 e#1 e#2 ] : zp byte:5 , reg byte x , 
Potential registers zp byte:6 [ y#2 y#4 y#1 ] : zp byte:6 , reg byte x , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 55: zp byte:5 [ e#3 e#5 e#1 e#2 ] 46.75: zp ptr byte:2 [ cursor#3 cursor#5 cursor#1 cursor#2 ] 29.33: zp byte:6 [ y#2 y#4 y#1 ] 14.67: zp byte:4 [ x#2 x#1 ] 

Uplifting [] best 1180 combination reg byte x [ e#3 e#5 e#1 e#2 ] zp ptr byte:2 [ cursor#3 cursor#5 cursor#1 cursor#2 ] zp byte:6 [ y#2 y#4 y#1 ] zp byte:4 [ x#2 x#1 ] 
Re-allocated ZP register from zp byte:6 to zp byte:5
Removing instruction jmp B1
Removing instruction jmp B3
Removing instruction jmp BEND
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] phi from @BEGIN to @1
B1_from_BBEGIN:
//SEG2 [0] phi (byte) y#2 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 5
//SEG3 [0] phi (byte) e#3 = (byte) 12 -- xby=coby1 
  ldx #12
//SEG4 [0] phi (byte) x#2 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 4
//SEG5 [0] phi (byte*) cursor#3 = (word) 1024 -- zpptrby1=cowo1 
  lda #<1024
  sta 2
  lda #>1024
  sta 2+1
  jmp B1
//SEG6 [0] phi from @3 to @1
B1_from_B3:
//SEG7 [0] phi (byte) y#2 = (byte) y#4 -- register_copy 
//SEG8 [0] phi (byte) e#3 = (byte) e#5 -- register_copy 
//SEG9 [0] phi (byte) x#2 = (byte) x#1 -- register_copy 
//SEG10 [0] phi (byte*) cursor#3 = (byte*) cursor#5 -- register_copy 
//SEG11 @1
B1:
//SEG12 [1] *((byte*) cursor#3) ← (byte) 81 [ cursor#3 x#2 e#3 y#2 ] -- _star_zpptrby1=coby1 
  ldy #0
  lda #81
  sta (2),y
//SEG13 [2] (byte) x#1 ← (byte) x#2 + (byte) 1 [ x#1 cursor#3 e#3 y#2 ] -- zpby1=zpby1_plus_1 
  inc 4
//SEG14 [3] (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1 [ x#1 e#3 cursor#1 y#2 ] -- zpptrby1=zpptrby1_plus_1 
  inc 2
  bne !+
  inc 2+1
!:
//SEG15 [4] (byte) e#1 ← (byte) e#3 + (byte) 24 [ x#1 e#1 cursor#1 y#2 ] -- xby=xby_plus_coby1 
  txa
  clc
  adc #24
  tax
//SEG16 [5] if((byte) 39<(byte) e#1) goto @2 [ x#1 e#1 cursor#1 y#2 ] -- coby1_lt_xby_then_la1 
  cpx #39
  bcs B2
//SEG17 [6] phi from @1 to @3
B3_from_B1:
//SEG18 [6] phi (byte) y#4 = (byte) y#2 -- register_copy 
//SEG19 [6] phi (byte) e#5 = (byte) e#1 -- register_copy 
//SEG20 [6] phi (byte*) cursor#5 = (byte*) cursor#1 -- register_copy 
//SEG21 @3
B3:
//SEG22 [7] if((byte) x#1<(byte) 40) goto @1 [ cursor#5 x#1 e#5 y#4 ] -- zpby1_lt_coby1_then_la1 
  lda 4
  cmp #40
  bcc B1_from_B3
//SEG23 @END
BEND:
//SEG24 @2
B2:
//SEG25 [8] (byte) y#1 ← (byte) y#2 + (byte) 1 [ x#1 e#1 cursor#1 y#1 ] -- zpby1=zpby1_plus_1 
  inc 5
//SEG26 [9] (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40 [ x#1 e#1 cursor#2 y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
  lda 2
  clc
  adc #40
  sta 2
  bcc !+
  inc 2+1
!:
//SEG27 [10] (byte) e#2 ← (byte) e#1 - (byte) 39 [ x#1 cursor#2 e#2 y#1 ] -- xby=xby_minus_coby1 
  txa
  sec
  sbc #39
  tax
//SEG28 [6] phi from @2 to @3
B3_from_B2:
//SEG29 [6] phi (byte) y#4 = (byte) y#1 -- register_copy 
//SEG30 [6] phi (byte) e#5 = (byte) e#2 -- register_copy 
//SEG31 [6] phi (byte*) cursor#5 = (byte*) cursor#2 -- register_copy 
  jmp B3

Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
ASSEMBLER
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] phi from @BEGIN to @1
B1_from_BBEGIN:
//SEG2 [0] phi (byte) y#2 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 5
//SEG3 [0] phi (byte) e#3 = (byte) 12 -- xby=coby1 
  ldx #12
//SEG4 [0] phi (byte) x#2 = (byte) 0 -- zpby1=coby1 
  sta 4
//SEG5 [0] phi (byte*) cursor#3 = (word) 1024 -- zpptrby1=cowo1 
  lda #<1024
  sta 2
  lda #>1024
  sta 2+1
  jmp B1
//SEG6 [0] phi from @3 to @1
B1_from_B3:
//SEG7 [0] phi (byte) y#2 = (byte) y#4 -- register_copy 
//SEG8 [0] phi (byte) e#3 = (byte) e#5 -- register_copy 
//SEG9 [0] phi (byte) x#2 = (byte) x#1 -- register_copy 
//SEG10 [0] phi (byte*) cursor#3 = (byte*) cursor#5 -- register_copy 
//SEG11 @1
B1:
//SEG12 [1] *((byte*) cursor#3) ← (byte) 81 [ cursor#3 x#2 e#3 y#2 ] -- _star_zpptrby1=coby1 
  ldy #0
  lda #81
  sta (2),y
//SEG13 [2] (byte) x#1 ← (byte) x#2 + (byte) 1 [ x#1 cursor#3 e#3 y#2 ] -- zpby1=zpby1_plus_1 
  inc 4
//SEG14 [3] (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1 [ x#1 e#3 cursor#1 y#2 ] -- zpptrby1=zpptrby1_plus_1 
  inc 2
  bne !+
  inc 2+1
!:
//SEG15 [4] (byte) e#1 ← (byte) e#3 + (byte) 24 [ x#1 e#1 cursor#1 y#2 ] -- xby=xby_plus_coby1 
  txa
  clc
  adc #24
  tax
//SEG16 [5] if((byte) 39<(byte) e#1) goto @2 [ x#1 e#1 cursor#1 y#2 ] -- coby1_lt_xby_then_la1 
  cpx #39
  bcs B2
//SEG17 [6] phi from @1 to @3
B3_from_B1:
//SEG18 [6] phi (byte) y#4 = (byte) y#2 -- register_copy 
//SEG19 [6] phi (byte) e#5 = (byte) e#1 -- register_copy 
//SEG20 [6] phi (byte*) cursor#5 = (byte*) cursor#1 -- register_copy 
//SEG21 @3
B3:
//SEG22 [7] if((byte) x#1<(byte) 40) goto @1 [ cursor#5 x#1 e#5 y#4 ] -- zpby1_lt_coby1_then_la1 
  lda 4
  cmp #40
  bcc B1_from_B3
//SEG23 @END
BEND:
//SEG24 @2
B2:
//SEG25 [8] (byte) y#1 ← (byte) y#2 + (byte) 1 [ x#1 e#1 cursor#1 y#1 ] -- zpby1=zpby1_plus_1 
  inc 5
//SEG26 [9] (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40 [ x#1 e#1 cursor#2 y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
  lda 2
  clc
  adc #40
  sta 2
  bcc !+
  inc 2+1
!:
//SEG27 [10] (byte) e#2 ← (byte) e#1 - (byte) 39 [ x#1 cursor#2 e#2 y#1 ] -- xby=xby_minus_coby1 
  txa
  sec
  sbc #39
  tax
//SEG28 [6] phi from @2 to @3
B3_from_B2:
//SEG29 [6] phi (byte) y#4 = (byte) y#1 -- register_copy 
//SEG30 [6] phi (byte) e#5 = (byte) e#2 -- register_copy 
//SEG31 [6] phi (byte*) cursor#5 = (byte*) cursor#2 -- register_copy 
  jmp B3

Removing instruction jmp B1
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] phi from @BEGIN to @1
B1_from_BBEGIN:
//SEG2 [0] phi (byte) y#2 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 5
//SEG3 [0] phi (byte) e#3 = (byte) 12 -- xby=coby1 
  ldx #12
//SEG4 [0] phi (byte) x#2 = (byte) 0 -- zpby1=coby1 
  sta 4
//SEG5 [0] phi (byte*) cursor#3 = (word) 1024 -- zpptrby1=cowo1 
  lda #<1024
  sta 2
  lda #>1024
  sta 2+1
//SEG6 [0] phi from @3 to @1
B1_from_B3:
//SEG7 [0] phi (byte) y#2 = (byte) y#4 -- register_copy 
//SEG8 [0] phi (byte) e#3 = (byte) e#5 -- register_copy 
//SEG9 [0] phi (byte) x#2 = (byte) x#1 -- register_copy 
//SEG10 [0] phi (byte*) cursor#3 = (byte*) cursor#5 -- register_copy 
//SEG11 @1
B1:
//SEG12 [1] *((byte*) cursor#3) ← (byte) 81 [ cursor#3 x#2 e#3 y#2 ] -- _star_zpptrby1=coby1 
  ldy #0
  lda #81
  sta (2),y
//SEG13 [2] (byte) x#1 ← (byte) x#2 + (byte) 1 [ x#1 cursor#3 e#3 y#2 ] -- zpby1=zpby1_plus_1 
  inc 4
//SEG14 [3] (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1 [ x#1 e#3 cursor#1 y#2 ] -- zpptrby1=zpptrby1_plus_1 
  inc 2
  bne !+
  inc 2+1
!:
//SEG15 [4] (byte) e#1 ← (byte) e#3 + (byte) 24 [ x#1 e#1 cursor#1 y#2 ] -- xby=xby_plus_coby1 
  txa
  clc
  adc #24
  tax
//SEG16 [5] if((byte) 39<(byte) e#1) goto @2 [ x#1 e#1 cursor#1 y#2 ] -- coby1_lt_xby_then_la1 
  cpx #39
  bcs B2
//SEG17 [6] phi from @1 to @3
B3_from_B1:
//SEG18 [6] phi (byte) y#4 = (byte) y#2 -- register_copy 
//SEG19 [6] phi (byte) e#5 = (byte) e#1 -- register_copy 
//SEG20 [6] phi (byte*) cursor#5 = (byte*) cursor#1 -- register_copy 
//SEG21 @3
B3:
//SEG22 [7] if((byte) x#1<(byte) 40) goto @1 [ cursor#5 x#1 e#5 y#4 ] -- zpby1_lt_coby1_then_la1 
  lda 4
  cmp #40
  bcc B1_from_B3
//SEG23 @END
BEND:
//SEG24 @2
B2:
//SEG25 [8] (byte) y#1 ← (byte) y#2 + (byte) 1 [ x#1 e#1 cursor#1 y#1 ] -- zpby1=zpby1_plus_1 
  inc 5
//SEG26 [9] (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40 [ x#1 e#1 cursor#2 y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
  lda 2
  clc
  adc #40
  sta 2
  bcc !+
  inc 2+1
!:
//SEG27 [10] (byte) e#2 ← (byte) e#1 - (byte) 39 [ x#1 cursor#2 e#2 y#1 ] -- xby=xby_minus_coby1 
  txa
  sec
  sbc #39
  tax
//SEG28 [6] phi from @2 to @3
B3_from_B2:
//SEG29 [6] phi (byte) y#4 = (byte) y#1 -- register_copy 
//SEG30 [6] phi (byte) e#5 = (byte) e#2 -- register_copy 
//SEG31 [6] phi (byte*) cursor#5 = (byte*) cursor#2 -- register_copy 
  jmp B3

FINAL SYMBOL TABLE
(label) @1
(label) @2
(label) @3
(label) @BEGIN
(label) @END
(byte[1000]) SCREEN
(byte) STAR
(byte*) cursor
(byte*) cursor#1 zp ptr byte:2 8.25
(byte*) cursor#2 zp ptr byte:2 11.0
(byte*) cursor#3 zp ptr byte:2 11.0
(byte*) cursor#5 zp ptr byte:2 16.5
(byte) e
(byte) e#1 reg byte x 11.0
(byte) e#2 reg byte x 22.0
(byte) e#3 reg byte x 5.5
(byte) e#5 reg byte x 16.5
(byte) x
(byte) x#1 zp byte:4 3.666666666666667
(byte) x#2 zp byte:4 11.0
(byte) x0
(byte) x1
(byte) xd
(byte) y
(byte) y#1 zp byte:5 7.333333333333333
(byte) y#2 zp byte:5 5.5
(byte) y#4 zp byte:5 16.5
(byte) y0
(byte) y1
(byte) yd

zp ptr byte:2 [ cursor#3 cursor#5 cursor#1 cursor#2 ]
zp byte:4 [ x#2 x#1 ]
reg byte x [ e#3 e#5 e#1 e#2 ]
zp byte:5 [ y#2 y#4 y#1 ]

FINAL CODE
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] phi from @BEGIN to @1
B1_from_BBEGIN:
//SEG2 [0] phi (byte) y#2 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 5
//SEG3 [0] phi (byte) e#3 = (byte) 12 -- xby=coby1 
  ldx #12
//SEG4 [0] phi (byte) x#2 = (byte) 0 -- zpby1=coby1 
  sta 4
//SEG5 [0] phi (byte*) cursor#3 = (word) 1024 -- zpptrby1=cowo1 
  lda #<1024
  sta 2
  lda #>1024
  sta 2+1
//SEG6 [0] phi from @3 to @1
B1_from_B3:
//SEG7 [0] phi (byte) y#2 = (byte) y#4 -- register_copy 
//SEG8 [0] phi (byte) e#3 = (byte) e#5 -- register_copy 
//SEG9 [0] phi (byte) x#2 = (byte) x#1 -- register_copy 
//SEG10 [0] phi (byte*) cursor#3 = (byte*) cursor#5 -- register_copy 
//SEG11 @1
B1:
//SEG12 [1] *((byte*) cursor#3) ← (byte) 81 [ cursor#3 x#2 e#3 y#2 ] -- _star_zpptrby1=coby1 
  ldy #0
  lda #81
  sta (2),y
//SEG13 [2] (byte) x#1 ← (byte) x#2 + (byte) 1 [ x#1 cursor#3 e#3 y#2 ] -- zpby1=zpby1_plus_1 
  inc 4
//SEG14 [3] (byte*) cursor#1 ← (byte*) cursor#3 + (byte) 1 [ x#1 e#3 cursor#1 y#2 ] -- zpptrby1=zpptrby1_plus_1 
  inc 2
  bne !+
  inc 2+1
!:
//SEG15 [4] (byte) e#1 ← (byte) e#3 + (byte) 24 [ x#1 e#1 cursor#1 y#2 ] -- xby=xby_plus_coby1 
  txa
  clc
  adc #24
  tax
//SEG16 [5] if((byte) 39<(byte) e#1) goto @2 [ x#1 e#1 cursor#1 y#2 ] -- coby1_lt_xby_then_la1 
  cpx #39
  bcs B2
//SEG17 [6] phi from @1 to @3
B3_from_B1:
//SEG18 [6] phi (byte) y#4 = (byte) y#2 -- register_copy 
//SEG19 [6] phi (byte) e#5 = (byte) e#1 -- register_copy 
//SEG20 [6] phi (byte*) cursor#5 = (byte*) cursor#1 -- register_copy 
//SEG21 @3
B3:
//SEG22 [7] if((byte) x#1<(byte) 40) goto @1 [ cursor#5 x#1 e#5 y#4 ] -- zpby1_lt_coby1_then_la1 
  lda 4
  cmp #40
  bcc B1_from_B3
//SEG23 @END
BEND:
//SEG24 @2
B2:
//SEG25 [8] (byte) y#1 ← (byte) y#2 + (byte) 1 [ x#1 e#1 cursor#1 y#1 ] -- zpby1=zpby1_plus_1 
  inc 5
//SEG26 [9] (byte*) cursor#2 ← (byte*) cursor#1 + (byte) 40 [ x#1 e#1 cursor#2 y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
  lda 2
  clc
  adc #40
  sta 2
  bcc !+
  inc 2+1
!:
//SEG27 [10] (byte) e#2 ← (byte) e#1 - (byte) 39 [ x#1 cursor#2 e#2 y#1 ] -- xby=xby_minus_coby1 
  txa
  sec
  sbc #39
  tax
//SEG28 [6] phi from @2 to @3
B3_from_B2:
//SEG29 [6] phi (byte) y#4 = (byte) y#1 -- register_copy 
//SEG30 [6] phi (byte) e#5 = (byte) e#2 -- register_copy 
//SEG31 [6] phi (byte*) cursor#5 = (byte*) cursor#2 -- register_copy 
  jmp B3

