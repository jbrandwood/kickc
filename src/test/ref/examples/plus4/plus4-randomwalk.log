Fixing struct type size struct MOS7360_TED to 63
Fixing struct type SIZE_OF struct MOS7360_TED to 63
Fixing struct type SIZE_OF struct MOS7360_TED to 63
Inlined call call __init 

CONTROL FLOW GRAPH SSA

void* memset(void* memset::str , byte memset::c , word memset::num)
memset: scope:[memset]  from main main::@14 main::@15
  memset::c#6 = phi( main/memset::c#0, main::@14/memset::c#1, main::@15/memset::c#2 )
  memset::str#5 = phi( main/memset::str#0, main::@14/memset::str#1, main::@15/memset::str#2 )
  memset::num#3 = phi( main/memset::num#0, main::@14/memset::num#1, main::@15/memset::num#2 )
  memset::$0 = memset::num#3 > 0
  memset::$1 = ! memset::$0
  if(memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@3
  memset::str#3 = phi( memset/memset::str#5, memset::@3/memset::str#6 )
  memset::return#0 = memset::str#3
  to:memset::@return
memset::@2: scope:[memset]  from memset
  memset::c#5 = phi( memset/memset::c#6 )
  memset::num#4 = phi( memset/memset::num#3 )
  memset::str#4 = phi( memset/memset::str#5 )
  memset::$4 = (byte*)memset::str#4
  memset::$2 = memset::$4 + memset::num#4
  memset::end#0 = memset::$2
  memset::dst#0 = ((byte*)) memset::str#4
  to:memset::@3
memset::@3: scope:[memset]  from memset::@2 memset::@4
  memset::c#4 = phi( memset::@2/memset::c#5, memset::@4/memset::c#3 )
  memset::str#6 = phi( memset::@2/memset::str#4, memset::@4/memset::str#7 )
  memset::end#1 = phi( memset::@2/memset::end#0, memset::@4/memset::end#2 )
  memset::dst#2 = phi( memset::@2/memset::dst#0, memset::@4/memset::dst#1 )
  memset::$3 = memset::dst#2 != memset::end#1
  if(memset::$3) goto memset::@4
  to:memset::@1
memset::@4: scope:[memset]  from memset::@3
  memset::str#7 = phi( memset::@3/memset::str#6 )
  memset::end#2 = phi( memset::@3/memset::end#1 )
  memset::dst#3 = phi( memset::@3/memset::dst#2 )
  memset::c#3 = phi( memset::@3/memset::c#4 )
  *memset::dst#3 = memset::c#3
  memset::dst#1 = ++ memset::dst#3
  to:memset::@3
memset::@return: scope:[memset]  from memset::@1
  memset::return#5 = phi( memset::@1/memset::return#0 )
  memset::return#1 = memset::return#5
  return 
  to:@return

word rand()
rand: scope:[rand]  from main::@2
  rand_state#9 = phi( main::@2/rand_state#15 )
  rand::$0 = rand_state#9 << 7
  rand_state#0 = rand_state#9 ^ rand::$0
  rand::$1 = rand_state#0 >> 9
  rand_state#1 = rand_state#0 ^ rand::$1
  rand::$2 = rand_state#1 << 8
  rand_state#2 = rand_state#1 ^ rand::$2
  rand::return#0 = rand_state#2
  to:rand::@return
rand::@return: scope:[rand]  from rand
  rand_state#10 = phi( rand/rand_state#2 )
  rand::return#3 = phi( rand/rand::return#0 )
  rand::return#1 = rand::return#3
  rand_state#3 = rand_state#10
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  rand_state#32 = phi( __start::@1/rand_state#17 )
  memset::str#0 = (void*)DEFAULT_SCREEN
  memset::c#0 = $a0
  memset::num#0 = $3e8
  call memset 
  memset::return#2 = memset::return#1
  to:main::@14
main::@14: scope:[main]  from main
  rand_state#29 = phi( main/rand_state#32 )
  memset::str#1 = (void*)DEFAULT_COLORRAM
  memset::c#1 = 0
  memset::num#1 = $3e8
  call memset 
  memset::return#3 = memset::return#1
  to:main::@15
main::@15: scope:[main]  from main::@14
  rand_state#20 = phi( main::@14/rand_state#29 )
  memset::str#2 = (void*)VISITS
  memset::c#2 = 0
  memset::num#2 = $3e8
  call memset 
  memset::return#4 = memset::return#1
  to:main::@16
main::@16: scope:[main]  from main::@15
  rand_state#18 = phi( main::@15/rand_state#20 )
  *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0
  *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0
  main::x#0 = $14
  main::y#0 = $c
  to:main::@1
main::@1: scope:[main]  from main::@16 main::@8
  rand_state#16 = phi( main::@16/rand_state#18, main::@8/rand_state#19 )
  main::x#8 = phi( main::@16/main::x#0, main::@8/main::x#10 )
  main::y#8 = phi( main::@16/main::y#0, main::@8/main::y#10 )
  main::$25 = 0 != 1
  if(main::$25) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  rand_state#15 = phi( main::@1/rand_state#16 )
  main::x#5 = phi( main::@1/main::x#8 )
  main::y#5 = phi( main::@1/main::y#8 )
  main::$24 = (word)main::y#5
  main::$3 = main::$24 * $28
  main::$4 = main::$3 + main::x#5
  main::offset#0 = main::$4
  main::$5 = VISITS + main::offset#0
  *main::$5 = ++ *main::$5
  main::$6 = VISITS + main::offset#0
  main::cnt#0 = *main::$6
  main::$8 = DEFAULT_COLORRAM + main::offset#0
  main::$9 = main::cnt#0 & $f
  *main::$8 = FADE[main::$9]
  call rand 
  rand::return#2 = rand::return#1
  to:main::@17
main::@17: scope:[main]  from main::@2
  main::y#11 = phi( main::@2/main::y#5 )
  main::x#11 = phi( main::@2/main::x#5 )
  rand_state#11 = phi( main::@2/rand_state#3 )
  rand::return#4 = phi( main::@2/rand::return#2 )
  main::$10 = rand::return#4
  rand_state#4 = rand_state#11
  main::$11 = byte1  main::$10
  main::rnd#0 = main::$11
  main::$12 = main::rnd#0 & $80
  main::$26 = 0 != main::$12
  if(main::$26) goto main::@3
  to:main::@9
main::@3: scope:[main]  from main::@17
  rand_state#31 = phi( main::@17/rand_state#4 )
  main::y#16 = phi( main::@17/main::y#11 )
  main::x#9 = phi( main::@17/main::x#11 )
  main::rnd#1 = phi( main::@17/main::rnd#0 )
  main::$18 = main::rnd#1 & $40
  main::$27 = 0 != main::$18
  if(main::$27) goto main::@6
  to:main::@12
main::@9: scope:[main]  from main::@17
  rand_state#30 = phi( main::@17/rand_state#4 )
  main::x#16 = phi( main::@17/main::x#11 )
  main::y#9 = phi( main::@17/main::y#11 )
  main::rnd#2 = phi( main::@17/main::rnd#0 )
  main::$13 = main::rnd#2 & $40
  main::$28 = 0 != main::$13
  if(main::$28) goto main::@4
  to:main::@10
main::@4: scope:[main]  from main::@9
  rand_state#25 = phi( main::@9/rand_state#30 )
  main::x#14 = phi( main::@9/main::x#16 )
  main::y#6 = phi( main::@9/main::y#9 )
  main::y#1 = ++ main::y#6
  main::$16 = main::y#1 == $19
  main::$17 = ! main::$16
  if(main::$17) goto main::@8
  to:main::@5
main::@10: scope:[main]  from main::@9
  rand_state#21 = phi( main::@9/rand_state#30 )
  main::x#12 = phi( main::@9/main::x#16 )
  main::y#7 = phi( main::@9/main::y#9 )
  main::y#2 = -- main::y#7
  main::$14 = main::y#2 == $ff
  main::$15 = ! main::$14
  if(main::$15) goto main::@8
  to:main::@11
main::@11: scope:[main]  from main::@10
  rand_state#22 = phi( main::@10/rand_state#21 )
  main::x#13 = phi( main::@10/main::x#12 )
  main::y#3 = 0
  to:main::@8
main::@5: scope:[main]  from main::@4
  rand_state#26 = phi( main::@4/rand_state#25 )
  main::x#15 = phi( main::@4/main::x#14 )
  main::y#4 = $18
  to:main::@8
main::@6: scope:[main]  from main::@3
  rand_state#27 = phi( main::@3/rand_state#31 )
  main::y#14 = phi( main::@3/main::y#16 )
  main::x#6 = phi( main::@3/main::x#9 )
  main::x#1 = ++ main::x#6
  main::$21 = main::x#1 == $28
  main::$22 = ! main::$21
  if(main::$22) goto main::@8
  to:main::@7
main::@12: scope:[main]  from main::@3
  rand_state#23 = phi( main::@3/rand_state#31 )
  main::y#12 = phi( main::@3/main::y#16 )
  main::x#7 = phi( main::@3/main::x#9 )
  main::x#2 = -- main::x#7
  main::$19 = main::x#2 == $ff
  main::$20 = ! main::$19
  if(main::$20) goto main::@8
  to:main::@13
main::@13: scope:[main]  from main::@12
  rand_state#24 = phi( main::@12/rand_state#23 )
  main::y#13 = phi( main::@12/main::y#12 )
  main::x#3 = 0
  to:main::@8
main::@7: scope:[main]  from main::@6
  rand_state#28 = phi( main::@6/rand_state#27 )
  main::y#15 = phi( main::@6/main::y#14 )
  main::x#4 = $27
  to:main::@8
main::@8: scope:[main]  from main::@10 main::@11 main::@12 main::@13 main::@4 main::@5 main::@6 main::@7 main::@8
  rand_state#19 = phi( main::@10/rand_state#21, main::@11/rand_state#22, main::@12/rand_state#23, main::@13/rand_state#24, main::@4/rand_state#25, main::@5/rand_state#26, main::@6/rand_state#27, main::@7/rand_state#28, main::@8/rand_state#19 )
  main::x#10 = phi( main::@10/main::x#12, main::@11/main::x#13, main::@12/main::x#2, main::@13/main::x#3, main::@4/main::x#14, main::@5/main::x#15, main::@6/main::x#1, main::@7/main::x#4, main::@8/main::x#10 )
  main::y#10 = phi( main::@10/main::y#2, main::@11/main::y#3, main::@12/main::y#12, main::@13/main::y#13, main::@4/main::y#1, main::@5/main::y#4, main::@6/main::y#14, main::@7/main::y#15, main::@8/main::y#10 )
  main::$23 = *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO) != $ff
  if(main::$23) goto main::@8
  to:main::@1
main::@return: scope:[main]  from main::@1
  rand_state#12 = phi( main::@1/rand_state#16 )
  rand_state#5 = rand_state#12
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  rand_state#6 = 1
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  rand_state#17 = phi( __start::__init1/rand_state#6 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  rand_state#13 = phi( __start::@1/rand_state#5 )
  rand_state#7 = rand_state#13
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  rand_state#14 = phi( __start::@2/rand_state#7 )
  rand_state#8 = rand_state#14
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* const DEFAULT_COLORRAM = (byte*)$800
constant byte* const DEFAULT_SCREEN = (byte*)$c00
constant byte* FADE[$10]  = { 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6 }
constant byte OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
constant byte OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
constant byte OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
constant byte RADIX::BINARY = 2
constant byte RADIX::DECIMAL = $a
constant byte RADIX::HEXADECIMAL = $10
constant byte RADIX::OCTAL = 8
constant struct MOS7360_TED* const TED = (struct MOS7360_TED*)$ff00
constant byte* VISITS[$3e8]  = { fill( $3e8, 0) }
void __start()
void main()
word~ main::$10
byte~ main::$11
number~ main::$12
number~ main::$13
bool~ main::$14
bool~ main::$15
bool~ main::$16
bool~ main::$17
number~ main::$18
bool~ main::$19
bool~ main::$20
bool~ main::$21
bool~ main::$22
bool~ main::$23
word~ main::$24
bool~ main::$25
bool~ main::$26
bool~ main::$27
bool~ main::$28
number~ main::$3
number~ main::$4
byte*~ main::$5
byte*~ main::$6
byte*~ main::$8
number~ main::$9
byte main::cnt
byte main::cnt#0
word main::offset
word main::offset#0
byte main::rnd
byte main::rnd#0
byte main::rnd#1
byte main::rnd#2
byte main::x
byte main::x#0
byte main::x#1
byte main::x#10
byte main::x#11
byte main::x#12
byte main::x#13
byte main::x#14
byte main::x#15
byte main::x#16
byte main::x#2
byte main::x#3
byte main::x#4
byte main::x#5
byte main::x#6
byte main::x#7
byte main::x#8
byte main::x#9
byte main::y
byte main::y#0
byte main::y#1
byte main::y#10
byte main::y#11
byte main::y#12
byte main::y#13
byte main::y#14
byte main::y#15
byte main::y#16
byte main::y#2
byte main::y#3
byte main::y#4
byte main::y#5
byte main::y#6
byte main::y#7
byte main::y#8
byte main::y#9
void* memset(void* memset::str , byte memset::c , word memset::num)
bool~ memset::$0
bool~ memset::$1
byte*~ memset::$2
bool~ memset::$3
byte*~ memset::$4
byte memset::c
byte memset::c#0
byte memset::c#1
byte memset::c#2
byte memset::c#3
byte memset::c#4
byte memset::c#5
byte memset::c#6
byte* memset::dst
byte* memset::dst#0
byte* memset::dst#1
byte* memset::dst#2
byte* memset::dst#3
byte* memset::end
byte* memset::end#0
byte* memset::end#1
byte* memset::end#2
word memset::num
word memset::num#0
word memset::num#1
word memset::num#2
word memset::num#3
word memset::num#4
void* memset::return
void* memset::return#0
void* memset::return#1
void* memset::return#2
void* memset::return#3
void* memset::return#4
void* memset::return#5
void* memset::str
void* memset::str#0
void* memset::str#1
void* memset::str#2
void* memset::str#3
void* memset::str#4
void* memset::str#5
void* memset::str#6
void* memset::str#7
word rand()
word~ rand::$0
word~ rand::$1
word~ rand::$2
word rand::return
word rand::return#0
word rand::return#1
word rand::return#2
word rand::return#3
word rand::return#4
word rand_state
word rand_state#0
word rand_state#1
word rand_state#10
word rand_state#11
word rand_state#12
word rand_state#13
word rand_state#14
word rand_state#15
word rand_state#16
word rand_state#17
word rand_state#18
word rand_state#19
word rand_state#2
word rand_state#20
word rand_state#21
word rand_state#22
word rand_state#23
word rand_state#24
word rand_state#25
word rand_state#26
word rand_state#27
word rand_state#28
word rand_state#29
word rand_state#3
word rand_state#30
word rand_state#31
word rand_state#32
word rand_state#4
word rand_state#5
word rand_state#6
word rand_state#7
word rand_state#8
word rand_state#9

Adding number conversion cast (unumber) 0 in memset::$0 = memset::num#3 > 0
Adding number conversion cast (unumber) 7 in rand::$0 = rand_state#9 << 7
Adding number conversion cast (unumber) 9 in rand::$1 = rand_state#0 >> 9
Adding number conversion cast (unumber) 8 in rand::$2 = rand_state#1 << 8
Adding number conversion cast (unumber) $a0 in memset::c#0 = $a0
Adding number conversion cast (unumber) $3e8 in memset::num#0 = $3e8
Adding number conversion cast (unumber) 0 in memset::c#1 = 0
Adding number conversion cast (unumber) $3e8 in memset::num#1 = $3e8
Adding number conversion cast (unumber) 0 in memset::c#2 = 0
Adding number conversion cast (unumber) $3e8 in memset::num#2 = $3e8
Adding number conversion cast (unumber) 0 in *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0
Adding number conversion cast (unumber) 0 in *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0
Adding number conversion cast (unumber) $28 in main::$3 = main::$24 * $28
Adding number conversion cast (unumber) main::$3 in main::$3 = main::$24 * (unumber)$28
Adding number conversion cast (unumber) main::$4 in main::$4 = main::$3 + main::x#5
Adding number conversion cast (unumber) $f in main::$9 = main::cnt#0 & $f
Adding number conversion cast (unumber) main::$9 in main::$9 = main::cnt#0 & (unumber)$f
Adding number conversion cast (unumber) $80 in main::$12 = main::rnd#0 & $80
Adding number conversion cast (unumber) main::$12 in main::$12 = main::rnd#0 & (unumber)$80
Adding number conversion cast (unumber) 0 in main::$26 = 0 != main::$12
Adding number conversion cast (unumber) $40 in main::$18 = main::rnd#1 & $40
Adding number conversion cast (unumber) main::$18 in main::$18 = main::rnd#1 & (unumber)$40
Adding number conversion cast (unumber) 0 in main::$27 = 0 != main::$18
Adding number conversion cast (unumber) $40 in main::$13 = main::rnd#2 & $40
Adding number conversion cast (unumber) main::$13 in main::$13 = main::rnd#2 & (unumber)$40
Adding number conversion cast (unumber) 0 in main::$28 = 0 != main::$13
Adding number conversion cast (unumber) $19 in main::$16 = main::y#1 == $19
Adding number conversion cast (unumber) $ff in main::$14 = main::y#2 == $ff
Adding number conversion cast (unumber) 0 in main::y#3 = 0
Adding number conversion cast (unumber) $18 in main::y#4 = $18
Adding number conversion cast (unumber) $28 in main::$21 = main::x#1 == $28
Adding number conversion cast (unumber) $ff in main::$19 = main::x#2 == $ff
Adding number conversion cast (unumber) 0 in main::x#3 = 0
Adding number conversion cast (unumber) $27 in main::x#4 = $27
Adding number conversion cast (unumber) $ff in main::$23 = *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO) != $ff
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast memset::dst#0 = (byte*)memset::str#4
Inlining cast memset::c#0 = (unumber)$a0
Inlining cast memset::num#0 = (unumber)$3e8
Inlining cast memset::c#1 = (unumber)0
Inlining cast memset::num#1 = (unumber)$3e8
Inlining cast memset::c#2 = (unumber)0
Inlining cast memset::num#2 = (unumber)$3e8
Inlining cast *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = (unumber)0
Inlining cast *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = (unumber)0
Inlining cast main::y#3 = (unumber)0
Inlining cast main::y#4 = (unumber)$18
Inlining cast main::x#3 = (unumber)0
Inlining cast main::x#4 = (unumber)$27
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 2048
Simplifying constant pointer cast (byte*) 3072
Simplifying constant pointer cast (struct MOS7360_TED*) 65280
Simplifying constant integer cast 0
Simplifying constant integer cast 7
Simplifying constant integer cast 9
Simplifying constant integer cast 8
Simplifying constant integer cast $a0
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast $f
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast 0
Simplifying constant integer cast $19
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $18
Simplifying constant integer cast $28
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $27
Simplifying constant integer cast $ff
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $a0
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $27
Finalized unsigned number type (byte) $ff
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to word in main::$3 = main::$24 * $28
Inferred type updated to word in main::$4 = main::$3 + main::x#5
Inferred type updated to byte in main::$9 = main::cnt#0 & $f
Inferred type updated to byte in main::$12 = main::rnd#0 & $80
Inferred type updated to byte in main::$18 = main::rnd#1 & $40
Inferred type updated to byte in main::$13 = main::rnd#2 & $40
Inversing boolean not [2] memset::$1 = memset::num#3 <= 0 from [1] memset::$0 = memset::num#3 > 0
Inversing boolean not [91] main::$17 = main::y#1 != $19 from [90] main::$16 = main::y#1 == $19
Inversing boolean not [96] main::$15 = main::y#2 != $ff from [95] main::$14 = main::y#2 == $ff
Inversing boolean not [105] main::$22 = main::x#1 != $28 from [104] main::$21 = main::x#1 == $28
Inversing boolean not [110] main::$20 = main::x#2 != $ff from [109] main::$19 = main::x#2 == $ff
Successful SSA optimization Pass2UnaryNotSimplification
Alias memset::return#0 = memset::str#3 memset::return#5 memset::return#1 
Alias memset::str#4 = memset::str#5 
Alias memset::num#3 = memset::num#4 
Alias memset::c#5 = memset::c#6 
Alias memset::end#0 = memset::$2 
Alias memset::c#3 = memset::c#4 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#6 = memset::str#7 
Alias rand::return#0 = rand::return#3 rand::return#1 
Alias rand_state#10 = rand_state#2 rand_state#3 
Alias rand_state#18 = rand_state#29 rand_state#32 rand_state#20 
Alias main::y#11 = main::y#5 main::y#8 main::y#16 main::y#9 main::y#6 main::y#7 main::y#14 main::y#12 main::y#13 main::y#15 
Alias main::x#11 = main::x#5 main::x#8 main::x#9 main::x#16 main::x#14 main::x#12 main::x#13 main::x#15 main::x#6 main::x#7 
Alias rand_state#12 = rand_state#15 rand_state#16 rand_state#5 
Alias main::offset#0 = main::$4 
Alias rand::return#2 = rand::return#4 
Alias rand_state#11 = rand_state#4 rand_state#31 rand_state#30 rand_state#25 rand_state#21 rand_state#22 rand_state#26 rand_state#27 rand_state#23 rand_state#24 rand_state#28 
Alias main::rnd#0 = main::$11 main::rnd#1 main::rnd#2 
Alias rand_state#17 = rand_state#6 
Alias rand_state#13 = rand_state#7 rand_state#14 rand_state#8 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values memset::end#1 memset::end#0
Identical Phi Values memset::str#6 memset::str#4
Identical Phi Values memset::c#3 memset::c#5
Identical Phi Values rand_state#9 rand_state#12
Identical Phi Values rand_state#18 rand_state#17
Identical Phi Values rand_state#11 rand_state#10
Identical Phi Values rand_state#19 rand_state#11
Identical Phi Values rand_state#13 rand_state#12
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values memset::return#0 memset::str#4
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [65] main::$6 = VISITS + main::offset#0
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition memset::$1 [2] if(memset::num#3<=0) goto memset::@1
Simple Condition memset::$3 [9] if(memset::dst#2!=memset::end#0) goto memset::@4
Simple Condition main::$25 [44] if(0!=1) goto main::@2
Simple Condition main::$26 [62] if(0!=main::$12) goto main::@3
Simple Condition main::$27 [65] if(0!=main::$18) goto main::@6
Simple Condition main::$28 [68] if(0!=main::$13) goto main::@4
Simple Condition main::$17 [71] if(main::y#1!=$19) goto main::@8
Simple Condition main::$15 [74] if(main::y#2!=$ff) goto main::@8
Simple Condition main::$22 [79] if(main::x#1!=$28) goto main::@8
Simple Condition main::$20 [82] if(main::x#2!=$ff) goto main::@8
Simple Condition main::$23 [87] if(*((byte*)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@8
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant memset::str#0 = (void*)DEFAULT_SCREEN
Constant memset::c#0 = $a0
Constant memset::num#0 = $3e8
Constant memset::str#1 = (void*)DEFAULT_COLORRAM
Constant memset::c#1 = 0
Constant memset::num#1 = $3e8
Constant memset::str#2 = (void*)VISITS
Constant memset::c#2 = 0
Constant memset::num#2 = $3e8
Constant main::x#0 = $14
Constant main::y#0 = $c
Constant main::y#3 = 0
Constant main::y#4 = $18
Constant main::x#3 = 0
Constant main::x#4 = $27
Constant rand_state#17 = 1
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [44] if(0!=1) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused variable memset::return#2 and assignment [19] memset::return#2 = memset::str#4
Eliminating unused variable memset::return#3 and assignment [21] memset::return#3 = memset::str#4
Eliminating unused variable memset::return#4 and assignment [23] memset::return#4 = memset::str#4
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Alias main::$6 = main::$5 
Successful SSA optimization Pass2AliasElimination
Inlining Noop Cast [2] memset::$4 = (byte*)memset::str#4 keeping memset::str#4
Inlining Noop Cast [4] memset::dst#0 = (byte*)memset::str#4 keeping memset::str#4
Successful SSA optimization Pass2NopCastInlining
Rewriting multiplication to use shift and addition[25] main::$3 = main::$24 * $28
Inlining constant with var siblings memset::str#0
Inlining constant with var siblings memset::c#0
Inlining constant with var siblings memset::num#0
Inlining constant with var siblings memset::str#1
Inlining constant with var siblings memset::c#1
Inlining constant with var siblings memset::num#1
Inlining constant with var siblings memset::str#2
Inlining constant with var siblings memset::c#2
Inlining constant with var siblings memset::num#2
Inlining constant with var siblings main::x#0
Inlining constant with var siblings main::y#0
Inlining constant with var siblings main::y#3
Inlining constant with var siblings main::y#4
Inlining constant with var siblings main::x#3
Inlining constant with var siblings main::x#4
Inlining constant with var siblings rand_state#17
Constant inlined memset::str#2 = (void*)VISITS
Constant inlined memset::str#1 = (void*)DEFAULT_COLORRAM
Constant inlined rand_state#17 = 1
Constant inlined memset::str#0 = (void*)DEFAULT_SCREEN
Constant inlined memset::num#2 = $3e8
Constant inlined main::x#3 = 0
Constant inlined memset::num#1 = $3e8
Constant inlined main::x#0 = $14
Constant inlined memset::num#0 = $3e8
Constant inlined main::y#0 = $c
Constant inlined main::y#3 = 0
Constant inlined main::x#4 = $27
Constant inlined main::y#4 = $18
Constant inlined memset::c#0 = $a0
Constant inlined memset::c#1 = 0
Constant inlined memset::c#2 = 0
Successful SSA optimization Pass2ConstantInlining
Alias main::$3 = main::$31 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values memset::num#3 $3e8
Successful SSA optimization Pass2IdenticalPhiElimination
if() condition always false - eliminating [1] if($3e8<=0) goto memset::@1
Successful SSA optimization Pass2ConstantIfs
Finalized unsigned number type (byte) $1d
Finalized unsigned number type (byte) $1d
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $10
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (word) $3e8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Added new block during phi lifting main::@18(between main::@8 and main::@1)
Added new block during phi lifting main::@19(between main::@10 and main::@8)
Added new block during phi lifting main::@20(between main::@12 and main::@8)
Added new block during phi lifting main::@21(between main::@4 and main::@8)
Added new block during phi lifting main::@22(between main::@6 and main::@8)
Added new block during phi lifting main::@23(between main::@8 and main::@8)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of memset::@1
CALL GRAPH
Calls in [main] to memset:1 memset:3 memset:5 rand:20 

Created 8 initial phi equivalence classes
Coalesced [30] main::x#19 = main::x#11
Coalesced [33] main::y#17 = main::y#10
Coalesced (already) [34] main::x#17 = main::x#10
Coalesced [35] rand_state#33 = rand_state#10
Coalesced (already) [36] main::y#24 = main::y#10
Coalesced (already) [37] main::x#24 = main::x#10
Coalesced [38] main::y#18 = main::y#2
Coalesced (already) [39] main::x#18 = main::x#11
Coalesced (already) [42] main::x#22 = main::x#11
Coalesced [43] main::y#21 = main::y#1
Coalesced (already) [44] main::x#21 = main::x#11
Coalesced (already) [49] main::y#20 = main::y#11
Coalesced (already) [50] main::y#19 = main::y#11
Coalesced [51] main::x#20 = main::x#2
Coalesced (already) [54] main::y#23 = main::y#11
Coalesced (already) [55] main::y#22 = main::y#11
Coalesced [56] main::x#23 = main::x#1
Coalesced [66] memset::dst#5 = memset::dst#1
Coalesced down to 6 phi equivalence classes
Culled Empty Block label main::@11
Culled Empty Block label main::@18
Culled Empty Block label main::@23
Culled Empty Block label main::@5
Culled Empty Block label main::@13
Culled Empty Block label main::@7
Culled Empty Block label memset::@1
Renumbering block memset::@2 to memset::@1
Renumbering block memset::@3 to memset::@2
Renumbering block memset::@4 to memset::@3
Renumbering block main::@6 to main::@5
Renumbering block main::@8 to main::@6
Renumbering block main::@9 to main::@7
Renumbering block main::@10 to main::@8
Renumbering block main::@12 to main::@9
Renumbering block main::@14 to main::@10
Renumbering block main::@15 to main::@11
Renumbering block main::@16 to main::@12
Renumbering block main::@17 to main::@13
Renumbering block main::@19 to main::@14
Renumbering block main::@20 to main::@15
Renumbering block main::@21 to main::@16
Renumbering block main::@22 to main::@17
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@16
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@17

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call memset 
  to:main::@10
main::@10: scope:[main]  from main
  [2] phi()
  [3] call memset 
  to:main::@11
main::@11: scope:[main]  from main::@10
  [4] phi()
  [5] call memset 
  to:main::@12
main::@12: scope:[main]  from main::@11
  [6] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0
  [7] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0
  to:main::@1
main::@1: scope:[main]  from main::@12 main::@6
  [8] rand_state#12 = phi( main::@12/1, main::@6/rand_state#10 )
  [8] main::x#11 = phi( main::@12/$14, main::@6/main::x#10 )
  [8] main::y#11 = phi( main::@12/$c, main::@6/main::y#10 )
  to:main::@2
main::@2: scope:[main]  from main::@1
  [9] main::$24 = (word)main::y#11
  [10] main::$29 = main::$24 << 2
  [11] main::$30 = main::$29 + main::$24
  [12] main::$3 = main::$30 << 3
  [13] main::offset#0 = main::$3 + main::x#11
  [14] main::$6 = VISITS + main::offset#0
  [15] *main::$6 = ++ *main::$6
  [16] main::cnt#0 = *main::$6
  [17] main::$8 = DEFAULT_COLORRAM + main::offset#0
  [18] main::$9 = main::cnt#0 & $f
  [19] *main::$8 = FADE[main::$9]
  [20] call rand 
  [21] rand::return#2 = rand::return#0
  to:main::@13
main::@13: scope:[main]  from main::@2
  [22] main::$10 = rand::return#2
  [23] main::rnd#0 = byte1  main::$10
  [24] main::$12 = main::rnd#0 & $80
  [25] if(0!=main::$12) goto main::@3
  to:main::@7
main::@7: scope:[main]  from main::@13
  [26] main::$13 = main::rnd#0 & $40
  [27] if(0!=main::$13) goto main::@4
  to:main::@8
main::@8: scope:[main]  from main::@7
  [28] main::y#2 = -- main::y#11
  [29] if(main::y#2!=$ff) goto main::@14
  to:main::@6
main::@14: scope:[main]  from main::@8
  [30] phi()
  to:main::@6
main::@6: scope:[main]  from main::@14 main::@15 main::@16 main::@17 main::@4 main::@5 main::@6 main::@8 main::@9
  [31] main::x#10 = phi( main::@14/main::x#11, main::@8/main::x#11, main::@15/main::x#2, main::@9/0, main::@16/main::x#11, main::@4/main::x#11, main::@17/main::x#1, main::@5/$27, main::@6/main::x#10 )
  [31] main::y#10 = phi( main::@14/main::y#2, main::@8/0, main::@15/main::y#11, main::@9/main::y#11, main::@16/main::y#1, main::@4/$18, main::@17/main::y#11, main::@5/main::y#11, main::@6/main::y#10 )
  [32] if(*((byte*)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6
  to:main::@1
main::@4: scope:[main]  from main::@7
  [33] main::y#1 = ++ main::y#11
  [34] if(main::y#1!=$19) goto main::@16
  to:main::@6
main::@16: scope:[main]  from main::@4
  [35] phi()
  to:main::@6
main::@3: scope:[main]  from main::@13
  [36] main::$18 = main::rnd#0 & $40
  [37] if(0!=main::$18) goto main::@5
  to:main::@9
main::@9: scope:[main]  from main::@3
  [38] main::x#2 = -- main::x#11
  [39] if(main::x#2!=$ff) goto main::@15
  to:main::@6
main::@15: scope:[main]  from main::@9
  [40] phi()
  to:main::@6
main::@5: scope:[main]  from main::@3
  [41] main::x#1 = ++ main::x#11
  [42] if(main::x#1!=$28) goto main::@17
  to:main::@6
main::@17: scope:[main]  from main::@5
  [43] phi()
  to:main::@6

void* memset(void* memset::str , byte memset::c , word memset::num)
memset: scope:[memset]  from main main::@10 main::@11
  [44] memset::c#5 = phi( main/$a0, main::@10/0, main::@11/0 )
  [44] memset::str#4 = phi( main/(void*)DEFAULT_SCREEN, main::@10/(void*)DEFAULT_COLORRAM, main::@11/(void*)VISITS )
  to:memset::@1
memset::@1: scope:[memset]  from memset
  [45] memset::end#0 = (byte*)memset::str#4 + $3e8
  [46] memset::dst#4 = (byte*)memset::str#4
  to:memset::@2
memset::@2: scope:[memset]  from memset::@1 memset::@3
  [47] memset::dst#2 = phi( memset::@1/memset::dst#4, memset::@3/memset::dst#1 )
  [48] if(memset::dst#2!=memset::end#0) goto memset::@3
  to:memset::@return
memset::@return: scope:[memset]  from memset::@2
  [49] return 
  to:@return
memset::@3: scope:[memset]  from memset::@2
  [50] *memset::dst#2 = memset::c#5
  [51] memset::dst#1 = ++ memset::dst#2
  to:memset::@2

word rand()
rand: scope:[rand]  from main::@2
  [52] rand::$0 = rand_state#12 << 7
  [53] rand_state#0 = rand_state#12 ^ rand::$0
  [54] rand::$1 = rand_state#0 >> 9
  [55] rand_state#1 = rand_state#0 ^ rand::$1
  [56] rand::$2 = rand_state#1 << 8
  [57] rand_state#10 = rand_state#1 ^ rand::$2
  [58] rand::return#0 = rand_state#10
  to:rand::@return
rand::@return: scope:[rand]  from rand
  [59] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void main()
word~ main::$10 22.0
byte~ main::$12 22.0
byte~ main::$13 22.0
byte~ main::$18 22.0
word~ main::$24 16.5
word~ main::$29 22.0
word~ main::$3 22.0
word~ main::$30 22.0
byte*~ main::$6 22.0
byte*~ main::$8 11.0
byte~ main::$9 22.0
byte main::cnt
byte main::cnt#0 11.0
word main::offset
word main::offset#0 8.25
byte main::rnd
byte main::rnd#0 14.666666666666666
byte main::x
byte main::x#1 11.0
byte main::x#10 184.5
byte main::x#11 6.357142857142859
byte main::x#2 11.0
byte main::y
byte main::y#1 11.0
byte main::y#10 184.5
byte main::y#11 5.964285714285716
byte main::y#2 11.0
void* memset(void* memset::str , byte memset::c , word memset::num)
byte memset::c
byte memset::c#5 14.428571428571429
byte* memset::dst
byte* memset::dst#1 202.0
byte* memset::dst#2 138.33333333333331
byte* memset::dst#4 22.0
byte* memset::end
byte* memset::end#0 18.666666666666664
word memset::num
void* memset::return
void* memset::str
void* memset::str#4
word rand()
word~ rand::$0 202.0
word~ rand::$1 202.0
word~ rand::$2 202.0
word rand::return
word rand::return#0 37.33333333333333
word rand::return#2 22.0
word rand_state
word rand_state#0 151.5
word rand_state#1 151.5
word rand_state#10 11.222222222222223
word rand_state#12 23.307692307692307

Initial phi equivalence classes
[ main::y#11 main::y#10 main::y#2 main::y#1 ]
[ main::x#11 main::x#10 main::x#2 main::x#1 ]
[ rand_state#12 rand_state#10 ]
[ memset::str#4 ]
[ memset::c#5 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
Added variable main::$24 to live range equivalence class [ main::$24 ]
Added variable main::$29 to live range equivalence class [ main::$29 ]
Added variable main::$30 to live range equivalence class [ main::$30 ]
Added variable main::$3 to live range equivalence class [ main::$3 ]
Added variable main::offset#0 to live range equivalence class [ main::offset#0 ]
Added variable main::$6 to live range equivalence class [ main::$6 ]
Added variable main::cnt#0 to live range equivalence class [ main::cnt#0 ]
Added variable main::$8 to live range equivalence class [ main::$8 ]
Added variable main::$9 to live range equivalence class [ main::$9 ]
Added variable rand::return#2 to live range equivalence class [ rand::return#2 ]
Added variable main::$10 to live range equivalence class [ main::$10 ]
Added variable main::rnd#0 to live range equivalence class [ main::rnd#0 ]
Added variable main::$12 to live range equivalence class [ main::$12 ]
Added variable main::$13 to live range equivalence class [ main::$13 ]
Added variable main::$18 to live range equivalence class [ main::$18 ]
Added variable memset::end#0 to live range equivalence class [ memset::end#0 ]
Added variable rand::$0 to live range equivalence class [ rand::$0 ]
Added variable rand_state#0 to live range equivalence class [ rand_state#0 ]
Added variable rand::$1 to live range equivalence class [ rand::$1 ]
Added variable rand_state#1 to live range equivalence class [ rand_state#1 ]
Added variable rand::$2 to live range equivalence class [ rand::$2 ]
Added variable rand::return#0 to live range equivalence class [ rand::return#0 ]
Complete equivalence classes
[ main::y#11 main::y#10 main::y#2 main::y#1 ]
[ main::x#11 main::x#10 main::x#2 main::x#1 ]
[ rand_state#12 rand_state#10 ]
[ memset::str#4 ]
[ memset::c#5 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
[ main::$24 ]
[ main::$29 ]
[ main::$30 ]
[ main::$3 ]
[ main::offset#0 ]
[ main::$6 ]
[ main::cnt#0 ]
[ main::$8 ]
[ main::$9 ]
[ rand::return#2 ]
[ main::$10 ]
[ main::rnd#0 ]
[ main::$12 ]
[ main::$13 ]
[ main::$18 ]
[ memset::end#0 ]
[ rand::$0 ]
[ rand_state#0 ]
[ rand::$1 ]
[ rand_state#1 ]
[ rand::$2 ]
[ rand::return#0 ]
Allocated zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Allocated zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ]
Allocated zp[2]:4 [ rand_state#12 rand_state#10 ]
Allocated zp[2]:6 [ memset::str#4 ]
Allocated zp[1]:8 [ memset::c#5 ]
Allocated zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ]
Allocated zp[2]:11 [ main::$24 ]
Allocated zp[2]:13 [ main::$29 ]
Allocated zp[2]:15 [ main::$30 ]
Allocated zp[2]:17 [ main::$3 ]
Allocated zp[2]:19 [ main::offset#0 ]
Allocated zp[2]:21 [ main::$6 ]
Allocated zp[1]:23 [ main::cnt#0 ]
Allocated zp[2]:24 [ main::$8 ]
Allocated zp[1]:26 [ main::$9 ]
Allocated zp[2]:27 [ rand::return#2 ]
Allocated zp[2]:29 [ main::$10 ]
Allocated zp[1]:31 [ main::rnd#0 ]
Allocated zp[1]:32 [ main::$12 ]
Allocated zp[1]:33 [ main::$13 ]
Allocated zp[1]:34 [ main::$18 ]
Allocated zp[2]:35 [ memset::end#0 ]
Allocated zp[2]:37 [ rand::$0 ]
Allocated zp[2]:39 [ rand_state#0 ]
Allocated zp[2]:41 [ rand::$1 ]
Allocated zp[2]:43 [ rand_state#1 ]
Allocated zp[2]:45 [ rand::$2 ]
Allocated zp[2]:47 [ rand::return#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [7] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] main::$24 = (word)main::y#11 [ main::y#11 main::x#11 rand_state#12 main::$24 ] (  [ main::y#11 main::x#11 rand_state#12 main::$24 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ]
Statement [10] main::$29 = main::$24 << 2 [ main::y#11 main::x#11 rand_state#12 main::$24 main::$29 ] (  [ main::y#11 main::x#11 rand_state#12 main::$24 main::$29 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [11] main::$30 = main::$29 + main::$24 [ main::y#11 main::x#11 rand_state#12 main::$30 ] (  [ main::y#11 main::x#11 rand_state#12 main::$30 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [12] main::$3 = main::$30 << 3 [ main::y#11 main::x#11 rand_state#12 main::$3 ] (  [ main::y#11 main::x#11 rand_state#12 main::$3 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [13] main::offset#0 = main::$3 + main::x#11 [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [14] main::$6 = VISITS + main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [15] *main::$6 = ++ *main::$6 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ]
Statement [16] main::cnt#0 = *main::$6 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::cnt#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::cnt#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [17] main::$8 = DEFAULT_COLORRAM + main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::cnt#0 main::$8 ] (  [ main::y#11 main::x#11 rand_state#12 main::cnt#0 main::$8 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:23 [ main::cnt#0 ]
Statement [18] main::$9 = main::cnt#0 & $f [ main::y#11 main::x#11 rand_state#12 main::$8 main::$9 ] (  [ main::y#11 main::x#11 rand_state#12 main::$8 main::$9 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [19] *main::$8 = FADE[main::$9] [ main::y#11 main::x#11 rand_state#12 ] (  [ main::y#11 main::x#11 rand_state#12 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [21] rand::return#2 = rand::return#0 [ main::y#11 main::x#11 rand_state#10 rand::return#2 ] (  [ main::y#11 main::x#11 rand_state#10 rand::return#2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [22] main::$10 = rand::return#2 [ main::y#11 main::x#11 rand_state#10 main::$10 ] (  [ main::y#11 main::x#11 rand_state#10 main::$10 ] { }  ) always clobbers reg byte a 
Statement [32] if(*((byte*)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6 [ main::y#10 main::x#10 rand_state#10 ] (  [ main::y#10 main::x#10 rand_state#10 ] { }  ) always clobbers reg byte a 
Statement [45] memset::end#0 = (byte*)memset::str#4 + $3e8 [ memset::str#4 memset::c#5 memset::end#0 ] ( memset:1 [ memset::str#4 memset::c#5 memset::end#0 ] { }  memset:3 [ memset::str#4 memset::c#5 memset::end#0 ] { }  memset:5 [ memset::str#4 memset::c#5 memset::end#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:8 [ memset::c#5 ]
Statement [46] memset::dst#4 = (byte*)memset::str#4 [ memset::c#5 memset::end#0 memset::dst#4 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [48] if(memset::dst#2!=memset::end#0) goto memset::@3 [ memset::c#5 memset::end#0 memset::dst#2 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [50] *memset::dst#2 = memset::c#5 [ memset::c#5 memset::end#0 memset::dst#2 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:8 [ memset::c#5 ]
Statement [52] rand::$0 = rand_state#12 << 7 [ rand_state#12 rand::$0 ] ( rand:20 [ main::y#11 main::x#11 rand_state#12 rand::$0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [53] rand_state#0 = rand_state#12 ^ rand::$0 [ rand_state#0 ] ( rand:20 [ main::y#11 main::x#11 rand_state#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [54] rand::$1 = rand_state#0 >> 9 [ rand_state#0 rand::$1 ] ( rand:20 [ main::y#11 main::x#11 rand_state#0 rand::$1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [55] rand_state#1 = rand_state#0 ^ rand::$1 [ rand_state#1 ] ( rand:20 [ main::y#11 main::x#11 rand_state#1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [56] rand::$2 = rand_state#1 << 8 [ rand_state#1 rand::$2 ] ( rand:20 [ main::y#11 main::x#11 rand_state#1 rand::$2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [57] rand_state#10 = rand_state#1 ^ rand::$2 [ rand_state#10 ] ( rand:20 [ main::y#11 main::x#11 rand_state#10 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [58] rand::return#0 = rand_state#10 [ rand_state#10 rand::return#0 ] ( rand:20 [ main::y#11 main::x#11 rand_state#10 rand::return#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [6] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [7] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] main::$24 = (word)main::y#11 [ main::y#11 main::x#11 rand_state#12 main::$24 ] (  [ main::y#11 main::x#11 rand_state#12 main::$24 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [10] main::$29 = main::$24 << 2 [ main::y#11 main::x#11 rand_state#12 main::$24 main::$29 ] (  [ main::y#11 main::x#11 rand_state#12 main::$24 main::$29 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [11] main::$30 = main::$29 + main::$24 [ main::y#11 main::x#11 rand_state#12 main::$30 ] (  [ main::y#11 main::x#11 rand_state#12 main::$30 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [12] main::$3 = main::$30 << 3 [ main::y#11 main::x#11 rand_state#12 main::$3 ] (  [ main::y#11 main::x#11 rand_state#12 main::$3 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [13] main::offset#0 = main::$3 + main::x#11 [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [14] main::$6 = VISITS + main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [15] *main::$6 = ++ *main::$6 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [16] main::cnt#0 = *main::$6 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::cnt#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::cnt#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [17] main::$8 = DEFAULT_COLORRAM + main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::cnt#0 main::$8 ] (  [ main::y#11 main::x#11 rand_state#12 main::cnt#0 main::$8 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [18] main::$9 = main::cnt#0 & $f [ main::y#11 main::x#11 rand_state#12 main::$8 main::$9 ] (  [ main::y#11 main::x#11 rand_state#12 main::$8 main::$9 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [19] *main::$8 = FADE[main::$9] [ main::y#11 main::x#11 rand_state#12 ] (  [ main::y#11 main::x#11 rand_state#12 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [21] rand::return#2 = rand::return#0 [ main::y#11 main::x#11 rand_state#10 rand::return#2 ] (  [ main::y#11 main::x#11 rand_state#10 rand::return#2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [22] main::$10 = rand::return#2 [ main::y#11 main::x#11 rand_state#10 main::$10 ] (  [ main::y#11 main::x#11 rand_state#10 main::$10 ] { }  ) always clobbers reg byte a 
Statement [32] if(*((byte*)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6 [ main::y#10 main::x#10 rand_state#10 ] (  [ main::y#10 main::x#10 rand_state#10 ] { }  ) always clobbers reg byte a 
Statement [45] memset::end#0 = (byte*)memset::str#4 + $3e8 [ memset::str#4 memset::c#5 memset::end#0 ] ( memset:1 [ memset::str#4 memset::c#5 memset::end#0 ] { }  memset:3 [ memset::str#4 memset::c#5 memset::end#0 ] { }  memset:5 [ memset::str#4 memset::c#5 memset::end#0 ] { }  ) always clobbers reg byte a 
Statement [46] memset::dst#4 = (byte*)memset::str#4 [ memset::c#5 memset::end#0 memset::dst#4 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [48] if(memset::dst#2!=memset::end#0) goto memset::@3 [ memset::c#5 memset::end#0 memset::dst#2 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [50] *memset::dst#2 = memset::c#5 [ memset::c#5 memset::end#0 memset::dst#2 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [52] rand::$0 = rand_state#12 << 7 [ rand_state#12 rand::$0 ] ( rand:20 [ main::y#11 main::x#11 rand_state#12 rand::$0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [53] rand_state#0 = rand_state#12 ^ rand::$0 [ rand_state#0 ] ( rand:20 [ main::y#11 main::x#11 rand_state#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [54] rand::$1 = rand_state#0 >> 9 [ rand_state#0 rand::$1 ] ( rand:20 [ main::y#11 main::x#11 rand_state#0 rand::$1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [55] rand_state#1 = rand_state#0 ^ rand::$1 [ rand_state#1 ] ( rand:20 [ main::y#11 main::x#11 rand_state#1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [56] rand::$2 = rand_state#1 << 8 [ rand_state#1 rand::$2 ] ( rand:20 [ main::y#11 main::x#11 rand_state#1 rand::$2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [57] rand_state#10 = rand_state#1 ^ rand::$2 [ rand_state#10 ] ( rand:20 [ main::y#11 main::x#11 rand_state#10 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [58] rand::return#0 = rand_state#10 [ rand_state#10 rand::return#0 ] ( rand:20 [ main::y#11 main::x#11 rand_state#10 rand::return#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ] : zp[1]:2 , reg byte x , 
Potential registers zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ] : zp[1]:3 , reg byte x , 
Potential registers zp[2]:4 [ rand_state#12 rand_state#10 ] : zp[2]:4 , 
Potential registers zp[2]:6 [ memset::str#4 ] : zp[2]:6 , 
Potential registers zp[1]:8 [ memset::c#5 ] : zp[1]:8 , reg byte x , 
Potential registers zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ] : zp[2]:9 , 
Potential registers zp[2]:11 [ main::$24 ] : zp[2]:11 , 
Potential registers zp[2]:13 [ main::$29 ] : zp[2]:13 , 
Potential registers zp[2]:15 [ main::$30 ] : zp[2]:15 , 
Potential registers zp[2]:17 [ main::$3 ] : zp[2]:17 , 
Potential registers zp[2]:19 [ main::offset#0 ] : zp[2]:19 , 
Potential registers zp[2]:21 [ main::$6 ] : zp[2]:21 , 
Potential registers zp[1]:23 [ main::cnt#0 ] : zp[1]:23 , reg byte x , reg byte y , 
Potential registers zp[2]:24 [ main::$8 ] : zp[2]:24 , 
Potential registers zp[1]:26 [ main::$9 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:27 [ rand::return#2 ] : zp[2]:27 , 
Potential registers zp[2]:29 [ main::$10 ] : zp[2]:29 , 
Potential registers zp[1]:31 [ main::rnd#0 ] : zp[1]:31 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:32 [ main::$12 ] : zp[1]:32 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:33 [ main::$13 ] : zp[1]:33 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:34 [ main::$18 ] : zp[1]:34 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:35 [ memset::end#0 ] : zp[2]:35 , 
Potential registers zp[2]:37 [ rand::$0 ] : zp[2]:37 , 
Potential registers zp[2]:39 [ rand_state#0 ] : zp[2]:39 , 
Potential registers zp[2]:41 [ rand::$1 ] : zp[2]:41 , 
Potential registers zp[2]:43 [ rand_state#1 ] : zp[2]:43 , 
Potential registers zp[2]:45 [ rand::$2 ] : zp[2]:45 , 
Potential registers zp[2]:47 [ rand::return#0 ] : zp[2]:47 , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 212.86: zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ] 212.46: zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ] 22: zp[2]:13 [ main::$29 ] 22: zp[2]:15 [ main::$30 ] 22: zp[2]:17 [ main::$3 ] 22: zp[2]:21 [ main::$6 ] 22: zp[1]:26 [ main::$9 ] 22: zp[2]:29 [ main::$10 ] 22: zp[1]:32 [ main::$12 ] 22: zp[1]:33 [ main::$13 ] 22: zp[1]:34 [ main::$18 ] 16.5: zp[2]:11 [ main::$24 ] 14.67: zp[1]:31 [ main::rnd#0 ] 11: zp[1]:23 [ main::cnt#0 ] 11: zp[2]:24 [ main::$8 ] 8.25: zp[2]:19 [ main::offset#0 ] 
Uplift Scope [rand] 202: zp[2]:37 [ rand::$0 ] 202: zp[2]:41 [ rand::$1 ] 202: zp[2]:45 [ rand::$2 ] 37.33: zp[2]:47 [ rand::return#0 ] 22: zp[2]:27 [ rand::return#2 ] 
Uplift Scope [memset] 362.33: zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ] 18.67: zp[2]:35 [ memset::end#0 ] 14.43: zp[1]:8 [ memset::c#5 ] 0: zp[2]:6 [ memset::str#4 ] 
Uplift Scope [] 151.5: zp[2]:39 [ rand_state#0 ] 151.5: zp[2]:43 [ rand_state#1 ] 34.53: zp[2]:4 [ rand_state#12 rand_state#10 ] 
Uplift Scope [MOS7360_TED] 
Uplift Scope [MOS6551_ACIA] 
Uplift Scope [MOS6529_PIO] 
Uplift Scope [MOS7501_PORT] 
Uplift Scope [PLUS4_ROM_BANKING] 
Uplift Scope [RADIX] 

Uplifting [main] best 8134 combination reg byte x [ main::x#11 main::x#10 main::x#2 main::x#1 ] zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ] zp[2]:13 [ main::$29 ] zp[2]:15 [ main::$30 ] zp[2]:17 [ main::$3 ] zp[2]:21 [ main::$6 ] reg byte a [ main::$9 ] zp[2]:29 [ main::$10 ] reg byte a [ main::$12 ] reg byte a [ main::$13 ] zp[1]:34 [ main::$18 ] zp[2]:11 [ main::$24 ] zp[1]:31 [ main::rnd#0 ] zp[1]:23 [ main::cnt#0 ] zp[2]:24 [ main::$8 ] zp[2]:19 [ main::offset#0 ] 
Limited combination testing to 100 combinations of 12288 possible.
Uplifting [rand] best 8134 combination zp[2]:37 [ rand::$0 ] zp[2]:41 [ rand::$1 ] zp[2]:45 [ rand::$2 ] zp[2]:47 [ rand::return#0 ] zp[2]:27 [ rand::return#2 ] 
Uplifting [memset] best 8115 combination zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ] zp[2]:35 [ memset::end#0 ] reg byte x [ memset::c#5 ] zp[2]:6 [ memset::str#4 ] 
Uplifting [] best 8115 combination zp[2]:39 [ rand_state#0 ] zp[2]:43 [ rand_state#1 ] zp[2]:4 [ rand_state#12 rand_state#10 ] 
Uplifting [MOS7360_TED] best 8115 combination 
Uplifting [MOS6551_ACIA] best 8115 combination 
Uplifting [MOS6529_PIO] best 8115 combination 
Uplifting [MOS7501_PORT] best 8115 combination 
Uplifting [PLUS4_ROM_BANKING] best 8115 combination 
Uplifting [RADIX] best 8115 combination 
Attempting to uplift remaining variables inzp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Uplifting [main] best 8115 combination zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ] 
Attempting to uplift remaining variables inzp[1]:34 [ main::$18 ]
Uplifting [main] best 8075 combination reg byte a [ main::$18 ] 
Attempting to uplift remaining variables inzp[1]:31 [ main::rnd#0 ]
Uplifting [main] best 8015 combination reg byte y [ main::rnd#0 ] 
Attempting to uplift remaining variables inzp[1]:23 [ main::cnt#0 ]
Uplifting [main] best 7995 combination reg byte y [ main::cnt#0 ] 
Coalescing zero page register [ zp[2]:4 [ rand_state#12 rand_state#10 ] ] with [ zp[2]:39 [ rand_state#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:4 [ rand_state#12 rand_state#10 rand_state#0 ] ] with [ zp[2]:43 [ rand_state#1 ] ] - score: 1
Coalescing zero page register [ zp[2]:6 [ memset::str#4 ] ] with [ zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ] ] - score: 1
Coalescing zero page register [ zp[2]:11 [ main::$24 ] ] with [ zp[2]:15 [ main::$30 ] ] - score: 1
Coalescing zero page register [ zp[2]:17 [ main::$3 ] ] with [ zp[2]:19 [ main::offset#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:27 [ rand::return#2 ] ] with [ zp[2]:29 [ main::$10 ] ] - score: 1
Coalescing zero page register [ zp[2]:27 [ rand::return#2 main::$10 ] ] with [ zp[2]:47 [ rand::return#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:11 [ main::$24 main::$30 ] ] with [ zp[2]:17 [ main::$3 main::offset#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:11 [ main::$24 main::$30 main::$3 main::offset#0 ] ] with [ zp[2]:24 [ main::$8 ] ] - score: 1
Coalescing zero page register [ zp[2]:6 [ memset::str#4 memset::dst#2 memset::dst#4 memset::dst#1 ] ] with [ zp[2]:4 [ rand_state#12 rand_state#10 rand_state#0 rand_state#1 ] ]
Coalescing zero page register [ zp[2]:37 [ rand::$0 ] ] with [ zp[2]:35 [ memset::end#0 ] ]
Allocated (was zp[2]:6) zp[2]:3 [ memset::str#4 memset::dst#2 memset::dst#4 memset::dst#1 rand_state#12 rand_state#10 rand_state#0 rand_state#1 ]
Allocated (was zp[2]:11) zp[2]:5 [ main::$24 main::$30 main::$3 main::offset#0 main::$8 ]
Allocated (was zp[2]:13) zp[2]:7 [ main::$29 ]
Allocated (was zp[2]:21) zp[2]:9 [ main::$6 ]
Allocated (was zp[2]:27) zp[2]:11 [ rand::return#2 main::$10 rand::return#0 ]
Allocated (was zp[2]:37) zp[2]:13 [ rand::$0 memset::end#0 ]
Allocated (was zp[2]:41) zp[2]:15 [ rand::$1 ]
Allocated (was zp[2]:45) zp[2]:17 [ rand::$2 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Random walk with color fading for Commodore Plus/4 / C16
/// @file
/// Plus/4 / Commodore 16 registers and memory layout
///
/// http://zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/264_Hardware_Spec.pdf
/// http://www.zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/Plus_4_Technical_Docs.pdf
/// http://personalpages.tds.net/~rcarlsen/cbm/c16/C16_Service_Manual_314001-03_(1984_Oct).pdf
/// https://www.floodgap.com/retrobits/ckb/secret/264memory.txt
/// @file
/// The MOS 7360/8360 TED chip used for graphics and sound in Plus/4 and Commodore 16
///
/// https://www.karlstechnology.com/commodore/TED7360-datasheet.pdf
/// http://mclauchlan.site.net.au/scott/C=Hacking/C-Hacking12/gfx.html
  // Upstart
  // Commodore 16 / Plus/4 executable PRG file
.file [name="plus4-randomwalk.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$1001]
.segmentdef Code [start=$100d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
  .const OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
  .const OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
  /// Default address of screen luminance/color matrix
  .label DEFAULT_COLORRAM = $800
  /// Default address of screen character matrix
  .label DEFAULT_SCREEN = $c00
  /// The TED chip controlling video and sound on the Plus/4 and Commodore 16
  .label TED = $ff00
  // The random state variable
  .label rand_state = 3
.segment Code
  // main
main: {
    .label __3 = 5
    .label __6 = 9
    .label __8 = 5
    .label __10 = $b
    .label __24 = 5
    .label offset = 5
    .label y = 2
    .label __29 = 7
    .label __30 = 5
    // [1] call memset 
    // [44] phi from main to memset [phi:main->memset]
  memset_from_main:
    // [44] phi memset::c#5 = $a0 [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #$a0
    // [44] phi memset::str#4 = (void*)DEFAULT_SCREEN [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_SCREEN
    sta.z memset.str
    lda #>DEFAULT_SCREEN
    sta.z memset.str+1
    jsr memset
    // [2] phi from main to main::@10 [phi:main->main::@10]
  __b10_from_main:
    jmp __b10
    // main::@10
  __b10:
    // [3] call memset 
    // [44] phi from main::@10 to memset [phi:main::@10->memset]
  memset_from___b10:
    // [44] phi memset::c#5 = 0 [phi:main::@10->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [44] phi memset::str#4 = (void*)DEFAULT_COLORRAM [phi:main::@10->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_COLORRAM
    sta.z memset.str
    lda #>DEFAULT_COLORRAM
    sta.z memset.str+1
    jsr memset
    // [4] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  __b11_from___b10:
    jmp __b11
    // main::@11
  __b11:
    // [5] call memset 
    // [44] phi from main::@11 to memset [phi:main::@11->memset]
  memset_from___b11:
    // [44] phi memset::c#5 = 0 [phi:main::@11->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [44] phi memset::str#4 = (void*)VISITS [phi:main::@11->memset#1] -- pvoz1=pvoc1 
    lda #<VISITS
    sta.z memset.str
    lda #>VISITS
    sta.z memset.str+1
    jsr memset
    jmp __b12
    // main::@12
  __b12:
    // [6] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR
    // [7] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR
    // [8] phi from main::@12 to main::@1 [phi:main::@12->main::@1]
  __b1_from___b12:
    // [8] phi rand_state#12 = 1 [phi:main::@12->main::@1#0] -- vwuz1=vwuc1 
    lda #<1
    sta.z rand_state
    lda #>1
    sta.z rand_state+1
    // [8] phi main::x#11 = $14 [phi:main::@12->main::@1#1] -- vbuxx=vbuc1 
    ldx #$14
    // [8] phi main::y#11 = $c [phi:main::@12->main::@1#2] -- vbuz1=vbuc1 
    lda #$c
    sta.z y
    jmp __b1
    // main::@1
  __b1:
    jmp __b2
    // main::@2
  __b2:
    // [9] main::$24 = (word)main::y#11 -- vwuz1=_word_vbuz2 
    lda.z y
    sta.z __24
    lda #0
    sta.z __24+1
    // [10] main::$29 = main::$24 << 2 -- vwuz1=vwuz2_rol_2 
    lda.z __24
    asl
    sta.z __29
    lda.z __24+1
    rol
    sta.z __29+1
    asl.z __29
    rol.z __29+1
    // [11] main::$30 = main::$29 + main::$24 -- vwuz1=vwuz2_plus_vwuz1 
    clc
    lda.z __30
    adc.z __29
    sta.z __30
    lda.z __30+1
    adc.z __29+1
    sta.z __30+1
    // [12] main::$3 = main::$30 << 3 -- vwuz1=vwuz1_rol_3 
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    // [13] main::offset#0 = main::$3 + main::x#11 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z offset
    sta.z offset
    bcc !+
    inc.z offset+1
  !:
    // [14] main::$6 = VISITS + main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    clc
    lda.z offset
    adc #<VISITS
    sta.z __6
    lda.z offset+1
    adc #>VISITS
    sta.z __6+1
    // [15] *main::$6 = ++ *main::$6 -- _deref_pbuz1=_inc__deref_pbuz1 
    ldy #0
    lda (__6),y
    clc
    adc #1
    ldy #0
    sta (__6),y
    // [16] main::cnt#0 = *main::$6 -- vbuyy=_deref_pbuz1 
    ldy #0
    lda (__6),y
    tay
    // [17] main::$8 = DEFAULT_COLORRAM + main::offset#0 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z __8
    adc #<DEFAULT_COLORRAM
    sta.z __8
    lda.z __8+1
    adc #>DEFAULT_COLORRAM
    sta.z __8+1
    // [18] main::$9 = main::cnt#0 & $f -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$f
    // [19] *main::$8 = FADE[main::$9] -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda FADE,y
    ldy #0
    sta (__8),y
    // [20] call rand 
    jsr rand
    // [21] rand::return#2 = rand::return#0
    jmp __b13
    // main::@13
  __b13:
    // [22] main::$10 = rand::return#2
    // [23] main::rnd#0 = byte1  main::$10 -- vbuyy=_byte1_vwuz1 
    ldy.z __10+1
    // [24] main::$12 = main::rnd#0 & $80 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$80
    // [25] if(0!=main::$12) goto main::@3 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b3
    jmp __b7
    // main::@7
  __b7:
    // [26] main::$13 = main::rnd#0 & $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // [27] if(0!=main::$13) goto main::@4 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b4
    jmp __b8
    // main::@8
  __b8:
    // [28] main::y#2 = -- main::y#11 -- vbuz1=_dec_vbuz1 
    dec.z y
    // [29] if(main::y#2!=$ff) goto main::@14 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z y
    bne __b14_from___b8
    // [31] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
  __b6_from___b8:
    // [31] phi main::x#10 = main::x#11 [phi:main::@8->main::@6#0] -- register_copy 
    // [31] phi main::y#10 = 0 [phi:main::@8->main::@6#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp __b6
    // [30] phi from main::@8 to main::@14 [phi:main::@8->main::@14]
  __b14_from___b8:
    jmp __b14
    // main::@14
  __b14:
    // [31] phi from main::@14 main::@15 main::@16 main::@17 main::@6 to main::@6 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6]
  __b6_from___b14:
  __b6_from___b15:
  __b6_from___b16:
  __b6_from___b17:
  __b6_from___b6:
    // [31] phi main::x#10 = main::x#11 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#0] -- register_copy 
    // [31] phi main::y#10 = main::y#2 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#1] -- register_copy 
    jmp __b6
    // main::@6
  __b6:
    // [32] if(*((byte*)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO
    bne __b6_from___b6
    // [8] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
  __b1_from___b6:
    // [8] phi rand_state#12 = rand_state#10 [phi:main::@6->main::@1#0] -- register_copy 
    // [8] phi main::x#11 = main::x#10 [phi:main::@6->main::@1#1] -- register_copy 
    // [8] phi main::y#11 = main::y#10 [phi:main::@6->main::@1#2] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // [33] main::y#1 = ++ main::y#11 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [34] if(main::y#1!=$19) goto main::@16 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b16_from___b4
    // [31] phi from main::@4 to main::@6 [phi:main::@4->main::@6]
  __b6_from___b4:
    // [31] phi main::x#10 = main::x#11 [phi:main::@4->main::@6#0] -- register_copy 
    // [31] phi main::y#10 = $18 [phi:main::@4->main::@6#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z y
    jmp __b6
    // [35] phi from main::@4 to main::@16 [phi:main::@4->main::@16]
  __b16_from___b4:
    jmp __b16
    // main::@16
  __b16:
    jmp __b6_from___b16
    // main::@3
  __b3:
    // [36] main::$18 = main::rnd#0 & $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // [37] if(0!=main::$18) goto main::@5 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b5
    jmp __b9
    // main::@9
  __b9:
    // [38] main::x#2 = -- main::x#11 -- vbuxx=_dec_vbuxx 
    dex
    // [39] if(main::x#2!=$ff) goto main::@15 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b15_from___b9
    // [31] phi from main::@9 to main::@6 [phi:main::@9->main::@6]
  __b6_from___b9:
    // [31] phi main::x#10 = 0 [phi:main::@9->main::@6#0] -- vbuxx=vbuc1 
    ldx #0
    // [31] phi main::y#10 = main::y#11 [phi:main::@9->main::@6#1] -- register_copy 
    jmp __b6
    // [40] phi from main::@9 to main::@15 [phi:main::@9->main::@15]
  __b15_from___b9:
    jmp __b15
    // main::@15
  __b15:
    jmp __b6_from___b15
    // main::@5
  __b5:
    // [41] main::x#1 = ++ main::x#11 -- vbuxx=_inc_vbuxx 
    inx
    // [42] if(main::x#1!=$28) goto main::@17 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne __b17_from___b5
    // [31] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    // [31] phi main::x#10 = $27 [phi:main::@5->main::@6#0] -- vbuxx=vbuc1 
    ldx #$27
    // [31] phi main::y#10 = main::y#11 [phi:main::@5->main::@6#1] -- register_copy 
    jmp __b6
    // [43] phi from main::@5 to main::@17 [phi:main::@5->main::@17]
  __b17_from___b5:
    jmp __b17
    // main::@17
  __b17:
    jmp __b6_from___b17
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zp(3) str, byte register(X) c)
memset: {
    .label end = $d
    .label dst = 3
    .label str = 3
    jmp __b1
    // memset::@1
  __b1:
    // [45] memset::end#0 = (byte*)memset::str#4 + $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    clc
    lda.z str
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [46] memset::dst#4 = (byte*)memset::str#4
    // [47] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  __b2_from___b1:
  __b2_from___b3:
    // [47] phi memset::dst#2 = memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp __b2
    // memset::@2
  __b2:
    // [48] if(memset::dst#2!=memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    jmp __breturn
    // memset::@return
  __breturn:
    // [49] return 
    rts
    // memset::@3
  __b3:
    // [50] *memset::dst#2 = memset::c#5 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // [51] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2_from___b3
}
  // rand
// Returns a pseudo-random number in the range of 0 to RAND_MAX (65535)
// Uses an xorshift pseudorandom number generator that hits all different values
// Information https://en.wikipedia.org/wiki/Xorshift
// Source http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html
rand: {
    .label __0 = $d
    .label __1 = $f
    .label __2 = $11
    .label return = $b
    // [52] rand::$0 = rand_state#12 << 7 -- vwuz1=vwuz2_rol_7 
    lda.z rand_state+1
    lsr
    lda.z rand_state
    ror
    sta.z __0+1
    lda #0
    ror
    sta.z __0
    // [53] rand_state#0 = rand_state#12 ^ rand::$0 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __0
    sta.z rand_state
    lda.z rand_state+1
    eor.z __0+1
    sta.z rand_state+1
    // [54] rand::$1 = rand_state#0 >> 9 -- vwuz1=vwuz2_ror_9 
    lda.z rand_state+1
    lsr
    sta.z __1
    lda #0
    sta.z __1+1
    // [55] rand_state#1 = rand_state#0 ^ rand::$1 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __1
    sta.z rand_state
    lda.z rand_state+1
    eor.z __1+1
    sta.z rand_state+1
    // [56] rand::$2 = rand_state#1 << 8 -- vwuz1=vwuz2_rol_8 
    lda.z rand_state
    sta.z __2+1
    lda #0
    sta.z __2
    // [57] rand_state#10 = rand_state#1 ^ rand::$2 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __2
    sta.z rand_state
    lda.z rand_state+1
    eor.z __2+1
    sta.z rand_state+1
    // [58] rand::return#0 = rand_state#10 -- vwuz1=vwuz2 
    lda.z rand_state
    sta.z return
    lda.z rand_state+1
    sta.z return+1
    jmp __breturn
    // rand::@return
  __breturn:
    // [59] return 
    rts
}
  // File Data
.segment Data
  // Colors to fade up/down when visiting a char multiple times
  FADE: .byte 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6
  // The number of times each character has been visited
  VISITS: .fill $3e8, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b13
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b14
Removing instruction jmp __b6
Removing instruction jmp __b16
Removing instruction jmp __b9
Removing instruction jmp __b15
Removing instruction jmp __b17
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction lda.z rand_state+1
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b14_from___b8 with __b6
Replacing label __b6_from___b6 with __b6
Replacing label __b1 with __b2
Replacing label __b16_from___b4 with __b16
Replacing label __b6_from___b16 with __b6
Replacing label __b15_from___b9 with __b15
Replacing label __b6_from___b15 with __b6
Replacing label __b17_from___b5 with __b17
Replacing label __b6_from___b17 with __b6
Replacing label __b2_from___b3 with __b2
Removing instruction __b10_from_main:
Removing instruction memset_from___b10:
Removing instruction __b11_from___b10:
Removing instruction memset_from___b11:
Removing instruction __b1:
Removing instruction __b14_from___b8:
Removing instruction __b14:
Removing instruction __b6_from___b14:
Removing instruction __b6_from___b15:
Removing instruction __b6_from___b16:
Removing instruction __b6_from___b17:
Removing instruction __b6_from___b6:
Removing instruction __b16_from___b4:
Removing instruction __b15_from___b9:
Removing instruction __b17_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction memset_from_main:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b1_from___b12:
Removing instruction __b13:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b6_from___b8:
Removing instruction __b1_from___b6:
Removing instruction __b6_from___b4:
Removing instruction __b9:
Removing instruction __b6_from___b9:
Removing instruction __b6_from___b5:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Skipping double jump to __b6 in bne __b16
Skipping double jump to __b6 in bne __b15
Skipping double jump to __b6 in bne __b17
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction jmp __b6
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b16:
Removing instruction __b15:
Removing instruction __b17:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing unreachable instruction jmp __b6
Removing unreachable instruction jmp __b6
Removing unreachable instruction jmp __b6
Succesful ASM optimization Pass5UnreachableCodeElimination

FINAL SYMBOL TABLE
constant byte* const DEFAULT_COLORRAM = (byte*) 2048
constant byte* const DEFAULT_SCREEN = (byte*) 3072
constant byte* FADE[$10]  = { 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6 }
constant byte OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
constant byte OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
constant byte OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
constant byte RADIX::BINARY = 2
constant byte RADIX::DECIMAL = $a
constant byte RADIX::HEXADECIMAL = $10
constant byte RADIX::OCTAL = 8
constant struct MOS7360_TED* const TED = (struct MOS7360_TED*) 65280
constant byte* VISITS[$3e8]  = { fill( $3e8, 0) }
void main()
word~ main::$10 zp[2]:11 22.0
byte~ main::$12 reg byte a 22.0
byte~ main::$13 reg byte a 22.0
byte~ main::$18 reg byte a 22.0
word~ main::$24 zp[2]:5 16.5
word~ main::$29 zp[2]:7 22.0
word~ main::$3 zp[2]:5 22.0
word~ main::$30 zp[2]:5 22.0
byte*~ main::$6 zp[2]:9 22.0
byte*~ main::$8 zp[2]:5 11.0
byte~ main::$9 reg byte a 22.0
byte main::cnt
byte main::cnt#0 reg byte y 11.0
word main::offset
word main::offset#0 offset zp[2]:5 8.25
byte main::rnd
byte main::rnd#0 reg byte y 14.666666666666666
byte main::x
byte main::x#1 reg byte x 11.0
byte main::x#10 reg byte x 184.5
byte main::x#11 reg byte x 6.357142857142859
byte main::x#2 reg byte x 11.0
byte main::y
byte main::y#1 y zp[1]:2 11.0
byte main::y#10 y zp[1]:2 184.5
byte main::y#11 y zp[1]:2 5.964285714285716
byte main::y#2 y zp[1]:2 11.0
void* memset(void* memset::str , byte memset::c , word memset::num)
byte memset::c
byte memset::c#5 reg byte x 14.428571428571429
byte* memset::dst
byte* memset::dst#1 dst zp[2]:3 202.0
byte* memset::dst#2 dst zp[2]:3 138.33333333333331
byte* memset::dst#4 dst zp[2]:3 22.0
byte* memset::end
byte* memset::end#0 end zp[2]:13 18.666666666666664
word memset::num
void* memset::return
void* memset::str
void* memset::str#4 str zp[2]:3
word rand()
word~ rand::$0 zp[2]:13 202.0
word~ rand::$1 zp[2]:15 202.0
word~ rand::$2 zp[2]:17 202.0
word rand::return
word rand::return#0 return zp[2]:11 37.33333333333333
word rand::return#2 return zp[2]:11 22.0
word rand_state
word rand_state#0 rand_state zp[2]:3 151.5
word rand_state#1 rand_state zp[2]:3 151.5
word rand_state#10 rand_state zp[2]:3 11.222222222222223
word rand_state#12 rand_state zp[2]:3 23.307692307692307

zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
reg byte x [ main::x#11 main::x#10 main::x#2 main::x#1 ]
zp[2]:3 [ memset::str#4 memset::dst#2 memset::dst#4 memset::dst#1 rand_state#12 rand_state#10 rand_state#0 rand_state#1 ]
reg byte x [ memset::c#5 ]
zp[2]:5 [ main::$24 main::$30 main::$3 main::offset#0 main::$8 ]
zp[2]:7 [ main::$29 ]
zp[2]:9 [ main::$6 ]
reg byte y [ main::cnt#0 ]
reg byte a [ main::$9 ]
zp[2]:11 [ rand::return#2 main::$10 rand::return#0 ]
reg byte y [ main::rnd#0 ]
reg byte a [ main::$12 ]
reg byte a [ main::$13 ]
reg byte a [ main::$18 ]
zp[2]:13 [ rand::$0 memset::end#0 ]
zp[2]:15 [ rand::$1 ]
zp[2]:17 [ rand::$2 ]


FINAL ASSEMBLER
Score: 6541

  // File Comments
// Random walk with color fading for Commodore Plus/4 / C16
/// @file
/// Plus/4 / Commodore 16 registers and memory layout
///
/// http://zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/264_Hardware_Spec.pdf
/// http://www.zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/Plus_4_Technical_Docs.pdf
/// http://personalpages.tds.net/~rcarlsen/cbm/c16/C16_Service_Manual_314001-03_(1984_Oct).pdf
/// https://www.floodgap.com/retrobits/ckb/secret/264memory.txt
/// @file
/// The MOS 7360/8360 TED chip used for graphics and sound in Plus/4 and Commodore 16
///
/// https://www.karlstechnology.com/commodore/TED7360-datasheet.pdf
/// http://mclauchlan.site.net.au/scott/C=Hacking/C-Hacking12/gfx.html
  // Upstart
  // Commodore 16 / Plus/4 executable PRG file
.file [name="plus4-randomwalk.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$1001]
.segmentdef Code [start=$100d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
  .const OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
  .const OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
  /// Default address of screen luminance/color matrix
  .label DEFAULT_COLORRAM = $800
  /// Default address of screen character matrix
  .label DEFAULT_SCREEN = $c00
  /// The TED chip controlling video and sound on the Plus/4 and Commodore 16
  .label TED = $ff00
  // The random state variable
  .label rand_state = 3
.segment Code
  // main
main: {
    .label __3 = 5
    .label __6 = 9
    .label __8 = 5
    .label __10 = $b
    .label __24 = 5
    .label offset = 5
    .label y = 2
    .label __29 = 7
    .label __30 = 5
    // memset(DEFAULT_SCREEN, 0xa0, 1000)
    // [1] call memset 
    // [44] phi from main to memset [phi:main->memset]
    // [44] phi memset::c#5 = $a0 [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #$a0
    // [44] phi memset::str#4 = (void*)DEFAULT_SCREEN [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_SCREEN
    sta.z memset.str
    lda #>DEFAULT_SCREEN
    sta.z memset.str+1
    jsr memset
    // [2] phi from main to main::@10 [phi:main->main::@10]
    // main::@10
    // memset(DEFAULT_COLORRAM, 0, 1000)
    // [3] call memset 
    // [44] phi from main::@10 to memset [phi:main::@10->memset]
    // [44] phi memset::c#5 = 0 [phi:main::@10->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [44] phi memset::str#4 = (void*)DEFAULT_COLORRAM [phi:main::@10->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_COLORRAM
    sta.z memset.str
    lda #>DEFAULT_COLORRAM
    sta.z memset.str+1
    jsr memset
    // [4] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
    // main::@11
    // memset(VISITS, 0, 1000)
    // [5] call memset 
    // [44] phi from main::@11 to memset [phi:main::@11->memset]
    // [44] phi memset::c#5 = 0 [phi:main::@11->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [44] phi memset::str#4 = (void*)VISITS [phi:main::@11->memset#1] -- pvoz1=pvoc1 
    lda #<VISITS
    sta.z memset.str
    lda #>VISITS
    sta.z memset.str+1
    jsr memset
    // main::@12
    // TED->BG_COLOR = 0
    // [6] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR
    // TED->BORDER_COLOR = 0
    // [7] *((byte*)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0 -- _deref_pbuc1=vbuc2 
    sta TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR
    // [8] phi from main::@12 to main::@1 [phi:main::@12->main::@1]
    // [8] phi rand_state#12 = 1 [phi:main::@12->main::@1#0] -- vwuz1=vwuc1 
    lda #<1
    sta.z rand_state
    lda #>1
    sta.z rand_state+1
    // [8] phi main::x#11 = $14 [phi:main::@12->main::@1#1] -- vbuxx=vbuc1 
    ldx #$14
    // [8] phi main::y#11 = $c [phi:main::@12->main::@1#2] -- vbuz1=vbuc1 
    lda #$c
    sta.z y
    // main::@1
    // main::@2
  __b2:
    // (unsigned int)y*40
    // [9] main::$24 = (word)main::y#11 -- vwuz1=_word_vbuz2 
    lda.z y
    sta.z __24
    lda #0
    sta.z __24+1
    // [10] main::$29 = main::$24 << 2 -- vwuz1=vwuz2_rol_2 
    lda.z __24
    asl
    sta.z __29
    lda.z __24+1
    rol
    sta.z __29+1
    asl.z __29
    rol.z __29+1
    // [11] main::$30 = main::$29 + main::$24 -- vwuz1=vwuz2_plus_vwuz1 
    clc
    lda.z __30
    adc.z __29
    sta.z __30
    lda.z __30+1
    adc.z __29+1
    sta.z __30+1
    // [12] main::$3 = main::$30 << 3 -- vwuz1=vwuz1_rol_3 
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    // unsigned int offset = (unsigned int)y*40+x
    // [13] main::offset#0 = main::$3 + main::x#11 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z offset
    sta.z offset
    bcc !+
    inc.z offset+1
  !:
    // VISITS+offset
    // [14] main::$6 = VISITS + main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    clc
    lda.z offset
    adc #<VISITS
    sta.z __6
    lda.z offset+1
    adc #>VISITS
    sta.z __6+1
    // char cnt = ++*(VISITS+offset)
    // [15] *main::$6 = ++ *main::$6 -- _deref_pbuz1=_inc__deref_pbuz1 
    ldy #0
    lda (__6),y
    clc
    adc #1
    sta (__6),y
    // [16] main::cnt#0 = *main::$6 -- vbuyy=_deref_pbuz1 
    lda (__6),y
    tay
    // DEFAULT_COLORRAM+offset
    // [17] main::$8 = DEFAULT_COLORRAM + main::offset#0 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z __8
    adc #<DEFAULT_COLORRAM
    sta.z __8
    lda.z __8+1
    adc #>DEFAULT_COLORRAM
    sta.z __8+1
    // cnt&0xf
    // [18] main::$9 = main::cnt#0 & $f -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$f
    // *(DEFAULT_COLORRAM+offset) = FADE[cnt&0xf]
    // [19] *main::$8 = FADE[main::$9] -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda FADE,y
    ldy #0
    sta (__8),y
    // rand()
    // [20] call rand 
    jsr rand
    // [21] rand::return#2 = rand::return#0
    // main::@13
    // [22] main::$10 = rand::return#2
    // char rnd = BYTE1(rand())
    // [23] main::rnd#0 = byte1  main::$10 -- vbuyy=_byte1_vwuz1 
    ldy.z __10+1
    // rnd & 0x80
    // [24] main::$12 = main::rnd#0 & $80 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$80
    // if(rnd & 0x80)
    // [25] if(0!=main::$12) goto main::@3 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b3
    // main::@7
    // rnd & 0x40
    // [26] main::$13 = main::rnd#0 & $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // if(rnd & 0x40)
    // [27] if(0!=main::$13) goto main::@4 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b4
    // main::@8
    // y--;
    // [28] main::y#2 = -- main::y#11 -- vbuz1=_dec_vbuz1 
    dec.z y
    // if(y==0xff)
    // [29] if(main::y#2!=$ff) goto main::@14 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z y
    bne __b6
    // [31] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
    // [31] phi main::x#10 = main::x#11 [phi:main::@8->main::@6#0] -- register_copy 
    // [31] phi main::y#10 = 0 [phi:main::@8->main::@6#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [30] phi from main::@8 to main::@14 [phi:main::@8->main::@14]
    // main::@14
    // [31] phi from main::@14 main::@15 main::@16 main::@17 main::@6 to main::@6 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6]
    // [31] phi main::x#10 = main::x#11 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#0] -- register_copy 
    // [31] phi main::y#10 = main::y#2 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#1] -- register_copy 
    // main::@6
  __b6:
    // while(TED->RASTER_LO!=0xff)
    // [32] if(*((byte*)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO
    bne __b6
    // [8] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
    // [8] phi rand_state#12 = rand_state#10 [phi:main::@6->main::@1#0] -- register_copy 
    // [8] phi main::x#11 = main::x#10 [phi:main::@6->main::@1#1] -- register_copy 
    // [8] phi main::y#11 = main::y#10 [phi:main::@6->main::@1#2] -- register_copy 
    jmp __b2
    // main::@4
  __b4:
    // y++;
    // [33] main::y#1 = ++ main::y#11 -- vbuz1=_inc_vbuz1 
    inc.z y
    // if(y==25)
    // [34] if(main::y#1!=$19) goto main::@16 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b6
    // [31] phi from main::@4 to main::@6 [phi:main::@4->main::@6]
    // [31] phi main::x#10 = main::x#11 [phi:main::@4->main::@6#0] -- register_copy 
    // [31] phi main::y#10 = $18 [phi:main::@4->main::@6#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z y
    jmp __b6
    // [35] phi from main::@4 to main::@16 [phi:main::@4->main::@16]
    // main::@16
    // main::@3
  __b3:
    // rnd& 0x40
    // [36] main::$18 = main::rnd#0 & $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // if(rnd& 0x40)
    // [37] if(0!=main::$18) goto main::@5 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b5
    // main::@9
    // x--;
    // [38] main::x#2 = -- main::x#11 -- vbuxx=_dec_vbuxx 
    dex
    // if(x==0xff)
    // [39] if(main::x#2!=$ff) goto main::@15 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b6
    // [31] phi from main::@9 to main::@6 [phi:main::@9->main::@6]
    // [31] phi main::x#10 = 0 [phi:main::@9->main::@6#0] -- vbuxx=vbuc1 
    ldx #0
    // [31] phi main::y#10 = main::y#11 [phi:main::@9->main::@6#1] -- register_copy 
    jmp __b6
    // [40] phi from main::@9 to main::@15 [phi:main::@9->main::@15]
    // main::@15
    // main::@5
  __b5:
    // x++;
    // [41] main::x#1 = ++ main::x#11 -- vbuxx=_inc_vbuxx 
    inx
    // if(x==40)
    // [42] if(main::x#1!=$28) goto main::@17 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne __b6
    // [31] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // [31] phi main::x#10 = $27 [phi:main::@5->main::@6#0] -- vbuxx=vbuc1 
    ldx #$27
    // [31] phi main::y#10 = main::y#11 [phi:main::@5->main::@6#1] -- register_copy 
    jmp __b6
    // [43] phi from main::@5 to main::@17 [phi:main::@5->main::@17]
    // main::@17
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zp(3) str, byte register(X) c)
memset: {
    .label end = $d
    .label dst = 3
    .label str = 3
    // memset::@1
    // char* end = (char*)str + num
    // [45] memset::end#0 = (byte*)memset::str#4 + $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    clc
    lda.z str
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [46] memset::dst#4 = (byte*)memset::str#4
    // [47] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
    // [47] phi memset::dst#2 = memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    // memset::@2
  __b2:
    // for(char* dst = str; dst!=end; dst++)
    // [48] if(memset::dst#2!=memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    // memset::@return
    // }
    // [49] return 
    rts
    // memset::@3
  __b3:
    // *dst = c
    // [50] *memset::dst#2 = memset::c#5 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [51] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2
}
  // rand
// Returns a pseudo-random number in the range of 0 to RAND_MAX (65535)
// Uses an xorshift pseudorandom number generator that hits all different values
// Information https://en.wikipedia.org/wiki/Xorshift
// Source http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html
rand: {
    .label __0 = $d
    .label __1 = $f
    .label __2 = $11
    .label return = $b
    // rand_state << 7
    // [52] rand::$0 = rand_state#12 << 7 -- vwuz1=vwuz2_rol_7 
    lda.z rand_state+1
    lsr
    lda.z rand_state
    ror
    sta.z __0+1
    lda #0
    ror
    sta.z __0
    // rand_state ^= rand_state << 7
    // [53] rand_state#0 = rand_state#12 ^ rand::$0 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __0
    sta.z rand_state
    lda.z rand_state+1
    eor.z __0+1
    sta.z rand_state+1
    // rand_state >> 9
    // [54] rand::$1 = rand_state#0 >> 9 -- vwuz1=vwuz2_ror_9 
    lsr
    sta.z __1
    lda #0
    sta.z __1+1
    // rand_state ^= rand_state >> 9
    // [55] rand_state#1 = rand_state#0 ^ rand::$1 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __1
    sta.z rand_state
    lda.z rand_state+1
    eor.z __1+1
    sta.z rand_state+1
    // rand_state << 8
    // [56] rand::$2 = rand_state#1 << 8 -- vwuz1=vwuz2_rol_8 
    lda.z rand_state
    sta.z __2+1
    lda #0
    sta.z __2
    // rand_state ^= rand_state << 8
    // [57] rand_state#10 = rand_state#1 ^ rand::$2 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __2
    sta.z rand_state
    lda.z rand_state+1
    eor.z __2+1
    sta.z rand_state+1
    // return rand_state;
    // [58] rand::return#0 = rand_state#10 -- vwuz1=vwuz2 
    lda.z rand_state
    sta.z return
    lda.z rand_state+1
    sta.z return+1
    // rand::@return
    // }
    // [59] return 
    rts
}
  // File Data
.segment Data
  // Colors to fade up/down when visiting a char multiple times
  FADE: .byte 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6
  // The number of times each character has been visited
  VISITS: .fill $3e8, 0

