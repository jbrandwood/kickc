Identified constant variable (byte*) RASTER
Identified constant variable (byte*) D018
Identified constant variable (byte*) BGCOL
Identified constant variable (byte*) screen
Identified constant variable (byte*) charset1
Identified constant variable (byte*) charset2
Inlined call (byte~) main::$1 ← call toD018 (byte*) screen (byte*) charset1 
Inlined call (byte~) main::$3 ← call toD018 (byte*) screen (byte*) charset2 
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@17
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@18
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::toD0181_@1
Culled Empty Block (label) main::@8
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@13
Culled Empty Block (label) main::toD0182_@1
Culled Empty Block (label) main::@14
Culled Empty Block (label) main::@15
Culled Empty Block (label) main::@16
Culled Empty Block (label) @1

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) RASTER#0 ← ((byte*)) (number) $d012
  (byte*) D018#0 ← ((byte*)) (number) $d018
  (byte*) BGCOL#0 ← ((byte*)) (number) $d021
  (byte*) screen#0 ← ((byte*)) (number) $400
  (byte*) charset1#0 ← ((byte*)) (number) $1000
  (byte*) charset2#0 ← ((byte*)) (number) $1800
  to:@2
main: scope:[main]  from @2
  asm { sei  }
  to:main::@1
main::@1: scope:[main]  from main main::@20
  if(true) goto main::@4
  to:main::@return
main::@4: scope:[main]  from main::@1 main::@4
  (bool~) main::$0 ← *((byte*) RASTER#0) != (number) $ff
  if((bool~) main::$0) goto main::@4
  to:main::@6
main::@6: scope:[main]  from main::@4
  (byte*) main::toD0181_screen#0 ← (byte*) screen#0
  (byte*) main::toD0181_charset#0 ← (byte*) charset1#0
  to:main::toD0181
main::toD0181: scope:[main]  from main::@6
  (byte*) main::toD0181_charset#1 ← phi( main::@6/(byte*) main::toD0181_charset#0 )
  (byte*) main::toD0181_screen#1 ← phi( main::@6/(byte*) main::toD0181_screen#0 )
  (word~) main::toD0181_$0#0 ← ((word)) (byte*) main::toD0181_screen#1
  (number~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 / (number) $40
  (word~) main::toD0181_$2#0 ← ((word)) (byte*) main::toD0181_charset#1
  (number~) main::toD0181_$3#0 ← (word~) main::toD0181_$2#0 / (number) $400
  (number~) main::toD0181_$4#0 ← (number~) main::toD0181_$1#0 | (number~) main::toD0181_$3#0
  (byte~) main::toD0181_$5#0 ← ((byte)) (number~) main::toD0181_$4#0
  (byte) main::toD0181_return#0 ← (byte~) main::toD0181_$5#0
  to:main::toD0181_@return
main::toD0181_@return: scope:[main]  from main::toD0181
  (byte) main::toD0181_return#2 ← phi( main::toD0181/(byte) main::toD0181_return#0 )
  (byte) main::toD0181_return#1 ← (byte) main::toD0181_return#2
  to:main::@19
main::@19: scope:[main]  from main::toD0181_@return
  (byte) main::toD0181_return#3 ← phi( main::toD0181_@return/(byte) main::toD0181_return#1 )
  (byte~) main::$1 ← (byte) main::toD0181_return#3
  *((byte*) D018#0) ← (byte~) main::$1
  *((byte*) BGCOL#0) ← (number) 6
  to:main::@10
main::@10: scope:[main]  from main::@10 main::@19
  (bool~) main::$2 ← *((byte*) RASTER#0) != (number) $62
  if((bool~) main::$2) goto main::@10
  to:main::@12
main::@12: scope:[main]  from main::@10
  (byte*) main::toD0182_screen#0 ← (byte*) screen#0
  (byte*) main::toD0182_charset#0 ← (byte*) charset2#0
  to:main::toD0182
main::toD0182: scope:[main]  from main::@12
  (byte*) main::toD0182_charset#1 ← phi( main::@12/(byte*) main::toD0182_charset#0 )
  (byte*) main::toD0182_screen#1 ← phi( main::@12/(byte*) main::toD0182_screen#0 )
  (word~) main::toD0182_$0#0 ← ((word)) (byte*) main::toD0182_screen#1
  (number~) main::toD0182_$1#0 ← (word~) main::toD0182_$0#0 / (number) $40
  (word~) main::toD0182_$2#0 ← ((word)) (byte*) main::toD0182_charset#1
  (number~) main::toD0182_$3#0 ← (word~) main::toD0182_$2#0 / (number) $400
  (number~) main::toD0182_$4#0 ← (number~) main::toD0182_$1#0 | (number~) main::toD0182_$3#0
  (byte~) main::toD0182_$5#0 ← ((byte)) (number~) main::toD0182_$4#0
  (byte) main::toD0182_return#0 ← (byte~) main::toD0182_$5#0
  to:main::toD0182_@return
main::toD0182_@return: scope:[main]  from main::toD0182
  (byte) main::toD0182_return#2 ← phi( main::toD0182/(byte) main::toD0182_return#0 )
  (byte) main::toD0182_return#1 ← (byte) main::toD0182_return#2
  to:main::@20
main::@20: scope:[main]  from main::toD0182_@return
  (byte) main::toD0182_return#3 ← phi( main::toD0182_@return/(byte) main::toD0182_return#1 )
  (byte~) main::$3 ← (byte) main::toD0182_return#3
  *((byte*) D018#0) ← (byte~) main::$3
  *((byte*) BGCOL#0) ← (number) $b
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return
@2: scope:[]  from @begin
  call main 
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(label) @2
(label) @3
(label) @begin
(label) @end
(byte*) BGCOL
(byte*) BGCOL#0
(byte*) D018
(byte*) D018#0
(byte*) RASTER
(byte*) RASTER#0
(byte*) charset1
(byte*) charset1#0
(byte*) charset2
(byte*) charset2#0
(void()) main()
(bool~) main::$0
(byte~) main::$1
(bool~) main::$2
(byte~) main::$3
(label) main::@1
(label) main::@10
(label) main::@12
(label) main::@19
(label) main::@20
(label) main::@4
(label) main::@6
(label) main::@return
(label) main::toD0181
(word~) main::toD0181_$0
(word~) main::toD0181_$0#0
(number~) main::toD0181_$1
(number~) main::toD0181_$1#0
(word~) main::toD0181_$2
(word~) main::toD0181_$2#0
(number~) main::toD0181_$3
(number~) main::toD0181_$3#0
(number~) main::toD0181_$4
(number~) main::toD0181_$4#0
(byte~) main::toD0181_$5
(byte~) main::toD0181_$5#0
(label) main::toD0181_@return
(byte*) main::toD0181_charset
(byte*) main::toD0181_charset#0
(byte*) main::toD0181_charset#1
(byte) main::toD0181_return
(byte) main::toD0181_return#0
(byte) main::toD0181_return#1
(byte) main::toD0181_return#2
(byte) main::toD0181_return#3
(byte*) main::toD0181_screen
(byte*) main::toD0181_screen#0
(byte*) main::toD0181_screen#1
(label) main::toD0182
(word~) main::toD0182_$0
(word~) main::toD0182_$0#0
(number~) main::toD0182_$1
(number~) main::toD0182_$1#0
(word~) main::toD0182_$2
(word~) main::toD0182_$2#0
(number~) main::toD0182_$3
(number~) main::toD0182_$3#0
(number~) main::toD0182_$4
(number~) main::toD0182_$4#0
(byte~) main::toD0182_$5
(byte~) main::toD0182_$5#0
(label) main::toD0182_@return
(byte*) main::toD0182_charset
(byte*) main::toD0182_charset#0
(byte*) main::toD0182_charset#1
(byte) main::toD0182_return
(byte) main::toD0182_return#0
(byte) main::toD0182_return#1
(byte) main::toD0182_return#2
(byte) main::toD0182_return#3
(byte*) main::toD0182_screen
(byte*) main::toD0182_screen#0
(byte*) main::toD0182_screen#1
(byte*) screen
(byte*) screen#0

Adding number conversion cast (unumber) $ff in (bool~) main::$0 ← *((byte*) RASTER#0) != (number) $ff
Adding number conversion cast (unumber) $40 in (number~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 / (number) $40
Adding number conversion cast (unumber) main::toD0181_$1#0 in (number~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 / (unumber)(number) $40
Adding number conversion cast (unumber) $400 in (number~) main::toD0181_$3#0 ← (word~) main::toD0181_$2#0 / (number) $400
Adding number conversion cast (unumber) main::toD0181_$3#0 in (number~) main::toD0181_$3#0 ← (word~) main::toD0181_$2#0 / (unumber)(number) $400
Adding number conversion cast (unumber) main::toD0181_$4#0 in (number~) main::toD0181_$4#0 ← (unumber~) main::toD0181_$1#0 | (unumber~) main::toD0181_$3#0
Adding number conversion cast (unumber) 6 in *((byte*) BGCOL#0) ← (number) 6
Adding number conversion cast (unumber) $62 in (bool~) main::$2 ← *((byte*) RASTER#0) != (number) $62
Adding number conversion cast (unumber) $40 in (number~) main::toD0182_$1#0 ← (word~) main::toD0182_$0#0 / (number) $40
Adding number conversion cast (unumber) main::toD0182_$1#0 in (number~) main::toD0182_$1#0 ← (word~) main::toD0182_$0#0 / (unumber)(number) $40
Adding number conversion cast (unumber) $400 in (number~) main::toD0182_$3#0 ← (word~) main::toD0182_$2#0 / (number) $400
Adding number conversion cast (unumber) main::toD0182_$3#0 in (number~) main::toD0182_$3#0 ← (word~) main::toD0182_$2#0 / (unumber)(number) $400
Adding number conversion cast (unumber) main::toD0182_$4#0 in (number~) main::toD0182_$4#0 ← (unumber~) main::toD0182_$1#0 | (unumber~) main::toD0182_$3#0
Adding number conversion cast (unumber) $b in *((byte*) BGCOL#0) ← (number) $b
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) RASTER#0 ← (byte*)(number) $d012
Inlining cast (byte*) D018#0 ← (byte*)(number) $d018
Inlining cast (byte*) BGCOL#0 ← (byte*)(number) $d021
Inlining cast (byte*) screen#0 ← (byte*)(number) $400
Inlining cast (byte*) charset1#0 ← (byte*)(number) $1000
Inlining cast (byte*) charset2#0 ← (byte*)(number) $1800
Inlining cast (word~) main::toD0181_$0#0 ← (word)(byte*) main::toD0181_screen#1
Inlining cast (word~) main::toD0181_$2#0 ← (word)(byte*) main::toD0181_charset#1
Inlining cast (byte~) main::toD0181_$5#0 ← (byte)(unumber~) main::toD0181_$4#0
Inlining cast *((byte*) BGCOL#0) ← (unumber)(number) 6
Inlining cast (word~) main::toD0182_$0#0 ← (word)(byte*) main::toD0182_screen#1
Inlining cast (word~) main::toD0182_$2#0 ← (word)(byte*) main::toD0182_charset#1
Inlining cast (byte~) main::toD0182_$5#0 ← (byte)(unumber~) main::toD0182_$4#0
Inlining cast *((byte*) BGCOL#0) ← (unumber)(number) $b
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53272
Simplifying constant pointer cast (byte*) 53281
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 4096
Simplifying constant pointer cast (byte*) 6144
Simplifying constant integer cast $ff
Simplifying constant integer cast $40
Simplifying constant integer cast $400
Simplifying constant integer cast 6
Simplifying constant integer cast $62
Simplifying constant integer cast $40
Simplifying constant integer cast $400
Simplifying constant integer cast $b
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $400
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) $62
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $400
Finalized unsigned number type (byte) $b
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to word in (unumber~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 / (byte) $40
Inferred type updated to word in (unumber~) main::toD0181_$3#0 ← (word~) main::toD0181_$2#0 / (word) $400
Inferred type updated to word in (unumber~) main::toD0181_$4#0 ← (word~) main::toD0181_$1#0 | (word~) main::toD0181_$3#0
Inferred type updated to word in (unumber~) main::toD0182_$1#0 ← (word~) main::toD0182_$0#0 / (byte) $40
Inferred type updated to word in (unumber~) main::toD0182_$3#0 ← (word~) main::toD0182_$2#0 / (word) $400
Inferred type updated to word in (unumber~) main::toD0182_$4#0 ← (word~) main::toD0182_$1#0 | (word~) main::toD0182_$3#0
Alias (byte*) main::toD0181_screen#0 = (byte*) main::toD0181_screen#1 
Alias (byte*) main::toD0181_charset#0 = (byte*) main::toD0181_charset#1 
Alias (byte) main::toD0181_return#0 = (byte~) main::toD0181_$5#0 (byte) main::toD0181_return#2 (byte) main::toD0181_return#1 (byte) main::toD0181_return#3 (byte~) main::$1 
Alias (byte*) main::toD0182_screen#0 = (byte*) main::toD0182_screen#1 
Alias (byte*) main::toD0182_charset#0 = (byte*) main::toD0182_charset#1 
Alias (byte) main::toD0182_return#0 = (byte~) main::toD0182_$5#0 (byte) main::toD0182_return#2 (byte) main::toD0182_return#1 (byte) main::toD0182_return#3 (byte~) main::$3 
Successful SSA optimization Pass2AliasElimination
Simple Condition (bool~) main::$0 [9] if(*((byte*) RASTER#0)!=(byte) $ff) goto main::@4
Simple Condition (bool~) main::$2 [27] if(*((byte*) RASTER#0)!=(byte) $62) goto main::@10
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) RASTER#0 = (byte*) 53266
Constant (const byte*) D018#0 = (byte*) 53272
Constant (const byte*) BGCOL#0 = (byte*) 53281
Constant (const byte*) screen#0 = (byte*) 1024
Constant (const byte*) charset1#0 = (byte*) 4096
Constant (const byte*) charset2#0 = (byte*) 6144
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) main::toD0181_screen#0 = screen#0
Constant (const byte*) main::toD0181_charset#0 = charset1#0
Constant (const byte*) main::toD0182_screen#0 = screen#0
Constant (const byte*) main::toD0182_charset#0 = charset2#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)main::toD0181_screen#0 in [13] (word~) main::toD0181_$0#0 ← (word)(const byte*) main::toD0181_screen#0
Constant value identified (word)main::toD0181_charset#0 in [15] (word~) main::toD0181_$2#0 ← (word)(const byte*) main::toD0181_charset#0
Constant value identified (word)main::toD0182_screen#0 in [31] (word~) main::toD0182_$0#0 ← (word)(const byte*) main::toD0182_screen#0
Constant value identified (word)main::toD0182_charset#0 in [33] (word~) main::toD0182_$2#0 ← (word)(const byte*) main::toD0182_charset#0
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [7] if(true) goto main::@4
Successful SSA optimization Pass2ConstantIfs
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Constant (const word) main::toD0181_$0#0 = (word)main::toD0181_screen#0
Constant (const word) main::toD0181_$2#0 = (word)main::toD0181_charset#0
Constant (const word) main::toD0182_$0#0 = (word)main::toD0182_screen#0
Constant (const word) main::toD0182_$2#0 = (word)main::toD0182_charset#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [2] (word~) main::toD0181_$1#0 ← (const word) main::toD0181_$0#0 / (byte) $40
Constant right-side identified [3] (word~) main::toD0181_$3#0 ← (const word) main::toD0181_$2#0 / (word) $400
Constant right-side identified [9] (word~) main::toD0182_$1#0 ← (const word) main::toD0182_$0#0 / (byte) $40
Constant right-side identified [10] (word~) main::toD0182_$3#0 ← (const word) main::toD0182_$2#0 / (word) $400
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::toD0181_$1#0 = main::toD0181_$0#0/$40
Constant (const word) main::toD0181_$3#0 = main::toD0181_$2#0/$400
Constant (const word) main::toD0182_$1#0 = main::toD0182_$0#0/$40
Constant (const word) main::toD0182_$3#0 = main::toD0182_$2#0/$400
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [2] (word~) main::toD0181_$4#0 ← (const word) main::toD0181_$1#0 | (const word) main::toD0181_$3#0
Constant right-side identified [7] (word~) main::toD0182_$4#0 ← (const word) main::toD0182_$1#0 | (const word) main::toD0182_$3#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::toD0181_$4#0 = main::toD0181_$1#0|main::toD0181_$3#0
Constant (const word) main::toD0182_$4#0 = main::toD0182_$1#0|main::toD0182_$3#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)main::toD0181_$4#0 in [3] (byte) main::toD0181_return#0 ← (byte)(const word) main::toD0181_$4#0
Constant value identified (byte)main::toD0182_$4#0 in [8] (byte) main::toD0182_return#0 ← (byte)(const word) main::toD0182_$4#0
Successful SSA optimization Pass2ConstantValues
Constant (const byte) main::toD0181_return#0 = (byte)main::toD0181_$4#0
Constant (const byte) main::toD0182_return#0 = (byte)main::toD0182_$4#0
Successful SSA optimization Pass2ConstantIdentification
Constant inlined main::toD0181_screen#0 = (const byte*) screen#0
Constant inlined main::toD0182_charset#0 = (const byte*) charset2#0
Constant inlined main::toD0182_$4#0 = (word)(const byte*) screen#0/(byte) $40|(word)(const byte*) charset2#0/(word) $400
Constant inlined main::toD0182_$3#0 = (word)(const byte*) charset2#0/(word) $400
Constant inlined main::toD0181_$0#0 = (word)(const byte*) screen#0
Constant inlined main::toD0181_$1#0 = (word)(const byte*) screen#0/(byte) $40
Constant inlined main::toD0181_$2#0 = (word)(const byte*) charset1#0
Constant inlined main::toD0182_$0#0 = (word)(const byte*) screen#0
Constant inlined main::toD0182_screen#0 = (const byte*) screen#0
Constant inlined main::toD0181_$3#0 = (word)(const byte*) charset1#0/(word) $400
Constant inlined main::toD0182_$2#0 = (word)(const byte*) charset2#0
Constant inlined main::toD0181_$4#0 = (word)(const byte*) screen#0/(byte) $40|(word)(const byte*) charset1#0/(word) $400
Constant inlined main::toD0182_$1#0 = (word)(const byte*) screen#0/(byte) $40
Constant inlined main::toD0181_charset#0 = (const byte*) charset1#0
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0181_@return
Adding NOP phi() at start of main::@12
Adding NOP phi() at start of main::toD0182
Adding NOP phi() at start of main::toD0182_@return
CALL GRAPH
Calls in [] to main:2 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block (label) @3
Culled Empty Block (label) main::@1
Culled Empty Block (label) main::@6
Culled Empty Block (label) main::toD0181_@return
Culled Empty Block (label) main::@12
Culled Empty Block (label) main::toD0182_@return
Renumbering block @2 to @1
Renumbering block main::@4 to main::@1
Renumbering block main::@10 to main::@2
Renumbering block main::@19 to main::@3
Renumbering block main::@20 to main::@4
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0182

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  asm { sei  }
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@4
  [5] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@1
  to:main::toD0181
main::toD0181: scope:[main]  from main::@1
  [6] phi()
  to:main::@3
main::@3: scope:[main]  from main::toD0181
  [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0
  [8] *((const byte*) BGCOL#0) ← (byte) 6
  to:main::@2
main::@2: scope:[main]  from main::@2 main::@3
  [9] if(*((const byte*) RASTER#0)!=(byte) $62) goto main::@2
  to:main::toD0182
main::toD0182: scope:[main]  from main::@2
  [10] phi()
  to:main::@4
main::@4: scope:[main]  from main::toD0182
  [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0
  [12] *((const byte*) BGCOL#0) ← (byte) $b
  to:main::@1


VARIABLE REGISTER WEIGHTS
(byte*) BGCOL
(byte*) D018
(byte*) RASTER
(byte*) charset1
(byte*) charset2
(void()) main()
(word~) main::toD0181_$0
(number~) main::toD0181_$1
(word~) main::toD0181_$2
(number~) main::toD0181_$3
(number~) main::toD0181_$4
(byte~) main::toD0181_$5
(byte*) main::toD0181_charset
(byte) main::toD0181_return
(byte*) main::toD0181_screen
(word~) main::toD0182_$0
(number~) main::toD0182_$1
(word~) main::toD0182_$2
(number~) main::toD0182_$3
(number~) main::toD0182_$4
(byte~) main::toD0182_$5
(byte*) main::toD0182_charset
(byte) main::toD0182_return
(byte*) main::toD0182_screen
(byte*) screen

Initial phi equivalence classes
Complete equivalence classes

INITIAL ASM
Target platform is c64basic / 6502X
  // File Comments
// Test inline function
// Splits screen so upper half is lower case and lower half lower case
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label RASTER = $d012
  .label D018 = $d018
  .label BGCOL = $d021
  .label screen = $400
  .label charset1 = $1000
  .label charset2 = $1800
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .const toD0181_return = screen/$40|charset1/$400
    .const toD0182_return = screen/$40|charset2/$400
    // asm { sei  }
    sei
    jmp b1
    // main::@1
  b1:
    // [5] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b1
    // [6] phi from main::@1 to main::toD0181 [phi:main::@1->main::toD0181]
  toD0181_from_b1:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp b3
    // main::@3
  b3:
    // [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // [8] *((const byte*) BGCOL#0) ← (byte) 6 -- _deref_pbuc1=vbuc2 
    lda #6
    sta BGCOL
    jmp b2
    // main::@2
  b2:
    // [9] if(*((const byte*) RASTER#0)!=(byte) $62) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$62
    cmp RASTER
    bne b2
    // [10] phi from main::@2 to main::toD0182 [phi:main::@2->main::toD0182]
  toD0182_from_b2:
    jmp toD0182
    // main::toD0182
  toD0182:
    jmp b4
    // main::@4
  b4:
    // [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0182_return
    sta D018
    // [12] *((const byte*) BGCOL#0) ← (byte) $b -- _deref_pbuc1=vbuc2 
    lda #$b
    sta BGCOL
    jmp b1
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [5] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [8] *((const byte*) BGCOL#0) ← (byte) 6 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [9] if(*((const byte*) RASTER#0)!=(byte) $62) goto main::@2 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] *((const byte*) BGCOL#0) ← (byte) $b [ ] ( main:2 [ ] ) always clobbers reg byte a 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [main] best 2137 combination 
Uplifting [] best 2137 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test inline function
// Splits screen so upper half is lower case and lower half lower case
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label RASTER = $d012
  .label D018 = $d018
  .label BGCOL = $d021
  .label screen = $400
  .label charset1 = $1000
  .label charset2 = $1800
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .const toD0181_return = screen/$40|charset1/$400
    .const toD0182_return = screen/$40|charset2/$400
    // asm { sei  }
    sei
    jmp b1
    // main::@1
  b1:
    // [5] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b1
    // [6] phi from main::@1 to main::toD0181 [phi:main::@1->main::toD0181]
  toD0181_from_b1:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp b3
    // main::@3
  b3:
    // [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // [8] *((const byte*) BGCOL#0) ← (byte) 6 -- _deref_pbuc1=vbuc2 
    lda #6
    sta BGCOL
    jmp b2
    // main::@2
  b2:
    // [9] if(*((const byte*) RASTER#0)!=(byte) $62) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$62
    cmp RASTER
    bne b2
    // [10] phi from main::@2 to main::toD0182 [phi:main::@2->main::toD0182]
  toD0182_from_b2:
    jmp toD0182
    // main::toD0182
  toD0182:
    jmp b4
    // main::@4
  b4:
    // [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0182_return
    sta D018
    // [12] *((const byte*) BGCOL#0) ← (byte) $b -- _deref_pbuc1=vbuc2 
    lda #$b
    sta BGCOL
    jmp b1
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp toD0181
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp toD0182
Removing instruction jmp b4
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction bend_from_b1:
Removing instruction toD0181_from_b1:
Removing instruction toD0181:
Removing instruction toD0182_from_b2:
Removing instruction toD0182:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b3:
Removing instruction b4:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) BGCOL
(const byte*) BGCOL#0 BGCOL = (byte*) 53281
(byte*) D018
(const byte*) D018#0 D018 = (byte*) 53272
(byte*) RASTER
(const byte*) RASTER#0 RASTER = (byte*) 53266
(byte*) charset1
(const byte*) charset1#0 charset1 = (byte*) 4096
(byte*) charset2
(const byte*) charset2#0 charset2 = (byte*) 6144
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::toD0181
(word~) main::toD0181_$0
(number~) main::toD0181_$1
(word~) main::toD0181_$2
(number~) main::toD0181_$3
(number~) main::toD0181_$4
(byte~) main::toD0181_$5
(byte*) main::toD0181_charset
(byte) main::toD0181_return
(const byte) main::toD0181_return#0 toD0181_return = (byte)(word)(const byte*) screen#0/(byte) $40|(word)(const byte*) charset1#0/(word) $400
(byte*) main::toD0181_screen
(label) main::toD0182
(word~) main::toD0182_$0
(number~) main::toD0182_$1
(word~) main::toD0182_$2
(number~) main::toD0182_$3
(number~) main::toD0182_$4
(byte~) main::toD0182_$5
(byte*) main::toD0182_charset
(byte) main::toD0182_return
(const byte) main::toD0182_return#0 toD0182_return = (byte)(word)(const byte*) screen#0/(byte) $40|(word)(const byte*) charset2#0/(word) $400
(byte*) main::toD0182_screen
(byte*) screen
(const byte*) screen#0 screen = (byte*) 1024



FINAL ASSEMBLER
Score: 1972

  // File Comments
// Test inline function
// Splits screen so upper half is lower case and lower half lower case
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label RASTER = $d012
  .label D018 = $d018
  .label BGCOL = $d021
  .label screen = $400
  .label charset1 = $1000
  .label charset2 = $1800
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .const toD0181_return = screen/$40|charset1/$400
    .const toD0182_return = screen/$40|charset2/$400
    // asm
    // asm { sei  }
    sei
    // main::@1
  b1:
    // while(*RASTER!=$ff)
    // [5] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b1
    // [6] phi from main::@1 to main::toD0181 [phi:main::@1->main::toD0181]
    // main::toD0181
    // main::@3
    // *D018 = toD018(screen, charset1)
    // [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // *BGCOL = $6
    // [8] *((const byte*) BGCOL#0) ← (byte) 6 -- _deref_pbuc1=vbuc2 
    lda #6
    sta BGCOL
    // main::@2
  b2:
    // while(*RASTER!=$62)
    // [9] if(*((const byte*) RASTER#0)!=(byte) $62) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$62
    cmp RASTER
    bne b2
    // [10] phi from main::@2 to main::toD0182 [phi:main::@2->main::toD0182]
    // main::toD0182
    // main::@4
    // *D018 = toD018(screen, charset2)
    // [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0182_return
    sta D018
    // *BGCOL = $b
    // [12] *((const byte*) BGCOL#0) ← (byte) $b -- _deref_pbuc1=vbuc2 
    lda #$b
    sta BGCOL
    jmp b1
}
  // File Data

