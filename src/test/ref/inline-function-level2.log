Inlined call call line 2 $40 $a '*' 
Inlined call call plot main::line1_$1 main::line1_ch 
Inlined call call line 4 $80 $f '.' 
Inlined call call plot main::line2_$1 main::line2_ch 
Inlined call call plot line::$1 line::ch 
Inlined call call __init 

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  main::sc#0 = (byte*)$400
  to:main::@1
main::@1: scope:[main]  from main main::@2
  main::sc#2 = phi( main/main::sc#0, main::@2/main::sc#1 )
  main::$2 = main::sc#2 < $400+$3e8
  if(main::$2) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  main::sc#3 = phi( main::@1/main::sc#2 )
  *main::sc#3 = ' '
  main::sc#1 = ++ main::sc#3
  to:main::@1
main::@3: scope:[main]  from main::@1
  main::line1_xpos#0 = 2
  main::line1_xadd#0 = $40
  main::line1_ysize#0 = $a
  main::line1_ch#0 = '*'
  to:main::line1
main::line1: scope:[main]  from main::@3
  main::line1_xadd#5 = phi( main::@3/main::line1_xadd#0 )
  main::line1_ch#4 = phi( main::@3/main::line1_ch#0 )
  main::line1_ysize#3 = phi( main::@3/main::line1_ysize#0 )
  main::line1_xpos#1 = phi( main::@3/main::line1_xpos#0 )
  cur_line#0 = (byte*)$400
  main::line1_pos#0 = (word){ main::line1_xpos#1, 0 }
  main::line1_i#0 = 0
  to:main::line1_@1
main::line1_@1: scope:[main]  from main::@5 main::line1
  main::line1_xadd#4 = phi( main::@5/main::line1_xadd#1, main::line1/main::line1_xadd#5 )
  cur_line#19 = phi( main::@5/cur_line#1, main::line1/cur_line#0 )
  main::line1_ch#2 = phi( main::@5/main::line1_ch#3, main::line1/main::line1_ch#4 )
  main::line1_pos#4 = phi( main::@5/main::line1_pos#1, main::line1/main::line1_pos#0 )
  main::line1_ysize#1 = phi( main::@5/main::line1_ysize#2, main::line1/main::line1_ysize#3 )
  main::line1_i#2 = phi( main::@5/main::line1_i#1, main::line1/main::line1_i#0 )
  main::line1_$0 = main::line1_i#2 < main::line1_ysize#1
  if(main::line1_$0) goto main::line1_@2
  to:main::@4
main::line1_@2: scope:[main]  from main::line1_@1
  main::line1_ysize#5 = phi( main::line1_@1/main::line1_ysize#1 )
  main::line1_i#5 = phi( main::line1_@1/main::line1_i#2 )
  main::line1_xadd#3 = phi( main::line1_@1/main::line1_xadd#4 )
  cur_line#15 = phi( main::line1_@1/cur_line#19 )
  main::line1_ch#1 = phi( main::line1_@1/main::line1_ch#2 )
  main::line1_pos#2 = phi( main::line1_@1/main::line1_pos#4 )
  main::line1_$1 = > main::line1_pos#2
  main::plot1_xpos#0 = main::line1_$1
  main::plot1_ch#0 = main::line1_ch#1
  to:main::plot1
main::plot1: scope:[main]  from main::line1_@2
  main::line1_ch#5 = phi( main::line1_@2/main::line1_ch#1 )
  main::line1_ysize#4 = phi( main::line1_@2/main::line1_ysize#5 )
  main::line1_i#4 = phi( main::line1_@2/main::line1_i#5 )
  main::line1_xadd#2 = phi( main::line1_@2/main::line1_xadd#3 )
  main::line1_pos#5 = phi( main::line1_@2/main::line1_pos#2 )
  main::plot1_ch#1 = phi( main::line1_@2/main::plot1_ch#0 )
  main::plot1_xpos#1 = phi( main::line1_@2/main::plot1_xpos#0 )
  cur_line#8 = phi( main::line1_@2/cur_line#15 )
  main::plot1_$0 = cur_line#8 + main::plot1_xpos#1
  *main::plot1_$0 = main::plot1_ch#1
  to:main::@5
main::@5: scope:[main]  from main::plot1
  main::line1_ch#3 = phi( main::plot1/main::line1_ch#5 )
  main::line1_ysize#2 = phi( main::plot1/main::line1_ysize#4 )
  main::line1_i#3 = phi( main::plot1/main::line1_i#4 )
  cur_line#9 = phi( main::plot1/cur_line#8 )
  main::line1_xadd#1 = phi( main::plot1/main::line1_xadd#2 )
  main::line1_pos#3 = phi( main::plot1/main::line1_pos#5 )
  main::line1_pos#1 = main::line1_pos#3 + main::line1_xadd#1
  cur_line#1 = cur_line#9 + $28
  main::line1_i#1 = ++ main::line1_i#3
  to:main::line1_@1
main::@4: scope:[main]  from main::line1_@1
  main::line2_xpos#0 = 4
  main::line2_xadd#0 = $80
  main::line2_ysize#0 = $f
  main::line2_ch#0 = '.'
  to:main::line2
main::line2: scope:[main]  from main::@4
  main::line2_xadd#5 = phi( main::@4/main::line2_xadd#0 )
  main::line2_ch#4 = phi( main::@4/main::line2_ch#0 )
  main::line2_ysize#3 = phi( main::@4/main::line2_ysize#0 )
  main::line2_xpos#1 = phi( main::@4/main::line2_xpos#0 )
  cur_line#2 = (byte*)$400
  main::line2_pos#0 = (word){ main::line2_xpos#1, 0 }
  main::line2_i#0 = 0
  to:main::line2_@1
main::line2_@1: scope:[main]  from main::@6 main::line2
  main::line2_xadd#4 = phi( main::@6/main::line2_xadd#1, main::line2/main::line2_xadd#5 )
  cur_line#17 = phi( main::@6/cur_line#3, main::line2/cur_line#2 )
  main::line2_ch#2 = phi( main::@6/main::line2_ch#3, main::line2/main::line2_ch#4 )
  main::line2_pos#4 = phi( main::@6/main::line2_pos#1, main::line2/main::line2_pos#0 )
  main::line2_ysize#1 = phi( main::@6/main::line2_ysize#2, main::line2/main::line2_ysize#3 )
  main::line2_i#2 = phi( main::@6/main::line2_i#1, main::line2/main::line2_i#0 )
  main::line2_$0 = main::line2_i#2 < main::line2_ysize#1
  if(main::line2_$0) goto main::line2_@2
  to:main::@return
main::line2_@2: scope:[main]  from main::line2_@1
  main::line2_ysize#5 = phi( main::line2_@1/main::line2_ysize#1 )
  main::line2_i#5 = phi( main::line2_@1/main::line2_i#2 )
  main::line2_xadd#3 = phi( main::line2_@1/main::line2_xadd#4 )
  cur_line#16 = phi( main::line2_@1/cur_line#17 )
  main::line2_ch#1 = phi( main::line2_@1/main::line2_ch#2 )
  main::line2_pos#2 = phi( main::line2_@1/main::line2_pos#4 )
  main::line2_$1 = > main::line2_pos#2
  main::plot2_xpos#0 = main::line2_$1
  main::plot2_ch#0 = main::line2_ch#1
  to:main::plot2
main::plot2: scope:[main]  from main::line2_@2
  main::line2_ch#5 = phi( main::line2_@2/main::line2_ch#1 )
  main::line2_ysize#4 = phi( main::line2_@2/main::line2_ysize#5 )
  main::line2_i#4 = phi( main::line2_@2/main::line2_i#5 )
  main::line2_xadd#2 = phi( main::line2_@2/main::line2_xadd#3 )
  main::line2_pos#5 = phi( main::line2_@2/main::line2_pos#2 )
  main::plot2_ch#1 = phi( main::line2_@2/main::plot2_ch#0 )
  main::plot2_xpos#1 = phi( main::line2_@2/main::plot2_xpos#0 )
  cur_line#10 = phi( main::line2_@2/cur_line#16 )
  main::plot2_$0 = cur_line#10 + main::plot2_xpos#1
  *main::plot2_$0 = main::plot2_ch#1
  to:main::@6
main::@6: scope:[main]  from main::plot2
  main::line2_ch#3 = phi( main::plot2/main::line2_ch#5 )
  main::line2_ysize#2 = phi( main::plot2/main::line2_ysize#4 )
  main::line2_i#3 = phi( main::plot2/main::line2_i#4 )
  cur_line#11 = phi( main::plot2/cur_line#10 )
  main::line2_xadd#1 = phi( main::plot2/main::line2_xadd#2 )
  main::line2_pos#3 = phi( main::plot2/main::line2_pos#5 )
  main::line2_pos#1 = main::line2_pos#3 + main::line2_xadd#1
  cur_line#3 = cur_line#11 + $28
  main::line2_i#1 = ++ main::line2_i#3
  to:main::line2_@1
main::@return: scope:[main]  from main::line2_@1
  cur_line#12 = phi( main::line2_@1/cur_line#17 )
  cur_line#4 = cur_line#12
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  cur_line#5 = (byte*)$400
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  cur_line#18 = phi( __start::__init1/cur_line#5 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  cur_line#13 = phi( __start::@1/cur_line#4 )
  cur_line#6 = cur_line#13
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  cur_line#14 = phi( __start::@2/cur_line#6 )
  cur_line#7 = cur_line#14
  return 
  to:@return

SYMBOL TABLE SSA
void __start()
byte* cur_line
byte* cur_line#0
byte* cur_line#1
byte* cur_line#10
byte* cur_line#11
byte* cur_line#12
byte* cur_line#13
byte* cur_line#14
byte* cur_line#15
byte* cur_line#16
byte* cur_line#17
byte* cur_line#18
byte* cur_line#19
byte* cur_line#2
byte* cur_line#3
byte* cur_line#4
byte* cur_line#5
byte* cur_line#6
byte* cur_line#7
byte* cur_line#8
byte* cur_line#9
void main()
bool~ main::$2
bool~ main::line1_$0
byte~ main::line1_$1
byte main::line1_ch
byte main::line1_ch#0
byte main::line1_ch#1
byte main::line1_ch#2
byte main::line1_ch#3
byte main::line1_ch#4
byte main::line1_ch#5
byte main::line1_i
byte main::line1_i#0
byte main::line1_i#1
byte main::line1_i#2
byte main::line1_i#3
byte main::line1_i#4
byte main::line1_i#5
word main::line1_pos
word main::line1_pos#0
word main::line1_pos#1
word main::line1_pos#2
word main::line1_pos#3
word main::line1_pos#4
word main::line1_pos#5
byte main::line1_xadd
byte main::line1_xadd#0
byte main::line1_xadd#1
byte main::line1_xadd#2
byte main::line1_xadd#3
byte main::line1_xadd#4
byte main::line1_xadd#5
byte main::line1_xpos
byte main::line1_xpos#0
byte main::line1_xpos#1
byte main::line1_ysize
byte main::line1_ysize#0
byte main::line1_ysize#1
byte main::line1_ysize#2
byte main::line1_ysize#3
byte main::line1_ysize#4
byte main::line1_ysize#5
bool~ main::line2_$0
byte~ main::line2_$1
byte main::line2_ch
byte main::line2_ch#0
byte main::line2_ch#1
byte main::line2_ch#2
byte main::line2_ch#3
byte main::line2_ch#4
byte main::line2_ch#5
byte main::line2_i
byte main::line2_i#0
byte main::line2_i#1
byte main::line2_i#2
byte main::line2_i#3
byte main::line2_i#4
byte main::line2_i#5
word main::line2_pos
word main::line2_pos#0
word main::line2_pos#1
word main::line2_pos#2
word main::line2_pos#3
word main::line2_pos#4
word main::line2_pos#5
byte main::line2_xadd
byte main::line2_xadd#0
byte main::line2_xadd#1
byte main::line2_xadd#2
byte main::line2_xadd#3
byte main::line2_xadd#4
byte main::line2_xadd#5
byte main::line2_xpos
byte main::line2_xpos#0
byte main::line2_xpos#1
byte main::line2_ysize
byte main::line2_ysize#0
byte main::line2_ysize#1
byte main::line2_ysize#2
byte main::line2_ysize#3
byte main::line2_ysize#4
byte main::line2_ysize#5
byte*~ main::plot1_$0
byte main::plot1_ch
byte main::plot1_ch#0
byte main::plot1_ch#1
byte main::plot1_xpos
byte main::plot1_xpos#0
byte main::plot1_xpos#1
byte*~ main::plot2_$0
byte main::plot2_ch
byte main::plot2_ch#0
byte main::plot2_ch#1
byte main::plot2_xpos
byte main::plot2_xpos#0
byte main::plot2_xpos#1
byte* main::sc
byte* main::sc#0
byte* main::sc#1
byte* main::sc#2
byte* main::sc#3

Fixing inline constructor with main::$3 = (byte)main::line1_xpos#1 w= (byte)0
Fixing inline constructor with main::$4 = (byte)main::line2_xpos#1 w= (byte)0
Successful SSA optimization Pass2FixInlineConstructors
Adding number conversion cast (unumber) $400+$3e8 in main::$2 = main::sc#2 < $400+$3e8
Adding number conversion cast (unumber) 2 in main::line1_xpos#0 = 2
Adding number conversion cast (unumber) $40 in main::line1_xadd#0 = $40
Adding number conversion cast (unumber) $a in main::line1_ysize#0 = $a
Adding number conversion cast (unumber) $28 in cur_line#1 = cur_line#9 + $28
Adding number conversion cast (unumber) 4 in main::line2_xpos#0 = 4
Adding number conversion cast (unumber) $80 in main::line2_xadd#0 = $80
Adding number conversion cast (unumber) $f in main::line2_ysize#0 = $f
Adding number conversion cast (unumber) $28 in cur_line#3 = cur_line#11 + $28
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast main::line1_xpos#0 = (unumber)2
Inlining cast main::line1_xadd#0 = (unumber)$40
Inlining cast main::line1_ysize#0 = (unumber)$a
Inlining cast main::line2_xpos#0 = (unumber)4
Inlining cast main::line2_xadd#0 = (unumber)$80
Inlining cast main::line2_ysize#0 = (unumber)$f
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 2
Simplifying constant integer cast $40
Simplifying constant integer cast $a
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast main::line1_xpos#1
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast 4
Simplifying constant integer cast $80
Simplifying constant integer cast $f
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast main::line2_xpos#1
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant pointer cast (byte*) 1024
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias main::sc#2 = main::sc#3 
Alias main::line1_xpos#0 = main::line1_xpos#1 
Alias main::line1_ysize#0 = main::line1_ysize#3 
Alias main::line1_ch#0 = main::line1_ch#4 
Alias main::line1_xadd#0 = main::line1_xadd#5 
Alias main::line1_pos#0 = main::$3 
Alias main::line1_pos#2 = main::line1_pos#4 main::line1_pos#5 main::line1_pos#3 
Alias main::line1_ch#1 = main::line1_ch#2 main::plot1_ch#0 main::plot1_ch#1 main::line1_ch#5 main::line1_ch#3 
Alias cur_line#15 = cur_line#19 cur_line#8 cur_line#9 
Alias main::line1_xadd#1 = main::line1_xadd#3 main::line1_xadd#4 main::line1_xadd#2 
Alias main::line1_i#2 = main::line1_i#5 main::line1_i#4 main::line1_i#3 
Alias main::line1_ysize#1 = main::line1_ysize#5 main::line1_ysize#4 main::line1_ysize#2 
Alias main::plot1_xpos#0 = main::line1_$1 main::plot1_xpos#1 
Alias main::line2_xpos#0 = main::line2_xpos#1 
Alias main::line2_ysize#0 = main::line2_ysize#3 
Alias main::line2_ch#0 = main::line2_ch#4 
Alias main::line2_xadd#0 = main::line2_xadd#5 
Alias main::line2_pos#0 = main::$4 
Alias main::line2_pos#2 = main::line2_pos#4 main::line2_pos#5 main::line2_pos#3 
Alias main::line2_ch#1 = main::line2_ch#2 main::plot2_ch#0 main::plot2_ch#1 main::line2_ch#5 main::line2_ch#3 
Alias cur_line#10 = cur_line#16 cur_line#17 cur_line#11 cur_line#12 cur_line#4 
Alias main::line2_xadd#1 = main::line2_xadd#3 main::line2_xadd#4 main::line2_xadd#2 
Alias main::line2_i#2 = main::line2_i#5 main::line2_i#4 main::line2_i#3 
Alias main::line2_ysize#1 = main::line2_ysize#5 main::line2_ysize#4 main::line2_ysize#2 
Alias main::plot2_xpos#0 = main::line2_$1 main::plot2_xpos#1 
Alias cur_line#18 = cur_line#5 
Alias cur_line#13 = cur_line#6 cur_line#14 cur_line#7 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values main::line1_ysize#1 main::line1_ysize#0
Identical Phi Values main::line1_ch#1 main::line1_ch#0
Identical Phi Values main::line1_xadd#1 main::line1_xadd#0
Identical Phi Values main::line2_ysize#1 main::line2_ysize#0
Identical Phi Values main::line2_ch#1 main::line2_ch#0
Identical Phi Values main::line2_xadd#1 main::line2_xadd#0
Identical Phi Values cur_line#13 cur_line#10
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$2 [3] if(main::sc#2<(word)$400+$3e8) goto main::@2
Simple Condition main::line1_$0 [15] if(main::line1_i#2<main::line1_ysize#0) goto main::line1_@2
Simple Condition main::line2_$0 [31] if(main::line2_i#2<main::line2_ysize#0) goto main::line2_@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant main::sc#0 = (byte*) 1024
Constant main::line1_xpos#0 = 2
Constant main::line1_xadd#0 = $40
Constant main::line1_ysize#0 = $a
Constant main::line1_ch#0 = '*'
Constant cur_line#0 = (byte*) 1024
Constant main::line1_i#0 = 0
Constant main::line2_xpos#0 = 4
Constant main::line2_xadd#0 = $80
Constant main::line2_ysize#0 = $f
Constant main::line2_ch#0 = '.'
Constant cur_line#2 = (byte*) 1024
Constant main::line2_i#0 = 0
Constant cur_line#18 = (byte*) 1024
Successful SSA optimization Pass2ConstantIdentification
Converting *(pointer+n) to pointer[n] [18] *main::plot1_$0 = main::line1_ch#0  -- cur_line#15[main::plot1_xpos#0]
Converting *(pointer+n) to pointer[n] [34] *main::plot2_$0 = main::line2_ch#0  -- cur_line#10[main::plot2_xpos#0]
Successful SSA optimization Pass2InlineDerefIdx
Eliminating unused variable main::plot1_$0 and assignment [8] main::plot1_$0 = cur_line#15 + main::plot1_xpos#0
Eliminating unused variable main::plot2_$0 and assignment [17] main::plot2_$0 = cur_line#10 + main::plot2_xpos#0
Eliminating unused constant cur_line#18
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Constant right-side identified [4] main::line1_pos#0 = main::line1_xpos#0 w= 0
Constant right-side identified [12] main::line2_pos#0 = main::line2_xpos#0 w= 0
Successful SSA optimization Pass2ConstantRValueConsolidation
Simplifying expression containing zero main::line1_xpos#0*$100 in [4] main::line1_pos#0 = main::line1_xpos#0*$100+0
Simplifying expression containing zero main::line2_xpos#0*$100 in [12] main::line2_pos#0 = main::line2_xpos#0*$100+0
Successful SSA optimization PassNSimplifyExpressionWithZero
Adding number conversion cast (unumber) main::line1_xpos#0*$100 in main::line1_pos#0 = main::line1_xpos#0*$100
Adding number conversion cast (unumber) $100 in main::line1_pos#0 = ((unumber)) main::line1_xpos#0*$100
Adding number conversion cast (unumber) main::line2_xpos#0*$100 in main::line2_pos#0 = main::line2_xpos#0*$100
Adding number conversion cast (unumber) $100 in main::line2_pos#0 = ((unumber)) main::line2_xpos#0*$100
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast main::line1_pos#0 = (unumber)main::line1_xpos#0*(unumber)$100
Inlining cast main::line2_pos#0 = (unumber)main::line2_xpos#0*(unumber)$100
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast main::line1_xpos#0*(unumber)$100
Simplifying constant integer cast $100
Simplifying constant integer cast main::line2_xpos#0*(unumber)$100
Simplifying constant integer cast $100
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (word) $100
Finalized unsigned number type (word) $100
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant main::line1_pos#0 = main::line1_xpos#0*$100
Constant main::line2_pos#0 = main::line2_xpos#0*$100
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings main::sc#0
Inlining constant with var siblings main::line1_i#0
Inlining constant with var siblings main::line2_i#0
Inlining constant with var siblings main::line1_pos#0
Inlining constant with var siblings main::line2_pos#0
Inlining constant with var siblings cur_line#0
Inlining constant with var siblings cur_line#2
Constant inlined main::line2_i#0 = 0
Constant inlined main::line1_i#0 = 0
Constant inlined main::line2_pos#0 = main::line2_xpos#0*$100
Constant inlined cur_line#0 = (byte*) 1024
Constant inlined main::sc#0 = (byte*) 1024
Constant inlined cur_line#2 = (byte*) 1024
Constant inlined main::line1_pos#0 = main::line1_xpos#0*$100
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (word) $400
Finalized unsigned number type (word) $3e8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Simplifying constant integer cast $400+$3e8
Successful SSA optimization PassNCastSimplification
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::line1
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of main::line2
CALL GRAPH

Created 7 initial phi equivalence classes
Coalesced [17] main::line2_i#6 = main::line2_i#1
Coalesced [18] main::line2_pos#6 = main::line2_pos#1
Coalesced [19] cur_line#21 = cur_line#3
Coalesced [25] main::line1_i#6 = main::line1_i#1
Coalesced [26] main::line1_pos#6 = main::line1_pos#1
Coalesced [27] cur_line#20 = cur_line#1
Coalesced [30] main::sc#4 = main::sc#1
Coalesced down to 7 phi equivalence classes
Culled Empty Block label main::@3
Culled Empty Block label main::@4
Renumbering block main::@5 to main::@3
Renumbering block main::@6 to main::@4
Adding NOP phi() at start of main
Adding NOP phi() at start of main::line1
Adding NOP phi() at start of main::line2

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [1] main::sc#2 = phi( main/(byte*) 1024, main::@2/main::sc#1 )
  [2] if(main::sc#2<$400+$3e8) goto main::@2
  to:main::line1
main::line1: scope:[main]  from main::@1
  [3] phi()
  to:main::line1_@1
main::line1_@1: scope:[main]  from main::@3 main::line1
  [4] cur_line#15 = phi( main::@3/cur_line#1, main::line1/(byte*) 1024 )
  [4] main::line1_pos#2 = phi( main::@3/main::line1_pos#1, main::line1/main::line1_xpos#0*$100 )
  [4] main::line1_i#2 = phi( main::@3/main::line1_i#1, main::line1/0 )
  [5] if(main::line1_i#2<main::line1_ysize#0) goto main::line1_@2
  to:main::line2
main::line2: scope:[main]  from main::line1_@1
  [6] phi()
  to:main::line2_@1
main::line2_@1: scope:[main]  from main::@4 main::line2
  [7] cur_line#10 = phi( main::@4/cur_line#3, main::line2/(byte*) 1024 )
  [7] main::line2_pos#2 = phi( main::@4/main::line2_pos#1, main::line2/main::line2_xpos#0*$100 )
  [7] main::line2_i#2 = phi( main::@4/main::line2_i#1, main::line2/0 )
  [8] if(main::line2_i#2<main::line2_ysize#0) goto main::line2_@2
  to:main::@return
main::@return: scope:[main]  from main::line2_@1
  [9] return 
  to:@return
main::line2_@2: scope:[main]  from main::line2_@1
  [10] main::plot2_xpos#0 = > main::line2_pos#2
  to:main::plot2
main::plot2: scope:[main]  from main::line2_@2
  [11] cur_line#10[main::plot2_xpos#0] = main::line2_ch#0
  to:main::@4
main::@4: scope:[main]  from main::plot2
  [12] main::line2_pos#1 = main::line2_pos#2 + main::line2_xadd#0
  [13] cur_line#3 = cur_line#10 + $28
  [14] main::line2_i#1 = ++ main::line2_i#2
  to:main::line2_@1
main::line1_@2: scope:[main]  from main::line1_@1
  [15] main::plot1_xpos#0 = > main::line1_pos#2
  to:main::plot1
main::plot1: scope:[main]  from main::line1_@2
  [16] cur_line#15[main::plot1_xpos#0] = main::line1_ch#0
  to:main::@3
main::@3: scope:[main]  from main::plot1
  [17] main::line1_pos#1 = main::line1_pos#2 + main::line1_xadd#0
  [18] cur_line#1 = cur_line#15 + $28
  [19] main::line1_i#1 = ++ main::line1_i#2
  to:main::line1_@1
main::@2: scope:[main]  from main::@1
  [20] *main::sc#2 = ' '
  [21] main::sc#1 = ++ main::sc#2
  to:main::@1


VARIABLE REGISTER WEIGHTS
byte* cur_line
byte* cur_line#1 11.0
byte* cur_line#10 6.6000000000000005
byte* cur_line#15 6.6000000000000005
byte* cur_line#3 11.0
void main()
byte main::line1_ch
byte main::line1_i
byte main::line1_i#1 22.0
byte main::line1_i#2 5.5
word main::line1_pos
word main::line1_pos#1 7.333333333333333
word main::line1_pos#2 8.25
byte main::line1_xadd
byte main::line1_xpos
byte main::line1_ysize
byte main::line2_ch
byte main::line2_i
byte main::line2_i#1 22.0
byte main::line2_i#2 5.5
word main::line2_pos
word main::line2_pos#1 7.333333333333333
word main::line2_pos#2 8.25
byte main::line2_xadd
byte main::line2_xpos
byte main::line2_ysize
byte main::plot1_ch
byte main::plot1_xpos
byte main::plot1_xpos#0 22.0
byte main::plot2_ch
byte main::plot2_xpos
byte main::plot2_xpos#0 22.0
byte* main::sc
byte* main::sc#1 22.0
byte* main::sc#2 14.666666666666666

Initial phi equivalence classes
[ main::sc#2 main::sc#1 ]
[ main::line1_i#2 main::line1_i#1 ]
[ main::line1_pos#2 main::line1_pos#1 ]
[ cur_line#15 cur_line#1 ]
[ main::line2_i#2 main::line2_i#1 ]
[ main::line2_pos#2 main::line2_pos#1 ]
[ cur_line#10 cur_line#3 ]
Added variable main::plot2_xpos#0 to live range equivalence class [ main::plot2_xpos#0 ]
Added variable main::plot1_xpos#0 to live range equivalence class [ main::plot1_xpos#0 ]
Complete equivalence classes
[ main::sc#2 main::sc#1 ]
[ main::line1_i#2 main::line1_i#1 ]
[ main::line1_pos#2 main::line1_pos#1 ]
[ cur_line#15 cur_line#1 ]
[ main::line2_i#2 main::line2_i#1 ]
[ main::line2_pos#2 main::line2_pos#1 ]
[ cur_line#10 cur_line#3 ]
[ main::plot2_xpos#0 ]
[ main::plot1_xpos#0 ]
Allocated zp[2]:2 [ main::sc#2 main::sc#1 ]
Allocated zp[1]:4 [ main::line1_i#2 main::line1_i#1 ]
Allocated zp[2]:5 [ main::line1_pos#2 main::line1_pos#1 ]
Allocated zp[2]:7 [ cur_line#15 cur_line#1 ]
Allocated zp[1]:9 [ main::line2_i#2 main::line2_i#1 ]
Allocated zp[2]:10 [ main::line2_pos#2 main::line2_pos#1 ]
Allocated zp[2]:12 [ cur_line#10 cur_line#3 ]
Allocated zp[1]:14 [ main::plot2_xpos#0 ]
Allocated zp[1]:15 [ main::plot1_xpos#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] if(main::sc#2<$400+$3e8) goto main::@2 [ main::sc#2 ] (  [ main::sc#2 ] { }  ) always clobbers reg byte a 
Statement [11] cur_line#10[main::plot2_xpos#0] = main::line2_ch#0 [ main::line2_i#2 main::line2_pos#2 cur_line#10 ] (  [ main::line2_i#2 main::line2_pos#2 cur_line#10 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:9 [ main::line2_i#2 main::line2_i#1 ]
Statement [12] main::line2_pos#1 = main::line2_pos#2 + main::line2_xadd#0 [ main::line2_i#2 cur_line#10 main::line2_pos#1 ] (  [ main::line2_i#2 cur_line#10 main::line2_pos#1 ] { }  ) always clobbers reg byte a 
Statement [13] cur_line#3 = cur_line#10 + $28 [ main::line2_i#2 main::line2_pos#1 cur_line#3 ] (  [ main::line2_i#2 main::line2_pos#1 cur_line#3 ] { }  ) always clobbers reg byte a 
Statement [16] cur_line#15[main::plot1_xpos#0] = main::line1_ch#0 [ main::line1_i#2 main::line1_pos#2 cur_line#15 ] (  [ main::line1_i#2 main::line1_pos#2 cur_line#15 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ main::line1_i#2 main::line1_i#1 ]
Statement [17] main::line1_pos#1 = main::line1_pos#2 + main::line1_xadd#0 [ main::line1_i#2 cur_line#15 main::line1_pos#1 ] (  [ main::line1_i#2 cur_line#15 main::line1_pos#1 ] { }  ) always clobbers reg byte a 
Statement [18] cur_line#1 = cur_line#15 + $28 [ main::line1_i#2 main::line1_pos#1 cur_line#1 ] (  [ main::line1_i#2 main::line1_pos#1 cur_line#1 ] { }  ) always clobbers reg byte a 
Statement [20] *main::sc#2 = ' ' [ main::sc#2 ] (  [ main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [2] if(main::sc#2<$400+$3e8) goto main::@2 [ main::sc#2 ] (  [ main::sc#2 ] { }  ) always clobbers reg byte a 
Statement [11] cur_line#10[main::plot2_xpos#0] = main::line2_ch#0 [ main::line2_i#2 main::line2_pos#2 cur_line#10 ] (  [ main::line2_i#2 main::line2_pos#2 cur_line#10 ] { }  ) always clobbers reg byte a 
Statement [12] main::line2_pos#1 = main::line2_pos#2 + main::line2_xadd#0 [ main::line2_i#2 cur_line#10 main::line2_pos#1 ] (  [ main::line2_i#2 cur_line#10 main::line2_pos#1 ] { }  ) always clobbers reg byte a 
Statement [13] cur_line#3 = cur_line#10 + $28 [ main::line2_i#2 main::line2_pos#1 cur_line#3 ] (  [ main::line2_i#2 main::line2_pos#1 cur_line#3 ] { }  ) always clobbers reg byte a 
Statement [16] cur_line#15[main::plot1_xpos#0] = main::line1_ch#0 [ main::line1_i#2 main::line1_pos#2 cur_line#15 ] (  [ main::line1_i#2 main::line1_pos#2 cur_line#15 ] { }  ) always clobbers reg byte a 
Statement [17] main::line1_pos#1 = main::line1_pos#2 + main::line1_xadd#0 [ main::line1_i#2 cur_line#15 main::line1_pos#1 ] (  [ main::line1_i#2 cur_line#15 main::line1_pos#1 ] { }  ) always clobbers reg byte a 
Statement [18] cur_line#1 = cur_line#15 + $28 [ main::line1_i#2 main::line1_pos#1 cur_line#1 ] (  [ main::line1_i#2 main::line1_pos#1 cur_line#1 ] { }  ) always clobbers reg byte a 
Statement [20] *main::sc#2 = ' ' [ main::sc#2 ] (  [ main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Potential registers zp[2]:2 [ main::sc#2 main::sc#1 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ main::line1_i#2 main::line1_i#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[2]:5 [ main::line1_pos#2 main::line1_pos#1 ] : zp[2]:5 , 
Potential registers zp[2]:7 [ cur_line#15 cur_line#1 ] : zp[2]:7 , 
Potential registers zp[1]:9 [ main::line2_i#2 main::line2_i#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[2]:10 [ main::line2_pos#2 main::line2_pos#1 ] : zp[2]:10 , 
Potential registers zp[2]:12 [ cur_line#10 cur_line#3 ] : zp[2]:12 , 
Potential registers zp[1]:14 [ main::plot2_xpos#0 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ main::plot1_xpos#0 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 36.67: zp[2]:2 [ main::sc#2 main::sc#1 ] 27.5: zp[1]:4 [ main::line1_i#2 main::line1_i#1 ] 27.5: zp[1]:9 [ main::line2_i#2 main::line2_i#1 ] 22: zp[1]:14 [ main::plot2_xpos#0 ] 22: zp[1]:15 [ main::plot1_xpos#0 ] 15.58: zp[2]:5 [ main::line1_pos#2 main::line1_pos#1 ] 15.58: zp[2]:10 [ main::line2_pos#2 main::line2_pos#1 ] 
Uplift Scope [] 17.6: zp[2]:7 [ cur_line#15 cur_line#1 ] 17.6: zp[2]:12 [ cur_line#10 cur_line#3 ] 

Uplifting [main] best 2352 combination zp[2]:2 [ main::sc#2 main::sc#1 ] reg byte x [ main::line1_i#2 main::line1_i#1 ] reg byte x [ main::line2_i#2 main::line2_i#1 ] reg byte y [ main::plot2_xpos#0 ] reg byte a [ main::plot1_xpos#0 ] zp[2]:5 [ main::line1_pos#2 main::line1_pos#1 ] zp[2]:10 [ main::line2_pos#2 main::line2_pos#1 ] 
Limited combination testing to 100 combinations of 144 possible.
Uplifting [] best 2352 combination zp[2]:7 [ cur_line#15 cur_line#1 ] zp[2]:12 [ cur_line#10 cur_line#3 ] 
Coalescing zero page register [ zp[2]:7 [ cur_line#15 cur_line#1 ] ] with [ zp[2]:2 [ main::sc#2 main::sc#1 ] ]
Coalescing zero page register [ zp[2]:12 [ cur_line#10 cur_line#3 ] ] with [ zp[2]:5 [ main::line1_pos#2 main::line1_pos#1 ] ]
Allocated (was zp[2]:7) zp[2]:2 [ cur_line#15 cur_line#1 main::sc#2 main::sc#1 ]
Allocated (was zp[2]:10) zp[2]:4 [ main::line2_pos#2 main::line2_pos#1 ]
Allocated (was zp[2]:12) zp[2]:6 [ cur_line#10 cur_line#3 main::line1_pos#2 main::line1_pos#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Inline functions in two levels
  // Upstart
  // Commodore 64 PRG executable file
.file [name="inline-function-level2.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label cur_line = 2
  .label cur_line_1 = 6
.segment Code
  // main
main: {
    .const line1_xpos = 2
    .const line1_xadd = $40
    .const line1_ysize = $a
    .const line1_ch = '*'
    .const line2_xpos = 4
    .const line2_xadd = $80
    .const line2_ysize = $f
    .const line2_ch = '.'
    .label sc = 2
    .label line1_pos = 6
    .label line2_pos = 4
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi main::sc#2 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z sc
    lda #>$400
    sta.z sc+1
    jmp __b1
    // main::@1
  __b1:
    // [2] if(main::sc#2<$400+$3e8) goto main::@2 -- pbuz1_lt_vwuc1_then_la1 
    lda.z sc+1
    cmp #>$400+$3e8
    bcc __b2
    bne !+
    lda.z sc
    cmp #<$400+$3e8
    bcc __b2
  !:
    // [3] phi from main::@1 to main::line1 [phi:main::@1->main::line1]
  line1_from___b1:
    jmp line1
    // main::line1
  line1:
    // [4] phi from main::line1 to main::line1_@1 [phi:main::line1->main::line1_@1]
  line1___b1_from_line1:
    // [4] phi cur_line#15 = (byte*) 1024 [phi:main::line1->main::line1_@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z cur_line
    lda #>$400
    sta.z cur_line+1
    // [4] phi main::line1_pos#2 = main::line1_xpos#0*$100 [phi:main::line1->main::line1_@1#1] -- vwuz1=vwuc1 
    lda #<line1_xpos*$100
    sta.z line1_pos
    lda #>line1_xpos*$100
    sta.z line1_pos+1
    // [4] phi main::line1_i#2 = 0 [phi:main::line1->main::line1_@1#2] -- vbuxx=vbuc1 
    ldx #0
    jmp line1___b1
    // main::line1_@1
  line1___b1:
    // [5] if(main::line1_i#2<main::line1_ysize#0) goto main::line1_@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #line1_ysize
    bcc line1___b2
    // [6] phi from main::line1_@1 to main::line2 [phi:main::line1_@1->main::line2]
  line2_from_line1___b1:
    jmp line2
    // main::line2
  line2:
    // [7] phi from main::line2 to main::line2_@1 [phi:main::line2->main::line2_@1]
  line2___b1_from_line2:
    // [7] phi cur_line#10 = (byte*) 1024 [phi:main::line2->main::line2_@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z cur_line_1
    lda #>$400
    sta.z cur_line_1+1
    // [7] phi main::line2_pos#2 = main::line2_xpos#0*$100 [phi:main::line2->main::line2_@1#1] -- vwuz1=vwuc1 
    lda #<line2_xpos*$100
    sta.z line2_pos
    lda #>line2_xpos*$100
    sta.z line2_pos+1
    // [7] phi main::line2_i#2 = 0 [phi:main::line2->main::line2_@1#2] -- vbuxx=vbuc1 
    ldx #0
    jmp line2___b1
    // main::line2_@1
  line2___b1:
    // [8] if(main::line2_i#2<main::line2_ysize#0) goto main::line2_@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #line2_ysize
    bcc line2___b2
    jmp __breturn
    // main::@return
  __breturn:
    // [9] return 
    rts
    // main::line2_@2
  line2___b2:
    // [10] main::plot2_xpos#0 = > main::line2_pos#2 -- vbuyy=_hi_vwuz1 
    ldy.z line2_pos+1
    jmp plot2
    // main::plot2
  plot2:
    // [11] cur_line#10[main::plot2_xpos#0] = main::line2_ch#0 -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #line2_ch
    sta (cur_line_1),y
    jmp __b4
    // main::@4
  __b4:
    // [12] main::line2_pos#1 = main::line2_pos#2 + main::line2_xadd#0 -- vwuz1=vwuz1_plus_vbuc1 
    lda #line2_xadd
    clc
    adc.z line2_pos
    sta.z line2_pos
    bcc !+
    inc.z line2_pos+1
  !:
    // [13] cur_line#3 = cur_line#10 + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z cur_line_1
    sta.z cur_line_1
    bcc !+
    inc.z cur_line_1+1
  !:
    // [14] main::line2_i#1 = ++ main::line2_i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [7] phi from main::@4 to main::line2_@1 [phi:main::@4->main::line2_@1]
  line2___b1_from___b4:
    // [7] phi cur_line#10 = cur_line#3 [phi:main::@4->main::line2_@1#0] -- register_copy 
    // [7] phi main::line2_pos#2 = main::line2_pos#1 [phi:main::@4->main::line2_@1#1] -- register_copy 
    // [7] phi main::line2_i#2 = main::line2_i#1 [phi:main::@4->main::line2_@1#2] -- register_copy 
    jmp line2___b1
    // main::line1_@2
  line1___b2:
    // [15] main::plot1_xpos#0 = > main::line1_pos#2 -- vbuaa=_hi_vwuz1 
    lda.z line1_pos+1
    jmp plot1
    // main::plot1
  plot1:
    // [16] cur_line#15[main::plot1_xpos#0] = main::line1_ch#0 -- pbuz1_derefidx_vbuaa=vbuc1 
    tay
    lda #line1_ch
    sta (cur_line),y
    jmp __b3
    // main::@3
  __b3:
    // [17] main::line1_pos#1 = main::line1_pos#2 + main::line1_xadd#0 -- vwuz1=vwuz1_plus_vbuc1 
    lda #line1_xadd
    clc
    adc.z line1_pos
    sta.z line1_pos
    bcc !+
    inc.z line1_pos+1
  !:
    // [18] cur_line#1 = cur_line#15 + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z cur_line
    sta.z cur_line
    bcc !+
    inc.z cur_line+1
  !:
    // [19] main::line1_i#1 = ++ main::line1_i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [4] phi from main::@3 to main::line1_@1 [phi:main::@3->main::line1_@1]
  line1___b1_from___b3:
    // [4] phi cur_line#15 = cur_line#1 [phi:main::@3->main::line1_@1#0] -- register_copy 
    // [4] phi main::line1_pos#2 = main::line1_pos#1 [phi:main::@3->main::line1_@1#1] -- register_copy 
    // [4] phi main::line1_i#2 = main::line1_i#1 [phi:main::@3->main::line1_@1#2] -- register_copy 
    jmp line1___b1
    // main::@2
  __b2:
    // [20] *main::sc#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [21] main::sc#1 = ++ main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [1] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [1] phi main::sc#2 = main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp line1
Removing instruction jmp line1___b1
Removing instruction jmp line2
Removing instruction jmp line2___b1
Removing instruction jmp __breturn
Removing instruction jmp plot2
Removing instruction jmp __b4
Removing instruction jmp plot1
Removing instruction jmp __b3
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction line1_from___b1:
Removing instruction line1___b1_from_line1:
Removing instruction line2_from_line1___b1:
Removing instruction line2___b1_from_line2:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction line1:
Removing instruction line2:
Removing instruction __breturn:
Removing instruction plot2:
Removing instruction __b4:
Removing instruction line2___b1_from___b4:
Removing instruction plot1:
Removing instruction __b3:
Removing instruction line1___b1_from___b3:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
byte* cur_line
byte* cur_line#1 cur_line zp[2]:2 11.0
byte* cur_line#10 cur_line_1 zp[2]:6 6.6000000000000005
byte* cur_line#15 cur_line zp[2]:2 6.6000000000000005
byte* cur_line#3 cur_line_1 zp[2]:6 11.0
void main()
byte main::line1_ch
constant byte main::line1_ch#0 line1_ch = '*'
byte main::line1_i
byte main::line1_i#1 reg byte x 22.0
byte main::line1_i#2 reg byte x 5.5
word main::line1_pos
word main::line1_pos#1 line1_pos zp[2]:6 7.333333333333333
word main::line1_pos#2 line1_pos zp[2]:6 8.25
byte main::line1_xadd
constant byte main::line1_xadd#0 line1_xadd = $40
byte main::line1_xpos
constant byte main::line1_xpos#0 line1_xpos = 2
byte main::line1_ysize
constant byte main::line1_ysize#0 line1_ysize = $a
byte main::line2_ch
constant byte main::line2_ch#0 line2_ch = '.'
byte main::line2_i
byte main::line2_i#1 reg byte x 22.0
byte main::line2_i#2 reg byte x 5.5
word main::line2_pos
word main::line2_pos#1 line2_pos zp[2]:4 7.333333333333333
word main::line2_pos#2 line2_pos zp[2]:4 8.25
byte main::line2_xadd
constant byte main::line2_xadd#0 line2_xadd = $80
byte main::line2_xpos
constant byte main::line2_xpos#0 line2_xpos = 4
byte main::line2_ysize
constant byte main::line2_ysize#0 line2_ysize = $f
byte main::plot1_ch
byte main::plot1_xpos
byte main::plot1_xpos#0 reg byte a 22.0
byte main::plot2_ch
byte main::plot2_xpos
byte main::plot2_xpos#0 reg byte y 22.0
byte* main::sc
byte* main::sc#1 sc zp[2]:2 22.0
byte* main::sc#2 sc zp[2]:2 14.666666666666666

reg byte x [ main::line1_i#2 main::line1_i#1 ]
zp[2]:2 [ cur_line#15 cur_line#1 main::sc#2 main::sc#1 ]
reg byte x [ main::line2_i#2 main::line2_i#1 ]
zp[2]:4 [ main::line2_pos#2 main::line2_pos#1 ]
zp[2]:6 [ cur_line#10 cur_line#3 main::line1_pos#2 main::line1_pos#1 ]
reg byte y [ main::plot2_xpos#0 ]
reg byte a [ main::plot1_xpos#0 ]


FINAL ASSEMBLER
Score: 2106

  // File Comments
// Inline functions in two levels
  // Upstart
  // Commodore 64 PRG executable file
.file [name="inline-function-level2.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label cur_line = 2
  .label cur_line_1 = 6
.segment Code
  // main
main: {
    .const line1_xpos = 2
    .const line1_xadd = $40
    .const line1_ysize = $a
    .const line1_ch = '*'
    .const line2_xpos = 4
    .const line2_xadd = $80
    .const line2_ysize = $f
    .const line2_ch = '.'
    .label sc = 2
    .label line1_pos = 6
    .label line2_pos = 4
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi main::sc#2 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z sc
    lda #>$400
    sta.z sc+1
    // main::@1
  __b1:
    // for(byte* sc = (byte*)$400;sc<$400+1000;sc++)
    // [2] if(main::sc#2<$400+$3e8) goto main::@2 -- pbuz1_lt_vwuc1_then_la1 
    lda.z sc+1
    cmp #>$400+$3e8
    bcc __b2
    bne !+
    lda.z sc
    cmp #<$400+$3e8
    bcc __b2
  !:
    // [3] phi from main::@1 to main::line1 [phi:main::@1->main::line1]
    // main::line1
    // [4] phi from main::line1 to main::line1_@1 [phi:main::line1->main::line1_@1]
    // [4] phi cur_line#15 = (byte*) 1024 [phi:main::line1->main::line1_@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z cur_line
    lda #>$400
    sta.z cur_line+1
    // [4] phi main::line1_pos#2 = main::line1_xpos#0*$100 [phi:main::line1->main::line1_@1#1] -- vwuz1=vwuc1 
    lda #<line1_xpos*$100
    sta.z line1_pos
    lda #>line1_xpos*$100
    sta.z line1_pos+1
    // [4] phi main::line1_i#2 = 0 [phi:main::line1->main::line1_@1#2] -- vbuxx=vbuc1 
    ldx #0
    // main::line1_@1
  line1___b1:
    // for( byte i=0;i<ysize; i++)
    // [5] if(main::line1_i#2<main::line1_ysize#0) goto main::line1_@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #line1_ysize
    bcc line1___b2
    // [6] phi from main::line1_@1 to main::line2 [phi:main::line1_@1->main::line2]
    // main::line2
    // [7] phi from main::line2 to main::line2_@1 [phi:main::line2->main::line2_@1]
    // [7] phi cur_line#10 = (byte*) 1024 [phi:main::line2->main::line2_@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z cur_line_1
    lda #>$400
    sta.z cur_line_1+1
    // [7] phi main::line2_pos#2 = main::line2_xpos#0*$100 [phi:main::line2->main::line2_@1#1] -- vwuz1=vwuc1 
    lda #<line2_xpos*$100
    sta.z line2_pos
    lda #>line2_xpos*$100
    sta.z line2_pos+1
    // [7] phi main::line2_i#2 = 0 [phi:main::line2->main::line2_@1#2] -- vbuxx=vbuc1 
    ldx #0
    // main::line2_@1
  line2___b1:
    // for( byte i=0;i<ysize; i++)
    // [8] if(main::line2_i#2<main::line2_ysize#0) goto main::line2_@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #line2_ysize
    bcc line2___b2
    // main::@return
    // }
    // [9] return 
    rts
    // main::line2_@2
  line2___b2:
    // plot(>pos, ch)
    // [10] main::plot2_xpos#0 = > main::line2_pos#2 -- vbuyy=_hi_vwuz1 
    ldy.z line2_pos+1
    // main::plot2
    // *(cur_line+xpos) = ch
    // [11] cur_line#10[main::plot2_xpos#0] = main::line2_ch#0 -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #line2_ch
    sta (cur_line_1),y
    // main::@4
    // pos += xadd
    // [12] main::line2_pos#1 = main::line2_pos#2 + main::line2_xadd#0 -- vwuz1=vwuz1_plus_vbuc1 
    lda #line2_xadd
    clc
    adc.z line2_pos
    sta.z line2_pos
    bcc !+
    inc.z line2_pos+1
  !:
    // cur_line += 40
    // [13] cur_line#3 = cur_line#10 + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z cur_line_1
    sta.z cur_line_1
    bcc !+
    inc.z cur_line_1+1
  !:
    // for( byte i=0;i<ysize; i++)
    // [14] main::line2_i#1 = ++ main::line2_i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [7] phi from main::@4 to main::line2_@1 [phi:main::@4->main::line2_@1]
    // [7] phi cur_line#10 = cur_line#3 [phi:main::@4->main::line2_@1#0] -- register_copy 
    // [7] phi main::line2_pos#2 = main::line2_pos#1 [phi:main::@4->main::line2_@1#1] -- register_copy 
    // [7] phi main::line2_i#2 = main::line2_i#1 [phi:main::@4->main::line2_@1#2] -- register_copy 
    jmp line2___b1
    // main::line1_@2
  line1___b2:
    // plot(>pos, ch)
    // [15] main::plot1_xpos#0 = > main::line1_pos#2 -- vbuaa=_hi_vwuz1 
    lda.z line1_pos+1
    // main::plot1
    // *(cur_line+xpos) = ch
    // [16] cur_line#15[main::plot1_xpos#0] = main::line1_ch#0 -- pbuz1_derefidx_vbuaa=vbuc1 
    tay
    lda #line1_ch
    sta (cur_line),y
    // main::@3
    // pos += xadd
    // [17] main::line1_pos#1 = main::line1_pos#2 + main::line1_xadd#0 -- vwuz1=vwuz1_plus_vbuc1 
    lda #line1_xadd
    clc
    adc.z line1_pos
    sta.z line1_pos
    bcc !+
    inc.z line1_pos+1
  !:
    // cur_line += 40
    // [18] cur_line#1 = cur_line#15 + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z cur_line
    sta.z cur_line
    bcc !+
    inc.z cur_line+1
  !:
    // for( byte i=0;i<ysize; i++)
    // [19] main::line1_i#1 = ++ main::line1_i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [4] phi from main::@3 to main::line1_@1 [phi:main::@3->main::line1_@1]
    // [4] phi cur_line#15 = cur_line#1 [phi:main::@3->main::line1_@1#0] -- register_copy 
    // [4] phi main::line1_pos#2 = main::line1_pos#1 [phi:main::@3->main::line1_@1#1] -- register_copy 
    // [4] phi main::line1_i#2 = main::line1_i#1 [phi:main::@3->main::line1_@1#2] -- register_copy 
    jmp line1___b1
    // main::@2
  __b2:
    // *sc = ' '
    // [20] *main::sc#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // for(byte* sc = (byte*)$400;sc<$400+1000;sc++)
    // [21] main::sc#1 = ++ main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [1] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [1] phi main::sc#2 = main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // File Data

