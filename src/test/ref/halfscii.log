Inlined call call __init 

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  asm { sei  }
  *PROCPORT = $32
  main::chargen#0 = CHARGEN
  main::charset4#0 = CHARSET4
  to:main::@1
main::@1: scope:[main]  from main main::@5
  main::charset4#9 = phi( main/main::charset4#0, main::@5/main::charset4#1 )
  main::chargen#2 = phi( main/main::chargen#0, main::@5/main::chargen#1 )
  main::bits_gen#0 = 0
  main::$0 = main::chargen#2 + 1
  main::chargen1#0 = main::$0
  main::$1 = *main::chargen#2 & $60
  main::$2 = *main::chargen1#0 & $60
  main::$3 = main::$2 / 4
  main::$4 = main::$1 | main::$3
  main::$5 = main::$4 / 2
  main::$6 = main::$5 / 4
  main::bits#0 = bits_count[main::$6]
  main::$7 = main::bits#0 >= 2
  main::$8 = ! main::$7
  if(main::$8) goto main::@2
  to:main::@6
main::@2: scope:[main]  from main::@1 main::@6
  main::charset4#7 = phi( main::@1/main::charset4#9, main::@6/main::charset4#10 )
  main::chargen1#1 = phi( main::@1/main::chargen1#0, main::@6/main::chargen1#4 )
  main::chargen#3 = phi( main::@1/main::chargen#2, main::@6/main::chargen#7 )
  main::bits_gen#9 = phi( main::@1/main::bits_gen#0, main::@6/main::bits_gen#2 )
  main::$10 = main::bits_gen#9 * 2
  main::bits_gen#1 = main::$10
  main::$11 = *main::chargen#3 & $18
  main::$12 = *main::chargen1#1 & $18
  main::$13 = main::$12 / 4
  main::$14 = main::$11 | main::$13
  main::$15 = main::$14 / 2
  main::bits#1 = bits_count[main::$15]
  main::$16 = main::bits#1 >= 2
  main::$17 = ! main::$16
  if(main::$17) goto main::@3
  to:main::@7
main::@6: scope:[main]  from main::@1
  main::charset4#10 = phi( main::@1/main::charset4#9 )
  main::chargen1#4 = phi( main::@1/main::chargen1#0 )
  main::chargen#7 = phi( main::@1/main::chargen#2 )
  main::bits_gen#10 = phi( main::@1/main::bits_gen#0 )
  main::$9 = main::bits_gen#10 + 1
  main::bits_gen#2 = main::$9
  to:main::@2
main::@3: scope:[main]  from main::@2 main::@7
  main::charset4#5 = phi( main::@2/main::charset4#7, main::@7/main::charset4#8 )
  main::chargen1#2 = phi( main::@2/main::chargen1#1, main::@7/main::chargen1#5 )
  main::chargen#4 = phi( main::@2/main::chargen#3, main::@7/main::chargen#8 )
  main::bits_gen#11 = phi( main::@2/main::bits_gen#1, main::@7/main::bits_gen#4 )
  main::$19 = main::bits_gen#11 * 2
  main::bits_gen#3 = main::$19
  main::$20 = *main::chargen#4 & 6
  main::$21 = main::$20 * 2
  main::$22 = *main::chargen1#2 & 6
  main::$23 = main::$22 / 2
  main::$24 = main::$21 | main::$23
  main::bits#2 = bits_count[main::$24]
  main::$25 = main::bits#2 >= 2
  main::$26 = ! main::$25
  if(main::$26) goto main::@4
  to:main::@8
main::@7: scope:[main]  from main::@2
  main::charset4#8 = phi( main::@2/main::charset4#7 )
  main::chargen1#5 = phi( main::@2/main::chargen1#1 )
  main::chargen#8 = phi( main::@2/main::chargen#3 )
  main::bits_gen#12 = phi( main::@2/main::bits_gen#1 )
  main::$18 = main::bits_gen#12 + 1
  main::bits_gen#4 = main::$18
  to:main::@3
main::@4: scope:[main]  from main::@3 main::@8
  main::charset4#3 = phi( main::@3/main::charset4#5, main::@8/main::charset4#6 )
  main::chargen1#3 = phi( main::@3/main::chargen1#2, main::@8/main::chargen1#6 )
  main::chargen#5 = phi( main::@3/main::chargen#4, main::@8/main::chargen#9 )
  main::bits_gen#13 = phi( main::@3/main::bits_gen#3, main::@8/main::bits_gen#6 )
  main::$28 = main::bits_gen#13 * 2
  main::bits_gen#5 = main::$28
  main::$29 = *main::chargen#5 & 1
  main::$30 = main::$29 * 4
  main::$31 = *main::chargen1#3 & 1
  main::$32 = main::$30 | main::$31
  main::bits#3 = bits_count[main::$32]
  main::$33 = main::bits#3 >= 2
  main::$34 = ! main::$33
  if(main::$34) goto main::@5
  to:main::@9
main::@8: scope:[main]  from main::@3
  main::charset4#6 = phi( main::@3/main::charset4#5 )
  main::chargen1#6 = phi( main::@3/main::chargen1#2 )
  main::chargen#9 = phi( main::@3/main::chargen#4 )
  main::bits_gen#14 = phi( main::@3/main::bits_gen#3 )
  main::$27 = main::bits_gen#14 + 1
  main::bits_gen#6 = main::$27
  to:main::@4
main::@5: scope:[main]  from main::@4 main::@9
  main::chargen#6 = phi( main::@4/main::chargen#5, main::@9/main::chargen#10 )
  main::charset4#2 = phi( main::@4/main::charset4#3, main::@9/main::charset4#4 )
  main::bits_gen#15 = phi( main::@4/main::bits_gen#5, main::@9/main::bits_gen#8 )
  main::$36 = main::bits_gen#15 * 2
  main::bits_gen#7 = main::$36
  *main::charset4#2 = main::bits_gen#7
  main::charset4#1 = ++ main::charset4#2
  main::$37 = main::chargen#6 + 2
  main::chargen#1 = main::$37
  main::$38 = CHARGEN + $800
  main::$39 = main::chargen#1 < main::$38
  if(main::$39) goto main::@1
  to:main::@10
main::@9: scope:[main]  from main::@4
  main::chargen#10 = phi( main::@4/main::chargen#5 )
  main::charset4#4 = phi( main::@4/main::charset4#3 )
  main::bits_gen#16 = phi( main::@4/main::bits_gen#5 )
  main::$35 = main::bits_gen#16 + 1
  main::bits_gen#8 = main::$35
  to:main::@5
main::@10: scope:[main]  from main::@5
  *PROCPORT = $37
  asm { cli  }
  main::i#0 = 0
  to:main::@11
main::@11: scope:[main]  from main::@10 main::@11
  main::i#2 = phi( main::@10/main::i#0, main::@11/main::i#1 )
  SCREEN[main::i#2] = main::i#2
  main::i#1 = main::i#2 + rangenext(0,$ff)
  main::$40 = main::i#1 != rangelast(0,$ff)
  if(main::$40) goto main::@11
  to:main::@12
main::@12: scope:[main]  from main::@11
  *D018 = $19
  to:main::@return
main::@return: scope:[main]  from main::@12
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* CHARGEN = (byte*)$d000
constant byte* CHARSET4 = (byte*)$2800
constant byte* D018 = (byte*)$d018
constant byte* PROCPORT = (byte*)1
constant byte* SCREEN = (byte*)$400
void __start()
constant byte* bits_count[]  = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 }
void main()
byte*~ main::$0
number~ main::$1
number~ main::$10
number~ main::$11
number~ main::$12
number~ main::$13
number~ main::$14
number~ main::$15
bool~ main::$16
bool~ main::$17
number~ main::$18
number~ main::$19
number~ main::$2
number~ main::$20
number~ main::$21
number~ main::$22
number~ main::$23
number~ main::$24
bool~ main::$25
bool~ main::$26
number~ main::$27
number~ main::$28
number~ main::$29
number~ main::$3
number~ main::$30
number~ main::$31
number~ main::$32
bool~ main::$33
bool~ main::$34
number~ main::$35
number~ main::$36
byte*~ main::$37
byte*~ main::$38
bool~ main::$39
number~ main::$4
bool~ main::$40
number~ main::$5
number~ main::$6
bool~ main::$7
bool~ main::$8
number~ main::$9
byte main::bits
byte main::bits#0
byte main::bits#1
byte main::bits#2
byte main::bits#3
byte main::bits_gen
byte main::bits_gen#0
byte main::bits_gen#1
byte main::bits_gen#10
byte main::bits_gen#11
byte main::bits_gen#12
byte main::bits_gen#13
byte main::bits_gen#14
byte main::bits_gen#15
byte main::bits_gen#16
byte main::bits_gen#2
byte main::bits_gen#3
byte main::bits_gen#4
byte main::bits_gen#5
byte main::bits_gen#6
byte main::bits_gen#7
byte main::bits_gen#8
byte main::bits_gen#9
byte* main::chargen
byte* main::chargen#0
byte* main::chargen#1
byte* main::chargen#10
byte* main::chargen#2
byte* main::chargen#3
byte* main::chargen#4
byte* main::chargen#5
byte* main::chargen#6
byte* main::chargen#7
byte* main::chargen#8
byte* main::chargen#9
byte* main::chargen1
byte* main::chargen1#0
byte* main::chargen1#1
byte* main::chargen1#2
byte* main::chargen1#3
byte* main::chargen1#4
byte* main::chargen1#5
byte* main::chargen1#6
byte* main::charset4
byte* main::charset4#0
byte* main::charset4#1
byte* main::charset4#10
byte* main::charset4#2
byte* main::charset4#3
byte* main::charset4#4
byte* main::charset4#5
byte* main::charset4#6
byte* main::charset4#7
byte* main::charset4#8
byte* main::charset4#9
byte main::i
byte main::i#0
byte main::i#1
byte main::i#2

Adding number conversion cast (unumber) $32 in *PROCPORT = $32
Adding number conversion cast (unumber) 1 in main::$0 = main::chargen#2 + 1
Adding number conversion cast (unumber) $60 in main::$1 = *main::chargen#2 & $60
Adding number conversion cast (unumber) main::$1 in main::$1 = *main::chargen#2 & (unumber)$60
Adding number conversion cast (unumber) $60 in main::$2 = *main::chargen1#0 & $60
Adding number conversion cast (unumber) main::$2 in main::$2 = *main::chargen1#0 & (unumber)$60
Adding number conversion cast (unumber) 4 in main::$3 = main::$2 / 4
Adding number conversion cast (unumber) main::$3 in main::$3 = main::$2 / (unumber)4
Adding number conversion cast (unumber) main::$4 in main::$4 = main::$1 | main::$3
Adding number conversion cast (unumber) 2 in main::$5 = main::$4 / 2
Adding number conversion cast (unumber) main::$5 in main::$5 = main::$4 / (unumber)2
Adding number conversion cast (unumber) 4 in main::$6 = main::$5 / 4
Adding number conversion cast (unumber) main::$6 in main::$6 = main::$5 / (unumber)4
Adding number conversion cast (unumber) 2 in main::$7 = main::bits#0 >= 2
Adding number conversion cast (unumber) 2 in main::$10 = main::bits_gen#9 * 2
Adding number conversion cast (unumber) main::$10 in main::$10 = main::bits_gen#9 * (unumber)2
Adding number conversion cast (unumber) $18 in main::$11 = *main::chargen#3 & $18
Adding number conversion cast (unumber) main::$11 in main::$11 = *main::chargen#3 & (unumber)$18
Adding number conversion cast (unumber) $18 in main::$12 = *main::chargen1#1 & $18
Adding number conversion cast (unumber) main::$12 in main::$12 = *main::chargen1#1 & (unumber)$18
Adding number conversion cast (unumber) 4 in main::$13 = main::$12 / 4
Adding number conversion cast (unumber) main::$13 in main::$13 = main::$12 / (unumber)4
Adding number conversion cast (unumber) main::$14 in main::$14 = main::$11 | main::$13
Adding number conversion cast (unumber) 2 in main::$15 = main::$14 / 2
Adding number conversion cast (unumber) main::$15 in main::$15 = main::$14 / (unumber)2
Adding number conversion cast (unumber) 2 in main::$16 = main::bits#1 >= 2
Adding number conversion cast (unumber) 1 in main::$9 = main::bits_gen#10 + 1
Adding number conversion cast (unumber) main::$9 in main::$9 = main::bits_gen#10 + (unumber)1
Adding number conversion cast (unumber) 2 in main::$19 = main::bits_gen#11 * 2
Adding number conversion cast (unumber) main::$19 in main::$19 = main::bits_gen#11 * (unumber)2
Adding number conversion cast (unumber) 6 in main::$20 = *main::chargen#4 & 6
Adding number conversion cast (unumber) main::$20 in main::$20 = *main::chargen#4 & (unumber)6
Adding number conversion cast (unumber) 2 in main::$21 = main::$20 * 2
Adding number conversion cast (unumber) main::$21 in main::$21 = main::$20 * (unumber)2
Adding number conversion cast (unumber) 6 in main::$22 = *main::chargen1#2 & 6
Adding number conversion cast (unumber) main::$22 in main::$22 = *main::chargen1#2 & (unumber)6
Adding number conversion cast (unumber) 2 in main::$23 = main::$22 / 2
Adding number conversion cast (unumber) main::$23 in main::$23 = main::$22 / (unumber)2
Adding number conversion cast (unumber) main::$24 in main::$24 = main::$21 | main::$23
Adding number conversion cast (unumber) 2 in main::$25 = main::bits#2 >= 2
Adding number conversion cast (unumber) 1 in main::$18 = main::bits_gen#12 + 1
Adding number conversion cast (unumber) main::$18 in main::$18 = main::bits_gen#12 + (unumber)1
Adding number conversion cast (unumber) 2 in main::$28 = main::bits_gen#13 * 2
Adding number conversion cast (unumber) main::$28 in main::$28 = main::bits_gen#13 * (unumber)2
Adding number conversion cast (unumber) 1 in main::$29 = *main::chargen#5 & 1
Adding number conversion cast (unumber) main::$29 in main::$29 = *main::chargen#5 & (unumber)1
Adding number conversion cast (unumber) 4 in main::$30 = main::$29 * 4
Adding number conversion cast (unumber) main::$30 in main::$30 = main::$29 * (unumber)4
Adding number conversion cast (unumber) 1 in main::$31 = *main::chargen1#3 & 1
Adding number conversion cast (unumber) main::$31 in main::$31 = *main::chargen1#3 & (unumber)1
Adding number conversion cast (unumber) main::$32 in main::$32 = main::$30 | main::$31
Adding number conversion cast (unumber) 2 in main::$33 = main::bits#3 >= 2
Adding number conversion cast (unumber) 1 in main::$27 = main::bits_gen#14 + 1
Adding number conversion cast (unumber) main::$27 in main::$27 = main::bits_gen#14 + (unumber)1
Adding number conversion cast (unumber) 2 in main::$36 = main::bits_gen#15 * 2
Adding number conversion cast (unumber) main::$36 in main::$36 = main::bits_gen#15 * (unumber)2
Adding number conversion cast (unumber) 2 in main::$37 = main::chargen#6 + 2
Adding number conversion cast (unumber) $800 in main::$38 = CHARGEN + $800
Adding number conversion cast (unumber) 1 in main::$35 = main::bits_gen#16 + 1
Adding number conversion cast (unumber) main::$35 in main::$35 = main::bits_gen#16 + (unumber)1
Adding number conversion cast (unumber) $37 in *PROCPORT = $37
Adding number conversion cast (unumber) $19 in *D018 = $19
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *PROCPORT = (unumber)$32
Inlining cast *PROCPORT = (unumber)$37
Inlining cast *D018 = (unumber)$19
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 1
Simplifying constant pointer cast (byte*) 53272
Simplifying constant pointer cast (byte*) 10240
Simplifying constant integer cast $32
Simplifying constant integer cast 1
Simplifying constant integer cast $60
Simplifying constant integer cast $60
Simplifying constant integer cast 4
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast $18
Simplifying constant integer cast $18
Simplifying constant integer cast 4
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 6
Simplifying constant integer cast 2
Simplifying constant integer cast 6
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 4
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast $800
Simplifying constant integer cast 1
Simplifying constant integer cast $37
Simplifying constant integer cast $19
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $32
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $60
Finalized unsigned number type (byte) $60
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (word) $800
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $37
Finalized unsigned number type (byte) $19
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in main::$1 = *main::chargen#2 & $60
Inferred type updated to byte in main::$2 = *main::chargen1#0 & $60
Inferred type updated to byte in main::$3 = main::$2 / 4
Inferred type updated to byte in main::$4 = main::$1 | main::$3
Inferred type updated to byte in main::$5 = main::$4 / 2
Inferred type updated to byte in main::$6 = main::$5 / 4
Inferred type updated to byte in main::$10 = main::bits_gen#9 * 2
Inferred type updated to byte in main::$11 = *main::chargen#3 & $18
Inferred type updated to byte in main::$12 = *main::chargen1#1 & $18
Inferred type updated to byte in main::$13 = main::$12 / 4
Inferred type updated to byte in main::$14 = main::$11 | main::$13
Inferred type updated to byte in main::$15 = main::$14 / 2
Inferred type updated to byte in main::$9 = main::bits_gen#10 + 1
Inferred type updated to byte in main::$19 = main::bits_gen#11 * 2
Inferred type updated to byte in main::$20 = *main::chargen#4 & 6
Inferred type updated to byte in main::$21 = main::$20 * 2
Inferred type updated to byte in main::$22 = *main::chargen1#2 & 6
Inferred type updated to byte in main::$23 = main::$22 / 2
Inferred type updated to byte in main::$24 = main::$21 | main::$23
Inferred type updated to byte in main::$18 = main::bits_gen#12 + 1
Inferred type updated to byte in main::$28 = main::bits_gen#13 * 2
Inferred type updated to byte in main::$29 = *main::chargen#5 & 1
Inferred type updated to byte in main::$30 = main::$29 * 4
Inferred type updated to byte in main::$31 = *main::chargen1#3 & 1
Inferred type updated to byte in main::$32 = main::$30 | main::$31
Inferred type updated to byte in main::$27 = main::bits_gen#14 + 1
Inferred type updated to byte in main::$36 = main::bits_gen#15 * 2
Inferred type updated to byte in main::$35 = main::bits_gen#16 + 1
Inversing boolean not [16] main::$8 = main::bits#0 < 2 from [15] main::$7 = main::bits#0 >= 2
Inversing boolean not [28] main::$17 = main::bits#1 < 2 from [27] main::$16 = main::bits#1 >= 2
Inversing boolean not [43] main::$26 = main::bits#2 < 2 from [42] main::$25 = main::bits#2 >= 2
Inversing boolean not [57] main::$34 = main::bits#3 < 2 from [56] main::$33 = main::bits#3 >= 2
Successful SSA optimization Pass2UnaryNotSimplification
Alias main::chargen1#0 = main::$0 main::chargen1#4 
Alias main::bits_gen#1 = main::$10 main::bits_gen#12 
Alias main::bits_gen#0 = main::bits_gen#10 
Alias main::chargen#2 = main::chargen#7 
Alias main::charset4#10 = main::charset4#9 
Alias main::bits_gen#2 = main::$9 
Alias main::bits_gen#14 = main::bits_gen#3 main::$19 
Alias main::chargen#3 = main::chargen#8 
Alias main::chargen1#1 = main::chargen1#5 
Alias main::charset4#7 = main::charset4#8 
Alias main::bits_gen#4 = main::$18 
Alias main::bits_gen#16 = main::bits_gen#5 main::$28 
Alias main::chargen#4 = main::chargen#9 
Alias main::chargen1#2 = main::chargen1#6 
Alias main::charset4#5 = main::charset4#6 
Alias main::bits_gen#6 = main::$27 
Alias main::bits_gen#7 = main::$36 
Alias main::chargen#1 = main::$37 
Alias main::charset4#3 = main::charset4#4 
Alias main::chargen#10 = main::chargen#5 
Alias main::bits_gen#8 = main::$35 
Successful SSA optimization Pass2AliasElimination
Alias main::chargen#10 = main::chargen#3 main::chargen#2 main::chargen#4 main::chargen#6 
Alias main::chargen1#0 = main::chargen1#1 main::chargen1#2 main::chargen1#3 
Alias main::charset4#10 = main::charset4#7 main::charset4#5 main::charset4#3 main::charset4#2 
Successful SSA optimization Pass2AliasElimination
Simple Condition main::$8 [15] if(main::bits#0<2) goto main::@2
Simple Condition main::$17 [25] if(main::bits#1<2) goto main::@3
Simple Condition main::$26 [36] if(main::bits#2<2) goto main::@4
Simple Condition main::$34 [46] if(main::bits#3<2) goto main::@5
Simple Condition main::$39 [55] if(main::chargen#1<main::$38) goto main::@1
Simple Condition main::$40 [64] if(main::i#1!=rangelast(0,$ff)) goto main::@11
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [53] main::$38 = CHARGEN + $800
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::chargen#0 = CHARGEN
Constant main::charset4#0 = CHARSET4
Constant main::bits_gen#0 = 0
Constant main::$38 = CHARGEN+$800
Constant main::i#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [62] main::i#1 = ++ main::i#2 to ++
Resolved ranged comparison value [64] if(main::i#1!=rangelast(0,$ff)) goto main::@11 to 0
Simplifying expression containing zero 1 in [26] main::bits_gen#2 = main::bits_gen#0 + 1
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) 0 in [53] if(main::i#1!=0) goto main::@11
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant main::bits_gen#2 = 1
Successful SSA optimization Pass2ConstantIdentification
Rewriting division to use shift [6] main::$3 = main::$2 / 4
Rewriting division to use shift [8] main::$5 = main::$4 / 2
Rewriting division to use shift [9] main::$6 = main::$5 / 4
Rewriting multiplication to use shift [13] main::bits_gen#1 = main::bits_gen#9 * 2
Rewriting division to use shift [16] main::$13 = main::$12 / 4
Rewriting division to use shift [18] main::$15 = main::$14 / 2
Rewriting multiplication to use shift [22] main::bits_gen#14 = main::bits_gen#11 * 2
Rewriting multiplication to use shift [24] main::$21 = main::$20 * 2
Rewriting division to use shift [26] main::$23 = main::$22 / 2
Rewriting multiplication to use shift [32] main::bits_gen#16 = main::bits_gen#13 * 2
Rewriting multiplication to use shift [34] main::$30 = main::$29 * 4
Rewriting multiplication to use shift [41] main::bits_gen#7 = main::bits_gen#15 * 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings main::chargen#0
Inlining constant with var siblings main::charset4#0
Inlining constant with var siblings main::bits_gen#0
Inlining constant with var siblings main::i#0
Inlining constant with var siblings main::bits_gen#2
Constant inlined main::i#0 = 0
Constant inlined main::bits_gen#2 = 1
Constant inlined main::chargen#0 = CHARGEN
Constant inlined main::bits_gen#0 = 0
Constant inlined main::$38 = CHARGEN+$800
Constant inlined main::charset4#0 = CHARSET4
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@13(between main::@5 and main::@1)
Added new block during phi lifting main::@14(between main::@2 and main::@3)
Added new block during phi lifting main::@15(between main::@3 and main::@4)
Added new block during phi lifting main::@16(between main::@4 and main::@5)
Added new block during phi lifting main::@17(between main::@11 and main::@11)
Adding NOP phi() at start of main::@6
CALL GRAPH

Created 7 initial phi equivalence classes
Coalesced [23] main::bits_gen#18 = main::bits_gen#4
Coalesced [34] main::bits_gen#20 = main::bits_gen#6
Coalesced [44] main::bits_gen#22 = main::bits_gen#8
Coalesced [59] main::i#3 = main::i#1
Coalesced [60] main::chargen#11 = main::chargen#1
Coalesced [61] main::charset4#11 = main::charset4#1
Coalesced [62] main::bits_gen#21 = main::bits_gen#16
Coalesced [63] main::bits_gen#19 = main::bits_gen#14
Coalesced [64] main::bits_gen#17 = main::bits_gen#1
Coalesced down to 7 phi equivalence classes
Culled Empty Block label main::@17
Culled Empty Block label main::@13
Culled Empty Block label main::@16
Culled Empty Block label main::@15
Culled Empty Block label main::@14
Adding NOP phi() at start of main::@6

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  asm { sei  }
  [1] *PROCPORT = $32
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [2] main::charset4#10 = phi( main/CHARSET4, main::@5/main::charset4#1 )
  [2] main::chargen#10 = phi( main/CHARGEN, main::@5/main::chargen#1 )
  [3] main::chargen1#0 = main::chargen#10 + 1
  [4] main::$1 = *main::chargen#10 & $60
  [5] main::$2 = *main::chargen1#0 & $60
  [6] main::$3 = main::$2 >> 2
  [7] main::$4 = main::$1 | main::$3
  [8] main::$5 = main::$4 >> 1
  [9] main::$6 = main::$5 >> 2
  [10] main::bits#0 = bits_count[main::$6]
  [11] if(main::bits#0<2) goto main::@2
  to:main::@6
main::@6: scope:[main]  from main::@1
  [12] phi()
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@6
  [13] main::bits_gen#9 = phi( main::@1/0, main::@6/1 )
  [14] main::bits_gen#1 = main::bits_gen#9 << 1
  [15] main::$11 = *main::chargen#10 & $18
  [16] main::$12 = *main::chargen1#0 & $18
  [17] main::$13 = main::$12 >> 2
  [18] main::$14 = main::$11 | main::$13
  [19] main::$15 = main::$14 >> 1
  [20] main::bits#1 = bits_count[main::$15]
  [21] if(main::bits#1<2) goto main::@3
  to:main::@7
main::@7: scope:[main]  from main::@2
  [22] main::bits_gen#4 = main::bits_gen#1 + 1
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@7
  [23] main::bits_gen#11 = phi( main::@2/main::bits_gen#1, main::@7/main::bits_gen#4 )
  [24] main::bits_gen#14 = main::bits_gen#11 << 1
  [25] main::$20 = *main::chargen#10 & 6
  [26] main::$21 = main::$20 << 1
  [27] main::$22 = *main::chargen1#0 & 6
  [28] main::$23 = main::$22 >> 1
  [29] main::$24 = main::$21 | main::$23
  [30] main::bits#2 = bits_count[main::$24]
  [31] if(main::bits#2<2) goto main::@4
  to:main::@8
main::@8: scope:[main]  from main::@3
  [32] main::bits_gen#6 = main::bits_gen#14 + 1
  to:main::@4
main::@4: scope:[main]  from main::@3 main::@8
  [33] main::bits_gen#13 = phi( main::@3/main::bits_gen#14, main::@8/main::bits_gen#6 )
  [34] main::bits_gen#16 = main::bits_gen#13 << 1
  [35] main::$29 = *main::chargen#10 & 1
  [36] main::$30 = main::$29 << 2
  [37] main::$31 = *main::chargen1#0 & 1
  [38] main::$32 = main::$30 | main::$31
  [39] main::bits#3 = bits_count[main::$32]
  [40] if(main::bits#3<2) goto main::@5
  to:main::@9
main::@9: scope:[main]  from main::@4
  [41] main::bits_gen#8 = main::bits_gen#16 + 1
  to:main::@5
main::@5: scope:[main]  from main::@4 main::@9
  [42] main::bits_gen#15 = phi( main::@4/main::bits_gen#16, main::@9/main::bits_gen#8 )
  [43] main::bits_gen#7 = main::bits_gen#15 << 1
  [44] *main::charset4#10 = main::bits_gen#7
  [45] main::charset4#1 = ++ main::charset4#10
  [46] main::chargen#1 = main::chargen#10 + 2
  [47] if(main::chargen#1<CHARGEN+$800) goto main::@1
  to:main::@10
main::@10: scope:[main]  from main::@5
  [48] *PROCPORT = $37
  asm { cli  }
  to:main::@11
main::@11: scope:[main]  from main::@10 main::@11
  [50] main::i#2 = phi( main::@10/0, main::@11/main::i#1 )
  [51] SCREEN[main::i#2] = main::i#2
  [52] main::i#1 = ++ main::i#2
  [53] if(main::i#1!=0) goto main::@11
  to:main::@12
main::@12: scope:[main]  from main::@11
  [54] *D018 = $19
  to:main::@return
main::@return: scope:[main]  from main::@12
  [55] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void main()
byte~ main::$1 7.333333333333333
byte~ main::$11 7.333333333333333
byte~ main::$12 22.0
byte~ main::$13 22.0
byte~ main::$14 22.0
byte~ main::$15 22.0
byte~ main::$2 22.0
byte~ main::$20 22.0
byte~ main::$21 7.333333333333333
byte~ main::$22 22.0
byte~ main::$23 22.0
byte~ main::$24 22.0
byte~ main::$29 22.0
byte~ main::$3 22.0
byte~ main::$30 11.0
byte~ main::$31 22.0
byte~ main::$32 22.0
byte~ main::$4 22.0
byte~ main::$5 22.0
byte~ main::$6 22.0
byte main::bits
byte main::bits#0 22.0
byte main::bits#1 22.0
byte main::bits#2 22.0
byte main::bits#3 22.0
byte main::bits_gen
byte main::bits_gen#1 4.125
byte main::bits_gen#11 33.0
byte main::bits_gen#13 33.0
byte main::bits_gen#14 4.125
byte main::bits_gen#15 33.0
byte main::bits_gen#16 4.714285714285714
byte main::bits_gen#4 22.0
byte main::bits_gen#6 22.0
byte main::bits_gen#7 22.0
byte main::bits_gen#8 22.0
byte main::bits_gen#9 11.0
byte* main::chargen
byte* main::chargen#1 16.5
byte* main::chargen#10 1.75
byte* main::chargen1
byte* main::chargen1#0 1.6176470588235294
byte* main::charset4
byte* main::charset4#1 7.333333333333333
byte* main::charset4#10 0.7674418604651163
byte main::i
byte main::i#1 16.5
byte main::i#2 22.0

Initial phi equivalence classes
[ main::chargen#10 main::chargen#1 ]
[ main::charset4#10 main::charset4#1 ]
[ main::bits_gen#9 ]
[ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ]
[ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ]
[ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ]
[ main::i#2 main::i#1 ]
Added variable main::chargen1#0 to live range equivalence class [ main::chargen1#0 ]
Added variable main::$1 to live range equivalence class [ main::$1 ]
Added variable main::$2 to live range equivalence class [ main::$2 ]
Added variable main::$3 to live range equivalence class [ main::$3 ]
Added variable main::$4 to live range equivalence class [ main::$4 ]
Added variable main::$5 to live range equivalence class [ main::$5 ]
Added variable main::$6 to live range equivalence class [ main::$6 ]
Added variable main::bits#0 to live range equivalence class [ main::bits#0 ]
Added variable main::$11 to live range equivalence class [ main::$11 ]
Added variable main::$12 to live range equivalence class [ main::$12 ]
Added variable main::$13 to live range equivalence class [ main::$13 ]
Added variable main::$14 to live range equivalence class [ main::$14 ]
Added variable main::$15 to live range equivalence class [ main::$15 ]
Added variable main::bits#1 to live range equivalence class [ main::bits#1 ]
Added variable main::$20 to live range equivalence class [ main::$20 ]
Added variable main::$21 to live range equivalence class [ main::$21 ]
Added variable main::$22 to live range equivalence class [ main::$22 ]
Added variable main::$23 to live range equivalence class [ main::$23 ]
Added variable main::$24 to live range equivalence class [ main::$24 ]
Added variable main::bits#2 to live range equivalence class [ main::bits#2 ]
Added variable main::$29 to live range equivalence class [ main::$29 ]
Added variable main::$30 to live range equivalence class [ main::$30 ]
Added variable main::$31 to live range equivalence class [ main::$31 ]
Added variable main::$32 to live range equivalence class [ main::$32 ]
Added variable main::bits#3 to live range equivalence class [ main::bits#3 ]
Added variable main::bits_gen#7 to live range equivalence class [ main::bits_gen#7 ]
Complete equivalence classes
[ main::chargen#10 main::chargen#1 ]
[ main::charset4#10 main::charset4#1 ]
[ main::bits_gen#9 ]
[ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ]
[ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ]
[ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ]
[ main::i#2 main::i#1 ]
[ main::chargen1#0 ]
[ main::$1 ]
[ main::$2 ]
[ main::$3 ]
[ main::$4 ]
[ main::$5 ]
[ main::$6 ]
[ main::bits#0 ]
[ main::$11 ]
[ main::$12 ]
[ main::$13 ]
[ main::$14 ]
[ main::$15 ]
[ main::bits#1 ]
[ main::$20 ]
[ main::$21 ]
[ main::$22 ]
[ main::$23 ]
[ main::$24 ]
[ main::bits#2 ]
[ main::$29 ]
[ main::$30 ]
[ main::$31 ]
[ main::$32 ]
[ main::bits#3 ]
[ main::bits_gen#7 ]
Allocated zp[2]:2 [ main::chargen#10 main::chargen#1 ]
Allocated zp[2]:4 [ main::charset4#10 main::charset4#1 ]
Allocated zp[1]:6 [ main::bits_gen#9 ]
Allocated zp[1]:7 [ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ]
Allocated zp[1]:8 [ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ]
Allocated zp[1]:9 [ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ]
Allocated zp[1]:10 [ main::i#2 main::i#1 ]
Allocated zp[2]:11 [ main::chargen1#0 ]
Allocated zp[1]:13 [ main::$1 ]
Allocated zp[1]:14 [ main::$2 ]
Allocated zp[1]:15 [ main::$3 ]
Allocated zp[1]:16 [ main::$4 ]
Allocated zp[1]:17 [ main::$5 ]
Allocated zp[1]:18 [ main::$6 ]
Allocated zp[1]:19 [ main::bits#0 ]
Allocated zp[1]:20 [ main::$11 ]
Allocated zp[1]:21 [ main::$12 ]
Allocated zp[1]:22 [ main::$13 ]
Allocated zp[1]:23 [ main::$14 ]
Allocated zp[1]:24 [ main::$15 ]
Allocated zp[1]:25 [ main::bits#1 ]
Allocated zp[1]:26 [ main::$20 ]
Allocated zp[1]:27 [ main::$21 ]
Allocated zp[1]:28 [ main::$22 ]
Allocated zp[1]:29 [ main::$23 ]
Allocated zp[1]:30 [ main::$24 ]
Allocated zp[1]:31 [ main::bits#2 ]
Allocated zp[1]:32 [ main::$29 ]
Allocated zp[1]:33 [ main::$30 ]
Allocated zp[1]:34 [ main::$31 ]
Allocated zp[1]:35 [ main::$32 ]
Allocated zp[1]:36 [ main::bits#3 ]
Allocated zp[1]:37 [ main::bits_gen#7 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] *PROCPORT = $32 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] main::chargen1#0 = main::chargen#10 + 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 ] { }  ) always clobbers reg byte a 
Statement [4] main::$1 = *main::chargen#10 & $60 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [5] main::$2 = *main::chargen1#0 & $60 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 main::$2 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 main::$2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:13 [ main::$1 ]
Removing always clobbered register reg byte y as potential for zp[1]:13 [ main::$1 ]
Statement [6] main::$3 = main::$2 >> 2 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 main::$3 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 main::$3 ] { }  ) always clobbers reg byte a 
Statement [8] main::$5 = main::$4 >> 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$5 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$5 ] { }  ) always clobbers reg byte a 
Statement [9] main::$6 = main::$5 >> 2 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$6 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$6 ] { }  ) always clobbers reg byte a 
Statement [14] main::bits_gen#1 = main::bits_gen#9 << 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 ] { }  ) always clobbers reg byte a 
Statement [15] main::$11 = *main::chargen#10 & $18 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:7 [ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ]
Removing always clobbered register reg byte y as potential for zp[1]:7 [ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ]
Statement [16] main::$12 = *main::chargen1#0 & $18 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 main::$12 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 main::$12 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:20 [ main::$11 ]
Removing always clobbered register reg byte y as potential for zp[1]:20 [ main::$11 ]
Statement [17] main::$13 = main::$12 >> 2 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 main::$13 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 main::$13 ] { }  ) always clobbers reg byte a 
Statement [19] main::$15 = main::$14 >> 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$15 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$15 ] { }  ) always clobbers reg byte a 
Statement [24] main::bits_gen#14 = main::bits_gen#11 << 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 ] { }  ) always clobbers reg byte a 
Statement [25] main::$20 = *main::chargen#10 & 6 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$20 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$20 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:8 [ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ]
Removing always clobbered register reg byte y as potential for zp[1]:8 [ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ]
Statement [26] main::$21 = main::$20 << 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 ] { }  ) always clobbers reg byte a 
Statement [27] main::$22 = *main::chargen1#0 & 6 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 main::$22 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 main::$22 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:27 [ main::$21 ]
Removing always clobbered register reg byte y as potential for zp[1]:27 [ main::$21 ]
Statement [28] main::$23 = main::$22 >> 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 main::$23 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 main::$23 ] { }  ) always clobbers reg byte a 
Statement [34] main::bits_gen#16 = main::bits_gen#13 << 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 ] { }  ) always clobbers reg byte a 
Statement [35] main::$29 = *main::chargen#10 & 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 main::$29 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 main::$29 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:9 [ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ]
Removing always clobbered register reg byte y as potential for zp[1]:9 [ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ]
Statement [36] main::$30 = main::$29 << 2 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 main::$30 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 main::$30 ] { }  ) always clobbers reg byte a 
Statement [37] main::$31 = *main::chargen1#0 & 1 [ main::chargen#10 main::charset4#10 main::bits_gen#16 main::$30 main::$31 ] (  [ main::chargen#10 main::charset4#10 main::bits_gen#16 main::$30 main::$31 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:33 [ main::$30 ]
Removing always clobbered register reg byte y as potential for zp[1]:33 [ main::$30 ]
Statement [43] main::bits_gen#7 = main::bits_gen#15 << 1 [ main::chargen#10 main::charset4#10 main::bits_gen#7 ] (  [ main::chargen#10 main::charset4#10 main::bits_gen#7 ] { }  ) always clobbers reg byte a 
Statement [44] *main::charset4#10 = main::bits_gen#7 [ main::chargen#10 main::charset4#10 ] (  [ main::chargen#10 main::charset4#10 ] { }  ) always clobbers reg byte y 
Statement [46] main::chargen#1 = main::chargen#10 + 2 [ main::chargen#1 main::charset4#1 ] (  [ main::chargen#1 main::charset4#1 ] { }  ) always clobbers reg byte a 
Statement [47] if(main::chargen#1<CHARGEN+$800) goto main::@1 [ main::chargen#1 main::charset4#1 ] (  [ main::chargen#1 main::charset4#1 ] { }  ) always clobbers reg byte a 
Statement [48] *PROCPORT = $37 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [54] *D018 = $19 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [1] *PROCPORT = $32 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] main::chargen1#0 = main::chargen#10 + 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 ] { }  ) always clobbers reg byte a 
Statement [4] main::$1 = *main::chargen#10 & $60 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [5] main::$2 = *main::chargen1#0 & $60 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 main::$2 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 main::$2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [6] main::$3 = main::$2 >> 2 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 main::$3 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$1 main::$3 ] { }  ) always clobbers reg byte a 
Statement [8] main::$5 = main::$4 >> 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$5 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$5 ] { }  ) always clobbers reg byte a 
Statement [9] main::$6 = main::$5 >> 2 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$6 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::$6 ] { }  ) always clobbers reg byte a 
Statement [14] main::bits_gen#1 = main::bits_gen#9 << 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 ] { }  ) always clobbers reg byte a 
Statement [15] main::$11 = *main::chargen#10 & $18 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 ] { }  ) always clobbers reg byte a reg byte y 
Statement [16] main::$12 = *main::chargen1#0 & $18 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 main::$12 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 main::$12 ] { }  ) always clobbers reg byte a reg byte y 
Statement [17] main::$13 = main::$12 >> 2 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 main::$13 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$11 main::$13 ] { }  ) always clobbers reg byte a 
Statement [19] main::$15 = main::$14 >> 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$15 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#1 main::$15 ] { }  ) always clobbers reg byte a 
Statement [24] main::bits_gen#14 = main::bits_gen#11 << 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 ] { }  ) always clobbers reg byte a 
Statement [25] main::$20 = *main::chargen#10 & 6 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$20 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$20 ] { }  ) always clobbers reg byte a reg byte y 
Statement [26] main::$21 = main::$20 << 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 ] { }  ) always clobbers reg byte a 
Statement [27] main::$22 = *main::chargen1#0 & 6 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 main::$22 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 main::$22 ] { }  ) always clobbers reg byte a reg byte y 
Statement [28] main::$23 = main::$22 >> 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 main::$23 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#14 main::$21 main::$23 ] { }  ) always clobbers reg byte a 
Statement [34] main::bits_gen#16 = main::bits_gen#13 << 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 ] { }  ) always clobbers reg byte a 
Statement [35] main::$29 = *main::chargen#10 & 1 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 main::$29 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 main::$29 ] { }  ) always clobbers reg byte a reg byte y 
Statement [36] main::$30 = main::$29 << 2 [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 main::$30 ] (  [ main::chargen#10 main::charset4#10 main::chargen1#0 main::bits_gen#16 main::$30 ] { }  ) always clobbers reg byte a 
Statement [37] main::$31 = *main::chargen1#0 & 1 [ main::chargen#10 main::charset4#10 main::bits_gen#16 main::$30 main::$31 ] (  [ main::chargen#10 main::charset4#10 main::bits_gen#16 main::$30 main::$31 ] { }  ) always clobbers reg byte a reg byte y 
Statement [43] main::bits_gen#7 = main::bits_gen#15 << 1 [ main::chargen#10 main::charset4#10 main::bits_gen#7 ] (  [ main::chargen#10 main::charset4#10 main::bits_gen#7 ] { }  ) always clobbers reg byte a 
Statement [44] *main::charset4#10 = main::bits_gen#7 [ main::chargen#10 main::charset4#10 ] (  [ main::chargen#10 main::charset4#10 ] { }  ) always clobbers reg byte y 
Statement [46] main::chargen#1 = main::chargen#10 + 2 [ main::chargen#1 main::charset4#1 ] (  [ main::chargen#1 main::charset4#1 ] { }  ) always clobbers reg byte a 
Statement [47] if(main::chargen#1<CHARGEN+$800) goto main::@1 [ main::chargen#1 main::charset4#1 ] (  [ main::chargen#1 main::charset4#1 ] { }  ) always clobbers reg byte a 
Statement [48] *PROCPORT = $37 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [54] *D018 = $19 [ ] (  [ ] { }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ main::chargen#10 main::chargen#1 ] : zp[2]:2 , 
Potential registers zp[2]:4 [ main::charset4#10 main::charset4#1 ] : zp[2]:4 , 
Potential registers zp[1]:6 [ main::bits_gen#9 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ] : zp[1]:7 , reg byte x , 
Potential registers zp[1]:8 [ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ] : zp[1]:8 , reg byte x , 
Potential registers zp[1]:9 [ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ] : zp[1]:9 , reg byte x , 
Potential registers zp[1]:10 [ main::i#2 main::i#1 ] : zp[1]:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:11 [ main::chargen1#0 ] : zp[2]:11 , 
Potential registers zp[1]:13 [ main::$1 ] : zp[1]:13 , reg byte x , 
Potential registers zp[1]:14 [ main::$2 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ main::$3 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ main::$4 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ main::$5 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:18 [ main::$6 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:19 [ main::bits#0 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:20 [ main::$11 ] : zp[1]:20 , reg byte x , 
Potential registers zp[1]:21 [ main::$12 ] : zp[1]:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:22 [ main::$13 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:23 [ main::$14 ] : zp[1]:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:24 [ main::$15 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:25 [ main::bits#1 ] : zp[1]:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:26 [ main::$20 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:27 [ main::$21 ] : zp[1]:27 , reg byte x , 
Potential registers zp[1]:28 [ main::$22 ] : zp[1]:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:29 [ main::$23 ] : zp[1]:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:30 [ main::$24 ] : zp[1]:30 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:31 [ main::bits#2 ] : zp[1]:31 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:32 [ main::$29 ] : zp[1]:32 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:33 [ main::$30 ] : zp[1]:33 , reg byte x , 
Potential registers zp[1]:34 [ main::$31 ] : zp[1]:34 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:35 [ main::$32 ] : zp[1]:35 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:36 [ main::bits#3 ] : zp[1]:36 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:37 [ main::bits_gen#7 ] : zp[1]:37 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 59.71: zp[1]:9 [ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ] 59.12: zp[1]:7 [ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ] 59.12: zp[1]:8 [ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ] 38.5: zp[1]:10 [ main::i#2 main::i#1 ] 22: zp[1]:14 [ main::$2 ] 22: zp[1]:15 [ main::$3 ] 22: zp[1]:16 [ main::$4 ] 22: zp[1]:17 [ main::$5 ] 22: zp[1]:18 [ main::$6 ] 22: zp[1]:19 [ main::bits#0 ] 22: zp[1]:21 [ main::$12 ] 22: zp[1]:22 [ main::$13 ] 22: zp[1]:23 [ main::$14 ] 22: zp[1]:24 [ main::$15 ] 22: zp[1]:25 [ main::bits#1 ] 22: zp[1]:26 [ main::$20 ] 22: zp[1]:28 [ main::$22 ] 22: zp[1]:29 [ main::$23 ] 22: zp[1]:30 [ main::$24 ] 22: zp[1]:31 [ main::bits#2 ] 22: zp[1]:32 [ main::$29 ] 22: zp[1]:34 [ main::$31 ] 22: zp[1]:35 [ main::$32 ] 22: zp[1]:36 [ main::bits#3 ] 22: zp[1]:37 [ main::bits_gen#7 ] 18.25: zp[2]:2 [ main::chargen#10 main::chargen#1 ] 11: zp[1]:6 [ main::bits_gen#9 ] 11: zp[1]:33 [ main::$30 ] 8.1: zp[2]:4 [ main::charset4#10 main::charset4#1 ] 7.33: zp[1]:13 [ main::$1 ] 7.33: zp[1]:20 [ main::$11 ] 7.33: zp[1]:27 [ main::$21 ] 1.62: zp[2]:11 [ main::chargen1#0 ] 
Uplift Scope [] 

Uplifting [] best 5071 combination 
Attempting to uplift remaining variables inzp[1]:9 [ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ]
Uplifting [main] best 5021 combination reg byte x [ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ] 
Attempting to uplift remaining variables inzp[1]:7 [ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ]
Uplifting [main] best 4971 combination reg byte x [ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ] 
Attempting to uplift remaining variables inzp[1]:8 [ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ]
Uplifting [main] best 4921 combination reg byte x [ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ] 
Attempting to uplift remaining variables inzp[1]:10 [ main::i#2 main::i#1 ]
Uplifting [main] best 4821 combination reg byte x [ main::i#2 main::i#1 ] 
Attempting to uplift remaining variables inzp[1]:14 [ main::$2 ]
Uplifting [main] best 4761 combination reg byte a [ main::$2 ] 
Attempting to uplift remaining variables inzp[1]:15 [ main::$3 ]
Uplifting [main] best 4701 combination reg byte a [ main::$3 ] 
Attempting to uplift remaining variables inzp[1]:16 [ main::$4 ]
Uplifting [main] best 4641 combination reg byte a [ main::$4 ] 
Attempting to uplift remaining variables inzp[1]:17 [ main::$5 ]
Uplifting [main] best 4581 combination reg byte a [ main::$5 ] 
Attempting to uplift remaining variables inzp[1]:18 [ main::$6 ]
Uplifting [main] best 4541 combination reg byte a [ main::$6 ] 
Attempting to uplift remaining variables inzp[1]:19 [ main::bits#0 ]
Uplifting [main] best 4481 combination reg byte a [ main::bits#0 ] 
Attempting to uplift remaining variables inzp[1]:21 [ main::$12 ]
Uplifting [main] best 4421 combination reg byte a [ main::$12 ] 
Attempting to uplift remaining variables inzp[1]:22 [ main::$13 ]
Uplifting [main] best 4361 combination reg byte a [ main::$13 ] 
Attempting to uplift remaining variables inzp[1]:23 [ main::$14 ]
Uplifting [main] best 4301 combination reg byte a [ main::$14 ] 
Attempting to uplift remaining variables inzp[1]:24 [ main::$15 ]
Uplifting [main] best 4261 combination reg byte a [ main::$15 ] 
Attempting to uplift remaining variables inzp[1]:25 [ main::bits#1 ]
Uplifting [main] best 4201 combination reg byte a [ main::bits#1 ] 
Attempting to uplift remaining variables inzp[1]:26 [ main::$20 ]
Uplifting [main] best 4141 combination reg byte a [ main::$20 ] 
Attempting to uplift remaining variables inzp[1]:28 [ main::$22 ]
Uplifting [main] best 4081 combination reg byte a [ main::$22 ] 
Attempting to uplift remaining variables inzp[1]:29 [ main::$23 ]
Uplifting [main] best 4021 combination reg byte a [ main::$23 ] 
Attempting to uplift remaining variables inzp[1]:30 [ main::$24 ]
Uplifting [main] best 3981 combination reg byte a [ main::$24 ] 
Attempting to uplift remaining variables inzp[1]:31 [ main::bits#2 ]
Uplifting [main] best 3921 combination reg byte a [ main::bits#2 ] 
Attempting to uplift remaining variables inzp[1]:32 [ main::$29 ]
Uplifting [main] best 3861 combination reg byte a [ main::$29 ] 
Attempting to uplift remaining variables inzp[1]:34 [ main::$31 ]
Uplifting [main] best 3801 combination reg byte a [ main::$31 ] 
Attempting to uplift remaining variables inzp[1]:35 [ main::$32 ]
Uplifting [main] best 3761 combination reg byte a [ main::$32 ] 
Attempting to uplift remaining variables inzp[1]:36 [ main::bits#3 ]
Uplifting [main] best 3701 combination reg byte a [ main::bits#3 ] 
Attempting to uplift remaining variables inzp[1]:37 [ main::bits_gen#7 ]
Uplifting [main] best 3641 combination reg byte a [ main::bits_gen#7 ] 
Attempting to uplift remaining variables inzp[1]:6 [ main::bits_gen#9 ]
Uplifting [main] best 3551 combination reg byte a [ main::bits_gen#9 ] 
Attempting to uplift remaining variables inzp[1]:33 [ main::$30 ]
Uplifting [main] best 3551 combination zp[1]:33 [ main::$30 ] 
Attempting to uplift remaining variables inzp[1]:13 [ main::$1 ]
Uplifting [main] best 3551 combination zp[1]:13 [ main::$1 ] 
Attempting to uplift remaining variables inzp[1]:20 [ main::$11 ]
Uplifting [main] best 3551 combination zp[1]:20 [ main::$11 ] 
Attempting to uplift remaining variables inzp[1]:27 [ main::$21 ]
Uplifting [main] best 3551 combination zp[1]:27 [ main::$21 ] 
Allocated (was zp[2]:11) zp[2]:6 [ main::chargen1#0 ]
Allocated (was zp[1]:13) zp[1]:8 [ main::$1 ]
Allocated (was zp[1]:20) zp[1]:9 [ main::$11 ]
Allocated (was zp[1]:27) zp[1]:10 [ main::$21 ]
Allocated (was zp[1]:33) zp[1]:11 [ main::$30 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
  // Upstart
  // Commodore 64 PRG executable file
.file [name="halfscii.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label SCREEN = $400
  .label CHARGEN = $d000
  .label PROCPORT = 1
  .label D018 = $d018
  .label CHARSET4 = $2800
.segment Code
  // main
main: {
    .label __1 = 8
    .label __11 = 9
    .label __21 = $a
    .label __30 = $b
    .label chargen1 = 6
    .label charset4 = 4
    .label chargen = 2
    // asm { sei  }
    sei
    // [1] *PROCPORT = $32 -- _deref_pbuc1=vbuc2 
    lda #$32
    sta PROCPORT
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [2] phi main::charset4#10 = CHARSET4 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET4
    sta.z charset4
    lda #>CHARSET4
    sta.z charset4+1
    // [2] phi main::chargen#10 = CHARGEN [phi:main->main::@1#1] -- pbuz1=pbuc1 
    lda #<CHARGEN
    sta.z chargen
    lda #>CHARGEN
    sta.z chargen+1
    jmp __b1
    // [2] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  __b1_from___b5:
    // [2] phi main::charset4#10 = main::charset4#1 [phi:main::@5->main::@1#0] -- register_copy 
    // [2] phi main::chargen#10 = main::chargen#1 [phi:main::@5->main::@1#1] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [3] main::chargen1#0 = main::chargen#10 + 1 -- pbuz1=pbuz2_plus_1 
    clc
    lda.z chargen
    adc #1
    sta.z chargen1
    lda.z chargen+1
    adc #0
    sta.z chargen1+1
    // [4] main::$1 = *main::chargen#10 & $60 -- vbuz1=_deref_pbuz2_band_vbuc1 
    lda #$60
    ldy #0
    and (chargen),y
    sta.z __1
    // [5] main::$2 = *main::chargen1#0 & $60 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #$60
    ldy #0
    and (chargen1),y
    // [6] main::$3 = main::$2 >> 2 -- vbuaa=vbuaa_ror_2 
    lsr
    lsr
    // [7] main::$4 = main::$1 | main::$3 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // [8] main::$5 = main::$4 >> 1 -- vbuaa=vbuaa_ror_1 
    lsr
    // [9] main::$6 = main::$5 >> 2 -- vbuaa=vbuaa_ror_2 
    lsr
    lsr
    // [10] main::bits#0 = bits_count[main::$6] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda bits_count,y
    // [11] if(main::bits#0<2) goto main::@2 -- vbuaa_lt_vbuc1_then_la1 
    cmp #2
    bcc __b2_from___b1
    // [12] phi from main::@1 to main::@6 [phi:main::@1->main::@6]
  __b6_from___b1:
    jmp __b6
    // main::@6
  __b6:
    // [13] phi from main::@6 to main::@2 [phi:main::@6->main::@2]
  __b2_from___b6:
    // [13] phi main::bits_gen#9 = 1 [phi:main::@6->main::@2#0] -- vbuaa=vbuc1 
    lda #1
    jmp __b2
    // [13] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    // [13] phi main::bits_gen#9 = 0 [phi:main::@1->main::@2#0] -- vbuaa=vbuc1 
    lda #0
    jmp __b2
    // main::@2
  __b2:
    // [14] main::bits_gen#1 = main::bits_gen#9 << 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [15] main::$11 = *main::chargen#10 & $18 -- vbuz1=_deref_pbuz2_band_vbuc1 
    lda #$18
    ldy #0
    and (chargen),y
    sta.z __11
    // [16] main::$12 = *main::chargen1#0 & $18 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #$18
    ldy #0
    and (chargen1),y
    // [17] main::$13 = main::$12 >> 2 -- vbuaa=vbuaa_ror_2 
    lsr
    lsr
    // [18] main::$14 = main::$11 | main::$13 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __11
    // [19] main::$15 = main::$14 >> 1 -- vbuaa=vbuaa_ror_1 
    lsr
    // [20] main::bits#1 = bits_count[main::$15] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda bits_count,y
    // [21] if(main::bits#1<2) goto main::@3 -- vbuaa_lt_vbuc1_then_la1 
    cmp #2
    bcc __b3_from___b2
    jmp __b7
    // main::@7
  __b7:
    // [22] main::bits_gen#4 = main::bits_gen#1 + 1 -- vbuxx=vbuxx_plus_1 
    inx
    // [23] phi from main::@2 main::@7 to main::@3 [phi:main::@2/main::@7->main::@3]
  __b3_from___b2:
  __b3_from___b7:
    // [23] phi main::bits_gen#11 = main::bits_gen#1 [phi:main::@2/main::@7->main::@3#0] -- register_copy 
    jmp __b3
    // main::@3
  __b3:
    // [24] main::bits_gen#14 = main::bits_gen#11 << 1 -- vbuxx=vbuxx_rol_1 
    txa
    asl
    tax
    // [25] main::$20 = *main::chargen#10 & 6 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #6
    ldy #0
    and (chargen),y
    // [26] main::$21 = main::$20 << 1 -- vbuz1=vbuaa_rol_1 
    asl
    sta.z __21
    // [27] main::$22 = *main::chargen1#0 & 6 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #6
    ldy #0
    and (chargen1),y
    // [28] main::$23 = main::$22 >> 1 -- vbuaa=vbuaa_ror_1 
    lsr
    // [29] main::$24 = main::$21 | main::$23 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __21
    // [30] main::bits#2 = bits_count[main::$24] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda bits_count,y
    // [31] if(main::bits#2<2) goto main::@4 -- vbuaa_lt_vbuc1_then_la1 
    cmp #2
    bcc __b4_from___b3
    jmp __b8
    // main::@8
  __b8:
    // [32] main::bits_gen#6 = main::bits_gen#14 + 1 -- vbuxx=vbuxx_plus_1 
    inx
    // [33] phi from main::@3 main::@8 to main::@4 [phi:main::@3/main::@8->main::@4]
  __b4_from___b3:
  __b4_from___b8:
    // [33] phi main::bits_gen#13 = main::bits_gen#14 [phi:main::@3/main::@8->main::@4#0] -- register_copy 
    jmp __b4
    // main::@4
  __b4:
    // [34] main::bits_gen#16 = main::bits_gen#13 << 1 -- vbuxx=vbuxx_rol_1 
    txa
    asl
    tax
    // [35] main::$29 = *main::chargen#10 & 1 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #1
    ldy #0
    and (chargen),y
    // [36] main::$30 = main::$29 << 2 -- vbuz1=vbuaa_rol_2 
    asl
    asl
    sta.z __30
    // [37] main::$31 = *main::chargen1#0 & 1 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #1
    ldy #0
    and (chargen1),y
    // [38] main::$32 = main::$30 | main::$31 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __30
    // [39] main::bits#3 = bits_count[main::$32] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda bits_count,y
    // [40] if(main::bits#3<2) goto main::@5 -- vbuaa_lt_vbuc1_then_la1 
    cmp #2
    bcc __b5_from___b4
    jmp __b9
    // main::@9
  __b9:
    // [41] main::bits_gen#8 = main::bits_gen#16 + 1 -- vbuxx=vbuxx_plus_1 
    inx
    // [42] phi from main::@4 main::@9 to main::@5 [phi:main::@4/main::@9->main::@5]
  __b5_from___b4:
  __b5_from___b9:
    // [42] phi main::bits_gen#15 = main::bits_gen#16 [phi:main::@4/main::@9->main::@5#0] -- register_copy 
    jmp __b5
    // main::@5
  __b5:
    // [43] main::bits_gen#7 = main::bits_gen#15 << 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [44] *main::charset4#10 = main::bits_gen#7 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (charset4),y
    // [45] main::charset4#1 = ++ main::charset4#10 -- pbuz1=_inc_pbuz1 
    inc.z charset4
    bne !+
    inc.z charset4+1
  !:
    // [46] main::chargen#1 = main::chargen#10 + 2 -- pbuz1=pbuz1_plus_vbuc1 
    lda #2
    clc
    adc.z chargen
    sta.z chargen
    bcc !+
    inc.z chargen+1
  !:
    // [47] if(main::chargen#1<CHARGEN+$800) goto main::@1 -- pbuz1_lt_pbuc1_then_la1 
    lda.z chargen+1
    cmp #>CHARGEN+$800
    bcc __b1_from___b5
    bne !+
    lda.z chargen
    cmp #<CHARGEN+$800
    bcc __b1_from___b5
  !:
    jmp __b10
    // main::@10
  __b10:
    // [48] *PROCPORT = $37 -- _deref_pbuc1=vbuc2 
    lda #$37
    sta PROCPORT
    // asm { cli  }
    cli
    // [50] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  __b11_from___b10:
    // [50] phi main::i#2 = 0 [phi:main::@10->main::@11#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b11
    // [50] phi from main::@11 to main::@11 [phi:main::@11->main::@11]
  __b11_from___b11:
    // [50] phi main::i#2 = main::i#1 [phi:main::@11->main::@11#0] -- register_copy 
    jmp __b11
    // main::@11
  __b11:
    // [51] SCREEN[main::i#2] = main::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta SCREEN,x
    // [52] main::i#1 = ++ main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [53] if(main::i#1!=0) goto main::@11 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b11_from___b11
    jmp __b12
    // main::@12
  __b12:
    // [54] *D018 = $19 -- _deref_pbuc1=vbuc2 
    lda #$19
    sta D018
    jmp __breturn
    // main::@return
  __breturn:
    // [55] return 
    rts
}
  // File Data
.segment Data
  bits_count: .byte 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b6
Removing instruction jmp __b2
Removing instruction jmp __b7
Removing instruction jmp __b3
Removing instruction jmp __b8
Removing instruction jmp __b4
Removing instruction jmp __b9
Removing instruction jmp __b5
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b3_from___b2 with __b3
Replacing label __b4_from___b3 with __b4
Replacing label __b5_from___b4 with __b5
Replacing label __b1_from___b5 with __b1
Replacing label __b1_from___b5 with __b1
Replacing label __b11_from___b11 with __b11
Removing instruction __b1_from___b5:
Removing instruction __b6_from___b1:
Removing instruction __b2_from___b6:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b7:
Removing instruction __b4_from___b3:
Removing instruction __b4_from___b8:
Removing instruction __b5_from___b4:
Removing instruction __b5_from___b9:
Removing instruction __b11_from___b11:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b11_from___b10:
Removing instruction __b12:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Relabelling long label __b2_from___b1 to __b6
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b1
Removing instruction jmp __b11
Succesful ASM optimization Pass5NextJumpElimination
Fixing long branch [133] bcc __b1 to bcs
Fixing long branch [139] bcc __b1 to bcs

FINAL SYMBOL TABLE
constant byte* CHARGEN = (byte*) 53248
constant byte* CHARSET4 = (byte*) 10240
constant byte* D018 = (byte*) 53272
constant byte* PROCPORT = (byte*) 1
constant byte* SCREEN = (byte*) 1024
constant byte* bits_count[]  = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 }
void main()
byte~ main::$1 zp[1]:8 7.333333333333333
byte~ main::$11 zp[1]:9 7.333333333333333
byte~ main::$12 reg byte a 22.0
byte~ main::$13 reg byte a 22.0
byte~ main::$14 reg byte a 22.0
byte~ main::$15 reg byte a 22.0
byte~ main::$2 reg byte a 22.0
byte~ main::$20 reg byte a 22.0
byte~ main::$21 zp[1]:10 7.333333333333333
byte~ main::$22 reg byte a 22.0
byte~ main::$23 reg byte a 22.0
byte~ main::$24 reg byte a 22.0
byte~ main::$29 reg byte a 22.0
byte~ main::$3 reg byte a 22.0
byte~ main::$30 zp[1]:11 11.0
byte~ main::$31 reg byte a 22.0
byte~ main::$32 reg byte a 22.0
byte~ main::$4 reg byte a 22.0
byte~ main::$5 reg byte a 22.0
byte~ main::$6 reg byte a 22.0
byte main::bits
byte main::bits#0 reg byte a 22.0
byte main::bits#1 reg byte a 22.0
byte main::bits#2 reg byte a 22.0
byte main::bits#3 reg byte a 22.0
byte main::bits_gen
byte main::bits_gen#1 reg byte x 4.125
byte main::bits_gen#11 reg byte x 33.0
byte main::bits_gen#13 reg byte x 33.0
byte main::bits_gen#14 reg byte x 4.125
byte main::bits_gen#15 reg byte x 33.0
byte main::bits_gen#16 reg byte x 4.714285714285714
byte main::bits_gen#4 reg byte x 22.0
byte main::bits_gen#6 reg byte x 22.0
byte main::bits_gen#7 reg byte a 22.0
byte main::bits_gen#8 reg byte x 22.0
byte main::bits_gen#9 reg byte a 11.0
byte* main::chargen
byte* main::chargen#1 chargen zp[2]:2 16.5
byte* main::chargen#10 chargen zp[2]:2 1.75
byte* main::chargen1
byte* main::chargen1#0 chargen1 zp[2]:6 1.6176470588235294
byte* main::charset4
byte* main::charset4#1 charset4 zp[2]:4 7.333333333333333
byte* main::charset4#10 charset4 zp[2]:4 0.7674418604651163
byte main::i
byte main::i#1 reg byte x 16.5
byte main::i#2 reg byte x 22.0

zp[2]:2 [ main::chargen#10 main::chargen#1 ]
zp[2]:4 [ main::charset4#10 main::charset4#1 ]
reg byte a [ main::bits_gen#9 ]
reg byte x [ main::bits_gen#11 main::bits_gen#1 main::bits_gen#4 ]
reg byte x [ main::bits_gen#13 main::bits_gen#14 main::bits_gen#6 ]
reg byte x [ main::bits_gen#15 main::bits_gen#16 main::bits_gen#8 ]
reg byte x [ main::i#2 main::i#1 ]
zp[2]:6 [ main::chargen1#0 ]
zp[1]:8 [ main::$1 ]
reg byte a [ main::$2 ]
reg byte a [ main::$3 ]
reg byte a [ main::$4 ]
reg byte a [ main::$5 ]
reg byte a [ main::$6 ]
reg byte a [ main::bits#0 ]
zp[1]:9 [ main::$11 ]
reg byte a [ main::$12 ]
reg byte a [ main::$13 ]
reg byte a [ main::$14 ]
reg byte a [ main::$15 ]
reg byte a [ main::bits#1 ]
reg byte a [ main::$20 ]
zp[1]:10 [ main::$21 ]
reg byte a [ main::$22 ]
reg byte a [ main::$23 ]
reg byte a [ main::$24 ]
reg byte a [ main::bits#2 ]
reg byte a [ main::$29 ]
zp[1]:11 [ main::$30 ]
reg byte a [ main::$31 ]
reg byte a [ main::$32 ]
reg byte a [ main::bits#3 ]
reg byte a [ main::bits_gen#7 ]


FINAL ASSEMBLER
Score: 3108

  // File Comments
  // Upstart
  // Commodore 64 PRG executable file
.file [name="halfscii.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label SCREEN = $400
  .label CHARGEN = $d000
  .label PROCPORT = 1
  .label D018 = $d018
  .label CHARSET4 = $2800
.segment Code
  // main
main: {
    .label __1 = 8
    .label __11 = 9
    .label __21 = $a
    .label __30 = $b
    .label chargen1 = 6
    .label charset4 = 4
    .label chargen = 2
    // asm
    // asm { sei  }
    sei
    // *PROCPORT = $32
    // [1] *PROCPORT = $32 -- _deref_pbuc1=vbuc2 
    lda #$32
    sta PROCPORT
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // [2] phi main::charset4#10 = CHARSET4 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET4
    sta.z charset4
    lda #>CHARSET4
    sta.z charset4+1
    // [2] phi main::chargen#10 = CHARGEN [phi:main->main::@1#1] -- pbuz1=pbuc1 
    lda #<CHARGEN
    sta.z chargen
    lda #>CHARGEN
    sta.z chargen+1
    // [2] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
    // [2] phi main::charset4#10 = main::charset4#1 [phi:main::@5->main::@1#0] -- register_copy 
    // [2] phi main::chargen#10 = main::chargen#1 [phi:main::@5->main::@1#1] -- register_copy 
    // main::@1
  __b1:
    // chargen1 = chargen+1
    // [3] main::chargen1#0 = main::chargen#10 + 1 -- pbuz1=pbuz2_plus_1 
    clc
    lda.z chargen
    adc #1
    sta.z chargen1
    lda.z chargen+1
    adc #0
    sta.z chargen1+1
    // *chargen & %01100000
    // [4] main::$1 = *main::chargen#10 & $60 -- vbuz1=_deref_pbuz2_band_vbuc1 
    lda #$60
    ldy #0
    and (chargen),y
    sta.z __1
    // *chargen1 & %01100000
    // [5] main::$2 = *main::chargen1#0 & $60 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #$60
    and (chargen1),y
    // (*chargen1 & %01100000)/4
    // [6] main::$3 = main::$2 >> 2 -- vbuaa=vbuaa_ror_2 
    lsr
    lsr
    // (*chargen & %01100000) | (*chargen1 & %01100000)/4
    // [7] main::$4 = main::$1 | main::$3 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // ((*chargen & %01100000) | (*chargen1 & %01100000)/4)/2
    // [8] main::$5 = main::$4 >> 1 -- vbuaa=vbuaa_ror_1 
    lsr
    // ((*chargen & %01100000) | (*chargen1 & %01100000)/4)/2/4
    // [9] main::$6 = main::$5 >> 2 -- vbuaa=vbuaa_ror_2 
    lsr
    lsr
    // bits = bits_count[((*chargen & %01100000) | (*chargen1 & %01100000)/4)/2/4]
    // [10] main::bits#0 = bits_count[main::$6] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda bits_count,y
    // if(bits>=2)
    // [11] if(main::bits#0<2) goto main::@2 -- vbuaa_lt_vbuc1_then_la1 
    cmp #2
    bcc __b6
    // [12] phi from main::@1 to main::@6 [phi:main::@1->main::@6]
    // main::@6
    // [13] phi from main::@6 to main::@2 [phi:main::@6->main::@2]
    // [13] phi main::bits_gen#9 = 1 [phi:main::@6->main::@2#0] -- vbuaa=vbuc1 
    lda #1
    jmp __b2
    // [13] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b6:
    // [13] phi main::bits_gen#9 = 0 [phi:main::@1->main::@2#0] -- vbuaa=vbuc1 
    lda #0
    // main::@2
  __b2:
    // bits_gen = bits_gen*2
    // [14] main::bits_gen#1 = main::bits_gen#9 << 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // *chargen & %00011000
    // [15] main::$11 = *main::chargen#10 & $18 -- vbuz1=_deref_pbuz2_band_vbuc1 
    lda #$18
    ldy #0
    and (chargen),y
    sta.z __11
    // *chargen1 & %00011000
    // [16] main::$12 = *main::chargen1#0 & $18 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #$18
    and (chargen1),y
    // (*chargen1 & %00011000)/4
    // [17] main::$13 = main::$12 >> 2 -- vbuaa=vbuaa_ror_2 
    lsr
    lsr
    // (*chargen & %00011000) | (*chargen1 & %00011000)/4
    // [18] main::$14 = main::$11 | main::$13 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __11
    // ((*chargen & %00011000) | (*chargen1 & %00011000)/4)/2
    // [19] main::$15 = main::$14 >> 1 -- vbuaa=vbuaa_ror_1 
    lsr
    // bits = bits_count[((*chargen & %00011000) | (*chargen1 & %00011000)/4)/2]
    // [20] main::bits#1 = bits_count[main::$15] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda bits_count,y
    // if(bits>=2)
    // [21] if(main::bits#1<2) goto main::@3 -- vbuaa_lt_vbuc1_then_la1 
    cmp #2
    bcc __b3
    // main::@7
    // bits_gen = bits_gen + 1
    // [22] main::bits_gen#4 = main::bits_gen#1 + 1 -- vbuxx=vbuxx_plus_1 
    inx
    // [23] phi from main::@2 main::@7 to main::@3 [phi:main::@2/main::@7->main::@3]
    // [23] phi main::bits_gen#11 = main::bits_gen#1 [phi:main::@2/main::@7->main::@3#0] -- register_copy 
    // main::@3
  __b3:
    // bits_gen = bits_gen*2
    // [24] main::bits_gen#14 = main::bits_gen#11 << 1 -- vbuxx=vbuxx_rol_1 
    txa
    asl
    tax
    // *chargen & %00000110
    // [25] main::$20 = *main::chargen#10 & 6 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #6
    ldy #0
    and (chargen),y
    // (*chargen & %00000110)*2
    // [26] main::$21 = main::$20 << 1 -- vbuz1=vbuaa_rol_1 
    asl
    sta.z __21
    // *chargen1 & %00000110
    // [27] main::$22 = *main::chargen1#0 & 6 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #6
    and (chargen1),y
    // (*chargen1 & %00000110)/2
    // [28] main::$23 = main::$22 >> 1 -- vbuaa=vbuaa_ror_1 
    lsr
    // (*chargen & %00000110)*2 | (*chargen1 & %00000110)/2
    // [29] main::$24 = main::$21 | main::$23 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __21
    // bits = bits_count[((*chargen & %00000110)*2 | (*chargen1 & %00000110)/2)]
    // [30] main::bits#2 = bits_count[main::$24] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda bits_count,y
    // if(bits>=2)
    // [31] if(main::bits#2<2) goto main::@4 -- vbuaa_lt_vbuc1_then_la1 
    cmp #2
    bcc __b4
    // main::@8
    // bits_gen = bits_gen + 1
    // [32] main::bits_gen#6 = main::bits_gen#14 + 1 -- vbuxx=vbuxx_plus_1 
    inx
    // [33] phi from main::@3 main::@8 to main::@4 [phi:main::@3/main::@8->main::@4]
    // [33] phi main::bits_gen#13 = main::bits_gen#14 [phi:main::@3/main::@8->main::@4#0] -- register_copy 
    // main::@4
  __b4:
    // bits_gen = bits_gen*2
    // [34] main::bits_gen#16 = main::bits_gen#13 << 1 -- vbuxx=vbuxx_rol_1 
    txa
    asl
    tax
    // *chargen & %00000001
    // [35] main::$29 = *main::chargen#10 & 1 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #1
    ldy #0
    and (chargen),y
    // (*chargen & %00000001)*4
    // [36] main::$30 = main::$29 << 2 -- vbuz1=vbuaa_rol_2 
    asl
    asl
    sta.z __30
    // *chargen1 & %00000001
    // [37] main::$31 = *main::chargen1#0 & 1 -- vbuaa=_deref_pbuz1_band_vbuc1 
    lda #1
    and (chargen1),y
    // (*chargen & %00000001)*4 | (*chargen1 & %00000001)
    // [38] main::$32 = main::$30 | main::$31 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __30
    // bits = bits_count[((*chargen & %00000001)*4 | (*chargen1 & %00000001))]
    // [39] main::bits#3 = bits_count[main::$32] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda bits_count,y
    // if(bits>=2)
    // [40] if(main::bits#3<2) goto main::@5 -- vbuaa_lt_vbuc1_then_la1 
    cmp #2
    bcc __b5
    // main::@9
    // bits_gen = bits_gen + 1
    // [41] main::bits_gen#8 = main::bits_gen#16 + 1 -- vbuxx=vbuxx_plus_1 
    inx
    // [42] phi from main::@4 main::@9 to main::@5 [phi:main::@4/main::@9->main::@5]
    // [42] phi main::bits_gen#15 = main::bits_gen#16 [phi:main::@4/main::@9->main::@5#0] -- register_copy 
    // main::@5
  __b5:
    // bits_gen = bits_gen*2
    // [43] main::bits_gen#7 = main::bits_gen#15 << 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // *charset4 = bits_gen
    // [44] *main::charset4#10 = main::bits_gen#7 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (charset4),y
    // charset4++;
    // [45] main::charset4#1 = ++ main::charset4#10 -- pbuz1=_inc_pbuz1 
    inc.z charset4
    bne !+
    inc.z charset4+1
  !:
    // chargen = chargen+2
    // [46] main::chargen#1 = main::chargen#10 + 2 -- pbuz1=pbuz1_plus_vbuc1 
    lda #2
    clc
    adc.z chargen
    sta.z chargen
    bcc !+
    inc.z chargen+1
  !:
    // while (chargen<CHARGEN+$800)
    // [47] if(main::chargen#1<CHARGEN+$800) goto main::@1 -- pbuz1_lt_pbuc1_then_la1 
    lda.z chargen+1
    cmp #>CHARGEN+$800
    bcs !__b1+
    jmp __b1
  !__b1:
    bne !+
    lda.z chargen
    cmp #<CHARGEN+$800
    bcs !__b1+
    jmp __b1
  !__b1:
  !:
    // main::@10
    // *PROCPORT = $37
    // [48] *PROCPORT = $37 -- _deref_pbuc1=vbuc2 
    lda #$37
    sta PROCPORT
    // asm
    // asm { cli  }
    cli
    // [50] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
    // [50] phi main::i#2 = 0 [phi:main::@10->main::@11#0] -- vbuxx=vbuc1 
    ldx #0
    // [50] phi from main::@11 to main::@11 [phi:main::@11->main::@11]
    // [50] phi main::i#2 = main::i#1 [phi:main::@11->main::@11#0] -- register_copy 
    // main::@11
  __b11:
    // SCREEN[i] = i
    // [51] SCREEN[main::i#2] = main::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta SCREEN,x
    // for(byte i : 0..255)
    // [52] main::i#1 = ++ main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [53] if(main::i#1!=0) goto main::@11 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b11
    // main::@12
    // *D018 = $19
    // [54] *D018 = $19 -- _deref_pbuc1=vbuc2 
    lda #$19
    sta D018
    // main::@return
    // }
    // [55] return 
    rts
}
  // File Data
.segment Data
  bits_count: .byte 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4

