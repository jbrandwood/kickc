Resolved forward reference idx to idx
Resolved forward reference idx to idx
Resolved forward reference idx to idx
Inlined call call __init

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  idx#0 = 0
  main::$0 = typeid  $c+$c
  assertType::t1#0 = main::$0
  assertType::t2#0 = TYPEID_SIGNED_CHAR
  call assertType
  to:main::@1
main::@1: scope:[main]  from main
  idx#44 = phi( main/idx#40 )
  idx#1 = idx#44
  main::$2 = typeid  $c+$82
  assertType::t1#1 = main::$2
  assertType::t2#1 = TYPEID_INT
  call assertType
  to:main::@2
main::@2: scope:[main]  from main::@1
  idx#45 = phi( main::@1/idx#40 )
  idx#2 = idx#45
  main::$4 = typeid  $c+$80e8
  assertType::t1#2 = main::$4
  assertType::t2#2 = TYPEID_LONG
  call assertType
  to:main::@3
main::@3: scope:[main]  from main::@2
  idx#46 = phi( main::@2/idx#40 )
  idx#3 = idx#46
  main::$6 = typeid  $c+$c
  assertType::t1#3 = main::$6
  assertType::t2#3 = TYPEID_INT
  call assertType
  to:main::@4
main::@4: scope:[main]  from main::@3
  idx#47 = phi( main::@3/idx#40 )
  idx#4 = idx#47
  main::$8 = typeid  $c+$82
  assertType::t1#4 = main::$8
  assertType::t2#4 = TYPEID_INT
  call assertType
  to:main::@5
main::@5: scope:[main]  from main::@4
  idx#48 = phi( main::@4/idx#40 )
  idx#5 = idx#48
  main::$10 = typeid  $c+$186a0
  assertType::t1#5 = main::$10
  assertType::t2#5 = TYPEID_LONG
  call assertType
  to:main::@6
main::@6: scope:[main]  from main::@5
  idx#49 = phi( main::@5/idx#40 )
  idx#6 = idx#49
  main::$12 = typeid  $c+$c
  assertType::t1#6 = main::$12
  assertType::t2#6 = TYPEID_LONG
  call assertType
  to:main::@7
main::@7: scope:[main]  from main::@6
  idx#50 = phi( main::@6/idx#40 )
  idx#7 = idx#50
  main::$14 = typeid  $c+$82
  assertType::t1#7 = main::$14
  assertType::t2#7 = TYPEID_LONG
  call assertType
  to:main::@8
main::@8: scope:[main]  from main::@7
  idx#51 = phi( main::@7/idx#40 )
  idx#8 = idx#51
  main::$16 = typeid  $c+$186a0
  assertType::t1#8 = main::$16
  assertType::t2#8 = TYPEID_LONG
  call assertType
  to:main::@9
main::@9: scope:[main]  from main::@8
  idx#52 = phi( main::@8/idx#40 )
  idx#9 = idx#52
  idx#10 = $28
  main::$18 = typeid  $c+$c
  assertType::t1#9 = main::$18
  assertType::t2#9 = TYPEID_CHAR
  call assertType
  to:main::@10
main::@10: scope:[main]  from main::@9
  idx#53 = phi( main::@9/idx#40 )
  idx#11 = idx#53
  main::$20 = typeid  $c+$fa
  assertType::t1#10 = main::$20
  assertType::t2#10 = TYPEID_CHAR
  call assertType
  to:main::@11
main::@11: scope:[main]  from main::@10
  idx#54 = phi( main::@10/idx#40 )
  idx#12 = idx#54
  main::$22 = typeid  $c+$12c
  assertType::t1#11 = main::$22
  assertType::t2#11 = TYPEID_UNSIGNED_INT
  call assertType
  to:main::@12
main::@12: scope:[main]  from main::@11
  idx#55 = phi( main::@11/idx#40 )
  idx#13 = idx#55
  main::$24 = typeid  $c+$fffe
  assertType::t1#12 = main::$24
  assertType::t2#12 = TYPEID_UNSIGNED_INT
  call assertType
  to:main::@13
main::@13: scope:[main]  from main::@12
  idx#56 = phi( main::@12/idx#40 )
  idx#14 = idx#56
  main::$26 = typeid  $c+$101d0
  assertType::t1#13 = main::$26
  assertType::t2#13 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@14
main::@14: scope:[main]  from main::@13
  idx#57 = phi( main::@13/idx#40 )
  idx#15 = idx#57
  main::$28 = typeid  $c+$c
  assertType::t1#14 = main::$28
  assertType::t2#14 = TYPEID_UNSIGNED_INT
  call assertType
  to:main::@15
main::@15: scope:[main]  from main::@14
  idx#58 = phi( main::@14/idx#40 )
  idx#16 = idx#58
  main::$30 = typeid  $c+$82
  assertType::t1#15 = main::$30
  assertType::t2#15 = TYPEID_UNSIGNED_INT
  call assertType
  to:main::@16
main::@16: scope:[main]  from main::@15
  idx#59 = phi( main::@15/idx#40 )
  idx#17 = idx#59
  main::$32 = typeid  $c+$101d0
  assertType::t1#16 = main::$32
  assertType::t2#16 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@17
main::@17: scope:[main]  from main::@16
  idx#60 = phi( main::@16/idx#40 )
  idx#18 = idx#60
  main::$34 = typeid  $c+$c
  assertType::t1#17 = main::$34
  assertType::t2#17 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@18
main::@18: scope:[main]  from main::@17
  idx#61 = phi( main::@17/idx#40 )
  idx#19 = idx#61
  main::$36 = typeid  $c+$82
  assertType::t1#18 = main::$36
  assertType::t2#18 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@19
main::@19: scope:[main]  from main::@18
  idx#62 = phi( main::@18/idx#40 )
  idx#20 = idx#62
  main::$38 = typeid  $c+$101d0
  assertType::t1#19 = main::$38
  assertType::t2#19 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@20
main::@20: scope:[main]  from main::@19
  idx#63 = phi( main::@19/idx#40 )
  idx#21 = idx#63
  main::$40 = typeid  $c+$b2d05e00
  assertType::t1#20 = main::$40
  assertType::t2#20 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@21
main::@21: scope:[main]  from main::@20
  idx#64 = phi( main::@20/idx#40 )
  idx#22 = idx#64
  idx#23 = $50
  main::$42 = typeid  $c+-$c
  assertType::t1#21 = main::$42
  assertType::t2#21 = TYPEID_CHAR
  call assertType
  to:main::@22
main::@22: scope:[main]  from main::@21
  idx#65 = phi( main::@21/idx#40 )
  idx#24 = idx#65
  main::$44 = typeid  $c+-$78
  assertType::t1#22 = main::$44
  assertType::t2#22 = TYPEID_CHAR
  call assertType
  to:main::@23
main::@23: scope:[main]  from main::@22
  idx#66 = phi( main::@22/idx#40 )
  idx#25 = idx#66
  main::$46 = typeid  $c+-$fa
  assertType::t1#23 = main::$46
  assertType::t2#23 = TYPEID_CHAR
  call assertType
  to:main::@24
main::@24: scope:[main]  from main::@23
  idx#67 = phi( main::@23/idx#40 )
  idx#26 = idx#67
  main::$48 = typeid  $c+-$104
  assertType::t1#24 = main::$48
  assertType::t2#24 = TYPEID_UNSIGNED_INT
  call assertType
  to:main::@25
main::@25: scope:[main]  from main::@24
  idx#68 = phi( main::@24/idx#40 )
  idx#27 = idx#68
  main::$50 = typeid  $c+-$fde8
  assertType::t1#25 = main::$50
  assertType::t2#25 = TYPEID_UNSIGNED_INT
  call assertType
  to:main::@26
main::@26: scope:[main]  from main::@25
  idx#69 = phi( main::@25/idx#40 )
  idx#28 = idx#69
  main::$52 = typeid  $c+-$101d0
  assertType::t1#26 = main::$52
  assertType::t2#26 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@27
main::@27: scope:[main]  from main::@26
  idx#70 = phi( main::@26/idx#40 )
  idx#29 = idx#70
  main::$54 = typeid  $c+-$c
  assertType::t1#27 = main::$54
  assertType::t2#27 = TYPEID_UNSIGNED_INT
  call assertType
  to:main::@28
main::@28: scope:[main]  from main::@27
  idx#71 = phi( main::@27/idx#40 )
  idx#30 = idx#71
  main::$56 = typeid  $c+-$82
  assertType::t1#28 = main::$56
  assertType::t2#28 = TYPEID_UNSIGNED_INT
  call assertType
  to:main::@29
main::@29: scope:[main]  from main::@28
  idx#72 = phi( main::@28/idx#40 )
  idx#31 = idx#72
  main::$58 = typeid  $c+-$fde8
  assertType::t1#29 = main::$58
  assertType::t2#29 = TYPEID_UNSIGNED_INT
  call assertType
  to:main::@30
main::@30: scope:[main]  from main::@29
  idx#73 = phi( main::@29/idx#40 )
  idx#32 = idx#73
  main::$60 = typeid  $c+-$101d0
  assertType::t1#30 = main::$60
  assertType::t2#30 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@31
main::@31: scope:[main]  from main::@30
  idx#74 = phi( main::@30/idx#40 )
  idx#33 = idx#74
  main::$62 = typeid  $c+-$c
  assertType::t1#31 = main::$62
  assertType::t2#31 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@32
main::@32: scope:[main]  from main::@31
  idx#75 = phi( main::@31/idx#40 )
  idx#34 = idx#75
  main::$64 = typeid  $c+-$82
  assertType::t1#32 = main::$64
  assertType::t2#32 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@33
main::@33: scope:[main]  from main::@32
  idx#76 = phi( main::@32/idx#40 )
  idx#35 = idx#76
  main::$66 = typeid  $c+-$101d0
  assertType::t1#33 = main::$66
  assertType::t2#33 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@34
main::@34: scope:[main]  from main::@33
  idx#77 = phi( main::@33/idx#40 )
  idx#36 = idx#77
  main::$68 = typeid  $c+-$7d2b7500
  assertType::t1#34 = main::$68
  assertType::t2#34 = TYPEID_UNSIGNED_LONG
  call assertType
  to:main::@35
main::@35: scope:[main]  from main::@34
  idx#78 = phi( main::@34/idx#40 )
  idx#37 = idx#78
  to:main::@return
main::@return: scope:[main]  from main::@35
  idx#79 = phi( main::@35/idx#37 )
  idx#38 = idx#79
  return 
  to:@return

void assertType(char t1 , char t2)
assertType: scope:[assertType]  from main main::@1 main::@10 main::@11 main::@12 main::@13 main::@14 main::@15 main::@16 main::@17 main::@18 main::@19 main::@2 main::@20 main::@21 main::@22 main::@23 main::@24 main::@25 main::@26 main::@27 main::@28 main::@29 main::@3 main::@30 main::@31 main::@32 main::@33 main::@34 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  idx#86 = phi( main/idx#0, main::@1/idx#1, main::@10/idx#11, main::@11/idx#12, main::@12/idx#13, main::@13/idx#14, main::@14/idx#15, main::@15/idx#16, main::@16/idx#17, main::@17/idx#18, main::@18/idx#19, main::@19/idx#20, main::@2/idx#2, main::@20/idx#21, main::@21/idx#23, main::@22/idx#24, main::@23/idx#25, main::@24/idx#26, main::@25/idx#27, main::@26/idx#28, main::@27/idx#29, main::@28/idx#30, main::@29/idx#31, main::@3/idx#3, main::@30/idx#32, main::@31/idx#33, main::@32/idx#34, main::@33/idx#35, main::@34/idx#36, main::@4/idx#4, main::@5/idx#5, main::@6/idx#6, main::@7/idx#7, main::@8/idx#8, main::@9/idx#10 )
  assertType::t2#35 = phi( main/assertType::t2#0, main::@1/assertType::t2#1, main::@10/assertType::t2#10, main::@11/assertType::t2#11, main::@12/assertType::t2#12, main::@13/assertType::t2#13, main::@14/assertType::t2#14, main::@15/assertType::t2#15, main::@16/assertType::t2#16, main::@17/assertType::t2#17, main::@18/assertType::t2#18, main::@19/assertType::t2#19, main::@2/assertType::t2#2, main::@20/assertType::t2#20, main::@21/assertType::t2#21, main::@22/assertType::t2#22, main::@23/assertType::t2#23, main::@24/assertType::t2#24, main::@25/assertType::t2#25, main::@26/assertType::t2#26, main::@27/assertType::t2#27, main::@28/assertType::t2#28, main::@29/assertType::t2#29, main::@3/assertType::t2#3, main::@30/assertType::t2#30, main::@31/assertType::t2#31, main::@32/assertType::t2#32, main::@33/assertType::t2#33, main::@34/assertType::t2#34, main::@4/assertType::t2#4, main::@5/assertType::t2#5, main::@6/assertType::t2#6, main::@7/assertType::t2#7, main::@8/assertType::t2#8, main::@9/assertType::t2#9 )
  assertType::t1#35 = phi( main/assertType::t1#0, main::@1/assertType::t1#1, main::@10/assertType::t1#10, main::@11/assertType::t1#11, main::@12/assertType::t1#12, main::@13/assertType::t1#13, main::@14/assertType::t1#14, main::@15/assertType::t1#15, main::@16/assertType::t1#16, main::@17/assertType::t1#17, main::@18/assertType::t1#18, main::@19/assertType::t1#19, main::@2/assertType::t1#2, main::@20/assertType::t1#20, main::@21/assertType::t1#21, main::@22/assertType::t1#22, main::@23/assertType::t1#23, main::@24/assertType::t1#24, main::@25/assertType::t1#25, main::@26/assertType::t1#26, main::@27/assertType::t1#27, main::@28/assertType::t1#28, main::@29/assertType::t1#29, main::@3/assertType::t1#3, main::@30/assertType::t1#30, main::@31/assertType::t1#31, main::@32/assertType::t1#32, main::@33/assertType::t1#33, main::@34/assertType::t1#34, main::@4/assertType::t1#4, main::@5/assertType::t1#5, main::@6/assertType::t1#6, main::@7/assertType::t1#7, main::@8/assertType::t1#8, main::@9/assertType::t1#9 )
  assertType::$0 = assertType::t1#35 == assertType::t2#35
  if(assertType::$0) goto assertType::@1
  to:assertType::@3
assertType::@1: scope:[assertType]  from assertType
  assertType::t1#37 = phi( assertType/assertType::t1#35 )
  idx#80 = phi( assertType/idx#86 )
  COLS[idx#80] = GREEN
  to:assertType::@2
assertType::@3: scope:[assertType]  from assertType
  assertType::t1#38 = phi( assertType/assertType::t1#35 )
  idx#81 = phi( assertType/idx#86 )
  COLS[idx#81] = RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  idx#82 = phi( assertType::@1/idx#80, assertType::@3/idx#81 )
  assertType::t1#36 = phi( assertType::@1/assertType::t1#37, assertType::@3/assertType::t1#38 )
  SCREEN[idx#82] = assertType::t1#36
  idx#39 = ++ idx#82
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  idx#83 = phi( assertType::@2/idx#39 )
  idx#40 = idx#83
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  idx#41 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  idx#87 = phi( __start::__init1/idx#41 )
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  idx#84 = phi( __start::@1/idx#38 )
  idx#42 = idx#84
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  idx#85 = phi( __start::@2/idx#42 )
  idx#43 = idx#85
  return 
  to:@return

SYMBOL TABLE SSA
__constant char * const COLS = (char *)$d800
__constant const char GREEN = 5
__constant const char RED = 2
__constant char * const SCREEN = (char *)$400
__constant char TYPEID_CHAR = 1
__constant char TYPEID_INT = 4
__constant char TYPEID_LONG = 6
__constant char TYPEID_SIGNED_CHAR = 2
__constant char TYPEID_UNSIGNED_INT = 3
__constant char TYPEID_UNSIGNED_LONG = 5
void __start()
void assertType(char t1 , char t2)
bool assertType::$0
char assertType::t1
char assertType::t1#0
char assertType::t1#1
char assertType::t1#10
char assertType::t1#11
char assertType::t1#12
char assertType::t1#13
char assertType::t1#14
char assertType::t1#15
char assertType::t1#16
char assertType::t1#17
char assertType::t1#18
char assertType::t1#19
char assertType::t1#2
char assertType::t1#20
char assertType::t1#21
char assertType::t1#22
char assertType::t1#23
char assertType::t1#24
char assertType::t1#25
char assertType::t1#26
char assertType::t1#27
char assertType::t1#28
char assertType::t1#29
char assertType::t1#3
char assertType::t1#30
char assertType::t1#31
char assertType::t1#32
char assertType::t1#33
char assertType::t1#34
char assertType::t1#35
char assertType::t1#36
char assertType::t1#37
char assertType::t1#38
char assertType::t1#4
char assertType::t1#5
char assertType::t1#6
char assertType::t1#7
char assertType::t1#8
char assertType::t1#9
char assertType::t2
char assertType::t2#0
char assertType::t2#1
char assertType::t2#10
char assertType::t2#11
char assertType::t2#12
char assertType::t2#13
char assertType::t2#14
char assertType::t2#15
char assertType::t2#16
char assertType::t2#17
char assertType::t2#18
char assertType::t2#19
char assertType::t2#2
char assertType::t2#20
char assertType::t2#21
char assertType::t2#22
char assertType::t2#23
char assertType::t2#24
char assertType::t2#25
char assertType::t2#26
char assertType::t2#27
char assertType::t2#28
char assertType::t2#29
char assertType::t2#3
char assertType::t2#30
char assertType::t2#31
char assertType::t2#32
char assertType::t2#33
char assertType::t2#34
char assertType::t2#35
char assertType::t2#4
char assertType::t2#5
char assertType::t2#6
char assertType::t2#7
char assertType::t2#8
char assertType::t2#9
char idx
char idx#0
char idx#1
char idx#10
char idx#11
char idx#12
char idx#13
char idx#14
char idx#15
char idx#16
char idx#17
char idx#18
char idx#19
char idx#2
char idx#20
char idx#21
char idx#22
char idx#23
char idx#24
char idx#25
char idx#26
char idx#27
char idx#28
char idx#29
char idx#3
char idx#30
char idx#31
char idx#32
char idx#33
char idx#34
char idx#35
char idx#36
char idx#37
char idx#38
char idx#39
char idx#4
char idx#40
char idx#41
char idx#42
char idx#43
char idx#44
char idx#45
char idx#46
char idx#47
char idx#48
char idx#49
char idx#5
char idx#50
char idx#51
char idx#52
char idx#53
char idx#54
char idx#55
char idx#56
char idx#57
char idx#58
char idx#59
char idx#6
char idx#60
char idx#61
char idx#62
char idx#63
char idx#64
char idx#65
char idx#66
char idx#67
char idx#68
char idx#69
char idx#7
char idx#70
char idx#71
char idx#72
char idx#73
char idx#74
char idx#75
char idx#76
char idx#77
char idx#78
char idx#79
char idx#8
char idx#80
char idx#81
char idx#82
char idx#83
char idx#84
char idx#85
char idx#86
char idx#87
char idx#9
void main()
char main::$0
char main::$10
char main::$12
char main::$14
char main::$16
char main::$18
char main::$2
char main::$20
char main::$22
char main::$24
char main::$26
char main::$28
char main::$30
char main::$32
char main::$34
char main::$36
char main::$38
char main::$4
char main::$40
char main::$42
char main::$44
char main::$46
char main::$48
char main::$50
char main::$52
char main::$54
char main::$56
char main::$58
char main::$6
char main::$60
char main::$62
char main::$64
char main::$66
char main::$68
char main::$8

Adding number conversion cast (snumber) $c in main::$0 = typeid  $c+$c
Adding number conversion cast (snumber) $82 in main::$2 = typeid  $c+$82
Adding number conversion cast (snumber) $80e8 in main::$4 = typeid  $c+$80e8
Adding number conversion cast (snumber) $c in main::$6 = typeid  $c+$c
Adding number conversion cast (snumber) $82 in main::$8 = typeid  $c+$82
Adding number conversion cast (snumber) $186a0 in main::$10 = typeid  $c+$186a0
Adding number conversion cast (snumber) $c in main::$12 = typeid  $c+$c
Adding number conversion cast (snumber) $82 in main::$14 = typeid  $c+$82
Adding number conversion cast (snumber) $186a0 in main::$16 = typeid  $c+$186a0
Adding number conversion cast (unumber) $c in main::$18 = typeid  $c+$c
Adding number conversion cast (unumber) $fa in main::$20 = typeid  $c+$fa
Adding number conversion cast (unumber) $12c in main::$22 = typeid  $c+$12c
Adding number conversion cast (unumber) $fffe in main::$24 = typeid  $c+$fffe
Adding number conversion cast (unumber) $101d0 in main::$26 = typeid  $c+$101d0
Adding number conversion cast (unumber) $c in main::$28 = typeid  $c+$c
Adding number conversion cast (unumber) $82 in main::$30 = typeid  $c+$82
Adding number conversion cast (unumber) $101d0 in main::$32 = typeid  $c+$101d0
Adding number conversion cast (unumber) $c in main::$34 = typeid  $c+$c
Adding number conversion cast (unumber) $82 in main::$36 = typeid  $c+$82
Adding number conversion cast (unumber) $101d0 in main::$38 = typeid  $c+$101d0
Adding number conversion cast (unumber) $b2d05e00 in main::$40 = typeid  $c+$b2d05e00
Adding number conversion cast (unumber) -$c in main::$42 = typeid  $c+-$c
Adding number conversion cast (unumber) -$78 in main::$44 = typeid  $c+-$78
Adding number conversion cast (unumber) -$fa in main::$46 = typeid  $c+-$fa
Adding number conversion cast (unumber) -$104 in main::$48 = typeid  $c+-$104
Adding number conversion cast (unumber) -$fde8 in main::$50 = typeid  $c+-$fde8
Adding number conversion cast (unumber) -$101d0 in main::$52 = typeid  $c+-$101d0
Adding number conversion cast (unumber) -$c in main::$54 = typeid  $c+-$c
Adding number conversion cast (unumber) -$82 in main::$56 = typeid  $c+-$82
Adding number conversion cast (unumber) -$fde8 in main::$58 = typeid  $c+-$fde8
Adding number conversion cast (unumber) -$101d0 in main::$60 = typeid  $c+-$101d0
Adding number conversion cast (unumber) -$c in main::$62 = typeid  $c+-$c
Adding number conversion cast (unumber) -$82 in main::$64 = typeid  $c+-$82
Adding number conversion cast (unumber) -$101d0 in main::$66 = typeid  $c+-$101d0
Adding number conversion cast (snumber) -$7d2b7500 in main::$68 = typeid  $c+-$7d2b7500
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $80e8
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $186a0
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $186a0
Simplifying constant integer cast $c
Simplifying constant integer cast $fa
Simplifying constant integer cast $12c
Simplifying constant integer cast $fffe
Simplifying constant integer cast $101d0
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $101d0
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $101d0
Simplifying constant integer cast $b2d05e00
Simplifying constant integer cast -$c
Simplifying constant integer cast -$78
Simplifying constant integer cast -$fa
Simplifying constant integer cast -$104
Simplifying constant integer cast -$fde8
Simplifying constant integer cast -$101d0
Simplifying constant integer cast -$c
Simplifying constant integer cast -$82
Simplifying constant integer cast -$fde8
Simplifying constant integer cast -$101d0
Simplifying constant integer cast -$c
Simplifying constant integer cast -$82
Simplifying constant integer cast -$101d0
Simplifying constant integer cast -$7d2b7500
Successful SSA optimization PassNCastSimplification
Finalized signed number type (signed char) $c
Finalized signed number type (int) $82
Finalized signed number type (long) $80e8
Finalized signed number type (signed char) $c
Finalized signed number type (int) $82
Finalized signed number type (long) $186a0
Finalized signed number type (signed char) $c
Finalized signed number type (int) $82
Finalized signed number type (long) $186a0
Finalized unsigned number type (char) $c
Finalized unsigned number type (char) $fa
Finalized unsigned number type (unsigned int) $12c
Finalized unsigned number type (unsigned int) $fffe
Finalized unsigned number type (unsigned long) $101d0
Finalized unsigned number type (char) $c
Finalized unsigned number type (char) $82
Finalized unsigned number type (unsigned long) $101d0
Finalized unsigned number type (char) $c
Finalized unsigned number type (char) $82
Finalized unsigned number type (unsigned long) $101d0
Finalized unsigned number type (unsigned long) $b2d05e00
Finalized unsigned number type (char) -$c
Finalized unsigned number type (char) -$78
Finalized unsigned number type (char) -$fa
Finalized unsigned number type (unsigned int) -$104
Finalized unsigned number type (unsigned int) -$fde8
Finalized unsigned number type (unsigned long) -$101d0
Finalized unsigned number type (char) -$c
Finalized unsigned number type (char) -$82
Finalized unsigned number type (unsigned int) -$fde8
Finalized unsigned number type (unsigned long) -$101d0
Finalized unsigned number type (char) -$c
Finalized unsigned number type (char) -$82
Finalized unsigned number type (unsigned long) -$101d0
Finalized signed number type (long) -$7d2b7500
Successful SSA optimization PassNFinalizeNumberTypeConversions
Resolving typeid() main::$0 = typeid  $c+$c
Resolving typeid() main::$2 = typeid  $c+$82
Resolving typeid() main::$4 = typeid  $c+$80e8
Resolving typeid() main::$6 = typeid  $c+$c
Resolving typeid() main::$8 = typeid  $c+$82
Resolving typeid() main::$10 = typeid  $c+$186a0
Resolving typeid() main::$12 = typeid  $c+$c
Resolving typeid() main::$14 = typeid  $c+$82
Resolving typeid() main::$16 = typeid  $c+$186a0
Resolving typeid() main::$18 = typeid  $c+$c
Resolving typeid() main::$20 = typeid  $c+$fa
Resolving typeid() main::$22 = typeid  $c+$12c
Resolving typeid() main::$24 = typeid  $c+$fffe
Resolving typeid() main::$26 = typeid  $c+$101d0
Resolving typeid() main::$28 = typeid  $c+$c
Resolving typeid() main::$30 = typeid  $c+$82
Resolving typeid() main::$32 = typeid  $c+$101d0
Resolving typeid() main::$34 = typeid  $c+$c
Resolving typeid() main::$36 = typeid  $c+$82
Resolving typeid() main::$38 = typeid  $c+$101d0
Resolving typeid() main::$40 = typeid  $c+$b2d05e00
Resolving typeid() main::$42 = typeid  $c+-$c
Resolving typeid() main::$44 = typeid  $c+-$78
Resolving typeid() main::$46 = typeid  $c+-$fa
Resolving typeid() main::$48 = typeid  $c+-$104
Resolving typeid() main::$50 = typeid  $c+-$fde8
Resolving typeid() main::$52 = typeid  $c+-$101d0
Resolving typeid() main::$54 = typeid  $c+-$c
Resolving typeid() main::$56 = typeid  $c+-$82
Resolving typeid() main::$58 = typeid  $c+-$fde8
Resolving typeid() main::$60 = typeid  $c+-$101d0
Resolving typeid() main::$62 = typeid  $c+-$c
Resolving typeid() main::$64 = typeid  $c+-$82
Resolving typeid() main::$66 = typeid  $c+-$101d0
Resolving typeid() main::$68 = typeid  $c+-$7d2b7500
Successful SSA optimization PassNTypeIdSimplification
Alias assertType::t1#0 = main::$0 
Alias idx#1 = idx#44 
Alias assertType::t1#1 = main::$2 
Alias idx#2 = idx#45 
Alias assertType::t1#2 = main::$4 
Alias idx#3 = idx#46 
Alias assertType::t1#3 = main::$6 
Alias idx#4 = idx#47 
Alias assertType::t1#4 = main::$8 
Alias idx#48 = idx#5 
Alias assertType::t1#5 = main::$10 
Alias idx#49 = idx#6 
Alias assertType::t1#6 = main::$12 
Alias idx#50 = idx#7 
Alias assertType::t1#7 = main::$14 
Alias idx#51 = idx#8 
Alias assertType::t1#8 = main::$16 
Alias idx#52 = idx#9 
Alias assertType::t1#9 = main::$18 
Alias idx#11 = idx#53 
Alias assertType::t1#10 = main::$20 
Alias idx#12 = idx#54 
Alias assertType::t1#11 = main::$22 
Alias idx#13 = idx#55 
Alias assertType::t1#12 = main::$24 
Alias idx#14 = idx#56 
Alias assertType::t1#13 = main::$26 
Alias idx#15 = idx#57 
Alias assertType::t1#14 = main::$28 
Alias idx#16 = idx#58 
Alias assertType::t1#15 = main::$30 
Alias idx#17 = idx#59 
Alias assertType::t1#16 = main::$32 
Alias idx#18 = idx#60 
Alias assertType::t1#17 = main::$34 
Alias idx#19 = idx#61 
Alias assertType::t1#18 = main::$36 
Alias idx#20 = idx#62 
Alias assertType::t1#19 = main::$38 
Alias idx#21 = idx#63 
Alias assertType::t1#20 = main::$40 
Alias idx#22 = idx#64 
Alias assertType::t1#21 = main::$42 
Alias idx#24 = idx#65 
Alias assertType::t1#22 = main::$44 
Alias idx#25 = idx#66 
Alias assertType::t1#23 = main::$46 
Alias idx#26 = idx#67 
Alias assertType::t1#24 = main::$48 
Alias idx#27 = idx#68 
Alias assertType::t1#25 = main::$50 
Alias idx#28 = idx#69 
Alias assertType::t1#26 = main::$52 
Alias idx#29 = idx#70 
Alias assertType::t1#27 = main::$54 
Alias idx#30 = idx#71 
Alias assertType::t1#28 = main::$56 
Alias idx#31 = idx#72 
Alias assertType::t1#29 = main::$58 
Alias idx#32 = idx#73 
Alias assertType::t1#30 = main::$60 
Alias idx#33 = idx#74 
Alias assertType::t1#31 = main::$62 
Alias idx#34 = idx#75 
Alias assertType::t1#32 = main::$64 
Alias idx#35 = idx#76 
Alias assertType::t1#33 = main::$66 
Alias idx#36 = idx#77 
Alias assertType::t1#34 = main::$68 
Alias idx#37 = idx#78 idx#79 idx#38 
Alias idx#80 = idx#86 idx#81 
Alias assertType::t1#35 = assertType::t1#37 assertType::t1#38 
Alias idx#39 = idx#83 idx#40 
Alias idx#41 = idx#87 
Alias idx#42 = idx#84 idx#85 idx#43 
Successful SSA optimization Pass2AliasElimination
Alias assertType::t1#35 = assertType::t1#36 
Alias idx#80 = idx#82 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values idx#1 idx#39
Identical Phi Values idx#2 idx#39
Identical Phi Values idx#3 idx#39
Identical Phi Values idx#4 idx#39
Identical Phi Values idx#48 idx#39
Identical Phi Values idx#49 idx#39
Identical Phi Values idx#50 idx#39
Identical Phi Values idx#51 idx#39
Identical Phi Values idx#52 idx#39
Identical Phi Values idx#11 idx#39
Identical Phi Values idx#12 idx#39
Identical Phi Values idx#13 idx#39
Identical Phi Values idx#14 idx#39
Identical Phi Values idx#15 idx#39
Identical Phi Values idx#16 idx#39
Identical Phi Values idx#17 idx#39
Identical Phi Values idx#18 idx#39
Identical Phi Values idx#19 idx#39
Identical Phi Values idx#20 idx#39
Identical Phi Values idx#21 idx#39
Identical Phi Values idx#22 idx#39
Identical Phi Values idx#24 idx#39
Identical Phi Values idx#25 idx#39
Identical Phi Values idx#26 idx#39
Identical Phi Values idx#27 idx#39
Identical Phi Values idx#28 idx#39
Identical Phi Values idx#29 idx#39
Identical Phi Values idx#30 idx#39
Identical Phi Values idx#31 idx#39
Identical Phi Values idx#32 idx#39
Identical Phi Values idx#33 idx#39
Identical Phi Values idx#34 idx#39
Identical Phi Values idx#35 idx#39
Identical Phi Values idx#36 idx#39
Identical Phi Values idx#37 idx#39
Identical Phi Values idx#42 idx#37
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition assertType::$0 [146] if(assertType::t1#35==assertType::t2#35) goto assertType::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant idx#0 = 0
Constant assertType::t1#0 = TYPEID_SIGNED_CHAR
Constant assertType::t2#0 = TYPEID_SIGNED_CHAR
Constant assertType::t1#1 = TYPEID_INT
Constant assertType::t2#1 = TYPEID_INT
Constant assertType::t1#2 = TYPEID_LONG
Constant assertType::t2#2 = TYPEID_LONG
Constant assertType::t1#3 = TYPEID_INT
Constant assertType::t2#3 = TYPEID_INT
Constant assertType::t1#4 = TYPEID_INT
Constant assertType::t2#4 = TYPEID_INT
Constant assertType::t1#5 = TYPEID_LONG
Constant assertType::t2#5 = TYPEID_LONG
Constant assertType::t1#6 = TYPEID_LONG
Constant assertType::t2#6 = TYPEID_LONG
Constant assertType::t1#7 = TYPEID_LONG
Constant assertType::t2#7 = TYPEID_LONG
Constant assertType::t1#8 = TYPEID_LONG
Constant assertType::t2#8 = TYPEID_LONG
Constant idx#10 = $28
Constant assertType::t1#9 = TYPEID_CHAR
Constant assertType::t2#9 = TYPEID_CHAR
Constant assertType::t1#10 = TYPEID_CHAR
Constant assertType::t2#10 = TYPEID_CHAR
Constant assertType::t1#11 = TYPEID_UNSIGNED_INT
Constant assertType::t2#11 = TYPEID_UNSIGNED_INT
Constant assertType::t1#12 = TYPEID_UNSIGNED_INT
Constant assertType::t2#12 = TYPEID_UNSIGNED_INT
Constant assertType::t1#13 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#13 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#14 = TYPEID_UNSIGNED_INT
Constant assertType::t2#14 = TYPEID_UNSIGNED_INT
Constant assertType::t1#15 = TYPEID_UNSIGNED_INT
Constant assertType::t2#15 = TYPEID_UNSIGNED_INT
Constant assertType::t1#16 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#16 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#17 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#17 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#18 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#18 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#19 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#19 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#20 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#20 = TYPEID_UNSIGNED_LONG
Constant idx#23 = $50
Constant assertType::t1#21 = TYPEID_CHAR
Constant assertType::t2#21 = TYPEID_CHAR
Constant assertType::t1#22 = TYPEID_CHAR
Constant assertType::t2#22 = TYPEID_CHAR
Constant assertType::t1#23 = TYPEID_CHAR
Constant assertType::t2#23 = TYPEID_CHAR
Constant assertType::t1#24 = TYPEID_UNSIGNED_INT
Constant assertType::t2#24 = TYPEID_UNSIGNED_INT
Constant assertType::t1#25 = TYPEID_UNSIGNED_INT
Constant assertType::t2#25 = TYPEID_UNSIGNED_INT
Constant assertType::t1#26 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#26 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#27 = TYPEID_UNSIGNED_INT
Constant assertType::t2#27 = TYPEID_UNSIGNED_INT
Constant assertType::t1#28 = TYPEID_UNSIGNED_INT
Constant assertType::t2#28 = TYPEID_UNSIGNED_INT
Constant assertType::t1#29 = TYPEID_UNSIGNED_INT
Constant assertType::t2#29 = TYPEID_UNSIGNED_INT
Constant assertType::t1#30 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#30 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#31 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#31 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#32 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#32 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#33 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#33 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#34 = TYPEID_LONG
Constant assertType::t2#34 = TYPEID_UNSIGNED_LONG
Constant idx#41 = 0
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant idx#41
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings assertType::t1#0
Inlining constant with var siblings assertType::t2#0
Inlining constant with var siblings assertType::t1#1
Inlining constant with var siblings assertType::t2#1
Inlining constant with var siblings assertType::t1#2
Inlining constant with var siblings assertType::t2#2
Inlining constant with var siblings assertType::t1#3
Inlining constant with var siblings assertType::t2#3
Inlining constant with var siblings assertType::t1#4
Inlining constant with var siblings assertType::t2#4
Inlining constant with var siblings assertType::t1#5
Inlining constant with var siblings assertType::t2#5
Inlining constant with var siblings assertType::t1#6
Inlining constant with var siblings assertType::t2#6
Inlining constant with var siblings assertType::t1#7
Inlining constant with var siblings assertType::t2#7
Inlining constant with var siblings assertType::t1#8
Inlining constant with var siblings assertType::t2#8
Inlining constant with var siblings assertType::t1#9
Inlining constant with var siblings assertType::t2#9
Inlining constant with var siblings assertType::t1#10
Inlining constant with var siblings assertType::t2#10
Inlining constant with var siblings assertType::t1#11
Inlining constant with var siblings assertType::t2#11
Inlining constant with var siblings assertType::t1#12
Inlining constant with var siblings assertType::t2#12
Inlining constant with var siblings assertType::t1#13
Inlining constant with var siblings assertType::t2#13
Inlining constant with var siblings assertType::t1#14
Inlining constant with var siblings assertType::t2#14
Inlining constant with var siblings assertType::t1#15
Inlining constant with var siblings assertType::t2#15
Inlining constant with var siblings assertType::t1#16
Inlining constant with var siblings assertType::t2#16
Inlining constant with var siblings assertType::t1#17
Inlining constant with var siblings assertType::t2#17
Inlining constant with var siblings assertType::t1#18
Inlining constant with var siblings assertType::t2#18
Inlining constant with var siblings assertType::t1#19
Inlining constant with var siblings assertType::t2#19
Inlining constant with var siblings assertType::t1#20
Inlining constant with var siblings assertType::t2#20
Inlining constant with var siblings assertType::t1#21
Inlining constant with var siblings assertType::t2#21
Inlining constant with var siblings assertType::t1#22
Inlining constant with var siblings assertType::t2#22
Inlining constant with var siblings assertType::t1#23
Inlining constant with var siblings assertType::t2#23
Inlining constant with var siblings assertType::t1#24
Inlining constant with var siblings assertType::t2#24
Inlining constant with var siblings assertType::t1#25
Inlining constant with var siblings assertType::t2#25
Inlining constant with var siblings assertType::t1#26
Inlining constant with var siblings assertType::t2#26
Inlining constant with var siblings assertType::t1#27
Inlining constant with var siblings assertType::t2#27
Inlining constant with var siblings assertType::t1#28
Inlining constant with var siblings assertType::t2#28
Inlining constant with var siblings assertType::t1#29
Inlining constant with var siblings assertType::t2#29
Inlining constant with var siblings assertType::t1#30
Inlining constant with var siblings assertType::t2#30
Inlining constant with var siblings assertType::t1#31
Inlining constant with var siblings assertType::t2#31
Inlining constant with var siblings assertType::t1#32
Inlining constant with var siblings assertType::t2#32
Inlining constant with var siblings assertType::t1#33
Inlining constant with var siblings assertType::t2#33
Inlining constant with var siblings assertType::t1#34
Inlining constant with var siblings assertType::t2#34
Inlining constant with var siblings idx#0
Inlining constant with var siblings idx#10
Inlining constant with var siblings idx#23
Constant inlined assertType::t2#5 = TYPEID_LONG
Constant inlined assertType::t2#6 = TYPEID_LONG
Constant inlined assertType::t2#7 = TYPEID_LONG
Constant inlined assertType::t2#8 = TYPEID_LONG
Constant inlined assertType::t2#9 = TYPEID_CHAR
Constant inlined assertType::t2#31 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t2#30 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#21 = TYPEID_CHAR
Constant inlined assertType::t2#33 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#20 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t2#32 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#23 = TYPEID_CHAR
Constant inlined assertType::t1#22 = TYPEID_CHAR
Constant inlined assertType::t2#34 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#25 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#24 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#27 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#0 = TYPEID_SIGNED_CHAR
Constant inlined assertType::t1#26 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t2#1 = TYPEID_INT
Constant inlined assertType::t1#29 = TYPEID_UNSIGNED_INT
Constant inlined idx#0 = 0
Constant inlined assertType::t2#2 = TYPEID_LONG
Constant inlined assertType::t1#28 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#3 = TYPEID_INT
Constant inlined assertType::t2#4 = TYPEID_INT
Constant inlined idx#23 = $50
Constant inlined assertType::t2#20 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#10 = TYPEID_CHAR
Constant inlined assertType::t2#22 = TYPEID_CHAR
Constant inlined assertType::t2#21 = TYPEID_CHAR
Constant inlined assertType::t1#12 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#24 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#11 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#23 = TYPEID_CHAR
Constant inlined assertType::t1#14 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#26 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#13 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t2#25 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#16 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t2#28 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#15 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#27 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#18 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#17 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t2#29 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#19 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#6 = TYPEID_LONG
Constant inlined idx#10 = $28
Constant inlined assertType::t1#7 = TYPEID_LONG
Constant inlined assertType::t1#8 = TYPEID_LONG
Constant inlined assertType::t1#9 = TYPEID_CHAR
Constant inlined assertType::t2#11 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#10 = TYPEID_CHAR
Constant inlined assertType::t2#13 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t2#12 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#15 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#14 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#0 = TYPEID_SIGNED_CHAR
Constant inlined assertType::t2#17 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#1 = TYPEID_INT
Constant inlined assertType::t2#16 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#2 = TYPEID_LONG
Constant inlined assertType::t2#19 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#3 = TYPEID_INT
Constant inlined assertType::t2#18 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#4 = TYPEID_INT
Constant inlined assertType::t1#5 = TYPEID_LONG
Constant inlined assertType::t1#30 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#32 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#31 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#34 = TYPEID_LONG
Constant inlined assertType::t1#33 = TYPEID_UNSIGNED_LONG
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 4
Finalized unsigned number type (char) 6
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 3
Finalized unsigned number type (char) 5
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@9
Adding NOP phi() at start of main::@21
Adding NOP phi() at start of main::@35
CALL GRAPH
Calls in [main] to assertType:1 assertType:3 assertType:5 assertType:7 assertType:9 assertType:11 assertType:13 assertType:15 assertType:17 assertType:19 assertType:21 assertType:23 assertType:25 assertType:27 assertType:29 assertType:31 assertType:33 assertType:35 assertType:37 assertType:39 assertType:41 assertType:43 assertType:45 assertType:47 assertType:49 assertType:51 assertType:53 assertType:55 assertType:57 assertType:59 assertType:61 assertType:63 assertType:65 assertType:67 assertType:69 

Created 3 initial phi equivalence classes
Coalesced [2] idx#88 = idx#39
Coalesced (already) [4] idx#99 = idx#39
Coalesced (already) [6] idx#109 = idx#39
Coalesced (already) [8] idx#115 = idx#39
Coalesced (already) [10] idx#116 = idx#39
Coalesced (already) [12] idx#117 = idx#39
Coalesced (already) [14] idx#118 = idx#39
Coalesced (already) [16] idx#119 = idx#39
Coalesced (already) [20] idx#89 = idx#39
Coalesced (already) [22] idx#90 = idx#39
Coalesced (already) [24] idx#91 = idx#39
Coalesced (already) [26] idx#92 = idx#39
Coalesced (already) [28] idx#93 = idx#39
Coalesced (already) [30] idx#94 = idx#39
Coalesced (already) [32] idx#95 = idx#39
Coalesced (already) [34] idx#96 = idx#39
Coalesced (already) [36] idx#97 = idx#39
Coalesced (already) [38] idx#98 = idx#39
Coalesced (already) [40] idx#100 = idx#39
Coalesced (already) [44] idx#101 = idx#39
Coalesced (already) [46] idx#102 = idx#39
Coalesced (already) [48] idx#103 = idx#39
Coalesced (already) [50] idx#104 = idx#39
Coalesced (already) [52] idx#105 = idx#39
Coalesced (already) [54] idx#106 = idx#39
Coalesced (already) [56] idx#107 = idx#39
Coalesced (already) [58] idx#108 = idx#39
Coalesced (already) [60] idx#110 = idx#39
Coalesced (already) [62] idx#111 = idx#39
Coalesced (already) [64] idx#112 = idx#39
Coalesced (already) [66] idx#113 = idx#39
Coalesced (already) [68] idx#114 = idx#39
Coalesced down to 3 phi equivalence classes
Culled Empty Block label main::@35
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@9
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@12
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@16
Adding NOP phi() at start of main::@17
Adding NOP phi() at start of main::@18
Adding NOP phi() at start of main::@19
Adding NOP phi() at start of main::@20
Adding NOP phi() at start of main::@21
Adding NOP phi() at start of main::@22
Adding NOP phi() at start of main::@23
Adding NOP phi() at start of main::@24
Adding NOP phi() at start of main::@25
Adding NOP phi() at start of main::@26
Adding NOP phi() at start of main::@27
Adding NOP phi() at start of main::@28
Adding NOP phi() at start of main::@29
Adding NOP phi() at start of main::@30
Adding NOP phi() at start of main::@31
Adding NOP phi() at start of main::@32
Adding NOP phi() at start of main::@33
Adding NOP phi() at start of main::@34

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call assertType
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call assertType
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] phi()
  [5] call assertType
  to:main::@3
main::@3: scope:[main]  from main::@2
  [6] phi()
  [7] call assertType
  to:main::@4
main::@4: scope:[main]  from main::@3
  [8] phi()
  [9] call assertType
  to:main::@5
main::@5: scope:[main]  from main::@4
  [10] phi()
  [11] call assertType
  to:main::@6
main::@6: scope:[main]  from main::@5
  [12] phi()
  [13] call assertType
  to:main::@7
main::@7: scope:[main]  from main::@6
  [14] phi()
  [15] call assertType
  to:main::@8
main::@8: scope:[main]  from main::@7
  [16] phi()
  [17] call assertType
  to:main::@9
main::@9: scope:[main]  from main::@8
  [18] phi()
  [19] call assertType
  to:main::@10
main::@10: scope:[main]  from main::@9
  [20] phi()
  [21] call assertType
  to:main::@11
main::@11: scope:[main]  from main::@10
  [22] phi()
  [23] call assertType
  to:main::@12
main::@12: scope:[main]  from main::@11
  [24] phi()
  [25] call assertType
  to:main::@13
main::@13: scope:[main]  from main::@12
  [26] phi()
  [27] call assertType
  to:main::@14
main::@14: scope:[main]  from main::@13
  [28] phi()
  [29] call assertType
  to:main::@15
main::@15: scope:[main]  from main::@14
  [30] phi()
  [31] call assertType
  to:main::@16
main::@16: scope:[main]  from main::@15
  [32] phi()
  [33] call assertType
  to:main::@17
main::@17: scope:[main]  from main::@16
  [34] phi()
  [35] call assertType
  to:main::@18
main::@18: scope:[main]  from main::@17
  [36] phi()
  [37] call assertType
  to:main::@19
main::@19: scope:[main]  from main::@18
  [38] phi()
  [39] call assertType
  to:main::@20
main::@20: scope:[main]  from main::@19
  [40] phi()
  [41] call assertType
  to:main::@21
main::@21: scope:[main]  from main::@20
  [42] phi()
  [43] call assertType
  to:main::@22
main::@22: scope:[main]  from main::@21
  [44] phi()
  [45] call assertType
  to:main::@23
main::@23: scope:[main]  from main::@22
  [46] phi()
  [47] call assertType
  to:main::@24
main::@24: scope:[main]  from main::@23
  [48] phi()
  [49] call assertType
  to:main::@25
main::@25: scope:[main]  from main::@24
  [50] phi()
  [51] call assertType
  to:main::@26
main::@26: scope:[main]  from main::@25
  [52] phi()
  [53] call assertType
  to:main::@27
main::@27: scope:[main]  from main::@26
  [54] phi()
  [55] call assertType
  to:main::@28
main::@28: scope:[main]  from main::@27
  [56] phi()
  [57] call assertType
  to:main::@29
main::@29: scope:[main]  from main::@28
  [58] phi()
  [59] call assertType
  to:main::@30
main::@30: scope:[main]  from main::@29
  [60] phi()
  [61] call assertType
  to:main::@31
main::@31: scope:[main]  from main::@30
  [62] phi()
  [63] call assertType
  to:main::@32
main::@32: scope:[main]  from main::@31
  [64] phi()
  [65] call assertType
  to:main::@33
main::@33: scope:[main]  from main::@32
  [66] phi()
  [67] call assertType
  to:main::@34
main::@34: scope:[main]  from main::@33
  [68] phi()
  [69] call assertType
  to:main::@return
main::@return: scope:[main]  from main::@34
  [70] return 
  to:@return

void assertType(char t1 , char t2)
assertType: scope:[assertType]  from main main::@1 main::@10 main::@11 main::@12 main::@13 main::@14 main::@15 main::@16 main::@17 main::@18 main::@19 main::@2 main::@20 main::@21 main::@22 main::@23 main::@24 main::@25 main::@26 main::@27 main::@28 main::@29 main::@3 main::@30 main::@31 main::@32 main::@33 main::@34 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  [71] idx#80 = phi( main/0, main::@1/idx#39, main::@10/idx#39, main::@11/idx#39, main::@12/idx#39, main::@13/idx#39, main::@14/idx#39, main::@15/idx#39, main::@16/idx#39, main::@17/idx#39, main::@18/idx#39, main::@19/idx#39, main::@2/idx#39, main::@20/idx#39, main::@21/$50, main::@22/idx#39, main::@23/idx#39, main::@24/idx#39, main::@25/idx#39, main::@26/idx#39, main::@27/idx#39, main::@28/idx#39, main::@29/idx#39, main::@3/idx#39, main::@30/idx#39, main::@31/idx#39, main::@32/idx#39, main::@33/idx#39, main::@34/idx#39, main::@4/idx#39, main::@5/idx#39, main::@6/idx#39, main::@7/idx#39, main::@8/idx#39, main::@9/$28 )
  [71] assertType::t2#35 = phi( main/TYPEID_SIGNED_CHAR, main::@1/TYPEID_INT, main::@10/TYPEID_CHAR, main::@11/TYPEID_UNSIGNED_INT, main::@12/TYPEID_UNSIGNED_INT, main::@13/TYPEID_UNSIGNED_LONG, main::@14/TYPEID_UNSIGNED_INT, main::@15/TYPEID_UNSIGNED_INT, main::@16/TYPEID_UNSIGNED_LONG, main::@17/TYPEID_UNSIGNED_LONG, main::@18/TYPEID_UNSIGNED_LONG, main::@19/TYPEID_UNSIGNED_LONG, main::@2/TYPEID_LONG, main::@20/TYPEID_UNSIGNED_LONG, main::@21/TYPEID_CHAR, main::@22/TYPEID_CHAR, main::@23/TYPEID_CHAR, main::@24/TYPEID_UNSIGNED_INT, main::@25/TYPEID_UNSIGNED_INT, main::@26/TYPEID_UNSIGNED_LONG, main::@27/TYPEID_UNSIGNED_INT, main::@28/TYPEID_UNSIGNED_INT, main::@29/TYPEID_UNSIGNED_INT, main::@3/TYPEID_INT, main::@30/TYPEID_UNSIGNED_LONG, main::@31/TYPEID_UNSIGNED_LONG, main::@32/TYPEID_UNSIGNED_LONG, main::@33/TYPEID_UNSIGNED_LONG, main::@34/TYPEID_UNSIGNED_LONG, main::@4/TYPEID_INT, main::@5/TYPEID_LONG, main::@6/TYPEID_LONG, main::@7/TYPEID_LONG, main::@8/TYPEID_LONG, main::@9/TYPEID_CHAR )
  [71] assertType::t1#35 = phi( main/TYPEID_SIGNED_CHAR, main::@1/TYPEID_INT, main::@10/TYPEID_CHAR, main::@11/TYPEID_UNSIGNED_INT, main::@12/TYPEID_UNSIGNED_INT, main::@13/TYPEID_UNSIGNED_LONG, main::@14/TYPEID_UNSIGNED_INT, main::@15/TYPEID_UNSIGNED_INT, main::@16/TYPEID_UNSIGNED_LONG, main::@17/TYPEID_UNSIGNED_LONG, main::@18/TYPEID_UNSIGNED_LONG, main::@19/TYPEID_UNSIGNED_LONG, main::@2/TYPEID_LONG, main::@20/TYPEID_UNSIGNED_LONG, main::@21/TYPEID_CHAR, main::@22/TYPEID_CHAR, main::@23/TYPEID_CHAR, main::@24/TYPEID_UNSIGNED_INT, main::@25/TYPEID_UNSIGNED_INT, main::@26/TYPEID_UNSIGNED_LONG, main::@27/TYPEID_UNSIGNED_INT, main::@28/TYPEID_UNSIGNED_INT, main::@29/TYPEID_UNSIGNED_INT, main::@3/TYPEID_INT, main::@30/TYPEID_UNSIGNED_LONG, main::@31/TYPEID_UNSIGNED_LONG, main::@32/TYPEID_UNSIGNED_LONG, main::@33/TYPEID_UNSIGNED_LONG, main::@34/TYPEID_LONG, main::@4/TYPEID_INT, main::@5/TYPEID_LONG, main::@6/TYPEID_LONG, main::@7/TYPEID_LONG, main::@8/TYPEID_LONG, main::@9/TYPEID_CHAR )
  [72] if(assertType::t1#35==assertType::t2#35) goto assertType::@1
  to:assertType::@3
assertType::@3: scope:[assertType]  from assertType
  [73] COLS[idx#80] = RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  [74] SCREEN[idx#80] = assertType::t1#35
  [75] idx#39 = ++ idx#80
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  [76] return 
  to:@return
assertType::@1: scope:[assertType]  from assertType
  [77] COLS[idx#80] = GREEN
  to:assertType::@2


VARIABLE REGISTER WEIGHTS
void assertType(char t1 , char t2)
char assertType::t1
char assertType::t1#35 // 5.5
char assertType::t2
char assertType::t2#35 // 11.0
char idx
char idx#39 // 1.1363636363636358
char idx#80 // 21.600000000000005
void main()

Initial phi equivalence classes
[ assertType::t1#35 ]
[ assertType::t2#35 ]
[ idx#80 idx#39 ]
Complete equivalence classes
[ assertType::t1#35 ]
[ assertType::t2#35 ]
[ idx#80 idx#39 ]
Allocated zp[1]:2 [ idx#80 idx#39 ]
Allocated zp[1]:3 [ assertType::t2#35 ]
Allocated zp[1]:4 [ assertType::t1#35 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [73] COLS[idx#80] = RED [ assertType::t1#35 idx#80 ] ( assertType:1 [ assertType::t1#35 idx#80 ] { }  assertType:3 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ assertType::t1#35 idx#80 ] { }  assertType:21 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ assertType::t1#35 idx#80 ] { }  assertType:45 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ assertType::t1#35 ]
Removing always clobbered register reg byte a as potential for zp[1]:2 [ idx#80 idx#39 ]
Statement [74] SCREEN[idx#80] = assertType::t1#35 [ idx#80 ] ( assertType:1 [ idx#80 ] { }  assertType:3 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ idx#80 ] { }  assertType:21 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ idx#80 ] { }  assertType:45 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Statement [77] COLS[idx#80] = GREEN [ assertType::t1#35 idx#80 ] ( assertType:1 [ assertType::t1#35 idx#80 ] { }  assertType:3 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ assertType::t1#35 idx#80 ] { }  assertType:21 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ assertType::t1#35 idx#80 ] { }  assertType:45 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Statement [73] COLS[idx#80] = RED [ assertType::t1#35 idx#80 ] ( assertType:1 [ assertType::t1#35 idx#80 ] { }  assertType:3 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ assertType::t1#35 idx#80 ] { }  assertType:21 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ assertType::t1#35 idx#80 ] { }  assertType:45 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Statement [74] SCREEN[idx#80] = assertType::t1#35 [ idx#80 ] ( assertType:1 [ idx#80 ] { }  assertType:3 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ idx#80 ] { }  assertType:21 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ idx#80 ] { }  assertType:45 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Statement [77] COLS[idx#80] = GREEN [ assertType::t1#35 idx#80 ] ( assertType:1 [ assertType::t1#35 idx#80 ] { }  assertType:3 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ assertType::t1#35 idx#80 ] { }  assertType:21 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ assertType::t1#35 idx#80 ] { }  assertType:45 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Potential registers zp[1]:4 [ assertType::t1#35 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ assertType::t2#35 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:2 [ idx#80 idx#39 ] : zp[1]:2 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 22.74: zp[1]:2 [ idx#80 idx#39 ] 
Uplift Scope [assertType] 11: zp[1]:3 [ assertType::t2#35 ] 5.5: zp[1]:4 [ assertType::t1#35 ] 
Uplift Scope [main] 

Uplifting [] best 727 combination reg byte x [ idx#80 idx#39 ] 
Uplifting [assertType] best 620 combination zp[1]:3 [ assertType::t2#35 ] reg byte y [ assertType::t1#35 ] 
Uplifting [main] best 620 combination 
Attempting to uplift remaining variables inzp[1]:3 [ assertType::t2#35 ]
Uplifting [assertType] best 620 combination zp[1]:3 [ assertType::t2#35 ] 
Allocated (was zp[1]:3) zp[1]:2 [ assertType::t2#35 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests conversion of numbers to correct int types
// See https://gitlab.com/camelot/kickc/issues/181
  // Upstart
  // Commodore 64 PRG executable file
.file [name="number-conversion.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const TYPEID_SIGNED_CHAR = 2
  .const TYPEID_INT = 4
  .const TYPEID_LONG = 6
  .const TYPEID_CHAR = 1
  .const TYPEID_UNSIGNED_INT = 3
  .const TYPEID_UNSIGNED_LONG = 5
  .const RED = 2
  .const GREEN = 5
  .label SCREEN = $400
  .label COLS = $d800
.segment Code
  // main
main: {
    // [1] call assertType
    // [71] phi from main to assertType [phi:main->assertType]
  assertType_from_main:
    // [71] phi idx#80 = 0 [phi:main->assertType#0] -- vbuxx=vbuc1 
    ldx #0
    // [71] phi assertType::t2#35 = TYPEID_SIGNED_CHAR [phi:main->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_SIGNED_CHAR [phi:main->assertType#2] -- call_phi_near 
    ldy #TYPEID_SIGNED_CHAR
    jsr assertType
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call assertType
    // [71] phi from main::@1 to assertType [phi:main::@1->assertType]
  assertType_from___b1:
    // [71] phi idx#80 = idx#39 [phi:main::@1->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_INT [phi:main::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_INT [phi:main::@1->assertType#2] -- call_phi_near 
    ldy #TYPEID_INT
    jsr assertType
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [5] call assertType
    // [71] phi from main::@2 to assertType [phi:main::@2->assertType]
  assertType_from___b2:
    // [71] phi idx#80 = idx#39 [phi:main::@2->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@2->assertType#2] -- call_phi_near 
    ldy #TYPEID_LONG
    jsr assertType
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [7] call assertType
    // [71] phi from main::@3 to assertType [phi:main::@3->assertType]
  assertType_from___b3:
    // [71] phi idx#80 = idx#39 [phi:main::@3->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_INT [phi:main::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_INT [phi:main::@3->assertType#2] -- call_phi_near 
    ldy #TYPEID_INT
    jsr assertType
    // [8] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  __b4_from___b3:
    jmp __b4
    // main::@4
  __b4:
    // [9] call assertType
    // [71] phi from main::@4 to assertType [phi:main::@4->assertType]
  assertType_from___b4:
    // [71] phi idx#80 = idx#39 [phi:main::@4->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_INT [phi:main::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_INT [phi:main::@4->assertType#2] -- call_phi_near 
    ldy #TYPEID_INT
    jsr assertType
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    jmp __b5
    // main::@5
  __b5:
    // [11] call assertType
    // [71] phi from main::@5 to assertType [phi:main::@5->assertType]
  assertType_from___b5:
    // [71] phi idx#80 = idx#39 [phi:main::@5->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@5->assertType#2] -- call_phi_near 
    ldy #TYPEID_LONG
    jsr assertType
    // [12] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    jmp __b6
    // main::@6
  __b6:
    // [13] call assertType
    // [71] phi from main::@6 to assertType [phi:main::@6->assertType]
  assertType_from___b6:
    // [71] phi idx#80 = idx#39 [phi:main::@6->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@6->assertType#2] -- call_phi_near 
    ldy #TYPEID_LONG
    jsr assertType
    // [14] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  __b7_from___b6:
    jmp __b7
    // main::@7
  __b7:
    // [15] call assertType
    // [71] phi from main::@7 to assertType [phi:main::@7->assertType]
  assertType_from___b7:
    // [71] phi idx#80 = idx#39 [phi:main::@7->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@7->assertType#2] -- call_phi_near 
    ldy #TYPEID_LONG
    jsr assertType
    // [16] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  __b8_from___b7:
    jmp __b8
    // main::@8
  __b8:
    // [17] call assertType
    // [71] phi from main::@8 to assertType [phi:main::@8->assertType]
  assertType_from___b8:
    // [71] phi idx#80 = idx#39 [phi:main::@8->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@8->assertType#2] -- call_phi_near 
    ldy #TYPEID_LONG
    jsr assertType
    // [18] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
  __b9_from___b8:
    jmp __b9
    // main::@9
  __b9:
    // [19] call assertType
    // [71] phi from main::@9 to assertType [phi:main::@9->assertType]
  assertType_from___b9:
    // [71] phi idx#80 = $28 [phi:main::@9->assertType#0] -- vbuxx=vbuc1 
    ldx #$28
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@9->assertType#2] -- call_phi_near 
    ldy #TYPEID_CHAR
    jsr assertType
    // [20] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  __b10_from___b9:
    jmp __b10
    // main::@10
  __b10:
    // [21] call assertType
    // [71] phi from main::@10 to assertType [phi:main::@10->assertType]
  assertType_from___b10:
    // [71] phi idx#80 = idx#39 [phi:main::@10->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@10->assertType#2] -- call_phi_near 
    ldy #TYPEID_CHAR
    jsr assertType
    // [22] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  __b11_from___b10:
    jmp __b11
    // main::@11
  __b11:
    // [23] call assertType
    // [71] phi from main::@11 to assertType [phi:main::@11->assertType]
  assertType_from___b11:
    // [71] phi idx#80 = idx#39 [phi:main::@11->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@11->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_INT
    jsr assertType
    // [24] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  __b12_from___b11:
    jmp __b12
    // main::@12
  __b12:
    // [25] call assertType
    // [71] phi from main::@12 to assertType [phi:main::@12->assertType]
  assertType_from___b12:
    // [71] phi idx#80 = idx#39 [phi:main::@12->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@12->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_INT
    jsr assertType
    // [26] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
  __b13_from___b12:
    jmp __b13
    // main::@13
  __b13:
    // [27] call assertType
    // [71] phi from main::@13 to assertType [phi:main::@13->assertType]
  assertType_from___b13:
    // [71] phi idx#80 = idx#39 [phi:main::@13->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@13->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [28] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
  __b14_from___b13:
    jmp __b14
    // main::@14
  __b14:
    // [29] call assertType
    // [71] phi from main::@14 to assertType [phi:main::@14->assertType]
  assertType_from___b14:
    // [71] phi idx#80 = idx#39 [phi:main::@14->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@14->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_INT
    jsr assertType
    // [30] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  __b15_from___b14:
    jmp __b15
    // main::@15
  __b15:
    // [31] call assertType
    // [71] phi from main::@15 to assertType [phi:main::@15->assertType]
  assertType_from___b15:
    // [71] phi idx#80 = idx#39 [phi:main::@15->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@15->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@15->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_INT
    jsr assertType
    // [32] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
  __b16_from___b15:
    jmp __b16
    // main::@16
  __b16:
    // [33] call assertType
    // [71] phi from main::@16 to assertType [phi:main::@16->assertType]
  assertType_from___b16:
    // [71] phi idx#80 = idx#39 [phi:main::@16->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@16->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@16->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [34] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
  __b17_from___b16:
    jmp __b17
    // main::@17
  __b17:
    // [35] call assertType
    // [71] phi from main::@17 to assertType [phi:main::@17->assertType]
  assertType_from___b17:
    // [71] phi idx#80 = idx#39 [phi:main::@17->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@17->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@17->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [36] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  __b18_from___b17:
    jmp __b18
    // main::@18
  __b18:
    // [37] call assertType
    // [71] phi from main::@18 to assertType [phi:main::@18->assertType]
  assertType_from___b18:
    // [71] phi idx#80 = idx#39 [phi:main::@18->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@18->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@18->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [38] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  __b19_from___b18:
    jmp __b19
    // main::@19
  __b19:
    // [39] call assertType
    // [71] phi from main::@19 to assertType [phi:main::@19->assertType]
  assertType_from___b19:
    // [71] phi idx#80 = idx#39 [phi:main::@19->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@19->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@19->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [40] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  __b20_from___b19:
    jmp __b20
    // main::@20
  __b20:
    // [41] call assertType
    // [71] phi from main::@20 to assertType [phi:main::@20->assertType]
  assertType_from___b20:
    // [71] phi idx#80 = idx#39 [phi:main::@20->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@20->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@20->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [42] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
  __b21_from___b20:
    jmp __b21
    // main::@21
  __b21:
    // [43] call assertType
    // [71] phi from main::@21 to assertType [phi:main::@21->assertType]
  assertType_from___b21:
    // [71] phi idx#80 = $50 [phi:main::@21->assertType#0] -- vbuxx=vbuc1 
    ldx #$50
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@21->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@21->assertType#2] -- call_phi_near 
    ldy #TYPEID_CHAR
    jsr assertType
    // [44] phi from main::@21 to main::@22 [phi:main::@21->main::@22]
  __b22_from___b21:
    jmp __b22
    // main::@22
  __b22:
    // [45] call assertType
    // [71] phi from main::@22 to assertType [phi:main::@22->assertType]
  assertType_from___b22:
    // [71] phi idx#80 = idx#39 [phi:main::@22->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@22->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@22->assertType#2] -- call_phi_near 
    ldy #TYPEID_CHAR
    jsr assertType
    // [46] phi from main::@22 to main::@23 [phi:main::@22->main::@23]
  __b23_from___b22:
    jmp __b23
    // main::@23
  __b23:
    // [47] call assertType
    // [71] phi from main::@23 to assertType [phi:main::@23->assertType]
  assertType_from___b23:
    // [71] phi idx#80 = idx#39 [phi:main::@23->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@23->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@23->assertType#2] -- call_phi_near 
    ldy #TYPEID_CHAR
    jsr assertType
    // [48] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
  __b24_from___b23:
    jmp __b24
    // main::@24
  __b24:
    // [49] call assertType
    // [71] phi from main::@24 to assertType [phi:main::@24->assertType]
  assertType_from___b24:
    // [71] phi idx#80 = idx#39 [phi:main::@24->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@24->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@24->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_INT
    jsr assertType
    // [50] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
  __b25_from___b24:
    jmp __b25
    // main::@25
  __b25:
    // [51] call assertType
    // [71] phi from main::@25 to assertType [phi:main::@25->assertType]
  assertType_from___b25:
    // [71] phi idx#80 = idx#39 [phi:main::@25->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@25->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@25->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_INT
    jsr assertType
    // [52] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
  __b26_from___b25:
    jmp __b26
    // main::@26
  __b26:
    // [53] call assertType
    // [71] phi from main::@26 to assertType [phi:main::@26->assertType]
  assertType_from___b26:
    // [71] phi idx#80 = idx#39 [phi:main::@26->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@26->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@26->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [54] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
  __b27_from___b26:
    jmp __b27
    // main::@27
  __b27:
    // [55] call assertType
    // [71] phi from main::@27 to assertType [phi:main::@27->assertType]
  assertType_from___b27:
    // [71] phi idx#80 = idx#39 [phi:main::@27->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@27->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@27->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_INT
    jsr assertType
    // [56] phi from main::@27 to main::@28 [phi:main::@27->main::@28]
  __b28_from___b27:
    jmp __b28
    // main::@28
  __b28:
    // [57] call assertType
    // [71] phi from main::@28 to assertType [phi:main::@28->assertType]
  assertType_from___b28:
    // [71] phi idx#80 = idx#39 [phi:main::@28->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@28->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@28->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_INT
    jsr assertType
    // [58] phi from main::@28 to main::@29 [phi:main::@28->main::@29]
  __b29_from___b28:
    jmp __b29
    // main::@29
  __b29:
    // [59] call assertType
    // [71] phi from main::@29 to assertType [phi:main::@29->assertType]
  assertType_from___b29:
    // [71] phi idx#80 = idx#39 [phi:main::@29->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@29->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@29->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_INT
    jsr assertType
    // [60] phi from main::@29 to main::@30 [phi:main::@29->main::@30]
  __b30_from___b29:
    jmp __b30
    // main::@30
  __b30:
    // [61] call assertType
    // [71] phi from main::@30 to assertType [phi:main::@30->assertType]
  assertType_from___b30:
    // [71] phi idx#80 = idx#39 [phi:main::@30->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@30->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@30->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [62] phi from main::@30 to main::@31 [phi:main::@30->main::@31]
  __b31_from___b30:
    jmp __b31
    // main::@31
  __b31:
    // [63] call assertType
    // [71] phi from main::@31 to assertType [phi:main::@31->assertType]
  assertType_from___b31:
    // [71] phi idx#80 = idx#39 [phi:main::@31->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@31->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@31->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [64] phi from main::@31 to main::@32 [phi:main::@31->main::@32]
  __b32_from___b31:
    jmp __b32
    // main::@32
  __b32:
    // [65] call assertType
    // [71] phi from main::@32 to assertType [phi:main::@32->assertType]
  assertType_from___b32:
    // [71] phi idx#80 = idx#39 [phi:main::@32->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@32->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@32->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [66] phi from main::@32 to main::@33 [phi:main::@32->main::@33]
  __b33_from___b32:
    jmp __b33
    // main::@33
  __b33:
    // [67] call assertType
    // [71] phi from main::@33 to assertType [phi:main::@33->assertType]
  assertType_from___b33:
    // [71] phi idx#80 = idx#39 [phi:main::@33->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@33->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@33->assertType#2] -- call_phi_near 
    ldy #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [68] phi from main::@33 to main::@34 [phi:main::@33->main::@34]
  __b34_from___b33:
    jmp __b34
    // main::@34
  __b34:
    // [69] call assertType
    // [71] phi from main::@34 to assertType [phi:main::@34->assertType]
  assertType_from___b34:
    // [71] phi idx#80 = idx#39 [phi:main::@34->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@34->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@34->assertType#2] -- call_phi_near 
    ldy #TYPEID_LONG
    jsr assertType
    jmp __breturn
    // main::@return
  __breturn:
    // [70] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// void assertType(__register(Y) char t1, __zp(2) char t2)
assertType: {
    .label t2 = 2
    // [72] if(assertType::t1#35==assertType::t2#35) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp.z t2
    beq __b1
    jmp __b3
    // assertType::@3
  __b3:
    // [73] COLS[idx#80] = RED -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta COLS,x
    jmp __b2
    // assertType::@2
  __b2:
    // [74] SCREEN[idx#80] = assertType::t1#35 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta SCREEN,x
    // [75] idx#39 = ++ idx#80 -- vbuxx=_inc_vbuxx 
    inx
    jmp __breturn
    // assertType::@return
  __breturn:
    // [76] return 
    rts
    // assertType::@1
  __b1:
    // [77] COLS[idx#80] = GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta COLS,x
    jmp __b2
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b13
Removing instruction jmp __b14
Removing instruction jmp __b15
Removing instruction jmp __b16
Removing instruction jmp __b17
Removing instruction jmp __b18
Removing instruction jmp __b19
Removing instruction jmp __b20
Removing instruction jmp __b21
Removing instruction jmp __b22
Removing instruction jmp __b23
Removing instruction jmp __b24
Removing instruction jmp __b25
Removing instruction jmp __b26
Removing instruction jmp __b27
Removing instruction jmp __b28
Removing instruction jmp __b29
Removing instruction jmp __b30
Removing instruction jmp __b31
Removing instruction jmp __b32
Removing instruction jmp __b33
Removing instruction jmp __b34
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing instruction ldy #TYPEID_SIGNED_CHAR with TAY
Replacing instruction ldy #TYPEID_INT with TAY
Replacing instruction ldy #TYPEID_LONG with TAY
Replacing instruction ldy #TYPEID_INT with TAY
Replacing instruction ldy #TYPEID_INT with TAY
Replacing instruction ldy #TYPEID_LONG with TAY
Replacing instruction ldy #TYPEID_LONG with TAY
Replacing instruction ldy #TYPEID_LONG with TAY
Replacing instruction ldy #TYPEID_LONG with TAY
Replacing instruction ldy #TYPEID_CHAR with TAY
Replacing instruction ldy #TYPEID_CHAR with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_INT with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_INT with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_INT with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_INT with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_CHAR with TAY
Replacing instruction ldy #TYPEID_CHAR with TAY
Replacing instruction ldy #TYPEID_CHAR with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_INT with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_INT with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_INT with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_INT with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_INT with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Replacing instruction ldy #TYPEID_UNSIGNED_LONG with TAY
Removing instruction __b1_from_main:
Removing instruction assertType_from___b1:
Removing instruction __b2_from___b1:
Removing instruction assertType_from___b2:
Removing instruction __b3_from___b2:
Removing instruction assertType_from___b3:
Removing instruction __b4_from___b3:
Removing instruction assertType_from___b4:
Removing instruction __b5_from___b4:
Removing instruction assertType_from___b5:
Removing instruction __b6_from___b5:
Removing instruction assertType_from___b6:
Removing instruction __b7_from___b6:
Removing instruction assertType_from___b7:
Removing instruction __b8_from___b7:
Removing instruction assertType_from___b8:
Removing instruction __b9_from___b8:
Removing instruction assertType_from___b9:
Removing instruction __b10_from___b9:
Removing instruction assertType_from___b10:
Removing instruction __b11_from___b10:
Removing instruction assertType_from___b11:
Removing instruction __b12_from___b11:
Removing instruction assertType_from___b12:
Removing instruction __b13_from___b12:
Removing instruction assertType_from___b13:
Removing instruction __b14_from___b13:
Removing instruction assertType_from___b14:
Removing instruction __b15_from___b14:
Removing instruction assertType_from___b15:
Removing instruction __b16_from___b15:
Removing instruction assertType_from___b16:
Removing instruction __b17_from___b16:
Removing instruction assertType_from___b17:
Removing instruction __b18_from___b17:
Removing instruction assertType_from___b18:
Removing instruction __b19_from___b18:
Removing instruction assertType_from___b19:
Removing instruction __b20_from___b19:
Removing instruction assertType_from___b20:
Removing instruction __b21_from___b20:
Removing instruction assertType_from___b21:
Removing instruction __b22_from___b21:
Removing instruction assertType_from___b22:
Removing instruction __b23_from___b22:
Removing instruction assertType_from___b23:
Removing instruction __b24_from___b23:
Removing instruction assertType_from___b24:
Removing instruction __b25_from___b24:
Removing instruction assertType_from___b25:
Removing instruction __b26_from___b25:
Removing instruction assertType_from___b26:
Removing instruction __b27_from___b26:
Removing instruction assertType_from___b27:
Removing instruction __b28_from___b27:
Removing instruction assertType_from___b28:
Removing instruction __b29_from___b28:
Removing instruction assertType_from___b29:
Removing instruction __b30_from___b29:
Removing instruction assertType_from___b30:
Removing instruction __b31_from___b30:
Removing instruction assertType_from___b31:
Removing instruction __b32_from___b31:
Removing instruction assertType_from___b32:
Removing instruction __b33_from___b32:
Removing instruction assertType_from___b33:
Removing instruction __b34_from___b33:
Removing instruction assertType_from___b34:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction assertType_from_main:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b13:
Removing instruction __b14:
Removing instruction __b15:
Removing instruction __b16:
Removing instruction __b17:
Removing instruction __b18:
Removing instruction __b19:
Removing instruction __b20:
Removing instruction __b21:
Removing instruction __b22:
Removing instruction __b23:
Removing instruction __b24:
Removing instruction __b25:
Removing instruction __b26:
Removing instruction __b27:
Removing instruction __b28:
Removing instruction __b29:
Removing instruction __b30:
Removing instruction __b31:
Removing instruction __b32:
Removing instruction __b33:
Removing instruction __b34:
Removing instruction __breturn:
Removing instruction __b3:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
__constant char * const COLS = (char *)$d800
__constant const char GREEN = 5
__constant const char RED = 2
__constant char * const SCREEN = (char *)$400
__constant char TYPEID_CHAR = 1
__constant char TYPEID_INT = 4
__constant char TYPEID_LONG = 6
__constant char TYPEID_SIGNED_CHAR = 2
__constant char TYPEID_UNSIGNED_INT = 3
__constant char TYPEID_UNSIGNED_LONG = 5
void assertType(char t1 , char t2)
char assertType::t1
char assertType::t1#35 // reg byte y 5.5
char assertType::t2
char assertType::t2#35 // t2 zp[1]:2 11.0
char idx
char idx#39 // reg byte x 1.1363636363636358
char idx#80 // reg byte x 21.600000000000005
void main()

reg byte y [ assertType::t1#35 ]
zp[1]:2 [ assertType::t2#35 ]
reg byte x [ idx#80 idx#39 ]


FINAL ASSEMBLER
Score: 506

  // File Comments
// Tests conversion of numbers to correct int types
// See https://gitlab.com/camelot/kickc/issues/181
  // Upstart
  // Commodore 64 PRG executable file
.file [name="number-conversion.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const TYPEID_SIGNED_CHAR = 2
  .const TYPEID_INT = 4
  .const TYPEID_LONG = 6
  .const TYPEID_CHAR = 1
  .const TYPEID_UNSIGNED_INT = 3
  .const TYPEID_UNSIGNED_LONG = 5
  .const RED = 2
  .const GREEN = 5
  .label SCREEN = $400
  .label COLS = $d800
.segment Code
  // main
main: {
    // assertType(typeid(12sb+12), typeid(signed byte))
    // [1] call assertType
    // [71] phi from main to assertType [phi:main->assertType]
    // [71] phi idx#80 = 0 [phi:main->assertType#0] -- vbuxx=vbuc1 
    ldx #0
    // [71] phi assertType::t2#35 = TYPEID_SIGNED_CHAR [phi:main->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_SIGNED_CHAR [phi:main->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // assertType(typeid(12sb+130), typeid(signed word))
    // [3] call assertType
    // [71] phi from main::@1 to assertType [phi:main::@1->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@1->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_INT [phi:main::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_INT [phi:main::@1->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // assertType(typeid(12sb+33000), typeid(signed dword))
    // [5] call assertType
    // [71] phi from main::@2 to assertType [phi:main::@2->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@2->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@2->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // main::@3
    // assertType(typeid(12sw+12), typeid(signed word))
    // [7] call assertType
    // [71] phi from main::@3 to assertType [phi:main::@3->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@3->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_INT [phi:main::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_INT [phi:main::@3->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [8] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
    // main::@4
    // assertType(typeid(12sw+130), typeid(signed word))
    // [9] call assertType
    // [71] phi from main::@4 to assertType [phi:main::@4->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@4->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_INT [phi:main::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_INT [phi:main::@4->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
    // main::@5
    // assertType(typeid(12sw+100000), typeid(signed dword))
    // [11] call assertType
    // [71] phi from main::@5 to assertType [phi:main::@5->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@5->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@5->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [12] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // main::@6
    // assertType(typeid(12sd+12), typeid(signed dword))
    // [13] call assertType
    // [71] phi from main::@6 to assertType [phi:main::@6->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@6->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@6->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [14] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
    // main::@7
    // assertType(typeid(12sd+130), typeid(signed dword))
    // [15] call assertType
    // [71] phi from main::@7 to assertType [phi:main::@7->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@7->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@7->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [16] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
    // main::@8
    // assertType(typeid(12sd+100000), typeid(signed dword))
    // [17] call assertType
    // [71] phi from main::@8 to assertType [phi:main::@8->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@8->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_LONG [phi:main::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@8->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [18] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
    // main::@9
    // assertType(typeid(12ub+12), typeid(unsigned byte))
    // [19] call assertType
    // [71] phi from main::@9 to assertType [phi:main::@9->assertType]
    // [71] phi idx#80 = $28 [phi:main::@9->assertType#0] -- vbuxx=vbuc1 
    ldx #$28
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@9->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [20] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
    // main::@10
    // assertType(typeid(12ub+250), typeid(unsigned byte))
    // [21] call assertType
    // [71] phi from main::@10 to assertType [phi:main::@10->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@10->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@10->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [22] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
    // main::@11
    // assertType(typeid(12ub+300), typeid(unsigned word))
    // [23] call assertType
    // [71] phi from main::@11 to assertType [phi:main::@11->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@11->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@11->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [24] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
    // main::@12
    // assertType(typeid(12ub+65534), typeid(unsigned word))
    // [25] call assertType
    // [71] phi from main::@12 to assertType [phi:main::@12->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@12->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@12->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [26] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
    // main::@13
    // assertType(typeid(12ub+66000), typeid(unsigned dword))
    // [27] call assertType
    // [71] phi from main::@13 to assertType [phi:main::@13->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@13->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@13->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [28] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
    // main::@14
    // assertType(typeid(12uw+12), typeid(unsigned word))
    // [29] call assertType
    // [71] phi from main::@14 to assertType [phi:main::@14->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@14->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@14->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [30] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
    // main::@15
    // assertType(typeid(12uw+130), typeid(unsigned word))
    // [31] call assertType
    // [71] phi from main::@15 to assertType [phi:main::@15->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@15->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@15->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@15->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [32] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
    // main::@16
    // assertType(typeid(12uw+66000), typeid(unsigned dword))
    // [33] call assertType
    // [71] phi from main::@16 to assertType [phi:main::@16->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@16->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@16->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@16->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [34] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
    // main::@17
    // assertType(typeid(12ud+12), typeid(unsigned dword))
    // [35] call assertType
    // [71] phi from main::@17 to assertType [phi:main::@17->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@17->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@17->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@17->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [36] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
    // main::@18
    // assertType(typeid(12ud+130), typeid(unsigned dword))
    // [37] call assertType
    // [71] phi from main::@18 to assertType [phi:main::@18->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@18->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@18->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@18->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [38] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
    // main::@19
    // assertType(typeid(12ud+66000), typeid(unsigned dword))
    // [39] call assertType
    // [71] phi from main::@19 to assertType [phi:main::@19->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@19->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@19->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@19->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [40] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
    // main::@20
    // assertType(typeid(12ub+3000000000), typeid(unsigned dword))
    // [41] call assertType
    // [71] phi from main::@20 to assertType [phi:main::@20->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@20->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@20->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@20->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [42] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
    // main::@21
    // assertType(typeid(12ub+-12), typeid(unsigned byte))
    // [43] call assertType
    // [71] phi from main::@21 to assertType [phi:main::@21->assertType]
    // [71] phi idx#80 = $50 [phi:main::@21->assertType#0] -- vbuxx=vbuc1 
    ldx #$50
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@21->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@21->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [44] phi from main::@21 to main::@22 [phi:main::@21->main::@22]
    // main::@22
    // assertType(typeid(12ub+-120), typeid(unsigned byte))
    // [45] call assertType
    // [71] phi from main::@22 to assertType [phi:main::@22->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@22->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@22->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@22->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [46] phi from main::@22 to main::@23 [phi:main::@22->main::@23]
    // main::@23
    // assertType(typeid(12ub+-250), typeid(unsigned byte))
    // [47] call assertType
    // [71] phi from main::@23 to assertType [phi:main::@23->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@23->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_CHAR [phi:main::@23->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_CHAR
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_CHAR [phi:main::@23->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [48] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
    // main::@24
    // assertType(typeid(12ub+-260), typeid(unsigned word))
    // [49] call assertType
    // [71] phi from main::@24 to assertType [phi:main::@24->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@24->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@24->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@24->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [50] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
    // main::@25
    // assertType(typeid(12ub+-65000), typeid(unsigned word))
    // [51] call assertType
    // [71] phi from main::@25 to assertType [phi:main::@25->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@25->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@25->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@25->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [52] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
    // main::@26
    // assertType(typeid(12ub+-66000), typeid(unsigned dword))
    // [53] call assertType
    // [71] phi from main::@26 to assertType [phi:main::@26->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@26->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@26->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@26->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [54] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
    // main::@27
    // assertType(typeid(12uw+-12), typeid(unsigned word))
    // [55] call assertType
    // [71] phi from main::@27 to assertType [phi:main::@27->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@27->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@27->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@27->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [56] phi from main::@27 to main::@28 [phi:main::@27->main::@28]
    // main::@28
    // assertType(typeid(12uw+-130), typeid(unsigned word))
    // [57] call assertType
    // [71] phi from main::@28 to assertType [phi:main::@28->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@28->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@28->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@28->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [58] phi from main::@28 to main::@29 [phi:main::@28->main::@29]
    // main::@29
    // assertType(typeid(12uw+-65000), typeid(unsigned word))
    // [59] call assertType
    // [71] phi from main::@29 to assertType [phi:main::@29->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@29->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_INT [phi:main::@29->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_INT
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_INT [phi:main::@29->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [60] phi from main::@29 to main::@30 [phi:main::@29->main::@30]
    // main::@30
    // assertType(typeid(12uw+-66000), typeid(unsigned dword))
    // [61] call assertType
    // [71] phi from main::@30 to assertType [phi:main::@30->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@30->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@30->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@30->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [62] phi from main::@30 to main::@31 [phi:main::@30->main::@31]
    // main::@31
    // assertType(typeid(12ud+-12), typeid(unsigned dword))
    // [63] call assertType
    // [71] phi from main::@31 to assertType [phi:main::@31->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@31->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@31->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@31->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [64] phi from main::@31 to main::@32 [phi:main::@31->main::@32]
    // main::@32
    // assertType(typeid(12ud+-130), typeid(unsigned dword))
    // [65] call assertType
    // [71] phi from main::@32 to assertType [phi:main::@32->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@32->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@32->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@32->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [66] phi from main::@32 to main::@33 [phi:main::@32->main::@33]
    // main::@33
    // assertType(typeid(12ud+-66000), typeid(unsigned dword))
    // [67] call assertType
    // [71] phi from main::@33 to assertType [phi:main::@33->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@33->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@33->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_UNSIGNED_LONG [phi:main::@33->assertType#2] -- call_phi_near 
    tay
    jsr assertType
    // [68] phi from main::@33 to main::@34 [phi:main::@33->main::@34]
    // main::@34
    // assertType(typeid(12sb+-2100000000), typeid(unsigned dword))
    // [69] call assertType
    // [71] phi from main::@34 to assertType [phi:main::@34->assertType]
    // [71] phi idx#80 = idx#39 [phi:main::@34->assertType#0] -- register_copy 
    // [71] phi assertType::t2#35 = TYPEID_UNSIGNED_LONG [phi:main::@34->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_UNSIGNED_LONG
    sta.z assertType.t2
    // [71] phi assertType::t1#35 = TYPEID_LONG [phi:main::@34->assertType#2] -- call_phi_near 
    ldy #TYPEID_LONG
    jsr assertType
    // main::@return
    // }
    // [70] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// void assertType(__register(Y) char t1, __zp(2) char t2)
assertType: {
    .label t2 = 2
    // if(t1==t2)
    // [72] if(assertType::t1#35==assertType::t2#35) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp.z t2
    beq __b1
    // assertType::@3
    // COLS[idx] = RED
    // [73] COLS[idx#80] = RED -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta COLS,x
    // assertType::@2
  __b2:
    // SCREEN[idx++] = t1
    // [74] SCREEN[idx#80] = assertType::t1#35 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta SCREEN,x
    // SCREEN[idx++] = t1;
    // [75] idx#39 = ++ idx#80 -- vbuxx=_inc_vbuxx 
    inx
    // assertType::@return
    // }
    // [76] return 
    rts
    // assertType::@1
  __b1:
    // COLS[idx] = GREEN
    // [77] COLS[idx#80] = GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta COLS,x
    jmp __b2
}
  // File Data

