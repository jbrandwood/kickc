Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @5
Culled Empty Block (label) keyboard_matrix_read::@1
Culled Empty Block (label) @6
Culled Empty Block (label) keyboard_key_pressed::@1
Culled Empty Block (label) @7
Culled Empty Block (label) keyboard_get_keycode::@1
Culled Empty Block (label) @8
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@6
Culled Empty Block (label) main::@8
Culled Empty Block (label) main::@29
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@30
Culled Empty Block (label) main::@17
Culled Empty Block (label) main::@22
Culled Empty Block (label) main::@25
Culled Empty Block (label) main::@27
Culled Empty Block (label) main::@28

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) RASTER ← ((byte*)) (number) $d012
  (byte*) CIA1_PORT_A ← ((byte*)) (number) $dc00
  (byte*) CIA1_PORT_B ← ((byte*)) (number) $dc01
  (byte*) CIA1_PORT_A_DDR ← ((byte*)) (number) $dc02
  (byte*) CIA1_PORT_B_DDR ← ((byte*)) (number) $dc03
  to:@4
@4: scope:[]  from @begin
  (byte) KEY_3 ← (number) 8
  (byte) KEY_W ← (number) 9
  (byte) KEY_A ← (number) $a
  (byte) KEY_4 ← (number) $b
  (byte) KEY_Z ← (number) $c
  (byte) KEY_S ← (number) $d
  (byte) KEY_E ← (number) $e
  (byte) KEY_5 ← (number) $10
  (byte) KEY_R ← (number) $11
  (byte) KEY_D ← (number) $12
  (byte) KEY_6 ← (number) $13
  (byte) KEY_C ← (number) $14
  (byte) KEY_F ← (number) $15
  (byte) KEY_T ← (number) $16
  (byte) KEY_X ← (number) $17
  (byte) KEY_7 ← (number) $18
  (byte) KEY_Y ← (number) $19
  (byte) KEY_G ← (number) $1a
  (byte) KEY_8 ← (number) $1b
  (byte) KEY_B ← (number) $1c
  (byte) KEY_H ← (number) $1d
  (byte) KEY_U ← (number) $1e
  (byte) KEY_V ← (number) $1f
  (byte) KEY_9 ← (number) $20
  (byte) KEY_I ← (number) $21
  (byte) KEY_J ← (number) $22
  (byte) KEY_0 ← (number) $23
  (byte) KEY_M ← (number) $24
  (byte) KEY_K ← (number) $25
  (byte) KEY_O ← (number) $26
  (byte) KEY_N ← (number) $27
  (byte) KEY_PLUS ← (number) $28
  (byte) KEY_P ← (number) $29
  (byte) KEY_L ← (number) $2a
  (byte) KEY_MINUS ← (number) $2b
  (byte) KEY_DOT ← (number) $2c
  (byte) KEY_COLON ← (number) $2d
  (byte) KEY_AT ← (number) $2e
  (byte) KEY_COMMA ← (number) $2f
  (byte) KEY_POUND ← (number) $30
  (byte) KEY_ASTERISK ← (number) $31
  (byte) KEY_SEMICOLON ← (number) $32
  (byte) KEY_EQUALS ← (number) $35
  (byte) KEY_ARROW_UP ← (number) $36
  (byte) KEY_SLASH ← (number) $37
  (byte) KEY_1 ← (number) $38
  (byte) KEY_ARROW_LEFT ← (number) $39
  (byte) KEY_2 ← (number) $3b
  (byte) KEY_SPACE ← (number) $3c
  (byte) KEY_Q ← (number) $3e
  (byte[]) keyboard_char_keycodes ← { (byte) KEY_AT, (byte) KEY_A, (byte) KEY_B, (byte) KEY_C, (byte) KEY_D, (byte) KEY_E, (byte) KEY_F, (byte) KEY_G, (byte) KEY_H, (byte) KEY_I, (byte) KEY_J, (byte) KEY_K, (byte) KEY_L, (byte) KEY_M, (byte) KEY_N, (byte) KEY_O, (byte) KEY_P, (byte) KEY_Q, (byte) KEY_R, (byte) KEY_S, (byte) KEY_T, (byte) KEY_U, (byte) KEY_V, (byte) KEY_W, (byte) KEY_X, (byte) KEY_Y, (byte) KEY_Z, (number) $3f, (byte) KEY_POUND, (number) $3f, (byte) KEY_ARROW_UP, (byte) KEY_ARROW_LEFT, (byte) KEY_SPACE, (number) $3f, (number) $3f, (number) $3f, (number) $3f, (number) $3f, (number) $3f, (number) $3f, (number) $3f, (number) $3f, (byte) KEY_ASTERISK, (byte) KEY_PLUS, (byte) KEY_COMMA, (byte) KEY_MINUS, (byte) KEY_DOT, (byte) KEY_SLASH, (byte) KEY_0, (byte) KEY_1, (byte) KEY_2, (byte) KEY_3, (byte) KEY_4, (byte) KEY_5, (byte) KEY_6, (byte) KEY_7, (byte) KEY_8, (byte) KEY_9, (byte) KEY_COLON, (byte) KEY_SEMICOLON, (number) $3f, (byte) KEY_EQUALS, (number) $3f, (number) $3f }
  (byte[8]) keyboard_matrix_row_bitmask ← { (number) $fe, (number) $fd, (number) $fb, (number) $f7, (number) $ef, (number) $df, (number) $bf, (number) $7f }
  (byte[8]) keyboard_matrix_col_bitmask ← { (number) 1, (number) 2, (number) 4, (number) 8, (number) $10, (number) $20, (number) $40, (number) $80 }
  to:@12

(void()) keyboard_init()
keyboard_init: scope:[keyboard_init]  from main::@3
  *((byte*) CIA1_PORT_A_DDR) ← (number) $ff
  *((byte*) CIA1_PORT_B_DDR) ← (number) 0
  to:keyboard_init::@return
keyboard_init::@return: scope:[keyboard_init]  from keyboard_init
  return 
  to:@return

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed main::@12
  (byte) keyboard_matrix_read::rowid#2 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::rowid#0 main::@12/(byte) keyboard_matrix_read::rowid#1 )
  *((byte*) CIA1_PORT_A) ← *((byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2)
  (byte~) keyboard_matrix_read::$0 ← ~ *((byte*) CIA1_PORT_B)
  (byte) keyboard_matrix_read::row_pressed_bits#0 ← (byte~) keyboard_matrix_read::$0
  (byte) keyboard_matrix_read::return#0 ← (byte) keyboard_matrix_read::row_pressed_bits#0
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  (byte) keyboard_matrix_read::return#4 ← phi( keyboard_matrix_read/(byte) keyboard_matrix_read::return#0 )
  (byte) keyboard_matrix_read::return#1 ← (byte) keyboard_matrix_read::return#4
  return 
  to:@return

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from main::@23
  (byte) keyboard_key_pressed::key#1 ← phi( main::@23/(byte) keyboard_key_pressed::key#0 )
  (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (number) 7
  (byte) keyboard_key_pressed::colidx#0 ← (number~) keyboard_key_pressed::$0
  (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#1 >> (number) 3
  (byte) keyboard_key_pressed::rowidx#0 ← (byte~) keyboard_key_pressed::$1
  (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  call keyboard_matrix_read 
  (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#1
  to:keyboard_key_pressed::@2
keyboard_key_pressed::@2: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  (byte) keyboard_key_pressed::colidx#1 ← phi( keyboard_key_pressed/(byte) keyboard_key_pressed::colidx#0 )
  (byte) keyboard_matrix_read::return#5 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::return#2 )
  (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#5
  (byte~) keyboard_key_pressed::$3 ← (byte~) keyboard_key_pressed::$2 & *((byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#1)
  (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$3
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@2
  (byte) keyboard_key_pressed::return#3 ← phi( keyboard_key_pressed::@2/(byte) keyboard_key_pressed::return#0 )
  (byte) keyboard_key_pressed::return#1 ← (byte) keyboard_key_pressed::return#3
  return 
  to:@return

(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
keyboard_get_keycode: scope:[keyboard_get_keycode]  from main::@20
  (byte) keyboard_get_keycode::ch#1 ← phi( main::@20/(byte) keyboard_get_keycode::ch#0 )
  (byte) keyboard_get_keycode::return#0 ← *((byte[]) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#1)
  to:keyboard_get_keycode::@return
keyboard_get_keycode::@return: scope:[keyboard_get_keycode]  from keyboard_get_keycode
  (byte) keyboard_get_keycode::return#3 ← phi( keyboard_get_keycode/(byte) keyboard_get_keycode::return#0 )
  (byte) keyboard_get_keycode::return#1 ← (byte) keyboard_get_keycode::return#3
  return 
  to:@return

(void()) main()
main: scope:[main]  from @12
  (byte*) main::sc#0 ← ((byte*)) (number) $400
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte*) main::sc#2 ← phi( main/(byte*) main::sc#0 main::@2/(byte*) main::sc#1 )
  (bool~) main::$1 ← (byte*) main::sc#2 < (number) $400+(number) $3e8
  if((bool~) main::$1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  (byte*) main::sc#3 ← phi( main::@1/(byte*) main::sc#2 )
  *((byte*) main::sc#3) ← (byte) ' '
  (byte*) main::sc#1 ← ++ (byte*) main::sc#3
  to:main::@1
main::@3: scope:[main]  from main::@1
  call keyboard_init 
  to:main::@31
main::@31: scope:[main]  from main::@3
  to:main::@7
main::@7: scope:[main]  from main::@26 main::@31
  if(true) goto main::@10
  to:main::@return
main::@10: scope:[main]  from main::@10 main::@7
  (bool~) main::$2 ← *((byte*) RASTER) != (number) $ff
  if((bool~) main::$2) goto main::@10
  to:main::@11
main::@11: scope:[main]  from main::@10
  (byte*) main::screen#0 ← ((byte*)) (number) $400
  (byte) main::row#0 ← (byte) 0
  to:main::@12
main::@12: scope:[main]  from main::@11 main::@18
  (byte*) main::screen#16 ← phi( main::@11/(byte*) main::screen#0 main::@18/(byte*) main::screen#1 )
  (byte) main::row#2 ← phi( main::@11/(byte) main::row#0 main::@18/(byte) main::row#1 )
  (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2
  call keyboard_matrix_read 
  (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#1
  to:main::@32
main::@32: scope:[main]  from main::@12
  (byte) main::row#8 ← phi( main::@12/(byte) main::row#2 )
  (byte*) main::screen#13 ← phi( main::@12/(byte*) main::screen#16 )
  (byte) keyboard_matrix_read::return#6 ← phi( main::@12/(byte) keyboard_matrix_read::return#3 )
  (byte~) main::$3 ← (byte) keyboard_matrix_read::return#6
  (byte) main::row_pressed_bits#0 ← (byte~) main::$3
  (byte) main::col#0 ← (byte) 0
  to:main::@13
main::@13: scope:[main]  from main::@15 main::@32
  (byte) main::row#7 ← phi( main::@15/(byte) main::row#4 main::@32/(byte) main::row#8 )
  (byte) main::col#5 ← phi( main::@15/(byte) main::col#1 main::@32/(byte) main::col#0 )
  (byte*) main::screen#9 ← phi( main::@15/(byte*) main::screen#10 main::@32/(byte*) main::screen#13 )
  (byte) main::row_pressed_bits#2 ← phi( main::@15/(byte) main::row_pressed_bits#1 main::@32/(byte) main::row_pressed_bits#0 )
  (number~) main::$4 ← (byte) main::row_pressed_bits#2 & (number) $80
  (bool~) main::$5 ← (number~) main::$4 != (number) 0
  if((bool~) main::$5) goto main::@14
  to:main::@16
main::@14: scope:[main]  from main::@13
  (byte) main::row#5 ← phi( main::@13/(byte) main::row#7 )
  (byte) main::row_pressed_bits#4 ← phi( main::@13/(byte) main::row_pressed_bits#2 )
  (byte) main::col#2 ← phi( main::@13/(byte) main::col#5 )
  (byte*) main::screen#3 ← phi( main::@13/(byte*) main::screen#9 )
  *((byte*) main::screen#3 + (byte) main::col#2) ← (byte) '1'
  to:main::@15
main::@16: scope:[main]  from main::@13
  (byte) main::row#6 ← phi( main::@13/(byte) main::row#7 )
  (byte) main::row_pressed_bits#5 ← phi( main::@13/(byte) main::row_pressed_bits#2 )
  (byte) main::col#3 ← phi( main::@13/(byte) main::col#5 )
  (byte*) main::screen#4 ← phi( main::@13/(byte*) main::screen#9 )
  *((byte*) main::screen#4 + (byte) main::col#3) ← (byte) '0'
  to:main::@15
main::@15: scope:[main]  from main::@14 main::@16
  (byte) main::row#4 ← phi( main::@14/(byte) main::row#5 main::@16/(byte) main::row#6 )
  (byte*) main::screen#10 ← phi( main::@14/(byte*) main::screen#3 main::@16/(byte*) main::screen#4 )
  (byte) main::col#4 ← phi( main::@14/(byte) main::col#2 main::@16/(byte) main::col#3 )
  (byte) main::row_pressed_bits#3 ← phi( main::@14/(byte) main::row_pressed_bits#4 main::@16/(byte) main::row_pressed_bits#5 )
  (number~) main::$6 ← (byte) main::row_pressed_bits#3 * (number) 2
  (byte) main::row_pressed_bits#1 ← (number~) main::$6
  (byte) main::col#1 ← (byte) main::col#4 + rangenext(0,7)
  (bool~) main::$7 ← (byte) main::col#1 != rangelast(0,7)
  if((bool~) main::$7) goto main::@13
  to:main::@18
main::@18: scope:[main]  from main::@15
  (byte) main::row#3 ← phi( main::@15/(byte) main::row#4 )
  (byte*) main::screen#5 ← phi( main::@15/(byte*) main::screen#10 )
  (byte*~) main::$8 ← (byte*) main::screen#5 + (number) $28
  (byte*) main::screen#1 ← (byte*~) main::$8
  (byte) main::row#1 ← (byte) main::row#3 + rangenext(0,7)
  (bool~) main::$9 ← (byte) main::row#1 != rangelast(0,7)
  if((bool~) main::$9) goto main::@12
  to:main::@19
main::@19: scope:[main]  from main::@18
  (byte*) main::screen#6 ← phi( main::@18/(byte*) main::screen#1 )
  (byte*~) main::$10 ← (byte*) main::screen#6 + (number) $28
  (byte*) main::screen#2 ← (byte*~) main::$10
  (byte) main::i#0 ← (number) 0
  (byte) main::ch#0 ← (byte) 0
  to:main::@20
main::@20: scope:[main]  from main::@19 main::@21
  (byte) main::i#9 ← phi( main::@19/(byte) main::i#0 main::@21/(byte) main::i#6 )
  (byte*) main::screen#17 ← phi( main::@19/(byte*) main::screen#2 main::@21/(byte*) main::screen#12 )
  (byte) main::ch#2 ← phi( main::@19/(byte) main::ch#0 main::@21/(byte) main::ch#1 )
  (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2
  call keyboard_get_keycode 
  (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#1
  to:main::@33
main::@33: scope:[main]  from main::@20
  (byte) main::i#7 ← phi( main::@20/(byte) main::i#9 )
  (byte*) main::screen#14 ← phi( main::@20/(byte*) main::screen#17 )
  (byte) main::ch#5 ← phi( main::@20/(byte) main::ch#2 )
  (byte) keyboard_get_keycode::return#4 ← phi( main::@20/(byte) keyboard_get_keycode::return#2 )
  (byte~) main::$11 ← (byte) keyboard_get_keycode::return#4
  (byte) main::key#0 ← (byte~) main::$11
  (bool~) main::$12 ← (byte) main::key#0 != (number) $3f
  (bool~) main::$13 ← ! (bool~) main::$12
  if((bool~) main::$13) goto main::@21
  to:main::@23
main::@21: scope:[main]  from main::@24 main::@33 main::@34
  (byte) main::i#6 ← phi( main::@24/(byte) main::i#1 main::@33/(byte) main::i#7 main::@34/(byte) main::i#5 )
  (byte*) main::screen#12 ← phi( main::@24/(byte*) main::screen#7 main::@33/(byte*) main::screen#14 main::@34/(byte*) main::screen#11 )
  (byte) main::ch#3 ← phi( main::@24/(byte) main::ch#4 main::@33/(byte) main::ch#5 main::@34/(byte) main::ch#6 )
  (byte) main::ch#1 ← (byte) main::ch#3 + rangenext(0,$3f)
  (bool~) main::$17 ← (byte) main::ch#1 != rangelast(0,$3f)
  if((bool~) main::$17) goto main::@20
  to:main::@26
main::@23: scope:[main]  from main::@33
  (byte) main::i#8 ← phi( main::@33/(byte) main::i#7 )
  (byte*) main::screen#15 ← phi( main::@33/(byte*) main::screen#14 )
  (byte) main::ch#7 ← phi( main::@33/(byte) main::ch#5 )
  (byte) main::key#1 ← phi( main::@33/(byte) main::key#0 )
  (byte) keyboard_key_pressed::key#0 ← (byte) main::key#1
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#1
  to:main::@34
main::@34: scope:[main]  from main::@23
  (byte) main::i#5 ← phi( main::@23/(byte) main::i#8 )
  (byte*) main::screen#11 ← phi( main::@23/(byte*) main::screen#15 )
  (byte) main::ch#6 ← phi( main::@23/(byte) main::ch#7 )
  (byte) keyboard_key_pressed::return#4 ← phi( main::@23/(byte) keyboard_key_pressed::return#2 )
  (byte~) main::$14 ← (byte) keyboard_key_pressed::return#4
  (bool~) main::$15 ← (byte~) main::$14 != (number) 0
  (bool~) main::$16 ← ! (bool~) main::$15
  if((bool~) main::$16) goto main::@21
  to:main::@24
main::@24: scope:[main]  from main::@34
  (byte) main::i#3 ← phi( main::@34/(byte) main::i#5 )
  (byte*) main::screen#7 ← phi( main::@34/(byte*) main::screen#11 )
  (byte) main::ch#4 ← phi( main::@34/(byte) main::ch#6 )
  *((byte*) main::screen#7 + (byte) main::i#3) ← (byte) main::ch#4
  (byte) main::i#1 ← ++ (byte) main::i#3
  to:main::@21
main::@26: scope:[main]  from main::@21 main::@26
  (byte) main::i#4 ← phi( main::@21/(byte) main::i#6 main::@26/(byte) main::i#2 )
  (byte*) main::screen#8 ← phi( main::@21/(byte*) main::screen#12 main::@26/(byte*) main::screen#8 )
  *((byte*) main::screen#8 + (byte) main::i#4) ← (byte) ' '
  (byte) main::i#2 ← ++ (byte) main::i#4
  (bool~) main::$18 ← (byte) main::i#2 < (number) 5
  if((bool~) main::$18) goto main::@26
  to:main::@7
main::@return: scope:[main]  from main::@7
  return 
  to:@return
@12: scope:[]  from @4
  call main 
  to:@13
@13: scope:[]  from @12
  to:@end
@end: scope:[]  from @13

SYMBOL TABLE SSA
(label) @12
(label) @13
(label) @4
(label) @begin
(label) @end
(byte*) CIA1_PORT_A
(byte*) CIA1_PORT_A_DDR
(byte*) CIA1_PORT_B
(byte*) CIA1_PORT_B_DDR
(byte) KEY_0
(byte) KEY_1
(byte) KEY_2
(byte) KEY_3
(byte) KEY_4
(byte) KEY_5
(byte) KEY_6
(byte) KEY_7
(byte) KEY_8
(byte) KEY_9
(byte) KEY_A
(byte) KEY_ARROW_LEFT
(byte) KEY_ARROW_UP
(byte) KEY_ASTERISK
(byte) KEY_AT
(byte) KEY_B
(byte) KEY_C
(byte) KEY_COLON
(byte) KEY_COMMA
(byte) KEY_D
(byte) KEY_DOT
(byte) KEY_E
(byte) KEY_EQUALS
(byte) KEY_F
(byte) KEY_G
(byte) KEY_H
(byte) KEY_I
(byte) KEY_J
(byte) KEY_K
(byte) KEY_L
(byte) KEY_M
(byte) KEY_MINUS
(byte) KEY_N
(byte) KEY_O
(byte) KEY_P
(byte) KEY_PLUS
(byte) KEY_POUND
(byte) KEY_Q
(byte) KEY_R
(byte) KEY_S
(byte) KEY_SEMICOLON
(byte) KEY_SLASH
(byte) KEY_SPACE
(byte) KEY_T
(byte) KEY_U
(byte) KEY_V
(byte) KEY_W
(byte) KEY_X
(byte) KEY_Y
(byte) KEY_Z
(byte*) RASTER
(byte[]) keyboard_char_keycodes
(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
(label) keyboard_get_keycode::@return
(byte) keyboard_get_keycode::ch
(byte) keyboard_get_keycode::ch#0
(byte) keyboard_get_keycode::ch#1
(byte) keyboard_get_keycode::return
(byte) keyboard_get_keycode::return#0
(byte) keyboard_get_keycode::return#1
(byte) keyboard_get_keycode::return#2
(byte) keyboard_get_keycode::return#3
(byte) keyboard_get_keycode::return#4
(void()) keyboard_init()
(label) keyboard_init::@return
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(number~) keyboard_key_pressed::$0
(byte~) keyboard_key_pressed::$1
(byte~) keyboard_key_pressed::$2
(byte~) keyboard_key_pressed::$3
(label) keyboard_key_pressed::@2
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0
(byte) keyboard_key_pressed::colidx#1
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0
(byte) keyboard_key_pressed::key#1
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0
(byte) keyboard_key_pressed::return#1
(byte) keyboard_key_pressed::return#2
(byte) keyboard_key_pressed::return#3
(byte) keyboard_key_pressed::return#4
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0
(byte[8]) keyboard_matrix_col_bitmask
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte~) keyboard_matrix_read::$0
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0
(byte) keyboard_matrix_read::return#1
(byte) keyboard_matrix_read::return#2
(byte) keyboard_matrix_read::return#3
(byte) keyboard_matrix_read::return#4
(byte) keyboard_matrix_read::return#5
(byte) keyboard_matrix_read::return#6
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::row_pressed_bits#0
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0
(byte) keyboard_matrix_read::rowid#1
(byte) keyboard_matrix_read::rowid#2
(byte[8]) keyboard_matrix_row_bitmask
(void()) main()
(bool~) main::$1
(byte*~) main::$10
(byte~) main::$11
(bool~) main::$12
(bool~) main::$13
(byte~) main::$14
(bool~) main::$15
(bool~) main::$16
(bool~) main::$17
(bool~) main::$18
(bool~) main::$2
(byte~) main::$3
(number~) main::$4
(bool~) main::$5
(number~) main::$6
(bool~) main::$7
(byte*~) main::$8
(bool~) main::$9
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@23
(label) main::@24
(label) main::@26
(label) main::@3
(label) main::@31
(label) main::@32
(label) main::@33
(label) main::@34
(label) main::@7
(label) main::@return
(byte) main::ch
(byte) main::ch#0
(byte) main::ch#1
(byte) main::ch#2
(byte) main::ch#3
(byte) main::ch#4
(byte) main::ch#5
(byte) main::ch#6
(byte) main::ch#7
(byte) main::col
(byte) main::col#0
(byte) main::col#1
(byte) main::col#2
(byte) main::col#3
(byte) main::col#4
(byte) main::col#5
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte) main::i#3
(byte) main::i#4
(byte) main::i#5
(byte) main::i#6
(byte) main::i#7
(byte) main::i#8
(byte) main::i#9
(byte) main::key
(byte) main::key#0
(byte) main::key#1
(byte) main::row
(byte) main::row#0
(byte) main::row#1
(byte) main::row#2
(byte) main::row#3
(byte) main::row#4
(byte) main::row#5
(byte) main::row#6
(byte) main::row#7
(byte) main::row#8
(byte) main::row_pressed_bits
(byte) main::row_pressed_bits#0
(byte) main::row_pressed_bits#1
(byte) main::row_pressed_bits#2
(byte) main::row_pressed_bits#3
(byte) main::row_pressed_bits#4
(byte) main::row_pressed_bits#5
(byte*) main::sc
(byte*) main::sc#0
(byte*) main::sc#1
(byte*) main::sc#2
(byte*) main::sc#3
(byte*) main::screen
(byte*) main::screen#0
(byte*) main::screen#1
(byte*) main::screen#10
(byte*) main::screen#11
(byte*) main::screen#12
(byte*) main::screen#13
(byte*) main::screen#14
(byte*) main::screen#15
(byte*) main::screen#16
(byte*) main::screen#17
(byte*) main::screen#2
(byte*) main::screen#3
(byte*) main::screen#4
(byte*) main::screen#5
(byte*) main::screen#6
(byte*) main::screen#7
(byte*) main::screen#8
(byte*) main::screen#9

Adding number conversion cast (unumber) 8 in (byte) KEY_3 ← (number) 8
Adding number conversion cast (unumber) 9 in (byte) KEY_W ← (number) 9
Adding number conversion cast (unumber) $a in (byte) KEY_A ← (number) $a
Adding number conversion cast (unumber) $b in (byte) KEY_4 ← (number) $b
Adding number conversion cast (unumber) $c in (byte) KEY_Z ← (number) $c
Adding number conversion cast (unumber) $d in (byte) KEY_S ← (number) $d
Adding number conversion cast (unumber) $e in (byte) KEY_E ← (number) $e
Adding number conversion cast (unumber) $10 in (byte) KEY_5 ← (number) $10
Adding number conversion cast (unumber) $11 in (byte) KEY_R ← (number) $11
Adding number conversion cast (unumber) $12 in (byte) KEY_D ← (number) $12
Adding number conversion cast (unumber) $13 in (byte) KEY_6 ← (number) $13
Adding number conversion cast (unumber) $14 in (byte) KEY_C ← (number) $14
Adding number conversion cast (unumber) $15 in (byte) KEY_F ← (number) $15
Adding number conversion cast (unumber) $16 in (byte) KEY_T ← (number) $16
Adding number conversion cast (unumber) $17 in (byte) KEY_X ← (number) $17
Adding number conversion cast (unumber) $18 in (byte) KEY_7 ← (number) $18
Adding number conversion cast (unumber) $19 in (byte) KEY_Y ← (number) $19
Adding number conversion cast (unumber) $1a in (byte) KEY_G ← (number) $1a
Adding number conversion cast (unumber) $1b in (byte) KEY_8 ← (number) $1b
Adding number conversion cast (unumber) $1c in (byte) KEY_B ← (number) $1c
Adding number conversion cast (unumber) $1d in (byte) KEY_H ← (number) $1d
Adding number conversion cast (unumber) $1e in (byte) KEY_U ← (number) $1e
Adding number conversion cast (unumber) $1f in (byte) KEY_V ← (number) $1f
Adding number conversion cast (unumber) $20 in (byte) KEY_9 ← (number) $20
Adding number conversion cast (unumber) $21 in (byte) KEY_I ← (number) $21
Adding number conversion cast (unumber) $22 in (byte) KEY_J ← (number) $22
Adding number conversion cast (unumber) $23 in (byte) KEY_0 ← (number) $23
Adding number conversion cast (unumber) $24 in (byte) KEY_M ← (number) $24
Adding number conversion cast (unumber) $25 in (byte) KEY_K ← (number) $25
Adding number conversion cast (unumber) $26 in (byte) KEY_O ← (number) $26
Adding number conversion cast (unumber) $27 in (byte) KEY_N ← (number) $27
Adding number conversion cast (unumber) $28 in (byte) KEY_PLUS ← (number) $28
Adding number conversion cast (unumber) $29 in (byte) KEY_P ← (number) $29
Adding number conversion cast (unumber) $2a in (byte) KEY_L ← (number) $2a
Adding number conversion cast (unumber) $2b in (byte) KEY_MINUS ← (number) $2b
Adding number conversion cast (unumber) $2c in (byte) KEY_DOT ← (number) $2c
Adding number conversion cast (unumber) $2d in (byte) KEY_COLON ← (number) $2d
Adding number conversion cast (unumber) $2e in (byte) KEY_AT ← (number) $2e
Adding number conversion cast (unumber) $2f in (byte) KEY_COMMA ← (number) $2f
Adding number conversion cast (unumber) $30 in (byte) KEY_POUND ← (number) $30
Adding number conversion cast (unumber) $31 in (byte) KEY_ASTERISK ← (number) $31
Adding number conversion cast (unumber) $32 in (byte) KEY_SEMICOLON ← (number) $32
Adding number conversion cast (unumber) $35 in (byte) KEY_EQUALS ← (number) $35
Adding number conversion cast (unumber) $36 in (byte) KEY_ARROW_UP ← (number) $36
Adding number conversion cast (unumber) $37 in (byte) KEY_SLASH ← (number) $37
Adding number conversion cast (unumber) $38 in (byte) KEY_1 ← (number) $38
Adding number conversion cast (unumber) $39 in (byte) KEY_ARROW_LEFT ← (number) $39
Adding number conversion cast (unumber) $3b in (byte) KEY_2 ← (number) $3b
Adding number conversion cast (unumber) $3c in (byte) KEY_SPACE ← (number) $3c
Adding number conversion cast (unumber) $3e in (byte) KEY_Q ← (number) $3e
Adding number conversion cast (unumber) $ff in *((byte*) CIA1_PORT_A_DDR) ← (number) $ff
Adding number conversion cast (unumber) 0 in *((byte*) CIA1_PORT_B_DDR) ← (number) 0
Adding number conversion cast (unumber) 7 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (number) 7
Adding number conversion cast (unumber) keyboard_key_pressed::$0 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (unumber)(number) 7
Adding number conversion cast (unumber) 3 in (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#1 >> (number) 3
Adding number conversion cast (unumber) $400+$3e8 in (bool~) main::$1 ← (byte*) main::sc#2 < (number) $400+(number) $3e8
Adding number conversion cast (unumber) $ff in (bool~) main::$2 ← *((byte*) RASTER) != (number) $ff
Adding number conversion cast (unumber) $80 in (number~) main::$4 ← (byte) main::row_pressed_bits#2 & (number) $80
Adding number conversion cast (unumber) main::$4 in (number~) main::$4 ← (byte) main::row_pressed_bits#2 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) main::$5 ← (unumber~) main::$4 != (number) 0
Adding number conversion cast (unumber) 2 in (number~) main::$6 ← (byte) main::row_pressed_bits#3 * (number) 2
Adding number conversion cast (unumber) main::$6 in (number~) main::$6 ← (byte) main::row_pressed_bits#3 * (unumber)(number) 2
Adding number conversion cast (unumber) $28 in (byte*~) main::$8 ← (byte*) main::screen#5 + (number) $28
Adding number conversion cast (unumber) $28 in (byte*~) main::$10 ← (byte*) main::screen#6 + (number) $28
Adding number conversion cast (unumber) 0 in (byte) main::i#0 ← (number) 0
Adding number conversion cast (unumber) $3f in (bool~) main::$12 ← (byte) main::key#0 != (number) $3f
Adding number conversion cast (unumber) 0 in (bool~) main::$15 ← (byte~) main::$14 != (number) 0
Adding number conversion cast (unumber) 5 in (bool~) main::$18 ← (byte) main::i#2 < (number) 5
Successful SSA optimization PassNAddNumberTypeConversions
Added casts to value list in (byte[]) keyboard_char_keycodes ← (byte[]){ (byte) KEY_AT, (byte) KEY_A, (byte) KEY_B, (byte) KEY_C, (byte) KEY_D, (byte) KEY_E, (byte) KEY_F, (byte) KEY_G, (byte) KEY_H, (byte) KEY_I, (byte) KEY_J, (byte) KEY_K, (byte) KEY_L, (byte) KEY_M, (byte) KEY_N, (byte) KEY_O, (byte) KEY_P, (byte) KEY_Q, (byte) KEY_R, (byte) KEY_S, (byte) KEY_T, (byte) KEY_U, (byte) KEY_V, (byte) KEY_W, (byte) KEY_X, (byte) KEY_Y, (byte) KEY_Z, (byte)(number) $3f, (byte) KEY_POUND, (byte)(number) $3f, (byte) KEY_ARROW_UP, (byte) KEY_ARROW_LEFT, (byte) KEY_SPACE, (byte)(number) $3f, (byte)(number) $3f, (byte)(number) $3f, (byte)(number) $3f, (byte)(number) $3f, (byte)(number) $3f, (byte)(number) $3f, (byte)(number) $3f, (byte)(number) $3f, (byte) KEY_ASTERISK, (byte) KEY_PLUS, (byte) KEY_COMMA, (byte) KEY_MINUS, (byte) KEY_DOT, (byte) KEY_SLASH, (byte) KEY_0, (byte) KEY_1, (byte) KEY_2, (byte) KEY_3, (byte) KEY_4, (byte) KEY_5, (byte) KEY_6, (byte) KEY_7, (byte) KEY_8, (byte) KEY_9, (byte) KEY_COLON, (byte) KEY_SEMICOLON, (byte)(number) $3f, (byte) KEY_EQUALS, (byte)(number) $3f, (byte)(number) $3f }
Added casts to value list in (byte[8]) keyboard_matrix_row_bitmask ← (byte[8]){ (byte)(number) $fe, (byte)(number) $fd, (byte)(number) $fb, (byte)(number) $f7, (byte)(number) $ef, (byte)(number) $df, (byte)(number) $bf, (byte)(number) $7f }
Added casts to value list in (byte[8]) keyboard_matrix_col_bitmask ← (byte[8]){ (byte)(number) 1, (byte)(number) 2, (byte)(number) 4, (byte)(number) 8, (byte)(number) $10, (byte)(number) $20, (byte)(number) $40, (byte)(number) $80 }
Successful SSA optimization PassNAddInitializerValueListTypeCasts
Inlining cast (byte*) RASTER ← (byte*)(number) $d012
Inlining cast (byte*) CIA1_PORT_A ← (byte*)(number) $dc00
Inlining cast (byte*) CIA1_PORT_B ← (byte*)(number) $dc01
Inlining cast (byte*) CIA1_PORT_A_DDR ← (byte*)(number) $dc02
Inlining cast (byte*) CIA1_PORT_B_DDR ← (byte*)(number) $dc03
Inlining cast (byte) KEY_3 ← (unumber)(number) 8
Inlining cast (byte) KEY_W ← (unumber)(number) 9
Inlining cast (byte) KEY_A ← (unumber)(number) $a
Inlining cast (byte) KEY_4 ← (unumber)(number) $b
Inlining cast (byte) KEY_Z ← (unumber)(number) $c
Inlining cast (byte) KEY_S ← (unumber)(number) $d
Inlining cast (byte) KEY_E ← (unumber)(number) $e
Inlining cast (byte) KEY_5 ← (unumber)(number) $10
Inlining cast (byte) KEY_R ← (unumber)(number) $11
Inlining cast (byte) KEY_D ← (unumber)(number) $12
Inlining cast (byte) KEY_6 ← (unumber)(number) $13
Inlining cast (byte) KEY_C ← (unumber)(number) $14
Inlining cast (byte) KEY_F ← (unumber)(number) $15
Inlining cast (byte) KEY_T ← (unumber)(number) $16
Inlining cast (byte) KEY_X ← (unumber)(number) $17
Inlining cast (byte) KEY_7 ← (unumber)(number) $18
Inlining cast (byte) KEY_Y ← (unumber)(number) $19
Inlining cast (byte) KEY_G ← (unumber)(number) $1a
Inlining cast (byte) KEY_8 ← (unumber)(number) $1b
Inlining cast (byte) KEY_B ← (unumber)(number) $1c
Inlining cast (byte) KEY_H ← (unumber)(number) $1d
Inlining cast (byte) KEY_U ← (unumber)(number) $1e
Inlining cast (byte) KEY_V ← (unumber)(number) $1f
Inlining cast (byte) KEY_9 ← (unumber)(number) $20
Inlining cast (byte) KEY_I ← (unumber)(number) $21
Inlining cast (byte) KEY_J ← (unumber)(number) $22
Inlining cast (byte) KEY_0 ← (unumber)(number) $23
Inlining cast (byte) KEY_M ← (unumber)(number) $24
Inlining cast (byte) KEY_K ← (unumber)(number) $25
Inlining cast (byte) KEY_O ← (unumber)(number) $26
Inlining cast (byte) KEY_N ← (unumber)(number) $27
Inlining cast (byte) KEY_PLUS ← (unumber)(number) $28
Inlining cast (byte) KEY_P ← (unumber)(number) $29
Inlining cast (byte) KEY_L ← (unumber)(number) $2a
Inlining cast (byte) KEY_MINUS ← (unumber)(number) $2b
Inlining cast (byte) KEY_DOT ← (unumber)(number) $2c
Inlining cast (byte) KEY_COLON ← (unumber)(number) $2d
Inlining cast (byte) KEY_AT ← (unumber)(number) $2e
Inlining cast (byte) KEY_COMMA ← (unumber)(number) $2f
Inlining cast (byte) KEY_POUND ← (unumber)(number) $30
Inlining cast (byte) KEY_ASTERISK ← (unumber)(number) $31
Inlining cast (byte) KEY_SEMICOLON ← (unumber)(number) $32
Inlining cast (byte) KEY_EQUALS ← (unumber)(number) $35
Inlining cast (byte) KEY_ARROW_UP ← (unumber)(number) $36
Inlining cast (byte) KEY_SLASH ← (unumber)(number) $37
Inlining cast (byte) KEY_1 ← (unumber)(number) $38
Inlining cast (byte) KEY_ARROW_LEFT ← (unumber)(number) $39
Inlining cast (byte) KEY_2 ← (unumber)(number) $3b
Inlining cast (byte) KEY_SPACE ← (unumber)(number) $3c
Inlining cast (byte) KEY_Q ← (unumber)(number) $3e
Inlining cast *((byte*) CIA1_PORT_A_DDR) ← (unumber)(number) $ff
Inlining cast *((byte*) CIA1_PORT_B_DDR) ← (unumber)(number) 0
Inlining cast (byte*) main::sc#0 ← (byte*)(number) $400
Inlining cast (byte*) main::screen#0 ← (byte*)(number) $400
Inlining cast (byte) main::i#0 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 56320
Simplifying constant pointer cast (byte*) 56321
Simplifying constant pointer cast (byte*) 56322
Simplifying constant pointer cast (byte*) 56323
Simplifying constant integer cast 8
Simplifying constant integer cast 9
Simplifying constant integer cast $a
Simplifying constant integer cast $b
Simplifying constant integer cast $c
Simplifying constant integer cast $d
Simplifying constant integer cast $e
Simplifying constant integer cast $10
Simplifying constant integer cast $11
Simplifying constant integer cast $12
Simplifying constant integer cast $13
Simplifying constant integer cast $14
Simplifying constant integer cast $15
Simplifying constant integer cast $16
Simplifying constant integer cast $17
Simplifying constant integer cast $18
Simplifying constant integer cast $19
Simplifying constant integer cast $1a
Simplifying constant integer cast $1b
Simplifying constant integer cast $1c
Simplifying constant integer cast $1d
Simplifying constant integer cast $1e
Simplifying constant integer cast $1f
Simplifying constant integer cast $20
Simplifying constant integer cast $21
Simplifying constant integer cast $22
Simplifying constant integer cast $23
Simplifying constant integer cast $24
Simplifying constant integer cast $25
Simplifying constant integer cast $26
Simplifying constant integer cast $27
Simplifying constant integer cast $28
Simplifying constant integer cast $29
Simplifying constant integer cast $2a
Simplifying constant integer cast $2b
Simplifying constant integer cast $2c
Simplifying constant integer cast $2d
Simplifying constant integer cast $2e
Simplifying constant integer cast $2f
Simplifying constant integer cast $30
Simplifying constant integer cast $31
Simplifying constant integer cast $32
Simplifying constant integer cast $35
Simplifying constant integer cast $36
Simplifying constant integer cast $37
Simplifying constant integer cast $38
Simplifying constant integer cast $39
Simplifying constant integer cast $3b
Simplifying constant integer cast $3c
Simplifying constant integer cast $3e
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $3f
Simplifying constant integer cast $fe
Simplifying constant integer cast $fd
Simplifying constant integer cast $fb
Simplifying constant integer cast $f7
Simplifying constant integer cast $ef
Simplifying constant integer cast $df
Simplifying constant integer cast $bf
Simplifying constant integer cast $7f
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 8
Simplifying constant integer cast $10
Simplifying constant integer cast $20
Simplifying constant integer cast $40
Simplifying constant integer cast $80
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 7
Simplifying constant integer cast 3
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $ff
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $28
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast $3f
Simplifying constant integer cast 0
Simplifying constant integer cast 5
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $c
Finalized unsigned number type (byte) $d
Finalized unsigned number type (byte) $e
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $11
Finalized unsigned number type (byte) $12
Finalized unsigned number type (byte) $13
Finalized unsigned number type (byte) $14
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) $16
Finalized unsigned number type (byte) $17
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) $1a
Finalized unsigned number type (byte) $1b
Finalized unsigned number type (byte) $1c
Finalized unsigned number type (byte) $1d
Finalized unsigned number type (byte) $1e
Finalized unsigned number type (byte) $1f
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) $21
Finalized unsigned number type (byte) $22
Finalized unsigned number type (byte) $23
Finalized unsigned number type (byte) $24
Finalized unsigned number type (byte) $25
Finalized unsigned number type (byte) $26
Finalized unsigned number type (byte) $27
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $29
Finalized unsigned number type (byte) $2a
Finalized unsigned number type (byte) $2b
Finalized unsigned number type (byte) $2c
Finalized unsigned number type (byte) $2d
Finalized unsigned number type (byte) $2e
Finalized unsigned number type (byte) $2f
Finalized unsigned number type (byte) $30
Finalized unsigned number type (byte) $31
Finalized unsigned number type (byte) $32
Finalized unsigned number type (byte) $35
Finalized unsigned number type (byte) $36
Finalized unsigned number type (byte) $37
Finalized unsigned number type (byte) $38
Finalized unsigned number type (byte) $39
Finalized unsigned number type (byte) $3b
Finalized unsigned number type (byte) $3c
Finalized unsigned number type (byte) $3e
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $3f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 5
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (byte) 7
Inferred type updated to byte in (unumber~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80
Inferred type updated to byte in (unumber~) main::$6 ← (byte) main::row_pressed_bits#3 * (byte) 2
Inversing boolean not [143] (bool~) main::$13 ← (byte) main::key#0 == (byte) $3f from [142] (bool~) main::$12 ← (byte) main::key#0 != (byte) $3f
Inversing boolean not [156] (bool~) main::$16 ← (byte~) main::$14 == (byte) 0 from [155] (bool~) main::$15 ← (byte~) main::$14 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte) keyboard_matrix_read::return#0 = (byte) keyboard_matrix_read::row_pressed_bits#0 (byte~) keyboard_matrix_read::$0 (byte) keyboard_matrix_read::return#4 (byte) keyboard_matrix_read::return#1 
Alias (byte) keyboard_key_pressed::colidx#0 = (byte~) keyboard_key_pressed::$0 (byte) keyboard_key_pressed::colidx#1 
Alias (byte) keyboard_key_pressed::rowidx#0 = (byte~) keyboard_key_pressed::$1 
Alias (byte) keyboard_matrix_read::return#2 = (byte) keyboard_matrix_read::return#5 
Alias (byte) keyboard_key_pressed::return#0 = (byte~) keyboard_key_pressed::$3 (byte) keyboard_key_pressed::return#3 (byte) keyboard_key_pressed::return#1 
Alias (byte) keyboard_get_keycode::return#0 = (byte) keyboard_get_keycode::return#3 (byte) keyboard_get_keycode::return#1 
Alias (byte*) main::sc#2 = (byte*) main::sc#3 
Alias (byte) keyboard_matrix_read::return#3 = (byte) keyboard_matrix_read::return#6 
Alias (byte*) main::screen#13 = (byte*) main::screen#16 
Alias (byte) main::row#2 = (byte) main::row#8 
Alias (byte) main::row_pressed_bits#0 = (byte~) main::$3 
Alias (byte*) main::screen#3 = (byte*) main::screen#9 (byte*) main::screen#4 
Alias (byte) main::col#2 = (byte) main::col#5 (byte) main::col#3 
Alias (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#4 (byte) main::row_pressed_bits#5 
Alias (byte) main::row#5 = (byte) main::row#7 (byte) main::row#6 
Alias (byte) main::row_pressed_bits#1 = (byte~) main::$6 
Alias (byte*) main::screen#10 = (byte*) main::screen#5 
Alias (byte) main::row#3 = (byte) main::row#4 
Alias (byte*) main::screen#1 = (byte*~) main::$8 (byte*) main::screen#6 
Alias (byte*) main::screen#2 = (byte*~) main::$10 
Alias (byte) keyboard_get_keycode::return#2 = (byte) keyboard_get_keycode::return#4 
Alias (byte) main::ch#2 = (byte) main::ch#5 (byte) main::ch#7 (byte) main::ch#6 (byte) main::ch#4 
Alias (byte*) main::screen#11 = (byte*) main::screen#14 (byte*) main::screen#17 (byte*) main::screen#15 (byte*) main::screen#7 
Alias (byte) main::i#3 = (byte) main::i#7 (byte) main::i#9 (byte) main::i#8 (byte) main::i#5 
Alias (byte) main::key#0 = (byte~) main::$11 (byte) main::key#1 
Alias (byte) keyboard_key_pressed::return#2 = (byte) keyboard_key_pressed::return#4 
Successful SSA optimization Pass2AliasElimination
Alias (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#3 
Alias (byte) main::col#2 = (byte) main::col#4 
Alias (byte*) main::screen#10 = (byte*) main::screen#3 
Alias (byte) main::row#3 = (byte) main::row#5 
Alias (byte) main::ch#2 = (byte) main::ch#3 
Alias (byte*) main::screen#11 = (byte*) main::screen#12 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) keyboard_key_pressed::key#1 (byte) keyboard_key_pressed::key#0
Identical Phi Values (byte) keyboard_get_keycode::ch#1 (byte) keyboard_get_keycode::ch#0
Identical Phi Values (byte*) main::screen#10 (byte*) main::screen#13
Identical Phi Values (byte) main::row#3 (byte) main::row#2
Identical Phi Values (byte*) main::screen#11 (byte*) main::screen#2
Identical Phi Values (byte*) main::screen#8 (byte*) main::screen#11
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$1 [92] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2
Simple Condition (bool~) main::$2 [99] if(*((byte*) RASTER)!=(byte) $ff) goto main::@10
Simple Condition (bool~) main::$5 [113] if((byte~) main::$4!=(byte) 0) goto main::@14
Simple Condition (bool~) main::$7 [123] if((byte) main::col#1!=rangelast(0,7)) goto main::@13
Simple Condition (bool~) main::$9 [129] if((byte) main::row#1!=rangelast(0,7)) goto main::@12
Simple Condition (bool~) main::$13 [144] if((byte) main::key#0==(byte) $3f) goto main::@21
Simple Condition (bool~) main::$17 [148] if((byte) main::ch#1!=rangelast(0,$3f)) goto main::@20
Simple Condition (bool~) main::$16 [157] if((byte~) main::$14==(byte) 0) goto main::@21
Simple Condition (bool~) main::$18 [165] if((byte) main::i#2<(byte) 5) goto main::@26
Successful SSA optimization Pass2ConditionalJumpSimplification
Identified constant from value list (byte[8]) { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
Identified constant from value list (byte[8]) { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
Successful SSA optimization Pass2ConstantInitializerValueLists
Constant (const byte*) RASTER = (byte*) 53266
Constant (const byte*) CIA1_PORT_A = (byte*) 56320
Constant (const byte*) CIA1_PORT_B = (byte*) 56321
Constant (const byte*) CIA1_PORT_A_DDR = (byte*) 56322
Constant (const byte*) CIA1_PORT_B_DDR = (byte*) 56323
Constant (const byte) KEY_3 = 8
Constant (const byte) KEY_W = 9
Constant (const byte) KEY_A = $a
Constant (const byte) KEY_4 = $b
Constant (const byte) KEY_Z = $c
Constant (const byte) KEY_S = $d
Constant (const byte) KEY_E = $e
Constant (const byte) KEY_5 = $10
Constant (const byte) KEY_R = $11
Constant (const byte) KEY_D = $12
Constant (const byte) KEY_6 = $13
Constant (const byte) KEY_C = $14
Constant (const byte) KEY_F = $15
Constant (const byte) KEY_T = $16
Constant (const byte) KEY_X = $17
Constant (const byte) KEY_7 = $18
Constant (const byte) KEY_Y = $19
Constant (const byte) KEY_G = $1a
Constant (const byte) KEY_8 = $1b
Constant (const byte) KEY_B = $1c
Constant (const byte) KEY_H = $1d
Constant (const byte) KEY_U = $1e
Constant (const byte) KEY_V = $1f
Constant (const byte) KEY_9 = $20
Constant (const byte) KEY_I = $21
Constant (const byte) KEY_J = $22
Constant (const byte) KEY_0 = $23
Constant (const byte) KEY_M = $24
Constant (const byte) KEY_K = $25
Constant (const byte) KEY_O = $26
Constant (const byte) KEY_N = $27
Constant (const byte) KEY_PLUS = $28
Constant (const byte) KEY_P = $29
Constant (const byte) KEY_L = $2a
Constant (const byte) KEY_MINUS = $2b
Constant (const byte) KEY_DOT = $2c
Constant (const byte) KEY_COLON = $2d
Constant (const byte) KEY_AT = $2e
Constant (const byte) KEY_COMMA = $2f
Constant (const byte) KEY_POUND = $30
Constant (const byte) KEY_ASTERISK = $31
Constant (const byte) KEY_SEMICOLON = $32
Constant (const byte) KEY_EQUALS = $35
Constant (const byte) KEY_ARROW_UP = $36
Constant (const byte) KEY_SLASH = $37
Constant (const byte) KEY_1 = $38
Constant (const byte) KEY_ARROW_LEFT = $39
Constant (const byte) KEY_2 = $3b
Constant (const byte) KEY_SPACE = $3c
Constant (const byte) KEY_Q = $3e
Constant (const byte[8]) keyboard_matrix_row_bitmask = { $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f }
Constant (const byte[8]) keyboard_matrix_col_bitmask = { 1, 2, 4, 8, $10, $20, $40, $80 }
Constant (const byte*) main::sc#0 = (byte*) 1024
Constant (const byte*) main::screen#0 = (byte*) 1024
Constant (const byte) main::row#0 = 0
Constant (const byte) main::col#0 = 0
Constant (const byte) main::i#0 = 0
Constant (const byte) main::ch#0 = 0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [97] if(true) goto main::@10
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [121] main::col#1 ← ++ main::col#2 to ++
Resolved ranged comparison value [123] if(main::col#1!=rangelast(0,7)) goto main::@13 to (number) 8
Resolved ranged next value [127] main::row#1 ← ++ main::row#2 to ++
Resolved ranged comparison value [129] if(main::row#1!=rangelast(0,7)) goto main::@12 to (number) 8
Resolved ranged next value [146] main::ch#1 ← ++ main::ch#2 to ++
Resolved ranged comparison value [148] if(main::ch#1!=rangelast(0,$3f)) goto main::@20 to (number) $40
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 8 in if((byte) main::col#1!=(number) 8) goto main::@13
Adding number conversion cast (unumber) 8 in if((byte) main::row#1!=(number) 8) goto main::@12
Adding number conversion cast (unumber) $40 in if((byte) main::ch#1!=(number) $40) goto main::@20
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Simplifying constant integer cast 8
Simplifying constant integer cast $40
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $40
Successful SSA optimization PassNFinalizeNumberTypeConversions
Identified constant from value list (byte[]) { (const byte) KEY_AT, (const byte) KEY_A, (const byte) KEY_B, (const byte) KEY_C, (const byte) KEY_D, (const byte) KEY_E, (const byte) KEY_F, (const byte) KEY_G, (const byte) KEY_H, (const byte) KEY_I, (const byte) KEY_J, (const byte) KEY_K, (const byte) KEY_L, (const byte) KEY_M, (const byte) KEY_N, (const byte) KEY_O, (const byte) KEY_P, (const byte) KEY_Q, (const byte) KEY_R, (const byte) KEY_S, (const byte) KEY_T, (const byte) KEY_U, (const byte) KEY_V, (const byte) KEY_W, (const byte) KEY_X, (const byte) KEY_Y, (const byte) KEY_Z, (byte) $3f, (const byte) KEY_POUND, (byte) $3f, (const byte) KEY_ARROW_UP, (const byte) KEY_ARROW_LEFT, (const byte) KEY_SPACE, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (const byte) KEY_ASTERISK, (const byte) KEY_PLUS, (const byte) KEY_COMMA, (const byte) KEY_MINUS, (const byte) KEY_DOT, (const byte) KEY_SLASH, (const byte) KEY_0, (const byte) KEY_1, (const byte) KEY_2, (const byte) KEY_3, (const byte) KEY_4, (const byte) KEY_5, (const byte) KEY_6, (const byte) KEY_7, (const byte) KEY_8, (const byte) KEY_9, (const byte) KEY_COLON, (const byte) KEY_SEMICOLON, (byte) $3f, (const byte) KEY_EQUALS, (byte) $3f, (byte) $3f }
Successful SSA optimization Pass2ConstantInitializerValueLists
Constant (const byte[]) keyboard_char_keycodes = { KEY_AT, KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, $3f, KEY_POUND, $3f, KEY_ARROW_UP, KEY_ARROW_LEFT, KEY_SPACE, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, KEY_ASTERISK, KEY_PLUS, KEY_COMMA, KEY_MINUS, KEY_DOT, KEY_SLASH, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_COLON, KEY_SEMICOLON, $3f, KEY_EQUALS, $3f, $3f }
Successful SSA optimization Pass2ConstantIdentification
Rewriting multiplication to use shift [33] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 * (byte) 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte*) main::sc#0
Inlining constant with var siblings (const byte*) main::screen#0
Inlining constant with var siblings (const byte) main::row#0
Inlining constant with var siblings (const byte) main::col#0
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with var siblings (const byte) main::ch#0
Constant inlined main::screen#0 = (byte*) 1024
Constant inlined main::col#0 = (byte) 0
Constant inlined main::i#0 = (byte) 0
Constant inlined main::sc#0 = (byte*) 1024
Constant inlined main::row#0 = (byte) 0
Constant inlined main::ch#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@35(between main::@18 and main::@12)
Added new block during phi lifting main::@36(between main::@15 and main::@13)
Added new block during phi lifting main::@37(between main::@21 and main::@20)
Added new block during phi lifting main::@38(between main::@33 and main::@21)
Added new block during phi lifting main::@39(between main::@34 and main::@21)
Added new block during phi lifting main::@40(between main::@21 and main::@26)
Added new block during phi lifting main::@41(between main::@26 and main::@26)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @12
Adding NOP phi() at start of @13
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@31
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@11
CALL GRAPH
Calls in [] to main:3 
Calls in [main] to keyboard_init:10 keyboard_matrix_read:18 keyboard_get_keycode:35 keyboard_key_pressed:40 
Calls in [keyboard_key_pressed] to keyboard_matrix_read:72 

Created 10 initial phi equivalence classes
Coalesced [17] keyboard_matrix_read::rowid#4 ← keyboard_matrix_read::rowid#1
Coalesced [21] main::row_pressed_bits#7 ← main::row_pressed_bits#0
Coalesced [46] main::i#11 ← main::i#1
Coalesced [50] main::i#14 ← main::i#6
Coalesced [55] main::i#15 ← main::i#2
Coalesced [56] main::ch#8 ← main::ch#1
Coalesced [57] main::i#10 ← main::i#6
Coalesced (already) [58] main::i#13 ← main::i#3
Coalesced (already) [59] main::i#12 ← main::i#3
Coalesced [60] main::row#9 ← main::row#1
Coalesced [61] main::screen#18 ← main::screen#1
Coalesced [62] main::row_pressed_bits#6 ← main::row_pressed_bits#1
Coalesced [63] main::col#6 ← main::col#1
Coalesced [67] main::sc#4 ← main::sc#1
Coalesced [71] keyboard_matrix_read::rowid#3 ← keyboard_matrix_read::rowid#0
Coalesced down to 8 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @13
Culled Empty Block (label) main::@31
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@40
Culled Empty Block (label) main::@41
Culled Empty Block (label) main::@37
Culled Empty Block (label) main::@39
Culled Empty Block (label) main::@38
Culled Empty Block (label) main::@35
Culled Empty Block (label) main::@36
Renumbering block @12 to @1
Renumbering block keyboard_key_pressed::@2 to keyboard_key_pressed::@1
Renumbering block main::@10 to main::@4
Renumbering block main::@12 to main::@5
Renumbering block main::@13 to main::@6
Renumbering block main::@14 to main::@7
Renumbering block main::@15 to main::@8
Renumbering block main::@16 to main::@9
Renumbering block main::@18 to main::@10
Renumbering block main::@19 to main::@11
Renumbering block main::@20 to main::@12
Renumbering block main::@21 to main::@13
Renumbering block main::@23 to main::@14
Renumbering block main::@24 to main::@15
Renumbering block main::@26 to main::@16
Renumbering block main::@32 to main::@17
Renumbering block main::@33 to main::@18
Renumbering block main::@34 to main::@19
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [5] (byte*) main::sc#2 ← phi( main/(byte*) 1024 main::@2/(byte*) main::sc#1 )
  [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [7] phi()
  [8] call keyboard_init 
  to:main::@4
main::@4: scope:[main]  from main::@16 main::@3 main::@4
  [9] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@10 main::@4
  [10] (byte*) main::screen#13 ← phi( main::@4/(byte*) 1024 main::@10/(byte*) main::screen#1 )
  [10] (byte) main::row#2 ← phi( main::@4/(byte) 0 main::@10/(byte) main::row#1 )
  [11] (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2
  [12] call keyboard_matrix_read 
  [13] (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#0
  to:main::@17
main::@17: scope:[main]  from main::@5
  [14] (byte) main::row_pressed_bits#0 ← (byte) keyboard_matrix_read::return#3
  to:main::@6
main::@6: scope:[main]  from main::@17 main::@8
  [15] (byte) main::col#2 ← phi( main::@8/(byte) main::col#1 main::@17/(byte) 0 )
  [15] (byte) main::row_pressed_bits#2 ← phi( main::@8/(byte) main::row_pressed_bits#1 main::@17/(byte) main::row_pressed_bits#0 )
  [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80
  [17] if((byte~) main::$4!=(byte) 0) goto main::@7
  to:main::@9
main::@9: scope:[main]  from main::@6
  [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0'
  to:main::@8
main::@8: scope:[main]  from main::@7 main::@9
  [19] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 << (byte) 1
  [20] (byte) main::col#1 ← ++ (byte) main::col#2
  [21] if((byte) main::col#1!=(byte) 8) goto main::@6
  to:main::@10
main::@10: scope:[main]  from main::@8
  [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28
  [23] (byte) main::row#1 ← ++ (byte) main::row#2
  [24] if((byte) main::row#1!=(byte) 8) goto main::@5
  to:main::@11
main::@11: scope:[main]  from main::@10
  [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28
  to:main::@12
main::@12: scope:[main]  from main::@11 main::@13
  [26] (byte) main::i#3 ← phi( main::@11/(byte) 0 main::@13/(byte) main::i#6 )
  [26] (byte) main::ch#2 ← phi( main::@11/(byte) 0 main::@13/(byte) main::ch#1 )
  [27] (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2
  [28] call keyboard_get_keycode 
  [29] (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#0
  to:main::@18
main::@18: scope:[main]  from main::@12
  [30] (byte) main::key#0 ← (byte) keyboard_get_keycode::return#2
  [31] if((byte) main::key#0==(byte) $3f) goto main::@13
  to:main::@14
main::@14: scope:[main]  from main::@18
  [32] (byte) keyboard_key_pressed::key#0 ← (byte) main::key#0
  [33] call keyboard_key_pressed 
  [34] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
  to:main::@19
main::@19: scope:[main]  from main::@14
  [35] (byte~) main::$14 ← (byte) keyboard_key_pressed::return#2
  [36] if((byte~) main::$14==(byte) 0) goto main::@13
  to:main::@15
main::@15: scope:[main]  from main::@19
  [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2
  [38] (byte) main::i#1 ← ++ (byte) main::i#3
  to:main::@13
main::@13: scope:[main]  from main::@15 main::@18 main::@19
  [39] (byte) main::i#6 ← phi( main::@15/(byte) main::i#1 main::@18/(byte) main::i#3 main::@19/(byte) main::i#3 )
  [40] (byte) main::ch#1 ← ++ (byte) main::ch#2
  [41] if((byte) main::ch#1!=(byte) $40) goto main::@12
  to:main::@16
main::@16: scope:[main]  from main::@13 main::@16
  [42] (byte) main::i#4 ← phi( main::@13/(byte) main::i#6 main::@16/(byte) main::i#2 )
  [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' '
  [44] (byte) main::i#2 ← ++ (byte) main::i#4
  [45] if((byte) main::i#2<(byte) 5) goto main::@16
  to:main::@4
main::@7: scope:[main]  from main::@6
  [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1'
  to:main::@8
main::@2: scope:[main]  from main::@1
  [47] *((byte*) main::sc#2) ← (byte) ' '
  [48] (byte*) main::sc#1 ← ++ (byte*) main::sc#2
  to:main::@1

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from main::@14
  [49] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#0 & (byte) 7
  [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3
  [51] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  [52] call keyboard_matrix_read 
  [53] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  [54] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
  [55] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0)
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  [56] return 
  to:@return

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed main::@5
  [57] (byte) keyboard_matrix_read::rowid#2 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::rowid#0 main::@5/(byte) keyboard_matrix_read::rowid#1 )
  [58] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2)
  [59] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B)
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  [60] return 
  to:@return

(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
keyboard_get_keycode: scope:[keyboard_get_keycode]  from main::@12
  [61] (byte) keyboard_get_keycode::return#0 ← *((const byte[]) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#0)
  to:keyboard_get_keycode::@return
keyboard_get_keycode::@return: scope:[keyboard_get_keycode]  from keyboard_get_keycode
  [62] return 
  to:@return

(void()) keyboard_init()
keyboard_init: scope:[keyboard_init]  from main::@3
  [63] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff
  [64] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0
  to:keyboard_init::@return
keyboard_init::@return: scope:[keyboard_init]  from keyboard_init
  [65] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
(byte) keyboard_get_keycode::ch
(byte) keyboard_get_keycode::ch#0 103.0
(byte) keyboard_get_keycode::return
(byte) keyboard_get_keycode::return#0 34.33333333333333
(byte) keyboard_get_keycode::return#2 202.0
(void()) keyboard_init()
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 4.0
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0 0.6666666666666666
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0 52.5
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 34.33333333333333
(byte) keyboard_key_pressed::return#2 202.0
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0 4.0
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 26.25
(byte) keyboard_matrix_read::return#2 4.0
(byte) keyboard_matrix_read::return#3 202.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0 4.0
(byte) keyboard_matrix_read::rowid#1 202.0
(byte) keyboard_matrix_read::rowid#2 105.0
(void()) main()
(byte~) main::$14 202.0
(byte~) main::$4 2002.0
(byte) main::ch
(byte) main::ch#1 151.5
(byte) main::ch#2 28.857142857142858
(byte) main::col
(byte) main::col#1 1501.5
(byte) main::col#2 667.3333333333334
(byte) main::i
(byte) main::i#1 202.0
(byte) main::i#2 151.5
(byte) main::i#3 42.08333333333333
(byte) main::i#4 202.0
(byte) main::i#6 168.33333333333331
(byte) main::key
(byte) main::key#0 151.5
(byte) main::row
(byte) main::row#1 151.5
(byte) main::row#2 21.642857142857142
(byte) main::row_pressed_bits
(byte) main::row_pressed_bits#0 202.0
(byte) main::row_pressed_bits#1 667.3333333333334
(byte) main::row_pressed_bits#2 620.8
(byte*) main::sc
(byte*) main::sc#1 22.0
(byte*) main::sc#2 14.666666666666666
(byte*) main::screen
(byte*) main::screen#1 71.0
(byte*) main::screen#13 169.53846153846155
(byte*) main::screen#2 10.142857142857142

Initial phi equivalence classes
[ main::sc#2 main::sc#1 ]
[ main::row#2 main::row#1 ]
[ main::screen#13 main::screen#1 ]
[ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
[ main::col#2 main::col#1 ]
[ main::ch#2 main::ch#1 ]
[ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
[ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ]
Added variable keyboard_matrix_read::return#3 to zero page equivalence class [ keyboard_matrix_read::return#3 ]
Added variable main::$4 to zero page equivalence class [ main::$4 ]
Added variable main::screen#2 to zero page equivalence class [ main::screen#2 ]
Added variable keyboard_get_keycode::ch#0 to zero page equivalence class [ keyboard_get_keycode::ch#0 ]
Added variable keyboard_get_keycode::return#2 to zero page equivalence class [ keyboard_get_keycode::return#2 ]
Added variable main::key#0 to zero page equivalence class [ main::key#0 ]
Added variable keyboard_key_pressed::key#0 to zero page equivalence class [ keyboard_key_pressed::key#0 ]
Added variable keyboard_key_pressed::return#2 to zero page equivalence class [ keyboard_key_pressed::return#2 ]
Added variable main::$14 to zero page equivalence class [ main::$14 ]
Added variable keyboard_key_pressed::colidx#0 to zero page equivalence class [ keyboard_key_pressed::colidx#0 ]
Added variable keyboard_key_pressed::rowidx#0 to zero page equivalence class [ keyboard_key_pressed::rowidx#0 ]
Added variable keyboard_matrix_read::return#2 to zero page equivalence class [ keyboard_matrix_read::return#2 ]
Added variable keyboard_key_pressed::$2 to zero page equivalence class [ keyboard_key_pressed::$2 ]
Added variable keyboard_key_pressed::return#0 to zero page equivalence class [ keyboard_key_pressed::return#0 ]
Added variable keyboard_matrix_read::return#0 to zero page equivalence class [ keyboard_matrix_read::return#0 ]
Added variable keyboard_get_keycode::return#0 to zero page equivalence class [ keyboard_get_keycode::return#0 ]
Complete equivalence classes
[ main::sc#2 main::sc#1 ]
[ main::row#2 main::row#1 ]
[ main::screen#13 main::screen#1 ]
[ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
[ main::col#2 main::col#1 ]
[ main::ch#2 main::ch#1 ]
[ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
[ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ]
[ keyboard_matrix_read::return#3 ]
[ main::$4 ]
[ main::screen#2 ]
[ keyboard_get_keycode::ch#0 ]
[ keyboard_get_keycode::return#2 ]
[ main::key#0 ]
[ keyboard_key_pressed::key#0 ]
[ keyboard_key_pressed::return#2 ]
[ main::$14 ]
[ keyboard_key_pressed::colidx#0 ]
[ keyboard_key_pressed::rowidx#0 ]
[ keyboard_matrix_read::return#2 ]
[ keyboard_key_pressed::$2 ]
[ keyboard_key_pressed::return#0 ]
[ keyboard_matrix_read::return#0 ]
[ keyboard_get_keycode::return#0 ]
Allocated zp ZP_WORD:2 [ main::sc#2 main::sc#1 ]
Allocated zp ZP_BYTE:4 [ main::row#2 main::row#1 ]
Allocated zp ZP_WORD:5 [ main::screen#13 main::screen#1 ]
Allocated zp ZP_BYTE:7 [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
Allocated zp ZP_BYTE:8 [ main::col#2 main::col#1 ]
Allocated zp ZP_BYTE:9 [ main::ch#2 main::ch#1 ]
Allocated zp ZP_BYTE:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
Allocated zp ZP_BYTE:11 [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ]
Allocated zp ZP_BYTE:12 [ keyboard_matrix_read::return#3 ]
Allocated zp ZP_BYTE:13 [ main::$4 ]
Allocated zp ZP_WORD:14 [ main::screen#2 ]
Allocated zp ZP_BYTE:16 [ keyboard_get_keycode::ch#0 ]
Allocated zp ZP_BYTE:17 [ keyboard_get_keycode::return#2 ]
Allocated zp ZP_BYTE:18 [ main::key#0 ]
Allocated zp ZP_BYTE:19 [ keyboard_key_pressed::key#0 ]
Allocated zp ZP_BYTE:20 [ keyboard_key_pressed::return#2 ]
Allocated zp ZP_BYTE:21 [ main::$14 ]
Allocated zp ZP_BYTE:22 [ keyboard_key_pressed::colidx#0 ]
Allocated zp ZP_BYTE:23 [ keyboard_key_pressed::rowidx#0 ]
Allocated zp ZP_BYTE:24 [ keyboard_matrix_read::return#2 ]
Allocated zp ZP_BYTE:25 [ keyboard_key_pressed::$2 ]
Allocated zp ZP_BYTE:26 [ keyboard_key_pressed::return#0 ]
Allocated zp ZP_BYTE:27 [ keyboard_matrix_read::return#0 ]
Allocated zp ZP_BYTE:28 [ keyboard_get_keycode::return#0 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Test keyboard input - in the keyboard matrix and mapping screen codes to key codes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label RASTER = $d012
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  // CIA #1 Port A data direction register.
  .label CIA1_PORT_A_DDR = $dc02
  // CIA #1 Port B data direction register.
  .label CIA1_PORT_B_DDR = $dc03
  .const KEY_3 = 8
  .const KEY_W = 9
  .const KEY_A = $a
  .const KEY_4 = $b
  .const KEY_Z = $c
  .const KEY_S = $d
  .const KEY_E = $e
  .const KEY_5 = $10
  .const KEY_R = $11
  .const KEY_D = $12
  .const KEY_6 = $13
  .const KEY_C = $14
  .const KEY_F = $15
  .const KEY_T = $16
  .const KEY_X = $17
  .const KEY_7 = $18
  .const KEY_Y = $19
  .const KEY_G = $1a
  .const KEY_8 = $1b
  .const KEY_B = $1c
  .const KEY_H = $1d
  .const KEY_U = $1e
  .const KEY_V = $1f
  .const KEY_9 = $20
  .const KEY_I = $21
  .const KEY_J = $22
  .const KEY_0 = $23
  .const KEY_M = $24
  .const KEY_K = $25
  .const KEY_O = $26
  .const KEY_N = $27
  .const KEY_PLUS = $28
  .const KEY_P = $29
  .const KEY_L = $2a
  .const KEY_MINUS = $2b
  .const KEY_DOT = $2c
  .const KEY_COLON = $2d
  .const KEY_AT = $2e
  .const KEY_COMMA = $2f
  .const KEY_POUND = $30
  .const KEY_ASTERISK = $31
  .const KEY_SEMICOLON = $32
  .const KEY_EQUALS = $35
  .const KEY_ARROW_UP = $36
  .const KEY_SLASH = $37
  .const KEY_1 = $38
  .const KEY_ARROW_LEFT = $39
  .const KEY_2 = $3b
  .const KEY_SPACE = $3c
  .const KEY_Q = $3e
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label __4 = $d
    .label __14 = $15
    .label sc = 2
    .label row_pressed_bits = 7
    .label col = 8
    .label screen = 5
    .label row = 4
    .label screen_2 = $e
    .label key = $12
    .label ch = 9
    .label i = $a
    // [5] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [5] phi (byte*) main::sc#2 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z sc
    lda #>$400
    sta.z sc+1
    jmp __b1
  // Clear screen
    // main::@1
  __b1:
    // [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 -- pbuz1_lt_vwuc1_then_la1 
    lda.z sc+1
    cmp #>$400+$3e8
    bcc __b2
    bne !+
    lda.z sc
    cmp #<$400+$3e8
    bcc __b2
  !:
    // [7] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [8] call keyboard_init 
    jsr keyboard_init
    jmp __b4
    // main::@4
  __b4:
    // [9] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@4 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b4
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    // [10] phi (byte*) main::screen#13 = (byte*) 1024 [phi:main::@4->main::@5#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z screen
    lda #>$400
    sta.z screen+1
    // [10] phi (byte) main::row#2 = (byte) 0 [phi:main::@4->main::@5#1] -- vbuz1=vbuc1 
    lda #0
    sta.z row
    jmp __b5
  // Read & print keyboard matrix
    // [10] phi from main::@10 to main::@5 [phi:main::@10->main::@5]
  __b5_from___b10:
    // [10] phi (byte*) main::screen#13 = (byte*) main::screen#1 [phi:main::@10->main::@5#0] -- register_copy 
    // [10] phi (byte) main::row#2 = (byte) main::row#1 [phi:main::@10->main::@5#1] -- register_copy 
    jmp __b5
    // main::@5
  __b5:
    // [11] (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2 -- vbuz1=vbuz2 
    lda.z row
    sta.z keyboard_matrix_read.rowid
    // [12] call keyboard_matrix_read 
    // [57] phi from main::@5 to keyboard_matrix_read [phi:main::@5->keyboard_matrix_read]
  keyboard_matrix_read_from___b5:
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#1 [phi:main::@5->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // [13] (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return
    sta.z keyboard_matrix_read.return_3
    jmp __b17
    // main::@17
  __b17:
    // [14] (byte) main::row_pressed_bits#0 ← (byte) keyboard_matrix_read::return#3 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return_3
    sta.z row_pressed_bits
    // [15] phi from main::@17 to main::@6 [phi:main::@17->main::@6]
  __b6_from___b17:
    // [15] phi (byte) main::col#2 = (byte) 0 [phi:main::@17->main::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta.z col
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#0 [phi:main::@17->main::@6#1] -- register_copy 
    jmp __b6
    // [15] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
  __b6_from___b8:
    // [15] phi (byte) main::col#2 = (byte) main::col#1 [phi:main::@8->main::@6#0] -- register_copy 
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#1 [phi:main::@8->main::@6#1] -- register_copy 
    jmp __b6
    // main::@6
  __b6:
    // [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and.z row_pressed_bits
    sta.z __4
    // [17] if((byte~) main::$4!=(byte) 0) goto main::@7 -- vbuz1_neq_0_then_la1 
    lda.z __4
    cmp #0
    bne __b7
    jmp __b9
    // main::@9
  __b9:
    // [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' -- pbuz1_derefidx_vbuz2=vbuc1 
    lda #'0'
    ldy.z col
    sta (screen),y
    jmp __b8
    // main::@8
  __b8:
    // [19] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z row_pressed_bits
    // [20] (byte) main::col#1 ← ++ (byte) main::col#2 -- vbuz1=_inc_vbuz1 
    inc.z col
    // [21] if((byte) main::col#1!=(byte) 8) goto main::@6 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z col
    bne __b6_from___b8
    jmp __b10
    // main::@10
  __b10:
    // [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [23] (byte) main::row#1 ← ++ (byte) main::row#2 -- vbuz1=_inc_vbuz1 
    inc.z row
    // [24] if((byte) main::row#1!=(byte) 8) goto main::@5 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z row
    bne __b5_from___b10
    jmp __b11
    // main::@11
  __b11:
    // [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 -- pbuz1=pbuz2_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen_2
    lda #0
    adc.z screen+1
    sta.z screen_2+1
    // [26] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  __b12_from___b11:
    // [26] phi (byte) main::i#3 = (byte) 0 [phi:main::@11->main::@12#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [26] phi (byte) main::ch#2 = (byte) 0 [phi:main::@11->main::@12#1] -- vbuz1=vbuc1 
    lda #0
    sta.z ch
    jmp __b12
    // [26] phi from main::@13 to main::@12 [phi:main::@13->main::@12]
  __b12_from___b13:
    // [26] phi (byte) main::i#3 = (byte) main::i#6 [phi:main::@13->main::@12#0] -- register_copy 
    // [26] phi (byte) main::ch#2 = (byte) main::ch#1 [phi:main::@13->main::@12#1] -- register_copy 
    jmp __b12
    // main::@12
  __b12:
    // [27] (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2 -- vbuz1=vbuz2 
    lda.z ch
    sta.z keyboard_get_keycode.ch
    // [28] call keyboard_get_keycode 
    jsr keyboard_get_keycode
    // [29] (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_get_keycode.return
    sta.z keyboard_get_keycode.return_2
    jmp __b18
    // main::@18
  __b18:
    // [30] (byte) main::key#0 ← (byte) keyboard_get_keycode::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_get_keycode.return_2
    sta.z key
    // [31] if((byte) main::key#0==(byte) $3f) goto main::@13 -- vbuz1_eq_vbuc1_then_la1 
    lda #$3f
    cmp.z key
    beq __b13_from___b18
    jmp __b14
    // main::@14
  __b14:
    // [32] (byte) keyboard_key_pressed::key#0 ← (byte) main::key#0 -- vbuz1=vbuz2 
    lda.z key
    sta.z keyboard_key_pressed.key
    // [33] call keyboard_key_pressed 
    jsr keyboard_key_pressed
    // [34] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_2
    jmp __b19
    // main::@19
  __b19:
    // [35] (byte~) main::$14 ← (byte) keyboard_key_pressed::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_2
    sta.z __14
    // [36] if((byte~) main::$14==(byte) 0) goto main::@13 -- vbuz1_eq_0_then_la1 
    lda.z __14
    cmp #0
    beq __b13_from___b19
    jmp __b15
    // main::@15
  __b15:
    // [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2 -- pbuz1_derefidx_vbuz2=vbuz3 
    lda.z ch
    ldy.z i
    sta (screen_2),y
    // [38] (byte) main::i#1 ← ++ (byte) main::i#3 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [39] phi from main::@15 main::@18 main::@19 to main::@13 [phi:main::@15/main::@18/main::@19->main::@13]
  __b13_from___b15:
  __b13_from___b18:
  __b13_from___b19:
    // [39] phi (byte) main::i#6 = (byte) main::i#1 [phi:main::@15/main::@18/main::@19->main::@13#0] -- register_copy 
    jmp __b13
    // main::@13
  __b13:
    // [40] (byte) main::ch#1 ← ++ (byte) main::ch#2 -- vbuz1=_inc_vbuz1 
    inc.z ch
    // [41] if((byte) main::ch#1!=(byte) $40) goto main::@12 -- vbuz1_neq_vbuc1_then_la1 
    lda #$40
    cmp.z ch
    bne __b12_from___b13
    // [42] phi from main::@13 main::@16 to main::@16 [phi:main::@13/main::@16->main::@16]
  __b16_from___b13:
  __b16_from___b16:
    // [42] phi (byte) main::i#4 = (byte) main::i#6 [phi:main::@13/main::@16->main::@16#0] -- register_copy 
    jmp __b16
  // Add some spaces
    // main::@16
  __b16:
    // [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' -- pbuz1_derefidx_vbuz2=vbuc1 
    lda #' '
    ldy.z i
    sta (screen_2),y
    // [44] (byte) main::i#2 ← ++ (byte) main::i#4 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [45] if((byte) main::i#2<(byte) 5) goto main::@16 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #5
    bcc __b16_from___b16
    jmp __b4
    // main::@7
  __b7:
    // [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' -- pbuz1_derefidx_vbuz2=vbuc1 
    lda #'1'
    ldy.z col
    sta (screen),y
    jmp __b8
    // main::@2
  __b2:
    // [47] *((byte*) main::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [48] (byte*) main::sc#1 ← ++ (byte*) main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [5] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [5] phi (byte*) main::sc#2 = (byte*) main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte zeropage($13) key)
keyboard_key_pressed: {
    .label __2 = $19
    .label colidx = $16
    .label rowidx = $17
    .label return = $1a
    .label key = $13
    .label return_2 = $14
    // [49] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#0 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z key
    sta.z colidx
    // [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z key
    lsr
    lsr
    lsr
    sta.z rowidx
    // [51] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuz1=vbuz2 
    lda.z rowidx
    sta.z keyboard_matrix_read.rowid
    // [52] call keyboard_matrix_read 
    // [57] phi from keyboard_key_pressed to keyboard_matrix_read [phi:keyboard_key_pressed->keyboard_matrix_read]
  keyboard_matrix_read_from_keyboard_key_pressed:
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#0 [phi:keyboard_key_pressed->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // [53] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return
    sta.z keyboard_matrix_read.return_2
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [54] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return_2
    sta.z __2
    // [55] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0) -- vbuz1=vbuz2_band_pbuc1_derefidx_vbuz3 
    lda.z __2
    ldy.z colidx
    and keyboard_matrix_col_bitmask,y
    sta.z return
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [56] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte zeropage($b) rowid)
keyboard_matrix_read: {
    .label return = $1b
    .label rowid = $b
    .label return_2 = $18
    .label return_3 = $c
    // [58] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) -- _deref_pbuc1=pbuc2_derefidx_vbuz1 
    ldy.z rowid
    lda keyboard_matrix_row_bitmask,y
    sta CIA1_PORT_A
    // [59] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuz1=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    sta.z return
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [60] return 
    rts
}
  // keyboard_get_keycode
// Get the keycode corresponding to a specific screen code character
// ch is the character to get the key code for ($00-$3f)
// Returns the key code corresponding to the passed character. Only characters with a non-shifted key are handled.
// If there is no non-shifted key representing the char $3f is returned (representing RUN/STOP) .
// keyboard_get_keycode(byte zeropage($10) ch)
keyboard_get_keycode: {
    .label return = $1c
    .label ch = $10
    .label return_2 = $11
    // [61] (byte) keyboard_get_keycode::return#0 ← *((const byte[]) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z ch
    lda keyboard_char_keycodes,y
    sta.z return
    jmp __breturn
    // keyboard_get_keycode::@return
  __breturn:
    // [62] return 
    rts
}
  // keyboard_init
// Initialize keyboard reading by setting CIA#$ Data Direction Registers
keyboard_init: {
    // [63] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Write Mode
    lda #$ff
    sta CIA1_PORT_A_DDR
    // [64] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Read Mode
    lda #0
    sta CIA1_PORT_B_DDR
    jmp __breturn
    // keyboard_init::@return
  __breturn:
    // [65] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80
  // Keycodes for each screen code character from $00-$3f.
  // Chars that do not have an unmodified keycode return $3f (representing RUN/STOP).
  keyboard_char_keycodes: .byte KEY_AT, KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, $3f, KEY_POUND, $3f, KEY_ARROW_UP, KEY_ARROW_LEFT, KEY_SPACE, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, KEY_ASTERISK, KEY_PLUS, KEY_COMMA, KEY_MINUS, KEY_DOT, KEY_SLASH, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_COLON, KEY_SEMICOLON, $3f, KEY_EQUALS, $3f, $3f

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 [ main::sc#2 ] ( main:2 [ main::sc#2 ] ) always clobbers reg byte a 
Statement [9] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@4 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ main::row#2 main::row#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:8 [ main::col#2 main::col#1 ]
Statement [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 [ main::row#2 main::screen#1 ] ( main:2 [ main::row#2 main::screen#1 ] ) always clobbers reg byte a 
Statement [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 [ main::screen#2 ] ( main:2 [ main::screen#2 ] ) always clobbers reg byte a 
Statement [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' [ main::screen#2 main::i#4 ] ( main:2 [ main::screen#2 main::i#4 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
Statement [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ) always clobbers reg byte a 
Statement [47] *((byte*) main::sc#2) ← (byte) ' ' [ main::sc#2 ] ( main:2 [ main::sc#2 ] ) always clobbers reg byte a reg byte y 
Statement [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( main:2::keyboard_key_pressed:33 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ main::ch#2 main::ch#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:22 [ keyboard_key_pressed::colidx#0 ]
Statement [58] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) [ ] ( main:2::keyboard_matrix_read:12 [ main::row#2 main::screen#13 ] main:2::keyboard_key_pressed:33::keyboard_matrix_read:52 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 ] ) always clobbers reg byte a 
Statement [59] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:2::keyboard_matrix_read:12 [ main::row#2 main::screen#13 keyboard_matrix_read::return#0 ] main:2::keyboard_key_pressed:33::keyboard_matrix_read:52 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] ) always clobbers reg byte a 
Statement [63] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff [ ] ( main:2::keyboard_init:8 [ ] ) always clobbers reg byte a 
Statement [64] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0 [ ] ( main:2::keyboard_init:8 [ ] ) always clobbers reg byte a 
Statement [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 [ main::sc#2 ] ( main:2 [ main::sc#2 ] ) always clobbers reg byte a 
Statement [9] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@4 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 main::$4 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 main::$4 ] ) always clobbers reg byte a 
Statement [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ) always clobbers reg byte a 
Statement [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 [ main::row#2 main::screen#1 ] ( main:2 [ main::row#2 main::screen#1 ] ) always clobbers reg byte a 
Statement [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 [ main::screen#2 ] ( main:2 [ main::screen#2 ] ) always clobbers reg byte a 
Statement [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2 [ main::screen#2 main::ch#2 main::i#3 ] ( main:2 [ main::screen#2 main::ch#2 main::i#3 ] ) always clobbers reg byte a 
Statement [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' [ main::screen#2 main::i#4 ] ( main:2 [ main::screen#2 main::i#4 ] ) always clobbers reg byte a 
Statement [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ) always clobbers reg byte a 
Statement [47] *((byte*) main::sc#2) ← (byte) ' ' [ main::sc#2 ] ( main:2 [ main::sc#2 ] ) always clobbers reg byte a reg byte y 
Statement [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( main:2::keyboard_key_pressed:33 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ) always clobbers reg byte a 
Statement [58] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) [ ] ( main:2::keyboard_matrix_read:12 [ main::row#2 main::screen#13 ] main:2::keyboard_key_pressed:33::keyboard_matrix_read:52 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 ] ) always clobbers reg byte a 
Statement [59] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:2::keyboard_matrix_read:12 [ main::row#2 main::screen#13 keyboard_matrix_read::return#0 ] main:2::keyboard_key_pressed:33::keyboard_matrix_read:52 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] ) always clobbers reg byte a 
Statement [63] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff [ ] ( main:2::keyboard_init:8 [ ] ) always clobbers reg byte a 
Statement [64] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0 [ ] ( main:2::keyboard_init:8 [ ] ) always clobbers reg byte a 
Potential registers zp ZP_WORD:2 [ main::sc#2 main::sc#1 ] : zp ZP_WORD:2 , 
Potential registers zp ZP_BYTE:4 [ main::row#2 main::row#1 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:5 [ main::screen#13 main::screen#1 ] : zp ZP_WORD:5 , 
Potential registers zp ZP_BYTE:7 [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ] : zp ZP_BYTE:7 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ main::col#2 main::col#1 ] : zp ZP_BYTE:8 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:9 [ main::ch#2 main::ch#1 ] : zp ZP_BYTE:9 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ] : zp ZP_BYTE:10 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:11 [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ] : zp ZP_BYTE:11 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:12 [ keyboard_matrix_read::return#3 ] : zp ZP_BYTE:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ main::$4 ] : zp ZP_BYTE:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:14 [ main::screen#2 ] : zp ZP_WORD:14 , 
Potential registers zp ZP_BYTE:16 [ keyboard_get_keycode::ch#0 ] : zp ZP_BYTE:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:17 [ keyboard_get_keycode::return#2 ] : zp ZP_BYTE:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:18 [ main::key#0 ] : zp ZP_BYTE:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:19 [ keyboard_key_pressed::key#0 ] : zp ZP_BYTE:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:20 [ keyboard_key_pressed::return#2 ] : zp ZP_BYTE:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:21 [ main::$14 ] : zp ZP_BYTE:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:22 [ keyboard_key_pressed::colidx#0 ] : zp ZP_BYTE:22 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:23 [ keyboard_key_pressed::rowidx#0 ] : zp ZP_BYTE:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:24 [ keyboard_matrix_read::return#2 ] : zp ZP_BYTE:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:25 [ keyboard_key_pressed::$2 ] : zp ZP_BYTE:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:26 [ keyboard_key_pressed::return#0 ] : zp ZP_BYTE:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:27 [ keyboard_matrix_read::return#0 ] : zp ZP_BYTE:27 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:28 [ keyboard_get_keycode::return#0 ] : zp ZP_BYTE:28 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 2,168.83: zp ZP_BYTE:8 [ main::col#2 main::col#1 ] 2,002: zp ZP_BYTE:13 [ main::$4 ] 1,490.13: zp ZP_BYTE:7 [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ] 765.92: zp ZP_BYTE:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ] 240.54: zp ZP_WORD:5 [ main::screen#13 main::screen#1 ] 202: zp ZP_BYTE:21 [ main::$14 ] 180.36: zp ZP_BYTE:9 [ main::ch#2 main::ch#1 ] 173.14: zp ZP_BYTE:4 [ main::row#2 main::row#1 ] 151.5: zp ZP_BYTE:18 [ main::key#0 ] 36.67: zp ZP_WORD:2 [ main::sc#2 main::sc#1 ] 10.14: zp ZP_WORD:14 [ main::screen#2 ] 
Uplift Scope [keyboard_matrix_read] 311: zp ZP_BYTE:11 [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ] 202: zp ZP_BYTE:12 [ keyboard_matrix_read::return#3 ] 26.25: zp ZP_BYTE:27 [ keyboard_matrix_read::return#0 ] 4: zp ZP_BYTE:24 [ keyboard_matrix_read::return#2 ] 
Uplift Scope [keyboard_get_keycode] 202: zp ZP_BYTE:17 [ keyboard_get_keycode::return#2 ] 103: zp ZP_BYTE:16 [ keyboard_get_keycode::ch#0 ] 34.33: zp ZP_BYTE:28 [ keyboard_get_keycode::return#0 ] 
Uplift Scope [keyboard_key_pressed] 202: zp ZP_BYTE:20 [ keyboard_key_pressed::return#2 ] 52.5: zp ZP_BYTE:19 [ keyboard_key_pressed::key#0 ] 34.33: zp ZP_BYTE:26 [ keyboard_key_pressed::return#0 ] 4: zp ZP_BYTE:23 [ keyboard_key_pressed::rowidx#0 ] 4: zp ZP_BYTE:25 [ keyboard_key_pressed::$2 ] 0.67: zp ZP_BYTE:22 [ keyboard_key_pressed::colidx#0 ] 
Uplift Scope [keyboard_init] 
Uplift Scope [] 

Uplifting [main] best 80258 combination reg byte y [ main::col#2 main::col#1 ] reg byte a [ main::$4 ] reg byte x [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ] reg byte x [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ] zp ZP_WORD:5 [ main::screen#13 main::screen#1 ] zp ZP_BYTE:21 [ main::$14 ] zp ZP_BYTE:9 [ main::ch#2 main::ch#1 ] zp ZP_BYTE:4 [ main::row#2 main::row#1 ] zp ZP_BYTE:18 [ main::key#0 ] zp ZP_WORD:2 [ main::sc#2 main::sc#1 ] zp ZP_WORD:14 [ main::screen#2 ] 
Limited combination testing to 100 combinations of 15552 possible.
Uplifting [keyboard_matrix_read] best 79240 combination reg byte y [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ] reg byte a [ keyboard_matrix_read::return#3 ] reg byte a [ keyboard_matrix_read::return#0 ] reg byte a [ keyboard_matrix_read::return#2 ] 
Limited combination testing to 100 combinations of 256 possible.
Uplifting [keyboard_get_keycode] best 78034 combination reg byte a [ keyboard_get_keycode::return#2 ] reg byte y [ keyboard_get_keycode::ch#0 ] reg byte a [ keyboard_get_keycode::return#0 ] 
Uplifting [keyboard_key_pressed] best 76825 combination reg byte a [ keyboard_key_pressed::return#2 ] reg byte y [ keyboard_key_pressed::key#0 ] reg byte a [ keyboard_key_pressed::return#0 ] reg byte a [ keyboard_key_pressed::rowidx#0 ] zp ZP_BYTE:25 [ keyboard_key_pressed::$2 ] zp ZP_BYTE:22 [ keyboard_key_pressed::colidx#0 ] 
Limited combination testing to 100 combinations of 3072 possible.
Uplifting [keyboard_init] best 76825 combination 
Uplifting [] best 76825 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:21 [ main::$14 ]
Uplifting [main] best 76225 combination reg byte a [ main::$14 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:9 [ main::ch#2 main::ch#1 ]
Uplifting [main] best 76225 combination zp ZP_BYTE:9 [ main::ch#2 main::ch#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:4 [ main::row#2 main::row#1 ]
Uplifting [main] best 76225 combination zp ZP_BYTE:4 [ main::row#2 main::row#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:18 [ main::key#0 ]
Uplifting [main] best 75525 combination reg byte a [ main::key#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:25 [ keyboard_key_pressed::$2 ]
Uplifting [keyboard_key_pressed] best 75519 combination reg byte a [ keyboard_key_pressed::$2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:22 [ keyboard_key_pressed::colidx#0 ]
Uplifting [keyboard_key_pressed] best 75519 combination zp ZP_BYTE:22 [ keyboard_key_pressed::colidx#0 ] 
Coalescing zero page register [ zp ZP_WORD:5 [ main::screen#13 main::screen#1 ] ] with [ zp ZP_WORD:14 [ main::screen#2 ] ] - score: 1
Coalescing zero page register [ zp ZP_BYTE:22 [ keyboard_key_pressed::colidx#0 ] ] with [ zp ZP_BYTE:4 [ main::row#2 main::row#1 ] ]
Allocated (was zp ZP_WORD:5) zp ZP_WORD:4 [ main::screen#13 main::screen#1 main::screen#2 ]
Allocated (was zp ZP_BYTE:9) zp ZP_BYTE:6 [ main::ch#2 main::ch#1 ]
Allocated (was zp ZP_BYTE:22) zp ZP_BYTE:7 [ keyboard_key_pressed::colidx#0 main::row#2 main::row#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test keyboard input - in the keyboard matrix and mapping screen codes to key codes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label RASTER = $d012
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  // CIA #1 Port A data direction register.
  .label CIA1_PORT_A_DDR = $dc02
  // CIA #1 Port B data direction register.
  .label CIA1_PORT_B_DDR = $dc03
  .const KEY_3 = 8
  .const KEY_W = 9
  .const KEY_A = $a
  .const KEY_4 = $b
  .const KEY_Z = $c
  .const KEY_S = $d
  .const KEY_E = $e
  .const KEY_5 = $10
  .const KEY_R = $11
  .const KEY_D = $12
  .const KEY_6 = $13
  .const KEY_C = $14
  .const KEY_F = $15
  .const KEY_T = $16
  .const KEY_X = $17
  .const KEY_7 = $18
  .const KEY_Y = $19
  .const KEY_G = $1a
  .const KEY_8 = $1b
  .const KEY_B = $1c
  .const KEY_H = $1d
  .const KEY_U = $1e
  .const KEY_V = $1f
  .const KEY_9 = $20
  .const KEY_I = $21
  .const KEY_J = $22
  .const KEY_0 = $23
  .const KEY_M = $24
  .const KEY_K = $25
  .const KEY_O = $26
  .const KEY_N = $27
  .const KEY_PLUS = $28
  .const KEY_P = $29
  .const KEY_L = $2a
  .const KEY_MINUS = $2b
  .const KEY_DOT = $2c
  .const KEY_COLON = $2d
  .const KEY_AT = $2e
  .const KEY_COMMA = $2f
  .const KEY_POUND = $30
  .const KEY_ASTERISK = $31
  .const KEY_SEMICOLON = $32
  .const KEY_EQUALS = $35
  .const KEY_ARROW_UP = $36
  .const KEY_SLASH = $37
  .const KEY_1 = $38
  .const KEY_ARROW_LEFT = $39
  .const KEY_2 = $3b
  .const KEY_SPACE = $3c
  .const KEY_Q = $3e
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label sc = 2
    .label screen = 4
    .label row = 7
    .label ch = 6
    // [5] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [5] phi (byte*) main::sc#2 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z sc
    lda #>$400
    sta.z sc+1
    jmp __b1
  // Clear screen
    // main::@1
  __b1:
    // [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 -- pbuz1_lt_vwuc1_then_la1 
    lda.z sc+1
    cmp #>$400+$3e8
    bcc __b2
    bne !+
    lda.z sc
    cmp #<$400+$3e8
    bcc __b2
  !:
    // [7] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [8] call keyboard_init 
    jsr keyboard_init
    jmp __b4
    // main::@4
  __b4:
    // [9] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@4 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b4
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    // [10] phi (byte*) main::screen#13 = (byte*) 1024 [phi:main::@4->main::@5#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z screen
    lda #>$400
    sta.z screen+1
    // [10] phi (byte) main::row#2 = (byte) 0 [phi:main::@4->main::@5#1] -- vbuz1=vbuc1 
    lda #0
    sta.z row
    jmp __b5
  // Read & print keyboard matrix
    // [10] phi from main::@10 to main::@5 [phi:main::@10->main::@5]
  __b5_from___b10:
    // [10] phi (byte*) main::screen#13 = (byte*) main::screen#1 [phi:main::@10->main::@5#0] -- register_copy 
    // [10] phi (byte) main::row#2 = (byte) main::row#1 [phi:main::@10->main::@5#1] -- register_copy 
    jmp __b5
    // main::@5
  __b5:
    // [11] (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2 -- vbuyy=vbuz1 
    ldy.z row
    // [12] call keyboard_matrix_read 
    // [57] phi from main::@5 to keyboard_matrix_read [phi:main::@5->keyboard_matrix_read]
  keyboard_matrix_read_from___b5:
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#1 [phi:main::@5->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // [13] (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#0
    jmp __b17
    // main::@17
  __b17:
    // [14] (byte) main::row_pressed_bits#0 ← (byte) keyboard_matrix_read::return#3 -- vbuxx=vbuaa 
    tax
    // [15] phi from main::@17 to main::@6 [phi:main::@17->main::@6]
  __b6_from___b17:
    // [15] phi (byte) main::col#2 = (byte) 0 [phi:main::@17->main::@6#0] -- vbuyy=vbuc1 
    ldy #0
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#0 [phi:main::@17->main::@6#1] -- register_copy 
    jmp __b6
    // [15] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
  __b6_from___b8:
    // [15] phi (byte) main::col#2 = (byte) main::col#1 [phi:main::@8->main::@6#0] -- register_copy 
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#1 [phi:main::@8->main::@6#1] -- register_copy 
    jmp __b6
    // main::@6
  __b6:
    // [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #$80
    // [17] if((byte~) main::$4!=(byte) 0) goto main::@7 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b7
    jmp __b9
    // main::@9
  __b9:
    // [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #'0'
    sta (screen),y
    jmp __b8
    // main::@8
  __b8:
    // [19] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 << (byte) 1 -- vbuxx=vbuxx_rol_1 
    txa
    asl
    tax
    // [20] (byte) main::col#1 ← ++ (byte) main::col#2 -- vbuyy=_inc_vbuyy 
    iny
    // [21] if((byte) main::col#1!=(byte) 8) goto main::@6 -- vbuyy_neq_vbuc1_then_la1 
    cpy #8
    bne __b6_from___b8
    jmp __b10
    // main::@10
  __b10:
    // [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [23] (byte) main::row#1 ← ++ (byte) main::row#2 -- vbuz1=_inc_vbuz1 
    inc.z row
    // [24] if((byte) main::row#1!=(byte) 8) goto main::@5 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z row
    bne __b5_from___b10
    jmp __b11
    // main::@11
  __b11:
    // [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [26] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  __b12_from___b11:
    // [26] phi (byte) main::i#3 = (byte) 0 [phi:main::@11->main::@12#0] -- vbuxx=vbuc1 
    ldx #0
    // [26] phi (byte) main::ch#2 = (byte) 0 [phi:main::@11->main::@12#1] -- vbuz1=vbuc1 
    lda #0
    sta.z ch
    jmp __b12
    // [26] phi from main::@13 to main::@12 [phi:main::@13->main::@12]
  __b12_from___b13:
    // [26] phi (byte) main::i#3 = (byte) main::i#6 [phi:main::@13->main::@12#0] -- register_copy 
    // [26] phi (byte) main::ch#2 = (byte) main::ch#1 [phi:main::@13->main::@12#1] -- register_copy 
    jmp __b12
    // main::@12
  __b12:
    // [27] (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2 -- vbuyy=vbuz1 
    ldy.z ch
    // [28] call keyboard_get_keycode 
    jsr keyboard_get_keycode
    // [29] (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#0
    jmp __b18
    // main::@18
  __b18:
    // [30] (byte) main::key#0 ← (byte) keyboard_get_keycode::return#2
    // [31] if((byte) main::key#0==(byte) $3f) goto main::@13 -- vbuaa_eq_vbuc1_then_la1 
    cmp #$3f
    beq __b13_from___b18
    jmp __b14
    // main::@14
  __b14:
    // [32] (byte) keyboard_key_pressed::key#0 ← (byte) main::key#0 -- vbuyy=vbuaa 
    tay
    // [33] call keyboard_key_pressed 
    jsr keyboard_key_pressed
    // [34] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    jmp __b19
    // main::@19
  __b19:
    // [35] (byte~) main::$14 ← (byte) keyboard_key_pressed::return#2
    // [36] if((byte~) main::$14==(byte) 0) goto main::@13 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b13_from___b19
    jmp __b15
    // main::@15
  __b15:
    // [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2 -- pbuz1_derefidx_vbuxx=vbuz2 
    txa
    tay
    lda.z ch
    sta (screen),y
    // [38] (byte) main::i#1 ← ++ (byte) main::i#3 -- vbuxx=_inc_vbuxx 
    inx
    // [39] phi from main::@15 main::@18 main::@19 to main::@13 [phi:main::@15/main::@18/main::@19->main::@13]
  __b13_from___b15:
  __b13_from___b18:
  __b13_from___b19:
    // [39] phi (byte) main::i#6 = (byte) main::i#1 [phi:main::@15/main::@18/main::@19->main::@13#0] -- register_copy 
    jmp __b13
    // main::@13
  __b13:
    // [40] (byte) main::ch#1 ← ++ (byte) main::ch#2 -- vbuz1=_inc_vbuz1 
    inc.z ch
    // [41] if((byte) main::ch#1!=(byte) $40) goto main::@12 -- vbuz1_neq_vbuc1_then_la1 
    lda #$40
    cmp.z ch
    bne __b12_from___b13
    // [42] phi from main::@13 main::@16 to main::@16 [phi:main::@13/main::@16->main::@16]
  __b16_from___b13:
  __b16_from___b16:
    // [42] phi (byte) main::i#4 = (byte) main::i#6 [phi:main::@13/main::@16->main::@16#0] -- register_copy 
    jmp __b16
  // Add some spaces
    // main::@16
  __b16:
    // [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' -- pbuz1_derefidx_vbuxx=vbuc1 
    txa
    tay
    lda #' '
    sta (screen),y
    // [44] (byte) main::i#2 ← ++ (byte) main::i#4 -- vbuxx=_inc_vbuxx 
    inx
    // [45] if((byte) main::i#2<(byte) 5) goto main::@16 -- vbuxx_lt_vbuc1_then_la1 
    cpx #5
    bcc __b16_from___b16
    jmp __b4
    // main::@7
  __b7:
    // [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #'1'
    sta (screen),y
    jmp __b8
    // main::@2
  __b2:
    // [47] *((byte*) main::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [48] (byte*) main::sc#1 ← ++ (byte*) main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [5] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [5] phi (byte*) main::sc#2 = (byte*) main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(Y) key)
keyboard_key_pressed: {
    .label colidx = 7
    // [49] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#0 & (byte) 7 -- vbuz1=vbuyy_band_vbuc1 
    tya
    and #7
    sta.z colidx
    // [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 -- vbuaa=vbuyy_ror_3 
    tya
    lsr
    lsr
    lsr
    // [51] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuyy=vbuaa 
    tay
    // [52] call keyboard_matrix_read 
    // [57] phi from keyboard_key_pressed to keyboard_matrix_read [phi:keyboard_key_pressed->keyboard_matrix_read]
  keyboard_matrix_read_from_keyboard_key_pressed:
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#0 [phi:keyboard_key_pressed->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // [53] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [54] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // [55] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuz1 
    ldy.z colidx
    and keyboard_matrix_col_bitmask,y
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [56] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(Y) rowid)
keyboard_matrix_read: {
    // [58] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) -- _deref_pbuc1=pbuc2_derefidx_vbuyy 
    lda keyboard_matrix_row_bitmask,y
    sta CIA1_PORT_A
    // [59] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [60] return 
    rts
}
  // keyboard_get_keycode
// Get the keycode corresponding to a specific screen code character
// ch is the character to get the key code for ($00-$3f)
// Returns the key code corresponding to the passed character. Only characters with a non-shifted key are handled.
// If there is no non-shifted key representing the char $3f is returned (representing RUN/STOP) .
// keyboard_get_keycode(byte register(Y) ch)
keyboard_get_keycode: {
    // [61] (byte) keyboard_get_keycode::return#0 ← *((const byte[]) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#0) -- vbuaa=pbuc1_derefidx_vbuyy 
    lda keyboard_char_keycodes,y
    jmp __breturn
    // keyboard_get_keycode::@return
  __breturn:
    // [62] return 
    rts
}
  // keyboard_init
// Initialize keyboard reading by setting CIA#$ Data Direction Registers
keyboard_init: {
    // [63] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Write Mode
    lda #$ff
    sta CIA1_PORT_A_DDR
    // [64] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Read Mode
    lda #0
    sta CIA1_PORT_B_DDR
    jmp __breturn
    // keyboard_init::@return
  __breturn:
    // [65] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80
  // Keycodes for each screen code character from $00-$3f.
  // Chars that do not have an unmodified keycode return $3f (representing RUN/STOP).
  keyboard_char_keycodes: .byte KEY_AT, KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, $3f, KEY_POUND, $3f, KEY_ARROW_UP, KEY_ARROW_LEFT, KEY_SPACE, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, KEY_ASTERISK, KEY_PLUS, KEY_COMMA, KEY_MINUS, KEY_DOT, KEY_SLASH, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_COLON, KEY_SEMICOLON, $3f, KEY_EQUALS, $3f, $3f

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b17
Removing instruction jmp __b6
Removing instruction jmp __b9
Removing instruction jmp __b8
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b18
Removing instruction jmp __b14
Removing instruction jmp __b19
Removing instruction jmp __b15
Removing instruction jmp __b13
Removing instruction jmp __b16
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing instruction lda #0 with TXA
Replacing label __bbegin with __b1
Replacing label __b6_from___b8 with __b6
Replacing label __b5_from___b10 with __b5
Replacing label __b13_from___b18 with __b13
Replacing label __b13_from___b19 with __b13
Replacing label __b12_from___b13 with __b12
Removing instruction __bbegin:
Removing instruction __b1_from___bbegin:
Removing instruction main_from___b1:
Removing instruction __bend_from___b1:
Removing instruction __b3_from___b1:
Removing instruction __b5_from___b10:
Removing instruction __b6_from___b8:
Removing instruction __b12_from___b13:
Removing instruction __b13_from___b15:
Removing instruction __b13_from___b18:
Removing instruction __b13_from___b19:
Removing instruction __b16_from___b13:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __b5_from___b4:
Removing instruction keyboard_matrix_read_from___b5:
Removing instruction __b17:
Removing instruction __b6_from___b17:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12_from___b11:
Removing instruction __b18:
Removing instruction __b14:
Removing instruction __b19:
Removing instruction __b15:
Removing instruction __b16:
Removing instruction __b1_from___b2:
Removing instruction keyboard_matrix_read_from_keyboard_key_pressed:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Relabelling long label __b16_from___b16 to b1
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b12
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b1:
Succesful ASM optimization Pass5UnusedLabelElimination
Fixing long branch [76] bcc __b2 to bcs
Fixing long branch [82] bcc __b2 to bcs

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) CIA1_PORT_A CIA1_PORT_A = (byte*) 56320
(const byte*) CIA1_PORT_A_DDR CIA1_PORT_A_DDR = (byte*) 56322
(const byte*) CIA1_PORT_B CIA1_PORT_B = (byte*) 56321
(const byte*) CIA1_PORT_B_DDR CIA1_PORT_B_DDR = (byte*) 56323
(const byte) KEY_0 KEY_0 = (byte) $23
(const byte) KEY_1 KEY_1 = (byte) $38
(const byte) KEY_2 KEY_2 = (byte) $3b
(const byte) KEY_3 KEY_3 = (byte) 8
(const byte) KEY_4 KEY_4 = (byte) $b
(const byte) KEY_5 KEY_5 = (byte) $10
(const byte) KEY_6 KEY_6 = (byte) $13
(const byte) KEY_7 KEY_7 = (byte) $18
(const byte) KEY_8 KEY_8 = (byte) $1b
(const byte) KEY_9 KEY_9 = (byte) $20
(const byte) KEY_A KEY_A = (byte) $a
(const byte) KEY_ARROW_LEFT KEY_ARROW_LEFT = (byte) $39
(const byte) KEY_ARROW_UP KEY_ARROW_UP = (byte) $36
(const byte) KEY_ASTERISK KEY_ASTERISK = (byte) $31
(const byte) KEY_AT KEY_AT = (byte) $2e
(const byte) KEY_B KEY_B = (byte) $1c
(const byte) KEY_C KEY_C = (byte) $14
(const byte) KEY_COLON KEY_COLON = (byte) $2d
(const byte) KEY_COMMA KEY_COMMA = (byte) $2f
(const byte) KEY_D KEY_D = (byte) $12
(const byte) KEY_DOT KEY_DOT = (byte) $2c
(const byte) KEY_E KEY_E = (byte) $e
(const byte) KEY_EQUALS KEY_EQUALS = (byte) $35
(const byte) KEY_F KEY_F = (byte) $15
(const byte) KEY_G KEY_G = (byte) $1a
(const byte) KEY_H KEY_H = (byte) $1d
(const byte) KEY_I KEY_I = (byte) $21
(const byte) KEY_J KEY_J = (byte) $22
(const byte) KEY_K KEY_K = (byte) $25
(const byte) KEY_L KEY_L = (byte) $2a
(const byte) KEY_M KEY_M = (byte) $24
(const byte) KEY_MINUS KEY_MINUS = (byte) $2b
(const byte) KEY_N KEY_N = (byte) $27
(const byte) KEY_O KEY_O = (byte) $26
(const byte) KEY_P KEY_P = (byte) $29
(const byte) KEY_PLUS KEY_PLUS = (byte) $28
(const byte) KEY_POUND KEY_POUND = (byte) $30
(const byte) KEY_Q KEY_Q = (byte) $3e
(const byte) KEY_R KEY_R = (byte) $11
(const byte) KEY_S KEY_S = (byte) $d
(const byte) KEY_SEMICOLON KEY_SEMICOLON = (byte) $32
(const byte) KEY_SLASH KEY_SLASH = (byte) $37
(const byte) KEY_SPACE KEY_SPACE = (byte) $3c
(const byte) KEY_T KEY_T = (byte) $16
(const byte) KEY_U KEY_U = (byte) $1e
(const byte) KEY_V KEY_V = (byte) $1f
(const byte) KEY_W KEY_W = (byte) 9
(const byte) KEY_X KEY_X = (byte) $17
(const byte) KEY_Y KEY_Y = (byte) $19
(const byte) KEY_Z KEY_Z = (byte) $c
(const byte*) RASTER RASTER = (byte*) 53266
(const byte[]) keyboard_char_keycodes keyboard_char_keycodes = { (const byte) KEY_AT, (const byte) KEY_A, (const byte) KEY_B, (const byte) KEY_C, (const byte) KEY_D, (const byte) KEY_E, (const byte) KEY_F, (const byte) KEY_G, (const byte) KEY_H, (const byte) KEY_I, (const byte) KEY_J, (const byte) KEY_K, (const byte) KEY_L, (const byte) KEY_M, (const byte) KEY_N, (const byte) KEY_O, (const byte) KEY_P, (const byte) KEY_Q, (const byte) KEY_R, (const byte) KEY_S, (const byte) KEY_T, (const byte) KEY_U, (const byte) KEY_V, (const byte) KEY_W, (const byte) KEY_X, (const byte) KEY_Y, (const byte) KEY_Z, (byte) $3f, (const byte) KEY_POUND, (byte) $3f, (const byte) KEY_ARROW_UP, (const byte) KEY_ARROW_LEFT, (const byte) KEY_SPACE, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (const byte) KEY_ASTERISK, (const byte) KEY_PLUS, (const byte) KEY_COMMA, (const byte) KEY_MINUS, (const byte) KEY_DOT, (const byte) KEY_SLASH, (const byte) KEY_0, (const byte) KEY_1, (const byte) KEY_2, (const byte) KEY_3, (const byte) KEY_4, (const byte) KEY_5, (const byte) KEY_6, (const byte) KEY_7, (const byte) KEY_8, (const byte) KEY_9, (const byte) KEY_COLON, (const byte) KEY_SEMICOLON, (byte) $3f, (const byte) KEY_EQUALS, (byte) $3f, (byte) $3f }
(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
(label) keyboard_get_keycode::@return
(byte) keyboard_get_keycode::ch
(byte) keyboard_get_keycode::ch#0 reg byte y 103.0
(byte) keyboard_get_keycode::return
(byte) keyboard_get_keycode::return#0 reg byte a 34.33333333333333
(byte) keyboard_get_keycode::return#2 reg byte a 202.0
(void()) keyboard_init()
(label) keyboard_init::@return
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 reg byte a 4.0
(label) keyboard_key_pressed::@1
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0 colidx zp ZP_BYTE:7 0.6666666666666666
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0 reg byte y 52.5
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 reg byte a 34.33333333333333
(byte) keyboard_key_pressed::return#2 reg byte a 202.0
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0 reg byte a 4.0
(const byte[8]) keyboard_matrix_col_bitmask keyboard_matrix_col_bitmask = { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 reg byte a 26.25
(byte) keyboard_matrix_read::return#2 reg byte a 4.0
(byte) keyboard_matrix_read::return#3 reg byte a 202.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0 reg byte y 4.0
(byte) keyboard_matrix_read::rowid#1 reg byte y 202.0
(byte) keyboard_matrix_read::rowid#2 reg byte y 105.0
(const byte[8]) keyboard_matrix_row_bitmask keyboard_matrix_row_bitmask = { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
(void()) main()
(byte~) main::$14 reg byte a 202.0
(byte~) main::$4 reg byte a 2002.0
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(byte) main::ch
(byte) main::ch#1 ch zp ZP_BYTE:6 151.5
(byte) main::ch#2 ch zp ZP_BYTE:6 28.857142857142858
(byte) main::col
(byte) main::col#1 reg byte y 1501.5
(byte) main::col#2 reg byte y 667.3333333333334
(byte) main::i
(byte) main::i#1 reg byte x 202.0
(byte) main::i#2 reg byte x 151.5
(byte) main::i#3 reg byte x 42.08333333333333
(byte) main::i#4 reg byte x 202.0
(byte) main::i#6 reg byte x 168.33333333333331
(byte) main::key
(byte) main::key#0 reg byte a 151.5
(byte) main::row
(byte) main::row#1 row zp ZP_BYTE:7 151.5
(byte) main::row#2 row zp ZP_BYTE:7 21.642857142857142
(byte) main::row_pressed_bits
(byte) main::row_pressed_bits#0 reg byte x 202.0
(byte) main::row_pressed_bits#1 reg byte x 667.3333333333334
(byte) main::row_pressed_bits#2 reg byte x 620.8
(byte*) main::sc
(byte*) main::sc#1 sc zp ZP_WORD:2 22.0
(byte*) main::sc#2 sc zp ZP_WORD:2 14.666666666666666
(byte*) main::screen
(byte*) main::screen#1 screen zp ZP_WORD:4 71.0
(byte*) main::screen#13 screen zp ZP_WORD:4 169.53846153846155
(byte*) main::screen#2 screen zp ZP_WORD:4 10.142857142857142

zp ZP_WORD:2 [ main::sc#2 main::sc#1 ]
zp ZP_WORD:4 [ main::screen#13 main::screen#1 main::screen#2 ]
reg byte x [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
reg byte y [ main::col#2 main::col#1 ]
zp ZP_BYTE:6 [ main::ch#2 main::ch#1 ]
reg byte x [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
reg byte y [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ]
reg byte a [ keyboard_matrix_read::return#3 ]
reg byte a [ main::$4 ]
reg byte y [ keyboard_get_keycode::ch#0 ]
reg byte a [ keyboard_get_keycode::return#2 ]
reg byte a [ main::key#0 ]
reg byte y [ keyboard_key_pressed::key#0 ]
reg byte a [ keyboard_key_pressed::return#2 ]
reg byte a [ main::$14 ]
zp ZP_BYTE:7 [ keyboard_key_pressed::colidx#0 main::row#2 main::row#1 ]
reg byte a [ keyboard_key_pressed::rowidx#0 ]
reg byte a [ keyboard_matrix_read::return#2 ]
reg byte a [ keyboard_key_pressed::$2 ]
reg byte a [ keyboard_key_pressed::return#0 ]
reg byte a [ keyboard_matrix_read::return#0 ]
reg byte a [ keyboard_get_keycode::return#0 ]


FINAL ASSEMBLER
Score: 56911

  // File Comments
// Test keyboard input - in the keyboard matrix and mapping screen codes to key codes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label RASTER = $d012
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  // CIA #1 Port A data direction register.
  .label CIA1_PORT_A_DDR = $dc02
  // CIA #1 Port B data direction register.
  .label CIA1_PORT_B_DDR = $dc03
  .const KEY_3 = 8
  .const KEY_W = 9
  .const KEY_A = $a
  .const KEY_4 = $b
  .const KEY_Z = $c
  .const KEY_S = $d
  .const KEY_E = $e
  .const KEY_5 = $10
  .const KEY_R = $11
  .const KEY_D = $12
  .const KEY_6 = $13
  .const KEY_C = $14
  .const KEY_F = $15
  .const KEY_T = $16
  .const KEY_X = $17
  .const KEY_7 = $18
  .const KEY_Y = $19
  .const KEY_G = $1a
  .const KEY_8 = $1b
  .const KEY_B = $1c
  .const KEY_H = $1d
  .const KEY_U = $1e
  .const KEY_V = $1f
  .const KEY_9 = $20
  .const KEY_I = $21
  .const KEY_J = $22
  .const KEY_0 = $23
  .const KEY_M = $24
  .const KEY_K = $25
  .const KEY_O = $26
  .const KEY_N = $27
  .const KEY_PLUS = $28
  .const KEY_P = $29
  .const KEY_L = $2a
  .const KEY_MINUS = $2b
  .const KEY_DOT = $2c
  .const KEY_COLON = $2d
  .const KEY_AT = $2e
  .const KEY_COMMA = $2f
  .const KEY_POUND = $30
  .const KEY_ASTERISK = $31
  .const KEY_SEMICOLON = $32
  .const KEY_EQUALS = $35
  .const KEY_ARROW_UP = $36
  .const KEY_SLASH = $37
  .const KEY_1 = $38
  .const KEY_ARROW_LEFT = $39
  .const KEY_2 = $3b
  .const KEY_SPACE = $3c
  .const KEY_Q = $3e
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label sc = 2
    .label screen = 4
    .label row = 7
    .label ch = 6
    // [5] phi from main to main::@1 [phi:main->main::@1]
    // [5] phi (byte*) main::sc#2 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z sc
    lda #>$400
    sta.z sc+1
  // Clear screen
    // main::@1
  __b1:
    // for(byte* sc = $400; sc<$400+1000;sc++)
    // [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 -- pbuz1_lt_vwuc1_then_la1 
    lda.z sc+1
    cmp #>$400+$3e8
    bcs !__b2+
    jmp __b2
  !__b2:
    bne !+
    lda.z sc
    cmp #<$400+$3e8
    bcs !__b2+
    jmp __b2
  !__b2:
  !:
    // [7] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // main::@3
    // keyboard_init()
    // [8] call keyboard_init 
    jsr keyboard_init
    // main::@4
  __b4:
    // while (*RASTER!=$ff)
    // [9] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@4 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b4
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
    // [10] phi (byte*) main::screen#13 = (byte*) 1024 [phi:main::@4->main::@5#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z screen
    lda #>$400
    sta.z screen+1
    // [10] phi (byte) main::row#2 = (byte) 0 [phi:main::@4->main::@5#1] -- vbuz1=vbuc1 
    lda #0
    sta.z row
  // Read & print keyboard matrix
    // [10] phi from main::@10 to main::@5 [phi:main::@10->main::@5]
    // [10] phi (byte*) main::screen#13 = (byte*) main::screen#1 [phi:main::@10->main::@5#0] -- register_copy 
    // [10] phi (byte) main::row#2 = (byte) main::row#1 [phi:main::@10->main::@5#1] -- register_copy 
    // main::@5
  __b5:
    // keyboard_matrix_read(row)
    // [11] (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2 -- vbuyy=vbuz1 
    ldy.z row
    // [12] call keyboard_matrix_read 
    // [57] phi from main::@5 to keyboard_matrix_read [phi:main::@5->keyboard_matrix_read]
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#1 [phi:main::@5->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // keyboard_matrix_read(row)
    // [13] (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#0
    // main::@17
    // row_pressed_bits = keyboard_matrix_read(row)
    // [14] (byte) main::row_pressed_bits#0 ← (byte) keyboard_matrix_read::return#3 -- vbuxx=vbuaa 
    tax
    // [15] phi from main::@17 to main::@6 [phi:main::@17->main::@6]
    // [15] phi (byte) main::col#2 = (byte) 0 [phi:main::@17->main::@6#0] -- vbuyy=vbuc1 
    ldy #0
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#0 [phi:main::@17->main::@6#1] -- register_copy 
    // [15] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
    // [15] phi (byte) main::col#2 = (byte) main::col#1 [phi:main::@8->main::@6#0] -- register_copy 
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#1 [phi:main::@8->main::@6#1] -- register_copy 
    // main::@6
  __b6:
    // row_pressed_bits & $80
    // [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #$80
    // if( (row_pressed_bits & $80) != 0)
    // [17] if((byte~) main::$4!=(byte) 0) goto main::@7 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b7
    // main::@9
    // screen[col] = '0'
    // [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #'0'
    sta (screen),y
    // main::@8
  __b8:
    // row_pressed_bits = row_pressed_bits * 2
    // [19] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 << (byte) 1 -- vbuxx=vbuxx_rol_1 
    txa
    asl
    tax
    // for(byte col : 0..7)
    // [20] (byte) main::col#1 ← ++ (byte) main::col#2 -- vbuyy=_inc_vbuyy 
    iny
    // [21] if((byte) main::col#1!=(byte) 8) goto main::@6 -- vbuyy_neq_vbuc1_then_la1 
    cpy #8
    bne __b6
    // main::@10
    // screen = screen + 40
    // [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // for(byte row : 0..7)
    // [23] (byte) main::row#1 ← ++ (byte) main::row#2 -- vbuz1=_inc_vbuz1 
    inc.z row
    // [24] if((byte) main::row#1!=(byte) 8) goto main::@5 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z row
    bne __b5
    // main::@11
    // screen = screen + 40
    // [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [26] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
    // [26] phi (byte) main::i#3 = (byte) 0 [phi:main::@11->main::@12#0] -- vbuxx=vbuc1 
    ldx #0
    // [26] phi (byte) main::ch#2 = (byte) 0 [phi:main::@11->main::@12#1] -- vbuz1=vbuc1 
    txa
    sta.z ch
    // [26] phi from main::@13 to main::@12 [phi:main::@13->main::@12]
    // [26] phi (byte) main::i#3 = (byte) main::i#6 [phi:main::@13->main::@12#0] -- register_copy 
    // [26] phi (byte) main::ch#2 = (byte) main::ch#1 [phi:main::@13->main::@12#1] -- register_copy 
    // main::@12
  __b12:
    // keyboard_get_keycode(ch)
    // [27] (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2 -- vbuyy=vbuz1 
    ldy.z ch
    // [28] call keyboard_get_keycode 
    jsr keyboard_get_keycode
    // [29] (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#0
    // main::@18
    // key = keyboard_get_keycode(ch)
    // [30] (byte) main::key#0 ← (byte) keyboard_get_keycode::return#2
    // if(key!=$3f)
    // [31] if((byte) main::key#0==(byte) $3f) goto main::@13 -- vbuaa_eq_vbuc1_then_la1 
    cmp #$3f
    beq __b13
    // main::@14
    // keyboard_key_pressed(key)
    // [32] (byte) keyboard_key_pressed::key#0 ← (byte) main::key#0 -- vbuyy=vbuaa 
    tay
    // [33] call keyboard_key_pressed 
    jsr keyboard_key_pressed
    // [34] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    // main::@19
    // [35] (byte~) main::$14 ← (byte) keyboard_key_pressed::return#2
    // if(keyboard_key_pressed(key)!=0)
    // [36] if((byte~) main::$14==(byte) 0) goto main::@13 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b13
    // main::@15
    // screen[i++] = ch
    // [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2 -- pbuz1_derefidx_vbuxx=vbuz2 
    txa
    tay
    lda.z ch
    sta (screen),y
    // screen[i++] = ch;
    // [38] (byte) main::i#1 ← ++ (byte) main::i#3 -- vbuxx=_inc_vbuxx 
    inx
    // [39] phi from main::@15 main::@18 main::@19 to main::@13 [phi:main::@15/main::@18/main::@19->main::@13]
    // [39] phi (byte) main::i#6 = (byte) main::i#1 [phi:main::@15/main::@18/main::@19->main::@13#0] -- register_copy 
    // main::@13
  __b13:
    // for( byte ch : 0..$3f )
    // [40] (byte) main::ch#1 ← ++ (byte) main::ch#2 -- vbuz1=_inc_vbuz1 
    inc.z ch
    // [41] if((byte) main::ch#1!=(byte) $40) goto main::@12 -- vbuz1_neq_vbuc1_then_la1 
    lda #$40
    cmp.z ch
    bne __b12
    // [42] phi from main::@13 main::@16 to main::@16 [phi:main::@13/main::@16->main::@16]
  b1:
    // [42] phi (byte) main::i#4 = (byte) main::i#6 [phi:main::@13/main::@16->main::@16#0] -- register_copy 
  // Add some spaces
    // main::@16
    // screen[i++] = ' '
    // [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' -- pbuz1_derefidx_vbuxx=vbuc1 
    txa
    tay
    lda #' '
    sta (screen),y
    // screen[i++] = ' ';
    // [44] (byte) main::i#2 ← ++ (byte) main::i#4 -- vbuxx=_inc_vbuxx 
    inx
    // while (i<5)
    // [45] if((byte) main::i#2<(byte) 5) goto main::@16 -- vbuxx_lt_vbuc1_then_la1 
    cpx #5
    bcc b1
    jmp __b4
    // main::@7
  __b7:
    // screen[col] = '1'
    // [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #'1'
    sta (screen),y
    jmp __b8
    // main::@2
  __b2:
    // *sc = ' '
    // [47] *((byte*) main::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // for(byte* sc = $400; sc<$400+1000;sc++)
    // [48] (byte*) main::sc#1 ← ++ (byte*) main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [5] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [5] phi (byte*) main::sc#2 = (byte*) main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(Y) key)
keyboard_key_pressed: {
    .label colidx = 7
    // colidx = key&7
    // [49] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#0 & (byte) 7 -- vbuz1=vbuyy_band_vbuc1 
    tya
    and #7
    sta.z colidx
    // rowidx = key>>3
    // [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 -- vbuaa=vbuyy_ror_3 
    tya
    lsr
    lsr
    lsr
    // keyboard_matrix_read(rowidx)
    // [51] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuyy=vbuaa 
    tay
    // [52] call keyboard_matrix_read 
    // [57] phi from keyboard_key_pressed to keyboard_matrix_read [phi:keyboard_key_pressed->keyboard_matrix_read]
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#0 [phi:keyboard_key_pressed->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // keyboard_matrix_read(rowidx)
    // [53] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    // keyboard_key_pressed::@1
    // [54] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // keyboard_matrix_read(rowidx) & keyboard_matrix_col_bitmask[colidx]
    // [55] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuz1 
    ldy.z colidx
    and keyboard_matrix_col_bitmask,y
    // keyboard_key_pressed::@return
    // }
    // [56] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(Y) rowid)
keyboard_matrix_read: {
    // *CIA1_PORT_A = keyboard_matrix_row_bitmask[rowid]
    // [58] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) -- _deref_pbuc1=pbuc2_derefidx_vbuyy 
    lda keyboard_matrix_row_bitmask,y
    sta CIA1_PORT_A
    // ~*CIA1_PORT_B
    // [59] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    // keyboard_matrix_read::@return
    // }
    // [60] return 
    rts
}
  // keyboard_get_keycode
// Get the keycode corresponding to a specific screen code character
// ch is the character to get the key code for ($00-$3f)
// Returns the key code corresponding to the passed character. Only characters with a non-shifted key are handled.
// If there is no non-shifted key representing the char $3f is returned (representing RUN/STOP) .
// keyboard_get_keycode(byte register(Y) ch)
keyboard_get_keycode: {
    // return keyboard_char_keycodes[ch];
    // [61] (byte) keyboard_get_keycode::return#0 ← *((const byte[]) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#0) -- vbuaa=pbuc1_derefidx_vbuyy 
    lda keyboard_char_keycodes,y
    // keyboard_get_keycode::@return
    // }
    // [62] return 
    rts
}
  // keyboard_init
// Initialize keyboard reading by setting CIA#$ Data Direction Registers
keyboard_init: {
    // *CIA1_PORT_A_DDR = $ff
    // [63] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Write Mode
    lda #$ff
    sta CIA1_PORT_A_DDR
    // *CIA1_PORT_B_DDR = $00
    // [64] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Read Mode
    lda #0
    sta CIA1_PORT_B_DDR
    // keyboard_init::@return
    // }
    // [65] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80
  // Keycodes for each screen code character from $00-$3f.
  // Chars that do not have an unmodified keycode return $3f (representing RUN/STOP).
  keyboard_char_keycodes: .byte KEY_AT, KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, $3f, KEY_POUND, $3f, KEY_ARROW_UP, KEY_ARROW_LEFT, KEY_SPACE, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, KEY_ASTERISK, KEY_PLUS, KEY_COMMA, KEY_MINUS, KEY_DOT, KEY_SLASH, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_COLON, KEY_SEMICOLON, $3f, KEY_EQUALS, $3f, $3f

