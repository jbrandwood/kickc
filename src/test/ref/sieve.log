Fixing pointer addition (word*~) bsearch16u::$7 ← (word*) bsearch16u::items + (byte~) bsearch16u::$6
Fixing pointer addition (word*~) bsearch16u::$15 ← (word*) bsearch16u::pivot + (number) 1
Fixing pointer addition (word*~) bsearch16u::$1 ← (word*) bsearch16u::items - (number) 1
Fixing pointer array-indexing *((word*) utoa::digit_values + (byte) utoa::digit)
Fixing pointer array-indexing *((dword*) ultoa::digit_values + (byte) ultoa::digit)
Warning! Adding boolean cast to non-boolean condition *((byte*) strcpy::src)
Warning! Adding boolean cast to non-boolean condition *((byte*) print_str_lines::str)
Warning! Adding boolean cast to non-boolean condition (byte) print_str_lines::ch
Warning! Adding boolean cast to non-boolean condition *((byte*) print_str::str)
Warning! Adding boolean cast to non-boolean condition *((byte*) print_str_at::str)
Warning! Adding boolean cast to non-boolean sub-expression (byte) print_str_lines::ch
Warning! Adding boolean cast to non-boolean sub-expression *((byte*) main::sieve_i)
Warning! Adding boolean cast to non-boolean sub-expression *((byte*) sieve + (word) main::i)
Identified constant variable (byte*) HEAP_TOP
Identified constant variable (byte*) sieve
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call (byte~) main::$0 ← call toD018 (byte*) SCREEN (byte*)(number) $1800 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) memset::@7
Culled Empty Block (label) memset::@6
Culled Empty Block (label) memset::@8
Culled Empty Block (label) memset::@9
Culled Empty Block (label) memset::@3
Culled Empty Block (label) @3
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) @7
Culled Empty Block (label) clock::@1
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) divr16u::@7
Culled Empty Block (label) @13
Culled Empty Block (label) @14
Culled Empty Block (label) div32u16u::@1
Culled Empty Block (label) @15
Culled Empty Block (label) @16
Culled Empty Block (label) @17
Culled Empty Block (label) @18
Culled Empty Block (label) @19
Culled Empty Block (label) @20
Culled Empty Block (label) @21
Culled Empty Block (label) utoa::@13
Culled Empty Block (label) utoa::@5
Culled Empty Block (label) utoa::@14
Culled Empty Block (label) utoa::@6
Culled Empty Block (label) utoa::@15
Culled Empty Block (label) utoa::@7
Culled Empty Block (label) utoa::@16
Culled Empty Block (label) utoa::@17
Culled Empty Block (label) utoa::@22
Culled Empty Block (label) utoa::@23
Culled Empty Block (label) utoa::@25
Culled Empty Block (label) @23
Culled Empty Block (label) utoa_append::@4
Culled Empty Block (label) utoa_append::@5
Culled Empty Block (label) utoa_append::@6
Culled Empty Block (label) utoa_append::@7
Culled Empty Block (label) ultoa::@13
Culled Empty Block (label) ultoa::@5
Culled Empty Block (label) ultoa::@14
Culled Empty Block (label) ultoa::@6
Culled Empty Block (label) ultoa::@15
Culled Empty Block (label) ultoa::@7
Culled Empty Block (label) ultoa::@16
Culled Empty Block (label) ultoa::@17
Culled Empty Block (label) ultoa::@22
Culled Empty Block (label) ultoa::@23
Culled Empty Block (label) ultoa::@25
Culled Empty Block (label) @25
Culled Empty Block (label) ultoa_append::@4
Culled Empty Block (label) ultoa_append::@5
Culled Empty Block (label) ultoa_append::@6
Culled Empty Block (label) ultoa_append::@7
Culled Empty Block (label) @27
Culled Empty Block (label) @28
Culled Empty Block (label) print_str::@4
Culled Empty Block (label) print_str::@3
Culled Empty Block (label) print_str::@5
Culled Empty Block (label) print_str::@6
Culled Empty Block (label) @29
Culled Empty Block (label) @30
Culled Empty Block (label) @31
Culled Empty Block (label) @32
Culled Empty Block (label) @33
Culled Empty Block (label) @34
Culled Empty Block (label) @35
Culled Empty Block (label) @37
Culled Empty Block (label) @38
Culled Empty Block (label) @39
Culled Empty Block (label) @41
Culled Empty Block (label) @42
Culled Empty Block (label) @43
Culled Empty Block (label) @44
Culled Empty Block (label) @45
Culled Empty Block (label) @46
Culled Empty Block (label) @47
Culled Empty Block (label) @48
Culled Empty Block (label) @49
Culled Empty Block (label) main::toD0181_@1
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@12
Culled Empty Block (label) main::@8
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@10
Culled Empty Block (label) main::@14
Culled Empty Block (label) main::@19
Culled Empty Block (label) main::@20
Culled Empty Block (label) main::@22
Culled Empty Block (label) main::@26
Culled Empty Block (label) main::@25
Culled Empty Block (label) main::@27
Culled Empty Block (label) main::@28

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@4

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from main::@35 print_cls
  (byte) memset::c#5 ← phi( main::@35/(byte) memset::c#1 print_cls/(byte) memset::c#0 )
  (void*) memset::str#4 ← phi( main::@35/(void*) memset::str#1 print_cls/(void*) memset::str#0 )
  (word) memset::num#2 ← phi( main::@35/(word) memset::num#1 print_cls/(word) memset::num#0 )
  (bool~) memset::$0 ← (word) memset::num#2 > (number) 0
  (bool~) memset::$1 ← ! (bool~) memset::$0
  if((bool~) memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@4
  (void*) memset::str#2 ← phi( memset/(void*) memset::str#4 memset::@4/(void*) memset::str#5 )
  (void*) memset::return#0 ← (void*) memset::str#2
  to:memset::@return
memset::@2: scope:[memset]  from memset
  (byte) memset::c#4 ← phi( memset/(byte) memset::c#5 )
  (word) memset::num#3 ← phi( memset/(word) memset::num#2 )
  (void*) memset::str#3 ← phi( memset/(void*) memset::str#4 )
  (byte*~) memset::$2 ← ((byte*)) (void*) memset::str#3
  (byte*~) memset::$3 ← (byte*~) memset::$2 + (word) memset::num#3
  (byte*) memset::end#0 ← (byte*~) memset::$3
  (byte*) memset::dst#0 ← ((byte*)) (void*) memset::str#3
  to:memset::@4
memset::@4: scope:[memset]  from memset::@2 memset::@5
  (byte) memset::c#3 ← phi( memset::@2/(byte) memset::c#4 memset::@5/(byte) memset::c#2 )
  (void*) memset::str#5 ← phi( memset::@2/(void*) memset::str#3 memset::@5/(void*) memset::str#6 )
  (byte*) memset::end#1 ← phi( memset::@2/(byte*) memset::end#0 memset::@5/(byte*) memset::end#2 )
  (byte*) memset::dst#2 ← phi( memset::@2/(byte*) memset::dst#0 memset::@5/(byte*) memset::dst#1 )
  (bool~) memset::$4 ← (byte*) memset::dst#2 != (byte*) memset::end#1
  if((bool~) memset::$4) goto memset::@5
  to:memset::@1
memset::@5: scope:[memset]  from memset::@4
  (void*) memset::str#6 ← phi( memset::@4/(void*) memset::str#5 )
  (byte*) memset::end#2 ← phi( memset::@4/(byte*) memset::end#1 )
  (byte*) memset::dst#3 ← phi( memset::@4/(byte*) memset::dst#2 )
  (byte) memset::c#2 ← phi( memset::@4/(byte) memset::c#3 )
  *((byte*) memset::dst#3) ← (byte) memset::c#2
  (byte*) memset::dst#1 ← ++ (byte*) memset::dst#3
  to:memset::@4
memset::@return: scope:[memset]  from memset::@1
  (void*) memset::return#4 ← phi( memset::@1/(void*) memset::return#0 )
  (void*) memset::return#1 ← (void*) memset::return#4
  return 
  to:@return
@4: scope:[]  from @begin
  (byte*) D018 ← ((byte*)) (number) $d018
  (dword*) CIA2_TIMER_AB ← ((dword*)) (number) $dd04
  (byte*) CIA2_TIMER_A_CONTROL ← ((byte*)) (number) $dd0e
  (byte*) CIA2_TIMER_B_CONTROL ← ((byte*)) (number) $dd0f
  (byte) CIA_TIMER_CONTROL_STOP ← (number) 0
  (byte) CIA_TIMER_CONTROL_START ← (number) 1
  (byte) CIA_TIMER_CONTROL_CONTINUOUS ← (number) 0
  (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES ← (number) 0
  (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A ← (number) $40
  to:@8
@8: scope:[]  from @4
  (word) CLOCKS_PER_FRAME ← (number) $4cc8
  (byte) FRAMES_PER_SEC ← (number) $3c
  (word~) $0 ← (word) CLOCKS_PER_FRAME * (byte) FRAMES_PER_SEC
  (dword) CLOCKS_PER_SEC ← (word~) $0
  (dword) CLOCKS_PER_INIT ← (number) $12
  to:@12

(dword()) clock()
clock: scope:[clock]  from main::@3
  (number~) clock::$0 ← (number) $ffffffff - *((dword*) CIA2_TIMER_AB)
  (dword) clock::return#0 ← (number~) clock::$0
  to:clock::@return
clock::@return: scope:[clock]  from clock
  (dword) clock::return#3 ← phi( clock/(dword) clock::return#0 )
  (dword) clock::return#1 ← (dword) clock::return#3
  return 
  to:@return

(void()) clock_start()
clock_start: scope:[clock_start]  from main::@36
  (byte~) clock_start::$0 ← (byte) CIA_TIMER_CONTROL_STOP | (byte) CIA_TIMER_CONTROL_CONTINUOUS
  (byte~) clock_start::$1 ← (byte~) clock_start::$0 | (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
  *((byte*) CIA2_TIMER_A_CONTROL) ← (byte~) clock_start::$1
  (byte~) clock_start::$2 ← (byte) CIA_TIMER_CONTROL_STOP | (byte) CIA_TIMER_CONTROL_CONTINUOUS
  (byte~) clock_start::$3 ← (byte~) clock_start::$2 | (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  *((byte*) CIA2_TIMER_B_CONTROL) ← (byte~) clock_start::$3
  *((dword*) CIA2_TIMER_AB) ← (number) $ffffffff
  (byte~) clock_start::$4 ← (byte) CIA_TIMER_CONTROL_START | (byte) CIA_TIMER_CONTROL_CONTINUOUS
  (byte~) clock_start::$5 ← (byte~) clock_start::$4 | (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  *((byte*) CIA2_TIMER_B_CONTROL) ← (byte~) clock_start::$5
  (byte~) clock_start::$6 ← (byte) CIA_TIMER_CONTROL_START | (byte) CIA_TIMER_CONTROL_CONTINUOUS
  (byte~) clock_start::$7 ← (byte~) clock_start::$6 | (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
  *((byte*) CIA2_TIMER_A_CONTROL) ← (byte~) clock_start::$7
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  return 
  to:@return
@12: scope:[]  from @8
  (word) rem16u#0 ← (number) 0
  to:@22

(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
divr16u: scope:[divr16u]  from div32u16u div32u16u::@2
  (word) divr16u::divisor#6 ← phi( div32u16u/(word) divr16u::divisor#0 div32u16u::@2/(word) divr16u::divisor#1 )
  (word) divr16u::dividend#5 ← phi( div32u16u/(word) divr16u::dividend#1 div32u16u::@2/(word) divr16u::dividend#2 )
  (word) divr16u::rem#10 ← phi( div32u16u/(word) divr16u::rem#3 div32u16u::@2/(word) divr16u::rem#4 )
  (word) divr16u::quotient#0 ← (number) 0
  (byte) divr16u::i#0 ← (byte) 0
  to:divr16u::@1
divr16u::@1: scope:[divr16u]  from divr16u divr16u::@3
  (byte) divr16u::i#5 ← phi( divr16u/(byte) divr16u::i#0 divr16u::@3/(byte) divr16u::i#1 )
  (word) divr16u::divisor#4 ← phi( divr16u/(word) divr16u::divisor#6 divr16u::@3/(word) divr16u::divisor#7 )
  (word) divr16u::quotient#6 ← phi( divr16u/(word) divr16u::quotient#0 divr16u::@3/(word) divr16u::quotient#8 )
  (word) divr16u::dividend#3 ← phi( divr16u/(word) divr16u::dividend#5 divr16u::@3/(word) divr16u::dividend#6 )
  (word) divr16u::rem#5 ← phi( divr16u/(word) divr16u::rem#10 divr16u::@3/(word) divr16u::rem#11 )
  (word~) divr16u::$0 ← (word) divr16u::rem#5 << (number) 1
  (word) divr16u::rem#0 ← (word~) divr16u::$0
  (byte~) divr16u::$1 ← > (word) divr16u::dividend#3
  (number~) divr16u::$2 ← (byte~) divr16u::$1 & (number) $80
  (bool~) divr16u::$3 ← (number~) divr16u::$2 != (number) 0
  (bool~) divr16u::$4 ← ! (bool~) divr16u::$3
  if((bool~) divr16u::$4) goto divr16u::@2
  to:divr16u::@4
divr16u::@2: scope:[divr16u]  from divr16u::@1 divr16u::@4
  (byte) divr16u::i#3 ← phi( divr16u::@1/(byte) divr16u::i#5 divr16u::@4/(byte) divr16u::i#6 )
  (word) divr16u::divisor#2 ← phi( divr16u::@1/(word) divr16u::divisor#4 divr16u::@4/(word) divr16u::divisor#5 )
  (word) divr16u::rem#6 ← phi( divr16u::@1/(word) divr16u::rem#0 divr16u::@4/(word) divr16u::rem#1 )
  (word) divr16u::quotient#3 ← phi( divr16u::@1/(word) divr16u::quotient#6 divr16u::@4/(word) divr16u::quotient#7 )
  (word) divr16u::dividend#4 ← phi( divr16u::@1/(word) divr16u::dividend#3 divr16u::@4/(word) divr16u::dividend#7 )
  (word~) divr16u::$6 ← (word) divr16u::dividend#4 << (number) 1
  (word) divr16u::dividend#0 ← (word~) divr16u::$6
  (word~) divr16u::$7 ← (word) divr16u::quotient#3 << (number) 1
  (word) divr16u::quotient#1 ← (word~) divr16u::$7
  (bool~) divr16u::$8 ← (word) divr16u::rem#6 >= (word) divr16u::divisor#2
  (bool~) divr16u::$9 ← ! (bool~) divr16u::$8
  if((bool~) divr16u::$9) goto divr16u::@3
  to:divr16u::@5
divr16u::@4: scope:[divr16u]  from divr16u::@1
  (byte) divr16u::i#6 ← phi( divr16u::@1/(byte) divr16u::i#5 )
  (word) divr16u::divisor#5 ← phi( divr16u::@1/(word) divr16u::divisor#4 )
  (word) divr16u::quotient#7 ← phi( divr16u::@1/(word) divr16u::quotient#6 )
  (word) divr16u::dividend#7 ← phi( divr16u::@1/(word) divr16u::dividend#3 )
  (word) divr16u::rem#7 ← phi( divr16u::@1/(word) divr16u::rem#0 )
  (number~) divr16u::$5 ← (word) divr16u::rem#7 | (number) 1
  (word) divr16u::rem#1 ← (number~) divr16u::$5
  to:divr16u::@2
divr16u::@3: scope:[divr16u]  from divr16u::@2 divr16u::@5
  (word) divr16u::divisor#7 ← phi( divr16u::@2/(word) divr16u::divisor#2 divr16u::@5/(word) divr16u::divisor#3 )
  (word) divr16u::quotient#8 ← phi( divr16u::@2/(word) divr16u::quotient#1 divr16u::@5/(word) divr16u::quotient#2 )
  (word) divr16u::dividend#6 ← phi( divr16u::@2/(word) divr16u::dividend#0 divr16u::@5/(word) divr16u::dividend#8 )
  (word) divr16u::rem#11 ← phi( divr16u::@2/(word) divr16u::rem#6 divr16u::@5/(word) divr16u::rem#2 )
  (byte) divr16u::i#2 ← phi( divr16u::@2/(byte) divr16u::i#3 divr16u::@5/(byte) divr16u::i#4 )
  (byte) divr16u::i#1 ← (byte) divr16u::i#2 + rangenext(0,$f)
  (bool~) divr16u::$11 ← (byte) divr16u::i#1 != rangelast(0,$f)
  if((bool~) divr16u::$11) goto divr16u::@1
  to:divr16u::@6
divr16u::@5: scope:[divr16u]  from divr16u::@2
  (word) divr16u::dividend#8 ← phi( divr16u::@2/(word) divr16u::dividend#0 )
  (byte) divr16u::i#4 ← phi( divr16u::@2/(byte) divr16u::i#3 )
  (word) divr16u::divisor#3 ← phi( divr16u::@2/(word) divr16u::divisor#2 )
  (word) divr16u::rem#8 ← phi( divr16u::@2/(word) divr16u::rem#6 )
  (word) divr16u::quotient#4 ← phi( divr16u::@2/(word) divr16u::quotient#1 )
  (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#4
  (word~) divr16u::$10 ← (word) divr16u::rem#8 - (word) divr16u::divisor#3
  (word) divr16u::rem#2 ← (word~) divr16u::$10
  to:divr16u::@3
divr16u::@6: scope:[divr16u]  from divr16u::@3
  (word) divr16u::quotient#5 ← phi( divr16u::@3/(word) divr16u::quotient#8 )
  (word) divr16u::rem#9 ← phi( divr16u::@3/(word) divr16u::rem#11 )
  (word) rem16u#1 ← (word) divr16u::rem#9
  (word) divr16u::return#0 ← (word) divr16u::quotient#5
  to:divr16u::@return
divr16u::@return: scope:[divr16u]  from divr16u::@6
  (word) rem16u#9 ← phi( divr16u::@6/(word) rem16u#1 )
  (word) divr16u::return#4 ← phi( divr16u::@6/(word) divr16u::return#0 )
  (word) divr16u::return#1 ← (word) divr16u::return#4
  (word) rem16u#2 ← (word) rem16u#9
  return 
  to:@return

(dword()) div32u16u((dword) div32u16u::dividend , (word) div32u16u::divisor)
div32u16u: scope:[div32u16u]  from main::@38
  (word) rem16u#16 ← phi( main::@38/(word) rem16u#17 )
  (word) div32u16u::divisor#1 ← phi( main::@38/(word) div32u16u::divisor#0 )
  (dword) div32u16u::dividend#1 ← phi( main::@38/(dword) div32u16u::dividend#0 )
  (word~) div32u16u::$0 ← > (dword) div32u16u::dividend#1
  (word) divr16u::dividend#1 ← (word~) div32u16u::$0
  (word) divr16u::divisor#0 ← (word) div32u16u::divisor#1
  (word) divr16u::rem#3 ← (number) 0
  call divr16u 
  (word) divr16u::return#2 ← (word) divr16u::return#1
  to:div32u16u::@2
div32u16u::@2: scope:[div32u16u]  from div32u16u
  (word) div32u16u::divisor#2 ← phi( div32u16u/(word) div32u16u::divisor#1 )
  (dword) div32u16u::dividend#2 ← phi( div32u16u/(dword) div32u16u::dividend#1 )
  (word) rem16u#10 ← phi( div32u16u/(word) rem16u#2 )
  (word) divr16u::return#5 ← phi( div32u16u/(word) divr16u::return#2 )
  (word~) div32u16u::$1 ← (word) divr16u::return#5
  (word) rem16u#3 ← (word) rem16u#10
  (word) div32u16u::quotient_hi#0 ← (word~) div32u16u::$1
  (word~) div32u16u::$2 ← < (dword) div32u16u::dividend#2
  (word) divr16u::dividend#2 ← (word~) div32u16u::$2
  (word) divr16u::divisor#1 ← (word) div32u16u::divisor#2
  (word) divr16u::rem#4 ← (word) rem16u#3
  call divr16u 
  (word) divr16u::return#3 ← (word) divr16u::return#1
  to:div32u16u::@3
div32u16u::@3: scope:[div32u16u]  from div32u16u::@2
  (word) div32u16u::quotient_hi#1 ← phi( div32u16u::@2/(word) div32u16u::quotient_hi#0 )
  (word) rem16u#11 ← phi( div32u16u::@2/(word) rem16u#2 )
  (word) divr16u::return#6 ← phi( div32u16u::@2/(word) divr16u::return#3 )
  (word~) div32u16u::$3 ← (word) divr16u::return#6
  (word) rem16u#4 ← (word) rem16u#11
  (word) div32u16u::quotient_lo#0 ← (word~) div32u16u::$3
  (dword) div32u16u::quotient#0 ← ((dword)) { (word) div32u16u::quotient_hi#1, (word) div32u16u::quotient_lo#0 }
  (dword) div32u16u::return#0 ← (dword) div32u16u::quotient#0
  to:div32u16u::@return
div32u16u::@return: scope:[div32u16u]  from div32u16u::@3
  (word) rem16u#12 ← phi( div32u16u::@3/(word) rem16u#4 )
  (dword) div32u16u::return#3 ← phi( div32u16u::@3/(dword) div32u16u::return#0 )
  (dword) div32u16u::return#1 ← (dword) div32u16u::return#3
  (word) rem16u#5 ← (word) rem16u#12
  return 
  to:@return
@22: scope:[]  from @12
  (word) rem16u#44 ← phi( @12/(word) rem16u#0 )
  (byte[]) DIGITS ← (const string) $1
  (word[]) RADIX_BINARY_VALUES ← { (number) $8000, (number) $4000, (number) $2000, (number) $1000, (number) $800, (number) $400, (number) $200, (number) $100, (number) $80, (number) $40, (number) $20, (number) $10, (number) 8, (number) 4, (number) 2 }
  (word[]) RADIX_OCTAL_VALUES ← { (number) $8000, (number) $1000, (number) $200, (number) $40, (number) 8 }
  (word[]) RADIX_DECIMAL_VALUES ← { (number) $2710, (number) $3e8, (number) $64, (number) $a }
  (word[]) RADIX_HEXADECIMAL_VALUES ← { (number) $1000, (number) $100, (number) $10 }
  to:@24

(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
utoa: scope:[utoa]  from print_word_decimal
  (byte*) utoa::buffer#21 ← phi( print_word_decimal/(byte*) utoa::buffer#5 )
  (word) utoa::value#12 ← phi( print_word_decimal/(word) utoa::value#1 )
  (byte) utoa::radix#1 ← phi( print_word_decimal/(byte) utoa::radix#0 )
  (byte) utoa::max_digits#0 ← (byte) 0
  (word*) utoa::digit_values#0 ← (word*) 0
  (bool~) utoa::$0 ← (byte) utoa::radix#1 == (const byte) DECIMAL
  if((bool~) utoa::$0) goto utoa::@1
  to:utoa::@9
utoa::@1: scope:[utoa]  from utoa
  (byte*) utoa::buffer#17 ← phi( utoa/(byte*) utoa::buffer#21 )
  (word) utoa::value#8 ← phi( utoa/(word) utoa::value#12 )
  (byte) utoa::max_digits#1 ← (number) 5
  (word*) utoa::digit_values#1 ← (word[]) RADIX_DECIMAL_VALUES
  to:utoa::@8
utoa::@9: scope:[utoa]  from utoa
  (word) utoa::value#13 ← phi( utoa/(word) utoa::value#12 )
  (byte*) utoa::buffer#16 ← phi( utoa/(byte*) utoa::buffer#21 )
  (byte) utoa::radix#2 ← phi( utoa/(byte) utoa::radix#1 )
  (bool~) utoa::$1 ← (byte) utoa::radix#2 == (const byte) HEXADECIMAL
  if((bool~) utoa::$1) goto utoa::@2
  to:utoa::@10
utoa::@2: scope:[utoa]  from utoa::@9
  (byte*) utoa::buffer#18 ← phi( utoa::@9/(byte*) utoa::buffer#16 )
  (word) utoa::value#9 ← phi( utoa::@9/(word) utoa::value#13 )
  (byte) utoa::max_digits#2 ← (number) 4
  (word*) utoa::digit_values#2 ← (word[]) RADIX_HEXADECIMAL_VALUES
  to:utoa::@8
utoa::@10: scope:[utoa]  from utoa::@9
  (word) utoa::value#14 ← phi( utoa::@9/(word) utoa::value#13 )
  (byte*) utoa::buffer#13 ← phi( utoa::@9/(byte*) utoa::buffer#16 )
  (byte) utoa::radix#3 ← phi( utoa::@9/(byte) utoa::radix#2 )
  (bool~) utoa::$2 ← (byte) utoa::radix#3 == (const byte) OCTAL
  if((bool~) utoa::$2) goto utoa::@3
  to:utoa::@11
utoa::@3: scope:[utoa]  from utoa::@10
  (byte*) utoa::buffer#19 ← phi( utoa::@10/(byte*) utoa::buffer#13 )
  (word) utoa::value#10 ← phi( utoa::@10/(word) utoa::value#14 )
  (byte) utoa::max_digits#3 ← (number) 6
  (word*) utoa::digit_values#3 ← (word[]) RADIX_OCTAL_VALUES
  to:utoa::@8
utoa::@11: scope:[utoa]  from utoa::@10
  (word) utoa::value#15 ← phi( utoa::@10/(word) utoa::value#14 )
  (byte*) utoa::buffer#10 ← phi( utoa::@10/(byte*) utoa::buffer#13 )
  (byte) utoa::radix#4 ← phi( utoa::@10/(byte) utoa::radix#3 )
  (bool~) utoa::$3 ← (byte) utoa::radix#4 == (const byte) BINARY
  if((bool~) utoa::$3) goto utoa::@4
  to:utoa::@12
utoa::@4: scope:[utoa]  from utoa::@11
  (byte*) utoa::buffer#20 ← phi( utoa::@11/(byte*) utoa::buffer#10 )
  (word) utoa::value#11 ← phi( utoa::@11/(word) utoa::value#15 )
  (byte) utoa::max_digits#4 ← (number) $10
  (word*) utoa::digit_values#4 ← (word[]) RADIX_BINARY_VALUES
  to:utoa::@8
utoa::@12: scope:[utoa]  from utoa::@11
  (byte*) utoa::buffer#6 ← phi( utoa::@11/(byte*) utoa::buffer#10 )
  *((byte*) utoa::buffer#6) ← (byte) 'e'
  (byte*) utoa::buffer#0 ← ++ (byte*) utoa::buffer#6
  *((byte*) utoa::buffer#0) ← (byte) 'r'
  (byte*) utoa::buffer#1 ← ++ (byte*) utoa::buffer#0
  *((byte*) utoa::buffer#1) ← (byte) 'r'
  (byte*) utoa::buffer#2 ← ++ (byte*) utoa::buffer#1
  *((byte*) utoa::buffer#2) ← (number) 0
  to:utoa::@return
utoa::@return: scope:[utoa]  from utoa::@12 utoa::@20
  return 
  to:@return
utoa::@8: scope:[utoa]  from utoa::@1 utoa::@2 utoa::@3 utoa::@4
  (byte*) utoa::buffer#15 ← phi( utoa::@1/(byte*) utoa::buffer#17 utoa::@2/(byte*) utoa::buffer#18 utoa::@3/(byte*) utoa::buffer#19 utoa::@4/(byte*) utoa::buffer#20 )
  (word) utoa::value#7 ← phi( utoa::@1/(word) utoa::value#8 utoa::@2/(word) utoa::value#9 utoa::@3/(word) utoa::value#10 utoa::@4/(word) utoa::value#11 )
  (word*) utoa::digit_values#8 ← phi( utoa::@1/(word*) utoa::digit_values#1 utoa::@2/(word*) utoa::digit_values#2 utoa::@3/(word*) utoa::digit_values#3 utoa::@4/(word*) utoa::digit_values#4 )
  (byte) utoa::max_digits#7 ← phi( utoa::@1/(byte) utoa::max_digits#1 utoa::@2/(byte) utoa::max_digits#2 utoa::@3/(byte) utoa::max_digits#3 utoa::@4/(byte) utoa::max_digits#4 )
  (byte) utoa::started#0 ← (number) 0
  (byte) utoa::digit#0 ← (number) 0
  to:utoa::@18
utoa::@18: scope:[utoa]  from utoa::@21 utoa::@8
  (byte*) utoa::buffer#11 ← phi( utoa::@21/(byte*) utoa::buffer#14 utoa::@8/(byte*) utoa::buffer#15 )
  (byte) utoa::started#3 ← phi( utoa::@21/(byte) utoa::started#4 utoa::@8/(byte) utoa::started#0 )
  (word) utoa::value#5 ← phi( utoa::@21/(word) utoa::value#6 utoa::@8/(word) utoa::value#7 )
  (word*) utoa::digit_values#6 ← phi( utoa::@21/(word*) utoa::digit_values#7 utoa::@8/(word*) utoa::digit_values#8 )
  (byte) utoa::digit#2 ← phi( utoa::@21/(byte) utoa::digit#1 utoa::@8/(byte) utoa::digit#0 )
  (byte) utoa::max_digits#5 ← phi( utoa::@21/(byte) utoa::max_digits#6 utoa::@8/(byte) utoa::max_digits#7 )
  (number~) utoa::$5 ← (byte) utoa::max_digits#5 - (number) 1
  (bool~) utoa::$6 ← (byte) utoa::digit#2 < (number~) utoa::$5
  if((bool~) utoa::$6) goto utoa::@19
  to:utoa::@20
utoa::@19: scope:[utoa]  from utoa::@18
  (byte) utoa::max_digits#8 ← phi( utoa::@18/(byte) utoa::max_digits#5 )
  (byte*) utoa::buffer#12 ← phi( utoa::@18/(byte*) utoa::buffer#11 )
  (byte) utoa::started#2 ← phi( utoa::@18/(byte) utoa::started#3 )
  (word) utoa::value#2 ← phi( utoa::@18/(word) utoa::value#5 )
  (word*) utoa::digit_values#5 ← phi( utoa::@18/(word*) utoa::digit_values#6 )
  (byte) utoa::digit#3 ← phi( utoa::@18/(byte) utoa::digit#2 )
  (byte~) utoa::$11 ← (byte) utoa::digit#3 * (const byte) SIZEOF_WORD
  (word) utoa::digit_value#0 ← *((word*) utoa::digit_values#5 + (byte~) utoa::$11)
  (bool~) utoa::$7 ← (word) utoa::value#2 >= (word) utoa::digit_value#0
  (bool~) utoa::$8 ← (byte) utoa::started#2 || (bool~) utoa::$7
  (bool~) utoa::$9 ← ! (bool~) utoa::$8
  if((bool~) utoa::$9) goto utoa::@21
  to:utoa::@24
utoa::@20: scope:[utoa]  from utoa::@18
  (byte*) utoa::buffer#7 ← phi( utoa::@18/(byte*) utoa::buffer#11 )
  (word) utoa::value#3 ← phi( utoa::@18/(word) utoa::value#5 )
  (byte~) utoa::$4 ← ((byte)) (word) utoa::value#3
  *((byte*) utoa::buffer#7) ← *((byte[]) DIGITS + (byte~) utoa::$4)
  (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#7
  *((byte*) utoa::buffer#3) ← (number) 0
  to:utoa::@return
utoa::@21: scope:[utoa]  from utoa::@19 utoa::@26
  (byte*) utoa::buffer#14 ← phi( utoa::@19/(byte*) utoa::buffer#12 utoa::@26/(byte*) utoa::buffer#4 )
  (byte) utoa::started#4 ← phi( utoa::@19/(byte) utoa::started#2 utoa::@26/(byte) utoa::started#1 )
  (word) utoa::value#6 ← phi( utoa::@19/(word) utoa::value#2 utoa::@26/(word) utoa::value#0 )
  (word*) utoa::digit_values#7 ← phi( utoa::@19/(word*) utoa::digit_values#5 utoa::@26/(word*) utoa::digit_values#9 )
  (byte) utoa::max_digits#6 ← phi( utoa::@19/(byte) utoa::max_digits#8 utoa::@26/(byte) utoa::max_digits#9 )
  (byte) utoa::digit#4 ← phi( utoa::@19/(byte) utoa::digit#3 utoa::@26/(byte) utoa::digit#5 )
  (byte) utoa::digit#1 ← ++ (byte) utoa::digit#4
  to:utoa::@18
utoa::@24: scope:[utoa]  from utoa::@19
  (word*) utoa::digit_values#10 ← phi( utoa::@19/(word*) utoa::digit_values#5 )
  (byte) utoa::max_digits#10 ← phi( utoa::@19/(byte) utoa::max_digits#8 )
  (byte) utoa::digit#6 ← phi( utoa::@19/(byte) utoa::digit#3 )
  (word) utoa::digit_value#1 ← phi( utoa::@19/(word) utoa::digit_value#0 )
  (word) utoa::value#4 ← phi( utoa::@19/(word) utoa::value#2 )
  (byte*) utoa::buffer#8 ← phi( utoa::@19/(byte*) utoa::buffer#12 )
  (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#8
  (word) utoa_append::value#0 ← (word) utoa::value#4
  (word) utoa_append::sub#0 ← (word) utoa::digit_value#1
  call utoa_append 
  (word) utoa_append::return#0 ← (word) utoa_append::return#2
  to:utoa::@26
utoa::@26: scope:[utoa]  from utoa::@24
  (word*) utoa::digit_values#9 ← phi( utoa::@24/(word*) utoa::digit_values#10 )
  (byte) utoa::max_digits#9 ← phi( utoa::@24/(byte) utoa::max_digits#10 )
  (byte) utoa::digit#5 ← phi( utoa::@24/(byte) utoa::digit#6 )
  (byte*) utoa::buffer#9 ← phi( utoa::@24/(byte*) utoa::buffer#8 )
  (word) utoa_append::return#3 ← phi( utoa::@24/(word) utoa_append::return#0 )
  (word~) utoa::$10 ← (word) utoa_append::return#3
  (word) utoa::value#0 ← (word~) utoa::$10
  (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#9
  (byte) utoa::started#1 ← (number) 1
  to:utoa::@21

(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
utoa_append: scope:[utoa_append]  from utoa::@24
  (byte*) utoa_append::buffer#3 ← phi( utoa::@24/(byte*) utoa_append::buffer#0 )
  (word) utoa_append::sub#3 ← phi( utoa::@24/(word) utoa_append::sub#0 )
  (word) utoa_append::value#5 ← phi( utoa::@24/(word) utoa_append::value#0 )
  (byte) utoa_append::digit#0 ← (number) 0
  to:utoa_append::@1
utoa_append::@1: scope:[utoa_append]  from utoa_append utoa_append::@2
  (byte*) utoa_append::buffer#2 ← phi( utoa_append/(byte*) utoa_append::buffer#3 utoa_append::@2/(byte*) utoa_append::buffer#4 )
  (byte) utoa_append::digit#4 ← phi( utoa_append/(byte) utoa_append::digit#0 utoa_append::@2/(byte) utoa_append::digit#1 )
  (word) utoa_append::sub#1 ← phi( utoa_append/(word) utoa_append::sub#3 utoa_append::@2/(word) utoa_append::sub#2 )
  (word) utoa_append::value#2 ← phi( utoa_append/(word) utoa_append::value#5 utoa_append::@2/(word) utoa_append::value#1 )
  (bool~) utoa_append::$0 ← (word) utoa_append::value#2 >= (word) utoa_append::sub#1
  if((bool~) utoa_append::$0) goto utoa_append::@2
  to:utoa_append::@3
utoa_append::@2: scope:[utoa_append]  from utoa_append::@1
  (byte*) utoa_append::buffer#4 ← phi( utoa_append::@1/(byte*) utoa_append::buffer#2 )
  (word) utoa_append::sub#2 ← phi( utoa_append::@1/(word) utoa_append::sub#1 )
  (word) utoa_append::value#3 ← phi( utoa_append::@1/(word) utoa_append::value#2 )
  (byte) utoa_append::digit#2 ← phi( utoa_append::@1/(byte) utoa_append::digit#4 )
  (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2
  (word) utoa_append::value#1 ← (word) utoa_append::value#3 - (word) utoa_append::sub#2
  to:utoa_append::@1
utoa_append::@3: scope:[utoa_append]  from utoa_append::@1
  (word) utoa_append::value#4 ← phi( utoa_append::@1/(word) utoa_append::value#2 )
  (byte*) utoa_append::buffer#1 ← phi( utoa_append::@1/(byte*) utoa_append::buffer#2 )
  (byte) utoa_append::digit#3 ← phi( utoa_append::@1/(byte) utoa_append::digit#4 )
  *((byte*) utoa_append::buffer#1) ← *((byte[]) DIGITS + (byte) utoa_append::digit#3)
  (word) utoa_append::return#1 ← (word) utoa_append::value#4
  to:utoa_append::@return
utoa_append::@return: scope:[utoa_append]  from utoa_append::@3
  (word) utoa_append::return#4 ← phi( utoa_append::@3/(word) utoa_append::return#1 )
  (word) utoa_append::return#2 ← (word) utoa_append::return#4
  return 
  to:@return
@24: scope:[]  from @22
  (word) rem16u#37 ← phi( @22/(word) rem16u#44 )
  (dword[]) RADIX_BINARY_VALUES_LONG ← { (number) $80000000, (number) $40000000, (number) $20000000, (number) $10000000, (number) $8000000, (number) $4000000, (number) $2000000, (number) $1000000, (number) $800000, (number) $400000, (number) $200000, (number) $100000, (number) $80000, (number) $40000, (number) $20000, (number) $10000, (number) $8000, (number) $4000, (number) $2000, (number) $1000, (number) $800, (number) $400, (number) $200, (number) $100, (number) $80, (number) $40, (number) $20, (number) $10, (number) 8, (number) 4, (number) 2 }
  (dword[]) RADIX_OCTAL_VALUES_LONG ← { (number) $40000000, (number) $8000000, (number) $1000000, (number) $200000, (number) $40000, (number) $8000, (number) $1000, (number) $200, (number) $40, (number) 8 }
  (dword[]) RADIX_DECIMAL_VALUES_LONG ← { (number) $3b9aca00, (number) $5f5e100, (number) $989680, (number) $f4240, (number) $186a0, (number) $2710, (number) $3e8, (number) $64, (number) $a }
  (dword[]) RADIX_HEXADECIMAL_VALUES_LONG ← { (number) $10000000, (number) $1000000, (number) $100000, (number) $10000, (number) $1000, (number) $100, (number) $10 }
  to:@26

(void()) ultoa((dword) ultoa::value , (byte*) ultoa::buffer , (byte) ultoa::radix)
ultoa: scope:[ultoa]  from print_dword_decimal
  (byte*) ultoa::buffer#21 ← phi( print_dword_decimal/(byte*) ultoa::buffer#5 )
  (dword) ultoa::value#12 ← phi( print_dword_decimal/(dword) ultoa::value#1 )
  (byte) ultoa::radix#1 ← phi( print_dword_decimal/(byte) ultoa::radix#0 )
  (byte) ultoa::max_digits#0 ← (byte) 0
  (dword*) ultoa::digit_values#0 ← (dword*) 0
  (bool~) ultoa::$0 ← (byte) ultoa::radix#1 == (const byte) DECIMAL
  if((bool~) ultoa::$0) goto ultoa::@1
  to:ultoa::@9
ultoa::@1: scope:[ultoa]  from ultoa
  (byte*) ultoa::buffer#17 ← phi( ultoa/(byte*) ultoa::buffer#21 )
  (dword) ultoa::value#8 ← phi( ultoa/(dword) ultoa::value#12 )
  (byte) ultoa::max_digits#1 ← (number) $a
  (dword*) ultoa::digit_values#1 ← (dword[]) RADIX_DECIMAL_VALUES_LONG
  to:ultoa::@8
ultoa::@9: scope:[ultoa]  from ultoa
  (dword) ultoa::value#13 ← phi( ultoa/(dword) ultoa::value#12 )
  (byte*) ultoa::buffer#16 ← phi( ultoa/(byte*) ultoa::buffer#21 )
  (byte) ultoa::radix#2 ← phi( ultoa/(byte) ultoa::radix#1 )
  (bool~) ultoa::$1 ← (byte) ultoa::radix#2 == (const byte) HEXADECIMAL
  if((bool~) ultoa::$1) goto ultoa::@2
  to:ultoa::@10
ultoa::@2: scope:[ultoa]  from ultoa::@9
  (byte*) ultoa::buffer#18 ← phi( ultoa::@9/(byte*) ultoa::buffer#16 )
  (dword) ultoa::value#9 ← phi( ultoa::@9/(dword) ultoa::value#13 )
  (byte) ultoa::max_digits#2 ← (number) 8
  (dword*) ultoa::digit_values#2 ← (dword[]) RADIX_HEXADECIMAL_VALUES_LONG
  to:ultoa::@8
ultoa::@10: scope:[ultoa]  from ultoa::@9
  (dword) ultoa::value#14 ← phi( ultoa::@9/(dword) ultoa::value#13 )
  (byte*) ultoa::buffer#13 ← phi( ultoa::@9/(byte*) ultoa::buffer#16 )
  (byte) ultoa::radix#3 ← phi( ultoa::@9/(byte) ultoa::radix#2 )
  (bool~) ultoa::$2 ← (byte) ultoa::radix#3 == (const byte) OCTAL
  if((bool~) ultoa::$2) goto ultoa::@3
  to:ultoa::@11
ultoa::@3: scope:[ultoa]  from ultoa::@10
  (byte*) ultoa::buffer#19 ← phi( ultoa::@10/(byte*) ultoa::buffer#13 )
  (dword) ultoa::value#10 ← phi( ultoa::@10/(dword) ultoa::value#14 )
  (byte) ultoa::max_digits#3 ← (number) $b
  (dword*) ultoa::digit_values#3 ← (dword[]) RADIX_OCTAL_VALUES_LONG
  to:ultoa::@8
ultoa::@11: scope:[ultoa]  from ultoa::@10
  (dword) ultoa::value#15 ← phi( ultoa::@10/(dword) ultoa::value#14 )
  (byte*) ultoa::buffer#10 ← phi( ultoa::@10/(byte*) ultoa::buffer#13 )
  (byte) ultoa::radix#4 ← phi( ultoa::@10/(byte) ultoa::radix#3 )
  (bool~) ultoa::$3 ← (byte) ultoa::radix#4 == (const byte) BINARY
  if((bool~) ultoa::$3) goto ultoa::@4
  to:ultoa::@12
ultoa::@4: scope:[ultoa]  from ultoa::@11
  (byte*) ultoa::buffer#20 ← phi( ultoa::@11/(byte*) ultoa::buffer#10 )
  (dword) ultoa::value#11 ← phi( ultoa::@11/(dword) ultoa::value#15 )
  (byte) ultoa::max_digits#4 ← (number) $20
  (dword*) ultoa::digit_values#4 ← (dword[]) RADIX_BINARY_VALUES_LONG
  to:ultoa::@8
ultoa::@12: scope:[ultoa]  from ultoa::@11
  (byte*) ultoa::buffer#6 ← phi( ultoa::@11/(byte*) ultoa::buffer#10 )
  *((byte*) ultoa::buffer#6) ← (byte) 'e'
  (byte*) ultoa::buffer#0 ← ++ (byte*) ultoa::buffer#6
  *((byte*) ultoa::buffer#0) ← (byte) 'r'
  (byte*) ultoa::buffer#1 ← ++ (byte*) ultoa::buffer#0
  *((byte*) ultoa::buffer#1) ← (byte) 'r'
  (byte*) ultoa::buffer#2 ← ++ (byte*) ultoa::buffer#1
  *((byte*) ultoa::buffer#2) ← (number) 0
  to:ultoa::@return
ultoa::@return: scope:[ultoa]  from ultoa::@12 ultoa::@20
  return 
  to:@return
ultoa::@8: scope:[ultoa]  from ultoa::@1 ultoa::@2 ultoa::@3 ultoa::@4
  (byte*) ultoa::buffer#15 ← phi( ultoa::@1/(byte*) ultoa::buffer#17 ultoa::@2/(byte*) ultoa::buffer#18 ultoa::@3/(byte*) ultoa::buffer#19 ultoa::@4/(byte*) ultoa::buffer#20 )
  (dword) ultoa::value#7 ← phi( ultoa::@1/(dword) ultoa::value#8 ultoa::@2/(dword) ultoa::value#9 ultoa::@3/(dword) ultoa::value#10 ultoa::@4/(dword) ultoa::value#11 )
  (dword*) ultoa::digit_values#8 ← phi( ultoa::@1/(dword*) ultoa::digit_values#1 ultoa::@2/(dword*) ultoa::digit_values#2 ultoa::@3/(dword*) ultoa::digit_values#3 ultoa::@4/(dword*) ultoa::digit_values#4 )
  (byte) ultoa::max_digits#7 ← phi( ultoa::@1/(byte) ultoa::max_digits#1 ultoa::@2/(byte) ultoa::max_digits#2 ultoa::@3/(byte) ultoa::max_digits#3 ultoa::@4/(byte) ultoa::max_digits#4 )
  (byte) ultoa::started#0 ← (number) 0
  (byte) ultoa::digit#0 ← (number) 0
  to:ultoa::@18
ultoa::@18: scope:[ultoa]  from ultoa::@21 ultoa::@8
  (byte*) ultoa::buffer#11 ← phi( ultoa::@21/(byte*) ultoa::buffer#14 ultoa::@8/(byte*) ultoa::buffer#15 )
  (byte) ultoa::started#3 ← phi( ultoa::@21/(byte) ultoa::started#4 ultoa::@8/(byte) ultoa::started#0 )
  (dword) ultoa::value#5 ← phi( ultoa::@21/(dword) ultoa::value#6 ultoa::@8/(dword) ultoa::value#7 )
  (dword*) ultoa::digit_values#6 ← phi( ultoa::@21/(dword*) ultoa::digit_values#7 ultoa::@8/(dword*) ultoa::digit_values#8 )
  (byte) ultoa::digit#2 ← phi( ultoa::@21/(byte) ultoa::digit#1 ultoa::@8/(byte) ultoa::digit#0 )
  (byte) ultoa::max_digits#5 ← phi( ultoa::@21/(byte) ultoa::max_digits#6 ultoa::@8/(byte) ultoa::max_digits#7 )
  (number~) ultoa::$5 ← (byte) ultoa::max_digits#5 - (number) 1
  (bool~) ultoa::$6 ← (byte) ultoa::digit#2 < (number~) ultoa::$5
  if((bool~) ultoa::$6) goto ultoa::@19
  to:ultoa::@20
ultoa::@19: scope:[ultoa]  from ultoa::@18
  (byte) ultoa::max_digits#8 ← phi( ultoa::@18/(byte) ultoa::max_digits#5 )
  (byte*) ultoa::buffer#12 ← phi( ultoa::@18/(byte*) ultoa::buffer#11 )
  (byte) ultoa::started#2 ← phi( ultoa::@18/(byte) ultoa::started#3 )
  (dword) ultoa::value#2 ← phi( ultoa::@18/(dword) ultoa::value#5 )
  (dword*) ultoa::digit_values#5 ← phi( ultoa::@18/(dword*) ultoa::digit_values#6 )
  (byte) ultoa::digit#3 ← phi( ultoa::@18/(byte) ultoa::digit#2 )
  (byte~) ultoa::$11 ← (byte) ultoa::digit#3 * (const byte) SIZEOF_DWORD
  (dword) ultoa::digit_value#0 ← *((dword*) ultoa::digit_values#5 + (byte~) ultoa::$11)
  (bool~) ultoa::$7 ← (dword) ultoa::value#2 >= (dword) ultoa::digit_value#0
  (bool~) ultoa::$8 ← (byte) ultoa::started#2 || (bool~) ultoa::$7
  (bool~) ultoa::$9 ← ! (bool~) ultoa::$8
  if((bool~) ultoa::$9) goto ultoa::@21
  to:ultoa::@24
ultoa::@20: scope:[ultoa]  from ultoa::@18
  (byte*) ultoa::buffer#7 ← phi( ultoa::@18/(byte*) ultoa::buffer#11 )
  (dword) ultoa::value#3 ← phi( ultoa::@18/(dword) ultoa::value#5 )
  (byte~) ultoa::$4 ← ((byte)) (dword) ultoa::value#3
  *((byte*) ultoa::buffer#7) ← *((byte[]) DIGITS + (byte~) ultoa::$4)
  (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#7
  *((byte*) ultoa::buffer#3) ← (number) 0
  to:ultoa::@return
ultoa::@21: scope:[ultoa]  from ultoa::@19 ultoa::@26
  (byte*) ultoa::buffer#14 ← phi( ultoa::@19/(byte*) ultoa::buffer#12 ultoa::@26/(byte*) ultoa::buffer#4 )
  (byte) ultoa::started#4 ← phi( ultoa::@19/(byte) ultoa::started#2 ultoa::@26/(byte) ultoa::started#1 )
  (dword) ultoa::value#6 ← phi( ultoa::@19/(dword) ultoa::value#2 ultoa::@26/(dword) ultoa::value#0 )
  (dword*) ultoa::digit_values#7 ← phi( ultoa::@19/(dword*) ultoa::digit_values#5 ultoa::@26/(dword*) ultoa::digit_values#9 )
  (byte) ultoa::max_digits#6 ← phi( ultoa::@19/(byte) ultoa::max_digits#8 ultoa::@26/(byte) ultoa::max_digits#9 )
  (byte) ultoa::digit#4 ← phi( ultoa::@19/(byte) ultoa::digit#3 ultoa::@26/(byte) ultoa::digit#5 )
  (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#4
  to:ultoa::@18
ultoa::@24: scope:[ultoa]  from ultoa::@19
  (dword*) ultoa::digit_values#10 ← phi( ultoa::@19/(dword*) ultoa::digit_values#5 )
  (byte) ultoa::max_digits#10 ← phi( ultoa::@19/(byte) ultoa::max_digits#8 )
  (byte) ultoa::digit#6 ← phi( ultoa::@19/(byte) ultoa::digit#3 )
  (dword) ultoa::digit_value#1 ← phi( ultoa::@19/(dword) ultoa::digit_value#0 )
  (dword) ultoa::value#4 ← phi( ultoa::@19/(dword) ultoa::value#2 )
  (byte*) ultoa::buffer#8 ← phi( ultoa::@19/(byte*) ultoa::buffer#12 )
  (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#8
  (dword) ultoa_append::value#0 ← (dword) ultoa::value#4
  (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#1
  call ultoa_append 
  (dword) ultoa_append::return#0 ← (dword) ultoa_append::return#2
  to:ultoa::@26
ultoa::@26: scope:[ultoa]  from ultoa::@24
  (dword*) ultoa::digit_values#9 ← phi( ultoa::@24/(dword*) ultoa::digit_values#10 )
  (byte) ultoa::max_digits#9 ← phi( ultoa::@24/(byte) ultoa::max_digits#10 )
  (byte) ultoa::digit#5 ← phi( ultoa::@24/(byte) ultoa::digit#6 )
  (byte*) ultoa::buffer#9 ← phi( ultoa::@24/(byte*) ultoa::buffer#8 )
  (dword) ultoa_append::return#3 ← phi( ultoa::@24/(dword) ultoa_append::return#0 )
  (dword~) ultoa::$10 ← (dword) ultoa_append::return#3
  (dword) ultoa::value#0 ← (dword~) ultoa::$10
  (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#9
  (byte) ultoa::started#1 ← (number) 1
  to:ultoa::@21

(dword()) ultoa_append((byte*) ultoa_append::buffer , (dword) ultoa_append::value , (dword) ultoa_append::sub)
ultoa_append: scope:[ultoa_append]  from ultoa::@24
  (byte*) ultoa_append::buffer#3 ← phi( ultoa::@24/(byte*) ultoa_append::buffer#0 )
  (dword) ultoa_append::sub#3 ← phi( ultoa::@24/(dword) ultoa_append::sub#0 )
  (dword) ultoa_append::value#5 ← phi( ultoa::@24/(dword) ultoa_append::value#0 )
  (byte) ultoa_append::digit#0 ← (number) 0
  to:ultoa_append::@1
ultoa_append::@1: scope:[ultoa_append]  from ultoa_append ultoa_append::@2
  (byte*) ultoa_append::buffer#2 ← phi( ultoa_append/(byte*) ultoa_append::buffer#3 ultoa_append::@2/(byte*) ultoa_append::buffer#4 )
  (byte) ultoa_append::digit#4 ← phi( ultoa_append/(byte) ultoa_append::digit#0 ultoa_append::@2/(byte) ultoa_append::digit#1 )
  (dword) ultoa_append::sub#1 ← phi( ultoa_append/(dword) ultoa_append::sub#3 ultoa_append::@2/(dword) ultoa_append::sub#2 )
  (dword) ultoa_append::value#2 ← phi( ultoa_append/(dword) ultoa_append::value#5 ultoa_append::@2/(dword) ultoa_append::value#1 )
  (bool~) ultoa_append::$0 ← (dword) ultoa_append::value#2 >= (dword) ultoa_append::sub#1
  if((bool~) ultoa_append::$0) goto ultoa_append::@2
  to:ultoa_append::@3
ultoa_append::@2: scope:[ultoa_append]  from ultoa_append::@1
  (byte*) ultoa_append::buffer#4 ← phi( ultoa_append::@1/(byte*) ultoa_append::buffer#2 )
  (dword) ultoa_append::sub#2 ← phi( ultoa_append::@1/(dword) ultoa_append::sub#1 )
  (dword) ultoa_append::value#3 ← phi( ultoa_append::@1/(dword) ultoa_append::value#2 )
  (byte) ultoa_append::digit#2 ← phi( ultoa_append::@1/(byte) ultoa_append::digit#4 )
  (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2
  (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#3 - (dword) ultoa_append::sub#2
  to:ultoa_append::@1
ultoa_append::@3: scope:[ultoa_append]  from ultoa_append::@1
  (dword) ultoa_append::value#4 ← phi( ultoa_append::@1/(dword) ultoa_append::value#2 )
  (byte*) ultoa_append::buffer#1 ← phi( ultoa_append::@1/(byte*) ultoa_append::buffer#2 )
  (byte) ultoa_append::digit#3 ← phi( ultoa_append::@1/(byte) ultoa_append::digit#4 )
  *((byte*) ultoa_append::buffer#1) ← *((byte[]) DIGITS + (byte) ultoa_append::digit#3)
  (dword) ultoa_append::return#1 ← (dword) ultoa_append::value#4
  to:ultoa_append::@return
ultoa_append::@return: scope:[ultoa_append]  from ultoa_append::@3
  (dword) ultoa_append::return#4 ← phi( ultoa_append::@3/(dword) ultoa_append::return#1 )
  (dword) ultoa_append::return#2 ← (dword) ultoa_append::return#4
  return 
  to:@return
@26: scope:[]  from @24
  (word) rem16u#31 ← phi( @24/(word) rem16u#37 )
  (byte*) print_screen#0 ← ((byte*)) (number) $400
  (byte*) print_line_cursor#0 ← (byte*) print_screen#0
  (byte*) print_char_cursor#0 ← (byte*) print_line_cursor#0
  to:@36

(void()) print_str((byte*) print_str::str)
print_str: scope:[print_str]  from main::@17 main::@30 main::@32 main::@39 main::@41 print_dword_decimal::@1 print_word_decimal::@1
  (byte*) print_char_cursor#66 ← phi( main::@17/(byte*) print_char_cursor#62 main::@30/(byte*) print_char_cursor#13 main::@32/(byte*) print_char_cursor#15 main::@39/(byte*) print_char_cursor#61 main::@41/(byte*) print_char_cursor#20 print_dword_decimal::@1/(byte*) print_char_cursor#59 print_word_decimal::@1/(byte*) print_char_cursor#58 )
  (byte*) print_str::str#10 ← phi( main::@17/(byte*) print_str::str#7 main::@30/(byte*) print_str::str#3 main::@32/(byte*) print_str::str#4 main::@39/(byte*) print_str::str#5 main::@41/(byte*) print_str::str#6 print_dword_decimal::@1/(byte*) print_str::str#2 print_word_decimal::@1/(byte*) print_str::str#1 )
  to:print_str::@1
print_str::@1: scope:[print_str]  from print_str print_str::@2
  (byte*) print_char_cursor#56 ← phi( print_str/(byte*) print_char_cursor#66 print_str::@2/(byte*) print_char_cursor#1 )
  (byte*) print_str::str#8 ← phi( print_str/(byte*) print_str::str#10 print_str::@2/(byte*) print_str::str#0 )
  (bool~) print_str::$0 ← (number) 0 != *((byte*) print_str::str#8)
  if((bool~) print_str::$0) goto print_str::@2
  to:print_str::@return
print_str::@2: scope:[print_str]  from print_str::@1
  (byte*) print_char_cursor#29 ← phi( print_str::@1/(byte*) print_char_cursor#56 )
  (byte*) print_str::str#9 ← phi( print_str::@1/(byte*) print_str::str#8 )
  *((byte*) print_char_cursor#29) ← *((byte*) print_str::str#9)
  (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#29
  (byte*) print_str::str#0 ← ++ (byte*) print_str::str#9
  to:print_str::@1
print_str::@return: scope:[print_str]  from print_str::@1
  (byte*) print_char_cursor#30 ← phi( print_str::@1/(byte*) print_char_cursor#56 )
  (byte*) print_char_cursor#2 ← (byte*) print_char_cursor#30
  return 
  to:@return

(void()) print_ln()
print_ln: scope:[print_ln]  from main::@31 main::@34 main::@43
  (byte*) print_char_cursor#57 ← phi( main::@31/(byte*) print_char_cursor#14 main::@34/(byte*) print_char_cursor#17 main::@43/(byte*) print_char_cursor#22 )
  (byte*) print_line_cursor#21 ← phi( main::@31/(byte*) print_line_cursor#23 main::@34/(byte*) print_line_cursor#24 main::@43/(byte*) print_line_cursor#25 )
  to:print_ln::@1
print_ln::@1: scope:[print_ln]  from print_ln print_ln::@1
  (byte*) print_char_cursor#31 ← phi( print_ln/(byte*) print_char_cursor#57 print_ln::@1/(byte*) print_char_cursor#31 )
  (byte*) print_line_cursor#11 ← phi( print_ln/(byte*) print_line_cursor#21 print_ln::@1/(byte*) print_line_cursor#1 )
  (byte*~) print_ln::$0 ← (byte*) print_line_cursor#11 + (number) $28
  (byte*) print_line_cursor#1 ← (byte*~) print_ln::$0
  (bool~) print_ln::$1 ← (byte*) print_line_cursor#1 < (byte*) print_char_cursor#31
  if((bool~) print_ln::$1) goto print_ln::@1
  to:print_ln::@2
print_ln::@2: scope:[print_ln]  from print_ln::@1
  (byte*) print_line_cursor#12 ← phi( print_ln::@1/(byte*) print_line_cursor#1 )
  (byte*) print_char_cursor#3 ← (byte*) print_line_cursor#12
  to:print_ln::@return
print_ln::@return: scope:[print_ln]  from print_ln::@2
  (byte*) print_char_cursor#32 ← phi( print_ln::@2/(byte*) print_char_cursor#3 )
  (byte*) print_line_cursor#13 ← phi( print_ln::@2/(byte*) print_line_cursor#12 )
  (byte*) print_line_cursor#2 ← (byte*) print_line_cursor#13
  (byte*) print_char_cursor#4 ← (byte*) print_char_cursor#32
  return 
  to:@return
@36: scope:[]  from @26
  (byte*) print_screen#10 ← phi( @26/(byte*) print_screen#0 )
  (word) rem16u#27 ← phi( @26/(word) rem16u#31 )
  (byte*) print_char_cursor#79 ← phi( @26/(byte*) print_char_cursor#0 )
  (byte*) print_line_cursor#38 ← phi( @26/(byte*) print_line_cursor#0 )
  (byte[6]) decimal_digits ← { fill( 6, 0) }
  to:@40

(void()) print_word_decimal((word) print_word_decimal::w)
print_word_decimal: scope:[print_word_decimal]  from main::@21 main::@33 main::@40
  (byte*) print_char_cursor#67 ← phi( main::@21/(byte*) print_char_cursor#63 main::@33/(byte*) print_char_cursor#16 main::@40/(byte*) print_char_cursor#19 )
  (word) print_word_decimal::w#3 ← phi( main::@21/(word) print_word_decimal::w#2 main::@33/(word) print_word_decimal::w#0 main::@40/(word) print_word_decimal::w#1 )
  (word) utoa::value#1 ← (word) print_word_decimal::w#3
  (byte*) utoa::buffer#5 ← (byte[6]) decimal_digits
  (byte) utoa::radix#0 ← (const byte) DECIMAL
  call utoa 
  to:print_word_decimal::@1
print_word_decimal::@1: scope:[print_word_decimal]  from print_word_decimal
  (byte*) print_char_cursor#58 ← phi( print_word_decimal/(byte*) print_char_cursor#67 )
  (byte*) print_str::str#1 ← (byte[6]) decimal_digits
  call print_str 
  to:print_word_decimal::@2
print_word_decimal::@2: scope:[print_word_decimal]  from print_word_decimal::@1
  (byte*) print_char_cursor#33 ← phi( print_word_decimal::@1/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#5 ← (byte*) print_char_cursor#33
  to:print_word_decimal::@return
print_word_decimal::@return: scope:[print_word_decimal]  from print_word_decimal::@2
  (byte*) print_char_cursor#34 ← phi( print_word_decimal::@2/(byte*) print_char_cursor#5 )
  (byte*) print_char_cursor#6 ← (byte*) print_char_cursor#34
  return 
  to:@return
@40: scope:[]  from @36
  (byte*) print_screen#9 ← phi( @36/(byte*) print_screen#10 )
  (word) rem16u#24 ← phi( @36/(word) rem16u#27 )
  (byte*) print_char_cursor#75 ← phi( @36/(byte*) print_char_cursor#79 )
  (byte*) print_line_cursor#34 ← phi( @36/(byte*) print_line_cursor#38 )
  (byte[$b]) decimal_digits_long ← { fill( $b, 0) }
  to:@50

(void()) print_dword_decimal((dword) print_dword_decimal::w)
print_dword_decimal: scope:[print_dword_decimal]  from main::@42
  (byte*) print_char_cursor#68 ← phi( main::@42/(byte*) print_char_cursor#21 )
  (dword) print_dword_decimal::w#1 ← phi( main::@42/(dword) print_dword_decimal::w#0 )
  (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#1
  (byte*) ultoa::buffer#5 ← (byte[$b]) decimal_digits_long
  (byte) ultoa::radix#0 ← (const byte) DECIMAL
  call ultoa 
  to:print_dword_decimal::@1
print_dword_decimal::@1: scope:[print_dword_decimal]  from print_dword_decimal
  (byte*) print_char_cursor#59 ← phi( print_dword_decimal/(byte*) print_char_cursor#68 )
  (byte*) print_str::str#2 ← (byte[$b]) decimal_digits_long
  call print_str 
  to:print_dword_decimal::@2
print_dword_decimal::@2: scope:[print_dword_decimal]  from print_dword_decimal::@1
  (byte*) print_char_cursor#35 ← phi( print_dword_decimal::@1/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#7 ← (byte*) print_char_cursor#35
  to:print_dword_decimal::@return
print_dword_decimal::@return: scope:[print_dword_decimal]  from print_dword_decimal::@2
  (byte*) print_char_cursor#36 ← phi( print_dword_decimal::@2/(byte*) print_char_cursor#7 )
  (byte*) print_char_cursor#8 ← (byte*) print_char_cursor#36
  return 
  to:@return

(void()) print_char((byte) print_char::ch)
print_char: scope:[print_char]  from main::@46
  (byte*) print_char_cursor#37 ← phi( main::@46/(byte*) print_char_cursor#25 )
  (byte) print_char::ch#1 ← phi( main::@46/(byte) print_char::ch#0 )
  *((byte*) print_char_cursor#37) ← (byte) print_char::ch#1
  (byte*) print_char_cursor#9 ← ++ (byte*) print_char_cursor#37
  to:print_char::@return
print_char::@return: scope:[print_char]  from print_char
  (byte*) print_char_cursor#38 ← phi( print_char/(byte*) print_char_cursor#9 )
  (byte*) print_char_cursor#10 ← (byte*) print_char_cursor#38
  return 
  to:@return

(void()) print_cls()
print_cls: scope:[print_cls]  from main::@29
  (byte*) print_screen#1 ← phi( main::@29/(byte*) print_screen#3 )
  (void*) memset::str#0 ← (void*)(byte*) print_screen#1
  (byte) memset::c#0 ← (byte) ' '
  (word) memset::num#0 ← (number) $3e8
  call memset 
  (void*) memset::return#2 ← (void*) memset::return#1
  to:print_cls::@1
print_cls::@1: scope:[print_cls]  from print_cls
  (byte*) print_screen#2 ← phi( print_cls/(byte*) print_screen#1 )
  (byte*) print_line_cursor#3 ← (byte*) print_screen#2
  (byte*) print_char_cursor#11 ← (byte*) print_line_cursor#3
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls::@1
  (byte*) print_char_cursor#39 ← phi( print_cls::@1/(byte*) print_char_cursor#11 )
  (byte*) print_line_cursor#14 ← phi( print_cls::@1/(byte*) print_line_cursor#3 )
  (byte*) print_line_cursor#4 ← (byte*) print_line_cursor#14
  (byte*) print_char_cursor#12 ← (byte*) print_char_cursor#39
  return 
  to:@return
@50: scope:[]  from @40
  (byte*) print_screen#8 ← phi( @40/(byte*) print_screen#9 )
  (word) rem16u#23 ← phi( @40/(word) rem16u#24 )
  (byte*) print_char_cursor#74 ← phi( @40/(byte*) print_char_cursor#75 )
  (byte*) print_line_cursor#33 ← phi( @40/(byte*) print_line_cursor#34 )
  (byte*) SCREEN ← ((byte*)) (number) $400
  (word) COUNT ← (number) $4000
  (byte) SQRT_COUNT ← (number) $80
  (byte*) sieve#0 ← ((byte*)) (number) $1000
  to:@51

(void()) main()
main: scope:[main]  from @51
  (word) rem16u#58 ← phi( @51/(word) rem16u#19 )
  (byte*) print_char_cursor#80 ← phi( @51/(byte*) print_char_cursor#65 )
  (byte*) print_line_cursor#39 ← phi( @51/(byte*) print_line_cursor#27 )
  (byte*) print_screen#6 ← phi( @51/(byte*) print_screen#7 )
  (byte*) main::toD0181_screen#0 ← (byte*) SCREEN
  (byte*) main::toD0181_gfx#0 ← (byte*)(number) $1800
  to:main::toD0181
main::toD0181: scope:[main]  from main
  (word) rem16u#57 ← phi( main/(word) rem16u#58 )
  (byte*) print_char_cursor#76 ← phi( main/(byte*) print_char_cursor#80 )
  (byte*) print_line_cursor#35 ← phi( main/(byte*) print_line_cursor#39 )
  (byte*) print_screen#5 ← phi( main/(byte*) print_screen#6 )
  (byte*) main::toD0181_gfx#1 ← phi( main/(byte*) main::toD0181_gfx#0 )
  (byte*) main::toD0181_screen#1 ← phi( main/(byte*) main::toD0181_screen#0 )
  (word~) main::toD0181_$0 ← ((word)) (byte*) main::toD0181_screen#1
  (number~) main::toD0181_$1 ← (word~) main::toD0181_$0 & (number) $3fff
  (number~) main::toD0181_$2 ← (number~) main::toD0181_$1 * (number) 4
  (number~) main::toD0181_$3 ← > (number~) main::toD0181_$2
  (word~) main::toD0181_$4 ← ((word)) (byte*) main::toD0181_gfx#1
  (byte~) main::toD0181_$5 ← > (word~) main::toD0181_$4
  (number~) main::toD0181_$6 ← (byte~) main::toD0181_$5 / (number) 4
  (number~) main::toD0181_$7 ← (number~) main::toD0181_$6 & (number) $f
  (number~) main::toD0181_$8 ← (number~) main::toD0181_$3 | (number~) main::toD0181_$7
  (byte) main::toD0181_return#0 ← (number~) main::toD0181_$8
  to:main::toD0181_@return
main::toD0181_@return: scope:[main]  from main::toD0181
  (word) rem16u#56 ← phi( main::toD0181/(word) rem16u#57 )
  (byte*) print_char_cursor#69 ← phi( main::toD0181/(byte*) print_char_cursor#76 )
  (byte*) print_line_cursor#28 ← phi( main::toD0181/(byte*) print_line_cursor#35 )
  (byte*) print_screen#4 ← phi( main::toD0181/(byte*) print_screen#5 )
  (byte) main::toD0181_return#2 ← phi( main::toD0181/(byte) main::toD0181_return#0 )
  (byte) main::toD0181_return#1 ← (byte) main::toD0181_return#2
  to:main::@29
main::@29: scope:[main]  from main::toD0181_@return
  (word) rem16u#55 ← phi( main::toD0181_@return/(word) rem16u#56 )
  (byte*) print_char_cursor#60 ← phi( main::toD0181_@return/(byte*) print_char_cursor#69 )
  (byte*) print_line_cursor#22 ← phi( main::toD0181_@return/(byte*) print_line_cursor#28 )
  (byte*) print_screen#3 ← phi( main::toD0181_@return/(byte*) print_screen#4 )
  (byte) main::toD0181_return#3 ← phi( main::toD0181_@return/(byte) main::toD0181_return#1 )
  (byte~) main::$0 ← (byte) main::toD0181_return#3
  *((byte*) D018) ← (byte~) main::$0
  call print_cls 
  to:main::@30
main::@30: scope:[main]  from main::@29
  (word) rem16u#54 ← phi( main::@29/(word) rem16u#55 )
  (byte*) print_char_cursor#40 ← phi( main::@29/(byte*) print_char_cursor#12 )
  (byte*) print_line_cursor#15 ← phi( main::@29/(byte*) print_line_cursor#4 )
  (byte*) print_line_cursor#5 ← (byte*) print_line_cursor#15
  (byte*) print_char_cursor#13 ← (byte*) print_char_cursor#40
  (byte*) print_str::str#3 ← (const string) main::str
  call print_str 
  to:main::@31
main::@31: scope:[main]  from main::@30
  (word) rem16u#53 ← phi( main::@30/(word) rem16u#54 )
  (byte*) print_line_cursor#23 ← phi( main::@30/(byte*) print_line_cursor#5 )
  (byte*) print_char_cursor#41 ← phi( main::@30/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#14 ← (byte*) print_char_cursor#41
  call print_ln 
  to:main::@32
main::@32: scope:[main]  from main::@31
  (word) rem16u#51 ← phi( main::@31/(word) rem16u#53 )
  (byte*) print_char_cursor#42 ← phi( main::@31/(byte*) print_char_cursor#4 )
  (byte*) print_line_cursor#16 ← phi( main::@31/(byte*) print_line_cursor#2 )
  (byte*) print_line_cursor#6 ← (byte*) print_line_cursor#16
  (byte*) print_char_cursor#15 ← (byte*) print_char_cursor#42
  (byte*) print_str::str#4 ← (const string) main::str1
  call print_str 
  to:main::@33
main::@33: scope:[main]  from main::@32
  (word) rem16u#48 ← phi( main::@32/(word) rem16u#51 )
  (byte*) print_line_cursor#29 ← phi( main::@32/(byte*) print_line_cursor#6 )
  (byte*) print_char_cursor#43 ← phi( main::@32/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#16 ← (byte*) print_char_cursor#43
  (word) print_word_decimal::w#0 ← (word) COUNT
  call print_word_decimal 
  to:main::@34
main::@34: scope:[main]  from main::@33
  (word) rem16u#45 ← phi( main::@33/(word) rem16u#48 )
  (byte*) print_line_cursor#24 ← phi( main::@33/(byte*) print_line_cursor#29 )
  (byte*) print_char_cursor#44 ← phi( main::@33/(byte*) print_char_cursor#6 )
  (byte*) print_char_cursor#17 ← (byte*) print_char_cursor#44
  call print_ln 
  to:main::@35
main::@35: scope:[main]  from main::@34
  (word) rem16u#38 ← phi( main::@34/(word) rem16u#45 )
  (byte*) print_char_cursor#45 ← phi( main::@34/(byte*) print_char_cursor#4 )
  (byte*) print_line_cursor#17 ← phi( main::@34/(byte*) print_line_cursor#2 )
  (byte*) print_line_cursor#7 ← (byte*) print_line_cursor#17
  (byte*) print_char_cursor#18 ← (byte*) print_char_cursor#45
  (void*) memset::str#1 ← (void*)(byte*) sieve#0
  (byte) memset::c#1 ← (number) 0
  (word) memset::num#1 ← (word) COUNT
  call memset 
  (void*) memset::return#3 ← (void*) memset::return#1
  to:main::@36
main::@36: scope:[main]  from main::@35
  (byte*) print_line_cursor#53 ← phi( main::@35/(byte*) print_line_cursor#7 )
  (byte*) print_char_cursor#84 ← phi( main::@35/(byte*) print_char_cursor#18 )
  (word) rem16u#32 ← phi( main::@35/(word) rem16u#38 )
  call clock_start 
  to:main::@37
main::@37: scope:[main]  from main::@36
  (byte*) print_line_cursor#51 ← phi( main::@36/(byte*) print_line_cursor#53 )
  (byte*) print_char_cursor#82 ← phi( main::@36/(byte*) print_char_cursor#84 )
  (word) rem16u#28 ← phi( main::@36/(word) rem16u#32 )
  (word) main::i#0 ← (number) 2
  (byte*~) main::$9 ← & *((byte*) sieve#0 + (word) main::i#0)
  (byte*) main::sieve_i#0 ← (byte*~) main::$9
  to:main::@1
main::@1: scope:[main]  from main::@37 main::@4
  (byte*) print_line_cursor#49 ← phi( main::@37/(byte*) print_line_cursor#51 main::@4/(byte*) print_line_cursor#52 )
  (byte*) print_char_cursor#81 ← phi( main::@37/(byte*) print_char_cursor#82 main::@4/(byte*) print_char_cursor#83 )
  (word) rem16u#25 ← phi( main::@37/(word) rem16u#28 main::@4/(word) rem16u#29 )
  (byte*) main::sieve_i#4 ← phi( main::@37/(byte*) main::sieve_i#0 main::@4/(byte*) main::sieve_i#1 )
  (word) main::i#4 ← phi( main::@37/(word) main::i#0 main::@4/(word) main::i#2 )
  (bool~) main::$22 ← (word) main::i#4 < (byte) SQRT_COUNT
  if((bool~) main::$22) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  (byte*) print_line_cursor#54 ← phi( main::@1/(byte*) print_line_cursor#49 )
  (byte*) print_char_cursor#85 ← phi( main::@1/(byte*) print_char_cursor#81 )
  (word) rem16u#33 ← phi( main::@1/(word) rem16u#25 )
  (word) main::i#12 ← phi( main::@1/(word) main::i#4 )
  (byte*) main::sieve_i#2 ← phi( main::@1/(byte*) main::sieve_i#4 )
  (bool~) main::$37 ← (number) 0 != *((byte*) main::sieve_i#2)
  (bool~) main::$23 ← ! (bool~) main::$37
  (bool~) main::$24 ← ! (bool~) main::$23
  if((bool~) main::$24) goto main::@4
  to:main::@13
main::@3: scope:[main]  from main::@1
  (byte*) print_line_cursor#47 ← phi( main::@1/(byte*) print_line_cursor#49 )
  (byte*) print_char_cursor#77 ← phi( main::@1/(byte*) print_char_cursor#81 )
  (word) rem16u#20 ← phi( main::@1/(word) rem16u#25 )
  call clock 
  (dword) clock::return#2 ← (dword) clock::return#1
  to:main::@38
main::@38: scope:[main]  from main::@3
  (byte*) print_line_cursor#44 ← phi( main::@3/(byte*) print_line_cursor#47 )
  (byte*) print_char_cursor#70 ← phi( main::@3/(byte*) print_char_cursor#77 )
  (word) rem16u#17 ← phi( main::@3/(word) rem16u#20 )
  (dword) clock::return#4 ← phi( main::@3/(dword) clock::return#2 )
  (dword~) main::$10 ← (dword) clock::return#4
  (dword~) main::$11 ← (dword~) main::$10 - (dword) CLOCKS_PER_INIT
  (dword) main::cyclecount#0 ← (dword~) main::$11
  (number~) main::$12 ← (dword) CLOCKS_PER_SEC / (number) $64
  (word~) main::$13 ← ((word)) (number~) main::$12
  (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0
  (word) div32u16u::divisor#0 ← (word~) main::$13
  call div32u16u 
  (dword) div32u16u::return#2 ← (dword) div32u16u::return#1
  to:main::@39
main::@39: scope:[main]  from main::@38
  (byte*) print_line_cursor#42 ← phi( main::@38/(byte*) print_line_cursor#44 )
  (dword) main::cyclecount#4 ← phi( main::@38/(dword) main::cyclecount#0 )
  (byte*) print_char_cursor#61 ← phi( main::@38/(byte*) print_char_cursor#70 )
  (word) rem16u#13 ← phi( main::@38/(word) rem16u#5 )
  (dword) div32u16u::return#4 ← phi( main::@38/(dword) div32u16u::return#2 )
  (dword~) main::$14 ← (dword) div32u16u::return#4
  (word) rem16u#6 ← (word) rem16u#13
  (word~) main::$15 ← ((word)) (dword~) main::$14
  (word) main::sec100s#0 ← (word~) main::$15
  (byte*) print_str::str#5 ← (const string) main::str2
  call print_str 
  to:main::@40
main::@40: scope:[main]  from main::@39
  (word) rem16u#52 ← phi( main::@39/(word) rem16u#6 )
  (byte*) print_line_cursor#40 ← phi( main::@39/(byte*) print_line_cursor#42 )
  (dword) main::cyclecount#3 ← phi( main::@39/(dword) main::cyclecount#4 )
  (word) main::sec100s#1 ← phi( main::@39/(word) main::sec100s#0 )
  (byte*) print_char_cursor#46 ← phi( main::@39/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#19 ← (byte*) print_char_cursor#46
  (word) print_word_decimal::w#1 ← (word) main::sec100s#1
  call print_word_decimal 
  to:main::@41
main::@41: scope:[main]  from main::@40
  (word) rem16u#49 ← phi( main::@40/(word) rem16u#52 )
  (byte*) print_line_cursor#36 ← phi( main::@40/(byte*) print_line_cursor#40 )
  (dword) main::cyclecount#2 ← phi( main::@40/(dword) main::cyclecount#3 )
  (byte*) print_char_cursor#47 ← phi( main::@40/(byte*) print_char_cursor#6 )
  (byte*) print_char_cursor#20 ← (byte*) print_char_cursor#47
  (byte*) print_str::str#6 ← (const string) main::str3
  call print_str 
  to:main::@42
main::@42: scope:[main]  from main::@41
  (word) rem16u#46 ← phi( main::@41/(word) rem16u#49 )
  (byte*) print_line_cursor#30 ← phi( main::@41/(byte*) print_line_cursor#36 )
  (dword) main::cyclecount#1 ← phi( main::@41/(dword) main::cyclecount#2 )
  (byte*) print_char_cursor#48 ← phi( main::@41/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#21 ← (byte*) print_char_cursor#48
  (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#1
  call print_dword_decimal 
  to:main::@43
main::@43: scope:[main]  from main::@42
  (word) rem16u#39 ← phi( main::@42/(word) rem16u#46 )
  (byte*) print_line_cursor#25 ← phi( main::@42/(byte*) print_line_cursor#30 )
  (byte*) print_char_cursor#49 ← phi( main::@42/(byte*) print_char_cursor#8 )
  (byte*) print_char_cursor#22 ← (byte*) print_char_cursor#49
  call print_ln 
  to:main::@44
main::@44: scope:[main]  from main::@43
  (word) rem16u#36 ← phi( main::@43/(word) rem16u#39 )
  (byte*) print_char_cursor#50 ← phi( main::@43/(byte*) print_char_cursor#4 )
  (byte*) print_line_cursor#18 ← phi( main::@43/(byte*) print_line_cursor#2 )
  (byte*) print_line_cursor#8 ← (byte*) print_line_cursor#18
  (byte*) print_char_cursor#23 ← (byte*) print_char_cursor#50
  (word) main::i#1 ← (number) 2
  to:main::@15
main::@4: scope:[main]  from main::@2 main::@5
  (byte*) print_line_cursor#52 ← phi( main::@2/(byte*) print_line_cursor#54 main::@5/(byte*) print_line_cursor#55 )
  (byte*) print_char_cursor#83 ← phi( main::@2/(byte*) print_char_cursor#85 main::@5/(byte*) print_char_cursor#86 )
  (word) rem16u#29 ← phi( main::@2/(word) rem16u#33 main::@5/(word) rem16u#34 )
  (byte*) main::sieve_i#3 ← phi( main::@2/(byte*) main::sieve_i#2 main::@5/(byte*) main::sieve_i#5 )
  (word) main::i#5 ← phi( main::@2/(word) main::i#12 main::@5/(word) main::i#13 )
  (word) main::i#2 ← ++ (word) main::i#5
  (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#3
  to:main::@1
main::@13: scope:[main]  from main::@2
  (byte*) print_line_cursor#56 ← phi( main::@2/(byte*) print_line_cursor#54 )
  (byte*) print_char_cursor#87 ← phi( main::@2/(byte*) print_char_cursor#85 )
  (word) rem16u#40 ← phi( main::@2/(word) rem16u#33 )
  (byte*) main::sieve_i#6 ← phi( main::@2/(byte*) main::sieve_i#2 )
  (word) main::i#6 ← phi( main::@2/(word) main::i#12 )
  (number~) main::$25 ← (word) main::i#6 * (number) 2
  (word) main::j#0 ← (number~) main::$25
  (byte*~) main::$26 ← & *((byte*) sieve#0 + (word) main::j#0)
  (byte*) main::s#0 ← (byte*~) main::$26
  to:main::@5
main::@5: scope:[main]  from main::@13 main::@6
  (byte*) print_line_cursor#55 ← phi( main::@13/(byte*) print_line_cursor#56 main::@6/(byte*) print_line_cursor#57 )
  (byte*) print_char_cursor#86 ← phi( main::@13/(byte*) print_char_cursor#87 main::@6/(byte*) print_char_cursor#88 )
  (word) rem16u#34 ← phi( main::@13/(word) rem16u#40 main::@6/(word) rem16u#41 )
  (byte*) main::s#3 ← phi( main::@13/(byte*) main::s#0 main::@6/(byte*) main::s#1 )
  (byte*) main::sieve_i#5 ← phi( main::@13/(byte*) main::sieve_i#6 main::@6/(byte*) main::sieve_i#7 )
  (word) main::i#13 ← phi( main::@13/(word) main::i#6 main::@6/(word) main::i#7 )
  (word) main::j#2 ← phi( main::@13/(word) main::j#0 main::@6/(word) main::j#1 )
  (bool~) main::$27 ← (word) main::j#2 < (word) COUNT
  if((bool~) main::$27) goto main::@6
  to:main::@4
main::@6: scope:[main]  from main::@5
  (byte*) print_line_cursor#57 ← phi( main::@5/(byte*) print_line_cursor#55 )
  (byte*) print_char_cursor#88 ← phi( main::@5/(byte*) print_char_cursor#86 )
  (word) rem16u#41 ← phi( main::@5/(word) rem16u#34 )
  (byte*) main::sieve_i#7 ← phi( main::@5/(byte*) main::sieve_i#5 )
  (word) main::j#3 ← phi( main::@5/(word) main::j#2 )
  (word) main::i#7 ← phi( main::@5/(word) main::i#13 )
  (byte*) main::s#2 ← phi( main::@5/(byte*) main::s#3 )
  *((byte*) main::s#2) ← (number) 1
  (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#7
  (word) main::j#1 ← (word) main::j#3 + (word) main::i#7
  to:main::@5
main::@15: scope:[main]  from main::@18 main::@44
  (word) rem16u#30 ← phi( main::@18/(word) rem16u#35 main::@44/(word) rem16u#36 )
  (byte*) print_line_cursor#41 ← phi( main::@18/(byte*) print_line_cursor#43 main::@44/(byte*) print_line_cursor#8 )
  (byte*) print_char_cursor#71 ← phi( main::@18/(byte*) print_char_cursor#78 main::@44/(byte*) print_char_cursor#23 )
  (word) main::i#8 ← phi( main::@18/(word) main::i#3 main::@44/(word) main::i#1 )
  (bool~) main::$28 ← (word) main::i#8 < (number) $514
  if((bool~) main::$28) goto main::@16
  to:main::@17
main::@16: scope:[main]  from main::@15
  (word) rem16u#42 ← phi( main::@15/(word) rem16u#30 )
  (byte*) print_line_cursor#45 ← phi( main::@15/(byte*) print_line_cursor#41 )
  (byte*) print_char_cursor#72 ← phi( main::@15/(byte*) print_char_cursor#71 )
  (word) main::i#9 ← phi( main::@15/(word) main::i#8 )
  (bool~) main::$38 ← (number) 0 != *((byte*) sieve#0 + (word) main::i#9)
  (bool~) main::$29 ← ! (bool~) main::$38
  (bool~) main::$30 ← ! (bool~) main::$29
  if((bool~) main::$30) goto main::@18
  to:main::@21
main::@17: scope:[main]  from main::@15
  (word) rem16u#26 ← phi( main::@15/(word) rem16u#30 )
  (byte*) print_line_cursor#37 ← phi( main::@15/(byte*) print_line_cursor#41 )
  (byte*) print_char_cursor#62 ← phi( main::@15/(byte*) print_char_cursor#71 )
  (byte*) print_str::str#7 ← (const string) main::str4
  call print_str 
  to:main::@45
main::@45: scope:[main]  from main::@17
  (word) rem16u#22 ← phi( main::@17/(word) rem16u#26 )
  (byte*) print_line_cursor#32 ← phi( main::@17/(byte*) print_line_cursor#37 )
  (byte*) print_char_cursor#51 ← phi( main::@17/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#24 ← (byte*) print_char_cursor#51
  to:main::@23
main::@18: scope:[main]  from main::@16 main::@47
  (word) rem16u#35 ← phi( main::@16/(word) rem16u#42 main::@47/(word) rem16u#43 )
  (byte*) print_line_cursor#43 ← phi( main::@16/(byte*) print_line_cursor#45 main::@47/(byte*) print_line_cursor#46 )
  (byte*) print_char_cursor#78 ← phi( main::@16/(byte*) print_char_cursor#72 main::@47/(byte*) print_char_cursor#26 )
  (word) main::i#10 ← phi( main::@16/(word) main::i#9 main::@47/(word) main::i#14 )
  (word) main::i#3 ← ++ (word) main::i#10
  to:main::@15
main::@21: scope:[main]  from main::@16
  (word) rem16u#50 ← phi( main::@16/(word) rem16u#42 )
  (byte*) print_line_cursor#50 ← phi( main::@16/(byte*) print_line_cursor#45 )
  (byte*) print_char_cursor#63 ← phi( main::@16/(byte*) print_char_cursor#72 )
  (word) main::i#11 ← phi( main::@16/(word) main::i#9 )
  (word) print_word_decimal::w#2 ← (word) main::i#11
  call print_word_decimal 
  to:main::@46
main::@46: scope:[main]  from main::@21
  (word) rem16u#47 ← phi( main::@21/(word) rem16u#50 )
  (byte*) print_line_cursor#48 ← phi( main::@21/(byte*) print_line_cursor#50 )
  (word) main::i#15 ← phi( main::@21/(word) main::i#11 )
  (byte*) print_char_cursor#52 ← phi( main::@21/(byte*) print_char_cursor#6 )
  (byte*) print_char_cursor#25 ← (byte*) print_char_cursor#52
  (byte) print_char::ch#0 ← (byte) ' '
  call print_char 
  to:main::@47
main::@47: scope:[main]  from main::@46
  (word) rem16u#43 ← phi( main::@46/(word) rem16u#47 )
  (byte*) print_line_cursor#46 ← phi( main::@46/(byte*) print_line_cursor#48 )
  (word) main::i#14 ← phi( main::@46/(word) main::i#15 )
  (byte*) print_char_cursor#53 ← phi( main::@46/(byte*) print_char_cursor#10 )
  (byte*) print_char_cursor#26 ← (byte*) print_char_cursor#53
  to:main::@18
main::@23: scope:[main]  from main::@24 main::@45
  (word) rem16u#18 ← phi( main::@24/(word) rem16u#21 main::@45/(word) rem16u#22 )
  (byte*) print_char_cursor#64 ← phi( main::@24/(byte*) print_char_cursor#73 main::@45/(byte*) print_char_cursor#24 )
  (byte*) print_line_cursor#26 ← phi( main::@24/(byte*) print_line_cursor#31 main::@45/(byte*) print_line_cursor#32 )
  if(true) goto main::@24
  to:main::@return
main::@24: scope:[main]  from main::@23
  (word) rem16u#21 ← phi( main::@23/(word) rem16u#18 )
  (byte*) print_char_cursor#73 ← phi( main::@23/(byte*) print_char_cursor#64 )
  (byte*) print_line_cursor#31 ← phi( main::@23/(byte*) print_line_cursor#26 )
  (byte*~) main::$36 ← (byte*) SCREEN + (number) $3e7
  *((byte*~) main::$36) ← ++ *((byte*~) main::$36)
  to:main::@23
main::@return: scope:[main]  from main::@23
  (word) rem16u#14 ← phi( main::@23/(word) rem16u#18 )
  (byte*) print_char_cursor#54 ← phi( main::@23/(byte*) print_char_cursor#64 )
  (byte*) print_line_cursor#19 ← phi( main::@23/(byte*) print_line_cursor#26 )
  (byte*) print_line_cursor#9 ← (byte*) print_line_cursor#19
  (byte*) print_char_cursor#27 ← (byte*) print_char_cursor#54
  (word) rem16u#7 ← (word) rem16u#14
  return 
  to:@return
@51: scope:[]  from @50
  (byte*) print_screen#7 ← phi( @50/(byte*) print_screen#8 )
  (word) rem16u#19 ← phi( @50/(word) rem16u#23 )
  (byte*) print_char_cursor#65 ← phi( @50/(byte*) print_char_cursor#74 )
  (byte*) print_line_cursor#27 ← phi( @50/(byte*) print_line_cursor#33 )
  call main 
  to:@52
@52: scope:[]  from @51
  (word) rem16u#15 ← phi( @51/(word) rem16u#7 )
  (byte*) print_char_cursor#55 ← phi( @51/(byte*) print_char_cursor#27 )
  (byte*) print_line_cursor#20 ← phi( @51/(byte*) print_line_cursor#9 )
  (byte*) print_line_cursor#10 ← (byte*) print_line_cursor#20
  (byte*) print_char_cursor#28 ← (byte*) print_char_cursor#55
  (word) rem16u#8 ← (word) rem16u#15
  to:@end
@end: scope:[]  from @52

SYMBOL TABLE SSA
(word~) $0
(const string) $1 = (string) "0123456789abcdef"z
(label) @12
(label) @22
(label) @24
(label) @26
(label) @36
(label) @4
(label) @40
(label) @50
(label) @51
(label) @52
(label) @8
(label) @begin
(label) @end
(const byte) BINARY = (number) 2
(dword*) CIA2_TIMER_AB
(byte*) CIA2_TIMER_A_CONTROL
(byte*) CIA2_TIMER_B_CONTROL
(byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
(byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
(byte) CIA_TIMER_CONTROL_CONTINUOUS
(byte) CIA_TIMER_CONTROL_START
(byte) CIA_TIMER_CONTROL_STOP
(word) CLOCKS_PER_FRAME
(dword) CLOCKS_PER_INIT
(dword) CLOCKS_PER_SEC
(word) COUNT
(byte*) D018
(const byte) DECIMAL = (number) $a
(byte[]) DIGITS
(byte) FRAMES_PER_SEC
(const byte) HEXADECIMAL = (number) $10
(const byte) OCTAL = (number) 8
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(word[]) RADIX_BINARY_VALUES
(dword[]) RADIX_BINARY_VALUES_LONG
(word[]) RADIX_DECIMAL_VALUES
(dword[]) RADIX_DECIMAL_VALUES_LONG
(word[]) RADIX_HEXADECIMAL_VALUES
(dword[]) RADIX_HEXADECIMAL_VALUES_LONG
(word[]) RADIX_OCTAL_VALUES
(dword[]) RADIX_OCTAL_VALUES_LONG
(byte*) SCREEN
(const byte) SIZEOF_DWORD = (byte) 4
(const byte) SIZEOF_WORD = (byte) 2
(byte) SQRT_COUNT
(dword()) clock()
(number~) clock::$0
(label) clock::@return
(dword) clock::return
(dword) clock::return#0
(dword) clock::return#1
(dword) clock::return#2
(dword) clock::return#3
(dword) clock::return#4
(void()) clock_start()
(byte~) clock_start::$0
(byte~) clock_start::$1
(byte~) clock_start::$2
(byte~) clock_start::$3
(byte~) clock_start::$4
(byte~) clock_start::$5
(byte~) clock_start::$6
(byte~) clock_start::$7
(label) clock_start::@return
(byte[6]) decimal_digits
(byte[$b]) decimal_digits_long
(dword()) div32u16u((dword) div32u16u::dividend , (word) div32u16u::divisor)
(word~) div32u16u::$0
(word~) div32u16u::$1
(word~) div32u16u::$2
(word~) div32u16u::$3
(label) div32u16u::@2
(label) div32u16u::@3
(label) div32u16u::@return
(dword) div32u16u::dividend
(dword) div32u16u::dividend#0
(dword) div32u16u::dividend#1
(dword) div32u16u::dividend#2
(word) div32u16u::divisor
(word) div32u16u::divisor#0
(word) div32u16u::divisor#1
(word) div32u16u::divisor#2
(dword) div32u16u::quotient
(dword) div32u16u::quotient#0
(word) div32u16u::quotient_hi
(word) div32u16u::quotient_hi#0
(word) div32u16u::quotient_hi#1
(word) div32u16u::quotient_lo
(word) div32u16u::quotient_lo#0
(dword) div32u16u::return
(dword) div32u16u::return#0
(dword) div32u16u::return#1
(dword) div32u16u::return#2
(dword) div32u16u::return#3
(dword) div32u16u::return#4
(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
(word~) divr16u::$0
(byte~) divr16u::$1
(word~) divr16u::$10
(bool~) divr16u::$11
(number~) divr16u::$2
(bool~) divr16u::$3
(bool~) divr16u::$4
(number~) divr16u::$5
(word~) divr16u::$6
(word~) divr16u::$7
(bool~) divr16u::$8
(bool~) divr16u::$9
(label) divr16u::@1
(label) divr16u::@2
(label) divr16u::@3
(label) divr16u::@4
(label) divr16u::@5
(label) divr16u::@6
(label) divr16u::@return
(word) divr16u::dividend
(word) divr16u::dividend#0
(word) divr16u::dividend#1
(word) divr16u::dividend#2
(word) divr16u::dividend#3
(word) divr16u::dividend#4
(word) divr16u::dividend#5
(word) divr16u::dividend#6
(word) divr16u::dividend#7
(word) divr16u::dividend#8
(word) divr16u::divisor
(word) divr16u::divisor#0
(word) divr16u::divisor#1
(word) divr16u::divisor#2
(word) divr16u::divisor#3
(word) divr16u::divisor#4
(word) divr16u::divisor#5
(word) divr16u::divisor#6
(word) divr16u::divisor#7
(byte) divr16u::i
(byte) divr16u::i#0
(byte) divr16u::i#1
(byte) divr16u::i#2
(byte) divr16u::i#3
(byte) divr16u::i#4
(byte) divr16u::i#5
(byte) divr16u::i#6
(word) divr16u::quotient
(word) divr16u::quotient#0
(word) divr16u::quotient#1
(word) divr16u::quotient#2
(word) divr16u::quotient#3
(word) divr16u::quotient#4
(word) divr16u::quotient#5
(word) divr16u::quotient#6
(word) divr16u::quotient#7
(word) divr16u::quotient#8
(word) divr16u::rem
(word) divr16u::rem#0
(word) divr16u::rem#1
(word) divr16u::rem#10
(word) divr16u::rem#11
(word) divr16u::rem#2
(word) divr16u::rem#3
(word) divr16u::rem#4
(word) divr16u::rem#5
(word) divr16u::rem#6
(word) divr16u::rem#7
(word) divr16u::rem#8
(word) divr16u::rem#9
(word) divr16u::return
(word) divr16u::return#0
(word) divr16u::return#1
(word) divr16u::return#2
(word) divr16u::return#3
(word) divr16u::return#4
(word) divr16u::return#5
(word) divr16u::return#6
(void()) main()
(byte~) main::$0
(dword~) main::$10
(dword~) main::$11
(number~) main::$12
(word~) main::$13
(dword~) main::$14
(word~) main::$15
(bool~) main::$22
(bool~) main::$23
(bool~) main::$24
(number~) main::$25
(byte*~) main::$26
(bool~) main::$27
(bool~) main::$28
(bool~) main::$29
(bool~) main::$30
(byte*~) main::$36
(bool~) main::$37
(bool~) main::$38
(byte*~) main::$9
(label) main::@1
(label) main::@13
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@2
(label) main::@21
(label) main::@23
(label) main::@24
(label) main::@29
(label) main::@3
(label) main::@30
(label) main::@31
(label) main::@32
(label) main::@33
(label) main::@34
(label) main::@35
(label) main::@36
(label) main::@37
(label) main::@38
(label) main::@39
(label) main::@4
(label) main::@40
(label) main::@41
(label) main::@42
(label) main::@43
(label) main::@44
(label) main::@45
(label) main::@46
(label) main::@47
(label) main::@5
(label) main::@6
(label) main::@return
(dword) main::cyclecount
(dword) main::cyclecount#0
(dword) main::cyclecount#1
(dword) main::cyclecount#2
(dword) main::cyclecount#3
(dword) main::cyclecount#4
(word) main::i
(word) main::i#0
(word) main::i#1
(word) main::i#10
(word) main::i#11
(word) main::i#12
(word) main::i#13
(word) main::i#14
(word) main::i#15
(word) main::i#2
(word) main::i#3
(word) main::i#4
(word) main::i#5
(word) main::i#6
(word) main::i#7
(word) main::i#8
(word) main::i#9
(word) main::j
(word) main::j#0
(word) main::j#1
(word) main::j#2
(word) main::j#3
(byte*) main::s
(byte*) main::s#0
(byte*) main::s#1
(byte*) main::s#2
(byte*) main::s#3
(word) main::sec100s
(word) main::sec100s#0
(word) main::sec100s#1
(byte*) main::sieve_i
(byte*) main::sieve_i#0
(byte*) main::sieve_i#1
(byte*) main::sieve_i#2
(byte*) main::sieve_i#3
(byte*) main::sieve_i#4
(byte*) main::sieve_i#5
(byte*) main::sieve_i#6
(byte*) main::sieve_i#7
(const string) main::str = (string) "Sieve benchmark - calculating primes"
(const string) main::str1 = (string) "between 2 and "
(const string) main::str2 = (string) "100ths seconds used: "
(const string) main::str3 = (string) " cycles: "
(const string) main::str4 = (string) "..."
(label) main::toD0181
(word~) main::toD0181_$0
(number~) main::toD0181_$1
(number~) main::toD0181_$2
(number~) main::toD0181_$3
(word~) main::toD0181_$4
(byte~) main::toD0181_$5
(number~) main::toD0181_$6
(number~) main::toD0181_$7
(number~) main::toD0181_$8
(label) main::toD0181_@return
(byte*) main::toD0181_gfx
(byte*) main::toD0181_gfx#0
(byte*) main::toD0181_gfx#1
(byte) main::toD0181_return
(byte) main::toD0181_return#0
(byte) main::toD0181_return#1
(byte) main::toD0181_return#2
(byte) main::toD0181_return#3
(byte*) main::toD0181_screen
(byte*) main::toD0181_screen#0
(byte*) main::toD0181_screen#1
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(bool~) memset::$0
(bool~) memset::$1
(byte*~) memset::$2
(byte*~) memset::$3
(bool~) memset::$4
(label) memset::@1
(label) memset::@2
(label) memset::@4
(label) memset::@5
(label) memset::@return
(byte) memset::c
(byte) memset::c#0
(byte) memset::c#1
(byte) memset::c#2
(byte) memset::c#3
(byte) memset::c#4
(byte) memset::c#5
(byte*) memset::dst
(byte*) memset::dst#0
(byte*) memset::dst#1
(byte*) memset::dst#2
(byte*) memset::dst#3
(byte*) memset::end
(byte*) memset::end#0
(byte*) memset::end#1
(byte*) memset::end#2
(word) memset::num
(word) memset::num#0
(word) memset::num#1
(word) memset::num#2
(word) memset::num#3
(void*) memset::return
(void*) memset::return#0
(void*) memset::return#1
(void*) memset::return#2
(void*) memset::return#3
(void*) memset::return#4
(void*) memset::str
(void*) memset::str#0
(void*) memset::str#1
(void*) memset::str#2
(void*) memset::str#3
(void*) memset::str#4
(void*) memset::str#5
(void*) memset::str#6
(void()) print_char((byte) print_char::ch)
(label) print_char::@return
(byte) print_char::ch
(byte) print_char::ch#0
(byte) print_char::ch#1
(byte*) print_char_cursor
(byte*) print_char_cursor#0
(byte*) print_char_cursor#1
(byte*) print_char_cursor#10
(byte*) print_char_cursor#11
(byte*) print_char_cursor#12
(byte*) print_char_cursor#13
(byte*) print_char_cursor#14
(byte*) print_char_cursor#15
(byte*) print_char_cursor#16
(byte*) print_char_cursor#17
(byte*) print_char_cursor#18
(byte*) print_char_cursor#19
(byte*) print_char_cursor#2
(byte*) print_char_cursor#20
(byte*) print_char_cursor#21
(byte*) print_char_cursor#22
(byte*) print_char_cursor#23
(byte*) print_char_cursor#24
(byte*) print_char_cursor#25
(byte*) print_char_cursor#26
(byte*) print_char_cursor#27
(byte*) print_char_cursor#28
(byte*) print_char_cursor#29
(byte*) print_char_cursor#3
(byte*) print_char_cursor#30
(byte*) print_char_cursor#31
(byte*) print_char_cursor#32
(byte*) print_char_cursor#33
(byte*) print_char_cursor#34
(byte*) print_char_cursor#35
(byte*) print_char_cursor#36
(byte*) print_char_cursor#37
(byte*) print_char_cursor#38
(byte*) print_char_cursor#39
(byte*) print_char_cursor#4
(byte*) print_char_cursor#40
(byte*) print_char_cursor#41
(byte*) print_char_cursor#42
(byte*) print_char_cursor#43
(byte*) print_char_cursor#44
(byte*) print_char_cursor#45
(byte*) print_char_cursor#46
(byte*) print_char_cursor#47
(byte*) print_char_cursor#48
(byte*) print_char_cursor#49
(byte*) print_char_cursor#5
(byte*) print_char_cursor#50
(byte*) print_char_cursor#51
(byte*) print_char_cursor#52
(byte*) print_char_cursor#53
(byte*) print_char_cursor#54
(byte*) print_char_cursor#55
(byte*) print_char_cursor#56
(byte*) print_char_cursor#57
(byte*) print_char_cursor#58
(byte*) print_char_cursor#59
(byte*) print_char_cursor#6
(byte*) print_char_cursor#60
(byte*) print_char_cursor#61
(byte*) print_char_cursor#62
(byte*) print_char_cursor#63
(byte*) print_char_cursor#64
(byte*) print_char_cursor#65
(byte*) print_char_cursor#66
(byte*) print_char_cursor#67
(byte*) print_char_cursor#68
(byte*) print_char_cursor#69
(byte*) print_char_cursor#7
(byte*) print_char_cursor#70
(byte*) print_char_cursor#71
(byte*) print_char_cursor#72
(byte*) print_char_cursor#73
(byte*) print_char_cursor#74
(byte*) print_char_cursor#75
(byte*) print_char_cursor#76
(byte*) print_char_cursor#77
(byte*) print_char_cursor#78
(byte*) print_char_cursor#79
(byte*) print_char_cursor#8
(byte*) print_char_cursor#80
(byte*) print_char_cursor#81
(byte*) print_char_cursor#82
(byte*) print_char_cursor#83
(byte*) print_char_cursor#84
(byte*) print_char_cursor#85
(byte*) print_char_cursor#86
(byte*) print_char_cursor#87
(byte*) print_char_cursor#88
(byte*) print_char_cursor#9
(void()) print_cls()
(label) print_cls::@1
(label) print_cls::@return
(void()) print_dword_decimal((dword) print_dword_decimal::w)
(label) print_dword_decimal::@1
(label) print_dword_decimal::@2
(label) print_dword_decimal::@return
(dword) print_dword_decimal::w
(dword) print_dword_decimal::w#0
(dword) print_dword_decimal::w#1
(byte*) print_line_cursor
(byte*) print_line_cursor#0
(byte*) print_line_cursor#1
(byte*) print_line_cursor#10
(byte*) print_line_cursor#11
(byte*) print_line_cursor#12
(byte*) print_line_cursor#13
(byte*) print_line_cursor#14
(byte*) print_line_cursor#15
(byte*) print_line_cursor#16
(byte*) print_line_cursor#17
(byte*) print_line_cursor#18
(byte*) print_line_cursor#19
(byte*) print_line_cursor#2
(byte*) print_line_cursor#20
(byte*) print_line_cursor#21
(byte*) print_line_cursor#22
(byte*) print_line_cursor#23
(byte*) print_line_cursor#24
(byte*) print_line_cursor#25
(byte*) print_line_cursor#26
(byte*) print_line_cursor#27
(byte*) print_line_cursor#28
(byte*) print_line_cursor#29
(byte*) print_line_cursor#3
(byte*) print_line_cursor#30
(byte*) print_line_cursor#31
(byte*) print_line_cursor#32
(byte*) print_line_cursor#33
(byte*) print_line_cursor#34
(byte*) print_line_cursor#35
(byte*) print_line_cursor#36
(byte*) print_line_cursor#37
(byte*) print_line_cursor#38
(byte*) print_line_cursor#39
(byte*) print_line_cursor#4
(byte*) print_line_cursor#40
(byte*) print_line_cursor#41
(byte*) print_line_cursor#42
(byte*) print_line_cursor#43
(byte*) print_line_cursor#44
(byte*) print_line_cursor#45
(byte*) print_line_cursor#46
(byte*) print_line_cursor#47
(byte*) print_line_cursor#48
(byte*) print_line_cursor#49
(byte*) print_line_cursor#5
(byte*) print_line_cursor#50
(byte*) print_line_cursor#51
(byte*) print_line_cursor#52
(byte*) print_line_cursor#53
(byte*) print_line_cursor#54
(byte*) print_line_cursor#55
(byte*) print_line_cursor#56
(byte*) print_line_cursor#57
(byte*) print_line_cursor#6
(byte*) print_line_cursor#7
(byte*) print_line_cursor#8
(byte*) print_line_cursor#9
(void()) print_ln()
(byte*~) print_ln::$0
(bool~) print_ln::$1
(label) print_ln::@1
(label) print_ln::@2
(label) print_ln::@return
(byte*) print_screen
(byte*) print_screen#0
(byte*) print_screen#1
(byte*) print_screen#10
(byte*) print_screen#2
(byte*) print_screen#3
(byte*) print_screen#4
(byte*) print_screen#5
(byte*) print_screen#6
(byte*) print_screen#7
(byte*) print_screen#8
(byte*) print_screen#9
(void()) print_str((byte*) print_str::str)
(bool~) print_str::$0
(label) print_str::@1
(label) print_str::@2
(label) print_str::@return
(byte*) print_str::str
(byte*) print_str::str#0
(byte*) print_str::str#1
(byte*) print_str::str#10
(byte*) print_str::str#2
(byte*) print_str::str#3
(byte*) print_str::str#4
(byte*) print_str::str#5
(byte*) print_str::str#6
(byte*) print_str::str#7
(byte*) print_str::str#8
(byte*) print_str::str#9
(void()) print_word_decimal((word) print_word_decimal::w)
(label) print_word_decimal::@1
(label) print_word_decimal::@2
(label) print_word_decimal::@return
(word) print_word_decimal::w
(word) print_word_decimal::w#0
(word) print_word_decimal::w#1
(word) print_word_decimal::w#2
(word) print_word_decimal::w#3
(word) rem16u
(word) rem16u#0
(word) rem16u#1
(word) rem16u#10
(word) rem16u#11
(word) rem16u#12
(word) rem16u#13
(word) rem16u#14
(word) rem16u#15
(word) rem16u#16
(word) rem16u#17
(word) rem16u#18
(word) rem16u#19
(word) rem16u#2
(word) rem16u#20
(word) rem16u#21
(word) rem16u#22
(word) rem16u#23
(word) rem16u#24
(word) rem16u#25
(word) rem16u#26
(word) rem16u#27
(word) rem16u#28
(word) rem16u#29
(word) rem16u#3
(word) rem16u#30
(word) rem16u#31
(word) rem16u#32
(word) rem16u#33
(word) rem16u#34
(word) rem16u#35
(word) rem16u#36
(word) rem16u#37
(word) rem16u#38
(word) rem16u#39
(word) rem16u#4
(word) rem16u#40
(word) rem16u#41
(word) rem16u#42
(word) rem16u#43
(word) rem16u#44
(word) rem16u#45
(word) rem16u#46
(word) rem16u#47
(word) rem16u#48
(word) rem16u#49
(word) rem16u#5
(word) rem16u#50
(word) rem16u#51
(word) rem16u#52
(word) rem16u#53
(word) rem16u#54
(word) rem16u#55
(word) rem16u#56
(word) rem16u#57
(word) rem16u#58
(word) rem16u#6
(word) rem16u#7
(word) rem16u#8
(word) rem16u#9
(byte*) sieve
(byte*) sieve#0
(void()) ultoa((dword) ultoa::value , (byte*) ultoa::buffer , (byte) ultoa::radix)
(bool~) ultoa::$0
(bool~) ultoa::$1
(dword~) ultoa::$10
(byte~) ultoa::$11
(bool~) ultoa::$2
(bool~) ultoa::$3
(byte~) ultoa::$4
(number~) ultoa::$5
(bool~) ultoa::$6
(bool~) ultoa::$7
(bool~) ultoa::$8
(bool~) ultoa::$9
(label) ultoa::@1
(label) ultoa::@10
(label) ultoa::@11
(label) ultoa::@12
(label) ultoa::@18
(label) ultoa::@19
(label) ultoa::@2
(label) ultoa::@20
(label) ultoa::@21
(label) ultoa::@24
(label) ultoa::@26
(label) ultoa::@3
(label) ultoa::@4
(label) ultoa::@8
(label) ultoa::@9
(label) ultoa::@return
(byte*) ultoa::buffer
(byte*) ultoa::buffer#0
(byte*) ultoa::buffer#1
(byte*) ultoa::buffer#10
(byte*) ultoa::buffer#11
(byte*) ultoa::buffer#12
(byte*) ultoa::buffer#13
(byte*) ultoa::buffer#14
(byte*) ultoa::buffer#15
(byte*) ultoa::buffer#16
(byte*) ultoa::buffer#17
(byte*) ultoa::buffer#18
(byte*) ultoa::buffer#19
(byte*) ultoa::buffer#2
(byte*) ultoa::buffer#20
(byte*) ultoa::buffer#21
(byte*) ultoa::buffer#3
(byte*) ultoa::buffer#4
(byte*) ultoa::buffer#5
(byte*) ultoa::buffer#6
(byte*) ultoa::buffer#7
(byte*) ultoa::buffer#8
(byte*) ultoa::buffer#9
(byte) ultoa::digit
(byte) ultoa::digit#0
(byte) ultoa::digit#1
(byte) ultoa::digit#2
(byte) ultoa::digit#3
(byte) ultoa::digit#4
(byte) ultoa::digit#5
(byte) ultoa::digit#6
(dword) ultoa::digit_value
(dword) ultoa::digit_value#0
(dword) ultoa::digit_value#1
(dword*) ultoa::digit_values
(dword*) ultoa::digit_values#0
(dword*) ultoa::digit_values#1
(dword*) ultoa::digit_values#10
(dword*) ultoa::digit_values#2
(dword*) ultoa::digit_values#3
(dword*) ultoa::digit_values#4
(dword*) ultoa::digit_values#5
(dword*) ultoa::digit_values#6
(dword*) ultoa::digit_values#7
(dword*) ultoa::digit_values#8
(dword*) ultoa::digit_values#9
(byte) ultoa::max_digits
(byte) ultoa::max_digits#0
(byte) ultoa::max_digits#1
(byte) ultoa::max_digits#10
(byte) ultoa::max_digits#2
(byte) ultoa::max_digits#3
(byte) ultoa::max_digits#4
(byte) ultoa::max_digits#5
(byte) ultoa::max_digits#6
(byte) ultoa::max_digits#7
(byte) ultoa::max_digits#8
(byte) ultoa::max_digits#9
(byte) ultoa::radix
(byte) ultoa::radix#0
(byte) ultoa::radix#1
(byte) ultoa::radix#2
(byte) ultoa::radix#3
(byte) ultoa::radix#4
(byte) ultoa::started
(byte) ultoa::started#0
(byte) ultoa::started#1
(byte) ultoa::started#2
(byte) ultoa::started#3
(byte) ultoa::started#4
(dword) ultoa::value
(dword) ultoa::value#0
(dword) ultoa::value#1
(dword) ultoa::value#10
(dword) ultoa::value#11
(dword) ultoa::value#12
(dword) ultoa::value#13
(dword) ultoa::value#14
(dword) ultoa::value#15
(dword) ultoa::value#2
(dword) ultoa::value#3
(dword) ultoa::value#4
(dword) ultoa::value#5
(dword) ultoa::value#6
(dword) ultoa::value#7
(dword) ultoa::value#8
(dword) ultoa::value#9
(dword()) ultoa_append((byte*) ultoa_append::buffer , (dword) ultoa_append::value , (dword) ultoa_append::sub)
(bool~) ultoa_append::$0
(label) ultoa_append::@1
(label) ultoa_append::@2
(label) ultoa_append::@3
(label) ultoa_append::@return
(byte*) ultoa_append::buffer
(byte*) ultoa_append::buffer#0
(byte*) ultoa_append::buffer#1
(byte*) ultoa_append::buffer#2
(byte*) ultoa_append::buffer#3
(byte*) ultoa_append::buffer#4
(byte) ultoa_append::digit
(byte) ultoa_append::digit#0
(byte) ultoa_append::digit#1
(byte) ultoa_append::digit#2
(byte) ultoa_append::digit#3
(byte) ultoa_append::digit#4
(dword) ultoa_append::return
(dword) ultoa_append::return#0
(dword) ultoa_append::return#1
(dword) ultoa_append::return#2
(dword) ultoa_append::return#3
(dword) ultoa_append::return#4
(dword) ultoa_append::sub
(dword) ultoa_append::sub#0
(dword) ultoa_append::sub#1
(dword) ultoa_append::sub#2
(dword) ultoa_append::sub#3
(dword) ultoa_append::value
(dword) ultoa_append::value#0
(dword) ultoa_append::value#1
(dword) ultoa_append::value#2
(dword) ultoa_append::value#3
(dword) ultoa_append::value#4
(dword) ultoa_append::value#5
(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
(bool~) utoa::$0
(bool~) utoa::$1
(word~) utoa::$10
(byte~) utoa::$11
(bool~) utoa::$2
(bool~) utoa::$3
(byte~) utoa::$4
(number~) utoa::$5
(bool~) utoa::$6
(bool~) utoa::$7
(bool~) utoa::$8
(bool~) utoa::$9
(label) utoa::@1
(label) utoa::@10
(label) utoa::@11
(label) utoa::@12
(label) utoa::@18
(label) utoa::@19
(label) utoa::@2
(label) utoa::@20
(label) utoa::@21
(label) utoa::@24
(label) utoa::@26
(label) utoa::@3
(label) utoa::@4
(label) utoa::@8
(label) utoa::@9
(label) utoa::@return
(byte*) utoa::buffer
(byte*) utoa::buffer#0
(byte*) utoa::buffer#1
(byte*) utoa::buffer#10
(byte*) utoa::buffer#11
(byte*) utoa::buffer#12
(byte*) utoa::buffer#13
(byte*) utoa::buffer#14
(byte*) utoa::buffer#15
(byte*) utoa::buffer#16
(byte*) utoa::buffer#17
(byte*) utoa::buffer#18
(byte*) utoa::buffer#19
(byte*) utoa::buffer#2
(byte*) utoa::buffer#20
(byte*) utoa::buffer#21
(byte*) utoa::buffer#3
(byte*) utoa::buffer#4
(byte*) utoa::buffer#5
(byte*) utoa::buffer#6
(byte*) utoa::buffer#7
(byte*) utoa::buffer#8
(byte*) utoa::buffer#9
(byte) utoa::digit
(byte) utoa::digit#0
(byte) utoa::digit#1
(byte) utoa::digit#2
(byte) utoa::digit#3
(byte) utoa::digit#4
(byte) utoa::digit#5
(byte) utoa::digit#6
(word) utoa::digit_value
(word) utoa::digit_value#0
(word) utoa::digit_value#1
(word*) utoa::digit_values
(word*) utoa::digit_values#0
(word*) utoa::digit_values#1
(word*) utoa::digit_values#10
(word*) utoa::digit_values#2
(word*) utoa::digit_values#3
(word*) utoa::digit_values#4
(word*) utoa::digit_values#5
(word*) utoa::digit_values#6
(word*) utoa::digit_values#7
(word*) utoa::digit_values#8
(word*) utoa::digit_values#9
(byte) utoa::max_digits
(byte) utoa::max_digits#0
(byte) utoa::max_digits#1
(byte) utoa::max_digits#10
(byte) utoa::max_digits#2
(byte) utoa::max_digits#3
(byte) utoa::max_digits#4
(byte) utoa::max_digits#5
(byte) utoa::max_digits#6
(byte) utoa::max_digits#7
(byte) utoa::max_digits#8
(byte) utoa::max_digits#9
(byte) utoa::radix
(byte) utoa::radix#0
(byte) utoa::radix#1
(byte) utoa::radix#2
(byte) utoa::radix#3
(byte) utoa::radix#4
(byte) utoa::started
(byte) utoa::started#0
(byte) utoa::started#1
(byte) utoa::started#2
(byte) utoa::started#3
(byte) utoa::started#4
(word) utoa::value
(word) utoa::value#0
(word) utoa::value#1
(word) utoa::value#10
(word) utoa::value#11
(word) utoa::value#12
(word) utoa::value#13
(word) utoa::value#14
(word) utoa::value#15
(word) utoa::value#2
(word) utoa::value#3
(word) utoa::value#4
(word) utoa::value#5
(word) utoa::value#6
(word) utoa::value#7
(word) utoa::value#8
(word) utoa::value#9
(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
(bool~) utoa_append::$0
(label) utoa_append::@1
(label) utoa_append::@2
(label) utoa_append::@3
(label) utoa_append::@return
(byte*) utoa_append::buffer
(byte*) utoa_append::buffer#0
(byte*) utoa_append::buffer#1
(byte*) utoa_append::buffer#2
(byte*) utoa_append::buffer#3
(byte*) utoa_append::buffer#4
(byte) utoa_append::digit
(byte) utoa_append::digit#0
(byte) utoa_append::digit#1
(byte) utoa_append::digit#2
(byte) utoa_append::digit#3
(byte) utoa_append::digit#4
(word) utoa_append::return
(word) utoa_append::return#0
(word) utoa_append::return#1
(word) utoa_append::return#2
(word) utoa_append::return#3
(word) utoa_append::return#4
(word) utoa_append::sub
(word) utoa_append::sub#0
(word) utoa_append::sub#1
(word) utoa_append::sub#2
(word) utoa_append::sub#3
(word) utoa_append::value
(word) utoa_append::value#0
(word) utoa_append::value#1
(word) utoa_append::value#2
(word) utoa_append::value#3
(word) utoa_append::value#4
(word) utoa_append::value#5

Fixing inline constructor with div32u16u::$4 ← (word)div32u16u::quotient_hi#1 dw= (word)div32u16u::quotient_lo#0
Successful SSA optimization Pass2FixInlineConstructors
Adding number conversion cast (unumber) 0 in (bool~) memset::$0 ← (word) memset::num#2 > (number) 0
Adding number conversion cast (unumber) 0 in (byte) CIA_TIMER_CONTROL_STOP ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) CIA_TIMER_CONTROL_START ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) CIA_TIMER_CONTROL_CONTINUOUS ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES ← (number) 0
Adding number conversion cast (unumber) $40 in (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A ← (number) $40
Adding number conversion cast (unumber) $4cc8 in (word) CLOCKS_PER_FRAME ← (number) $4cc8
Adding number conversion cast (unumber) $3c in (byte) FRAMES_PER_SEC ← (number) $3c
Adding number conversion cast (unumber) $12 in (dword) CLOCKS_PER_INIT ← (number) $12
Adding number conversion cast (unumber) $ffffffff in (number~) clock::$0 ← (number) $ffffffff - *((dword*) CIA2_TIMER_AB)
Adding number conversion cast (unumber) clock::$0 in (number~) clock::$0 ← (unumber)(number) $ffffffff - *((dword*) CIA2_TIMER_AB)
Adding number conversion cast (unumber) $ffffffff in *((dword*) CIA2_TIMER_AB) ← (number) $ffffffff
Adding number conversion cast (unumber) 0 in (word) rem16u#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (word) divr16u::quotient#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (word~) divr16u::$0 ← (word) divr16u::rem#5 << (number) 1
Adding number conversion cast (unumber) $80 in (number~) divr16u::$2 ← (byte~) divr16u::$1 & (number) $80
Adding number conversion cast (unumber) divr16u::$2 in (number~) divr16u::$2 ← (byte~) divr16u::$1 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) divr16u::$3 ← (unumber~) divr16u::$2 != (number) 0
Adding number conversion cast (unumber) 1 in (word~) divr16u::$6 ← (word) divr16u::dividend#4 << (number) 1
Adding number conversion cast (unumber) 1 in (word~) divr16u::$7 ← (word) divr16u::quotient#3 << (number) 1
Adding number conversion cast (unumber) 1 in (number~) divr16u::$5 ← (word) divr16u::rem#7 | (number) 1
Adding number conversion cast (unumber) divr16u::$5 in (number~) divr16u::$5 ← (word) divr16u::rem#7 | (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (word) divr16u::rem#3 ← (number) 0
Adding number conversion cast (unumber) 5 in (byte) utoa::max_digits#1 ← (number) 5
Adding number conversion cast (unumber) 4 in (byte) utoa::max_digits#2 ← (number) 4
Adding number conversion cast (unumber) 6 in (byte) utoa::max_digits#3 ← (number) 6
Adding number conversion cast (unumber) $10 in (byte) utoa::max_digits#4 ← (number) $10
Adding number conversion cast (unumber) 0 in *((byte*) utoa::buffer#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa::started#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa::digit#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (number~) utoa::$5 ← (byte) utoa::max_digits#5 - (number) 1
Adding number conversion cast (unumber) utoa::$5 in (number~) utoa::$5 ← (byte) utoa::max_digits#5 - (unumber)(number) 1
Adding number conversion cast (unumber) 0 in *((byte*) utoa::buffer#3) ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) utoa::started#1 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) utoa_append::digit#0 ← (number) 0
Adding number conversion cast (unumber) $a in (byte) ultoa::max_digits#1 ← (number) $a
Adding number conversion cast (unumber) 8 in (byte) ultoa::max_digits#2 ← (number) 8
Adding number conversion cast (unumber) $b in (byte) ultoa::max_digits#3 ← (number) $b
Adding number conversion cast (unumber) $20 in (byte) ultoa::max_digits#4 ← (number) $20
Adding number conversion cast (unumber) 0 in *((byte*) ultoa::buffer#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) ultoa::started#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) ultoa::digit#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (number~) ultoa::$5 ← (byte) ultoa::max_digits#5 - (number) 1
Adding number conversion cast (unumber) ultoa::$5 in (number~) ultoa::$5 ← (byte) ultoa::max_digits#5 - (unumber)(number) 1
Adding number conversion cast (unumber) 0 in *((byte*) ultoa::buffer#3) ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) ultoa::started#1 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) ultoa_append::digit#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (bool~) print_str::$0 ← (number) 0 != *((byte*) print_str::str#8)
Adding number conversion cast (unumber) $28 in (byte*~) print_ln::$0 ← (byte*) print_line_cursor#11 + (number) $28
Adding number conversion cast (unumber) $3e8 in (word) memset::num#0 ← (number) $3e8
Adding number conversion cast (unumber) $4000 in (word) COUNT ← (number) $4000
Adding number conversion cast (unumber) $80 in (byte) SQRT_COUNT ← (number) $80
Adding number conversion cast (unumber) $3fff in (number~) main::toD0181_$1 ← (word~) main::toD0181_$0 & (number) $3fff
Adding number conversion cast (unumber) main::toD0181_$1 in (number~) main::toD0181_$1 ← (word~) main::toD0181_$0 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$2 ← (unumber~) main::toD0181_$1 * (number) 4
Adding number conversion cast (unumber) main::toD0181_$2 in (number~) main::toD0181_$2 ← (unumber~) main::toD0181_$1 * (unumber)(number) 4
Adding number conversion cast (unumber) main::toD0181_$3 in (number~) main::toD0181_$3 ← > (unumber~) main::toD0181_$2
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$6 ← (byte~) main::toD0181_$5 / (number) 4
Adding number conversion cast (unumber) main::toD0181_$6 in (number~) main::toD0181_$6 ← (byte~) main::toD0181_$5 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) main::toD0181_$7 ← (unumber~) main::toD0181_$6 & (number) $f
Adding number conversion cast (unumber) main::toD0181_$7 in (number~) main::toD0181_$7 ← (unumber~) main::toD0181_$6 & (unumber)(number) $f
Adding number conversion cast (unumber) main::toD0181_$8 in (number~) main::toD0181_$8 ← (unumber~) main::toD0181_$3 | (unumber~) main::toD0181_$7
Adding number conversion cast (unumber) 0 in (byte) memset::c#1 ← (number) 0
Adding number conversion cast (unumber) 2 in (word) main::i#0 ← (number) 2
Adding number conversion cast (unumber) 0 in (bool~) main::$37 ← (number) 0 != *((byte*) main::sieve_i#2)
Adding number conversion cast (unumber) $64 in (number~) main::$12 ← (dword) CLOCKS_PER_SEC / (number) $64
Adding number conversion cast (unumber) main::$12 in (number~) main::$12 ← (dword) CLOCKS_PER_SEC / (unumber)(number) $64
Adding number conversion cast (unumber) 2 in (word) main::i#1 ← (number) 2
Adding number conversion cast (unumber) 2 in (number~) main::$25 ← (word) main::i#6 * (number) 2
Adding number conversion cast (unumber) main::$25 in (number~) main::$25 ← (word) main::i#6 * (unumber)(number) 2
Adding number conversion cast (unumber) 1 in *((byte*) main::s#2) ← (number) 1
Adding number conversion cast (unumber) $514 in (bool~) main::$28 ← (word) main::i#8 < (number) $514
Adding number conversion cast (unumber) 0 in (bool~) main::$38 ← (number) 0 != *((byte*) sieve#0 + (word) main::i#9)
Adding number conversion cast (unumber) $3e7 in (byte*~) main::$36 ← (byte*) SCREEN + (number) $3e7
Successful SSA optimization PassNAddNumberTypeConversions
Added casts to value list in (word[]) RADIX_BINARY_VALUES ← (word[]){ (word)(number) $8000, (word)(number) $4000, (word)(number) $2000, (word)(number) $1000, (word)(number) $800, (word)(number) $400, (word)(number) $200, (word)(number) $100, (word)(number) $80, (word)(number) $40, (word)(number) $20, (word)(number) $10, (word)(number) 8, (word)(number) 4, (word)(number) 2 }
Added casts to value list in (word[]) RADIX_OCTAL_VALUES ← (word[]){ (word)(number) $8000, (word)(number) $1000, (word)(number) $200, (word)(number) $40, (word)(number) 8 }
Added casts to value list in (word[]) RADIX_DECIMAL_VALUES ← (word[]){ (word)(number) $2710, (word)(number) $3e8, (word)(number) $64, (word)(number) $a }
Added casts to value list in (word[]) RADIX_HEXADECIMAL_VALUES ← (word[]){ (word)(number) $1000, (word)(number) $100, (word)(number) $10 }
Added casts to value list in (dword[]) RADIX_BINARY_VALUES_LONG ← (dword[]){ (dword)(number) $80000000, (dword)(number) $40000000, (dword)(number) $20000000, (dword)(number) $10000000, (dword)(number) $8000000, (dword)(number) $4000000, (dword)(number) $2000000, (dword)(number) $1000000, (dword)(number) $800000, (dword)(number) $400000, (dword)(number) $200000, (dword)(number) $100000, (dword)(number) $80000, (dword)(number) $40000, (dword)(number) $20000, (dword)(number) $10000, (dword)(number) $8000, (dword)(number) $4000, (dword)(number) $2000, (dword)(number) $1000, (dword)(number) $800, (dword)(number) $400, (dword)(number) $200, (dword)(number) $100, (dword)(number) $80, (dword)(number) $40, (dword)(number) $20, (dword)(number) $10, (dword)(number) 8, (dword)(number) 4, (dword)(number) 2 }
Added casts to value list in (dword[]) RADIX_OCTAL_VALUES_LONG ← (dword[]){ (dword)(number) $40000000, (dword)(number) $8000000, (dword)(number) $1000000, (dword)(number) $200000, (dword)(number) $40000, (dword)(number) $8000, (dword)(number) $1000, (dword)(number) $200, (dword)(number) $40, (dword)(number) 8 }
Added casts to value list in (dword[]) RADIX_DECIMAL_VALUES_LONG ← (dword[]){ (dword)(number) $3b9aca00, (dword)(number) $5f5e100, (dword)(number) $989680, (dword)(number) $f4240, (dword)(number) $186a0, (dword)(number) $2710, (dword)(number) $3e8, (dword)(number) $64, (dword)(number) $a }
Added casts to value list in (dword[]) RADIX_HEXADECIMAL_VALUES_LONG ← (dword[]){ (dword)(number) $10000000, (dword)(number) $1000000, (dword)(number) $100000, (dword)(number) $10000, (dword)(number) $1000, (dword)(number) $100, (dword)(number) $10 }
Successful SSA optimization PassNAddInitializerValueListTypeCasts
Inlining cast (byte*~) memset::$2 ← (byte*)(void*) memset::str#3
Inlining cast (byte*) memset::dst#0 ← (byte*)(void*) memset::str#3
Inlining cast (byte*) D018 ← (byte*)(number) $d018
Inlining cast (dword*) CIA2_TIMER_AB ← (dword*)(number) $dd04
Inlining cast (byte*) CIA2_TIMER_A_CONTROL ← (byte*)(number) $dd0e
Inlining cast (byte*) CIA2_TIMER_B_CONTROL ← (byte*)(number) $dd0f
Inlining cast (byte) CIA_TIMER_CONTROL_STOP ← (unumber)(number) 0
Inlining cast (byte) CIA_TIMER_CONTROL_START ← (unumber)(number) 1
Inlining cast (byte) CIA_TIMER_CONTROL_CONTINUOUS ← (unumber)(number) 0
Inlining cast (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES ← (unumber)(number) 0
Inlining cast (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A ← (unumber)(number) $40
Inlining cast (word) CLOCKS_PER_FRAME ← (unumber)(number) $4cc8
Inlining cast (byte) FRAMES_PER_SEC ← (unumber)(number) $3c
Inlining cast (dword) CLOCKS_PER_INIT ← (unumber)(number) $12
Inlining cast *((dword*) CIA2_TIMER_AB) ← (unumber)(number) $ffffffff
Inlining cast (word) rem16u#0 ← (unumber)(number) 0
Inlining cast (word) divr16u::quotient#0 ← (unumber)(number) 0
Inlining cast (word) divr16u::rem#3 ← (unumber)(number) 0
Inlining cast (byte) utoa::max_digits#1 ← (unumber)(number) 5
Inlining cast (byte) utoa::max_digits#2 ← (unumber)(number) 4
Inlining cast (byte) utoa::max_digits#3 ← (unumber)(number) 6
Inlining cast (byte) utoa::max_digits#4 ← (unumber)(number) $10
Inlining cast *((byte*) utoa::buffer#2) ← (unumber)(number) 0
Inlining cast (byte) utoa::started#0 ← (unumber)(number) 0
Inlining cast (byte) utoa::digit#0 ← (unumber)(number) 0
Inlining cast (byte~) utoa::$4 ← (byte)(word) utoa::value#3
Inlining cast *((byte*) utoa::buffer#3) ← (unumber)(number) 0
Inlining cast (byte) utoa::started#1 ← (unumber)(number) 1
Inlining cast (byte) utoa_append::digit#0 ← (unumber)(number) 0
Inlining cast (byte) ultoa::max_digits#1 ← (unumber)(number) $a
Inlining cast (byte) ultoa::max_digits#2 ← (unumber)(number) 8
Inlining cast (byte) ultoa::max_digits#3 ← (unumber)(number) $b
Inlining cast (byte) ultoa::max_digits#4 ← (unumber)(number) $20
Inlining cast *((byte*) ultoa::buffer#2) ← (unumber)(number) 0
Inlining cast (byte) ultoa::started#0 ← (unumber)(number) 0
Inlining cast (byte) ultoa::digit#0 ← (unumber)(number) 0
Inlining cast (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#3
Inlining cast *((byte*) ultoa::buffer#3) ← (unumber)(number) 0
Inlining cast (byte) ultoa::started#1 ← (unumber)(number) 1
Inlining cast (byte) ultoa_append::digit#0 ← (unumber)(number) 0
Inlining cast (byte*) print_screen#0 ← (byte*)(number) $400
Inlining cast (word) memset::num#0 ← (unumber)(number) $3e8
Inlining cast (byte*) SCREEN ← (byte*)(number) $400
Inlining cast (word) COUNT ← (unumber)(number) $4000
Inlining cast (byte) SQRT_COUNT ← (unumber)(number) $80
Inlining cast (byte*) sieve#0 ← (byte*)(number) $1000
Inlining cast (word~) main::toD0181_$0 ← (word)(byte*) main::toD0181_screen#1
Inlining cast (word~) main::toD0181_$4 ← (word)(byte*) main::toD0181_gfx#1
Inlining cast (byte) memset::c#1 ← (unumber)(number) 0
Inlining cast (word) main::i#0 ← (unumber)(number) 2
Inlining cast (word~) main::$13 ← (word)(unumber~) main::$12
Inlining cast (word~) main::$15 ← (word)(dword~) main::$14
Inlining cast (word) main::i#1 ← (unumber)(number) 2
Inlining cast *((byte*) main::s#2) ← (unumber)(number) 1
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 53272
Simplifying constant pointer cast (dword*) 56580
Simplifying constant pointer cast (byte*) 56590
Simplifying constant pointer cast (byte*) 56591
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast $4cc8
Simplifying constant integer cast $3c
Simplifying constant integer cast $12
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast (word) div32u16u::quotient_hi#1
Simplifying constant integer cast (word) div32u16u::quotient_lo#0
Simplifying constant integer cast $8000
Simplifying constant integer cast $4000
Simplifying constant integer cast $2000
Simplifying constant integer cast $1000
Simplifying constant integer cast $800
Simplifying constant integer cast $400
Simplifying constant integer cast $200
Simplifying constant integer cast $100
Simplifying constant integer cast $80
Simplifying constant integer cast $40
Simplifying constant integer cast $20
Simplifying constant integer cast $10
Simplifying constant integer cast 8
Simplifying constant integer cast 4
Simplifying constant integer cast 2
Simplifying constant integer cast $8000
Simplifying constant integer cast $1000
Simplifying constant integer cast $200
Simplifying constant integer cast $40
Simplifying constant integer cast 8
Simplifying constant integer cast $2710
Simplifying constant integer cast $3e8
Simplifying constant integer cast $64
Simplifying constant integer cast $a
Simplifying constant integer cast $1000
Simplifying constant integer cast $100
Simplifying constant integer cast $10
Simplifying constant integer cast 5
Simplifying constant integer cast 4
Simplifying constant integer cast 6
Simplifying constant integer cast $10
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $80000000
Simplifying constant integer cast $40000000
Simplifying constant integer cast $20000000
Simplifying constant integer cast $10000000
Simplifying constant integer cast $8000000
Simplifying constant integer cast $4000000
Simplifying constant integer cast $2000000
Simplifying constant integer cast $1000000
Simplifying constant integer cast $800000
Simplifying constant integer cast $400000
Simplifying constant integer cast $200000
Simplifying constant integer cast $100000
Simplifying constant integer cast $80000
Simplifying constant integer cast $40000
Simplifying constant integer cast $20000
Simplifying constant integer cast $10000
Simplifying constant integer cast $8000
Simplifying constant integer cast $4000
Simplifying constant integer cast $2000
Simplifying constant integer cast $1000
Simplifying constant integer cast $800
Simplifying constant integer cast $400
Simplifying constant integer cast $200
Simplifying constant integer cast $100
Simplifying constant integer cast $80
Simplifying constant integer cast $40
Simplifying constant integer cast $20
Simplifying constant integer cast $10
Simplifying constant integer cast 8
Simplifying constant integer cast 4
Simplifying constant integer cast 2
Simplifying constant integer cast $40000000
Simplifying constant integer cast $8000000
Simplifying constant integer cast $1000000
Simplifying constant integer cast $200000
Simplifying constant integer cast $40000
Simplifying constant integer cast $8000
Simplifying constant integer cast $1000
Simplifying constant integer cast $200
Simplifying constant integer cast $40
Simplifying constant integer cast 8
Simplifying constant integer cast $3b9aca00
Simplifying constant integer cast $5f5e100
Simplifying constant integer cast $989680
Simplifying constant integer cast $f4240
Simplifying constant integer cast $186a0
Simplifying constant integer cast $2710
Simplifying constant integer cast $3e8
Simplifying constant integer cast $64
Simplifying constant integer cast $a
Simplifying constant integer cast $10000000
Simplifying constant integer cast $1000000
Simplifying constant integer cast $100000
Simplifying constant integer cast $10000
Simplifying constant integer cast $1000
Simplifying constant integer cast $100
Simplifying constant integer cast $10
Simplifying constant integer cast $a
Simplifying constant integer cast 8
Simplifying constant integer cast $b
Simplifying constant integer cast $20
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast $3e8
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $4000
Simplifying constant integer cast $80
Simplifying constant pointer cast (byte*) 4096
Simplifying constant pointer cast (byte*) 6144
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast $64
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast $514
Simplifying constant integer cast 0
Simplifying constant integer cast $3e7
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $4cc8
Finalized unsigned number type (byte) $3c
Finalized unsigned number type (byte) $12
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (word) $4000
Finalized unsigned number type (byte) $80
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $64
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $514
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3e7
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to dword in (unumber~) clock::$0 ← (dword) $ffffffff - *((dword*) CIA2_TIMER_AB)
Inferred type updated to byte in (unumber~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80
Inferred type updated to word in (unumber~) divr16u::$5 ← (word) divr16u::rem#7 | (byte) 1
Inferred type updated to byte in (unumber~) utoa::$5 ← (byte) utoa::max_digits#5 - (byte) 1
Inferred type updated to byte in (unumber~) ultoa::$5 ← (byte) ultoa::max_digits#5 - (byte) 1
Inferred type updated to word in (unumber~) main::toD0181_$1 ← (word~) main::toD0181_$0 & (word) $3fff
Inferred type updated to word in (unumber~) main::toD0181_$2 ← (word~) main::toD0181_$1 * (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$3 ← > (word~) main::toD0181_$2
Inferred type updated to byte in (unumber~) main::toD0181_$6 ← (byte~) main::toD0181_$5 / (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$7 ← (byte~) main::toD0181_$6 & (byte) $f
Inferred type updated to byte in (unumber~) main::toD0181_$8 ← (byte~) main::toD0181_$3 | (byte~) main::toD0181_$7
Inferred type updated to dword in (unumber~) main::$12 ← (dword) CLOCKS_PER_SEC / (byte) $64
Inferred type updated to word in (unumber~) main::$25 ← (word) main::i#6 * (byte) 2
Inversing boolean not [2] (bool~) memset::$1 ← (word) memset::num#2 <= (byte) 0 from [1] (bool~) memset::$0 ← (word) memset::num#2 > (byte) 0
Inversing boolean not [63] (bool~) divr16u::$4 ← (byte~) divr16u::$2 == (byte) 0 from [62] (bool~) divr16u::$3 ← (byte~) divr16u::$2 != (byte) 0
Inversing boolean not [71] (bool~) divr16u::$9 ← (word) divr16u::rem#6 < (word) divr16u::divisor#2 from [70] (bool~) divr16u::$8 ← (word) divr16u::rem#6 >= (word) divr16u::divisor#2
Inversing boolean not [432] (bool~) main::$23 ← (byte) 0 == *((byte*) main::sieve_i#2) from [431] (bool~) main::$37 ← (byte) 0 != *((byte*) main::sieve_i#2)
Inversing boolean not [433] (bool~) main::$24 ← (byte) 0 != *((byte*) main::sieve_i#2) from [432] (bool~) main::$23 ← (byte) 0 == *((byte*) main::sieve_i#2)
Inversing boolean not [494] (bool~) main::$29 ← (byte) 0 == *((byte*) sieve#0 + (word) main::i#9) from [493] (bool~) main::$38 ← (byte) 0 != *((byte*) sieve#0 + (word) main::i#9)
Inversing boolean not [495] (bool~) main::$30 ← (byte) 0 != *((byte*) sieve#0 + (word) main::i#9) from [494] (bool~) main::$29 ← (byte) 0 == *((byte*) sieve#0 + (word) main::i#9)
Successful SSA optimization Pass2UnaryNotSimplification
Alias (void*) memset::return#0 = (void*) memset::str#2 (void*) memset::return#4 (void*) memset::return#1 
Alias (void*) memset::str#3 = (void*) memset::str#4 
Alias (word) memset::num#2 = (word) memset::num#3 
Alias (byte) memset::c#4 = (byte) memset::c#5 
Alias (byte*) memset::end#0 = (byte*~) memset::$3 
Alias (byte) memset::c#2 = (byte) memset::c#3 
Alias (byte*) memset::dst#2 = (byte*) memset::dst#3 
Alias (byte*) memset::end#1 = (byte*) memset::end#2 
Alias (void*) memset::str#5 = (void*) memset::str#6 
Alias (dword) CLOCKS_PER_SEC = (word~) $0 
Alias (dword) clock::return#0 = (dword~) clock::$0 (dword) clock::return#3 (dword) clock::return#1 
Alias (word) divr16u::rem#0 = (word~) divr16u::$0 (word) divr16u::rem#7 
Alias (word) divr16u::dividend#0 = (word~) divr16u::$6 (word) divr16u::dividend#8 
Alias (word) divr16u::quotient#1 = (word~) divr16u::$7 (word) divr16u::quotient#4 
Alias (word) divr16u::dividend#3 = (word) divr16u::dividend#7 
Alias (word) divr16u::quotient#6 = (word) divr16u::quotient#7 
Alias (word) divr16u::divisor#4 = (word) divr16u::divisor#5 
Alias (byte) divr16u::i#5 = (byte) divr16u::i#6 
Alias (word) divr16u::rem#1 = (word~) divr16u::$5 
Alias (word) divr16u::rem#6 = (word) divr16u::rem#8 
Alias (word) divr16u::divisor#2 = (word) divr16u::divisor#3 
Alias (byte) divr16u::i#3 = (byte) divr16u::i#4 
Alias (word) divr16u::rem#2 = (word~) divr16u::$10 
Alias (word) divr16u::rem#11 = (word) divr16u::rem#9 
Alias (word) divr16u::return#0 = (word) divr16u::quotient#5 (word) divr16u::quotient#8 (word) divr16u::return#4 (word) divr16u::return#1 
Alias (word) rem16u#1 = (word) rem16u#9 (word) rem16u#2 
Alias (word) divr16u::dividend#1 = (word~) div32u16u::$0 
Alias (word) divr16u::return#2 = (word) divr16u::return#5 
Alias (dword) div32u16u::dividend#1 = (dword) div32u16u::dividend#2 
Alias (word) div32u16u::divisor#1 = (word) div32u16u::divisor#2 
Alias (word) rem16u#10 = (word) rem16u#3 
Alias (word) div32u16u::quotient_hi#0 = (word~) div32u16u::$1 (word) div32u16u::quotient_hi#1 
Alias (word) divr16u::dividend#2 = (word~) div32u16u::$2 
Alias (word) divr16u::return#3 = (word) divr16u::return#6 
Alias (word) rem16u#11 = (word) rem16u#4 (word) rem16u#12 (word) rem16u#5 
Alias (word) div32u16u::quotient_lo#0 = (word~) div32u16u::$3 
Alias (dword) div32u16u::return#0 = (dword) div32u16u::quotient#0 (dword~) div32u16u::$4 (dword) div32u16u::return#3 (dword) div32u16u::return#1 
Alias (word) rem16u#0 = (word) rem16u#44 (word) rem16u#37 (word) rem16u#31 (word) rem16u#27 (word) rem16u#24 (word) rem16u#23 (word) rem16u#19 
Alias (word) utoa::value#10 = (word) utoa::value#8 (word) utoa::value#12 (word) utoa::value#13 (word) utoa::value#9 (word) utoa::value#14 (word) utoa::value#15 (word) utoa::value#11 
Alias (byte*) utoa::buffer#10 = (byte*) utoa::buffer#17 (byte*) utoa::buffer#21 (byte*) utoa::buffer#16 (byte*) utoa::buffer#18 (byte*) utoa::buffer#13 (byte*) utoa::buffer#19 (byte*) utoa::buffer#20 (byte*) utoa::buffer#6 
Alias (byte) utoa::radix#1 = (byte) utoa::radix#2 (byte) utoa::radix#3 (byte) utoa::radix#4 
Alias (byte) utoa::digit#2 = (byte) utoa::digit#3 (byte) utoa::digit#6 (byte) utoa::digit#5 
Alias (word*) utoa::digit_values#10 = (word*) utoa::digit_values#5 (word*) utoa::digit_values#6 (word*) utoa::digit_values#9 
Alias (word) utoa::value#2 = (word) utoa::value#5 (word) utoa::value#3 (word) utoa::value#4 
Alias (byte) utoa::started#2 = (byte) utoa::started#3 
Alias (byte*) utoa::buffer#11 = (byte*) utoa::buffer#12 (byte*) utoa::buffer#7 (byte*) utoa::buffer#8 (byte*) utoa::buffer#9 
Alias (byte) utoa::max_digits#10 = (byte) utoa::max_digits#8 (byte) utoa::max_digits#5 (byte) utoa::max_digits#9 
Alias (word) utoa::digit_value#0 = (word) utoa::digit_value#1 
Alias (word) utoa_append::return#0 = (word) utoa_append::return#3 
Alias (word) utoa::value#0 = (word~) utoa::$10 
Alias (byte) utoa_append::digit#2 = (byte) utoa_append::digit#4 (byte) utoa_append::digit#3 
Alias (word) utoa_append::value#2 = (word) utoa_append::value#3 (word) utoa_append::value#4 (word) utoa_append::return#1 (word) utoa_append::return#4 (word) utoa_append::return#2 
Alias (word) utoa_append::sub#1 = (word) utoa_append::sub#2 
Alias (byte*) utoa_append::buffer#1 = (byte*) utoa_append::buffer#4 (byte*) utoa_append::buffer#2 
Alias (dword) ultoa::value#10 = (dword) ultoa::value#8 (dword) ultoa::value#12 (dword) ultoa::value#13 (dword) ultoa::value#9 (dword) ultoa::value#14 (dword) ultoa::value#15 (dword) ultoa::value#11 
Alias (byte*) ultoa::buffer#10 = (byte*) ultoa::buffer#17 (byte*) ultoa::buffer#21 (byte*) ultoa::buffer#16 (byte*) ultoa::buffer#18 (byte*) ultoa::buffer#13 (byte*) ultoa::buffer#19 (byte*) ultoa::buffer#20 (byte*) ultoa::buffer#6 
Alias (byte) ultoa::radix#1 = (byte) ultoa::radix#2 (byte) ultoa::radix#3 (byte) ultoa::radix#4 
Alias (byte) ultoa::digit#2 = (byte) ultoa::digit#3 (byte) ultoa::digit#6 (byte) ultoa::digit#5 
Alias (dword*) ultoa::digit_values#10 = (dword*) ultoa::digit_values#5 (dword*) ultoa::digit_values#6 (dword*) ultoa::digit_values#9 
Alias (dword) ultoa::value#2 = (dword) ultoa::value#5 (dword) ultoa::value#3 (dword) ultoa::value#4 
Alias (byte) ultoa::started#2 = (byte) ultoa::started#3 
Alias (byte*) ultoa::buffer#11 = (byte*) ultoa::buffer#12 (byte*) ultoa::buffer#7 (byte*) ultoa::buffer#8 (byte*) ultoa::buffer#9 
Alias (byte) ultoa::max_digits#10 = (byte) ultoa::max_digits#8 (byte) ultoa::max_digits#5 (byte) ultoa::max_digits#9 
Alias (dword) ultoa::digit_value#0 = (dword) ultoa::digit_value#1 
Alias (dword) ultoa_append::return#0 = (dword) ultoa_append::return#3 
Alias (dword) ultoa::value#0 = (dword~) ultoa::$10 
Alias (byte) ultoa_append::digit#2 = (byte) ultoa_append::digit#4 (byte) ultoa_append::digit#3 
Alias (dword) ultoa_append::value#2 = (dword) ultoa_append::value#3 (dword) ultoa_append::value#4 (dword) ultoa_append::return#1 (dword) ultoa_append::return#4 (dword) ultoa_append::return#2 
Alias (dword) ultoa_append::sub#1 = (dword) ultoa_append::sub#2 
Alias (byte*) ultoa_append::buffer#1 = (byte*) ultoa_append::buffer#4 (byte*) ultoa_append::buffer#2 
Alias (byte*) print_line_cursor#0 = (byte*) print_screen#0 (byte*) print_char_cursor#0 (byte*) print_line_cursor#38 (byte*) print_char_cursor#79 (byte*) print_screen#10 (byte*) print_line_cursor#34 (byte*) print_char_cursor#75 (byte*) print_screen#9 (byte*) print_line_cursor#33 (byte*) print_char_cursor#74 (byte*) print_screen#8 (byte*) print_line_cursor#27 (byte*) print_char_cursor#65 (byte*) print_screen#7 
Alias (byte*) print_str::str#8 = (byte*) print_str::str#9 
Alias (byte*) print_char_cursor#2 = (byte*) print_char_cursor#29 (byte*) print_char_cursor#56 (byte*) print_char_cursor#30 
Alias (byte*) print_line_cursor#1 = (byte*~) print_ln::$0 (byte*) print_line_cursor#12 (byte*) print_char_cursor#3 (byte*) print_line_cursor#13 (byte*) print_char_cursor#32 (byte*) print_line_cursor#2 (byte*) print_char_cursor#4 
Alias (byte*) print_char_cursor#58 = (byte*) print_char_cursor#67 
Alias (byte*) print_char_cursor#33 = (byte*) print_char_cursor#5 (byte*) print_char_cursor#34 (byte*) print_char_cursor#6 
Alias (byte*) print_char_cursor#59 = (byte*) print_char_cursor#68 
Alias (byte*) print_char_cursor#35 = (byte*) print_char_cursor#7 (byte*) print_char_cursor#36 (byte*) print_char_cursor#8 
Alias (byte*) print_char_cursor#10 = (byte*) print_char_cursor#38 (byte*) print_char_cursor#9 
Alias (byte*) print_line_cursor#14 = (byte*) print_screen#2 (byte*) print_screen#1 (byte*) print_line_cursor#3 (byte*) print_char_cursor#11 (byte*) print_char_cursor#39 (byte*) print_line_cursor#4 (byte*) print_char_cursor#12 
Alias (byte*) main::toD0181_screen#0 = (byte*) main::toD0181_screen#1 
Alias (byte*) main::toD0181_gfx#0 = (byte*) main::toD0181_gfx#1 
Alias (byte*) print_screen#3 = (byte*) print_screen#5 (byte*) print_screen#6 (byte*) print_screen#4 
Alias (byte*) print_line_cursor#22 = (byte*) print_line_cursor#35 (byte*) print_line_cursor#39 (byte*) print_line_cursor#28 
Alias (byte*) print_char_cursor#60 = (byte*) print_char_cursor#76 (byte*) print_char_cursor#80 (byte*) print_char_cursor#69 
Alias (word) rem16u#28 = (word) rem16u#57 (word) rem16u#58 (word) rem16u#56 (word) rem16u#55 (word) rem16u#54 (word) rem16u#53 (word) rem16u#51 (word) rem16u#48 (word) rem16u#45 (word) rem16u#38 (word) rem16u#32 
Alias (byte) main::toD0181_return#0 = (byte~) main::toD0181_$8 (byte) main::toD0181_return#2 (byte) main::toD0181_return#1 (byte) main::toD0181_return#3 (byte~) main::$0 
Alias (byte*) print_line_cursor#15 = (byte*) print_line_cursor#5 (byte*) print_line_cursor#23 
Alias (byte*) print_char_cursor#13 = (byte*) print_char_cursor#40 
Alias (byte*) print_char_cursor#14 = (byte*) print_char_cursor#41 
Alias (byte*) print_line_cursor#16 = (byte*) print_line_cursor#6 (byte*) print_line_cursor#29 (byte*) print_line_cursor#24 
Alias (byte*) print_char_cursor#15 = (byte*) print_char_cursor#42 
Alias (byte*) print_char_cursor#16 = (byte*) print_char_cursor#43 
Alias (byte*) print_char_cursor#17 = (byte*) print_char_cursor#44 
Alias (byte*) print_line_cursor#17 = (byte*) print_line_cursor#7 (byte*) print_line_cursor#53 (byte*) print_line_cursor#51 
Alias (byte*) print_char_cursor#18 = (byte*) print_char_cursor#45 (byte*) print_char_cursor#84 (byte*) print_char_cursor#82 
Alias (byte*) main::sieve_i#0 = (byte*~) main::$9 
Alias (byte*) main::sieve_i#2 = (byte*) main::sieve_i#4 (byte*) main::sieve_i#6 
Alias (word) main::i#12 = (word) main::i#4 (word) main::i#6 
Alias (word) rem16u#17 = (word) rem16u#33 (word) rem16u#25 (word) rem16u#20 (word) rem16u#40 
Alias (byte*) print_char_cursor#61 = (byte*) print_char_cursor#85 (byte*) print_char_cursor#81 (byte*) print_char_cursor#77 (byte*) print_char_cursor#70 (byte*) print_char_cursor#87 
Alias (byte*) print_line_cursor#25 = (byte*) print_line_cursor#54 (byte*) print_line_cursor#49 (byte*) print_line_cursor#47 (byte*) print_line_cursor#44 (byte*) print_line_cursor#42 (byte*) print_line_cursor#40 (byte*) print_line_cursor#36 (byte*) print_line_cursor#30 (byte*) print_line_cursor#56 
Alias (dword) clock::return#2 = (dword) clock::return#4 
Alias (dword) main::cyclecount#0 = (dword~) main::$11 (dword) main::cyclecount#4 (dword) main::cyclecount#3 (dword) main::cyclecount#2 (dword) main::cyclecount#1 
Alias (word) div32u16u::divisor#0 = (word~) main::$13 
Alias (dword) div32u16u::return#2 = (dword) div32u16u::return#4 
Alias (word) rem16u#13 = (word) rem16u#6 (word) rem16u#52 (word) rem16u#49 (word) rem16u#46 (word) rem16u#39 (word) rem16u#36 
Alias (word) main::sec100s#0 = (word~) main::$15 (word) main::sec100s#1 
Alias (byte*) print_char_cursor#19 = (byte*) print_char_cursor#46 
Alias (byte*) print_char_cursor#20 = (byte*) print_char_cursor#47 
Alias (byte*) print_char_cursor#21 = (byte*) print_char_cursor#48 
Alias (byte*) print_char_cursor#22 = (byte*) print_char_cursor#49 
Alias (byte*) print_line_cursor#18 = (byte*) print_line_cursor#8 
Alias (byte*) print_char_cursor#23 = (byte*) print_char_cursor#50 
Alias (word) main::j#0 = (word~) main::$25 
Alias (byte*) main::s#0 = (byte*~) main::$26 
Alias (byte*) main::s#2 = (byte*) main::s#3 
Alias (word) main::i#13 = (word) main::i#7 
Alias (word) main::j#2 = (word) main::j#3 
Alias (byte*) main::sieve_i#5 = (byte*) main::sieve_i#7 
Alias (word) rem16u#34 = (word) rem16u#41 
Alias (byte*) print_char_cursor#86 = (byte*) print_char_cursor#88 
Alias (byte*) print_line_cursor#55 = (byte*) print_line_cursor#57 
Alias (word) main::i#11 = (word) main::i#9 (word) main::i#8 (word) main::i#15 (word) main::i#14 
Alias (byte*) print_char_cursor#62 = (byte*) print_char_cursor#72 (byte*) print_char_cursor#71 (byte*) print_char_cursor#63 
Alias (byte*) print_line_cursor#32 = (byte*) print_line_cursor#45 (byte*) print_line_cursor#41 (byte*) print_line_cursor#37 (byte*) print_line_cursor#50 (byte*) print_line_cursor#48 (byte*) print_line_cursor#46 
Alias (word) rem16u#22 = (word) rem16u#42 (word) rem16u#30 (word) rem16u#26 (word) rem16u#50 (word) rem16u#47 (word) rem16u#43 
Alias (byte*) print_char_cursor#24 = (byte*) print_char_cursor#51 
Alias (byte*) print_char_cursor#25 = (byte*) print_char_cursor#52 
Alias (byte*) print_char_cursor#26 = (byte*) print_char_cursor#53 
Alias (byte*) print_line_cursor#19 = (byte*) print_line_cursor#31 (byte*) print_line_cursor#26 (byte*) print_line_cursor#9 
Alias (byte*) print_char_cursor#27 = (byte*) print_char_cursor#73 (byte*) print_char_cursor#64 (byte*) print_char_cursor#54 
Alias (word) rem16u#14 = (word) rem16u#21 (word) rem16u#18 (word) rem16u#7 
Alias (byte*) print_line_cursor#10 = (byte*) print_line_cursor#20 
Alias (byte*) print_char_cursor#28 = (byte*) print_char_cursor#55 
Alias (word) rem16u#15 = (word) rem16u#8 
Successful SSA optimization Pass2AliasElimination
Alias (word) divr16u::dividend#3 = (word) divr16u::dividend#4 
Alias (word) divr16u::quotient#3 = (word) divr16u::quotient#6 
Alias (word) divr16u::divisor#2 = (word) divr16u::divisor#4 (word) divr16u::divisor#7 
Alias (byte) divr16u::i#2 = (byte) divr16u::i#3 (byte) divr16u::i#5 
Alias (word) divr16u::dividend#0 = (word) divr16u::dividend#6 
Alias (word) utoa::value#10 = (word) utoa::value#7 
Alias (byte*) utoa::buffer#10 = (byte*) utoa::buffer#15 
Alias (byte) utoa::digit#2 = (byte) utoa::digit#4 
Alias (byte) utoa::max_digits#10 = (byte) utoa::max_digits#6 
Alias (word*) utoa::digit_values#10 = (word*) utoa::digit_values#7 
Alias (dword) ultoa::value#10 = (dword) ultoa::value#7 
Alias (byte*) ultoa::buffer#10 = (byte*) ultoa::buffer#15 
Alias (byte) ultoa::digit#2 = (byte) ultoa::digit#4 
Alias (byte) ultoa::max_digits#10 = (byte) ultoa::max_digits#6 
Alias (dword*) ultoa::digit_values#10 = (dword*) ultoa::digit_values#7 
Alias (word) main::i#10 = (word) main::i#11 
Alias (byte*) print_line_cursor#32 = (byte*) print_line_cursor#43 
Alias (word) rem16u#22 = (word) rem16u#35 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte*) memset::end#1 (byte*) memset::end#0
Identical Phi Values (void*) memset::str#5 (void*) memset::str#3
Identical Phi Values (byte) memset::c#2 (byte) memset::c#4
Identical Phi Values (word) divr16u::divisor#2 (word) divr16u::divisor#6
Identical Phi Values (dword) div32u16u::dividend#1 (dword) div32u16u::dividend#0
Identical Phi Values (word) div32u16u::divisor#1 (word) div32u16u::divisor#0
Identical Phi Values (word) rem16u#16 (word) rem16u#17
Identical Phi Values (word) rem16u#10 (word) rem16u#1
Identical Phi Values (word) rem16u#11 (word) rem16u#1
Identical Phi Values (byte) utoa::radix#1 (byte) utoa::radix#0
Identical Phi Values (word) utoa::value#10 (word) utoa::value#1
Identical Phi Values (byte*) utoa::buffer#10 (byte*) utoa::buffer#5
Identical Phi Values (byte) utoa::max_digits#10 (byte) utoa::max_digits#7
Identical Phi Values (word*) utoa::digit_values#10 (word*) utoa::digit_values#8
Identical Phi Values (word) utoa_append::value#5 (word) utoa_append::value#0
Identical Phi Values (word) utoa_append::sub#3 (word) utoa_append::sub#0
Identical Phi Values (byte*) utoa_append::buffer#3 (byte*) utoa_append::buffer#0
Identical Phi Values (word) utoa_append::sub#1 (word) utoa_append::sub#3
Identical Phi Values (byte*) utoa_append::buffer#1 (byte*) utoa_append::buffer#3
Identical Phi Values (byte) ultoa::radix#1 (byte) ultoa::radix#0
Identical Phi Values (dword) ultoa::value#10 (dword) ultoa::value#1
Identical Phi Values (byte*) ultoa::buffer#10 (byte*) ultoa::buffer#5
Identical Phi Values (byte) ultoa::max_digits#10 (byte) ultoa::max_digits#7
Identical Phi Values (dword*) ultoa::digit_values#10 (dword*) ultoa::digit_values#8
Identical Phi Values (dword) ultoa_append::value#5 (dword) ultoa_append::value#0
Identical Phi Values (dword) ultoa_append::sub#3 (dword) ultoa_append::sub#0
Identical Phi Values (byte*) ultoa_append::buffer#3 (byte*) ultoa_append::buffer#0
Identical Phi Values (dword) ultoa_append::sub#1 (dword) ultoa_append::sub#3
Identical Phi Values (byte*) ultoa_append::buffer#1 (byte*) ultoa_append::buffer#3
Identical Phi Values (byte*) print_char_cursor#31 (byte*) print_char_cursor#57
Identical Phi Values (byte*) print_char_cursor#33 (byte*) print_char_cursor#2
Identical Phi Values (dword) print_dword_decimal::w#1 (dword) print_dword_decimal::w#0
Identical Phi Values (byte*) print_char_cursor#59 (byte*) print_char_cursor#21
Identical Phi Values (byte*) print_char_cursor#35 (byte*) print_char_cursor#2
Identical Phi Values (byte) print_char::ch#1 (byte) print_char::ch#0
Identical Phi Values (byte*) print_char_cursor#37 (byte*) print_char_cursor#25
Identical Phi Values (byte*) print_line_cursor#14 (byte*) print_screen#3
Identical Phi Values (byte*) print_screen#3 (byte*) print_line_cursor#0
Identical Phi Values (byte*) print_line_cursor#22 (byte*) print_line_cursor#0
Identical Phi Values (byte*) print_char_cursor#60 (byte*) print_line_cursor#0
Identical Phi Values (word) rem16u#28 (word) rem16u#0
Identical Phi Values (byte*) print_line_cursor#15 (byte*) print_line_cursor#14
Identical Phi Values (byte*) print_char_cursor#13 (byte*) print_line_cursor#14
Identical Phi Values (byte*) print_char_cursor#14 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_line_cursor#16 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_char_cursor#15 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_char_cursor#16 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_char_cursor#17 (byte*) print_char_cursor#33
Identical Phi Values (byte*) print_line_cursor#17 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_char_cursor#18 (byte*) print_line_cursor#1
Identical Phi Values (word) rem16u#13 (word) rem16u#11
Identical Phi Values (byte*) print_char_cursor#19 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_char_cursor#20 (byte*) print_char_cursor#33
Identical Phi Values (byte*) print_char_cursor#21 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_char_cursor#22 (byte*) print_char_cursor#35
Identical Phi Values (byte*) print_line_cursor#18 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_char_cursor#23 (byte*) print_line_cursor#1
Identical Phi Values (word) main::i#13 (word) main::i#12
Identical Phi Values (byte*) main::sieve_i#5 (byte*) main::sieve_i#2
Identical Phi Values (word) rem16u#34 (word) rem16u#17
Identical Phi Values (byte*) print_char_cursor#86 (byte*) print_char_cursor#61
Identical Phi Values (byte*) print_line_cursor#55 (byte*) print_line_cursor#25
Identical Phi Values (byte*) print_line_cursor#32 (byte*) print_line_cursor#18
Identical Phi Values (word) rem16u#22 (word) rem16u#13
Identical Phi Values (byte*) print_char_cursor#24 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_char_cursor#25 (byte*) print_char_cursor#33
Identical Phi Values (byte*) print_char_cursor#26 (byte*) print_char_cursor#10
Identical Phi Values (byte*) print_line_cursor#19 (byte*) print_line_cursor#32
Identical Phi Values (byte*) print_char_cursor#27 (byte*) print_char_cursor#24
Identical Phi Values (word) rem16u#14 (word) rem16u#22
Identical Phi Values (byte*) print_line_cursor#10 (byte*) print_line_cursor#19
Identical Phi Values (byte*) print_char_cursor#28 (byte*) print_char_cursor#27
Identical Phi Values (word) rem16u#15 (word) rem16u#14
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (void*) memset::return#0 (void*) memset::str#3
Identical Phi Values (byte*) print_char_cursor#57 (byte*) print_char_cursor#2
Identical Phi Values (word) main::i#5 (word) main::i#12
Identical Phi Values (byte*) main::sieve_i#3 (byte*) main::sieve_i#2
Identical Phi Values (word) rem16u#29 (word) rem16u#17
Identical Phi Values (byte*) print_char_cursor#83 (byte*) print_char_cursor#61
Identical Phi Values (byte*) print_line_cursor#52 (byte*) print_line_cursor#25
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (word) rem16u#17 (word) rem16u#0
Identical Phi Values (byte*) print_char_cursor#61 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_line_cursor#25 (byte*) print_line_cursor#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [42] (byte~) clock_start::$2 ← (byte) CIA_TIMER_CONTROL_STOP | (byte) CIA_TIMER_CONTROL_CONTINUOUS
Identified duplicate assignment right side [49] (byte~) clock_start::$6 ← (byte) CIA_TIMER_CONTROL_START | (byte) CIA_TIMER_CONTROL_CONTINUOUS
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) memset::$1 [3] if((word) memset::num#2<=(byte) 0) goto memset::@1
Simple Condition (bool~) memset::$4 [13] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@5
Simple Condition (bool~) divr16u::$4 [64] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2
Simple Condition (bool~) divr16u::$9 [72] if((word) divr16u::rem#6<(word) divr16u::divisor#6) goto divr16u::@3
Simple Condition (bool~) divr16u::$11 [79] if((byte) divr16u::i#1!=rangelast(0,$f)) goto divr16u::@1
Simple Condition (bool~) utoa::$0 [129] if((byte) utoa::radix#0==(const byte) DECIMAL) goto utoa::@1
Simple Condition (bool~) utoa::$1 [135] if((byte) utoa::radix#0==(const byte) HEXADECIMAL) goto utoa::@2
Simple Condition (bool~) utoa::$2 [141] if((byte) utoa::radix#0==(const byte) OCTAL) goto utoa::@3
Simple Condition (bool~) utoa::$3 [147] if((byte) utoa::radix#0==(const byte) BINARY) goto utoa::@4
Simple Condition (bool~) utoa::$6 [166] if((byte) utoa::digit#2<(byte~) utoa::$5) goto utoa::@19
Simple Condition (bool~) utoa_append::$0 [196] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2
Simple Condition (bool~) ultoa::$0 [215] if((byte) ultoa::radix#0==(const byte) DECIMAL) goto ultoa::@1
Simple Condition (bool~) ultoa::$1 [221] if((byte) ultoa::radix#0==(const byte) HEXADECIMAL) goto ultoa::@2
Simple Condition (bool~) ultoa::$2 [227] if((byte) ultoa::radix#0==(const byte) OCTAL) goto ultoa::@3
Simple Condition (bool~) ultoa::$3 [233] if((byte) ultoa::radix#0==(const byte) BINARY) goto ultoa::@4
Simple Condition (bool~) ultoa::$6 [252] if((byte) ultoa::digit#2<(byte~) ultoa::$5) goto ultoa::@19
Simple Condition (bool~) ultoa_append::$0 [282] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2
Simple Condition (bool~) print_str::$0 [299] if((byte) 0!=*((byte*) print_str::str#8)) goto print_str::@2
Simple Condition (bool~) print_ln::$1 [312] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1
Simple Condition (bool~) main::$22 [429] if((word) main::i#12<(byte) SQRT_COUNT) goto main::@2
Simple Condition (bool~) main::$24 [434] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4
Simple Condition (bool~) main::$27 [484] if((word) main::j#2<(word) COUNT) goto main::@6
Simple Condition (bool~) main::$28 [491] if((word) main::i#10<(word) $514) goto main::@16
Simple Condition (bool~) main::$30 [496] if((byte) 0!=*((byte*) sieve#0 + (word) main::i#10)) goto main::@18
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting ! if()-condition to reversed if() [172] (bool~) utoa::$9 ← ! (bool~) utoa::$8
Rewriting || if()-condition to two if()s [171] (bool~) utoa::$8 ← (byte) utoa::started#2 || (bool~) utoa::$7
Rewriting ! if()-condition to reversed if() [258] (bool~) ultoa::$9 ← ! (bool~) ultoa::$8
Rewriting || if()-condition to two if()s [257] (bool~) ultoa::$8 ← (byte) ultoa::started#2 || (bool~) ultoa::$7
Successful SSA optimization Pass2ConditionalAndOrRewriting
Warning! Adding boolean cast to non-boolean condition (byte) utoa::started#2
Warning! Adding boolean cast to non-boolean condition (byte) ultoa::started#2
Rewriting array member address-of to pointer addition [425] (byte*) main::sieve_i#0 ← (byte*) sieve#0 + (word) main::i#0
Rewriting array member address-of to pointer addition [480] (byte*) main::s#0 ← (byte*) sieve#0 + (word) main::j#0
Successful SSA optimization PassNArrayElementAddressOfRewriting
Constant right-side identified [320] (byte[6]) decimal_digits ← { fill( 6, 0) }
Constant right-side identified [335] (byte[$b]) decimal_digits_long ← { fill( $b, 0) }
Successful SSA optimization Pass2ConstantRValueConsolidation
Identified constant from value list (word[]) { (word) $8000, (word) $4000, (word) $2000, (word) $1000, (word) $800, (word) $400, (word) $200, (word) $100, (word) $80, (word) $40, (word) $20, (word) $10, (word) 8, (word) 4, (word) 2 }
Identified constant from value list (word[]) { (word) $8000, (word) $1000, (word) $200, (word) $40, (word) 8 }
Identified constant from value list (word[]) { (word) $2710, (word) $3e8, (word) $64, (word) $a }
Identified constant from value list (word[]) { (word) $1000, (word) $100, (word) $10 }
Identified constant from value list (dword[]) { (dword) $80000000, (dword) $40000000, (dword) $20000000, (dword) $10000000, (dword) $8000000, (dword) $4000000, (dword) $2000000, (dword) $1000000, (dword) $800000, (dword) $400000, (dword) $200000, (dword) $100000, (dword) $80000, (dword) $40000, (dword) $20000, (dword) $10000, (dword) $8000, (dword) $4000, (dword) $2000, (dword) $1000, (dword) $800, (dword) $400, (dword) $200, (dword) $100, (dword) $80, (dword) $40, (dword) $20, (dword) $10, (dword) 8, (dword) 4, (dword) 2 }
Identified constant from value list (dword[]) { (dword) $40000000, (dword) $8000000, (dword) $1000000, (dword) $200000, (dword) $40000, (dword) $8000, (dword) $1000, (dword) $200, (dword) $40, (dword) 8 }
Identified constant from value list (dword[]) { (dword) $3b9aca00, (dword) $5f5e100, (dword) $989680, (dword) $f4240, (dword) $186a0, (dword) $2710, (dword) $3e8, (dword) $64, (dword) $a }
Identified constant from value list (dword[]) { (dword) $10000000, (dword) $1000000, (dword) $100000, (dword) $10000, (dword) $1000, (dword) $100, (dword) $10 }
Successful SSA optimization Pass2ConstantInitializerValueLists
Constant (const byte*) D018 = (byte*) 53272
Constant (const dword*) CIA2_TIMER_AB = (dword*) 56580
Constant (const byte*) CIA2_TIMER_A_CONTROL = (byte*) 56590
Constant (const byte*) CIA2_TIMER_B_CONTROL = (byte*) 56591
Constant (const byte) CIA_TIMER_CONTROL_STOP = 0
Constant (const byte) CIA_TIMER_CONTROL_START = 1
Constant (const byte) CIA_TIMER_CONTROL_CONTINUOUS = 0
Constant (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES = 0
Constant (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
Constant (const word) CLOCKS_PER_FRAME = $4cc8
Constant (const byte) FRAMES_PER_SEC = $3c
Constant (const dword) CLOCKS_PER_INIT = $12
Constant (const word) rem16u#0 = 0
Constant (const word) divr16u::quotient#0 = 0
Constant (const byte) divr16u::i#0 = 0
Constant (const word) divr16u::rem#3 = 0
Constant (const byte[]) DIGITS = $1
Constant (const word[]) RADIX_BINARY_VALUES = { $8000, $4000, $2000, $1000, $800, $400, $200, $100, $80, $40, $20, $10, 8, 4, 2 }
Constant (const word[]) RADIX_OCTAL_VALUES = { $8000, $1000, $200, $40, 8 }
Constant (const word[]) RADIX_DECIMAL_VALUES = { $2710, $3e8, $64, $a }
Constant (const word[]) RADIX_HEXADECIMAL_VALUES = { $1000, $100, $10 }
Constant (const byte) utoa::max_digits#0 = 0
Constant (const word*) utoa::digit_values#0 = (word*) 0
Constant (const byte) utoa::max_digits#1 = 5
Constant (const byte) utoa::max_digits#2 = 4
Constant (const byte) utoa::max_digits#3 = 6
Constant (const byte) utoa::max_digits#4 = $10
Constant (const byte) utoa::started#0 = 0
Constant (const byte) utoa::digit#0 = 0
Constant (const byte) utoa::started#1 = 1
Constant (const byte) utoa_append::digit#0 = 0
Constant (const dword[]) RADIX_BINARY_VALUES_LONG = { $80000000, $40000000, $20000000, $10000000, $8000000, $4000000, $2000000, $1000000, $800000, $400000, $200000, $100000, $80000, $40000, $20000, $10000, $8000, $4000, $2000, $1000, $800, $400, $200, $100, $80, $40, $20, $10, 8, 4, 2 }
Constant (const dword[]) RADIX_OCTAL_VALUES_LONG = { $40000000, $8000000, $1000000, $200000, $40000, $8000, $1000, $200, $40, 8 }
Constant (const dword[]) RADIX_DECIMAL_VALUES_LONG = { $3b9aca00, $5f5e100, $989680, $f4240, $186a0, $2710, $3e8, $64, $a }
Constant (const dword[]) RADIX_HEXADECIMAL_VALUES_LONG = { $10000000, $1000000, $100000, $10000, $1000, $100, $10 }
Constant (const byte) ultoa::max_digits#0 = 0
Constant (const dword*) ultoa::digit_values#0 = (dword*) 0
Constant (const byte) ultoa::max_digits#1 = $a
Constant (const byte) ultoa::max_digits#2 = 8
Constant (const byte) ultoa::max_digits#3 = $b
Constant (const byte) ultoa::max_digits#4 = $20
Constant (const byte) ultoa::started#0 = 0
Constant (const byte) ultoa::digit#0 = 0
Constant (const byte) ultoa::started#1 = 1
Constant (const byte) ultoa_append::digit#0 = 0
Constant (const byte*) print_line_cursor#0 = (byte*) 1024
Constant (const byte[6]) decimal_digits = { fill( 6, 0) }
Constant (const byte) utoa::radix#0 = DECIMAL
Constant (const byte[$b]) decimal_digits_long = { fill( $b, 0) }
Constant (const byte) ultoa::radix#0 = DECIMAL
Constant (const byte) memset::c#0 = ' '
Constant (const word) memset::num#0 = $3e8
Constant (const byte*) SCREEN = (byte*) 1024
Constant (const word) COUNT = $4000
Constant (const byte) SQRT_COUNT = $80
Constant (const byte*) sieve#0 = (byte*) 4096
Constant (const byte*) main::toD0181_gfx#0 = (byte*) 6144
Constant (const byte*) print_str::str#3 = main::str
Constant (const byte*) print_str::str#4 = main::str1
Constant (const byte) memset::c#1 = 0
Constant (const word) main::i#0 = 2
Constant (const byte*) print_str::str#5 = main::str2
Constant (const byte*) print_str::str#6 = main::str3
Constant (const word) main::i#1 = 2
Constant (const byte*) print_str::str#7 = main::str4
Constant (const byte) print_char::ch#0 = ' '
Successful SSA optimization Pass2ConstantIdentification
Constant (const word*) utoa::digit_values#1 = RADIX_DECIMAL_VALUES
Constant (const word*) utoa::digit_values#2 = RADIX_HEXADECIMAL_VALUES
Constant (const word*) utoa::digit_values#3 = RADIX_OCTAL_VALUES
Constant (const word*) utoa::digit_values#4 = RADIX_BINARY_VALUES
Constant (const dword*) ultoa::digit_values#1 = RADIX_DECIMAL_VALUES_LONG
Constant (const dword*) ultoa::digit_values#2 = RADIX_HEXADECIMAL_VALUES_LONG
Constant (const dword*) ultoa::digit_values#3 = RADIX_OCTAL_VALUES_LONG
Constant (const dword*) ultoa::digit_values#4 = RADIX_BINARY_VALUES_LONG
Constant (const byte*) utoa::buffer#5 = decimal_digits
Constant (const byte*) print_str::str#1 = decimal_digits
Constant (const byte*) ultoa::buffer#5 = decimal_digits_long
Constant (const byte*) print_str::str#2 = decimal_digits_long
Constant (const byte*) main::toD0181_screen#0 = SCREEN
Constant (const word) print_word_decimal::w#0 = COUNT
Constant (const word) memset::num#1 = COUNT
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (void*)print_line_cursor#0 in [356] (void*) memset::str#0 ← (void*)(const byte*) print_line_cursor#0
Constant value identified (word)main::toD0181_screen#0 in [377] (word~) main::toD0181_$0 ← (word)(const byte*) main::toD0181_screen#0
Constant value identified (word)main::toD0181_gfx#0 in [381] (word~) main::toD0181_$4 ← (word)(const byte*) main::toD0181_gfx#0
Constant value identified (void*)sieve#0 in [416] (void*) memset::str#1 ← (void*)(const byte*) sieve#0
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [129] if((const byte) utoa::radix#0==(const byte) DECIMAL) goto utoa::@1
if() condition always false - eliminating [135] if((const byte) utoa::radix#0==(const byte) HEXADECIMAL) goto utoa::@2
if() condition always false - eliminating [141] if((const byte) utoa::radix#0==(const byte) OCTAL) goto utoa::@3
if() condition always false - eliminating [147] if((const byte) utoa::radix#0==(const byte) BINARY) goto utoa::@4
if() condition always true - replacing block destination [215] if((const byte) ultoa::radix#0==(const byte) DECIMAL) goto ultoa::@1
if() condition always false - eliminating [221] if((const byte) ultoa::radix#0==(const byte) HEXADECIMAL) goto ultoa::@2
if() condition always false - eliminating [227] if((const byte) ultoa::radix#0==(const byte) OCTAL) goto ultoa::@3
if() condition always false - eliminating [233] if((const byte) ultoa::radix#0==(const byte) BINARY) goto ultoa::@4
if() condition always true - replacing block destination [514] if(true) goto main::@24
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [77] divr16u::i#1 ← ++ divr16u::i#2 to ++
Resolved ranged comparison value [79] if(divr16u::i#1!=rangelast(0,$f)) goto divr16u::@1 to (number) $10
De-inlining pointer[w] to *(pointer+w)   [496] if((byte) 0!=*((const byte*) sieve#0 + (word) main::i#10)) goto main::@18
Successful SSA optimization Pass2DeInlineWordDerefIdx
Simplifying expression containing zero CIA_TIMER_CONTROL_CONTINUOUS in [39] (byte~) clock_start::$0 ← (const byte) CIA_TIMER_CONTROL_STOP | (const byte) CIA_TIMER_CONTROL_CONTINUOUS
Simplifying expression containing zero clock_start::$0 in [40] (byte~) clock_start::$1 ← (byte~) clock_start::$0 | (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
Simplifying expression containing zero CIA_TIMER_CONTROL_START in [46] (byte~) clock_start::$4 ← (const byte) CIA_TIMER_CONTROL_START | (const byte) CIA_TIMER_CONTROL_CONTINUOUS
Simplifying expression containing zero clock_start::$6 in [50] (byte~) clock_start::$7 ← (byte~) clock_start::$6 | (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable (void*) memset::return#2 and assignment [156] (void*) memset::return#2 ← (void*) memset::str#3
Eliminating unused variable (void*) memset::return#3 and assignment [176] (void*) memset::return#3 ← (void*) memset::str#3
Eliminating unused constant (const byte) BINARY
Eliminating unused constant (const byte) OCTAL
Eliminating unused constant (const byte) HEXADECIMAL
Eliminating unused constant (const byte) utoa::max_digits#0
Eliminating unused constant (const word*) utoa::digit_values#0
Eliminating unused constant (const byte) utoa::radix#0
Eliminating unused constant (const byte) ultoa::max_digits#0
Eliminating unused constant (const dword*) ultoa::digit_values#0
Eliminating unused constant (const byte) ultoa::radix#0
Eliminating unused constant (const byte) CIA_TIMER_CONTROL_STOP
Eliminating unused constant (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
Eliminating unused constant (const word) rem16u#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte) DECIMAL
Successful SSA optimization PassNEliminateUnusedVars
Eliminating variable (byte*) utoa::buffer#0 from unused block utoa::@12
Eliminating variable (byte*) utoa::buffer#1 from unused block utoa::@12
Eliminating variable (byte*) utoa::buffer#2 from unused block utoa::@12
Eliminating variable (byte*) ultoa::buffer#0 from unused block ultoa::@12
Eliminating variable (byte*) ultoa::buffer#1 from unused block ultoa::@12
Eliminating variable (byte*) ultoa::buffer#2 from unused block ultoa::@12
Removing unused block utoa::@9
Removing PHI-reference to removed block (utoa::@2) in block utoa::@8
Removing PHI-reference to removed block (utoa::@2) in block utoa::@8
Removing unused block utoa::@2
Removing unused block utoa::@10
Removing PHI-reference to removed block (utoa::@3) in block utoa::@8
Removing PHI-reference to removed block (utoa::@3) in block utoa::@8
Removing unused block utoa::@3
Removing unused block utoa::@11
Removing PHI-reference to removed block (utoa::@4) in block utoa::@8
Removing PHI-reference to removed block (utoa::@4) in block utoa::@8
Removing unused block utoa::@4
Removing unused block utoa::@12
Removing unused block ultoa::@9
Removing PHI-reference to removed block (ultoa::@2) in block ultoa::@8
Removing PHI-reference to removed block (ultoa::@2) in block ultoa::@8
Removing unused block ultoa::@2
Removing unused block ultoa::@10
Removing PHI-reference to removed block (ultoa::@3) in block ultoa::@8
Removing PHI-reference to removed block (ultoa::@3) in block ultoa::@8
Removing unused block ultoa::@3
Removing unused block ultoa::@11
Removing PHI-reference to removed block (ultoa::@4) in block ultoa::@8
Removing PHI-reference to removed block (ultoa::@4) in block ultoa::@8
Removing unused block ultoa::@4
Removing unused block ultoa::@12
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) $10 in if((byte) divr16u::i#1!=(number) $10) goto divr16u::@1
Adding number conversion cast (unumber) 0 in (bool~) utoa::$12 ← (number) 0 != (byte) utoa::started#2
Adding number conversion cast (unumber) 0 in (bool~) ultoa::$12 ← (number) 0 != (byte) ultoa::started#2
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $10
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias (byte~) clock_start::$1 = (byte~) clock_start::$0 (byte~) clock_start::$2 
Alias (byte~) clock_start::$6 = (byte~) clock_start::$4 (byte~) clock_start::$7 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) utoa::max_digits#7 (const byte) utoa::max_digits#1
Identical Phi Values (word*) utoa::digit_values#8 (const word*) utoa::digit_values#1
Identical Phi Values (byte) ultoa::max_digits#7 (const byte) ultoa::max_digits#1
Identical Phi Values (dword*) ultoa::digit_values#8 (const dword*) ultoa::digit_values#1
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) utoa::$12 [67] if((byte) 0!=(byte) utoa::started#2) goto utoa::@24
Simple Condition (bool~) ultoa::$12 [96] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@24
Simple Condition (bool~) utoa::$7 [206] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@24
Simple Condition (bool~) ultoa::$7 [207] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@24
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [10] (dword) CLOCKS_PER_SEC ← (const word) CLOCKS_PER_FRAME * (const byte) FRAMES_PER_SEC
Constant right-side identified [61] (byte~) utoa::$5 ← (const byte) utoa::max_digits#1 - (byte) 1
Constant right-side identified [90] (byte~) ultoa::$5 ← (const byte) ultoa::max_digits#1 - (byte) 1
Constant right-side identified [162] (byte*) main::sieve_i#0 ← (const byte*) sieve#0 + (const word) main::i#0
Constant right-side identified [203] (byte*~) main::$36 ← (const byte*) SCREEN + (word) $3e7
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const dword) CLOCKS_PER_SEC = CLOCKS_PER_FRAME*FRAMES_PER_SEC
Constant (const byte) clock_start::$1 = CIA_TIMER_CONTROL_CONTINUOUS
Constant (const byte) clock_start::$6 = CIA_TIMER_CONTROL_START
Constant (const byte) utoa::$5 = utoa::max_digits#1-1
Constant (const byte) ultoa::$5 = ultoa::max_digits#1-1
Constant (const void*) memset::str#0 = (void*)print_line_cursor#0
Constant (const word) main::toD0181_$0 = (word)main::toD0181_screen#0
Constant (const word) main::toD0181_$4 = (word)main::toD0181_gfx#0
Constant (const void*) memset::str#1 = (void*)sieve#0
Constant (const byte*) main::sieve_i#0 = sieve#0+main::i#0
Constant (const byte*) main::$36 = SCREEN+$3e7
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A in [17] (byte~) clock_start::$3 ← (const byte) clock_start::$1 | (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) utoa::max_digits#2
Eliminating unused constant (const byte) utoa::max_digits#3
Eliminating unused constant (const byte) utoa::max_digits#4
Eliminating unused constant (const word*) utoa::digit_values#2
Eliminating unused constant (const word*) utoa::digit_values#3
Eliminating unused constant (const word*) utoa::digit_values#4
Eliminating unused constant (const byte) ultoa::max_digits#2
Eliminating unused constant (const byte) ultoa::max_digits#3
Eliminating unused constant (const byte) ultoa::max_digits#4
Eliminating unused constant (const dword*) ultoa::digit_values#2
Eliminating unused constant (const dword*) ultoa::digit_values#3
Eliminating unused constant (const dword*) ultoa::digit_values#4
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const word[]) RADIX_BINARY_VALUES
Eliminating unused constant (const word[]) RADIX_OCTAL_VALUES
Eliminating unused constant (const word[]) RADIX_HEXADECIMAL_VALUES
Eliminating unused constant (const dword[]) RADIX_BINARY_VALUES_LONG
Eliminating unused constant (const dword[]) RADIX_OCTAL_VALUES_LONG
Eliminating unused constant (const dword[]) RADIX_HEXADECIMAL_VALUES_LONG
Successful SSA optimization PassNEliminateUnusedVars
Constant right-side identified [16] (byte~) clock_start::$5 ← (const byte) clock_start::$6 | (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Constant right-side identified [127] (word~) main::toD0181_$1 ← (const word) main::toD0181_$0 & (word) $3fff
Constant right-side identified [130] (byte~) main::toD0181_$5 ← > (const word) main::toD0181_$4
Constant right-side identified [150] (dword~) main::$12 ← (const dword) CLOCKS_PER_SEC / (byte) $64
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) clock_start::$3 = CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Constant (const byte) clock_start::$5 = clock_start::$6|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Constant (const word) main::toD0181_$1 = main::toD0181_$0&$3fff
Constant (const byte) main::toD0181_$5 = >main::toD0181_$4
Constant (const dword) main::$12 = CLOCKS_PER_SEC/$64
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)main::$12 in [151] (word) div32u16u::divisor#0 ← (word)(const dword) main::$12
Successful SSA optimization Pass2ConstantValues
Constant right-side identified [125] (word~) main::toD0181_$2 ← (const word) main::toD0181_$1 * (byte) 4
Constant right-side identified [127] (byte~) main::toD0181_$6 ← (const byte) main::toD0181_$5 / (byte) 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::toD0181_$2 = main::toD0181_$1*4
Constant (const byte) main::toD0181_$6 = main::toD0181_$5/4
Constant (const word) div32u16u::divisor#0 = (word)main::$12
Successful SSA optimization Pass2ConstantIdentification
Constant (const word) divr16u::divisor#0 = div32u16u::divisor#0
Constant (const word) divr16u::divisor#1 = div32u16u::divisor#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [123] (byte~) main::toD0181_$3 ← > (const word) main::toD0181_$2
Constant right-side identified [124] (byte~) main::toD0181_$7 ← (const byte) main::toD0181_$6 & (byte) $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::toD0181_$3 = >main::toD0181_$2
Constant (const byte) main::toD0181_$7 = main::toD0181_$6&$f
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [123] (byte) main::toD0181_return#0 ← (const byte) main::toD0181_$3 | (const byte) main::toD0181_$7
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::toD0181_return#0 = main::toD0181_$3|main::toD0181_$7
Successful SSA optimization Pass2ConstantIdentification
Inlining Noop Cast [2] (byte*~) memset::$2 ← (byte*)(void*) memset::str#3 keeping memset::str#3
Inlining Noop Cast [4] (byte*) memset::dst#0 ← (byte*)(void*) memset::str#3 keeping memset::str#3
Successful SSA optimization Pass2NopCastInlining
Rewriting multiplication to use shift [50] (byte~) utoa::$11 ← (byte) utoa::digit#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [75] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 * (const byte) SIZEOF_DWORD
Rewriting multiplication to use shift [153] (word) main::j#0 ← (word) main::i#12 * (byte) 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) memset::c#0
Inlining constant with var siblings (const word) memset::num#0
Inlining constant with var siblings (const byte) memset::c#1
Inlining constant with var siblings (const word) memset::num#1
Inlining constant with var siblings (const void*) memset::str#0
Inlining constant with var siblings (const void*) memset::str#1
Inlining constant with var siblings (const word) divr16u::quotient#0
Inlining constant with var siblings (const byte) divr16u::i#0
Inlining constant with var siblings (const word) divr16u::rem#3
Inlining constant with var siblings (const word) divr16u::divisor#0
Inlining constant with var siblings (const word) divr16u::divisor#1
Inlining constant with var siblings (const byte) utoa::started#0
Inlining constant with var siblings (const byte) utoa::digit#0
Inlining constant with var siblings (const byte) utoa::started#1
Inlining constant with var siblings (const byte*) utoa::buffer#5
Inlining constant with var siblings (const byte) utoa_append::digit#0
Inlining constant with var siblings (const byte) ultoa::started#0
Inlining constant with var siblings (const byte) ultoa::digit#0
Inlining constant with var siblings (const byte) ultoa::started#1
Inlining constant with var siblings (const byte*) ultoa::buffer#5
Inlining constant with var siblings (const byte) ultoa_append::digit#0
Inlining constant with var siblings (const byte*) print_str::str#3
Inlining constant with var siblings (const byte*) print_str::str#4
Inlining constant with var siblings (const byte*) print_str::str#5
Inlining constant with var siblings (const byte*) print_str::str#6
Inlining constant with var siblings (const byte*) print_str::str#7
Inlining constant with var siblings (const byte*) print_str::str#1
Inlining constant with var siblings (const byte*) print_str::str#2
Inlining constant with var siblings (const word) print_word_decimal::w#0
Inlining constant with var siblings (const word) main::i#0
Inlining constant with var siblings (const word) main::i#1
Inlining constant with var siblings (const byte*) main::sieve_i#0
Inlining constant with var siblings (const byte*) print_line_cursor#0
Constant inlined utoa::digit_values#1 = (const word[]) RADIX_DECIMAL_VALUES
Constant inlined divr16u::rem#3 = (byte) 0
Constant inlined main::$12 = (const dword) CLOCKS_PER_SEC/(byte) $64
Constant inlined memset::num#1 = (const word) COUNT
Constant inlined memset::num#0 = (word) $3e8
Constant inlined clock_start::$5 = (const byte) CIA_TIMER_CONTROL_START|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Constant inlined clock_start::$6 = (const byte) CIA_TIMER_CONTROL_START
Constant inlined $1 = (const byte[]) DIGITS
Constant inlined clock_start::$3 = (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Constant inlined utoa::$5 = (const byte) utoa::max_digits#1-(byte) 1
Constant inlined main::toD0181_$7 = >(word)(const byte*) main::toD0181_gfx#0/(byte) 4&(byte) $f
Constant inlined print_line_cursor#0 = (byte*) 1024
Constant inlined main::toD0181_$2 = (word)(const byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined main::toD0181_$1 = (word)(const byte*) SCREEN&(word) $3fff
Constant inlined main::toD0181_$0 = (word)(const byte*) SCREEN
Constant inlined ultoa::started#1 = (byte) 1
Constant inlined main::toD0181_$6 = >(word)(const byte*) main::toD0181_gfx#0/(byte) 4
Constant inlined main::toD0181_$5 = >(word)(const byte*) main::toD0181_gfx#0
Constant inlined main::toD0181_$4 = (word)(const byte*) main::toD0181_gfx#0
Constant inlined main::toD0181_$3 = >(word)(const byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined utoa::buffer#5 = (const byte[6]) decimal_digits
Constant inlined ultoa::digit#0 = (byte) 0
Constant inlined print_str::str#4 = (const string) main::str1
Constant inlined print_str::str#3 = (const string) main::str
Constant inlined print_str::str#2 = (const byte[$b]) decimal_digits_long
Constant inlined print_str::str#1 = (const byte[6]) decimal_digits
Constant inlined memset::c#0 = (byte) ' '
Constant inlined memset::c#1 = (byte) 0
Constant inlined print_str::str#7 = (const string) main::str4
Constant inlined print_str::str#6 = (const string) main::str3
Constant inlined print_str::str#5 = (const string) main::str2
Constant inlined utoa_append::digit#0 = (byte) 0
Constant inlined main::toD0181_screen#0 = (const byte*) SCREEN
Constant inlined divr16u::i#0 = (byte) 0
Constant inlined main::$36 = (const byte*) SCREEN+(word) $3e7
Constant inlined divr16u::quotient#0 = (byte) 0
Constant inlined ultoa::buffer#5 = (const byte[$b]) decimal_digits_long
Constant inlined ultoa::$5 = (const byte) ultoa::max_digits#1-(byte) 1
Constant inlined ultoa::started#0 = (byte) 0
Constant inlined utoa::digit#0 = (byte) 0
Constant inlined main::i#0 = (byte) 2
Constant inlined main::i#1 = (byte) 2
Constant inlined divr16u::divisor#1 = (const word) div32u16u::divisor#0
Constant inlined divr16u::divisor#0 = (const word) div32u16u::divisor#0
Constant inlined print_word_decimal::w#0 = (const word) COUNT
Constant inlined memset::str#1 = (void*)(const byte*) sieve#0
Constant inlined memset::str#0 = (void*)(byte*) 1024
Constant inlined utoa::started#1 = (byte) 1
Constant inlined utoa::started#0 = (byte) 0
Constant inlined clock_start::$1 = (const byte) CIA_TIMER_CONTROL_CONTINUOUS
Constant inlined ultoa_append::digit#0 = (byte) 0
Constant inlined ultoa::digit_values#1 = (const dword[]) RADIX_DECIMAL_VALUES_LONG
Constant inlined main::sieve_i#0 = (const byte*) sieve#0+(byte) 2
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values (word) divr16u::divisor#6 (const word) div32u16u::divisor#0
Successful SSA optimization Pass2IdenticalPhiElimination
Eliminating unused constant (const byte) SIZEOF_WORD
Eliminating unused constant (const byte) SIZEOF_DWORD
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting divr16u::@8(between divr16u::@3 and divr16u::@1)
Added new block during phi lifting divr16u::@9(between divr16u::@1 and divr16u::@2)
Added new block during phi lifting divr16u::@10(between divr16u::@2 and divr16u::@3)
Added new block during phi lifting utoa::@28(between utoa::@27 and utoa::@21)
Added new block during phi lifting ultoa::@28(between ultoa::@27 and ultoa::@21)
Added new block during phi lifting print_ln::@3(between print_ln::@1 and print_ln::@1)
Added new block during phi lifting main::@48(between main::@16 and main::@18)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @8
Adding NOP phi() at start of @12
Adding NOP phi() at start of @22
Adding NOP phi() at start of @24
Adding NOP phi() at start of @26
Adding NOP phi() at start of @36
Adding NOP phi() at start of @40
Adding NOP phi() at start of @50
Adding NOP phi() at start of @51
Adding NOP phi() at start of @52
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0181_@return
Adding NOP phi() at start of main::@30
Adding NOP phi() at start of main::@31
Adding NOP phi() at start of main::@35
Adding NOP phi() at start of main::@36
Adding NOP phi() at start of main::@37
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@45
Adding NOP phi() at start of main::@23
Adding NOP phi() at start of main::@46
Adding NOP phi() at start of print_word_decimal::@2
Adding NOP phi() at start of utoa
Adding NOP phi() at start of utoa::@1
Adding NOP phi() at start of print_ln::@2
Adding NOP phi() at start of print_dword_decimal::@2
Adding NOP phi() at start of ultoa
Adding NOP phi() at start of ultoa::@1
Adding NOP phi() at start of memset::@1
Adding NOP phi() at start of print_cls
Adding NOP phi() at start of print_cls::@1
CALL GRAPH
Calls in [] to main:11 
Calls in [main] to print_cls:18 print_str:20 print_ln:22 print_str:24 print_word_decimal:26 print_ln:28 memset:30 clock_start:32 clock:37 div32u16u:42 print_str:47 print_word_decimal:51 print_str:53 print_dword_decimal:55 print_ln:57 print_str:62 print_word_decimal:71 print_char:73 
Calls in [print_word_decimal] to utoa:101 print_str:103 
Calls in [utoa] to utoa_append:143 
Calls in [print_dword_decimal] to ultoa:167 print_str:169 
Calls in [ultoa] to ultoa_append:198 
Calls in [div32u16u] to divr16u:215 divr16u:222 
Calls in [print_cls] to memset:277 

Created 46 initial phi equivalence classes
Not coalescing [23] print_char_cursor#90 ← print_line_cursor#1
Coalesced [25] print_char_cursor#98 ← print_char_cursor#2
Coalesced [27] print_line_cursor#58 ← print_line_cursor#1
Not coalescing [46] print_char_cursor#91 ← print_line_cursor#1
Coalesced [49] print_word_decimal::w#5 ← print_word_decimal::w#1
Coalesced (already) [50] print_char_cursor#99 ← print_char_cursor#2
Coalesced [52] print_char_cursor#92 ← print_char_cursor#2
Coalesced (already) [56] print_line_cursor#59 ← print_line_cursor#1
Coalesced [58] print_char_cursor#101 ← print_line_cursor#1
Not coalescing [61] print_char_cursor#89 ← print_char_cursor#62
Coalesced [69] print_word_decimal::w#4 ← print_word_decimal::w#2
Not coalescing [70] print_char_cursor#97 ← print_char_cursor#62
Coalesced [74] print_char_cursor#103 ← print_char_cursor#10
Coalesced [77] main::i#17 ← main::i#3
Coalesced [78] print_char_cursor#100 ← print_char_cursor#78
Coalesced (already) [79] print_char_cursor#102 ← print_char_cursor#62
Coalesced [83] main::j#4 ← main::j#0
Coalesced [84] main::s#4 ← main::s#0
Coalesced [89] main::i#16 ← main::i#2
Coalesced [90] main::sieve_i#8 ← main::sieve_i#1
Coalesced [94] main::j#5 ← main::j#1
Coalesced [95] main::s#5 ← main::s#1
Coalesced (already) [102] print_char_cursor#94 ← print_char_cursor#58
Coalesced [107] print_str::str#11 ← print_str::str#10
Coalesced (already) [108] print_char_cursor#95 ← print_char_cursor#66
Coalesced [115] print_str::str#12 ← print_str::str#0
Coalesced [116] print_char_cursor#96 ← print_char_cursor#1
Coalesced [119] utoa::value#17 ← utoa::value#1
Coalesced [131] utoa::value#18 ← utoa::value#2
Coalesced [132] utoa::started#6 ← utoa::started#2
Coalesced [133] utoa::buffer#23 ← utoa::buffer#11
Coalesced [136] utoa::digit#7 ← utoa::digit#1
Coalesced (already) [137] utoa::value#16 ← utoa::value#6
Coalesced (already) [138] utoa::started#5 ← utoa::started#4
Coalesced (already) [139] utoa::buffer#22 ← utoa::buffer#14
Coalesced [147] utoa::value#19 ← utoa::value#0
Coalesced [148] utoa::buffer#24 ← utoa::buffer#4
Coalesced [149] utoa_append::value#6 ← utoa_append::value#0
Coalesced [156] utoa_append::value#7 ← utoa_append::value#1
Coalesced [157] utoa_append::digit#5 ← utoa_append::digit#1
Coalesced [159] print_line_cursor#60 ← print_line_cursor#21
Coalesced (already) [165] print_line_cursor#61 ← print_line_cursor#1
Coalesced (already) [168] print_char_cursor#93 ← print_char_cursor#2
Coalesced [174] ultoa::value#17 ← ultoa::value#1
Coalesced [186] ultoa::value#18 ← ultoa::value#2
Coalesced [187] ultoa::started#6 ← ultoa::started#2
Coalesced [188] ultoa::buffer#23 ← ultoa::buffer#11
Coalesced [191] ultoa::digit#7 ← ultoa::digit#1
Coalesced (already) [192] ultoa::value#16 ← ultoa::value#6
Coalesced (already) [193] ultoa::started#5 ← ultoa::started#4
Coalesced (already) [194] ultoa::buffer#22 ← ultoa::buffer#14
Coalesced [202] ultoa::value#19 ← ultoa::value#0
Coalesced [203] ultoa::buffer#24 ← ultoa::buffer#4
Coalesced [204] ultoa_append::value#6 ← ultoa_append::value#0
Coalesced [211] ultoa_append::value#7 ← ultoa_append::value#1
Coalesced [212] ultoa_append::digit#5 ← ultoa_append::digit#1
Coalesced [214] divr16u::dividend#9 ← divr16u::dividend#1
Coalesced [220] divr16u::rem#12 ← divr16u::rem#4
Coalesced [221] divr16u::dividend#10 ← divr16u::dividend#2
Coalesced [228] divr16u::rem#13 ← divr16u::rem#10
Coalesced [229] divr16u::dividend#11 ← divr16u::dividend#5
Coalesced [236] divr16u::rem#16 ← divr16u::rem#1
Coalesced [243] divr16u::rem#18 ← divr16u::rem#2
Coalesced [244] divr16u::return#8 ← divr16u::quotient#2
Coalesced [250] divr16u::rem#14 ← divr16u::rem#11
Coalesced [251] divr16u::dividend#12 ← divr16u::dividend#0
Coalesced [252] divr16u::quotient#9 ← divr16u::return#0
Coalesced [253] divr16u::i#7 ← divr16u::i#1
Coalesced [254] divr16u::rem#17 ← divr16u::rem#6
Coalesced [255] divr16u::return#7 ← divr16u::quotient#1
Coalesced [256] divr16u::rem#15 ← divr16u::rem#0
Coalesced [275] memset::dst#5 ← memset::dst#1
Coalesced down to 29 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @8
Culled Empty Block (label) @12
Culled Empty Block (label) @22
Culled Empty Block (label) @24
Culled Empty Block (label) @26
Culled Empty Block (label) @36
Culled Empty Block (label) @40
Culled Empty Block (label) @50
Culled Empty Block (label) @52
Culled Empty Block (label) main::toD0181_@return
Culled Empty Block (label) main::@37
Culled Empty Block (label) main::@44
Culled Empty Block (label) main::@45
Culled Empty Block (label) main::@23
Culled Empty Block (label) main::@47
Culled Empty Block (label) main::@48
Culled Empty Block (label) print_word_decimal::@2
Culled Empty Block (label) utoa::@1
Culled Empty Block (label) utoa::@8
Culled Empty Block (label) utoa::@28
Culled Empty Block (label) print_ln::@2
Culled Empty Block (label) print_ln::@3
Culled Empty Block (label) print_dword_decimal::@2
Culled Empty Block (label) ultoa::@1
Culled Empty Block (label) ultoa::@8
Culled Empty Block (label) ultoa::@28
Culled Empty Block (label) divr16u::@8
Culled Empty Block (label) divr16u::@10
Culled Empty Block (label) divr16u::@9
Culled Empty Block (label) memset::@1
Culled Empty Block (label) print_cls::@1
Renumbering block @51 to @1
Renumbering block memset::@2 to memset::@1
Renumbering block memset::@4 to memset::@2
Renumbering block memset::@5 to memset::@3
Renumbering block div32u16u::@2 to div32u16u::@1
Renumbering block div32u16u::@3 to div32u16u::@2
Renumbering block utoa::@18 to utoa::@1
Renumbering block utoa::@19 to utoa::@2
Renumbering block utoa::@20 to utoa::@3
Renumbering block utoa::@21 to utoa::@4
Renumbering block utoa::@24 to utoa::@5
Renumbering block utoa::@26 to utoa::@6
Renumbering block utoa::@27 to utoa::@7
Renumbering block ultoa::@18 to ultoa::@1
Renumbering block ultoa::@19 to ultoa::@2
Renumbering block ultoa::@20 to ultoa::@3
Renumbering block ultoa::@21 to ultoa::@4
Renumbering block ultoa::@24 to ultoa::@5
Renumbering block ultoa::@26 to ultoa::@6
Renumbering block ultoa::@27 to ultoa::@7
Renumbering block main::@13 to main::@7
Renumbering block main::@15 to main::@8
Renumbering block main::@16 to main::@9
Renumbering block main::@17 to main::@10
Renumbering block main::@18 to main::@11
Renumbering block main::@21 to main::@12
Renumbering block main::@24 to main::@13
Renumbering block main::@29 to main::@14
Renumbering block main::@30 to main::@15
Renumbering block main::@31 to main::@16
Renumbering block main::@32 to main::@17
Renumbering block main::@33 to main::@18
Renumbering block main::@34 to main::@19
Renumbering block main::@35 to main::@20
Renumbering block main::@36 to main::@21
Renumbering block main::@38 to main::@22
Renumbering block main::@39 to main::@23
Renumbering block main::@40 to main::@24
Renumbering block main::@41 to main::@25
Renumbering block main::@42 to main::@26
Renumbering block main::@43 to main::@27
Renumbering block main::@46 to main::@28
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@16
Adding NOP phi() at start of main::@18
Adding NOP phi() at start of main::@19
Adding NOP phi() at start of main::@20
Adding NOP phi() at start of main::@21
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@25
Adding NOP phi() at start of main::@27
Adding NOP phi() at start of main::@28
Adding NOP phi() at start of print_word_decimal::@1
Adding NOP phi() at start of utoa
Adding NOP phi() at start of utoa_append
Adding NOP phi() at start of print_dword_decimal::@1
Adding NOP phi() at start of ultoa
Adding NOP phi() at start of ultoa_append
Adding NOP phi() at start of print_cls

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  to:main::toD0181
main::toD0181: scope:[main]  from main
  [5] phi()
  to:main::@14
main::@14: scope:[main]  from main::toD0181
  [6] *((const byte*) D018) ← (const byte) main::toD0181_return#0
  [7] call print_cls 
  to:main::@15
main::@15: scope:[main]  from main::@14
  [8] phi()
  [9] call print_str 
  to:main::@16
main::@16: scope:[main]  from main::@15
  [10] phi()
  [11] call print_ln 
  to:main::@17
main::@17: scope:[main]  from main::@16
  [12] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1
  [13] call print_str 
  to:main::@18
main::@18: scope:[main]  from main::@17
  [14] phi()
  [15] call print_word_decimal 
  to:main::@19
main::@19: scope:[main]  from main::@18
  [16] phi()
  [17] call print_ln 
  to:main::@20
main::@20: scope:[main]  from main::@19
  [18] phi()
  [19] call memset 
  to:main::@21
main::@21: scope:[main]  from main::@20
  [20] phi()
  [21] call clock_start 
  to:main::@1
main::@1: scope:[main]  from main::@21 main::@4
  [22] (byte*) main::sieve_i#2 ← phi( main::@21/(const byte*) sieve#0+(byte) 2 main::@4/(byte*) main::sieve_i#1 )
  [22] (word) main::i#12 ← phi( main::@21/(byte) 2 main::@4/(word) main::i#2 )
  [23] if((word) main::i#12<(const byte) SQRT_COUNT) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [24] phi()
  [25] call clock 
  [26] (dword) clock::return#2 ← (dword) clock::return#0
  to:main::@22
main::@22: scope:[main]  from main::@3
  [27] (dword~) main::$10 ← (dword) clock::return#2
  [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT
  [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0
  [30] call div32u16u 
  [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0
  to:main::@23
main::@23: scope:[main]  from main::@22
  [32] (dword~) main::$14 ← (dword) div32u16u::return#2
  [33] (word) main::sec100s#0 ← (word)(dword~) main::$14
  [34] (byte*~) print_char_cursor#91 ← (byte*) print_line_cursor#1
  [35] call print_str 
  to:main::@24
main::@24: scope:[main]  from main::@23
  [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0
  [37] call print_word_decimal 
  to:main::@25
main::@25: scope:[main]  from main::@24
  [38] phi()
  [39] call print_str 
  to:main::@26
main::@26: scope:[main]  from main::@25
  [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0
  [41] call print_dword_decimal 
  to:main::@27
main::@27: scope:[main]  from main::@26
  [42] phi()
  [43] call print_ln 
  to:main::@8
main::@8: scope:[main]  from main::@11 main::@27
  [44] (byte*) print_char_cursor#62 ← phi( main::@11/(byte*) print_char_cursor#78 main::@27/(byte*) print_line_cursor#1 )
  [44] (word) main::i#10 ← phi( main::@11/(word) main::i#3 main::@27/(byte) 2 )
  [45] if((word) main::i#10<(word) $514) goto main::@9
  to:main::@10
main::@10: scope:[main]  from main::@8
  [46] (byte*~) print_char_cursor#89 ← (byte*) print_char_cursor#62
  [47] call print_str 
  to:main::@13
main::@13: scope:[main]  from main::@10 main::@13
  [48] *((const byte*) SCREEN+(word) $3e7) ← ++ *((const byte*) SCREEN+(word) $3e7)
  to:main::@13
main::@9: scope:[main]  from main::@8
  [49] (byte*~) main::$39 ← (const byte*) sieve#0 + (word) main::i#10
  [50] if((byte) 0!=*((byte*~) main::$39)) goto main::@11
  to:main::@12
main::@12: scope:[main]  from main::@9
  [51] (word) print_word_decimal::w#2 ← (word) main::i#10
  [52] (byte*~) print_char_cursor#97 ← (byte*) print_char_cursor#62
  [53] call print_word_decimal 
  to:main::@28
main::@28: scope:[main]  from main::@12
  [54] phi()
  [55] call print_char 
  to:main::@11
main::@11: scope:[main]  from main::@28 main::@9
  [56] (byte*) print_char_cursor#78 ← phi( main::@9/(byte*) print_char_cursor#62 main::@28/(byte*) print_char_cursor#10 )
  [57] (word) main::i#3 ← ++ (word) main::i#10
  to:main::@8
main::@2: scope:[main]  from main::@1
  [58] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4
  to:main::@7
main::@7: scope:[main]  from main::@2
  [59] (word) main::j#0 ← (word) main::i#12 << (byte) 1
  [60] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0
  to:main::@5
main::@5: scope:[main]  from main::@6 main::@7
  [61] (byte*) main::s#2 ← phi( main::@7/(byte*) main::s#0 main::@6/(byte*) main::s#1 )
  [61] (word) main::j#2 ← phi( main::@7/(word) main::j#0 main::@6/(word) main::j#1 )
  [62] if((word) main::j#2<(const word) COUNT) goto main::@6
  to:main::@4
main::@4: scope:[main]  from main::@2 main::@5
  [63] (word) main::i#2 ← ++ (word) main::i#12
  [64] (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#2
  to:main::@1
main::@6: scope:[main]  from main::@5
  [65] *((byte*) main::s#2) ← (byte) 1
  [66] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#12
  [67] (word) main::j#1 ← (word) main::j#2 + (word) main::i#12
  to:main::@5

(void()) print_char((byte) print_char::ch)
print_char: scope:[print_char]  from main::@28
  [68] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0
  [69] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2
  to:print_char::@return
print_char::@return: scope:[print_char]  from print_char
  [70] return 
  to:@return

(void()) print_word_decimal((word) print_word_decimal::w)
print_word_decimal: scope:[print_word_decimal]  from main::@12 main::@18 main::@24
  [71] (byte*) print_char_cursor#58 ← phi( main::@12/(byte*~) print_char_cursor#97 main::@18/(byte*) print_char_cursor#2 main::@24/(byte*) print_char_cursor#2 )
  [71] (word) print_word_decimal::w#3 ← phi( main::@12/(word) print_word_decimal::w#2 main::@18/(const word) COUNT main::@24/(word) print_word_decimal::w#1 )
  [72] (word) utoa::value#1 ← (word) print_word_decimal::w#3
  [73] call utoa 
  to:print_word_decimal::@1
print_word_decimal::@1: scope:[print_word_decimal]  from print_word_decimal
  [74] phi()
  [75] call print_str 
  to:print_word_decimal::@return
print_word_decimal::@return: scope:[print_word_decimal]  from print_word_decimal::@1
  [76] return 
  to:@return

(void()) print_str((byte*) print_str::str)
print_str: scope:[print_str]  from main::@10 main::@15 main::@17 main::@23 main::@25 print_dword_decimal::@1 print_word_decimal::@1
  [77] (byte*) print_char_cursor#66 ← phi( main::@10/(byte*~) print_char_cursor#89 main::@15/(byte*) 1024 main::@17/(byte*~) print_char_cursor#90 main::@23/(byte*~) print_char_cursor#91 main::@25/(byte*) print_char_cursor#2 print_dword_decimal::@1/(byte*) print_char_cursor#2 print_word_decimal::@1/(byte*) print_char_cursor#58 )
  [77] (byte*) print_str::str#10 ← phi( main::@10/(const string) main::str4 main::@15/(const string) main::str main::@17/(const string) main::str1 main::@23/(const string) main::str2 main::@25/(const string) main::str3 print_dword_decimal::@1/(const byte[$b]) decimal_digits_long print_word_decimal::@1/(const byte[6]) decimal_digits )
  to:print_str::@1
print_str::@1: scope:[print_str]  from print_str print_str::@2
  [78] (byte*) print_char_cursor#2 ← phi( print_str/(byte*) print_char_cursor#66 print_str::@2/(byte*) print_char_cursor#1 )
  [78] (byte*) print_str::str#8 ← phi( print_str/(byte*) print_str::str#10 print_str::@2/(byte*) print_str::str#0 )
  [79] if((byte) 0!=*((byte*) print_str::str#8)) goto print_str::@2
  to:print_str::@return
print_str::@return: scope:[print_str]  from print_str::@1
  [80] return 
  to:@return
print_str::@2: scope:[print_str]  from print_str::@1
  [81] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8)
  [82] (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#2
  [83] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#8
  to:print_str::@1

(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
utoa: scope:[utoa]  from print_word_decimal
  [84] phi()
  to:utoa::@1
utoa::@1: scope:[utoa]  from utoa utoa::@4
  [85] (byte*) utoa::buffer#11 ← phi( utoa::@4/(byte*) utoa::buffer#14 utoa/(const byte[6]) decimal_digits )
  [85] (byte) utoa::started#2 ← phi( utoa::@4/(byte) utoa::started#4 utoa/(byte) 0 )
  [85] (word) utoa::value#2 ← phi( utoa::@4/(word) utoa::value#6 utoa/(word) utoa::value#1 )
  [85] (byte) utoa::digit#2 ← phi( utoa::@4/(byte) utoa::digit#1 utoa/(byte) 0 )
  [86] if((byte) utoa::digit#2<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@2
  to:utoa::@3
utoa::@3: scope:[utoa]  from utoa::@1
  [87] (byte~) utoa::$4 ← (byte)(word) utoa::value#2
  [88] *((byte*) utoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) utoa::$4)
  [89] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11
  [90] *((byte*) utoa::buffer#3) ← (byte) 0
  to:utoa::@return
utoa::@return: scope:[utoa]  from utoa::@3
  [91] return 
  to:@return
utoa::@2: scope:[utoa]  from utoa::@1
  [92] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1
  [93] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES + (byte~) utoa::$11)
  [94] if((byte) 0!=(byte) utoa::started#2) goto utoa::@5
  to:utoa::@7
utoa::@7: scope:[utoa]  from utoa::@2
  [95] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@5
  to:utoa::@4
utoa::@4: scope:[utoa]  from utoa::@6 utoa::@7
  [96] (byte*) utoa::buffer#14 ← phi( utoa::@7/(byte*) utoa::buffer#11 utoa::@6/(byte*) utoa::buffer#4 )
  [96] (byte) utoa::started#4 ← phi( utoa::@7/(byte) utoa::started#2 utoa::@6/(byte) 1 )
  [96] (word) utoa::value#6 ← phi( utoa::@7/(word) utoa::value#2 utoa::@6/(word) utoa::value#0 )
  [97] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2
  to:utoa::@1
utoa::@5: scope:[utoa]  from utoa::@2 utoa::@7
  [98] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11
  [99] (word) utoa_append::value#0 ← (word) utoa::value#2
  [100] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0
  [101] call utoa_append 
  [102] (word) utoa_append::return#0 ← (word) utoa_append::value#2
  to:utoa::@6
utoa::@6: scope:[utoa]  from utoa::@5
  [103] (word) utoa::value#0 ← (word) utoa_append::return#0
  [104] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#11
  to:utoa::@4

(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
utoa_append: scope:[utoa_append]  from utoa::@5
  [105] phi()
  to:utoa_append::@1
utoa_append::@1: scope:[utoa_append]  from utoa_append utoa_append::@2
  [106] (byte) utoa_append::digit#2 ← phi( utoa_append/(byte) 0 utoa_append::@2/(byte) utoa_append::digit#1 )
  [106] (word) utoa_append::value#2 ← phi( utoa_append/(word) utoa_append::value#0 utoa_append::@2/(word) utoa_append::value#1 )
  [107] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2
  to:utoa_append::@3
utoa_append::@3: scope:[utoa_append]  from utoa_append::@1
  [108] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) utoa_append::digit#2)
  to:utoa_append::@return
utoa_append::@return: scope:[utoa_append]  from utoa_append::@3
  [109] return 
  to:@return
utoa_append::@2: scope:[utoa_append]  from utoa_append::@1
  [110] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2
  [111] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0
  to:utoa_append::@1

(void()) print_ln()
print_ln: scope:[print_ln]  from main::@16 main::@19 main::@27
  [112] (byte*) print_line_cursor#21 ← phi( main::@16/(byte*) 1024 main::@19/(byte*) print_line_cursor#1 main::@27/(byte*) print_line_cursor#1 )
  to:print_ln::@1
print_ln::@1: scope:[print_ln]  from print_ln print_ln::@1
  [113] (byte*) print_line_cursor#11 ← phi( print_ln/(byte*) print_line_cursor#21 print_ln::@1/(byte*) print_line_cursor#1 )
  [114] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28
  [115] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1
  to:print_ln::@return
print_ln::@return: scope:[print_ln]  from print_ln::@1
  [116] return 
  to:@return

(void()) print_dword_decimal((dword) print_dword_decimal::w)
print_dword_decimal: scope:[print_dword_decimal]  from main::@26
  [117] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0
  [118] call ultoa 
  to:print_dword_decimal::@1
print_dword_decimal::@1: scope:[print_dword_decimal]  from print_dword_decimal
  [119] phi()
  [120] call print_str 
  to:print_dword_decimal::@return
print_dword_decimal::@return: scope:[print_dword_decimal]  from print_dword_decimal::@1
  [121] return 
  to:@return

(void()) ultoa((dword) ultoa::value , (byte*) ultoa::buffer , (byte) ultoa::radix)
ultoa: scope:[ultoa]  from print_dword_decimal
  [122] phi()
  to:ultoa::@1
ultoa::@1: scope:[ultoa]  from ultoa ultoa::@4
  [123] (byte*) ultoa::buffer#11 ← phi( ultoa::@4/(byte*) ultoa::buffer#14 ultoa/(const byte[$b]) decimal_digits_long )
  [123] (byte) ultoa::started#2 ← phi( ultoa::@4/(byte) ultoa::started#4 ultoa/(byte) 0 )
  [123] (dword) ultoa::value#2 ← phi( ultoa::@4/(dword) ultoa::value#6 ultoa/(dword) ultoa::value#1 )
  [123] (byte) ultoa::digit#2 ← phi( ultoa::@4/(byte) ultoa::digit#1 ultoa/(byte) 0 )
  [124] if((byte) ultoa::digit#2<(const byte) ultoa::max_digits#1-(byte) 1) goto ultoa::@2
  to:ultoa::@3
ultoa::@3: scope:[ultoa]  from ultoa::@1
  [125] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#2
  [126] *((byte*) ultoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) ultoa::$4)
  [127] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11
  [128] *((byte*) ultoa::buffer#3) ← (byte) 0
  to:ultoa::@return
ultoa::@return: scope:[ultoa]  from ultoa::@3
  [129] return 
  to:@return
ultoa::@2: scope:[ultoa]  from ultoa::@1
  [130] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2
  [131] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG + (byte~) ultoa::$11)
  [132] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@5
  to:ultoa::@7
ultoa::@7: scope:[ultoa]  from ultoa::@2
  [133] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@5
  to:ultoa::@4
ultoa::@4: scope:[ultoa]  from ultoa::@6 ultoa::@7
  [134] (byte*) ultoa::buffer#14 ← phi( ultoa::@7/(byte*) ultoa::buffer#11 ultoa::@6/(byte*) ultoa::buffer#4 )
  [134] (byte) ultoa::started#4 ← phi( ultoa::@7/(byte) ultoa::started#2 ultoa::@6/(byte) 1 )
  [134] (dword) ultoa::value#6 ← phi( ultoa::@7/(dword) ultoa::value#2 ultoa::@6/(dword) ultoa::value#0 )
  [135] (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#2
  to:ultoa::@1
ultoa::@5: scope:[ultoa]  from ultoa::@2 ultoa::@7
  [136] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11
  [137] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2
  [138] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0
  [139] call ultoa_append 
  [140] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2
  to:ultoa::@6
ultoa::@6: scope:[ultoa]  from ultoa::@5
  [141] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0
  [142] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#11
  to:ultoa::@4

(dword()) ultoa_append((byte*) ultoa_append::buffer , (dword) ultoa_append::value , (dword) ultoa_append::sub)
ultoa_append: scope:[ultoa_append]  from ultoa::@5
  [143] phi()
  to:ultoa_append::@1
ultoa_append::@1: scope:[ultoa_append]  from ultoa_append ultoa_append::@2
  [144] (byte) ultoa_append::digit#2 ← phi( ultoa_append/(byte) 0 ultoa_append::@2/(byte) ultoa_append::digit#1 )
  [144] (dword) ultoa_append::value#2 ← phi( ultoa_append/(dword) ultoa_append::value#0 ultoa_append::@2/(dword) ultoa_append::value#1 )
  [145] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2
  to:ultoa_append::@3
ultoa_append::@3: scope:[ultoa_append]  from ultoa_append::@1
  [146] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) ultoa_append::digit#2)
  to:ultoa_append::@return
ultoa_append::@return: scope:[ultoa_append]  from ultoa_append::@3
  [147] return 
  to:@return
ultoa_append::@2: scope:[ultoa_append]  from ultoa_append::@1
  [148] (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2
  [149] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0
  to:ultoa_append::@1

(dword()) div32u16u((dword) div32u16u::dividend , (word) div32u16u::divisor)
div32u16u: scope:[div32u16u]  from main::@22
  [150] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0
  [151] call divr16u 
  [152] (word) divr16u::return#2 ← (word) divr16u::return#0
  to:div32u16u::@1
div32u16u::@1: scope:[div32u16u]  from div32u16u
  [153] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2
  [154] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0
  [155] (word) divr16u::rem#4 ← (word) rem16u#1
  [156] call divr16u 
  [157] (word) divr16u::return#3 ← (word) divr16u::return#0
  to:div32u16u::@2
div32u16u::@2: scope:[div32u16u]  from div32u16u::@1
  [158] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3
  [159] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0
  to:div32u16u::@return
div32u16u::@return: scope:[div32u16u]  from div32u16u::@2
  [160] return 
  to:@return

(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
divr16u: scope:[divr16u]  from div32u16u div32u16u::@1
  [161] (word) divr16u::dividend#5 ← phi( div32u16u/(word) divr16u::dividend#1 div32u16u::@1/(word) divr16u::dividend#2 )
  [161] (word) divr16u::rem#10 ← phi( div32u16u/(byte) 0 div32u16u::@1/(word) divr16u::rem#4 )
  to:divr16u::@1
divr16u::@1: scope:[divr16u]  from divr16u divr16u::@3
  [162] (byte) divr16u::i#2 ← phi( divr16u/(byte) 0 divr16u::@3/(byte) divr16u::i#1 )
  [162] (word) divr16u::quotient#3 ← phi( divr16u/(byte) 0 divr16u::@3/(word) divr16u::return#0 )
  [162] (word) divr16u::dividend#3 ← phi( divr16u/(word) divr16u::dividend#5 divr16u::@3/(word) divr16u::dividend#0 )
  [162] (word) divr16u::rem#5 ← phi( divr16u/(word) divr16u::rem#10 divr16u::@3/(word) divr16u::rem#11 )
  [163] (word) divr16u::rem#0 ← (word) divr16u::rem#5 << (byte) 1
  [164] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3
  [165] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80
  [166] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2
  to:divr16u::@4
divr16u::@4: scope:[divr16u]  from divr16u::@1
  [167] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1
  to:divr16u::@2
divr16u::@2: scope:[divr16u]  from divr16u::@1 divr16u::@4
  [168] (word) divr16u::rem#6 ← phi( divr16u::@1/(word) divr16u::rem#0 divr16u::@4/(word) divr16u::rem#1 )
  [169] (word) divr16u::dividend#0 ← (word) divr16u::dividend#3 << (byte) 1
  [170] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1
  [171] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3
  to:divr16u::@5
divr16u::@5: scope:[divr16u]  from divr16u::@2
  [172] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1
  [173] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0
  to:divr16u::@3
divr16u::@3: scope:[divr16u]  from divr16u::@2 divr16u::@5
  [174] (word) divr16u::return#0 ← phi( divr16u::@2/(word) divr16u::quotient#1 divr16u::@5/(word) divr16u::quotient#2 )
  [174] (word) divr16u::rem#11 ← phi( divr16u::@2/(word) divr16u::rem#6 divr16u::@5/(word) divr16u::rem#2 )
  [175] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2
  [176] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1
  to:divr16u::@6
divr16u::@6: scope:[divr16u]  from divr16u::@3
  [177] (word) rem16u#1 ← (word) divr16u::rem#11
  to:divr16u::@return
divr16u::@return: scope:[divr16u]  from divr16u::@6
  [178] return 
  to:@return

(dword()) clock()
clock: scope:[clock]  from main::@3
  [179] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB)
  to:clock::@return
clock::@return: scope:[clock]  from clock
  [180] return 
  to:@return

(void()) clock_start()
clock_start: scope:[clock_start]  from main::@21
  [181] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS
  [182] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  [183] *((const dword*) CIA2_TIMER_AB) ← (dword) $ffffffff
  [184] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  [185] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  [186] return 
  to:@return

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from main::@20 print_cls
  [187] (byte) memset::c#4 ← phi( main::@20/(byte) 0 print_cls/(byte) ' ' )
  [187] (void*) memset::str#3 ← phi( main::@20/(void*)(const byte*) sieve#0 print_cls/(void*)(byte*) 1024 )
  [187] (word) memset::num#2 ← phi( main::@20/(const word) COUNT print_cls/(word) $3e8 )
  [188] if((word) memset::num#2<=(byte) 0) goto memset::@return
  to:memset::@1
memset::@1: scope:[memset]  from memset
  [189] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2
  [190] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3
  to:memset::@2
memset::@2: scope:[memset]  from memset::@1 memset::@3
  [191] (byte*) memset::dst#2 ← phi( memset::@1/(byte*~) memset::dst#4 memset::@3/(byte*) memset::dst#1 )
  [192] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3
  to:memset::@return
memset::@return: scope:[memset]  from memset memset::@2
  [193] return 
  to:@return
memset::@3: scope:[memset]  from memset::@2
  [194] *((byte*) memset::dst#2) ← (byte) memset::c#4
  [195] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  to:memset::@2

(void()) print_cls()
print_cls: scope:[print_cls]  from main::@14
  [196] phi()
  [197] call memset 
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls
  [198] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(dword()) clock()
(dword) clock::return
(dword) clock::return#0 1.3333333333333333
(dword) clock::return#2 4.0
(void()) clock_start()
(dword()) div32u16u((dword) div32u16u::dividend , (word) div32u16u::divisor)
(dword) div32u16u::dividend
(dword) div32u16u::dividend#0 1.2000000000000002
(word) div32u16u::divisor
(dword) div32u16u::quotient
(word) div32u16u::quotient_hi
(word) div32u16u::quotient_hi#0 0.6666666666666666
(word) div32u16u::quotient_lo
(word) div32u16u::quotient_lo#0 4.0
(dword) div32u16u::return
(dword) div32u16u::return#0 1.3333333333333333
(dword) div32u16u::return#2 4.0
(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
(byte~) divr16u::$1 22.0
(byte~) divr16u::$2 22.0
(word) divr16u::dividend
(word) divr16u::dividend#0 2.75
(word) divr16u::dividend#1 4.0
(word) divr16u::dividend#2 2.0
(word) divr16u::dividend#3 5.0
(word) divr16u::dividend#5 6.0
(word) divr16u::divisor
(byte) divr16u::i
(byte) divr16u::i#1 16.5
(byte) divr16u::i#2 1.6923076923076923
(word) divr16u::quotient
(word) divr16u::quotient#1 16.5
(word) divr16u::quotient#2 11.0
(word) divr16u::quotient#3 2.75
(word) divr16u::rem
(word) divr16u::rem#0 8.25
(word) divr16u::rem#1 22.0
(word) divr16u::rem#10 4.0
(word) divr16u::rem#11 11.666666666666666
(word) divr16u::rem#2 22.0
(word) divr16u::rem#4 4.0
(word) divr16u::rem#5 24.0
(word) divr16u::rem#6 11.0
(word) divr16u::return
(word) divr16u::return#0 5.285714285714286
(word) divr16u::return#2 4.0
(word) divr16u::return#3 4.0
(void()) main()
(dword~) main::$10 4.0
(dword~) main::$14 2.0
(byte*~) main::$39 22.0
(dword) main::cyclecount
(dword) main::cyclecount#0 0.5
(word) main::i
(word) main::i#10 5.5
(word) main::i#12 24.6
(word) main::i#2 11.0
(word) main::i#3 22.0
(word) main::j
(word) main::j#0 16.5
(word) main::j#1 202.0
(word) main::j#2 78.5
(byte*) main::s
(byte*) main::s#0 22.0
(byte*) main::s#1 101.0
(byte*) main::s#2 104.66666666666666
(word) main::sec100s
(word) main::sec100s#0 1.3333333333333333
(byte*) main::sieve_i
(byte*) main::sieve_i#1 22.0
(byte*) main::sieve_i#2 3.0
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(byte*) main::toD0181_screen
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(byte) memset::c
(byte) memset::c#4 1.375
(byte*) memset::dst
(byte*) memset::dst#1 22.0
(byte*) memset::dst#2 15.333333333333332
(byte*~) memset::dst#4 4.0
(byte*) memset::end
(byte*) memset::end#0 2.1666666666666665
(word) memset::num
(word) memset::num#2 2.0
(void*) memset::return
(void*) memset::str
(void*) memset::str#3
(void()) print_char((byte) print_char::ch)
(byte) print_char::ch
(byte*) print_char_cursor
(byte*) print_char_cursor#1 101.0
(byte*) print_char_cursor#10 4.333333333333333
(byte*) print_char_cursor#2 10.25
(byte*) print_char_cursor#58 4.25
(byte*) print_char_cursor#62 7.4
(byte*) print_char_cursor#66 14.0
(byte*) print_char_cursor#78 16.5
(byte*~) print_char_cursor#89 4.0
(byte*~) print_char_cursor#90 4.0
(byte*~) print_char_cursor#91 4.0
(byte*~) print_char_cursor#97 22.0
(void()) print_cls()
(void()) print_dword_decimal((dword) print_dword_decimal::w)
(dword) print_dword_decimal::w
(dword) print_dword_decimal::w#0 4.0
(byte*) print_line_cursor
(byte*) print_line_cursor#1 0.9347826086956521
(byte*) print_line_cursor#11 24.0
(byte*) print_line_cursor#21 6.0
(void()) print_ln()
(byte*) print_screen
(void()) print_str((byte*) print_str::str)
(byte*) print_str::str
(byte*) print_str::str#0 202.0
(byte*) print_str::str#10 2.0
(byte*) print_str::str#8 101.5
(void()) print_word_decimal((word) print_word_decimal::w)
(word) print_word_decimal::w
(word) print_word_decimal::w#1 4.0
(word) print_word_decimal::w#2 11.0
(word) print_word_decimal::w#3 15.0
(word) rem16u
(word) rem16u#1 0.6666666666666666
(byte*) sieve
(void()) ultoa((dword) ultoa::value , (byte*) ultoa::buffer , (byte) ultoa::radix)
(byte~) ultoa::$11 22.0
(byte~) ultoa::$4 4.0
(byte*) ultoa::buffer
(byte*) ultoa::buffer#11 3.4285714285714284
(byte*) ultoa::buffer#14 16.5
(byte*) ultoa::buffer#3 4.0
(byte*) ultoa::buffer#4 22.0
(byte) ultoa::digit
(byte) ultoa::digit#1 22.0
(byte) ultoa::digit#2 3.142857142857143
(dword) ultoa::digit_value
(dword) ultoa::digit_value#0 6.6000000000000005
(dword*) ultoa::digit_values
(byte) ultoa::max_digits
(byte) ultoa::radix
(byte) ultoa::started
(byte) ultoa::started#2 5.5
(byte) ultoa::started#4 11.0
(dword) ultoa::value
(dword) ultoa::value#0 11.0
(dword) ultoa::value#1 2.0
(dword) ultoa::value#2 6.571428571428571
(dword) ultoa::value#6 16.5
(dword()) ultoa_append((byte*) ultoa_append::buffer , (dword) ultoa_append::value , (dword) ultoa_append::sub)
(byte*) ultoa_append::buffer
(byte*) ultoa_append::buffer#0 1.625
(byte) ultoa_append::digit
(byte) ultoa_append::digit#1 101.0
(byte) ultoa_append::digit#2 102.0
(dword) ultoa_append::return
(dword) ultoa_append::return#0 22.0
(dword) ultoa_append::sub
(dword) ultoa_append::sub#0 35.5
(dword) ultoa_append::value
(dword) ultoa_append::value#0 4.333333333333333
(dword) ultoa_append::value#1 202.0
(dword) ultoa_append::value#2 52.66666666666666
(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
(byte~) utoa::$11 202.0
(byte~) utoa::$4 4.0
(byte*) utoa::buffer
(byte*) utoa::buffer#11 29.142857142857146
(byte*) utoa::buffer#14 151.5
(byte*) utoa::buffer#3 4.0
(byte*) utoa::buffer#4 202.0
(byte) utoa::digit
(byte) utoa::digit#1 202.0
(byte) utoa::digit#2 28.857142857142858
(word) utoa::digit_value
(word) utoa::digit_value#0 60.599999999999994
(word*) utoa::digit_values
(byte) utoa::max_digits
(byte) utoa::radix
(byte) utoa::started
(byte) utoa::started#2 50.5
(byte) utoa::started#4 101.0
(word) utoa::value
(word) utoa::value#0 101.0
(word) utoa::value#1 2.0
(word) utoa::value#2 58.00000000000001
(word) utoa::value#6 151.5
(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
(byte*) utoa_append::buffer
(byte*) utoa_append::buffer#0 12.875
(byte) utoa_append::digit
(byte) utoa_append::digit#1 1001.0
(byte) utoa_append::digit#2 1002.0
(word) utoa_append::return
(word) utoa_append::return#0 202.0
(word) utoa_append::sub
(word) utoa_append::sub#0 350.5
(word) utoa_append::value
(word) utoa_append::value#0 34.33333333333333
(word) utoa_append::value#1 2002.0
(word) utoa_append::value#2 517.6666666666667

Initial phi equivalence classes
[ main::i#12 main::i#2 ]
[ main::sieve_i#2 main::sieve_i#1 ]
[ main::i#10 main::i#3 ]
[ main::j#2 main::j#0 main::j#1 ]
[ main::s#2 main::s#0 main::s#1 ]
[ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ]
[ print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 ]
[ print_str::str#8 print_str::str#10 print_str::str#0 ]
[ utoa::digit#2 utoa::digit#1 ]
[ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 ]
[ utoa::started#2 utoa::started#4 ]
[ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 ]
[ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ]
[ utoa_append::digit#2 utoa_append::digit#1 ]
[ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#78 print_line_cursor#1 print_char_cursor#10 ]
[ ultoa::digit#2 ultoa::digit#1 ]
[ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ]
[ ultoa::started#2 ultoa::started#4 ]
[ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ]
[ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ]
[ ultoa_append::digit#2 ultoa_append::digit#1 ]
[ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ]
[ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ]
[ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ]
[ divr16u::i#2 divr16u::i#1 ]
[ memset::num#2 ]
[ memset::str#3 ]
[ memset::c#4 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
Added variable clock::return#2 to zero page equivalence class [ clock::return#2 ]
Added variable main::$10 to zero page equivalence class [ main::$10 ]
Added variable main::cyclecount#0 to zero page equivalence class [ main::cyclecount#0 ]
Added variable div32u16u::dividend#0 to zero page equivalence class [ div32u16u::dividend#0 ]
Added variable div32u16u::return#2 to zero page equivalence class [ div32u16u::return#2 ]
Added variable main::$14 to zero page equivalence class [ main::$14 ]
Added variable main::sec100s#0 to zero page equivalence class [ main::sec100s#0 ]
Added variable print_dword_decimal::w#0 to zero page equivalence class [ print_dword_decimal::w#0 ]
Added variable main::$39 to zero page equivalence class [ main::$39 ]
Added variable utoa::$4 to zero page equivalence class [ utoa::$4 ]
Added variable utoa::buffer#3 to zero page equivalence class [ utoa::buffer#3 ]
Added variable utoa::$11 to zero page equivalence class [ utoa::$11 ]
Added variable utoa::digit_value#0 to zero page equivalence class [ utoa::digit_value#0 ]
Added variable utoa_append::buffer#0 to zero page equivalence class [ utoa_append::buffer#0 ]
Added variable utoa_append::sub#0 to zero page equivalence class [ utoa_append::sub#0 ]
Added variable utoa_append::return#0 to zero page equivalence class [ utoa_append::return#0 ]
Added variable ultoa::$4 to zero page equivalence class [ ultoa::$4 ]
Added variable ultoa::buffer#3 to zero page equivalence class [ ultoa::buffer#3 ]
Added variable ultoa::$11 to zero page equivalence class [ ultoa::$11 ]
Added variable ultoa::digit_value#0 to zero page equivalence class [ ultoa::digit_value#0 ]
Added variable ultoa_append::buffer#0 to zero page equivalence class [ ultoa_append::buffer#0 ]
Added variable ultoa_append::sub#0 to zero page equivalence class [ ultoa_append::sub#0 ]
Added variable ultoa_append::return#0 to zero page equivalence class [ ultoa_append::return#0 ]
Added variable divr16u::return#2 to zero page equivalence class [ divr16u::return#2 ]
Added variable div32u16u::quotient_hi#0 to zero page equivalence class [ div32u16u::quotient_hi#0 ]
Added variable divr16u::return#3 to zero page equivalence class [ divr16u::return#3 ]
Added variable div32u16u::quotient_lo#0 to zero page equivalence class [ div32u16u::quotient_lo#0 ]
Added variable div32u16u::return#0 to zero page equivalence class [ div32u16u::return#0 ]
Added variable divr16u::$1 to zero page equivalence class [ divr16u::$1 ]
Added variable divr16u::$2 to zero page equivalence class [ divr16u::$2 ]
Added variable rem16u#1 to zero page equivalence class [ rem16u#1 ]
Added variable clock::return#0 to zero page equivalence class [ clock::return#0 ]
Added variable memset::end#0 to zero page equivalence class [ memset::end#0 ]
Complete equivalence classes
[ main::i#12 main::i#2 ]
[ main::sieve_i#2 main::sieve_i#1 ]
[ main::i#10 main::i#3 ]
[ main::j#2 main::j#0 main::j#1 ]
[ main::s#2 main::s#0 main::s#1 ]
[ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ]
[ print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 ]
[ print_str::str#8 print_str::str#10 print_str::str#0 ]
[ utoa::digit#2 utoa::digit#1 ]
[ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 ]
[ utoa::started#2 utoa::started#4 ]
[ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 ]
[ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ]
[ utoa_append::digit#2 utoa_append::digit#1 ]
[ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#78 print_line_cursor#1 print_char_cursor#10 ]
[ ultoa::digit#2 ultoa::digit#1 ]
[ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ]
[ ultoa::started#2 ultoa::started#4 ]
[ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ]
[ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ]
[ ultoa_append::digit#2 ultoa_append::digit#1 ]
[ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ]
[ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ]
[ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ]
[ divr16u::i#2 divr16u::i#1 ]
[ memset::num#2 ]
[ memset::str#3 ]
[ memset::c#4 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
[ clock::return#2 ]
[ main::$10 ]
[ main::cyclecount#0 ]
[ div32u16u::dividend#0 ]
[ div32u16u::return#2 ]
[ main::$14 ]
[ main::sec100s#0 ]
[ print_dword_decimal::w#0 ]
[ main::$39 ]
[ utoa::$4 ]
[ utoa::buffer#3 ]
[ utoa::$11 ]
[ utoa::digit_value#0 ]
[ utoa_append::buffer#0 ]
[ utoa_append::sub#0 ]
[ utoa_append::return#0 ]
[ ultoa::$4 ]
[ ultoa::buffer#3 ]
[ ultoa::$11 ]
[ ultoa::digit_value#0 ]
[ ultoa_append::buffer#0 ]
[ ultoa_append::sub#0 ]
[ ultoa_append::return#0 ]
[ divr16u::return#2 ]
[ div32u16u::quotient_hi#0 ]
[ divr16u::return#3 ]
[ div32u16u::quotient_lo#0 ]
[ div32u16u::return#0 ]
[ divr16u::$1 ]
[ divr16u::$2 ]
[ rem16u#1 ]
[ clock::return#0 ]
[ memset::end#0 ]
Allocated zp ZP_WORD:2 [ main::i#12 main::i#2 ]
Allocated zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ]
Allocated zp ZP_WORD:6 [ main::i#10 main::i#3 ]
Allocated zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ]
Allocated zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ]
Allocated zp ZP_WORD:12 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ]
Allocated zp ZP_WORD:14 [ print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 ]
Allocated zp ZP_WORD:16 [ print_str::str#8 print_str::str#10 print_str::str#0 ]
Allocated zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ]
Allocated zp ZP_WORD:19 [ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 ]
Allocated zp ZP_BYTE:21 [ utoa::started#2 utoa::started#4 ]
Allocated zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 ]
Allocated zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ]
Allocated zp ZP_BYTE:26 [ utoa_append::digit#2 utoa_append::digit#1 ]
Allocated zp ZP_WORD:27 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#78 print_line_cursor#1 print_char_cursor#10 ]
Allocated zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ]
Allocated zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ]
Allocated zp ZP_BYTE:34 [ ultoa::started#2 ultoa::started#4 ]
Allocated zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ]
Allocated zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ]
Allocated zp ZP_BYTE:41 [ ultoa_append::digit#2 ultoa_append::digit#1 ]
Allocated zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ]
Allocated zp ZP_WORD:44 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ]
Allocated zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ]
Allocated zp ZP_BYTE:48 [ divr16u::i#2 divr16u::i#1 ]
Allocated zp ZP_WORD:49 [ memset::num#2 ]
Allocated zp ZP_WORD:51 [ memset::str#3 ]
Allocated zp ZP_BYTE:53 [ memset::c#4 ]
Allocated zp ZP_WORD:54 [ memset::dst#2 memset::dst#4 memset::dst#1 ]
Allocated zp ZP_DWORD:56 [ clock::return#2 ]
Allocated zp ZP_DWORD:60 [ main::$10 ]
Allocated zp ZP_DWORD:64 [ main::cyclecount#0 ]
Allocated zp ZP_DWORD:68 [ div32u16u::dividend#0 ]
Allocated zp ZP_DWORD:72 [ div32u16u::return#2 ]
Allocated zp ZP_DWORD:76 [ main::$14 ]
Allocated zp ZP_WORD:80 [ main::sec100s#0 ]
Allocated zp ZP_DWORD:82 [ print_dword_decimal::w#0 ]
Allocated zp ZP_WORD:86 [ main::$39 ]
Allocated zp ZP_BYTE:88 [ utoa::$4 ]
Allocated zp ZP_WORD:89 [ utoa::buffer#3 ]
Allocated zp ZP_BYTE:91 [ utoa::$11 ]
Allocated zp ZP_WORD:92 [ utoa::digit_value#0 ]
Allocated zp ZP_WORD:94 [ utoa_append::buffer#0 ]
Allocated zp ZP_WORD:96 [ utoa_append::sub#0 ]
Allocated zp ZP_WORD:98 [ utoa_append::return#0 ]
Allocated zp ZP_BYTE:100 [ ultoa::$4 ]
Allocated zp ZP_WORD:101 [ ultoa::buffer#3 ]
Allocated zp ZP_BYTE:103 [ ultoa::$11 ]
Allocated zp ZP_DWORD:104 [ ultoa::digit_value#0 ]
Allocated zp ZP_WORD:108 [ ultoa_append::buffer#0 ]
Allocated zp ZP_DWORD:110 [ ultoa_append::sub#0 ]
Allocated zp ZP_DWORD:114 [ ultoa_append::return#0 ]
Allocated zp ZP_WORD:118 [ divr16u::return#2 ]
Allocated zp ZP_WORD:120 [ div32u16u::quotient_hi#0 ]
Allocated zp ZP_WORD:122 [ divr16u::return#3 ]
Allocated zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ]
Allocated zp ZP_DWORD:126 [ div32u16u::return#0 ]
Allocated zp ZP_BYTE:130 [ divr16u::$1 ]
Allocated zp ZP_BYTE:131 [ divr16u::$2 ]
Allocated zp ZP_WORD:132 [ rem16u#1 ]
Allocated zp ZP_DWORD:134 [ clock::return#0 ]
Allocated zp ZP_WORD:138 [ memset::end#0 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label D018 = $d018
  // CIA #2 Timer A+B Value (32-bit)
  .label CIA2_TIMER_AB = $dd04
  // CIA #2 Timer A Control Register
  .label CIA2_TIMER_A_CONTROL = $dd0e
  // CIA #2 Timer B Control Register
  .label CIA2_TIMER_B_CONTROL = $dd0f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer Control - Time CONTINUOUS/ONE-SHOT (0:CONTINUOUS, 1: ONE-SHOT)
  .const CIA_TIMER_CONTROL_CONTINUOUS = 0
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  // Clock cycles per frame (on a C64 PAL)
  .const CLOCKS_PER_FRAME = $4cc8
  // Frames per second (on a C64 PAL)
  .const FRAMES_PER_SEC = $3c
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .label SCREEN = $400
  .const COUNT = $4000
  /* Up to what number? */
  .const SQRT_COUNT = $80
  /* Sqrt of COUNT */
  .label sieve = $1000
  // Clock cycles per second (on a C64 PAL)
  .const CLOCKS_PER_SEC = CLOCKS_PER_FRAME*FRAMES_PER_SEC
  .label rem16u = $84
  .label print_char_cursor = $e
  .label print_line_cursor = $1b
  .label print_char_cursor_10 = $1b
  .label print_char_cursor_62 = $1b
  .label print_char_cursor_78 = $1b
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label toD0181_gfx = $1800
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>toD0181_gfx)/4&$f
    .label _10 = $3c
    .label _14 = $4c
    .label cyclecount = $40
    .label sec100s = $50
    .label i = 2
    .label sieve_i = 4
    .label j = 8
    .label s = $a
    .label i_3 = 6
    .label i_10 = 6
    .label _39 = $56
    // [5] phi from main to main::toD0181 [phi:main->main::toD0181]
  toD0181_from_main:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp b14
    // main::@14
  b14:
    // [6] *((const byte*) D018) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    //Show lower case font
    lda #toD0181_return
    sta D018
    // [7] call print_cls 
    // [196] phi from main::@14 to print_cls [phi:main::@14->print_cls]
  print_cls_from_b14:
    jsr print_cls
    // [8] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  b15_from_b14:
    jmp b15
    // main::@15
  b15:
    // [9] call print_str 
    // [77] phi from main::@15 to print_str [phi:main::@15->print_str]
  print_str_from_b15:
    // [77] phi (byte*) print_char_cursor#66 = (byte*) 1024 [phi:main::@15->print_str#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z print_char_cursor
    lda #>$400
    sta.z print_char_cursor+1
    // [77] phi (byte*) print_str::str#10 = (const string) main::str [phi:main::@15->print_str#1] -- pbuz1=pbuc1 
    lda #<str
    sta.z print_str.str
    lda #>str
    sta.z print_str.str+1
    jsr print_str
    // [10] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
  b16_from_b15:
    jmp b16
    // main::@16
  b16:
    // [11] call print_ln 
    // [112] phi from main::@16 to print_ln [phi:main::@16->print_ln]
  print_ln_from_b16:
    // [112] phi (byte*) print_line_cursor#21 = (byte*) 1024 [phi:main::@16->print_ln#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z print_line_cursor
    lda #>$400
    sta.z print_line_cursor+1
    jsr print_ln
    jmp b17
    // main::@17
  b17:
    // [12] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda.z print_line_cursor
    sta.z print_char_cursor
    lda.z print_line_cursor+1
    sta.z print_char_cursor+1
    // [13] call print_str 
    // [77] phi from main::@17 to print_str [phi:main::@17->print_str]
  print_str_from_b17:
    // [77] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#90 [phi:main::@17->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str1 [phi:main::@17->print_str#1] -- pbuz1=pbuc1 
    lda #<str1
    sta.z print_str.str
    lda #>str1
    sta.z print_str.str+1
    jsr print_str
    // [14] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  b18_from_b17:
    jmp b18
    // main::@18
  b18:
    // [15] call print_word_decimal 
    // [71] phi from main::@18 to print_word_decimal [phi:main::@18->print_word_decimal]
  print_word_decimal_from_b18:
    // [71] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@18->print_word_decimal#0] -- register_copy 
    // [71] phi (word) print_word_decimal::w#3 = (const word) COUNT [phi:main::@18->print_word_decimal#1] -- vwuz1=vwuc1 
    lda #<COUNT
    sta.z print_word_decimal.w
    lda #>COUNT
    sta.z print_word_decimal.w+1
    jsr print_word_decimal
    // [16] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  b19_from_b18:
    jmp b19
    // main::@19
  b19:
    // [17] call print_ln 
    // [112] phi from main::@19 to print_ln [phi:main::@19->print_ln]
  print_ln_from_b19:
    // [112] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@19->print_ln#0] -- register_copy 
    jsr print_ln
    // [18] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  b20_from_b19:
    jmp b20
    // main::@20
  b20:
    // [19] call memset 
    // [187] phi from main::@20 to memset [phi:main::@20->memset]
  memset_from_b20:
    // [187] phi (byte) memset::c#4 = (byte) 0 [phi:main::@20->memset#0] -- vbuz1=vbuc1 
    lda #0
    sta.z memset.c
    // [187] phi (void*) memset::str#3 = (void*)(const byte*) sieve#0 [phi:main::@20->memset#1] -- pvoz1=pvoc1 
    lda #<sieve
    sta.z memset.str
    lda #>sieve
    sta.z memset.str+1
    // [187] phi (word) memset::num#2 = (const word) COUNT [phi:main::@20->memset#2] -- vwuz1=vwuc1 
    lda #<COUNT
    sta.z memset.num
    lda #>COUNT
    sta.z memset.num+1
    jsr memset
    // [20] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
  b21_from_b20:
    jmp b21
    // main::@21
  b21:
    // [21] call clock_start 
    jsr clock_start
    // [22] phi from main::@21 to main::@1 [phi:main::@21->main::@1]
  b1_from_b21:
    // [22] phi (byte*) main::sieve_i#2 = (const byte*) sieve#0+(byte) 2 [phi:main::@21->main::@1#0] -- pbuz1=pbuc1 
    lda #<sieve+2
    sta.z sieve_i
    lda #>sieve+2
    sta.z sieve_i+1
    // [22] phi (word) main::i#12 = (byte) 2 [phi:main::@21->main::@1#1] -- vwuz1=vbuc1 
    lda #<2
    sta.z i
    lda #>2
    sta.z i+1
    jmp b1
    // main::@1
  b1:
    // [23] if((word) main::i#12<(const byte) SQRT_COUNT) goto main::@2 -- vwuz1_lt_vbuc1_then_la1 
    lda.z i+1
    cmp #>SQRT_COUNT
    bcc b2
    bne !+
    lda.z i
    cmp #<SQRT_COUNT
    bcc b2
  !:
    // [24] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  b3_from_b1:
    jmp b3
    // main::@3
  b3:
    // [25] call clock 
    jsr clock
    // [26] (dword) clock::return#2 ← (dword) clock::return#0 -- vduz1=vduz2 
    lda.z clock.return
    sta.z clock.return_2
    lda.z clock.return+1
    sta.z clock.return_2+1
    lda.z clock.return+2
    sta.z clock.return_2+2
    lda.z clock.return+3
    sta.z clock.return_2+3
    jmp b22
    // main::@22
  b22:
    // [27] (dword~) main::$10 ← (dword) clock::return#2 -- vduz1=vduz2 
    lda.z clock.return_2
    sta.z _10
    lda.z clock.return_2+1
    sta.z _10+1
    lda.z clock.return_2+2
    sta.z _10+2
    lda.z clock.return_2+3
    sta.z _10+3
    // [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT -- vduz1=vduz2_minus_vduc1 
    lda.z _10
    sec
    sbc #<CLOCKS_PER_INIT
    sta.z cyclecount
    lda.z _10+1
    sbc #>CLOCKS_PER_INIT
    sta.z cyclecount+1
    lda.z _10+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta.z cyclecount+2
    lda.z _10+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta.z cyclecount+3
    // [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0 -- vduz1=vduz2 
    lda.z cyclecount
    sta.z div32u16u.dividend
    lda.z cyclecount+1
    sta.z div32u16u.dividend+1
    lda.z cyclecount+2
    sta.z div32u16u.dividend+2
    lda.z cyclecount+3
    sta.z div32u16u.dividend+3
    // [30] call div32u16u 
    jsr div32u16u
    // [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0 -- vduz1=vduz2 
    lda.z div32u16u.return
    sta.z div32u16u.return_2
    lda.z div32u16u.return+1
    sta.z div32u16u.return_2+1
    lda.z div32u16u.return+2
    sta.z div32u16u.return_2+2
    lda.z div32u16u.return+3
    sta.z div32u16u.return_2+3
    jmp b23
    // main::@23
  b23:
    // [32] (dword~) main::$14 ← (dword) div32u16u::return#2 -- vduz1=vduz2 
    lda.z div32u16u.return_2
    sta.z _14
    lda.z div32u16u.return_2+1
    sta.z _14+1
    lda.z div32u16u.return_2+2
    sta.z _14+2
    lda.z div32u16u.return_2+3
    sta.z _14+3
    // [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 -- vwuz1=_word_vduz2 
    lda.z _14
    sta.z sec100s
    lda.z _14+1
    sta.z sec100s+1
    // [34] (byte*~) print_char_cursor#91 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda.z print_line_cursor
    sta.z print_char_cursor
    lda.z print_line_cursor+1
    sta.z print_char_cursor+1
    // [35] call print_str 
    // [77] phi from main::@23 to print_str [phi:main::@23->print_str]
  print_str_from_b23:
    // [77] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#91 [phi:main::@23->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str2 [phi:main::@23->print_str#1] -- pbuz1=pbuc1 
    lda #<str2
    sta.z print_str.str
    lda #>str2
    sta.z print_str.str+1
    jsr print_str
    jmp b24
    // main::@24
  b24:
    // [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0 -- vwuz1=vwuz2 
    lda.z sec100s
    sta.z print_word_decimal.w
    lda.z sec100s+1
    sta.z print_word_decimal.w+1
    // [37] call print_word_decimal 
    // [71] phi from main::@24 to print_word_decimal [phi:main::@24->print_word_decimal]
  print_word_decimal_from_b24:
    // [71] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@24->print_word_decimal#0] -- register_copy 
    // [71] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#1 [phi:main::@24->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [38] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
  b25_from_b24:
    jmp b25
    // main::@25
  b25:
    // [39] call print_str 
    // [77] phi from main::@25 to print_str [phi:main::@25->print_str]
  print_str_from_b25:
    // [77] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:main::@25->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str3 [phi:main::@25->print_str#1] -- pbuz1=pbuc1 
    lda #<str3
    sta.z print_str.str
    lda #>str3
    sta.z print_str.str+1
    jsr print_str
    jmp b26
    // main::@26
  b26:
    // [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0 -- vduz1=vduz2 
    lda.z cyclecount
    sta.z print_dword_decimal.w
    lda.z cyclecount+1
    sta.z print_dword_decimal.w+1
    lda.z cyclecount+2
    sta.z print_dword_decimal.w+2
    lda.z cyclecount+3
    sta.z print_dword_decimal.w+3
    // [41] call print_dword_decimal 
    jsr print_dword_decimal
    // [42] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
  b27_from_b26:
    jmp b27
    // main::@27
  b27:
    // [43] call print_ln 
    // [112] phi from main::@27 to print_ln [phi:main::@27->print_ln]
  print_ln_from_b27:
    // [112] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@27->print_ln#0] -- register_copy 
    jsr print_ln
    // [44] phi from main::@27 to main::@8 [phi:main::@27->main::@8]
  b8_from_b27:
    // [44] phi (byte*) print_char_cursor#62 = (byte*) print_line_cursor#1 [phi:main::@27->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (byte) 2 [phi:main::@27->main::@8#1] -- vwuz1=vbuc1 
    lda #<2
    sta.z i_10
    lda #>2
    sta.z i_10+1
    jmp b8
    // main::@8
  b8:
    // [45] if((word) main::i#10<(word) $514) goto main::@9 -- vwuz1_lt_vwuc1_then_la1 
    lda.z i_10+1
    cmp #>$514
    bcc b9
    bne !+
    lda.z i_10
    cmp #<$514
    bcc b9
  !:
    jmp b10
    // main::@10
  b10:
    // [46] (byte*~) print_char_cursor#89 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda.z print_char_cursor_62
    sta.z print_char_cursor
    lda.z print_char_cursor_62+1
    sta.z print_char_cursor+1
    // [47] call print_str 
    // [77] phi from main::@10 to print_str [phi:main::@10->print_str]
  print_str_from_b10:
    // [77] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#89 [phi:main::@10->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str4 [phi:main::@10->print_str#1] -- pbuz1=pbuc1 
    lda #<str4
    sta.z print_str.str
    lda #>str4
    sta.z print_str.str+1
    jsr print_str
    jmp b13
    // main::@13
  b13:
    // [48] *((const byte*) SCREEN+(word) $3e7) ← ++ *((const byte*) SCREEN+(word) $3e7) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN+$3e7
    jmp b13
    // main::@9
  b9:
    // [49] (byte*~) main::$39 ← (const byte*) sieve#0 + (word) main::i#10 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z i_10
    clc
    adc #<sieve
    sta.z _39
    lda.z i_10+1
    adc #>sieve
    sta.z _39+1
    // [50] if((byte) 0!=*((byte*~) main::$39)) goto main::@11 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (_39),y
    cmp #0
    bne b11_from_b9
    jmp b12
    // main::@12
  b12:
    // [51] (word) print_word_decimal::w#2 ← (word) main::i#10 -- vwuz1=vwuz2 
    lda.z i_10
    sta.z print_word_decimal.w
    lda.z i_10+1
    sta.z print_word_decimal.w+1
    // [52] (byte*~) print_char_cursor#97 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda.z print_char_cursor_62
    sta.z print_char_cursor
    lda.z print_char_cursor_62+1
    sta.z print_char_cursor+1
    // [53] call print_word_decimal 
    // [71] phi from main::@12 to print_word_decimal [phi:main::@12->print_word_decimal]
  print_word_decimal_from_b12:
    // [71] phi (byte*) print_char_cursor#58 = (byte*~) print_char_cursor#97 [phi:main::@12->print_word_decimal#0] -- register_copy 
    // [71] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#2 [phi:main::@12->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [54] phi from main::@12 to main::@28 [phi:main::@12->main::@28]
  b28_from_b12:
    jmp b28
    // main::@28
  b28:
    // [55] call print_char 
    jsr print_char
    // [56] phi from main::@28 main::@9 to main::@11 [phi:main::@28/main::@9->main::@11]
  b11_from_b28:
  b11_from_b9:
    // [56] phi (byte*) print_char_cursor#78 = (byte*) print_char_cursor#10 [phi:main::@28/main::@9->main::@11#0] -- register_copy 
    jmp b11
    // main::@11
  b11:
    // [57] (word) main::i#3 ← ++ (word) main::i#10 -- vwuz1=_inc_vwuz1 
    inc.z i_3
    bne !+
    inc.z i_3+1
  !:
    // [44] phi from main::@11 to main::@8 [phi:main::@11->main::@8]
  b8_from_b11:
    // [44] phi (byte*) print_char_cursor#62 = (byte*) print_char_cursor#78 [phi:main::@11->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (word) main::i#3 [phi:main::@11->main::@8#1] -- register_copy 
    jmp b8
    // main::@2
  b2:
    // [58] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (sieve_i),y
    cmp #0
    bne b4
    jmp b7
    // main::@7
  b7:
    // [59] (word) main::j#0 ← (word) main::i#12 << (byte) 1 -- vwuz1=vwuz2_rol_1 
    lda.z i
    asl
    sta.z j
    lda.z i+1
    rol
    sta.z j+1
    // [60] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z j
    clc
    adc #<sieve
    sta.z s
    lda.z j+1
    adc #>sieve
    sta.z s+1
    // [61] phi from main::@6 main::@7 to main::@5 [phi:main::@6/main::@7->main::@5]
  b5_from_b6:
  b5_from_b7:
    // [61] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@6/main::@7->main::@5#0] -- register_copy 
    // [61] phi (word) main::j#2 = (word) main::j#1 [phi:main::@6/main::@7->main::@5#1] -- register_copy 
    jmp b5
    // main::@5
  b5:
    // [62] if((word) main::j#2<(const word) COUNT) goto main::@6 -- vwuz1_lt_vwuc1_then_la1 
    lda.z j+1
    cmp #>COUNT
    bcc b6
    bne !+
    lda.z j
    cmp #<COUNT
    bcc b6
  !:
    jmp b4
    // main::@4
  b4:
    // [63] (word) main::i#2 ← ++ (word) main::i#12 -- vwuz1=_inc_vwuz1 
    inc.z i
    bne !+
    inc.z i+1
  !:
    // [64] (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#2 -- pbuz1=_inc_pbuz1 
    inc.z sieve_i
    bne !+
    inc.z sieve_i+1
  !:
    // [22] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  b1_from_b4:
    // [22] phi (byte*) main::sieve_i#2 = (byte*) main::sieve_i#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [22] phi (word) main::i#12 = (word) main::i#2 [phi:main::@4->main::@1#1] -- register_copy 
    jmp b1
    // main::@6
  b6:
    // [65] *((byte*) main::s#2) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (s),y
    // [66] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#12 -- pbuz1=pbuz1_plus_vwuz2 
    lda.z s
    clc
    adc.z i
    sta.z s
    lda.z s+1
    adc.z i+1
    sta.z s+1
    // [67] (word) main::j#1 ← (word) main::j#2 + (word) main::i#12 -- vwuz1=vwuz1_plus_vwuz2 
    lda.z j
    clc
    adc.z i
    sta.z j
    lda.z j+1
    adc.z i+1
    sta.z j+1
    jmp b5_from_b6
    str: .text "Sieve benchmark - calculating primes"
    .byte 0
    str1: .text "between 2 and "
    .byte 0
    str2: .text "100ths seconds used: "
    .byte 0
    str3: .text " cycles: "
    .byte 0
    str4: .text "..."
    .byte 0
}
  // print_char
// Print a single char
print_char: {
    .const ch = ' '
    // [68] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 -- _deref_pbuz1=vbuc1 
    lda #ch
    ldy #0
    sta (print_char_cursor),y
    // [69] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz2 
    lda.z print_char_cursor
    clc
    adc #1
    sta.z print_char_cursor_10
    lda.z print_char_cursor+1
    adc #0
    sta.z print_char_cursor_10+1
    jmp breturn
    // print_char::@return
  breturn:
    // [70] return 
    rts
}
  // print_word_decimal
// Print a word as DECIMAL
// print_word_decimal(word zeropage($c) w)
print_word_decimal: {
    .label w = $c
    // [72] (word) utoa::value#1 ← (word) print_word_decimal::w#3 -- vwuz1=vwuz2 
    lda.z w
    sta.z utoa.value
    lda.z w+1
    sta.z utoa.value+1
    // [73] call utoa 
    // [84] phi from print_word_decimal to utoa [phi:print_word_decimal->utoa]
  utoa_from_print_word_decimal:
    jsr utoa
    // [74] phi from print_word_decimal to print_word_decimal::@1 [phi:print_word_decimal->print_word_decimal::@1]
  b1_from_print_word_decimal:
    jmp b1
    // print_word_decimal::@1
  b1:
    // [75] call print_str 
    // [77] phi from print_word_decimal::@1 to print_str [phi:print_word_decimal::@1->print_str]
  print_str_from_b1:
    // [77] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#58 [phi:print_word_decimal::@1->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const byte[6]) decimal_digits [phi:print_word_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta.z print_str.str
    lda #>decimal_digits
    sta.z print_str.str+1
    jsr print_str
    jmp breturn
    // print_word_decimal::@return
  breturn:
    // [76] return 
    rts
}
  // print_str
// Print a zero-terminated string
// print_str(byte* zeropage($10) str)
print_str: {
    .label str = $10
    // [78] phi from print_str print_str::@2 to print_str::@1 [phi:print_str/print_str::@2->print_str::@1]
  b1_from_print_str:
  b1_from_b2:
    // [78] phi (byte*) print_char_cursor#2 = (byte*) print_char_cursor#66 [phi:print_str/print_str::@2->print_str::@1#0] -- register_copy 
    // [78] phi (byte*) print_str::str#8 = (byte*) print_str::str#10 [phi:print_str/print_str::@2->print_str::@1#1] -- register_copy 
    jmp b1
    // print_str::@1
  b1:
    // [79] if((byte) 0!=*((byte*) print_str::str#8)) goto print_str::@2 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (str),y
    cmp #0
    bne b2
    jmp breturn
    // print_str::@return
  breturn:
    // [80] return 
    rts
    // print_str::@2
  b2:
    // [81] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) -- _deref_pbuz1=_deref_pbuz2 
    ldy #0
    lda (str),y
    ldy #0
    sta (print_char_cursor),y
    // [82] (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz1 
    inc.z print_char_cursor
    bne !+
    inc.z print_char_cursor+1
  !:
    // [83] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#8 -- pbuz1=_inc_pbuz1 
    inc.z str
    bne !+
    inc.z str+1
  !:
    jmp b1_from_b2
}
  // utoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// utoa(word zeropage($13) value, byte* zeropage($59) buffer)
utoa: {
    .const max_digits = 5
    .label _4 = $58
    .label _11 = $5b
    .label digit_value = $5c
    .label buffer = $59
    .label digit = $12
    .label value = $13
    .label buffer_4 = $16
    .label started = $15
    .label buffer_11 = $16
    .label buffer_14 = $16
    // [85] phi from utoa to utoa::@1 [phi:utoa->utoa::@1]
  b1_from_utoa:
    // [85] phi (byte*) utoa::buffer#11 = (const byte[6]) decimal_digits [phi:utoa->utoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta.z buffer_11
    lda #>decimal_digits
    sta.z buffer_11+1
    // [85] phi (byte) utoa::started#2 = (byte) 0 [phi:utoa->utoa::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z started
    // [85] phi (word) utoa::value#2 = (word) utoa::value#1 [phi:utoa->utoa::@1#2] -- register_copy 
    // [85] phi (byte) utoa::digit#2 = (byte) 0 [phi:utoa->utoa::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    jmp b1
    // utoa::@1
  b1:
    // [86] if((byte) utoa::digit#2<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z digit
    cmp #max_digits-1
    bcc b2
    jmp b3
    // utoa::@3
  b3:
    // [87] (byte~) utoa::$4 ← (byte)(word) utoa::value#2 -- vbuz1=_byte_vwuz2 
    lda.z value
    sta.z _4
    // [88] *((byte*) utoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) utoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z _4
    lda DIGITS,y
    ldy #0
    sta (buffer_11),y
    // [89] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11 -- pbuz1=_inc_pbuz2 
    lda.z buffer_11
    clc
    adc #1
    sta.z buffer
    lda.z buffer_11+1
    adc #0
    sta.z buffer+1
    // [90] *((byte*) utoa::buffer#3) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (buffer),y
    jmp breturn
    // utoa::@return
  breturn:
    // [91] return 
    rts
    // utoa::@2
  b2:
    // [92] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z digit
    asl
    sta.z _11
    // [93] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES + (byte~) utoa::$11) -- vwuz1=pwuc1_derefidx_vbuz2 
    ldy.z _11
    lda RADIX_DECIMAL_VALUES,y
    sta.z digit_value
    lda RADIX_DECIMAL_VALUES+1,y
    sta.z digit_value+1
    // [94] if((byte) 0!=(byte) utoa::started#2) goto utoa::@5 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z started
    bne b5
    jmp b7
    // utoa::@7
  b7:
    // [95] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@5 -- vwuz1_ge_vwuz2_then_la1 
    lda.z digit_value+1
    cmp.z value+1
    bne !+
    lda.z digit_value
    cmp.z value
    beq b5
  !:
    bcc b5
    // [96] phi from utoa::@7 to utoa::@4 [phi:utoa::@7->utoa::@4]
  b4_from_b7:
    // [96] phi (byte*) utoa::buffer#14 = (byte*) utoa::buffer#11 [phi:utoa::@7->utoa::@4#0] -- register_copy 
    // [96] phi (byte) utoa::started#4 = (byte) utoa::started#2 [phi:utoa::@7->utoa::@4#1] -- register_copy 
    // [96] phi (word) utoa::value#6 = (word) utoa::value#2 [phi:utoa::@7->utoa::@4#2] -- register_copy 
    jmp b4
    // utoa::@4
  b4:
    // [97] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc.z digit
    // [85] phi from utoa::@4 to utoa::@1 [phi:utoa::@4->utoa::@1]
  b1_from_b4:
    // [85] phi (byte*) utoa::buffer#11 = (byte*) utoa::buffer#14 [phi:utoa::@4->utoa::@1#0] -- register_copy 
    // [85] phi (byte) utoa::started#2 = (byte) utoa::started#4 [phi:utoa::@4->utoa::@1#1] -- register_copy 
    // [85] phi (word) utoa::value#2 = (word) utoa::value#6 [phi:utoa::@4->utoa::@1#2] -- register_copy 
    // [85] phi (byte) utoa::digit#2 = (byte) utoa::digit#1 [phi:utoa::@4->utoa::@1#3] -- register_copy 
    jmp b1
    // utoa::@5
  b5:
    // [98] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11 -- pbuz1=pbuz2 
    lda.z buffer_11
    sta.z utoa_append.buffer
    lda.z buffer_11+1
    sta.z utoa_append.buffer+1
    // [99] (word) utoa_append::value#0 ← (word) utoa::value#2 -- vwuz1=vwuz2 
    lda.z value
    sta.z utoa_append.value
    lda.z value+1
    sta.z utoa_append.value+1
    // [100] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0 -- vwuz1=vwuz2 
    lda.z digit_value
    sta.z utoa_append.sub
    lda.z digit_value+1
    sta.z utoa_append.sub+1
    // [101] call utoa_append 
    // [105] phi from utoa::@5 to utoa_append [phi:utoa::@5->utoa_append]
  utoa_append_from_b5:
    jsr utoa_append
    // [102] (word) utoa_append::return#0 ← (word) utoa_append::value#2 -- vwuz1=vwuz2 
    lda.z utoa_append.value
    sta.z utoa_append.return
    lda.z utoa_append.value+1
    sta.z utoa_append.return+1
    jmp b6
    // utoa::@6
  b6:
    // [103] (word) utoa::value#0 ← (word) utoa_append::return#0 -- vwuz1=vwuz2 
    lda.z utoa_append.return
    sta.z value
    lda.z utoa_append.return+1
    sta.z value+1
    // [104] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer_4
    bne !+
    inc.z buffer_4+1
  !:
    // [96] phi from utoa::@6 to utoa::@4 [phi:utoa::@6->utoa::@4]
  b4_from_b6:
    // [96] phi (byte*) utoa::buffer#14 = (byte*) utoa::buffer#4 [phi:utoa::@6->utoa::@4#0] -- register_copy 
    // [96] phi (byte) utoa::started#4 = (byte) 1 [phi:utoa::@6->utoa::@4#1] -- vbuz1=vbuc1 
    lda #1
    sta.z started
    // [96] phi (word) utoa::value#6 = (word) utoa::value#0 [phi:utoa::@6->utoa::@4#2] -- register_copy 
    jmp b4
}
  // utoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// utoa_append(byte* zeropage($5e) buffer, word zeropage($18) value, word zeropage($60) sub)
utoa_append: {
    .label buffer = $5e
    .label value = $18
    .label sub = $60
    .label return = $62
    .label digit = $1a
    // [106] phi from utoa_append to utoa_append::@1 [phi:utoa_append->utoa_append::@1]
  b1_from_utoa_append:
    // [106] phi (byte) utoa_append::digit#2 = (byte) 0 [phi:utoa_append->utoa_append::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [106] phi (word) utoa_append::value#2 = (word) utoa_append::value#0 [phi:utoa_append->utoa_append::@1#1] -- register_copy 
    jmp b1
    // utoa_append::@1
  b1:
    // [107] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 -- vwuz1_ge_vwuz2_then_la1 
    lda.z sub+1
    cmp.z value+1
    bne !+
    lda.z sub
    cmp.z value
    beq b2
  !:
    bcc b2
    jmp b3
    // utoa_append::@3
  b3:
    // [108] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) utoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z digit
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    jmp breturn
    // utoa_append::@return
  breturn:
    // [109] return 
    rts
    // utoa_append::@2
  b2:
    // [110] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2 -- vbuz1=_inc_vbuz1 
    inc.z digit
    // [111] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 -- vwuz1=vwuz1_minus_vwuz2 
    lda.z value
    sec
    sbc.z sub
    sta.z value
    lda.z value+1
    sbc.z sub+1
    sta.z value+1
    // [106] phi from utoa_append::@2 to utoa_append::@1 [phi:utoa_append::@2->utoa_append::@1]
  b1_from_b2:
    // [106] phi (byte) utoa_append::digit#2 = (byte) utoa_append::digit#1 [phi:utoa_append::@2->utoa_append::@1#0] -- register_copy 
    // [106] phi (word) utoa_append::value#2 = (word) utoa_append::value#1 [phi:utoa_append::@2->utoa_append::@1#1] -- register_copy 
    jmp b1
}
  // print_ln
// Print a newline
print_ln: {
    // [113] phi from print_ln print_ln::@1 to print_ln::@1 [phi:print_ln/print_ln::@1->print_ln::@1]
  b1_from_print_ln:
  b1_from_b1:
    // [113] phi (byte*) print_line_cursor#11 = (byte*) print_line_cursor#21 [phi:print_ln/print_ln::@1->print_ln::@1#0] -- register_copy 
    jmp b1
    // print_ln::@1
  b1:
    // [114] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z print_line_cursor
    sta.z print_line_cursor
    bcc !+
    inc.z print_line_cursor+1
  !:
    // [115] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 -- pbuz1_lt_pbuz2_then_la1 
    lda.z print_line_cursor+1
    cmp.z print_char_cursor+1
    bcc b1_from_b1
    bne !+
    lda.z print_line_cursor
    cmp.z print_char_cursor
    bcc b1_from_b1
  !:
    jmp breturn
    // print_ln::@return
  breturn:
    // [116] return 
    rts
}
  // print_dword_decimal
// Print a dword as DECIMAL
// print_dword_decimal(dword zeropage($52) w)
print_dword_decimal: {
    .label w = $52
    // [117] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0 -- vduz1=vduz2 
    lda.z w
    sta.z ultoa.value
    lda.z w+1
    sta.z ultoa.value+1
    lda.z w+2
    sta.z ultoa.value+2
    lda.z w+3
    sta.z ultoa.value+3
    // [118] call ultoa 
    // [122] phi from print_dword_decimal to ultoa [phi:print_dword_decimal->ultoa]
  ultoa_from_print_dword_decimal:
    jsr ultoa
    // [119] phi from print_dword_decimal to print_dword_decimal::@1 [phi:print_dword_decimal->print_dword_decimal::@1]
  b1_from_print_dword_decimal:
    jmp b1
    // print_dword_decimal::@1
  b1:
    // [120] call print_str 
    // [77] phi from print_dword_decimal::@1 to print_str [phi:print_dword_decimal::@1->print_str]
  print_str_from_b1:
    // [77] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:print_dword_decimal::@1->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const byte[$b]) decimal_digits_long [phi:print_dword_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta.z print_str.str
    lda #>decimal_digits_long
    sta.z print_str.str+1
    jsr print_str
    jmp breturn
    // print_dword_decimal::@return
  breturn:
    // [121] return 
    rts
}
  // ultoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// ultoa(dword zeropage($1e) value, byte* zeropage($65) buffer)
ultoa: {
    .const max_digits = $a
    .label _4 = $64
    .label _11 = $67
    .label digit_value = $68
    .label buffer = $65
    .label digit = $1d
    .label value = $1e
    .label buffer_4 = $23
    .label started = $22
    .label buffer_11 = $23
    .label buffer_14 = $23
    // [123] phi from ultoa to ultoa::@1 [phi:ultoa->ultoa::@1]
  b1_from_ultoa:
    // [123] phi (byte*) ultoa::buffer#11 = (const byte[$b]) decimal_digits_long [phi:ultoa->ultoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta.z buffer_11
    lda #>decimal_digits_long
    sta.z buffer_11+1
    // [123] phi (byte) ultoa::started#2 = (byte) 0 [phi:ultoa->ultoa::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z started
    // [123] phi (dword) ultoa::value#2 = (dword) ultoa::value#1 [phi:ultoa->ultoa::@1#2] -- register_copy 
    // [123] phi (byte) ultoa::digit#2 = (byte) 0 [phi:ultoa->ultoa::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    jmp b1
    // ultoa::@1
  b1:
    // [124] if((byte) ultoa::digit#2<(const byte) ultoa::max_digits#1-(byte) 1) goto ultoa::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z digit
    cmp #max_digits-1
    bcc b2
    jmp b3
    // ultoa::@3
  b3:
    // [125] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#2 -- vbuz1=_byte_vduz2 
    lda.z value
    sta.z _4
    // [126] *((byte*) ultoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) ultoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z _4
    lda DIGITS,y
    ldy #0
    sta (buffer_11),y
    // [127] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11 -- pbuz1=_inc_pbuz2 
    lda.z buffer_11
    clc
    adc #1
    sta.z buffer
    lda.z buffer_11+1
    adc #0
    sta.z buffer+1
    // [128] *((byte*) ultoa::buffer#3) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (buffer),y
    jmp breturn
    // ultoa::@return
  breturn:
    // [129] return 
    rts
    // ultoa::@2
  b2:
    // [130] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 -- vbuz1=vbuz2_rol_2 
    lda.z digit
    asl
    asl
    sta.z _11
    // [131] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG + (byte~) ultoa::$11) -- vduz1=pduc1_derefidx_vbuz2 
    ldy.z _11
    lda RADIX_DECIMAL_VALUES_LONG,y
    sta.z digit_value
    lda RADIX_DECIMAL_VALUES_LONG+1,y
    sta.z digit_value+1
    lda RADIX_DECIMAL_VALUES_LONG+2,y
    sta.z digit_value+2
    lda RADIX_DECIMAL_VALUES_LONG+3,y
    sta.z digit_value+3
    // [132] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@5 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z started
    bne b5
    jmp b7
    // ultoa::@7
  b7:
    // [133] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@5 -- vduz1_ge_vduz2_then_la1 
    lda.z value+3
    cmp.z digit_value+3
    bcc !+
    bne b5
    lda.z value+2
    cmp.z digit_value+2
    bcc !+
    bne b5
    lda.z value+1
    cmp.z digit_value+1
    bcc !+
    bne b5
    lda.z value
    cmp.z digit_value
    bcs b5
  !:
    // [134] phi from ultoa::@7 to ultoa::@4 [phi:ultoa::@7->ultoa::@4]
  b4_from_b7:
    // [134] phi (byte*) ultoa::buffer#14 = (byte*) ultoa::buffer#11 [phi:ultoa::@7->ultoa::@4#0] -- register_copy 
    // [134] phi (byte) ultoa::started#4 = (byte) ultoa::started#2 [phi:ultoa::@7->ultoa::@4#1] -- register_copy 
    // [134] phi (dword) ultoa::value#6 = (dword) ultoa::value#2 [phi:ultoa::@7->ultoa::@4#2] -- register_copy 
    jmp b4
    // ultoa::@4
  b4:
    // [135] (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc.z digit
    // [123] phi from ultoa::@4 to ultoa::@1 [phi:ultoa::@4->ultoa::@1]
  b1_from_b4:
    // [123] phi (byte*) ultoa::buffer#11 = (byte*) ultoa::buffer#14 [phi:ultoa::@4->ultoa::@1#0] -- register_copy 
    // [123] phi (byte) ultoa::started#2 = (byte) ultoa::started#4 [phi:ultoa::@4->ultoa::@1#1] -- register_copy 
    // [123] phi (dword) ultoa::value#2 = (dword) ultoa::value#6 [phi:ultoa::@4->ultoa::@1#2] -- register_copy 
    // [123] phi (byte) ultoa::digit#2 = (byte) ultoa::digit#1 [phi:ultoa::@4->ultoa::@1#3] -- register_copy 
    jmp b1
    // ultoa::@5
  b5:
    // [136] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11 -- pbuz1=pbuz2 
    lda.z buffer_11
    sta.z ultoa_append.buffer
    lda.z buffer_11+1
    sta.z ultoa_append.buffer+1
    // [137] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2 -- vduz1=vduz2 
    lda.z value
    sta.z ultoa_append.value
    lda.z value+1
    sta.z ultoa_append.value+1
    lda.z value+2
    sta.z ultoa_append.value+2
    lda.z value+3
    sta.z ultoa_append.value+3
    // [138] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0 -- vduz1=vduz2 
    lda.z digit_value
    sta.z ultoa_append.sub
    lda.z digit_value+1
    sta.z ultoa_append.sub+1
    lda.z digit_value+2
    sta.z ultoa_append.sub+2
    lda.z digit_value+3
    sta.z ultoa_append.sub+3
    // [139] call ultoa_append 
    // [143] phi from ultoa::@5 to ultoa_append [phi:ultoa::@5->ultoa_append]
  ultoa_append_from_b5:
    jsr ultoa_append
    // [140] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2 -- vduz1=vduz2 
    lda.z ultoa_append.value
    sta.z ultoa_append.return
    lda.z ultoa_append.value+1
    sta.z ultoa_append.return+1
    lda.z ultoa_append.value+2
    sta.z ultoa_append.return+2
    lda.z ultoa_append.value+3
    sta.z ultoa_append.return+3
    jmp b6
    // ultoa::@6
  b6:
    // [141] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0 -- vduz1=vduz2 
    lda.z ultoa_append.return
    sta.z value
    lda.z ultoa_append.return+1
    sta.z value+1
    lda.z ultoa_append.return+2
    sta.z value+2
    lda.z ultoa_append.return+3
    sta.z value+3
    // [142] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer_4
    bne !+
    inc.z buffer_4+1
  !:
    // [134] phi from ultoa::@6 to ultoa::@4 [phi:ultoa::@6->ultoa::@4]
  b4_from_b6:
    // [134] phi (byte*) ultoa::buffer#14 = (byte*) ultoa::buffer#4 [phi:ultoa::@6->ultoa::@4#0] -- register_copy 
    // [134] phi (byte) ultoa::started#4 = (byte) 1 [phi:ultoa::@6->ultoa::@4#1] -- vbuz1=vbuc1 
    lda #1
    sta.z started
    // [134] phi (dword) ultoa::value#6 = (dword) ultoa::value#0 [phi:ultoa::@6->ultoa::@4#2] -- register_copy 
    jmp b4
}
  // ultoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// ultoa_append(byte* zeropage($6c) buffer, dword zeropage($25) value, dword zeropage($6e) sub)
ultoa_append: {
    .label buffer = $6c
    .label value = $25
    .label sub = $6e
    .label return = $72
    .label digit = $29
    // [144] phi from ultoa_append to ultoa_append::@1 [phi:ultoa_append->ultoa_append::@1]
  b1_from_ultoa_append:
    // [144] phi (byte) ultoa_append::digit#2 = (byte) 0 [phi:ultoa_append->ultoa_append::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [144] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#0 [phi:ultoa_append->ultoa_append::@1#1] -- register_copy 
    jmp b1
    // ultoa_append::@1
  b1:
    // [145] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 -- vduz1_ge_vduz2_then_la1 
    lda.z value+3
    cmp.z sub+3
    bcc !+
    bne b2
    lda.z value+2
    cmp.z sub+2
    bcc !+
    bne b2
    lda.z value+1
    cmp.z sub+1
    bcc !+
    bne b2
    lda.z value
    cmp.z sub
    bcs b2
  !:
    jmp b3
    // ultoa_append::@3
  b3:
    // [146] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) ultoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z digit
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    jmp breturn
    // ultoa_append::@return
  breturn:
    // [147] return 
    rts
    // ultoa_append::@2
  b2:
    // [148] (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2 -- vbuz1=_inc_vbuz1 
    inc.z digit
    // [149] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 -- vduz1=vduz1_minus_vduz2 
    lda.z value
    sec
    sbc.z sub
    sta.z value
    lda.z value+1
    sbc.z sub+1
    sta.z value+1
    lda.z value+2
    sbc.z sub+2
    sta.z value+2
    lda.z value+3
    sbc.z sub+3
    sta.z value+3
    // [144] phi from ultoa_append::@2 to ultoa_append::@1 [phi:ultoa_append::@2->ultoa_append::@1]
  b1_from_b2:
    // [144] phi (byte) ultoa_append::digit#2 = (byte) ultoa_append::digit#1 [phi:ultoa_append::@2->ultoa_append::@1#0] -- register_copy 
    // [144] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#1 [phi:ultoa_append::@2->ultoa_append::@1#1] -- register_copy 
    jmp b1
}
  // div32u16u
// Divide unsigned 32-bit dword dividend with a 16-bit word divisor
// The 16-bit word remainder can be found in rem16u after the division
// div32u16u(dword zeropage($44) dividend)
div32u16u: {
    .label divisor = CLOCKS_PER_SEC/$64
    .label quotient_hi = $78
    .label quotient_lo = $7c
    .label return = $7e
    .label dividend = $44
    .label return_2 = $48
    // [150] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 -- vwuz1=_hi_vduz2 
    lda.z dividend+2
    sta.z divr16u.dividend
    lda.z dividend+3
    sta.z divr16u.dividend+1
    // [151] call divr16u 
    // [161] phi from div32u16u to divr16u [phi:div32u16u->divr16u]
  divr16u_from_div32u16u:
    // [161] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#1 [phi:div32u16u->divr16u#0] -- register_copy 
    // [161] phi (word) divr16u::rem#10 = (byte) 0 [phi:div32u16u->divr16u#1] -- vwuz1=vbuc1 
    lda #<0
    sta.z divr16u.rem
    lda #>0
    sta.z divr16u.rem+1
    jsr divr16u
    // [152] (word) divr16u::return#2 ← (word) divr16u::return#0 -- vwuz1=vwuz2 
    lda.z divr16u.return
    sta.z divr16u.return_2
    lda.z divr16u.return+1
    sta.z divr16u.return_2+1
    jmp b1
    // div32u16u::@1
  b1:
    // [153] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 -- vwuz1=vwuz2 
    lda.z divr16u.return_2
    sta.z quotient_hi
    lda.z divr16u.return_2+1
    sta.z quotient_hi+1
    // [154] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 -- vwuz1=_lo_vduz2 
    lda.z dividend
    sta.z divr16u.dividend
    lda.z dividend+1
    sta.z divr16u.dividend+1
    // [155] (word) divr16u::rem#4 ← (word) rem16u#1 -- vwuz1=vwuz2 
    lda.z rem16u
    sta.z divr16u.rem
    lda.z rem16u+1
    sta.z divr16u.rem+1
    // [156] call divr16u 
    // [161] phi from div32u16u::@1 to divr16u [phi:div32u16u::@1->divr16u]
  divr16u_from_b1:
    // [161] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#2 [phi:div32u16u::@1->divr16u#0] -- register_copy 
    // [161] phi (word) divr16u::rem#10 = (word) divr16u::rem#4 [phi:div32u16u::@1->divr16u#1] -- register_copy 
    jsr divr16u
    // [157] (word) divr16u::return#3 ← (word) divr16u::return#0 -- vwuz1=vwuz2 
    lda.z divr16u.return
    sta.z divr16u.return_3
    lda.z divr16u.return+1
    sta.z divr16u.return_3+1
    jmp b2
    // div32u16u::@2
  b2:
    // [158] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3 -- vwuz1=vwuz2 
    lda.z divr16u.return_3
    sta.z quotient_lo
    lda.z divr16u.return_3+1
    sta.z quotient_lo+1
    // [159] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 -- vduz1=vwuz2_dword_vwuz3 
    lda.z quotient_hi
    sta.z return+2
    lda.z quotient_hi+1
    sta.z return+3
    lda.z quotient_lo
    sta.z return
    lda.z quotient_lo+1
    sta.z return+1
    jmp breturn
    // div32u16u::@return
  breturn:
    // [160] return 
    rts
}
  // divr16u
// Performs division on two 16 bit unsigned words and an initial remainder
// Returns the quotient dividend/divisor.
// The final remainder will be set into the global variable rem16u
// Implemented using simple binary division
// divr16u(word zeropage($2c) dividend, word zeropage($2a) rem)
divr16u: {
    .label _1 = $82
    .label _2 = $83
    .label rem = $2a
    .label dividend = $2c
    .label quotient = $2e
    .label i = $30
    .label return = $2e
    .label return_2 = $76
    .label return_3 = $7a
    // [162] phi from divr16u to divr16u::@1 [phi:divr16u->divr16u::@1]
  b1_from_divr16u:
    // [162] phi (byte) divr16u::i#2 = (byte) 0 [phi:divr16u->divr16u::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [162] phi (word) divr16u::quotient#3 = (byte) 0 [phi:divr16u->divr16u::@1#1] -- vwuz1=vbuc1 
    lda #<0
    sta.z quotient
    lda #>0
    sta.z quotient+1
    // [162] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#5 [phi:divr16u->divr16u::@1#2] -- register_copy 
    // [162] phi (word) divr16u::rem#5 = (word) divr16u::rem#10 [phi:divr16u->divr16u::@1#3] -- register_copy 
    jmp b1
    // [162] phi from divr16u::@3 to divr16u::@1 [phi:divr16u::@3->divr16u::@1]
  b1_from_b3:
    // [162] phi (byte) divr16u::i#2 = (byte) divr16u::i#1 [phi:divr16u::@3->divr16u::@1#0] -- register_copy 
    // [162] phi (word) divr16u::quotient#3 = (word) divr16u::return#0 [phi:divr16u::@3->divr16u::@1#1] -- register_copy 
    // [162] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#0 [phi:divr16u::@3->divr16u::@1#2] -- register_copy 
    // [162] phi (word) divr16u::rem#5 = (word) divr16u::rem#11 [phi:divr16u::@3->divr16u::@1#3] -- register_copy 
    jmp b1
    // divr16u::@1
  b1:
    // [163] (word) divr16u::rem#0 ← (word) divr16u::rem#5 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z rem
    rol.z rem+1
    // [164] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 -- vbuz1=_hi_vwuz2 
    lda.z dividend+1
    sta.z _1
    // [165] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and.z _1
    sta.z _2
    // [166] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2 -- vbuz1_eq_0_then_la1 
    lda.z _2
    cmp #0
    beq b2_from_b1
    jmp b4
    // divr16u::@4
  b4:
    // [167] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 -- vwuz1=vwuz1_bor_vbuc1 
    lda #1
    ora.z rem
    sta.z rem
    // [168] phi from divr16u::@1 divr16u::@4 to divr16u::@2 [phi:divr16u::@1/divr16u::@4->divr16u::@2]
  b2_from_b1:
  b2_from_b4:
    // [168] phi (word) divr16u::rem#6 = (word) divr16u::rem#0 [phi:divr16u::@1/divr16u::@4->divr16u::@2#0] -- register_copy 
    jmp b2
    // divr16u::@2
  b2:
    // [169] (word) divr16u::dividend#0 ← (word) divr16u::dividend#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z dividend
    rol.z dividend+1
    // [170] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z quotient
    rol.z quotient+1
    // [171] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 -- vwuz1_lt_vwuc1_then_la1 
    lda.z rem+1
    cmp #>div32u16u.divisor
    bcc b3_from_b2
    bne !+
    lda.z rem
    cmp #<div32u16u.divisor
    bcc b3_from_b2
  !:
    jmp b5
    // divr16u::@5
  b5:
    // [172] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1 -- vwuz1=_inc_vwuz1 
    inc.z quotient
    bne !+
    inc.z quotient+1
  !:
    // [173] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 -- vwuz1=vwuz1_minus_vwuc1 
    lda.z rem
    sec
    sbc #<div32u16u.divisor
    sta.z rem
    lda.z rem+1
    sbc #>div32u16u.divisor
    sta.z rem+1
    // [174] phi from divr16u::@2 divr16u::@5 to divr16u::@3 [phi:divr16u::@2/divr16u::@5->divr16u::@3]
  b3_from_b2:
  b3_from_b5:
    // [174] phi (word) divr16u::return#0 = (word) divr16u::quotient#1 [phi:divr16u::@2/divr16u::@5->divr16u::@3#0] -- register_copy 
    // [174] phi (word) divr16u::rem#11 = (word) divr16u::rem#6 [phi:divr16u::@2/divr16u::@5->divr16u::@3#1] -- register_copy 
    jmp b3
    // divr16u::@3
  b3:
    // [175] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [176] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$10
    cmp.z i
    bne b1_from_b3
    jmp b6
    // divr16u::@6
  b6:
    // [177] (word) rem16u#1 ← (word) divr16u::rem#11 -- vwuz1=vwuz2 
    lda.z rem
    sta.z rem16u
    lda.z rem+1
    sta.z rem16u+1
    jmp breturn
    // divr16u::@return
  breturn:
    // [178] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = $86
    .label return_2 = $38
    // [179] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta.z return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta.z return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta.z return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta.z return+3
    jmp breturn
    // clock::@return
  breturn:
    // [180] return 
    rts
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [181] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #CIA_TIMER_CONTROL_CONTINUOUS
    sta CIA2_TIMER_A_CONTROL
    // [182] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [183] *((const dword*) CIA2_TIMER_AB) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [184] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [185] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2_TIMER_A_CONTROL
    jmp breturn
    // clock_start::@return
  breturn:
    // [186] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zeropage($33) str, byte zeropage($35) c, word zeropage($31) num)
memset: {
    .label end = $8a
    .label dst = $36
    .label num = $31
    .label str = $33
    .label c = $35
    // [188] if((word) memset::num#2<=(byte) 0) goto memset::@return -- vwuz1_le_0_then_la1 
    lda.z num
    bne !+
    lda.z num+1
    beq breturn
  !:
    jmp b1
    // memset::@1
  b1:
    // [189] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 -- pbuz1=pbuz2_plus_vwuz3 
    lda.z str
    clc
    adc.z num
    sta.z end
    lda.z str+1
    adc.z num+1
    sta.z end+1
    // [190] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3 -- pbuz1=pbuz2 
    lda.z str
    sta.z dst
    lda.z str+1
    sta.z dst+1
    // [191] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  b2_from_b1:
  b2_from_b3:
    // [191] phi (byte*) memset::dst#2 = (byte*~) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp b2
    // memset::@2
  b2:
    // [192] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne b3
    lda.z dst
    cmp.z end
    bne b3
    jmp breturn
    // memset::@return
  breturn:
    // [193] return 
    rts
    // memset::@3
  b3:
    // [194] *((byte*) memset::dst#2) ← (byte) memset::c#4 -- _deref_pbuz1=vbuz2 
    lda.z c
    ldy #0
    sta (dst),y
    // [195] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp b2_from_b3
}
  // print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    // [197] call memset 
    // [187] phi from print_cls to memset [phi:print_cls->memset]
  memset_from_print_cls:
    // [187] phi (byte) memset::c#4 = (byte) ' ' [phi:print_cls->memset#0] -- vbuz1=vbuc1 
    lda #' '
    sta.z memset.c
    // [187] phi (void*) memset::str#3 = (void*)(byte*) 1024 [phi:print_cls->memset#1] -- pvoz1=pvoc1 
    lda #<$400
    sta.z memset.str
    lda #>$400
    sta.z memset.str+1
    // [187] phi (word) memset::num#2 = (word) $3e8 [phi:print_cls->memset#2] -- vwuz1=vwuc1 
    lda #<$3e8
    sta.z memset.num
    lda #>$3e8
    sta.z memset.num+1
    jsr memset
    jmp breturn
    // print_cls::@return
  breturn:
    // [198] return 
    rts
}
  // File Data
  // The digits used for numbers
  DIGITS: .text "0123456789abcdef"
  // Values of decimal digits
  RADIX_DECIMAL_VALUES: .word $2710, $3e8, $64, $a
  // Values of decimal digits
  RADIX_DECIMAL_VALUES_LONG: .dword $3b9aca00, $5f5e100, $989680, $f4240, $186a0, $2710, $3e8, $64, $a
  // Digits used for storing the decimal word
  decimal_digits: .fill 6, 0
  // Digits used for storing the decimal word
  decimal_digits_long: .fill $b, 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] *((const byte*) D018) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 [ print_char_cursor#90 print_line_cursor#1 ] ( main:2 [ print_char_cursor#90 print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [23] if((word) main::i#12<(const byte) SQRT_COUNT) goto main::@2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 ] ) always clobbers reg byte a 
Statement [26] (dword) clock::return#2 ← (dword) clock::return#0 [ print_line_cursor#1 clock::return#2 ] ( main:2 [ print_line_cursor#1 clock::return#2 ] ) always clobbers reg byte a 
Statement [27] (dword~) main::$10 ← (dword) clock::return#2 [ print_line_cursor#1 main::$10 ] ( main:2 [ print_line_cursor#1 main::$10 ] ) always clobbers reg byte a 
Statement [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT [ print_line_cursor#1 main::cyclecount#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 ] ) always clobbers reg byte a 
Statement [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 ] ) always clobbers reg byte a 
Statement [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#2 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#2 ] ) always clobbers reg byte a 
Statement [32] (dword~) main::$14 ← (dword) div32u16u::return#2 [ print_line_cursor#1 main::cyclecount#0 main::$14 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::$14 ] ) always clobbers reg byte a 
Statement [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 ] ) always clobbers reg byte a 
Statement [34] (byte*~) print_char_cursor#91 ← (byte*) print_line_cursor#1 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#91 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#91 ] ) always clobbers reg byte a 
Statement [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0 [ print_line_cursor#1 main::cyclecount#0 print_word_decimal::w#1 print_char_cursor#2 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 print_word_decimal::w#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0 [ print_line_cursor#1 print_dword_decimal::w#0 print_char_cursor#2 ] ( main:2 [ print_line_cursor#1 print_dword_decimal::w#0 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [45] if((word) main::i#10<(word) $514) goto main::@9 [ main::i#10 print_char_cursor#62 ] ( main:2 [ main::i#10 print_char_cursor#62 ] ) always clobbers reg byte a 
Statement [46] (byte*~) print_char_cursor#89 ← (byte*) print_char_cursor#62 [ print_char_cursor#89 ] ( main:2 [ print_char_cursor#89 ] ) always clobbers reg byte a 
Statement [49] (byte*~) main::$39 ← (const byte*) sieve#0 + (word) main::i#10 [ main::i#10 print_char_cursor#62 main::$39 ] ( main:2 [ main::i#10 print_char_cursor#62 main::$39 ] ) always clobbers reg byte a 
Statement [50] if((byte) 0!=*((byte*~) main::$39)) goto main::@11 [ main::i#10 print_char_cursor#62 ] ( main:2 [ main::i#10 print_char_cursor#62 ] ) always clobbers reg byte a reg byte y 
Statement [51] (word) print_word_decimal::w#2 ← (word) main::i#10 [ main::i#10 print_char_cursor#62 print_word_decimal::w#2 ] ( main:2 [ main::i#10 print_char_cursor#62 print_word_decimal::w#2 ] ) always clobbers reg byte a 
Statement [52] (byte*~) print_char_cursor#97 ← (byte*) print_char_cursor#62 [ main::i#10 print_word_decimal::w#2 print_char_cursor#97 ] ( main:2 [ main::i#10 print_word_decimal::w#2 print_char_cursor#97 ] ) always clobbers reg byte a 
Statement [58] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 [ print_line_cursor#1 main::i#12 main::sieve_i#2 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 ] ) always clobbers reg byte a reg byte y 
Statement [59] (word) main::j#0 ← (word) main::i#12 << (byte) 1 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#0 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#0 ] ) always clobbers reg byte a 
Statement [60] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#0 main::s#0 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#0 main::s#0 ] ) always clobbers reg byte a 
Statement [62] if((word) main::j#2<(const word) COUNT) goto main::@6 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#2 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#2 ] ) always clobbers reg byte a 
Statement [65] *((byte*) main::s#2) ← (byte) 1 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#2 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#2 ] ) always clobbers reg byte a reg byte y 
Statement [66] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#12 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#1 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#1 ] ) always clobbers reg byte a 
Statement [67] (word) main::j#1 ← (word) main::j#2 + (word) main::i#12 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#1 main::s#1 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#1 main::s#1 ] ) always clobbers reg byte a 
Statement [68] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 [ print_char_cursor#2 ] ( main:2::print_char:55 [ main::i#10 print_char_cursor#2 ] ) always clobbers reg byte a reg byte y 
Statement [69] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2 [ print_char_cursor#10 ] ( main:2::print_char:55 [ main::i#10 print_char_cursor#10 ] ) always clobbers reg byte a 
Statement [72] (word) utoa::value#1 ← (word) print_word_decimal::w#3 [ print_char_cursor#58 utoa::value#1 ] ( main:2::print_word_decimal:15 [ print_line_cursor#1 print_char_cursor#58 utoa::value#1 ] main:2::print_word_decimal:37 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::value#1 ] main:2::print_word_decimal:53 [ main::i#10 print_char_cursor#58 utoa::value#1 ] ) always clobbers reg byte a 
Statement [79] if((byte) 0!=*((byte*) print_str::str#8)) goto print_str::@2 [ print_char_cursor#2 print_str::str#8 ] ( main:2::print_str:9 [ print_char_cursor#2 print_str::str#8 ] main:2::print_str:13 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_str:35 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:39 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:47 [ print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:15::print_str:75 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:37::print_str:75 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:53::print_str:75 [ main::i#10 print_char_cursor#2 print_str::str#8 ] main:2::print_dword_decimal:41::print_str:120 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] ) always clobbers reg byte a reg byte y 
Statement [81] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) [ print_char_cursor#2 print_str::str#8 ] ( main:2::print_str:9 [ print_char_cursor#2 print_str::str#8 ] main:2::print_str:13 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_str:35 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:39 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:47 [ print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:15::print_str:75 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:37::print_str:75 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:53::print_str:75 [ main::i#10 print_char_cursor#2 print_str::str#8 ] main:2::print_dword_decimal:41::print_str:120 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] ) always clobbers reg byte a reg byte y 
Statement [87] (byte~) utoa::$4 ← (byte)(word) utoa::value#2 [ utoa::buffer#11 utoa::$4 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#11 utoa::$4 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#11 utoa::$4 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::buffer#11 utoa::$4 ] ) always clobbers reg byte a 
Statement [88] *((byte*) utoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) utoa::$4) [ utoa::buffer#11 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#11 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#11 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::buffer#11 ] ) always clobbers reg byte a reg byte y 
Statement [89] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11 [ utoa::buffer#3 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#3 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#3 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::buffer#3 ] ) always clobbers reg byte a 
Statement [90] *((byte*) utoa::buffer#3) ← (byte) 0 [ ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 ] ) always clobbers reg byte a reg byte y 
Statement [92] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:21 [ utoa::started#2 utoa::started#4 ]
Statement [93] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES + (byte~) utoa::$11) [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [95] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@5 [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [98] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11 [ utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] ) always clobbers reg byte a 
Statement [99] (word) utoa_append::value#0 ← (word) utoa::value#2 [ utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] ) always clobbers reg byte a 
Statement [100] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0 [ utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] ) always clobbers reg byte a 
Statement [102] (word) utoa_append::return#0 ← (word) utoa_append::value#2 [ utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] ) always clobbers reg byte a 
Statement [103] (word) utoa::value#0 ← (word) utoa_append::return#0 [ utoa::digit#2 utoa::buffer#11 utoa::value#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] ) always clobbers reg byte a 
Statement [107] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 [ utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] ( main:2::print_word_decimal:15::utoa:73::utoa_append:101 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] main:2::print_word_decimal:37::utoa:73::utoa_append:101 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] main:2::print_word_decimal:53::utoa:73::utoa_append:101 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:26 [ utoa_append::digit#2 utoa_append::digit#1 ]
Statement [108] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) utoa_append::digit#2) [ utoa_append::value#2 ] ( main:2::print_word_decimal:15::utoa:73::utoa_append:101 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] main:2::print_word_decimal:37::utoa:73::utoa_append:101 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] main:2::print_word_decimal:53::utoa:73::utoa_append:101 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ]
Statement [111] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 [ utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] ( main:2::print_word_decimal:15::utoa:73::utoa_append:101 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] main:2::print_word_decimal:37::utoa:73::utoa_append:101 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] main:2::print_word_decimal:53::utoa:73::utoa_append:101 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] ) always clobbers reg byte a 
Statement [114] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 [ print_line_cursor#1 print_char_cursor#2 ] ( main:2::print_ln:11 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:17 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:43 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [115] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 [ print_line_cursor#1 print_char_cursor#2 ] ( main:2::print_ln:11 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:17 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:43 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [117] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0 [ print_char_cursor#2 ultoa::value#1 ] ( main:2::print_dword_decimal:41 [ print_line_cursor#1 print_char_cursor#2 ultoa::value#1 ] ) always clobbers reg byte a 
Statement [125] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#2 [ ultoa::buffer#11 ultoa::$4 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#11 ultoa::$4 ] ) always clobbers reg byte a 
Statement [126] *((byte*) ultoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) ultoa::$4) [ ultoa::buffer#11 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#11 ] ) always clobbers reg byte a reg byte y 
Statement [127] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11 [ ultoa::buffer#3 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#3 ] ) always clobbers reg byte a 
Statement [128] *((byte*) ultoa::buffer#3) ← (byte) 0 [ ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a reg byte y 
Statement [130] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::$11 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::$11 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:34 [ ultoa::started#2 ultoa::started#4 ]
Statement [131] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG + (byte~) ultoa::$11) [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [133] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@5 [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [136] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11 [ ultoa::digit#2 ultoa::value#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ] ) always clobbers reg byte a 
Statement [137] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2 [ ultoa::digit#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ultoa_append::value#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ultoa_append::value#0 ] ) always clobbers reg byte a 
Statement [138] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0 [ ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::value#0 ultoa_append::sub#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::value#0 ultoa_append::sub#0 ] ) always clobbers reg byte a 
Statement [140] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2 [ ultoa::digit#2 ultoa::buffer#11 ultoa_append::return#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::return#0 ] ) always clobbers reg byte a 
Statement [141] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0 [ ultoa::digit#2 ultoa::buffer#11 ultoa::value#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa::value#0 ] ) always clobbers reg byte a 
Statement [145] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 [ ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#2 ultoa_append::digit#2 ] ( main:2::print_dword_decimal:41::ultoa:118::ultoa_append:139 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#2 ultoa_append::digit#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:41 [ ultoa_append::digit#2 ultoa_append::digit#1 ]
Statement [146] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) ultoa_append::digit#2) [ ultoa_append::value#2 ] ( main:2::print_dword_decimal:41::ultoa:118::ultoa_append:139 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::value#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ]
Statement [149] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 [ ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#1 ultoa_append::digit#1 ] ( main:2::print_dword_decimal:41::ultoa:118::ultoa_append:139 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#1 ultoa_append::digit#1 ] ) always clobbers reg byte a 
Statement [150] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 [ div32u16u::dividend#0 divr16u::dividend#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#1 ] ) always clobbers reg byte a 
Statement [152] (word) divr16u::return#2 ← (word) divr16u::return#0 [ div32u16u::dividend#0 divr16u::return#2 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::return#2 rem16u#1 ] ) always clobbers reg byte a 
Statement [153] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 [ div32u16u::dividend#0 div32u16u::quotient_hi#0 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 div32u16u::quotient_hi#0 rem16u#1 ] ) always clobbers reg byte a 
Statement [154] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 [ div32u16u::quotient_hi#0 divr16u::dividend#2 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#2 rem16u#1 ] ) always clobbers reg byte a 
Statement [155] (word) divr16u::rem#4 ← (word) rem16u#1 [ div32u16u::quotient_hi#0 divr16u::dividend#2 divr16u::rem#4 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#2 divr16u::rem#4 ] ) always clobbers reg byte a 
Statement [157] (word) divr16u::return#3 ← (word) divr16u::return#0 [ div32u16u::quotient_hi#0 divr16u::return#3 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::return#3 ] ) always clobbers reg byte a 
Statement [158] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3 [ div32u16u::quotient_hi#0 div32u16u::quotient_lo#0 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 div32u16u::quotient_lo#0 ] ) always clobbers reg byte a 
Statement [159] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 [ div32u16u::return#0 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#0 ] ) always clobbers reg byte a 
Statement [164] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 [ divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:48 [ divr16u::i#2 divr16u::i#1 ]
Statement [167] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 [ divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ) always clobbers reg byte a 
Statement [171] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 [ divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] ) always clobbers reg byte a 
Statement [173] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 [ divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ) always clobbers reg byte a 
Statement [177] (word) rem16u#1 ← (word) divr16u::rem#11 [ divr16u::return#0 rem16u#1 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::return#0 rem16u#1 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::return#0 rem16u#1 ] ) always clobbers reg byte a 
Statement [179] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB) [ clock::return#0 ] ( main:2::clock:25 [ print_line_cursor#1 clock::return#0 ] ) always clobbers reg byte a 
Statement [181] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [182] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [183] *((const dword*) CIA2_TIMER_AB) ← (dword) $ffffffff [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [184] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [185] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [188] if((word) memset::num#2<=(byte) 0) goto memset::@return [ memset::num#2 memset::str#3 memset::c#4 ] ( main:2::memset:19 [ print_line_cursor#1 memset::num#2 memset::str#3 memset::c#4 ] main:2::print_cls:7::memset:197 [ memset::num#2 memset::str#3 memset::c#4 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:53 [ memset::c#4 ]
Statement [189] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 [ memset::str#3 memset::c#4 memset::end#0 ] ( main:2::memset:19 [ print_line_cursor#1 memset::str#3 memset::c#4 memset::end#0 ] main:2::print_cls:7::memset:197 [ memset::str#3 memset::c#4 memset::end#0 ] ) always clobbers reg byte a 
Statement [190] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3 [ memset::c#4 memset::end#0 memset::dst#4 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#4 memset::end#0 memset::dst#4 ] main:2::print_cls:7::memset:197 [ memset::c#4 memset::end#0 memset::dst#4 ] ) always clobbers reg byte a 
Statement [192] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 [ memset::c#4 memset::end#0 memset::dst#2 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#4 memset::end#0 memset::dst#2 ] main:2::print_cls:7::memset:197 [ memset::c#4 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a 
Statement [194] *((byte*) memset::dst#2) ← (byte) memset::c#4 [ memset::c#4 memset::end#0 memset::dst#2 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#4 memset::end#0 memset::dst#2 ] main:2::print_cls:7::memset:197 [ memset::c#4 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:53 [ memset::c#4 ]
Statement [6] *((const byte*) D018) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 [ print_char_cursor#90 print_line_cursor#1 ] ( main:2 [ print_char_cursor#90 print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [23] if((word) main::i#12<(const byte) SQRT_COUNT) goto main::@2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 ] ) always clobbers reg byte a 
Statement [26] (dword) clock::return#2 ← (dword) clock::return#0 [ print_line_cursor#1 clock::return#2 ] ( main:2 [ print_line_cursor#1 clock::return#2 ] ) always clobbers reg byte a 
Statement [27] (dword~) main::$10 ← (dword) clock::return#2 [ print_line_cursor#1 main::$10 ] ( main:2 [ print_line_cursor#1 main::$10 ] ) always clobbers reg byte a 
Statement [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT [ print_line_cursor#1 main::cyclecount#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 ] ) always clobbers reg byte a 
Statement [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 ] ) always clobbers reg byte a 
Statement [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#2 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#2 ] ) always clobbers reg byte a 
Statement [32] (dword~) main::$14 ← (dword) div32u16u::return#2 [ print_line_cursor#1 main::cyclecount#0 main::$14 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::$14 ] ) always clobbers reg byte a 
Statement [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 ] ) always clobbers reg byte a 
Statement [34] (byte*~) print_char_cursor#91 ← (byte*) print_line_cursor#1 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#91 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#91 ] ) always clobbers reg byte a 
Statement [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0 [ print_line_cursor#1 main::cyclecount#0 print_word_decimal::w#1 print_char_cursor#2 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 print_word_decimal::w#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0 [ print_line_cursor#1 print_dword_decimal::w#0 print_char_cursor#2 ] ( main:2 [ print_line_cursor#1 print_dword_decimal::w#0 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [45] if((word) main::i#10<(word) $514) goto main::@9 [ main::i#10 print_char_cursor#62 ] ( main:2 [ main::i#10 print_char_cursor#62 ] ) always clobbers reg byte a 
Statement [46] (byte*~) print_char_cursor#89 ← (byte*) print_char_cursor#62 [ print_char_cursor#89 ] ( main:2 [ print_char_cursor#89 ] ) always clobbers reg byte a 
Statement [49] (byte*~) main::$39 ← (const byte*) sieve#0 + (word) main::i#10 [ main::i#10 print_char_cursor#62 main::$39 ] ( main:2 [ main::i#10 print_char_cursor#62 main::$39 ] ) always clobbers reg byte a 
Statement [50] if((byte) 0!=*((byte*~) main::$39)) goto main::@11 [ main::i#10 print_char_cursor#62 ] ( main:2 [ main::i#10 print_char_cursor#62 ] ) always clobbers reg byte a reg byte y 
Statement [51] (word) print_word_decimal::w#2 ← (word) main::i#10 [ main::i#10 print_char_cursor#62 print_word_decimal::w#2 ] ( main:2 [ main::i#10 print_char_cursor#62 print_word_decimal::w#2 ] ) always clobbers reg byte a 
Statement [52] (byte*~) print_char_cursor#97 ← (byte*) print_char_cursor#62 [ main::i#10 print_word_decimal::w#2 print_char_cursor#97 ] ( main:2 [ main::i#10 print_word_decimal::w#2 print_char_cursor#97 ] ) always clobbers reg byte a 
Statement [58] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 [ print_line_cursor#1 main::i#12 main::sieve_i#2 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 ] ) always clobbers reg byte a reg byte y 
Statement [59] (word) main::j#0 ← (word) main::i#12 << (byte) 1 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#0 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#0 ] ) always clobbers reg byte a 
Statement [60] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#0 main::s#0 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#0 main::s#0 ] ) always clobbers reg byte a 
Statement [62] if((word) main::j#2<(const word) COUNT) goto main::@6 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#2 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#2 ] ) always clobbers reg byte a 
Statement [65] *((byte*) main::s#2) ← (byte) 1 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#2 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#2 ] ) always clobbers reg byte a reg byte y 
Statement [66] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#12 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#1 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#2 main::s#1 ] ) always clobbers reg byte a 
Statement [67] (word) main::j#1 ← (word) main::j#2 + (word) main::i#12 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#1 main::s#1 ] ( main:2 [ print_line_cursor#1 main::i#12 main::sieve_i#2 main::j#1 main::s#1 ] ) always clobbers reg byte a 
Statement [68] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 [ print_char_cursor#2 ] ( main:2::print_char:55 [ main::i#10 print_char_cursor#2 ] ) always clobbers reg byte a reg byte y 
Statement [69] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2 [ print_char_cursor#10 ] ( main:2::print_char:55 [ main::i#10 print_char_cursor#10 ] ) always clobbers reg byte a 
Statement [72] (word) utoa::value#1 ← (word) print_word_decimal::w#3 [ print_char_cursor#58 utoa::value#1 ] ( main:2::print_word_decimal:15 [ print_line_cursor#1 print_char_cursor#58 utoa::value#1 ] main:2::print_word_decimal:37 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::value#1 ] main:2::print_word_decimal:53 [ main::i#10 print_char_cursor#58 utoa::value#1 ] ) always clobbers reg byte a 
Statement [79] if((byte) 0!=*((byte*) print_str::str#8)) goto print_str::@2 [ print_char_cursor#2 print_str::str#8 ] ( main:2::print_str:9 [ print_char_cursor#2 print_str::str#8 ] main:2::print_str:13 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_str:35 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:39 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:47 [ print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:15::print_str:75 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:37::print_str:75 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:53::print_str:75 [ main::i#10 print_char_cursor#2 print_str::str#8 ] main:2::print_dword_decimal:41::print_str:120 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] ) always clobbers reg byte a reg byte y 
Statement [81] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) [ print_char_cursor#2 print_str::str#8 ] ( main:2::print_str:9 [ print_char_cursor#2 print_str::str#8 ] main:2::print_str:13 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_str:35 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:39 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:47 [ print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:15::print_str:75 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:37::print_str:75 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:53::print_str:75 [ main::i#10 print_char_cursor#2 print_str::str#8 ] main:2::print_dword_decimal:41::print_str:120 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] ) always clobbers reg byte a reg byte y 
Statement [87] (byte~) utoa::$4 ← (byte)(word) utoa::value#2 [ utoa::buffer#11 utoa::$4 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#11 utoa::$4 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#11 utoa::$4 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::buffer#11 utoa::$4 ] ) always clobbers reg byte a 
Statement [88] *((byte*) utoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) utoa::$4) [ utoa::buffer#11 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#11 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#11 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::buffer#11 ] ) always clobbers reg byte a reg byte y 
Statement [89] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11 [ utoa::buffer#3 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#3 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#3 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::buffer#3 ] ) always clobbers reg byte a 
Statement [90] *((byte*) utoa::buffer#3) ← (byte) 0 [ ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 ] ) always clobbers reg byte a reg byte y 
Statement [92] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] ) always clobbers reg byte a 
Statement [93] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES + (byte~) utoa::$11) [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [95] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@5 [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [98] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11 [ utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] ) always clobbers reg byte a 
Statement [99] (word) utoa_append::value#0 ← (word) utoa::value#2 [ utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] ) always clobbers reg byte a 
Statement [100] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0 [ utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] ) always clobbers reg byte a 
Statement [102] (word) utoa_append::return#0 ← (word) utoa_append::value#2 [ utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] ) always clobbers reg byte a 
Statement [103] (word) utoa::value#0 ← (word) utoa_append::return#0 [ utoa::digit#2 utoa::buffer#11 utoa::value#0 ] ( main:2::print_word_decimal:15::utoa:73 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] main:2::print_word_decimal:37::utoa:73 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] main:2::print_word_decimal:53::utoa:73 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] ) always clobbers reg byte a 
Statement [107] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 [ utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] ( main:2::print_word_decimal:15::utoa:73::utoa_append:101 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] main:2::print_word_decimal:37::utoa:73::utoa_append:101 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] main:2::print_word_decimal:53::utoa:73::utoa_append:101 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] ) always clobbers reg byte a 
Statement [108] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) utoa_append::digit#2) [ utoa_append::value#2 ] ( main:2::print_word_decimal:15::utoa:73::utoa_append:101 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] main:2::print_word_decimal:37::utoa:73::utoa_append:101 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] main:2::print_word_decimal:53::utoa:73::utoa_append:101 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] ) always clobbers reg byte a reg byte y 
Statement [111] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 [ utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] ( main:2::print_word_decimal:15::utoa:73::utoa_append:101 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] main:2::print_word_decimal:37::utoa:73::utoa_append:101 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] main:2::print_word_decimal:53::utoa:73::utoa_append:101 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] ) always clobbers reg byte a 
Statement [114] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 [ print_line_cursor#1 print_char_cursor#2 ] ( main:2::print_ln:11 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:17 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:43 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [115] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 [ print_line_cursor#1 print_char_cursor#2 ] ( main:2::print_ln:11 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:17 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:43 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [117] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0 [ print_char_cursor#2 ultoa::value#1 ] ( main:2::print_dword_decimal:41 [ print_line_cursor#1 print_char_cursor#2 ultoa::value#1 ] ) always clobbers reg byte a 
Statement [125] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#2 [ ultoa::buffer#11 ultoa::$4 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#11 ultoa::$4 ] ) always clobbers reg byte a 
Statement [126] *((byte*) ultoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) ultoa::$4) [ ultoa::buffer#11 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#11 ] ) always clobbers reg byte a reg byte y 
Statement [127] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11 [ ultoa::buffer#3 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#3 ] ) always clobbers reg byte a 
Statement [128] *((byte*) ultoa::buffer#3) ← (byte) 0 [ ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a reg byte y 
Statement [130] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::$11 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::$11 ] ) always clobbers reg byte a 
Statement [131] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG + (byte~) ultoa::$11) [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [133] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@5 [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [136] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11 [ ultoa::digit#2 ultoa::value#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ] ) always clobbers reg byte a 
Statement [137] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2 [ ultoa::digit#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ultoa_append::value#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ultoa_append::value#0 ] ) always clobbers reg byte a 
Statement [138] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0 [ ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::value#0 ultoa_append::sub#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::value#0 ultoa_append::sub#0 ] ) always clobbers reg byte a 
Statement [140] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2 [ ultoa::digit#2 ultoa::buffer#11 ultoa_append::return#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::return#0 ] ) always clobbers reg byte a 
Statement [141] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0 [ ultoa::digit#2 ultoa::buffer#11 ultoa::value#0 ] ( main:2::print_dword_decimal:41::ultoa:118 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa::value#0 ] ) always clobbers reg byte a 
Statement [145] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 [ ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#2 ultoa_append::digit#2 ] ( main:2::print_dword_decimal:41::ultoa:118::ultoa_append:139 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#2 ultoa_append::digit#2 ] ) always clobbers reg byte a 
Statement [146] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) ultoa_append::digit#2) [ ultoa_append::value#2 ] ( main:2::print_dword_decimal:41::ultoa:118::ultoa_append:139 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::value#2 ] ) always clobbers reg byte a reg byte y 
Statement [149] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 [ ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#1 ultoa_append::digit#1 ] ( main:2::print_dword_decimal:41::ultoa:118::ultoa_append:139 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#1 ultoa_append::digit#1 ] ) always clobbers reg byte a 
Statement [150] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 [ div32u16u::dividend#0 divr16u::dividend#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#1 ] ) always clobbers reg byte a 
Statement [152] (word) divr16u::return#2 ← (word) divr16u::return#0 [ div32u16u::dividend#0 divr16u::return#2 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::return#2 rem16u#1 ] ) always clobbers reg byte a 
Statement [153] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 [ div32u16u::dividend#0 div32u16u::quotient_hi#0 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 div32u16u::quotient_hi#0 rem16u#1 ] ) always clobbers reg byte a 
Statement [154] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 [ div32u16u::quotient_hi#0 divr16u::dividend#2 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#2 rem16u#1 ] ) always clobbers reg byte a 
Statement [155] (word) divr16u::rem#4 ← (word) rem16u#1 [ div32u16u::quotient_hi#0 divr16u::dividend#2 divr16u::rem#4 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#2 divr16u::rem#4 ] ) always clobbers reg byte a 
Statement [157] (word) divr16u::return#3 ← (word) divr16u::return#0 [ div32u16u::quotient_hi#0 divr16u::return#3 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::return#3 ] ) always clobbers reg byte a 
Statement [158] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3 [ div32u16u::quotient_hi#0 div32u16u::quotient_lo#0 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 div32u16u::quotient_lo#0 ] ) always clobbers reg byte a 
Statement [159] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 [ div32u16u::return#0 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#0 ] ) always clobbers reg byte a 
Statement [164] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 [ divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ) always clobbers reg byte a 
Statement [167] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 [ divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ) always clobbers reg byte a 
Statement [171] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 [ divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] ) always clobbers reg byte a 
Statement [173] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 [ divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ) always clobbers reg byte a 
Statement [177] (word) rem16u#1 ← (word) divr16u::rem#11 [ divr16u::return#0 rem16u#1 ] ( main:2::div32u16u:30::divr16u:151 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::return#0 rem16u#1 ] main:2::div32u16u:30::divr16u:156 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::return#0 rem16u#1 ] ) always clobbers reg byte a 
Statement [179] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB) [ clock::return#0 ] ( main:2::clock:25 [ print_line_cursor#1 clock::return#0 ] ) always clobbers reg byte a 
Statement [181] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [182] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [183] *((const dword*) CIA2_TIMER_AB) ← (dword) $ffffffff [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [184] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [185] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [188] if((word) memset::num#2<=(byte) 0) goto memset::@return [ memset::num#2 memset::str#3 memset::c#4 ] ( main:2::memset:19 [ print_line_cursor#1 memset::num#2 memset::str#3 memset::c#4 ] main:2::print_cls:7::memset:197 [ memset::num#2 memset::str#3 memset::c#4 ] ) always clobbers reg byte a 
Statement [189] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 [ memset::str#3 memset::c#4 memset::end#0 ] ( main:2::memset:19 [ print_line_cursor#1 memset::str#3 memset::c#4 memset::end#0 ] main:2::print_cls:7::memset:197 [ memset::str#3 memset::c#4 memset::end#0 ] ) always clobbers reg byte a 
Statement [190] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3 [ memset::c#4 memset::end#0 memset::dst#4 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#4 memset::end#0 memset::dst#4 ] main:2::print_cls:7::memset:197 [ memset::c#4 memset::end#0 memset::dst#4 ] ) always clobbers reg byte a 
Statement [192] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 [ memset::c#4 memset::end#0 memset::dst#2 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#4 memset::end#0 memset::dst#2 ] main:2::print_cls:7::memset:197 [ memset::c#4 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a 
Statement [194] *((byte*) memset::dst#2) ← (byte) memset::c#4 [ memset::c#4 memset::end#0 memset::dst#2 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#4 memset::end#0 memset::dst#2 ] main:2::print_cls:7::memset:197 [ memset::c#4 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a reg byte y 
Potential registers zp ZP_WORD:2 [ main::i#12 main::i#2 ] : zp ZP_WORD:2 , 
Potential registers zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ] : zp ZP_WORD:4 , 
Potential registers zp ZP_WORD:6 [ main::i#10 main::i#3 ] : zp ZP_WORD:6 , 
Potential registers zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ] : zp ZP_WORD:8 , 
Potential registers zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ] : zp ZP_WORD:10 , 
Potential registers zp ZP_WORD:12 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] : zp ZP_WORD:12 , 
Potential registers zp ZP_WORD:14 [ print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 ] : zp ZP_WORD:14 , 
Potential registers zp ZP_WORD:16 [ print_str::str#8 print_str::str#10 print_str::str#0 ] : zp ZP_WORD:16 , 
Potential registers zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ] : zp ZP_BYTE:18 , reg byte x , 
Potential registers zp ZP_WORD:19 [ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 ] : zp ZP_WORD:19 , 
Potential registers zp ZP_BYTE:21 [ utoa::started#2 utoa::started#4 ] : zp ZP_BYTE:21 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 ] : zp ZP_WORD:22 , 
Potential registers zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] : zp ZP_WORD:24 , 
Potential registers zp ZP_BYTE:26 [ utoa_append::digit#2 utoa_append::digit#1 ] : zp ZP_BYTE:26 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:27 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#78 print_line_cursor#1 print_char_cursor#10 ] : zp ZP_WORD:27 , 
Potential registers zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ] : zp ZP_BYTE:29 , reg byte x , 
Potential registers zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ] : zp ZP_DWORD:30 , 
Potential registers zp ZP_BYTE:34 [ ultoa::started#2 ultoa::started#4 ] : zp ZP_BYTE:34 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ] : zp ZP_WORD:35 , 
Potential registers zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] : zp ZP_DWORD:37 , 
Potential registers zp ZP_BYTE:41 [ ultoa_append::digit#2 ultoa_append::digit#1 ] : zp ZP_BYTE:41 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] : zp ZP_WORD:42 , 
Potential registers zp ZP_WORD:44 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ] : zp ZP_WORD:44 , 
Potential registers zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] : zp ZP_WORD:46 , 
Potential registers zp ZP_BYTE:48 [ divr16u::i#2 divr16u::i#1 ] : zp ZP_BYTE:48 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:49 [ memset::num#2 ] : zp ZP_WORD:49 , 
Potential registers zp ZP_WORD:51 [ memset::str#3 ] : zp ZP_WORD:51 , 
Potential registers zp ZP_BYTE:53 [ memset::c#4 ] : zp ZP_BYTE:53 , reg byte x , 
Potential registers zp ZP_WORD:54 [ memset::dst#2 memset::dst#4 memset::dst#1 ] : zp ZP_WORD:54 , 
Potential registers zp ZP_DWORD:56 [ clock::return#2 ] : zp ZP_DWORD:56 , 
Potential registers zp ZP_DWORD:60 [ main::$10 ] : zp ZP_DWORD:60 , 
Potential registers zp ZP_DWORD:64 [ main::cyclecount#0 ] : zp ZP_DWORD:64 , 
Potential registers zp ZP_DWORD:68 [ div32u16u::dividend#0 ] : zp ZP_DWORD:68 , 
Potential registers zp ZP_DWORD:72 [ div32u16u::return#2 ] : zp ZP_DWORD:72 , 
Potential registers zp ZP_DWORD:76 [ main::$14 ] : zp ZP_DWORD:76 , 
Potential registers zp ZP_WORD:80 [ main::sec100s#0 ] : zp ZP_WORD:80 , 
Potential registers zp ZP_DWORD:82 [ print_dword_decimal::w#0 ] : zp ZP_DWORD:82 , 
Potential registers zp ZP_WORD:86 [ main::$39 ] : zp ZP_WORD:86 , 
Potential registers zp ZP_BYTE:88 [ utoa::$4 ] : zp ZP_BYTE:88 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:89 [ utoa::buffer#3 ] : zp ZP_WORD:89 , 
Potential registers zp ZP_BYTE:91 [ utoa::$11 ] : zp ZP_BYTE:91 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:92 [ utoa::digit_value#0 ] : zp ZP_WORD:92 , 
Potential registers zp ZP_WORD:94 [ utoa_append::buffer#0 ] : zp ZP_WORD:94 , 
Potential registers zp ZP_WORD:96 [ utoa_append::sub#0 ] : zp ZP_WORD:96 , 
Potential registers zp ZP_WORD:98 [ utoa_append::return#0 ] : zp ZP_WORD:98 , 
Potential registers zp ZP_BYTE:100 [ ultoa::$4 ] : zp ZP_BYTE:100 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:101 [ ultoa::buffer#3 ] : zp ZP_WORD:101 , 
Potential registers zp ZP_BYTE:103 [ ultoa::$11 ] : zp ZP_BYTE:103 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_DWORD:104 [ ultoa::digit_value#0 ] : zp ZP_DWORD:104 , 
Potential registers zp ZP_WORD:108 [ ultoa_append::buffer#0 ] : zp ZP_WORD:108 , 
Potential registers zp ZP_DWORD:110 [ ultoa_append::sub#0 ] : zp ZP_DWORD:110 , 
Potential registers zp ZP_DWORD:114 [ ultoa_append::return#0 ] : zp ZP_DWORD:114 , 
Potential registers zp ZP_WORD:118 [ divr16u::return#2 ] : zp ZP_WORD:118 , 
Potential registers zp ZP_WORD:120 [ div32u16u::quotient_hi#0 ] : zp ZP_WORD:120 , 
Potential registers zp ZP_WORD:122 [ divr16u::return#3 ] : zp ZP_WORD:122 , 
Potential registers zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ] : zp ZP_WORD:124 , 
Potential registers zp ZP_DWORD:126 [ div32u16u::return#0 ] : zp ZP_DWORD:126 , 
Potential registers zp ZP_BYTE:130 [ divr16u::$1 ] : zp ZP_BYTE:130 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:131 [ divr16u::$2 ] : zp ZP_BYTE:131 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:132 [ rem16u#1 ] : zp ZP_WORD:132 , 
Potential registers zp ZP_DWORD:134 [ clock::return#0 ] : zp ZP_DWORD:134 , 
Potential registers zp ZP_WORD:138 [ memset::end#0 ] : zp ZP_WORD:138 , 

REGISTER UPLIFT SCOPES
Uplift Scope [utoa_append] 2,554: zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] 2,003: zp ZP_BYTE:26 [ utoa_append::digit#2 utoa_append::digit#1 ] 350.5: zp ZP_WORD:96 [ utoa_append::sub#0 ] 202: zp ZP_WORD:98 [ utoa_append::return#0 ] 12.88: zp ZP_WORD:94 [ utoa_append::buffer#0 ] 
Uplift Scope [utoa] 382.64: zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 ] 312.5: zp ZP_WORD:19 [ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 ] 230.86: zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ] 202: zp ZP_BYTE:91 [ utoa::$11 ] 151.5: zp ZP_BYTE:21 [ utoa::started#2 utoa::started#4 ] 60.6: zp ZP_WORD:92 [ utoa::digit_value#0 ] 4: zp ZP_BYTE:88 [ utoa::$4 ] 4: zp ZP_WORD:89 [ utoa::buffer#3 ] 
Uplift Scope [main] 297: zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ] 227.67: zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ] 35.6: zp ZP_WORD:2 [ main::i#12 main::i#2 ] 27.5: zp ZP_WORD:6 [ main::i#10 main::i#3 ] 25: zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ] 22: zp ZP_WORD:86 [ main::$39 ] 4: zp ZP_DWORD:60 [ main::$10 ] 2: zp ZP_DWORD:76 [ main::$14 ] 1.33: zp ZP_WORD:80 [ main::sec100s#0 ] 0.5: zp ZP_DWORD:64 [ main::cyclecount#0 ] 
Uplift Scope [ultoa_append] 259: zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] 203: zp ZP_BYTE:41 [ ultoa_append::digit#2 ultoa_append::digit#1 ] 35.5: zp ZP_DWORD:110 [ ultoa_append::sub#0 ] 22: zp ZP_DWORD:114 [ ultoa_append::return#0 ] 1.62: zp ZP_WORD:108 [ ultoa_append::buffer#0 ] 
Uplift Scope [print_str] 305.5: zp ZP_WORD:16 [ print_str::str#8 print_str::str#10 print_str::str#0 ] 
Uplift Scope [divr16u] 106.92: zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] 35.54: zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] 22: zp ZP_BYTE:130 [ divr16u::$1 ] 22: zp ZP_BYTE:131 [ divr16u::$2 ] 19.75: zp ZP_WORD:44 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ] 18.19: zp ZP_BYTE:48 [ divr16u::i#2 divr16u::i#1 ] 4: zp ZP_WORD:118 [ divr16u::return#2 ] 4: zp ZP_WORD:122 [ divr16u::return#3 ] 
Uplift Scope [] 163.5: zp ZP_WORD:14 [ print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 ] 59.17: zp ZP_WORD:27 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#78 print_line_cursor#1 print_char_cursor#10 ] 0.67: zp ZP_WORD:132 [ rem16u#1 ] 
Uplift Scope [ultoa] 41.93: zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ] 36.07: zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ] 25.14: zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ] 22: zp ZP_BYTE:103 [ ultoa::$11 ] 16.5: zp ZP_BYTE:34 [ ultoa::started#2 ultoa::started#4 ] 6.6: zp ZP_DWORD:104 [ ultoa::digit_value#0 ] 4: zp ZP_BYTE:100 [ ultoa::$4 ] 4: zp ZP_WORD:101 [ ultoa::buffer#3 ] 
Uplift Scope [memset] 41.33: zp ZP_WORD:54 [ memset::dst#2 memset::dst#4 memset::dst#1 ] 2.17: zp ZP_WORD:138 [ memset::end#0 ] 2: zp ZP_WORD:49 [ memset::num#2 ] 1.38: zp ZP_BYTE:53 [ memset::c#4 ] 0: zp ZP_WORD:51 [ memset::str#3 ] 
Uplift Scope [print_word_decimal] 30: zp ZP_WORD:12 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] 
Uplift Scope [div32u16u] 4: zp ZP_DWORD:72 [ div32u16u::return#2 ] 4: zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ] 1.33: zp ZP_DWORD:126 [ div32u16u::return#0 ] 1.2: zp ZP_DWORD:68 [ div32u16u::dividend#0 ] 0.67: zp ZP_WORD:120 [ div32u16u::quotient_hi#0 ] 
Uplift Scope [clock] 4: zp ZP_DWORD:56 [ clock::return#2 ] 1.33: zp ZP_DWORD:134 [ clock::return#0 ] 
Uplift Scope [print_dword_decimal] 4: zp ZP_DWORD:82 [ print_dword_decimal::w#0 ] 
Uplift Scope [clock_start] 
Uplift Scope [RADIX] 
Uplift Scope [print_ln] 
Uplift Scope [print_char] 
Uplift Scope [print_cls] 

Uplifting [utoa_append] best 103419 combination zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] reg byte x [ utoa_append::digit#2 utoa_append::digit#1 ] zp ZP_WORD:96 [ utoa_append::sub#0 ] zp ZP_WORD:98 [ utoa_append::return#0 ] zp ZP_WORD:94 [ utoa_append::buffer#0 ] 
Uplifting [utoa] best 102115 combination zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 ] zp ZP_WORD:19 [ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 ] zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ] reg byte a [ utoa::$11 ] reg byte x [ utoa::started#2 utoa::started#4 ] zp ZP_WORD:92 [ utoa::digit_value#0 ] reg byte a [ utoa::$4 ] zp ZP_WORD:89 [ utoa::buffer#3 ] 
Uplifting [main] best 102115 combination zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ] zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ] zp ZP_WORD:2 [ main::i#12 main::i#2 ] zp ZP_WORD:6 [ main::i#10 main::i#3 ] zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ] zp ZP_WORD:86 [ main::$39 ] zp ZP_DWORD:60 [ main::$10 ] zp ZP_DWORD:76 [ main::$14 ] zp ZP_WORD:80 [ main::sec100s#0 ] zp ZP_DWORD:64 [ main::cyclecount#0 ] 
Uplifting [ultoa_append] best 101512 combination zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] reg byte x [ ultoa_append::digit#2 ultoa_append::digit#1 ] zp ZP_DWORD:110 [ ultoa_append::sub#0 ] zp ZP_DWORD:114 [ ultoa_append::return#0 ] zp ZP_WORD:108 [ ultoa_append::buffer#0 ] 
Uplifting [print_str] best 101512 combination zp ZP_WORD:16 [ print_str::str#8 print_str::str#10 print_str::str#0 ] 
Uplifting [divr16u] best 101302 combination zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] reg byte a [ divr16u::$1 ] reg byte a [ divr16u::$2 ] zp ZP_WORD:44 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ] reg byte x [ divr16u::i#2 divr16u::i#1 ] zp ZP_WORD:118 [ divr16u::return#2 ] zp ZP_WORD:122 [ divr16u::return#3 ] 
Uplifting [] best 101302 combination zp ZP_WORD:14 [ print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 ] zp ZP_WORD:27 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#78 print_line_cursor#1 print_char_cursor#10 ] zp ZP_WORD:132 [ rem16u#1 ] 
Uplifting [ultoa] best 101168 combination zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ] zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ] zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ] reg byte a [ ultoa::$11 ] reg byte x [ ultoa::started#2 ultoa::started#4 ] zp ZP_DWORD:104 [ ultoa::digit_value#0 ] reg byte a [ ultoa::$4 ] zp ZP_WORD:101 [ ultoa::buffer#3 ] 
Uplifting [memset] best 101152 combination zp ZP_WORD:54 [ memset::dst#2 memset::dst#4 memset::dst#1 ] zp ZP_WORD:138 [ memset::end#0 ] zp ZP_WORD:49 [ memset::num#2 ] reg byte x [ memset::c#4 ] zp ZP_WORD:51 [ memset::str#3 ] 
Uplifting [print_word_decimal] best 101152 combination zp ZP_WORD:12 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] 
Uplifting [div32u16u] best 101152 combination zp ZP_DWORD:72 [ div32u16u::return#2 ] zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ] zp ZP_DWORD:126 [ div32u16u::return#0 ] zp ZP_DWORD:68 [ div32u16u::dividend#0 ] zp ZP_WORD:120 [ div32u16u::quotient_hi#0 ] 
Uplifting [clock] best 101152 combination zp ZP_DWORD:56 [ clock::return#2 ] zp ZP_DWORD:134 [ clock::return#0 ] 
Uplifting [print_dword_decimal] best 101152 combination zp ZP_DWORD:82 [ print_dword_decimal::w#0 ] 
Uplifting [clock_start] best 101152 combination 
Uplifting [RADIX] best 101152 combination 
Uplifting [print_ln] best 101152 combination 
Uplifting [print_char] best 101152 combination 
Uplifting [print_cls] best 101152 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ]
Uplifting [utoa] best 101152 combination zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ]
Uplifting [ultoa] best 101152 combination zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ] 
Coalescing zero page register [ zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] ] with [ zp ZP_WORD:132 [ rem16u#1 ] ] - score: 2
Coalescing zero page register [ zp ZP_WORD:6 [ main::i#10 main::i#3 ] ] with [ zp ZP_WORD:12 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:19 [ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 ] ] with [ zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:19 [ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] ] with [ zp ZP_WORD:98 [ utoa_append::return#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 ] ] with [ zp ZP_WORD:89 [ utoa::buffer#3 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 utoa::buffer#3 ] ] with [ zp ZP_WORD:94 [ utoa_append::buffer#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ] ] with [ zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] ] with [ zp ZP_DWORD:82 [ print_dword_decimal::w#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ] ] with [ zp ZP_DWORD:114 [ ultoa_append::return#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ] ] with [ zp ZP_WORD:101 [ ultoa::buffer#3 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ultoa::buffer#3 ] ] with [ zp ZP_WORD:108 [ ultoa_append::buffer#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] ] with [ zp ZP_WORD:118 [ divr16u::return#2 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 ] ] with [ zp ZP_WORD:122 [ divr16u::return#3 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:49 [ memset::num#2 ] ] with [ zp ZP_WORD:138 [ memset::end#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:51 [ memset::str#3 ] ] with [ zp ZP_WORD:54 [ memset::dst#2 memset::dst#4 memset::dst#1 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:56 [ clock::return#2 ] ] with [ zp ZP_DWORD:60 [ main::$10 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:56 [ clock::return#2 main::$10 ] ] with [ zp ZP_DWORD:134 [ clock::return#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:64 [ main::cyclecount#0 ] ] with [ zp ZP_DWORD:68 [ div32u16u::dividend#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:72 [ div32u16u::return#2 ] ] with [ zp ZP_DWORD:76 [ main::$14 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:72 [ div32u16u::return#2 main::$14 ] ] with [ zp ZP_DWORD:126 [ div32u16u::return#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:92 [ utoa::digit_value#0 ] ] with [ zp ZP_WORD:96 [ utoa_append::sub#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:104 [ ultoa::digit_value#0 ] ] with [ zp ZP_DWORD:110 [ ultoa_append::sub#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:6 [ main::i#10 main::i#3 print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] ] with [ zp ZP_WORD:80 [ main::sec100s#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ultoa_append::return#0 ] ] with [ zp ZP_DWORD:64 [ main::cyclecount#0 div32u16u::dividend#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 divr16u::return#3 ] ] with [ zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ultoa_append::return#0 main::cyclecount#0 div32u16u::dividend#0 ] ] with [ zp ZP_DWORD:56 [ clock::return#2 main::$10 clock::return#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:14 [ print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 ] ] with [ zp ZP_WORD:2 [ main::i#12 main::i#2 ] ]
Coalescing zero page register [ zp ZP_WORD:16 [ print_str::str#8 print_str::str#10 print_str::str#0 ] ] with [ zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ] ]
Coalescing zero page register [ zp ZP_WORD:19 [ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 utoa_append::return#0 ] ] with [ zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ] ]
Coalescing zero page register [ zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 utoa::buffer#3 utoa_append::buffer#0 ] ] with [ zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ] ]
Coalescing zero page register [ zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ] ] with [ zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ] ]
Coalescing zero page register [ zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ultoa::buffer#3 ultoa_append::buffer#0 ] ] with [ zp ZP_WORD:6 [ main::i#10 main::i#3 print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 main::sec100s#0 ] ]
Coalescing zero page register [ zp ZP_WORD:49 [ memset::num#2 memset::end#0 ] ] with [ zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 rem16u#1 ] ]
Coalescing zero page register [ zp ZP_WORD:51 [ memset::str#3 memset::dst#2 memset::dst#4 memset::dst#1 ] ] with [ zp ZP_WORD:44 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ] ]
Coalescing zero page register [ zp ZP_WORD:86 [ main::$39 ] ] with [ zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 divr16u::return#3 div32u16u::quotient_lo#0 ] ]
Coalescing zero page register [ zp ZP_DWORD:104 [ ultoa::digit_value#0 ultoa_append::sub#0 ] ] with [ zp ZP_DWORD:72 [ div32u16u::return#2 main::$14 div32u16u::return#0 ] ]
Coalescing zero page register [ zp ZP_WORD:120 [ div32u16u::quotient_hi#0 ] ] with [ zp ZP_WORD:92 [ utoa::digit_value#0 utoa_append::sub#0 ] ]
Coalescing zero page register [ zp ZP_WORD:49 [ memset::num#2 memset::end#0 divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 rem16u#1 ] ] with [ zp ZP_WORD:16 [ print_str::str#8 print_str::str#10 print_str::str#0 main::sieve_i#2 main::sieve_i#1 ] ]
Coalescing zero page register [ zp ZP_WORD:51 [ memset::str#3 memset::dst#2 memset::dst#4 memset::dst#1 divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ] ] with [ zp ZP_WORD:14 [ print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 main::i#12 main::i#2 ] ]
Allocated (was zp ZP_WORD:19) zp ZP_WORD:2 [ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 utoa_append::return#0 main::j#2 main::j#0 main::j#1 ]
Allocated (was zp ZP_WORD:22) zp ZP_WORD:4 [ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 utoa::buffer#3 utoa_append::buffer#0 main::s#2 main::s#0 main::s#1 ]
Allocated (was zp ZP_WORD:27) zp ZP_WORD:6 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#78 print_line_cursor#1 print_char_cursor#10 ]
Allocated (was zp ZP_BYTE:29) zp ZP_BYTE:8 [ ultoa::digit#2 ultoa::digit#1 utoa::digit#2 utoa::digit#1 ]
Allocated (was zp ZP_DWORD:30) zp ZP_DWORD:9 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ultoa_append::return#0 main::cyclecount#0 div32u16u::dividend#0 clock::return#2 main::$10 clock::return#0 ]
Allocated (was zp ZP_WORD:35) zp ZP_WORD:13 [ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ultoa::buffer#3 ultoa_append::buffer#0 main::i#10 main::i#3 print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 main::sec100s#0 ]
Allocated (was zp ZP_WORD:49) zp ZP_WORD:15 [ memset::num#2 memset::end#0 divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 rem16u#1 print_str::str#8 print_str::str#10 print_str::str#0 main::sieve_i#2 main::sieve_i#1 ]
Allocated (was zp ZP_WORD:51) zp ZP_WORD:17 [ memset::str#3 memset::dst#2 memset::dst#4 memset::dst#1 divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 main::i#12 main::i#2 ]
Allocated (was zp ZP_WORD:86) zp ZP_WORD:19 [ main::$39 divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 divr16u::return#3 div32u16u::quotient_lo#0 ]
Allocated (was zp ZP_DWORD:104) zp ZP_DWORD:21 [ ultoa::digit_value#0 ultoa_append::sub#0 div32u16u::return#2 main::$14 div32u16u::return#0 ]
Allocated (was zp ZP_WORD:120) zp ZP_WORD:25 [ div32u16u::quotient_hi#0 utoa::digit_value#0 utoa_append::sub#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label D018 = $d018
  // CIA #2 Timer A+B Value (32-bit)
  .label CIA2_TIMER_AB = $dd04
  // CIA #2 Timer A Control Register
  .label CIA2_TIMER_A_CONTROL = $dd0e
  // CIA #2 Timer B Control Register
  .label CIA2_TIMER_B_CONTROL = $dd0f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer Control - Time CONTINUOUS/ONE-SHOT (0:CONTINUOUS, 1: ONE-SHOT)
  .const CIA_TIMER_CONTROL_CONTINUOUS = 0
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  // Clock cycles per frame (on a C64 PAL)
  .const CLOCKS_PER_FRAME = $4cc8
  // Frames per second (on a C64 PAL)
  .const FRAMES_PER_SEC = $3c
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .label SCREEN = $400
  .const COUNT = $4000
  /* Up to what number? */
  .const SQRT_COUNT = $80
  /* Sqrt of COUNT */
  .label sieve = $1000
  // Clock cycles per second (on a C64 PAL)
  .const CLOCKS_PER_SEC = CLOCKS_PER_FRAME*FRAMES_PER_SEC
  .label rem16u = $f
  .label print_char_cursor = $11
  .label print_line_cursor = 6
  .label print_char_cursor_10 = 6
  .label print_char_cursor_62 = 6
  .label print_char_cursor_78 = 6
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label toD0181_gfx = $1800
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>toD0181_gfx)/4&$f
    .label _10 = 9
    .label _14 = $15
    .label cyclecount = 9
    .label sec100s = $d
    .label i = $11
    .label sieve_i = $f
    .label j = 2
    .label s = 4
    .label i_3 = $d
    .label i_10 = $d
    .label _39 = $13
    // [5] phi from main to main::toD0181 [phi:main->main::toD0181]
  toD0181_from_main:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp b14
    // main::@14
  b14:
    // [6] *((const byte*) D018) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    //Show lower case font
    lda #toD0181_return
    sta D018
    // [7] call print_cls 
    // [196] phi from main::@14 to print_cls [phi:main::@14->print_cls]
  print_cls_from_b14:
    jsr print_cls
    // [8] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  b15_from_b14:
    jmp b15
    // main::@15
  b15:
    // [9] call print_str 
    // [77] phi from main::@15 to print_str [phi:main::@15->print_str]
  print_str_from_b15:
    // [77] phi (byte*) print_char_cursor#66 = (byte*) 1024 [phi:main::@15->print_str#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z print_char_cursor
    lda #>$400
    sta.z print_char_cursor+1
    // [77] phi (byte*) print_str::str#10 = (const string) main::str [phi:main::@15->print_str#1] -- pbuz1=pbuc1 
    lda #<str
    sta.z print_str.str
    lda #>str
    sta.z print_str.str+1
    jsr print_str
    // [10] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
  b16_from_b15:
    jmp b16
    // main::@16
  b16:
    // [11] call print_ln 
    // [112] phi from main::@16 to print_ln [phi:main::@16->print_ln]
  print_ln_from_b16:
    // [112] phi (byte*) print_line_cursor#21 = (byte*) 1024 [phi:main::@16->print_ln#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z print_line_cursor
    lda #>$400
    sta.z print_line_cursor+1
    jsr print_ln
    jmp b17
    // main::@17
  b17:
    // [12] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda.z print_line_cursor
    sta.z print_char_cursor
    lda.z print_line_cursor+1
    sta.z print_char_cursor+1
    // [13] call print_str 
    // [77] phi from main::@17 to print_str [phi:main::@17->print_str]
  print_str_from_b17:
    // [77] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#90 [phi:main::@17->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str1 [phi:main::@17->print_str#1] -- pbuz1=pbuc1 
    lda #<str1
    sta.z print_str.str
    lda #>str1
    sta.z print_str.str+1
    jsr print_str
    // [14] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  b18_from_b17:
    jmp b18
    // main::@18
  b18:
    // [15] call print_word_decimal 
    // [71] phi from main::@18 to print_word_decimal [phi:main::@18->print_word_decimal]
  print_word_decimal_from_b18:
    // [71] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@18->print_word_decimal#0] -- register_copy 
    // [71] phi (word) print_word_decimal::w#3 = (const word) COUNT [phi:main::@18->print_word_decimal#1] -- vwuz1=vwuc1 
    lda #<COUNT
    sta.z print_word_decimal.w
    lda #>COUNT
    sta.z print_word_decimal.w+1
    jsr print_word_decimal
    // [16] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  b19_from_b18:
    jmp b19
    // main::@19
  b19:
    // [17] call print_ln 
    // [112] phi from main::@19 to print_ln [phi:main::@19->print_ln]
  print_ln_from_b19:
    // [112] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@19->print_ln#0] -- register_copy 
    jsr print_ln
    // [18] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  b20_from_b19:
    jmp b20
    // main::@20
  b20:
    // [19] call memset 
    // [187] phi from main::@20 to memset [phi:main::@20->memset]
  memset_from_b20:
    // [187] phi (byte) memset::c#4 = (byte) 0 [phi:main::@20->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [187] phi (void*) memset::str#3 = (void*)(const byte*) sieve#0 [phi:main::@20->memset#1] -- pvoz1=pvoc1 
    lda #<sieve
    sta.z memset.str
    lda #>sieve
    sta.z memset.str+1
    // [187] phi (word) memset::num#2 = (const word) COUNT [phi:main::@20->memset#2] -- vwuz1=vwuc1 
    lda #<COUNT
    sta.z memset.num
    lda #>COUNT
    sta.z memset.num+1
    jsr memset
    // [20] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
  b21_from_b20:
    jmp b21
    // main::@21
  b21:
    // [21] call clock_start 
    jsr clock_start
    // [22] phi from main::@21 to main::@1 [phi:main::@21->main::@1]
  b1_from_b21:
    // [22] phi (byte*) main::sieve_i#2 = (const byte*) sieve#0+(byte) 2 [phi:main::@21->main::@1#0] -- pbuz1=pbuc1 
    lda #<sieve+2
    sta.z sieve_i
    lda #>sieve+2
    sta.z sieve_i+1
    // [22] phi (word) main::i#12 = (byte) 2 [phi:main::@21->main::@1#1] -- vwuz1=vbuc1 
    lda #<2
    sta.z i
    lda #>2
    sta.z i+1
    jmp b1
    // main::@1
  b1:
    // [23] if((word) main::i#12<(const byte) SQRT_COUNT) goto main::@2 -- vwuz1_lt_vbuc1_then_la1 
    lda.z i+1
    cmp #>SQRT_COUNT
    bcc b2
    bne !+
    lda.z i
    cmp #<SQRT_COUNT
    bcc b2
  !:
    // [24] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  b3_from_b1:
    jmp b3
    // main::@3
  b3:
    // [25] call clock 
    jsr clock
    // [26] (dword) clock::return#2 ← (dword) clock::return#0
    jmp b22
    // main::@22
  b22:
    // [27] (dword~) main::$10 ← (dword) clock::return#2
    // [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT -- vduz1=vduz1_minus_vduc1 
    lda.z cyclecount
    sec
    sbc #<CLOCKS_PER_INIT
    sta.z cyclecount
    lda.z cyclecount+1
    sbc #>CLOCKS_PER_INIT
    sta.z cyclecount+1
    lda.z cyclecount+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta.z cyclecount+2
    lda.z cyclecount+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta.z cyclecount+3
    // [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0
    // [30] call div32u16u 
    jsr div32u16u
    // [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0
    jmp b23
    // main::@23
  b23:
    // [32] (dword~) main::$14 ← (dword) div32u16u::return#2
    // [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 -- vwuz1=_word_vduz2 
    lda.z _14
    sta.z sec100s
    lda.z _14+1
    sta.z sec100s+1
    // [34] (byte*~) print_char_cursor#91 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda.z print_line_cursor
    sta.z print_char_cursor
    lda.z print_line_cursor+1
    sta.z print_char_cursor+1
    // [35] call print_str 
    // [77] phi from main::@23 to print_str [phi:main::@23->print_str]
  print_str_from_b23:
    // [77] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#91 [phi:main::@23->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str2 [phi:main::@23->print_str#1] -- pbuz1=pbuc1 
    lda #<str2
    sta.z print_str.str
    lda #>str2
    sta.z print_str.str+1
    jsr print_str
    jmp b24
    // main::@24
  b24:
    // [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0
    // [37] call print_word_decimal 
    // [71] phi from main::@24 to print_word_decimal [phi:main::@24->print_word_decimal]
  print_word_decimal_from_b24:
    // [71] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@24->print_word_decimal#0] -- register_copy 
    // [71] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#1 [phi:main::@24->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [38] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
  b25_from_b24:
    jmp b25
    // main::@25
  b25:
    // [39] call print_str 
    // [77] phi from main::@25 to print_str [phi:main::@25->print_str]
  print_str_from_b25:
    // [77] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:main::@25->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str3 [phi:main::@25->print_str#1] -- pbuz1=pbuc1 
    lda #<str3
    sta.z print_str.str
    lda #>str3
    sta.z print_str.str+1
    jsr print_str
    jmp b26
    // main::@26
  b26:
    // [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0
    // [41] call print_dword_decimal 
    jsr print_dword_decimal
    // [42] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
  b27_from_b26:
    jmp b27
    // main::@27
  b27:
    // [43] call print_ln 
    // [112] phi from main::@27 to print_ln [phi:main::@27->print_ln]
  print_ln_from_b27:
    // [112] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@27->print_ln#0] -- register_copy 
    jsr print_ln
    // [44] phi from main::@27 to main::@8 [phi:main::@27->main::@8]
  b8_from_b27:
    // [44] phi (byte*) print_char_cursor#62 = (byte*) print_line_cursor#1 [phi:main::@27->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (byte) 2 [phi:main::@27->main::@8#1] -- vwuz1=vbuc1 
    lda #<2
    sta.z i_10
    lda #>2
    sta.z i_10+1
    jmp b8
    // main::@8
  b8:
    // [45] if((word) main::i#10<(word) $514) goto main::@9 -- vwuz1_lt_vwuc1_then_la1 
    lda.z i_10+1
    cmp #>$514
    bcc b9
    bne !+
    lda.z i_10
    cmp #<$514
    bcc b9
  !:
    jmp b10
    // main::@10
  b10:
    // [46] (byte*~) print_char_cursor#89 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda.z print_char_cursor_62
    sta.z print_char_cursor
    lda.z print_char_cursor_62+1
    sta.z print_char_cursor+1
    // [47] call print_str 
    // [77] phi from main::@10 to print_str [phi:main::@10->print_str]
  print_str_from_b10:
    // [77] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#89 [phi:main::@10->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str4 [phi:main::@10->print_str#1] -- pbuz1=pbuc1 
    lda #<str4
    sta.z print_str.str
    lda #>str4
    sta.z print_str.str+1
    jsr print_str
    jmp b13
    // main::@13
  b13:
    // [48] *((const byte*) SCREEN+(word) $3e7) ← ++ *((const byte*) SCREEN+(word) $3e7) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN+$3e7
    jmp b13
    // main::@9
  b9:
    // [49] (byte*~) main::$39 ← (const byte*) sieve#0 + (word) main::i#10 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z i_10
    clc
    adc #<sieve
    sta.z _39
    lda.z i_10+1
    adc #>sieve
    sta.z _39+1
    // [50] if((byte) 0!=*((byte*~) main::$39)) goto main::@11 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (_39),y
    cmp #0
    bne b11_from_b9
    jmp b12
    // main::@12
  b12:
    // [51] (word) print_word_decimal::w#2 ← (word) main::i#10
    // [52] (byte*~) print_char_cursor#97 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda.z print_char_cursor_62
    sta.z print_char_cursor
    lda.z print_char_cursor_62+1
    sta.z print_char_cursor+1
    // [53] call print_word_decimal 
    // [71] phi from main::@12 to print_word_decimal [phi:main::@12->print_word_decimal]
  print_word_decimal_from_b12:
    // [71] phi (byte*) print_char_cursor#58 = (byte*~) print_char_cursor#97 [phi:main::@12->print_word_decimal#0] -- register_copy 
    // [71] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#2 [phi:main::@12->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [54] phi from main::@12 to main::@28 [phi:main::@12->main::@28]
  b28_from_b12:
    jmp b28
    // main::@28
  b28:
    // [55] call print_char 
    jsr print_char
    // [56] phi from main::@28 main::@9 to main::@11 [phi:main::@28/main::@9->main::@11]
  b11_from_b28:
  b11_from_b9:
    // [56] phi (byte*) print_char_cursor#78 = (byte*) print_char_cursor#10 [phi:main::@28/main::@9->main::@11#0] -- register_copy 
    jmp b11
    // main::@11
  b11:
    // [57] (word) main::i#3 ← ++ (word) main::i#10 -- vwuz1=_inc_vwuz1 
    inc.z i_3
    bne !+
    inc.z i_3+1
  !:
    // [44] phi from main::@11 to main::@8 [phi:main::@11->main::@8]
  b8_from_b11:
    // [44] phi (byte*) print_char_cursor#62 = (byte*) print_char_cursor#78 [phi:main::@11->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (word) main::i#3 [phi:main::@11->main::@8#1] -- register_copy 
    jmp b8
    // main::@2
  b2:
    // [58] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (sieve_i),y
    cmp #0
    bne b4
    jmp b7
    // main::@7
  b7:
    // [59] (word) main::j#0 ← (word) main::i#12 << (byte) 1 -- vwuz1=vwuz2_rol_1 
    lda.z i
    asl
    sta.z j
    lda.z i+1
    rol
    sta.z j+1
    // [60] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z j
    clc
    adc #<sieve
    sta.z s
    lda.z j+1
    adc #>sieve
    sta.z s+1
    // [61] phi from main::@6 main::@7 to main::@5 [phi:main::@6/main::@7->main::@5]
  b5_from_b6:
  b5_from_b7:
    // [61] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@6/main::@7->main::@5#0] -- register_copy 
    // [61] phi (word) main::j#2 = (word) main::j#1 [phi:main::@6/main::@7->main::@5#1] -- register_copy 
    jmp b5
    // main::@5
  b5:
    // [62] if((word) main::j#2<(const word) COUNT) goto main::@6 -- vwuz1_lt_vwuc1_then_la1 
    lda.z j+1
    cmp #>COUNT
    bcc b6
    bne !+
    lda.z j
    cmp #<COUNT
    bcc b6
  !:
    jmp b4
    // main::@4
  b4:
    // [63] (word) main::i#2 ← ++ (word) main::i#12 -- vwuz1=_inc_vwuz1 
    inc.z i
    bne !+
    inc.z i+1
  !:
    // [64] (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#2 -- pbuz1=_inc_pbuz1 
    inc.z sieve_i
    bne !+
    inc.z sieve_i+1
  !:
    // [22] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  b1_from_b4:
    // [22] phi (byte*) main::sieve_i#2 = (byte*) main::sieve_i#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [22] phi (word) main::i#12 = (word) main::i#2 [phi:main::@4->main::@1#1] -- register_copy 
    jmp b1
    // main::@6
  b6:
    // [65] *((byte*) main::s#2) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (s),y
    // [66] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#12 -- pbuz1=pbuz1_plus_vwuz2 
    lda.z s
    clc
    adc.z i
    sta.z s
    lda.z s+1
    adc.z i+1
    sta.z s+1
    // [67] (word) main::j#1 ← (word) main::j#2 + (word) main::i#12 -- vwuz1=vwuz1_plus_vwuz2 
    lda.z j
    clc
    adc.z i
    sta.z j
    lda.z j+1
    adc.z i+1
    sta.z j+1
    jmp b5_from_b6
    str: .text "Sieve benchmark - calculating primes"
    .byte 0
    str1: .text "between 2 and "
    .byte 0
    str2: .text "100ths seconds used: "
    .byte 0
    str3: .text " cycles: "
    .byte 0
    str4: .text "..."
    .byte 0
}
  // print_char
// Print a single char
print_char: {
    .const ch = ' '
    // [68] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 -- _deref_pbuz1=vbuc1 
    lda #ch
    ldy #0
    sta (print_char_cursor),y
    // [69] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz2 
    lda.z print_char_cursor
    clc
    adc #1
    sta.z print_char_cursor_10
    lda.z print_char_cursor+1
    adc #0
    sta.z print_char_cursor_10+1
    jmp breturn
    // print_char::@return
  breturn:
    // [70] return 
    rts
}
  // print_word_decimal
// Print a word as DECIMAL
// print_word_decimal(word zeropage($d) w)
print_word_decimal: {
    .label w = $d
    // [72] (word) utoa::value#1 ← (word) print_word_decimal::w#3 -- vwuz1=vwuz2 
    lda.z w
    sta.z utoa.value
    lda.z w+1
    sta.z utoa.value+1
    // [73] call utoa 
    // [84] phi from print_word_decimal to utoa [phi:print_word_decimal->utoa]
  utoa_from_print_word_decimal:
    jsr utoa
    // [74] phi from print_word_decimal to print_word_decimal::@1 [phi:print_word_decimal->print_word_decimal::@1]
  b1_from_print_word_decimal:
    jmp b1
    // print_word_decimal::@1
  b1:
    // [75] call print_str 
    // [77] phi from print_word_decimal::@1 to print_str [phi:print_word_decimal::@1->print_str]
  print_str_from_b1:
    // [77] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#58 [phi:print_word_decimal::@1->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const byte[6]) decimal_digits [phi:print_word_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta.z print_str.str
    lda #>decimal_digits
    sta.z print_str.str+1
    jsr print_str
    jmp breturn
    // print_word_decimal::@return
  breturn:
    // [76] return 
    rts
}
  // print_str
// Print a zero-terminated string
// print_str(byte* zeropage($f) str)
print_str: {
    .label str = $f
    // [78] phi from print_str print_str::@2 to print_str::@1 [phi:print_str/print_str::@2->print_str::@1]
  b1_from_print_str:
  b1_from_b2:
    // [78] phi (byte*) print_char_cursor#2 = (byte*) print_char_cursor#66 [phi:print_str/print_str::@2->print_str::@1#0] -- register_copy 
    // [78] phi (byte*) print_str::str#8 = (byte*) print_str::str#10 [phi:print_str/print_str::@2->print_str::@1#1] -- register_copy 
    jmp b1
    // print_str::@1
  b1:
    // [79] if((byte) 0!=*((byte*) print_str::str#8)) goto print_str::@2 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (str),y
    cmp #0
    bne b2
    jmp breturn
    // print_str::@return
  breturn:
    // [80] return 
    rts
    // print_str::@2
  b2:
    // [81] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) -- _deref_pbuz1=_deref_pbuz2 
    ldy #0
    lda (str),y
    ldy #0
    sta (print_char_cursor),y
    // [82] (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz1 
    inc.z print_char_cursor
    bne !+
    inc.z print_char_cursor+1
  !:
    // [83] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#8 -- pbuz1=_inc_pbuz1 
    inc.z str
    bne !+
    inc.z str+1
  !:
    jmp b1_from_b2
}
  // utoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// utoa(word zeropage(2) value, byte* zeropage(4) buffer)
utoa: {
    .const max_digits = 5
    .label digit_value = $19
    .label buffer = 4
    .label digit = 8
    .label value = 2
    // [85] phi from utoa to utoa::@1 [phi:utoa->utoa::@1]
  b1_from_utoa:
    // [85] phi (byte*) utoa::buffer#11 = (const byte[6]) decimal_digits [phi:utoa->utoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta.z buffer
    lda #>decimal_digits
    sta.z buffer+1
    // [85] phi (byte) utoa::started#2 = (byte) 0 [phi:utoa->utoa::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [85] phi (word) utoa::value#2 = (word) utoa::value#1 [phi:utoa->utoa::@1#2] -- register_copy 
    // [85] phi (byte) utoa::digit#2 = (byte) 0 [phi:utoa->utoa::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    jmp b1
    // utoa::@1
  b1:
    // [86] if((byte) utoa::digit#2<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z digit
    cmp #max_digits-1
    bcc b2
    jmp b3
    // utoa::@3
  b3:
    // [87] (byte~) utoa::$4 ← (byte)(word) utoa::value#2 -- vbuaa=_byte_vwuz1 
    lda.z value
    // [88] *((byte*) utoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) utoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // [89] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer
    bne !+
    inc.z buffer+1
  !:
    // [90] *((byte*) utoa::buffer#3) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (buffer),y
    jmp breturn
    // utoa::@return
  breturn:
    // [91] return 
    rts
    // utoa::@2
  b2:
    // [92] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z digit
    asl
    // [93] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES + (byte~) utoa::$11) -- vwuz1=pwuc1_derefidx_vbuaa 
    tay
    lda RADIX_DECIMAL_VALUES,y
    sta.z digit_value
    lda RADIX_DECIMAL_VALUES+1,y
    sta.z digit_value+1
    // [94] if((byte) 0!=(byte) utoa::started#2) goto utoa::@5 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne b5
    jmp b7
    // utoa::@7
  b7:
    // [95] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@5 -- vwuz1_ge_vwuz2_then_la1 
    lda.z digit_value+1
    cmp.z value+1
    bne !+
    lda.z digit_value
    cmp.z value
    beq b5
  !:
    bcc b5
    // [96] phi from utoa::@7 to utoa::@4 [phi:utoa::@7->utoa::@4]
  b4_from_b7:
    // [96] phi (byte*) utoa::buffer#14 = (byte*) utoa::buffer#11 [phi:utoa::@7->utoa::@4#0] -- register_copy 
    // [96] phi (byte) utoa::started#4 = (byte) utoa::started#2 [phi:utoa::@7->utoa::@4#1] -- register_copy 
    // [96] phi (word) utoa::value#6 = (word) utoa::value#2 [phi:utoa::@7->utoa::@4#2] -- register_copy 
    jmp b4
    // utoa::@4
  b4:
    // [97] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc.z digit
    // [85] phi from utoa::@4 to utoa::@1 [phi:utoa::@4->utoa::@1]
  b1_from_b4:
    // [85] phi (byte*) utoa::buffer#11 = (byte*) utoa::buffer#14 [phi:utoa::@4->utoa::@1#0] -- register_copy 
    // [85] phi (byte) utoa::started#2 = (byte) utoa::started#4 [phi:utoa::@4->utoa::@1#1] -- register_copy 
    // [85] phi (word) utoa::value#2 = (word) utoa::value#6 [phi:utoa::@4->utoa::@1#2] -- register_copy 
    // [85] phi (byte) utoa::digit#2 = (byte) utoa::digit#1 [phi:utoa::@4->utoa::@1#3] -- register_copy 
    jmp b1
    // utoa::@5
  b5:
    // [98] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11
    // [99] (word) utoa_append::value#0 ← (word) utoa::value#2
    // [100] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0
    // [101] call utoa_append 
    // [105] phi from utoa::@5 to utoa_append [phi:utoa::@5->utoa_append]
  utoa_append_from_b5:
    jsr utoa_append
    // [102] (word) utoa_append::return#0 ← (word) utoa_append::value#2
    jmp b6
    // utoa::@6
  b6:
    // [103] (word) utoa::value#0 ← (word) utoa_append::return#0
    // [104] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer
    bne !+
    inc.z buffer+1
  !:
    // [96] phi from utoa::@6 to utoa::@4 [phi:utoa::@6->utoa::@4]
  b4_from_b6:
    // [96] phi (byte*) utoa::buffer#14 = (byte*) utoa::buffer#4 [phi:utoa::@6->utoa::@4#0] -- register_copy 
    // [96] phi (byte) utoa::started#4 = (byte) 1 [phi:utoa::@6->utoa::@4#1] -- vbuxx=vbuc1 
    ldx #1
    // [96] phi (word) utoa::value#6 = (word) utoa::value#0 [phi:utoa::@6->utoa::@4#2] -- register_copy 
    jmp b4
}
  // utoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// utoa_append(byte* zeropage(4) buffer, word zeropage(2) value, word zeropage($19) sub)
utoa_append: {
    .label buffer = 4
    .label value = 2
    .label sub = $19
    .label return = 2
    // [106] phi from utoa_append to utoa_append::@1 [phi:utoa_append->utoa_append::@1]
  b1_from_utoa_append:
    // [106] phi (byte) utoa_append::digit#2 = (byte) 0 [phi:utoa_append->utoa_append::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [106] phi (word) utoa_append::value#2 = (word) utoa_append::value#0 [phi:utoa_append->utoa_append::@1#1] -- register_copy 
    jmp b1
    // utoa_append::@1
  b1:
    // [107] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 -- vwuz1_ge_vwuz2_then_la1 
    lda.z sub+1
    cmp.z value+1
    bne !+
    lda.z sub
    cmp.z value
    beq b2
  !:
    bcc b2
    jmp b3
    // utoa_append::@3
  b3:
    // [108] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) utoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda DIGITS,x
    ldy #0
    sta (buffer),y
    jmp breturn
    // utoa_append::@return
  breturn:
    // [109] return 
    rts
    // utoa_append::@2
  b2:
    // [110] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2 -- vbuxx=_inc_vbuxx 
    inx
    // [111] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 -- vwuz1=vwuz1_minus_vwuz2 
    lda.z value
    sec
    sbc.z sub
    sta.z value
    lda.z value+1
    sbc.z sub+1
    sta.z value+1
    // [106] phi from utoa_append::@2 to utoa_append::@1 [phi:utoa_append::@2->utoa_append::@1]
  b1_from_b2:
    // [106] phi (byte) utoa_append::digit#2 = (byte) utoa_append::digit#1 [phi:utoa_append::@2->utoa_append::@1#0] -- register_copy 
    // [106] phi (word) utoa_append::value#2 = (word) utoa_append::value#1 [phi:utoa_append::@2->utoa_append::@1#1] -- register_copy 
    jmp b1
}
  // print_ln
// Print a newline
print_ln: {
    // [113] phi from print_ln print_ln::@1 to print_ln::@1 [phi:print_ln/print_ln::@1->print_ln::@1]
  b1_from_print_ln:
  b1_from_b1:
    // [113] phi (byte*) print_line_cursor#11 = (byte*) print_line_cursor#21 [phi:print_ln/print_ln::@1->print_ln::@1#0] -- register_copy 
    jmp b1
    // print_ln::@1
  b1:
    // [114] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z print_line_cursor
    sta.z print_line_cursor
    bcc !+
    inc.z print_line_cursor+1
  !:
    // [115] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 -- pbuz1_lt_pbuz2_then_la1 
    lda.z print_line_cursor+1
    cmp.z print_char_cursor+1
    bcc b1_from_b1
    bne !+
    lda.z print_line_cursor
    cmp.z print_char_cursor
    bcc b1_from_b1
  !:
    jmp breturn
    // print_ln::@return
  breturn:
    // [116] return 
    rts
}
  // print_dword_decimal
// Print a dword as DECIMAL
// print_dword_decimal(dword zeropage(9) w)
print_dword_decimal: {
    .label w = 9
    // [117] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0
    // [118] call ultoa 
    // [122] phi from print_dword_decimal to ultoa [phi:print_dword_decimal->ultoa]
  ultoa_from_print_dword_decimal:
    jsr ultoa
    // [119] phi from print_dword_decimal to print_dword_decimal::@1 [phi:print_dword_decimal->print_dword_decimal::@1]
  b1_from_print_dword_decimal:
    jmp b1
    // print_dword_decimal::@1
  b1:
    // [120] call print_str 
    // [77] phi from print_dword_decimal::@1 to print_str [phi:print_dword_decimal::@1->print_str]
  print_str_from_b1:
    // [77] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:print_dword_decimal::@1->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const byte[$b]) decimal_digits_long [phi:print_dword_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta.z print_str.str
    lda #>decimal_digits_long
    sta.z print_str.str+1
    jsr print_str
    jmp breturn
    // print_dword_decimal::@return
  breturn:
    // [121] return 
    rts
}
  // ultoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// ultoa(dword zeropage(9) value, byte* zeropage($d) buffer)
ultoa: {
    .const max_digits = $a
    .label digit_value = $15
    .label buffer = $d
    .label digit = 8
    .label value = 9
    // [123] phi from ultoa to ultoa::@1 [phi:ultoa->ultoa::@1]
  b1_from_ultoa:
    // [123] phi (byte*) ultoa::buffer#11 = (const byte[$b]) decimal_digits_long [phi:ultoa->ultoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta.z buffer
    lda #>decimal_digits_long
    sta.z buffer+1
    // [123] phi (byte) ultoa::started#2 = (byte) 0 [phi:ultoa->ultoa::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [123] phi (dword) ultoa::value#2 = (dword) ultoa::value#1 [phi:ultoa->ultoa::@1#2] -- register_copy 
    // [123] phi (byte) ultoa::digit#2 = (byte) 0 [phi:ultoa->ultoa::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    jmp b1
    // ultoa::@1
  b1:
    // [124] if((byte) ultoa::digit#2<(const byte) ultoa::max_digits#1-(byte) 1) goto ultoa::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z digit
    cmp #max_digits-1
    bcc b2
    jmp b3
    // ultoa::@3
  b3:
    // [125] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#2 -- vbuaa=_byte_vduz1 
    lda.z value
    // [126] *((byte*) ultoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) ultoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // [127] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer
    bne !+
    inc.z buffer+1
  !:
    // [128] *((byte*) ultoa::buffer#3) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (buffer),y
    jmp breturn
    // ultoa::@return
  breturn:
    // [129] return 
    rts
    // ultoa::@2
  b2:
    // [130] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 -- vbuaa=vbuz1_rol_2 
    lda.z digit
    asl
    asl
    // [131] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG + (byte~) ultoa::$11) -- vduz1=pduc1_derefidx_vbuaa 
    tay
    lda RADIX_DECIMAL_VALUES_LONG,y
    sta.z digit_value
    lda RADIX_DECIMAL_VALUES_LONG+1,y
    sta.z digit_value+1
    lda RADIX_DECIMAL_VALUES_LONG+2,y
    sta.z digit_value+2
    lda RADIX_DECIMAL_VALUES_LONG+3,y
    sta.z digit_value+3
    // [132] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@5 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne b5
    jmp b7
    // ultoa::@7
  b7:
    // [133] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@5 -- vduz1_ge_vduz2_then_la1 
    lda.z value+3
    cmp.z digit_value+3
    bcc !+
    bne b5
    lda.z value+2
    cmp.z digit_value+2
    bcc !+
    bne b5
    lda.z value+1
    cmp.z digit_value+1
    bcc !+
    bne b5
    lda.z value
    cmp.z digit_value
    bcs b5
  !:
    // [134] phi from ultoa::@7 to ultoa::@4 [phi:ultoa::@7->ultoa::@4]
  b4_from_b7:
    // [134] phi (byte*) ultoa::buffer#14 = (byte*) ultoa::buffer#11 [phi:ultoa::@7->ultoa::@4#0] -- register_copy 
    // [134] phi (byte) ultoa::started#4 = (byte) ultoa::started#2 [phi:ultoa::@7->ultoa::@4#1] -- register_copy 
    // [134] phi (dword) ultoa::value#6 = (dword) ultoa::value#2 [phi:ultoa::@7->ultoa::@4#2] -- register_copy 
    jmp b4
    // ultoa::@4
  b4:
    // [135] (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc.z digit
    // [123] phi from ultoa::@4 to ultoa::@1 [phi:ultoa::@4->ultoa::@1]
  b1_from_b4:
    // [123] phi (byte*) ultoa::buffer#11 = (byte*) ultoa::buffer#14 [phi:ultoa::@4->ultoa::@1#0] -- register_copy 
    // [123] phi (byte) ultoa::started#2 = (byte) ultoa::started#4 [phi:ultoa::@4->ultoa::@1#1] -- register_copy 
    // [123] phi (dword) ultoa::value#2 = (dword) ultoa::value#6 [phi:ultoa::@4->ultoa::@1#2] -- register_copy 
    // [123] phi (byte) ultoa::digit#2 = (byte) ultoa::digit#1 [phi:ultoa::@4->ultoa::@1#3] -- register_copy 
    jmp b1
    // ultoa::@5
  b5:
    // [136] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11
    // [137] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2
    // [138] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0
    // [139] call ultoa_append 
    // [143] phi from ultoa::@5 to ultoa_append [phi:ultoa::@5->ultoa_append]
  ultoa_append_from_b5:
    jsr ultoa_append
    // [140] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2
    jmp b6
    // ultoa::@6
  b6:
    // [141] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0
    // [142] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer
    bne !+
    inc.z buffer+1
  !:
    // [134] phi from ultoa::@6 to ultoa::@4 [phi:ultoa::@6->ultoa::@4]
  b4_from_b6:
    // [134] phi (byte*) ultoa::buffer#14 = (byte*) ultoa::buffer#4 [phi:ultoa::@6->ultoa::@4#0] -- register_copy 
    // [134] phi (byte) ultoa::started#4 = (byte) 1 [phi:ultoa::@6->ultoa::@4#1] -- vbuxx=vbuc1 
    ldx #1
    // [134] phi (dword) ultoa::value#6 = (dword) ultoa::value#0 [phi:ultoa::@6->ultoa::@4#2] -- register_copy 
    jmp b4
}
  // ultoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// ultoa_append(byte* zeropage($d) buffer, dword zeropage(9) value, dword zeropage($15) sub)
ultoa_append: {
    .label buffer = $d
    .label value = 9
    .label sub = $15
    .label return = 9
    // [144] phi from ultoa_append to ultoa_append::@1 [phi:ultoa_append->ultoa_append::@1]
  b1_from_ultoa_append:
    // [144] phi (byte) ultoa_append::digit#2 = (byte) 0 [phi:ultoa_append->ultoa_append::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [144] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#0 [phi:ultoa_append->ultoa_append::@1#1] -- register_copy 
    jmp b1
    // ultoa_append::@1
  b1:
    // [145] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 -- vduz1_ge_vduz2_then_la1 
    lda.z value+3
    cmp.z sub+3
    bcc !+
    bne b2
    lda.z value+2
    cmp.z sub+2
    bcc !+
    bne b2
    lda.z value+1
    cmp.z sub+1
    bcc !+
    bne b2
    lda.z value
    cmp.z sub
    bcs b2
  !:
    jmp b3
    // ultoa_append::@3
  b3:
    // [146] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) ultoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda DIGITS,x
    ldy #0
    sta (buffer),y
    jmp breturn
    // ultoa_append::@return
  breturn:
    // [147] return 
    rts
    // ultoa_append::@2
  b2:
    // [148] (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2 -- vbuxx=_inc_vbuxx 
    inx
    // [149] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 -- vduz1=vduz1_minus_vduz2 
    lda.z value
    sec
    sbc.z sub
    sta.z value
    lda.z value+1
    sbc.z sub+1
    sta.z value+1
    lda.z value+2
    sbc.z sub+2
    sta.z value+2
    lda.z value+3
    sbc.z sub+3
    sta.z value+3
    // [144] phi from ultoa_append::@2 to ultoa_append::@1 [phi:ultoa_append::@2->ultoa_append::@1]
  b1_from_b2:
    // [144] phi (byte) ultoa_append::digit#2 = (byte) ultoa_append::digit#1 [phi:ultoa_append::@2->ultoa_append::@1#0] -- register_copy 
    // [144] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#1 [phi:ultoa_append::@2->ultoa_append::@1#1] -- register_copy 
    jmp b1
}
  // div32u16u
// Divide unsigned 32-bit dword dividend with a 16-bit word divisor
// The 16-bit word remainder can be found in rem16u after the division
// div32u16u(dword zeropage(9) dividend)
div32u16u: {
    .label divisor = CLOCKS_PER_SEC/$64
    .label quotient_hi = $19
    .label quotient_lo = $13
    .label return = $15
    .label dividend = 9
    // [150] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 -- vwuz1=_hi_vduz2 
    lda.z dividend+2
    sta.z divr16u.dividend
    lda.z dividend+3
    sta.z divr16u.dividend+1
    // [151] call divr16u 
    // [161] phi from div32u16u to divr16u [phi:div32u16u->divr16u]
  divr16u_from_div32u16u:
    // [161] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#1 [phi:div32u16u->divr16u#0] -- register_copy 
    // [161] phi (word) divr16u::rem#10 = (byte) 0 [phi:div32u16u->divr16u#1] -- vwuz1=vbuc1 
    lda #<0
    sta.z divr16u.rem
    lda #>0
    sta.z divr16u.rem+1
    jsr divr16u
    // [152] (word) divr16u::return#2 ← (word) divr16u::return#0
    jmp b1
    // div32u16u::@1
  b1:
    // [153] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 -- vwuz1=vwuz2 
    lda.z divr16u.return
    sta.z quotient_hi
    lda.z divr16u.return+1
    sta.z quotient_hi+1
    // [154] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 -- vwuz1=_lo_vduz2 
    lda.z dividend
    sta.z divr16u.dividend
    lda.z dividend+1
    sta.z divr16u.dividend+1
    // [155] (word) divr16u::rem#4 ← (word) rem16u#1
    // [156] call divr16u 
    // [161] phi from div32u16u::@1 to divr16u [phi:div32u16u::@1->divr16u]
  divr16u_from_b1:
    // [161] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#2 [phi:div32u16u::@1->divr16u#0] -- register_copy 
    // [161] phi (word) divr16u::rem#10 = (word) divr16u::rem#4 [phi:div32u16u::@1->divr16u#1] -- register_copy 
    jsr divr16u
    // [157] (word) divr16u::return#3 ← (word) divr16u::return#0
    jmp b2
    // div32u16u::@2
  b2:
    // [158] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3
    // [159] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 -- vduz1=vwuz2_dword_vwuz3 
    lda.z quotient_hi
    sta.z return+2
    lda.z quotient_hi+1
    sta.z return+3
    lda.z quotient_lo
    sta.z return
    lda.z quotient_lo+1
    sta.z return+1
    jmp breturn
    // div32u16u::@return
  breturn:
    // [160] return 
    rts
}
  // divr16u
// Performs division on two 16 bit unsigned words and an initial remainder
// Returns the quotient dividend/divisor.
// The final remainder will be set into the global variable rem16u
// Implemented using simple binary division
// divr16u(word zeropage($11) dividend, word zeropage($f) rem)
divr16u: {
    .label rem = $f
    .label dividend = $11
    .label quotient = $13
    .label return = $13
    // [162] phi from divr16u to divr16u::@1 [phi:divr16u->divr16u::@1]
  b1_from_divr16u:
    // [162] phi (byte) divr16u::i#2 = (byte) 0 [phi:divr16u->divr16u::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [162] phi (word) divr16u::quotient#3 = (byte) 0 [phi:divr16u->divr16u::@1#1] -- vwuz1=vbuc1 
    lda #<0
    sta.z quotient
    lda #>0
    sta.z quotient+1
    // [162] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#5 [phi:divr16u->divr16u::@1#2] -- register_copy 
    // [162] phi (word) divr16u::rem#5 = (word) divr16u::rem#10 [phi:divr16u->divr16u::@1#3] -- register_copy 
    jmp b1
    // [162] phi from divr16u::@3 to divr16u::@1 [phi:divr16u::@3->divr16u::@1]
  b1_from_b3:
    // [162] phi (byte) divr16u::i#2 = (byte) divr16u::i#1 [phi:divr16u::@3->divr16u::@1#0] -- register_copy 
    // [162] phi (word) divr16u::quotient#3 = (word) divr16u::return#0 [phi:divr16u::@3->divr16u::@1#1] -- register_copy 
    // [162] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#0 [phi:divr16u::@3->divr16u::@1#2] -- register_copy 
    // [162] phi (word) divr16u::rem#5 = (word) divr16u::rem#11 [phi:divr16u::@3->divr16u::@1#3] -- register_copy 
    jmp b1
    // divr16u::@1
  b1:
    // [163] (word) divr16u::rem#0 ← (word) divr16u::rem#5 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z rem
    rol.z rem+1
    // [164] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 -- vbuaa=_hi_vwuz1 
    lda.z dividend+1
    // [165] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // [166] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b2_from_b1
    jmp b4
    // divr16u::@4
  b4:
    // [167] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 -- vwuz1=vwuz1_bor_vbuc1 
    lda #1
    ora.z rem
    sta.z rem
    // [168] phi from divr16u::@1 divr16u::@4 to divr16u::@2 [phi:divr16u::@1/divr16u::@4->divr16u::@2]
  b2_from_b1:
  b2_from_b4:
    // [168] phi (word) divr16u::rem#6 = (word) divr16u::rem#0 [phi:divr16u::@1/divr16u::@4->divr16u::@2#0] -- register_copy 
    jmp b2
    // divr16u::@2
  b2:
    // [169] (word) divr16u::dividend#0 ← (word) divr16u::dividend#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z dividend
    rol.z dividend+1
    // [170] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z quotient
    rol.z quotient+1
    // [171] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 -- vwuz1_lt_vwuc1_then_la1 
    lda.z rem+1
    cmp #>div32u16u.divisor
    bcc b3_from_b2
    bne !+
    lda.z rem
    cmp #<div32u16u.divisor
    bcc b3_from_b2
  !:
    jmp b5
    // divr16u::@5
  b5:
    // [172] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1 -- vwuz1=_inc_vwuz1 
    inc.z quotient
    bne !+
    inc.z quotient+1
  !:
    // [173] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 -- vwuz1=vwuz1_minus_vwuc1 
    lda.z rem
    sec
    sbc #<div32u16u.divisor
    sta.z rem
    lda.z rem+1
    sbc #>div32u16u.divisor
    sta.z rem+1
    // [174] phi from divr16u::@2 divr16u::@5 to divr16u::@3 [phi:divr16u::@2/divr16u::@5->divr16u::@3]
  b3_from_b2:
  b3_from_b5:
    // [174] phi (word) divr16u::return#0 = (word) divr16u::quotient#1 [phi:divr16u::@2/divr16u::@5->divr16u::@3#0] -- register_copy 
    // [174] phi (word) divr16u::rem#11 = (word) divr16u::rem#6 [phi:divr16u::@2/divr16u::@5->divr16u::@3#1] -- register_copy 
    jmp b3
    // divr16u::@3
  b3:
    // [175] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [176] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$10
    bne b1_from_b3
    jmp b6
    // divr16u::@6
  b6:
    // [177] (word) rem16u#1 ← (word) divr16u::rem#11
    jmp breturn
    // divr16u::@return
  breturn:
    // [178] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = 9
    // [179] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta.z return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta.z return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta.z return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta.z return+3
    jmp breturn
    // clock::@return
  breturn:
    // [180] return 
    rts
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [181] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #CIA_TIMER_CONTROL_CONTINUOUS
    sta CIA2_TIMER_A_CONTROL
    // [182] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [183] *((const dword*) CIA2_TIMER_AB) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [184] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [185] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2_TIMER_A_CONTROL
    jmp breturn
    // clock_start::@return
  breturn:
    // [186] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zeropage($11) str, byte register(X) c, word zeropage($f) num)
memset: {
    .label end = $f
    .label dst = $11
    .label num = $f
    .label str = $11
    // [188] if((word) memset::num#2<=(byte) 0) goto memset::@return -- vwuz1_le_0_then_la1 
    lda.z num
    bne !+
    lda.z num+1
    beq breturn
  !:
    jmp b1
    // memset::@1
  b1:
    // [189] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 -- pbuz1=pbuz2_plus_vwuz1 
    lda.z end
    clc
    adc.z str
    sta.z end
    lda.z end+1
    adc.z str+1
    sta.z end+1
    // [190] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3
    // [191] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  b2_from_b1:
  b2_from_b3:
    // [191] phi (byte*) memset::dst#2 = (byte*~) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp b2
    // memset::@2
  b2:
    // [192] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne b3
    lda.z dst
    cmp.z end
    bne b3
    jmp breturn
    // memset::@return
  breturn:
    // [193] return 
    rts
    // memset::@3
  b3:
    // [194] *((byte*) memset::dst#2) ← (byte) memset::c#4 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // [195] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp b2_from_b3
}
  // print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    // [197] call memset 
    // [187] phi from print_cls to memset [phi:print_cls->memset]
  memset_from_print_cls:
    // [187] phi (byte) memset::c#4 = (byte) ' ' [phi:print_cls->memset#0] -- vbuxx=vbuc1 
    ldx #' '
    // [187] phi (void*) memset::str#3 = (void*)(byte*) 1024 [phi:print_cls->memset#1] -- pvoz1=pvoc1 
    lda #<$400
    sta.z memset.str
    lda #>$400
    sta.z memset.str+1
    // [187] phi (word) memset::num#2 = (word) $3e8 [phi:print_cls->memset#2] -- vwuz1=vwuc1 
    lda #<$3e8
    sta.z memset.num
    lda #>$3e8
    sta.z memset.num+1
    jsr memset
    jmp breturn
    // print_cls::@return
  breturn:
    // [198] return 
    rts
}
  // File Data
  // The digits used for numbers
  DIGITS: .text "0123456789abcdef"
  // Values of decimal digits
  RADIX_DECIMAL_VALUES: .word $2710, $3e8, $64, $a
  // Values of decimal digits
  RADIX_DECIMAL_VALUES_LONG: .dword $3b9aca00, $5f5e100, $989680, $f4240, $186a0, $2710, $3e8, $64, $a
  // Digits used for storing the decimal word
  decimal_digits: .fill 6, 0
  // Digits used for storing the decimal word
  decimal_digits_long: .fill $b, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp toD0181
Removing instruction jmp b14
Removing instruction jmp b15
Removing instruction jmp b16
Removing instruction jmp b17
Removing instruction jmp b18
Removing instruction jmp b19
Removing instruction jmp b20
Removing instruction jmp b21
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b22
Removing instruction jmp b23
Removing instruction jmp b24
Removing instruction jmp b25
Removing instruction jmp b26
Removing instruction jmp b27
Removing instruction jmp b8
Removing instruction jmp b10
Removing instruction jmp b13
Removing instruction jmp b12
Removing instruction jmp b28
Removing instruction jmp b11
Removing instruction jmp b7
Removing instruction jmp b5
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b7
Removing instruction jmp b4
Removing instruction jmp b6
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b7
Removing instruction jmp b4
Removing instruction jmp b6
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b4
Removing instruction jmp b2
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b6
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy #0
Replacing instruction lda #0 with TXA
Replacing instruction ldy #0 with TAY
Replacing instruction lda #0 with TXA
Replacing instruction ldy #0 with TAY
Removing instruction lda #>0
Replacing instruction lda #<0 with TXA
Removing instruction lda #>0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b11_from_b9 with b11
Replacing label b5_from_b6 with b5
Replacing label b1_from_b2 with b1
Replacing label b1_from_b1 with b1
Replacing label b1_from_b1 with b1
Replacing label b2_from_b1 with b2
Replacing label b3_from_b2 with b3
Replacing label b3_from_b2 with b3
Replacing label b1_from_b3 with b1
Replacing label b2_from_b3 with b2
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction toD0181_from_main:
Removing instruction toD0181:
Removing instruction b15_from_b14:
Removing instruction print_str_from_b15:
Removing instruction b16_from_b15:
Removing instruction print_ln_from_b16:
Removing instruction b18_from_b17:
Removing instruction print_word_decimal_from_b18:
Removing instruction b19_from_b18:
Removing instruction print_ln_from_b19:
Removing instruction b20_from_b19:
Removing instruction memset_from_b20:
Removing instruction b21_from_b20:
Removing instruction b3_from_b1:
Removing instruction print_word_decimal_from_b24:
Removing instruction b25_from_b24:
Removing instruction print_str_from_b25:
Removing instruction b27_from_b26:
Removing instruction print_ln_from_b27:
Removing instruction b28_from_b12:
Removing instruction b11_from_b28:
Removing instruction b11_from_b9:
Removing instruction b5_from_b6:
Removing instruction b5_from_b7:
Removing instruction b1_from_print_word_decimal:
Removing instruction print_str_from_b1:
Removing instruction b1_from_print_str:
Removing instruction b1_from_b2:
Removing instruction b4_from_b7:
Removing instruction utoa_append_from_b5:
Removing instruction b1_from_print_ln:
Removing instruction b1_from_b1:
Removing instruction b1_from_print_dword_decimal:
Removing instruction print_str_from_b1:
Removing instruction b4_from_b7:
Removing instruction ultoa_append_from_b5:
Removing instruction b1_from_b3:
Removing instruction b2_from_b1:
Removing instruction b2_from_b4:
Removing instruction b3_from_b2:
Removing instruction b3_from_b5:
Removing instruction breturn:
Removing instruction b2_from_b1:
Removing instruction b2_from_b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b14:
Removing instruction print_cls_from_b14:
Removing instruction b15:
Removing instruction b16:
Removing instruction b17:
Removing instruction print_str_from_b17:
Removing instruction b18:
Removing instruction b19:
Removing instruction b20:
Removing instruction b21:
Removing instruction b1_from_b21:
Removing instruction b3:
Removing instruction b22:
Removing instruction b23:
Removing instruction print_str_from_b23:
Removing instruction b24:
Removing instruction b25:
Removing instruction b26:
Removing instruction b27:
Removing instruction b8_from_b27:
Removing instruction b10:
Removing instruction print_str_from_b10:
Removing instruction b12:
Removing instruction print_word_decimal_from_b12:
Removing instruction b28:
Removing instruction b8_from_b11:
Removing instruction b7:
Removing instruction b1_from_b4:
Removing instruction breturn:
Removing instruction utoa_from_print_word_decimal:
Removing instruction b1:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction b1_from_utoa:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b7:
Removing instruction b1_from_b4:
Removing instruction b6:
Removing instruction b4_from_b6:
Removing instruction b1_from_utoa_append:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction breturn:
Removing instruction ultoa_from_print_dword_decimal:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_ultoa:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b7:
Removing instruction b1_from_b4:
Removing instruction b6:
Removing instruction b4_from_b6:
Removing instruction b1_from_ultoa_append:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction divr16u_from_div32u16u:
Removing instruction b1:
Removing instruction divr16u_from_b1:
Removing instruction b2:
Removing instruction breturn:
Removing instruction b1_from_divr16u:
Removing instruction b4:
Removing instruction b5:
Removing instruction b6:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction b1:
Removing instruction memset_from_print_cls:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda.z digit_value+1
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination
Fixing long branch [106] bcc b2 to bcs
Fixing long branch [112] bcc b2 to bcs

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const dword*) CIA2_TIMER_AB CIA2_TIMER_AB = (dword*) 56580
(const byte*) CIA2_TIMER_A_CONTROL CIA2_TIMER_A_CONTROL = (byte*) 56590
(const byte*) CIA2_TIMER_B_CONTROL CIA2_TIMER_B_CONTROL = (byte*) 56591
(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = (byte) $40
(const byte) CIA_TIMER_CONTROL_CONTINUOUS CIA_TIMER_CONTROL_CONTINUOUS = (byte) 0
(const byte) CIA_TIMER_CONTROL_START CIA_TIMER_CONTROL_START = (byte) 1
(const word) CLOCKS_PER_FRAME CLOCKS_PER_FRAME = (word) $4cc8
(const dword) CLOCKS_PER_INIT CLOCKS_PER_INIT = (byte) $12
(const dword) CLOCKS_PER_SEC CLOCKS_PER_SEC = (const word) CLOCKS_PER_FRAME*(const byte) FRAMES_PER_SEC
(const word) COUNT COUNT = (word) $4000
(const byte*) D018 D018 = (byte*) 53272
(const byte[]) DIGITS DIGITS = (string) "0123456789abcdef"z
(const byte) FRAMES_PER_SEC FRAMES_PER_SEC = (byte) $3c
(const byte) RADIX::BINARY BINARY = (number) 2
(const byte) RADIX::DECIMAL DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL OCTAL = (number) 8
(const word[]) RADIX_DECIMAL_VALUES RADIX_DECIMAL_VALUES = { (word) $2710, (word) $3e8, (word) $64, (word) $a }
(const dword[]) RADIX_DECIMAL_VALUES_LONG RADIX_DECIMAL_VALUES_LONG = { (dword) $3b9aca00, (dword) $5f5e100, (dword) $989680, (dword) $f4240, (dword) $186a0, (dword) $2710, (dword) $3e8, (dword) $64, (dword) $a }
(const byte*) SCREEN SCREEN = (byte*) 1024
(const byte) SQRT_COUNT SQRT_COUNT = (byte) $80
(dword()) clock()
(label) clock::@return
(dword) clock::return
(dword) clock::return#0 return zp ZP_DWORD:9 1.3333333333333333
(dword) clock::return#2 return zp ZP_DWORD:9 4.0
(void()) clock_start()
(label) clock_start::@return
(const byte[6]) decimal_digits decimal_digits = { fill( 6, 0) }
(const byte[$b]) decimal_digits_long decimal_digits_long = { fill( $b, 0) }
(dword()) div32u16u((dword) div32u16u::dividend , (word) div32u16u::divisor)
(label) div32u16u::@1
(label) div32u16u::@2
(label) div32u16u::@return
(dword) div32u16u::dividend
(dword) div32u16u::dividend#0 dividend zp ZP_DWORD:9 1.2000000000000002
(word) div32u16u::divisor
(const word) div32u16u::divisor#0 divisor = (word)(const dword) CLOCKS_PER_SEC/(byte) $64
(dword) div32u16u::quotient
(word) div32u16u::quotient_hi
(word) div32u16u::quotient_hi#0 quotient_hi zp ZP_WORD:25 0.6666666666666666
(word) div32u16u::quotient_lo
(word) div32u16u::quotient_lo#0 quotient_lo zp ZP_WORD:19 4.0
(dword) div32u16u::return
(dword) div32u16u::return#0 return zp ZP_DWORD:21 1.3333333333333333
(dword) div32u16u::return#2 return zp ZP_DWORD:21 4.0
(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
(byte~) divr16u::$1 reg byte a 22.0
(byte~) divr16u::$2 reg byte a 22.0
(label) divr16u::@1
(label) divr16u::@2
(label) divr16u::@3
(label) divr16u::@4
(label) divr16u::@5
(label) divr16u::@6
(label) divr16u::@return
(word) divr16u::dividend
(word) divr16u::dividend#0 dividend zp ZP_WORD:17 2.75
(word) divr16u::dividend#1 dividend zp ZP_WORD:17 4.0
(word) divr16u::dividend#2 dividend zp ZP_WORD:17 2.0
(word) divr16u::dividend#3 dividend zp ZP_WORD:17 5.0
(word) divr16u::dividend#5 dividend zp ZP_WORD:17 6.0
(word) divr16u::divisor
(byte) divr16u::i
(byte) divr16u::i#1 reg byte x 16.5
(byte) divr16u::i#2 reg byte x 1.6923076923076923
(word) divr16u::quotient
(word) divr16u::quotient#1 quotient zp ZP_WORD:19 16.5
(word) divr16u::quotient#2 quotient zp ZP_WORD:19 11.0
(word) divr16u::quotient#3 quotient zp ZP_WORD:19 2.75
(word) divr16u::rem
(word) divr16u::rem#0 rem zp ZP_WORD:15 8.25
(word) divr16u::rem#1 rem zp ZP_WORD:15 22.0
(word) divr16u::rem#10 rem zp ZP_WORD:15 4.0
(word) divr16u::rem#11 rem zp ZP_WORD:15 11.666666666666666
(word) divr16u::rem#2 rem zp ZP_WORD:15 22.0
(word) divr16u::rem#4 rem zp ZP_WORD:15 4.0
(word) divr16u::rem#5 rem zp ZP_WORD:15 24.0
(word) divr16u::rem#6 rem zp ZP_WORD:15 11.0
(word) divr16u::return
(word) divr16u::return#0 return zp ZP_WORD:19 5.285714285714286
(word) divr16u::return#2 return zp ZP_WORD:19 4.0
(word) divr16u::return#3 return zp ZP_WORD:19 4.0
(void()) main()
(dword~) main::$10 $10 zp ZP_DWORD:9 4.0
(dword~) main::$14 $14 zp ZP_DWORD:21 2.0
(byte*~) main::$39 $39 zp ZP_WORD:19 22.0
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@22
(label) main::@23
(label) main::@24
(label) main::@25
(label) main::@26
(label) main::@27
(label) main::@28
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(dword) main::cyclecount
(dword) main::cyclecount#0 cyclecount zp ZP_DWORD:9 0.5
(word) main::i
(word) main::i#10 i#10 zp ZP_WORD:13 5.5
(word) main::i#12 i zp ZP_WORD:17 24.6
(word) main::i#2 i zp ZP_WORD:17 11.0
(word) main::i#3 i#3 zp ZP_WORD:13 22.0
(word) main::j
(word) main::j#0 j zp ZP_WORD:2 16.5
(word) main::j#1 j zp ZP_WORD:2 202.0
(word) main::j#2 j zp ZP_WORD:2 78.5
(byte*) main::s
(byte*) main::s#0 s zp ZP_WORD:4 22.0
(byte*) main::s#1 s zp ZP_WORD:4 101.0
(byte*) main::s#2 s zp ZP_WORD:4 104.66666666666666
(word) main::sec100s
(word) main::sec100s#0 sec100s zp ZP_WORD:13 1.3333333333333333
(byte*) main::sieve_i
(byte*) main::sieve_i#1 sieve_i zp ZP_WORD:15 22.0
(byte*) main::sieve_i#2 sieve_i zp ZP_WORD:15 3.0
(const string) main::str str = (string) "Sieve benchmark - calculating primes"
(const string) main::str1 str1 = (string) "between 2 and "
(const string) main::str2 str2 = (string) "100ths seconds used: "
(const string) main::str3 str3 = (string) " cycles: "
(const string) main::str4 str4 = (string) "..."
(label) main::toD0181
(byte*) main::toD0181_gfx
(const byte*) main::toD0181_gfx#0 toD0181_gfx = (byte*) 6144
(byte) main::toD0181_return
(const byte) main::toD0181_return#0 toD0181_return = >(word)(const byte*) SCREEN&(word) $3fff*(byte) 4|>(word)(const byte*) main::toD0181_gfx#0/(byte) 4&(byte) $f
(byte*) main::toD0181_screen
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(label) memset::@1
(label) memset::@2
(label) memset::@3
(label) memset::@return
(byte) memset::c
(byte) memset::c#4 reg byte x 1.375
(byte*) memset::dst
(byte*) memset::dst#1 dst zp ZP_WORD:17 22.0
(byte*) memset::dst#2 dst zp ZP_WORD:17 15.333333333333332
(byte*~) memset::dst#4 dst zp ZP_WORD:17 4.0
(byte*) memset::end
(byte*) memset::end#0 end zp ZP_WORD:15 2.1666666666666665
(word) memset::num
(word) memset::num#2 num zp ZP_WORD:15 2.0
(void*) memset::return
(void*) memset::str
(void*) memset::str#3 str zp ZP_WORD:17
(void()) print_char((byte) print_char::ch)
(label) print_char::@return
(byte) print_char::ch
(const byte) print_char::ch#0 ch = (byte) ' '
(byte*) print_char_cursor
(byte*) print_char_cursor#1 print_char_cursor zp ZP_WORD:17 101.0
(byte*) print_char_cursor#10 print_char_cursor#10 zp ZP_WORD:6 4.333333333333333
(byte*) print_char_cursor#2 print_char_cursor zp ZP_WORD:17 10.25
(byte*) print_char_cursor#58 print_char_cursor zp ZP_WORD:17 4.25
(byte*) print_char_cursor#62 print_char_cursor#62 zp ZP_WORD:6 7.4
(byte*) print_char_cursor#66 print_char_cursor zp ZP_WORD:17 14.0
(byte*) print_char_cursor#78 print_char_cursor#78 zp ZP_WORD:6 16.5
(byte*~) print_char_cursor#89 print_char_cursor zp ZP_WORD:17 4.0
(byte*~) print_char_cursor#90 print_char_cursor zp ZP_WORD:17 4.0
(byte*~) print_char_cursor#91 print_char_cursor zp ZP_WORD:17 4.0
(byte*~) print_char_cursor#97 print_char_cursor zp ZP_WORD:17 22.0
(void()) print_cls()
(label) print_cls::@return
(void()) print_dword_decimal((dword) print_dword_decimal::w)
(label) print_dword_decimal::@1
(label) print_dword_decimal::@return
(dword) print_dword_decimal::w
(dword) print_dword_decimal::w#0 w zp ZP_DWORD:9 4.0
(byte*) print_line_cursor
(byte*) print_line_cursor#1 print_line_cursor zp ZP_WORD:6 0.9347826086956521
(byte*) print_line_cursor#11 print_line_cursor zp ZP_WORD:6 24.0
(byte*) print_line_cursor#21 print_line_cursor zp ZP_WORD:6 6.0
(void()) print_ln()
(label) print_ln::@1
(label) print_ln::@return
(byte*) print_screen
(void()) print_str((byte*) print_str::str)
(label) print_str::@1
(label) print_str::@2
(label) print_str::@return
(byte*) print_str::str
(byte*) print_str::str#0 str zp ZP_WORD:15 202.0
(byte*) print_str::str#10 str zp ZP_WORD:15 2.0
(byte*) print_str::str#8 str zp ZP_WORD:15 101.5
(void()) print_word_decimal((word) print_word_decimal::w)
(label) print_word_decimal::@1
(label) print_word_decimal::@return
(word) print_word_decimal::w
(word) print_word_decimal::w#1 w zp ZP_WORD:13 4.0
(word) print_word_decimal::w#2 w zp ZP_WORD:13 11.0
(word) print_word_decimal::w#3 w zp ZP_WORD:13 15.0
(word) rem16u
(word) rem16u#1 rem16u zp ZP_WORD:15 0.6666666666666666
(byte*) sieve
(const byte*) sieve#0 sieve = (byte*) 4096
(void()) ultoa((dword) ultoa::value , (byte*) ultoa::buffer , (byte) ultoa::radix)
(byte~) ultoa::$11 reg byte a 22.0
(byte~) ultoa::$4 reg byte a 4.0
(label) ultoa::@1
(label) ultoa::@2
(label) ultoa::@3
(label) ultoa::@4
(label) ultoa::@5
(label) ultoa::@6
(label) ultoa::@7
(label) ultoa::@return
(byte*) ultoa::buffer
(byte*) ultoa::buffer#11 buffer zp ZP_WORD:13 3.4285714285714284
(byte*) ultoa::buffer#14 buffer zp ZP_WORD:13 16.5
(byte*) ultoa::buffer#3 buffer zp ZP_WORD:13 4.0
(byte*) ultoa::buffer#4 buffer zp ZP_WORD:13 22.0
(byte) ultoa::digit
(byte) ultoa::digit#1 digit zp ZP_BYTE:8 22.0
(byte) ultoa::digit#2 digit zp ZP_BYTE:8 3.142857142857143
(dword) ultoa::digit_value
(dword) ultoa::digit_value#0 digit_value zp ZP_DWORD:21 6.6000000000000005
(dword*) ultoa::digit_values
(byte) ultoa::max_digits
(const byte) ultoa::max_digits#1 max_digits = (byte) $a
(byte) ultoa::radix
(byte) ultoa::started
(byte) ultoa::started#2 reg byte x 5.5
(byte) ultoa::started#4 reg byte x 11.0
(dword) ultoa::value
(dword) ultoa::value#0 value zp ZP_DWORD:9 11.0
(dword) ultoa::value#1 value zp ZP_DWORD:9 2.0
(dword) ultoa::value#2 value zp ZP_DWORD:9 6.571428571428571
(dword) ultoa::value#6 value zp ZP_DWORD:9 16.5
(dword()) ultoa_append((byte*) ultoa_append::buffer , (dword) ultoa_append::value , (dword) ultoa_append::sub)
(label) ultoa_append::@1
(label) ultoa_append::@2
(label) ultoa_append::@3
(label) ultoa_append::@return
(byte*) ultoa_append::buffer
(byte*) ultoa_append::buffer#0 buffer zp ZP_WORD:13 1.625
(byte) ultoa_append::digit
(byte) ultoa_append::digit#1 reg byte x 101.0
(byte) ultoa_append::digit#2 reg byte x 102.0
(dword) ultoa_append::return
(dword) ultoa_append::return#0 return zp ZP_DWORD:9 22.0
(dword) ultoa_append::sub
(dword) ultoa_append::sub#0 sub zp ZP_DWORD:21 35.5
(dword) ultoa_append::value
(dword) ultoa_append::value#0 value zp ZP_DWORD:9 4.333333333333333
(dword) ultoa_append::value#1 value zp ZP_DWORD:9 202.0
(dword) ultoa_append::value#2 value zp ZP_DWORD:9 52.66666666666666
(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
(byte~) utoa::$11 reg byte a 202.0
(byte~) utoa::$4 reg byte a 4.0
(label) utoa::@1
(label) utoa::@2
(label) utoa::@3
(label) utoa::@4
(label) utoa::@5
(label) utoa::@6
(label) utoa::@7
(label) utoa::@return
(byte*) utoa::buffer
(byte*) utoa::buffer#11 buffer zp ZP_WORD:4 29.142857142857146
(byte*) utoa::buffer#14 buffer zp ZP_WORD:4 151.5
(byte*) utoa::buffer#3 buffer zp ZP_WORD:4 4.0
(byte*) utoa::buffer#4 buffer zp ZP_WORD:4 202.0
(byte) utoa::digit
(byte) utoa::digit#1 digit zp ZP_BYTE:8 202.0
(byte) utoa::digit#2 digit zp ZP_BYTE:8 28.857142857142858
(word) utoa::digit_value
(word) utoa::digit_value#0 digit_value zp ZP_WORD:25 60.599999999999994
(word*) utoa::digit_values
(byte) utoa::max_digits
(const byte) utoa::max_digits#1 max_digits = (byte) 5
(byte) utoa::radix
(byte) utoa::started
(byte) utoa::started#2 reg byte x 50.5
(byte) utoa::started#4 reg byte x 101.0
(word) utoa::value
(word) utoa::value#0 value zp ZP_WORD:2 101.0
(word) utoa::value#1 value zp ZP_WORD:2 2.0
(word) utoa::value#2 value zp ZP_WORD:2 58.00000000000001
(word) utoa::value#6 value zp ZP_WORD:2 151.5
(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
(label) utoa_append::@1
(label) utoa_append::@2
(label) utoa_append::@3
(label) utoa_append::@return
(byte*) utoa_append::buffer
(byte*) utoa_append::buffer#0 buffer zp ZP_WORD:4 12.875
(byte) utoa_append::digit
(byte) utoa_append::digit#1 reg byte x 1001.0
(byte) utoa_append::digit#2 reg byte x 1002.0
(word) utoa_append::return
(word) utoa_append::return#0 return zp ZP_WORD:2 202.0
(word) utoa_append::sub
(word) utoa_append::sub#0 sub zp ZP_WORD:25 350.5
(word) utoa_append::value
(word) utoa_append::value#0 value zp ZP_WORD:2 34.33333333333333
(word) utoa_append::value#1 value zp ZP_WORD:2 2002.0
(word) utoa_append::value#2 value zp ZP_WORD:2 517.6666666666667

zp ZP_WORD:2 [ utoa::value#2 utoa::value#6 utoa::value#1 utoa::value#0 utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 utoa_append::return#0 main::j#2 main::j#0 main::j#1 ]
reg byte x [ utoa::started#2 utoa::started#4 ]
zp ZP_WORD:4 [ utoa::buffer#11 utoa::buffer#14 utoa::buffer#4 utoa::buffer#3 utoa_append::buffer#0 main::s#2 main::s#0 main::s#1 ]
reg byte x [ utoa_append::digit#2 utoa_append::digit#1 ]
zp ZP_WORD:6 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#78 print_line_cursor#1 print_char_cursor#10 ]
zp ZP_BYTE:8 [ ultoa::digit#2 ultoa::digit#1 utoa::digit#2 utoa::digit#1 ]
zp ZP_DWORD:9 [ ultoa::value#2 ultoa::value#6 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ultoa_append::return#0 main::cyclecount#0 div32u16u::dividend#0 clock::return#2 main::$10 clock::return#0 ]
reg byte x [ ultoa::started#2 ultoa::started#4 ]
zp ZP_WORD:13 [ ultoa::buffer#11 ultoa::buffer#14 ultoa::buffer#4 ultoa::buffer#3 ultoa_append::buffer#0 main::i#10 main::i#3 print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 main::sec100s#0 ]
reg byte x [ ultoa_append::digit#2 ultoa_append::digit#1 ]
reg byte x [ divr16u::i#2 divr16u::i#1 ]
zp ZP_WORD:15 [ memset::num#2 memset::end#0 divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 rem16u#1 print_str::str#8 print_str::str#10 print_str::str#0 main::sieve_i#2 main::sieve_i#1 ]
zp ZP_WORD:17 [ memset::str#3 memset::dst#2 memset::dst#4 memset::dst#1 divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 print_char_cursor#66 print_char_cursor#89 print_char_cursor#90 print_char_cursor#91 print_char_cursor#58 print_char_cursor#97 print_char_cursor#2 print_char_cursor#1 main::i#12 main::i#2 ]
reg byte x [ memset::c#4 ]
zp ZP_WORD:19 [ main::$39 divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 divr16u::return#3 div32u16u::quotient_lo#0 ]
reg byte a [ utoa::$4 ]
reg byte a [ utoa::$11 ]
reg byte a [ ultoa::$4 ]
reg byte a [ ultoa::$11 ]
zp ZP_DWORD:21 [ ultoa::digit_value#0 ultoa_append::sub#0 div32u16u::return#2 main::$14 div32u16u::return#0 ]
zp ZP_WORD:25 [ div32u16u::quotient_hi#0 utoa::digit_value#0 utoa_append::sub#0 ]
reg byte a [ divr16u::$1 ]
reg byte a [ divr16u::$2 ]


FINAL ASSEMBLER
Score: 83095

  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label D018 = $d018
  // CIA #2 Timer A+B Value (32-bit)
  .label CIA2_TIMER_AB = $dd04
  // CIA #2 Timer A Control Register
  .label CIA2_TIMER_A_CONTROL = $dd0e
  // CIA #2 Timer B Control Register
  .label CIA2_TIMER_B_CONTROL = $dd0f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer Control - Time CONTINUOUS/ONE-SHOT (0:CONTINUOUS, 1: ONE-SHOT)
  .const CIA_TIMER_CONTROL_CONTINUOUS = 0
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  // Clock cycles per frame (on a C64 PAL)
  .const CLOCKS_PER_FRAME = $4cc8
  // Frames per second (on a C64 PAL)
  .const FRAMES_PER_SEC = $3c
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .label SCREEN = $400
  .const COUNT = $4000
  /* Up to what number? */
  .const SQRT_COUNT = $80
  /* Sqrt of COUNT */
  .label sieve = $1000
  // Clock cycles per second (on a C64 PAL)
  .const CLOCKS_PER_SEC = CLOCKS_PER_FRAME*FRAMES_PER_SEC
  .label rem16u = $f
  .label print_char_cursor = $11
  .label print_line_cursor = 6
  .label print_char_cursor_10 = 6
  .label print_char_cursor_62 = 6
  .label print_char_cursor_78 = 6
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label toD0181_gfx = $1800
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>toD0181_gfx)/4&$f
    .label _10 = 9
    .label _14 = $15
    .label cyclecount = 9
    .label sec100s = $d
    .label i = $11
    .label sieve_i = $f
    .label j = 2
    .label s = 4
    .label i_3 = $d
    .label i_10 = $d
    .label _39 = $13
    // [5] phi from main to main::toD0181 [phi:main->main::toD0181]
    // main::toD0181
    // main::@14
    // *D018 = toD018(SCREEN, 0x1800)
    // [6] *((const byte*) D018) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    //Show lower case font
    lda #toD0181_return
    sta D018
    // print_cls()
    // [7] call print_cls 
    // [196] phi from main::@14 to print_cls [phi:main::@14->print_cls]
    jsr print_cls
    // [8] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
    // main::@15
    // print_str("Sieve benchmark - calculating primes")
    // [9] call print_str 
    // [77] phi from main::@15 to print_str [phi:main::@15->print_str]
    // [77] phi (byte*) print_char_cursor#66 = (byte*) 1024 [phi:main::@15->print_str#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z print_char_cursor
    lda #>$400
    sta.z print_char_cursor+1
    // [77] phi (byte*) print_str::str#10 = (const string) main::str [phi:main::@15->print_str#1] -- pbuz1=pbuc1 
    lda #<str
    sta.z print_str.str
    lda #>str
    sta.z print_str.str+1
    jsr print_str
    // [10] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
    // main::@16
    // print_ln()
    // [11] call print_ln 
    // [112] phi from main::@16 to print_ln [phi:main::@16->print_ln]
    // [112] phi (byte*) print_line_cursor#21 = (byte*) 1024 [phi:main::@16->print_ln#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z print_line_cursor
    lda #>$400
    sta.z print_line_cursor+1
    jsr print_ln
    // main::@17
    // [12] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda.z print_line_cursor
    sta.z print_char_cursor
    lda.z print_line_cursor+1
    sta.z print_char_cursor+1
    // print_str("between 2 and ")
    // [13] call print_str 
    // [77] phi from main::@17 to print_str [phi:main::@17->print_str]
    // [77] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#90 [phi:main::@17->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str1 [phi:main::@17->print_str#1] -- pbuz1=pbuc1 
    lda #<str1
    sta.z print_str.str
    lda #>str1
    sta.z print_str.str+1
    jsr print_str
    // [14] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
    // main::@18
    // print_word_decimal(COUNT)
    // [15] call print_word_decimal 
    // [71] phi from main::@18 to print_word_decimal [phi:main::@18->print_word_decimal]
    // [71] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@18->print_word_decimal#0] -- register_copy 
    // [71] phi (word) print_word_decimal::w#3 = (const word) COUNT [phi:main::@18->print_word_decimal#1] -- vwuz1=vwuc1 
    lda #<COUNT
    sta.z print_word_decimal.w
    lda #>COUNT
    sta.z print_word_decimal.w+1
    jsr print_word_decimal
    // [16] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
    // main::@19
    // print_ln()
    // [17] call print_ln 
    // [112] phi from main::@19 to print_ln [phi:main::@19->print_ln]
    // [112] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@19->print_ln#0] -- register_copy 
    jsr print_ln
    // [18] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
    // main::@20
    // memset(sieve, 0, COUNT)
    // [19] call memset 
    // [187] phi from main::@20 to memset [phi:main::@20->memset]
    // [187] phi (byte) memset::c#4 = (byte) 0 [phi:main::@20->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [187] phi (void*) memset::str#3 = (void*)(const byte*) sieve#0 [phi:main::@20->memset#1] -- pvoz1=pvoc1 
    lda #<sieve
    sta.z memset.str
    lda #>sieve
    sta.z memset.str+1
    // [187] phi (word) memset::num#2 = (const word) COUNT [phi:main::@20->memset#2] -- vwuz1=vwuc1 
    lda #<COUNT
    sta.z memset.num
    lda #>COUNT
    sta.z memset.num+1
    jsr memset
    // [20] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
    // main::@21
    // clock_start()
    // [21] call clock_start 
    jsr clock_start
    // [22] phi from main::@21 to main::@1 [phi:main::@21->main::@1]
    // [22] phi (byte*) main::sieve_i#2 = (const byte*) sieve#0+(byte) 2 [phi:main::@21->main::@1#0] -- pbuz1=pbuc1 
    lda #<sieve+2
    sta.z sieve_i
    lda #>sieve+2
    sta.z sieve_i+1
    // [22] phi (word) main::i#12 = (byte) 2 [phi:main::@21->main::@1#1] -- vwuz1=vbuc1 
    lda #<2
    sta.z i
    lda #>2
    sta.z i+1
    // main::@1
  b1:
    // while (i < SQRT_COUNT)
    // [23] if((word) main::i#12<(const byte) SQRT_COUNT) goto main::@2 -- vwuz1_lt_vbuc1_then_la1 
    lda.z i+1
    cmp #>SQRT_COUNT
    bcs !b2+
    jmp b2
  !b2:
    bne !+
    lda.z i
    cmp #<SQRT_COUNT
    bcs !b2+
    jmp b2
  !b2:
  !:
    // [24] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // main::@3
    // clock()
    // [25] call clock 
    jsr clock
    // [26] (dword) clock::return#2 ← (dword) clock::return#0
    // main::@22
    // [27] (dword~) main::$10 ← (dword) clock::return#2
    // cyclecount = clock()-CLOCKS_PER_INIT
    // [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT -- vduz1=vduz1_minus_vduc1 
    lda.z cyclecount
    sec
    sbc #<CLOCKS_PER_INIT
    sta.z cyclecount
    lda.z cyclecount+1
    sbc #>CLOCKS_PER_INIT
    sta.z cyclecount+1
    lda.z cyclecount+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta.z cyclecount+2
    lda.z cyclecount+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta.z cyclecount+3
    // div32u16u(cyclecount, (unsigned int)(CLOCKS_PER_SEC/100))
    // [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0
    // [30] call div32u16u 
    jsr div32u16u
    // [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0
    // main::@23
    // [32] (dword~) main::$14 ← (dword) div32u16u::return#2
    // sec100s = (unsigned int)div32u16u(cyclecount, (unsigned int)(CLOCKS_PER_SEC/100))
    // [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 -- vwuz1=_word_vduz2 
    lda.z _14
    sta.z sec100s
    lda.z _14+1
    sta.z sec100s+1
    // [34] (byte*~) print_char_cursor#91 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda.z print_line_cursor
    sta.z print_char_cursor
    lda.z print_line_cursor+1
    sta.z print_char_cursor+1
    // print_str("100ths seconds used: ")
    // [35] call print_str 
    // [77] phi from main::@23 to print_str [phi:main::@23->print_str]
    // [77] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#91 [phi:main::@23->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str2 [phi:main::@23->print_str#1] -- pbuz1=pbuc1 
    lda #<str2
    sta.z print_str.str
    lda #>str2
    sta.z print_str.str+1
    jsr print_str
    // main::@24
    // print_word_decimal(sec100s)
    // [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0
    // [37] call print_word_decimal 
    // [71] phi from main::@24 to print_word_decimal [phi:main::@24->print_word_decimal]
    // [71] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@24->print_word_decimal#0] -- register_copy 
    // [71] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#1 [phi:main::@24->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [38] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
    // main::@25
    // print_str(" cycles: ")
    // [39] call print_str 
    // [77] phi from main::@25 to print_str [phi:main::@25->print_str]
    // [77] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:main::@25->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str3 [phi:main::@25->print_str#1] -- pbuz1=pbuc1 
    lda #<str3
    sta.z print_str.str
    lda #>str3
    sta.z print_str.str+1
    jsr print_str
    // main::@26
    // print_dword_decimal(cyclecount)
    // [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0
    // [41] call print_dword_decimal 
    jsr print_dword_decimal
    // [42] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
    // main::@27
    // print_ln()
    // [43] call print_ln 
    // [112] phi from main::@27 to print_ln [phi:main::@27->print_ln]
    // [112] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@27->print_ln#0] -- register_copy 
    jsr print_ln
    // [44] phi from main::@27 to main::@8 [phi:main::@27->main::@8]
    // [44] phi (byte*) print_char_cursor#62 = (byte*) print_line_cursor#1 [phi:main::@27->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (byte) 2 [phi:main::@27->main::@8#1] -- vwuz1=vbuc1 
    lda #<2
    sta.z i_10
    lda #>2
    sta.z i_10+1
    // main::@8
  b8:
    // for (i = 2; i < 1300; ++i)
    // [45] if((word) main::i#10<(word) $514) goto main::@9 -- vwuz1_lt_vwuc1_then_la1 
    lda.z i_10+1
    cmp #>$514
    bcc b9
    bne !+
    lda.z i_10
    cmp #<$514
    bcc b9
  !:
    // main::@10
    // [46] (byte*~) print_char_cursor#89 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda.z print_char_cursor_62
    sta.z print_char_cursor
    lda.z print_char_cursor_62+1
    sta.z print_char_cursor+1
    // print_str("...")
    // [47] call print_str 
    // [77] phi from main::@10 to print_str [phi:main::@10->print_str]
    // [77] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#89 [phi:main::@10->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const string) main::str4 [phi:main::@10->print_str#1] -- pbuz1=pbuc1 
    lda #<str4
    sta.z print_str.str
    lda #>str4
    sta.z print_str.str+1
    jsr print_str
    // main::@13
  b13:
    // (*(SCREEN+999))++;
    // [48] *((const byte*) SCREEN+(word) $3e7) ← ++ *((const byte*) SCREEN+(word) $3e7) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN+$3e7
    jmp b13
    // main::@9
  b9:
    // if (!sieve[i])
    // [49] (byte*~) main::$39 ← (const byte*) sieve#0 + (word) main::i#10 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z i_10
    clc
    adc #<sieve
    sta.z _39
    lda.z i_10+1
    adc #>sieve
    sta.z _39+1
    // [50] if((byte) 0!=*((byte*~) main::$39)) goto main::@11 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (_39),y
    cmp #0
    bne b11
    // main::@12
    // print_word_decimal(i)
    // [51] (word) print_word_decimal::w#2 ← (word) main::i#10
    // [52] (byte*~) print_char_cursor#97 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda.z print_char_cursor_62
    sta.z print_char_cursor
    lda.z print_char_cursor_62+1
    sta.z print_char_cursor+1
    // print_word_decimal(i)
    // [53] call print_word_decimal 
    // [71] phi from main::@12 to print_word_decimal [phi:main::@12->print_word_decimal]
    // [71] phi (byte*) print_char_cursor#58 = (byte*~) print_char_cursor#97 [phi:main::@12->print_word_decimal#0] -- register_copy 
    // [71] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#2 [phi:main::@12->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [54] phi from main::@12 to main::@28 [phi:main::@12->main::@28]
    // main::@28
    // print_char(' ')
    // [55] call print_char 
    jsr print_char
    // [56] phi from main::@28 main::@9 to main::@11 [phi:main::@28/main::@9->main::@11]
    // [56] phi (byte*) print_char_cursor#78 = (byte*) print_char_cursor#10 [phi:main::@28/main::@9->main::@11#0] -- register_copy 
    // main::@11
  b11:
    // for (i = 2; i < 1300; ++i)
    // [57] (word) main::i#3 ← ++ (word) main::i#10 -- vwuz1=_inc_vwuz1 
    inc.z i_3
    bne !+
    inc.z i_3+1
  !:
    // [44] phi from main::@11 to main::@8 [phi:main::@11->main::@8]
    // [44] phi (byte*) print_char_cursor#62 = (byte*) print_char_cursor#78 [phi:main::@11->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (word) main::i#3 [phi:main::@11->main::@8#1] -- register_copy 
    jmp b8
    // main::@2
  b2:
    // if (!*sieve_i)
    // [58] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (sieve_i),y
    cmp #0
    bne b4
    // main::@7
    // j = i*2
    // [59] (word) main::j#0 ← (word) main::i#12 << (byte) 1 -- vwuz1=vwuz2_rol_1 
    lda.z i
    asl
    sta.z j
    lda.z i+1
    rol
    sta.z j+1
    // s = &sieve[j]
    // [60] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z j
    clc
    adc #<sieve
    sta.z s
    lda.z j+1
    adc #>sieve
    sta.z s+1
    // [61] phi from main::@6 main::@7 to main::@5 [phi:main::@6/main::@7->main::@5]
    // [61] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@6/main::@7->main::@5#0] -- register_copy 
    // [61] phi (word) main::j#2 = (word) main::j#1 [phi:main::@6/main::@7->main::@5#1] -- register_copy 
    // main::@5
  b5:
    // while (j < COUNT)
    // [62] if((word) main::j#2<(const word) COUNT) goto main::@6 -- vwuz1_lt_vwuc1_then_la1 
    lda.z j+1
    cmp #>COUNT
    bcc b6
    bne !+
    lda.z j
    cmp #<COUNT
    bcc b6
  !:
    // main::@4
  b4:
    // i++;
    // [63] (word) main::i#2 ← ++ (word) main::i#12 -- vwuz1=_inc_vwuz1 
    inc.z i
    bne !+
    inc.z i+1
  !:
    // sieve_i++;
    // [64] (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#2 -- pbuz1=_inc_pbuz1 
    inc.z sieve_i
    bne !+
    inc.z sieve_i+1
  !:
    // [22] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
    // [22] phi (byte*) main::sieve_i#2 = (byte*) main::sieve_i#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [22] phi (word) main::i#12 = (word) main::i#2 [phi:main::@4->main::@1#1] -- register_copy 
    jmp b1
    // main::@6
  b6:
    // *s = 1
    // [65] *((byte*) main::s#2) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (s),y
    // s += i
    // [66] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#12 -- pbuz1=pbuz1_plus_vwuz2 
    lda.z s
    clc
    adc.z i
    sta.z s
    lda.z s+1
    adc.z i+1
    sta.z s+1
    // j += i
    // [67] (word) main::j#1 ← (word) main::j#2 + (word) main::i#12 -- vwuz1=vwuz1_plus_vwuz2 
    lda.z j
    clc
    adc.z i
    sta.z j
    lda.z j+1
    adc.z i+1
    sta.z j+1
    jmp b5
    str: .text "Sieve benchmark - calculating primes"
    .byte 0
    str1: .text "between 2 and "
    .byte 0
    str2: .text "100ths seconds used: "
    .byte 0
    str3: .text " cycles: "
    .byte 0
    str4: .text "..."
    .byte 0
}
  // print_char
// Print a single char
print_char: {
    .const ch = ' '
    // *(print_char_cursor++) = ch
    // [68] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 -- _deref_pbuz1=vbuc1 
    lda #ch
    ldy #0
    sta (print_char_cursor),y
    // *(print_char_cursor++) = ch;
    // [69] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz2 
    lda.z print_char_cursor
    clc
    adc #1
    sta.z print_char_cursor_10
    lda.z print_char_cursor+1
    adc #0
    sta.z print_char_cursor_10+1
    // print_char::@return
    // }
    // [70] return 
    rts
}
  // print_word_decimal
// Print a word as DECIMAL
// print_word_decimal(word zeropage($d) w)
print_word_decimal: {
    .label w = $d
    // utoa(w, decimal_digits, DECIMAL)
    // [72] (word) utoa::value#1 ← (word) print_word_decimal::w#3 -- vwuz1=vwuz2 
    lda.z w
    sta.z utoa.value
    lda.z w+1
    sta.z utoa.value+1
    // [73] call utoa 
    // [84] phi from print_word_decimal to utoa [phi:print_word_decimal->utoa]
    jsr utoa
    // [74] phi from print_word_decimal to print_word_decimal::@1 [phi:print_word_decimal->print_word_decimal::@1]
    // print_word_decimal::@1
    // print_str(decimal_digits)
    // [75] call print_str 
    // [77] phi from print_word_decimal::@1 to print_str [phi:print_word_decimal::@1->print_str]
    // [77] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#58 [phi:print_word_decimal::@1->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const byte[6]) decimal_digits [phi:print_word_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta.z print_str.str
    lda #>decimal_digits
    sta.z print_str.str+1
    jsr print_str
    // print_word_decimal::@return
    // }
    // [76] return 
    rts
}
  // print_str
// Print a zero-terminated string
// print_str(byte* zeropage($f) str)
print_str: {
    .label str = $f
    // [78] phi from print_str print_str::@2 to print_str::@1 [phi:print_str/print_str::@2->print_str::@1]
    // [78] phi (byte*) print_char_cursor#2 = (byte*) print_char_cursor#66 [phi:print_str/print_str::@2->print_str::@1#0] -- register_copy 
    // [78] phi (byte*) print_str::str#8 = (byte*) print_str::str#10 [phi:print_str/print_str::@2->print_str::@1#1] -- register_copy 
    // print_str::@1
  b1:
    // while(*str)
    // [79] if((byte) 0!=*((byte*) print_str::str#8)) goto print_str::@2 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (str),y
    cmp #0
    bne b2
    // print_str::@return
    // }
    // [80] return 
    rts
    // print_str::@2
  b2:
    // *(print_char_cursor++) = *(str++)
    // [81] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) -- _deref_pbuz1=_deref_pbuz2 
    ldy #0
    lda (str),y
    sta (print_char_cursor),y
    // *(print_char_cursor++) = *(str++);
    // [82] (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz1 
    inc.z print_char_cursor
    bne !+
    inc.z print_char_cursor+1
  !:
    // [83] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#8 -- pbuz1=_inc_pbuz1 
    inc.z str
    bne !+
    inc.z str+1
  !:
    jmp b1
}
  // utoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// utoa(word zeropage(2) value, byte* zeropage(4) buffer)
utoa: {
    .const max_digits = 5
    .label digit_value = $19
    .label buffer = 4
    .label digit = 8
    .label value = 2
    // [85] phi from utoa to utoa::@1 [phi:utoa->utoa::@1]
    // [85] phi (byte*) utoa::buffer#11 = (const byte[6]) decimal_digits [phi:utoa->utoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta.z buffer
    lda #>decimal_digits
    sta.z buffer+1
    // [85] phi (byte) utoa::started#2 = (byte) 0 [phi:utoa->utoa::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [85] phi (word) utoa::value#2 = (word) utoa::value#1 [phi:utoa->utoa::@1#2] -- register_copy 
    // [85] phi (byte) utoa::digit#2 = (byte) 0 [phi:utoa->utoa::@1#3] -- vbuz1=vbuc1 
    txa
    sta.z digit
    // utoa::@1
  b1:
    // for( char digit=0; digit<max_digits-1; digit++ )
    // [86] if((byte) utoa::digit#2<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z digit
    cmp #max_digits-1
    bcc b2
    // utoa::@3
    // (char)value
    // [87] (byte~) utoa::$4 ← (byte)(word) utoa::value#2 -- vbuaa=_byte_vwuz1 
    lda.z value
    // *buffer++ = DIGITS[(char)value]
    // [88] *((byte*) utoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) utoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // *buffer++ = DIGITS[(char)value];
    // [89] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer
    bne !+
    inc.z buffer+1
  !:
    // *buffer = 0
    // [90] *((byte*) utoa::buffer#3) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (buffer),y
    // utoa::@return
    // }
    // [91] return 
    rts
    // utoa::@2
  b2:
    // digit_value = digit_values[digit]
    // [92] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z digit
    asl
    // [93] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES + (byte~) utoa::$11) -- vwuz1=pwuc1_derefidx_vbuaa 
    tay
    lda RADIX_DECIMAL_VALUES,y
    sta.z digit_value
    lda RADIX_DECIMAL_VALUES+1,y
    sta.z digit_value+1
    // if (started || value >= digit_value)
    // [94] if((byte) 0!=(byte) utoa::started#2) goto utoa::@5 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne b5
    // utoa::@7
    // [95] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@5 -- vwuz1_ge_vwuz2_then_la1 
    cmp.z value+1
    bne !+
    lda.z digit_value
    cmp.z value
    beq b5
  !:
    bcc b5
    // [96] phi from utoa::@7 to utoa::@4 [phi:utoa::@7->utoa::@4]
    // [96] phi (byte*) utoa::buffer#14 = (byte*) utoa::buffer#11 [phi:utoa::@7->utoa::@4#0] -- register_copy 
    // [96] phi (byte) utoa::started#4 = (byte) utoa::started#2 [phi:utoa::@7->utoa::@4#1] -- register_copy 
    // [96] phi (word) utoa::value#6 = (word) utoa::value#2 [phi:utoa::@7->utoa::@4#2] -- register_copy 
    // utoa::@4
  b4:
    // for( char digit=0; digit<max_digits-1; digit++ )
    // [97] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc.z digit
    // [85] phi from utoa::@4 to utoa::@1 [phi:utoa::@4->utoa::@1]
    // [85] phi (byte*) utoa::buffer#11 = (byte*) utoa::buffer#14 [phi:utoa::@4->utoa::@1#0] -- register_copy 
    // [85] phi (byte) utoa::started#2 = (byte) utoa::started#4 [phi:utoa::@4->utoa::@1#1] -- register_copy 
    // [85] phi (word) utoa::value#2 = (word) utoa::value#6 [phi:utoa::@4->utoa::@1#2] -- register_copy 
    // [85] phi (byte) utoa::digit#2 = (byte) utoa::digit#1 [phi:utoa::@4->utoa::@1#3] -- register_copy 
    jmp b1
    // utoa::@5
  b5:
    // utoa_append(buffer++, value, digit_value)
    // [98] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11
    // [99] (word) utoa_append::value#0 ← (word) utoa::value#2
    // [100] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0
    // [101] call utoa_append 
    // [105] phi from utoa::@5 to utoa_append [phi:utoa::@5->utoa_append]
    jsr utoa_append
    // utoa_append(buffer++, value, digit_value)
    // [102] (word) utoa_append::return#0 ← (word) utoa_append::value#2
    // utoa::@6
    // value = utoa_append(buffer++, value, digit_value)
    // [103] (word) utoa::value#0 ← (word) utoa_append::return#0
    // value = utoa_append(buffer++, value, digit_value);
    // [104] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer
    bne !+
    inc.z buffer+1
  !:
    // [96] phi from utoa::@6 to utoa::@4 [phi:utoa::@6->utoa::@4]
    // [96] phi (byte*) utoa::buffer#14 = (byte*) utoa::buffer#4 [phi:utoa::@6->utoa::@4#0] -- register_copy 
    // [96] phi (byte) utoa::started#4 = (byte) 1 [phi:utoa::@6->utoa::@4#1] -- vbuxx=vbuc1 
    ldx #1
    // [96] phi (word) utoa::value#6 = (word) utoa::value#0 [phi:utoa::@6->utoa::@4#2] -- register_copy 
    jmp b4
}
  // utoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// utoa_append(byte* zeropage(4) buffer, word zeropage(2) value, word zeropage($19) sub)
utoa_append: {
    .label buffer = 4
    .label value = 2
    .label sub = $19
    .label return = 2
    // [106] phi from utoa_append to utoa_append::@1 [phi:utoa_append->utoa_append::@1]
    // [106] phi (byte) utoa_append::digit#2 = (byte) 0 [phi:utoa_append->utoa_append::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [106] phi (word) utoa_append::value#2 = (word) utoa_append::value#0 [phi:utoa_append->utoa_append::@1#1] -- register_copy 
    // utoa_append::@1
  b1:
    // while (value >= sub)
    // [107] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 -- vwuz1_ge_vwuz2_then_la1 
    lda.z sub+1
    cmp.z value+1
    bne !+
    lda.z sub
    cmp.z value
    beq b2
  !:
    bcc b2
    // utoa_append::@3
    // *buffer = DIGITS[digit]
    // [108] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) utoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda DIGITS,x
    ldy #0
    sta (buffer),y
    // utoa_append::@return
    // }
    // [109] return 
    rts
    // utoa_append::@2
  b2:
    // digit++;
    // [110] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2 -- vbuxx=_inc_vbuxx 
    inx
    // value -= sub
    // [111] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 -- vwuz1=vwuz1_minus_vwuz2 
    lda.z value
    sec
    sbc.z sub
    sta.z value
    lda.z value+1
    sbc.z sub+1
    sta.z value+1
    // [106] phi from utoa_append::@2 to utoa_append::@1 [phi:utoa_append::@2->utoa_append::@1]
    // [106] phi (byte) utoa_append::digit#2 = (byte) utoa_append::digit#1 [phi:utoa_append::@2->utoa_append::@1#0] -- register_copy 
    // [106] phi (word) utoa_append::value#2 = (word) utoa_append::value#1 [phi:utoa_append::@2->utoa_append::@1#1] -- register_copy 
    jmp b1
}
  // print_ln
// Print a newline
print_ln: {
    // [113] phi from print_ln print_ln::@1 to print_ln::@1 [phi:print_ln/print_ln::@1->print_ln::@1]
    // [113] phi (byte*) print_line_cursor#11 = (byte*) print_line_cursor#21 [phi:print_ln/print_ln::@1->print_ln::@1#0] -- register_copy 
    // print_ln::@1
  b1:
    // print_line_cursor + $28
    // [114] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z print_line_cursor
    sta.z print_line_cursor
    bcc !+
    inc.z print_line_cursor+1
  !:
    // while (print_line_cursor<print_char_cursor)
    // [115] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 -- pbuz1_lt_pbuz2_then_la1 
    lda.z print_line_cursor+1
    cmp.z print_char_cursor+1
    bcc b1
    bne !+
    lda.z print_line_cursor
    cmp.z print_char_cursor
    bcc b1
  !:
    // print_ln::@return
    // }
    // [116] return 
    rts
}
  // print_dword_decimal
// Print a dword as DECIMAL
// print_dword_decimal(dword zeropage(9) w)
print_dword_decimal: {
    .label w = 9
    // ultoa(w, decimal_digits_long, DECIMAL)
    // [117] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0
    // [118] call ultoa 
    // [122] phi from print_dword_decimal to ultoa [phi:print_dword_decimal->ultoa]
    jsr ultoa
    // [119] phi from print_dword_decimal to print_dword_decimal::@1 [phi:print_dword_decimal->print_dword_decimal::@1]
    // print_dword_decimal::@1
    // print_str(decimal_digits_long)
    // [120] call print_str 
    // [77] phi from print_dword_decimal::@1 to print_str [phi:print_dword_decimal::@1->print_str]
    // [77] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:print_dword_decimal::@1->print_str#0] -- register_copy 
    // [77] phi (byte*) print_str::str#10 = (const byte[$b]) decimal_digits_long [phi:print_dword_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta.z print_str.str
    lda #>decimal_digits_long
    sta.z print_str.str+1
    jsr print_str
    // print_dword_decimal::@return
    // }
    // [121] return 
    rts
}
  // ultoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// ultoa(dword zeropage(9) value, byte* zeropage($d) buffer)
ultoa: {
    .const max_digits = $a
    .label digit_value = $15
    .label buffer = $d
    .label digit = 8
    .label value = 9
    // [123] phi from ultoa to ultoa::@1 [phi:ultoa->ultoa::@1]
    // [123] phi (byte*) ultoa::buffer#11 = (const byte[$b]) decimal_digits_long [phi:ultoa->ultoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta.z buffer
    lda #>decimal_digits_long
    sta.z buffer+1
    // [123] phi (byte) ultoa::started#2 = (byte) 0 [phi:ultoa->ultoa::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [123] phi (dword) ultoa::value#2 = (dword) ultoa::value#1 [phi:ultoa->ultoa::@1#2] -- register_copy 
    // [123] phi (byte) ultoa::digit#2 = (byte) 0 [phi:ultoa->ultoa::@1#3] -- vbuz1=vbuc1 
    txa
    sta.z digit
    // ultoa::@1
  b1:
    // for( char digit=0; digit<max_digits-1; digit++ )
    // [124] if((byte) ultoa::digit#2<(const byte) ultoa::max_digits#1-(byte) 1) goto ultoa::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z digit
    cmp #max_digits-1
    bcc b2
    // ultoa::@3
    // (char)value
    // [125] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#2 -- vbuaa=_byte_vduz1 
    lda.z value
    // *buffer++ = DIGITS[(char)value]
    // [126] *((byte*) ultoa::buffer#11) ← *((const byte[]) DIGITS + (byte~) ultoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // *buffer++ = DIGITS[(char)value];
    // [127] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer
    bne !+
    inc.z buffer+1
  !:
    // *buffer = 0
    // [128] *((byte*) ultoa::buffer#3) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (buffer),y
    // ultoa::@return
    // }
    // [129] return 
    rts
    // ultoa::@2
  b2:
    // digit_value = digit_values[digit]
    // [130] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 -- vbuaa=vbuz1_rol_2 
    lda.z digit
    asl
    asl
    // [131] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG + (byte~) ultoa::$11) -- vduz1=pduc1_derefidx_vbuaa 
    tay
    lda RADIX_DECIMAL_VALUES_LONG,y
    sta.z digit_value
    lda RADIX_DECIMAL_VALUES_LONG+1,y
    sta.z digit_value+1
    lda RADIX_DECIMAL_VALUES_LONG+2,y
    sta.z digit_value+2
    lda RADIX_DECIMAL_VALUES_LONG+3,y
    sta.z digit_value+3
    // if (started || value >= digit_value)
    // [132] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@5 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne b5
    // ultoa::@7
    // [133] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@5 -- vduz1_ge_vduz2_then_la1 
    lda.z value+3
    cmp.z digit_value+3
    bcc !+
    bne b5
    lda.z value+2
    cmp.z digit_value+2
    bcc !+
    bne b5
    lda.z value+1
    cmp.z digit_value+1
    bcc !+
    bne b5
    lda.z value
    cmp.z digit_value
    bcs b5
  !:
    // [134] phi from ultoa::@7 to ultoa::@4 [phi:ultoa::@7->ultoa::@4]
    // [134] phi (byte*) ultoa::buffer#14 = (byte*) ultoa::buffer#11 [phi:ultoa::@7->ultoa::@4#0] -- register_copy 
    // [134] phi (byte) ultoa::started#4 = (byte) ultoa::started#2 [phi:ultoa::@7->ultoa::@4#1] -- register_copy 
    // [134] phi (dword) ultoa::value#6 = (dword) ultoa::value#2 [phi:ultoa::@7->ultoa::@4#2] -- register_copy 
    // ultoa::@4
  b4:
    // for( char digit=0; digit<max_digits-1; digit++ )
    // [135] (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc.z digit
    // [123] phi from ultoa::@4 to ultoa::@1 [phi:ultoa::@4->ultoa::@1]
    // [123] phi (byte*) ultoa::buffer#11 = (byte*) ultoa::buffer#14 [phi:ultoa::@4->ultoa::@1#0] -- register_copy 
    // [123] phi (byte) ultoa::started#2 = (byte) ultoa::started#4 [phi:ultoa::@4->ultoa::@1#1] -- register_copy 
    // [123] phi (dword) ultoa::value#2 = (dword) ultoa::value#6 [phi:ultoa::@4->ultoa::@1#2] -- register_copy 
    // [123] phi (byte) ultoa::digit#2 = (byte) ultoa::digit#1 [phi:ultoa::@4->ultoa::@1#3] -- register_copy 
    jmp b1
    // ultoa::@5
  b5:
    // ultoa_append(buffer++, value, digit_value)
    // [136] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11
    // [137] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2
    // [138] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0
    // [139] call ultoa_append 
    // [143] phi from ultoa::@5 to ultoa_append [phi:ultoa::@5->ultoa_append]
    jsr ultoa_append
    // ultoa_append(buffer++, value, digit_value)
    // [140] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2
    // ultoa::@6
    // value = ultoa_append(buffer++, value, digit_value)
    // [141] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0
    // value = ultoa_append(buffer++, value, digit_value);
    // [142] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc.z buffer
    bne !+
    inc.z buffer+1
  !:
    // [134] phi from ultoa::@6 to ultoa::@4 [phi:ultoa::@6->ultoa::@4]
    // [134] phi (byte*) ultoa::buffer#14 = (byte*) ultoa::buffer#4 [phi:ultoa::@6->ultoa::@4#0] -- register_copy 
    // [134] phi (byte) ultoa::started#4 = (byte) 1 [phi:ultoa::@6->ultoa::@4#1] -- vbuxx=vbuc1 
    ldx #1
    // [134] phi (dword) ultoa::value#6 = (dword) ultoa::value#0 [phi:ultoa::@6->ultoa::@4#2] -- register_copy 
    jmp b4
}
  // ultoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// ultoa_append(byte* zeropage($d) buffer, dword zeropage(9) value, dword zeropage($15) sub)
ultoa_append: {
    .label buffer = $d
    .label value = 9
    .label sub = $15
    .label return = 9
    // [144] phi from ultoa_append to ultoa_append::@1 [phi:ultoa_append->ultoa_append::@1]
    // [144] phi (byte) ultoa_append::digit#2 = (byte) 0 [phi:ultoa_append->ultoa_append::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [144] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#0 [phi:ultoa_append->ultoa_append::@1#1] -- register_copy 
    // ultoa_append::@1
  b1:
    // while (value >= sub)
    // [145] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 -- vduz1_ge_vduz2_then_la1 
    lda.z value+3
    cmp.z sub+3
    bcc !+
    bne b2
    lda.z value+2
    cmp.z sub+2
    bcc !+
    bne b2
    lda.z value+1
    cmp.z sub+1
    bcc !+
    bne b2
    lda.z value
    cmp.z sub
    bcs b2
  !:
    // ultoa_append::@3
    // *buffer = DIGITS[digit]
    // [146] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS + (byte) ultoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda DIGITS,x
    ldy #0
    sta (buffer),y
    // ultoa_append::@return
    // }
    // [147] return 
    rts
    // ultoa_append::@2
  b2:
    // digit++;
    // [148] (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2 -- vbuxx=_inc_vbuxx 
    inx
    // value -= sub
    // [149] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 -- vduz1=vduz1_minus_vduz2 
    lda.z value
    sec
    sbc.z sub
    sta.z value
    lda.z value+1
    sbc.z sub+1
    sta.z value+1
    lda.z value+2
    sbc.z sub+2
    sta.z value+2
    lda.z value+3
    sbc.z sub+3
    sta.z value+3
    // [144] phi from ultoa_append::@2 to ultoa_append::@1 [phi:ultoa_append::@2->ultoa_append::@1]
    // [144] phi (byte) ultoa_append::digit#2 = (byte) ultoa_append::digit#1 [phi:ultoa_append::@2->ultoa_append::@1#0] -- register_copy 
    // [144] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#1 [phi:ultoa_append::@2->ultoa_append::@1#1] -- register_copy 
    jmp b1
}
  // div32u16u
// Divide unsigned 32-bit dword dividend with a 16-bit word divisor
// The 16-bit word remainder can be found in rem16u after the division
// div32u16u(dword zeropage(9) dividend)
div32u16u: {
    .label divisor = CLOCKS_PER_SEC/$64
    .label quotient_hi = $19
    .label quotient_lo = $13
    .label return = $15
    .label dividend = 9
    // divr16u(>dividend, divisor, 0)
    // [150] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 -- vwuz1=_hi_vduz2 
    lda.z dividend+2
    sta.z divr16u.dividend
    lda.z dividend+3
    sta.z divr16u.dividend+1
    // [151] call divr16u 
    // [161] phi from div32u16u to divr16u [phi:div32u16u->divr16u]
    // [161] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#1 [phi:div32u16u->divr16u#0] -- register_copy 
    // [161] phi (word) divr16u::rem#10 = (byte) 0 [phi:div32u16u->divr16u#1] -- vwuz1=vbuc1 
    lda #<0
    sta.z divr16u.rem
    sta.z divr16u.rem+1
    jsr divr16u
    // divr16u(>dividend, divisor, 0)
    // [152] (word) divr16u::return#2 ← (word) divr16u::return#0
    // div32u16u::@1
    // quotient_hi = divr16u(>dividend, divisor, 0)
    // [153] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 -- vwuz1=vwuz2 
    lda.z divr16u.return
    sta.z quotient_hi
    lda.z divr16u.return+1
    sta.z quotient_hi+1
    // divr16u(<dividend, divisor, rem16u)
    // [154] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 -- vwuz1=_lo_vduz2 
    lda.z dividend
    sta.z divr16u.dividend
    lda.z dividend+1
    sta.z divr16u.dividend+1
    // [155] (word) divr16u::rem#4 ← (word) rem16u#1
    // [156] call divr16u 
    // [161] phi from div32u16u::@1 to divr16u [phi:div32u16u::@1->divr16u]
    // [161] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#2 [phi:div32u16u::@1->divr16u#0] -- register_copy 
    // [161] phi (word) divr16u::rem#10 = (word) divr16u::rem#4 [phi:div32u16u::@1->divr16u#1] -- register_copy 
    jsr divr16u
    // divr16u(<dividend, divisor, rem16u)
    // [157] (word) divr16u::return#3 ← (word) divr16u::return#0
    // div32u16u::@2
    // quotient_lo = divr16u(<dividend, divisor, rem16u)
    // [158] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3
    // quotient = { quotient_hi, quotient_lo}
    // [159] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 -- vduz1=vwuz2_dword_vwuz3 
    lda.z quotient_hi
    sta.z return+2
    lda.z quotient_hi+1
    sta.z return+3
    lda.z quotient_lo
    sta.z return
    lda.z quotient_lo+1
    sta.z return+1
    // div32u16u::@return
    // }
    // [160] return 
    rts
}
  // divr16u
// Performs division on two 16 bit unsigned words and an initial remainder
// Returns the quotient dividend/divisor.
// The final remainder will be set into the global variable rem16u
// Implemented using simple binary division
// divr16u(word zeropage($11) dividend, word zeropage($f) rem)
divr16u: {
    .label rem = $f
    .label dividend = $11
    .label quotient = $13
    .label return = $13
    // [162] phi from divr16u to divr16u::@1 [phi:divr16u->divr16u::@1]
    // [162] phi (byte) divr16u::i#2 = (byte) 0 [phi:divr16u->divr16u::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [162] phi (word) divr16u::quotient#3 = (byte) 0 [phi:divr16u->divr16u::@1#1] -- vwuz1=vbuc1 
    txa
    sta.z quotient
    sta.z quotient+1
    // [162] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#5 [phi:divr16u->divr16u::@1#2] -- register_copy 
    // [162] phi (word) divr16u::rem#5 = (word) divr16u::rem#10 [phi:divr16u->divr16u::@1#3] -- register_copy 
    // [162] phi from divr16u::@3 to divr16u::@1 [phi:divr16u::@3->divr16u::@1]
    // [162] phi (byte) divr16u::i#2 = (byte) divr16u::i#1 [phi:divr16u::@3->divr16u::@1#0] -- register_copy 
    // [162] phi (word) divr16u::quotient#3 = (word) divr16u::return#0 [phi:divr16u::@3->divr16u::@1#1] -- register_copy 
    // [162] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#0 [phi:divr16u::@3->divr16u::@1#2] -- register_copy 
    // [162] phi (word) divr16u::rem#5 = (word) divr16u::rem#11 [phi:divr16u::@3->divr16u::@1#3] -- register_copy 
    // divr16u::@1
  b1:
    // rem = rem << 1
    // [163] (word) divr16u::rem#0 ← (word) divr16u::rem#5 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z rem
    rol.z rem+1
    // >dividend
    // [164] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 -- vbuaa=_hi_vwuz1 
    lda.z dividend+1
    // >dividend & $80
    // [165] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // if( (>dividend & $80) != 0 )
    // [166] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b2
    // divr16u::@4
    // rem = rem | 1
    // [167] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 -- vwuz1=vwuz1_bor_vbuc1 
    lda #1
    ora.z rem
    sta.z rem
    // [168] phi from divr16u::@1 divr16u::@4 to divr16u::@2 [phi:divr16u::@1/divr16u::@4->divr16u::@2]
    // [168] phi (word) divr16u::rem#6 = (word) divr16u::rem#0 [phi:divr16u::@1/divr16u::@4->divr16u::@2#0] -- register_copy 
    // divr16u::@2
  b2:
    // dividend = dividend << 1
    // [169] (word) divr16u::dividend#0 ← (word) divr16u::dividend#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z dividend
    rol.z dividend+1
    // quotient = quotient << 1
    // [170] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z quotient
    rol.z quotient+1
    // if(rem>=divisor)
    // [171] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 -- vwuz1_lt_vwuc1_then_la1 
    lda.z rem+1
    cmp #>div32u16u.divisor
    bcc b3
    bne !+
    lda.z rem
    cmp #<div32u16u.divisor
    bcc b3
  !:
    // divr16u::@5
    // quotient++;
    // [172] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1 -- vwuz1=_inc_vwuz1 
    inc.z quotient
    bne !+
    inc.z quotient+1
  !:
    // rem = rem - divisor
    // [173] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 -- vwuz1=vwuz1_minus_vwuc1 
    lda.z rem
    sec
    sbc #<div32u16u.divisor
    sta.z rem
    lda.z rem+1
    sbc #>div32u16u.divisor
    sta.z rem+1
    // [174] phi from divr16u::@2 divr16u::@5 to divr16u::@3 [phi:divr16u::@2/divr16u::@5->divr16u::@3]
    // [174] phi (word) divr16u::return#0 = (word) divr16u::quotient#1 [phi:divr16u::@2/divr16u::@5->divr16u::@3#0] -- register_copy 
    // [174] phi (word) divr16u::rem#11 = (word) divr16u::rem#6 [phi:divr16u::@2/divr16u::@5->divr16u::@3#1] -- register_copy 
    // divr16u::@3
  b3:
    // for( byte i : 0..15)
    // [175] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [176] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$10
    bne b1
    // divr16u::@6
    // rem16u = rem
    // [177] (word) rem16u#1 ← (word) divr16u::rem#11
    // divr16u::@return
    // }
    // [178] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = 9
    // 0xffffffff - *CIA2_TIMER_AB
    // [179] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta.z return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta.z return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta.z return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta.z return+3
    // clock::@return
    // }
    // [180] return 
    rts
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // *CIA2_TIMER_A_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [181] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #CIA_TIMER_CONTROL_CONTINUOUS
    sta CIA2_TIMER_A_CONTROL
    // *CIA2_TIMER_B_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [182] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // *CIA2_TIMER_AB = 0xffffffff
    // [183] *((const dword*) CIA2_TIMER_AB) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // *CIA2_TIMER_B_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [184] *((const byte*) CIA2_TIMER_B_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // *CIA2_TIMER_A_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [185] *((const byte*) CIA2_TIMER_A_CONTROL) ← (const byte) CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2_TIMER_A_CONTROL
    // clock_start::@return
    // }
    // [186] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zeropage($11) str, byte register(X) c, word zeropage($f) num)
memset: {
    .label end = $f
    .label dst = $11
    .label num = $f
    .label str = $11
    // if(num>0)
    // [188] if((word) memset::num#2<=(byte) 0) goto memset::@return -- vwuz1_le_0_then_la1 
    lda.z num
    bne !+
    lda.z num+1
    beq breturn
  !:
    // memset::@1
    // end = (char*)str + num
    // [189] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 -- pbuz1=pbuz2_plus_vwuz1 
    lda.z end
    clc
    adc.z str
    sta.z end
    lda.z end+1
    adc.z str+1
    sta.z end+1
    // [190] (byte*~) memset::dst#4 ← (byte*)(void*) memset::str#3
    // [191] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
    // [191] phi (byte*) memset::dst#2 = (byte*~) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    // memset::@2
  b2:
    // for(char* dst = str; dst!=end; dst++)
    // [192] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne b3
    lda.z dst
    cmp.z end
    bne b3
    // memset::@return
  breturn:
    // }
    // [193] return 
    rts
    // memset::@3
  b3:
    // *dst = c
    // [194] *((byte*) memset::dst#2) ← (byte) memset::c#4 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [195] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp b2
}
  // print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    // memset(print_screen, ' ', 1000)
    // [197] call memset 
    // [187] phi from print_cls to memset [phi:print_cls->memset]
    // [187] phi (byte) memset::c#4 = (byte) ' ' [phi:print_cls->memset#0] -- vbuxx=vbuc1 
    ldx #' '
    // [187] phi (void*) memset::str#3 = (void*)(byte*) 1024 [phi:print_cls->memset#1] -- pvoz1=pvoc1 
    lda #<$400
    sta.z memset.str
    lda #>$400
    sta.z memset.str+1
    // [187] phi (word) memset::num#2 = (word) $3e8 [phi:print_cls->memset#2] -- vwuz1=vwuc1 
    lda #<$3e8
    sta.z memset.num
    lda #>$3e8
    sta.z memset.num+1
    jsr memset
    // print_cls::@return
    // }
    // [198] return 
    rts
}
  // File Data
  // The digits used for numbers
  DIGITS: .text "0123456789abcdef"
  // Values of decimal digits
  RADIX_DECIMAL_VALUES: .word $2710, $3e8, $64, $a
  // Values of decimal digits
  RADIX_DECIMAL_VALUES_LONG: .dword $3b9aca00, $5f5e100, $989680, $f4240, $186a0, $2710, $3e8, $64, $a
  // Digits used for storing the decimal word
  decimal_digits: .fill 6, 0
  // Digits used for storing the decimal word
  decimal_digits_long: .fill $b, 0

