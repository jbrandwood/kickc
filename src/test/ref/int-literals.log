Resolving typeid() testSimpleTypes::$0 = typeid  $c
Resolving typeid() testSimpleTypes::$2 = typeid  $c
Resolving typeid() testSimpleTypes::$4 = typeid  $c
Resolving typeid() testSimpleTypes::$6 = typeid  $c
Resolving typeid() testSimpleTypes::$8 = typeid  $c
Resolving typeid() testSimpleTypes::$10 = typeid  $c
Resolving typeid() testSimpleTypes::$12 = typeid  $c
Resolving typeid() testSimpleTypes::$14 = typeid  $c
Resolving typeid() testSimpleTypes::$16 = typeid  $c
Resolving typeid() testSimpleTypes::$18 = typeid  $c
Resolving typeid() testSimpleTypes::$20 = typeid  $c
Resolving typeid() testSimpleTypes::$22 = typeid  $c
Resolving typeid() testSimpleTypes::$24 = typeid  $c
Resolving typeid() testSimpleTypes::$26 = typeid  $c
Resolving typeid() testSimpleTypes::$28 = typeid  $c
Inlined call call __init 

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  idx#52 = phi( __start::@1/idx#50 )
  main::s#0 = SCREEN
  to:main::@1
main::@1: scope:[main]  from main main::@2
  idx#51 = phi( main/idx#52, main::@2/idx#53 )
  main::s#2 = phi( main/main::s#0, main::@2/main::s#1 )
  main::$1 = main::s#2 < SCREEN+$3e8
  if(main::$1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  idx#53 = phi( main::@1/idx#51 )
  main::s#3 = phi( main::@1/main::s#2 )
  *main::s#3 = ' '
  main::s#1 = ++ main::s#3
  to:main::@1
main::@3: scope:[main]  from main::@1
  idx#48 = phi( main::@1/idx#51 )
  call testSimpleTypes 
  to:main::@4
main::@4: scope:[main]  from main::@3
  idx#24 = phi( main::@3/idx#18 )
  idx#0 = idx#24
  to:main::@return
main::@return: scope:[main]  from main::@4
  idx#25 = phi( main::@4/idx#0 )
  idx#1 = idx#25
  return 
  to:@return

void testSimpleTypes()
testSimpleTypes: scope:[testSimpleTypes]  from main::@3
  idx#2 = 0
  testSimpleTypes::$0 = TYPEID_BYTE
  assertType::t1#0 = testSimpleTypes::$0
  assertType::t2#0 = TYPEID_BYTE
  call assertType 
  to:testSimpleTypes::@1
testSimpleTypes::@1: scope:[testSimpleTypes]  from testSimpleTypes
  idx#26 = phi( testSimpleTypes/idx#20 )
  idx#3 = idx#26
  testSimpleTypes::$2 = TYPEID_BYTE
  assertType::t1#1 = testSimpleTypes::$2
  assertType::t2#1 = TYPEID_BYTE
  call assertType 
  to:testSimpleTypes::@2
testSimpleTypes::@2: scope:[testSimpleTypes]  from testSimpleTypes::@1
  idx#27 = phi( testSimpleTypes::@1/idx#20 )
  idx#4 = idx#27
  testSimpleTypes::$4 = TYPEID_SIGNED_BYTE
  assertType::t1#2 = testSimpleTypes::$4
  assertType::t2#2 = TYPEID_SIGNED_BYTE
  call assertType 
  to:testSimpleTypes::@3
testSimpleTypes::@3: scope:[testSimpleTypes]  from testSimpleTypes::@2
  idx#28 = phi( testSimpleTypes::@2/idx#20 )
  idx#5 = idx#28
  testSimpleTypes::$6 = TYPEID_SIGNED_BYTE
  assertType::t1#3 = testSimpleTypes::$6
  assertType::t2#3 = TYPEID_SIGNED_BYTE
  call assertType 
  to:testSimpleTypes::@4
testSimpleTypes::@4: scope:[testSimpleTypes]  from testSimpleTypes::@3
  idx#29 = phi( testSimpleTypes::@3/idx#20 )
  idx#6 = idx#29
  testSimpleTypes::$8 = TYPEID_WORD
  assertType::t1#4 = testSimpleTypes::$8
  assertType::t2#4 = TYPEID_WORD
  call assertType 
  to:testSimpleTypes::@5
testSimpleTypes::@5: scope:[testSimpleTypes]  from testSimpleTypes::@4
  idx#30 = phi( testSimpleTypes::@4/idx#20 )
  idx#7 = idx#30
  testSimpleTypes::$10 = TYPEID_WORD
  assertType::t1#5 = testSimpleTypes::$10
  assertType::t2#5 = TYPEID_WORD
  call assertType 
  to:testSimpleTypes::@6
testSimpleTypes::@6: scope:[testSimpleTypes]  from testSimpleTypes::@5
  idx#31 = phi( testSimpleTypes::@5/idx#20 )
  idx#8 = idx#31
  testSimpleTypes::$12 = TYPEID_WORD
  assertType::t1#6 = testSimpleTypes::$12
  assertType::t2#6 = TYPEID_WORD
  call assertType 
  to:testSimpleTypes::@7
testSimpleTypes::@7: scope:[testSimpleTypes]  from testSimpleTypes::@6
  idx#32 = phi( testSimpleTypes::@6/idx#20 )
  idx#9 = idx#32
  testSimpleTypes::$14 = TYPEID_SIGNED_WORD
  assertType::t1#7 = testSimpleTypes::$14
  assertType::t2#7 = TYPEID_SIGNED_WORD
  call assertType 
  to:testSimpleTypes::@8
testSimpleTypes::@8: scope:[testSimpleTypes]  from testSimpleTypes::@7
  idx#33 = phi( testSimpleTypes::@7/idx#20 )
  idx#10 = idx#33
  testSimpleTypes::$16 = TYPEID_SIGNED_WORD
  assertType::t1#8 = testSimpleTypes::$16
  assertType::t2#8 = TYPEID_SIGNED_WORD
  call assertType 
  to:testSimpleTypes::@9
testSimpleTypes::@9: scope:[testSimpleTypes]  from testSimpleTypes::@8
  idx#34 = phi( testSimpleTypes::@8/idx#20 )
  idx#11 = idx#34
  testSimpleTypes::$18 = TYPEID_SIGNED_WORD
  assertType::t1#9 = testSimpleTypes::$18
  assertType::t2#9 = TYPEID_SIGNED_WORD
  call assertType 
  to:testSimpleTypes::@10
testSimpleTypes::@10: scope:[testSimpleTypes]  from testSimpleTypes::@9
  idx#35 = phi( testSimpleTypes::@9/idx#20 )
  idx#12 = idx#35
  testSimpleTypes::$20 = TYPEID_DWORD
  assertType::t1#10 = testSimpleTypes::$20
  assertType::t2#10 = TYPEID_DWORD
  call assertType 
  to:testSimpleTypes::@11
testSimpleTypes::@11: scope:[testSimpleTypes]  from testSimpleTypes::@10
  idx#36 = phi( testSimpleTypes::@10/idx#20 )
  idx#13 = idx#36
  testSimpleTypes::$22 = TYPEID_DWORD
  assertType::t1#11 = testSimpleTypes::$22
  assertType::t2#11 = TYPEID_DWORD
  call assertType 
  to:testSimpleTypes::@12
testSimpleTypes::@12: scope:[testSimpleTypes]  from testSimpleTypes::@11
  idx#37 = phi( testSimpleTypes::@11/idx#20 )
  idx#14 = idx#37
  testSimpleTypes::$24 = TYPEID_SIGNED_DWORD
  assertType::t1#12 = testSimpleTypes::$24
  assertType::t2#12 = TYPEID_SIGNED_DWORD
  call assertType 
  to:testSimpleTypes::@13
testSimpleTypes::@13: scope:[testSimpleTypes]  from testSimpleTypes::@12
  idx#38 = phi( testSimpleTypes::@12/idx#20 )
  idx#15 = idx#38
  testSimpleTypes::$26 = TYPEID_SIGNED_DWORD
  assertType::t1#13 = testSimpleTypes::$26
  assertType::t2#13 = TYPEID_SIGNED_DWORD
  call assertType 
  to:testSimpleTypes::@14
testSimpleTypes::@14: scope:[testSimpleTypes]  from testSimpleTypes::@13
  idx#39 = phi( testSimpleTypes::@13/idx#20 )
  idx#16 = idx#39
  testSimpleTypes::$28 = TYPEID_SIGNED_DWORD
  assertType::t1#14 = testSimpleTypes::$28
  assertType::t2#14 = TYPEID_SIGNED_DWORD
  call assertType 
  to:testSimpleTypes::@15
testSimpleTypes::@15: scope:[testSimpleTypes]  from testSimpleTypes::@14
  idx#40 = phi( testSimpleTypes::@14/idx#20 )
  idx#17 = idx#40
  to:testSimpleTypes::@return
testSimpleTypes::@return: scope:[testSimpleTypes]  from testSimpleTypes::@15
  idx#41 = phi( testSimpleTypes::@15/idx#17 )
  idx#18 = idx#41
  return 
  to:@return

void assertType(byte assertType::t1 , byte assertType::t2)
assertType: scope:[assertType]  from testSimpleTypes testSimpleTypes::@1 testSimpleTypes::@10 testSimpleTypes::@11 testSimpleTypes::@12 testSimpleTypes::@13 testSimpleTypes::@14 testSimpleTypes::@2 testSimpleTypes::@3 testSimpleTypes::@4 testSimpleTypes::@5 testSimpleTypes::@6 testSimpleTypes::@7 testSimpleTypes::@8 testSimpleTypes::@9
  idx#49 = phi( testSimpleTypes/idx#2, testSimpleTypes::@1/idx#3, testSimpleTypes::@10/idx#12, testSimpleTypes::@11/idx#13, testSimpleTypes::@12/idx#14, testSimpleTypes::@13/idx#15, testSimpleTypes::@14/idx#16, testSimpleTypes::@2/idx#4, testSimpleTypes::@3/idx#5, testSimpleTypes::@4/idx#6, testSimpleTypes::@5/idx#7, testSimpleTypes::@6/idx#8, testSimpleTypes::@7/idx#9, testSimpleTypes::@8/idx#10, testSimpleTypes::@9/idx#11 )
  assertType::t2#15 = phi( testSimpleTypes/assertType::t2#0, testSimpleTypes::@1/assertType::t2#1, testSimpleTypes::@10/assertType::t2#10, testSimpleTypes::@11/assertType::t2#11, testSimpleTypes::@12/assertType::t2#12, testSimpleTypes::@13/assertType::t2#13, testSimpleTypes::@14/assertType::t2#14, testSimpleTypes::@2/assertType::t2#2, testSimpleTypes::@3/assertType::t2#3, testSimpleTypes::@4/assertType::t2#4, testSimpleTypes::@5/assertType::t2#5, testSimpleTypes::@6/assertType::t2#6, testSimpleTypes::@7/assertType::t2#7, testSimpleTypes::@8/assertType::t2#8, testSimpleTypes::@9/assertType::t2#9 )
  assertType::t1#15 = phi( testSimpleTypes/assertType::t1#0, testSimpleTypes::@1/assertType::t1#1, testSimpleTypes::@10/assertType::t1#10, testSimpleTypes::@11/assertType::t1#11, testSimpleTypes::@12/assertType::t1#12, testSimpleTypes::@13/assertType::t1#13, testSimpleTypes::@14/assertType::t1#14, testSimpleTypes::@2/assertType::t1#2, testSimpleTypes::@3/assertType::t1#3, testSimpleTypes::@4/assertType::t1#4, testSimpleTypes::@5/assertType::t1#5, testSimpleTypes::@6/assertType::t1#6, testSimpleTypes::@7/assertType::t1#7, testSimpleTypes::@8/assertType::t1#8, testSimpleTypes::@9/assertType::t1#9 )
  assertType::$0 = assertType::t1#15 == assertType::t2#15
  if(assertType::$0) goto assertType::@1
  to:assertType::@3
assertType::@1: scope:[assertType]  from assertType
  assertType::t1#17 = phi( assertType/assertType::t1#15 )
  idx#42 = phi( assertType/idx#49 )
  COLS[idx#42] = GREEN
  to:assertType::@2
assertType::@3: scope:[assertType]  from assertType
  assertType::t1#18 = phi( assertType/assertType::t1#15 )
  idx#43 = phi( assertType/idx#49 )
  COLS[idx#43] = RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  idx#44 = phi( assertType::@1/idx#42, assertType::@3/idx#43 )
  assertType::t1#16 = phi( assertType::@1/assertType::t1#17, assertType::@3/assertType::t1#18 )
  SCREEN[idx#44] = assertType::t1#16
  idx#19 = ++ idx#44
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  idx#45 = phi( assertType::@2/idx#19 )
  idx#20 = idx#45
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  idx#21 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  idx#50 = phi( __start::__init1/idx#21 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  idx#46 = phi( __start::@1/idx#1 )
  idx#22 = idx#46
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  idx#47 = phi( __start::@2/idx#22 )
  idx#23 = idx#47
  return 
  to:@return

SYMBOL TABLE SSA
const nomodify byte* COLS = (byte*)$d800
const nomodify byte GREEN = 5
const nomodify byte RED = 2
const nomodify byte* SCREEN = (byte*)$400
const byte TYPEID_BYTE = 1
const byte TYPEID_DWORD = 5
const byte TYPEID_SIGNED_BYTE = 2
const byte TYPEID_SIGNED_DWORD = 6
const byte TYPEID_SIGNED_WORD = 4
const byte TYPEID_WORD = 3
void __start()
void assertType(byte assertType::t1 , byte assertType::t2)
bool~ assertType::$0
byte assertType::t1
byte assertType::t1#0
byte assertType::t1#1
byte assertType::t1#10
byte assertType::t1#11
byte assertType::t1#12
byte assertType::t1#13
byte assertType::t1#14
byte assertType::t1#15
byte assertType::t1#16
byte assertType::t1#17
byte assertType::t1#18
byte assertType::t1#2
byte assertType::t1#3
byte assertType::t1#4
byte assertType::t1#5
byte assertType::t1#6
byte assertType::t1#7
byte assertType::t1#8
byte assertType::t1#9
byte assertType::t2
byte assertType::t2#0
byte assertType::t2#1
byte assertType::t2#10
byte assertType::t2#11
byte assertType::t2#12
byte assertType::t2#13
byte assertType::t2#14
byte assertType::t2#15
byte assertType::t2#2
byte assertType::t2#3
byte assertType::t2#4
byte assertType::t2#5
byte assertType::t2#6
byte assertType::t2#7
byte assertType::t2#8
byte assertType::t2#9
byte idx
byte idx#0
byte idx#1
byte idx#10
byte idx#11
byte idx#12
byte idx#13
byte idx#14
byte idx#15
byte idx#16
byte idx#17
byte idx#18
byte idx#19
byte idx#2
byte idx#20
byte idx#21
byte idx#22
byte idx#23
byte idx#24
byte idx#25
byte idx#26
byte idx#27
byte idx#28
byte idx#29
byte idx#3
byte idx#30
byte idx#31
byte idx#32
byte idx#33
byte idx#34
byte idx#35
byte idx#36
byte idx#37
byte idx#38
byte idx#39
byte idx#4
byte idx#40
byte idx#41
byte idx#42
byte idx#43
byte idx#44
byte idx#45
byte idx#46
byte idx#47
byte idx#48
byte idx#49
byte idx#5
byte idx#50
byte idx#51
byte idx#52
byte idx#53
byte idx#6
byte idx#7
byte idx#8
byte idx#9
void main()
bool~ main::$1
byte* main::s
byte* main::s#0
byte* main::s#1
byte* main::s#2
byte* main::s#3
void testSimpleTypes()
byte~ testSimpleTypes::$0
byte~ testSimpleTypes::$10
byte~ testSimpleTypes::$12
byte~ testSimpleTypes::$14
byte~ testSimpleTypes::$16
byte~ testSimpleTypes::$18
byte~ testSimpleTypes::$2
byte~ testSimpleTypes::$20
byte~ testSimpleTypes::$22
byte~ testSimpleTypes::$24
byte~ testSimpleTypes::$26
byte~ testSimpleTypes::$28
byte~ testSimpleTypes::$4
byte~ testSimpleTypes::$6
byte~ testSimpleTypes::$8

Alias main::s#2 = main::s#3 
Alias idx#48 = idx#53 idx#51 
Alias idx#0 = idx#24 idx#25 idx#1 
Alias assertType::t1#0 = testSimpleTypes::$0 
Alias idx#26 = idx#3 
Alias assertType::t1#1 = testSimpleTypes::$2 
Alias idx#27 = idx#4 
Alias assertType::t1#2 = testSimpleTypes::$4 
Alias idx#28 = idx#5 
Alias assertType::t1#3 = testSimpleTypes::$6 
Alias idx#29 = idx#6 
Alias assertType::t1#4 = testSimpleTypes::$8 
Alias idx#30 = idx#7 
Alias assertType::t1#5 = testSimpleTypes::$10 
Alias idx#31 = idx#8 
Alias assertType::t1#6 = testSimpleTypes::$12 
Alias idx#32 = idx#9 
Alias assertType::t1#7 = testSimpleTypes::$14 
Alias idx#10 = idx#33 
Alias assertType::t1#8 = testSimpleTypes::$16 
Alias idx#11 = idx#34 
Alias assertType::t1#9 = testSimpleTypes::$18 
Alias idx#12 = idx#35 
Alias assertType::t1#10 = testSimpleTypes::$20 
Alias idx#13 = idx#36 
Alias assertType::t1#11 = testSimpleTypes::$22 
Alias idx#14 = idx#37 
Alias assertType::t1#12 = testSimpleTypes::$24 
Alias idx#15 = idx#38 
Alias assertType::t1#13 = testSimpleTypes::$26 
Alias idx#16 = idx#39 
Alias assertType::t1#14 = testSimpleTypes::$28 
Alias idx#17 = idx#40 idx#41 idx#18 
Alias idx#42 = idx#49 idx#43 
Alias assertType::t1#15 = assertType::t1#17 assertType::t1#18 
Alias idx#19 = idx#45 idx#20 
Alias idx#21 = idx#50 
Alias idx#22 = idx#46 idx#47 idx#23 
Successful SSA optimization Pass2AliasElimination
Alias assertType::t1#15 = assertType::t1#16 
Alias idx#42 = idx#44 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values idx#52 idx#21
Identical Phi Values idx#48 idx#52
Identical Phi Values idx#0 idx#17
Identical Phi Values idx#26 idx#19
Identical Phi Values idx#27 idx#19
Identical Phi Values idx#28 idx#19
Identical Phi Values idx#29 idx#19
Identical Phi Values idx#30 idx#19
Identical Phi Values idx#31 idx#19
Identical Phi Values idx#32 idx#19
Identical Phi Values idx#10 idx#19
Identical Phi Values idx#11 idx#19
Identical Phi Values idx#12 idx#19
Identical Phi Values idx#13 idx#19
Identical Phi Values idx#14 idx#19
Identical Phi Values idx#15 idx#19
Identical Phi Values idx#16 idx#19
Identical Phi Values idx#17 idx#19
Identical Phi Values idx#22 idx#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$1 [4] if(main::s#2<SCREEN+$3e8) goto main::@2
Simple Condition assertType::$0 [74] if(assertType::t1#15==assertType::t2#15) goto assertType::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant main::s#0 = SCREEN
Constant idx#2 = 0
Constant assertType::t1#0 = TYPEID_BYTE
Constant assertType::t2#0 = TYPEID_BYTE
Constant assertType::t1#1 = TYPEID_BYTE
Constant assertType::t2#1 = TYPEID_BYTE
Constant assertType::t1#2 = TYPEID_SIGNED_BYTE
Constant assertType::t2#2 = TYPEID_SIGNED_BYTE
Constant assertType::t1#3 = TYPEID_SIGNED_BYTE
Constant assertType::t2#3 = TYPEID_SIGNED_BYTE
Constant assertType::t1#4 = TYPEID_WORD
Constant assertType::t2#4 = TYPEID_WORD
Constant assertType::t1#5 = TYPEID_WORD
Constant assertType::t2#5 = TYPEID_WORD
Constant assertType::t1#6 = TYPEID_WORD
Constant assertType::t2#6 = TYPEID_WORD
Constant assertType::t1#7 = TYPEID_SIGNED_WORD
Constant assertType::t2#7 = TYPEID_SIGNED_WORD
Constant assertType::t1#8 = TYPEID_SIGNED_WORD
Constant assertType::t2#8 = TYPEID_SIGNED_WORD
Constant assertType::t1#9 = TYPEID_SIGNED_WORD
Constant assertType::t2#9 = TYPEID_SIGNED_WORD
Constant assertType::t1#10 = TYPEID_DWORD
Constant assertType::t2#10 = TYPEID_DWORD
Constant assertType::t1#11 = TYPEID_DWORD
Constant assertType::t2#11 = TYPEID_DWORD
Constant assertType::t1#12 = TYPEID_SIGNED_DWORD
Constant assertType::t2#12 = TYPEID_SIGNED_DWORD
Constant assertType::t1#13 = TYPEID_SIGNED_DWORD
Constant assertType::t2#13 = TYPEID_SIGNED_DWORD
Constant assertType::t1#14 = TYPEID_SIGNED_DWORD
Constant assertType::t2#14 = TYPEID_SIGNED_DWORD
Constant idx#21 = 0
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant idx#21
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings main::s#0
Inlining constant with var siblings assertType::t1#0
Inlining constant with var siblings assertType::t2#0
Inlining constant with var siblings assertType::t1#1
Inlining constant with var siblings assertType::t2#1
Inlining constant with var siblings assertType::t1#2
Inlining constant with var siblings assertType::t2#2
Inlining constant with var siblings assertType::t1#3
Inlining constant with var siblings assertType::t2#3
Inlining constant with var siblings assertType::t1#4
Inlining constant with var siblings assertType::t2#4
Inlining constant with var siblings assertType::t1#5
Inlining constant with var siblings assertType::t2#5
Inlining constant with var siblings assertType::t1#6
Inlining constant with var siblings assertType::t2#6
Inlining constant with var siblings assertType::t1#7
Inlining constant with var siblings assertType::t2#7
Inlining constant with var siblings assertType::t1#8
Inlining constant with var siblings assertType::t2#8
Inlining constant with var siblings assertType::t1#9
Inlining constant with var siblings assertType::t2#9
Inlining constant with var siblings assertType::t1#10
Inlining constant with var siblings assertType::t2#10
Inlining constant with var siblings assertType::t1#11
Inlining constant with var siblings assertType::t2#11
Inlining constant with var siblings assertType::t1#12
Inlining constant with var siblings assertType::t2#12
Inlining constant with var siblings assertType::t1#13
Inlining constant with var siblings assertType::t2#13
Inlining constant with var siblings assertType::t1#14
Inlining constant with var siblings assertType::t2#14
Inlining constant with var siblings idx#2
Constant inlined assertType::t2#5 = TYPEID_WORD
Constant inlined assertType::t1#6 = TYPEID_WORD
Constant inlined assertType::t2#6 = TYPEID_WORD
Constant inlined assertType::t1#7 = TYPEID_SIGNED_WORD
Constant inlined assertType::t2#7 = TYPEID_SIGNED_WORD
Constant inlined assertType::t1#8 = TYPEID_SIGNED_WORD
Constant inlined assertType::t2#8 = TYPEID_SIGNED_WORD
Constant inlined assertType::t1#9 = TYPEID_SIGNED_WORD
Constant inlined assertType::t2#9 = TYPEID_SIGNED_WORD
Constant inlined assertType::t2#11 = TYPEID_DWORD
Constant inlined assertType::t2#10 = TYPEID_DWORD
Constant inlined assertType::t2#13 = TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#12 = TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#14 = TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#0 = TYPEID_BYTE
Constant inlined idx#2 = 0
Constant inlined assertType::t2#0 = TYPEID_BYTE
Constant inlined assertType::t1#1 = TYPEID_BYTE
Constant inlined assertType::t2#1 = TYPEID_BYTE
Constant inlined assertType::t1#2 = TYPEID_SIGNED_BYTE
Constant inlined assertType::t2#2 = TYPEID_SIGNED_BYTE
Constant inlined assertType::t1#3 = TYPEID_SIGNED_BYTE
Constant inlined assertType::t2#3 = TYPEID_SIGNED_BYTE
Constant inlined assertType::t1#4 = TYPEID_WORD
Constant inlined assertType::t2#4 = TYPEID_WORD
Constant inlined assertType::t1#5 = TYPEID_WORD
Constant inlined main::s#0 = SCREEN
Constant inlined assertType::t1#10 = TYPEID_DWORD
Constant inlined assertType::t1#12 = TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#11 = TYPEID_DWORD
Constant inlined assertType::t1#14 = TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#13 = TYPEID_SIGNED_DWORD
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 6
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of testSimpleTypes
Adding NOP phi() at start of testSimpleTypes::@15
CALL GRAPH
Calls in [main] to testSimpleTypes:4 
Calls in [testSimpleTypes] to assertType:11 assertType:13 assertType:15 assertType:17 assertType:19 assertType:21 assertType:23 assertType:25 assertType:27 assertType:29 assertType:31 assertType:33 assertType:35 assertType:37 assertType:39 

Created 4 initial phi equivalence classes
Coalesced [9] main::s#4 = main::s#1
Coalesced [12] idx#54 = idx#19
Coalesced (already) [14] idx#60 = idx#19
Coalesced (already) [16] idx#61 = idx#19
Coalesced (already) [18] idx#62 = idx#19
Coalesced (already) [20] idx#63 = idx#19
Coalesced (already) [22] idx#64 = idx#19
Coalesced (already) [24] idx#65 = idx#19
Coalesced (already) [26] idx#66 = idx#19
Coalesced (already) [28] idx#67 = idx#19
Coalesced (already) [30] idx#55 = idx#19
Coalesced (already) [32] idx#56 = idx#19
Coalesced (already) [34] idx#57 = idx#19
Coalesced (already) [36] idx#58 = idx#19
Coalesced (already) [38] idx#59 = idx#19
Coalesced down to 4 phi equivalence classes
Culled Empty Block label main::@4
Culled Empty Block label testSimpleTypes::@15
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of testSimpleTypes
Adding NOP phi() at start of testSimpleTypes::@1
Adding NOP phi() at start of testSimpleTypes::@2
Adding NOP phi() at start of testSimpleTypes::@3
Adding NOP phi() at start of testSimpleTypes::@4
Adding NOP phi() at start of testSimpleTypes::@5
Adding NOP phi() at start of testSimpleTypes::@6
Adding NOP phi() at start of testSimpleTypes::@7
Adding NOP phi() at start of testSimpleTypes::@8
Adding NOP phi() at start of testSimpleTypes::@9
Adding NOP phi() at start of testSimpleTypes::@10
Adding NOP phi() at start of testSimpleTypes::@11
Adding NOP phi() at start of testSimpleTypes::@12
Adding NOP phi() at start of testSimpleTypes::@13
Adding NOP phi() at start of testSimpleTypes::@14

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [1] main::s#2 = phi( main/SCREEN, main::@2/main::s#1 )
  [2] if(main::s#2<SCREEN+$3e8) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [3] phi()
  [4] call testSimpleTypes 
  to:main::@return
main::@return: scope:[main]  from main::@3
  [5] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [6] *main::s#2 = ' '
  [7] main::s#1 = ++ main::s#2
  to:main::@1

void testSimpleTypes()
testSimpleTypes: scope:[testSimpleTypes]  from main::@3
  [8] phi()
  [9] call assertType 
  to:testSimpleTypes::@1
testSimpleTypes::@1: scope:[testSimpleTypes]  from testSimpleTypes
  [10] phi()
  [11] call assertType 
  to:testSimpleTypes::@2
testSimpleTypes::@2: scope:[testSimpleTypes]  from testSimpleTypes::@1
  [12] phi()
  [13] call assertType 
  to:testSimpleTypes::@3
testSimpleTypes::@3: scope:[testSimpleTypes]  from testSimpleTypes::@2
  [14] phi()
  [15] call assertType 
  to:testSimpleTypes::@4
testSimpleTypes::@4: scope:[testSimpleTypes]  from testSimpleTypes::@3
  [16] phi()
  [17] call assertType 
  to:testSimpleTypes::@5
testSimpleTypes::@5: scope:[testSimpleTypes]  from testSimpleTypes::@4
  [18] phi()
  [19] call assertType 
  to:testSimpleTypes::@6
testSimpleTypes::@6: scope:[testSimpleTypes]  from testSimpleTypes::@5
  [20] phi()
  [21] call assertType 
  to:testSimpleTypes::@7
testSimpleTypes::@7: scope:[testSimpleTypes]  from testSimpleTypes::@6
  [22] phi()
  [23] call assertType 
  to:testSimpleTypes::@8
testSimpleTypes::@8: scope:[testSimpleTypes]  from testSimpleTypes::@7
  [24] phi()
  [25] call assertType 
  to:testSimpleTypes::@9
testSimpleTypes::@9: scope:[testSimpleTypes]  from testSimpleTypes::@8
  [26] phi()
  [27] call assertType 
  to:testSimpleTypes::@10
testSimpleTypes::@10: scope:[testSimpleTypes]  from testSimpleTypes::@9
  [28] phi()
  [29] call assertType 
  to:testSimpleTypes::@11
testSimpleTypes::@11: scope:[testSimpleTypes]  from testSimpleTypes::@10
  [30] phi()
  [31] call assertType 
  to:testSimpleTypes::@12
testSimpleTypes::@12: scope:[testSimpleTypes]  from testSimpleTypes::@11
  [32] phi()
  [33] call assertType 
  to:testSimpleTypes::@13
testSimpleTypes::@13: scope:[testSimpleTypes]  from testSimpleTypes::@12
  [34] phi()
  [35] call assertType 
  to:testSimpleTypes::@14
testSimpleTypes::@14: scope:[testSimpleTypes]  from testSimpleTypes::@13
  [36] phi()
  [37] call assertType 
  to:testSimpleTypes::@return
testSimpleTypes::@return: scope:[testSimpleTypes]  from testSimpleTypes::@14
  [38] return 
  to:@return

void assertType(byte assertType::t1 , byte assertType::t2)
assertType: scope:[assertType]  from testSimpleTypes testSimpleTypes::@1 testSimpleTypes::@10 testSimpleTypes::@11 testSimpleTypes::@12 testSimpleTypes::@13 testSimpleTypes::@14 testSimpleTypes::@2 testSimpleTypes::@3 testSimpleTypes::@4 testSimpleTypes::@5 testSimpleTypes::@6 testSimpleTypes::@7 testSimpleTypes::@8 testSimpleTypes::@9
  [39] idx#42 = phi( testSimpleTypes/0, testSimpleTypes::@1/idx#19, testSimpleTypes::@10/idx#19, testSimpleTypes::@11/idx#19, testSimpleTypes::@12/idx#19, testSimpleTypes::@13/idx#19, testSimpleTypes::@14/idx#19, testSimpleTypes::@2/idx#19, testSimpleTypes::@3/idx#19, testSimpleTypes::@4/idx#19, testSimpleTypes::@5/idx#19, testSimpleTypes::@6/idx#19, testSimpleTypes::@7/idx#19, testSimpleTypes::@8/idx#19, testSimpleTypes::@9/idx#19 )
  [39] assertType::t2#15 = phi( testSimpleTypes/TYPEID_BYTE, testSimpleTypes::@1/TYPEID_BYTE, testSimpleTypes::@10/TYPEID_DWORD, testSimpleTypes::@11/TYPEID_DWORD, testSimpleTypes::@12/TYPEID_SIGNED_DWORD, testSimpleTypes::@13/TYPEID_SIGNED_DWORD, testSimpleTypes::@14/TYPEID_SIGNED_DWORD, testSimpleTypes::@2/TYPEID_SIGNED_BYTE, testSimpleTypes::@3/TYPEID_SIGNED_BYTE, testSimpleTypes::@4/TYPEID_WORD, testSimpleTypes::@5/TYPEID_WORD, testSimpleTypes::@6/TYPEID_WORD, testSimpleTypes::@7/TYPEID_SIGNED_WORD, testSimpleTypes::@8/TYPEID_SIGNED_WORD, testSimpleTypes::@9/TYPEID_SIGNED_WORD )
  [39] assertType::t1#15 = phi( testSimpleTypes/TYPEID_BYTE, testSimpleTypes::@1/TYPEID_BYTE, testSimpleTypes::@10/TYPEID_DWORD, testSimpleTypes::@11/TYPEID_DWORD, testSimpleTypes::@12/TYPEID_SIGNED_DWORD, testSimpleTypes::@13/TYPEID_SIGNED_DWORD, testSimpleTypes::@14/TYPEID_SIGNED_DWORD, testSimpleTypes::@2/TYPEID_SIGNED_BYTE, testSimpleTypes::@3/TYPEID_SIGNED_BYTE, testSimpleTypes::@4/TYPEID_WORD, testSimpleTypes::@5/TYPEID_WORD, testSimpleTypes::@6/TYPEID_WORD, testSimpleTypes::@7/TYPEID_SIGNED_WORD, testSimpleTypes::@8/TYPEID_SIGNED_WORD, testSimpleTypes::@9/TYPEID_SIGNED_WORD )
  [40] if(assertType::t1#15==assertType::t2#15) goto assertType::@1
  to:assertType::@3
assertType::@3: scope:[assertType]  from assertType
  [41] COLS[idx#42] = RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  [42] SCREEN[idx#42] = assertType::t1#15
  [43] idx#19 = ++ idx#42
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  [44] return 
  to:@return
assertType::@1: scope:[assertType]  from assertType
  [45] COLS[idx#42] = GREEN
  to:assertType::@2


VARIABLE REGISTER WEIGHTS
void assertType(byte assertType::t1 , byte assertType::t2)
byte assertType::t1
byte assertType::t1#15 50.5
byte assertType::t2
byte assertType::t2#15 101.0
byte idx
byte idx#19 8.499999999999998
byte idx#42 111.6
void main()
byte* main::s
byte* main::s#1 22.0
byte* main::s#2 14.666666666666666
void testSimpleTypes()

Initial phi equivalence classes
[ main::s#2 main::s#1 ]
[ assertType::t1#15 ]
[ assertType::t2#15 ]
[ idx#42 idx#19 ]
Complete equivalence classes
[ main::s#2 main::s#1 ]
[ assertType::t1#15 ]
[ assertType::t2#15 ]
[ idx#42 idx#19 ]
Allocated zp[2]:2 [ main::s#2 main::s#1 ]
Allocated zp[1]:4 [ assertType::t1#15 ]
Allocated zp[1]:5 [ assertType::t2#15 ]
Allocated zp[1]:6 [ idx#42 idx#19 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] if(main::s#2<SCREEN+$3e8) goto main::@2 [ main::s#2 ] (  [ main::s#2 ] { }  ) always clobbers reg byte a 
Statement [6] *main::s#2 = ' ' [ main::s#2 ] (  [ main::s#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [41] COLS[idx#42] = RED [ assertType::t1#15 idx#42 ] ( testSimpleTypes:4::assertType:9 [ assertType::t1#15 idx#42 ] { }  testSimpleTypes:4::assertType:11 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:13 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:15 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:17 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:19 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:21 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:23 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:25 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:27 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:29 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:31 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:33 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:35 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:37 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ assertType::t1#15 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ idx#42 idx#19 ]
Statement [42] SCREEN[idx#42] = assertType::t1#15 [ idx#42 ] ( testSimpleTypes:4::assertType:9 [ idx#42 ] { }  testSimpleTypes:4::assertType:11 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:13 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:15 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:17 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:19 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:21 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:23 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:25 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:27 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:29 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:31 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:33 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:35 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:37 [ idx#42 ] { { idx#19 = idx#42 } }  ) always clobbers reg byte a 
Statement [45] COLS[idx#42] = GREEN [ assertType::t1#15 idx#42 ] ( testSimpleTypes:4::assertType:9 [ assertType::t1#15 idx#42 ] { }  testSimpleTypes:4::assertType:11 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:13 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:15 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:17 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:19 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:21 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:23 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:25 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:27 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:29 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:31 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:33 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:35 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:37 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  ) always clobbers reg byte a 
Statement [2] if(main::s#2<SCREEN+$3e8) goto main::@2 [ main::s#2 ] (  [ main::s#2 ] { }  ) always clobbers reg byte a 
Statement [6] *main::s#2 = ' ' [ main::s#2 ] (  [ main::s#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [41] COLS[idx#42] = RED [ assertType::t1#15 idx#42 ] ( testSimpleTypes:4::assertType:9 [ assertType::t1#15 idx#42 ] { }  testSimpleTypes:4::assertType:11 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:13 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:15 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:17 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:19 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:21 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:23 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:25 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:27 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:29 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:31 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:33 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:35 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:37 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  ) always clobbers reg byte a 
Statement [42] SCREEN[idx#42] = assertType::t1#15 [ idx#42 ] ( testSimpleTypes:4::assertType:9 [ idx#42 ] { }  testSimpleTypes:4::assertType:11 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:13 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:15 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:17 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:19 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:21 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:23 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:25 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:27 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:29 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:31 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:33 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:35 [ idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:37 [ idx#42 ] { { idx#19 = idx#42 } }  ) always clobbers reg byte a 
Statement [45] COLS[idx#42] = GREEN [ assertType::t1#15 idx#42 ] ( testSimpleTypes:4::assertType:9 [ assertType::t1#15 idx#42 ] { }  testSimpleTypes:4::assertType:11 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:13 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:15 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:17 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:19 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:21 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:23 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:25 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:27 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:29 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:31 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:33 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:35 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  testSimpleTypes:4::assertType:37 [ assertType::t1#15 idx#42 ] { { idx#19 = idx#42 } }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ main::s#2 main::s#1 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ assertType::t1#15 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ assertType::t2#15 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ idx#42 idx#19 ] : zp[1]:6 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [assertType] 101: zp[1]:5 [ assertType::t2#15 ] 50.5: zp[1]:4 [ assertType::t1#15 ] 
Uplift Scope [] 120.1: zp[1]:6 [ idx#42 idx#19 ] 
Uplift Scope [main] 36.67: zp[2]:2 [ main::s#2 main::s#1 ] 
Uplift Scope [testSimpleTypes] 

Uplifting [assertType] best 845 combination reg byte y [ assertType::t2#15 ] reg byte x [ assertType::t1#15 ] 
Uplifting [] best 845 combination zp[1]:6 [ idx#42 idx#19 ] 
Uplifting [main] best 845 combination zp[2]:2 [ main::s#2 main::s#1 ] 
Uplifting [testSimpleTypes] best 845 combination 
Attempting to uplift remaining variables inzp[1]:6 [ idx#42 idx#19 ]
Uplifting [] best 845 combination zp[1]:6 [ idx#42 idx#19 ] 
Allocated (was zp[1]:6) zp[1]:4 [ idx#42 idx#19 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests different integer literal types
  // Upstart
  // Commodore 64 PRG executable file
.file [name="int-literals.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const RED = 2
  .const GREEN = 5
  .const TYPEID_BYTE = 1
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_WORD = 3
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_DWORD = 5
  .const TYPEID_SIGNED_DWORD = 6
  .label SCREEN = $400
  .label COLS = $d800
  .label idx = 4
.segment Code
  // main
main: {
    .label s = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi main::s#2 = SCREEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z s
    lda #>SCREEN
    sta.z s+1
    jmp __b1
    // main::@1
  __b1:
    // [2] if(main::s#2<SCREEN+$3e8) goto main::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z s+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z s
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // [3] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [4] call testSimpleTypes 
    // [8] phi from main::@3 to testSimpleTypes [phi:main::@3->testSimpleTypes]
  testSimpleTypes_from___b3:
    jsr testSimpleTypes
    jmp __breturn
    // main::@return
  __breturn:
    // [5] return 
    rts
    // main::@2
  __b2:
    // [6] *main::s#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
    // [7] main::s#1 = ++ main::s#2 -- pbuz1=_inc_pbuz1 
    inc.z s
    bne !+
    inc.z s+1
  !:
    // [1] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [1] phi main::s#2 = main::s#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // testSimpleTypes
testSimpleTypes: {
    // [9] call assertType 
  // Simple types
    // [39] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
  assertType_from_testSimpleTypes:
    // [39] phi idx#42 = 0 [phi:testSimpleTypes->assertType#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [39] phi assertType::t2#15 = TYPEID_BYTE [phi:testSimpleTypes->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    // [39] phi assertType::t1#15 = TYPEID_BYTE [phi:testSimpleTypes->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_BYTE
    jsr assertType
    // [10] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
  __b1_from_testSimpleTypes:
    jmp __b1
    // testSimpleTypes::@1
  __b1:
    // [11] call assertType 
    // [39] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
  assertType_from___b1:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    // [39] phi assertType::t1#15 = TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_BYTE
    jsr assertType
    // [12] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
  __b2_from___b1:
    jmp __b2
    // testSimpleTypes::@2
  __b2:
    // [13] call assertType 
    // [39] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
  assertType_from___b2:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_BYTE
    jsr assertType
    // [14] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
  __b3_from___b2:
    jmp __b3
    // testSimpleTypes::@3
  __b3:
    // [15] call assertType 
    // [39] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
  assertType_from___b3:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_BYTE
    jsr assertType
    // [16] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
  __b4_from___b3:
    jmp __b4
    // testSimpleTypes::@4
  __b4:
    // [17] call assertType 
    // [39] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
  assertType_from___b4:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_WORD [phi:testSimpleTypes::@4->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    // [39] phi assertType::t1#15 = TYPEID_WORD [phi:testSimpleTypes::@4->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_WORD
    jsr assertType
    // [18] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
  __b5_from___b4:
    jmp __b5
    // testSimpleTypes::@5
  __b5:
    // [19] call assertType 
    // [39] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
  assertType_from___b5:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_WORD [phi:testSimpleTypes::@5->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    // [39] phi assertType::t1#15 = TYPEID_WORD [phi:testSimpleTypes::@5->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_WORD
    jsr assertType
    // [20] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
  __b6_from___b5:
    jmp __b6
    // testSimpleTypes::@6
  __b6:
    // [21] call assertType 
    // [39] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
  assertType_from___b6:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_WORD [phi:testSimpleTypes::@6->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    // [39] phi assertType::t1#15 = TYPEID_WORD [phi:testSimpleTypes::@6->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_WORD
    jsr assertType
    // [22] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
  __b7_from___b6:
    jmp __b7
    // testSimpleTypes::@7
  __b7:
    // [23] call assertType 
    // [39] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
  assertType_from___b7:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_WORD
    jsr assertType
    // [24] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
  __b8_from___b7:
    jmp __b8
    // testSimpleTypes::@8
  __b8:
    // [25] call assertType 
    // [39] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
  assertType_from___b8:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_WORD
    jsr assertType
    // [26] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
  __b9_from___b8:
    jmp __b9
    // testSimpleTypes::@9
  __b9:
    // [27] call assertType 
    // [39] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
  assertType_from___b9:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_WORD
    jsr assertType
    // [28] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
  __b10_from___b9:
    jmp __b10
    // testSimpleTypes::@10
  __b10:
    // [29] call assertType 
    // [39] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
  assertType_from___b10:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    // [39] phi assertType::t1#15 = TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_DWORD
    jsr assertType
    // [30] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
  __b11_from___b10:
    jmp __b11
    // testSimpleTypes::@11
  __b11:
    // [31] call assertType 
    // [39] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
  assertType_from___b11:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    // [39] phi assertType::t1#15 = TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_DWORD
    jsr assertType
    // [32] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
  __b12_from___b11:
    jmp __b12
    // testSimpleTypes::@12
  __b12:
    // [33] call assertType 
    // [39] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
  assertType_from___b12:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_DWORD
    jsr assertType
    // [34] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
  __b13_from___b12:
    jmp __b13
    // testSimpleTypes::@13
  __b13:
    // [35] call assertType 
    // [39] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
  assertType_from___b13:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_DWORD
    jsr assertType
    // [36] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
  __b14_from___b13:
    jmp __b14
    // testSimpleTypes::@14
  __b14:
    // [37] call assertType 
    // [39] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
  assertType_from___b14:
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_DWORD
    jsr assertType
    jmp __breturn
    // testSimpleTypes::@return
  __breturn:
    // [38] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(X) t1, byte register(Y) t2)
assertType: {
    // [40] if(assertType::t1#15==assertType::t2#15) goto assertType::@1 -- vbuxx_eq_vbuyy_then_la1 
    sty.z $ff
    cpx.z $ff
    beq __b1
    jmp __b3
    // assertType::@3
  __b3:
    // [41] COLS[idx#42] = RED -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #RED
    ldy.z idx
    sta COLS,y
    jmp __b2
    // assertType::@2
  __b2:
    // [42] SCREEN[idx#42] = assertType::t1#15 -- pbuc1_derefidx_vbuz1=vbuxx 
    ldy.z idx
    txa
    sta SCREEN,y
    // [43] idx#19 = ++ idx#42 -- vbuz1=_inc_vbuz1 
    inc.z idx
    jmp __breturn
    // assertType::@return
  __breturn:
    // [44] return 
    rts
    // assertType::@1
  __b1:
    // [45] COLS[idx#42] = GREEN -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy.z idx
    sta COLS,y
    jmp __b2
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b13
Removing instruction jmp __b14
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b3_from___b1:
Removing instruction testSimpleTypes_from___b3:
Removing instruction __b1_from_testSimpleTypes:
Removing instruction assertType_from___b1:
Removing instruction __b2_from___b1:
Removing instruction assertType_from___b2:
Removing instruction __b3_from___b2:
Removing instruction assertType_from___b3:
Removing instruction __b4_from___b3:
Removing instruction assertType_from___b4:
Removing instruction __b5_from___b4:
Removing instruction assertType_from___b5:
Removing instruction __b6_from___b5:
Removing instruction assertType_from___b6:
Removing instruction __b7_from___b6:
Removing instruction assertType_from___b7:
Removing instruction __b8_from___b7:
Removing instruction assertType_from___b8:
Removing instruction __b9_from___b8:
Removing instruction assertType_from___b9:
Removing instruction __b10_from___b9:
Removing instruction assertType_from___b10:
Removing instruction __b11_from___b10:
Removing instruction assertType_from___b11:
Removing instruction __b12_from___b11:
Removing instruction assertType_from___b12:
Removing instruction __b13_from___b12:
Removing instruction assertType_from___b13:
Removing instruction __b14_from___b13:
Removing instruction assertType_from___b14:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction assertType_from_testSimpleTypes:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b13:
Removing instruction __b14:
Removing instruction __breturn:
Removing instruction __b3:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
const nomodify byte* COLS = (byte*)$d800
const nomodify byte GREEN = 5
const nomodify byte RED = 2
const nomodify byte* SCREEN = (byte*)$400
const byte TYPEID_BYTE = 1
const byte TYPEID_DWORD = 5
const byte TYPEID_SIGNED_BYTE = 2
const byte TYPEID_SIGNED_DWORD = 6
const byte TYPEID_SIGNED_WORD = 4
const byte TYPEID_WORD = 3
void assertType(byte assertType::t1 , byte assertType::t2)
byte assertType::t1
byte assertType::t1#15 reg byte x 50.5
byte assertType::t2
byte assertType::t2#15 reg byte y 101.0
byte idx
byte idx#19 idx zp[1]:4 8.499999999999998
byte idx#42 idx zp[1]:4 111.6
void main()
byte* main::s
byte* main::s#1 s zp[2]:2 22.0
byte* main::s#2 s zp[2]:2 14.666666666666666
void testSimpleTypes()

zp[2]:2 [ main::s#2 main::s#1 ]
reg byte x [ assertType::t1#15 ]
reg byte y [ assertType::t2#15 ]
zp[1]:4 [ idx#42 idx#19 ]


FINAL ASSEMBLER
Score: 755

  // File Comments
// Tests different integer literal types
  // Upstart
  // Commodore 64 PRG executable file
.file [name="int-literals.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const RED = 2
  .const GREEN = 5
  .const TYPEID_BYTE = 1
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_WORD = 3
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_DWORD = 5
  .const TYPEID_SIGNED_DWORD = 6
  .label SCREEN = $400
  .label COLS = $d800
  .label idx = 4
.segment Code
  // main
main: {
    .label s = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi main::s#2 = SCREEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z s
    lda #>SCREEN
    sta.z s+1
    // main::@1
  __b1:
    // for(byte* s=SCREEN;s<SCREEN+1000uw;s++)
    // [2] if(main::s#2<SCREEN+$3e8) goto main::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z s+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z s
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // [3] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // main::@3
    // testSimpleTypes()
    // [4] call testSimpleTypes 
    // [8] phi from main::@3 to testSimpleTypes [phi:main::@3->testSimpleTypes]
    jsr testSimpleTypes
    // main::@return
    // }
    // [5] return 
    rts
    // main::@2
  __b2:
    // *s = ' '
    // [6] *main::s#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
    // for(byte* s=SCREEN;s<SCREEN+1000uw;s++)
    // [7] main::s#1 = ++ main::s#2 -- pbuz1=_inc_pbuz1 
    inc.z s
    bne !+
    inc.z s+1
  !:
    // [1] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [1] phi main::s#2 = main::s#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // testSimpleTypes
testSimpleTypes: {
    // assertType(typeid(12ub), typeid(unsigned byte))
    // [9] call assertType 
  // Simple types
    // [39] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
    // [39] phi idx#42 = 0 [phi:testSimpleTypes->assertType#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [39] phi assertType::t2#15 = TYPEID_BYTE [phi:testSimpleTypes->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    // [39] phi assertType::t1#15 = TYPEID_BYTE [phi:testSimpleTypes->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_BYTE
    jsr assertType
    // [10] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
    // testSimpleTypes::@1
    // assertType(typeid(12uc), typeid(unsigned byte))
    // [11] call assertType 
    // [39] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    // [39] phi assertType::t1#15 = TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_BYTE
    jsr assertType
    // [12] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
    // testSimpleTypes::@2
    // assertType(typeid(12sb), typeid(signed byte))
    // [13] call assertType 
    // [39] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_BYTE
    jsr assertType
    // [14] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
    // testSimpleTypes::@3
    // assertType(typeid(12sc), typeid(signed byte))
    // [15] call assertType 
    // [39] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_BYTE
    jsr assertType
    // [16] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
    // testSimpleTypes::@4
    // assertType(typeid(12uw), typeid(unsigned word))
    // [17] call assertType 
    // [39] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_WORD [phi:testSimpleTypes::@4->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    // [39] phi assertType::t1#15 = TYPEID_WORD [phi:testSimpleTypes::@4->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_WORD
    jsr assertType
    // [18] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
    // testSimpleTypes::@5
    // assertType(typeid(12ui), typeid(unsigned word))
    // [19] call assertType 
    // [39] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_WORD [phi:testSimpleTypes::@5->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    // [39] phi assertType::t1#15 = TYPEID_WORD [phi:testSimpleTypes::@5->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_WORD
    jsr assertType
    // [20] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
    // testSimpleTypes::@6
    // assertType(typeid(12us), typeid(unsigned word))
    // [21] call assertType 
    // [39] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_WORD [phi:testSimpleTypes::@6->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    // [39] phi assertType::t1#15 = TYPEID_WORD [phi:testSimpleTypes::@6->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_WORD
    jsr assertType
    // [22] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
    // testSimpleTypes::@7
    // assertType(typeid(12sw), typeid(signed word))
    // [23] call assertType 
    // [39] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_WORD
    jsr assertType
    // [24] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
    // testSimpleTypes::@8
    // assertType(typeid(12si), typeid(signed word))
    // [25] call assertType 
    // [39] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_WORD
    jsr assertType
    // [26] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
    // testSimpleTypes::@9
    // assertType(typeid(12ss), typeid(signed word))
    // [27] call assertType 
    // [39] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_WORD
    jsr assertType
    // [28] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
    // testSimpleTypes::@10
    // assertType(typeid(12ud), typeid(unsigned dword))
    // [29] call assertType 
    // [39] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    // [39] phi assertType::t1#15 = TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_DWORD
    jsr assertType
    // [30] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
    // testSimpleTypes::@11
    // assertType(typeid(12ul), typeid(unsigned dword))
    // [31] call assertType 
    // [39] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    // [39] phi assertType::t1#15 = TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_DWORD
    jsr assertType
    // [32] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
    // testSimpleTypes::@12
    // assertType(typeid(12sd), typeid(signed dword))
    // [33] call assertType 
    // [39] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_DWORD
    jsr assertType
    // [34] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
    // testSimpleTypes::@13
    // assertType(typeid(12sl), typeid(signed dword))
    // [35] call assertType 
    // [39] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_DWORD
    jsr assertType
    // [36] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
    // testSimpleTypes::@14
    // assertType(typeid(12l), typeid(signed dword))
    // [37] call assertType 
    // [39] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
    // [39] phi idx#42 = idx#19 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
    // [39] phi assertType::t2#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    // [39] phi assertType::t1#15 = TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_DWORD
    jsr assertType
    // testSimpleTypes::@return
    // }
    // [38] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(X) t1, byte register(Y) t2)
assertType: {
    // if(t1==t2)
    // [40] if(assertType::t1#15==assertType::t2#15) goto assertType::@1 -- vbuxx_eq_vbuyy_then_la1 
    sty.z $ff
    cpx.z $ff
    beq __b1
    // assertType::@3
    // COLS[idx] = RED
    // [41] COLS[idx#42] = RED -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #RED
    ldy.z idx
    sta COLS,y
    // assertType::@2
  __b2:
    // SCREEN[idx++] = t1
    // [42] SCREEN[idx#42] = assertType::t1#15 -- pbuc1_derefidx_vbuz1=vbuxx 
    ldy.z idx
    txa
    sta SCREEN,y
    // SCREEN[idx++] = t1;
    // [43] idx#19 = ++ idx#42 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // assertType::@return
    // }
    // [44] return 
    rts
    // assertType::@1
  __b1:
    // COLS[idx] = GREEN
    // [45] COLS[idx#42] = GREEN -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy.z idx
    sta COLS,y
    jmp __b2
}
  // File Data

