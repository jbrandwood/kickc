Adding pointer type conversion cast (byte*) main::screen in (byte*) main::screen ← (number) $400
Adding pointer type conversion cast (byte*) CORDIC_ATAN2_ANGLES in (byte*) CORDIC_ATAN2_ANGLES ← (number) $1000
Identified constant variable (byte*) CORDIC_ATAN2_ANGLES
Culled Empty Block (label) main::@4
Culled Empty Block (label) atan2::@6
Culled Empty Block (label) atan2::@7
Culled Empty Block (label) atan2::@9
Culled Empty Block (label) atan2::@10
Culled Empty Block (label) atan2::@11

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@1
main: scope:[main]  from @2
  (byte*) main::screen#0 ← ((byte*)) (number) $400
  (signed byte) main::y#0 ← (signed byte) 0
  to:main::@1
main::@1: scope:[main]  from main main::@3
  (byte*) main::screen#5 ← phi( main/(byte*) main::screen#0 main::@3/(byte*) main::screen#1 )
  (signed byte) main::y#4 ← phi( main/(signed byte) main::y#0 main::@3/(signed byte) main::y#1 )
  (signed byte) main::x#0 ← (signed byte) 0
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@5
  (byte*) main::screen#4 ← phi( main::@1/(byte*) main::screen#5 main::@5/(byte*) main::screen#2 )
  (signed byte) main::y#2 ← phi( main::@1/(signed byte) main::y#4 main::@5/(signed byte) main::y#5 )
  (signed byte) main::x#2 ← phi( main::@1/(signed byte) main::x#0 main::@5/(signed byte) main::x#1 )
  (signed byte) atan2::x#0 ← (signed byte) main::x#2
  (signed byte) atan2::y#0 ← (signed byte) main::y#2
  call atan2 
  (byte) atan2::return#0 ← (byte) atan2::return#2
  to:main::@5
main::@5: scope:[main]  from main::@2
  (signed byte) main::y#5 ← phi( main::@2/(signed byte) main::y#2 )
  (signed byte) main::x#3 ← phi( main::@2/(signed byte) main::x#2 )
  (byte*) main::screen#2 ← phi( main::@2/(byte*) main::screen#4 )
  (byte) atan2::return#3 ← phi( main::@2/(byte) atan2::return#0 )
  (byte~) main::$0 ← (byte) atan2::return#3
  (byte) main::angle#0 ← (byte~) main::$0
  *((byte*) main::screen#2 + (signed byte) main::x#3) ← (byte) main::angle#0
  (signed byte) main::x#1 ← (signed byte) main::x#3 + rangenext(0,$27)
  (bool~) main::$1 ← (signed byte) main::x#1 != rangelast(0,$27)
  if((bool~) main::$1) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@5
  (signed byte) main::y#3 ← phi( main::@5/(signed byte) main::y#5 )
  (byte*) main::screen#3 ← phi( main::@5/(byte*) main::screen#2 )
  (byte*) main::screen#1 ← (byte*) main::screen#3 + (number) $28
  (signed byte) main::y#1 ← (signed byte) main::y#3 + rangenext(0,$18)
  (bool~) main::$2 ← (signed byte) main::y#1 != rangelast(0,$18)
  if((bool~) main::$2) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
@1: scope:[]  from @begin
  (byte) CORDIC_ITERATIONS#0 ← (number) 8
  (byte*) CORDIC_ATAN2_ANGLES#0 ← ((byte*)) (number) $1000
  kickasm(location (byte*) CORDIC_ATAN2_ANGLES#0) {{ .fill CORDIC_ITERATIONS, 256*atan(1/pow(2,i))/PI/2
 }}
  to:@2
atan2: scope:[atan2]  from main::@2
  (signed byte) atan2::x#7 ← phi( main::@2/(signed byte) atan2::x#0 )
  (signed byte) atan2::y#7 ← phi( main::@2/(signed byte) atan2::y#0 )
  (byte) atan2::angle#0 ← (number) 0
  (byte) atan2::i#0 ← (byte) 0
  to:atan2::@1
atan2::@1: scope:[atan2]  from atan2 atan2::@5
  (byte) atan2::angle#6 ← phi( atan2/(byte) atan2::angle#0 atan2::@5/(byte) atan2::angle#7 )
  (byte) atan2::i#6 ← phi( atan2/(byte) atan2::i#0 atan2::@5/(byte) atan2::i#1 )
  (signed byte) atan2::x#6 ← phi( atan2/(signed byte) atan2::x#7 atan2::@5/(signed byte) atan2::x#8 )
  (signed byte) atan2::y#3 ← phi( atan2/(signed byte) atan2::y#7 atan2::@5/(signed byte) atan2::y#8 )
  (bool~) atan2::$0 ← (signed byte) atan2::y#3 == (number) 0
  (bool~) atan2::$1 ← ! (bool~) atan2::$0
  if((bool~) atan2::$1) goto atan2::@2
  to:atan2::@3
atan2::@2: scope:[atan2]  from atan2::@1
  (byte) atan2::angle#8 ← phi( atan2::@1/(byte) atan2::angle#6 )
  (signed byte) atan2::y#4 ← phi( atan2::@1/(signed byte) atan2::y#3 )
  (byte) atan2::i#2 ← phi( atan2::@1/(byte) atan2::i#6 )
  (signed byte) atan2::x#3 ← phi( atan2::@1/(signed byte) atan2::x#6 )
  (signed byte~) atan2::$2 ← (signed byte) atan2::x#3 >> (byte) atan2::i#2
  (signed byte) atan2::xd#0 ← (signed byte~) atan2::$2
  (signed byte~) atan2::$3 ← (signed byte) atan2::y#4 >> (byte) atan2::i#2
  (signed byte) atan2::yd#0 ← (signed byte~) atan2::$3
  (bool~) atan2::$4 ← (signed byte) atan2::y#4 > (number) 0
  if((bool~) atan2::$4) goto atan2::@4
  to:atan2::@8
atan2::@3: scope:[atan2]  from atan2::@1 atan2::@5
  (byte) atan2::angle#3 ← phi( atan2::@1/(byte) atan2::angle#6 atan2::@5/(byte) atan2::angle#7 )
  (byte) atan2::return#1 ← (byte) atan2::angle#3
  to:atan2::@return
atan2::@4: scope:[atan2]  from atan2::@2
  (byte) atan2::i#3 ← phi( atan2::@2/(byte) atan2::i#2 )
  (byte) atan2::angle#4 ← phi( atan2::@2/(byte) atan2::angle#8 )
  (signed byte) atan2::xd#1 ← phi( atan2::@2/(signed byte) atan2::xd#0 )
  (signed byte) atan2::y#5 ← phi( atan2::@2/(signed byte) atan2::y#4 )
  (signed byte) atan2::yd#1 ← phi( atan2::@2/(signed byte) atan2::yd#0 )
  (signed byte) atan2::x#4 ← phi( atan2::@2/(signed byte) atan2::x#3 )
  (signed byte) atan2::x#1 ← (signed byte) atan2::x#4 + (signed byte) atan2::yd#1
  (signed byte) atan2::y#1 ← (signed byte) atan2::y#5 - (signed byte) atan2::xd#1
  (byte) atan2::angle#1 ← (byte) atan2::angle#4 + *((byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#3)
  to:atan2::@5
atan2::@8: scope:[atan2]  from atan2::@2
  (byte) atan2::i#4 ← phi( atan2::@2/(byte) atan2::i#2 )
  (byte) atan2::angle#5 ← phi( atan2::@2/(byte) atan2::angle#8 )
  (signed byte) atan2::xd#2 ← phi( atan2::@2/(signed byte) atan2::xd#0 )
  (signed byte) atan2::y#6 ← phi( atan2::@2/(signed byte) atan2::y#4 )
  (signed byte) atan2::yd#2 ← phi( atan2::@2/(signed byte) atan2::yd#0 )
  (signed byte) atan2::x#5 ← phi( atan2::@2/(signed byte) atan2::x#3 )
  (signed byte) atan2::x#2 ← (signed byte) atan2::x#5 - (signed byte) atan2::yd#2
  (signed byte) atan2::y#2 ← (signed byte) atan2::y#6 + (signed byte) atan2::xd#2
  (byte) atan2::angle#2 ← (byte) atan2::angle#5 - *((byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#4)
  to:atan2::@5
atan2::@5: scope:[atan2]  from atan2::@4 atan2::@8
  (signed byte) atan2::x#8 ← phi( atan2::@4/(signed byte) atan2::x#1 atan2::@8/(signed byte) atan2::x#2 )
  (byte) atan2::angle#7 ← phi( atan2::@4/(byte) atan2::angle#1 atan2::@8/(byte) atan2::angle#2 )
  (signed byte) atan2::y#8 ← phi( atan2::@4/(signed byte) atan2::y#1 atan2::@8/(signed byte) atan2::y#2 )
  (byte) atan2::i#5 ← phi( atan2::@4/(byte) atan2::i#3 atan2::@8/(byte) atan2::i#4 )
  (byte) atan2::i#1 ← (byte) atan2::i#5 + rangenext(0,CORDIC_ITERATIONS#0)
  (bool~) atan2::$5 ← (byte) atan2::i#1 != rangelast(0,CORDIC_ITERATIONS#0)
  if((bool~) atan2::$5) goto atan2::@1
  to:atan2::@3
atan2::@return: scope:[atan2]  from atan2::@3
  (byte) atan2::return#4 ← phi( atan2::@3/(byte) atan2::return#1 )
  (byte) atan2::return#2 ← (byte) atan2::return#4
  return 
  to:@return
@2: scope:[]  from @1
  call main 
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(label) @1
(label) @2
(label) @3
(label) @begin
(label) @end
(byte*) CORDIC_ATAN2_ANGLES
(byte*) CORDIC_ATAN2_ANGLES#0
(byte) CORDIC_ITERATIONS
(byte) CORDIC_ITERATIONS#0
(byte()) atan2((signed byte) atan2::x , (signed byte) atan2::y)
(bool~) atan2::$0
(bool~) atan2::$1
(signed byte~) atan2::$2
(signed byte~) atan2::$3
(bool~) atan2::$4
(bool~) atan2::$5
(label) atan2::@1
(label) atan2::@2
(label) atan2::@3
(label) atan2::@4
(label) atan2::@5
(label) atan2::@8
(label) atan2::@return
(byte) atan2::angle
(byte) atan2::angle#0
(byte) atan2::angle#1
(byte) atan2::angle#2
(byte) atan2::angle#3
(byte) atan2::angle#4
(byte) atan2::angle#5
(byte) atan2::angle#6
(byte) atan2::angle#7
(byte) atan2::angle#8
(byte) atan2::i
(byte) atan2::i#0
(byte) atan2::i#1
(byte) atan2::i#2
(byte) atan2::i#3
(byte) atan2::i#4
(byte) atan2::i#5
(byte) atan2::i#6
(byte) atan2::return
(byte) atan2::return#0
(byte) atan2::return#1
(byte) atan2::return#2
(byte) atan2::return#3
(byte) atan2::return#4
(signed byte) atan2::x
(signed byte) atan2::x#0
(signed byte) atan2::x#1
(signed byte) atan2::x#2
(signed byte) atan2::x#3
(signed byte) atan2::x#4
(signed byte) atan2::x#5
(signed byte) atan2::x#6
(signed byte) atan2::x#7
(signed byte) atan2::x#8
(signed byte) atan2::xd
(signed byte) atan2::xd#0
(signed byte) atan2::xd#1
(signed byte) atan2::xd#2
(signed byte) atan2::y
(signed byte) atan2::y#0
(signed byte) atan2::y#1
(signed byte) atan2::y#2
(signed byte) atan2::y#3
(signed byte) atan2::y#4
(signed byte) atan2::y#5
(signed byte) atan2::y#6
(signed byte) atan2::y#7
(signed byte) atan2::y#8
(signed byte) atan2::yd
(signed byte) atan2::yd#0
(signed byte) atan2::yd#1
(signed byte) atan2::yd#2
(void()) main()
(byte~) main::$0
(bool~) main::$1
(bool~) main::$2
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@5
(label) main::@return
(byte) main::angle
(byte) main::angle#0
(byte*) main::screen
(byte*) main::screen#0
(byte*) main::screen#1
(byte*) main::screen#2
(byte*) main::screen#3
(byte*) main::screen#4
(byte*) main::screen#5
(signed byte) main::x
(signed byte) main::x#0
(signed byte) main::x#1
(signed byte) main::x#2
(signed byte) main::x#3
(signed byte) main::y
(signed byte) main::y#0
(signed byte) main::y#1
(signed byte) main::y#2
(signed byte) main::y#3
(signed byte) main::y#4
(signed byte) main::y#5

Adding number conversion cast (unumber) $28 in (byte*) main::screen#1 ← (byte*) main::screen#3 + (number) $28
Adding number conversion cast (unumber) 8 in (byte) CORDIC_ITERATIONS#0 ← (number) 8
Adding number conversion cast (unumber) 0 in (byte) atan2::angle#0 ← (number) 0
Adding number conversion cast (snumber) 0 in (bool~) atan2::$0 ← (signed byte) atan2::y#3 == (number) 0
Adding number conversion cast (snumber) 0 in (bool~) atan2::$4 ← (signed byte) atan2::y#4 > (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) main::screen#0 ← (byte*)(number) $400
Inlining cast (byte) CORDIC_ITERATIONS#0 ← (unumber)(number) 8
Inlining cast (byte*) CORDIC_ATAN2_ANGLES#0 ← (byte*)(number) $1000
Inlining cast (byte) atan2::angle#0 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $28
Simplifying constant integer cast 8
Simplifying constant pointer cast (byte*) 4096
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 0
Finalized signed number type (signed byte) 0
Finalized signed number type (signed byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inversing boolean not [30] (bool~) atan2::$1 ← (signed byte) atan2::y#3 != (signed byte) 0 from [29] (bool~) atan2::$0 ← (signed byte) atan2::y#3 == (signed byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte) atan2::return#0 = (byte) atan2::return#3 
Alias (byte*) main::screen#2 = (byte*) main::screen#4 (byte*) main::screen#3 
Alias (signed byte) main::x#2 = (signed byte) main::x#3 
Alias (signed byte) main::y#2 = (signed byte) main::y#5 (signed byte) main::y#3 
Alias (byte) main::angle#0 = (byte~) main::$0 
Alias (signed byte) atan2::x#3 = (signed byte) atan2::x#6 (signed byte) atan2::x#4 (signed byte) atan2::x#5 
Alias (byte) atan2::i#2 = (byte) atan2::i#6 (byte) atan2::i#3 (byte) atan2::i#4 
Alias (signed byte) atan2::y#3 = (signed byte) atan2::y#4 (signed byte) atan2::y#5 (signed byte) atan2::y#6 
Alias (byte) atan2::angle#4 = (byte) atan2::angle#8 (byte) atan2::angle#6 (byte) atan2::angle#5 
Alias (signed byte) atan2::xd#0 = (signed byte~) atan2::$2 (signed byte) atan2::xd#1 (signed byte) atan2::xd#2 
Alias (signed byte) atan2::yd#0 = (signed byte~) atan2::$3 (signed byte) atan2::yd#1 (signed byte) atan2::yd#2 
Alias (byte) atan2::return#1 = (byte) atan2::angle#3 (byte) atan2::return#4 (byte) atan2::return#2 
Successful SSA optimization Pass2AliasElimination
Alias (byte) atan2::i#2 = (byte) atan2::i#5 
Successful SSA optimization Pass2AliasElimination
Self Phi Eliminated (signed byte) main::y#2
Self Phi Eliminated (byte*) main::screen#2
Successful SSA optimization Pass2SelfPhiElimination
Identical Phi Values (signed byte) main::y#2 (signed byte) main::y#4
Identical Phi Values (byte*) main::screen#2 (byte*) main::screen#5
Identical Phi Values (signed byte) atan2::y#7 (signed byte) atan2::y#0
Identical Phi Values (signed byte) atan2::x#7 (signed byte) atan2::x#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$1 [15] if((signed byte) main::x#1!=rangelast(0,$27)) goto main::@2
Simple Condition (bool~) main::$2 [20] if((signed byte) main::y#1!=rangelast(0,$18)) goto main::@1
Simple Condition (bool~) atan2::$1 [31] if((signed byte) atan2::y#3!=(signed byte) 0) goto atan2::@2
Simple Condition (bool~) atan2::$4 [38] if((signed byte) atan2::y#3>(signed byte) 0) goto atan2::@4
Simple Condition (bool~) atan2::$5 [52] if((byte) atan2::i#1!=rangelast(0,CORDIC_ITERATIONS#0)) goto atan2::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [52] if((byte) atan2::i#1==rangelast(0,CORDIC_ITERATIONS#0)) goto atan2::@3
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant (const byte*) main::screen#0 = (byte*) 1024
Constant (const signed byte) main::y#0 = 0
Constant (const signed byte) main::x#0 = 0
Constant (const byte) CORDIC_ITERATIONS#0 = 8
Constant (const byte*) CORDIC_ATAN2_ANGLES#0 = (byte*) 4096
Constant (const byte) atan2::angle#0 = 0
Constant (const byte) atan2::i#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [13] main::x#1 ← ++ main::x#2 to ++
Resolved ranged comparison value [15] if(main::x#1!=rangelast(0,$27)) goto main::@2 to (number) $28
Resolved ranged next value [18] main::y#1 ← ++ main::y#4 to ++
Resolved ranged comparison value [20] if(main::y#1!=rangelast(0,$18)) goto main::@1 to (number) $19
Resolved ranged next value [50] atan2::i#1 ← ++ atan2::i#2 to ++
Resolved ranged comparison value [52] if(atan2::i#1==rangelast(0,CORDIC_ITERATIONS#0)) goto atan2::@3 to (const byte) CORDIC_ITERATIONS#0+(number) 1
Adding number conversion cast (snumber) $28 in if((signed byte) main::x#1!=(number) $28) goto main::@2
Adding number conversion cast (snumber) $19 in if((signed byte) main::y#1!=(number) $19) goto main::@1
Adding number conversion cast (unumber) CORDIC_ITERATIONS#0+1 in if((byte) atan2::i#1==(const byte) CORDIC_ITERATIONS#0+(number) 1) goto atan2::@3
Adding number conversion cast (unumber) 1 in if((byte) atan2::i#1==(unumber)(const byte) CORDIC_ITERATIONS#0+(number) 1) goto atan2::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $28
Simplifying constant integer cast $19
Simplifying constant integer cast (const byte) CORDIC_ITERATIONS#0+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized signed number type (signed byte) $28
Finalized signed number type (signed byte) $19
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings (const byte*) main::screen#0
Inlining constant with var siblings (const signed byte) main::y#0
Inlining constant with var siblings (const signed byte) main::x#0
Inlining constant with var siblings (const byte) atan2::angle#0
Inlining constant with var siblings (const byte) atan2::i#0
Constant inlined main::screen#0 = (byte*) 1024
Constant inlined atan2::i#0 = (byte) 0
Constant inlined main::x#0 = (signed byte) 0
Constant inlined main::y#0 = (signed byte) 0
Constant inlined atan2::angle#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@6(between main::@3 and main::@1)
Added new block during phi lifting main::@7(between main::@5 and main::@2)
Added new block during phi lifting atan2::@12(between atan2::@5 and atan2::@1)
Added new block during phi lifting atan2::@13(between atan2::@1 and atan2::@3)
Added new block during phi lifting atan2::@14(between atan2::@5 and atan2::@3)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to main:3 
Calls in [main] to atan2:11 

Created 11 initial phi equivalence classes
Coalesced [21] main::y#6 ← main::y#1
Coalesced [22] main::screen#6 ← main::screen#1
Coalesced [23] main::x#4 ← main::x#1
Coalesced [24] atan2::y#9 ← atan2::y#0
Coalesced [25] atan2::x#9 ← atan2::x#0
Coalesced [28] atan2::return#5 ← atan2::angle#4
Coalesced [37] atan2::y#12 ← atan2::y#2
Coalesced [38] atan2::angle#11 ← atan2::angle#2
Coalesced [39] atan2::x#12 ← atan2::x#2
Coalesced [43] atan2::y#10 ← atan2::y#8
Coalesced [44] atan2::x#10 ← atan2::x#8
Coalesced [45] atan2::i#7 ← atan2::i#1
Coalesced [46] atan2::angle#9 ← atan2::angle#7
Coalesced (already) [47] atan2::return#6 ← atan2::angle#7
Coalesced [51] atan2::y#11 ← atan2::y#1
Coalesced [52] atan2::angle#10 ← atan2::angle#1
Coalesced [53] atan2::x#11 ← atan2::x#1
Coalesced down to 7 phi equivalence classes
Culled Empty Block (label) @3
Culled Empty Block (label) main::@6
Culled Empty Block (label) main::@7
Culled Empty Block (label) atan2::@13
Culled Empty Block (label) atan2::@12
Culled Empty Block (label) atan2::@14
Renumbering block main::@5 to main::@4
Renumbering block atan2::@8 to atan2::@6
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of atan2

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  kickasm(location (const byte*) CORDIC_ATAN2_ANGLES#0) {{ .fill CORDIC_ITERATIONS, 256*atan(1/pow(2,i))/PI/2
 }}
  to:@2
@2: scope:[]  from @1
  [2] phi()
  [3] call main 
  to:@end
@end: scope:[]  from @2
  [4] phi()
main: scope:[main]  from @2
  [5] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@3
  [6] (byte*) main::screen#5 ← phi( main/(byte*) 1024 main::@3/(byte*) main::screen#1 )
  [6] (signed byte) main::y#4 ← phi( main/(signed byte) 0 main::@3/(signed byte) main::y#1 )
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@4
  [7] (signed byte) main::x#2 ← phi( main::@1/(signed byte) 0 main::@4/(signed byte) main::x#1 )
  [8] (signed byte) atan2::x#0 ← (signed byte) main::x#2
  [9] (signed byte) atan2::y#0 ← (signed byte) main::y#4
  [10] call atan2 
  [11] (byte) atan2::return#0 ← (byte) atan2::return#1
  to:main::@4
main::@4: scope:[main]  from main::@2
  [12] (byte) main::angle#0 ← (byte) atan2::return#0
  [13] *((byte*) main::screen#5 + (signed byte) main::x#2) ← (byte) main::angle#0
  [14] (signed byte) main::x#1 ← ++ (signed byte) main::x#2
  [15] if((signed byte) main::x#1!=(signed byte) $28) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@4
  [16] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28
  [17] (signed byte) main::y#1 ← ++ (signed byte) main::y#4
  [18] if((signed byte) main::y#1!=(signed byte) $19) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@3
  [19] return 
  to:@return
atan2: scope:[atan2]  from main::@2
  [20] phi()
  to:atan2::@1
atan2::@1: scope:[atan2]  from atan2 atan2::@5
  [21] (byte) atan2::angle#4 ← phi( atan2/(byte) 0 atan2::@5/(byte) atan2::angle#7 )
  [21] (byte) atan2::i#2 ← phi( atan2/(byte) 0 atan2::@5/(byte) atan2::i#1 )
  [21] (signed byte) atan2::x#3 ← phi( atan2/(signed byte) atan2::x#0 atan2::@5/(signed byte) atan2::x#8 )
  [21] (signed byte) atan2::y#3 ← phi( atan2/(signed byte) atan2::y#0 atan2::@5/(signed byte) atan2::y#8 )
  [22] if((signed byte) atan2::y#3!=(signed byte) 0) goto atan2::@2
  to:atan2::@3
atan2::@3: scope:[atan2]  from atan2::@1 atan2::@5
  [23] (byte) atan2::return#1 ← phi( atan2::@1/(byte) atan2::angle#4 atan2::@5/(byte) atan2::angle#7 )
  to:atan2::@return
atan2::@return: scope:[atan2]  from atan2::@3
  [24] return 
  to:@return
atan2::@2: scope:[atan2]  from atan2::@1
  [25] (signed byte) atan2::xd#0 ← (signed byte) atan2::x#3 >> (byte) atan2::i#2
  [26] (signed byte) atan2::yd#0 ← (signed byte) atan2::y#3 >> (byte) atan2::i#2
  [27] if((signed byte) atan2::y#3>(signed byte) 0) goto atan2::@4
  to:atan2::@6
atan2::@6: scope:[atan2]  from atan2::@2
  [28] (signed byte) atan2::x#2 ← (signed byte) atan2::x#3 - (signed byte) atan2::yd#0
  [29] (signed byte) atan2::y#2 ← (signed byte) atan2::y#3 + (signed byte) atan2::xd#0
  [30] (byte) atan2::angle#2 ← (byte) atan2::angle#4 - *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2)
  to:atan2::@5
atan2::@5: scope:[atan2]  from atan2::@4 atan2::@6
  [31] (signed byte) atan2::x#8 ← phi( atan2::@4/(signed byte) atan2::x#1 atan2::@6/(signed byte) atan2::x#2 )
  [31] (byte) atan2::angle#7 ← phi( atan2::@4/(byte) atan2::angle#1 atan2::@6/(byte) atan2::angle#2 )
  [31] (signed byte) atan2::y#8 ← phi( atan2::@4/(signed byte) atan2::y#1 atan2::@6/(signed byte) atan2::y#2 )
  [32] (byte) atan2::i#1 ← ++ (byte) atan2::i#2
  [33] if((byte) atan2::i#1==(const byte) CORDIC_ITERATIONS#0+(byte) 1) goto atan2::@3
  to:atan2::@1
atan2::@4: scope:[atan2]  from atan2::@2
  [34] (signed byte) atan2::x#1 ← (signed byte) atan2::x#3 + (signed byte) atan2::yd#0
  [35] (signed byte) atan2::y#1 ← (signed byte) atan2::y#3 - (signed byte) atan2::xd#0
  [36] (byte) atan2::angle#1 ← (byte) atan2::angle#4 + *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2)
  to:atan2::@5


VARIABLE REGISTER WEIGHTS
(byte*) CORDIC_ATAN2_ANGLES
(byte) CORDIC_ITERATIONS
(byte()) atan2((signed byte) atan2::x , (signed byte) atan2::y)
(byte) atan2::angle
(byte) atan2::angle#1 2002.0
(byte) atan2::angle#2 2002.0
(byte) atan2::angle#4 444.8888888888889
(byte) atan2::angle#7 1334.6666666666667
(byte) atan2::i
(byte) atan2::i#1 1501.5
(byte) atan2::i#2 500.50000000000006
(byte) atan2::return
(byte) atan2::return#0 202.0
(byte) atan2::return#1 701.0
(signed byte) atan2::x
(signed byte) atan2::x#0 34.33333333333333
(signed byte) atan2::x#1 667.3333333333334
(signed byte) atan2::x#2 667.3333333333334
(signed byte) atan2::x#3 801.2
(signed byte) atan2::x#8 1001.0
(signed byte) atan2::xd
(signed byte) atan2::xd#0 600.5999999999999
(signed byte) atan2::y
(signed byte) atan2::y#0 51.5
(signed byte) atan2::y#1 1001.0
(signed byte) atan2::y#2 1001.0
(signed byte) atan2::y#3 858.2857142857142
(signed byte) atan2::y#8 1001.0
(signed byte) atan2::yd
(signed byte) atan2::yd#0 1501.5
(void()) main()
(byte) main::angle
(byte) main::angle#0 202.0
(byte*) main::screen
(byte*) main::screen#1 7.333333333333333
(byte*) main::screen#5 12.299999999999999
(signed byte) main::x
(signed byte) main::x#1 151.5
(signed byte) main::x#2 57.714285714285715
(signed byte) main::y
(signed byte) main::y#1 16.5
(signed byte) main::y#4 11.181818181818182

Initial phi equivalence classes
[ main::y#4 main::y#1 ]
[ main::screen#5 main::screen#1 ]
[ main::x#2 main::x#1 ]
[ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ]
[ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ]
[ atan2::i#2 atan2::i#1 ]
[ atan2::return#1 atan2::angle#4 atan2::angle#7 atan2::angle#1 atan2::angle#2 ]
Added variable atan2::return#0 to zero page equivalence class [ atan2::return#0 ]
Added variable main::angle#0 to zero page equivalence class [ main::angle#0 ]
Added variable atan2::xd#0 to zero page equivalence class [ atan2::xd#0 ]
Added variable atan2::yd#0 to zero page equivalence class [ atan2::yd#0 ]
Complete equivalence classes
[ main::y#4 main::y#1 ]
[ main::screen#5 main::screen#1 ]
[ main::x#2 main::x#1 ]
[ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ]
[ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ]
[ atan2::i#2 atan2::i#1 ]
[ atan2::return#1 atan2::angle#4 atan2::angle#7 atan2::angle#1 atan2::angle#2 ]
[ atan2::return#0 ]
[ main::angle#0 ]
[ atan2::xd#0 ]
[ atan2::yd#0 ]
Allocated zp ZP_BYTE:2 [ main::y#4 main::y#1 ]
Allocated zp ZP_WORD:3 [ main::screen#5 main::screen#1 ]
Allocated zp ZP_BYTE:5 [ main::x#2 main::x#1 ]
Allocated zp ZP_BYTE:6 [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ]
Allocated zp ZP_BYTE:7 [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ]
Allocated zp ZP_BYTE:8 [ atan2::i#2 atan2::i#1 ]
Allocated zp ZP_BYTE:9 [ atan2::return#1 atan2::angle#4 atan2::angle#7 atan2::angle#1 atan2::angle#2 ]
Allocated zp ZP_BYTE:10 [ atan2::return#0 ]
Allocated zp ZP_BYTE:11 [ main::angle#0 ]
Allocated zp ZP_BYTE:12 [ atan2::xd#0 ]
Allocated zp ZP_BYTE:13 [ atan2::yd#0 ]

INITIAL ASM
//SEG0 File Comments
// Find atan2(x, y) using the CORDIC method
// See http://bsvi.ru/uploads/CORDIC--_10EBA/cordic.pdf
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  // The number of iterations performed during CORDIC atan2 calculation
  .const CORDIC_ITERATIONS = 8
  // Angles representing ATAN(0.5), ATAN(0.25), ATAN(0.125), ...
  .label CORDIC_ATAN2_ANGLES = $1000
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 kickasm(location (const byte*) CORDIC_ATAN2_ANGLES#0) {{ .fill CORDIC_ITERATIONS, 256*atan(1/pow(2,i))/PI/2  }}
// Populate cordic angles table
//SEG6 [2] phi from @1 to @2 [phi:@1->@2]
b2_from_b1:
  jmp b2
//SEG7 @2
b2:
//SEG8 [3] call main 
//SEG9 [5] phi from @2 to main [phi:@2->main]
main_from_b2:
  jsr main
//SEG10 [4] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
//SEG11 @end
bend:
//SEG12 main
main: {
    .label angle = $b
    .label x = 5
    .label screen = 3
    .label y = 2
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG14 [6] phi (byte*) main::screen#5 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+1
  //SEG15 [6] phi (signed byte) main::y#4 = (signed byte) 0 [phi:main->main::@1#1] -- vbsz1=vbsc1 
    lda #0
    sta y
    jmp b1
  //SEG16 [6] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  b1_from_b3:
  //SEG17 [6] phi (byte*) main::screen#5 = (byte*) main::screen#1 [phi:main::@3->main::@1#0] -- register_copy 
  //SEG18 [6] phi (signed byte) main::y#4 = (signed byte) main::y#1 [phi:main::@3->main::@1#1] -- register_copy 
    jmp b1
  //SEG19 main::@1
  b1:
  //SEG20 [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
  //SEG21 [7] phi (signed byte) main::x#2 = (signed byte) 0 [phi:main::@1->main::@2#0] -- vbsz1=vbsc1 
    lda #0
    sta x
    jmp b2
  //SEG22 [7] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  b2_from_b4:
  //SEG23 [7] phi (signed byte) main::x#2 = (signed byte) main::x#1 [phi:main::@4->main::@2#0] -- register_copy 
    jmp b2
  //SEG24 main::@2
  b2:
  //SEG25 [8] (signed byte) atan2::x#0 ← (signed byte) main::x#2 -- vbsz1=vbsz2 
    lda x
    sta atan2.x
  //SEG26 [9] (signed byte) atan2::y#0 ← (signed byte) main::y#4 -- vbsz1=vbsz2 
    lda y
    sta atan2.y
  //SEG27 [10] call atan2 
  //SEG28 [20] phi from main::@2 to atan2 [phi:main::@2->atan2]
  atan2_from_b2:
    jsr atan2
  //SEG29 [11] (byte) atan2::return#0 ← (byte) atan2::return#1 -- vbuz1=vbuz2 
    lda atan2.return_1
    sta atan2.return
    jmp b4
  //SEG30 main::@4
  b4:
  //SEG31 [12] (byte) main::angle#0 ← (byte) atan2::return#0 -- vbuz1=vbuz2 
    lda atan2.return
    sta angle
  //SEG32 [13] *((byte*) main::screen#5 + (signed byte) main::x#2) ← (byte) main::angle#0 -- pbuz1_derefidx_vbsz2=vbuz3 
    lda angle
    ldy x
    sta (screen),y
  //SEG33 [14] (signed byte) main::x#1 ← ++ (signed byte) main::x#2 -- vbsz1=_inc_vbsz1 
    inc x
  //SEG34 [15] if((signed byte) main::x#1!=(signed byte) $28) goto main::@2 -- vbsz1_neq_vbsc1_then_la1 
    lda #$28
    cmp x
    bne b2_from_b4
    jmp b3
  //SEG35 main::@3
  b3:
  //SEG36 [16] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc screen
    sta screen
    bcc !+
    inc screen+1
  !:
  //SEG37 [17] (signed byte) main::y#1 ← ++ (signed byte) main::y#4 -- vbsz1=_inc_vbsz1 
    inc y
  //SEG38 [18] if((signed byte) main::y#1!=(signed byte) $19) goto main::@1 -- vbsz1_neq_vbsc1_then_la1 
    lda #$19
    cmp y
    bne b1_from_b3
    jmp breturn
  //SEG39 main::@return
  breturn:
  //SEG40 [19] return 
    rts
}
//SEG41 atan2
// Find the atan2(x, y) - which is the angle of the line from (0,0) to (x,y)
// Finding the angle requires a binary search using CORDIC_ITERATIONS
// Returns the angle in hex-degrees (0=0, 128=PI, 256=2*PI)
// atan2(signed byte zeropage(7) x, signed byte zeropage(6) y)
atan2: {
    .label x = 7
    .label y = 6
    .label return = $a
    .label xd = $c
    .label yd = $d
    .label return_1 = 9
    .label angle = 9
    .label i = 8
  //SEG42 [21] phi from atan2 to atan2::@1 [phi:atan2->atan2::@1]
  b1_from_atan2:
  //SEG43 [21] phi (byte) atan2::angle#4 = (byte) 0 [phi:atan2->atan2::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta angle
  //SEG44 [21] phi (byte) atan2::i#2 = (byte) 0 [phi:atan2->atan2::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta i
  //SEG45 [21] phi (signed byte) atan2::x#3 = (signed byte) atan2::x#0 [phi:atan2->atan2::@1#2] -- register_copy 
  //SEG46 [21] phi (signed byte) atan2::y#3 = (signed byte) atan2::y#0 [phi:atan2->atan2::@1#3] -- register_copy 
    jmp b1
  //SEG47 atan2::@1
  b1:
  //SEG48 [22] if((signed byte) atan2::y#3!=(signed byte) 0) goto atan2::@2 -- vbsz1_neq_0_then_la1 
    lda y
    cmp #0
    bne b2
  //SEG49 [23] phi from atan2::@1 atan2::@5 to atan2::@3 [phi:atan2::@1/atan2::@5->atan2::@3]
  b3_from_b1:
  b3_from_b5:
  //SEG50 [23] phi (byte) atan2::return#1 = (byte) atan2::angle#4 [phi:atan2::@1/atan2::@5->atan2::@3#0] -- register_copy 
    jmp b3
  //SEG51 atan2::@3
  b3:
    jmp breturn
  //SEG52 atan2::@return
  breturn:
  //SEG53 [24] return 
    rts
  //SEG54 atan2::@2
  b2:
  //SEG55 [25] (signed byte) atan2::xd#0 ← (signed byte) atan2::x#3 >> (byte) atan2::i#2 -- vbsz1=vbsz2_ror_vbuz3 
    lda x
    ldy i
    cpy #0
    beq !e+
  !l:
    cmp #$80
    ror
    dey
    bne !l-
  !e:
    sta xd
  //SEG56 [26] (signed byte) atan2::yd#0 ← (signed byte) atan2::y#3 >> (byte) atan2::i#2 -- vbsz1=vbsz2_ror_vbuz3 
    lda y
    ldy i
    cpy #0
    beq !e+
  !l:
    cmp #$80
    ror
    dey
    bne !l-
  !e:
    sta yd
  //SEG57 [27] if((signed byte) atan2::y#3>(signed byte) 0) goto atan2::@4 -- vbsz1_gt_0_then_la1 
    lda y
    cmp #0
    beq !+
    bpl b4
  !:
    jmp b6
  //SEG58 atan2::@6
  b6:
  //SEG59 [28] (signed byte) atan2::x#2 ← (signed byte) atan2::x#3 - (signed byte) atan2::yd#0 -- vbsz1=vbsz1_minus_vbsz2 
    lda x
    sec
    sbc yd
    sta x
  //SEG60 [29] (signed byte) atan2::y#2 ← (signed byte) atan2::y#3 + (signed byte) atan2::xd#0 -- vbsz1=vbsz1_plus_vbsz2 
    lda y
    clc
    adc xd
    sta y
  //SEG61 [30] (byte) atan2::angle#2 ← (byte) atan2::angle#4 - *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) -- vbuz1=vbuz1_minus_pbuc1_derefidx_vbuz2 
    lda angle
    ldy i
    sec
    sbc CORDIC_ATAN2_ANGLES,y
    sta angle
  //SEG62 [31] phi from atan2::@4 atan2::@6 to atan2::@5 [phi:atan2::@4/atan2::@6->atan2::@5]
  b5_from_b4:
  b5_from_b6:
  //SEG63 [31] phi (signed byte) atan2::x#8 = (signed byte) atan2::x#1 [phi:atan2::@4/atan2::@6->atan2::@5#0] -- register_copy 
  //SEG64 [31] phi (byte) atan2::angle#7 = (byte) atan2::angle#1 [phi:atan2::@4/atan2::@6->atan2::@5#1] -- register_copy 
  //SEG65 [31] phi (signed byte) atan2::y#8 = (signed byte) atan2::y#1 [phi:atan2::@4/atan2::@6->atan2::@5#2] -- register_copy 
    jmp b5
  //SEG66 atan2::@5
  b5:
  //SEG67 [32] (byte) atan2::i#1 ← ++ (byte) atan2::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG68 [33] if((byte) atan2::i#1==(const byte) CORDIC_ITERATIONS#0+(byte) 1) goto atan2::@3 -- vbuz1_eq_vbuc1_then_la1 
    lda #CORDIC_ITERATIONS+1
    cmp i
    beq b3_from_b5
  //SEG69 [21] phi from atan2::@5 to atan2::@1 [phi:atan2::@5->atan2::@1]
  b1_from_b5:
  //SEG70 [21] phi (byte) atan2::angle#4 = (byte) atan2::angle#7 [phi:atan2::@5->atan2::@1#0] -- register_copy 
  //SEG71 [21] phi (byte) atan2::i#2 = (byte) atan2::i#1 [phi:atan2::@5->atan2::@1#1] -- register_copy 
  //SEG72 [21] phi (signed byte) atan2::x#3 = (signed byte) atan2::x#8 [phi:atan2::@5->atan2::@1#2] -- register_copy 
  //SEG73 [21] phi (signed byte) atan2::y#3 = (signed byte) atan2::y#8 [phi:atan2::@5->atan2::@1#3] -- register_copy 
    jmp b1
  //SEG74 atan2::@4
  b4:
  //SEG75 [34] (signed byte) atan2::x#1 ← (signed byte) atan2::x#3 + (signed byte) atan2::yd#0 -- vbsz1=vbsz1_plus_vbsz2 
    lda x
    clc
    adc yd
    sta x
  //SEG76 [35] (signed byte) atan2::y#1 ← (signed byte) atan2::y#3 - (signed byte) atan2::xd#0 -- vbsz1=vbsz1_minus_vbsz2 
    lda y
    sec
    sbc xd
    sta y
  //SEG77 [36] (byte) atan2::angle#1 ← (byte) atan2::angle#4 + *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) -- vbuz1=vbuz1_plus_pbuc1_derefidx_vbuz2 
    lda angle
    ldy i
    clc
    adc CORDIC_ATAN2_ANGLES,y
    sta angle
    jmp b5_from_b4
}
//SEG78 File Data
.pc = CORDIC_ATAN2_ANGLES "CORDIC_ATAN2_ANGLES"
  .fill CORDIC_ITERATIONS, 256*atan(1/pow(2,i))/PI/2


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [16] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 [ main::y#4 main::screen#1 ] ( main:3 [ main::y#4 main::screen#1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::y#4 main::y#1 ]
Potential register analysis [25] atan2::xd#0 ← atan2::x#3 >> atan2::i#2 missing fragment Fragment not found vbsaa=vbsz1_ror_vbuaa. Attempted variations vbsaa=vbsz1_ror_vbuaa  allocation: zp ZP_BYTE:7 [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] reg byte a [ atan2::i#2 atan2::i#1 ] reg byte a [ atan2::xd#0 ] 
Potential register analysis [25] atan2::xd#0 ← atan2::x#3 >> atan2::i#2 missing fragment Fragment not found vbsaa=vbsaa_ror_vbuaa. Attempted variations vbsaa=vbsaa_ror_vbuaa  allocation: reg byte a [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] reg byte a [ atan2::i#2 atan2::i#1 ] reg byte a [ atan2::xd#0 ] 
Potential register analysis [25] atan2::xd#0 ← atan2::x#3 >> atan2::i#2 missing fragment Fragment not found vbsaa=vbsxx_ror_vbuaa. Attempted variations vbsaa=vbsxx_ror_vbuaa  allocation: reg byte x [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] reg byte a [ atan2::i#2 atan2::i#1 ] reg byte a [ atan2::xd#0 ] 
Potential register analysis [25] atan2::xd#0 ← atan2::x#3 >> atan2::i#2 missing fragment Fragment not found vbsaa=vbsyy_ror_vbuaa. Attempted variations vbsaa=vbsyy_ror_vbuaa  allocation: reg byte y [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] reg byte a [ atan2::i#2 atan2::i#1 ] reg byte a [ atan2::xd#0 ] 
Potential register analysis [25] atan2::xd#0 ← atan2::x#3 >> atan2::i#2 missing fragment Fragment not found vbsaa=vbsxx_ror_vbuxx. Attempted variations vbsaa=vbsxx_ror_vbuxx  allocation: reg byte x [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] reg byte x [ atan2::i#2 atan2::i#1 ] reg byte a [ atan2::xd#0 ] 
Potential register analysis [25] atan2::xd#0 ← atan2::x#3 >> atan2::i#2 missing fragment Fragment not found vbsaa=vbsyy_ror_vbuyy. Attempted variations vbsaa=vbsyy_ror_vbuyy  allocation: reg byte y [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] reg byte y [ atan2::i#2 atan2::i#1 ] reg byte a [ atan2::xd#0 ] 
MISSING FRAGMENTS
  Fragment not found vbsaa=vbsz1_ror_vbuaa. Attempted variations vbsaa=vbsz1_ror_vbuaa 
  Fragment not found vbsaa=vbsaa_ror_vbuaa. Attempted variations vbsaa=vbsaa_ror_vbuaa 
  Fragment not found vbsaa=vbsxx_ror_vbuaa. Attempted variations vbsaa=vbsxx_ror_vbuaa 
  Fragment not found vbsaa=vbsyy_ror_vbuaa. Attempted variations vbsaa=vbsyy_ror_vbuaa 
  Fragment not found vbsaa=vbsxx_ror_vbuxx. Attempted variations vbsaa=vbsxx_ror_vbuxx 
  Fragment not found vbsaa=vbsyy_ror_vbuyy. Attempted variations vbsaa=vbsyy_ror_vbuyy 
Statement [25] (signed byte) atan2::xd#0 ← (signed byte) atan2::x#3 >> (byte) atan2::i#2 [ atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ main::x#2 main::x#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:8 [ atan2::i#2 atan2::i#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ atan2::return#1 atan2::angle#4 atan2::angle#7 atan2::angle#1 atan2::angle#2 ]
Potential register analysis [26] atan2::yd#0 ← atan2::y#3 >> atan2::i#2 missing fragment Fragment not found vbsaa=vbsxx_ror_vbuxx. Attempted variations vbsaa=vbsxx_ror_vbuxx  allocation: reg byte x [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ] reg byte a [ atan2::yd#0 ] reg byte x [ atan2::i#2 atan2::i#1 ] 
Potential register analysis [26] atan2::yd#0 ← atan2::y#3 >> atan2::i#2 missing fragment Fragment not found vbsaa=vbsyy_ror_vbuyy. Attempted variations vbsaa=vbsyy_ror_vbuyy  allocation: reg byte y [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ] reg byte a [ atan2::yd#0 ] reg byte y [ atan2::i#2 atan2::i#1 ] 
MISSING FRAGMENTS
  Fragment not found vbsaa=vbsxx_ror_vbuxx. Attempted variations vbsaa=vbsxx_ror_vbuxx 
  Fragment not found vbsaa=vbsyy_ror_vbuyy. Attempted variations vbsaa=vbsyy_ror_vbuyy 
Statement [26] (signed byte) atan2::yd#0 ← (signed byte) atan2::y#3 >> (byte) atan2::i#2 [ atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::yd#0 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::yd#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:12 [ atan2::xd#0 ]
Statement [27] if((signed byte) atan2::y#3>(signed byte) 0) goto atan2::@4 [ atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::yd#0 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::yd#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:13 [ atan2::yd#0 ]
Statement [28] (signed byte) atan2::x#2 ← (signed byte) atan2::x#3 - (signed byte) atan2::yd#0 [ atan2::y#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::x#2 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::x#2 ] ) always clobbers reg byte a 
Statement [29] (signed byte) atan2::y#2 ← (signed byte) atan2::y#3 + (signed byte) atan2::xd#0 [ atan2::i#2 atan2::angle#4 atan2::x#2 atan2::y#2 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::i#2 atan2::angle#4 atan2::x#2 atan2::y#2 ] ) always clobbers reg byte a 
Statement [30] (byte) atan2::angle#2 ← (byte) atan2::angle#4 - *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) [ atan2::i#2 atan2::x#2 atan2::y#2 atan2::angle#2 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::i#2 atan2::x#2 atan2::y#2 atan2::angle#2 ] ) always clobbers reg byte a 
Statement [34] (signed byte) atan2::x#1 ← (signed byte) atan2::x#3 + (signed byte) atan2::yd#0 [ atan2::y#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::x#1 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::x#1 ] ) always clobbers reg byte a 
Statement [35] (signed byte) atan2::y#1 ← (signed byte) atan2::y#3 - (signed byte) atan2::xd#0 [ atan2::i#2 atan2::angle#4 atan2::y#1 atan2::x#1 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::i#2 atan2::angle#4 atan2::y#1 atan2::x#1 ] ) always clobbers reg byte a 
Statement [36] (byte) atan2::angle#1 ← (byte) atan2::angle#4 + *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) [ atan2::i#2 atan2::y#1 atan2::angle#1 atan2::x#1 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::i#2 atan2::y#1 atan2::angle#1 atan2::x#1 ] ) always clobbers reg byte a 
Statement [16] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 [ main::y#4 main::screen#1 ] ( main:3 [ main::y#4 main::screen#1 ] ) always clobbers reg byte a 
Statement [22] if((signed byte) atan2::y#3!=(signed byte) 0) goto atan2::@2 [ atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 ] ) always clobbers reg byte a 
Statement [25] (signed byte) atan2::xd#0 ← (signed byte) atan2::x#3 >> (byte) atan2::i#2 [ atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 ] ) always clobbers reg byte a 
Statement [26] (signed byte) atan2::yd#0 ← (signed byte) atan2::y#3 >> (byte) atan2::i#2 [ atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::yd#0 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::yd#0 ] ) always clobbers reg byte a 
Statement [27] if((signed byte) atan2::y#3>(signed byte) 0) goto atan2::@4 [ atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::yd#0 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::x#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::yd#0 ] ) always clobbers reg byte a 
Statement [28] (signed byte) atan2::x#2 ← (signed byte) atan2::x#3 - (signed byte) atan2::yd#0 [ atan2::y#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::x#2 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::x#2 ] ) always clobbers reg byte a 
Statement [29] (signed byte) atan2::y#2 ← (signed byte) atan2::y#3 + (signed byte) atan2::xd#0 [ atan2::i#2 atan2::angle#4 atan2::x#2 atan2::y#2 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::i#2 atan2::angle#4 atan2::x#2 atan2::y#2 ] ) always clobbers reg byte a 
Statement [30] (byte) atan2::angle#2 ← (byte) atan2::angle#4 - *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) [ atan2::i#2 atan2::x#2 atan2::y#2 atan2::angle#2 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::i#2 atan2::x#2 atan2::y#2 atan2::angle#2 ] ) always clobbers reg byte a 
Statement [34] (signed byte) atan2::x#1 ← (signed byte) atan2::x#3 + (signed byte) atan2::yd#0 [ atan2::y#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::x#1 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::y#3 atan2::i#2 atan2::angle#4 atan2::xd#0 atan2::x#1 ] ) always clobbers reg byte a 
Statement [35] (signed byte) atan2::y#1 ← (signed byte) atan2::y#3 - (signed byte) atan2::xd#0 [ atan2::i#2 atan2::angle#4 atan2::y#1 atan2::x#1 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::i#2 atan2::angle#4 atan2::y#1 atan2::x#1 ] ) always clobbers reg byte a 
Statement [36] (byte) atan2::angle#1 ← (byte) atan2::angle#4 + *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) [ atan2::i#2 atan2::y#1 atan2::angle#1 atan2::x#1 ] ( main:3::atan2:10 [ main::y#4 main::screen#5 main::x#2 atan2::i#2 atan2::y#1 atan2::angle#1 atan2::x#1 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::y#4 main::y#1 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:3 [ main::screen#5 main::screen#1 ] : zp ZP_WORD:3 , 
Potential registers zp ZP_BYTE:5 [ main::x#2 main::x#1 ] : zp ZP_BYTE:5 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ] : zp ZP_BYTE:6 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] : zp ZP_BYTE:7 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ atan2::i#2 atan2::i#1 ] : zp ZP_BYTE:8 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:9 [ atan2::return#1 atan2::angle#4 atan2::angle#7 atan2::angle#1 atan2::angle#2 ] : zp ZP_BYTE:9 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:10 [ atan2::return#0 ] : zp ZP_BYTE:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:11 [ main::angle#0 ] : zp ZP_BYTE:11 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:12 [ atan2::xd#0 ] : zp ZP_BYTE:12 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ atan2::yd#0 ] : zp ZP_BYTE:13 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [atan2] 6,484.56: zp ZP_BYTE:9 [ atan2::return#1 atan2::angle#4 atan2::angle#7 atan2::angle#1 atan2::angle#2 ] 3,912.79: zp ZP_BYTE:6 [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ] 3,171.2: zp ZP_BYTE:7 [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] 2,002: zp ZP_BYTE:8 [ atan2::i#2 atan2::i#1 ] 1,501.5: zp ZP_BYTE:13 [ atan2::yd#0 ] 600.6: zp ZP_BYTE:12 [ atan2::xd#0 ] 202: zp ZP_BYTE:10 [ atan2::return#0 ] 
Uplift Scope [main] 209.21: zp ZP_BYTE:5 [ main::x#2 main::x#1 ] 202: zp ZP_BYTE:11 [ main::angle#0 ] 27.68: zp ZP_BYTE:2 [ main::y#4 main::y#1 ] 19.63: zp ZP_WORD:3 [ main::screen#5 main::screen#1 ] 
Uplift Scope [] 

Uplifting [atan2] best 176443 combination reg byte x [ atan2::return#1 atan2::angle#4 atan2::angle#7 atan2::angle#1 atan2::angle#2 ] zp ZP_BYTE:6 [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ] zp ZP_BYTE:7 [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] zp ZP_BYTE:8 [ atan2::i#2 atan2::i#1 ] zp ZP_BYTE:13 [ atan2::yd#0 ] zp ZP_BYTE:12 [ atan2::xd#0 ] zp ZP_BYTE:10 [ atan2::return#0 ] 
Limited combination testing to 100 combinations of 2916 possible.
Uplifting [main] best 175843 combination zp ZP_BYTE:5 [ main::x#2 main::x#1 ] reg byte a [ main::angle#0 ] zp ZP_BYTE:2 [ main::y#4 main::y#1 ] zp ZP_WORD:3 [ main::screen#5 main::screen#1 ] 
Uplifting [] best 175843 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:6 [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ]
Uplifting [atan2] best 175843 combination zp ZP_BYTE:6 [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:7 [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ]
Uplifting [atan2] best 175843 combination zp ZP_BYTE:7 [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:8 [ atan2::i#2 atan2::i#1 ]
Uplifting [atan2] best 175843 combination zp ZP_BYTE:8 [ atan2::i#2 atan2::i#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:13 [ atan2::yd#0 ]
Uplifting [atan2] best 174843 combination reg byte y [ atan2::yd#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:12 [ atan2::xd#0 ]
Uplifting [atan2] best 174843 combination zp ZP_BYTE:12 [ atan2::xd#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:5 [ main::x#2 main::x#1 ]
Uplifting [main] best 174843 combination zp ZP_BYTE:5 [ main::x#2 main::x#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:10 [ atan2::return#0 ]
Uplifting [atan2] best 174443 combination reg byte a [ atan2::return#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ main::y#4 main::y#1 ]
Uplifting [main] best 174443 combination zp ZP_BYTE:2 [ main::y#4 main::y#1 ] 
Allocated (was zp ZP_BYTE:12) zp ZP_BYTE:9 [ atan2::xd#0 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Find atan2(x, y) using the CORDIC method
// See http://bsvi.ru/uploads/CORDIC--_10EBA/cordic.pdf
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  // The number of iterations performed during CORDIC atan2 calculation
  .const CORDIC_ITERATIONS = 8
  // Angles representing ATAN(0.5), ATAN(0.25), ATAN(0.125), ...
  .label CORDIC_ATAN2_ANGLES = $1000
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 kickasm(location (const byte*) CORDIC_ATAN2_ANGLES#0) {{ .fill CORDIC_ITERATIONS, 256*atan(1/pow(2,i))/PI/2  }}
// Populate cordic angles table
//SEG6 [2] phi from @1 to @2 [phi:@1->@2]
b2_from_b1:
  jmp b2
//SEG7 @2
b2:
//SEG8 [3] call main 
//SEG9 [5] phi from @2 to main [phi:@2->main]
main_from_b2:
  jsr main
//SEG10 [4] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
//SEG11 @end
bend:
//SEG12 main
main: {
    .label x = 5
    .label screen = 3
    .label y = 2
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG14 [6] phi (byte*) main::screen#5 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+1
  //SEG15 [6] phi (signed byte) main::y#4 = (signed byte) 0 [phi:main->main::@1#1] -- vbsz1=vbsc1 
    lda #0
    sta y
    jmp b1
  //SEG16 [6] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  b1_from_b3:
  //SEG17 [6] phi (byte*) main::screen#5 = (byte*) main::screen#1 [phi:main::@3->main::@1#0] -- register_copy 
  //SEG18 [6] phi (signed byte) main::y#4 = (signed byte) main::y#1 [phi:main::@3->main::@1#1] -- register_copy 
    jmp b1
  //SEG19 main::@1
  b1:
  //SEG20 [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
  //SEG21 [7] phi (signed byte) main::x#2 = (signed byte) 0 [phi:main::@1->main::@2#0] -- vbsz1=vbsc1 
    lda #0
    sta x
    jmp b2
  //SEG22 [7] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  b2_from_b4:
  //SEG23 [7] phi (signed byte) main::x#2 = (signed byte) main::x#1 [phi:main::@4->main::@2#0] -- register_copy 
    jmp b2
  //SEG24 main::@2
  b2:
  //SEG25 [8] (signed byte) atan2::x#0 ← (signed byte) main::x#2 -- vbsz1=vbsz2 
    lda x
    sta atan2.x
  //SEG26 [9] (signed byte) atan2::y#0 ← (signed byte) main::y#4 -- vbsz1=vbsz2 
    lda y
    sta atan2.y
  //SEG27 [10] call atan2 
  //SEG28 [20] phi from main::@2 to atan2 [phi:main::@2->atan2]
  atan2_from_b2:
    jsr atan2
  //SEG29 [11] (byte) atan2::return#0 ← (byte) atan2::return#1 -- vbuaa=vbuxx 
    txa
    jmp b4
  //SEG30 main::@4
  b4:
  //SEG31 [12] (byte) main::angle#0 ← (byte) atan2::return#0
  //SEG32 [13] *((byte*) main::screen#5 + (signed byte) main::x#2) ← (byte) main::angle#0 -- pbuz1_derefidx_vbsz2=vbuaa 
    ldy x
    sta (screen),y
  //SEG33 [14] (signed byte) main::x#1 ← ++ (signed byte) main::x#2 -- vbsz1=_inc_vbsz1 
    inc x
  //SEG34 [15] if((signed byte) main::x#1!=(signed byte) $28) goto main::@2 -- vbsz1_neq_vbsc1_then_la1 
    lda #$28
    cmp x
    bne b2_from_b4
    jmp b3
  //SEG35 main::@3
  b3:
  //SEG36 [16] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc screen
    sta screen
    bcc !+
    inc screen+1
  !:
  //SEG37 [17] (signed byte) main::y#1 ← ++ (signed byte) main::y#4 -- vbsz1=_inc_vbsz1 
    inc y
  //SEG38 [18] if((signed byte) main::y#1!=(signed byte) $19) goto main::@1 -- vbsz1_neq_vbsc1_then_la1 
    lda #$19
    cmp y
    bne b1_from_b3
    jmp breturn
  //SEG39 main::@return
  breturn:
  //SEG40 [19] return 
    rts
}
//SEG41 atan2
// Find the atan2(x, y) - which is the angle of the line from (0,0) to (x,y)
// Finding the angle requires a binary search using CORDIC_ITERATIONS
// Returns the angle in hex-degrees (0=0, 128=PI, 256=2*PI)
// atan2(signed byte zeropage(7) x, signed byte zeropage(6) y)
atan2: {
    .label x = 7
    .label y = 6
    .label xd = 9
    .label i = 8
  //SEG42 [21] phi from atan2 to atan2::@1 [phi:atan2->atan2::@1]
  b1_from_atan2:
  //SEG43 [21] phi (byte) atan2::angle#4 = (byte) 0 [phi:atan2->atan2::@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG44 [21] phi (byte) atan2::i#2 = (byte) 0 [phi:atan2->atan2::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta i
  //SEG45 [21] phi (signed byte) atan2::x#3 = (signed byte) atan2::x#0 [phi:atan2->atan2::@1#2] -- register_copy 
  //SEG46 [21] phi (signed byte) atan2::y#3 = (signed byte) atan2::y#0 [phi:atan2->atan2::@1#3] -- register_copy 
    jmp b1
  //SEG47 atan2::@1
  b1:
  //SEG48 [22] if((signed byte) atan2::y#3!=(signed byte) 0) goto atan2::@2 -- vbsz1_neq_0_then_la1 
    lda y
    cmp #0
    bne b2
  //SEG49 [23] phi from atan2::@1 atan2::@5 to atan2::@3 [phi:atan2::@1/atan2::@5->atan2::@3]
  b3_from_b1:
  b3_from_b5:
  //SEG50 [23] phi (byte) atan2::return#1 = (byte) atan2::angle#4 [phi:atan2::@1/atan2::@5->atan2::@3#0] -- register_copy 
    jmp b3
  //SEG51 atan2::@3
  b3:
    jmp breturn
  //SEG52 atan2::@return
  breturn:
  //SEG53 [24] return 
    rts
  //SEG54 atan2::@2
  b2:
  //SEG55 [25] (signed byte) atan2::xd#0 ← (signed byte) atan2::x#3 >> (byte) atan2::i#2 -- vbsz1=vbsz2_ror_vbuz3 
    lda x
    ldy i
    cpy #0
    beq !e+
  !l:
    cmp #$80
    ror
    dey
    bne !l-
  !e:
    sta xd
  //SEG56 [26] (signed byte) atan2::yd#0 ← (signed byte) atan2::y#3 >> (byte) atan2::i#2 -- vbsyy=vbsz1_ror_vbuz2 
    lda y
    ldy i
    cpy #0
    beq !e+
  !l:
    cmp #$80
    ror
    dey
    bne !l-
  !e:
    tay
  //SEG57 [27] if((signed byte) atan2::y#3>(signed byte) 0) goto atan2::@4 -- vbsz1_gt_0_then_la1 
    lda y
    cmp #0
    beq !+
    bpl b4
  !:
    jmp b6
  //SEG58 atan2::@6
  b6:
  //SEG59 [28] (signed byte) atan2::x#2 ← (signed byte) atan2::x#3 - (signed byte) atan2::yd#0 -- vbsz1=vbsz1_minus_vbsyy 
    tya
    eor #$ff
    sec
    adc x
    sta x
  //SEG60 [29] (signed byte) atan2::y#2 ← (signed byte) atan2::y#3 + (signed byte) atan2::xd#0 -- vbsz1=vbsz1_plus_vbsz2 
    lda y
    clc
    adc xd
    sta y
  //SEG61 [30] (byte) atan2::angle#2 ← (byte) atan2::angle#4 - *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) -- vbuxx=vbuxx_minus_pbuc1_derefidx_vbuz1 
    txa
    ldx i
    sec
    sbc CORDIC_ATAN2_ANGLES,x
    tax
  //SEG62 [31] phi from atan2::@4 atan2::@6 to atan2::@5 [phi:atan2::@4/atan2::@6->atan2::@5]
  b5_from_b4:
  b5_from_b6:
  //SEG63 [31] phi (signed byte) atan2::x#8 = (signed byte) atan2::x#1 [phi:atan2::@4/atan2::@6->atan2::@5#0] -- register_copy 
  //SEG64 [31] phi (byte) atan2::angle#7 = (byte) atan2::angle#1 [phi:atan2::@4/atan2::@6->atan2::@5#1] -- register_copy 
  //SEG65 [31] phi (signed byte) atan2::y#8 = (signed byte) atan2::y#1 [phi:atan2::@4/atan2::@6->atan2::@5#2] -- register_copy 
    jmp b5
  //SEG66 atan2::@5
  b5:
  //SEG67 [32] (byte) atan2::i#1 ← ++ (byte) atan2::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG68 [33] if((byte) atan2::i#1==(const byte) CORDIC_ITERATIONS#0+(byte) 1) goto atan2::@3 -- vbuz1_eq_vbuc1_then_la1 
    lda #CORDIC_ITERATIONS+1
    cmp i
    beq b3_from_b5
  //SEG69 [21] phi from atan2::@5 to atan2::@1 [phi:atan2::@5->atan2::@1]
  b1_from_b5:
  //SEG70 [21] phi (byte) atan2::angle#4 = (byte) atan2::angle#7 [phi:atan2::@5->atan2::@1#0] -- register_copy 
  //SEG71 [21] phi (byte) atan2::i#2 = (byte) atan2::i#1 [phi:atan2::@5->atan2::@1#1] -- register_copy 
  //SEG72 [21] phi (signed byte) atan2::x#3 = (signed byte) atan2::x#8 [phi:atan2::@5->atan2::@1#2] -- register_copy 
  //SEG73 [21] phi (signed byte) atan2::y#3 = (signed byte) atan2::y#8 [phi:atan2::@5->atan2::@1#3] -- register_copy 
    jmp b1
  //SEG74 atan2::@4
  b4:
  //SEG75 [34] (signed byte) atan2::x#1 ← (signed byte) atan2::x#3 + (signed byte) atan2::yd#0 -- vbsz1=vbsz1_plus_vbsyy 
    tya
    clc
    adc x
    sta x
  //SEG76 [35] (signed byte) atan2::y#1 ← (signed byte) atan2::y#3 - (signed byte) atan2::xd#0 -- vbsz1=vbsz1_minus_vbsz2 
    lda y
    sec
    sbc xd
    sta y
  //SEG77 [36] (byte) atan2::angle#1 ← (byte) atan2::angle#4 + *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) -- vbuxx=vbuxx_plus_pbuc1_derefidx_vbuz1 
    txa
    ldx i
    clc
    adc CORDIC_ATAN2_ANGLES,x
    tax
    jmp b5_from_b4
}
//SEG78 File Data
.pc = CORDIC_ATAN2_ANGLES "CORDIC_ATAN2_ANGLES"
  .fill CORDIC_ITERATIONS, 256*atan(1/pow(2,i))/PI/2


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b6
Removing instruction jmp b5
Succesful ASM optimization Pass5NextJumpElimination
Replacing instruction lda #0 with TXA
Replacing label b2_from_b4 with b2
Replacing label b1_from_b3 with b1
Replacing label b3_from_b5 with b3
Replacing label b5_from_b4 with b5
Removing instruction b1:
Removing instruction b2_from_b1:
Removing instruction main_from_b2:
Removing instruction bend_from_b2:
Removing instruction b1_from_b3:
Removing instruction b2_from_b1:
Removing instruction b2_from_b4:
Removing instruction b3_from_b1:
Removing instruction b3_from_b5:
Removing instruction breturn:
Removing instruction b5_from_b4:
Removing instruction b5_from_b6:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b2:
Removing instruction bend:
Removing instruction b1_from_main:
Removing instruction atan2_from_b2:
Removing instruction b4:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b1_from_atan2:
Removing instruction b6:
Removing instruction b1_from_b5:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Removing instruction jmp b2
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #$28
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @2
(label) @begin
(label) @end
(byte*) CORDIC_ATAN2_ANGLES
(const byte*) CORDIC_ATAN2_ANGLES#0 CORDIC_ATAN2_ANGLES = (byte*) 4096
(byte) CORDIC_ITERATIONS
(const byte) CORDIC_ITERATIONS#0 CORDIC_ITERATIONS = (byte) 8
(byte()) atan2((signed byte) atan2::x , (signed byte) atan2::y)
(label) atan2::@1
(label) atan2::@2
(label) atan2::@3
(label) atan2::@4
(label) atan2::@5
(label) atan2::@6
(label) atan2::@return
(byte) atan2::angle
(byte) atan2::angle#1 reg byte x 2002.0
(byte) atan2::angle#2 reg byte x 2002.0
(byte) atan2::angle#4 reg byte x 444.8888888888889
(byte) atan2::angle#7 reg byte x 1334.6666666666667
(byte) atan2::i
(byte) atan2::i#1 i zp ZP_BYTE:8 1501.5
(byte) atan2::i#2 i zp ZP_BYTE:8 500.50000000000006
(byte) atan2::return
(byte) atan2::return#0 reg byte a 202.0
(byte) atan2::return#1 reg byte x 701.0
(signed byte) atan2::x
(signed byte) atan2::x#0 x zp ZP_BYTE:7 34.33333333333333
(signed byte) atan2::x#1 x zp ZP_BYTE:7 667.3333333333334
(signed byte) atan2::x#2 x zp ZP_BYTE:7 667.3333333333334
(signed byte) atan2::x#3 x zp ZP_BYTE:7 801.2
(signed byte) atan2::x#8 x zp ZP_BYTE:7 1001.0
(signed byte) atan2::xd
(signed byte) atan2::xd#0 xd zp ZP_BYTE:9 600.5999999999999
(signed byte) atan2::y
(signed byte) atan2::y#0 y zp ZP_BYTE:6 51.5
(signed byte) atan2::y#1 y zp ZP_BYTE:6 1001.0
(signed byte) atan2::y#2 y zp ZP_BYTE:6 1001.0
(signed byte) atan2::y#3 y zp ZP_BYTE:6 858.2857142857142
(signed byte) atan2::y#8 y zp ZP_BYTE:6 1001.0
(signed byte) atan2::yd
(signed byte) atan2::yd#0 reg byte y 1501.5
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return
(byte) main::angle
(byte) main::angle#0 reg byte a 202.0
(byte*) main::screen
(byte*) main::screen#1 screen zp ZP_WORD:3 7.333333333333333
(byte*) main::screen#5 screen zp ZP_WORD:3 12.299999999999999
(signed byte) main::x
(signed byte) main::x#1 x zp ZP_BYTE:5 151.5
(signed byte) main::x#2 x zp ZP_BYTE:5 57.714285714285715
(signed byte) main::y
(signed byte) main::y#1 y zp ZP_BYTE:2 16.5
(signed byte) main::y#4 y zp ZP_BYTE:2 11.181818181818182

zp ZP_BYTE:2 [ main::y#4 main::y#1 ]
zp ZP_WORD:3 [ main::screen#5 main::screen#1 ]
zp ZP_BYTE:5 [ main::x#2 main::x#1 ]
zp ZP_BYTE:6 [ atan2::y#3 atan2::y#0 atan2::y#8 atan2::y#1 atan2::y#2 ]
zp ZP_BYTE:7 [ atan2::x#3 atan2::x#0 atan2::x#8 atan2::x#1 atan2::x#2 ]
zp ZP_BYTE:8 [ atan2::i#2 atan2::i#1 ]
reg byte x [ atan2::return#1 atan2::angle#4 atan2::angle#7 atan2::angle#1 atan2::angle#2 ]
reg byte a [ atan2::return#0 ]
reg byte a [ main::angle#0 ]
zp ZP_BYTE:9 [ atan2::xd#0 ]
reg byte y [ atan2::yd#0 ]


FINAL ASSEMBLER
Score: 164058

//SEG0 File Comments
// Find atan2(x, y) using the CORDIC method
// See http://bsvi.ru/uploads/CORDIC--_10EBA/cordic.pdf
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  // The number of iterations performed during CORDIC atan2 calculation
  .const CORDIC_ITERATIONS = 8
  // Angles representing ATAN(0.5), ATAN(0.25), ATAN(0.125), ...
  .label CORDIC_ATAN2_ANGLES = $1000
//SEG3 @begin
//SEG4 @1
//SEG5 kickasm(location (const byte*) CORDIC_ATAN2_ANGLES#0) {{ .fill CORDIC_ITERATIONS, 256*atan(1/pow(2,i))/PI/2  }}
// Populate cordic angles table
//SEG6 [2] phi from @1 to @2 [phi:@1->@2]
//SEG7 @2
//SEG8 [3] call main 
//SEG9 [5] phi from @2 to main [phi:@2->main]
//SEG10 [4] phi from @2 to @end [phi:@2->@end]
//SEG11 @end
//SEG12 main
main: {
    .label x = 5
    .label screen = 3
    .label y = 2
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  //SEG14 [6] phi (byte*) main::screen#5 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+1
  //SEG15 [6] phi (signed byte) main::y#4 = (signed byte) 0 [phi:main->main::@1#1] -- vbsz1=vbsc1 
    lda #0
    sta y
  //SEG16 [6] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  //SEG17 [6] phi (byte*) main::screen#5 = (byte*) main::screen#1 [phi:main::@3->main::@1#0] -- register_copy 
  //SEG18 [6] phi (signed byte) main::y#4 = (signed byte) main::y#1 [phi:main::@3->main::@1#1] -- register_copy 
  //SEG19 main::@1
  b1:
  //SEG20 [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  //SEG21 [7] phi (signed byte) main::x#2 = (signed byte) 0 [phi:main::@1->main::@2#0] -- vbsz1=vbsc1 
    lda #0
    sta x
  //SEG22 [7] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  //SEG23 [7] phi (signed byte) main::x#2 = (signed byte) main::x#1 [phi:main::@4->main::@2#0] -- register_copy 
  //SEG24 main::@2
  b2:
  //SEG25 [8] (signed byte) atan2::x#0 ← (signed byte) main::x#2 -- vbsz1=vbsz2 
    lda x
    sta atan2.x
  //SEG26 [9] (signed byte) atan2::y#0 ← (signed byte) main::y#4 -- vbsz1=vbsz2 
    lda y
    sta atan2.y
  //SEG27 [10] call atan2 
  //SEG28 [20] phi from main::@2 to atan2 [phi:main::@2->atan2]
    jsr atan2
  //SEG29 [11] (byte) atan2::return#0 ← (byte) atan2::return#1 -- vbuaa=vbuxx 
    txa
  //SEG30 main::@4
  //SEG31 [12] (byte) main::angle#0 ← (byte) atan2::return#0
  //SEG32 [13] *((byte*) main::screen#5 + (signed byte) main::x#2) ← (byte) main::angle#0 -- pbuz1_derefidx_vbsz2=vbuaa 
    ldy x
    sta (screen),y
  //SEG33 [14] (signed byte) main::x#1 ← ++ (signed byte) main::x#2 -- vbsz1=_inc_vbsz1 
    inc x
  //SEG34 [15] if((signed byte) main::x#1!=(signed byte) $28) goto main::@2 -- vbsz1_neq_vbsc1_then_la1 
    lda #$28
    cmp x
    bne b2
  //SEG35 main::@3
  //SEG36 [16] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    clc
    adc screen
    sta screen
    bcc !+
    inc screen+1
  !:
  //SEG37 [17] (signed byte) main::y#1 ← ++ (signed byte) main::y#4 -- vbsz1=_inc_vbsz1 
    inc y
  //SEG38 [18] if((signed byte) main::y#1!=(signed byte) $19) goto main::@1 -- vbsz1_neq_vbsc1_then_la1 
    lda #$19
    cmp y
    bne b1
  //SEG39 main::@return
  //SEG40 [19] return 
    rts
}
//SEG41 atan2
// Find the atan2(x, y) - which is the angle of the line from (0,0) to (x,y)
// Finding the angle requires a binary search using CORDIC_ITERATIONS
// Returns the angle in hex-degrees (0=0, 128=PI, 256=2*PI)
// atan2(signed byte zeropage(7) x, signed byte zeropage(6) y)
atan2: {
    .label x = 7
    .label y = 6
    .label xd = 9
    .label i = 8
  //SEG42 [21] phi from atan2 to atan2::@1 [phi:atan2->atan2::@1]
  //SEG43 [21] phi (byte) atan2::angle#4 = (byte) 0 [phi:atan2->atan2::@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG44 [21] phi (byte) atan2::i#2 = (byte) 0 [phi:atan2->atan2::@1#1] -- vbuz1=vbuc1 
    txa
    sta i
  //SEG45 [21] phi (signed byte) atan2::x#3 = (signed byte) atan2::x#0 [phi:atan2->atan2::@1#2] -- register_copy 
  //SEG46 [21] phi (signed byte) atan2::y#3 = (signed byte) atan2::y#0 [phi:atan2->atan2::@1#3] -- register_copy 
  //SEG47 atan2::@1
  b1:
  //SEG48 [22] if((signed byte) atan2::y#3!=(signed byte) 0) goto atan2::@2 -- vbsz1_neq_0_then_la1 
    lda y
    cmp #0
    bne b2
  //SEG49 [23] phi from atan2::@1 atan2::@5 to atan2::@3 [phi:atan2::@1/atan2::@5->atan2::@3]
  //SEG50 [23] phi (byte) atan2::return#1 = (byte) atan2::angle#4 [phi:atan2::@1/atan2::@5->atan2::@3#0] -- register_copy 
  //SEG51 atan2::@3
  b3:
  //SEG52 atan2::@return
  //SEG53 [24] return 
    rts
  //SEG54 atan2::@2
  b2:
  //SEG55 [25] (signed byte) atan2::xd#0 ← (signed byte) atan2::x#3 >> (byte) atan2::i#2 -- vbsz1=vbsz2_ror_vbuz3 
    lda x
    ldy i
    cpy #0
    beq !e+
  !l:
    cmp #$80
    ror
    dey
    bne !l-
  !e:
    sta xd
  //SEG56 [26] (signed byte) atan2::yd#0 ← (signed byte) atan2::y#3 >> (byte) atan2::i#2 -- vbsyy=vbsz1_ror_vbuz2 
    lda y
    ldy i
    cpy #0
    beq !e+
  !l:
    cmp #$80
    ror
    dey
    bne !l-
  !e:
    tay
  //SEG57 [27] if((signed byte) atan2::y#3>(signed byte) 0) goto atan2::@4 -- vbsz1_gt_0_then_la1 
    lda y
    cmp #0
    beq !+
    bpl b4
  !:
  //SEG58 atan2::@6
  //SEG59 [28] (signed byte) atan2::x#2 ← (signed byte) atan2::x#3 - (signed byte) atan2::yd#0 -- vbsz1=vbsz1_minus_vbsyy 
    tya
    eor #$ff
    sec
    adc x
    sta x
  //SEG60 [29] (signed byte) atan2::y#2 ← (signed byte) atan2::y#3 + (signed byte) atan2::xd#0 -- vbsz1=vbsz1_plus_vbsz2 
    lda y
    clc
    adc xd
    sta y
  //SEG61 [30] (byte) atan2::angle#2 ← (byte) atan2::angle#4 - *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) -- vbuxx=vbuxx_minus_pbuc1_derefidx_vbuz1 
    txa
    ldx i
    sec
    sbc CORDIC_ATAN2_ANGLES,x
    tax
  //SEG62 [31] phi from atan2::@4 atan2::@6 to atan2::@5 [phi:atan2::@4/atan2::@6->atan2::@5]
  //SEG63 [31] phi (signed byte) atan2::x#8 = (signed byte) atan2::x#1 [phi:atan2::@4/atan2::@6->atan2::@5#0] -- register_copy 
  //SEG64 [31] phi (byte) atan2::angle#7 = (byte) atan2::angle#1 [phi:atan2::@4/atan2::@6->atan2::@5#1] -- register_copy 
  //SEG65 [31] phi (signed byte) atan2::y#8 = (signed byte) atan2::y#1 [phi:atan2::@4/atan2::@6->atan2::@5#2] -- register_copy 
  //SEG66 atan2::@5
  b5:
  //SEG67 [32] (byte) atan2::i#1 ← ++ (byte) atan2::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG68 [33] if((byte) atan2::i#1==(const byte) CORDIC_ITERATIONS#0+(byte) 1) goto atan2::@3 -- vbuz1_eq_vbuc1_then_la1 
    lda #CORDIC_ITERATIONS+1
    cmp i
    beq b3
  //SEG69 [21] phi from atan2::@5 to atan2::@1 [phi:atan2::@5->atan2::@1]
  //SEG70 [21] phi (byte) atan2::angle#4 = (byte) atan2::angle#7 [phi:atan2::@5->atan2::@1#0] -- register_copy 
  //SEG71 [21] phi (byte) atan2::i#2 = (byte) atan2::i#1 [phi:atan2::@5->atan2::@1#1] -- register_copy 
  //SEG72 [21] phi (signed byte) atan2::x#3 = (signed byte) atan2::x#8 [phi:atan2::@5->atan2::@1#2] -- register_copy 
  //SEG73 [21] phi (signed byte) atan2::y#3 = (signed byte) atan2::y#8 [phi:atan2::@5->atan2::@1#3] -- register_copy 
    jmp b1
  //SEG74 atan2::@4
  b4:
  //SEG75 [34] (signed byte) atan2::x#1 ← (signed byte) atan2::x#3 + (signed byte) atan2::yd#0 -- vbsz1=vbsz1_plus_vbsyy 
    tya
    clc
    adc x
    sta x
  //SEG76 [35] (signed byte) atan2::y#1 ← (signed byte) atan2::y#3 - (signed byte) atan2::xd#0 -- vbsz1=vbsz1_minus_vbsz2 
    lda y
    sec
    sbc xd
    sta y
  //SEG77 [36] (byte) atan2::angle#1 ← (byte) atan2::angle#4 + *((const byte*) CORDIC_ATAN2_ANGLES#0 + (byte) atan2::i#2) -- vbuxx=vbuxx_plus_pbuc1_derefidx_vbuz1 
    txa
    ldx i
    clc
    adc CORDIC_ATAN2_ANGLES,x
    tax
    jmp b5
}
//SEG78 File Data
.pc = CORDIC_ATAN2_ANGLES "CORDIC_ATAN2_ANGLES"
  .fill CORDIC_ITERATIONS, 256*atan(1/pow(2,i))/PI/2


