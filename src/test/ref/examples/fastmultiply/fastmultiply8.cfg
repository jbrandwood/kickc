@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  [5] call init_screen 
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [6] (byte*) main::at#4 ← phi( main/(byte*) 1024+(byte) 4 main::@5/(byte*) main::at#1 )
  [6] (byte) main::k#2 ← phi( main/(byte) 0 main::@5/(byte) main::k#1 )
  [7] (signed byte) print_sbyte_at::b#1 ← *((const signed byte[]) vals + (byte) main::k#2)
  [8] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4
  [9] call print_sbyte_at 
  to:main::@5
main::@5: scope:[main]  from main::@1
  [10] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4
  [11] (byte) main::k#1 ← ++ (byte) main::k#2
  [12] if((byte) main::k#1!=(byte) 9) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@4 main::@5
  [13] (byte) main::i#2 ← phi( main::@5/(byte) 0 main::@4/(byte) main::i#1 )
  [13] (byte*) main::at_line#2 ← phi( main::@5/(byte*) 1024 main::@4/(byte*) main::at#2 )
  [14] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28
  [15] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals + (byte) main::i#2)
  [16] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2
  [17] call print_sbyte_at 
  to:main::@6
main::@6: scope:[main]  from main::@2
  [18] (byte*) main::at#12 ← (byte*) main::at#2
  to:main::@3
main::@3: scope:[main]  from main::@6 main::@8
  [19] (byte) main::j#2 ← phi( main::@8/(byte) main::j#1 main::@6/(byte) 0 )
  [19] (byte*) main::at#6 ← phi( main::@8/(byte*) main::at#3 main::@6/(byte*) main::at#12 )
  [20] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4
  [21] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals + (byte) main::i#2)
  [22] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals + (byte) main::j#2)
  [23] call fmul8 
  [24] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1
  to:main::@7
main::@7: scope:[main]  from main::@3
  [25] (signed byte) main::r#0 ← (signed byte) fmul8::return#0
  [26] (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0
  [27] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3
  [28] call print_sbyte_at 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [29] (byte) main::j#1 ← ++ (byte) main::j#2
  [30] if((byte) main::j#1!=(byte) 9) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@8
  [31] (byte) main::i#1 ← ++ (byte) main::i#2
  [32] if((byte) main::i#1!=(byte) 9) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@4
  [33] return 
  to:@return

(void()) print_sbyte_at((signed byte) print_sbyte_at::b , (byte*) print_sbyte_at::at)
print_sbyte_at: scope:[print_sbyte_at]  from main::@1 main::@2 main::@7
  [34] (byte*) print_sbyte_at::at#3 ← phi( main::@1/(byte*) print_sbyte_at::at#0 main::@7/(byte*) print_sbyte_at::at#2 main::@2/(byte*) print_sbyte_at::at#1 )
  [34] (signed byte) print_sbyte_at::b#4 ← phi( main::@1/(signed byte) print_sbyte_at::b#1 main::@7/(signed byte) print_sbyte_at::b#3 main::@2/(signed byte) print_sbyte_at::b#2 )
  [35] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1
  to:print_sbyte_at::@3
print_sbyte_at::@3: scope:[print_sbyte_at]  from print_sbyte_at
  [36] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3
  [37] call print_char_at 
  to:print_sbyte_at::@2
print_sbyte_at::@2: scope:[print_sbyte_at]  from print_sbyte_at::@3 print_sbyte_at::@4
  [38] (signed byte) print_sbyte_at::b#6 ← phi( print_sbyte_at::@4/(signed byte) print_sbyte_at::b#0 print_sbyte_at::@3/(signed byte) print_sbyte_at::b#4 )
  [39] (byte) print_byte_at::b#0 ← (byte)(signed byte) print_sbyte_at::b#6
  [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1
  [41] call print_byte_at 
  to:print_sbyte_at::@return
print_sbyte_at::@return: scope:[print_sbyte_at]  from print_sbyte_at::@2
  [42] return 
  to:@return
print_sbyte_at::@1: scope:[print_sbyte_at]  from print_sbyte_at
  [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3
  [44] call print_char_at 
  to:print_sbyte_at::@4
print_sbyte_at::@4: scope:[print_sbyte_at]  from print_sbyte_at::@1
  [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4
  to:print_sbyte_at::@2

(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
print_char_at: scope:[print_char_at]  from print_byte_at print_byte_at::@1 print_sbyte_at::@1 print_sbyte_at::@3
  [46] (byte*) print_char_at::at#4 ← phi( print_byte_at/(byte*) print_char_at::at#2 print_byte_at::@1/(byte*) print_char_at::at#3 print_sbyte_at::@1/(byte*) print_char_at::at#0 print_sbyte_at::@3/(byte*) print_char_at::at#1 )
  [46] (byte) print_char_at::ch#4 ← phi( print_byte_at/(byte) print_char_at::ch#2 print_byte_at::@1/(byte) print_char_at::ch#3 print_sbyte_at::@1/(byte) '-' print_sbyte_at::@3/(byte) ' ' )
  [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  [48] return 
  to:@return

(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
print_byte_at: scope:[print_byte_at]  from print_sbyte_at::@2
  [49] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#0 >> (byte) 4
  [50] (byte) print_char_at::ch#2 ← *((const byte[]) print_hextab + (byte~) print_byte_at::$0)
  [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0
  [52] call print_char_at 
  to:print_byte_at::@1
print_byte_at::@1: scope:[print_byte_at]  from print_byte_at
  [53] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#0 & (byte) $f
  [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1
  [55] (byte) print_char_at::ch#3 ← *((const byte[]) print_hextab + (byte~) print_byte_at::$2)
  [56] call print_char_at 
  to:print_byte_at::@return
print_byte_at::@return: scope:[print_byte_at]  from print_byte_at::@1
  [57] return 
  to:@return

(signed byte()) fmul8((signed byte) fmul8::a , (signed byte) fmul8::b)
fmul8: scope:[fmul8]  from main::@3
  [58] *((const signed byte*) ap) ← (signed byte) fmul8::a#0
  [59] *((const signed byte*) bp) ← (signed byte) fmul8::b#0
  asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
  [61] (signed byte) fmul8::return#1 ← *((const signed byte*) cp)
  to:fmul8::@return
fmul8::@return: scope:[fmul8]  from fmul8
  [62] return 
  to:@return

(void()) init_screen()
init_screen: scope:[init_screen]  from main
  [63] phi()
  [64] call print_cls 
  to:init_screen::@1
init_screen::@1: scope:[init_screen]  from init_screen init_screen::@1
  [65] (byte) init_screen::l#2 ← phi( init_screen::@1/(byte) init_screen::l#1 init_screen/(byte) 0 )
  [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE
  [67] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2
  [68] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1
  to:init_screen::@2
init_screen::@2: scope:[init_screen]  from init_screen::@1 init_screen::@2
  [69] (byte) init_screen::m#2 ← phi( init_screen::@1/(byte) 0 init_screen::@2/(byte) init_screen::m#1 )
  [69] (byte*) init_screen::COLS#3 ← phi( init_screen::@1/(byte*) 55296 init_screen::@2/(byte*) init_screen::COLS#1 )
  [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE
  [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE
  [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE
  [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE
  [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28
  [75] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2
  [76] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2
  to:init_screen::@return
init_screen::@return: scope:[init_screen]  from init_screen::@2
  [77] return 
  to:@return

(void()) print_cls()
print_cls: scope:[print_cls]  from init_screen
  [78] phi()
  [79] call memset 
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls
  [80] return 
  to:@return

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from print_cls
  [81] phi()
  to:memset::@1
memset::@1: scope:[memset]  from memset memset::@2
  [82] (byte*) memset::dst#2 ← phi( memset/(byte*)(const void*) memset::str#0 memset::@2/(byte*) memset::dst#1 )
  [83] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset::@1
  [84] return 
  to:@return
memset::@2: scope:[memset]  from memset::@1
  [85] *((byte*) memset::dst#2) ← (const byte) memset::c#0
  [86] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  to:memset::@1
