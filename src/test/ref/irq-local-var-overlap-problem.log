Resolved forward reference irq to __interrupt(rom_min_c64) void irq()

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start
  asm { sei  }
  *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR
  *VICII_CONTROL = *VICII_CONTROL & $7f
  *RASTER = $fd
  *IRQ_ENABLE = IRQ_RASTER
  *KERNEL_IRQ = &irq
  asm { cli  }
  to:main::@1
main::@1: scope:[main]  from main main::@7
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  main::i#0 = 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@7
  main::i#7 = phi( main::@2/main::i#0, main::@7/main::i#1 )
  main::j#0 = 0
  to:main::@4
main::@4: scope:[main]  from main::@3 main::@6
  main::j#4 = phi( main::@3/main::j#0, main::@6/main::j#1 )
  main::i#4 = phi( main::@3/main::i#7, main::@6/main::i#6 )
  main::k#0 = 0
  to:main::@5
main::@5: scope:[main]  from main::@4 main::@8
  main::k#2 = phi( main::@4/main::k#0, main::@8/main::k#1 )
  main::j#2 = phi( main::@4/main::j#4, main::@8/main::j#5 )
  main::i#2 = phi( main::@4/main::i#4, main::@8/main::i#5 )
  main::$0 = main::i#2 + main::j#2
  main::$1 = main::$0 + main::k#2
  *FGCOL = main::$1
  call sub_main 
  to:main::@8
main::@8: scope:[main]  from main::@5
  main::j#5 = phi( main::@5/main::j#2 )
  main::i#5 = phi( main::@5/main::i#2 )
  main::k#3 = phi( main::@5/main::k#2 )
  main::k#1 = main::k#3 + rangenext(0,$a)
  main::$3 = main::k#1 != rangelast(0,$a)
  if(main::$3) goto main::@5
  to:main::@6
main::@6: scope:[main]  from main::@8
  main::i#6 = phi( main::@8/main::i#5 )
  main::j#3 = phi( main::@8/main::j#5 )
  main::j#1 = main::j#3 + rangenext(0,$a)
  main::$4 = main::j#1 != rangelast(0,$a)
  if(main::$4) goto main::@4
  to:main::@7
main::@7: scope:[main]  from main::@6
  main::i#3 = phi( main::@6/main::i#6 )
  main::i#1 = main::i#3 + rangenext(0,$a)
  main::$5 = main::i#1 != rangelast(0,$a)
  if(main::$5) goto main::@3
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return

__interrupt(rom_min_c64) void irq()
irq: scope:[irq]  from
  *BG_COLOR = ++ *BG_COLOR
  irq::i#0 = 0
  to:irq::@1
irq::@1: scope:[irq]  from irq irq::@5
  irq::i#7 = phi( irq/irq::i#0, irq::@5/irq::i#1 )
  irq::j#0 = 0
  to:irq::@2
irq::@2: scope:[irq]  from irq::@1 irq::@4
  irq::j#4 = phi( irq::@1/irq::j#0, irq::@4/irq::j#1 )
  irq::i#4 = phi( irq::@1/irq::i#7, irq::@4/irq::i#6 )
  irq::k#0 = 0
  to:irq::@3
irq::@3: scope:[irq]  from irq::@2 irq::@7
  irq::k#2 = phi( irq::@2/irq::k#0, irq::@7/irq::k#1 )
  irq::j#2 = phi( irq::@2/irq::j#4, irq::@7/irq::j#5 )
  irq::i#2 = phi( irq::@2/irq::i#4, irq::@7/irq::i#5 )
  irq::$2 = irq::i#2 + irq::j#2
  irq::$3 = irq::$2 + irq::k#2
  *FGCOL = irq::$3
  call sub_irq 
  to:irq::@7
irq::@7: scope:[irq]  from irq::@3
  irq::j#5 = phi( irq::@3/irq::j#2 )
  irq::i#5 = phi( irq::@3/irq::i#2 )
  irq::k#3 = phi( irq::@3/irq::k#2 )
  irq::k#1 = irq::k#3 + rangenext(0,$a)
  irq::$5 = irq::k#1 != rangelast(0,$a)
  if(irq::$5) goto irq::@3
  to:irq::@4
irq::@4: scope:[irq]  from irq::@7
  irq::i#6 = phi( irq::@7/irq::i#5 )
  irq::j#3 = phi( irq::@7/irq::j#5 )
  irq::j#1 = irq::j#3 + rangenext(0,$a)
  irq::$6 = irq::j#1 != rangelast(0,$a)
  if(irq::$6) goto irq::@2
  to:irq::@5
irq::@5: scope:[irq]  from irq::@4
  irq::i#3 = phi( irq::@4/irq::i#6 )
  irq::i#1 = irq::i#3 + rangenext(0,$a)
  irq::$7 = irq::i#1 != rangelast(0,$a)
  if(irq::$7) goto irq::@1
  to:irq::@6
irq::@6: scope:[irq]  from irq::@5
  *IRQ_STATUS = IRQ_RASTER
  *BG_COLOR = -- *BG_COLOR
  to:irq::@return
irq::@return: scope:[irq]  from irq::@6
  return 
  to:@return

void sub_main()
sub_main: scope:[sub_main]  from main::@5
  sub_main::i#0 = 0
  to:sub_main::@1
sub_main::@1: scope:[sub_main]  from sub_main sub_main::@5
  sub_main::i#6 = phi( sub_main/sub_main::i#0, sub_main::@5/sub_main::i#1 )
  sub_main::j#0 = 0
  to:sub_main::@2
sub_main::@2: scope:[sub_main]  from sub_main::@1 sub_main::@4
  sub_main::j#4 = phi( sub_main::@1/sub_main::j#0, sub_main::@4/sub_main::j#1 )
  sub_main::i#4 = phi( sub_main::@1/sub_main::i#6, sub_main::@4/sub_main::i#5 )
  sub_main::k#0 = 0
  to:sub_main::@3
sub_main::@3: scope:[sub_main]  from sub_main::@2 sub_main::@3
  sub_main::k#2 = phi( sub_main::@2/sub_main::k#0, sub_main::@3/sub_main::k#1 )
  sub_main::j#2 = phi( sub_main::@2/sub_main::j#4, sub_main::@3/sub_main::j#2 )
  sub_main::i#2 = phi( sub_main::@2/sub_main::i#4, sub_main::@3/sub_main::i#2 )
  sub_main::$0 = sub_main::i#2 + sub_main::j#2
  sub_main::$1 = sub_main::$0 + sub_main::k#2
  *BG_COLOR = sub_main::$1
  sub_main::k#1 = sub_main::k#2 + rangenext(0,$a)
  sub_main::$2 = sub_main::k#1 != rangelast(0,$a)
  if(sub_main::$2) goto sub_main::@3
  to:sub_main::@4
sub_main::@4: scope:[sub_main]  from sub_main::@3
  sub_main::i#5 = phi( sub_main::@3/sub_main::i#2 )
  sub_main::j#3 = phi( sub_main::@3/sub_main::j#2 )
  sub_main::j#1 = sub_main::j#3 + rangenext(0,$a)
  sub_main::$3 = sub_main::j#1 != rangelast(0,$a)
  if(sub_main::$3) goto sub_main::@2
  to:sub_main::@5
sub_main::@5: scope:[sub_main]  from sub_main::@4
  sub_main::i#3 = phi( sub_main::@4/sub_main::i#5 )
  sub_main::i#1 = sub_main::i#3 + rangenext(0,$a)
  sub_main::$4 = sub_main::i#1 != rangelast(0,$a)
  if(sub_main::$4) goto sub_main::@1
  to:sub_main::@return
sub_main::@return: scope:[sub_main]  from sub_main::@5
  return 
  to:@return

void sub_irq()
sub_irq: scope:[sub_irq]  from irq::@3
  sub_irq::i#0 = 0
  to:sub_irq::@1
sub_irq::@1: scope:[sub_irq]  from sub_irq sub_irq::@5
  sub_irq::i#6 = phi( sub_irq/sub_irq::i#0, sub_irq::@5/sub_irq::i#1 )
  sub_irq::j#0 = 0
  to:sub_irq::@2
sub_irq::@2: scope:[sub_irq]  from sub_irq::@1 sub_irq::@4
  sub_irq::j#4 = phi( sub_irq::@1/sub_irq::j#0, sub_irq::@4/sub_irq::j#1 )
  sub_irq::i#4 = phi( sub_irq::@1/sub_irq::i#6, sub_irq::@4/sub_irq::i#5 )
  sub_irq::k#0 = 0
  to:sub_irq::@3
sub_irq::@3: scope:[sub_irq]  from sub_irq::@2 sub_irq::@3
  sub_irq::k#2 = phi( sub_irq::@2/sub_irq::k#0, sub_irq::@3/sub_irq::k#1 )
  sub_irq::j#2 = phi( sub_irq::@2/sub_irq::j#4, sub_irq::@3/sub_irq::j#2 )
  sub_irq::i#2 = phi( sub_irq::@2/sub_irq::i#4, sub_irq::@3/sub_irq::i#2 )
  sub_irq::$0 = sub_irq::i#2 + sub_irq::j#2
  sub_irq::$1 = sub_irq::$0 + sub_irq::k#2
  *BG_COLOR = sub_irq::$1
  sub_irq::k#1 = sub_irq::k#2 + rangenext(0,$a)
  sub_irq::$2 = sub_irq::k#1 != rangelast(0,$a)
  if(sub_irq::$2) goto sub_irq::@3
  to:sub_irq::@4
sub_irq::@4: scope:[sub_irq]  from sub_irq::@3
  sub_irq::i#5 = phi( sub_irq::@3/sub_irq::i#2 )
  sub_irq::j#3 = phi( sub_irq::@3/sub_irq::j#2 )
  sub_irq::j#1 = sub_irq::j#3 + rangenext(0,$a)
  sub_irq::$3 = sub_irq::j#1 != rangelast(0,$a)
  if(sub_irq::$3) goto sub_irq::@2
  to:sub_irq::@5
sub_irq::@5: scope:[sub_irq]  from sub_irq::@4
  sub_irq::i#3 = phi( sub_irq::@4/sub_irq::i#5 )
  sub_irq::i#1 = sub_irq::i#3 + rangenext(0,$a)
  sub_irq::$4 = sub_irq::i#1 != rangelast(0,$a)
  if(sub_irq::$4) goto sub_irq::@1
  to:sub_irq::@return
sub_irq::@return: scope:[sub_irq]  from sub_irq::@5
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
const nomodify byte* BG_COLOR = (byte*)$d020
const nomodify byte* CIA1_INTERRUPT = (byte*)$dc0d
const nomodify byte CIA_INTERRUPT_CLEAR = $7f
const nomodify byte* FGCOL = (byte*)$d021
const nomodify byte* IRQ_ENABLE = (byte*)$d01a
const nomodify byte IRQ_RASTER = 1
const nomodify byte* IRQ_STATUS = (byte*)$d019
const nomodify void()** KERNEL_IRQ = (void()**)$314
const nomodify byte* RASTER = (byte*)$d012
const nomodify byte* VICII_CONTROL = (byte*)$d011
void __start()
__interrupt(rom_min_c64) void irq()
byte~ irq::$2
byte~ irq::$3
bool~ irq::$5
bool~ irq::$6
bool~ irq::$7
byte irq::i
byte irq::i#0
byte irq::i#1
byte irq::i#2
byte irq::i#3
byte irq::i#4
byte irq::i#5
byte irq::i#6
byte irq::i#7
byte irq::j
byte irq::j#0
byte irq::j#1
byte irq::j#2
byte irq::j#3
byte irq::j#4
byte irq::j#5
byte irq::k
byte irq::k#0
byte irq::k#1
byte irq::k#2
byte irq::k#3
void main()
byte~ main::$0
byte~ main::$1
bool~ main::$3
bool~ main::$4
bool~ main::$5
byte main::i
byte main::i#0
byte main::i#1
byte main::i#2
byte main::i#3
byte main::i#4
byte main::i#5
byte main::i#6
byte main::i#7
byte main::j
byte main::j#0
byte main::j#1
byte main::j#2
byte main::j#3
byte main::j#4
byte main::j#5
byte main::k
byte main::k#0
byte main::k#1
byte main::k#2
byte main::k#3
void sub_irq()
byte~ sub_irq::$0
byte~ sub_irq::$1
bool~ sub_irq::$2
bool~ sub_irq::$3
bool~ sub_irq::$4
byte sub_irq::i
byte sub_irq::i#0
byte sub_irq::i#1
byte sub_irq::i#2
byte sub_irq::i#3
byte sub_irq::i#4
byte sub_irq::i#5
byte sub_irq::i#6
byte sub_irq::j
byte sub_irq::j#0
byte sub_irq::j#1
byte sub_irq::j#2
byte sub_irq::j#3
byte sub_irq::j#4
byte sub_irq::k
byte sub_irq::k#0
byte sub_irq::k#1
byte sub_irq::k#2
void sub_main()
byte~ sub_main::$0
byte~ sub_main::$1
bool~ sub_main::$2
bool~ sub_main::$3
bool~ sub_main::$4
byte sub_main::i
byte sub_main::i#0
byte sub_main::i#1
byte sub_main::i#2
byte sub_main::i#3
byte sub_main::i#4
byte sub_main::i#5
byte sub_main::i#6
byte sub_main::j
byte sub_main::j#0
byte sub_main::j#1
byte sub_main::j#2
byte sub_main::j#3
byte sub_main::j#4
byte sub_main::k
byte sub_main::k#0
byte sub_main::k#1
byte sub_main::k#2

Adding number conversion cast (unumber) $7f in *VICII_CONTROL = *VICII_CONTROL & $7f
Adding number conversion cast (unumber) $fd in *RASTER = $fd
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *RASTER = (unumber)$fd
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (void()**) 788
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (byte*) 53273
Simplifying constant pointer cast (byte*) 53274
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53281
Simplifying constant pointer cast (byte*) 56333
Simplifying constant integer cast $7f
Simplifying constant integer cast $fd
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) $fd
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias main::k#2 = main::k#3 
Alias main::i#2 = main::i#5 main::i#6 main::i#3 
Alias main::j#2 = main::j#5 main::j#3 
Alias irq::k#2 = irq::k#3 
Alias irq::i#2 = irq::i#5 irq::i#6 irq::i#3 
Alias irq::j#2 = irq::j#5 irq::j#3 
Alias sub_main::j#2 = sub_main::j#3 
Alias sub_main::i#2 = sub_main::i#5 sub_main::i#3 
Alias sub_irq::j#2 = sub_irq::j#3 
Alias sub_irq::i#2 = sub_irq::i#5 sub_irq::i#3 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values main::i#2 main::i#4
Identical Phi Values main::j#2 main::j#4
Identical Phi Values irq::i#2 irq::i#4
Identical Phi Values irq::j#2 irq::j#4
Identical Phi Values sub_main::i#2 sub_main::i#4
Identical Phi Values sub_main::j#2 sub_main::j#4
Identical Phi Values sub_irq::i#2 sub_irq::i#4
Identical Phi Values sub_irq::j#2 sub_irq::j#4
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values main::i#4 main::i#7
Identical Phi Values irq::i#4 irq::i#7
Identical Phi Values sub_main::i#4 sub_main::i#6
Identical Phi Values sub_irq::i#4 sub_irq::i#6
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$3 [20] if(main::k#1!=rangelast(0,$a)) goto main::@5
Simple Condition main::$4 [23] if(main::j#1!=rangelast(0,$a)) goto main::@4
Simple Condition main::$5 [26] if(main::i#1!=rangelast(0,$a)) goto main::@3
Simple Condition irq::$5 [41] if(irq::k#1!=rangelast(0,$a)) goto irq::@3
Simple Condition irq::$6 [44] if(irq::j#1!=rangelast(0,$a)) goto irq::@2
Simple Condition irq::$7 [47] if(irq::i#1!=rangelast(0,$a)) goto irq::@1
Simple Condition sub_main::$2 [62] if(sub_main::k#1!=rangelast(0,$a)) goto sub_main::@3
Simple Condition sub_main::$3 [65] if(sub_main::j#1!=rangelast(0,$a)) goto sub_main::@2
Simple Condition sub_main::$4 [68] if(sub_main::i#1!=rangelast(0,$a)) goto sub_main::@1
Simple Condition sub_irq::$2 [81] if(sub_irq::k#1!=rangelast(0,$a)) goto sub_irq::@3
Simple Condition sub_irq::$3 [84] if(sub_irq::j#1!=rangelast(0,$a)) goto sub_irq::@2
Simple Condition sub_irq::$4 [87] if(sub_irq::i#1!=rangelast(0,$a)) goto sub_irq::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant main::i#0 = 0
Constant main::j#0 = 0
Constant main::k#0 = 0
Constant irq::i#0 = 0
Constant irq::j#0 = 0
Constant irq::k#0 = 0
Constant sub_main::i#0 = 0
Constant sub_main::j#0 = 0
Constant sub_main::k#0 = 0
Constant sub_irq::i#0 = 0
Constant sub_irq::j#0 = 0
Constant sub_irq::k#0 = 0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [7] if(true) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [18] main::k#1 = ++ main::k#2 to ++
Resolved ranged comparison value [20] if(main::k#1!=rangelast(0,$a)) goto main::@5 to $b
Resolved ranged next value [21] main::j#1 = ++ main::j#4 to ++
Resolved ranged comparison value [23] if(main::j#1!=rangelast(0,$a)) goto main::@4 to $b
Resolved ranged next value [24] main::i#1 = ++ main::i#7 to ++
Resolved ranged comparison value [26] if(main::i#1!=rangelast(0,$a)) goto main::@3 to $b
Resolved ranged next value [39] irq::k#1 = ++ irq::k#2 to ++
Resolved ranged comparison value [41] if(irq::k#1!=rangelast(0,$a)) goto irq::@3 to $b
Resolved ranged next value [42] irq::j#1 = ++ irq::j#4 to ++
Resolved ranged comparison value [44] if(irq::j#1!=rangelast(0,$a)) goto irq::@2 to $b
Resolved ranged next value [45] irq::i#1 = ++ irq::i#7 to ++
Resolved ranged comparison value [47] if(irq::i#1!=rangelast(0,$a)) goto irq::@1 to $b
Resolved ranged next value [60] sub_main::k#1 = ++ sub_main::k#2 to ++
Resolved ranged comparison value [62] if(sub_main::k#1!=rangelast(0,$a)) goto sub_main::@3 to $b
Resolved ranged next value [63] sub_main::j#1 = ++ sub_main::j#4 to ++
Resolved ranged comparison value [65] if(sub_main::j#1!=rangelast(0,$a)) goto sub_main::@2 to $b
Resolved ranged next value [66] sub_main::i#1 = ++ sub_main::i#6 to ++
Resolved ranged comparison value [68] if(sub_main::i#1!=rangelast(0,$a)) goto sub_main::@1 to $b
Resolved ranged next value [79] sub_irq::k#1 = ++ sub_irq::k#2 to ++
Resolved ranged comparison value [81] if(sub_irq::k#1!=rangelast(0,$a)) goto sub_irq::@3 to $b
Resolved ranged next value [82] sub_irq::j#1 = ++ sub_irq::j#4 to ++
Resolved ranged comparison value [84] if(sub_irq::j#1!=rangelast(0,$a)) goto sub_irq::@2 to $b
Resolved ranged next value [85] sub_irq::i#1 = ++ sub_irq::i#6 to ++
Resolved ranged comparison value [87] if(sub_irq::i#1!=rangelast(0,$a)) goto sub_irq::@1 to $b
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) $b in [15] if(main::k#1!=$b) goto main::@5
Adding number conversion cast (unumber) $b in [17] if(main::j#1!=$b) goto main::@4
Adding number conversion cast (unumber) $b in [19] if(main::i#1!=$b) goto main::@3
Adding number conversion cast (unumber) $b in [29] if(irq::k#1!=$b) goto irq::@3
Adding number conversion cast (unumber) $b in [31] if(irq::j#1!=$b) goto irq::@2
Adding number conversion cast (unumber) $b in [33] if(irq::i#1!=$b) goto irq::@1
Adding number conversion cast (unumber) $b in [44] if(sub_main::k#1!=$b) goto sub_main::@3
Adding number conversion cast (unumber) $b in [46] if(sub_main::j#1!=$b) goto sub_main::@2
Adding number conversion cast (unumber) $b in [48] if(sub_main::i#1!=$b) goto sub_main::@1
Adding number conversion cast (unumber) $b in [57] if(sub_irq::k#1!=$b) goto sub_irq::@3
Adding number conversion cast (unumber) $b in [59] if(sub_irq::j#1!=$b) goto sub_irq::@2
Adding number conversion cast (unumber) $b in [61] if(sub_irq::i#1!=$b) goto sub_irq::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings main::i#0
Inlining constant with var siblings main::j#0
Inlining constant with var siblings main::k#0
Inlining constant with var siblings irq::i#0
Inlining constant with var siblings irq::j#0
Inlining constant with var siblings irq::k#0
Inlining constant with var siblings sub_main::i#0
Inlining constant with var siblings sub_main::j#0
Inlining constant with var siblings sub_main::k#0
Inlining constant with var siblings sub_irq::i#0
Inlining constant with var siblings sub_irq::j#0
Inlining constant with var siblings sub_irq::k#0
Constant inlined sub_main::j#0 = 0
Constant inlined sub_main::i#0 = 0
Constant inlined irq::i#0 = 0
Constant inlined irq::j#0 = 0
Constant inlined irq::k#0 = 0
Constant inlined sub_irq::i#0 = 0
Constant inlined sub_irq::j#0 = 0
Constant inlined sub_irq::k#0 = 0
Constant inlined main::i#0 = 0
Constant inlined main::k#0 = 0
Constant inlined main::j#0 = 0
Constant inlined sub_main::k#0 = 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@9(between main::@7 and main::@3)
Added new block during phi lifting main::@10(between main::@6 and main::@4)
Added new block during phi lifting main::@11(between main::@8 and main::@5)
Added new block during phi lifting irq::@8(between irq::@5 and irq::@1)
Added new block during phi lifting irq::@9(between irq::@4 and irq::@2)
Added new block during phi lifting irq::@10(between irq::@7 and irq::@3)
Added new block during phi lifting sub_main::@6(between sub_main::@5 and sub_main::@1)
Added new block during phi lifting sub_main::@7(between sub_main::@4 and sub_main::@2)
Added new block during phi lifting sub_main::@8(between sub_main::@3 and sub_main::@3)
Added new block during phi lifting sub_irq::@6(between sub_irq::@5 and sub_irq::@1)
Added new block during phi lifting sub_irq::@7(between sub_irq::@4 and sub_irq::@2)
Added new block during phi lifting sub_irq::@8(between sub_irq::@3 and sub_irq::@3)
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of sub_irq
Adding NOP phi() at start of sub_main
CALL GRAPH
Calls in [irq] to sub_irq:7 
Calls in [main] to sub_main:35 

Created 12 initial phi equivalence classes
Coalesced [17] irq::i#8 = irq::i#1
Coalesced [18] irq::j#6 = irq::j#1
Coalesced [19] irq::k#4 = irq::k#1
Coalesced [42] main::i#8 = main::i#1
Coalesced [43] main::j#6 = main::j#1
Coalesced [44] main::k#4 = main::k#1
Coalesced [59] sub_irq::i#7 = sub_irq::i#1
Coalesced [60] sub_irq::j#5 = sub_irq::j#1
Coalesced [61] sub_irq::k#3 = sub_irq::k#1
Coalesced [76] sub_main::i#7 = sub_main::i#1
Coalesced [77] sub_main::j#5 = sub_main::j#1
Coalesced [78] sub_main::k#3 = sub_main::k#1
Coalesced down to 12 phi equivalence classes
Culled Empty Block label irq::@8
Culled Empty Block label irq::@9
Culled Empty Block label irq::@10
Culled Empty Block label main::@1
Culled Empty Block label main::@2
Culled Empty Block label main::@10
Culled Empty Block label main::@11
Culled Empty Block label sub_irq::@6
Culled Empty Block label sub_irq::@7
Culled Empty Block label sub_irq::@8
Culled Empty Block label sub_main::@6
Culled Empty Block label sub_main::@7
Culled Empty Block label sub_main::@8
Renumbering block main::@3 to main::@1
Renumbering block main::@4 to main::@2
Renumbering block main::@5 to main::@3
Renumbering block main::@6 to main::@4
Renumbering block main::@7 to main::@5
Renumbering block main::@8 to main::@6
Renumbering block main::@9 to main::@7
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of sub_irq
Adding NOP phi() at start of sub_main

FINAL CONTROL FLOW GRAPH

__interrupt(rom_min_c64) void irq()
irq: scope:[irq]  from
  [0] *BG_COLOR = ++ *BG_COLOR
  to:irq::@1
irq::@1: scope:[irq]  from irq irq::@5
  [1] irq::i#7 = phi( irq/0, irq::@5/irq::i#1 )
  to:irq::@2
irq::@2: scope:[irq]  from irq::@1 irq::@4
  [2] irq::j#4 = phi( irq::@1/0, irq::@4/irq::j#1 )
  to:irq::@3
irq::@3: scope:[irq]  from irq::@2 irq::@7
  [3] irq::k#2 = phi( irq::@2/0, irq::@7/irq::k#1 )
  [4] irq::$2 = irq::i#7 + irq::j#4
  [5] irq::$3 = irq::$2 + irq::k#2
  [6] *FGCOL = irq::$3
  [7] call sub_irq 
  to:irq::@7
irq::@7: scope:[irq]  from irq::@3
  [8] irq::k#1 = ++ irq::k#2
  [9] if(irq::k#1!=$b) goto irq::@3
  to:irq::@4
irq::@4: scope:[irq]  from irq::@7
  [10] irq::j#1 = ++ irq::j#4
  [11] if(irq::j#1!=$b) goto irq::@2
  to:irq::@5
irq::@5: scope:[irq]  from irq::@4
  [12] irq::i#1 = ++ irq::i#7
  [13] if(irq::i#1!=$b) goto irq::@1
  to:irq::@6
irq::@6: scope:[irq]  from irq::@5
  [14] *IRQ_STATUS = IRQ_RASTER
  [15] *BG_COLOR = -- *BG_COLOR
  to:irq::@return
irq::@return: scope:[irq]  from irq::@6
  [16] return 
  to:@return

void main()
main: scope:[main]  from
  asm { sei  }
  [18] *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR
  [19] *VICII_CONTROL = *VICII_CONTROL & $7f
  [20] *RASTER = $fd
  [21] *IRQ_ENABLE = IRQ_RASTER
  [22] *KERNEL_IRQ = &irq
  asm { cli  }
  to:main::@1
main::@1: scope:[main]  from main main::@5 main::@7
  [24] main::i#7 = phi( main/0, main::@7/main::i#1, main::@5/0 )
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@4
  [25] main::j#4 = phi( main::@1/0, main::@4/main::j#1 )
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@6
  [26] main::k#2 = phi( main::@2/0, main::@6/main::k#1 )
  [27] main::$0 = main::i#7 + main::j#4
  [28] main::$1 = main::$0 + main::k#2
  [29] *FGCOL = main::$1
  [30] call sub_main 
  to:main::@6
main::@6: scope:[main]  from main::@3
  [31] main::k#1 = ++ main::k#2
  [32] if(main::k#1!=$b) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@6
  [33] main::j#1 = ++ main::j#4
  [34] if(main::j#1!=$b) goto main::@2
  to:main::@5
main::@5: scope:[main]  from main::@4
  [35] main::i#1 = ++ main::i#7
  [36] if(main::i#1!=$b) goto main::@7
  to:main::@1
main::@7: scope:[main]  from main::@5
  [37] phi()
  to:main::@1

void sub_irq()
sub_irq: scope:[sub_irq]  from irq::@3
  [38] phi()
  to:sub_irq::@1
sub_irq::@1: scope:[sub_irq]  from sub_irq sub_irq::@5
  [39] sub_irq::i#6 = phi( sub_irq/0, sub_irq::@5/sub_irq::i#1 )
  to:sub_irq::@2
sub_irq::@2: scope:[sub_irq]  from sub_irq::@1 sub_irq::@4
  [40] sub_irq::j#4 = phi( sub_irq::@1/0, sub_irq::@4/sub_irq::j#1 )
  to:sub_irq::@3
sub_irq::@3: scope:[sub_irq]  from sub_irq::@2 sub_irq::@3
  [41] sub_irq::k#2 = phi( sub_irq::@2/0, sub_irq::@3/sub_irq::k#1 )
  [42] sub_irq::$0 = sub_irq::i#6 + sub_irq::j#4
  [43] sub_irq::$1 = sub_irq::$0 + sub_irq::k#2
  [44] *BG_COLOR = sub_irq::$1
  [45] sub_irq::k#1 = ++ sub_irq::k#2
  [46] if(sub_irq::k#1!=$b) goto sub_irq::@3
  to:sub_irq::@4
sub_irq::@4: scope:[sub_irq]  from sub_irq::@3
  [47] sub_irq::j#1 = ++ sub_irq::j#4
  [48] if(sub_irq::j#1!=$b) goto sub_irq::@2
  to:sub_irq::@5
sub_irq::@5: scope:[sub_irq]  from sub_irq::@4
  [49] sub_irq::i#1 = ++ sub_irq::i#6
  [50] if(sub_irq::i#1!=$b) goto sub_irq::@1
  to:sub_irq::@return
sub_irq::@return: scope:[sub_irq]  from sub_irq::@5
  [51] return 
  to:@return

void sub_main()
sub_main: scope:[sub_main]  from main::@3
  [52] phi()
  to:sub_main::@1
sub_main::@1: scope:[sub_main]  from sub_main sub_main::@5
  [53] sub_main::i#6 = phi( sub_main/0, sub_main::@5/sub_main::i#1 )
  to:sub_main::@2
sub_main::@2: scope:[sub_main]  from sub_main::@1 sub_main::@4
  [54] sub_main::j#4 = phi( sub_main::@1/0, sub_main::@4/sub_main::j#1 )
  to:sub_main::@3
sub_main::@3: scope:[sub_main]  from sub_main::@2 sub_main::@3
  [55] sub_main::k#2 = phi( sub_main::@2/0, sub_main::@3/sub_main::k#1 )
  [56] sub_main::$0 = sub_main::i#6 + sub_main::j#4
  [57] sub_main::$1 = sub_main::$0 + sub_main::k#2
  [58] *BG_COLOR = sub_main::$1
  [59] sub_main::k#1 = ++ sub_main::k#2
  [60] if(sub_main::k#1!=$b) goto sub_main::@3
  to:sub_main::@4
sub_main::@4: scope:[sub_main]  from sub_main::@3
  [61] sub_main::j#1 = ++ sub_main::j#4
  [62] if(sub_main::j#1!=$b) goto sub_main::@2
  to:sub_main::@5
sub_main::@5: scope:[sub_main]  from sub_main::@4
  [63] sub_main::i#1 = ++ sub_main::i#6
  [64] if(sub_main::i#1!=$b) goto sub_main::@1
  to:sub_main::@return
sub_main::@return: scope:[sub_main]  from sub_main::@5
  [65] return 
  to:@return


VARIABLE REGISTER WEIGHTS
__interrupt(rom_min_c64) void irq()
byte~ irq::$2 2002.0
byte~ irq::$3 2002.0
byte irq::i
byte irq::i#1 16.5
byte irq::i#7 93.0
byte irq::j
byte irq::j#1 151.5
byte irq::j#4 150.375
byte irq::k
byte irq::k#1 1501.5
byte irq::k#2 600.5999999999999
void main()
byte~ main::$0 20002.0
byte~ main::$1 20002.0
byte main::i
byte main::i#1 71.0
byte main::i#7 919.3636363636363
byte main::j
byte main::j#1 1501.5
byte main::j#4 1500.375
byte main::k
byte main::k#1 15001.5
byte main::k#2 6000.6
void sub_irq()
byte~ sub_irq::$0 2.0000000002E10
byte~ sub_irq::$1 2.0000000002E10
byte sub_irq::i
byte sub_irq::i#1 1.500000015E8
byte sub_irq::i#6 1.0200000003000001E9
byte sub_irq::j
byte sub_irq::j#1 1.5000000015E9
byte sub_irq::j#4 1.7142857147142856E9
byte sub_irq::k
byte sub_irq::k#1 1.50000000015E10
byte sub_irq::k#2 7.50000000075E9
void sub_main()
byte~ sub_main::$0 2.000000000002E12
byte~ sub_main::$1 2.000000000002E12
byte sub_main::i
byte sub_main::i#1 1.50000000015E10
byte sub_main::i#6 1.0200000000030002E11
byte sub_main::j
byte sub_main::j#1 1.500000000015E11
byte sub_main::j#4 1.71428571429E11
byte sub_main::k
byte sub_main::k#1 1.5000000000015E12
byte sub_main::k#2 7.5000000000075E11

Initial phi equivalence classes
[ irq::i#7 irq::i#1 ]
[ irq::j#4 irq::j#1 ]
[ irq::k#2 irq::k#1 ]
[ main::i#7 main::i#1 ]
[ main::j#4 main::j#1 ]
[ main::k#2 main::k#1 ]
[ sub_irq::i#6 sub_irq::i#1 ]
[ sub_irq::j#4 sub_irq::j#1 ]
[ sub_irq::k#2 sub_irq::k#1 ]
[ sub_main::i#6 sub_main::i#1 ]
[ sub_main::j#4 sub_main::j#1 ]
[ sub_main::k#2 sub_main::k#1 ]
Added variable irq::$2 to live range equivalence class [ irq::$2 ]
Added variable irq::$3 to live range equivalence class [ irq::$3 ]
Added variable main::$0 to live range equivalence class [ main::$0 ]
Added variable main::$1 to live range equivalence class [ main::$1 ]
Added variable sub_irq::$0 to live range equivalence class [ sub_irq::$0 ]
Added variable sub_irq::$1 to live range equivalence class [ sub_irq::$1 ]
Added variable sub_main::$0 to live range equivalence class [ sub_main::$0 ]
Added variable sub_main::$1 to live range equivalence class [ sub_main::$1 ]
Complete equivalence classes
[ irq::i#7 irq::i#1 ]
[ irq::j#4 irq::j#1 ]
[ irq::k#2 irq::k#1 ]
[ main::i#7 main::i#1 ]
[ main::j#4 main::j#1 ]
[ main::k#2 main::k#1 ]
[ sub_irq::i#6 sub_irq::i#1 ]
[ sub_irq::j#4 sub_irq::j#1 ]
[ sub_irq::k#2 sub_irq::k#1 ]
[ sub_main::i#6 sub_main::i#1 ]
[ sub_main::j#4 sub_main::j#1 ]
[ sub_main::k#2 sub_main::k#1 ]
[ irq::$2 ]
[ irq::$3 ]
[ main::$0 ]
[ main::$1 ]
[ sub_irq::$0 ]
[ sub_irq::$1 ]
[ sub_main::$0 ]
[ sub_main::$1 ]
Allocated zp[1]:2 [ irq::i#7 irq::i#1 ]
Allocated zp[1]:3 [ irq::j#4 irq::j#1 ]
Allocated zp[1]:4 [ irq::k#2 irq::k#1 ]
Allocated zp[1]:5 [ main::i#7 main::i#1 ]
Allocated zp[1]:6 [ main::j#4 main::j#1 ]
Allocated zp[1]:7 [ main::k#2 main::k#1 ]
Allocated zp[1]:8 [ sub_irq::i#6 sub_irq::i#1 ]
Allocated zp[1]:9 [ sub_irq::j#4 sub_irq::j#1 ]
Allocated zp[1]:10 [ sub_irq::k#2 sub_irq::k#1 ]
Allocated zp[1]:11 [ sub_main::i#6 sub_main::i#1 ]
Allocated zp[1]:12 [ sub_main::j#4 sub_main::j#1 ]
Allocated zp[1]:13 [ sub_main::k#2 sub_main::k#1 ]
Allocated zp[1]:14 [ irq::$2 ]
Allocated zp[1]:15 [ irq::$3 ]
Allocated zp[1]:16 [ main::$0 ]
Allocated zp[1]:17 [ main::$1 ]
Allocated zp[1]:18 [ sub_irq::$0 ]
Allocated zp[1]:19 [ sub_irq::$1 ]
Allocated zp[1]:20 [ sub_main::$0 ]
Allocated zp[1]:21 [ sub_main::$1 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [4] irq::$2 = irq::i#7 + irq::j#4 [ irq::i#7 irq::j#4 irq::k#2 irq::$2 ] (  [ irq::i#7 irq::j#4 irq::k#2 irq::$2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ irq::i#7 irq::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ irq::j#4 irq::j#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:4 [ irq::k#2 irq::k#1 ]
Statement [5] irq::$3 = irq::$2 + irq::k#2 [ irq::i#7 irq::j#4 irq::k#2 irq::$3 ] (  [ irq::i#7 irq::j#4 irq::k#2 irq::$3 ] { }  ) always clobbers reg byte a 
Statement [14] *IRQ_STATUS = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [18] *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [19] *VICII_CONTROL = *VICII_CONTROL & $7f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [20] *RASTER = $fd [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [21] *IRQ_ENABLE = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [22] *KERNEL_IRQ = &irq [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [27] main::$0 = main::i#7 + main::j#4 [ main::i#7 main::j#4 main::k#2 main::$0 ] (  [ main::i#7 main::j#4 main::k#2 main::$0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ main::i#7 main::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ main::j#4 main::j#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ main::k#2 main::k#1 ]
Statement [28] main::$1 = main::$0 + main::k#2 [ main::i#7 main::j#4 main::k#2 main::$1 ] (  [ main::i#7 main::j#4 main::k#2 main::$1 ] { }  ) always clobbers reg byte a 
Statement [42] sub_irq::$0 = sub_irq::i#6 + sub_irq::j#4 [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$0 ] ( sub_irq:7 [ irq::i#7 irq::j#4 irq::k#2 sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:8 [ sub_irq::i#6 sub_irq::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:9 [ sub_irq::j#4 sub_irq::j#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:10 [ sub_irq::k#2 sub_irq::k#1 ]
Statement [43] sub_irq::$1 = sub_irq::$0 + sub_irq::k#2 [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$1 ] ( sub_irq:7 [ irq::i#7 irq::j#4 irq::k#2 sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$1 ] { }  ) always clobbers reg byte a 
Statement [56] sub_main::$0 = sub_main::i#6 + sub_main::j#4 [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$0 ] ( sub_main:30 [ main::i#7 main::j#4 main::k#2 sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:11 [ sub_main::i#6 sub_main::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:12 [ sub_main::j#4 sub_main::j#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:13 [ sub_main::k#2 sub_main::k#1 ]
Statement [57] sub_main::$1 = sub_main::$0 + sub_main::k#2 [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$1 ] ( sub_main:30 [ main::i#7 main::j#4 main::k#2 sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$1 ] { }  ) always clobbers reg byte a 
Statement [4] irq::$2 = irq::i#7 + irq::j#4 [ irq::i#7 irq::j#4 irq::k#2 irq::$2 ] (  [ irq::i#7 irq::j#4 irq::k#2 irq::$2 ] { }  ) always clobbers reg byte a 
Statement [5] irq::$3 = irq::$2 + irq::k#2 [ irq::i#7 irq::j#4 irq::k#2 irq::$3 ] (  [ irq::i#7 irq::j#4 irq::k#2 irq::$3 ] { }  ) always clobbers reg byte a 
Statement [14] *IRQ_STATUS = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [18] *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [19] *VICII_CONTROL = *VICII_CONTROL & $7f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [20] *RASTER = $fd [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [21] *IRQ_ENABLE = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [22] *KERNEL_IRQ = &irq [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [27] main::$0 = main::i#7 + main::j#4 [ main::i#7 main::j#4 main::k#2 main::$0 ] (  [ main::i#7 main::j#4 main::k#2 main::$0 ] { }  ) always clobbers reg byte a 
Statement [28] main::$1 = main::$0 + main::k#2 [ main::i#7 main::j#4 main::k#2 main::$1 ] (  [ main::i#7 main::j#4 main::k#2 main::$1 ] { }  ) always clobbers reg byte a 
Statement [42] sub_irq::$0 = sub_irq::i#6 + sub_irq::j#4 [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$0 ] ( sub_irq:7 [ irq::i#7 irq::j#4 irq::k#2 sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$0 ] { }  ) always clobbers reg byte a 
Statement [43] sub_irq::$1 = sub_irq::$0 + sub_irq::k#2 [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$1 ] ( sub_irq:7 [ irq::i#7 irq::j#4 irq::k#2 sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$1 ] { }  ) always clobbers reg byte a 
Statement [56] sub_main::$0 = sub_main::i#6 + sub_main::j#4 [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$0 ] ( sub_main:30 [ main::i#7 main::j#4 main::k#2 sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$0 ] { }  ) always clobbers reg byte a 
Statement [57] sub_main::$1 = sub_main::$0 + sub_main::k#2 [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$1 ] ( sub_main:30 [ main::i#7 main::j#4 main::k#2 sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$1 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ irq::i#7 irq::i#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ irq::j#4 irq::j#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ irq::k#2 irq::k#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ main::i#7 main::i#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ main::j#4 main::j#1 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ main::k#2 main::k#1 ] : zp[1]:7 , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ sub_irq::i#6 sub_irq::i#1 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ sub_irq::j#4 sub_irq::j#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ sub_irq::k#2 sub_irq::k#1 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ sub_main::i#6 sub_main::i#1 ] : zp[1]:11 , reg byte x , reg byte y , 
Potential registers zp[1]:12 [ sub_main::j#4 sub_main::j#1 ] : zp[1]:12 , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ sub_main::k#2 sub_main::k#1 ] : zp[1]:13 , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ irq::$2 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ irq::$3 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ main::$0 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ main::$1 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:18 [ sub_irq::$0 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:19 [ sub_irq::$1 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:20 [ sub_main::$0 ] : zp[1]:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:21 [ sub_main::$1 ] : zp[1]:21 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [sub_main] 2,250,000,000,002.25: zp[1]:13 [ sub_main::k#2 sub_main::k#1 ] 2,000,000,000,002: zp[1]:20 [ sub_main::$0 ] 2,000,000,000,002: zp[1]:21 [ sub_main::$1 ] 321,428,571,430.5: zp[1]:12 [ sub_main::j#4 sub_main::j#1 ] 117,000,000,001.8: zp[1]:11 [ sub_main::i#6 sub_main::i#1 ] 
Uplift Scope [sub_irq] 22,500,000,002.25: zp[1]:10 [ sub_irq::k#2 sub_irq::k#1 ] 20,000,000,002: zp[1]:18 [ sub_irq::$0 ] 20,000,000,002: zp[1]:19 [ sub_irq::$1 ] 3,214,285,716.21: zp[1]:9 [ sub_irq::j#4 sub_irq::j#1 ] 1,170,000,001.8: zp[1]:8 [ sub_irq::i#6 sub_irq::i#1 ] 
Uplift Scope [main] 21,002.1: zp[1]:7 [ main::k#2 main::k#1 ] 20,002: zp[1]:16 [ main::$0 ] 20,002: zp[1]:17 [ main::$1 ] 3,001.88: zp[1]:6 [ main::j#4 main::j#1 ] 990.36: zp[1]:5 [ main::i#7 main::i#1 ] 
Uplift Scope [irq] 2,102.1: zp[1]:4 [ irq::k#2 irq::k#1 ] 2,002: zp[1]:14 [ irq::$2 ] 2,002: zp[1]:15 [ irq::$3 ] 301.88: zp[1]:3 [ irq::j#4 irq::j#1 ] 109.5: zp[1]:2 [ irq::i#7 irq::i#1 ] 
Uplift Scope [] 

Uplifting [sub_main] best 444207720 combination reg byte y [ sub_main::k#2 sub_main::k#1 ] reg byte a [ sub_main::$0 ] reg byte a [ sub_main::$1 ] reg byte x [ sub_main::j#4 sub_main::j#1 ] zp[1]:11 [ sub_main::i#6 sub_main::i#1 ] 
Limited combination testing to 100 combinations of 432 possible.
Uplifting [sub_irq] best 424307720 combination reg byte y [ sub_irq::k#2 sub_irq::k#1 ] reg byte a [ sub_irq::$0 ] reg byte a [ sub_irq::$1 ] reg byte x [ sub_irq::j#4 sub_irq::j#1 ] zp[1]:8 [ sub_irq::i#6 sub_irq::i#1 ] 
Limited combination testing to 100 combinations of 432 possible.
Uplifting [main] best 424187720 combination zp[1]:7 [ main::k#2 main::k#1 ] reg byte a [ main::$0 ] reg byte a [ main::$1 ] zp[1]:6 [ main::j#4 main::j#1 ] zp[1]:5 [ main::i#7 main::i#1 ] 
Limited combination testing to 100 combinations of 432 possible.
Uplifting [irq] best 424175720 combination zp[1]:4 [ irq::k#2 irq::k#1 ] reg byte a [ irq::$2 ] reg byte a [ irq::$3 ] zp[1]:3 [ irq::j#4 irq::j#1 ] zp[1]:2 [ irq::i#7 irq::i#1 ] 
Limited combination testing to 100 combinations of 432 possible.
Uplifting [] best 424175720 combination 
Attempting to uplift remaining variables inzp[1]:11 [ sub_main::i#6 sub_main::i#1 ]
Uplifting [sub_main] best 424175720 combination zp[1]:11 [ sub_main::i#6 sub_main::i#1 ] 
Attempting to uplift remaining variables inzp[1]:8 [ sub_irq::i#6 sub_irq::i#1 ]
Uplifting [sub_irq] best 424175720 combination zp[1]:8 [ sub_irq::i#6 sub_irq::i#1 ] 
Attempting to uplift remaining variables inzp[1]:7 [ main::k#2 main::k#1 ]
Uplifting [main] best 424175720 combination zp[1]:7 [ main::k#2 main::k#1 ] 
Attempting to uplift remaining variables inzp[1]:6 [ main::j#4 main::j#1 ]
Uplifting [main] best 424175720 combination zp[1]:6 [ main::j#4 main::j#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ irq::k#2 irq::k#1 ]
Uplifting [irq] best 424175720 combination zp[1]:4 [ irq::k#2 irq::k#1 ] 
Attempting to uplift remaining variables inzp[1]:5 [ main::i#7 main::i#1 ]
Uplifting [main] best 424175720 combination zp[1]:5 [ main::i#7 main::i#1 ] 
Attempting to uplift remaining variables inzp[1]:3 [ irq::j#4 irq::j#1 ]
Uplifting [irq] best 424175720 combination zp[1]:3 [ irq::j#4 irq::j#1 ] 
Attempting to uplift remaining variables inzp[1]:2 [ irq::i#7 irq::i#1 ]
Uplifting [irq] best 424175720 combination zp[1]:2 [ irq::i#7 irq::i#1 ] 
Allocated (was zp[1]:11) zp[1]:9 [ sub_main::i#6 sub_main::i#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Illustrates a problem where local variables inside an IRQ are assigned the same zeropage as a variable outside the IRQ
  // Upstart
  // Commodore 64 PRG executable file
.file [name="irq-local-var-overlap-problem.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const IRQ_RASTER = 1
  .const CIA_INTERRUPT_CLEAR = $7f
  .label KERNEL_IRQ = $314
  .label RASTER = $d012
  .label VICII_CONTROL = $d011
  .label IRQ_STATUS = $d019
  .label IRQ_ENABLE = $d01a
  .label BG_COLOR = $d020
  .label FGCOL = $d021
  .label CIA1_INTERRUPT = $dc0d
.segment Code
  // irq
irq: {
    .label k = 4
    .label j = 3
    .label i = 2
    // interrupt(isr_rom_min_c64_entry) -- isr_rom_min_c64_entry 
    // [0] *BG_COLOR = ++ *BG_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BG_COLOR
    // [1] phi from irq to irq::@1 [phi:irq->irq::@1]
  __b1_from_irq:
    // [1] phi irq::i#7 = 0 [phi:irq->irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [1] phi from irq::@5 to irq::@1 [phi:irq::@5->irq::@1]
  __b1_from___b5:
    // [1] phi irq::i#7 = irq::i#1 [phi:irq::@5->irq::@1#0] -- register_copy 
    jmp __b1
    // irq::@1
  __b1:
    // [2] phi from irq::@1 to irq::@2 [phi:irq::@1->irq::@2]
  __b2_from___b1:
    // [2] phi irq::j#4 = 0 [phi:irq::@1->irq::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    jmp __b2
    // [2] phi from irq::@4 to irq::@2 [phi:irq::@4->irq::@2]
  __b2_from___b4:
    // [2] phi irq::j#4 = irq::j#1 [phi:irq::@4->irq::@2#0] -- register_copy 
    jmp __b2
    // irq::@2
  __b2:
    // [3] phi from irq::@2 to irq::@3 [phi:irq::@2->irq::@3]
  __b3_from___b2:
    // [3] phi irq::k#2 = 0 [phi:irq::@2->irq::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    jmp __b3
    // [3] phi from irq::@7 to irq::@3 [phi:irq::@7->irq::@3]
  __b3_from___b7:
    // [3] phi irq::k#2 = irq::k#1 [phi:irq::@7->irq::@3#0] -- register_copy 
    jmp __b3
    // irq::@3
  __b3:
    // [4] irq::$2 = irq::i#7 + irq::j#4 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z i
    clc
    adc.z j
    // [5] irq::$3 = irq::$2 + irq::k#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z k
    // [6] *FGCOL = irq::$3 -- _deref_pbuc1=vbuaa 
    sta FGCOL
    // [7] call sub_irq 
    // [38] phi from irq::@3 to sub_irq [phi:irq::@3->sub_irq]
  sub_irq_from___b3:
    jsr sub_irq
    jmp __b7
    // irq::@7
  __b7:
    // [8] irq::k#1 = ++ irq::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [9] if(irq::k#1!=$b) goto irq::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3_from___b7
    jmp __b4
    // irq::@4
  __b4:
    // [10] irq::j#1 = ++ irq::j#4 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [11] if(irq::j#1!=$b) goto irq::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z j
    bne __b2_from___b4
    jmp __b5
    // irq::@5
  __b5:
    // [12] irq::i#1 = ++ irq::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [13] if(irq::i#1!=$b) goto irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1_from___b5
    jmp __b6
    // irq::@6
  __b6:
    // [14] *IRQ_STATUS = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // [15] *BG_COLOR = -- *BG_COLOR -- _deref_pbuc1=_dec__deref_pbuc1 
    dec BG_COLOR
    jmp __breturn
    // irq::@return
  __breturn:
    // [16] return 
    // interrupt(isr_rom_min_c64_exit) -- isr_rom_min_c64_exit 
    jmp $ea81
}
  // main
main: {
    .label k = 7
    .label j = 6
    .label i = 5
    // asm { sei  }
    sei
    // [18] *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
    // [19] *VICII_CONTROL = *VICII_CONTROL & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line to $0fd
    lda #$7f
    and VICII_CONTROL
    sta VICII_CONTROL
    // [20] *RASTER = $fd -- _deref_pbuc1=vbuc2 
    lda #$fd
    sta RASTER
    // [21] *IRQ_ENABLE = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // [22] *KERNEL_IRQ = &irq -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta KERNEL_IRQ
    lda #>irq
    sta KERNEL_IRQ+1
    // asm { cli  }
    cli
    // [24] phi from main main::@5 to main::@1 [phi:main/main::@5->main::@1]
  __b1_from_main:
  __b1_from___b5:
    // [24] phi main::i#7 = 0 [phi:main/main::@5->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // main::@1
  __b1:
    // [25] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    // [25] phi main::j#4 = 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    jmp __b2
    // [25] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  __b2_from___b4:
    // [25] phi main::j#4 = main::j#1 [phi:main::@4->main::@2#0] -- register_copy 
    jmp __b2
    // main::@2
  __b2:
    // [26] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [26] phi main::k#2 = 0 [phi:main::@2->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    jmp __b3
    // [26] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  __b3_from___b6:
    // [26] phi main::k#2 = main::k#1 [phi:main::@6->main::@3#0] -- register_copy 
    jmp __b3
    // main::@3
  __b3:
    // [27] main::$0 = main::i#7 + main::j#4 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z i
    clc
    adc.z j
    // [28] main::$1 = main::$0 + main::k#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z k
    // [29] *FGCOL = main::$1 -- _deref_pbuc1=vbuaa 
    sta FGCOL
    // [30] call sub_main 
    // [52] phi from main::@3 to sub_main [phi:main::@3->sub_main]
  sub_main_from___b3:
    jsr sub_main
    jmp __b6
    // main::@6
  __b6:
    // [31] main::k#1 = ++ main::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [32] if(main::k#1!=$b) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3_from___b6
    jmp __b4
    // main::@4
  __b4:
    // [33] main::j#1 = ++ main::j#4 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [34] if(main::j#1!=$b) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z j
    bne __b2_from___b4
    jmp __b5
    // main::@5
  __b5:
    // [35] main::i#1 = ++ main::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [36] if(main::i#1!=$b) goto main::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b7_from___b5
    jmp __b1_from___b5
    // [37] phi from main::@5 to main::@7 [phi:main::@5->main::@7]
  __b7_from___b5:
    jmp __b7
    // main::@7
  __b7:
    // [24] phi from main::@7 to main::@1 [phi:main::@7->main::@1]
  __b1_from___b7:
    // [24] phi main::i#7 = main::i#1 [phi:main::@7->main::@1#0] -- register_copy 
    jmp __b1
}
  // sub_irq
sub_irq: {
    .label i = 8
    // [39] phi from sub_irq to sub_irq::@1 [phi:sub_irq->sub_irq::@1]
  __b1_from_sub_irq:
    // [39] phi sub_irq::i#6 = 0 [phi:sub_irq->sub_irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [39] phi from sub_irq::@5 to sub_irq::@1 [phi:sub_irq::@5->sub_irq::@1]
  __b1_from___b5:
    // [39] phi sub_irq::i#6 = sub_irq::i#1 [phi:sub_irq::@5->sub_irq::@1#0] -- register_copy 
    jmp __b1
    // sub_irq::@1
  __b1:
    // [40] phi from sub_irq::@1 to sub_irq::@2 [phi:sub_irq::@1->sub_irq::@2]
  __b2_from___b1:
    // [40] phi sub_irq::j#4 = 0 [phi:sub_irq::@1->sub_irq::@2#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b2
    // [40] phi from sub_irq::@4 to sub_irq::@2 [phi:sub_irq::@4->sub_irq::@2]
  __b2_from___b4:
    // [40] phi sub_irq::j#4 = sub_irq::j#1 [phi:sub_irq::@4->sub_irq::@2#0] -- register_copy 
    jmp __b2
    // sub_irq::@2
  __b2:
    // [41] phi from sub_irq::@2 to sub_irq::@3 [phi:sub_irq::@2->sub_irq::@3]
  __b3_from___b2:
    // [41] phi sub_irq::k#2 = 0 [phi:sub_irq::@2->sub_irq::@3#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b3
    // [41] phi from sub_irq::@3 to sub_irq::@3 [phi:sub_irq::@3->sub_irq::@3]
  __b3_from___b3:
    // [41] phi sub_irq::k#2 = sub_irq::k#1 [phi:sub_irq::@3->sub_irq::@3#0] -- register_copy 
    jmp __b3
    // sub_irq::@3
  __b3:
    // [42] sub_irq::$0 = sub_irq::i#6 + sub_irq::j#4 -- vbuaa=vbuz1_plus_vbuxx 
    txa
    clc
    adc.z i
    // [43] sub_irq::$1 = sub_irq::$0 + sub_irq::k#2 -- vbuaa=vbuaa_plus_vbuyy 
    sty.z $ff
    clc
    adc.z $ff
    // [44] *BG_COLOR = sub_irq::$1 -- _deref_pbuc1=vbuaa 
    sta BG_COLOR
    // [45] sub_irq::k#1 = ++ sub_irq::k#2 -- vbuyy=_inc_vbuyy 
    iny
    // [46] if(sub_irq::k#1!=$b) goto sub_irq::@3 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne __b3_from___b3
    jmp __b4
    // sub_irq::@4
  __b4:
    // [47] sub_irq::j#1 = ++ sub_irq::j#4 -- vbuxx=_inc_vbuxx 
    inx
    // [48] if(sub_irq::j#1!=$b) goto sub_irq::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne __b2_from___b4
    jmp __b5
    // sub_irq::@5
  __b5:
    // [49] sub_irq::i#1 = ++ sub_irq::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [50] if(sub_irq::i#1!=$b) goto sub_irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1_from___b5
    jmp __breturn
    // sub_irq::@return
  __breturn:
    // [51] return 
    rts
}
  // sub_main
sub_main: {
    .label i = 9
    // [53] phi from sub_main to sub_main::@1 [phi:sub_main->sub_main::@1]
  __b1_from_sub_main:
    // [53] phi sub_main::i#6 = 0 [phi:sub_main->sub_main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [53] phi from sub_main::@5 to sub_main::@1 [phi:sub_main::@5->sub_main::@1]
  __b1_from___b5:
    // [53] phi sub_main::i#6 = sub_main::i#1 [phi:sub_main::@5->sub_main::@1#0] -- register_copy 
    jmp __b1
    // sub_main::@1
  __b1:
    // [54] phi from sub_main::@1 to sub_main::@2 [phi:sub_main::@1->sub_main::@2]
  __b2_from___b1:
    // [54] phi sub_main::j#4 = 0 [phi:sub_main::@1->sub_main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b2
    // [54] phi from sub_main::@4 to sub_main::@2 [phi:sub_main::@4->sub_main::@2]
  __b2_from___b4:
    // [54] phi sub_main::j#4 = sub_main::j#1 [phi:sub_main::@4->sub_main::@2#0] -- register_copy 
    jmp __b2
    // sub_main::@2
  __b2:
    // [55] phi from sub_main::@2 to sub_main::@3 [phi:sub_main::@2->sub_main::@3]
  __b3_from___b2:
    // [55] phi sub_main::k#2 = 0 [phi:sub_main::@2->sub_main::@3#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b3
    // [55] phi from sub_main::@3 to sub_main::@3 [phi:sub_main::@3->sub_main::@3]
  __b3_from___b3:
    // [55] phi sub_main::k#2 = sub_main::k#1 [phi:sub_main::@3->sub_main::@3#0] -- register_copy 
    jmp __b3
    // sub_main::@3
  __b3:
    // [56] sub_main::$0 = sub_main::i#6 + sub_main::j#4 -- vbuaa=vbuz1_plus_vbuxx 
    txa
    clc
    adc.z i
    // [57] sub_main::$1 = sub_main::$0 + sub_main::k#2 -- vbuaa=vbuaa_plus_vbuyy 
    sty.z $ff
    clc
    adc.z $ff
    // [58] *BG_COLOR = sub_main::$1 -- _deref_pbuc1=vbuaa 
    sta BG_COLOR
    // [59] sub_main::k#1 = ++ sub_main::k#2 -- vbuyy=_inc_vbuyy 
    iny
    // [60] if(sub_main::k#1!=$b) goto sub_main::@3 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne __b3_from___b3
    jmp __b4
    // sub_main::@4
  __b4:
    // [61] sub_main::j#1 = ++ sub_main::j#4 -- vbuxx=_inc_vbuxx 
    inx
    // [62] if(sub_main::j#1!=$b) goto sub_main::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne __b2_from___b4
    jmp __b5
    // sub_main::@5
  __b5:
    // [63] sub_main::i#1 = ++ sub_main::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [64] if(sub_main::i#1!=$b) goto sub_main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1_from___b5
    jmp __breturn
    // sub_main::@return
  __breturn:
    // [65] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b7
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b6
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b3_from___b7 with __b3
Replacing label __b2_from___b4 with __b2
Replacing label __b1_from___b5 with __b1
Replacing label __b3_from___b6 with __b3
Replacing label __b2_from___b4 with __b2
Replacing label __b7_from___b5 with __b7
Replacing label __b3_from___b3 with __b3
Replacing label __b2_from___b4 with __b2
Replacing label __b1_from___b5 with __b1
Replacing label __b3_from___b3 with __b3
Replacing label __b2_from___b4 with __b2
Replacing label __b1_from___b5 with __b1
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b7:
Removing instruction __b1_from_main:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b6:
Removing instruction __b7_from___b5:
Removing instruction __b1_from___b7:
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b3:
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_irq:
Removing instruction sub_irq_from___b3:
Removing instruction __b7:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __breturn:
Removing instruction sub_main_from___b3:
Removing instruction __b6:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b1_from_sub_irq:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __breturn:
Removing instruction __b1_from_sub_main:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Skipping double jump to __b1 in bne __b7
Succesful ASM optimization Pass5DoubleJumpElimination
Relabelling long label __b1_from___b5 to __b4
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #$b
Removing instruction lda #$b
Removing instruction lda #$b
Removing instruction lda #$b
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b7:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing unreachable instruction jmp __b1
Succesful ASM optimization Pass5UnreachableCodeElimination

FINAL SYMBOL TABLE
const nomodify byte* BG_COLOR = (byte*) 53280
const nomodify byte* CIA1_INTERRUPT = (byte*) 56333
const nomodify byte CIA_INTERRUPT_CLEAR = $7f
const nomodify byte* FGCOL = (byte*) 53281
const nomodify byte* IRQ_ENABLE = (byte*) 53274
const nomodify byte IRQ_RASTER = 1
const nomodify byte* IRQ_STATUS = (byte*) 53273
const nomodify void()** KERNEL_IRQ = (void()**) 788
const nomodify byte* RASTER = (byte*) 53266
const nomodify byte* VICII_CONTROL = (byte*) 53265
__interrupt(rom_min_c64) void irq()
byte~ irq::$2 reg byte a 2002.0
byte~ irq::$3 reg byte a 2002.0
byte irq::i
byte irq::i#1 i zp[1]:2 16.5
byte irq::i#7 i zp[1]:2 93.0
byte irq::j
byte irq::j#1 j zp[1]:3 151.5
byte irq::j#4 j zp[1]:3 150.375
byte irq::k
byte irq::k#1 k zp[1]:4 1501.5
byte irq::k#2 k zp[1]:4 600.5999999999999
void main()
byte~ main::$0 reg byte a 20002.0
byte~ main::$1 reg byte a 20002.0
byte main::i
byte main::i#1 i zp[1]:5 71.0
byte main::i#7 i zp[1]:5 919.3636363636363
byte main::j
byte main::j#1 j zp[1]:6 1501.5
byte main::j#4 j zp[1]:6 1500.375
byte main::k
byte main::k#1 k zp[1]:7 15001.5
byte main::k#2 k zp[1]:7 6000.6
void sub_irq()
byte~ sub_irq::$0 reg byte a 2.0000000002E10
byte~ sub_irq::$1 reg byte a 2.0000000002E10
byte sub_irq::i
byte sub_irq::i#1 i zp[1]:8 1.500000015E8
byte sub_irq::i#6 i zp[1]:8 1.0200000003000001E9
byte sub_irq::j
byte sub_irq::j#1 reg byte x 1.5000000015E9
byte sub_irq::j#4 reg byte x 1.7142857147142856E9
byte sub_irq::k
byte sub_irq::k#1 reg byte y 1.50000000015E10
byte sub_irq::k#2 reg byte y 7.50000000075E9
void sub_main()
byte~ sub_main::$0 reg byte a 2.000000000002E12
byte~ sub_main::$1 reg byte a 2.000000000002E12
byte sub_main::i
byte sub_main::i#1 i zp[1]:9 1.50000000015E10
byte sub_main::i#6 i zp[1]:9 1.0200000000030002E11
byte sub_main::j
byte sub_main::j#1 reg byte x 1.500000000015E11
byte sub_main::j#4 reg byte x 1.71428571429E11
byte sub_main::k
byte sub_main::k#1 reg byte y 1.5000000000015E12
byte sub_main::k#2 reg byte y 7.5000000000075E11

zp[1]:2 [ irq::i#7 irq::i#1 ]
zp[1]:3 [ irq::j#4 irq::j#1 ]
zp[1]:4 [ irq::k#2 irq::k#1 ]
zp[1]:5 [ main::i#7 main::i#1 ]
zp[1]:6 [ main::j#4 main::j#1 ]
zp[1]:7 [ main::k#2 main::k#1 ]
zp[1]:8 [ sub_irq::i#6 sub_irq::i#1 ]
reg byte x [ sub_irq::j#4 sub_irq::j#1 ]
reg byte y [ sub_irq::k#2 sub_irq::k#1 ]
zp[1]:9 [ sub_main::i#6 sub_main::i#1 ]
reg byte x [ sub_main::j#4 sub_main::j#1 ]
reg byte y [ sub_main::k#2 sub_main::k#1 ]
reg byte a [ irq::$2 ]
reg byte a [ irq::$3 ]
reg byte a [ main::$0 ]
reg byte a [ main::$1 ]
reg byte a [ sub_irq::$0 ]
reg byte a [ sub_irq::$1 ]
reg byte a [ sub_main::$0 ]
reg byte a [ sub_main::$1 ]


FINAL ASSEMBLER
Score: 314173671

  // File Comments
// Illustrates a problem where local variables inside an IRQ are assigned the same zeropage as a variable outside the IRQ
  // Upstart
  // Commodore 64 PRG executable file
.file [name="irq-local-var-overlap-problem.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const IRQ_RASTER = 1
  .const CIA_INTERRUPT_CLEAR = $7f
  .label KERNEL_IRQ = $314
  .label RASTER = $d012
  .label VICII_CONTROL = $d011
  .label IRQ_STATUS = $d019
  .label IRQ_ENABLE = $d01a
  .label BG_COLOR = $d020
  .label FGCOL = $d021
  .label CIA1_INTERRUPT = $dc0d
.segment Code
  // irq
irq: {
    .label k = 4
    .label j = 3
    .label i = 2
    // interrupt(isr_rom_min_c64_entry) -- isr_rom_min_c64_entry 
    // (*BG_COLOR)++;
    // [0] *BG_COLOR = ++ *BG_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BG_COLOR
    // [1] phi from irq to irq::@1 [phi:irq->irq::@1]
    // [1] phi irq::i#7 = 0 [phi:irq->irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [1] phi from irq::@5 to irq::@1 [phi:irq::@5->irq::@1]
    // [1] phi irq::i#7 = irq::i#1 [phi:irq::@5->irq::@1#0] -- register_copy 
    // irq::@1
  __b1:
    // [2] phi from irq::@1 to irq::@2 [phi:irq::@1->irq::@2]
    // [2] phi irq::j#4 = 0 [phi:irq::@1->irq::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    // [2] phi from irq::@4 to irq::@2 [phi:irq::@4->irq::@2]
    // [2] phi irq::j#4 = irq::j#1 [phi:irq::@4->irq::@2#0] -- register_copy 
    // irq::@2
  __b2:
    // [3] phi from irq::@2 to irq::@3 [phi:irq::@2->irq::@3]
    // [3] phi irq::k#2 = 0 [phi:irq::@2->irq::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    // [3] phi from irq::@7 to irq::@3 [phi:irq::@7->irq::@3]
    // [3] phi irq::k#2 = irq::k#1 [phi:irq::@7->irq::@3#0] -- register_copy 
    // irq::@3
  __b3:
    // i+j
    // [4] irq::$2 = irq::i#7 + irq::j#4 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z i
    clc
    adc.z j
    // i+j+k
    // [5] irq::$3 = irq::$2 + irq::k#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z k
    // *FGCOL = i+j+k
    // [6] *FGCOL = irq::$3 -- _deref_pbuc1=vbuaa 
    sta FGCOL
    // sub_irq()
    // [7] call sub_irq 
    // [38] phi from irq::@3 to sub_irq [phi:irq::@3->sub_irq]
    jsr sub_irq
    // irq::@7
    // for( byte k: 0..10 )
    // [8] irq::k#1 = ++ irq::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [9] if(irq::k#1!=$b) goto irq::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3
    // irq::@4
    // for( byte j: 0..10 )
    // [10] irq::j#1 = ++ irq::j#4 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [11] if(irq::j#1!=$b) goto irq::@2 -- vbuz1_neq_vbuc1_then_la1 
    cmp.z j
    bne __b2
    // irq::@5
    // for( byte i: 0..10 )
    // [12] irq::i#1 = ++ irq::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [13] if(irq::i#1!=$b) goto irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    cmp.z i
    bne __b1
    // irq::@6
    // *IRQ_STATUS = IRQ_RASTER
    // [14] *IRQ_STATUS = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // (*BG_COLOR)--;
    // [15] *BG_COLOR = -- *BG_COLOR -- _deref_pbuc1=_dec__deref_pbuc1 
    dec BG_COLOR
    // irq::@return
    // }
    // [16] return 
    // interrupt(isr_rom_min_c64_exit) -- isr_rom_min_c64_exit 
    jmp $ea81
}
  // main
main: {
    .label k = 7
    .label j = 6
    .label i = 5
    // asm
    // asm { sei  }
    sei
    // *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR
    // [18] *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
    // *VICII_CONTROL &=$7f
    // [19] *VICII_CONTROL = *VICII_CONTROL & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line to $0fd
    lda #$7f
    and VICII_CONTROL
    sta VICII_CONTROL
    // *RASTER = $fd
    // [20] *RASTER = $fd -- _deref_pbuc1=vbuc2 
    lda #$fd
    sta RASTER
    // *IRQ_ENABLE = IRQ_RASTER
    // [21] *IRQ_ENABLE = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // *KERNEL_IRQ = &irq
    // [22] *KERNEL_IRQ = &irq -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta KERNEL_IRQ
    lda #>irq
    sta KERNEL_IRQ+1
    // asm
    // asm { cli  }
    cli
    // [24] phi from main main::@5 to main::@1 [phi:main/main::@5->main::@1]
  __b4:
    // [24] phi main::i#7 = 0 [phi:main/main::@5->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // main::@1
  __b1:
    // [25] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // [25] phi main::j#4 = 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    // [25] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
    // [25] phi main::j#4 = main::j#1 [phi:main::@4->main::@2#0] -- register_copy 
    // main::@2
  __b2:
    // [26] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // [26] phi main::k#2 = 0 [phi:main::@2->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    // [26] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
    // [26] phi main::k#2 = main::k#1 [phi:main::@6->main::@3#0] -- register_copy 
    // main::@3
  __b3:
    // i+j
    // [27] main::$0 = main::i#7 + main::j#4 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z i
    clc
    adc.z j
    // i+j+k
    // [28] main::$1 = main::$0 + main::k#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z k
    // *FGCOL = i+j+k
    // [29] *FGCOL = main::$1 -- _deref_pbuc1=vbuaa 
    sta FGCOL
    // sub_main()
    // [30] call sub_main 
    // [52] phi from main::@3 to sub_main [phi:main::@3->sub_main]
    jsr sub_main
    // main::@6
    // for( byte k: 0..10 )
    // [31] main::k#1 = ++ main::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [32] if(main::k#1!=$b) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3
    // main::@4
    // for( byte j: 0..10 )
    // [33] main::j#1 = ++ main::j#4 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [34] if(main::j#1!=$b) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    cmp.z j
    bne __b2
    // main::@5
    // for( byte i: 0..10 )
    // [35] main::i#1 = ++ main::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [36] if(main::i#1!=$b) goto main::@7 -- vbuz1_neq_vbuc1_then_la1 
    cmp.z i
    bne __b1
    jmp __b4
    // [37] phi from main::@5 to main::@7 [phi:main::@5->main::@7]
    // main::@7
    // [24] phi from main::@7 to main::@1 [phi:main::@7->main::@1]
    // [24] phi main::i#7 = main::i#1 [phi:main::@7->main::@1#0] -- register_copy 
}
  // sub_irq
sub_irq: {
    .label i = 8
    // [39] phi from sub_irq to sub_irq::@1 [phi:sub_irq->sub_irq::@1]
    // [39] phi sub_irq::i#6 = 0 [phi:sub_irq->sub_irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [39] phi from sub_irq::@5 to sub_irq::@1 [phi:sub_irq::@5->sub_irq::@1]
    // [39] phi sub_irq::i#6 = sub_irq::i#1 [phi:sub_irq::@5->sub_irq::@1#0] -- register_copy 
    // sub_irq::@1
  __b1:
    // [40] phi from sub_irq::@1 to sub_irq::@2 [phi:sub_irq::@1->sub_irq::@2]
    // [40] phi sub_irq::j#4 = 0 [phi:sub_irq::@1->sub_irq::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [40] phi from sub_irq::@4 to sub_irq::@2 [phi:sub_irq::@4->sub_irq::@2]
    // [40] phi sub_irq::j#4 = sub_irq::j#1 [phi:sub_irq::@4->sub_irq::@2#0] -- register_copy 
    // sub_irq::@2
  __b2:
    // [41] phi from sub_irq::@2 to sub_irq::@3 [phi:sub_irq::@2->sub_irq::@3]
    // [41] phi sub_irq::k#2 = 0 [phi:sub_irq::@2->sub_irq::@3#0] -- vbuyy=vbuc1 
    ldy #0
    // [41] phi from sub_irq::@3 to sub_irq::@3 [phi:sub_irq::@3->sub_irq::@3]
    // [41] phi sub_irq::k#2 = sub_irq::k#1 [phi:sub_irq::@3->sub_irq::@3#0] -- register_copy 
    // sub_irq::@3
  __b3:
    // i+j
    // [42] sub_irq::$0 = sub_irq::i#6 + sub_irq::j#4 -- vbuaa=vbuz1_plus_vbuxx 
    txa
    clc
    adc.z i
    // i+j+k
    // [43] sub_irq::$1 = sub_irq::$0 + sub_irq::k#2 -- vbuaa=vbuaa_plus_vbuyy 
    sty.z $ff
    clc
    adc.z $ff
    // *BG_COLOR = i+j+k
    // [44] *BG_COLOR = sub_irq::$1 -- _deref_pbuc1=vbuaa 
    sta BG_COLOR
    // for( byte k: 0..10 )
    // [45] sub_irq::k#1 = ++ sub_irq::k#2 -- vbuyy=_inc_vbuyy 
    iny
    // [46] if(sub_irq::k#1!=$b) goto sub_irq::@3 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne __b3
    // sub_irq::@4
    // for( byte j: 0..10 )
    // [47] sub_irq::j#1 = ++ sub_irq::j#4 -- vbuxx=_inc_vbuxx 
    inx
    // [48] if(sub_irq::j#1!=$b) goto sub_irq::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne __b2
    // sub_irq::@5
    // for( byte i: 0..10 )
    // [49] sub_irq::i#1 = ++ sub_irq::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [50] if(sub_irq::i#1!=$b) goto sub_irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1
    // sub_irq::@return
    // }
    // [51] return 
    rts
}
  // sub_main
sub_main: {
    .label i = 9
    // [53] phi from sub_main to sub_main::@1 [phi:sub_main->sub_main::@1]
    // [53] phi sub_main::i#6 = 0 [phi:sub_main->sub_main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [53] phi from sub_main::@5 to sub_main::@1 [phi:sub_main::@5->sub_main::@1]
    // [53] phi sub_main::i#6 = sub_main::i#1 [phi:sub_main::@5->sub_main::@1#0] -- register_copy 
    // sub_main::@1
  __b1:
    // [54] phi from sub_main::@1 to sub_main::@2 [phi:sub_main::@1->sub_main::@2]
    // [54] phi sub_main::j#4 = 0 [phi:sub_main::@1->sub_main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [54] phi from sub_main::@4 to sub_main::@2 [phi:sub_main::@4->sub_main::@2]
    // [54] phi sub_main::j#4 = sub_main::j#1 [phi:sub_main::@4->sub_main::@2#0] -- register_copy 
    // sub_main::@2
  __b2:
    // [55] phi from sub_main::@2 to sub_main::@3 [phi:sub_main::@2->sub_main::@3]
    // [55] phi sub_main::k#2 = 0 [phi:sub_main::@2->sub_main::@3#0] -- vbuyy=vbuc1 
    ldy #0
    // [55] phi from sub_main::@3 to sub_main::@3 [phi:sub_main::@3->sub_main::@3]
    // [55] phi sub_main::k#2 = sub_main::k#1 [phi:sub_main::@3->sub_main::@3#0] -- register_copy 
    // sub_main::@3
  __b3:
    // i+j
    // [56] sub_main::$0 = sub_main::i#6 + sub_main::j#4 -- vbuaa=vbuz1_plus_vbuxx 
    txa
    clc
    adc.z i
    // i+j+k
    // [57] sub_main::$1 = sub_main::$0 + sub_main::k#2 -- vbuaa=vbuaa_plus_vbuyy 
    sty.z $ff
    clc
    adc.z $ff
    // *BG_COLOR = i+j+k
    // [58] *BG_COLOR = sub_main::$1 -- _deref_pbuc1=vbuaa 
    sta BG_COLOR
    // for( byte k: 0..10 )
    // [59] sub_main::k#1 = ++ sub_main::k#2 -- vbuyy=_inc_vbuyy 
    iny
    // [60] if(sub_main::k#1!=$b) goto sub_main::@3 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne __b3
    // sub_main::@4
    // for( byte j: 0..10 )
    // [61] sub_main::j#1 = ++ sub_main::j#4 -- vbuxx=_inc_vbuxx 
    inx
    // [62] if(sub_main::j#1!=$b) goto sub_main::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne __b2
    // sub_main::@5
    // for( byte i: 0..10 )
    // [63] sub_main::i#1 = ++ sub_main::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [64] if(sub_main::i#1!=$b) goto sub_main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1
    // sub_main::@return
    // }
    // [65] return 
    rts
}
  // File Data

