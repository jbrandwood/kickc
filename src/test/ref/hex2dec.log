Setting inferred volatile on symbol affected by address-of utoa16w::$2 = call utoa16n utoa16w::$1 &utoa16w::dst utoa16w::started 

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start
  asm { sei  }
  call cls 
  to:main::@6
main::@6: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@4 main::@6
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1 main::@2
  main::$1 = *control & $80
  main::$2 = *raster >> 1
  main::$3 = main::$1 | main::$2
  main::rst#0 = main::$3
  main::$4 = main::rst#0 != $30
  if(main::$4) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@2
  main::screen#0 = (byte*)$400
  *BORDER_COLOR = 1
  main::time_start#0 = *raster
  utoa16w::value#0 = 0
  utoa16w::dst = main::screen#0
  call utoa16w 
  to:main::@7
main::@7: scope:[main]  from main::@3
  main::time_start#5 = phi( main::@3/main::time_start#0 )
  main::screen#5 = phi( main::@3/main::screen#0 )
  *BORDER_COLOR = ++ *BORDER_COLOR
  main::screen#1 = main::screen#5 + $28
  utoa16w::value#1 = $4d2
  utoa16w::dst = main::screen#1
  call utoa16w 
  to:main::@8
main::@8: scope:[main]  from main::@7
  main::time_start#4 = phi( main::@7/main::time_start#5 )
  main::screen#6 = phi( main::@7/main::screen#1 )
  *BORDER_COLOR = ++ *BORDER_COLOR
  main::screen#2 = main::screen#6 + $28
  utoa16w::value#2 = $162e
  utoa16w::dst = main::screen#2
  call utoa16w 
  to:main::@9
main::@9: scope:[main]  from main::@8
  main::time_start#3 = phi( main::@8/main::time_start#4 )
  main::screen#7 = phi( main::@8/main::screen#2 )
  *BORDER_COLOR = ++ *BORDER_COLOR
  main::screen#3 = main::screen#7 + $28
  utoa16w::value#3 = $270f
  utoa16w::dst = main::screen#3
  call utoa16w 
  to:main::@10
main::@10: scope:[main]  from main::@9
  main::time_start#2 = phi( main::@9/main::time_start#3 )
  main::screen#8 = phi( main::@9/main::screen#3 )
  *BORDER_COLOR = ++ *BORDER_COLOR
  main::screen#4 = main::screen#8 + $28
  utoa16w::value#4 = $e608
  utoa16w::dst = main::screen#4
  call utoa16w 
  to:main::@11
main::@11: scope:[main]  from main::@10
  main::screen#9 = phi( main::@10/main::screen#4 )
  main::time_start#1 = phi( main::@10/main::time_start#2 )
  main::time_end#0 = *raster
  *BORDER_COLOR = 0
  main::$14 = main::time_end#0 - main::time_start#1
  main::time#0 = main::$14
  main::$15 = main::screen#9 + $50
  utoa10w::value#0 = (word)main::time#0
  utoa10w::dst#0 = main::$15
  call utoa10w 
  to:main::@12
main::@12: scope:[main]  from main::@11
  main::screen#12 = phi( main::@11/main::screen#9 )
  main::i#0 = 0
  to:main::@4
main::@4: scope:[main]  from main::@12 main::@5
  main::screen#11 = phi( main::@12/main::screen#12, main::@5/main::screen#10 )
  main::i#2 = phi( main::@12/main::i#0, main::@5/main::i#1 )
  main::$17 = main::msg[main::i#2] != 0
  if(main::$17) goto main::@5
  to:main::@1
main::@5: scope:[main]  from main::@4
  main::i#3 = phi( main::@4/main::i#2 )
  main::screen#10 = phi( main::@4/main::screen#11 )
  main::$18 = main::screen#10 + $50
  main::$19 = main::$18 + 3
  main::$19[main::i#3] = main::msg[main::i#3]
  main::i#1 = ++ main::i#3
  to:main::@4
main::@return: scope:[main]  from main::@1
  return 
  to:@return

void cls()
cls: scope:[cls]  from main
  cls::$0 = cls::screen + $3e7
  cls::sc#0 = cls::screen
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  cls::sc#2 = phi( cls/cls::sc#0, cls::@1/cls::sc#1 )
  *cls::sc#2 = ' '
  cls::sc#1 = cls::sc#2 + rangenext(cls::screen,cls::$0)
  cls::$1 = cls::sc#1 != rangelast(cls::screen,cls::$0)
  if(cls::$1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  return 
  to:@return

void utoa10w(word utoa10w::value , byte* utoa10w::dst)
utoa10w: scope:[utoa10w]  from main::@11
  utoa10w::dst#10 = phi( main::@11/utoa10w::dst#0 )
  utoa10w::value#5 = phi( main::@11/utoa10w::value#0 )
  utoa10w::bStarted#0 = 0
  utoa10w::digit#0 = 0
  utoa10w::i#0 = 0
  to:utoa10w::@1
utoa10w::@1: scope:[utoa10w]  from utoa10w utoa10w::@2 utoa10w::@6
  utoa10w::dst#9 = phi( utoa10w/utoa10w::dst#10, utoa10w::@2/utoa10w::dst#11, utoa10w::@6/utoa10w::dst#6 )
  utoa10w::bStarted#4 = phi( utoa10w/utoa10w::bStarted#0, utoa10w::@2/utoa10w::bStarted#1, utoa10w::@6/utoa10w::bStarted#5 )
  utoa10w::digit#5 = phi( utoa10w/utoa10w::digit#0, utoa10w::@2/utoa10w::digit#1, utoa10w::@6/utoa10w::digit#7 )
  utoa10w::value#2 = phi( utoa10w/utoa10w::value#5, utoa10w::@2/utoa10w::value#1, utoa10w::@6/utoa10w::value#6 )
  utoa10w::i#2 = phi( utoa10w/utoa10w::i#0, utoa10w::@2/utoa10w::i#3, utoa10w::@6/utoa10w::i#1 )
  utoa10w::$7 = utoa10w::i#2 * SIZEOF_WORD
  utoa10w::$0 = utoa10w::value#2 >= UTOA10_SUB[utoa10w::$7]
  if(utoa10w::$0) goto utoa10w::@2
  to:utoa10w::@3
utoa10w::@2: scope:[utoa10w]  from utoa10w::@1
  utoa10w::dst#11 = phi( utoa10w::@1/utoa10w::dst#9 )
  utoa10w::value#3 = phi( utoa10w::@1/utoa10w::value#2 )
  utoa10w::i#3 = phi( utoa10w::@1/utoa10w::i#2 )
  utoa10w::digit#3 = phi( utoa10w::@1/utoa10w::digit#5 )
  utoa10w::digit#1 = utoa10w::digit#3 + UTOA10_VAL[utoa10w::i#3]
  utoa10w::$8 = utoa10w::i#3 * SIZEOF_WORD
  utoa10w::value#1 = utoa10w::value#3 - UTOA10_SUB[utoa10w::$8]
  utoa10w::bStarted#1 = 1
  to:utoa10w::@1
utoa10w::@3: scope:[utoa10w]  from utoa10w::@1
  utoa10w::digit#8 = phi( utoa10w::@1/utoa10w::digit#5 )
  utoa10w::dst#7 = phi( utoa10w::@1/utoa10w::dst#9 )
  utoa10w::value#7 = phi( utoa10w::@1/utoa10w::value#2 )
  utoa10w::bStarted#3 = phi( utoa10w::@1/utoa10w::bStarted#4 )
  utoa10w::i#4 = phi( utoa10w::@1/utoa10w::i#2 )
  utoa10w::$1 = utoa10w::i#4 & 1
  utoa10w::$2 = utoa10w::$1 != 0
  utoa10w::$3 = ! utoa10w::$2
  if(utoa10w::$3) goto utoa10w::@6
  to:utoa10w::@4
utoa10w::@6: scope:[utoa10w]  from utoa10w::@3 utoa10w::@7
  utoa10w::bStarted#5 = phi( utoa10w::@3/utoa10w::bStarted#3, utoa10w::@7/utoa10w::bStarted#6 )
  utoa10w::digit#7 = phi( utoa10w::@3/utoa10w::digit#8, utoa10w::@7/utoa10w::digit#2 )
  utoa10w::dst#6 = phi( utoa10w::@3/utoa10w::dst#7, utoa10w::@7/utoa10w::dst#8 )
  utoa10w::value#6 = phi( utoa10w::@3/utoa10w::value#7, utoa10w::@7/utoa10w::value#8 )
  utoa10w::i#5 = phi( utoa10w::@3/utoa10w::i#4, utoa10w::@7/utoa10w::i#6 )
  utoa10w::i#1 = utoa10w::i#5 + rangenext(0,7)
  utoa10w::$6 = utoa10w::i#1 != rangelast(0,7)
  if(utoa10w::$6) goto utoa10w::@1
  to:utoa10w::@8
utoa10w::@4: scope:[utoa10w]  from utoa10w::@3
  utoa10w::value#9 = phi( utoa10w::@3/utoa10w::value#7 )
  utoa10w::i#7 = phi( utoa10w::@3/utoa10w::i#4 )
  utoa10w::dst#5 = phi( utoa10w::@3/utoa10w::dst#7 )
  utoa10w::digit#6 = phi( utoa10w::@3/utoa10w::digit#8 )
  utoa10w::bStarted#2 = phi( utoa10w::@3/utoa10w::bStarted#3 )
  utoa10w::$4 = utoa10w::bStarted#2 != 0
  utoa10w::$5 = ! utoa10w::$4
  if(utoa10w::$5) goto utoa10w::@7
  to:utoa10w::@5
utoa10w::@7: scope:[utoa10w]  from utoa10w::@4 utoa10w::@5
  utoa10w::bStarted#6 = phi( utoa10w::@4/utoa10w::bStarted#2, utoa10w::@5/utoa10w::bStarted#7 )
  utoa10w::dst#8 = phi( utoa10w::@4/utoa10w::dst#5, utoa10w::@5/utoa10w::dst#1 )
  utoa10w::value#8 = phi( utoa10w::@4/utoa10w::value#9, utoa10w::@5/utoa10w::value#10 )
  utoa10w::i#6 = phi( utoa10w::@4/utoa10w::i#7, utoa10w::@5/utoa10w::i#8 )
  utoa10w::digit#2 = 0
  to:utoa10w::@6
utoa10w::@5: scope:[utoa10w]  from utoa10w::@4
  utoa10w::bStarted#7 = phi( utoa10w::@4/utoa10w::bStarted#2 )
  utoa10w::value#10 = phi( utoa10w::@4/utoa10w::value#9 )
  utoa10w::i#8 = phi( utoa10w::@4/utoa10w::i#7 )
  utoa10w::dst#3 = phi( utoa10w::@4/utoa10w::dst#5 )
  utoa10w::digit#4 = phi( utoa10w::@4/utoa10w::digit#6 )
  *utoa10w::dst#3 = DIGITS[utoa10w::digit#4]
  utoa10w::dst#1 = ++ utoa10w::dst#3
  to:utoa10w::@7
utoa10w::@8: scope:[utoa10w]  from utoa10w::@6
  utoa10w::dst#4 = phi( utoa10w::@6/utoa10w::dst#6 )
  utoa10w::value#4 = phi( utoa10w::@6/utoa10w::value#6 )
  utoa10w::$9 = (byte)utoa10w::value#4
  *utoa10w::dst#4 = DIGITS[utoa10w::$9]
  utoa10w::dst#2 = ++ utoa10w::dst#4
  *utoa10w::dst#2 = 0
  to:utoa10w::@return
utoa10w::@return: scope:[utoa10w]  from utoa10w::@8
  return 
  to:@return

void utoa16w(word utoa16w::value , byte* volatile utoa16w::dst)
utoa16w: scope:[utoa16w]  from main::@10 main::@3 main::@7 main::@8 main::@9
  utoa16w::value#5 = phi( main::@10/utoa16w::value#4, main::@3/utoa16w::value#0, main::@7/utoa16w::value#1, main::@8/utoa16w::value#2, main::@9/utoa16w::value#3 )
  utoa16w::started#0 = 0
  utoa16w::$0 = > utoa16w::value#5
  utoa16w::$1 = utoa16w::$0 >> 4
  utoa16n::nybble#0 = utoa16w::$1
  utoa16n::dst#0 = &utoa16w::dst
  utoa16n::started#0 = utoa16w::started#0
  call utoa16n 
  utoa16n::return#0 = utoa16n::return#5
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  utoa16w::value#6 = phi( utoa16w/utoa16w::value#5 )
  utoa16n::return#6 = phi( utoa16w/utoa16n::return#0 )
  utoa16w::$2 = utoa16n::return#6
  utoa16w::started#1 = utoa16w::$2
  utoa16w::$3 = > utoa16w::value#6
  utoa16w::$4 = utoa16w::$3 & $f
  utoa16n::nybble#1 = utoa16w::$4
  utoa16n::dst#1 = &utoa16w::dst
  utoa16n::started#1 = utoa16w::started#1
  call utoa16n 
  utoa16n::return#1 = utoa16n::return#5
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  utoa16w::value#7 = phi( utoa16w::@1/utoa16w::value#6 )
  utoa16n::return#7 = phi( utoa16w::@1/utoa16n::return#1 )
  utoa16w::$5 = utoa16n::return#7
  utoa16w::started#2 = utoa16w::$5
  utoa16w::$6 = < utoa16w::value#7
  utoa16w::$7 = utoa16w::$6 >> 4
  utoa16n::nybble#2 = utoa16w::$7
  utoa16n::dst#2 = &utoa16w::dst
  utoa16n::started#2 = utoa16w::started#2
  call utoa16n 
  utoa16n::return#2 = utoa16n::return#5
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  utoa16w::value#8 = phi( utoa16w::@2/utoa16w::value#7 )
  utoa16n::return#8 = phi( utoa16w::@2/utoa16n::return#2 )
  utoa16w::$8 = utoa16n::return#8
  utoa16w::started#3 = utoa16w::$8
  utoa16w::$9 = < utoa16w::value#8
  utoa16w::$10 = utoa16w::$9 & $f
  utoa16n::nybble#3 = utoa16w::$10
  utoa16n::dst#3 = &utoa16w::dst
  utoa16n::started#3 = 1
  call utoa16n 
  utoa16n::return#3 = utoa16n::return#5
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  *utoa16w::dst = 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  return 
  to:@return

byte utoa16n(byte utoa16n::nybble , word** utoa16n::dst , byte utoa16n::started)
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  utoa16n::dst#6 = phi( utoa16w/utoa16n::dst#0, utoa16w::@1/utoa16n::dst#1, utoa16w::@2/utoa16n::dst#2, utoa16w::@3/utoa16n::dst#3 )
  utoa16n::started#7 = phi( utoa16w/utoa16n::started#0, utoa16w::@1/utoa16n::started#1, utoa16w::@2/utoa16n::started#2, utoa16w::@3/utoa16n::started#3 )
  utoa16n::nybble#4 = phi( utoa16w/utoa16n::nybble#0, utoa16w::@1/utoa16n::nybble#1, utoa16w::@2/utoa16n::nybble#2, utoa16w::@3/utoa16n::nybble#3 )
  utoa16n::$0 = utoa16n::nybble#4 != 0
  utoa16n::$1 = ! utoa16n::$0
  if(utoa16n::$1) goto utoa16n::@1
  to:utoa16n::@3
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  utoa16n::dst#5 = phi( utoa16n/utoa16n::dst#6, utoa16n::@3/utoa16n::dst#7 )
  utoa16n::nybble#6 = phi( utoa16n/utoa16n::nybble#4, utoa16n::@3/utoa16n::nybble#7 )
  utoa16n::started#5 = phi( utoa16n/utoa16n::started#7, utoa16n::@3/utoa16n::started#4 )
  utoa16n::$2 = utoa16n::started#5 != 0
  utoa16n::$3 = ! utoa16n::$2
  if(utoa16n::$3) goto utoa16n::@2
  to:utoa16n::@4
utoa16n::@3: scope:[utoa16n]  from utoa16n
  utoa16n::dst#7 = phi( utoa16n/utoa16n::dst#6 )
  utoa16n::nybble#7 = phi( utoa16n/utoa16n::nybble#4 )
  utoa16n::started#4 = 1
  to:utoa16n::@1
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1 utoa16n::@4
  utoa16n::started#6 = phi( utoa16n::@1/utoa16n::started#5, utoa16n::@4/utoa16n::started#8 )
  utoa16n::return#4 = utoa16n::started#6
  to:utoa16n::@return
utoa16n::@4: scope:[utoa16n]  from utoa16n::@1
  utoa16n::started#8 = phi( utoa16n::@1/utoa16n::started#5 )
  utoa16n::dst#4 = phi( utoa16n::@1/utoa16n::dst#5 )
  utoa16n::nybble#5 = phi( utoa16n::@1/utoa16n::nybble#6 )
  *(*utoa16n::dst#4) = DIGITS[utoa16n::nybble#5]
  *utoa16n::dst#4 = ++ *utoa16n::dst#4
  to:utoa16n::@2
utoa16n::@return: scope:[utoa16n]  from utoa16n::@2
  utoa16n::return#9 = phi( utoa16n::@2/utoa16n::return#4 )
  utoa16n::return#5 = utoa16n::return#9
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* const BORDER_COLOR = (byte*)$d020
constant byte* DIGITS[]  = "0123456789abcdef"
constant byte SIZEOF_WORD = 2
constant word* UTOA10_SUB[]  = { $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a }
constant byte* UTOA10_VAL[]  = { 3, 1, 3, 1, 3, 1, 3, 1 }
void __start()
void cls()
byte*~ cls::$0
bool~ cls::$1
byte* cls::sc
byte* cls::sc#0
byte* cls::sc#1
byte* cls::sc#2
constant byte* cls::screen = (byte*)$400
constant byte* const control = (byte*)$d011
void main()
number~ main::$1
byte~ main::$14
byte*~ main::$15
bool~ main::$17
byte*~ main::$18
byte*~ main::$19
byte~ main::$2
number~ main::$3
bool~ main::$4
byte main::i
byte main::i#0
byte main::i#1
byte main::i#2
byte main::i#3
constant byte* main::msg[]  = "raster lines"
byte main::rst
byte main::rst#0
byte* main::screen
byte* main::screen#0
byte* main::screen#1
byte* main::screen#10
byte* main::screen#11
byte* main::screen#12
byte* main::screen#2
byte* main::screen#3
byte* main::screen#4
byte* main::screen#5
byte* main::screen#6
byte* main::screen#7
byte* main::screen#8
byte* main::screen#9
byte main::time
byte main::time#0
byte main::time_end
byte main::time_end#0
byte main::time_start
byte main::time_start#0
byte main::time_start#1
byte main::time_start#2
byte main::time_start#3
byte main::time_start#4
byte main::time_start#5
constant byte* const raster = (byte*)$d012
void utoa10w(word utoa10w::value , byte* utoa10w::dst)
bool~ utoa10w::$0
number~ utoa10w::$1
bool~ utoa10w::$2
bool~ utoa10w::$3
bool~ utoa10w::$4
bool~ utoa10w::$5
bool~ utoa10w::$6
byte~ utoa10w::$7
byte~ utoa10w::$8
byte~ utoa10w::$9
byte utoa10w::bStarted
byte utoa10w::bStarted#0
byte utoa10w::bStarted#1
byte utoa10w::bStarted#2
byte utoa10w::bStarted#3
byte utoa10w::bStarted#4
byte utoa10w::bStarted#5
byte utoa10w::bStarted#6
byte utoa10w::bStarted#7
byte utoa10w::digit
byte utoa10w::digit#0
byte utoa10w::digit#1
byte utoa10w::digit#2
byte utoa10w::digit#3
byte utoa10w::digit#4
byte utoa10w::digit#5
byte utoa10w::digit#6
byte utoa10w::digit#7
byte utoa10w::digit#8
byte* utoa10w::dst
byte* utoa10w::dst#0
byte* utoa10w::dst#1
byte* utoa10w::dst#10
byte* utoa10w::dst#11
byte* utoa10w::dst#2
byte* utoa10w::dst#3
byte* utoa10w::dst#4
byte* utoa10w::dst#5
byte* utoa10w::dst#6
byte* utoa10w::dst#7
byte* utoa10w::dst#8
byte* utoa10w::dst#9
byte utoa10w::i
byte utoa10w::i#0
byte utoa10w::i#1
byte utoa10w::i#2
byte utoa10w::i#3
byte utoa10w::i#4
byte utoa10w::i#5
byte utoa10w::i#6
byte utoa10w::i#7
byte utoa10w::i#8
word utoa10w::value
word utoa10w::value#0
word utoa10w::value#1
word utoa10w::value#10
word utoa10w::value#2
word utoa10w::value#3
word utoa10w::value#4
word utoa10w::value#5
word utoa10w::value#6
word utoa10w::value#7
word utoa10w::value#8
word utoa10w::value#9
byte utoa16n(byte utoa16n::nybble , word** utoa16n::dst , byte utoa16n::started)
bool~ utoa16n::$0
bool~ utoa16n::$1
bool~ utoa16n::$2
bool~ utoa16n::$3
word** utoa16n::dst
word** utoa16n::dst#0
word** utoa16n::dst#1
word** utoa16n::dst#2
word** utoa16n::dst#3
word** utoa16n::dst#4
word** utoa16n::dst#5
word** utoa16n::dst#6
word** utoa16n::dst#7
byte utoa16n::nybble
byte utoa16n::nybble#0
byte utoa16n::nybble#1
byte utoa16n::nybble#2
byte utoa16n::nybble#3
byte utoa16n::nybble#4
byte utoa16n::nybble#5
byte utoa16n::nybble#6
byte utoa16n::nybble#7
byte utoa16n::return
byte utoa16n::return#0
byte utoa16n::return#1
byte utoa16n::return#2
byte utoa16n::return#3
byte utoa16n::return#4
byte utoa16n::return#5
byte utoa16n::return#6
byte utoa16n::return#7
byte utoa16n::return#8
byte utoa16n::return#9
byte utoa16n::started
byte utoa16n::started#0
byte utoa16n::started#1
byte utoa16n::started#2
byte utoa16n::started#3
byte utoa16n::started#4
byte utoa16n::started#5
byte utoa16n::started#6
byte utoa16n::started#7
byte utoa16n::started#8
void utoa16w(word utoa16w::value , byte* volatile utoa16w::dst)
byte~ utoa16w::$0
byte~ utoa16w::$1
number~ utoa16w::$10
byte~ utoa16w::$2
byte~ utoa16w::$3
number~ utoa16w::$4
byte~ utoa16w::$5
byte~ utoa16w::$6
byte~ utoa16w::$7
byte~ utoa16w::$8
byte~ utoa16w::$9
byte* volatile utoa16w::dst loadstore
byte utoa16w::started
byte utoa16w::started#0
byte utoa16w::started#1
byte utoa16w::started#2
byte utoa16w::started#3
word utoa16w::value
word utoa16w::value#0
word utoa16w::value#1
word utoa16w::value#2
word utoa16w::value#3
word utoa16w::value#4
word utoa16w::value#5
word utoa16w::value#6
word utoa16w::value#7
word utoa16w::value#8

Adding number conversion cast (unumber) $80 in main::$1 = *control & $80
Adding number conversion cast (unumber) main::$1 in main::$1 = *control & (unumber)$80
Adding number conversion cast (unumber) 1 in main::$2 = *raster >> 1
Adding number conversion cast (unumber) main::$3 in main::$3 = main::$1 | main::$2
Adding number conversion cast (unumber) $30 in main::$4 = main::rst#0 != $30
Adding number conversion cast (unumber) 1 in *BORDER_COLOR = 1
Adding number conversion cast (unumber) 0 in utoa16w::value#0 = 0
Adding number conversion cast (unumber) $28 in main::screen#1 = main::screen#5 + $28
Adding number conversion cast (unumber) $4d2 in utoa16w::value#1 = $4d2
Adding number conversion cast (unumber) $28 in main::screen#2 = main::screen#6 + $28
Adding number conversion cast (unumber) $162e in utoa16w::value#2 = $162e
Adding number conversion cast (unumber) $28 in main::screen#3 = main::screen#7 + $28
Adding number conversion cast (unumber) $270f in utoa16w::value#3 = $270f
Adding number conversion cast (unumber) $28 in main::screen#4 = main::screen#8 + $28
Adding number conversion cast (unumber) $e608 in utoa16w::value#4 = $e608
Adding number conversion cast (unumber) 0 in *BORDER_COLOR = 0
Adding number conversion cast (unumber) $50 in main::$15 = main::screen#9 + $50
Adding number conversion cast (unumber) 0 in main::$17 = main::msg[main::i#2] != 0
Adding number conversion cast (unumber) $50 in main::$18 = main::screen#10 + $50
Adding number conversion cast (unumber) 3 in main::$19 = main::$18 + 3
Adding number conversion cast (unumber) $3e7 in cls::$0 = cls::screen + $3e7
Adding number conversion cast (unumber) 1 in utoa10w::bStarted#1 = 1
Adding number conversion cast (unumber) 1 in utoa10w::$1 = utoa10w::i#4 & 1
Adding number conversion cast (unumber) utoa10w::$1 in utoa10w::$1 = utoa10w::i#4 & (unumber)1
Adding number conversion cast (unumber) 0 in utoa10w::$2 = utoa10w::$1 != 0
Adding number conversion cast (unumber) 0 in utoa10w::$4 = utoa10w::bStarted#2 != 0
Adding number conversion cast (unumber) 0 in utoa10w::digit#2 = 0
Adding number conversion cast (unumber) 0 in *utoa10w::dst#2 = 0
Adding number conversion cast (unumber) 4 in utoa16w::$1 = utoa16w::$0 >> 4
Adding number conversion cast (unumber) $f in utoa16w::$4 = utoa16w::$3 & $f
Adding number conversion cast (unumber) utoa16w::$4 in utoa16w::$4 = utoa16w::$3 & (unumber)$f
Adding number conversion cast (unumber) 4 in utoa16w::$7 = utoa16w::$6 >> 4
Adding number conversion cast (unumber) $f in utoa16w::$10 = utoa16w::$9 & $f
Adding number conversion cast (unumber) utoa16w::$10 in utoa16w::$10 = utoa16w::$9 & (unumber)$f
Adding number conversion cast (unumber) 1 in utoa16n::started#3 = 1
Adding number conversion cast (unumber) 0 in *utoa16w::dst = 0
Adding number conversion cast (unumber) 0 in utoa16n::$0 = utoa16n::nybble#4 != 0
Adding number conversion cast (unumber) 0 in utoa16n::$2 = utoa16n::started#5 != 0
Adding number conversion cast (unumber) 1 in utoa16n::started#4 = 1
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *BORDER_COLOR = (unumber)1
Inlining cast utoa16w::value#0 = (unumber)0
Inlining cast utoa16w::value#1 = (unumber)$4d2
Inlining cast utoa16w::value#2 = (unumber)$162e
Inlining cast utoa16w::value#3 = (unumber)$270f
Inlining cast utoa16w::value#4 = (unumber)$e608
Inlining cast *BORDER_COLOR = (unumber)0
Inlining cast utoa10w::bStarted#1 = (unumber)1
Inlining cast utoa10w::digit#2 = (unumber)0
Inlining cast *utoa10w::dst#2 = (unumber)0
Inlining cast utoa16n::started#3 = (unumber)1
Inlining cast *utoa16w::dst = (unumber)0
Inlining cast utoa16n::started#4 = (unumber)1
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $80
Simplifying constant integer cast 1
Simplifying constant integer cast $30
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast $4d2
Simplifying constant integer cast $28
Simplifying constant integer cast $162e
Simplifying constant integer cast $28
Simplifying constant integer cast $270f
Simplifying constant integer cast $28
Simplifying constant integer cast $e608
Simplifying constant integer cast 0
Simplifying constant integer cast $50
Simplifying constant integer cast 0
Simplifying constant integer cast $50
Simplifying constant integer cast 3
Simplifying constant integer cast $3e7
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $30
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $4d2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $162e
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $270f
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $e608
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $50
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $50
Finalized unsigned number type (byte) 3
Finalized unsigned number type (word) $3e7
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in main::$1 = *control & $80
Inferred type updated to byte in main::$3 = main::$1 | main::$2
Inferred type updated to byte in utoa10w::$1 = utoa10w::i#4 & 1
Inferred type updated to byte in utoa16w::$4 = utoa16w::$3 & $f
Inferred type updated to byte in utoa16w::$10 = utoa16w::$9 & $f
Inversing boolean not [83] utoa10w::$3 = utoa10w::$1 == 0 from [82] utoa10w::$2 = utoa10w::$1 != 0
Inversing boolean not [91] utoa10w::$5 = utoa10w::bStarted#2 == 0 from [90] utoa10w::$4 = utoa10w::bStarted#2 != 0
Inversing boolean not [147] utoa16n::$1 = utoa16n::nybble#4 == 0 from [146] utoa16n::$0 = utoa16n::nybble#4 != 0
Inversing boolean not [151] utoa16n::$3 = utoa16n::started#5 == 0 from [150] utoa16n::$2 = utoa16n::started#5 != 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias main::rst#0 = main::$3 
Alias main::screen#0 = main::screen#5 
Alias main::time_start#0 = main::time_start#5 main::time_start#4 main::time_start#3 main::time_start#2 main::time_start#1 
Alias main::screen#1 = main::screen#6 
Alias main::screen#2 = main::screen#7 
Alias main::screen#3 = main::screen#8 
Alias main::screen#12 = main::screen#9 main::screen#4 
Alias main::time#0 = main::$14 
Alias utoa10w::dst#0 = main::$15 
Alias main::screen#10 = main::screen#11 
Alias main::i#2 = main::i#3 
Alias utoa10w::digit#3 = utoa10w::digit#5 utoa10w::digit#8 utoa10w::digit#6 utoa10w::digit#4 
Alias utoa10w::i#2 = utoa10w::i#3 utoa10w::i#4 utoa10w::i#7 utoa10w::i#8 
Alias utoa10w::value#10 = utoa10w::value#3 utoa10w::value#2 utoa10w::value#7 utoa10w::value#9 
Alias utoa10w::dst#11 = utoa10w::dst#9 utoa10w::dst#7 utoa10w::dst#5 utoa10w::dst#3 
Alias utoa10w::bStarted#2 = utoa10w::bStarted#3 utoa10w::bStarted#4 utoa10w::bStarted#7 
Alias utoa10w::value#4 = utoa10w::value#6 
Alias utoa10w::dst#4 = utoa10w::dst#6 
Alias utoa16n::nybble#0 = utoa16w::$1 
Alias utoa16n::return#0 = utoa16n::return#6 
Alias utoa16w::value#5 = utoa16w::value#6 utoa16w::value#7 utoa16w::value#8 
Alias utoa16w::started#1 = utoa16w::$2 
Alias utoa16n::nybble#1 = utoa16w::$4 
Alias utoa16n::return#1 = utoa16n::return#7 
Alias utoa16w::started#2 = utoa16w::$5 
Alias utoa16n::nybble#2 = utoa16w::$7 
Alias utoa16n::return#2 = utoa16n::return#8 
Alias utoa16w::started#3 = utoa16w::$8 
Alias utoa16n::nybble#3 = utoa16w::$10 
Alias utoa16n::nybble#4 = utoa16n::nybble#7 
Alias utoa16n::dst#6 = utoa16n::dst#7 
Alias utoa16n::return#4 = utoa16n::started#6 utoa16n::return#9 utoa16n::return#5 
Alias utoa16n::nybble#5 = utoa16n::nybble#6 
Alias utoa16n::dst#4 = utoa16n::dst#5 
Alias utoa16n::started#5 = utoa16n::started#8 
Successful SSA optimization Pass2AliasElimination
Alias utoa10w::i#2 = utoa10w::i#6 
Alias utoa10w::value#10 = utoa10w::value#8 
Alias utoa10w::bStarted#2 = utoa10w::bStarted#6 
Alias utoa16n::nybble#4 = utoa16n::nybble#5 
Alias utoa16n::dst#4 = utoa16n::dst#6 
Alias utoa16n::return#4 = utoa16n::started#5 
Successful SSA optimization Pass2AliasElimination
Alias utoa10w::i#2 = utoa10w::i#5 
Alias utoa10w::value#10 = utoa10w::value#4 
Alias utoa10w::bStarted#2 = utoa10w::bStarted#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values main::screen#10 main::screen#12
Identical Phi Values utoa10w::value#5 utoa10w::value#0
Identical Phi Values utoa10w::dst#10 utoa10w::dst#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$4 [7] if(main::rst#0!=$30) goto main::@2
Simple Condition main::$17 [43] if(main::msg[main::i#2]!=0) goto main::@5
Simple Condition cls::$1 [55] if(cls::sc#1!=rangelast(cls::screen,cls::$0)) goto cls::@1
Simple Condition utoa10w::$0 [64] if(utoa10w::value#10>=UTOA10_SUB[utoa10w::$7]) goto utoa10w::@2
Simple Condition utoa10w::$3 [71] if(utoa10w::$1==0) goto utoa10w::@6
Simple Condition utoa10w::$6 [75] if(utoa10w::i#1!=rangelast(0,7)) goto utoa10w::@1
Simple Condition utoa10w::$5 [77] if(utoa10w::bStarted#2==0) goto utoa10w::@7
Simple Condition utoa16n::$1 [120] if(utoa16n::nybble#4==0) goto utoa16n::@1
Simple Condition utoa16n::$3 [123] if(utoa16n::return#4==0) goto utoa16n::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [49] cls::$0 = cls::screen + $3e7
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::screen#0 = (byte*) 1024
Constant utoa16w::value#0 = 0
Constant utoa16w::value#1 = $4d2
Constant utoa16w::value#2 = $162e
Constant utoa16w::value#3 = $270f
Constant utoa16w::value#4 = $e608
Constant main::i#0 = 0
Constant cls::$0 = cls::screen+$3e7
Constant cls::sc#0 = cls::screen
Constant utoa10w::bStarted#0 = 0
Constant utoa10w::digit#0 = 0
Constant utoa10w::i#0 = 0
Constant utoa10w::bStarted#1 = 1
Constant utoa10w::digit#2 = 0
Constant utoa16w::started#0 = 0
Constant utoa16n::dst#0 = &utoa16w::dst
Constant utoa16n::dst#1 = &utoa16w::dst
Constant utoa16n::dst#2 = &utoa16w::dst
Constant utoa16n::dst#3 = &utoa16w::dst
Constant utoa16n::started#3 = 1
Constant utoa16n::started#4 = 1
Successful SSA optimization Pass2ConstantIdentification
Constant utoa16n::started#0 = utoa16w::started#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [2] if(true) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [53] cls::sc#1 = ++ cls::sc#2 to ++
Resolved ranged comparison value [55] if(cls::sc#1!=rangelast(cls::screen,cls::$0)) goto cls::@1 to (byte*)cls::$0+1
Resolved ranged next value [73] utoa10w::i#1 = ++ utoa10w::i#2 to ++
Resolved ranged comparison value [75] if(utoa10w::i#1!=rangelast(0,7)) goto utoa10w::@1 to 8
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused variable utoa16w::started#3 and assignment [80] utoa16w::started#3 = utoa16n::return#2
Eliminating unused variable utoa16n::return#3 and assignment [84] utoa16n::return#3 = utoa16n::return#4
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused variable utoa16n::return#2 and assignment [79] utoa16n::return#2 = utoa16n::return#4
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) 1 in [41] if(cls::sc#1!=(byte*)cls::$0+1) goto cls::@1
Adding number conversion cast (unumber) 8 in [53] if(utoa10w::i#1!=8) goto utoa10w::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast cls::$0+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [11] main::screen#1 = main::screen#0 + $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::screen#1 = main::screen#0+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [14] main::screen#2 = main::screen#1 + $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::screen#2 = main::screen#1+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [17] main::screen#3 = main::screen#2 + $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::screen#3 = main::screen#2+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [20] main::screen#12 = main::screen#3 + $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::screen#12 = main::screen#3+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [25] utoa10w::dst#0 = main::screen#12 + $50
Constant right-side identified [30] main::$18 = main::screen#12 + $50
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant utoa10w::dst#0 = main::screen#12+$50
Constant main::$18 = main::screen#12+$50
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [29] main::$19 = main::$18 + 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::$19 = main::$18+3
Successful SSA optimization Pass2ConstantIdentification
Rewriting multiplication to use shift [37] utoa10w::$7 = utoa10w::i#2 * SIZEOF_WORD
Rewriting multiplication to use shift [40] utoa10w::$8 = utoa10w::i#2 * SIZEOF_WORD
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with different constant siblings main::screen#0
Inlining constant with var siblings main::i#0
Inlining constant with different constant siblings main::screen#1
Inlining constant with different constant siblings main::screen#2
Inlining constant with different constant siblings main::screen#3
Inlining constant with different constant siblings main::screen#12
Inlining constant with var siblings cls::sc#0
Inlining constant with var siblings utoa10w::bStarted#0
Inlining constant with var siblings utoa10w::digit#0
Inlining constant with var siblings utoa10w::i#0
Inlining constant with var siblings utoa10w::bStarted#1
Inlining constant with var siblings utoa10w::digit#2
Inlining constant with var siblings utoa10w::dst#0
Inlining constant with var siblings utoa16w::value#0
Inlining constant with var siblings utoa16w::value#1
Inlining constant with var siblings utoa16w::value#2
Inlining constant with var siblings utoa16w::value#3
Inlining constant with var siblings utoa16w::value#4
Inlining constant with var siblings utoa16w::started#0
Inlining constant with var siblings utoa16n::dst#0
Inlining constant with var siblings utoa16n::dst#1
Inlining constant with var siblings utoa16n::dst#2
Inlining constant with var siblings utoa16n::dst#3
Inlining constant with var siblings utoa16n::started#3
Inlining constant with var siblings utoa16n::started#4
Inlining constant with var siblings utoa16n::started#0
Constant inlined main::screen#0 = (byte*) 1024
Constant inlined main::screen#1 = (byte*) 1024+$28
Constant inlined utoa16w::value#2 = $162e
Constant inlined utoa16w::value#1 = $4d2
Constant inlined main::screen#2 = (byte*) 1024+$28+$28
Constant inlined utoa16w::value#0 = 0
Constant inlined main::screen#3 = (byte*) 1024+$28+$28+$28
Constant inlined utoa10w::bStarted#1 = 1
Constant inlined utoa10w::bStarted#0 = 0
Constant inlined main::screen#12 = (byte*) 1024+$28+$28+$28+$28
Constant inlined utoa16n::started#0 = 0
Constant inlined main::$18 = (byte*) 1024+$28+$28+$28+$28+$50
Constant inlined main::$19 = (byte*) 1024+$28+$28+$28+$28+$50+3
Constant inlined main::i#0 = 0
Constant inlined utoa16n::dst#1 = &utoa16w::dst
Constant inlined utoa16n::dst#0 = &utoa16w::dst
Constant inlined utoa16n::started#3 = 1
Constant inlined utoa16n::dst#3 = &utoa16w::dst
Constant inlined utoa16n::started#4 = 1
Constant inlined utoa16n::dst#2 = &utoa16w::dst
Constant inlined cls::sc#0 = cls::screen
Constant inlined utoa16w::started#0 = 0
Constant inlined cls::$0 = cls::screen+$3e7
Constant inlined utoa10w::i#0 = 0
Constant inlined utoa10w::dst#0 = (byte*) 1024+$28+$28+$28+$28+$50
Constant inlined utoa10w::digit#0 = 0
Constant inlined utoa16w::value#4 = $e608
Constant inlined utoa16w::value#3 = $270f
Constant inlined utoa10w::digit#2 = 0
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values utoa16n::dst#4 &utoa16w::dst
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [40] utoa10w::$8 = utoa10w::i#2 << 1
Successful SSA optimization Pass2DuplicateRValueIdentification
Eliminating unused constant SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Alias utoa10w::$8 = utoa10w::$7 
Successful SSA optimization Pass2AliasElimination
Added new block during phi lifting cls::@2(between cls::@1 and cls::@1)
Added new block during phi lifting utoa10w::@9(between utoa10w::@6 and utoa10w::@1)
Added new block during phi lifting utoa10w::@10(between utoa10w::@3 and utoa10w::@6)
Added new block during phi lifting utoa10w::@11(between utoa10w::@4 and utoa10w::@7)
Added new block during phi lifting utoa16n::@5(between utoa16n and utoa16n::@1)
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@12
Adding NOP phi() at start of cls
Adding NOP phi() at start of utoa16n::@3
Adding NOP phi() at start of utoa16n::@2
CALL GRAPH
Calls in [main] to cls:1 utoa16w:11 utoa16w:14 utoa16w:17 utoa16w:20 utoa16w:23 utoa10w:28 
Calls in [utoa16w] to utoa16n:46 utoa16n:54 utoa16n:62 utoa16n:66 

Created 14 initial phi equivalence classes
Coalesced [34] main::i#4 = main::i#1
Coalesced [41] cls::sc#3 = cls::sc#1
Coalesced [45] utoa16n::nybble#8 = utoa16n::nybble#0
Coalesced [52] utoa16n::nybble#9 = utoa16n::nybble#1
Coalesced [53] utoa16n::started#9 = utoa16n::started#1
Coalesced [60] utoa16n::nybble#10 = utoa16n::nybble#2
Coalesced [61] utoa16n::started#10 = utoa16n::started#2
Coalesced [65] utoa16n::nybble#11 = utoa16n::nybble#3
Coalesced [69] utoa10w::value#11 = utoa10w::value#0
Coalesced [78] utoa10w::dst#17 = utoa10w::dst#1
Coalesced [80] utoa10w::dst#15 = utoa10w::dst#8
Coalesced [89] utoa10w::i#10 = utoa10w::i#1
Coalesced (already) [90] utoa10w::value#13 = utoa10w::value#10
Coalesced [91] utoa10w::digit#10 = utoa10w::digit#7
Coalesced (already) [92] utoa10w::bStarted#8 = utoa10w::bStarted#2
Coalesced [93] utoa10w::dst#13 = utoa10w::dst#4
Coalesced (already) [94] utoa10w::dst#16 = utoa10w::dst#11
Coalesced (already) [95] utoa10w::dst#14 = utoa10w::dst#11
Coalesced (already) [96] utoa10w::digit#11 = utoa10w::digit#3
Coalesced (already) [99] utoa10w::i#9 = utoa10w::i#2
Coalesced [100] utoa10w::value#12 = utoa10w::value#1
Coalesced [101] utoa10w::digit#9 = utoa10w::digit#1
Coalesced (already) [102] utoa10w::dst#12 = utoa10w::dst#11
Coalesced [112] utoa16n::return#10 = utoa16n::started#7
Coalesced down to 10 phi equivalence classes
Culled Empty Block label main::@6
Culled Empty Block label main::@1
Culled Empty Block label main::@12
Culled Empty Block label cls::@2
Culled Empty Block label utoa10w::@9
Culled Empty Block label utoa10w::@11
Culled Empty Block label utoa10w::@10
Culled Empty Block label utoa16n::@3
Culled Empty Block label utoa16n::@2
Renumbering block main::@2 to main::@1
Renumbering block main::@3 to main::@2
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block main::@7 to main::@5
Renumbering block main::@8 to main::@6
Renumbering block main::@9 to main::@7
Renumbering block main::@10 to main::@8
Renumbering block main::@11 to main::@9
Renumbering block utoa16n::@4 to utoa16n::@2
Renumbering block utoa16n::@5 to utoa16n::@3
Adding NOP phi() at start of cls
Adding NOP phi() at start of utoa10w
Adding NOP phi() at start of utoa16n::@3

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  asm { sei  }
  [1] call cls 
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@3
  [2] main::$1 = *control & $80
  [3] main::$2 = *raster >> 1
  [4] main::rst#0 = main::$1 | main::$2
  [5] if(main::rst#0!=$30) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [6] *BORDER_COLOR = 1
  [7] main::time_start#0 = *raster
  [8] utoa16w::dst = (byte*) 1024
  [9] call utoa16w 
  to:main::@5
main::@5: scope:[main]  from main::@2
  [10] *BORDER_COLOR = ++ *BORDER_COLOR
  [11] utoa16w::dst = (byte*) 1024+$28
  [12] call utoa16w 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [13] *BORDER_COLOR = ++ *BORDER_COLOR
  [14] utoa16w::dst = (byte*) 1024+$28+$28
  [15] call utoa16w 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [16] *BORDER_COLOR = ++ *BORDER_COLOR
  [17] utoa16w::dst = (byte*) 1024+$28+$28+$28
  [18] call utoa16w 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [19] *BORDER_COLOR = ++ *BORDER_COLOR
  [20] utoa16w::dst = (byte*) 1024+$28+$28+$28+$28
  [21] call utoa16w 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [22] main::time_end#0 = *raster
  [23] *BORDER_COLOR = 0
  [24] main::time#0 = main::time_end#0 - main::time_start#0
  [25] utoa10w::value#0 = (word)main::time#0
  [26] call utoa10w 
  to:main::@3
main::@3: scope:[main]  from main::@4 main::@9
  [27] main::i#2 = phi( main::@9/0, main::@4/main::i#1 )
  [28] if(main::msg[main::i#2]!=0) goto main::@4
  to:main::@1
main::@4: scope:[main]  from main::@3
  [29] ((byte*) 1024+$28+$28+$28+$28+$50+3)[main::i#2] = main::msg[main::i#2]
  [30] main::i#1 = ++ main::i#2
  to:main::@3

void cls()
cls: scope:[cls]  from main
  [31] phi()
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  [32] cls::sc#2 = phi( cls/cls::screen, cls::@1/cls::sc#1 )
  [33] *cls::sc#2 = ' '
  [34] cls::sc#1 = ++ cls::sc#2
  [35] if(cls::sc#1!=cls::screen+$3e7+1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  [36] return 
  to:@return

void utoa16w(word utoa16w::value , byte* volatile utoa16w::dst)
utoa16w: scope:[utoa16w]  from main::@2 main::@5 main::@6 main::@7 main::@8
  [37] utoa16w::value#5 = phi( main::@8/$e608, main::@2/0, main::@5/$4d2, main::@6/$162e, main::@7/$270f )
  [38] utoa16w::$0 = > utoa16w::value#5
  [39] utoa16n::nybble#0 = utoa16w::$0 >> 4
  [40] call utoa16n 
  [41] utoa16n::return#0 = utoa16n::return#4
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  [42] utoa16w::started#1 = utoa16n::return#0
  [43] utoa16w::$3 = > utoa16w::value#5
  [44] utoa16n::nybble#1 = utoa16w::$3 & $f
  [45] utoa16n::started#1 = utoa16w::started#1
  [46] call utoa16n 
  [47] utoa16n::return#1 = utoa16n::return#4
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  [48] utoa16w::started#2 = utoa16n::return#1
  [49] utoa16w::$6 = < utoa16w::value#5
  [50] utoa16n::nybble#2 = utoa16w::$6 >> 4
  [51] utoa16n::started#2 = utoa16w::started#2
  [52] call utoa16n 
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  [53] utoa16w::$9 = < utoa16w::value#5
  [54] utoa16n::nybble#3 = utoa16w::$9 & $f
  [55] call utoa16n 
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  [56] *utoa16w::dst = 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  [57] return 
  to:@return

void utoa10w(word utoa10w::value , byte* utoa10w::dst)
utoa10w: scope:[utoa10w]  from main::@9
  [58] phi()
  to:utoa10w::@1
utoa10w::@1: scope:[utoa10w]  from utoa10w utoa10w::@2 utoa10w::@6
  [59] utoa10w::dst#11 = phi( utoa10w/(byte*) 1024+$28+$28+$28+$28+$50, utoa10w::@2/utoa10w::dst#11, utoa10w::@6/utoa10w::dst#4 )
  [59] utoa10w::bStarted#2 = phi( utoa10w/0, utoa10w::@2/1, utoa10w::@6/utoa10w::bStarted#2 )
  [59] utoa10w::digit#3 = phi( utoa10w/0, utoa10w::@2/utoa10w::digit#1, utoa10w::@6/utoa10w::digit#7 )
  [59] utoa10w::value#10 = phi( utoa10w/utoa10w::value#0, utoa10w::@2/utoa10w::value#1, utoa10w::@6/utoa10w::value#10 )
  [59] utoa10w::i#2 = phi( utoa10w/0, utoa10w::@2/utoa10w::i#2, utoa10w::@6/utoa10w::i#1 )
  [60] utoa10w::$8 = utoa10w::i#2 << 1
  [61] if(utoa10w::value#10>=UTOA10_SUB[utoa10w::$8]) goto utoa10w::@2
  to:utoa10w::@3
utoa10w::@3: scope:[utoa10w]  from utoa10w::@1
  [62] utoa10w::$1 = utoa10w::i#2 & 1
  [63] if(utoa10w::$1==0) goto utoa10w::@6
  to:utoa10w::@4
utoa10w::@4: scope:[utoa10w]  from utoa10w::@3
  [64] if(utoa10w::bStarted#2==0) goto utoa10w::@7
  to:utoa10w::@5
utoa10w::@5: scope:[utoa10w]  from utoa10w::@4
  [65] *utoa10w::dst#11 = DIGITS[utoa10w::digit#3]
  [66] utoa10w::dst#1 = ++ utoa10w::dst#11
  to:utoa10w::@7
utoa10w::@7: scope:[utoa10w]  from utoa10w::@4 utoa10w::@5
  [67] utoa10w::dst#8 = phi( utoa10w::@4/utoa10w::dst#11, utoa10w::@5/utoa10w::dst#1 )
  to:utoa10w::@6
utoa10w::@6: scope:[utoa10w]  from utoa10w::@3 utoa10w::@7
  [68] utoa10w::digit#7 = phi( utoa10w::@3/utoa10w::digit#3, utoa10w::@7/0 )
  [68] utoa10w::dst#4 = phi( utoa10w::@3/utoa10w::dst#11, utoa10w::@7/utoa10w::dst#8 )
  [69] utoa10w::i#1 = ++ utoa10w::i#2
  [70] if(utoa10w::i#1!=8) goto utoa10w::@1
  to:utoa10w::@8
utoa10w::@8: scope:[utoa10w]  from utoa10w::@6
  [71] utoa10w::$9 = (byte)utoa10w::value#10
  [72] *utoa10w::dst#4 = DIGITS[utoa10w::$9]
  [73] utoa10w::dst#2 = ++ utoa10w::dst#4
  [74] *utoa10w::dst#2 = 0
  to:utoa10w::@return
utoa10w::@return: scope:[utoa10w]  from utoa10w::@8
  [75] return 
  to:@return
utoa10w::@2: scope:[utoa10w]  from utoa10w::@1
  [76] utoa10w::digit#1 = utoa10w::digit#3 + UTOA10_VAL[utoa10w::i#2]
  [77] utoa10w::value#1 = utoa10w::value#10 - UTOA10_SUB[utoa10w::$8]
  to:utoa10w::@1

byte utoa16n(byte utoa16n::nybble , word** utoa16n::dst , byte utoa16n::started)
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  [78] utoa16n::started#7 = phi( utoa16w/0, utoa16w::@1/utoa16n::started#1, utoa16w::@2/utoa16n::started#2, utoa16w::@3/1 )
  [78] utoa16n::nybble#4 = phi( utoa16w/utoa16n::nybble#0, utoa16w::@1/utoa16n::nybble#1, utoa16w::@2/utoa16n::nybble#2, utoa16w::@3/utoa16n::nybble#3 )
  [79] if(utoa16n::nybble#4==0) goto utoa16n::@3
  to:utoa16n::@1
utoa16n::@3: scope:[utoa16n]  from utoa16n
  [80] phi()
  to:utoa16n::@1
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  [81] utoa16n::return#4 = phi( utoa16n::@3/utoa16n::started#7, utoa16n/1 )
  [82] if(utoa16n::return#4==0) goto utoa16n::@return
  to:utoa16n::@2
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1
  [83] *(*(&utoa16w::dst)) = DIGITS[utoa16n::nybble#4]
  [84] *(&utoa16w::dst) = ++ *(&utoa16w::dst)
  to:utoa16n::@return
utoa16n::@return: scope:[utoa16n]  from utoa16n::@1 utoa16n::@2
  [85] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void cls()
byte* cls::sc
byte* cls::sc#1 151.5
byte* cls::sc#2 151.5
void main()
byte~ main::$1 101.0
byte~ main::$2 202.0
byte main::i
byte main::i#1 202.0
byte main::i#2 168.33333333333331
byte main::rst
byte main::rst#0 202.0
byte* main::screen
byte main::time
byte main::time#0 11.0
byte main::time_end
byte main::time_end#0 11.0
byte main::time_start
byte main::time_start#0 1.2941176470588236
void utoa10w(word utoa10w::value , byte* utoa10w::dst)
byte~ utoa10w::$1 20002.0
byte~ utoa10w::$8 10001.0
byte~ utoa10w::$9 202.0
byte utoa10w::bStarted
byte utoa10w::bStarted#2 2500.25
byte utoa10w::digit
byte utoa10w::digit#1 10001.0
byte utoa10w::digit#3 8334.166666666666
byte utoa10w::digit#7 6667.333333333333
byte* utoa10w::dst
byte* utoa10w::dst#1 20002.0
byte* utoa10w::dst#11 7778.555555555557
byte* utoa10w::dst#2 202.0
byte* utoa10w::dst#4 6041.0
byte* utoa10w::dst#8 30003.0
byte utoa10w::i
byte utoa10w::i#1 15001.5
byte utoa10w::i#2 5833.916666666667
word utoa10w::value
word utoa10w::value#0 56.0
word utoa10w::value#1 20002.0
word utoa10w::value#10 3854.3076923076924
byte utoa16n(byte utoa16n::nybble , word** utoa16n::dst , byte utoa16n::started)
word** utoa16n::dst
byte utoa16n::nybble
byte utoa16n::nybble#0 202.0
byte utoa16n::nybble#1 101.0
byte utoa16n::nybble#2 101.0
byte utoa16n::nybble#3 202.0
byte utoa16n::nybble#4 481.2
byte utoa16n::return
byte utoa16n::return#0 202.0
byte utoa16n::return#1 202.0
byte utoa16n::return#4 314.8571428571429
byte utoa16n::started
byte utoa16n::started#1 202.0
byte utoa16n::started#2 202.0
byte utoa16n::started#7 401.0
void utoa16w(word utoa16w::value , byte* volatile utoa16w::dst)
byte~ utoa16w::$0 202.0
byte~ utoa16w::$3 202.0
byte~ utoa16w::$6 202.0
byte~ utoa16w::$9 202.0
byte* volatile utoa16w::dst loadstore 4.875
byte utoa16w::started
byte utoa16w::started#1 67.33333333333333
byte utoa16w::started#2 67.33333333333333
word utoa16w::value
word utoa16w::value#5 25.25

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ cls::sc#2 cls::sc#1 ]
[ utoa16w::value#5 ]
[ utoa10w::i#2 utoa10w::i#1 ]
[ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
[ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ]
[ utoa10w::bStarted#2 ]
[ utoa10w::dst#8 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ]
[ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
[ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Added variable main::$1 to live range equivalence class [ main::$1 ]
Added variable main::$2 to live range equivalence class [ main::$2 ]
Added variable main::rst#0 to live range equivalence class [ main::rst#0 ]
Added variable main::time_start#0 to live range equivalence class [ main::time_start#0 ]
Added variable utoa16w::dst to live range equivalence class [ utoa16w::dst ]
Added variable main::time_end#0 to live range equivalence class [ main::time_end#0 ]
Added variable main::time#0 to live range equivalence class [ main::time#0 ]
Added variable utoa16w::$0 to live range equivalence class [ utoa16w::$0 ]
Added variable utoa16n::return#0 to live range equivalence class [ utoa16n::return#0 ]
Added variable utoa16w::started#1 to live range equivalence class [ utoa16w::started#1 ]
Added variable utoa16w::$3 to live range equivalence class [ utoa16w::$3 ]
Added variable utoa16n::return#1 to live range equivalence class [ utoa16n::return#1 ]
Added variable utoa16w::started#2 to live range equivalence class [ utoa16w::started#2 ]
Added variable utoa16w::$6 to live range equivalence class [ utoa16w::$6 ]
Added variable utoa16w::$9 to live range equivalence class [ utoa16w::$9 ]
Added variable utoa10w::$8 to live range equivalence class [ utoa10w::$8 ]
Added variable utoa10w::$1 to live range equivalence class [ utoa10w::$1 ]
Added variable utoa10w::$9 to live range equivalence class [ utoa10w::$9 ]
Added variable utoa10w::dst#2 to live range equivalence class [ utoa10w::dst#2 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ cls::sc#2 cls::sc#1 ]
[ utoa16w::value#5 ]
[ utoa10w::i#2 utoa10w::i#1 ]
[ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
[ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ]
[ utoa10w::bStarted#2 ]
[ utoa10w::dst#8 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ]
[ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
[ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
[ main::$1 ]
[ main::$2 ]
[ main::rst#0 ]
[ main::time_start#0 ]
[ utoa16w::dst ]
[ main::time_end#0 ]
[ main::time#0 ]
[ utoa16w::$0 ]
[ utoa16n::return#0 ]
[ utoa16w::started#1 ]
[ utoa16w::$3 ]
[ utoa16n::return#1 ]
[ utoa16w::started#2 ]
[ utoa16w::$6 ]
[ utoa16w::$9 ]
[ utoa10w::$8 ]
[ utoa10w::$1 ]
[ utoa10w::$9 ]
[ utoa10w::dst#2 ]
Allocated zp[1]:2 [ main::i#2 main::i#1 ]
Allocated zp[2]:3 [ cls::sc#2 cls::sc#1 ]
Allocated zp[2]:5 [ utoa16w::value#5 ]
Allocated zp[1]:7 [ utoa10w::i#2 utoa10w::i#1 ]
Allocated zp[2]:8 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
Allocated zp[1]:10 [ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ]
Allocated zp[1]:11 [ utoa10w::bStarted#2 ]
Allocated zp[2]:12 [ utoa10w::dst#8 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ]
Allocated zp[1]:14 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
Allocated zp[1]:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Allocated zp[1]:16 [ main::$1 ]
Allocated zp[1]:17 [ main::$2 ]
Allocated zp[1]:18 [ main::rst#0 ]
Allocated zp[1]:19 [ main::time_start#0 ]
Allocated zp[2]:20 [ utoa16w::dst ]
Allocated zp[1]:22 [ main::time_end#0 ]
Allocated zp[1]:23 [ main::time#0 ]
Allocated zp[1]:24 [ utoa16w::$0 ]
Allocated zp[1]:25 [ utoa16n::return#0 ]
Allocated zp[1]:26 [ utoa16w::started#1 ]
Allocated zp[1]:27 [ utoa16w::$3 ]
Allocated zp[1]:28 [ utoa16n::return#1 ]
Allocated zp[1]:29 [ utoa16w::started#2 ]
Allocated zp[1]:30 [ utoa16w::$6 ]
Allocated zp[1]:31 [ utoa16w::$9 ]
Allocated zp[1]:32 [ utoa10w::$8 ]
Allocated zp[1]:33 [ utoa10w::$1 ]
Allocated zp[1]:34 [ utoa10w::$9 ]
Allocated zp[2]:35 [ utoa10w::dst#2 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] main::$1 = *control & $80 [ main::$1 ] (  [ main::$1 ] { }  ) always clobbers reg byte a 
Statement [3] main::$2 = *raster >> 1 [ main::$1 main::$2 ] (  [ main::$1 main::$2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:16 [ main::$1 ]
Statement [6] *BORDER_COLOR = 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] utoa16w::dst = (byte*) 1024 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:19 [ main::time_start#0 ]
Statement [11] utoa16w::dst = (byte*) 1024+$28 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [14] utoa16w::dst = (byte*) 1024+$28+$28 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [17] utoa16w::dst = (byte*) 1024+$28+$28+$28 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [20] utoa16w::dst = (byte*) 1024+$28+$28+$28+$28 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [23] *BORDER_COLOR = 0 [ main::time_start#0 main::time_end#0 ] (  [ main::time_start#0 main::time_end#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:22 [ main::time_end#0 ]
Statement [24] main::time#0 = main::time_end#0 - main::time_start#0 [ main::time#0 ] (  [ main::time#0 ] { }  ) always clobbers reg byte a 
Statement [25] utoa10w::value#0 = (word)main::time#0 [ utoa10w::value#0 ] (  [ utoa10w::value#0 ] { }  ) always clobbers reg byte a 
Statement [28] if(main::msg[main::i#2]!=0) goto main::@4 [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::i#2 main::i#1 ]
Statement [29] ((byte*) 1024+$28+$28+$28+$28+$50+3)[main::i#2] = main::msg[main::i#2] [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [33] *cls::sc#2 = ' ' [ cls::sc#2 ] ( cls:1 [ cls::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [35] if(cls::sc#1!=cls::screen+$3e7+1) goto cls::@1 [ cls::sc#1 ] ( cls:1 [ cls::sc#1 ] { }  ) always clobbers reg byte a 
Statement [39] utoa16n::nybble#0 = utoa16w::$0 >> 4 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] ( utoa16w:9 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:12 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:15 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:18 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:21 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  ) always clobbers reg byte a 
Statement [50] utoa16n::nybble#2 = utoa16w::$6 >> 4 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] ( utoa16w:9 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:12 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:15 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:18 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:21 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:29 [ utoa16w::started#2 ]
Statement [56] *utoa16w::dst = 0 [ ] ( utoa16w:9 [ main::time_start#0 ] { }  utoa16w:12 [ main::time_start#0 ] { }  utoa16w:15 [ main::time_start#0 ] { }  utoa16w:18 [ main::time_start#0 ] { }  utoa16w:21 [ main::time_start#0 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:19 [ main::time_start#0 ]
Statement [60] utoa10w::$8 = utoa10w::i#2 << 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:7 [ utoa10w::i#2 utoa10w::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:10 [ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ]
Removing always clobbered register reg byte a as potential for zp[1]:11 [ utoa10w::bStarted#2 ]
Statement [61] if(utoa10w::value#10>=UTOA10_SUB[utoa10w::$8]) goto utoa10w::@2 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:32 [ utoa10w::$8 ]
Statement [62] utoa10w::$1 = utoa10w::i#2 & 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$1 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$1 ] { }  ) always clobbers reg byte a 
Statement [65] *utoa10w::dst#11 = DIGITS[utoa10w::digit#3] [ utoa10w::i#2 utoa10w::value#10 utoa10w::bStarted#2 utoa10w::dst#11 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::bStarted#2 utoa10w::dst#11 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:7 [ utoa10w::i#2 utoa10w::i#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:11 [ utoa10w::bStarted#2 ]
Statement [71] utoa10w::$9 = (byte)utoa10w::value#10 [ utoa10w::dst#4 utoa10w::$9 ] ( utoa10w:26 [ utoa10w::dst#4 utoa10w::$9 ] { }  ) always clobbers reg byte a 
Statement [72] *utoa10w::dst#4 = DIGITS[utoa10w::$9] [ utoa10w::dst#4 ] ( utoa10w:26 [ utoa10w::dst#4 ] { }  ) always clobbers reg byte a reg byte y 
Statement [73] utoa10w::dst#2 = ++ utoa10w::dst#4 [ utoa10w::dst#2 ] ( utoa10w:26 [ utoa10w::dst#2 ] { }  ) always clobbers reg byte a 
Statement [74] *utoa10w::dst#2 = 0 [ ] ( utoa10w:26 [ ] { }  ) always clobbers reg byte a reg byte y 
Statement [76] utoa10w::digit#1 = utoa10w::digit#3 + UTOA10_VAL[utoa10w::i#2] [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 utoa10w::$8 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 utoa10w::$8 ] { }  ) always clobbers reg byte a 
Statement [77] utoa10w::value#1 = utoa10w::value#10 - UTOA10_SUB[utoa10w::$8] [ utoa10w::i#2 utoa10w::dst#11 utoa10w::value#1 utoa10w::digit#1 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::dst#11 utoa10w::value#1 utoa10w::digit#1 ] { }  ) always clobbers reg byte a 
Statement [83] *(*(&utoa16w::dst)) = DIGITS[utoa16n::nybble#4] [ utoa16w::dst utoa16n::return#4 ] ( utoa16w:9::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:12::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:15::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:18::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:21::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:9::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:12::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:15::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:18::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:21::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:9::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:12::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:15::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:18::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:21::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:9::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:12::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:15::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:18::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:21::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Removing always clobbered register reg byte y as potential for zp[1]:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Statement [2] main::$1 = *control & $80 [ main::$1 ] (  [ main::$1 ] { }  ) always clobbers reg byte a 
Statement [3] main::$2 = *raster >> 1 [ main::$1 main::$2 ] (  [ main::$1 main::$2 ] { }  ) always clobbers reg byte a 
Statement [6] *BORDER_COLOR = 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] utoa16w::dst = (byte*) 1024 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [11] utoa16w::dst = (byte*) 1024+$28 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [14] utoa16w::dst = (byte*) 1024+$28+$28 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [17] utoa16w::dst = (byte*) 1024+$28+$28+$28 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [20] utoa16w::dst = (byte*) 1024+$28+$28+$28+$28 [ main::time_start#0 utoa16w::dst ] (  [ main::time_start#0 utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [23] *BORDER_COLOR = 0 [ main::time_start#0 main::time_end#0 ] (  [ main::time_start#0 main::time_end#0 ] { }  ) always clobbers reg byte a 
Statement [24] main::time#0 = main::time_end#0 - main::time_start#0 [ main::time#0 ] (  [ main::time#0 ] { }  ) always clobbers reg byte a 
Statement [25] utoa10w::value#0 = (word)main::time#0 [ utoa10w::value#0 ] (  [ utoa10w::value#0 ] { }  ) always clobbers reg byte a 
Statement [28] if(main::msg[main::i#2]!=0) goto main::@4 [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [29] ((byte*) 1024+$28+$28+$28+$28+$50+3)[main::i#2] = main::msg[main::i#2] [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [33] *cls::sc#2 = ' ' [ cls::sc#2 ] ( cls:1 [ cls::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [35] if(cls::sc#1!=cls::screen+$3e7+1) goto cls::@1 [ cls::sc#1 ] ( cls:1 [ cls::sc#1 ] { }  ) always clobbers reg byte a 
Statement [39] utoa16n::nybble#0 = utoa16w::$0 >> 4 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] ( utoa16w:9 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:12 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:15 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:18 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:21 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  ) always clobbers reg byte a 
Statement [50] utoa16n::nybble#2 = utoa16w::$6 >> 4 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] ( utoa16w:9 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:12 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:15 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:18 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:21 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  ) always clobbers reg byte a 
Statement [56] *utoa16w::dst = 0 [ ] ( utoa16w:9 [ main::time_start#0 ] { }  utoa16w:12 [ main::time_start#0 ] { }  utoa16w:15 [ main::time_start#0 ] { }  utoa16w:18 [ main::time_start#0 ] { }  utoa16w:21 [ main::time_start#0 ] { }  ) always clobbers reg byte a reg byte y 
Statement [60] utoa10w::$8 = utoa10w::i#2 << 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] { }  ) always clobbers reg byte a 
Statement [61] if(utoa10w::value#10>=UTOA10_SUB[utoa10w::$8]) goto utoa10w::@2 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] { }  ) always clobbers reg byte a 
Statement [62] utoa10w::$1 = utoa10w::i#2 & 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$1 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$1 ] { }  ) always clobbers reg byte a 
Statement [65] *utoa10w::dst#11 = DIGITS[utoa10w::digit#3] [ utoa10w::i#2 utoa10w::value#10 utoa10w::bStarted#2 utoa10w::dst#11 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::bStarted#2 utoa10w::dst#11 ] { }  ) always clobbers reg byte a reg byte y 
Statement [71] utoa10w::$9 = (byte)utoa10w::value#10 [ utoa10w::dst#4 utoa10w::$9 ] ( utoa10w:26 [ utoa10w::dst#4 utoa10w::$9 ] { }  ) always clobbers reg byte a 
Statement [72] *utoa10w::dst#4 = DIGITS[utoa10w::$9] [ utoa10w::dst#4 ] ( utoa10w:26 [ utoa10w::dst#4 ] { }  ) always clobbers reg byte a reg byte y 
Statement [73] utoa10w::dst#2 = ++ utoa10w::dst#4 [ utoa10w::dst#2 ] ( utoa10w:26 [ utoa10w::dst#2 ] { }  ) always clobbers reg byte a 
Statement [74] *utoa10w::dst#2 = 0 [ ] ( utoa10w:26 [ ] { }  ) always clobbers reg byte a reg byte y 
Statement [76] utoa10w::digit#1 = utoa10w::digit#3 + UTOA10_VAL[utoa10w::i#2] [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 utoa10w::$8 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 utoa10w::$8 ] { }  ) always clobbers reg byte a 
Statement [77] utoa10w::value#1 = utoa10w::value#10 - UTOA10_SUB[utoa10w::$8] [ utoa10w::i#2 utoa10w::dst#11 utoa10w::value#1 utoa10w::digit#1 ] ( utoa10w:26 [ utoa10w::i#2 utoa10w::dst#11 utoa10w::value#1 utoa10w::digit#1 ] { }  ) always clobbers reg byte a 
Statement [83] *(*(&utoa16w::dst)) = DIGITS[utoa16n::nybble#4] [ utoa16w::dst utoa16n::return#4 ] ( utoa16w:9::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:12::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:15::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:18::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:21::utoa16n:40 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:9::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:12::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:15::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:18::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:21::utoa16n:46 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:9::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:12::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:15::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:18::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:21::utoa16n:52 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:9::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:12::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:15::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:18::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:21::utoa16n:55 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  ) always clobbers reg byte a reg byte y 
Potential registers zp[1]:2 [ main::i#2 main::i#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[2]:3 [ cls::sc#2 cls::sc#1 ] : zp[2]:3 , 
Potential registers zp[2]:5 [ utoa16w::value#5 ] : zp[2]:5 , 
Potential registers zp[1]:7 [ utoa10w::i#2 utoa10w::i#1 ] : zp[1]:7 , reg byte x , 
Potential registers zp[2]:8 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] : zp[2]:8 , 
Potential registers zp[1]:10 [ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ utoa10w::bStarted#2 ] : zp[1]:11 , reg byte x , 
Potential registers zp[2]:12 [ utoa10w::dst#8 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] : zp[2]:12 , 
Potential registers zp[1]:14 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] : zp[1]:15 , reg byte x , 
Potential registers zp[1]:16 [ main::$1 ] : zp[1]:16 , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ main::$2 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:18 [ main::rst#0 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:19 [ main::time_start#0 ] : zp[1]:19 , reg byte x , 
Potential registers zp[2]:20 [ utoa16w::dst ] : zp[2]:20 , 
Potential registers zp[1]:22 [ main::time_end#0 ] : zp[1]:22 , reg byte x , reg byte y , 
Potential registers zp[1]:23 [ main::time#0 ] : zp[1]:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:24 [ utoa16w::$0 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:25 [ utoa16n::return#0 ] : zp[1]:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:26 [ utoa16w::started#1 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:27 [ utoa16w::$3 ] : zp[1]:27 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:28 [ utoa16n::return#1 ] : zp[1]:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:29 [ utoa16w::started#2 ] : zp[1]:29 , reg byte x , reg byte y , 
Potential registers zp[1]:30 [ utoa16w::$6 ] : zp[1]:30 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:31 [ utoa16w::$9 ] : zp[1]:31 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:32 [ utoa10w::$8 ] : zp[1]:32 , reg byte x , reg byte y , 
Potential registers zp[1]:33 [ utoa10w::$1 ] : zp[1]:33 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:34 [ utoa10w::$9 ] : zp[1]:34 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:35 [ utoa10w::dst#2 ] : zp[2]:35 , 

REGISTER UPLIFT SCOPES
Uplift Scope [utoa10w] 63,824.56: zp[2]:12 [ utoa10w::dst#8 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] 25,002.5: zp[1]:10 [ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ] 23,912.31: zp[2]:8 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] 20,835.42: zp[1]:7 [ utoa10w::i#2 utoa10w::i#1 ] 20,002: zp[1]:33 [ utoa10w::$1 ] 10,001: zp[1]:32 [ utoa10w::$8 ] 2,500.25: zp[1]:11 [ utoa10w::bStarted#2 ] 202: zp[1]:34 [ utoa10w::$9 ] 202: zp[2]:35 [ utoa10w::dst#2 ] 
Uplift Scope [utoa16n] 1,119.86: zp[1]:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] 1,087.2: zp[1]:14 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] 202: zp[1]:25 [ utoa16n::return#0 ] 202: zp[1]:28 [ utoa16n::return#1 ] 
Uplift Scope [utoa16w] 202: zp[1]:24 [ utoa16w::$0 ] 202: zp[1]:27 [ utoa16w::$3 ] 202: zp[1]:30 [ utoa16w::$6 ] 202: zp[1]:31 [ utoa16w::$9 ] 67.33: zp[1]:26 [ utoa16w::started#1 ] 67.33: zp[1]:29 [ utoa16w::started#2 ] 25.25: zp[2]:5 [ utoa16w::value#5 ] 4.88: zp[2]:20 [ utoa16w::dst ] 
Uplift Scope [main] 370.33: zp[1]:2 [ main::i#2 main::i#1 ] 202: zp[1]:17 [ main::$2 ] 202: zp[1]:18 [ main::rst#0 ] 101: zp[1]:16 [ main::$1 ] 11: zp[1]:22 [ main::time_end#0 ] 11: zp[1]:23 [ main::time#0 ] 1.29: zp[1]:19 [ main::time_start#0 ] 
Uplift Scope [cls] 303: zp[2]:3 [ cls::sc#2 cls::sc#1 ] 
Uplift Scope [] 

Uplifting [utoa10w] best 27755 combination zp[2]:12 [ utoa10w::dst#8 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] zp[1]:10 [ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ] zp[2]:8 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] reg byte x [ utoa10w::i#2 utoa10w::i#1 ] reg byte a [ utoa10w::$1 ] reg byte y [ utoa10w::$8 ] zp[1]:11 [ utoa10w::bStarted#2 ] zp[1]:34 [ utoa10w::$9 ] zp[2]:35 [ utoa10w::dst#2 ] 
Limited combination testing to 100 combinations of 576 possible.
Uplifting [utoa16n] best 27707 combination reg byte x [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] reg byte a [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] reg byte x [ utoa16n::return#0 ] reg byte x [ utoa16n::return#1 ] 
Limited combination testing to 100 combinations of 128 possible.
Uplifting [utoa16w] best 27683 combination reg byte a [ utoa16w::$0 ] reg byte a [ utoa16w::$3 ] reg byte a [ utoa16w::$6 ] reg byte a [ utoa16w::$9 ] zp[1]:26 [ utoa16w::started#1 ] zp[1]:29 [ utoa16w::started#2 ] zp[2]:5 [ utoa16w::value#5 ] zp[2]:20 [ utoa16w::dst ] 
Limited combination testing to 100 combinations of 3072 possible.
Uplifting [main] best 25283 combination reg byte x [ main::i#2 main::i#1 ] reg byte a [ main::$2 ] reg byte a [ main::rst#0 ] zp[1]:16 [ main::$1 ] zp[1]:22 [ main::time_end#0 ] zp[1]:23 [ main::time#0 ] zp[1]:19 [ main::time_start#0 ] 
Limited combination testing to 100 combinations of 3456 possible.
Uplifting [cls] best 25283 combination zp[2]:3 [ cls::sc#2 cls::sc#1 ] 
Uplifting [] best 25283 combination 
Attempting to uplift remaining variables inzp[1]:10 [ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ]
Uplifting [utoa10w] best 25283 combination zp[1]:10 [ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ] 
Attempting to uplift remaining variables inzp[1]:11 [ utoa10w::bStarted#2 ]
Uplifting [utoa10w] best 25283 combination zp[1]:11 [ utoa10w::bStarted#2 ] 
Attempting to uplift remaining variables inzp[1]:34 [ utoa10w::$9 ]
Uplifting [utoa10w] best 25279 combination reg byte a [ utoa10w::$9 ] 
Attempting to uplift remaining variables inzp[1]:16 [ main::$1 ]
Uplifting [main] best 25279 combination zp[1]:16 [ main::$1 ] 
Attempting to uplift remaining variables inzp[1]:26 [ utoa16w::started#1 ]
Uplifting [utoa16w] best 25273 combination reg byte x [ utoa16w::started#1 ] 
Attempting to uplift remaining variables inzp[1]:29 [ utoa16w::started#2 ]
Uplifting [utoa16w] best 25267 combination reg byte x [ utoa16w::started#2 ] 
Attempting to uplift remaining variables inzp[1]:22 [ main::time_end#0 ]
Uplifting [main] best 25227 combination reg byte x [ main::time_end#0 ] 
Attempting to uplift remaining variables inzp[1]:23 [ main::time#0 ]
Uplifting [main] best 25167 combination reg byte a [ main::time#0 ] 
Attempting to uplift remaining variables inzp[1]:19 [ main::time_start#0 ]
Uplifting [main] best 25167 combination zp[1]:19 [ main::time_start#0 ] 
Coalescing zero page register [ zp[2]:12 [ utoa10w::dst#8 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] ] with [ zp[2]:35 [ utoa10w::dst#2 ] ] - score: 1
Coalescing zero page register [ zp[2]:5 [ utoa16w::value#5 ] ] with [ zp[2]:3 [ cls::sc#2 cls::sc#1 ] ]
Coalescing zero page register [ zp[1]:16 [ main::$1 ] ] with [ zp[1]:10 [ utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ] ]
Coalescing zero page register [ zp[1]:19 [ main::time_start#0 ] ] with [ zp[1]:11 [ utoa10w::bStarted#2 ] ]
Coalescing zero page register [ zp[2]:8 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] ] with [ zp[2]:5 [ utoa16w::value#5 cls::sc#2 cls::sc#1 ] ]
Allocated (was zp[2]:8) zp[2]:2 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 utoa16w::value#5 cls::sc#2 cls::sc#1 ]
Allocated (was zp[2]:12) zp[2]:4 [ utoa10w::dst#8 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 utoa10w::dst#2 ]
Allocated (was zp[1]:16) zp[1]:6 [ main::$1 utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ]
Allocated (was zp[1]:19) zp[1]:7 [ main::time_start#0 utoa10w::bStarted#2 ]
Allocated (was zp[2]:20) zp[2]:8 [ utoa16w::dst ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Testing hex to decimal conversion
  // Upstart
  // Commodore 64 PRG executable file
.file [name="hex2dec.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label control = $d011
  .label raster = $d012
  .label BORDER_COLOR = $d020
.segment Code
  // main
main: {
    .label __1 = 6
    .label time_start = 7
    // asm { sei  }
    sei
    // [1] call cls 
    // [31] phi from main to cls [phi:main->cls]
  cls_from_main:
    jsr cls
    jmp __b1
    // main::@1
  __b1:
    // [2] main::$1 = *control & $80 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #$80
    and control
    sta.z __1
    // [3] main::$2 = *raster >> 1 -- vbuaa=_deref_pbuc1_ror_1 
    lda raster
    lsr
    // [4] main::rst#0 = main::$1 | main::$2 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // [5] if(main::rst#0!=$30) goto main::@1 -- vbuaa_neq_vbuc1_then_la1 
    cmp #$30
    bne __b1
    jmp __b2
    // main::@2
  __b2:
    // [6] *BORDER_COLOR = 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta BORDER_COLOR
    // [7] main::time_start#0 = *raster -- vbuz1=_deref_pbuc1 
    lda raster
    sta.z time_start
    // [8] utoa16w::dst = (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z utoa16w.dst
    lda #>$400
    sta.z utoa16w.dst+1
    // [9] call utoa16w 
    // [37] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
  utoa16w_from___b2:
    // [37] phi utoa16w::value#5 = 0 [phi:main::@2->utoa16w#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z utoa16w.value
    lda #>0
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b5
    // main::@5
  __b5:
    // [10] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // [11] utoa16w::dst = (byte*) 1024+$28 -- pbuz1=pbuc1 
    lda #<$400+$28
    sta.z utoa16w.dst
    lda #>$400+$28
    sta.z utoa16w.dst+1
    // [12] call utoa16w 
    // [37] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
  utoa16w_from___b5:
    // [37] phi utoa16w::value#5 = $4d2 [phi:main::@5->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z utoa16w.value
    lda #>$4d2
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b6
    // main::@6
  __b6:
    // [13] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // [14] utoa16w::dst = (byte*) 1024+$28+$28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28
    sta.z utoa16w.dst+1
    // [15] call utoa16w 
    // [37] phi from main::@6 to utoa16w [phi:main::@6->utoa16w]
  utoa16w_from___b6:
    // [37] phi utoa16w::value#5 = $162e [phi:main::@6->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$162e
    sta.z utoa16w.value
    lda #>$162e
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b7
    // main::@7
  __b7:
    // [16] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // [17] utoa16w::dst = (byte*) 1024+$28+$28+$28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28
    sta.z utoa16w.dst+1
    // [18] call utoa16w 
    // [37] phi from main::@7 to utoa16w [phi:main::@7->utoa16w]
  utoa16w_from___b7:
    // [37] phi utoa16w::value#5 = $270f [phi:main::@7->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$270f
    sta.z utoa16w.value
    lda #>$270f
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b8
    // main::@8
  __b8:
    // [19] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // [20] utoa16w::dst = (byte*) 1024+$28+$28+$28+$28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta.z utoa16w.dst+1
    // [21] call utoa16w 
    // [37] phi from main::@8 to utoa16w [phi:main::@8->utoa16w]
  utoa16w_from___b8:
    // [37] phi utoa16w::value#5 = $e608 [phi:main::@8->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$e608
    sta.z utoa16w.value
    lda #>$e608
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b9
    // main::@9
  __b9:
    // [22] main::time_end#0 = *raster -- vbuxx=_deref_pbuc1 
    ldx raster
    // [23] *BORDER_COLOR = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDER_COLOR
    // [24] main::time#0 = main::time_end#0 - main::time_start#0 -- vbuaa=vbuxx_minus_vbuz1 
    txa
    sec
    sbc.z time_start
    // [25] utoa10w::value#0 = (word)main::time#0 -- vwuz1=_word_vbuaa 
    sta.z utoa10w.value
    lda #0
    sta.z utoa10w.value+1
    // [26] call utoa10w 
    // [58] phi from main::@9 to utoa10w [phi:main::@9->utoa10w]
  utoa10w_from___b9:
    jsr utoa10w
    // [27] phi from main::@9 to main::@3 [phi:main::@9->main::@3]
  __b3_from___b9:
    // [27] phi main::i#2 = 0 [phi:main::@9->main::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b3
    // main::@3
  __b3:
    // [28] if(main::msg[main::i#2]!=0) goto main::@4 -- pbuc1_derefidx_vbuxx_neq_0_then_la1 
    lda msg,x
    cmp #0
    bne __b4
    jmp __b1
    // main::@4
  __b4:
    // [29] ((byte*) 1024+$28+$28+$28+$28+$50+3)[main::i#2] = main::msg[main::i#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda msg,x
    sta $400+$28+$28+$28+$28+$50+3,x
    // [30] main::i#1 = ++ main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [27] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [27] phi main::i#2 = main::i#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
  .segment Data
    msg: .text "raster lines"
    .byte 0
}
.segment Code
  // cls
cls: {
    .label screen = $400
    .label sc = 2
    // [32] phi from cls to cls::@1 [phi:cls->cls::@1]
  __b1_from_cls:
    // [32] phi cls::sc#2 = cls::screen [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta.z sc
    lda #>screen
    sta.z sc+1
    jmp __b1
    // [32] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
  __b1_from___b1:
    // [32] phi cls::sc#2 = cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    jmp __b1
    // cls::@1
  __b1:
    // [33] *cls::sc#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [34] cls::sc#1 = ++ cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [35] if(cls::sc#1!=cls::screen+$3e7+1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>screen+$3e7+1
    bne __b1_from___b1
    lda.z sc
    cmp #<screen+$3e7+1
    bne __b1_from___b1
    jmp __breturn
    // cls::@return
  __breturn:
    // [36] return 
    rts
}
  // utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zp(2) value, byte* zp(8) dst)
utoa16w: {
    .label dst = 8
    .label value = 2
    // [38] utoa16w::$0 = > utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // [39] utoa16n::nybble#0 = utoa16w::$0 >> 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [40] call utoa16n 
    // [78] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
  utoa16n_from_utoa16w:
    // [78] phi utoa16n::started#7 = 0 [phi:utoa16w->utoa16n#0] -- vbuxx=vbuc1 
    ldx #0
    // [78] phi utoa16n::nybble#4 = utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [41] utoa16n::return#0 = utoa16n::return#4
    jmp __b1
    // utoa16w::@1
  __b1:
    // [42] utoa16w::started#1 = utoa16n::return#0
    // [43] utoa16w::$3 = > utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // [44] utoa16n::nybble#1 = utoa16w::$3 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [45] utoa16n::started#1 = utoa16w::started#1
    // [46] call utoa16n 
    // [78] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
  utoa16n_from___b1:
    // [78] phi utoa16n::started#7 = utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
    // [78] phi utoa16n::nybble#4 = utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [47] utoa16n::return#1 = utoa16n::return#4
    jmp __b2
    // utoa16w::@2
  __b2:
    // [48] utoa16w::started#2 = utoa16n::return#1
    // [49] utoa16w::$6 = < utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // [50] utoa16n::nybble#2 = utoa16w::$6 >> 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [51] utoa16n::started#2 = utoa16w::started#2
    // [52] call utoa16n 
    // [78] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
  utoa16n_from___b2:
    // [78] phi utoa16n::started#7 = utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
    // [78] phi utoa16n::nybble#4 = utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b3
    // utoa16w::@3
  __b3:
    // [53] utoa16w::$9 = < utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // [54] utoa16n::nybble#3 = utoa16w::$9 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [55] call utoa16n 
    // [78] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
  utoa16n_from___b3:
    // [78] phi utoa16n::started#7 = 1 [phi:utoa16w::@3->utoa16n#0] -- vbuxx=vbuc1 
    ldx #1
    // [78] phi utoa16n::nybble#4 = utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b4
    // utoa16w::@4
  __b4:
    // [56] *utoa16w::dst = 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp __breturn
    // utoa16w::@return
  __breturn:
    // [57] return 
    rts
}
  // utoa10w
// Decimal utoa() without using multiply or divide
// utoa10w(word zp(2) value, byte* zp(4) dst)
utoa10w: {
    .label value = 2
    .label digit = 6
    .label dst = 4
    .label bStarted = 7
    // [59] phi from utoa10w to utoa10w::@1 [phi:utoa10w->utoa10w::@1]
  __b1_from_utoa10w:
    // [59] phi utoa10w::dst#11 = (byte*) 1024+$28+$28+$28+$28+$50 [phi:utoa10w->utoa10w::@1#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28+$50
    sta.z dst
    lda #>$400+$28+$28+$28+$28+$50
    sta.z dst+1
    // [59] phi utoa10w::bStarted#2 = 0 [phi:utoa10w->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z bStarted
    // [59] phi utoa10w::digit#3 = 0 [phi:utoa10w->utoa10w::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [59] phi utoa10w::value#10 = utoa10w::value#0 [phi:utoa10w->utoa10w::@1#3] -- register_copy 
    // [59] phi utoa10w::i#2 = 0 [phi:utoa10w->utoa10w::@1#4] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [59] phi from utoa10w::@6 to utoa10w::@1 [phi:utoa10w::@6->utoa10w::@1]
  __b1_from___b6:
    // [59] phi utoa10w::dst#11 = utoa10w::dst#4 [phi:utoa10w::@6->utoa10w::@1#0] -- register_copy 
    // [59] phi utoa10w::bStarted#2 = utoa10w::bStarted#2 [phi:utoa10w::@6->utoa10w::@1#1] -- register_copy 
    // [59] phi utoa10w::digit#3 = utoa10w::digit#7 [phi:utoa10w::@6->utoa10w::@1#2] -- register_copy 
    // [59] phi utoa10w::value#10 = utoa10w::value#10 [phi:utoa10w::@6->utoa10w::@1#3] -- register_copy 
    // [59] phi utoa10w::i#2 = utoa10w::i#1 [phi:utoa10w::@6->utoa10w::@1#4] -- register_copy 
    jmp __b1
    // utoa10w::@1
  __b1:
    // [60] utoa10w::$8 = utoa10w::i#2 << 1 -- vbuyy=vbuxx_rol_1 
    txa
    asl
    tay
    // [61] if(utoa10w::value#10>=UTOA10_SUB[utoa10w::$8]) goto utoa10w::@2 -- vwuz1_ge_pwuc1_derefidx_vbuyy_then_la1 
    lda UTOA10_SUB+1,y
    cmp.z value+1
    bne !+
    lda UTOA10_SUB,y
    cmp.z value
    beq __b2
  !:
    bcc __b2
    jmp __b3
    // utoa10w::@3
  __b3:
    // [62] utoa10w::$1 = utoa10w::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [63] if(utoa10w::$1==0) goto utoa10w::@6 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b6_from___b3
    jmp __b4
    // utoa10w::@4
  __b4:
    // [64] if(utoa10w::bStarted#2==0) goto utoa10w::@7 -- vbuz1_eq_0_then_la1 
    lda.z bStarted
    beq __b7_from___b4
    jmp __b5
    // utoa10w::@5
  __b5:
    // [65] *utoa10w::dst#11 = DIGITS[utoa10w::digit#3] -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z digit
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // [66] utoa10w::dst#1 = ++ utoa10w::dst#11 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [67] phi from utoa10w::@4 utoa10w::@5 to utoa10w::@7 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7]
  __b7_from___b4:
  __b7_from___b5:
    // [67] phi utoa10w::dst#8 = utoa10w::dst#11 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7#0] -- register_copy 
    jmp __b7
    // utoa10w::@7
  __b7:
    // [68] phi from utoa10w::@7 to utoa10w::@6 [phi:utoa10w::@7->utoa10w::@6]
  __b6_from___b7:
    // [68] phi utoa10w::digit#7 = 0 [phi:utoa10w::@7->utoa10w::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [68] phi utoa10w::dst#4 = utoa10w::dst#8 [phi:utoa10w::@7->utoa10w::@6#1] -- register_copy 
    jmp __b6
    // [68] phi from utoa10w::@3 to utoa10w::@6 [phi:utoa10w::@3->utoa10w::@6]
  __b6_from___b3:
    // [68] phi utoa10w::digit#7 = utoa10w::digit#3 [phi:utoa10w::@3->utoa10w::@6#0] -- register_copy 
    // [68] phi utoa10w::dst#4 = utoa10w::dst#11 [phi:utoa10w::@3->utoa10w::@6#1] -- register_copy 
    jmp __b6
    // utoa10w::@6
  __b6:
    // [69] utoa10w::i#1 = ++ utoa10w::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [70] if(utoa10w::i#1!=8) goto utoa10w::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b1_from___b6
    jmp __b8
    // utoa10w::@8
  __b8:
    // [71] utoa10w::$9 = (byte)utoa10w::value#10 -- vbuaa=_byte_vwuz1 
    lda.z value
    // [72] *utoa10w::dst#4 = DIGITS[utoa10w::$9] -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // [73] utoa10w::dst#2 = ++ utoa10w::dst#4 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [74] *utoa10w::dst#2 = 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp __breturn
    // utoa10w::@return
  __breturn:
    // [75] return 
    rts
    // utoa10w::@2
  __b2:
    // [76] utoa10w::digit#1 = utoa10w::digit#3 + UTOA10_VAL[utoa10w::i#2] -- vbuz1=vbuz1_plus_pbuc1_derefidx_vbuxx 
    lda UTOA10_VAL,x
    clc
    adc.z digit
    sta.z digit
    // [77] utoa10w::value#1 = utoa10w::value#10 - UTOA10_SUB[utoa10w::$8] -- vwuz1=vwuz1_minus_pwuc1_derefidx_vbuyy 
    sec
    lda.z value
    sbc UTOA10_SUB,y
    sta.z value
    lda.z value+1
    sbc UTOA10_SUB+1,y
    sta.z value+1
    // [59] phi from utoa10w::@2 to utoa10w::@1 [phi:utoa10w::@2->utoa10w::@1]
  __b1_from___b2:
    // [59] phi utoa10w::dst#11 = utoa10w::dst#11 [phi:utoa10w::@2->utoa10w::@1#0] -- register_copy 
    // [59] phi utoa10w::bStarted#2 = 1 [phi:utoa10w::@2->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #1
    sta.z bStarted
    // [59] phi utoa10w::digit#3 = utoa10w::digit#1 [phi:utoa10w::@2->utoa10w::@1#2] -- register_copy 
    // [59] phi utoa10w::value#10 = utoa10w::value#1 [phi:utoa10w::@2->utoa10w::@1#3] -- register_copy 
    // [59] phi utoa10w::i#2 = utoa10w::i#2 [phi:utoa10w::@2->utoa10w::@1#4] -- register_copy 
    jmp __b1
}
  // utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte register(A) nybble, byte register(X) started)
utoa16n: {
    // [79] if(utoa16n::nybble#4==0) goto utoa16n::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3_from_utoa16n
    // [81] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
  __b1_from_utoa16n:
    // [81] phi utoa16n::return#4 = 1 [phi:utoa16n->utoa16n::@1#0] -- vbuxx=vbuc1 
    ldx #1
    jmp __b1
    // [80] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
  __b3_from_utoa16n:
    jmp __b3
    // utoa16n::@3
  __b3:
    // [81] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
  __b1_from___b3:
    // [81] phi utoa16n::return#4 = utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    jmp __b1
    // utoa16n::@1
  __b1:
    // [82] if(utoa16n::return#4==0) goto utoa16n::@return -- vbuxx_eq_0_then_la1 
    cpx #0
    beq __breturn
    jmp __b2
    // utoa16n::@2
  __b2:
    // [83] *(*(&utoa16w::dst)) = DIGITS[utoa16n::nybble#4] -- _deref_(_deref_qbuc1)=pbuc2_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy.z utoa16w.dst
    sty.z $fe
    ldy.z utoa16w.dst+1
    sty.z $ff
    ldy #0
    sta ($fe),y
    // [84] *(&utoa16w::dst) = ++ *(&utoa16w::dst) -- _deref_qbuc1=_inc__deref_qbuc1 
    inc.z utoa16w.dst
    bne !+
    inc.z utoa16w.dst+1
  !:
    jmp __breturn
    // utoa16n::@return
  __breturn:
    // [85] return 
    rts
}
  // File Data
.segment Data
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef"
  .byte 0
  // Subtraction values used for decimal utoa()
  UTOA10_SUB: .word $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a
  // Digit addition values used for decimal utoa()
  UTOA10_VAL: .byte 3, 1, 3, 1, 3, 1, 3, 1

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b6
Removing instruction jmp __b8
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #>0
Replacing instruction ldy #0 with TAY
Removing instruction lda #0
Replacing instruction ldx #0 with TAX
Replacing instruction ldy #0 with TAY
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b1_from___b1 with __b1
Replacing label __b1_from___b1 with __b1
Replacing label __b6_from___b3 with __b6
Replacing label __b7_from___b4 with __b7
Replacing label __b1_from___b6 with __b1
Replacing label __b3_from_utoa16n with __b1
Removing instruction __b1_from___b1:
Removing instruction __b1_from___b6:
Removing instruction __b7_from___b4:
Removing instruction __b7_from___b5:
Removing instruction __b6_from___b7:
Removing instruction __b6_from___b3:
Removing instruction __b3_from_utoa16n:
Removing instruction __b3:
Removing instruction __b1_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction cls_from_main:
Removing instruction __b2:
Removing instruction utoa16w_from___b2:
Removing instruction __b5:
Removing instruction utoa16w_from___b5:
Removing instruction __b6:
Removing instruction utoa16w_from___b6:
Removing instruction __b7:
Removing instruction utoa16w_from___b7:
Removing instruction __b8:
Removing instruction utoa16w_from___b8:
Removing instruction __b9:
Removing instruction utoa10w_from___b9:
Removing instruction __b3_from___b9:
Removing instruction __b3_from___b4:
Removing instruction __b1_from_cls:
Removing instruction __breturn:
Removing instruction utoa16n_from_utoa16w:
Removing instruction __b1:
Removing instruction utoa16n_from___b1:
Removing instruction __b2:
Removing instruction utoa16n_from___b2:
Removing instruction __b3:
Removing instruction utoa16n_from___b3:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __b1_from_utoa10w:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b8:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction __b1_from_utoa16n:
Removing instruction __b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b6
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
constant byte* const BORDER_COLOR = (byte*) 53280
constant byte* DIGITS[]  = "0123456789abcdef"
constant word* UTOA10_SUB[]  = { $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a }
constant byte* UTOA10_VAL[]  = { 3, 1, 3, 1, 3, 1, 3, 1 }
void cls()
byte* cls::sc
byte* cls::sc#1 sc zp[2]:2 151.5
byte* cls::sc#2 sc zp[2]:2 151.5
constant byte* cls::screen = (byte*) 1024
constant byte* const control = (byte*) 53265
void main()
byte~ main::$1 zp[1]:6 101.0
byte~ main::$2 reg byte a 202.0
byte main::i
byte main::i#1 reg byte x 202.0
byte main::i#2 reg byte x 168.33333333333331
constant byte* main::msg[]  = "raster lines"
byte main::rst
byte main::rst#0 reg byte a 202.0
byte* main::screen
byte main::time
byte main::time#0 reg byte a 11.0
byte main::time_end
byte main::time_end#0 reg byte x 11.0
byte main::time_start
byte main::time_start#0 time_start zp[1]:7 1.2941176470588236
constant byte* const raster = (byte*) 53266
void utoa10w(word utoa10w::value , byte* utoa10w::dst)
byte~ utoa10w::$1 reg byte a 20002.0
byte~ utoa10w::$8 reg byte y 10001.0
byte~ utoa10w::$9 reg byte a 202.0
byte utoa10w::bStarted
byte utoa10w::bStarted#2 bStarted zp[1]:7 2500.25
byte utoa10w::digit
byte utoa10w::digit#1 digit zp[1]:6 10001.0
byte utoa10w::digit#3 digit zp[1]:6 8334.166666666666
byte utoa10w::digit#7 digit zp[1]:6 6667.333333333333
byte* utoa10w::dst
byte* utoa10w::dst#1 dst zp[2]:4 20002.0
byte* utoa10w::dst#11 dst zp[2]:4 7778.555555555557
byte* utoa10w::dst#2 dst zp[2]:4 202.0
byte* utoa10w::dst#4 dst zp[2]:4 6041.0
byte* utoa10w::dst#8 dst zp[2]:4 30003.0
byte utoa10w::i
byte utoa10w::i#1 reg byte x 15001.5
byte utoa10w::i#2 reg byte x 5833.916666666667
word utoa10w::value
word utoa10w::value#0 value zp[2]:2 56.0
word utoa10w::value#1 value zp[2]:2 20002.0
word utoa10w::value#10 value zp[2]:2 3854.3076923076924
byte utoa16n(byte utoa16n::nybble , word** utoa16n::dst , byte utoa16n::started)
word** utoa16n::dst
byte utoa16n::nybble
byte utoa16n::nybble#0 reg byte a 202.0
byte utoa16n::nybble#1 reg byte a 101.0
byte utoa16n::nybble#2 reg byte a 101.0
byte utoa16n::nybble#3 reg byte a 202.0
byte utoa16n::nybble#4 reg byte a 481.2
byte utoa16n::return
byte utoa16n::return#0 reg byte x 202.0
byte utoa16n::return#1 reg byte x 202.0
byte utoa16n::return#4 reg byte x 314.8571428571429
byte utoa16n::started
byte utoa16n::started#1 reg byte x 202.0
byte utoa16n::started#2 reg byte x 202.0
byte utoa16n::started#7 reg byte x 401.0
void utoa16w(word utoa16w::value , byte* volatile utoa16w::dst)
byte~ utoa16w::$0 reg byte a 202.0
byte~ utoa16w::$3 reg byte a 202.0
byte~ utoa16w::$6 reg byte a 202.0
byte~ utoa16w::$9 reg byte a 202.0
byte* volatile utoa16w::dst loadstore zp[2]:8 4.875
byte utoa16w::started
byte utoa16w::started#1 reg byte x 67.33333333333333
byte utoa16w::started#2 reg byte x 67.33333333333333
word utoa16w::value
word utoa16w::value#5 value zp[2]:2 25.25

reg byte x [ main::i#2 main::i#1 ]
reg byte x [ utoa10w::i#2 utoa10w::i#1 ]
zp[2]:2 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 utoa16w::value#5 cls::sc#2 cls::sc#1 ]
zp[2]:4 [ utoa10w::dst#8 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 utoa10w::dst#2 ]
reg byte a [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
reg byte x [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
zp[1]:6 [ main::$1 utoa10w::digit#3 utoa10w::digit#1 utoa10w::digit#7 ]
reg byte a [ main::$2 ]
reg byte a [ main::rst#0 ]
zp[1]:7 [ main::time_start#0 utoa10w::bStarted#2 ]
zp[2]:8 [ utoa16w::dst ]
reg byte x [ main::time_end#0 ]
reg byte a [ main::time#0 ]
reg byte a [ utoa16w::$0 ]
reg byte x [ utoa16n::return#0 ]
reg byte x [ utoa16w::started#1 ]
reg byte a [ utoa16w::$3 ]
reg byte x [ utoa16n::return#1 ]
reg byte x [ utoa16w::started#2 ]
reg byte a [ utoa16w::$6 ]
reg byte a [ utoa16w::$9 ]
reg byte y [ utoa10w::$8 ]
reg byte a [ utoa10w::$1 ]
reg byte a [ utoa10w::$9 ]


FINAL ASSEMBLER
Score: 21518

  // File Comments
// Testing hex to decimal conversion
  // Upstart
  // Commodore 64 PRG executable file
.file [name="hex2dec.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label control = $d011
  .label raster = $d012
  .label BORDER_COLOR = $d020
.segment Code
  // main
main: {
    .label __1 = 6
    .label time_start = 7
    // asm
    // asm { sei  }
    sei
    // cls()
    // [1] call cls 
    // [31] phi from main to cls [phi:main->cls]
    jsr cls
    // main::@1
  __b1:
    // *control&0x80
    // [2] main::$1 = *control & $80 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #$80
    and control
    sta.z __1
    // *raster>>1
    // [3] main::$2 = *raster >> 1 -- vbuaa=_deref_pbuc1_ror_1 
    lda raster
    lsr
    // unsigned char rst = (*control&0x80)|(*raster>>1)
    // [4] main::rst#0 = main::$1 | main::$2 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // while (rst!=0x30)
    // [5] if(main::rst#0!=$30) goto main::@1 -- vbuaa_neq_vbuc1_then_la1 
    cmp #$30
    bne __b1
    // main::@2
    // *BORDER_COLOR = 1
    // [6] *BORDER_COLOR = 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta BORDER_COLOR
    // unsigned char time_start = *raster
    // [7] main::time_start#0 = *raster -- vbuz1=_deref_pbuc1 
    lda raster
    sta.z time_start
    // utoa16w(00000, screen)
    // [8] utoa16w::dst = (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z utoa16w.dst
    lda #>$400
    sta.z utoa16w.dst+1
    // [9] call utoa16w 
    // [37] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
    // [37] phi utoa16w::value#5 = 0 [phi:main::@2->utoa16w#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z utoa16w.value
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@5
    // (*BORDER_COLOR)++;
    // [10] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // utoa16w(01234, screen)
    // [11] utoa16w::dst = (byte*) 1024+$28 -- pbuz1=pbuc1 
    lda #<$400+$28
    sta.z utoa16w.dst
    lda #>$400+$28
    sta.z utoa16w.dst+1
    // [12] call utoa16w 
    // [37] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
    // [37] phi utoa16w::value#5 = $4d2 [phi:main::@5->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z utoa16w.value
    lda #>$4d2
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@6
    // (*BORDER_COLOR)++;
    // [13] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // utoa16w(05678, screen)
    // [14] utoa16w::dst = (byte*) 1024+$28+$28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28
    sta.z utoa16w.dst+1
    // [15] call utoa16w 
    // [37] phi from main::@6 to utoa16w [phi:main::@6->utoa16w]
    // [37] phi utoa16w::value#5 = $162e [phi:main::@6->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$162e
    sta.z utoa16w.value
    lda #>$162e
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@7
    // (*BORDER_COLOR)++;
    // [16] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // utoa16w(09999, screen)
    // [17] utoa16w::dst = (byte*) 1024+$28+$28+$28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28
    sta.z utoa16w.dst+1
    // [18] call utoa16w 
    // [37] phi from main::@7 to utoa16w [phi:main::@7->utoa16w]
    // [37] phi utoa16w::value#5 = $270f [phi:main::@7->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$270f
    sta.z utoa16w.value
    lda #>$270f
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@8
    // (*BORDER_COLOR)++;
    // [19] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // utoa16w(58888, screen)
    // [20] utoa16w::dst = (byte*) 1024+$28+$28+$28+$28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta.z utoa16w.dst+1
    // [21] call utoa16w 
    // [37] phi from main::@8 to utoa16w [phi:main::@8->utoa16w]
    // [37] phi utoa16w::value#5 = $e608 [phi:main::@8->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$e608
    sta.z utoa16w.value
    lda #>$e608
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@9
    // unsigned char time_end = *raster
    // [22] main::time_end#0 = *raster -- vbuxx=_deref_pbuc1 
    ldx raster
    // *BORDER_COLOR = 0
    // [23] *BORDER_COLOR = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDER_COLOR
    // unsigned char time = time_end - time_start
    // [24] main::time#0 = main::time_end#0 - main::time_start#0 -- vbuaa=vbuxx_minus_vbuz1 
    txa
    sec
    sbc.z time_start
    // utoa10w((unsigned int)time, screen+80)
    // [25] utoa10w::value#0 = (word)main::time#0 -- vwuz1=_word_vbuaa 
    sta.z utoa10w.value
    lda #0
    sta.z utoa10w.value+1
    // [26] call utoa10w 
    // [58] phi from main::@9 to utoa10w [phi:main::@9->utoa10w]
    jsr utoa10w
    // [27] phi from main::@9 to main::@3 [phi:main::@9->main::@3]
    // [27] phi main::i#2 = 0 [phi:main::@9->main::@3#0] -- vbuxx=vbuc1 
    ldx #0
    // main::@3
  __b3:
    // for( byte i=0; msg[i]!=0; i++ )
    // [28] if(main::msg[main::i#2]!=0) goto main::@4 -- pbuc1_derefidx_vbuxx_neq_0_then_la1 
    lda msg,x
    cmp #0
    bne __b4
    jmp __b1
    // main::@4
  __b4:
    // (screen+80+3)[i] = msg[i]
    // [29] ((byte*) 1024+$28+$28+$28+$28+$50+3)[main::i#2] = main::msg[main::i#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda msg,x
    sta $400+$28+$28+$28+$28+$50+3,x
    // for( byte i=0; msg[i]!=0; i++ )
    // [30] main::i#1 = ++ main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [27] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
    // [27] phi main::i#2 = main::i#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
  .segment Data
    msg: .text "raster lines"
    .byte 0
}
.segment Code
  // cls
cls: {
    .label screen = $400
    .label sc = 2
    // [32] phi from cls to cls::@1 [phi:cls->cls::@1]
    // [32] phi cls::sc#2 = cls::screen [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta.z sc
    lda #>screen
    sta.z sc+1
    // [32] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
    // [32] phi cls::sc#2 = cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    // cls::@1
  __b1:
    // *sc=' '
    // [33] *cls::sc#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // for( unsigned char *sc: screen..screen+999)
    // [34] cls::sc#1 = ++ cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [35] if(cls::sc#1!=cls::screen+$3e7+1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>screen+$3e7+1
    bne __b1
    lda.z sc
    cmp #<screen+$3e7+1
    bne __b1
    // cls::@return
    // }
    // [36] return 
    rts
}
  // utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zp(2) value, byte* zp(8) dst)
utoa16w: {
    .label dst = 8
    .label value = 2
    // >value
    // [38] utoa16w::$0 = > utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // utoa16n((>value)>>4, &dst, started)
    // [39] utoa16n::nybble#0 = utoa16w::$0 >> 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [40] call utoa16n 
    // [78] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
    // [78] phi utoa16n::started#7 = 0 [phi:utoa16w->utoa16n#0] -- vbuxx=vbuc1 
    ldx #0
    // [78] phi utoa16n::nybble#4 = utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16n((>value)>>4, &dst, started)
    // [41] utoa16n::return#0 = utoa16n::return#4
    // utoa16w::@1
    // started = utoa16n((>value)>>4, &dst, started)
    // [42] utoa16w::started#1 = utoa16n::return#0
    // >value
    // [43] utoa16w::$3 = > utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // utoa16n((>value)&0x0f, &dst, started)
    // [44] utoa16n::nybble#1 = utoa16w::$3 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [45] utoa16n::started#1 = utoa16w::started#1
    // [46] call utoa16n 
    // [78] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
    // [78] phi utoa16n::started#7 = utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
    // [78] phi utoa16n::nybble#4 = utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16n((>value)&0x0f, &dst, started)
    // [47] utoa16n::return#1 = utoa16n::return#4
    // utoa16w::@2
    // started = utoa16n((>value)&0x0f, &dst, started)
    // [48] utoa16w::started#2 = utoa16n::return#1
    // <value
    // [49] utoa16w::$6 = < utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // utoa16n((<value)>>4, &dst, started)
    // [50] utoa16n::nybble#2 = utoa16w::$6 >> 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [51] utoa16n::started#2 = utoa16w::started#2
    // [52] call utoa16n 
    // [78] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
    // [78] phi utoa16n::started#7 = utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
    // [78] phi utoa16n::nybble#4 = utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16w::@3
    // <value
    // [53] utoa16w::$9 = < utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // utoa16n((<value)&0x0f, &dst, 1)
    // [54] utoa16n::nybble#3 = utoa16w::$9 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [55] call utoa16n 
    // [78] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
    // [78] phi utoa16n::started#7 = 1 [phi:utoa16w::@3->utoa16n#0] -- vbuxx=vbuc1 
    ldx #1
    // [78] phi utoa16n::nybble#4 = utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16w::@4
    // *dst = 0
    // [56] *utoa16w::dst = 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (dst),y
    // utoa16w::@return
    // }
    // [57] return 
    rts
}
  // utoa10w
// Decimal utoa() without using multiply or divide
// utoa10w(word zp(2) value, byte* zp(4) dst)
utoa10w: {
    .label value = 2
    .label digit = 6
    .label dst = 4
    .label bStarted = 7
    // [59] phi from utoa10w to utoa10w::@1 [phi:utoa10w->utoa10w::@1]
    // [59] phi utoa10w::dst#11 = (byte*) 1024+$28+$28+$28+$28+$50 [phi:utoa10w->utoa10w::@1#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28+$50
    sta.z dst
    lda #>$400+$28+$28+$28+$28+$50
    sta.z dst+1
    // [59] phi utoa10w::bStarted#2 = 0 [phi:utoa10w->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z bStarted
    // [59] phi utoa10w::digit#3 = 0 [phi:utoa10w->utoa10w::@1#2] -- vbuz1=vbuc1 
    sta.z digit
    // [59] phi utoa10w::value#10 = utoa10w::value#0 [phi:utoa10w->utoa10w::@1#3] -- register_copy 
    // [59] phi utoa10w::i#2 = 0 [phi:utoa10w->utoa10w::@1#4] -- vbuxx=vbuc1 
    tax
    // [59] phi from utoa10w::@6 to utoa10w::@1 [phi:utoa10w::@6->utoa10w::@1]
    // [59] phi utoa10w::dst#11 = utoa10w::dst#4 [phi:utoa10w::@6->utoa10w::@1#0] -- register_copy 
    // [59] phi utoa10w::bStarted#2 = utoa10w::bStarted#2 [phi:utoa10w::@6->utoa10w::@1#1] -- register_copy 
    // [59] phi utoa10w::digit#3 = utoa10w::digit#7 [phi:utoa10w::@6->utoa10w::@1#2] -- register_copy 
    // [59] phi utoa10w::value#10 = utoa10w::value#10 [phi:utoa10w::@6->utoa10w::@1#3] -- register_copy 
    // [59] phi utoa10w::i#2 = utoa10w::i#1 [phi:utoa10w::@6->utoa10w::@1#4] -- register_copy 
    // utoa10w::@1
  __b1:
    // value>=UTOA10_SUB[i]
    // [60] utoa10w::$8 = utoa10w::i#2 << 1 -- vbuyy=vbuxx_rol_1 
    txa
    asl
    tay
    // while(value>=UTOA10_SUB[i])
    // [61] if(utoa10w::value#10>=UTOA10_SUB[utoa10w::$8]) goto utoa10w::@2 -- vwuz1_ge_pwuc1_derefidx_vbuyy_then_la1 
    lda UTOA10_SUB+1,y
    cmp.z value+1
    bne !+
    lda UTOA10_SUB,y
    cmp.z value
    beq __b2
  !:
    bcc __b2
    // utoa10w::@3
    // i&1
    // [62] utoa10w::$1 = utoa10w::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if((i&1)!=0)
    // [63] if(utoa10w::$1==0) goto utoa10w::@6 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b6
    // utoa10w::@4
    // if(bStarted!=0)
    // [64] if(utoa10w::bStarted#2==0) goto utoa10w::@7 -- vbuz1_eq_0_then_la1 
    lda.z bStarted
    beq __b7
    // utoa10w::@5
    // *dst++ = DIGITS[digit]
    // [65] *utoa10w::dst#11 = DIGITS[utoa10w::digit#3] -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z digit
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // *dst++ = DIGITS[digit];
    // [66] utoa10w::dst#1 = ++ utoa10w::dst#11 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [67] phi from utoa10w::@4 utoa10w::@5 to utoa10w::@7 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7]
    // [67] phi utoa10w::dst#8 = utoa10w::dst#11 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7#0] -- register_copy 
    // utoa10w::@7
  __b7:
    // [68] phi from utoa10w::@7 to utoa10w::@6 [phi:utoa10w::@7->utoa10w::@6]
    // [68] phi utoa10w::digit#7 = 0 [phi:utoa10w::@7->utoa10w::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [68] phi utoa10w::dst#4 = utoa10w::dst#8 [phi:utoa10w::@7->utoa10w::@6#1] -- register_copy 
    // [68] phi from utoa10w::@3 to utoa10w::@6 [phi:utoa10w::@3->utoa10w::@6]
    // [68] phi utoa10w::digit#7 = utoa10w::digit#3 [phi:utoa10w::@3->utoa10w::@6#0] -- register_copy 
    // [68] phi utoa10w::dst#4 = utoa10w::dst#11 [phi:utoa10w::@3->utoa10w::@6#1] -- register_copy 
    // utoa10w::@6
  __b6:
    // for( unsigned char i: 0..7)
    // [69] utoa10w::i#1 = ++ utoa10w::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [70] if(utoa10w::i#1!=8) goto utoa10w::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b1
    // utoa10w::@8
    // *dst++ = DIGITS[(unsigned char) value]
    // [71] utoa10w::$9 = (byte)utoa10w::value#10 -- vbuaa=_byte_vwuz1 
    lda.z value
    // [72] *utoa10w::dst#4 = DIGITS[utoa10w::$9] -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // *dst++ = DIGITS[(unsigned char) value];
    // [73] utoa10w::dst#2 = ++ utoa10w::dst#4 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // *dst = 0
    // [74] *utoa10w::dst#2 = 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (dst),y
    // utoa10w::@return
    // }
    // [75] return 
    rts
    // utoa10w::@2
  __b2:
    // digit += UTOA10_VAL[i]
    // [76] utoa10w::digit#1 = utoa10w::digit#3 + UTOA10_VAL[utoa10w::i#2] -- vbuz1=vbuz1_plus_pbuc1_derefidx_vbuxx 
    lda UTOA10_VAL,x
    clc
    adc.z digit
    sta.z digit
    // value -= UTOA10_SUB[i]
    // [77] utoa10w::value#1 = utoa10w::value#10 - UTOA10_SUB[utoa10w::$8] -- vwuz1=vwuz1_minus_pwuc1_derefidx_vbuyy 
    sec
    lda.z value
    sbc UTOA10_SUB,y
    sta.z value
    lda.z value+1
    sbc UTOA10_SUB+1,y
    sta.z value+1
    // [59] phi from utoa10w::@2 to utoa10w::@1 [phi:utoa10w::@2->utoa10w::@1]
    // [59] phi utoa10w::dst#11 = utoa10w::dst#11 [phi:utoa10w::@2->utoa10w::@1#0] -- register_copy 
    // [59] phi utoa10w::bStarted#2 = 1 [phi:utoa10w::@2->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #1
    sta.z bStarted
    // [59] phi utoa10w::digit#3 = utoa10w::digit#1 [phi:utoa10w::@2->utoa10w::@1#2] -- register_copy 
    // [59] phi utoa10w::value#10 = utoa10w::value#1 [phi:utoa10w::@2->utoa10w::@1#3] -- register_copy 
    // [59] phi utoa10w::i#2 = utoa10w::i#2 [phi:utoa10w::@2->utoa10w::@1#4] -- register_copy 
    jmp __b1
}
  // utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte register(A) nybble, byte register(X) started)
utoa16n: {
    // if(nybble!=0)
    // [79] if(utoa16n::nybble#4==0) goto utoa16n::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b1
    // [81] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
    // [81] phi utoa16n::return#4 = 1 [phi:utoa16n->utoa16n::@1#0] -- vbuxx=vbuc1 
    ldx #1
    // [80] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
    // utoa16n::@3
    // [81] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
    // [81] phi utoa16n::return#4 = utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    // utoa16n::@1
  __b1:
    // if(started!=0)
    // [82] if(utoa16n::return#4==0) goto utoa16n::@return -- vbuxx_eq_0_then_la1 
    cpx #0
    beq __breturn
    // utoa16n::@2
    // *(*dst)++ = DIGITS[nybble]
    // [83] *(*(&utoa16w::dst)) = DIGITS[utoa16n::nybble#4] -- _deref_(_deref_qbuc1)=pbuc2_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy.z utoa16w.dst
    sty.z $fe
    ldy.z utoa16w.dst+1
    sty.z $ff
    ldy #0
    sta ($fe),y
    // *(*dst)++ = DIGITS[nybble];
    // [84] *(&utoa16w::dst) = ++ *(&utoa16w::dst) -- _deref_qbuc1=_inc__deref_qbuc1 
    inc.z utoa16w.dst
    bne !+
    inc.z utoa16w.dst+1
  !:
    // utoa16n::@return
  __breturn:
    // }
    // [85] return 
    rts
}
  // File Data
.segment Data
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef"
  .byte 0
  // Subtraction values used for decimal utoa()
  UTOA10_SUB: .word $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a
  // Digit addition values used for decimal utoa()
  UTOA10_VAL: .byte 3, 1, 3, 1, 3, 1, 3, 1

