// Pre-calculated bobs inside a charset (pre-mpved to all x/y-combinations)
import "c64"
import "string"
import "keyboard"
import "time"
import "print"

// The prototype BOB (a 3x3 char image with a bob image in the upper 2x2 chars)
// The chars are layout as follows with data in chars 0, 1, 3, 4 initially
//   0 3 6
//   1 4 7
//   2 5 8
const char[3*3*8] PROTO_BOB = kickasm(resource "smiley.png") {{ 
	.var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
	.for (var x=0;x<3; x++)
    	.for (var y=0; y<24; y++)
            .byte pic.getSinglecolorByte(x,y)
}};

// Sine used for the X-coordinate
const char[0x200] SIN_X_TAB = kickasm {{ .fill $200, 75.5+75.5*sin(i*2*PI/256) }};
// Sine used for the Y-coordinate
const char[0x200] SIN_Y_TAB = kickasm {{ .fill $200, 91.5+91.5*sin(i*2*PI/256) }};

// The BASIC screen
const char* SCREEN_BASIC = 0x0400;
// The BASIC charset
const char* CHARSET_BASIC = 0x1000;
// The screen
const char* BOB_SCREEN = 0x4800;
// The charset that will receive the shifted bobs
const char* BOB_CHARSET = 0x4000;

// Tables containing the char to use for a specific cell of a shifted BOB.
// char_id = BOB_TABLES[cell*BOB_SUBTABLE_SIZE + shift_y*BOB_SHIFTS_X + shift_x];
char[9*8*4] BOB_TABLES;
// The number of different X-shifts
const char BOB_SHIFTS_X = 4;
// The number of different Y-shifts
const char BOB_SHIFTS_Y = 8;
// The size of a sub-table of BOB_TABLES
const char BOB_SUBTABLE_SIZE =  BOB_SHIFTS_X*BOB_SHIFTS_Y;

void main() {
	prepareBobs();
	vicSelectGfxBank(BOB_SCREEN);
	*D018 = toD018(BOB_SCREEN, BOB_CHARSET);
	// Clear screen
	memset(BOB_SCREEN, 0x00, 1000);
	// Display a BOB grid
	for( char x: 0..7)
	    for(char y: 0..3)
            renderBob(x*12+y, y*24+x);
	// Wait for space
	while(!keyboard_key_pressed(KEY_SPACE)) {}
	while(keyboard_key_pressed(KEY_SPACE)) {}
	// Clear screen
	memset(BOB_SCREEN, 0x00, 1000);
	// Render sine BOBs
	char sin_x_idx = 0;
	char sin_y_idx = 73;
	while(true) {
        do { } while (*RASTER<$f8);
        (*BORDERCOL)++;
        renderBob((SIN_X_TAB+21*4)[sin_x_idx], (SIN_Y_TAB+13*0)[sin_y_idx]);
        renderBob((SIN_X_TAB+19*3)[sin_x_idx], (SIN_Y_TAB+15*1)[sin_y_idx]);
        renderBob((SIN_X_TAB+17*2)[sin_x_idx], (SIN_Y_TAB+17*2)[sin_y_idx]);
        renderBob((SIN_X_TAB+15*1)[sin_x_idx], (SIN_Y_TAB+19*3)[sin_y_idx]);
        renderBob((SIN_X_TAB+13*0)[sin_x_idx], (SIN_Y_TAB+21*4)[sin_y_idx]);
        sin_x_idx++;
        sin_y_idx++;
        (*BORDERCOL)--;
	    if(keyboard_key_pressed(KEY_SPACE)) {
	        break;
	    }
	}
	// Return to BASIC
	vicSelectGfxBank(SCREEN_BASIC);
	*D018 = toD018(SCREEN_BASIC, CHARSET_BASIC);
}

// Render a single BOB at a given x/y-position
// X-position is 0-151. Each x-position is 2 pixels wide.
// Y-position is 0-183. Each y-position is 1 pixel high.
void renderBob(char xpos, char ypos) {
	char x_char_offset = xpos/BOB_SHIFTS_X;
	char y_char_offset = ypos/BOB_SHIFTS_Y;
	unsigned int y_offset = (unsigned int)y_char_offset*40;
	char* screen = BOB_SCREEN+y_offset+x_char_offset;
	char bob_table_idx = (ypos&7)*BOB_SHIFTS_X+(xpos&3);
    screen[0]  = (BOB_TABLES+0*BOB_SUBTABLE_SIZE)[bob_table_idx];
    screen[40] = (BOB_TABLES+1*BOB_SUBTABLE_SIZE)[bob_table_idx];
    screen[80] = (BOB_TABLES+2*BOB_SUBTABLE_SIZE)[bob_table_idx];
    screen[1]  = (BOB_TABLES+3*BOB_SUBTABLE_SIZE)[bob_table_idx];
    screen[41] = (BOB_TABLES+4*BOB_SUBTABLE_SIZE)[bob_table_idx];
    screen[81] = (BOB_TABLES+5*BOB_SUBTABLE_SIZE)[bob_table_idx];
    screen[2]  = (BOB_TABLES+6*BOB_SUBTABLE_SIZE)[bob_table_idx];
    screen[42] = (BOB_TABLES+7*BOB_SUBTABLE_SIZE)[bob_table_idx];
    screen[82] = (BOB_TABLES+8*BOB_SUBTABLE_SIZE)[bob_table_idx];
}

// Creates the pre-shifted bobs into BOB_CHARSET and populates the BOB_TABLES
// Modifies PROTO_BOB by shifting it around
void prepareBobs() {
	bob_charset_next_id = 0;
    // Ensure the first glyph is empty
    bobCharsetFindOrAddGlyph(PROTO_BOB+48);
	char bob_table_idx = 0;
	for(char shift_y=0;shift_y<BOB_SHIFTS_Y;shift_y++) {
		for(char shift_x=0;shift_x<BOB_SHIFTS_X;shift_x++) {
			// Populate charset and tables
			char* bob_glyph = PROTO_BOB;
			char* bob_table = BOB_TABLES + bob_table_idx;
			for(char cell = 0; cell<9; cell++) {
				// Look for an existing char in BOB_CHARSET 
				*bob_table = bobCharsetFindOrAddGlyph(bob_glyph);
				// Move to the next glyph
				bob_glyph+=8;
				// Move to the next sub-table
				bob_table += BOB_SHIFTS_X*BOB_SHIFTS_Y;
			}
			// Move to the next bob table idx
			bob_table_idx++;
			// Shift PROTO_BOB right twice
			shiftProtoBobRight();
			shiftProtoBobRight();
		}		
        // Shift PROTO_BOB down and 8px left
		shiftProtoBobDown();
	}
}

// Shift PROTO_BOB right one X pixel
void shiftProtoBobRight() {
	char carry = 0;
	char j = 0;
	for(char i=0;i<3*3*8;i++) {
		// Get the new carry
		char new_carry = (PROTO_BOB[j]&1)?0x80ub:0ub;
		// Shift value and add old carry
		PROTO_BOB[j] = PROTO_BOB[j]>>1 |Â carry;
		// Update carry
		carry = new_carry;
		// Increment j to iterate over the PROTO_BOB left-to-right, top-to-bottom (0, 24, 48, 1, 25, 49, ...)
		if(j>=48) {
			j-=47;
		} else {
			j+=24;
		}
	}
}

// Shift PROTO_BOB down one Y pixel
// At the same time restore PROTO_BOB X by shifting 8 pixels left
void shiftProtoBobDown() {
	for(char i=23;i>0;i--) {
		PROTO_BOB[i] = (PROTO_BOB+23)[i];
		(PROTO_BOB+24)[i] = (PROTO_BOB+47)[i];
		(PROTO_BOB+48)[i] = 0x00;
	}
	PROTO_BOB[0] = 0;
	PROTO_BOB[24] = 0;
	PROTO_BOB[48] = 0;

}

// BOB charset ID of the next glyph to be added
char bob_charset_next_id;

// Looks through BOB_CHARSET to find the passed bob glyph if present.
// If not present it is added
// Returns the glyph ID
char bobCharsetFindOrAddGlyph(char* bob_glyph) {
	char* glyph_cursor = BOB_CHARSET;
	byte glyph_id = 0;	
	while(glyph_id!=bob_charset_next_id) {
		byte found = 1;
		for(char i=0;i<8;i++) {
			if(glyph_cursor[i]!=bob_glyph[i]) {
				found = 0;
				break;
			}
		}
		if(found) return glyph_id;
		glyph_id++;		
		glyph_cursor +=8;
	}
	// Not found - add it
	for(char i=0;i<8;i++)
		glyph_cursor[i]=bob_glyph[i];	
	bob_charset_next_id++;
	return glyph_id;
}
