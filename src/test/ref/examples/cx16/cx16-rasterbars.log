Resolved forward reference irq_line to __interrupt(rom_min_cx16) void irq_line()
Setting inferred volatile on symbol affected by address-of: memcpy_vram_bram::pos in asm { ldypos ldxlen inx ldaptr sta!ptr++1 ldaptr+1 sta!ptr++2 !ptr: lda$ffff,y staVERA_DATA0 iny dex bne!ptr-  }
Setting inferred volatile on symbol affected by address-of: memcpy_vram_bram::len in asm { ldypos ldxlen inx ldaptr sta!ptr++1 ldaptr+1 sta!ptr++2 !ptr: lda$ffff,y staVERA_DATA0 iny dex bne!ptr-  }
Setting inferred volatile on symbol affected by address-of: memcpy_vram_bram::ptr in asm { ldypos ldxlen inx ldaptr sta!ptr++1 ldaptr+1 sta!ptr++2 !ptr: lda$ffff,y staVERA_DATA0 iny dex bne!ptr-  }
Setting inferred volatile on symbol affected by address-of: memcpy_vram_bram::num in asm { ldy#0 ldxnum inx ldaptr sta!ptr++1 ldaptr+1 sta!ptr++2 !ptr: lda$ffff,y staVERA_DATA0 iny dex bne!ptr-  }
Setting inferred volatile on symbol affected by address-of: cbm_k_setlfs::device in asm { ldxdevice ldachannel ldycommand jsrCBM_SETLFS  }
Setting inferred volatile on symbol affected by address-of: cbm_k_setlfs::channel in asm { ldxdevice ldachannel ldycommand jsrCBM_SETLFS  }
Setting inferred volatile on symbol affected by address-of: cbm_k_setlfs::command in asm { ldxdevice ldachannel ldycommand jsrCBM_SETLFS  }
Setting inferred volatile on symbol affected by address-of: cbm_k_setnam::filename_len in asm { ldafilename_len ldxfilename ldyfilename+1 jsrCBM_SETNAM  }
Setting inferred volatile on symbol affected by address-of: cbm_k_setnam::filename in asm { ldafilename_len ldxfilename ldyfilename+1 jsrCBM_SETNAM  }
Setting inferred volatile on symbol affected by address-of: cbm_k_close::channel in asm { ldachannel jsrCBM_CLOSE  }
Setting inferred volatile on symbol affected by address-of: cbm_k_chkin::channel in asm { ldxchannel jsrCBM_CHKIN stastatus  }
Setting inferred volatile on symbol affected by address-of: cbm_k_chkin::status in asm { ldxchannel jsrCBM_CHKIN stastatus  }
Setting inferred volatile on symbol affected by address-of: cbm_k_chrin::ch in asm { jsrCBM_CHRIN stach  }
Setting inferred volatile on symbol affected by address-of: cbm_k_getin::ch in asm { jsrCBM_GETIN stach  }
Setting inferred volatile on symbol affected by address-of: cbm_k_readst::status in asm { jsrCBM_READST stastatus  }
Setting inferred volatile on symbol affected by address-of: cbm_k_load::address in asm { .byte$db ldxaddress ldyaddress+1 ldaverify jsr$ffd5 bcs!error+ lda#$ff !error: stastatus  }
Setting inferred volatile on symbol affected by address-of: cbm_k_load::verify in asm { .byte$db ldxaddress ldyaddress+1 ldaverify jsr$ffd5 bcs!error+ lda#$ff !error: stastatus  }
Setting inferred volatile on symbol affected by address-of: cbm_k_load::status in asm { .byte$db ldxaddress ldyaddress+1 ldaverify jsr$ffd5 bcs!error+ lda#$ff !error: stastatus  }
Setting inferred volatile on symbol affected by address-of: cbm_k_plot_get::x in kickasm( uses cbm_k_plot_get::x uses cbm_k_plot_get::y uses CBM_PLOT) {{ sec
        jsr CBM_PLOT
        stx y
        sty x
     }}
Setting inferred volatile on symbol affected by address-of: cbm_k_plot_get::y in kickasm( uses cbm_k_plot_get::x uses cbm_k_plot_get::y uses CBM_PLOT) {{ sec
        jsr CBM_PLOT
        stx y
        sty x
     }}
Setting inferred volatile on symbol affected by address-of: cbm_k_plot_set::x in kickasm( uses cbm_k_plot_set::x uses cbm_k_plot_set::y uses CBM_PLOT) {{ ldx y
        ldy x
        clc
        jsr CBM_PLOT
     }}
Setting inferred volatile on symbol affected by address-of: cbm_k_plot_set::y in kickasm( uses cbm_k_plot_set::x uses cbm_k_plot_set::y uses CBM_PLOT) {{ ldx y
        ldy x
        clc
        jsr CBM_PLOT
     }}
Setting inferred volatile on symbol affected by address-of: cbm_k_chrout::ch in asm { ldach jsrCBM_CHROUT  }
Setting inferred volatile on symbol affected by address-of: cx16_k_macptr::bytes in asm { ldabytes ldxbuffer ldybuffer+1 clc jsrCX16_MACPTR stxbytes_read stybytes_read+1 bcc!+ lda#$FF stabytes_read stabytes_read+1 !:  }
Setting inferred volatile on symbol affected by address-of: cx16_k_macptr::buffer in asm { ldabytes ldxbuffer ldybuffer+1 clc jsrCX16_MACPTR stxbytes_read stybytes_read+1 bcc!+ lda#$FF stabytes_read stabytes_read+1 !:  }
Setting inferred volatile on symbol affected by address-of: cx16_k_macptr::bytes_read in asm { ldabytes ldxbuffer ldybuffer+1 clc jsrCX16_MACPTR stxbytes_read stybytes_read+1 bcc!+ lda#$FF stabytes_read stabytes_read+1 !:  }
Setting inferred volatile on symbol affected by address-of: cx16_k_screen_set_charset::charset in asm { ldacharset ldx<offset ldy>offset jsrCX16_SCREEN_SET_CHARSET  }
Setting inferred volatile on symbol affected by address-of: cx16_k_screen_set_charset::offset in asm { ldacharset ldx<offset ldy>offset jsrCX16_SCREEN_SET_CHARSET  }
Inlined call call bank_set_bram(bank_bram_ptr_inc::bank)
Inlined call memcpy_vram_bram::bank = call bank_get_bram
Inlined call call bank_set_bram(memcpy_vram_bram::sbank_bram)
Inlined call call bank_set_bram(memcpy_vram_bram::sbank_bram)
Inlined call call bank_set_bram(memcpy_vram_bram::sbank_bram)
Inlined call call bank_set_bram(memcpy_vram_bram::bank)
Inlined call call SEI
Inlined call call CLI
Inlined call call __init
Eliminating unused variable with no statement memset::$2
Eliminating unused variable with no statement irq_line::$10

CONTROL FLOW GRAPH SSA

void * memset(void *str , char c , unsigned int num)
memset: scope:[memset]  from irq_line::@1
  memset::c#4 = phi( irq_line::@1/memset::c#0 )
  memset::str#3 = phi( irq_line::@1/memset::str#0 )
  memset::num#1 = phi( irq_line::@1/memset::num#0 )
  memset::$0 = memset::num#1 > 0
  memset::$1 = ! memset::$0
  if(memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@3
  memset::str#1 = phi( memset/memset::str#3, memset::@3/memset::str#4 )
  memset::return#0 = memset::str#1
  to:memset::@return
memset::@2: scope:[memset]  from memset
  memset::c#3 = phi( memset/memset::c#4 )
  memset::num#2 = phi( memset/memset::num#1 )
  memset::str#2 = phi( memset/memset::str#3 )
  memset::$4 = (char *)memset::str#2
  memset::end#0 = memset::$4 + memset::num#2
  memset::dst#0 = ((char *)) memset::str#2
  to:memset::@3
memset::@3: scope:[memset]  from memset::@2 memset::@4
  memset::c#2 = phi( memset::@2/memset::c#3, memset::@4/memset::c#1 )
  memset::str#4 = phi( memset::@2/memset::str#2, memset::@4/memset::str#5 )
  memset::end#1 = phi( memset::@2/memset::end#0, memset::@4/memset::end#2 )
  memset::dst#2 = phi( memset::@2/memset::dst#0, memset::@4/memset::dst#1 )
  memset::$3 = memset::dst#2 != memset::end#1
  if(memset::$3) goto memset::@4
  to:memset::@1
memset::@4: scope:[memset]  from memset::@3
  memset::str#5 = phi( memset::@3/memset::str#4 )
  memset::end#2 = phi( memset::@3/memset::end#1 )
  memset::dst#3 = phi( memset::@3/memset::dst#2 )
  memset::c#1 = phi( memset::@3/memset::c#2 )
  *memset::dst#3 = memset::c#1
  memset::dst#1 = ++ memset::dst#3
  to:memset::@3
memset::@return: scope:[memset]  from memset::@1
  memset::return#3 = phi( memset::@1/memset::return#0 )
  memset::return#1 = memset::return#3
  return 
  to:@return

void cx16_init()
cx16_init: scope:[cx16_init]  from __start::__init1
  isr_vsync#0 = *((unsigned int *)$314)
  to:cx16_init::@return
cx16_init::@return: scope:[cx16_init]  from cx16_init
  isr_vsync#5 = phi( cx16_init/isr_vsync#0 )
  isr_vsync#1 = isr_vsync#5
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  to:main::SEI1
main::SEI1: scope:[main]  from main
  asm { sei  }
  to:main::@2
main::@2: scope:[main]  from main::SEI1
  *KERNEL_IRQ = &irq_line
  *VERA_IEN = VERA_LINE
  *VERA_IRQLINE_L = 5
  to:main::CLI1
main::CLI1: scope:[main]  from main::@2
  asm { cli  }
  to:main::@1
main::@1: scope:[main]  from main::@1 main::CLI1
  to:main::@1
main::@return: scope:[main]  from
  return 
  to:@return

__interrupt(rom_min_cx16) void irq_line()
irq_line: scope:[irq_line]  from
  *VERA_CTRL = *VERA_CTRL | VERA_DCSEL
  *VERA_DC_HSTART = hstart
  *VERA_DC_HSTOP = hstop
  *VERA_DC_VSTART = vstart
  *VERA_DC_VSTOP = vstop
  *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL
  irq_line::l#0 = 0
  to:irq_line::@2
irq_line::@2: scope:[irq_line]  from irq_line irq_line::@10
  irq_line::l#2 = phi( irq_line/irq_line::l#0, irq_line::@10/irq_line::l#1 )
  irq_line::$4 = irq_line::l#2 != $e6
  if(irq_line::$4) goto irq_line::@3
  to:irq_line::@4
irq_line::@3: scope:[irq_line]  from irq_line::@2
  irq_line::l#3 = phi( irq_line::@2/irq_line::l#2 )
  *VERA_DC_BORDER = BARS[irq_line::l#3]
  irq_line::i#0 = 0
  to:irq_line::@5
irq_line::@4: scope:[irq_line]  from irq_line::@2
  cnt = -- cnt
  irq_line::$0 = cnt == 0
  irq_line::$1 = ! irq_line::$0
  if(irq_line::$1) goto irq_line::@1
  to:irq_line::@11
irq_line::@5: scope:[irq_line]  from irq_line::@3 irq_line::@6
  irq_line::l#8 = phi( irq_line::@3/irq_line::l#3, irq_line::@6/irq_line::l#9 )
  irq_line::i#2 = phi( irq_line::@3/irq_line::i#0, irq_line::@6/irq_line::i#1 )
  irq_line::$5 = irq_line::i#2 < $18
  if(irq_line::$5) goto irq_line::@6
  to:irq_line::@7
irq_line::@6: scope:[irq_line]  from irq_line::@5
  irq_line::l#9 = phi( irq_line::@5/irq_line::l#8 )
  irq_line::i#3 = phi( irq_line::@5/irq_line::i#2 )
  irq_line::i#1 = ++ irq_line::i#3
  to:irq_line::@5
irq_line::@7: scope:[irq_line]  from irq_line::@5
  irq_line::l#6 = phi( irq_line::@5/irq_line::l#8 )
  *VERA_DC_BORDER = 0
  irq_line::i1#0 = 0
  to:irq_line::@8
irq_line::@8: scope:[irq_line]  from irq_line::@7 irq_line::@9
  irq_line::l#5 = phi( irq_line::@7/irq_line::l#6, irq_line::@9/irq_line::l#7 )
  irq_line::i1#2 = phi( irq_line::@7/irq_line::i1#0, irq_line::@9/irq_line::i1#1 )
  irq_line::$6 = irq_line::i1#2 < $17
  if(irq_line::$6) goto irq_line::@9
  to:irq_line::@10
irq_line::@9: scope:[irq_line]  from irq_line::@8
  irq_line::l#7 = phi( irq_line::@8/irq_line::l#5 )
  irq_line::i1#3 = phi( irq_line::@8/irq_line::i1#2 )
  irq_line::i1#1 = ++ irq_line::i1#3
  to:irq_line::@8
irq_line::@10: scope:[irq_line]  from irq_line::@8
  irq_line::l#4 = phi( irq_line::@8/irq_line::l#5 )
  asm { nop nop  }
  irq_line::l#1 = ++ irq_line::l#4
  to:irq_line::@2
irq_line::@1: scope:[irq_line]  from irq_line::@11 irq_line::@12 irq_line::@4
  irq_line::$2 = sizeof  BARS
  memset::str#0 = (void *)BARS
  memset::c#0 = 0
  memset::num#0 = irq_line::$2
  call memset
  memset::return#2 = memset::return#1
  to:irq_line::@19
irq_line::@19: scope:[irq_line]  from irq_line::@1
  irq_line::idx#0 = sin_idx
  sin_idx = -- sin_idx
  irq_line::b#0 = 0
  to:irq_line::@13
irq_line::@11: scope:[irq_line]  from irq_line::@4
  cnt = 2
  irq_line::$7 = hstart <= $140/4
  irq_line::$8 = ! irq_line::$7
  if(irq_line::$8) goto irq_line::@1
  to:irq_line::@12
irq_line::@12: scope:[irq_line]  from irq_line::@11
  hstart = ++ hstart
  hstop = -- hstop
  vstart = ++ vstart
  vstop = -- vstop
  to:irq_line::@1
irq_line::@13: scope:[irq_line]  from irq_line::@18 irq_line::@19
  irq_line::idx#4 = phi( irq_line::@18/irq_line::idx#1, irq_line::@19/irq_line::idx#0 )
  irq_line::b#2 = phi( irq_line::@18/irq_line::b#1, irq_line::@19/irq_line::b#0 )
  irq_line::$9 = irq_line::b#2 < 8
  if(irq_line::$9) goto irq_line::@14
  to:irq_line::@15
irq_line::@14: scope:[irq_line]  from irq_line::@13
  irq_line::b#5 = phi( irq_line::@13/irq_line::b#2 )
  irq_line::idx#2 = phi( irq_line::@13/irq_line::idx#4 )
  irq_line::bar#0 = BARS + SIN[irq_line::idx#2]
  irq_line::i2#0 = 0
  to:irq_line::@16
irq_line::@15: scope:[irq_line]  from irq_line::@13
  *VERA_ISR = VERA_LINE
  to:irq_line::@return
irq_line::@16: scope:[irq_line]  from irq_line::@14 irq_line::@17
  irq_line::b#4 = phi( irq_line::@14/irq_line::b#5, irq_line::@17/irq_line::b#6 )
  irq_line::idx#5 = phi( irq_line::@14/irq_line::idx#2, irq_line::@17/irq_line::idx#6 )
  irq_line::bar#2 = phi( irq_line::@14/irq_line::bar#0, irq_line::@17/irq_line::bar#1 )
  irq_line::i2#2 = phi( irq_line::@14/irq_line::i2#0, irq_line::@17/irq_line::i2#1 )
  irq_line::$11 = sizeof  BAR
  irq_line::$12 = irq_line::i2#2 < irq_line::$11
  if(irq_line::$12) goto irq_line::@17
  to:irq_line::@18
irq_line::@17: scope:[irq_line]  from irq_line::@16
  irq_line::b#6 = phi( irq_line::@16/irq_line::b#4 )
  irq_line::idx#6 = phi( irq_line::@16/irq_line::idx#5 )
  irq_line::bar#1 = phi( irq_line::@16/irq_line::bar#2 )
  irq_line::i2#3 = phi( irq_line::@16/irq_line::i2#2 )
  irq_line::bar#1[irq_line::i2#3] = BAR[irq_line::i2#3]
  irq_line::i2#1 = ++ irq_line::i2#3
  to:irq_line::@16
irq_line::@18: scope:[irq_line]  from irq_line::@16
  irq_line::b#3 = phi( irq_line::@16/irq_line::b#4 )
  irq_line::idx#3 = phi( irq_line::@16/irq_line::idx#5 )
  irq_line::idx#1 = irq_line::idx#3 + $d
  irq_line::b#1 = ++ irq_line::b#3
  to:irq_line::@13
irq_line::@return: scope:[irq_line]  from irq_line::@15
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  BRAM = 0
  BROM = 4
  isr_vsync#2 = $314
  hstart = (char)0/4
  hstop = (char)$280/4
  vstart = (char)0/2
  vstop = (char)$1e0/2
  cnt = 2
  sin_idx = $64
  call cx16_init
  to:__start::@2
__start::@2: scope:[__start]  from __start::__init1
  isr_vsync#6 = phi( __start::__init1/isr_vsync#1 )
  isr_vsync#3 = isr_vsync#6
  to:__start::@1
__start::@1: scope:[__start]  from __start::@2
  isr_vsync#9 = phi( __start::@2/isr_vsync#3 )
  call main
  to:__start::@3
__start::@3: scope:[__start]  from __start::@1
  isr_vsync#8 = phi( __start::@1/isr_vsync#9 )
  to:__start::@return
__start::@return: scope:[__start]  from __start::@3
  isr_vsync#7 = phi( __start::@3/isr_vsync#8 )
  isr_vsync#4 = isr_vsync#7
  return 
  to:@return

SYMBOL TABLE SSA
__constant char BAR[$20] = { $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1a, $1b, $1c, $1d, $1e, $1f, $1f, $1e, $1d, $1c, $1b, $1a, $19, $18, $17, $16, $15, $14, $13, $12, $11, $10 }
__constant char BARS[$e6] = { fill( $e6, 0) }
__loadstore volatile char BRAM // !zp[-1]:0
__loadstore volatile char BROM // !zp[-1]:1
__constant void (** const KERNEL_IRQ)() = (void (**)())$314
__constant char RADIX::BINARY = 2
__constant char RADIX::DECIMAL = $a
__constant char RADIX::HEXADECIMAL = $10
__constant char RADIX::OCTAL = 8
__constant char SIN[$100] = kickasm {{ .fill 256, 99+99*sin(i*2*PI/256)
 }}
__constant char * const VERA_CTRL = (char *)$9f25
__constant const char VERA_DCSEL = 2
__constant char * const VERA_DC_BORDER = (char *)$9f2c
__constant char * const VERA_DC_HSTART = (char *)$9f29
__constant char * const VERA_DC_HSTOP = (char *)$9f2a
__constant char * const VERA_DC_VSTART = (char *)$9f2b
__constant char * const VERA_DC_VSTOP = (char *)$9f2c
__constant char * const VERA_IEN = (char *)$9f26
__constant char * const VERA_IRQLINE_L = (char *)$9f28
__constant char * const VERA_ISR = (char *)$9f27
__constant const char VERA_LINE = 2
void __start()
__loadstore volatile char cnt
void cx16_init()
__loadstore volatile char hstart
__loadstore volatile char hstop
__interrupt(rom_min_cx16) void irq_line()
bool irq_line::$0
bool irq_line::$1
unsigned int irq_line::$11
bool irq_line::$12
unsigned int irq_line::$2
bool irq_line::$4
bool irq_line::$5
bool irq_line::$6
bool irq_line::$7
bool irq_line::$8
bool irq_line::$9
char irq_line::b
char irq_line::b#0
char irq_line::b#1
char irq_line::b#2
char irq_line::b#3
char irq_line::b#4
char irq_line::b#5
char irq_line::b#6
char *irq_line::bar
char *irq_line::bar#0
char *irq_line::bar#1
char *irq_line::bar#2
char irq_line::i
char irq_line::i#0
char irq_line::i#1
char irq_line::i#2
char irq_line::i#3
char irq_line::i1
char irq_line::i1#0
char irq_line::i1#1
char irq_line::i1#2
char irq_line::i1#3
char irq_line::i2
char irq_line::i2#0
char irq_line::i2#1
char irq_line::i2#2
char irq_line::i2#3
char irq_line::idx
char irq_line::idx#0
char irq_line::idx#1
char irq_line::idx#2
char irq_line::idx#3
char irq_line::idx#4
char irq_line::idx#5
char irq_line::idx#6
char irq_line::l
char irq_line::l#0
char irq_line::l#1
char irq_line::l#2
char irq_line::l#3
char irq_line::l#4
char irq_line::l#5
char irq_line::l#6
char irq_line::l#7
char irq_line::l#8
char irq_line::l#9
unsigned int isr_vsync
unsigned int isr_vsync#0
unsigned int isr_vsync#1
unsigned int isr_vsync#2
unsigned int isr_vsync#3
unsigned int isr_vsync#4
unsigned int isr_vsync#5
unsigned int isr_vsync#6
unsigned int isr_vsync#7
unsigned int isr_vsync#8
unsigned int isr_vsync#9
void main()
void * memset(void *str , char c , unsigned int num)
bool memset::$0
bool memset::$1
bool memset::$3
char *memset::$4
char memset::c
char memset::c#0
char memset::c#1
char memset::c#2
char memset::c#3
char memset::c#4
char *memset::dst
char *memset::dst#0
char *memset::dst#1
char *memset::dst#2
char *memset::dst#3
char *memset::end
char *memset::end#0
char *memset::end#1
char *memset::end#2
unsigned int memset::num
unsigned int memset::num#0
unsigned int memset::num#1
unsigned int memset::num#2
void *memset::return
void *memset::return#0
void *memset::return#1
void *memset::return#2
void *memset::return#3
void *memset::str
void *memset::str#0
void *memset::str#1
void *memset::str#2
void *memset::str#3
void *memset::str#4
void *memset::str#5
__loadstore volatile char sin_idx
__loadstore volatile char vstart
__loadstore volatile char vstop

Adding number conversion cast (unumber) 0 in memset::$0 = memset::num#1 > 0
Adding number conversion cast (unumber) 5 in *VERA_IRQLINE_L = 5
Adding number conversion cast (unumber) $e6 in irq_line::$4 = irq_line::l#2 != $e6
Adding number conversion cast (unumber) 0 in irq_line::$0 = cnt == 0
Adding number conversion cast (unumber) $18 in irq_line::$5 = irq_line::i#2 < $18
Adding number conversion cast (unumber) 0 in *VERA_DC_BORDER = 0
Adding number conversion cast (unumber) $17 in irq_line::$6 = irq_line::i1#2 < $17
Adding number conversion cast (unumber) 0 in memset::c#0 = 0
Adding number conversion cast (unumber) 2 in cnt = 2
Adding number conversion cast (unumber) $140/4 in irq_line::$7 = hstart <= $140/4
Adding number conversion cast (unumber) 8 in irq_line::$9 = irq_line::b#2 < 8
Adding number conversion cast (unumber) $d in irq_line::idx#1 = irq_line::idx#3 + $d
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast memset::dst#0 = (char *)memset::str#2
Inlining cast *VERA_IRQLINE_L = (unumber)5
Inlining cast *VERA_DC_BORDER = (unumber)0
Inlining cast memset::c#0 = (unumber)0
Inlining cast cnt = (unumber)2
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (void (**)()) 788
Simplifying constant pointer cast (char *) 40741
Simplifying constant pointer cast (char *) 40742
Simplifying constant pointer cast (char *) 40743
Simplifying constant pointer cast (char *) 40744
Simplifying constant pointer cast (char *) 40748
Simplifying constant pointer cast (char *) 40745
Simplifying constant pointer cast (char *) 40746
Simplifying constant pointer cast (char *) 40747
Simplifying constant pointer cast (char *) 40748
Simplifying constant integer cast 0
Simplifying constant pointer cast (unsigned int *) 788
Simplifying constant integer cast 5
Simplifying constant integer cast $e6
Simplifying constant integer cast 0
Simplifying constant integer cast $18
Simplifying constant integer cast 0
Simplifying constant integer cast $17
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 8
Simplifying constant integer cast $d
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 5
Finalized unsigned number type (char) $e6
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $18
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $17
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) $d
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inversing boolean not [2] memset::$1 = memset::num#1 <= 0 from [1] memset::$0 = memset::num#1 > 0
Inversing boolean not [44] irq_line::$1 = cnt != 0 from [43] irq_line::$0 = cnt == 0
Inversing boolean not [73] irq_line::$8 = hstart > (char)$140/4 from [72] irq_line::$7 = hstart <= (char)$140/4
Successful SSA optimization Pass2UnaryNotSimplification
Alias memset::return#0 = memset::str#1 memset::return#3 memset::return#1 
Alias memset::str#2 = memset::str#3 
Alias memset::num#1 = memset::num#2 
Alias memset::c#3 = memset::c#4 
Alias memset::c#1 = memset::c#2 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#4 = memset::str#5 
Alias isr_vsync#0 = isr_vsync#5 isr_vsync#1 
Alias irq_line::l#2 = irq_line::l#3 
Alias irq_line::i#2 = irq_line::i#3 
Alias irq_line::l#6 = irq_line::l#9 irq_line::l#8 
Alias irq_line::i1#2 = irq_line::i1#3 
Alias irq_line::l#4 = irq_line::l#7 irq_line::l#5 
Alias memset::num#0 = irq_line::$2 
Alias irq_line::idx#2 = irq_line::idx#4 
Alias irq_line::b#2 = irq_line::b#5 
Alias irq_line::i2#2 = irq_line::i2#3 
Alias irq_line::bar#1 = irq_line::bar#2 
Alias irq_line::idx#3 = irq_line::idx#6 irq_line::idx#5 
Alias irq_line::b#3 = irq_line::b#6 irq_line::b#4 
Alias isr_vsync#3 = isr_vsync#6 isr_vsync#9 isr_vsync#8 isr_vsync#7 isr_vsync#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values memset::num#1 memset::num#0
Identical Phi Values memset::str#2 memset::str#0
Identical Phi Values memset::c#3 memset::c#0
Identical Phi Values memset::end#1 memset::end#0
Identical Phi Values memset::str#4 memset::str#2
Identical Phi Values memset::c#1 memset::c#3
Identical Phi Values irq_line::l#6 irq_line::l#2
Identical Phi Values irq_line::l#4 irq_line::l#6
Identical Phi Values irq_line::bar#1 irq_line::bar#0
Identical Phi Values irq_line::idx#3 irq_line::idx#2
Identical Phi Values irq_line::b#3 irq_line::b#2
Identical Phi Values isr_vsync#3 isr_vsync#0
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values memset::return#0 memset::str#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition memset::$1 [2] if(memset::num#0<=0) goto memset::@1
Simple Condition memset::$3 [9] if(memset::dst#2!=memset::end#0) goto memset::@4
Simple Condition irq_line::$4 [30] if(irq_line::l#2!=$e6) goto irq_line::@3
Simple Condition irq_line::$1 [35] if(cnt!=0) goto irq_line::@1
Simple Condition irq_line::$5 [38] if(irq_line::i#2<$18) goto irq_line::@6
Simple Condition irq_line::$6 [44] if(irq_line::i1#2<$17) goto irq_line::@9
Simple Condition irq_line::$8 [58] if(hstart>(char)$140/4) goto irq_line::@1
Simple Condition irq_line::$9 [65] if(irq_line::b#2<8) goto irq_line::@14
Simple Condition irq_line::$12 [72] if(irq_line::i2#2<irq_line::$11) goto irq_line::@17
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [48] memset::num#0 = sizeof  BARS
Constant right-side identified [70] irq_line::$11 = sizeof  BAR
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant irq_line::l#0 = 0
Constant irq_line::i#0 = 0
Constant irq_line::i1#0 = 0
Constant memset::num#0 = sizeof BARS
Constant memset::str#0 = (void *)BARS
Constant memset::c#0 = 0
Constant irq_line::b#0 = 0
Constant irq_line::i2#0 = 0
Constant irq_line::$11 = sizeof BAR
Constant isr_vsync#2 = $314
Successful SSA optimization Pass2ConstantIdentification
Constant memset::$4 = (char *)memset::str#0
Constant memset::dst#0 = (char *)memset::str#0
Constant memset::return#2 = memset::str#0
Successful SSA optimization Pass2ConstantIdentification
Rewriting conditional comparison [58] if(hstart>(char)$140/4) goto irq_line::@1
Simplifying constant evaluating to zero (char)0/4 in [81] hstart = (char)0/4
Simplifying constant evaluating to zero (char)0/2 in [83] vstart = (char)0/2
Successful SSA optimization PassNSimplifyConstantZero
Removing call to empty/unused procedure [87] call cx16_init
Successful SSA optimization PassNEliminateUnusedConstructors
Eliminating variable isr_vsync#0 from unused block cx16_init
Removing unused procedure cx16_init
Removing unused procedure block cx16_init
Removing unused procedure block cx16_init::@return
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused constant memset::return#2
Successful SSA optimization PassNEliminateUnusedVars
Adding number conversion cast (unumber) (char)$140/4+1 in if(hstart>=(char)$140/4+1) goto irq_line::@1
Adding number conversion cast (unumber) 1 in if(hstart>=(unumber)(char)$140/4+1) goto irq_line::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (char)$140/4+(unumber)1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Resolving array sizeof() sizeof BARS
Resolving array sizeof() sizeof BAR
Successful SSA optimization PassNSizeOfSimplification
Constant right-side identified [1] memset::end#0 = memset::$4 + memset::num#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memset::end#0 = memset::$4+memset::num#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always false - eliminating [0] if(memset::num#0<=0) goto memset::@1
Successful SSA optimization Pass2ConstantIfs
Adding number conversion cast (unumber) $e6 in 
Adding number conversion cast (unumber) $20 in 
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $e6
Simplifying constant integer cast $20
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) $e6
Finalized unsigned number type (char) $20
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings memset::dst#0
Inlining constant with var siblings irq_line::l#0
Inlining constant with var siblings irq_line::i#0
Inlining constant with var siblings irq_line::i1#0
Inlining constant with var siblings irq_line::b#0
Inlining constant with var siblings irq_line::i2#0
Constant inlined irq_line::i#0 = 0
Constant inlined irq_line::$11 = $20*SIZEOF_CHAR
Constant inlined memset::$4 = (char *)memset::str#0
Constant inlined irq_line::l#0 = 0
Constant inlined irq_line::i2#0 = 0
Constant inlined irq_line::i1#0 = 0
Constant inlined memset::dst#0 = (char *)memset::str#0
Constant inlined irq_line::b#0 = 0
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) $a
Finalized unsigned number type (char) $10
Finalized unsigned number type (unsigned int) $100
Finalized unsigned number type (char) $e6
Finalized unsigned number type (char) $e6
Finalized unsigned number type (char) $20
Finalized unsigned number type (unsigned int) $140
Finalized unsigned number type (char) 4
Finalized unsigned number type (unsigned int) $280
Finalized unsigned number type (char) 4
Finalized unsigned number type (unsigned int) $1e0
Finalized unsigned number type (char) 2
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@2
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of __start::@3
Adding NOP phi() at start of irq_line::@1
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of memset
Adding NOP phi() at start of memset::@2
Adding NOP phi() at start of memset::@1
CALL GRAPH
Calls in [__start] to main:11 
Calls in [irq_line] to memset:31 

Created 7 initial phi equivalence classes
Coalesced [34] irq_line::idx#8 = irq_line::idx#0
Coalesced [44] irq_line::b#7 = irq_line::b#1
Coalesced [45] irq_line::idx#7 = irq_line::idx#1
Coalesced [48] irq_line::i2#4 = irq_line::i2#1
Coalesced [57] irq_line::l#10 = irq_line::l#1
Coalesced [59] irq_line::i1#4 = irq_line::i1#1
Coalesced [61] irq_line::i#4 = irq_line::i#1
Coalesced [77] memset::dst#4 = memset::dst#1
Coalesced down to 7 phi equivalence classes
Culled Empty Block label __start::@2
Culled Empty Block label __start::@3
Culled Empty Block label memset::@2
Culled Empty Block label memset::@1
Renumbering block memset::@3 to memset::@1
Renumbering block memset::@4 to memset::@2
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of irq_line::@1
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of memset

FINAL CONTROL FLOW GRAPH

void __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] BRAM = 0
  [2] BROM = 4
  [3] hstart = 0
  [4] hstop = (char)$280/4
  [5] vstart = 0
  [6] vstop = (char)$1e0/2
  [7] cnt = 2
  [8] sin_idx = $64
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [9] phi()
  [10] call main
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [11] return 
  to:@return

__interrupt(rom_min_cx16) void irq_line()
irq_line: scope:[irq_line]  from
  [12] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL
  [13] *VERA_DC_HSTART = hstart
  [14] *VERA_DC_HSTOP = hstop
  [15] *VERA_DC_VSTART = vstart
  [16] *VERA_DC_VSTOP = vstop
  [17] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL
  to:irq_line::@2
irq_line::@2: scope:[irq_line]  from irq_line irq_line::@10
  [18] irq_line::l#2 = phi( irq_line/0, irq_line::@10/irq_line::l#1 )
  [19] if(irq_line::l#2!=$e6) goto irq_line::@3
  to:irq_line::@4
irq_line::@4: scope:[irq_line]  from irq_line::@2
  [20] cnt = -- cnt
  [21] if(cnt!=0) goto irq_line::@1
  to:irq_line::@11
irq_line::@11: scope:[irq_line]  from irq_line::@4
  [22] cnt = 2
  [23] if(hstart>=(char)$140/4+1) goto irq_line::@1
  to:irq_line::@12
irq_line::@12: scope:[irq_line]  from irq_line::@11
  [24] hstart = ++ hstart
  [25] hstop = -- hstop
  [26] vstart = ++ vstart
  [27] vstop = -- vstop
  to:irq_line::@1
irq_line::@1: scope:[irq_line]  from irq_line::@11 irq_line::@12 irq_line::@4
  [28] phi()
  [29] call memset
  to:irq_line::@19
irq_line::@19: scope:[irq_line]  from irq_line::@1
  [30] irq_line::idx#0 = sin_idx
  [31] sin_idx = -- sin_idx
  to:irq_line::@13
irq_line::@13: scope:[irq_line]  from irq_line::@18 irq_line::@19
  [32] irq_line::idx#2 = phi( irq_line::@18/irq_line::idx#1, irq_line::@19/irq_line::idx#0 )
  [32] irq_line::b#2 = phi( irq_line::@18/irq_line::b#1, irq_line::@19/0 )
  [33] if(irq_line::b#2<8) goto irq_line::@14
  to:irq_line::@15
irq_line::@15: scope:[irq_line]  from irq_line::@13
  [34] *VERA_ISR = VERA_LINE
  to:irq_line::@return
irq_line::@return: scope:[irq_line]  from irq_line::@15
  [35] return 
  to:@return
irq_line::@14: scope:[irq_line]  from irq_line::@13
  [36] irq_line::bar#0 = BARS + SIN[irq_line::idx#2]
  to:irq_line::@16
irq_line::@16: scope:[irq_line]  from irq_line::@14 irq_line::@17
  [37] irq_line::i2#2 = phi( irq_line::@14/0, irq_line::@17/irq_line::i2#1 )
  [38] if(irq_line::i2#2<$20*SIZEOF_CHAR) goto irq_line::@17
  to:irq_line::@18
irq_line::@18: scope:[irq_line]  from irq_line::@16
  [39] irq_line::idx#1 = irq_line::idx#2 + $d
  [40] irq_line::b#1 = ++ irq_line::b#2
  to:irq_line::@13
irq_line::@17: scope:[irq_line]  from irq_line::@16
  [41] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2]
  [42] irq_line::i2#1 = ++ irq_line::i2#2
  to:irq_line::@16
irq_line::@3: scope:[irq_line]  from irq_line::@2
  [43] *VERA_DC_BORDER = BARS[irq_line::l#2]
  to:irq_line::@5
irq_line::@5: scope:[irq_line]  from irq_line::@3 irq_line::@6
  [44] irq_line::i#2 = phi( irq_line::@3/0, irq_line::@6/irq_line::i#1 )
  [45] if(irq_line::i#2<$18) goto irq_line::@6
  to:irq_line::@7
irq_line::@7: scope:[irq_line]  from irq_line::@5
  [46] *VERA_DC_BORDER = 0
  to:irq_line::@8
irq_line::@8: scope:[irq_line]  from irq_line::@7 irq_line::@9
  [47] irq_line::i1#2 = phi( irq_line::@7/0, irq_line::@9/irq_line::i1#1 )
  [48] if(irq_line::i1#2<$17) goto irq_line::@9
  to:irq_line::@10
irq_line::@10: scope:[irq_line]  from irq_line::@8
  asm { nop nop  }
  [50] irq_line::l#1 = ++ irq_line::l#2
  to:irq_line::@2
irq_line::@9: scope:[irq_line]  from irq_line::@8
  [51] irq_line::i1#1 = ++ irq_line::i1#2
  to:irq_line::@8
irq_line::@6: scope:[irq_line]  from irq_line::@5
  [52] irq_line::i#1 = ++ irq_line::i#2
  to:irq_line::@5

void main()
main: scope:[main]  from __start::@1
  [53] phi()
  to:main::SEI1
main::SEI1: scope:[main]  from main
  asm { sei  }
  to:main::@2
main::@2: scope:[main]  from main::SEI1
  [55] *KERNEL_IRQ = &irq_line
  [56] *VERA_IEN = VERA_LINE
  [57] *VERA_IRQLINE_L = 5
  to:main::CLI1
main::CLI1: scope:[main]  from main::@2
  asm { cli  }
  to:main::@1
main::@1: scope:[main]  from main::@1 main::CLI1
  [59] phi()
  to:main::@1

void * memset(void *str , char c , unsigned int num)
memset: scope:[memset]  from irq_line::@1
  [60] phi()
  to:memset::@1
memset::@1: scope:[memset]  from memset memset::@2
  [61] memset::dst#2 = phi( memset/(char *)memset::str#0, memset::@2/memset::dst#1 )
  [62] if(memset::dst#2!=memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset::@1
  [63] return 
  to:@return
memset::@2: scope:[memset]  from memset::@1
  [64] *memset::dst#2 = memset::c#0
  [65] memset::dst#1 = ++ memset::dst#2
  to:memset::@1


VARIABLE REGISTER WEIGHTS
__loadstore volatile char BRAM // !zp[-1]:0 20.0
__loadstore volatile char BROM // !zp[-1]:1 20.0
void __start()
__loadstore volatile char cnt // 0.5263157894736842
__loadstore volatile char hstart // 0.4545454545454546
__loadstore volatile char hstop // 0.34782608695652173
__interrupt(rom_min_cx16) void irq_line()
char irq_line::b
char irq_line::b#1 // 22.0
char irq_line::b#2 // 4.125
char *irq_line::bar
char *irq_line::bar#0 // 22.4
char irq_line::i
char irq_line::i#1 // 202.0
char irq_line::i#2 // 151.5
char irq_line::i1
char irq_line::i1#1 // 202.0
char irq_line::i1#2 // 151.5
char irq_line::i2
char irq_line::i2#1 // 202.0
char irq_line::i2#2 // 168.33333333333331
char irq_line::idx
char irq_line::idx#0 // 2.0
char irq_line::idx#1 // 11.0
char irq_line::idx#2 // 5.0
char irq_line::l
char irq_line::l#1 // 22.0
char irq_line::l#2 // 4.0
unsigned int isr_vsync
void main()
void * memset(void *str , char c , unsigned int num)
char memset::c
char *memset::dst
char *memset::dst#1 // 202.0
char *memset::dst#2 // 134.66666666666666
char *memset::end
unsigned int memset::num
void *memset::return
void *memset::str
__loadstore volatile char sin_idx // 0.27586206896551724
__loadstore volatile char vstart // 0.3333333333333333
__loadstore volatile char vstop // 0.32

Initial phi equivalence classes
[ irq_line::l#2 irq_line::l#1 ]
[ irq_line::b#2 irq_line::b#1 ]
[ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
[ irq_line::i2#2 irq_line::i2#1 ]
[ irq_line::i#2 irq_line::i#1 ]
[ irq_line::i1#2 irq_line::i1#1 ]
[ memset::dst#2 memset::dst#1 ]
Added variable BRAM to live range equivalence class [ BRAM ]
Added variable BROM to live range equivalence class [ BROM ]
Added variable hstart to live range equivalence class [ hstart ]
Added variable hstop to live range equivalence class [ hstop ]
Added variable vstart to live range equivalence class [ vstart ]
Added variable vstop to live range equivalence class [ vstop ]
Added variable cnt to live range equivalence class [ cnt ]
Added variable sin_idx to live range equivalence class [ sin_idx ]
Added variable irq_line::bar#0 to live range equivalence class [ irq_line::bar#0 ]
Complete equivalence classes
[ irq_line::l#2 irq_line::l#1 ]
[ irq_line::b#2 irq_line::b#1 ]
[ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
[ irq_line::i2#2 irq_line::i2#1 ]
[ irq_line::i#2 irq_line::i#1 ]
[ irq_line::i1#2 irq_line::i1#1 ]
[ memset::dst#2 memset::dst#1 ]
[ BRAM ]
[ BROM ]
[ hstart ]
[ hstop ]
[ vstart ]
[ vstop ]
[ cnt ]
[ sin_idx ]
[ irq_line::bar#0 ]
Allocated zp[1]:34 [ irq_line::i2#2 irq_line::i2#1 ]
Allocated zp[1]:35 [ irq_line::i#2 irq_line::i#1 ]
Allocated zp[1]:36 [ irq_line::i1#2 irq_line::i1#1 ]
Allocated zp[2]:37 [ memset::dst#2 memset::dst#1 ]
Allocated zp[1]:39 [ irq_line::b#2 irq_line::b#1 ]
Allocated zp[1]:40 [ irq_line::l#2 irq_line::l#1 ]
Allocated zp[2]:41 [ irq_line::bar#0 ]
Allocated zp[1]:43 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
Allocated zp[1]:44 [ cnt ]
Allocated zp[1]:45 [ hstart ]
Allocated zp[1]:46 [ hstop ]
Allocated zp[1]:47 [ vstart ]
Allocated zp[1]:48 [ vstop ]
Allocated zp[1]:49 [ sin_idx ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] BRAM = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] BROM = 4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] hstart = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] hstop = (char)$280/4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] vstart = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] vstop = (char)$1e0/2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [7] cnt = 2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] sin_idx = $64 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [12] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [13] *VERA_DC_HSTART = hstart [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [14] *VERA_DC_HSTOP = hstop [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [15] *VERA_DC_VSTART = vstart [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [16] *VERA_DC_VSTOP = vstop [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [17] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [21] if(cnt!=0) goto irq_line::@1 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [22] cnt = 2 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [23] if(hstart>=(char)$140/4+1) goto irq_line::@1 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [34] *VERA_ISR = VERA_LINE [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [36] irq_line::bar#0 = BARS + SIN[irq_line::idx#2] [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 ] (  [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:39 [ irq_line::b#2 irq_line::b#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:43 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
Statement [39] irq_line::idx#1 = irq_line::idx#2 + $d [ irq_line::b#2 irq_line::idx#1 ] (  [ irq_line::b#2 irq_line::idx#1 ] { }  ) always clobbers reg byte a 
Statement [41] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2] [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 irq_line::i2#2 ] (  [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 irq_line::i2#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:34 [ irq_line::i2#2 irq_line::i2#1 ]
Statement [43] *VERA_DC_BORDER = BARS[irq_line::l#2] [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] (  [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:40 [ irq_line::l#2 irq_line::l#1 ]
Statement [46] *VERA_DC_BORDER = 0 [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] (  [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] { }  ) always clobbers reg byte a 
Statement [55] *KERNEL_IRQ = &irq_line [ ] ( main:10 [ ] { }  ) always clobbers reg byte a 
Statement [56] *VERA_IEN = VERA_LINE [ ] ( main:10 [ ] { }  ) always clobbers reg byte a 
Statement [57] *VERA_IRQLINE_L = 5 [ ] ( main:10 [ ] { }  ) always clobbers reg byte a 
Statement [62] if(memset::dst#2!=memset::end#0) goto memset::@2 [ memset::dst#2 ] ( memset:29 [ sin_idx memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [64] *memset::dst#2 = memset::c#0 [ memset::dst#2 ] ( memset:29 [ sin_idx memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [1] BRAM = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] BROM = 4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] hstart = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] hstop = (char)$280/4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] vstart = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] vstop = (char)$1e0/2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [7] cnt = 2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] sin_idx = $64 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [12] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [13] *VERA_DC_HSTART = hstart [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [14] *VERA_DC_HSTOP = hstop [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [15] *VERA_DC_VSTART = vstart [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [16] *VERA_DC_VSTOP = vstop [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [17] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [21] if(cnt!=0) goto irq_line::@1 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [22] cnt = 2 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [23] if(hstart>=(char)$140/4+1) goto irq_line::@1 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [34] *VERA_ISR = VERA_LINE [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [36] irq_line::bar#0 = BARS + SIN[irq_line::idx#2] [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 ] (  [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 ] { }  ) always clobbers reg byte a 
Statement [39] irq_line::idx#1 = irq_line::idx#2 + $d [ irq_line::b#2 irq_line::idx#1 ] (  [ irq_line::b#2 irq_line::idx#1 ] { }  ) always clobbers reg byte a 
Statement [41] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2] [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 irq_line::i2#2 ] (  [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 irq_line::i2#2 ] { }  ) always clobbers reg byte a 
Statement [43] *VERA_DC_BORDER = BARS[irq_line::l#2] [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] (  [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] { }  ) always clobbers reg byte a 
Statement [46] *VERA_DC_BORDER = 0 [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] (  [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] { }  ) always clobbers reg byte a 
Statement [55] *KERNEL_IRQ = &irq_line [ ] ( main:10 [ ] { }  ) always clobbers reg byte a 
Statement [56] *VERA_IEN = VERA_LINE [ ] ( main:10 [ ] { }  ) always clobbers reg byte a 
Statement [57] *VERA_IRQLINE_L = 5 [ ] ( main:10 [ ] { }  ) always clobbers reg byte a 
Statement [62] if(memset::dst#2!=memset::end#0) goto memset::@2 [ memset::dst#2 ] ( memset:29 [ sin_idx memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [64] *memset::dst#2 = memset::c#0 [ memset::dst#2 ] ( memset:29 [ sin_idx memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Potential registers zp[1]:40 [ irq_line::l#2 irq_line::l#1 ] : zp[1]:40 , reg byte x , reg byte y , 
Potential registers zp[1]:39 [ irq_line::b#2 irq_line::b#1 ] : zp[1]:39 , reg byte x , reg byte y , 
Potential registers zp[1]:43 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ] : zp[1]:43 , reg byte x , reg byte y , 
Potential registers zp[1]:34 [ irq_line::i2#2 irq_line::i2#1 ] : zp[1]:34 , reg byte x , reg byte y , 
Potential registers zp[1]:35 [ irq_line::i#2 irq_line::i#1 ] : zp[1]:35 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:36 [ irq_line::i1#2 irq_line::i1#1 ] : zp[1]:36 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:37 [ memset::dst#2 memset::dst#1 ] : zp[2]:37 , 
Potential registers zp[1]:0 [ BRAM ] : zp[1]:0 , 
Potential registers zp[1]:1 [ BROM ] : zp[1]:1 , 
Potential registers zp[1]:45 [ hstart ] : zp[1]:45 , 
Potential registers zp[1]:46 [ hstop ] : zp[1]:46 , 
Potential registers zp[1]:47 [ vstart ] : zp[1]:47 , 
Potential registers zp[1]:48 [ vstop ] : zp[1]:48 , 
Potential registers zp[1]:44 [ cnt ] : zp[1]:44 , 
Potential registers zp[1]:49 [ sin_idx ] : zp[1]:49 , 
Potential registers zp[2]:41 [ irq_line::bar#0 ] : zp[2]:41 , 

REGISTER UPLIFT SCOPES
Uplift Scope [irq_line] 370.33: zp[1]:34 [ irq_line::i2#2 irq_line::i2#1 ] 353.5: zp[1]:35 [ irq_line::i#2 irq_line::i#1 ] 353.5: zp[1]:36 [ irq_line::i1#2 irq_line::i1#1 ] 26.12: zp[1]:39 [ irq_line::b#2 irq_line::b#1 ] 26: zp[1]:40 [ irq_line::l#2 irq_line::l#1 ] 22.4: zp[2]:41 [ irq_line::bar#0 ] 18: zp[1]:43 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ] 
Uplift Scope [memset] 336.67: zp[2]:37 [ memset::dst#2 memset::dst#1 ] 
Uplift Scope [] 20: zp[1]:0 [ BRAM ] 20: zp[1]:1 [ BROM ] 0.53: zp[1]:44 [ cnt ] 0.45: zp[1]:45 [ hstart ] 0.35: zp[1]:46 [ hstop ] 0.33: zp[1]:47 [ vstart ] 0.32: zp[1]:48 [ vstop ] 0.28: zp[1]:49 [ sin_idx ] 
Uplift Scope [MOS6522_VIA] 
Uplift Scope [RADIX] 
Uplift Scope [VERA_SPRITE] 
Uplift Scope [main] 
Uplift Scope [__start] 

Uplifting [irq_line] best 8211 combination reg byte y [ irq_line::i2#2 irq_line::i2#1 ] reg byte a [ irq_line::i#2 irq_line::i#1 ] reg byte a [ irq_line::i1#2 irq_line::i1#1 ] reg byte x [ irq_line::b#2 irq_line::b#1 ] zp[1]:40 [ irq_line::l#2 irq_line::l#1 ] zp[2]:41 [ irq_line::bar#0 ] zp[1]:43 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ] 
Limited combination testing to 100 combinations of 1296 possible.
Uplifting [memset] best 8211 combination zp[2]:37 [ memset::dst#2 memset::dst#1 ] 
Uplifting [] best 8211 combination zp[1]:0 [ BRAM ] zp[1]:1 [ BROM ] zp[1]:44 [ cnt ] zp[1]:45 [ hstart ] zp[1]:46 [ hstop ] zp[1]:47 [ vstart ] zp[1]:48 [ vstop ] zp[1]:49 [ sin_idx ] 
Uplifting [MOS6522_VIA] best 8211 combination 
Uplifting [RADIX] best 8211 combination 
Uplifting [VERA_SPRITE] best 8211 combination 
Uplifting [main] best 8211 combination 
Uplifting [__start] best 8211 combination 
Attempting to uplift remaining variables inzp[1]:40 [ irq_line::l#2 irq_line::l#1 ]
Uplifting [irq_line] best 8091 combination reg byte x [ irq_line::l#2 irq_line::l#1 ] 
Attempting to uplift remaining variables inzp[1]:0 [ BRAM ]
Uplifting [] best 8091 combination zp[1]:0 [ BRAM ] 
Attempting to uplift remaining variables inzp[1]:1 [ BROM ]
Uplifting [] best 8091 combination zp[1]:1 [ BROM ] 
Attempting to uplift remaining variables inzp[1]:43 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
Uplifting [irq_line] best 8091 combination zp[1]:43 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ] 
Attempting to uplift remaining variables inzp[1]:44 [ cnt ]
Uplifting [] best 8091 combination zp[1]:44 [ cnt ] 
Attempting to uplift remaining variables inzp[1]:45 [ hstart ]
Uplifting [] best 8091 combination zp[1]:45 [ hstart ] 
Attempting to uplift remaining variables inzp[1]:46 [ hstop ]
Uplifting [] best 8091 combination zp[1]:46 [ hstop ] 
Attempting to uplift remaining variables inzp[1]:47 [ vstart ]
Uplifting [] best 8091 combination zp[1]:47 [ vstart ] 
Attempting to uplift remaining variables inzp[1]:48 [ vstop ]
Uplifting [] best 8091 combination zp[1]:48 [ vstop ] 
Attempting to uplift remaining variables inzp[1]:49 [ sin_idx ]
Uplifting [] best 8091 combination zp[1]:49 [ sin_idx ] 
Coalescing zero page register [ zp[2]:41 [ irq_line::bar#0 ] ] with [ zp[2]:37 [ memset::dst#2 memset::dst#1 ] ]
Allocated (was zp[2]:41) zp[2]:34 [ irq_line::bar#0 memset::dst#2 memset::dst#1 ]
Allocated (was zp[1]:43) zp[1]:36 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
Allocated (was zp[1]:44) zp[1]:37 [ cnt ]
Allocated (was zp[1]:45) zp[1]:38 [ hstart ]
Allocated (was zp[1]:46) zp[1]:39 [ hstop ]
Allocated (was zp[1]:47) zp[1]:40 [ vstart ]
Allocated (was zp[1]:48) zp[1]:41 [ vstop ]
Allocated (was zp[1]:49) zp[1]:42 [ sin_idx ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Example program for the Commander X16
// Displays raster bars in the border
  // Upstart
.cpu _65c02
  // Commander X16 PRG executable file
.file [name="cx16-rasterbars.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)

  // Global Constants & labels
  .const VERA_DCSEL = 2
  .const VERA_LINE = 2
  .const isr_vsync = $314
  .const SIZEOF_CHAR = 1
  /// $0314	(RAM) IRQ vector - The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  /// $9F25	CTRL Control
  /// Bit 7: Reset
  /// Bit 1: DCSEL
  /// Bit 2: ADDRSEL
  .label VERA_CTRL = $9f25
  /// $9F26	IEN		Interrupt Enable
  /// Bit 7: IRQ line (8)
  /// Bit 3: AFLOW
  /// Bit 2: SPRCOL
  /// Bit 1: LINE
  /// Bit 0: VSYNC
  .label VERA_IEN = $9f26
  /// $9F27	ISR     Interrupt Status
  /// Interrupts will be generated for the interrupt sources set in the lower 4 bits of IEN. ISR will indicate the interrupts that have occurred.
  /// Writing a 1 to one of the lower 3 bits in ISR will clear that interrupt status. AFLOW can only be cleared by filling the audio FIFO for at least 1/4.
  /// Bit 4-7: Sprite Collisions. This field indicates which groups of sprites have collided.
  /// Bit 3: AFLOW
  /// Bit 2: SPRCOL
  /// Bit 1: LINE
  /// Bit 0: VSYNC
  .label VERA_ISR = $9f27
  /// $9F28	IRQLINE_L	IRQ line (7:0)
  /// IRQ_LINE specifies at which line the LINE interrupt will be generated.
  /// Note that bit 8 of this value is present in the IEN register.
  /// For interlaced modes the interrupt will be generated each field and the bit 0 of IRQ_LINE is ignored.
  .label VERA_IRQLINE_L = $9f28
  /// $9F2C	DC_BORDER (DCSEL=0)	Border Color
  .label VERA_DC_BORDER = $9f2c
  /// $9F29	DC_HSTART (DCSEL=1)	Active Display H-Start (9:2)
  .label VERA_DC_HSTART = $9f29
  /// $9F2A	DC_HSTOP (DCSEL=1)	Active Display H-Stop (9:2)
  .label VERA_DC_HSTOP = $9f2a
  /// $9F2B	DC_VSTART (DCSEL=1)	Active Display V-Start (8:1)
  .label VERA_DC_VSTART = $9f2b
  /// $9F2C	DC_VSTOP (DCSEL=1)	Active Display V-Stop (8:1)
  .label VERA_DC_VSTOP = $9f2c
  .label BRAM = 0
  .label BROM = 1
  // The horizontal start
  .label hstart = $26
  // The horizontal stop
  .label hstop = $27
  // The vertical start
  .label vstart = $28
  // The vertical stop
  .label vstop = $29
  // The countdown
  .label cnt = $25
  // The sin idx
  .label sin_idx = $2a
.segment Code
  // __start
__start: {
    jmp __init1
    // __start::__init1
  __init1:
    // [1] BRAM = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z BRAM
    // [2] BROM = 4 -- vbuz1=vbuc1 
    lda #4
    sta.z BROM
    // [3] hstart = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z hstart
    // [4] hstop = (char)$280/4 -- vbuz1=vbuc1 
    lda #$280/4
    sta.z hstop
    // [5] vstart = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z vstart
    // [6] vstop = (char)$1e0/2 -- vbuz1=vbuc1 
    lda #$1e0/2
    sta.z vstop
    // [7] cnt = 2 -- vbuz1=vbuc1 
    lda #2
    sta.z cnt
    // [8] sin_idx = $64 -- vbuz1=vbuc1 
    lda #$64
    sta.z sin_idx
    // [9] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
  __b1_from___init1:
    jmp __b1
    // __start::@1
  __b1:
    // [10] call main
    // [53] phi from __start::@1 to main [phi:__start::@1->main]
  main_from___b1:
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [11] return 
    rts
}
  // irq_line
// LINE Interrupt Routine
irq_line: {
    .label idx = $24
    .label bar = $22
    // interrupt(isr_rom_min_cx16_entry) -- isr_rom_min_cx16_entry 
    // [12] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Update the border
    lda #VERA_DCSEL
    ora VERA_CTRL
    sta VERA_CTRL
    // [13] *VERA_DC_HSTART = hstart -- _deref_pbuc1=vbuz1 
    lda.z hstart
    sta VERA_DC_HSTART
    // [14] *VERA_DC_HSTOP = hstop -- _deref_pbuc1=vbuz1 
    lda.z hstop
    sta VERA_DC_HSTOP
    // [15] *VERA_DC_VSTART = vstart -- _deref_pbuc1=vbuz1 
    lda.z vstart
    sta VERA_DC_VSTART
    // [16] *VERA_DC_VSTOP = vstop -- _deref_pbuc1=vbuz1 
    lda.z vstop
    sta VERA_DC_VSTOP
    // [17] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Show color raster bars in the border
    lda #VERA_DCSEL^$ff
    and VERA_CTRL
    sta VERA_CTRL
    // [18] phi from irq_line to irq_line::@2 [phi:irq_line->irq_line::@2]
  __b2_from_irq_line:
    // [18] phi irq_line::l#2 = 0 [phi:irq_line->irq_line::@2#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b2
    // irq_line::@2
  __b2:
    // [19] if(irq_line::l#2!=$e6) goto irq_line::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$e6
    bne __b3
    jmp __b4
    // irq_line::@4
  __b4:
    // [20] cnt = -- cnt -- vbuz1=_dec_vbuz1 
    dec.z cnt
    // [21] if(cnt!=0) goto irq_line::@1 -- vbuz1_neq_0_then_la1 
    lda.z cnt
    bne __b1_from___b4
    jmp __b11
    // irq_line::@11
  __b11:
    // [22] cnt = 2 -- vbuz1=vbuc1 
    lda #2
    sta.z cnt
    // [23] if(hstart>=(char)$140/4+1) goto irq_line::@1 -- vbuz1_ge_vbuc1_then_la1 
    lda.z hstart
    cmp #$140/4+1
    bcs __b1_from___b11
    jmp __b12
    // irq_line::@12
  __b12:
    // [24] hstart = ++ hstart -- vbuz1=_inc_vbuz1 
    inc.z hstart
    // [25] hstop = -- hstop -- vbuz1=_dec_vbuz1 
    dec.z hstop
    // [26] vstart = ++ vstart -- vbuz1=_inc_vbuz1 
    inc.z vstart
    // [27] vstop = -- vstop -- vbuz1=_dec_vbuz1 
    dec.z vstop
    // [28] phi from irq_line::@11 irq_line::@12 irq_line::@4 to irq_line::@1 [phi:irq_line::@11/irq_line::@12/irq_line::@4->irq_line::@1]
  __b1_from___b11:
  __b1_from___b12:
  __b1_from___b4:
    jmp __b1
    // irq_line::@1
  __b1:
    // [29] call memset
  // Animate the bars
    // [60] phi from irq_line::@1 to memset [phi:irq_line::@1->memset]
  memset_from___b1:
    jsr memset
    jmp __b19
    // irq_line::@19
  __b19:
    // [30] irq_line::idx#0 = sin_idx -- vbuz1=vbuz2 
    lda.z sin_idx
    sta.z idx
    // [31] sin_idx = -- sin_idx -- vbuz1=_dec_vbuz1 
    dec.z sin_idx
    // [32] phi from irq_line::@19 to irq_line::@13 [phi:irq_line::@19->irq_line::@13]
  __b13_from___b19:
    // [32] phi irq_line::idx#2 = irq_line::idx#0 [phi:irq_line::@19->irq_line::@13#0] -- register_copy 
    // [32] phi irq_line::b#2 = 0 [phi:irq_line::@19->irq_line::@13#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b13
    // irq_line::@13
  __b13:
    // [33] if(irq_line::b#2<8) goto irq_line::@14 -- vbuxx_lt_vbuc1_then_la1 
    cpx #8
    bcc __b14
    jmp __b15
    // irq_line::@15
  __b15:
    // [34] *VERA_ISR = VERA_LINE -- _deref_pbuc1=vbuc2 
    // Reset the LINE interrupt
    lda #VERA_LINE
    sta VERA_ISR
    jmp __breturn
    // irq_line::@return
  __breturn:
    // [35] return 
    // interrupt(isr_rom_min_cx16_exit) -- isr_rom_min_cx16_exit 
    jmp $e049
    // irq_line::@14
  __b14:
    // [36] irq_line::bar#0 = BARS + SIN[irq_line::idx#2] -- pbuz1=pbuc1_plus_pbuc2_derefidx_vbuz2 
    ldy.z idx
    lda SIN,y
    clc
    adc #<BARS
    sta.z bar
    lda #>BARS
    adc #0
    sta.z bar+1
    // [37] phi from irq_line::@14 to irq_line::@16 [phi:irq_line::@14->irq_line::@16]
  __b16_from___b14:
    // [37] phi irq_line::i2#2 = 0 [phi:irq_line::@14->irq_line::@16#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b16
    // irq_line::@16
  __b16:
    // [38] if(irq_line::i2#2<$20*SIZEOF_CHAR) goto irq_line::@17 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$20*SIZEOF_CHAR
    bcc __b17
    jmp __b18
    // irq_line::@18
  __b18:
    // [39] irq_line::idx#1 = irq_line::idx#2 + $d -- vbuz1=vbuz1_plus_vbuc1 
    lda #$d
    clc
    adc.z idx
    sta.z idx
    // [40] irq_line::b#1 = ++ irq_line::b#2 -- vbuxx=_inc_vbuxx 
    inx
    // [32] phi from irq_line::@18 to irq_line::@13 [phi:irq_line::@18->irq_line::@13]
  __b13_from___b18:
    // [32] phi irq_line::idx#2 = irq_line::idx#1 [phi:irq_line::@18->irq_line::@13#0] -- register_copy 
    // [32] phi irq_line::b#2 = irq_line::b#1 [phi:irq_line::@18->irq_line::@13#1] -- register_copy 
    jmp __b13
    // irq_line::@17
  __b17:
    // [41] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2] -- pbuz1_derefidx_vbuyy=pbuc1_derefidx_vbuyy 
    lda BAR,y
    sta (bar),y
    // [42] irq_line::i2#1 = ++ irq_line::i2#2 -- vbuyy=_inc_vbuyy 
    iny
    // [37] phi from irq_line::@17 to irq_line::@16 [phi:irq_line::@17->irq_line::@16]
  __b16_from___b17:
    // [37] phi irq_line::i2#2 = irq_line::i2#1 [phi:irq_line::@17->irq_line::@16#0] -- register_copy 
    jmp __b16
    // irq_line::@3
  __b3:
    // [43] *VERA_DC_BORDER = BARS[irq_line::l#2] -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda BARS,x
    sta VERA_DC_BORDER
    // [44] phi from irq_line::@3 to irq_line::@5 [phi:irq_line::@3->irq_line::@5]
  __b5_from___b3:
    // [44] phi irq_line::i#2 = 0 [phi:irq_line::@3->irq_line::@5#0] -- vbuaa=vbuc1 
    lda #0
    jmp __b5
    // irq_line::@5
  __b5:
    // [45] if(irq_line::i#2<$18) goto irq_line::@6 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$18
    bcc __b6
    jmp __b7
    // irq_line::@7
  __b7:
    // [46] *VERA_DC_BORDER = 0 -- _deref_pbuc1=vbuc2 
    // Wait exactly long enough to go to the next raster line
    lda #0
    sta VERA_DC_BORDER
    // [47] phi from irq_line::@7 to irq_line::@8 [phi:irq_line::@7->irq_line::@8]
  __b8_from___b7:
    // [47] phi irq_line::i1#2 = 0 [phi:irq_line::@7->irq_line::@8#0] -- vbuaa=vbuc1 
    lda #0
    jmp __b8
    // irq_line::@8
  __b8:
    // [48] if(irq_line::i1#2<$17) goto irq_line::@9 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$17
    bcc __b9
    jmp __b10
    // irq_line::@10
  __b10:
    // asm { nop nop  }
    // Wait exactly long enough to go to the next raster line
    nop
    nop
    // [50] irq_line::l#1 = ++ irq_line::l#2 -- vbuxx=_inc_vbuxx 
    inx
    // [18] phi from irq_line::@10 to irq_line::@2 [phi:irq_line::@10->irq_line::@2]
  __b2_from___b10:
    // [18] phi irq_line::l#2 = irq_line::l#1 [phi:irq_line::@10->irq_line::@2#0] -- register_copy 
    jmp __b2
    // irq_line::@9
  __b9:
    // [51] irq_line::i1#1 = ++ irq_line::i1#2 -- vbuaa=_inc_vbuaa 
    inc
    // [47] phi from irq_line::@9 to irq_line::@8 [phi:irq_line::@9->irq_line::@8]
  __b8_from___b9:
    // [47] phi irq_line::i1#2 = irq_line::i1#1 [phi:irq_line::@9->irq_line::@8#0] -- register_copy 
    jmp __b8
    // irq_line::@6
  __b6:
    // [52] irq_line::i#1 = ++ irq_line::i#2 -- vbuaa=_inc_vbuaa 
    inc
    // [44] phi from irq_line::@6 to irq_line::@5 [phi:irq_line::@6->irq_line::@5]
  __b5_from___b6:
    // [44] phi irq_line::i#2 = irq_line::i#1 [phi:irq_line::@6->irq_line::@5#0] -- register_copy 
    jmp __b5
}
  // main
main: {
    jmp SEI1
    // main::SEI1
  SEI1:
    // asm { sei  }
    sei
    jmp __b2
    // main::@2
  __b2:
    // [55] *KERNEL_IRQ = &irq_line -- _deref_qprc1=pprc2 
    lda #<irq_line
    sta KERNEL_IRQ
    lda #>irq_line
    sta KERNEL_IRQ+1
    // [56] *VERA_IEN = VERA_LINE -- _deref_pbuc1=vbuc2 
    lda #VERA_LINE
    sta VERA_IEN
    // [57] *VERA_IRQLINE_L = 5 -- _deref_pbuc1=vbuc2 
    lda #5
    sta VERA_IRQLINE_L
    jmp CLI1
    // main::CLI1
  CLI1:
    // asm { cli  }
    cli
    // [59] phi from main::@1 main::CLI1 to main::@1 [phi:main::@1/main::CLI1->main::@1]
  __b1_from___b1:
  __b1_from_CLI1:
    jmp __b1
    // main::@1
  __b1:
    jmp __b1_from___b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// void * memset(void *str, char c, unsigned int num)
memset: {
    .const num = $e6*SIZEOF_CHAR
    .const c = 0
    .label str = BARS
    .label end = str+num
    .label dst = $22
    // [61] phi from memset to memset::@1 [phi:memset->memset::@1]
  __b1_from_memset:
    // [61] phi memset::dst#2 = (char *)memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    jmp __b1
    // memset::@1
  __b1:
    // [62] if(memset::dst#2!=memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    jmp __breturn
    // memset::@return
  __breturn:
    // [63] return 
    rts
    // memset::@2
  __b2:
    // [64] *memset::dst#2 = memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // [65] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [61] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
  __b1_from___b2:
    // [61] phi memset::dst#2 = memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
.segment Data
  .align $100
SIN:
.fill 256, 99+99*sin(i*2*PI/256)

  .align $100
  BARS: .fill $e6, 0
  .align $100
  BAR: .byte $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1a, $1b, $1c, $1d, $1e, $1f, $1f, $1e, $1d, $1c, $1b, $1a, $19, $18, $17, $16, $15, $14, $13, $12, $11, $10

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __init1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b1
Removing instruction jmp __b19
Removing instruction jmp __b13
Removing instruction jmp __b15
Removing instruction jmp __breturn
Removing instruction jmp __b16
Removing instruction jmp __b18
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b10
Removing instruction jmp SEI1
Removing instruction jmp __b2
Removing instruction jmp CLI1
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b4 with __b1
Replacing label __b1_from___b11 with __b1
Replacing label __b1_from___b1 with __b1
Removing instruction __b1_from___init1:
Removing instruction main_from___b1:
Removing instruction __b1_from___b11:
Removing instruction __b1_from___b12:
Removing instruction __b1_from___b4:
Removing instruction __b1_from___b1:
Removing instruction __b1_from_CLI1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __init1:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b2_from_irq_line:
Removing instruction __b4:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction memset_from___b1:
Removing instruction __b19:
Removing instruction __b13_from___b19:
Removing instruction __b15:
Removing instruction __breturn:
Removing instruction __b16_from___b14:
Removing instruction __b18:
Removing instruction __b13_from___b18:
Removing instruction __b16_from___b17:
Removing instruction __b5_from___b3:
Removing instruction __b7:
Removing instruction __b8_from___b7:
Removing instruction __b10:
Removing instruction __b2_from___b10:
Removing instruction __b8_from___b9:
Removing instruction __b5_from___b6:
Removing instruction SEI1:
Removing instruction __b2:
Removing instruction CLI1:
Removing instruction __b1_from_memset:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination

FINAL SYMBOL TABLE
__constant char BAR[$20] = { $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1a, $1b, $1c, $1d, $1e, $1f, $1f, $1e, $1d, $1c, $1b, $1a, $19, $18, $17, $16, $15, $14, $13, $12, $11, $10 }
__constant char BARS[$e6] = { fill( $e6, 0) }
__loadstore volatile char BRAM // !zp[-1]:0 zp[1]:0 20.0
__loadstore volatile char BROM // !zp[-1]:1 zp[1]:1 20.0
__constant void (** const KERNEL_IRQ)() = (void (**)()) 788
__constant char RADIX::BINARY = 2
__constant char RADIX::DECIMAL = $a
__constant char RADIX::HEXADECIMAL = $10
__constant char RADIX::OCTAL = 8
__constant char SIN[$100] = kickasm {{ .fill 256, 99+99*sin(i*2*PI/256)
 }}
__constant char SIZEOF_CHAR = 1
__constant char * const VERA_CTRL = (char *) 40741
__constant const char VERA_DCSEL = 2
__constant char * const VERA_DC_BORDER = (char *) 40748
__constant char * const VERA_DC_HSTART = (char *) 40745
__constant char * const VERA_DC_HSTOP = (char *) 40746
__constant char * const VERA_DC_VSTART = (char *) 40747
__constant char * const VERA_DC_VSTOP = (char *) 40748
__constant char * const VERA_IEN = (char *) 40742
__constant char * const VERA_IRQLINE_L = (char *) 40744
__constant char * const VERA_ISR = (char *) 40743
__constant const char VERA_LINE = 2
void __start()
__loadstore volatile char cnt // zp[1]:37 0.5263157894736842
__loadstore volatile char hstart // zp[1]:38 0.4545454545454546
__loadstore volatile char hstop // zp[1]:39 0.34782608695652173
__interrupt(rom_min_cx16) void irq_line()
char irq_line::b
char irq_line::b#1 // reg byte x 22.0
char irq_line::b#2 // reg byte x 4.125
char *irq_line::bar
char *irq_line::bar#0 // bar zp[2]:34 22.4
char irq_line::i
char irq_line::i#1 // reg byte a 202.0
char irq_line::i#2 // reg byte a 151.5
char irq_line::i1
char irq_line::i1#1 // reg byte a 202.0
char irq_line::i1#2 // reg byte a 151.5
char irq_line::i2
char irq_line::i2#1 // reg byte y 202.0
char irq_line::i2#2 // reg byte y 168.33333333333331
char irq_line::idx
char irq_line::idx#0 // idx zp[1]:36 2.0
char irq_line::idx#1 // idx zp[1]:36 11.0
char irq_line::idx#2 // idx zp[1]:36 5.0
char irq_line::l
char irq_line::l#1 // reg byte x 22.0
char irq_line::l#2 // reg byte x 4.0
unsigned int isr_vsync
__constant unsigned int isr_vsync#2 = $314 // isr_vsync
void main()
void * memset(void *str , char c , unsigned int num)
char memset::c
__constant char memset::c#0 = 0 // c
char *memset::dst
char *memset::dst#1 // dst zp[2]:34 202.0
char *memset::dst#2 // dst zp[2]:34 134.66666666666666
char *memset::end
__constant char *memset::end#0 = (char *)memset::str#0+memset::num#0 // end
unsigned int memset::num
__constant unsigned int memset::num#0 = $e6*SIZEOF_CHAR // num
void *memset::return
void *memset::str
__constant void *memset::str#0 = (void *)BARS // str
__loadstore volatile char sin_idx // zp[1]:42 0.27586206896551724
__loadstore volatile char vstart // zp[1]:40 0.3333333333333333
__loadstore volatile char vstop // zp[1]:41 0.32

reg byte x [ irq_line::l#2 irq_line::l#1 ]
reg byte x [ irq_line::b#2 irq_line::b#1 ]
zp[1]:36 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
reg byte y [ irq_line::i2#2 irq_line::i2#1 ]
reg byte a [ irq_line::i#2 irq_line::i#1 ]
reg byte a [ irq_line::i1#2 irq_line::i1#1 ]
zp[1]:0 [ BRAM ]
zp[1]:1 [ BROM ]
zp[1]:38 [ hstart ]
zp[1]:39 [ hstop ]
zp[1]:40 [ vstart ]
zp[1]:41 [ vstop ]
zp[1]:37 [ cnt ]
zp[1]:42 [ sin_idx ]
zp[2]:34 [ irq_line::bar#0 memset::dst#2 memset::dst#1 ]


FINAL ASSEMBLER
Score: 5794

  // File Comments
// Example program for the Commander X16
// Displays raster bars in the border
  // Upstart
.cpu _65c02
  // Commander X16 PRG executable file
.file [name="cx16-rasterbars.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)

  // Global Constants & labels
  .const VERA_DCSEL = 2
  .const VERA_LINE = 2
  .const isr_vsync = $314
  .const SIZEOF_CHAR = 1
  /// $0314	(RAM) IRQ vector - The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  /// $9F25	CTRL Control
  /// Bit 7: Reset
  /// Bit 1: DCSEL
  /// Bit 2: ADDRSEL
  .label VERA_CTRL = $9f25
  /// $9F26	IEN		Interrupt Enable
  /// Bit 7: IRQ line (8)
  /// Bit 3: AFLOW
  /// Bit 2: SPRCOL
  /// Bit 1: LINE
  /// Bit 0: VSYNC
  .label VERA_IEN = $9f26
  /// $9F27	ISR     Interrupt Status
  /// Interrupts will be generated for the interrupt sources set in the lower 4 bits of IEN. ISR will indicate the interrupts that have occurred.
  /// Writing a 1 to one of the lower 3 bits in ISR will clear that interrupt status. AFLOW can only be cleared by filling the audio FIFO for at least 1/4.
  /// Bit 4-7: Sprite Collisions. This field indicates which groups of sprites have collided.
  /// Bit 3: AFLOW
  /// Bit 2: SPRCOL
  /// Bit 1: LINE
  /// Bit 0: VSYNC
  .label VERA_ISR = $9f27
  /// $9F28	IRQLINE_L	IRQ line (7:0)
  /// IRQ_LINE specifies at which line the LINE interrupt will be generated.
  /// Note that bit 8 of this value is present in the IEN register.
  /// For interlaced modes the interrupt will be generated each field and the bit 0 of IRQ_LINE is ignored.
  .label VERA_IRQLINE_L = $9f28
  /// $9F2C	DC_BORDER (DCSEL=0)	Border Color
  .label VERA_DC_BORDER = $9f2c
  /// $9F29	DC_HSTART (DCSEL=1)	Active Display H-Start (9:2)
  .label VERA_DC_HSTART = $9f29
  /// $9F2A	DC_HSTOP (DCSEL=1)	Active Display H-Stop (9:2)
  .label VERA_DC_HSTOP = $9f2a
  /// $9F2B	DC_VSTART (DCSEL=1)	Active Display V-Start (8:1)
  .label VERA_DC_VSTART = $9f2b
  /// $9F2C	DC_VSTOP (DCSEL=1)	Active Display V-Stop (8:1)
  .label VERA_DC_VSTOP = $9f2c
  .label BRAM = 0
  .label BROM = 1
  // The horizontal start
  .label hstart = $26
  // The horizontal stop
  .label hstop = $27
  // The vertical start
  .label vstart = $28
  // The vertical stop
  .label vstop = $29
  // The countdown
  .label cnt = $25
  // The sin idx
  .label sin_idx = $2a
.segment Code
  // __start
__start: {
    // __start::__init1
    // __export volatile __address(0x00) unsigned char BRAM = 0
    // [1] BRAM = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z BRAM
    // __export volatile __address(0x01) unsigned char BROM = 4
    // [2] BROM = 4 -- vbuz1=vbuc1 
    lda #4
    sta.z BROM
    // volatile char hstart = 0/4
    // [3] hstart = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z hstart
    // volatile char hstop = 640/4
    // [4] hstop = (char)$280/4 -- vbuz1=vbuc1 
    lda #$280/4
    sta.z hstop
    // volatile char vstart = 0/2
    // [5] vstart = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z vstart
    // volatile char vstop = 480/2
    // [6] vstop = (char)$1e0/2 -- vbuz1=vbuc1 
    lda #$1e0/2
    sta.z vstop
    // volatile char cnt = 2
    // [7] cnt = 2 -- vbuz1=vbuc1 
    lda #2
    sta.z cnt
    // volatile char sin_idx = 100
    // [8] sin_idx = $64 -- vbuz1=vbuc1 
    lda #$64
    sta.z sin_idx
    // [9] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
    // __start::@1
    // [10] call main
    // [53] phi from __start::@1 to main [phi:__start::@1->main]
    jsr main
    // __start::@return
    // [11] return 
    rts
}
  // irq_line
// LINE Interrupt Routine
irq_line: {
    .label idx = $24
    .label bar = $22
    // interrupt(isr_rom_min_cx16_entry) -- isr_rom_min_cx16_entry 
    // *VERA_CTRL |= VERA_DCSEL
    // [12] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Update the border
    lda #VERA_DCSEL
    ora VERA_CTRL
    sta VERA_CTRL
    // *VERA_DC_HSTART = hstart
    // [13] *VERA_DC_HSTART = hstart -- _deref_pbuc1=vbuz1 
    lda.z hstart
    sta VERA_DC_HSTART
    // *VERA_DC_HSTOP = hstop
    // [14] *VERA_DC_HSTOP = hstop -- _deref_pbuc1=vbuz1 
    lda.z hstop
    sta VERA_DC_HSTOP
    // *VERA_DC_VSTART = vstart
    // [15] *VERA_DC_VSTART = vstart -- _deref_pbuc1=vbuz1 
    lda.z vstart
    sta VERA_DC_VSTART
    // *VERA_DC_VSTOP = vstop
    // [16] *VERA_DC_VSTOP = vstop -- _deref_pbuc1=vbuz1 
    lda.z vstop
    sta VERA_DC_VSTOP
    // *VERA_CTRL &= ~VERA_DCSEL
    // [17] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Show color raster bars in the border
    lda #VERA_DCSEL^$ff
    and VERA_CTRL
    sta VERA_CTRL
    // [18] phi from irq_line to irq_line::@2 [phi:irq_line->irq_line::@2]
    // [18] phi irq_line::l#2 = 0 [phi:irq_line->irq_line::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // irq_line::@2
  __b2:
    // for(char l=0;l!=230;l++)
    // [19] if(irq_line::l#2!=$e6) goto irq_line::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$e6
    bne __b3
    // irq_line::@4
    // if(--cnt==0)
    // [20] cnt = -- cnt -- vbuz1=_dec_vbuz1 
    dec.z cnt
    // [21] if(cnt!=0) goto irq_line::@1 -- vbuz1_neq_0_then_la1 
    lda.z cnt
    bne __b1
    // irq_line::@11
    // cnt = 2
    // [22] cnt = 2 -- vbuz1=vbuc1 
    lda #2
    sta.z cnt
    // if(hstart<=320/4)
    // [23] if(hstart>=(char)$140/4+1) goto irq_line::@1 -- vbuz1_ge_vbuc1_then_la1 
    lda.z hstart
    cmp #$140/4+1
    bcs __b1
    // irq_line::@12
    // hstart++;
    // [24] hstart = ++ hstart -- vbuz1=_inc_vbuz1 
    inc.z hstart
    // hstop--;
    // [25] hstop = -- hstop -- vbuz1=_dec_vbuz1 
    dec.z hstop
    // vstart++;
    // [26] vstart = ++ vstart -- vbuz1=_inc_vbuz1 
    inc.z vstart
    // vstop--;
    // [27] vstop = -- vstop -- vbuz1=_dec_vbuz1 
    dec.z vstop
    // [28] phi from irq_line::@11 irq_line::@12 irq_line::@4 to irq_line::@1 [phi:irq_line::@11/irq_line::@12/irq_line::@4->irq_line::@1]
    // irq_line::@1
  __b1:
    // memset(BARS, 0, sizeof(BARS))
    // [29] call memset
  // Animate the bars
    // [60] phi from irq_line::@1 to memset [phi:irq_line::@1->memset]
    jsr memset
    // irq_line::@19
    // char idx = sin_idx--
    // [30] irq_line::idx#0 = sin_idx -- vbuz1=vbuz2 
    lda.z sin_idx
    sta.z idx
    // [31] sin_idx = -- sin_idx -- vbuz1=_dec_vbuz1 
    dec.z sin_idx
    // [32] phi from irq_line::@19 to irq_line::@13 [phi:irq_line::@19->irq_line::@13]
    // [32] phi irq_line::idx#2 = irq_line::idx#0 [phi:irq_line::@19->irq_line::@13#0] -- register_copy 
    // [32] phi irq_line::b#2 = 0 [phi:irq_line::@19->irq_line::@13#1] -- vbuxx=vbuc1 
    ldx #0
    // irq_line::@13
  __b13:
    // for(char b=0;b<8;b++)
    // [33] if(irq_line::b#2<8) goto irq_line::@14 -- vbuxx_lt_vbuc1_then_la1 
    cpx #8
    bcc __b14
    // irq_line::@15
    // *VERA_ISR = VERA_LINE
    // [34] *VERA_ISR = VERA_LINE -- _deref_pbuc1=vbuc2 
    // Reset the LINE interrupt
    lda #VERA_LINE
    sta VERA_ISR
    // irq_line::@return
    // }
    // [35] return 
    // interrupt(isr_rom_min_cx16_exit) -- isr_rom_min_cx16_exit 
    jmp $e049
    // irq_line::@14
  __b14:
    // char * bar = BARS + SIN[idx]
    // [36] irq_line::bar#0 = BARS + SIN[irq_line::idx#2] -- pbuz1=pbuc1_plus_pbuc2_derefidx_vbuz2 
    ldy.z idx
    lda SIN,y
    clc
    adc #<BARS
    sta.z bar
    lda #>BARS
    adc #0
    sta.z bar+1
    // [37] phi from irq_line::@14 to irq_line::@16 [phi:irq_line::@14->irq_line::@16]
    // [37] phi irq_line::i2#2 = 0 [phi:irq_line::@14->irq_line::@16#0] -- vbuyy=vbuc1 
    ldy #0
    // irq_line::@16
  __b16:
    // for(char i=0;i<sizeof(BAR);i++)
    // [38] if(irq_line::i2#2<$20*SIZEOF_CHAR) goto irq_line::@17 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$20*SIZEOF_CHAR
    bcc __b17
    // irq_line::@18
    // idx += 13
    // [39] irq_line::idx#1 = irq_line::idx#2 + $d -- vbuz1=vbuz1_plus_vbuc1 
    lda #$d
    clc
    adc.z idx
    sta.z idx
    // for(char b=0;b<8;b++)
    // [40] irq_line::b#1 = ++ irq_line::b#2 -- vbuxx=_inc_vbuxx 
    inx
    // [32] phi from irq_line::@18 to irq_line::@13 [phi:irq_line::@18->irq_line::@13]
    // [32] phi irq_line::idx#2 = irq_line::idx#1 [phi:irq_line::@18->irq_line::@13#0] -- register_copy 
    // [32] phi irq_line::b#2 = irq_line::b#1 [phi:irq_line::@18->irq_line::@13#1] -- register_copy 
    jmp __b13
    // irq_line::@17
  __b17:
    // bar[i] = BAR[i]
    // [41] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2] -- pbuz1_derefidx_vbuyy=pbuc1_derefidx_vbuyy 
    lda BAR,y
    sta (bar),y
    // for(char i=0;i<sizeof(BAR);i++)
    // [42] irq_line::i2#1 = ++ irq_line::i2#2 -- vbuyy=_inc_vbuyy 
    iny
    // [37] phi from irq_line::@17 to irq_line::@16 [phi:irq_line::@17->irq_line::@16]
    // [37] phi irq_line::i2#2 = irq_line::i2#1 [phi:irq_line::@17->irq_line::@16#0] -- register_copy 
    jmp __b16
    // irq_line::@3
  __b3:
    // *VERA_DC_BORDER = BARS[l]
    // [43] *VERA_DC_BORDER = BARS[irq_line::l#2] -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda BARS,x
    sta VERA_DC_BORDER
    // [44] phi from irq_line::@3 to irq_line::@5 [phi:irq_line::@3->irq_line::@5]
    // [44] phi irq_line::i#2 = 0 [phi:irq_line::@3->irq_line::@5#0] -- vbuaa=vbuc1 
    lda #0
    // irq_line::@5
  __b5:
    // for(char i=0;i<24;i++)
    // [45] if(irq_line::i#2<$18) goto irq_line::@6 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$18
    bcc __b6
    // irq_line::@7
    // *VERA_DC_BORDER = 0
    // [46] *VERA_DC_BORDER = 0 -- _deref_pbuc1=vbuc2 
    // Wait exactly long enough to go to the next raster line
    lda #0
    sta VERA_DC_BORDER
    // [47] phi from irq_line::@7 to irq_line::@8 [phi:irq_line::@7->irq_line::@8]
    // [47] phi irq_line::i1#2 = 0 [phi:irq_line::@7->irq_line::@8#0] -- vbuaa=vbuc1 
    // irq_line::@8
  __b8:
    // for(char i=0;i<23;i++)
    // [48] if(irq_line::i1#2<$17) goto irq_line::@9 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$17
    bcc __b9
    // irq_line::@10
    // asm
    // asm { nop nop  }
    // Wait exactly long enough to go to the next raster line
    nop
    nop
    // for(char l=0;l!=230;l++)
    // [50] irq_line::l#1 = ++ irq_line::l#2 -- vbuxx=_inc_vbuxx 
    inx
    // [18] phi from irq_line::@10 to irq_line::@2 [phi:irq_line::@10->irq_line::@2]
    // [18] phi irq_line::l#2 = irq_line::l#1 [phi:irq_line::@10->irq_line::@2#0] -- register_copy 
    jmp __b2
    // irq_line::@9
  __b9:
    // for(char i=0;i<23;i++)
    // [51] irq_line::i1#1 = ++ irq_line::i1#2 -- vbuaa=_inc_vbuaa 
    inc
    // [47] phi from irq_line::@9 to irq_line::@8 [phi:irq_line::@9->irq_line::@8]
    // [47] phi irq_line::i1#2 = irq_line::i1#1 [phi:irq_line::@9->irq_line::@8#0] -- register_copy 
    jmp __b8
    // irq_line::@6
  __b6:
    // for(char i=0;i<24;i++)
    // [52] irq_line::i#1 = ++ irq_line::i#2 -- vbuaa=_inc_vbuaa 
    inc
    // [44] phi from irq_line::@6 to irq_line::@5 [phi:irq_line::@6->irq_line::@5]
    // [44] phi irq_line::i#2 = irq_line::i#1 [phi:irq_line::@6->irq_line::@5#0] -- register_copy 
    jmp __b5
}
  // main
main: {
    // main::SEI1
    // asm
    // asm { sei  }
    sei
    // main::@2
    // *KERNEL_IRQ = &irq_line
    // [55] *KERNEL_IRQ = &irq_line -- _deref_qprc1=pprc2 
    lda #<irq_line
    sta KERNEL_IRQ
    lda #>irq_line
    sta KERNEL_IRQ+1
    // *VERA_IEN = VERA_LINE
    // [56] *VERA_IEN = VERA_LINE -- _deref_pbuc1=vbuc2 
    lda #VERA_LINE
    sta VERA_IEN
    // *VERA_IRQLINE_L = 5
    // [57] *VERA_IRQLINE_L = 5 -- _deref_pbuc1=vbuc2 
    lda #5
    sta VERA_IRQLINE_L
    // main::CLI1
    // asm
    // asm { cli  }
    cli
    // [59] phi from main::@1 main::CLI1 to main::@1 [phi:main::@1/main::CLI1->main::@1]
    // main::@1
  __b1:
    jmp __b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// void * memset(void *str, char c, unsigned int num)
memset: {
    .const num = $e6*SIZEOF_CHAR
    .const c = 0
    .label str = BARS
    .label end = str+num
    .label dst = $22
    // [61] phi from memset to memset::@1 [phi:memset->memset::@1]
    // [61] phi memset::dst#2 = (char *)memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    // memset::@1
  __b1:
    // for(char* dst = str; dst!=end; dst++)
    // [62] if(memset::dst#2!=memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    // memset::@return
    // }
    // [63] return 
    rts
    // memset::@2
  __b2:
    // *dst = c
    // [64] *memset::dst#2 = memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [65] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [61] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
    // [61] phi memset::dst#2 = memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
.segment Data
  .align $100
SIN:
.fill 256, 99+99*sin(i*2*PI/256)

  .align $100
  BARS: .fill $e6, 0
  .align $100
  BAR: .byte $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1a, $1b, $1c, $1d, $1e, $1f, $1f, $1e, $1d, $1c, $1b, $1a, $19, $18, $17, $16, $15, $14, $13, $12, $11, $10

