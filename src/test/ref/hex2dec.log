Setting inferred volatile on symbol affected by address-of (byte~) utoa16w::$2 ← call utoa16n (byte~) utoa16w::$1 &(byte*) utoa16w::dst (byte) utoa16w::started 
Setting inferred volatile on symbol affected by address-of (byte~) utoa16w::$5 ← call utoa16n (number~) utoa16w::$4 &(byte*) utoa16w::dst (byte) utoa16w::started 
Setting inferred volatile on symbol affected by address-of (byte~) utoa16w::$8 ← call utoa16n (byte~) utoa16w::$7 &(byte*) utoa16w::dst (byte) utoa16w::started 
Setting inferred volatile on symbol affected by address-of (byte~) utoa16w::$11 ← call utoa16n (number~) utoa16w::$10 &(byte*) utoa16w::dst (number) 1 
Fixing pointer array-indexing *((const word*) UTOA10_SUB + (byte) utoa10w::i)
Fixing pointer array-indexing *((const word*) UTOA10_SUB + (byte) utoa10w::i)
Identified constant variable (byte*) cls::screen
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@13
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@14
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@8
Culled Empty Block (label) main::@10
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@12
Culled Empty Block (label) @1
Culled Empty Block (label) cls::@2
Culled Empty Block (label) @2
Culled Empty Block (label) utoa10w::@1
Culled Empty Block (label) utoa10w::@5
Culled Empty Block (label) utoa10w::@6
Culled Empty Block (label) utoa10w::@7
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) utoa16n::@5

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@5

(void()) main()
main: scope:[main]  from @5
  asm { sei  }
  call cls 
  to:main::@15
main::@15: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@15 main::@6
  if(true) goto main::@4
  to:main::@return
main::@4: scope:[main]  from main::@1 main::@4
  (number~) main::$1 ← *((const byte*) control) & (number) $80
  (byte~) main::$2 ← *((const byte*) raster) >> (number) 1
  (number~) main::$3 ← (number~) main::$1 | (byte~) main::$2
  (byte) main::rst#0 ← (number~) main::$3
  (bool~) main::$4 ← (byte) main::rst#0 != (number) $30
  if((bool~) main::$4) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@4
  (byte*) main::screen#0 ← (byte*)(number) $400
  *((const byte*) bordercol) ← (number) 1
  (byte) main::time_start#0 ← *((const byte*) raster)
  (word) utoa16w::value#0 ← (number) 0
  (byte*) utoa16w::dst ← (byte*) main::screen#0
  call utoa16w 
  to:main::@16
main::@16: scope:[main]  from main::@5
  (byte) main::time_start#5 ← phi( main::@5/(byte) main::time_start#0 )
  (byte*) main::screen#5 ← phi( main::@5/(byte*) main::screen#0 )
  *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  (byte*) main::screen#1 ← (byte*) main::screen#5 + (number) $28
  (word) utoa16w::value#1 ← (number) $4d2
  (byte*) utoa16w::dst ← (byte*) main::screen#1
  call utoa16w 
  to:main::@17
main::@17: scope:[main]  from main::@16
  (byte) main::time_start#4 ← phi( main::@16/(byte) main::time_start#5 )
  (byte*) main::screen#6 ← phi( main::@16/(byte*) main::screen#1 )
  *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  (byte*) main::screen#2 ← (byte*) main::screen#6 + (number) $28
  (word) utoa16w::value#2 ← (number) $162e
  (byte*) utoa16w::dst ← (byte*) main::screen#2
  call utoa16w 
  to:main::@18
main::@18: scope:[main]  from main::@17
  (byte) main::time_start#3 ← phi( main::@17/(byte) main::time_start#4 )
  (byte*) main::screen#7 ← phi( main::@17/(byte*) main::screen#2 )
  *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  (byte*) main::screen#3 ← (byte*) main::screen#7 + (number) $28
  (word) utoa16w::value#3 ← (number) $270f
  (byte*) utoa16w::dst ← (byte*) main::screen#3
  call utoa16w 
  to:main::@19
main::@19: scope:[main]  from main::@18
  (byte) main::time_start#2 ← phi( main::@18/(byte) main::time_start#3 )
  (byte*) main::screen#8 ← phi( main::@18/(byte*) main::screen#3 )
  *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  (byte*) main::screen#4 ← (byte*) main::screen#8 + (number) $28
  (word) utoa16w::value#4 ← (number) $e608
  (byte*) utoa16w::dst ← (byte*) main::screen#4
  call utoa16w 
  to:main::@20
main::@20: scope:[main]  from main::@19
  (byte*) main::screen#9 ← phi( main::@19/(byte*) main::screen#4 )
  (byte) main::time_start#1 ← phi( main::@19/(byte) main::time_start#2 )
  (byte) main::time_end#0 ← *((const byte*) raster)
  *((const byte*) bordercol) ← (number) 0
  (byte~) main::$14 ← (byte) main::time_end#0 - (byte) main::time_start#1
  (byte) main::time#0 ← (byte~) main::$14
  (word~) main::$15 ← ((word)) (byte) main::time#0
  (byte*~) main::$16 ← (byte*) main::screen#9 + (number) $50
  (word) utoa10w::value#0 ← (word~) main::$15
  (byte*) utoa10w::dst#0 ← (byte*~) main::$16
  call utoa10w 
  to:main::@21
main::@21: scope:[main]  from main::@20
  (byte*) main::screen#12 ← phi( main::@20/(byte*) main::screen#9 )
  (byte) main::i#0 ← (byte) 0
  to:main::@6
main::@6: scope:[main]  from main::@21 main::@7
  (byte*) main::screen#11 ← phi( main::@21/(byte*) main::screen#12 main::@7/(byte*) main::screen#10 )
  (byte) main::i#2 ← phi( main::@21/(byte) main::i#0 main::@7/(byte) main::i#1 )
  (bool~) main::$18 ← *((const byte*) main::msg + (byte) main::i#2) != (number) 0
  if((bool~) main::$18) goto main::@7
  to:main::@1
main::@7: scope:[main]  from main::@6
  (byte) main::i#3 ← phi( main::@6/(byte) main::i#2 )
  (byte*) main::screen#10 ← phi( main::@6/(byte*) main::screen#11 )
  (byte*~) main::$19 ← (byte*) main::screen#10 + (number) $50
  (byte*~) main::$20 ← (byte*~) main::$19 + (number) 3
  *((byte*~) main::$20 + (byte) main::i#3) ← *((const byte*) main::msg + (byte) main::i#3)
  (byte) main::i#1 ← ++ (byte) main::i#3
  to:main::@6
main::@return: scope:[main]  from main::@1
  return 
  to:@return

(void()) cls()
cls: scope:[cls]  from main
  (byte*~) cls::$0 ← (const byte*) cls::screen + (number) $3e7
  (byte*) cls::sc#0 ← (const byte*) cls::screen
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  (byte*) cls::sc#2 ← phi( cls/(byte*) cls::sc#0 cls::@1/(byte*) cls::sc#1 )
  *((byte*) cls::sc#2) ← (byte) ' '
  (byte*) cls::sc#1 ← (byte*) cls::sc#2 + rangenext(cls::screen,cls::$0)
  (bool~) cls::$1 ← (byte*) cls::sc#1 != rangelast(cls::screen,cls::$0)
  if((bool~) cls::$1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  return 
  to:@return

(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
utoa10w: scope:[utoa10w]  from main::@20
  (byte*) utoa10w::dst#10 ← phi( main::@20/(byte*) utoa10w::dst#0 )
  (word) utoa10w::value#5 ← phi( main::@20/(word) utoa10w::value#0 )
  (byte) utoa10w::bStarted#0 ← (byte) 0
  (byte) utoa10w::digit#0 ← (byte) 0
  (byte) utoa10w::i#0 ← (byte) 0
  to:utoa10w::@2
utoa10w::@2: scope:[utoa10w]  from utoa10w utoa10w::@10 utoa10w::@3
  (byte*) utoa10w::dst#9 ← phi( utoa10w/(byte*) utoa10w::dst#10 utoa10w::@10/(byte*) utoa10w::dst#6 utoa10w::@3/(byte*) utoa10w::dst#11 )
  (byte) utoa10w::bStarted#4 ← phi( utoa10w/(byte) utoa10w::bStarted#0 utoa10w::@10/(byte) utoa10w::bStarted#5 utoa10w::@3/(byte) utoa10w::bStarted#1 )
  (byte) utoa10w::digit#5 ← phi( utoa10w/(byte) utoa10w::digit#0 utoa10w::@10/(byte) utoa10w::digit#7 utoa10w::@3/(byte) utoa10w::digit#1 )
  (word) utoa10w::value#2 ← phi( utoa10w/(word) utoa10w::value#5 utoa10w::@10/(word) utoa10w::value#6 utoa10w::@3/(word) utoa10w::value#1 )
  (byte) utoa10w::i#2 ← phi( utoa10w/(byte) utoa10w::i#0 utoa10w::@10/(byte) utoa10w::i#1 utoa10w::@3/(byte) utoa10w::i#3 )
  (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 * (const byte) SIZEOF_WORD
  (bool~) utoa10w::$1 ← (word) utoa10w::value#2 >= *((const word*) UTOA10_SUB + (byte~) utoa10w::$8)
  if((bool~) utoa10w::$1) goto utoa10w::@3
  to:utoa10w::@4
utoa10w::@3: scope:[utoa10w]  from utoa10w::@2
  (byte*) utoa10w::dst#11 ← phi( utoa10w::@2/(byte*) utoa10w::dst#9 )
  (word) utoa10w::value#3 ← phi( utoa10w::@2/(word) utoa10w::value#2 )
  (byte) utoa10w::i#3 ← phi( utoa10w::@2/(byte) utoa10w::i#2 )
  (byte) utoa10w::digit#3 ← phi( utoa10w::@2/(byte) utoa10w::digit#5 )
  (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte*) UTOA10_VAL + (byte) utoa10w::i#3)
  (byte~) utoa10w::$9 ← (byte) utoa10w::i#3 * (const byte) SIZEOF_WORD
  (word) utoa10w::value#1 ← (word) utoa10w::value#3 - *((const word*) UTOA10_SUB + (byte~) utoa10w::$9)
  (byte) utoa10w::bStarted#1 ← (number) 1
  to:utoa10w::@2
utoa10w::@4: scope:[utoa10w]  from utoa10w::@2
  (byte) utoa10w::digit#8 ← phi( utoa10w::@2/(byte) utoa10w::digit#5 )
  (byte*) utoa10w::dst#8 ← phi( utoa10w::@2/(byte*) utoa10w::dst#9 )
  (word) utoa10w::value#8 ← phi( utoa10w::@2/(word) utoa10w::value#2 )
  (byte) utoa10w::bStarted#3 ← phi( utoa10w::@2/(byte) utoa10w::bStarted#4 )
  (byte) utoa10w::i#4 ← phi( utoa10w::@2/(byte) utoa10w::i#2 )
  (number~) utoa10w::$2 ← (byte) utoa10w::i#4 & (number) 1
  (bool~) utoa10w::$3 ← (number~) utoa10w::$2 != (number) 0
  (bool~) utoa10w::$4 ← ! (bool~) utoa10w::$3
  if((bool~) utoa10w::$4) goto utoa10w::@10
  to:utoa10w::@8
utoa10w::@10: scope:[utoa10w]  from utoa10w::@11 utoa10w::@4
  (byte) utoa10w::bStarted#5 ← phi( utoa10w::@11/(byte) utoa10w::bStarted#6 utoa10w::@4/(byte) utoa10w::bStarted#3 )
  (byte) utoa10w::digit#7 ← phi( utoa10w::@11/(byte) utoa10w::digit#2 utoa10w::@4/(byte) utoa10w::digit#8 )
  (byte*) utoa10w::dst#6 ← phi( utoa10w::@11/(byte*) utoa10w::dst#7 utoa10w::@4/(byte*) utoa10w::dst#8 )
  (word) utoa10w::value#6 ← phi( utoa10w::@11/(word) utoa10w::value#7 utoa10w::@4/(word) utoa10w::value#8 )
  (byte) utoa10w::i#5 ← phi( utoa10w::@11/(byte) utoa10w::i#6 utoa10w::@4/(byte) utoa10w::i#4 )
  (byte) utoa10w::i#1 ← (byte) utoa10w::i#5 + rangenext(0,7)
  (bool~) utoa10w::$7 ← (byte) utoa10w::i#1 != rangelast(0,7)
  if((bool~) utoa10w::$7) goto utoa10w::@2
  to:utoa10w::@12
utoa10w::@8: scope:[utoa10w]  from utoa10w::@4
  (word) utoa10w::value#9 ← phi( utoa10w::@4/(word) utoa10w::value#8 )
  (byte) utoa10w::i#7 ← phi( utoa10w::@4/(byte) utoa10w::i#4 )
  (byte*) utoa10w::dst#5 ← phi( utoa10w::@4/(byte*) utoa10w::dst#8 )
  (byte) utoa10w::digit#6 ← phi( utoa10w::@4/(byte) utoa10w::digit#8 )
  (byte) utoa10w::bStarted#2 ← phi( utoa10w::@4/(byte) utoa10w::bStarted#3 )
  (bool~) utoa10w::$5 ← (byte) utoa10w::bStarted#2 != (number) 0
  (bool~) utoa10w::$6 ← ! (bool~) utoa10w::$5
  if((bool~) utoa10w::$6) goto utoa10w::@11
  to:utoa10w::@9
utoa10w::@11: scope:[utoa10w]  from utoa10w::@8 utoa10w::@9
  (byte) utoa10w::bStarted#6 ← phi( utoa10w::@8/(byte) utoa10w::bStarted#2 utoa10w::@9/(byte) utoa10w::bStarted#7 )
  (byte*) utoa10w::dst#7 ← phi( utoa10w::@8/(byte*) utoa10w::dst#5 utoa10w::@9/(byte*) utoa10w::dst#1 )
  (word) utoa10w::value#7 ← phi( utoa10w::@8/(word) utoa10w::value#9 utoa10w::@9/(word) utoa10w::value#10 )
  (byte) utoa10w::i#6 ← phi( utoa10w::@8/(byte) utoa10w::i#7 utoa10w::@9/(byte) utoa10w::i#8 )
  (byte) utoa10w::digit#2 ← (number) 0
  to:utoa10w::@10
utoa10w::@9: scope:[utoa10w]  from utoa10w::@8
  (byte) utoa10w::bStarted#7 ← phi( utoa10w::@8/(byte) utoa10w::bStarted#2 )
  (word) utoa10w::value#10 ← phi( utoa10w::@8/(word) utoa10w::value#9 )
  (byte) utoa10w::i#8 ← phi( utoa10w::@8/(byte) utoa10w::i#7 )
  (byte*) utoa10w::dst#3 ← phi( utoa10w::@8/(byte*) utoa10w::dst#5 )
  (byte) utoa10w::digit#4 ← phi( utoa10w::@8/(byte) utoa10w::digit#6 )
  *((byte*) utoa10w::dst#3) ← *((const byte*) DIGITS + (byte) utoa10w::digit#4)
  (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#3
  to:utoa10w::@11
utoa10w::@12: scope:[utoa10w]  from utoa10w::@10
  (byte*) utoa10w::dst#4 ← phi( utoa10w::@10/(byte*) utoa10w::dst#6 )
  (word) utoa10w::value#4 ← phi( utoa10w::@10/(word) utoa10w::value#6 )
  (byte~) utoa10w::$0 ← ((byte)) (word) utoa10w::value#4
  *((byte*) utoa10w::dst#4) ← *((const byte*) DIGITS + (byte~) utoa10w::$0)
  (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4
  *((byte*) utoa10w::dst#2) ← (number) 0
  to:utoa10w::@return
utoa10w::@return: scope:[utoa10w]  from utoa10w::@12
  return 
  to:@return

(void()) utoa16w((word) utoa16w::value , (byte*) utoa16w::dst)
utoa16w: scope:[utoa16w]  from main::@16 main::@17 main::@18 main::@19 main::@5
  (word) utoa16w::value#5 ← phi( main::@16/(word) utoa16w::value#1 main::@17/(word) utoa16w::value#2 main::@18/(word) utoa16w::value#3 main::@19/(word) utoa16w::value#4 main::@5/(word) utoa16w::value#0 )
  (byte) utoa16w::started#0 ← (byte) 0
  (byte~) utoa16w::$0 ← > (word) utoa16w::value#5
  (byte~) utoa16w::$1 ← (byte~) utoa16w::$0 >> (number) 4
  (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$1
  (word**) utoa16n::dst#0 ← &(byte*) utoa16w::dst
  (byte) utoa16n::started#0 ← (byte) utoa16w::started#0
  call utoa16n 
  (byte) utoa16n::return#0 ← (byte) utoa16n::return#5
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  (word) utoa16w::value#6 ← phi( utoa16w/(word) utoa16w::value#5 )
  (byte) utoa16n::return#6 ← phi( utoa16w/(byte) utoa16n::return#0 )
  (byte~) utoa16w::$2 ← (byte) utoa16n::return#6
  (byte) utoa16w::started#1 ← (byte~) utoa16w::$2
  (byte~) utoa16w::$3 ← > (word) utoa16w::value#6
  (number~) utoa16w::$4 ← (byte~) utoa16w::$3 & (number) $f
  (byte) utoa16n::nybble#1 ← (number~) utoa16w::$4
  (word**) utoa16n::dst#1 ← &(byte*) utoa16w::dst
  (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  call utoa16n 
  (byte) utoa16n::return#1 ← (byte) utoa16n::return#5
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  (word) utoa16w::value#7 ← phi( utoa16w::@1/(word) utoa16w::value#6 )
  (byte) utoa16n::return#7 ← phi( utoa16w::@1/(byte) utoa16n::return#1 )
  (byte~) utoa16w::$5 ← (byte) utoa16n::return#7
  (byte) utoa16w::started#2 ← (byte~) utoa16w::$5
  (byte~) utoa16w::$6 ← < (word) utoa16w::value#7
  (byte~) utoa16w::$7 ← (byte~) utoa16w::$6 >> (number) 4
  (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$7
  (word**) utoa16n::dst#2 ← &(byte*) utoa16w::dst
  (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  call utoa16n 
  (byte) utoa16n::return#2 ← (byte) utoa16n::return#5
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  (word) utoa16w::value#8 ← phi( utoa16w::@2/(word) utoa16w::value#7 )
  (byte) utoa16n::return#8 ← phi( utoa16w::@2/(byte) utoa16n::return#2 )
  (byte~) utoa16w::$8 ← (byte) utoa16n::return#8
  (byte) utoa16w::started#3 ← (byte~) utoa16w::$8
  (byte~) utoa16w::$9 ← < (word) utoa16w::value#8
  (number~) utoa16w::$10 ← (byte~) utoa16w::$9 & (number) $f
  (byte) utoa16n::nybble#3 ← (number~) utoa16w::$10
  (word**) utoa16n::dst#3 ← &(byte*) utoa16w::dst
  (byte) utoa16n::started#3 ← (number) 1
  call utoa16n 
  (byte) utoa16n::return#3 ← (byte) utoa16n::return#5
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  *((byte*) utoa16w::dst) ← (number) 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  return 
  to:@return

(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  (word**) utoa16n::dst#6 ← phi( utoa16w/(word**) utoa16n::dst#0 utoa16w::@1/(word**) utoa16n::dst#1 utoa16w::@2/(word**) utoa16n::dst#2 utoa16w::@3/(word**) utoa16n::dst#3 )
  (byte) utoa16n::started#7 ← phi( utoa16w/(byte) utoa16n::started#0 utoa16w::@1/(byte) utoa16n::started#1 utoa16w::@2/(byte) utoa16n::started#2 utoa16w::@3/(byte) utoa16n::started#3 )
  (byte) utoa16n::nybble#4 ← phi( utoa16w/(byte) utoa16n::nybble#0 utoa16w::@1/(byte) utoa16n::nybble#1 utoa16w::@2/(byte) utoa16n::nybble#2 utoa16w::@3/(byte) utoa16n::nybble#3 )
  (bool~) utoa16n::$0 ← (byte) utoa16n::nybble#4 != (number) 0
  (bool~) utoa16n::$1 ← ! (bool~) utoa16n::$0
  if((bool~) utoa16n::$1) goto utoa16n::@1
  to:utoa16n::@3
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  (word**) utoa16n::dst#5 ← phi( utoa16n/(word**) utoa16n::dst#6 utoa16n::@3/(word**) utoa16n::dst#7 )
  (byte) utoa16n::nybble#6 ← phi( utoa16n/(byte) utoa16n::nybble#4 utoa16n::@3/(byte) utoa16n::nybble#7 )
  (byte) utoa16n::started#5 ← phi( utoa16n/(byte) utoa16n::started#7 utoa16n::@3/(byte) utoa16n::started#4 )
  (bool~) utoa16n::$2 ← (byte) utoa16n::started#5 != (number) 0
  (bool~) utoa16n::$3 ← ! (bool~) utoa16n::$2
  if((bool~) utoa16n::$3) goto utoa16n::@2
  to:utoa16n::@4
utoa16n::@3: scope:[utoa16n]  from utoa16n
  (word**) utoa16n::dst#7 ← phi( utoa16n/(word**) utoa16n::dst#6 )
  (byte) utoa16n::nybble#7 ← phi( utoa16n/(byte) utoa16n::nybble#4 )
  (byte) utoa16n::started#4 ← (number) 1
  to:utoa16n::@1
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1 utoa16n::@4
  (byte) utoa16n::started#6 ← phi( utoa16n::@1/(byte) utoa16n::started#5 utoa16n::@4/(byte) utoa16n::started#8 )
  (byte) utoa16n::return#4 ← (byte) utoa16n::started#6
  to:utoa16n::@return
utoa16n::@4: scope:[utoa16n]  from utoa16n::@1
  (byte) utoa16n::started#8 ← phi( utoa16n::@1/(byte) utoa16n::started#5 )
  (word**) utoa16n::dst#4 ← phi( utoa16n::@1/(word**) utoa16n::dst#5 )
  (byte) utoa16n::nybble#5 ← phi( utoa16n::@1/(byte) utoa16n::nybble#6 )
  *(*((word**) utoa16n::dst#4)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#5)
  *((word**) utoa16n::dst#4) ← ++ *((word**) utoa16n::dst#4)
  to:utoa16n::@2
utoa16n::@return: scope:[utoa16n]  from utoa16n::@2
  (byte) utoa16n::return#9 ← phi( utoa16n::@2/(byte) utoa16n::return#4 )
  (byte) utoa16n::return#5 ← (byte) utoa16n::return#9
  return 
  to:@return
@5: scope:[]  from @begin
  call main 
  to:@6
@6: scope:[]  from @5
  to:@end
@end: scope:[]  from @6

SYMBOL TABLE SSA
(label) @5
(label) @6
(label) @begin
(label) @end
(const byte*) DIGITS[]  = (byte*) "0123456789abcdef"
(const byte) SIZEOF_WORD = (byte) 2
(const word*) UTOA10_SUB[]  = { (word) $7530, (word) $2710, (word) $bb8, (word) $3e8, (word) $12c, (word) $64, (word) $1e, (word) $a }
(const byte*) UTOA10_VAL[]  = { (byte) 3, (byte) 1, (byte) 3, (byte) 1, (byte) 3, (byte) 1, (byte) 3, (byte) 1 }
(const byte*) bordercol = (byte*)(number) $d020
(void()) cls()
(byte*~) cls::$0
(bool~) cls::$1
(label) cls::@1
(label) cls::@return
(byte*) cls::sc
(byte*) cls::sc#0
(byte*) cls::sc#1
(byte*) cls::sc#2
(const byte*) cls::screen = (byte*)(number) $400
(const byte*) control = (byte*)(number) $d011
(void()) main()
(number~) main::$1
(byte~) main::$14
(word~) main::$15
(byte*~) main::$16
(bool~) main::$18
(byte*~) main::$19
(byte~) main::$2
(byte*~) main::$20
(number~) main::$3
(bool~) main::$4
(label) main::@1
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@20
(label) main::@21
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@return
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte) main::i#3
(const byte*) main::msg[]  = (byte*) "raster lines"
(byte) main::rst
(byte) main::rst#0
(byte*) main::screen
(byte*) main::screen#0
(byte*) main::screen#1
(byte*) main::screen#10
(byte*) main::screen#11
(byte*) main::screen#12
(byte*) main::screen#2
(byte*) main::screen#3
(byte*) main::screen#4
(byte*) main::screen#5
(byte*) main::screen#6
(byte*) main::screen#7
(byte*) main::screen#8
(byte*) main::screen#9
(byte) main::time
(byte) main::time#0
(byte) main::time_end
(byte) main::time_end#0
(byte) main::time_start
(byte) main::time_start#0
(byte) main::time_start#1
(byte) main::time_start#2
(byte) main::time_start#3
(byte) main::time_start#4
(byte) main::time_start#5
(const byte*) raster = (byte*)(number) $d012
(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
(byte~) utoa10w::$0
(bool~) utoa10w::$1
(number~) utoa10w::$2
(bool~) utoa10w::$3
(bool~) utoa10w::$4
(bool~) utoa10w::$5
(bool~) utoa10w::$6
(bool~) utoa10w::$7
(byte~) utoa10w::$8
(byte~) utoa10w::$9
(label) utoa10w::@10
(label) utoa10w::@11
(label) utoa10w::@12
(label) utoa10w::@2
(label) utoa10w::@3
(label) utoa10w::@4
(label) utoa10w::@8
(label) utoa10w::@9
(label) utoa10w::@return
(byte) utoa10w::bStarted
(byte) utoa10w::bStarted#0
(byte) utoa10w::bStarted#1
(byte) utoa10w::bStarted#2
(byte) utoa10w::bStarted#3
(byte) utoa10w::bStarted#4
(byte) utoa10w::bStarted#5
(byte) utoa10w::bStarted#6
(byte) utoa10w::bStarted#7
(byte) utoa10w::digit
(byte) utoa10w::digit#0
(byte) utoa10w::digit#1
(byte) utoa10w::digit#2
(byte) utoa10w::digit#3
(byte) utoa10w::digit#4
(byte) utoa10w::digit#5
(byte) utoa10w::digit#6
(byte) utoa10w::digit#7
(byte) utoa10w::digit#8
(byte*) utoa10w::dst
(byte*) utoa10w::dst#0
(byte*) utoa10w::dst#1
(byte*) utoa10w::dst#10
(byte*) utoa10w::dst#11
(byte*) utoa10w::dst#2
(byte*) utoa10w::dst#3
(byte*) utoa10w::dst#4
(byte*) utoa10w::dst#5
(byte*) utoa10w::dst#6
(byte*) utoa10w::dst#7
(byte*) utoa10w::dst#8
(byte*) utoa10w::dst#9
(byte) utoa10w::i
(byte) utoa10w::i#0
(byte) utoa10w::i#1
(byte) utoa10w::i#2
(byte) utoa10w::i#3
(byte) utoa10w::i#4
(byte) utoa10w::i#5
(byte) utoa10w::i#6
(byte) utoa10w::i#7
(byte) utoa10w::i#8
(word) utoa10w::value
(word) utoa10w::value#0
(word) utoa10w::value#1
(word) utoa10w::value#10
(word) utoa10w::value#2
(word) utoa10w::value#3
(word) utoa10w::value#4
(word) utoa10w::value#5
(word) utoa10w::value#6
(word) utoa10w::value#7
(word) utoa10w::value#8
(word) utoa10w::value#9
(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
(bool~) utoa16n::$0
(bool~) utoa16n::$1
(bool~) utoa16n::$2
(bool~) utoa16n::$3
(label) utoa16n::@1
(label) utoa16n::@2
(label) utoa16n::@3
(label) utoa16n::@4
(label) utoa16n::@return
(word**) utoa16n::dst
(word**) utoa16n::dst#0
(word**) utoa16n::dst#1
(word**) utoa16n::dst#2
(word**) utoa16n::dst#3
(word**) utoa16n::dst#4
(word**) utoa16n::dst#5
(word**) utoa16n::dst#6
(word**) utoa16n::dst#7
(byte) utoa16n::nybble
(byte) utoa16n::nybble#0
(byte) utoa16n::nybble#1
(byte) utoa16n::nybble#2
(byte) utoa16n::nybble#3
(byte) utoa16n::nybble#4
(byte) utoa16n::nybble#5
(byte) utoa16n::nybble#6
(byte) utoa16n::nybble#7
(byte) utoa16n::return
(byte) utoa16n::return#0
(byte) utoa16n::return#1
(byte) utoa16n::return#2
(byte) utoa16n::return#3
(byte) utoa16n::return#4
(byte) utoa16n::return#5
(byte) utoa16n::return#6
(byte) utoa16n::return#7
(byte) utoa16n::return#8
(byte) utoa16n::return#9
(byte) utoa16n::started
(byte) utoa16n::started#0
(byte) utoa16n::started#1
(byte) utoa16n::started#2
(byte) utoa16n::started#3
(byte) utoa16n::started#4
(byte) utoa16n::started#5
(byte) utoa16n::started#6
(byte) utoa16n::started#7
(byte) utoa16n::started#8
(void()) utoa16w((word) utoa16w::value , (byte*) utoa16w::dst)
(byte~) utoa16w::$0
(byte~) utoa16w::$1
(number~) utoa16w::$10
(byte~) utoa16w::$2
(byte~) utoa16w::$3
(number~) utoa16w::$4
(byte~) utoa16w::$5
(byte~) utoa16w::$6
(byte~) utoa16w::$7
(byte~) utoa16w::$8
(byte~) utoa16w::$9
(label) utoa16w::@1
(label) utoa16w::@2
(label) utoa16w::@3
(label) utoa16w::@4
(label) utoa16w::@return
(byte*) utoa16w::dst loadstore
(byte) utoa16w::started
(byte) utoa16w::started#0
(byte) utoa16w::started#1
(byte) utoa16w::started#2
(byte) utoa16w::started#3
(word) utoa16w::value
(word) utoa16w::value#0
(word) utoa16w::value#1
(word) utoa16w::value#2
(word) utoa16w::value#3
(word) utoa16w::value#4
(word) utoa16w::value#5
(word) utoa16w::value#6
(word) utoa16w::value#7
(word) utoa16w::value#8

Adding number conversion cast (unumber) $80 in (number~) main::$1 ← *((const byte*) control) & (number) $80
Adding number conversion cast (unumber) main::$1 in (number~) main::$1 ← *((const byte*) control) & (unumber)(number) $80
Adding number conversion cast (unumber) 1 in (byte~) main::$2 ← *((const byte*) raster) >> (number) 1
Adding number conversion cast (unumber) main::$3 in (number~) main::$3 ← (unumber~) main::$1 | (byte~) main::$2
Adding number conversion cast (unumber) $30 in (bool~) main::$4 ← (byte) main::rst#0 != (number) $30
Adding number conversion cast (unumber) 1 in *((const byte*) bordercol) ← (number) 1
Adding number conversion cast (unumber) 0 in (word) utoa16w::value#0 ← (number) 0
Adding number conversion cast (unumber) $28 in (byte*) main::screen#1 ← (byte*) main::screen#5 + (number) $28
Adding number conversion cast (unumber) $4d2 in (word) utoa16w::value#1 ← (number) $4d2
Adding number conversion cast (unumber) $28 in (byte*) main::screen#2 ← (byte*) main::screen#6 + (number) $28
Adding number conversion cast (unumber) $162e in (word) utoa16w::value#2 ← (number) $162e
Adding number conversion cast (unumber) $28 in (byte*) main::screen#3 ← (byte*) main::screen#7 + (number) $28
Adding number conversion cast (unumber) $270f in (word) utoa16w::value#3 ← (number) $270f
Adding number conversion cast (unumber) $28 in (byte*) main::screen#4 ← (byte*) main::screen#8 + (number) $28
Adding number conversion cast (unumber) $e608 in (word) utoa16w::value#4 ← (number) $e608
Adding number conversion cast (unumber) 0 in *((const byte*) bordercol) ← (number) 0
Adding number conversion cast (unumber) $50 in (byte*~) main::$16 ← (byte*) main::screen#9 + (number) $50
Adding number conversion cast (unumber) 0 in (bool~) main::$18 ← *((const byte*) main::msg + (byte) main::i#2) != (number) 0
Adding number conversion cast (unumber) $50 in (byte*~) main::$19 ← (byte*) main::screen#10 + (number) $50
Adding number conversion cast (unumber) 3 in (byte*~) main::$20 ← (byte*~) main::$19 + (number) 3
Adding number conversion cast (unumber) $3e7 in (byte*~) cls::$0 ← (const byte*) cls::screen + (number) $3e7
Adding number conversion cast (unumber) 1 in (byte) utoa10w::bStarted#1 ← (number) 1
Adding number conversion cast (unumber) 1 in (number~) utoa10w::$2 ← (byte) utoa10w::i#4 & (number) 1
Adding number conversion cast (unumber) utoa10w::$2 in (number~) utoa10w::$2 ← (byte) utoa10w::i#4 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) utoa10w::$3 ← (unumber~) utoa10w::$2 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) utoa10w::$5 ← (byte) utoa10w::bStarted#2 != (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa10w::digit#2 ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*) utoa10w::dst#2) ← (number) 0
Adding number conversion cast (unumber) 4 in (byte~) utoa16w::$1 ← (byte~) utoa16w::$0 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) utoa16w::$4 ← (byte~) utoa16w::$3 & (number) $f
Adding number conversion cast (unumber) utoa16w::$4 in (number~) utoa16w::$4 ← (byte~) utoa16w::$3 & (unumber)(number) $f
Adding number conversion cast (unumber) 4 in (byte~) utoa16w::$7 ← (byte~) utoa16w::$6 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) utoa16w::$10 ← (byte~) utoa16w::$9 & (number) $f
Adding number conversion cast (unumber) utoa16w::$10 in (number~) utoa16w::$10 ← (byte~) utoa16w::$9 & (unumber)(number) $f
Adding number conversion cast (unumber) 1 in (byte) utoa16n::started#3 ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte*) utoa16w::dst) ← (number) 0
Adding number conversion cast (unumber) 0 in (bool~) utoa16n::$0 ← (byte) utoa16n::nybble#4 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) utoa16n::$2 ← (byte) utoa16n::started#5 != (number) 0
Adding number conversion cast (unumber) 1 in (byte) utoa16n::started#4 ← (number) 1
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((const byte*) bordercol) ← (unumber)(number) 1
Inlining cast (word) utoa16w::value#0 ← (unumber)(number) 0
Inlining cast (word) utoa16w::value#1 ← (unumber)(number) $4d2
Inlining cast (word) utoa16w::value#2 ← (unumber)(number) $162e
Inlining cast (word) utoa16w::value#3 ← (unumber)(number) $270f
Inlining cast (word) utoa16w::value#4 ← (unumber)(number) $e608
Inlining cast *((const byte*) bordercol) ← (unumber)(number) 0
Inlining cast (word~) main::$15 ← (word)(byte) main::time#0
Inlining cast (byte) utoa10w::bStarted#1 ← (unumber)(number) 1
Inlining cast (byte) utoa10w::digit#2 ← (unumber)(number) 0
Inlining cast (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#4
Inlining cast *((byte*) utoa10w::dst#2) ← (unumber)(number) 0
Inlining cast (byte) utoa16n::started#3 ← (unumber)(number) 1
Inlining cast *((byte*) utoa16w::dst) ← (unumber)(number) 0
Inlining cast (byte) utoa16n::started#4 ← (unumber)(number) 1
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $80
Simplifying constant integer cast 1
Simplifying constant integer cast $30
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast $4d2
Simplifying constant integer cast $28
Simplifying constant integer cast $162e
Simplifying constant integer cast $28
Simplifying constant integer cast $270f
Simplifying constant integer cast $28
Simplifying constant integer cast $e608
Simplifying constant integer cast 0
Simplifying constant integer cast $50
Simplifying constant integer cast 0
Simplifying constant integer cast $50
Simplifying constant integer cast 3
Simplifying constant integer cast $3e7
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $30
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $4d2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $162e
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $270f
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $e608
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $50
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $50
Finalized unsigned number type (byte) 3
Finalized unsigned number type (word) $3e7
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) main::$1 ← *((const byte*) control) & (byte) $80
Inferred type updated to byte in (unumber~) main::$3 ← (byte~) main::$1 | (byte~) main::$2
Inferred type updated to byte in (unumber~) utoa10w::$2 ← (byte) utoa10w::i#4 & (byte) 1
Inferred type updated to byte in (unumber~) utoa16w::$4 ← (byte~) utoa16w::$3 & (byte) $f
Inferred type updated to byte in (unumber~) utoa16w::$10 ← (byte~) utoa16w::$9 & (byte) $f
Inversing boolean not [84] (bool~) utoa10w::$4 ← (byte~) utoa10w::$2 == (byte) 0 from [83] (bool~) utoa10w::$3 ← (byte~) utoa10w::$2 != (byte) 0
Inversing boolean not [92] (bool~) utoa10w::$6 ← (byte) utoa10w::bStarted#2 == (byte) 0 from [91] (bool~) utoa10w::$5 ← (byte) utoa10w::bStarted#2 != (byte) 0
Inversing boolean not [148] (bool~) utoa16n::$1 ← (byte) utoa16n::nybble#4 == (byte) 0 from [147] (bool~) utoa16n::$0 ← (byte) utoa16n::nybble#4 != (byte) 0
Inversing boolean not [152] (bool~) utoa16n::$3 ← (byte) utoa16n::started#5 == (byte) 0 from [151] (bool~) utoa16n::$2 ← (byte) utoa16n::started#5 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte) main::rst#0 = (byte~) main::$3 
Alias (byte*) main::screen#0 = (byte*) main::screen#5 
Alias (byte) main::time_start#0 = (byte) main::time_start#5 (byte) main::time_start#4 (byte) main::time_start#3 (byte) main::time_start#2 (byte) main::time_start#1 
Alias (byte*) main::screen#1 = (byte*) main::screen#6 
Alias (byte*) main::screen#2 = (byte*) main::screen#7 
Alias (byte*) main::screen#3 = (byte*) main::screen#8 
Alias (byte*) main::screen#12 = (byte*) main::screen#9 (byte*) main::screen#4 
Alias (byte) main::time#0 = (byte~) main::$14 
Alias (word) utoa10w::value#0 = (word~) main::$15 
Alias (byte*) utoa10w::dst#0 = (byte*~) main::$16 
Alias (byte*) main::screen#10 = (byte*) main::screen#11 
Alias (byte) main::i#2 = (byte) main::i#3 
Alias (byte) utoa10w::digit#3 = (byte) utoa10w::digit#5 (byte) utoa10w::digit#8 (byte) utoa10w::digit#6 (byte) utoa10w::digit#4 
Alias (byte) utoa10w::i#2 = (byte) utoa10w::i#3 (byte) utoa10w::i#4 (byte) utoa10w::i#7 (byte) utoa10w::i#8 
Alias (word) utoa10w::value#10 = (word) utoa10w::value#3 (word) utoa10w::value#2 (word) utoa10w::value#8 (word) utoa10w::value#9 
Alias (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#9 (byte*) utoa10w::dst#8 (byte*) utoa10w::dst#5 (byte*) utoa10w::dst#3 
Alias (byte) utoa10w::bStarted#2 = (byte) utoa10w::bStarted#3 (byte) utoa10w::bStarted#4 (byte) utoa10w::bStarted#7 
Alias (word) utoa10w::value#4 = (word) utoa10w::value#6 
Alias (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#6 
Alias (byte) utoa16n::nybble#0 = (byte~) utoa16w::$1 
Alias (byte) utoa16n::return#0 = (byte) utoa16n::return#6 
Alias (word) utoa16w::value#5 = (word) utoa16w::value#6 (word) utoa16w::value#7 (word) utoa16w::value#8 
Alias (byte) utoa16w::started#1 = (byte~) utoa16w::$2 
Alias (byte) utoa16n::nybble#1 = (byte~) utoa16w::$4 
Alias (byte) utoa16n::return#1 = (byte) utoa16n::return#7 
Alias (byte) utoa16w::started#2 = (byte~) utoa16w::$5 
Alias (byte) utoa16n::nybble#2 = (byte~) utoa16w::$7 
Alias (byte) utoa16n::return#2 = (byte) utoa16n::return#8 
Alias (byte) utoa16w::started#3 = (byte~) utoa16w::$8 
Alias (byte) utoa16n::nybble#3 = (byte~) utoa16w::$10 
Alias (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#7 
Alias (word**) utoa16n::dst#6 = (word**) utoa16n::dst#7 
Alias (byte) utoa16n::return#4 = (byte) utoa16n::started#6 (byte) utoa16n::return#9 (byte) utoa16n::return#5 
Alias (byte) utoa16n::nybble#5 = (byte) utoa16n::nybble#6 
Alias (word**) utoa16n::dst#4 = (word**) utoa16n::dst#5 
Alias (byte) utoa16n::started#5 = (byte) utoa16n::started#8 
Successful SSA optimization Pass2AliasElimination
Alias (byte) utoa10w::i#2 = (byte) utoa10w::i#6 
Alias (word) utoa10w::value#10 = (word) utoa10w::value#7 
Alias (byte) utoa10w::bStarted#2 = (byte) utoa10w::bStarted#6 
Alias (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#5 
Alias (word**) utoa16n::dst#4 = (word**) utoa16n::dst#6 
Alias (byte) utoa16n::return#4 = (byte) utoa16n::started#5 
Successful SSA optimization Pass2AliasElimination
Alias (byte) utoa10w::i#2 = (byte) utoa10w::i#5 
Alias (word) utoa10w::value#10 = (word) utoa10w::value#4 
Alias (byte) utoa10w::bStarted#2 = (byte) utoa10w::bStarted#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte*) main::screen#10 (byte*) main::screen#12
Identical Phi Values (word) utoa10w::value#5 (word) utoa10w::value#0
Identical Phi Values (byte*) utoa10w::dst#10 (byte*) utoa10w::dst#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$4 [8] if((byte) main::rst#0!=(byte) $30) goto main::@4
Simple Condition (bool~) main::$18 [53] if(*((const byte*) main::msg + (byte) main::i#2)!=(byte) 0) goto main::@7
Simple Condition (bool~) cls::$1 [66] if((byte*) cls::sc#1!=rangelast(cls::screen,cls::$0)) goto cls::@1
Simple Condition (bool~) utoa10w::$1 [75] if((word) utoa10w::value#10>=*((const word*) UTOA10_SUB + (byte~) utoa10w::$8)) goto utoa10w::@3
Simple Condition (bool~) utoa10w::$4 [85] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@10
Simple Condition (bool~) utoa10w::$7 [89] if((byte) utoa10w::i#1!=rangelast(0,7)) goto utoa10w::@2
Simple Condition (bool~) utoa10w::$6 [93] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@11
Simple Condition (bool~) utoa16n::$1 [149] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@1
Simple Condition (bool~) utoa16n::$3 [153] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [60] (byte*~) cls::$0 ← (const byte*) cls::screen + (word) $3e7
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#0 = (byte*) 1024
Constant (const word) utoa16w::value#0 = 0
Constant (const word) utoa16w::value#1 = $4d2
Constant (const word) utoa16w::value#2 = $162e
Constant (const word) utoa16w::value#3 = $270f
Constant (const word) utoa16w::value#4 = $e608
Constant (const byte) main::i#0 = 0
Constant (const byte*) cls::$0 = cls::screen+$3e7
Constant (const byte*) cls::sc#0 = cls::screen
Constant (const byte) utoa10w::bStarted#0 = 0
Constant (const byte) utoa10w::digit#0 = 0
Constant (const byte) utoa10w::i#0 = 0
Constant (const byte) utoa10w::bStarted#1 = 1
Constant (const byte) utoa10w::digit#2 = 0
Constant (const byte) utoa16w::started#0 = 0
Constant (const word**) utoa16n::dst#0 = &utoa16w::dst
Constant (const word**) utoa16n::dst#1 = &utoa16w::dst
Constant (const word**) utoa16n::dst#2 = &utoa16w::dst
Constant (const word**) utoa16n::dst#3 = &utoa16w::dst
Constant (const byte) utoa16n::started#3 = 1
Constant (const byte) utoa16n::started#4 = 1
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) utoa16n::started#0 = utoa16w::started#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [2] if(true) goto main::@4
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [64] cls::sc#1 ← ++ cls::sc#2 to ++
Resolved ranged comparison value [66] if(cls::sc#1!=rangelast(cls::screen,cls::$0)) goto cls::@1 to (byte*)(const byte*) cls::$0+(number) 1
Resolved ranged next value [87] utoa10w::i#1 ← ++ utoa10w::i#2 to ++
Resolved ranged comparison value [89] if(utoa10w::i#1!=rangelast(0,7)) goto utoa10w::@2 to (number) 8
Eliminating unused variable (byte) utoa16w::started#3 and assignment [81] (byte) utoa16w::started#3 ← (byte) utoa16n::return#2
Eliminating unused variable (byte) utoa16n::return#3 and assignment [85] (byte) utoa16n::return#3 ← (byte) utoa16n::return#4
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused variable (byte) utoa16n::return#2 and assignment [80] (byte) utoa16n::return#2 ← (byte) utoa16n::return#4
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 1 in if((byte*) cls::sc#1!=(byte*)(const byte*) cls::$0+(number) 1) goto cls::@1
Adding number conversion cast (unumber) 8 in if((byte) utoa10w::i#1!=(number) 8) goto utoa10w::@2
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const byte*) cls::$0+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [11] (byte*) main::screen#1 ← (const byte*) main::screen#0 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#1 = main::screen#0+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [14] (byte*) main::screen#2 ← (const byte*) main::screen#1 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#2 = main::screen#1+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [17] (byte*) main::screen#3 ← (const byte*) main::screen#2 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#3 = main::screen#2+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [20] (byte*) main::screen#12 ← (const byte*) main::screen#3 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#12 = main::screen#3+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [26] (byte*) utoa10w::dst#0 ← (const byte*) main::screen#12 + (byte) $50
Constant right-side identified [30] (byte*~) main::$19 ← (const byte*) main::screen#12 + (byte) $50
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) utoa10w::dst#0 = main::screen#12+$50
Constant (const byte*) main::$19 = main::screen#12+$50
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [29] (byte*~) main::$20 ← (const byte*) main::$19 + (byte) 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::$20 = main::$19+3
Successful SSA optimization Pass2ConstantIdentification
Rewriting multiplication to use shift [37] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [40] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with different constant siblings (const byte*) main::screen#0
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with different constant siblings (const byte*) main::screen#1
Inlining constant with different constant siblings (const byte*) main::screen#2
Inlining constant with different constant siblings (const byte*) main::screen#3
Inlining constant with different constant siblings (const byte*) main::screen#12
Inlining constant with var siblings (const byte*) cls::sc#0
Inlining constant with var siblings (const byte) utoa10w::bStarted#0
Inlining constant with var siblings (const byte) utoa10w::digit#0
Inlining constant with var siblings (const byte) utoa10w::i#0
Inlining constant with var siblings (const byte) utoa10w::bStarted#1
Inlining constant with var siblings (const byte) utoa10w::digit#2
Inlining constant with var siblings (const byte*) utoa10w::dst#0
Inlining constant with var siblings (const word) utoa16w::value#0
Inlining constant with var siblings (const word) utoa16w::value#1
Inlining constant with var siblings (const word) utoa16w::value#2
Inlining constant with var siblings (const word) utoa16w::value#3
Inlining constant with var siblings (const word) utoa16w::value#4
Inlining constant with var siblings (const byte) utoa16w::started#0
Inlining constant with var siblings (const word**) utoa16n::dst#0
Inlining constant with var siblings (const word**) utoa16n::dst#1
Inlining constant with var siblings (const word**) utoa16n::dst#2
Inlining constant with var siblings (const word**) utoa16n::dst#3
Inlining constant with var siblings (const byte) utoa16n::started#3
Inlining constant with var siblings (const byte) utoa16n::started#4
Inlining constant with var siblings (const byte) utoa16n::started#0
Constant inlined main::screen#0 = (byte*) 1024
Constant inlined main::screen#1 = (byte*) 1024+(byte) $28
Constant inlined utoa16w::value#2 = (word) $162e
Constant inlined utoa16w::value#1 = (word) $4d2
Constant inlined main::screen#2 = (byte*) 1024+(byte) $28+(byte) $28
Constant inlined utoa16w::value#0 = (byte) 0
Constant inlined main::screen#3 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28
Constant inlined utoa10w::bStarted#1 = (byte) 1
Constant inlined utoa10w::bStarted#0 = (byte) 0
Constant inlined main::screen#12 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28
Constant inlined utoa16n::started#0 = (byte) 0
Constant inlined main::$19 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50
Constant inlined main::i#0 = (byte) 0
Constant inlined utoa16n::dst#1 = &(byte*) utoa16w::dst
Constant inlined utoa16n::dst#0 = &(byte*) utoa16w::dst
Constant inlined utoa16n::started#3 = (byte) 1
Constant inlined utoa16n::dst#3 = &(byte*) utoa16w::dst
Constant inlined utoa16n::started#4 = (byte) 1
Constant inlined utoa16n::dst#2 = &(byte*) utoa16w::dst
Constant inlined cls::sc#0 = (const byte*) cls::screen
Constant inlined main::$20 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3
Constant inlined utoa16w::started#0 = (byte) 0
Constant inlined cls::$0 = (const byte*) cls::screen+(word) $3e7
Constant inlined utoa10w::i#0 = (byte) 0
Constant inlined utoa10w::dst#0 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50
Constant inlined utoa10w::digit#0 = (byte) 0
Constant inlined utoa16w::value#4 = (word) $e608
Constant inlined utoa16w::value#3 = (word) $270f
Constant inlined utoa10w::digit#2 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values (word**) utoa16n::dst#4 &(byte*) utoa16w::dst
Successful SSA optimization Pass2IdenticalPhiElimination
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting cls::@3(between cls::@1 and cls::@1)
Added new block during phi lifting utoa10w::@13(between utoa10w::@10 and utoa10w::@2)
Added new block during phi lifting utoa10w::@14(between utoa10w::@4 and utoa10w::@10)
Added new block during phi lifting utoa10w::@15(between utoa10w::@8 and utoa10w::@11)
Added new block during phi lifting utoa16n::@6(between utoa16n and utoa16n::@1)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @5
Adding NOP phi() at start of @6
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@21
Adding NOP phi() at start of utoa16n::@3
Adding NOP phi() at start of utoa16n::@2
Adding NOP phi() at start of cls
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to cls:6 utoa16w:16 utoa16w:19 utoa16w:22 utoa16w:25 utoa16w:28 utoa10w:33 
Calls in [utoa16w] to utoa16n:79 utoa16n:87 utoa16n:95 utoa16n:99 

Created 14 initial phi equivalence classes
Coalesced [39] main::i#4 ← main::i#1
Coalesced [40] utoa10w::value#11 ← utoa10w::value#0
Coalesced [49] utoa10w::dst#17 ← utoa10w::dst#1
Coalesced [51] utoa10w::dst#14 ← utoa10w::dst#7
Coalesced [60] utoa10w::i#9 ← utoa10w::i#1
Coalesced (already) [61] utoa10w::value#12 ← utoa10w::value#10
Coalesced [62] utoa10w::digit#9 ← utoa10w::digit#7
Coalesced (already) [63] utoa10w::bStarted#8 ← utoa10w::bStarted#2
Coalesced [64] utoa10w::dst#12 ← utoa10w::dst#4
Coalesced (already) [65] utoa10w::dst#16 ← utoa10w::dst#11
Coalesced (already) [66] utoa10w::dst#15 ← utoa10w::dst#11
Coalesced (already) [67] utoa10w::digit#11 ← utoa10w::digit#3
Coalesced (already) [71] utoa10w::i#10 ← utoa10w::i#2
Coalesced [72] utoa10w::value#13 ← utoa10w::value#1
Coalesced [73] utoa10w::digit#10 ← utoa10w::digit#1
Coalesced (already) [74] utoa10w::dst#13 ← utoa10w::dst#11
Coalesced [78] utoa16n::nybble#8 ← utoa16n::nybble#0
Coalesced [85] utoa16n::nybble#9 ← utoa16n::nybble#1
Coalesced [86] utoa16n::started#9 ← utoa16n::started#1
Coalesced [93] utoa16n::nybble#10 ← utoa16n::nybble#2
Coalesced [94] utoa16n::started#10 ← utoa16n::started#2
Coalesced [98] utoa16n::nybble#11 ← utoa16n::nybble#3
Coalesced [111] utoa16n::return#10 ← utoa16n::started#7
Coalesced [118] cls::sc#3 ← cls::sc#1
Coalesced down to 10 phi equivalence classes
Culled Empty Block (label) @6
Culled Empty Block (label) main::@15
Culled Empty Block (label) main::@1
Culled Empty Block (label) main::@21
Culled Empty Block (label) utoa10w::@13
Culled Empty Block (label) utoa10w::@15
Culled Empty Block (label) utoa10w::@14
Culled Empty Block (label) utoa16n::@3
Culled Empty Block (label) utoa16n::@2
Culled Empty Block (label) cls::@3
Renumbering block @5 to @1
Renumbering block main::@4 to main::@1
Renumbering block main::@5 to main::@2
Renumbering block main::@6 to main::@3
Renumbering block main::@7 to main::@4
Renumbering block main::@16 to main::@5
Renumbering block main::@17 to main::@6
Renumbering block main::@18 to main::@7
Renumbering block main::@19 to main::@8
Renumbering block main::@20 to main::@9
Renumbering block utoa10w::@2 to utoa10w::@1
Renumbering block utoa10w::@3 to utoa10w::@2
Renumbering block utoa10w::@4 to utoa10w::@3
Renumbering block utoa10w::@8 to utoa10w::@4
Renumbering block utoa10w::@9 to utoa10w::@5
Renumbering block utoa10w::@10 to utoa10w::@6
Renumbering block utoa10w::@11 to utoa10w::@7
Renumbering block utoa10w::@12 to utoa10w::@8
Renumbering block utoa16n::@4 to utoa16n::@2
Renumbering block utoa16n::@6 to utoa16n::@3
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of utoa10w
Adding NOP phi() at start of utoa16n::@3
Adding NOP phi() at start of cls

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  asm { sei  }
  [5] call cls 
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@3
  [6] (byte~) main::$1 ← *((const byte*) control) & (byte) $80
  [7] (byte~) main::$2 ← *((const byte*) raster) >> (byte) 1
  [8] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2
  [9] if((byte) main::rst#0!=(byte) $30) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [10] *((const byte*) bordercol) ← (byte) 1
  [11] (byte) main::time_start#0 ← *((const byte*) raster)
  [12] (byte*) utoa16w::dst ← (byte*) 1024
  [13] call utoa16w 
  to:main::@5
main::@5: scope:[main]  from main::@2
  [14] *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  [15] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28
  [16] call utoa16w 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [17] *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  [18] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28
  [19] call utoa16w 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [20] *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  [21] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28
  [22] call utoa16w 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [23] *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  [24] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28
  [25] call utoa16w 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [26] (byte) main::time_end#0 ← *((const byte*) raster)
  [27] *((const byte*) bordercol) ← (byte) 0
  [28] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0
  [29] (word) utoa10w::value#0 ← (word)(byte) main::time#0
  [30] call utoa10w 
  to:main::@3
main::@3: scope:[main]  from main::@4 main::@9
  [31] (byte) main::i#2 ← phi( main::@9/(byte) 0 main::@4/(byte) main::i#1 )
  [32] if(*((const byte*) main::msg + (byte) main::i#2)!=(byte) 0) goto main::@4
  to:main::@1
main::@4: scope:[main]  from main::@3
  [33] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte*) main::msg + (byte) main::i#2)
  [34] (byte) main::i#1 ← ++ (byte) main::i#2
  to:main::@3

(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
utoa10w: scope:[utoa10w]  from main::@9
  [35] phi()
  to:utoa10w::@1
utoa10w::@1: scope:[utoa10w]  from utoa10w utoa10w::@2 utoa10w::@6
  [36] (byte*) utoa10w::dst#11 ← phi( utoa10w/(byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 utoa10w::@6/(byte*) utoa10w::dst#4 utoa10w::@2/(byte*) utoa10w::dst#11 )
  [36] (byte) utoa10w::bStarted#2 ← phi( utoa10w/(byte) 0 utoa10w::@6/(byte) utoa10w::bStarted#2 utoa10w::@2/(byte) 1 )
  [36] (byte) utoa10w::digit#3 ← phi( utoa10w/(byte) 0 utoa10w::@6/(byte) utoa10w::digit#7 utoa10w::@2/(byte) utoa10w::digit#1 )
  [36] (word) utoa10w::value#10 ← phi( utoa10w/(word) utoa10w::value#0 utoa10w::@6/(word) utoa10w::value#10 utoa10w::@2/(word) utoa10w::value#1 )
  [36] (byte) utoa10w::i#2 ← phi( utoa10w/(byte) 0 utoa10w::@6/(byte) utoa10w::i#1 utoa10w::@2/(byte) utoa10w::i#2 )
  [37] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1
  [38] if((word) utoa10w::value#10>=*((const word*) UTOA10_SUB + (byte~) utoa10w::$8)) goto utoa10w::@2
  to:utoa10w::@3
utoa10w::@3: scope:[utoa10w]  from utoa10w::@1
  [39] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1
  [40] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@6
  to:utoa10w::@4
utoa10w::@4: scope:[utoa10w]  from utoa10w::@3
  [41] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7
  to:utoa10w::@5
utoa10w::@5: scope:[utoa10w]  from utoa10w::@4
  [42] *((byte*) utoa10w::dst#11) ← *((const byte*) DIGITS + (byte) utoa10w::digit#3)
  [43] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11
  to:utoa10w::@7
utoa10w::@7: scope:[utoa10w]  from utoa10w::@4 utoa10w::@5
  [44] (byte*) utoa10w::dst#7 ← phi( utoa10w::@4/(byte*) utoa10w::dst#11 utoa10w::@5/(byte*) utoa10w::dst#1 )
  to:utoa10w::@6
utoa10w::@6: scope:[utoa10w]  from utoa10w::@3 utoa10w::@7
  [45] (byte) utoa10w::digit#7 ← phi( utoa10w::@7/(byte) 0 utoa10w::@3/(byte) utoa10w::digit#3 )
  [45] (byte*) utoa10w::dst#4 ← phi( utoa10w::@7/(byte*) utoa10w::dst#7 utoa10w::@3/(byte*) utoa10w::dst#11 )
  [46] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2
  [47] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1
  to:utoa10w::@8
utoa10w::@8: scope:[utoa10w]  from utoa10w::@6
  [48] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10
  [49] *((byte*) utoa10w::dst#4) ← *((const byte*) DIGITS + (byte~) utoa10w::$0)
  [50] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4
  [51] *((byte*) utoa10w::dst#2) ← (byte) 0
  to:utoa10w::@return
utoa10w::@return: scope:[utoa10w]  from utoa10w::@8
  [52] return 
  to:@return
utoa10w::@2: scope:[utoa10w]  from utoa10w::@1
  [53] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte*) UTOA10_VAL + (byte) utoa10w::i#2)
  [54] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1
  [55] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word*) UTOA10_SUB + (byte~) utoa10w::$9)
  to:utoa10w::@1

(void()) utoa16w((word) utoa16w::value , (byte*) utoa16w::dst)
utoa16w: scope:[utoa16w]  from main::@2 main::@5 main::@6 main::@7 main::@8
  [56] (word) utoa16w::value#5 ← phi( main::@5/(word) $4d2 main::@6/(word) $162e main::@7/(word) $270f main::@8/(word) $e608 main::@2/(byte) 0 )
  [57] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5
  [58] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4
  [59] call utoa16n 
  [60] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  [61] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
  [62] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5
  [63] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$3 & (byte) $f
  [64] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  [65] call utoa16n 
  [66] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  [67] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
  [68] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5
  [69] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4
  [70] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  [71] call utoa16n 
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  [72] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5
  [73] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$9 & (byte) $f
  [74] call utoa16n 
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  [75] *((byte*) utoa16w::dst) ← (byte) 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  [76] return 
  to:@return

(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  [77] (byte) utoa16n::started#7 ← phi( utoa16w/(byte) 0 utoa16w::@1/(byte) utoa16n::started#1 utoa16w::@2/(byte) utoa16n::started#2 utoa16w::@3/(byte) 1 )
  [77] (byte) utoa16n::nybble#4 ← phi( utoa16w/(byte) utoa16n::nybble#0 utoa16w::@1/(byte) utoa16n::nybble#1 utoa16w::@2/(byte) utoa16n::nybble#2 utoa16w::@3/(byte) utoa16n::nybble#3 )
  [78] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3
  to:utoa16n::@1
utoa16n::@3: scope:[utoa16n]  from utoa16n
  [79] phi()
  to:utoa16n::@1
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  [80] (byte) utoa16n::return#4 ← phi( utoa16n::@3/(byte) utoa16n::started#7 utoa16n/(byte) 1 )
  [81] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return
  to:utoa16n::@2
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1
  [82] *(*(&(byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4)
  [83] *(&(byte*) utoa16w::dst) ← ++ *(&(byte*) utoa16w::dst)
  to:utoa16n::@return
utoa16n::@return: scope:[utoa16n]  from utoa16n::@1 utoa16n::@2
  [84] return 
  to:@return

(void()) cls()
cls: scope:[cls]  from main
  [85] phi()
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  [86] (byte*) cls::sc#2 ← phi( cls/(const byte*) cls::screen cls::@1/(byte*) cls::sc#1 )
  [87] *((byte*) cls::sc#2) ← (byte) ' '
  [88] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2
  [89] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  [90] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) cls()
(byte*) cls::sc
(byte*) cls::sc#1 16.5
(byte*) cls::sc#2 16.5
(void()) main()
(byte~) main::$1 101.0
(byte~) main::$2 202.0
(byte) main::i
(byte) main::i#1 202.0
(byte) main::i#2 168.33333333333331
(byte) main::rst
(byte) main::rst#0 202.0
(byte*) main::screen
(byte) main::time
(byte) main::time#0 11.0
(byte) main::time_end
(byte) main::time_end#0 11.0
(byte) main::time_start
(byte) main::time_start#0 1.2941176470588236
(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
(byte~) utoa10w::$0 4.0
(byte~) utoa10w::$2 202.0
(byte~) utoa10w::$8 202.0
(byte~) utoa10w::$9 202.0
(byte) utoa10w::bStarted
(byte) utoa10w::bStarted#2 25.25
(byte) utoa10w::digit
(byte) utoa10w::digit#1 67.33333333333333
(byte) utoa10w::digit#3 84.16666666666666
(byte) utoa10w::digit#7 67.33333333333333
(byte*) utoa10w::dst
(byte*) utoa10w::dst#1 202.0
(byte*) utoa10w::dst#11 70.7
(byte*) utoa10w::dst#2 4.0
(byte*) utoa10w::dst#4 61.39999999999999
(byte*) utoa10w::dst#7 303.0
(byte) utoa10w::i
(byte) utoa10w::i#1 151.5
(byte) utoa10w::i#2 62.153846153846146
(word) utoa10w::value
(word) utoa10w::value#0 6.5
(word) utoa10w::value#1 202.0
(word) utoa10w::value#10 36.214285714285715
(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
(word**) utoa16n::dst
(byte) utoa16n::nybble
(byte) utoa16n::nybble#0 4.0
(byte) utoa16n::nybble#1 2.0
(byte) utoa16n::nybble#2 2.0
(byte) utoa16n::nybble#3 4.0
(byte) utoa16n::nybble#4 2.4
(byte) utoa16n::return
(byte) utoa16n::return#0 4.0
(byte) utoa16n::return#1 4.0
(byte) utoa16n::return#4 1.1428571428571428
(byte) utoa16n::started
(byte) utoa16n::started#1 4.0
(byte) utoa16n::started#2 4.0
(byte) utoa16n::started#7 2.0
(void()) utoa16w((word) utoa16w::value , (byte*) utoa16w::dst)
(byte~) utoa16w::$0 4.0
(byte~) utoa16w::$3 4.0
(byte~) utoa16w::$6 4.0
(byte~) utoa16w::$9 4.0
(byte*) utoa16w::dst loadstore 1.78125
(byte) utoa16w::started
(byte) utoa16w::started#1 1.3333333333333333
(byte) utoa16w::started#2 1.3333333333333333
(word) utoa16w::value
(word) utoa16w::value#5 0.5

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ utoa10w::i#2 utoa10w::i#1 ]
[ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
[ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
[ utoa10w::bStarted#2 ]
[ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ]
[ utoa16w::value#5 ]
[ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
[ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
[ cls::sc#2 cls::sc#1 ]
Added variable main::$1 to live range equivalence class [ main::$1 ]
Added variable main::$2 to live range equivalence class [ main::$2 ]
Added variable main::rst#0 to live range equivalence class [ main::rst#0 ]
Added variable main::time_start#0 to live range equivalence class [ main::time_start#0 ]
Added variable utoa16w::dst to live range equivalence class [ utoa16w::dst ]
Added variable main::time_end#0 to live range equivalence class [ main::time_end#0 ]
Added variable main::time#0 to live range equivalence class [ main::time#0 ]
Added variable utoa10w::$8 to live range equivalence class [ utoa10w::$8 ]
Added variable utoa10w::$2 to live range equivalence class [ utoa10w::$2 ]
Added variable utoa10w::$0 to live range equivalence class [ utoa10w::$0 ]
Added variable utoa10w::dst#2 to live range equivalence class [ utoa10w::dst#2 ]
Added variable utoa10w::$9 to live range equivalence class [ utoa10w::$9 ]
Added variable utoa16w::$0 to live range equivalence class [ utoa16w::$0 ]
Added variable utoa16n::return#0 to live range equivalence class [ utoa16n::return#0 ]
Added variable utoa16w::started#1 to live range equivalence class [ utoa16w::started#1 ]
Added variable utoa16w::$3 to live range equivalence class [ utoa16w::$3 ]
Added variable utoa16n::return#1 to live range equivalence class [ utoa16n::return#1 ]
Added variable utoa16w::started#2 to live range equivalence class [ utoa16w::started#2 ]
Added variable utoa16w::$6 to live range equivalence class [ utoa16w::$6 ]
Added variable utoa16w::$9 to live range equivalence class [ utoa16w::$9 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ utoa10w::i#2 utoa10w::i#1 ]
[ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
[ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
[ utoa10w::bStarted#2 ]
[ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ]
[ utoa16w::value#5 ]
[ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
[ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
[ cls::sc#2 cls::sc#1 ]
[ main::$1 ]
[ main::$2 ]
[ main::rst#0 ]
[ main::time_start#0 ]
[ utoa16w::dst ]
[ main::time_end#0 ]
[ main::time#0 ]
[ utoa10w::$8 ]
[ utoa10w::$2 ]
[ utoa10w::$0 ]
[ utoa10w::dst#2 ]
[ utoa10w::$9 ]
[ utoa16w::$0 ]
[ utoa16n::return#0 ]
[ utoa16w::started#1 ]
[ utoa16w::$3 ]
[ utoa16n::return#1 ]
[ utoa16w::started#2 ]
[ utoa16w::$6 ]
[ utoa16w::$9 ]
Allocated zp[1]:2 [ main::i#2 main::i#1 ]
Allocated zp[1]:3 [ utoa10w::i#2 utoa10w::i#1 ]
Allocated zp[2]:4 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
Allocated zp[1]:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
Allocated zp[1]:7 [ utoa10w::bStarted#2 ]
Allocated zp[2]:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ]
Allocated zp[2]:10 [ utoa16w::value#5 ]
Allocated zp[1]:12 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
Allocated zp[1]:13 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Allocated zp[2]:14 [ cls::sc#2 cls::sc#1 ]
Allocated zp[1]:16 [ main::$1 ]
Allocated zp[1]:17 [ main::$2 ]
Allocated zp[1]:18 [ main::rst#0 ]
Allocated zp[1]:19 [ main::time_start#0 ]
Allocated zp[2]:20 [ utoa16w::dst ]
Allocated zp[1]:22 [ main::time_end#0 ]
Allocated zp[1]:23 [ main::time#0 ]
Allocated zp[1]:24 [ utoa10w::$8 ]
Allocated zp[1]:25 [ utoa10w::$2 ]
Allocated zp[1]:26 [ utoa10w::$0 ]
Allocated zp[2]:27 [ utoa10w::dst#2 ]
Allocated zp[1]:29 [ utoa10w::$9 ]
Allocated zp[1]:30 [ utoa16w::$0 ]
Allocated zp[1]:31 [ utoa16n::return#0 ]
Allocated zp[1]:32 [ utoa16w::started#1 ]
Allocated zp[1]:33 [ utoa16w::$3 ]
Allocated zp[1]:34 [ utoa16n::return#1 ]
Allocated zp[1]:35 [ utoa16w::started#2 ]
Allocated zp[1]:36 [ utoa16w::$6 ]
Allocated zp[1]:37 [ utoa16w::$9 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Testing hex to decimal conversion
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label control = $d011
  .label raster = $d012
  .label bordercol = $d020
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label __1 = $10
    .label __2 = $11
    .label rst = $12
    .label time_start = $13
    .label time_end = $16
    .label time = $17
    .label i = 2
    // asm { sei  }
    sei
    // [5] call cls 
    // [85] phi from main to cls [phi:main->cls]
  cls_from_main:
    jsr cls
    jmp __b1
    // main::@1
  __b1:
    // [6] (byte~) main::$1 ← *((const byte*) control) & (byte) $80 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #$80
    and control
    sta.z __1
    // [7] (byte~) main::$2 ← *((const byte*) raster) >> (byte) 1 -- vbuz1=_deref_pbuc1_ror_1 
    lda raster
    lsr
    sta.z __2
    // [8] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2 -- vbuz1=vbuz2_bor_vbuz3 
    lda.z __1
    ora.z __2
    sta.z rst
    // [9] if((byte) main::rst#0!=(byte) $30) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$30
    cmp.z rst
    bne __b1
    jmp __b2
    // main::@2
  __b2:
    // [10] *((const byte*) bordercol) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta bordercol
    // [11] (byte) main::time_start#0 ← *((const byte*) raster) -- vbuz1=_deref_pbuc1 
    lda raster
    sta.z time_start
    // [12] (byte*) utoa16w::dst ← (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z utoa16w.dst
    lda #>$400
    sta.z utoa16w.dst+1
    // [13] call utoa16w 
    // [56] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
  utoa16w_from___b2:
    // [56] phi (word) utoa16w::value#5 = (byte) 0 [phi:main::@2->utoa16w#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z utoa16w.value
    lda #>0
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b5
    // main::@5
  __b5:
    // [14] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // [15] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28
    sta.z utoa16w.dst
    lda #>$400+$28
    sta.z utoa16w.dst+1
    // [16] call utoa16w 
    // [56] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
  utoa16w_from___b5:
    // [56] phi (word) utoa16w::value#5 = (word) $4d2 [phi:main::@5->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z utoa16w.value
    lda #>$4d2
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b6
    // main::@6
  __b6:
    // [17] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // [18] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28
    sta.z utoa16w.dst+1
    // [19] call utoa16w 
    // [56] phi from main::@6 to utoa16w [phi:main::@6->utoa16w]
  utoa16w_from___b6:
    // [56] phi (word) utoa16w::value#5 = (word) $162e [phi:main::@6->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$162e
    sta.z utoa16w.value
    lda #>$162e
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b7
    // main::@7
  __b7:
    // [20] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // [21] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28
    sta.z utoa16w.dst+1
    // [22] call utoa16w 
    // [56] phi from main::@7 to utoa16w [phi:main::@7->utoa16w]
  utoa16w_from___b7:
    // [56] phi (word) utoa16w::value#5 = (word) $270f [phi:main::@7->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$270f
    sta.z utoa16w.value
    lda #>$270f
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b8
    // main::@8
  __b8:
    // [23] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // [24] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta.z utoa16w.dst+1
    // [25] call utoa16w 
    // [56] phi from main::@8 to utoa16w [phi:main::@8->utoa16w]
  utoa16w_from___b8:
    // [56] phi (word) utoa16w::value#5 = (word) $e608 [phi:main::@8->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$e608
    sta.z utoa16w.value
    lda #>$e608
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b9
    // main::@9
  __b9:
    // [26] (byte) main::time_end#0 ← *((const byte*) raster) -- vbuz1=_deref_pbuc1 
    lda raster
    sta.z time_end
    // [27] *((const byte*) bordercol) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta bordercol
    // [28] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z time_end
    sec
    sbc.z time_start
    sta.z time
    // [29] (word) utoa10w::value#0 ← (word)(byte) main::time#0 -- vwuz1=_word_vbuz2 
    lda.z time
    sta.z utoa10w.value
    lda #0
    sta.z utoa10w.value+1
    // [30] call utoa10w 
    // [35] phi from main::@9 to utoa10w [phi:main::@9->utoa10w]
  utoa10w_from___b9:
    jsr utoa10w
    // [31] phi from main::@9 to main::@3 [phi:main::@9->main::@3]
  __b3_from___b9:
    // [31] phi (byte) main::i#2 = (byte) 0 [phi:main::@9->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b3
    // main::@3
  __b3:
    // [32] if(*((const byte*) main::msg + (byte) main::i#2)!=(byte) 0) goto main::@4 -- pbuc1_derefidx_vbuz1_neq_0_then_la1 
    ldy.z i
    lda msg,y
    cmp #0
    bne __b4
    jmp __b1
    // main::@4
  __b4:
    // [33] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte*) main::msg + (byte) main::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda msg,y
    sta $400+$28+$28+$28+$28+$50+3,y
    // [34] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [31] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [31] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
    msg: .text "raster lines"
    .byte 0
}
  // utoa10w
// Decimal utoa() without using multiply or divide
// utoa10w(word zp(4) value, byte* zp(8) dst)
utoa10w: {
    .label __0 = $1a
    .label __2 = $19
    .label __8 = $18
    .label __9 = $1d
    .label value = 4
    .label digit = 6
    .label i = 3
    .label dst = 8
    .label dst_1 = $1b
    .label bStarted = 7
    // [36] phi from utoa10w to utoa10w::@1 [phi:utoa10w->utoa10w::@1]
  __b1_from_utoa10w:
    // [36] phi (byte*) utoa10w::dst#11 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 [phi:utoa10w->utoa10w::@1#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28+$50
    sta.z dst
    lda #>$400+$28+$28+$28+$28+$50
    sta.z dst+1
    // [36] phi (byte) utoa10w::bStarted#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z bStarted
    // [36] phi (byte) utoa10w::digit#3 = (byte) 0 [phi:utoa10w->utoa10w::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [36] phi (word) utoa10w::value#10 = (word) utoa10w::value#0 [phi:utoa10w->utoa10w::@1#3] -- register_copy 
    // [36] phi (byte) utoa10w::i#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#4] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [36] phi from utoa10w::@6 to utoa10w::@1 [phi:utoa10w::@6->utoa10w::@1]
  __b1_from___b6:
    // [36] phi (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#4 [phi:utoa10w::@6->utoa10w::@1#0] -- register_copy 
    // [36] phi (byte) utoa10w::bStarted#2 = (byte) utoa10w::bStarted#2 [phi:utoa10w::@6->utoa10w::@1#1] -- register_copy 
    // [36] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#7 [phi:utoa10w::@6->utoa10w::@1#2] -- register_copy 
    // [36] phi (word) utoa10w::value#10 = (word) utoa10w::value#10 [phi:utoa10w::@6->utoa10w::@1#3] -- register_copy 
    // [36] phi (byte) utoa10w::i#2 = (byte) utoa10w::i#1 [phi:utoa10w::@6->utoa10w::@1#4] -- register_copy 
    jmp __b1
    // utoa10w::@1
  __b1:
    // [37] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z i
    asl
    sta.z __8
    // [38] if((word) utoa10w::value#10>=*((const word*) UTOA10_SUB + (byte~) utoa10w::$8)) goto utoa10w::@2 -- vwuz1_ge_pwuc1_derefidx_vbuz2_then_la1 
    ldy.z __8
    lda UTOA10_SUB+1,y
    cmp.z value+1
    bne !+
    lda UTOA10_SUB,y
    cmp.z value
    beq __b2
  !:
    bcc __b2
    jmp __b3
    // utoa10w::@3
  __b3:
    // [39] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and.z i
    sta.z __2
    // [40] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@6 -- vbuz1_eq_0_then_la1 
    lda.z __2
    cmp #0
    beq __b6_from___b3
    jmp __b4
    // utoa10w::@4
  __b4:
    // [41] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7 -- vbuz1_eq_0_then_la1 
    lda.z bStarted
    cmp #0
    beq __b7_from___b4
    jmp __b5
    // utoa10w::@5
  __b5:
    // [42] *((byte*) utoa10w::dst#11) ← *((const byte*) DIGITS + (byte) utoa10w::digit#3) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z digit
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // [43] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [44] phi from utoa10w::@4 utoa10w::@5 to utoa10w::@7 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7]
  __b7_from___b4:
  __b7_from___b5:
    // [44] phi (byte*) utoa10w::dst#7 = (byte*) utoa10w::dst#11 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7#0] -- register_copy 
    jmp __b7
    // utoa10w::@7
  __b7:
    // [45] phi from utoa10w::@7 to utoa10w::@6 [phi:utoa10w::@7->utoa10w::@6]
  __b6_from___b7:
    // [45] phi (byte) utoa10w::digit#7 = (byte) 0 [phi:utoa10w::@7->utoa10w::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [45] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#7 [phi:utoa10w::@7->utoa10w::@6#1] -- register_copy 
    jmp __b6
    // [45] phi from utoa10w::@3 to utoa10w::@6 [phi:utoa10w::@3->utoa10w::@6]
  __b6_from___b3:
    // [45] phi (byte) utoa10w::digit#7 = (byte) utoa10w::digit#3 [phi:utoa10w::@3->utoa10w::@6#0] -- register_copy 
    // [45] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#11 [phi:utoa10w::@3->utoa10w::@6#1] -- register_copy 
    jmp __b6
    // utoa10w::@6
  __b6:
    // [46] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [47] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z i
    bne __b1_from___b6
    jmp __b8
    // utoa10w::@8
  __b8:
    // [48] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 -- vbuz1=_byte_vwuz2 
    lda.z value
    sta.z __0
    // [49] *((byte*) utoa10w::dst#4) ← *((const byte*) DIGITS + (byte~) utoa10w::$0) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z __0
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // [50] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 -- pbuz1=_inc_pbuz2 
    lda.z dst
    clc
    adc #1
    sta.z dst_1
    lda.z dst+1
    adc #0
    sta.z dst_1+1
    // [51] *((byte*) utoa10w::dst#2) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst_1),y
    jmp __breturn
    // utoa10w::@return
  __breturn:
    // [52] return 
    rts
    // utoa10w::@2
  __b2:
    // [53] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte*) UTOA10_VAL + (byte) utoa10w::i#2) -- vbuz1=vbuz1_plus_pbuc1_derefidx_vbuz2 
    lda.z digit
    ldy.z i
    clc
    adc UTOA10_VAL,y
    sta.z digit
    // [54] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z i
    asl
    sta.z __9
    // [55] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word*) UTOA10_SUB + (byte~) utoa10w::$9) -- vwuz1=vwuz1_minus_pwuc1_derefidx_vbuz2 
    ldy.z __9
    sec
    lda.z value
    sbc UTOA10_SUB,y
    sta.z value
    lda.z value+1
    sbc UTOA10_SUB+1,y
    sta.z value+1
    // [36] phi from utoa10w::@2 to utoa10w::@1 [phi:utoa10w::@2->utoa10w::@1]
  __b1_from___b2:
    // [36] phi (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#11 [phi:utoa10w::@2->utoa10w::@1#0] -- register_copy 
    // [36] phi (byte) utoa10w::bStarted#2 = (byte) 1 [phi:utoa10w::@2->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #1
    sta.z bStarted
    // [36] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#1 [phi:utoa10w::@2->utoa10w::@1#2] -- register_copy 
    // [36] phi (word) utoa10w::value#10 = (word) utoa10w::value#1 [phi:utoa10w::@2->utoa10w::@1#3] -- register_copy 
    // [36] phi (byte) utoa10w::i#2 = (byte) utoa10w::i#2 [phi:utoa10w::@2->utoa10w::@1#4] -- register_copy 
    jmp __b1
}
  // utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zp($a) value, byte* zp($14) dst)
utoa16w: {
    .label dst = $14
    .label __0 = $1e
    .label __3 = $21
    .label __6 = $24
    .label __9 = $25
    .label started = $20
    .label started_1 = $23
    .label value = $a
    // [57] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 -- vbuz1=_hi_vwuz2 
    lda.z value+1
    sta.z __0
    // [58] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda.z __0
    lsr
    lsr
    lsr
    lsr
    sta.z utoa16n.nybble
    // [59] call utoa16n 
    // [77] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
  utoa16n_from_utoa16w:
    // [77] phi (byte) utoa16n::started#7 = (byte) 0 [phi:utoa16w->utoa16n#0] -- vbuz1=vbuc1 
    lda #0
    sta.z utoa16n.started
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [60] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4 -- vbuz1=vbuz2 
    lda.z utoa16n.return_2
    sta.z utoa16n.return
    jmp __b1
    // utoa16w::@1
  __b1:
    // [61] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0 -- vbuz1=vbuz2 
    lda.z utoa16n.return
    sta.z started
    // [62] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5 -- vbuz1=_hi_vwuz2 
    lda.z value+1
    sta.z __3
    // [63] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$3 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and.z __3
    sta.z utoa16n.nybble
    // [64] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1 -- vbuz1=vbuz2 
    lda.z started
    sta.z utoa16n.started
    // [65] call utoa16n 
    // [77] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
  utoa16n_from___b1:
    // [77] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [66] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4 -- vbuz1=vbuz2 
    lda.z utoa16n.return_2
    sta.z utoa16n.return_1
    jmp __b2
    // utoa16w::@2
  __b2:
    // [67] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1 -- vbuz1=vbuz2 
    lda.z utoa16n.return_1
    sta.z started_1
    // [68] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5 -- vbuz1=_lo_vwuz2 
    lda.z value
    sta.z __6
    // [69] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda.z __6
    lsr
    lsr
    lsr
    lsr
    sta.z utoa16n.nybble
    // [70] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2 -- vbuz1=vbuz2 
    lda.z started_1
    sta.z utoa16n.started
    // [71] call utoa16n 
    // [77] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
  utoa16n_from___b2:
    // [77] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b3
    // utoa16w::@3
  __b3:
    // [72] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5 -- vbuz1=_lo_vwuz2 
    lda.z value
    sta.z __9
    // [73] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$9 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and.z __9
    sta.z utoa16n.nybble
    // [74] call utoa16n 
    // [77] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
  utoa16n_from___b3:
    // [77] phi (byte) utoa16n::started#7 = (byte) 1 [phi:utoa16w::@3->utoa16n#0] -- vbuz1=vbuc1 
    lda #1
    sta.z utoa16n.started
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b4
    // utoa16w::@4
  __b4:
    // [75] *((byte*) utoa16w::dst) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp __breturn
    // utoa16w::@return
  __breturn:
    // [76] return 
    rts
}
  // utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte zp($c) nybble, byte zp($d) started)
utoa16n: {
    .label nybble = $c
    .label return = $1f
    .label started = $d
    .label return_1 = $22
    .label return_2 = $d
    // [78] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3 -- vbuz1_eq_0_then_la1 
    lda.z nybble
    cmp #0
    beq __b3_from_utoa16n
    // [80] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
  __b1_from_utoa16n:
    // [80] phi (byte) utoa16n::return#4 = (byte) 1 [phi:utoa16n->utoa16n::@1#0] -- vbuz1=vbuc1 
    lda #1
    sta.z return_2
    jmp __b1
    // [79] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
  __b3_from_utoa16n:
    jmp __b3
    // utoa16n::@3
  __b3:
    // [80] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
  __b1_from___b3:
    // [80] phi (byte) utoa16n::return#4 = (byte) utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    jmp __b1
    // utoa16n::@1
  __b1:
    // [81] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return -- vbuz1_eq_0_then_la1 
    lda.z return_2
    cmp #0
    beq __breturn
    jmp __b2
    // utoa16n::@2
  __b2:
    // [82] *(*(&(byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) -- _deref_(_deref_pptc1)=pbuc2_derefidx_vbuz1 
    ldy.z nybble
    lda DIGITS,y
    ldy.z utoa16w.dst
    sty.z $fe
    ldy.z utoa16w.dst+1
    sty.z $ff
    ldy #0
    sta ($fe),y
    // [83] *(&(byte*) utoa16w::dst) ← ++ *(&(byte*) utoa16w::dst) -- _deref_pptc1=_inc__deref_pptc1 
    inc.z utoa16w.dst
    bne !+
    inc.z utoa16w.dst+1
  !:
    jmp __breturn
    // utoa16n::@return
  __breturn:
    // [84] return 
    rts
}
  // cls
cls: {
    .label screen = $400
    .label sc = $e
    // [86] phi from cls to cls::@1 [phi:cls->cls::@1]
  __b1_from_cls:
    // [86] phi (byte*) cls::sc#2 = (const byte*) cls::screen [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta.z sc
    lda #>screen
    sta.z sc+1
    jmp __b1
    // [86] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
  __b1_from___b1:
    // [86] phi (byte*) cls::sc#2 = (byte*) cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    jmp __b1
    // cls::@1
  __b1:
    // [87] *((byte*) cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [88] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [89] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>screen+$3e7+1
    bne __b1_from___b1
    lda.z sc
    cmp #<screen+$3e7+1
    bne __b1_from___b1
    jmp __breturn
    // cls::@return
  __breturn:
    // [90] return 
    rts
}
  // File Data
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef"
  .byte 0
  // Subtraction values used for decimal utoa()
  UTOA10_SUB: .word $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a
  // Digit addition values used for decimal utoa()
  UTOA10_VAL: .byte 3, 1, 3, 1, 3, 1, 3, 1

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] (byte~) main::$1 ← *((const byte*) control) & (byte) $80 [ main::$1 ] ( main:2 [ main::$1 ] ) always clobbers reg byte a 
Statement [7] (byte~) main::$2 ← *((const byte*) raster) >> (byte) 1 [ main::$1 main::$2 ] ( main:2 [ main::$1 main::$2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:16 [ main::$1 ]
Statement [10] *((const byte*) bordercol) ← (byte) 1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] (byte*) utoa16w::dst ← (byte*) 1024 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:19 [ main::time_start#0 ]
Statement [15] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Statement [18] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Statement [21] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Statement [24] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Statement [27] *((const byte*) bordercol) ← (byte) 0 [ main::time_start#0 main::time_end#0 ] ( main:2 [ main::time_start#0 main::time_end#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:22 [ main::time_end#0 ]
Statement [28] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 [ main::time#0 ] ( main:2 [ main::time#0 ] ) always clobbers reg byte a 
Statement [29] (word) utoa10w::value#0 ← (word)(byte) main::time#0 [ utoa10w::value#0 ] ( main:2 [ utoa10w::value#0 ] ) always clobbers reg byte a 
Statement [32] if(*((const byte*) main::msg + (byte) main::i#2)!=(byte) 0) goto main::@4 [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::i#2 main::i#1 ]
Statement [33] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte*) main::msg + (byte) main::i#2) [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Statement [37] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:3 [ utoa10w::i#2 utoa10w::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ utoa10w::bStarted#2 ]
Statement [38] if((word) utoa10w::value#10>=*((const word*) UTOA10_SUB + (byte~) utoa10w::$8)) goto utoa10w::@2 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 ] ) always clobbers reg byte a 
Statement [39] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$2 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$2 ] ) always clobbers reg byte a 
Statement [42] *((byte*) utoa10w::dst#11) ← *((const byte*) DIGITS + (byte) utoa10w::digit#3) [ utoa10w::i#2 utoa10w::value#10 utoa10w::bStarted#2 utoa10w::dst#11 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::bStarted#2 utoa10w::dst#11 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:3 [ utoa10w::i#2 utoa10w::i#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:7 [ utoa10w::bStarted#2 ]
Statement [48] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 [ utoa10w::dst#4 utoa10w::$0 ] ( main:2::utoa10w:30 [ utoa10w::dst#4 utoa10w::$0 ] ) always clobbers reg byte a 
Statement [49] *((byte*) utoa10w::dst#4) ← *((const byte*) DIGITS + (byte~) utoa10w::$0) [ utoa10w::dst#4 ] ( main:2::utoa10w:30 [ utoa10w::dst#4 ] ) always clobbers reg byte a reg byte y 
Statement [50] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 [ utoa10w::dst#2 ] ( main:2::utoa10w:30 [ utoa10w::dst#2 ] ) always clobbers reg byte a 
Statement [51] *((byte*) utoa10w::dst#2) ← (byte) 0 [ ] ( main:2::utoa10w:30 [ ] ) always clobbers reg byte a reg byte y 
Statement [53] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte*) UTOA10_VAL + (byte) utoa10w::i#2) [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 ] ) always clobbers reg byte a 
Statement [54] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 utoa10w::$9 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 utoa10w::$9 ] ) always clobbers reg byte a 
Statement [55] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word*) UTOA10_SUB + (byte~) utoa10w::$9) [ utoa10w::i#2 utoa10w::dst#11 utoa10w::value#1 utoa10w::digit#1 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::dst#11 utoa10w::value#1 utoa10w::digit#1 ] ) always clobbers reg byte a 
Statement [57] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 [ utoa16w::dst utoa16w::value#5 utoa16w::$0 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] ) always clobbers reg byte a 
Statement [58] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] ) always clobbers reg byte a 
Statement [62] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5 [ utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:32 [ utoa16w::started#1 ]
Statement [68] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:35 [ utoa16w::started#2 ]
Statement [69] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] ) always clobbers reg byte a 
Statement [72] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5 [ utoa16w::dst utoa16w::$9 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] ) always clobbers reg byte a 
Statement [75] *((byte*) utoa16w::dst) ← (byte) 0 [ ] ( main:2::utoa16w:13 [ main::time_start#0 ] main:2::utoa16w:16 [ main::time_start#0 ] main:2::utoa16w:19 [ main::time_start#0 ] main:2::utoa16w:22 [ main::time_start#0 ] main:2::utoa16w:25 [ main::time_start#0 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:19 [ main::time_start#0 ]
Statement [82] *(*(&(byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) [ utoa16w::dst utoa16n::return#4 ] ( main:2::utoa16w:13::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:19::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:22::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:25::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:13::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:19::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:22::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:25::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:13::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:19::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:22::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:25::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:13::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:19::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:22::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:25::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:13 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Removing always clobbered register reg byte y as potential for zp[1]:13 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Statement [87] *((byte*) cls::sc#2) ← (byte) ' ' [ cls::sc#2 ] ( main:2::cls:5 [ cls::sc#2 ] ) always clobbers reg byte a reg byte y 
Statement [89] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 [ cls::sc#1 ] ( main:2::cls:5 [ cls::sc#1 ] ) always clobbers reg byte a 
Statement [6] (byte~) main::$1 ← *((const byte*) control) & (byte) $80 [ main::$1 ] ( main:2 [ main::$1 ] ) always clobbers reg byte a 
Statement [7] (byte~) main::$2 ← *((const byte*) raster) >> (byte) 1 [ main::$1 main::$2 ] ( main:2 [ main::$1 main::$2 ] ) always clobbers reg byte a 
Statement [10] *((const byte*) bordercol) ← (byte) 1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] (byte*) utoa16w::dst ← (byte*) 1024 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Statement [15] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Statement [18] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Statement [21] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Statement [24] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 [ main::time_start#0 utoa16w::dst ] ( main:2 [ main::time_start#0 utoa16w::dst ] ) always clobbers reg byte a 
Statement [27] *((const byte*) bordercol) ← (byte) 0 [ main::time_start#0 main::time_end#0 ] ( main:2 [ main::time_start#0 main::time_end#0 ] ) always clobbers reg byte a 
Statement [28] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 [ main::time#0 ] ( main:2 [ main::time#0 ] ) always clobbers reg byte a 
Statement [29] (word) utoa10w::value#0 ← (word)(byte) main::time#0 [ utoa10w::value#0 ] ( main:2 [ utoa10w::value#0 ] ) always clobbers reg byte a 
Statement [32] if(*((const byte*) main::msg + (byte) main::i#2)!=(byte) 0) goto main::@4 [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Statement [33] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte*) main::msg + (byte) main::i#2) [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Statement [37] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ) always clobbers reg byte a 
Statement [38] if((word) utoa10w::value#10>=*((const word*) UTOA10_SUB + (byte~) utoa10w::$8)) goto utoa10w::@2 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 ] ) always clobbers reg byte a 
Statement [39] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$2 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$2 ] ) always clobbers reg byte a 
Statement [42] *((byte*) utoa10w::dst#11) ← *((const byte*) DIGITS + (byte) utoa10w::digit#3) [ utoa10w::i#2 utoa10w::value#10 utoa10w::bStarted#2 utoa10w::dst#11 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::bStarted#2 utoa10w::dst#11 ] ) always clobbers reg byte a reg byte y 
Statement [48] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 [ utoa10w::dst#4 utoa10w::$0 ] ( main:2::utoa10w:30 [ utoa10w::dst#4 utoa10w::$0 ] ) always clobbers reg byte a 
Statement [49] *((byte*) utoa10w::dst#4) ← *((const byte*) DIGITS + (byte~) utoa10w::$0) [ utoa10w::dst#4 ] ( main:2::utoa10w:30 [ utoa10w::dst#4 ] ) always clobbers reg byte a reg byte y 
Statement [50] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 [ utoa10w::dst#2 ] ( main:2::utoa10w:30 [ utoa10w::dst#2 ] ) always clobbers reg byte a 
Statement [51] *((byte*) utoa10w::dst#2) ← (byte) 0 [ ] ( main:2::utoa10w:30 [ ] ) always clobbers reg byte a reg byte y 
Statement [53] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte*) UTOA10_VAL + (byte) utoa10w::i#2) [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 ] ) always clobbers reg byte a 
Statement [54] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 utoa10w::$9 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 utoa10w::digit#1 utoa10w::$9 ] ) always clobbers reg byte a 
Statement [55] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word*) UTOA10_SUB + (byte~) utoa10w::$9) [ utoa10w::i#2 utoa10w::dst#11 utoa10w::value#1 utoa10w::digit#1 ] ( main:2::utoa10w:30 [ utoa10w::i#2 utoa10w::dst#11 utoa10w::value#1 utoa10w::digit#1 ] ) always clobbers reg byte a 
Statement [57] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 [ utoa16w::dst utoa16w::value#5 utoa16w::$0 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::$0 ] ) always clobbers reg byte a 
Statement [58] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] ) always clobbers reg byte a 
Statement [62] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5 [ utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#1 utoa16w::$3 ] ) always clobbers reg byte a 
Statement [68] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16w::$6 ] ) always clobbers reg byte a 
Statement [69] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] ) always clobbers reg byte a 
Statement [72] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5 [ utoa16w::dst utoa16w::$9 ] ( main:2::utoa16w:13 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] main:2::utoa16w:19 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] main:2::utoa16w:22 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] main:2::utoa16w:25 [ main::time_start#0 utoa16w::dst utoa16w::$9 ] ) always clobbers reg byte a 
Statement [75] *((byte*) utoa16w::dst) ← (byte) 0 [ ] ( main:2::utoa16w:13 [ main::time_start#0 ] main:2::utoa16w:16 [ main::time_start#0 ] main:2::utoa16w:19 [ main::time_start#0 ] main:2::utoa16w:22 [ main::time_start#0 ] main:2::utoa16w:25 [ main::time_start#0 ] ) always clobbers reg byte a reg byte y 
Statement [82] *(*(&(byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) [ utoa16w::dst utoa16n::return#4 ] ( main:2::utoa16w:13::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:19::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:22::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:25::utoa16n:59 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:13::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:19::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:22::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:25::utoa16n:65 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:13::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:19::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:22::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:25::utoa16n:71 [ main::time_start#0 utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:13::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:19::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:22::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] main:2::utoa16w:25::utoa16n:74 [ main::time_start#0 utoa16w::dst utoa16n::return#4 ] ) always clobbers reg byte a reg byte y 
Statement [87] *((byte*) cls::sc#2) ← (byte) ' ' [ cls::sc#2 ] ( main:2::cls:5 [ cls::sc#2 ] ) always clobbers reg byte a reg byte y 
Statement [89] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 [ cls::sc#1 ] ( main:2::cls:5 [ cls::sc#1 ] ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::i#2 main::i#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ utoa10w::i#2 utoa10w::i#1 ] : zp[1]:3 , reg byte x , 
Potential registers zp[2]:4 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] : zp[2]:4 , 
Potential registers zp[1]:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ utoa10w::bStarted#2 ] : zp[1]:7 , reg byte x , 
Potential registers zp[2]:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] : zp[2]:8 , 
Potential registers zp[2]:10 [ utoa16w::value#5 ] : zp[2]:10 , 
Potential registers zp[1]:12 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] : zp[1]:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] : zp[1]:13 , reg byte x , 
Potential registers zp[2]:14 [ cls::sc#2 cls::sc#1 ] : zp[2]:14 , 
Potential registers zp[1]:16 [ main::$1 ] : zp[1]:16 , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ main::$2 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:18 [ main::rst#0 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:19 [ main::time_start#0 ] : zp[1]:19 , reg byte x , 
Potential registers zp[2]:20 [ utoa16w::dst ] : zp[2]:20 , 
Potential registers zp[1]:22 [ main::time_end#0 ] : zp[1]:22 , reg byte x , reg byte y , 
Potential registers zp[1]:23 [ main::time#0 ] : zp[1]:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:24 [ utoa10w::$8 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:25 [ utoa10w::$2 ] : zp[1]:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:26 [ utoa10w::$0 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:27 [ utoa10w::dst#2 ] : zp[2]:27 , 
Potential registers zp[1]:29 [ utoa10w::$9 ] : zp[1]:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:30 [ utoa16w::$0 ] : zp[1]:30 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:31 [ utoa16n::return#0 ] : zp[1]:31 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:32 [ utoa16w::started#1 ] : zp[1]:32 , reg byte x , reg byte y , 
Potential registers zp[1]:33 [ utoa16w::$3 ] : zp[1]:33 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:34 [ utoa16n::return#1 ] : zp[1]:34 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:35 [ utoa16w::started#2 ] : zp[1]:35 , reg byte x , reg byte y , 
Potential registers zp[1]:36 [ utoa16w::$6 ] : zp[1]:36 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:37 [ utoa16w::$9 ] : zp[1]:37 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [utoa10w] 637.1: zp[2]:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] 244.71: zp[2]:4 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] 218.83: zp[1]:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ] 213.65: zp[1]:3 [ utoa10w::i#2 utoa10w::i#1 ] 202: zp[1]:24 [ utoa10w::$8 ] 202: zp[1]:25 [ utoa10w::$2 ] 202: zp[1]:29 [ utoa10w::$9 ] 25.25: zp[1]:7 [ utoa10w::bStarted#2 ] 4: zp[1]:26 [ utoa10w::$0 ] 4: zp[2]:27 [ utoa10w::dst#2 ] 
Uplift Scope [main] 370.33: zp[1]:2 [ main::i#2 main::i#1 ] 202: zp[1]:17 [ main::$2 ] 202: zp[1]:18 [ main::rst#0 ] 101: zp[1]:16 [ main::$1 ] 11: zp[1]:22 [ main::time_end#0 ] 11: zp[1]:23 [ main::time#0 ] 1.29: zp[1]:19 [ main::time_start#0 ] 
Uplift Scope [utoa16n] 14.4: zp[1]:12 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] 11.14: zp[1]:13 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] 4: zp[1]:31 [ utoa16n::return#0 ] 4: zp[1]:34 [ utoa16n::return#1 ] 
Uplift Scope [cls] 33: zp[2]:14 [ cls::sc#2 cls::sc#1 ] 
Uplift Scope [utoa16w] 4: zp[1]:30 [ utoa16w::$0 ] 4: zp[1]:33 [ utoa16w::$3 ] 4: zp[1]:36 [ utoa16w::$6 ] 4: zp[1]:37 [ utoa16w::$9 ] 1.78: zp[2]:20 [ utoa16w::dst ] 1.33: zp[1]:32 [ utoa16w::started#1 ] 1.33: zp[1]:35 [ utoa16w::started#2 ] 0.5: zp[2]:10 [ utoa16w::value#5 ] 
Uplift Scope [] 

Uplifting [utoa10w] best 28971 combination zp[2]:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] zp[2]:4 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] zp[1]:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ] reg byte x [ utoa10w::i#2 utoa10w::i#1 ] reg byte a [ utoa10w::$8 ] reg byte a [ utoa10w::$2 ] zp[1]:29 [ utoa10w::$9 ] zp[1]:7 [ utoa10w::bStarted#2 ] zp[1]:26 [ utoa10w::$0 ] zp[2]:27 [ utoa10w::dst#2 ] 
Limited combination testing to 100 combinations of 3072 possible.
Uplifting [main] best 26571 combination reg byte x [ main::i#2 main::i#1 ] reg byte a [ main::$2 ] reg byte a [ main::rst#0 ] zp[1]:16 [ main::$1 ] zp[1]:22 [ main::time_end#0 ] zp[1]:23 [ main::time#0 ] zp[1]:19 [ main::time_start#0 ] 
Limited combination testing to 100 combinations of 3456 possible.
Uplifting [utoa16n] best 26519 combination reg byte a [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] reg byte x [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] reg byte x [ utoa16n::return#0 ] reg byte x [ utoa16n::return#1 ] 
Limited combination testing to 100 combinations of 128 possible.
Uplifting [cls] best 26519 combination zp[2]:14 [ cls::sc#2 cls::sc#1 ] 
Uplifting [utoa16w] best 26495 combination reg byte a [ utoa16w::$0 ] reg byte a [ utoa16w::$3 ] reg byte a [ utoa16w::$6 ] reg byte a [ utoa16w::$9 ] zp[2]:20 [ utoa16w::dst ] zp[1]:32 [ utoa16w::started#1 ] zp[1]:35 [ utoa16w::started#2 ] zp[2]:10 [ utoa16w::value#5 ] 
Limited combination testing to 100 combinations of 2304 possible.
Uplifting [] best 26495 combination 
Attempting to uplift remaining variables inzp[1]:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
Uplifting [utoa10w] best 26495 combination zp[1]:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ] 
Attempting to uplift remaining variables inzp[1]:29 [ utoa10w::$9 ]
Uplifting [utoa10w] best 26095 combination reg byte a [ utoa10w::$9 ] 
Attempting to uplift remaining variables inzp[1]:16 [ main::$1 ]
Uplifting [main] best 26095 combination zp[1]:16 [ main::$1 ] 
Attempting to uplift remaining variables inzp[1]:7 [ utoa10w::bStarted#2 ]
Uplifting [utoa10w] best 26095 combination zp[1]:7 [ utoa10w::bStarted#2 ] 
Attempting to uplift remaining variables inzp[1]:22 [ main::time_end#0 ]
Uplifting [main] best 26055 combination reg byte x [ main::time_end#0 ] 
Attempting to uplift remaining variables inzp[1]:23 [ main::time#0 ]
Uplifting [main] best 25995 combination reg byte a [ main::time#0 ] 
Attempting to uplift remaining variables inzp[1]:26 [ utoa10w::$0 ]
Uplifting [utoa10w] best 25991 combination reg byte a [ utoa10w::$0 ] 
Attempting to uplift remaining variables inzp[1]:32 [ utoa16w::started#1 ]
Uplifting [utoa16w] best 25985 combination reg byte x [ utoa16w::started#1 ] 
Attempting to uplift remaining variables inzp[1]:35 [ utoa16w::started#2 ]
Uplifting [utoa16w] best 25979 combination reg byte x [ utoa16w::started#2 ] 
Attempting to uplift remaining variables inzp[1]:19 [ main::time_start#0 ]
Uplifting [main] best 25979 combination zp[1]:19 [ main::time_start#0 ] 
Coalescing zero page register [ zp[2]:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] ] with [ zp[2]:27 [ utoa10w::dst#2 ] ] - score: 1
Coalescing zero page register [ zp[2]:10 [ utoa16w::value#5 ] ] with [ zp[2]:4 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] ]
Coalescing zero page register [ zp[2]:14 [ cls::sc#2 cls::sc#1 ] ] with [ zp[2]:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 utoa10w::dst#2 ] ]
Coalescing zero page register [ zp[1]:16 [ main::$1 ] ] with [ zp[1]:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ] ]
Coalescing zero page register [ zp[1]:19 [ main::time_start#0 ] ] with [ zp[1]:7 [ utoa10w::bStarted#2 ] ]
Allocated (was zp[2]:10) zp[2]:2 [ utoa16w::value#5 utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
Allocated (was zp[2]:14) zp[2]:4 [ cls::sc#2 cls::sc#1 utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 utoa10w::dst#2 ]
Allocated (was zp[1]:16) zp[1]:6 [ main::$1 utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
Allocated (was zp[1]:19) zp[1]:7 [ main::time_start#0 utoa10w::bStarted#2 ]
Allocated (was zp[2]:20) zp[2]:8 [ utoa16w::dst ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Testing hex to decimal conversion
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label control = $d011
  .label raster = $d012
  .label bordercol = $d020
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label __1 = 6
    .label time_start = 7
    // asm { sei  }
    sei
    // [5] call cls 
    // [85] phi from main to cls [phi:main->cls]
  cls_from_main:
    jsr cls
    jmp __b1
    // main::@1
  __b1:
    // [6] (byte~) main::$1 ← *((const byte*) control) & (byte) $80 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #$80
    and control
    sta.z __1
    // [7] (byte~) main::$2 ← *((const byte*) raster) >> (byte) 1 -- vbuaa=_deref_pbuc1_ror_1 
    lda raster
    lsr
    // [8] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // [9] if((byte) main::rst#0!=(byte) $30) goto main::@1 -- vbuaa_neq_vbuc1_then_la1 
    cmp #$30
    bne __b1
    jmp __b2
    // main::@2
  __b2:
    // [10] *((const byte*) bordercol) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta bordercol
    // [11] (byte) main::time_start#0 ← *((const byte*) raster) -- vbuz1=_deref_pbuc1 
    lda raster
    sta.z time_start
    // [12] (byte*) utoa16w::dst ← (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z utoa16w.dst
    lda #>$400
    sta.z utoa16w.dst+1
    // [13] call utoa16w 
    // [56] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
  utoa16w_from___b2:
    // [56] phi (word) utoa16w::value#5 = (byte) 0 [phi:main::@2->utoa16w#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z utoa16w.value
    lda #>0
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b5
    // main::@5
  __b5:
    // [14] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // [15] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28
    sta.z utoa16w.dst
    lda #>$400+$28
    sta.z utoa16w.dst+1
    // [16] call utoa16w 
    // [56] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
  utoa16w_from___b5:
    // [56] phi (word) utoa16w::value#5 = (word) $4d2 [phi:main::@5->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z utoa16w.value
    lda #>$4d2
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b6
    // main::@6
  __b6:
    // [17] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // [18] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28
    sta.z utoa16w.dst+1
    // [19] call utoa16w 
    // [56] phi from main::@6 to utoa16w [phi:main::@6->utoa16w]
  utoa16w_from___b6:
    // [56] phi (word) utoa16w::value#5 = (word) $162e [phi:main::@6->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$162e
    sta.z utoa16w.value
    lda #>$162e
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b7
    // main::@7
  __b7:
    // [20] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // [21] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28
    sta.z utoa16w.dst+1
    // [22] call utoa16w 
    // [56] phi from main::@7 to utoa16w [phi:main::@7->utoa16w]
  utoa16w_from___b7:
    // [56] phi (word) utoa16w::value#5 = (word) $270f [phi:main::@7->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$270f
    sta.z utoa16w.value
    lda #>$270f
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b8
    // main::@8
  __b8:
    // [23] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // [24] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta.z utoa16w.dst+1
    // [25] call utoa16w 
    // [56] phi from main::@8 to utoa16w [phi:main::@8->utoa16w]
  utoa16w_from___b8:
    // [56] phi (word) utoa16w::value#5 = (word) $e608 [phi:main::@8->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$e608
    sta.z utoa16w.value
    lda #>$e608
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b9
    // main::@9
  __b9:
    // [26] (byte) main::time_end#0 ← *((const byte*) raster) -- vbuxx=_deref_pbuc1 
    ldx raster
    // [27] *((const byte*) bordercol) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta bordercol
    // [28] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 -- vbuaa=vbuxx_minus_vbuz1 
    txa
    sec
    sbc.z time_start
    // [29] (word) utoa10w::value#0 ← (word)(byte) main::time#0 -- vwuz1=_word_vbuaa 
    sta.z utoa10w.value
    lda #0
    sta.z utoa10w.value+1
    // [30] call utoa10w 
    // [35] phi from main::@9 to utoa10w [phi:main::@9->utoa10w]
  utoa10w_from___b9:
    jsr utoa10w
    // [31] phi from main::@9 to main::@3 [phi:main::@9->main::@3]
  __b3_from___b9:
    // [31] phi (byte) main::i#2 = (byte) 0 [phi:main::@9->main::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b3
    // main::@3
  __b3:
    // [32] if(*((const byte*) main::msg + (byte) main::i#2)!=(byte) 0) goto main::@4 -- pbuc1_derefidx_vbuxx_neq_0_then_la1 
    lda msg,x
    cmp #0
    bne __b4
    jmp __b1
    // main::@4
  __b4:
    // [33] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte*) main::msg + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda msg,x
    sta $400+$28+$28+$28+$28+$50+3,x
    // [34] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [31] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [31] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
    msg: .text "raster lines"
    .byte 0
}
  // utoa10w
// Decimal utoa() without using multiply or divide
// utoa10w(word zp(2) value, byte* zp(4) dst)
utoa10w: {
    .label value = 2
    .label digit = 6
    .label dst = 4
    .label bStarted = 7
    // [36] phi from utoa10w to utoa10w::@1 [phi:utoa10w->utoa10w::@1]
  __b1_from_utoa10w:
    // [36] phi (byte*) utoa10w::dst#11 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 [phi:utoa10w->utoa10w::@1#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28+$50
    sta.z dst
    lda #>$400+$28+$28+$28+$28+$50
    sta.z dst+1
    // [36] phi (byte) utoa10w::bStarted#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z bStarted
    // [36] phi (byte) utoa10w::digit#3 = (byte) 0 [phi:utoa10w->utoa10w::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [36] phi (word) utoa10w::value#10 = (word) utoa10w::value#0 [phi:utoa10w->utoa10w::@1#3] -- register_copy 
    // [36] phi (byte) utoa10w::i#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#4] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [36] phi from utoa10w::@6 to utoa10w::@1 [phi:utoa10w::@6->utoa10w::@1]
  __b1_from___b6:
    // [36] phi (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#4 [phi:utoa10w::@6->utoa10w::@1#0] -- register_copy 
    // [36] phi (byte) utoa10w::bStarted#2 = (byte) utoa10w::bStarted#2 [phi:utoa10w::@6->utoa10w::@1#1] -- register_copy 
    // [36] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#7 [phi:utoa10w::@6->utoa10w::@1#2] -- register_copy 
    // [36] phi (word) utoa10w::value#10 = (word) utoa10w::value#10 [phi:utoa10w::@6->utoa10w::@1#3] -- register_copy 
    // [36] phi (byte) utoa10w::i#2 = (byte) utoa10w::i#1 [phi:utoa10w::@6->utoa10w::@1#4] -- register_copy 
    jmp __b1
    // utoa10w::@1
  __b1:
    // [37] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [38] if((word) utoa10w::value#10>=*((const word*) UTOA10_SUB + (byte~) utoa10w::$8)) goto utoa10w::@2 -- vwuz1_ge_pwuc1_derefidx_vbuaa_then_la1 
    tay
    lda UTOA10_SUB+1,y
    cmp.z value+1
    bne !+
    lda UTOA10_SUB,y
    cmp.z value
    beq __b2
  !:
    bcc __b2
    jmp __b3
    // utoa10w::@3
  __b3:
    // [39] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [40] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@6 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b6_from___b3
    jmp __b4
    // utoa10w::@4
  __b4:
    // [41] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7 -- vbuz1_eq_0_then_la1 
    lda.z bStarted
    cmp #0
    beq __b7_from___b4
    jmp __b5
    // utoa10w::@5
  __b5:
    // [42] *((byte*) utoa10w::dst#11) ← *((const byte*) DIGITS + (byte) utoa10w::digit#3) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z digit
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // [43] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [44] phi from utoa10w::@4 utoa10w::@5 to utoa10w::@7 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7]
  __b7_from___b4:
  __b7_from___b5:
    // [44] phi (byte*) utoa10w::dst#7 = (byte*) utoa10w::dst#11 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7#0] -- register_copy 
    jmp __b7
    // utoa10w::@7
  __b7:
    // [45] phi from utoa10w::@7 to utoa10w::@6 [phi:utoa10w::@7->utoa10w::@6]
  __b6_from___b7:
    // [45] phi (byte) utoa10w::digit#7 = (byte) 0 [phi:utoa10w::@7->utoa10w::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [45] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#7 [phi:utoa10w::@7->utoa10w::@6#1] -- register_copy 
    jmp __b6
    // [45] phi from utoa10w::@3 to utoa10w::@6 [phi:utoa10w::@3->utoa10w::@6]
  __b6_from___b3:
    // [45] phi (byte) utoa10w::digit#7 = (byte) utoa10w::digit#3 [phi:utoa10w::@3->utoa10w::@6#0] -- register_copy 
    // [45] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#11 [phi:utoa10w::@3->utoa10w::@6#1] -- register_copy 
    jmp __b6
    // utoa10w::@6
  __b6:
    // [46] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [47] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b1_from___b6
    jmp __b8
    // utoa10w::@8
  __b8:
    // [48] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 -- vbuaa=_byte_vwuz1 
    lda.z value
    // [49] *((byte*) utoa10w::dst#4) ← *((const byte*) DIGITS + (byte~) utoa10w::$0) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // [50] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [51] *((byte*) utoa10w::dst#2) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp __breturn
    // utoa10w::@return
  __breturn:
    // [52] return 
    rts
    // utoa10w::@2
  __b2:
    // [53] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte*) UTOA10_VAL + (byte) utoa10w::i#2) -- vbuz1=vbuz1_plus_pbuc1_derefidx_vbuxx 
    lda UTOA10_VAL,x
    clc
    adc.z digit
    sta.z digit
    // [54] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [55] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word*) UTOA10_SUB + (byte~) utoa10w::$9) -- vwuz1=vwuz1_minus_pwuc1_derefidx_vbuaa 
    tay
    sec
    lda.z value
    sbc UTOA10_SUB,y
    sta.z value
    lda.z value+1
    sbc UTOA10_SUB+1,y
    sta.z value+1
    // [36] phi from utoa10w::@2 to utoa10w::@1 [phi:utoa10w::@2->utoa10w::@1]
  __b1_from___b2:
    // [36] phi (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#11 [phi:utoa10w::@2->utoa10w::@1#0] -- register_copy 
    // [36] phi (byte) utoa10w::bStarted#2 = (byte) 1 [phi:utoa10w::@2->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #1
    sta.z bStarted
    // [36] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#1 [phi:utoa10w::@2->utoa10w::@1#2] -- register_copy 
    // [36] phi (word) utoa10w::value#10 = (word) utoa10w::value#1 [phi:utoa10w::@2->utoa10w::@1#3] -- register_copy 
    // [36] phi (byte) utoa10w::i#2 = (byte) utoa10w::i#2 [phi:utoa10w::@2->utoa10w::@1#4] -- register_copy 
    jmp __b1
}
  // utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zp(2) value, byte* zp(8) dst)
utoa16w: {
    .label dst = 8
    .label value = 2
    // [57] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // [58] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [59] call utoa16n 
    // [77] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
  utoa16n_from_utoa16w:
    // [77] phi (byte) utoa16n::started#7 = (byte) 0 [phi:utoa16w->utoa16n#0] -- vbuxx=vbuc1 
    ldx #0
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [60] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
    jmp __b1
    // utoa16w::@1
  __b1:
    // [61] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
    // [62] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // [63] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$3 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [64] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
    // [65] call utoa16n 
    // [77] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
  utoa16n_from___b1:
    // [77] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [66] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
    jmp __b2
    // utoa16w::@2
  __b2:
    // [67] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
    // [68] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // [69] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [70] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
    // [71] call utoa16n 
    // [77] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
  utoa16n_from___b2:
    // [77] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b3
    // utoa16w::@3
  __b3:
    // [72] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // [73] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$9 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [74] call utoa16n 
    // [77] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
  utoa16n_from___b3:
    // [77] phi (byte) utoa16n::started#7 = (byte) 1 [phi:utoa16w::@3->utoa16n#0] -- vbuxx=vbuc1 
    ldx #1
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b4
    // utoa16w::@4
  __b4:
    // [75] *((byte*) utoa16w::dst) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp __breturn
    // utoa16w::@return
  __breturn:
    // [76] return 
    rts
}
  // utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte register(A) nybble, byte register(X) started)
utoa16n: {
    // [78] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3_from_utoa16n
    // [80] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
  __b1_from_utoa16n:
    // [80] phi (byte) utoa16n::return#4 = (byte) 1 [phi:utoa16n->utoa16n::@1#0] -- vbuxx=vbuc1 
    ldx #1
    jmp __b1
    // [79] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
  __b3_from_utoa16n:
    jmp __b3
    // utoa16n::@3
  __b3:
    // [80] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
  __b1_from___b3:
    // [80] phi (byte) utoa16n::return#4 = (byte) utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    jmp __b1
    // utoa16n::@1
  __b1:
    // [81] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return -- vbuxx_eq_0_then_la1 
    cpx #0
    beq __breturn
    jmp __b2
    // utoa16n::@2
  __b2:
    // [82] *(*(&(byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) -- _deref_(_deref_pptc1)=pbuc2_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy.z utoa16w.dst
    sty.z $fe
    ldy.z utoa16w.dst+1
    sty.z $ff
    ldy #0
    sta ($fe),y
    // [83] *(&(byte*) utoa16w::dst) ← ++ *(&(byte*) utoa16w::dst) -- _deref_pptc1=_inc__deref_pptc1 
    inc.z utoa16w.dst
    bne !+
    inc.z utoa16w.dst+1
  !:
    jmp __breturn
    // utoa16n::@return
  __breturn:
    // [84] return 
    rts
}
  // cls
cls: {
    .label screen = $400
    .label sc = 4
    // [86] phi from cls to cls::@1 [phi:cls->cls::@1]
  __b1_from_cls:
    // [86] phi (byte*) cls::sc#2 = (const byte*) cls::screen [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta.z sc
    lda #>screen
    sta.z sc+1
    jmp __b1
    // [86] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
  __b1_from___b1:
    // [86] phi (byte*) cls::sc#2 = (byte*) cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    jmp __b1
    // cls::@1
  __b1:
    // [87] *((byte*) cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [88] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [89] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>screen+$3e7+1
    bne __b1_from___b1
    lda.z sc
    cmp #<screen+$3e7+1
    bne __b1_from___b1
    jmp __breturn
    // cls::@return
  __breturn:
    // [90] return 
    rts
}
  // File Data
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef"
  .byte 0
  // Subtraction values used for decimal utoa()
  UTOA10_SUB: .word $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a
  // Digit addition values used for decimal utoa()
  UTOA10_VAL: .byte 3, 1, 3, 1, 3, 1, 3, 1

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b6
Removing instruction jmp __b8
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #>0
Removing instruction lda #0
Replacing instruction ldx #0 with TAX
Replacing instruction ldy #0 with TAY
Replacing instruction ldy #0 with TAY
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __bbegin with __b1
Replacing label __b6_from___b3 with __b6
Replacing label __b7_from___b4 with __b7
Replacing label __b1_from___b6 with __b1
Replacing label __b3_from_utoa16n with __b1
Replacing label __b1_from___b1 with __b1
Replacing label __b1_from___b1 with __b1
Removing instruction __bbegin:
Removing instruction __b1_from___bbegin:
Removing instruction __bend_from___b1:
Removing instruction __b1_from___b6:
Removing instruction __b7_from___b4:
Removing instruction __b7_from___b5:
Removing instruction __b6_from___b7:
Removing instruction __b6_from___b3:
Removing instruction __b3_from_utoa16n:
Removing instruction __b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction cls_from_main:
Removing instruction __b2:
Removing instruction utoa16w_from___b2:
Removing instruction __b5:
Removing instruction utoa16w_from___b5:
Removing instruction __b6:
Removing instruction utoa16w_from___b6:
Removing instruction __b7:
Removing instruction utoa16w_from___b7:
Removing instruction __b8:
Removing instruction utoa16w_from___b8:
Removing instruction __b9:
Removing instruction utoa10w_from___b9:
Removing instruction __b3_from___b9:
Removing instruction __b3_from___b4:
Removing instruction __b1_from_utoa10w:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b8:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction utoa16n_from_utoa16w:
Removing instruction __b1:
Removing instruction utoa16n_from___b1:
Removing instruction __b2:
Removing instruction utoa16n_from___b2:
Removing instruction __b3:
Removing instruction utoa16n_from___b3:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __b1_from_utoa16n:
Removing instruction __b2:
Removing instruction __b1_from_cls:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp __b1
Removing instruction jmp __b6
Removing instruction jmp __b1
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b1:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) DIGITS[]  = (byte*) "0123456789abcdef"
(const word*) UTOA10_SUB[]  = { (word) $7530, (word) $2710, (word) $bb8, (word) $3e8, (word) $12c, (word) $64, (word) $1e, (word) $a }
(const byte*) UTOA10_VAL[]  = { (byte) 3, (byte) 1, (byte) 3, (byte) 1, (byte) 3, (byte) 1, (byte) 3, (byte) 1 }
(const byte*) bordercol = (byte*) 53280
(void()) cls()
(label) cls::@1
(label) cls::@return
(byte*) cls::sc
(byte*) cls::sc#1 sc zp[2]:4 16.5
(byte*) cls::sc#2 sc zp[2]:4 16.5
(const byte*) cls::screen = (byte*) 1024
(const byte*) control = (byte*) 53265
(void()) main()
(byte~) main::$1 zp[1]:6 101.0
(byte~) main::$2 reg byte a 202.0
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(byte) main::i
(byte) main::i#1 reg byte x 202.0
(byte) main::i#2 reg byte x 168.33333333333331
(const byte*) main::msg[]  = (byte*) "raster lines"
(byte) main::rst
(byte) main::rst#0 reg byte a 202.0
(byte*) main::screen
(byte) main::time
(byte) main::time#0 reg byte a 11.0
(byte) main::time_end
(byte) main::time_end#0 reg byte x 11.0
(byte) main::time_start
(byte) main::time_start#0 time_start zp[1]:7 1.2941176470588236
(const byte*) raster = (byte*) 53266
(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
(byte~) utoa10w::$0 reg byte a 4.0
(byte~) utoa10w::$2 reg byte a 202.0
(byte~) utoa10w::$8 reg byte a 202.0
(byte~) utoa10w::$9 reg byte a 202.0
(label) utoa10w::@1
(label) utoa10w::@2
(label) utoa10w::@3
(label) utoa10w::@4
(label) utoa10w::@5
(label) utoa10w::@6
(label) utoa10w::@7
(label) utoa10w::@8
(label) utoa10w::@return
(byte) utoa10w::bStarted
(byte) utoa10w::bStarted#2 bStarted zp[1]:7 25.25
(byte) utoa10w::digit
(byte) utoa10w::digit#1 digit zp[1]:6 67.33333333333333
(byte) utoa10w::digit#3 digit zp[1]:6 84.16666666666666
(byte) utoa10w::digit#7 digit zp[1]:6 67.33333333333333
(byte*) utoa10w::dst
(byte*) utoa10w::dst#1 dst zp[2]:4 202.0
(byte*) utoa10w::dst#11 dst zp[2]:4 70.7
(byte*) utoa10w::dst#2 dst zp[2]:4 4.0
(byte*) utoa10w::dst#4 dst zp[2]:4 61.39999999999999
(byte*) utoa10w::dst#7 dst zp[2]:4 303.0
(byte) utoa10w::i
(byte) utoa10w::i#1 reg byte x 151.5
(byte) utoa10w::i#2 reg byte x 62.153846153846146
(word) utoa10w::value
(word) utoa10w::value#0 value zp[2]:2 6.5
(word) utoa10w::value#1 value zp[2]:2 202.0
(word) utoa10w::value#10 value zp[2]:2 36.214285714285715
(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
(label) utoa16n::@1
(label) utoa16n::@2
(label) utoa16n::@3
(label) utoa16n::@return
(word**) utoa16n::dst
(byte) utoa16n::nybble
(byte) utoa16n::nybble#0 reg byte a 4.0
(byte) utoa16n::nybble#1 reg byte a 2.0
(byte) utoa16n::nybble#2 reg byte a 2.0
(byte) utoa16n::nybble#3 reg byte a 4.0
(byte) utoa16n::nybble#4 reg byte a 2.4
(byte) utoa16n::return
(byte) utoa16n::return#0 reg byte x 4.0
(byte) utoa16n::return#1 reg byte x 4.0
(byte) utoa16n::return#4 reg byte x 1.1428571428571428
(byte) utoa16n::started
(byte) utoa16n::started#1 reg byte x 4.0
(byte) utoa16n::started#2 reg byte x 4.0
(byte) utoa16n::started#7 reg byte x 2.0
(void()) utoa16w((word) utoa16w::value , (byte*) utoa16w::dst)
(byte~) utoa16w::$0 reg byte a 4.0
(byte~) utoa16w::$3 reg byte a 4.0
(byte~) utoa16w::$6 reg byte a 4.0
(byte~) utoa16w::$9 reg byte a 4.0
(label) utoa16w::@1
(label) utoa16w::@2
(label) utoa16w::@3
(label) utoa16w::@4
(label) utoa16w::@return
(byte*) utoa16w::dst loadstore zp[2]:8 1.78125
(byte) utoa16w::started
(byte) utoa16w::started#1 reg byte x 1.3333333333333333
(byte) utoa16w::started#2 reg byte x 1.3333333333333333
(word) utoa16w::value
(word) utoa16w::value#5 value zp[2]:2 0.5

reg byte x [ main::i#2 main::i#1 ]
reg byte x [ utoa10w::i#2 utoa10w::i#1 ]
zp[2]:2 [ utoa16w::value#5 utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
reg byte a [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
reg byte x [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
zp[2]:4 [ cls::sc#2 cls::sc#1 utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 utoa10w::dst#2 ]
zp[1]:6 [ main::$1 utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
reg byte a [ main::$2 ]
reg byte a [ main::rst#0 ]
zp[1]:7 [ main::time_start#0 utoa10w::bStarted#2 ]
zp[2]:8 [ utoa16w::dst ]
reg byte x [ main::time_end#0 ]
reg byte a [ main::time#0 ]
reg byte a [ utoa10w::$8 ]
reg byte a [ utoa10w::$2 ]
reg byte a [ utoa10w::$0 ]
reg byte a [ utoa10w::$9 ]
reg byte a [ utoa16w::$0 ]
reg byte x [ utoa16n::return#0 ]
reg byte x [ utoa16w::started#1 ]
reg byte a [ utoa16w::$3 ]
reg byte x [ utoa16n::return#1 ]
reg byte x [ utoa16w::started#2 ]
reg byte a [ utoa16w::$6 ]
reg byte a [ utoa16w::$9 ]


FINAL ASSEMBLER
Score: 22318

  // File Comments
// Testing hex to decimal conversion
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label control = $d011
  .label raster = $d012
  .label bordercol = $d020
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label __1 = 6
    .label time_start = 7
    // asm
    // asm { sei  }
    sei
    // cls()
    // [5] call cls 
    // [85] phi from main to cls [phi:main->cls]
    jsr cls
    // main::@1
  __b1:
    // *control&0x80
    // [6] (byte~) main::$1 ← *((const byte*) control) & (byte) $80 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #$80
    and control
    sta.z __1
    // *raster>>1
    // [7] (byte~) main::$2 ← *((const byte*) raster) >> (byte) 1 -- vbuaa=_deref_pbuc1_ror_1 
    lda raster
    lsr
    // rst = (*control&0x80)|(*raster>>1)
    // [8] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // while (rst!=0x30)
    // [9] if((byte) main::rst#0!=(byte) $30) goto main::@1 -- vbuaa_neq_vbuc1_then_la1 
    cmp #$30
    bne __b1
    // main::@2
    // *bordercol = 1
    // [10] *((const byte*) bordercol) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta bordercol
    // time_start = *raster
    // [11] (byte) main::time_start#0 ← *((const byte*) raster) -- vbuz1=_deref_pbuc1 
    lda raster
    sta.z time_start
    // utoa16w(00000, screen)
    // [12] (byte*) utoa16w::dst ← (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z utoa16w.dst
    lda #>$400
    sta.z utoa16w.dst+1
    // [13] call utoa16w 
    // [56] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
    // [56] phi (word) utoa16w::value#5 = (byte) 0 [phi:main::@2->utoa16w#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z utoa16w.value
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@5
    // (*bordercol)++;
    // [14] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // utoa16w(01234, screen)
    // [15] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28
    sta.z utoa16w.dst
    lda #>$400+$28
    sta.z utoa16w.dst+1
    // [16] call utoa16w 
    // [56] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
    // [56] phi (word) utoa16w::value#5 = (word) $4d2 [phi:main::@5->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z utoa16w.value
    lda #>$4d2
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@6
    // (*bordercol)++;
    // [17] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // utoa16w(05678, screen)
    // [18] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28
    sta.z utoa16w.dst+1
    // [19] call utoa16w 
    // [56] phi from main::@6 to utoa16w [phi:main::@6->utoa16w]
    // [56] phi (word) utoa16w::value#5 = (word) $162e [phi:main::@6->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$162e
    sta.z utoa16w.value
    lda #>$162e
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@7
    // (*bordercol)++;
    // [20] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // utoa16w(09999, screen)
    // [21] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28
    sta.z utoa16w.dst+1
    // [22] call utoa16w 
    // [56] phi from main::@7 to utoa16w [phi:main::@7->utoa16w]
    // [56] phi (word) utoa16w::value#5 = (word) $270f [phi:main::@7->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$270f
    sta.z utoa16w.value
    lda #>$270f
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@8
    // (*bordercol)++;
    // [23] *((const byte*) bordercol) ← ++ *((const byte*) bordercol) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
    // utoa16w(58888, screen)
    // [24] (byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta.z utoa16w.dst+1
    // [25] call utoa16w 
    // [56] phi from main::@8 to utoa16w [phi:main::@8->utoa16w]
    // [56] phi (word) utoa16w::value#5 = (word) $e608 [phi:main::@8->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$e608
    sta.z utoa16w.value
    lda #>$e608
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@9
    // time_end = *raster
    // [26] (byte) main::time_end#0 ← *((const byte*) raster) -- vbuxx=_deref_pbuc1 
    ldx raster
    // *bordercol = 0
    // [27] *((const byte*) bordercol) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta bordercol
    // time = time_end - time_start
    // [28] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 -- vbuaa=vbuxx_minus_vbuz1 
    txa
    sec
    sbc.z time_start
    // utoa10w((unsigned int)time, screen+80)
    // [29] (word) utoa10w::value#0 ← (word)(byte) main::time#0 -- vwuz1=_word_vbuaa 
    sta.z utoa10w.value
    lda #0
    sta.z utoa10w.value+1
    // [30] call utoa10w 
    // [35] phi from main::@9 to utoa10w [phi:main::@9->utoa10w]
    jsr utoa10w
    // [31] phi from main::@9 to main::@3 [phi:main::@9->main::@3]
    // [31] phi (byte) main::i#2 = (byte) 0 [phi:main::@9->main::@3#0] -- vbuxx=vbuc1 
    ldx #0
    // main::@3
  __b3:
    // for( byte i=0; msg[i]!=0; i++ )
    // [32] if(*((const byte*) main::msg + (byte) main::i#2)!=(byte) 0) goto main::@4 -- pbuc1_derefidx_vbuxx_neq_0_then_la1 
    lda msg,x
    cmp #0
    bne __b4
    jmp __b1
    // main::@4
  __b4:
    // (screen+80+3)[i] = msg[i]
    // [33] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte*) main::msg + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda msg,x
    sta $400+$28+$28+$28+$28+$50+3,x
    // for( byte i=0; msg[i]!=0; i++ )
    // [34] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [31] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
    // [31] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
    msg: .text "raster lines"
    .byte 0
}
  // utoa10w
// Decimal utoa() without using multiply or divide
// utoa10w(word zp(2) value, byte* zp(4) dst)
utoa10w: {
    .label value = 2
    .label digit = 6
    .label dst = 4
    .label bStarted = 7
    // [36] phi from utoa10w to utoa10w::@1 [phi:utoa10w->utoa10w::@1]
    // [36] phi (byte*) utoa10w::dst#11 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 [phi:utoa10w->utoa10w::@1#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28+$50
    sta.z dst
    lda #>$400+$28+$28+$28+$28+$50
    sta.z dst+1
    // [36] phi (byte) utoa10w::bStarted#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z bStarted
    // [36] phi (byte) utoa10w::digit#3 = (byte) 0 [phi:utoa10w->utoa10w::@1#2] -- vbuz1=vbuc1 
    sta.z digit
    // [36] phi (word) utoa10w::value#10 = (word) utoa10w::value#0 [phi:utoa10w->utoa10w::@1#3] -- register_copy 
    // [36] phi (byte) utoa10w::i#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#4] -- vbuxx=vbuc1 
    tax
    // [36] phi from utoa10w::@6 to utoa10w::@1 [phi:utoa10w::@6->utoa10w::@1]
    // [36] phi (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#4 [phi:utoa10w::@6->utoa10w::@1#0] -- register_copy 
    // [36] phi (byte) utoa10w::bStarted#2 = (byte) utoa10w::bStarted#2 [phi:utoa10w::@6->utoa10w::@1#1] -- register_copy 
    // [36] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#7 [phi:utoa10w::@6->utoa10w::@1#2] -- register_copy 
    // [36] phi (word) utoa10w::value#10 = (word) utoa10w::value#10 [phi:utoa10w::@6->utoa10w::@1#3] -- register_copy 
    // [36] phi (byte) utoa10w::i#2 = (byte) utoa10w::i#1 [phi:utoa10w::@6->utoa10w::@1#4] -- register_copy 
    // utoa10w::@1
  __b1:
    // value>=UTOA10_SUB[i]
    // [37] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // while(value>=UTOA10_SUB[i])
    // [38] if((word) utoa10w::value#10>=*((const word*) UTOA10_SUB + (byte~) utoa10w::$8)) goto utoa10w::@2 -- vwuz1_ge_pwuc1_derefidx_vbuaa_then_la1 
    tay
    lda UTOA10_SUB+1,y
    cmp.z value+1
    bne !+
    lda UTOA10_SUB,y
    cmp.z value
    beq __b2
  !:
    bcc __b2
    // utoa10w::@3
    // i&1
    // [39] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if((i&1)!=0)
    // [40] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@6 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b6
    // utoa10w::@4
    // if(bStarted!=0)
    // [41] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7 -- vbuz1_eq_0_then_la1 
    lda.z bStarted
    cmp #0
    beq __b7
    // utoa10w::@5
    // *dst++ = DIGITS[digit]
    // [42] *((byte*) utoa10w::dst#11) ← *((const byte*) DIGITS + (byte) utoa10w::digit#3) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z digit
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // *dst++ = DIGITS[digit];
    // [43] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [44] phi from utoa10w::@4 utoa10w::@5 to utoa10w::@7 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7]
    // [44] phi (byte*) utoa10w::dst#7 = (byte*) utoa10w::dst#11 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7#0] -- register_copy 
    // utoa10w::@7
  __b7:
    // [45] phi from utoa10w::@7 to utoa10w::@6 [phi:utoa10w::@7->utoa10w::@6]
    // [45] phi (byte) utoa10w::digit#7 = (byte) 0 [phi:utoa10w::@7->utoa10w::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta.z digit
    // [45] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#7 [phi:utoa10w::@7->utoa10w::@6#1] -- register_copy 
    // [45] phi from utoa10w::@3 to utoa10w::@6 [phi:utoa10w::@3->utoa10w::@6]
    // [45] phi (byte) utoa10w::digit#7 = (byte) utoa10w::digit#3 [phi:utoa10w::@3->utoa10w::@6#0] -- register_copy 
    // [45] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#11 [phi:utoa10w::@3->utoa10w::@6#1] -- register_copy 
    // utoa10w::@6
  __b6:
    // for( unsigned char i: 0..7)
    // [46] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [47] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b1
    // utoa10w::@8
    // (unsigned char) value
    // [48] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 -- vbuaa=_byte_vwuz1 
    lda.z value
    // *dst++ = DIGITS[(unsigned char) value]
    // [49] *((byte*) utoa10w::dst#4) ← *((const byte*) DIGITS + (byte~) utoa10w::$0) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (dst),y
    // *dst++ = DIGITS[(unsigned char) value];
    // [50] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // *dst = 0
    // [51] *((byte*) utoa10w::dst#2) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (dst),y
    // utoa10w::@return
    // }
    // [52] return 
    rts
    // utoa10w::@2
  __b2:
    // digit += UTOA10_VAL[i]
    // [53] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte*) UTOA10_VAL + (byte) utoa10w::i#2) -- vbuz1=vbuz1_plus_pbuc1_derefidx_vbuxx 
    lda UTOA10_VAL,x
    clc
    adc.z digit
    sta.z digit
    // value -= UTOA10_SUB[i]
    // [54] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [55] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word*) UTOA10_SUB + (byte~) utoa10w::$9) -- vwuz1=vwuz1_minus_pwuc1_derefidx_vbuaa 
    tay
    sec
    lda.z value
    sbc UTOA10_SUB,y
    sta.z value
    lda.z value+1
    sbc UTOA10_SUB+1,y
    sta.z value+1
    // [36] phi from utoa10w::@2 to utoa10w::@1 [phi:utoa10w::@2->utoa10w::@1]
    // [36] phi (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#11 [phi:utoa10w::@2->utoa10w::@1#0] -- register_copy 
    // [36] phi (byte) utoa10w::bStarted#2 = (byte) 1 [phi:utoa10w::@2->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #1
    sta.z bStarted
    // [36] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#1 [phi:utoa10w::@2->utoa10w::@1#2] -- register_copy 
    // [36] phi (word) utoa10w::value#10 = (word) utoa10w::value#1 [phi:utoa10w::@2->utoa10w::@1#3] -- register_copy 
    // [36] phi (byte) utoa10w::i#2 = (byte) utoa10w::i#2 [phi:utoa10w::@2->utoa10w::@1#4] -- register_copy 
    jmp __b1
}
  // utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zp(2) value, byte* zp(8) dst)
utoa16w: {
    .label dst = 8
    .label value = 2
    // >value
    // [57] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // utoa16n((>value)>>4, &dst, started)
    // [58] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [59] call utoa16n 
    // [77] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
    // [77] phi (byte) utoa16n::started#7 = (byte) 0 [phi:utoa16w->utoa16n#0] -- vbuxx=vbuc1 
    ldx #0
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16n((>value)>>4, &dst, started)
    // [60] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
    // utoa16w::@1
    // started = utoa16n((>value)>>4, &dst, started)
    // [61] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
    // >value
    // [62] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // utoa16n((>value)&0x0f, &dst, started)
    // [63] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$3 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [64] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
    // [65] call utoa16n 
    // [77] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
    // [77] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16n((>value)&0x0f, &dst, started)
    // [66] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
    // utoa16w::@2
    // started = utoa16n((>value)&0x0f, &dst, started)
    // [67] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
    // <value
    // [68] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // utoa16n((<value)>>4, &dst, started)
    // [69] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [70] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
    // [71] call utoa16n 
    // [77] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
    // [77] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16w::@3
    // <value
    // [72] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // utoa16n((<value)&0x0f, &dst, 1)
    // [73] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$9 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [74] call utoa16n 
    // [77] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
    // [77] phi (byte) utoa16n::started#7 = (byte) 1 [phi:utoa16w::@3->utoa16n#0] -- vbuxx=vbuc1 
    ldx #1
    // [77] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16w::@4
    // *dst = 0
    // [75] *((byte*) utoa16w::dst) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (dst),y
    // utoa16w::@return
    // }
    // [76] return 
    rts
}
  // utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte register(A) nybble, byte register(X) started)
utoa16n: {
    // if(nybble!=0)
    // [78] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b1
    // [80] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
    // [80] phi (byte) utoa16n::return#4 = (byte) 1 [phi:utoa16n->utoa16n::@1#0] -- vbuxx=vbuc1 
    ldx #1
    // [79] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
    // utoa16n::@3
    // [80] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
    // [80] phi (byte) utoa16n::return#4 = (byte) utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    // utoa16n::@1
  __b1:
    // if(started!=0)
    // [81] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return -- vbuxx_eq_0_then_la1 
    cpx #0
    beq __breturn
    // utoa16n::@2
    // *(*dst)++ = DIGITS[nybble]
    // [82] *(*(&(byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) -- _deref_(_deref_pptc1)=pbuc2_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy.z utoa16w.dst
    sty.z $fe
    ldy.z utoa16w.dst+1
    sty.z $ff
    ldy #0
    sta ($fe),y
    // *(*dst)++ = DIGITS[nybble];
    // [83] *(&(byte*) utoa16w::dst) ← ++ *(&(byte*) utoa16w::dst) -- _deref_pptc1=_inc__deref_pptc1 
    inc.z utoa16w.dst
    bne !+
    inc.z utoa16w.dst+1
  !:
    // utoa16n::@return
  __breturn:
    // }
    // [84] return 
    rts
}
  // cls
cls: {
    .label screen = $400
    .label sc = 4
    // [86] phi from cls to cls::@1 [phi:cls->cls::@1]
    // [86] phi (byte*) cls::sc#2 = (const byte*) cls::screen [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta.z sc
    lda #>screen
    sta.z sc+1
    // [86] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
    // [86] phi (byte*) cls::sc#2 = (byte*) cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    // cls::@1
  __b1:
    // *sc=' '
    // [87] *((byte*) cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // for( unsigned char *sc: screen..screen+999)
    // [88] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [89] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>screen+$3e7+1
    bne __b1
    lda.z sc
    cmp #<screen+$3e7+1
    bne __b1
    // cls::@return
    // }
    // [90] return 
    rts
}
  // File Data
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef"
  .byte 0
  // Subtraction values used for decimal utoa()
  UTOA10_SUB: .word $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a
  // Digit addition values used for decimal utoa()
  UTOA10_VAL: .byte 3, 1, 3, 1, 3, 1, 3, 1

