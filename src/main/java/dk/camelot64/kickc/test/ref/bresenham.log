byte STAR = 81;
byte[40*25] SCREEN = $0400;

main();

void main() {
  byte x0 = 0;
  byte y0 = 0;
  byte x1 = 39;
  byte y1 = 24;
  byte xd = x1-x0;
  byte yd = y1-y0;
  byte x = x0;
  byte y = y0;
  byte e = yd/2;
  byte *cursor = SCREEN+y*40+x;
  do  {
      *cursor = STAR;
      x = x + 1;
      cursor = cursor + 1;
      e = e+yd;
      if(xd<e) {
          y = y+1;
          cursor = cursor + 40;
          e = e - xd;
      }
  } while (x<(x1+1))
}
PROGRAM
  (byte) STAR ← (byte) 81
  (byte[1000]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
proc (void()) main()
  (byte) main::x0 ← (byte) 0
  (byte) main::y0 ← (byte) 0
  (byte) main::x1 ← (byte) 39
  (byte) main::y1 ← (byte) 24
  (byte~) main::$0 ← (byte) main::x1 - (byte) main::x0
  (byte) main::xd ← (byte~) main::$0
  (byte~) main::$1 ← (byte) main::y1 - (byte) main::y0
  (byte) main::yd ← (byte~) main::$1
  (byte) main::x ← (byte) main::x0
  (byte) main::y ← (byte) main::y0
  (byte~) main::$2 ← (byte) main::yd / (byte) 2
  (byte) main::e ← (byte~) main::$2
  (byte~) main::$3 ← (byte) main::y * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN + (byte~) main::$3
  (byte*~) main::$5 ← (byte*~) main::$4 + (byte) main::x
  (byte*) main::cursor ← (byte*~) main::$5
main::@1:
  *((byte*) main::cursor) ← (byte) STAR
  (byte~) main::$6 ← (byte) main::x + (byte) 1
  (byte) main::x ← (byte~) main::$6
  (byte*~) main::$7 ← (byte*) main::cursor + (byte) 1
  (byte*) main::cursor ← (byte*~) main::$7
  (byte~) main::$8 ← (byte) main::e + (byte) main::yd
  (byte) main::e ← (byte~) main::$8
  (boolean~) main::$9 ← (byte) main::xd < (byte) main::e
  (boolean~) main::$10 ← ! (boolean~) main::$9
  if((boolean~) main::$10) goto main::@2
  (byte~) main::$11 ← (byte) main::y + (byte) 1
  (byte) main::y ← (byte~) main::$11
  (byte*~) main::$12 ← (byte*) main::cursor + (byte) 40
  (byte*) main::cursor ← (byte*~) main::$12
  (byte~) main::$13 ← (byte) main::e - (byte) main::xd
  (byte) main::e ← (byte~) main::$13
main::@2:
  (byte~) main::$14 ← (byte) main::x1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
main::@return:
  return 
endproc // main()

SYMBOLS
(void~) $0
(byte[1000]) SCREEN
(byte) STAR
(void()) main()
(byte~) main::$0
(byte~) main::$1
(boolean~) main::$10
(byte~) main::$11
(byte*~) main::$12
(byte~) main::$13
(byte~) main::$14
(boolean~) main::$15
(byte~) main::$2
(byte~) main::$3
(byte*~) main::$4
(byte*~) main::$5
(byte~) main::$6
(byte*~) main::$7
(byte~) main::$8
(boolean~) main::$9
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) main::cursor
(byte) main::e
(byte) main::x
(byte) main::x0
(byte) main::x1
(byte) main::xd
(byte) main::y
(byte) main::y0
(byte) main::y1
(byte) main::yd

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) STAR ← (byte) 81
  (byte[1000]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@1
main: scope:[main]  from
  (byte) main::x0 ← (byte) 0
  (byte) main::y0 ← (byte) 0
  (byte) main::x1 ← (byte) 39
  (byte) main::y1 ← (byte) 24
  (byte~) main::$0 ← (byte) main::x1 - (byte) main::x0
  (byte) main::xd ← (byte~) main::$0
  (byte~) main::$1 ← (byte) main::y1 - (byte) main::y0
  (byte) main::yd ← (byte~) main::$1
  (byte) main::x ← (byte) main::x0
  (byte) main::y ← (byte) main::y0
  (byte~) main::$2 ← (byte) main::yd / (byte) 2
  (byte) main::e ← (byte~) main::$2
  (byte~) main::$3 ← (byte) main::y * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN + (byte~) main::$3
  (byte*~) main::$5 ← (byte*~) main::$4 + (byte) main::x
  (byte*) main::cursor ← (byte*~) main::$5
  to:main::@1
main::@1: scope:[main]  from main main::@2
  *((byte*) main::cursor) ← (byte) STAR
  (byte~) main::$6 ← (byte) main::x + (byte) 1
  (byte) main::x ← (byte~) main::$6
  (byte*~) main::$7 ← (byte*) main::cursor + (byte) 1
  (byte*) main::cursor ← (byte*~) main::$7
  (byte~) main::$8 ← (byte) main::e + (byte) main::yd
  (byte) main::e ← (byte~) main::$8
  (boolean~) main::$9 ← (byte) main::xd < (byte) main::e
  (boolean~) main::$10 ← ! (boolean~) main::$9
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte~) main::$14 ← (byte) main::x1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@4
main::@3: scope:[main]  from main::@1
  (byte~) main::$11 ← (byte) main::y + (byte) 1
  (byte) main::y ← (byte~) main::$11
  (byte*~) main::$12 ← (byte*) main::cursor + (byte) 40
  (byte*) main::cursor ← (byte*~) main::$12
  (byte~) main::$13 ← (byte) main::e - (byte) main::xd
  (byte) main::e ← (byte~) main::$13
  to:main::@2
main::@4: scope:[main]  from main::@2
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return
@1: scope:[]  from @begin
  to:@end
@end: scope:[]  from @1

Removing empty block main::@4
Removing empty block @1
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) STAR ← (byte) 81
  (byte[1000]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@end
main: scope:[main]  from
  (byte) main::x0 ← (byte) 0
  (byte) main::y0 ← (byte) 0
  (byte) main::x1 ← (byte) 39
  (byte) main::y1 ← (byte) 24
  (byte~) main::$0 ← (byte) main::x1 - (byte) main::x0
  (byte) main::xd ← (byte~) main::$0
  (byte~) main::$1 ← (byte) main::y1 - (byte) main::y0
  (byte) main::yd ← (byte~) main::$1
  (byte) main::x ← (byte) main::x0
  (byte) main::y ← (byte) main::y0
  (byte~) main::$2 ← (byte) main::yd / (byte) 2
  (byte) main::e ← (byte~) main::$2
  (byte~) main::$3 ← (byte) main::y * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN + (byte~) main::$3
  (byte*~) main::$5 ← (byte*~) main::$4 + (byte) main::x
  (byte*) main::cursor ← (byte*~) main::$5
  to:main::@1
main::@1: scope:[main]  from main main::@2
  *((byte*) main::cursor) ← (byte) STAR
  (byte~) main::$6 ← (byte) main::x + (byte) 1
  (byte) main::x ← (byte~) main::$6
  (byte*~) main::$7 ← (byte*) main::cursor + (byte) 1
  (byte*) main::cursor ← (byte*~) main::$7
  (byte~) main::$8 ← (byte) main::e + (byte) main::yd
  (byte) main::e ← (byte~) main::$8
  (boolean~) main::$9 ← (byte) main::xd < (byte) main::e
  (boolean~) main::$10 ← ! (boolean~) main::$9
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte~) main::$14 ← (byte) main::x1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte~) main::$11 ← (byte) main::y + (byte) 1
  (byte) main::y ← (byte~) main::$11
  (byte*~) main::$12 ← (byte*) main::cursor + (byte) 40
  (byte*) main::cursor ← (byte*~) main::$12
  (byte~) main::$13 ← (byte) main::e - (byte) main::xd
  (byte) main::e ← (byte~) main::$13
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

PROCEDURE MODIFY VARIABLE ANALYSIS

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  (byte) STAR ← (byte) 81
  (byte[1000]) SCREEN ← (word) 1024
  call main param-assignment
  to:@2
@2: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  (byte) main::x0 ← (byte) 0
  (byte) main::y0 ← (byte) 0
  (byte) main::x1 ← (byte) 39
  (byte) main::y1 ← (byte) 24
  (byte~) main::$0 ← (byte) main::x1 - (byte) main::x0
  (byte) main::xd ← (byte~) main::$0
  (byte~) main::$1 ← (byte) main::y1 - (byte) main::y0
  (byte) main::yd ← (byte~) main::$1
  (byte) main::x ← (byte) main::x0
  (byte) main::y ← (byte) main::y0
  (byte~) main::$2 ← (byte) main::yd / (byte) 2
  (byte) main::e ← (byte~) main::$2
  (byte~) main::$3 ← (byte) main::y * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN + (byte~) main::$3
  (byte*~) main::$5 ← (byte*~) main::$4 + (byte) main::x
  (byte*) main::cursor ← (byte*~) main::$5
  to:main::@1
main::@1: scope:[main]  from main main::@2
  *((byte*) main::cursor) ← (byte) STAR
  (byte~) main::$6 ← (byte) main::x + (byte) 1
  (byte) main::x ← (byte~) main::$6
  (byte*~) main::$7 ← (byte*) main::cursor + (byte) 1
  (byte*) main::cursor ← (byte*~) main::$7
  (byte~) main::$8 ← (byte) main::e + (byte) main::yd
  (byte) main::e ← (byte~) main::$8
  (boolean~) main::$9 ← (byte) main::xd < (byte) main::e
  (boolean~) main::$10 ← ! (boolean~) main::$9
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte~) main::$14 ← (byte) main::x1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte~) main::$11 ← (byte) main::y + (byte) 1
  (byte) main::y ← (byte~) main::$11
  (byte*~) main::$12 ← (byte*) main::cursor + (byte) 40
  (byte*) main::cursor ← (byte*~) main::$12
  (byte~) main::$13 ← (byte) main::e - (byte) main::xd
  (byte) main::e ← (byte~) main::$13
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @2

Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) STAR#0 ← (byte) 81
  (byte[1000]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@2
@2: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  (byte) STAR#2 ← phi( @begin/(byte) STAR#0 )
  (byte[1000]) SCREEN#1 ← phi( @begin/(byte[1000]) SCREEN#0 )
  (byte) main::x0#0 ← (byte) 0
  (byte) main::y0#0 ← (byte) 0
  (byte) main::x1#0 ← (byte) 39
  (byte) main::y1#0 ← (byte) 24
  (byte~) main::$0 ← (byte) main::x1#0 - (byte) main::x0#0
  (byte) main::xd#0 ← (byte~) main::$0
  (byte~) main::$1 ← (byte) main::y1#0 - (byte) main::y0#0
  (byte) main::yd#0 ← (byte~) main::$1
  (byte) main::x#0 ← (byte) main::x0#0
  (byte) main::y#0 ← (byte) main::y0#0
  (byte~) main::$2 ← (byte) main::yd#0 / (byte) 2
  (byte) main::e#0 ← (byte~) main::$2
  (byte~) main::$3 ← (byte) main::y#0 * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN#1 + (byte~) main::$3
  (byte*~) main::$5 ← (byte*~) main::$4 + (byte) main::x#0
  (byte*) main::cursor#0 ← (byte*~) main::$5
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#3 ← phi( main/(byte) main::y#0 main::@2/(byte) main::y#4 )
  (byte) main::x1#2 ← phi( main/(byte) main::x1#0 main::@2/(byte) main::x1#1 )
  (byte) main::xd#1 ← phi( main/(byte) main::xd#0 main::@2/(byte) main::xd#3 )
  (byte) main::yd#1 ← phi( main/(byte) main::yd#0 main::@2/(byte) main::yd#2 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@2/(byte) main::x#3 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  (byte) STAR#1 ← phi( main/(byte) STAR#2 main::@2/(byte) STAR#3 )
  *((byte*) main::cursor#3) ← (byte) STAR#1
  (byte~) main::$6 ← (byte) main::x#2 + (byte) 1
  (byte) main::x#1 ← (byte~) main::$6
  (byte*~) main::$7 ← (byte*) main::cursor#3 + (byte) 1
  (byte*) main::cursor#1 ← (byte*~) main::$7
  (byte~) main::$8 ← (byte) main::e#3 + (byte) main::yd#1
  (byte) main::e#1 ← (byte~) main::$8
  (boolean~) main::$9 ← (byte) main::xd#1 < (byte) main::e#1
  (boolean~) main::$10 ← ! (boolean~) main::$9
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#3 main::@3/(byte) main::y#1 )
  (byte) main::xd#3 ← phi( main::@1/(byte) main::xd#1 main::@3/(byte) main::xd#2 )
  (byte) main::yd#2 ← phi( main::@1/(byte) main::yd#1 main::@3/(byte) main::yd#3 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte) STAR#3 ← phi( main::@1/(byte) STAR#1 main::@3/(byte) STAR#4 )
  (byte) main::x#3 ← phi( main::@1/(byte) main::x#1 main::@3/(byte) main::x#4 )
  (byte) main::x1#1 ← phi( main::@1/(byte) main::x1#2 main::@3/(byte) main::x1#3 )
  (byte~) main::$14 ← (byte) main::x1#1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x#3 < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::yd#3 ← phi( main::@1/(byte) main::yd#1 )
  (byte) STAR#4 ← phi( main::@1/(byte) STAR#1 )
  (byte) main::x#4 ← phi( main::@1/(byte) main::x#1 )
  (byte) main::x1#3 ← phi( main::@1/(byte) main::x1#2 )
  (byte) main::xd#2 ← phi( main::@1/(byte) main::xd#1 )
  (byte) main::e#4 ← phi( main::@1/(byte) main::e#1 )
  (byte*) main::cursor#4 ← phi( main::@1/(byte*) main::cursor#1 )
  (byte) main::y#2 ← phi( main::@1/(byte) main::y#3 )
  (byte~) main::$11 ← (byte) main::y#2 + (byte) 1
  (byte) main::y#1 ← (byte~) main::$11
  (byte*~) main::$12 ← (byte*) main::cursor#4 + (byte) 40
  (byte*) main::cursor#2 ← (byte*~) main::$12
  (byte~) main::$13 ← (byte) main::e#4 - (byte) main::xd#2
  (byte) main::e#2 ← (byte~) main::$13
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @2

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (byte) STAR#0 ← (byte) 81
  (byte[1000]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@2
@2: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  (byte) STAR#2 ← phi( @begin/(byte) STAR#0 )
  (byte[1000]) SCREEN#1 ← phi( @begin/(byte[1000]) SCREEN#0 )
  (byte) main::x0#0 ← (byte) 0
  (byte) main::y0#0 ← (byte) 0
  (byte) main::x1#0 ← (byte) 39
  (byte) main::y1#0 ← (byte) 24
  (byte~) main::$0 ← (byte) main::x1#0 - (byte) main::x0#0
  (byte) main::xd#0 ← (byte~) main::$0
  (byte~) main::$1 ← (byte) main::y1#0 - (byte) main::y0#0
  (byte) main::yd#0 ← (byte~) main::$1
  (byte) main::x#0 ← (byte) main::x0#0
  (byte) main::y#0 ← (byte) main::y0#0
  (byte~) main::$2 ← (byte) main::yd#0 / (byte) 2
  (byte) main::e#0 ← (byte~) main::$2
  (byte~) main::$3 ← (byte) main::y#0 * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN#1 + (byte~) main::$3
  (byte*~) main::$5 ← (byte*~) main::$4 + (byte) main::x#0
  (byte*) main::cursor#0 ← (byte*~) main::$5
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#3 ← phi( main/(byte) main::y#0 main::@2/(byte) main::y#4 )
  (byte) main::x1#2 ← phi( main/(byte) main::x1#0 main::@2/(byte) main::x1#1 )
  (byte) main::xd#1 ← phi( main/(byte) main::xd#0 main::@2/(byte) main::xd#3 )
  (byte) main::yd#1 ← phi( main/(byte) main::yd#0 main::@2/(byte) main::yd#2 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@2/(byte) main::x#3 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  (byte) STAR#1 ← phi( main/(byte) STAR#2 main::@2/(byte) STAR#3 )
  *((byte*) main::cursor#3) ← (byte) STAR#1
  (byte~) main::$6 ← (byte) main::x#2 + (byte) 1
  (byte) main::x#1 ← (byte~) main::$6
  (byte*~) main::$7 ← (byte*) main::cursor#3 + (byte) 1
  (byte*) main::cursor#1 ← (byte*~) main::$7
  (byte~) main::$8 ← (byte) main::e#3 + (byte) main::yd#1
  (byte) main::e#1 ← (byte~) main::$8
  (boolean~) main::$9 ← (byte) main::xd#1 < (byte) main::e#1
  (boolean~) main::$10 ← ! (boolean~) main::$9
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#3 main::@3/(byte) main::y#1 )
  (byte) main::xd#3 ← phi( main::@1/(byte) main::xd#1 main::@3/(byte) main::xd#2 )
  (byte) main::yd#2 ← phi( main::@1/(byte) main::yd#1 main::@3/(byte) main::yd#3 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte) STAR#3 ← phi( main::@1/(byte) STAR#1 main::@3/(byte) STAR#4 )
  (byte) main::x#3 ← phi( main::@1/(byte) main::x#1 main::@3/(byte) main::x#4 )
  (byte) main::x1#1 ← phi( main::@1/(byte) main::x1#2 main::@3/(byte) main::x1#3 )
  (byte~) main::$14 ← (byte) main::x1#1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x#3 < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::yd#3 ← phi( main::@1/(byte) main::yd#1 )
  (byte) STAR#4 ← phi( main::@1/(byte) STAR#1 )
  (byte) main::x#4 ← phi( main::@1/(byte) main::x#1 )
  (byte) main::x1#3 ← phi( main::@1/(byte) main::x1#2 )
  (byte) main::xd#2 ← phi( main::@1/(byte) main::xd#1 )
  (byte) main::e#4 ← phi( main::@1/(byte) main::e#1 )
  (byte*) main::cursor#4 ← phi( main::@1/(byte*) main::cursor#1 )
  (byte) main::y#2 ← phi( main::@1/(byte) main::y#3 )
  (byte~) main::$11 ← (byte) main::y#2 + (byte) 1
  (byte) main::y#1 ← (byte~) main::$11
  (byte*~) main::$12 ← (byte*) main::cursor#4 + (byte) 40
  (byte*) main::cursor#2 ← (byte*~) main::$12
  (byte~) main::$13 ← (byte) main::e#4 - (byte) main::xd#2
  (byte) main::e#2 ← (byte~) main::$13
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @2

INITIAL SSA SYMBOL TABLE
(label) @2
(label) @begin
(label) @end
(byte[1000]) SCREEN
(byte[1000]) SCREEN#0
(byte[1000]) SCREEN#1
(byte) STAR
(byte) STAR#0
(byte) STAR#1
(byte) STAR#2
(byte) STAR#3
(byte) STAR#4
(void()) main()
(byte~) main::$0
(byte~) main::$1
(boolean~) main::$10
(byte~) main::$11
(byte*~) main::$12
(byte~) main::$13
(byte~) main::$14
(boolean~) main::$15
(byte~) main::$2
(byte~) main::$3
(byte*~) main::$4
(byte*~) main::$5
(byte~) main::$6
(byte*~) main::$7
(byte~) main::$8
(boolean~) main::$9
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(byte*) main::cursor
(byte*) main::cursor#0
(byte*) main::cursor#1
(byte*) main::cursor#2
(byte*) main::cursor#3
(byte*) main::cursor#4
(byte*) main::cursor#5
(byte) main::e
(byte) main::e#0
(byte) main::e#1
(byte) main::e#2
(byte) main::e#3
(byte) main::e#4
(byte) main::e#5
(byte) main::x
(byte) main::x#0
(byte) main::x#1
(byte) main::x#2
(byte) main::x#3
(byte) main::x#4
(byte) main::x0
(byte) main::x0#0
(byte) main::x1
(byte) main::x1#0
(byte) main::x1#1
(byte) main::x1#2
(byte) main::x1#3
(byte) main::xd
(byte) main::xd#0
(byte) main::xd#1
(byte) main::xd#2
(byte) main::xd#3
(byte) main::y
(byte) main::y#0
(byte) main::y#1
(byte) main::y#2
(byte) main::y#3
(byte) main::y#4
(byte) main::y0
(byte) main::y0#0
(byte) main::y1
(byte) main::y1#0
(byte) main::yd
(byte) main::yd#0
(byte) main::yd#1
(byte) main::yd#2
(byte) main::yd#3

Culled Empty Block (label) @2
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) STAR#0 ← (byte) 81
  (byte[1000]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) STAR#2 ← phi( @begin/(byte) STAR#0 )
  (byte[1000]) SCREEN#1 ← phi( @begin/(byte[1000]) SCREEN#0 )
  (byte) main::x0#0 ← (byte) 0
  (byte) main::y0#0 ← (byte) 0
  (byte) main::x1#0 ← (byte) 39
  (byte) main::y1#0 ← (byte) 24
  (byte~) main::$0 ← (byte) main::x1#0 - (byte) main::x0#0
  (byte) main::xd#0 ← (byte~) main::$0
  (byte~) main::$1 ← (byte) main::y1#0 - (byte) main::y0#0
  (byte) main::yd#0 ← (byte~) main::$1
  (byte) main::x#0 ← (byte) main::x0#0
  (byte) main::y#0 ← (byte) main::y0#0
  (byte~) main::$2 ← (byte) main::yd#0 / (byte) 2
  (byte) main::e#0 ← (byte~) main::$2
  (byte~) main::$3 ← (byte) main::y#0 * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN#1 + (byte~) main::$3
  (byte*~) main::$5 ← (byte*~) main::$4 + (byte) main::x#0
  (byte*) main::cursor#0 ← (byte*~) main::$5
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#3 ← phi( main/(byte) main::y#0 main::@2/(byte) main::y#4 )
  (byte) main::x1#2 ← phi( main/(byte) main::x1#0 main::@2/(byte) main::x1#1 )
  (byte) main::xd#1 ← phi( main/(byte) main::xd#0 main::@2/(byte) main::xd#3 )
  (byte) main::yd#1 ← phi( main/(byte) main::yd#0 main::@2/(byte) main::yd#2 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@2/(byte) main::x#3 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  (byte) STAR#1 ← phi( main/(byte) STAR#2 main::@2/(byte) STAR#3 )
  *((byte*) main::cursor#3) ← (byte) STAR#1
  (byte~) main::$6 ← (byte) main::x#2 + (byte) 1
  (byte) main::x#1 ← (byte~) main::$6
  (byte*~) main::$7 ← (byte*) main::cursor#3 + (byte) 1
  (byte*) main::cursor#1 ← (byte*~) main::$7
  (byte~) main::$8 ← (byte) main::e#3 + (byte) main::yd#1
  (byte) main::e#1 ← (byte~) main::$8
  (boolean~) main::$9 ← (byte) main::xd#1 < (byte) main::e#1
  (boolean~) main::$10 ← ! (boolean~) main::$9
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#3 main::@3/(byte) main::y#1 )
  (byte) main::xd#3 ← phi( main::@1/(byte) main::xd#1 main::@3/(byte) main::xd#2 )
  (byte) main::yd#2 ← phi( main::@1/(byte) main::yd#1 main::@3/(byte) main::yd#3 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte) STAR#3 ← phi( main::@1/(byte) STAR#1 main::@3/(byte) STAR#4 )
  (byte) main::x#3 ← phi( main::@1/(byte) main::x#1 main::@3/(byte) main::x#4 )
  (byte) main::x1#1 ← phi( main::@1/(byte) main::x1#2 main::@3/(byte) main::x1#3 )
  (byte~) main::$14 ← (byte) main::x1#1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x#3 < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::yd#3 ← phi( main::@1/(byte) main::yd#1 )
  (byte) STAR#4 ← phi( main::@1/(byte) STAR#1 )
  (byte) main::x#4 ← phi( main::@1/(byte) main::x#1 )
  (byte) main::x1#3 ← phi( main::@1/(byte) main::x1#2 )
  (byte) main::xd#2 ← phi( main::@1/(byte) main::xd#1 )
  (byte) main::e#4 ← phi( main::@1/(byte) main::e#1 )
  (byte*) main::cursor#4 ← phi( main::@1/(byte*) main::cursor#1 )
  (byte) main::y#2 ← phi( main::@1/(byte) main::y#3 )
  (byte~) main::$11 ← (byte) main::y#2 + (byte) 1
  (byte) main::y#1 ← (byte~) main::$11
  (byte*~) main::$12 ← (byte*) main::cursor#4 + (byte) 40
  (byte*) main::cursor#2 ← (byte*~) main::$12
  (byte~) main::$13 ← (byte) main::e#4 - (byte) main::xd#2
  (byte) main::e#2 ← (byte~) main::$13
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Constant (byte) STAR#0 (byte) 81
Constant (byte[1000]) SCREEN#0 (word) 1024
Constant (byte) main::x0#0 (byte) 0
Constant (byte) main::y0#0 (byte) 0
Constant (byte) main::x1#0 (byte) 39
Constant (byte) main::y1#0 (byte) 24
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) STAR#2 ← phi( @begin/(byte) 81 )
  (byte[1000]) SCREEN#1 ← phi( @begin/(word) 1024 )
  (byte~) main::$0 ← (byte) 39 - (byte) 0
  (byte) main::xd#0 ← (byte~) main::$0
  (byte~) main::$1 ← (byte) 24 - (byte) 0
  (byte) main::yd#0 ← (byte~) main::$1
  (byte) main::x#0 ← (byte) 0
  (byte) main::y#0 ← (byte) 0
  (byte~) main::$2 ← (byte) main::yd#0 / (byte) 2
  (byte) main::e#0 ← (byte~) main::$2
  (byte~) main::$3 ← (byte) main::y#0 * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN#1 + (byte~) main::$3
  (byte*~) main::$5 ← (byte*~) main::$4 + (byte) main::x#0
  (byte*) main::cursor#0 ← (byte*~) main::$5
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#3 ← phi( main/(byte) main::y#0 main::@2/(byte) main::y#4 )
  (byte) main::x1#2 ← phi( main/(byte) 39 main::@2/(byte) main::x1#1 )
  (byte) main::xd#1 ← phi( main/(byte) main::xd#0 main::@2/(byte) main::xd#3 )
  (byte) main::yd#1 ← phi( main/(byte) main::yd#0 main::@2/(byte) main::yd#2 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@2/(byte) main::x#3 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  (byte) STAR#1 ← phi( main/(byte) STAR#2 main::@2/(byte) STAR#3 )
  *((byte*) main::cursor#3) ← (byte) STAR#1
  (byte~) main::$6 ← (byte) main::x#2 + (byte) 1
  (byte) main::x#1 ← (byte~) main::$6
  (byte*~) main::$7 ← (byte*) main::cursor#3 + (byte) 1
  (byte*) main::cursor#1 ← (byte*~) main::$7
  (byte~) main::$8 ← (byte) main::e#3 + (byte) main::yd#1
  (byte) main::e#1 ← (byte~) main::$8
  (boolean~) main::$9 ← (byte) main::xd#1 < (byte) main::e#1
  (boolean~) main::$10 ← ! (boolean~) main::$9
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#3 main::@3/(byte) main::y#1 )
  (byte) main::xd#3 ← phi( main::@1/(byte) main::xd#1 main::@3/(byte) main::xd#2 )
  (byte) main::yd#2 ← phi( main::@1/(byte) main::yd#1 main::@3/(byte) main::yd#3 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte) STAR#3 ← phi( main::@1/(byte) STAR#1 main::@3/(byte) STAR#4 )
  (byte) main::x#3 ← phi( main::@1/(byte) main::x#1 main::@3/(byte) main::x#4 )
  (byte) main::x1#1 ← phi( main::@1/(byte) main::x1#2 main::@3/(byte) main::x1#3 )
  (byte~) main::$14 ← (byte) main::x1#1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x#3 < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::yd#3 ← phi( main::@1/(byte) main::yd#1 )
  (byte) STAR#4 ← phi( main::@1/(byte) STAR#1 )
  (byte) main::x#4 ← phi( main::@1/(byte) main::x#1 )
  (byte) main::x1#3 ← phi( main::@1/(byte) main::x1#2 )
  (byte) main::xd#2 ← phi( main::@1/(byte) main::xd#1 )
  (byte) main::e#4 ← phi( main::@1/(byte) main::e#1 )
  (byte*) main::cursor#4 ← phi( main::@1/(byte*) main::cursor#1 )
  (byte) main::y#2 ← phi( main::@1/(byte) main::y#3 )
  (byte~) main::$11 ← (byte) main::y#2 + (byte) 1
  (byte) main::y#1 ← (byte~) main::$11
  (byte*~) main::$12 ← (byte*) main::cursor#4 + (byte) 40
  (byte*) main::cursor#2 ← (byte*~) main::$12
  (byte~) main::$13 ← (byte) main::e#4 - (byte) main::xd#2
  (byte) main::e#2 ← (byte~) main::$13
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Multiple usages for variable. Not optimizing sub-constant (byte) main::x1#1
Inversing boolean not (boolean~) main::$10 ← (byte) main::xd#1 >= (byte) main::e#1 from (boolean~) main::$9 ← (byte) main::xd#1 < (byte) main::e#1
Succesful SSA optimization Pass2UnaryNotSimplification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) STAR#2 ← phi( @begin/(byte) 81 )
  (byte[1000]) SCREEN#1 ← phi( @begin/(word) 1024 )
  (byte~) main::$0 ← (byte) 39 - (byte) 0
  (byte) main::xd#0 ← (byte~) main::$0
  (byte~) main::$1 ← (byte) 24 - (byte) 0
  (byte) main::yd#0 ← (byte~) main::$1
  (byte) main::x#0 ← (byte) 0
  (byte) main::y#0 ← (byte) 0
  (byte~) main::$2 ← (byte) main::yd#0 / (byte) 2
  (byte) main::e#0 ← (byte~) main::$2
  (byte~) main::$3 ← (byte) main::y#0 * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN#1 + (byte~) main::$3
  (byte*~) main::$5 ← (byte*~) main::$4 + (byte) main::x#0
  (byte*) main::cursor#0 ← (byte*~) main::$5
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#3 ← phi( main/(byte) main::y#0 main::@2/(byte) main::y#4 )
  (byte) main::x1#2 ← phi( main/(byte) 39 main::@2/(byte) main::x1#1 )
  (byte) main::xd#1 ← phi( main/(byte) main::xd#0 main::@2/(byte) main::xd#3 )
  (byte) main::yd#1 ← phi( main/(byte) main::yd#0 main::@2/(byte) main::yd#2 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@2/(byte) main::x#3 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  (byte) STAR#1 ← phi( main/(byte) STAR#2 main::@2/(byte) STAR#3 )
  *((byte*) main::cursor#3) ← (byte) STAR#1
  (byte~) main::$6 ← (byte) main::x#2 + (byte) 1
  (byte) main::x#1 ← (byte~) main::$6
  (byte*~) main::$7 ← (byte*) main::cursor#3 + (byte) 1
  (byte*) main::cursor#1 ← (byte*~) main::$7
  (byte~) main::$8 ← (byte) main::e#3 + (byte) main::yd#1
  (byte) main::e#1 ← (byte~) main::$8
  (boolean~) main::$10 ← (byte) main::xd#1 >= (byte) main::e#1
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#3 main::@3/(byte) main::y#1 )
  (byte) main::xd#3 ← phi( main::@1/(byte) main::xd#1 main::@3/(byte) main::xd#2 )
  (byte) main::yd#2 ← phi( main::@1/(byte) main::yd#1 main::@3/(byte) main::yd#3 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte) STAR#3 ← phi( main::@1/(byte) STAR#1 main::@3/(byte) STAR#4 )
  (byte) main::x#3 ← phi( main::@1/(byte) main::x#1 main::@3/(byte) main::x#4 )
  (byte) main::x1#1 ← phi( main::@1/(byte) main::x1#2 main::@3/(byte) main::x1#3 )
  (byte~) main::$14 ← (byte) main::x1#1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x#3 < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::yd#3 ← phi( main::@1/(byte) main::yd#1 )
  (byte) STAR#4 ← phi( main::@1/(byte) STAR#1 )
  (byte) main::x#4 ← phi( main::@1/(byte) main::x#1 )
  (byte) main::x1#3 ← phi( main::@1/(byte) main::x1#2 )
  (byte) main::xd#2 ← phi( main::@1/(byte) main::xd#1 )
  (byte) main::e#4 ← phi( main::@1/(byte) main::e#1 )
  (byte*) main::cursor#4 ← phi( main::@1/(byte*) main::cursor#1 )
  (byte) main::y#2 ← phi( main::@1/(byte) main::y#3 )
  (byte~) main::$11 ← (byte) main::y#2 + (byte) 1
  (byte) main::y#1 ← (byte~) main::$11
  (byte*~) main::$12 ← (byte*) main::cursor#4 + (byte) 40
  (byte*) main::cursor#2 ← (byte*~) main::$12
  (byte~) main::$13 ← (byte) main::e#4 - (byte) main::xd#2
  (byte) main::e#2 ← (byte~) main::$13
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Alias (byte) main::xd#0 = (byte~) main::$0 
Alias (byte) main::yd#0 = (byte~) main::$1 
Alias (byte) main::e#0 = (byte~) main::$2 
Alias (byte*) main::cursor#0 = (byte*~) main::$5 
Alias (byte) main::x#1 = (byte~) main::$6 (byte) main::x#4 
Alias (byte*) main::cursor#1 = (byte*~) main::$7 (byte*) main::cursor#4 
Alias (byte) main::e#1 = (byte~) main::$8 (byte) main::e#4 
Alias (byte) main::y#2 = (byte) main::y#3 
Alias (byte) main::xd#1 = (byte) main::xd#2 
Alias (byte) main::x1#2 = (byte) main::x1#3 
Alias (byte) STAR#1 = (byte) STAR#4 
Alias (byte) main::yd#1 = (byte) main::yd#3 
Alias (byte) main::y#1 = (byte~) main::$11 
Alias (byte*) main::cursor#2 = (byte*~) main::$12 
Alias (byte) main::e#2 = (byte~) main::$13 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) STAR#2 ← phi( @begin/(byte) 81 )
  (byte[1000]) SCREEN#1 ← phi( @begin/(word) 1024 )
  (byte) main::xd#0 ← (byte) 39 - (byte) 0
  (byte) main::yd#0 ← (byte) 24 - (byte) 0
  (byte) main::x#0 ← (byte) 0
  (byte) main::y#0 ← (byte) 0
  (byte) main::e#0 ← (byte) main::yd#0 / (byte) 2
  (byte~) main::$3 ← (byte) main::y#0 * (byte) 40
  (byte*~) main::$4 ← (byte[1000]) SCREEN#1 + (byte~) main::$3
  (byte*) main::cursor#0 ← (byte*~) main::$4 + (byte) main::x#0
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) main::y#0 main::@2/(byte) main::y#4 )
  (byte) main::x1#2 ← phi( main/(byte) 39 main::@2/(byte) main::x1#1 )
  (byte) main::xd#1 ← phi( main/(byte) main::xd#0 main::@2/(byte) main::xd#3 )
  (byte) main::yd#1 ← phi( main/(byte) main::yd#0 main::@2/(byte) main::yd#2 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@2/(byte) main::x#3 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  (byte) STAR#1 ← phi( main/(byte) STAR#2 main::@2/(byte) STAR#3 )
  *((byte*) main::cursor#3) ← (byte) STAR#1
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) main::yd#1
  (boolean~) main::$10 ← (byte) main::xd#1 >= (byte) main::e#1
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::xd#3 ← phi( main::@1/(byte) main::xd#1 main::@3/(byte) main::xd#1 )
  (byte) main::yd#2 ← phi( main::@1/(byte) main::yd#1 main::@3/(byte) main::yd#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte) STAR#3 ← phi( main::@1/(byte) STAR#1 main::@3/(byte) STAR#1 )
  (byte) main::x#3 ← phi( main::@1/(byte) main::x#1 main::@3/(byte) main::x#1 )
  (byte) main::x1#1 ← phi( main::@1/(byte) main::x1#2 main::@3/(byte) main::x1#2 )
  (byte~) main::$14 ← (byte) main::x1#1 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x#3 < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) main::xd#1
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Redundant Phi (byte[1000]) SCREEN#1 (word) 1024
Redundant Phi (byte) STAR#2 (byte) 81
Redundant Phi (byte) main::x1#1 (byte) main::x1#2
Redundant Phi (byte) main::x#3 (byte) main::x#1
Redundant Phi (byte) STAR#3 (byte) STAR#1
Redundant Phi (byte) main::yd#2 (byte) main::yd#1
Redundant Phi (byte) main::xd#3 (byte) main::xd#1
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) main::xd#0 ← (byte) 39 - (byte) 0
  (byte) main::yd#0 ← (byte) 24 - (byte) 0
  (byte) main::x#0 ← (byte) 0
  (byte) main::y#0 ← (byte) 0
  (byte) main::e#0 ← (byte) main::yd#0 / (byte) 2
  (byte~) main::$3 ← (byte) main::y#0 * (byte) 40
  (byte*~) main::$4 ← (word) 1024 + (byte~) main::$3
  (byte*) main::cursor#0 ← (byte*~) main::$4 + (byte) main::x#0
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) main::y#0 main::@2/(byte) main::y#4 )
  (byte) main::x1#2 ← phi( main/(byte) 39 main::@2/(byte) main::x1#2 )
  (byte) main::xd#1 ← phi( main/(byte) main::xd#0 main::@2/(byte) main::xd#1 )
  (byte) main::yd#1 ← phi( main/(byte) main::yd#0 main::@2/(byte) main::yd#1 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@2/(byte) main::x#1 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  (byte) STAR#1 ← phi( main/(byte) 81 main::@2/(byte) STAR#1 )
  *((byte*) main::cursor#3) ← (byte) STAR#1
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) main::yd#1
  (boolean~) main::$10 ← (byte) main::xd#1 >= (byte) main::e#1
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte~) main::$14 ← (byte) main::x1#2 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x#1 < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) main::xd#1
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Self Phi Eliminated (byte) STAR#1
Self Phi Eliminated (byte) main::yd#1
Self Phi Eliminated (byte) main::xd#1
Self Phi Eliminated (byte) main::x1#2
Succesful SSA optimization Pass2SelfPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) main::xd#0 ← (byte) 39 - (byte) 0
  (byte) main::yd#0 ← (byte) 24 - (byte) 0
  (byte) main::x#0 ← (byte) 0
  (byte) main::y#0 ← (byte) 0
  (byte) main::e#0 ← (byte) main::yd#0 / (byte) 2
  (byte~) main::$3 ← (byte) main::y#0 * (byte) 40
  (byte*~) main::$4 ← (word) 1024 + (byte~) main::$3
  (byte*) main::cursor#0 ← (byte*~) main::$4 + (byte) main::x#0
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) main::y#0 main::@2/(byte) main::y#4 )
  (byte) main::x1#2 ← phi( main/(byte) 39 )
  (byte) main::xd#1 ← phi( main/(byte) main::xd#0 )
  (byte) main::yd#1 ← phi( main/(byte) main::yd#0 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@2/(byte) main::x#1 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  (byte) STAR#1 ← phi( main/(byte) 81 )
  *((byte*) main::cursor#3) ← (byte) STAR#1
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) main::yd#1
  (boolean~) main::$10 ← (byte) main::xd#1 >= (byte) main::e#1
  if((boolean~) main::$10) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte~) main::$14 ← (byte) main::x1#2 + (byte) 1
  (boolean~) main::$15 ← (byte) main::x#1 < (byte~) main::$14
  if((boolean~) main::$15) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) main::xd#1
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Simple Condition (boolean~) main::$10 if((byte) main::xd#1>=(byte) main::e#1) goto main::@2
Simple Condition (boolean~) main::$15 if((byte) main::x#1<(byte~) main::$14) goto main::@1
Succesful SSA optimization Pass2ConditionalJumpSimplification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) main::xd#0 ← (byte) 39 - (byte) 0
  (byte) main::yd#0 ← (byte) 24 - (byte) 0
  (byte) main::x#0 ← (byte) 0
  (byte) main::y#0 ← (byte) 0
  (byte) main::e#0 ← (byte) main::yd#0 / (byte) 2
  (byte~) main::$3 ← (byte) main::y#0 * (byte) 40
  (byte*~) main::$4 ← (word) 1024 + (byte~) main::$3
  (byte*) main::cursor#0 ← (byte*~) main::$4 + (byte) main::x#0
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) main::y#0 main::@2/(byte) main::y#4 )
  (byte) main::x1#2 ← phi( main/(byte) 39 )
  (byte) main::xd#1 ← phi( main/(byte) main::xd#0 )
  (byte) main::yd#1 ← phi( main/(byte) main::yd#0 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@2/(byte) main::x#1 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  (byte) STAR#1 ← phi( main/(byte) 81 )
  *((byte*) main::cursor#3) ← (byte) STAR#1
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) main::yd#1
  if((byte) main::xd#1>=(byte) main::e#1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte~) main::$14 ← (byte) main::x1#2 + (byte) 1
  if((byte) main::x#1<(byte~) main::$14) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) main::xd#1
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Constant (byte) main::xd#0 (byte) 39
Constant (byte) main::yd#0 (byte) 24
Constant (byte) main::x#0 (byte) 0
Constant (byte) main::y#0 (byte) 0
Constant (byte) STAR#1 (byte) 81
Constant (byte) main::x1#2 (byte) 39
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) main::e#0 ← (byte) 24 / (byte) 2
  (byte~) main::$3 ← (byte) 0 * (byte) 40
  (byte*~) main::$4 ← (word) 1024 + (byte~) main::$3
  (byte*) main::cursor#0 ← (byte*~) main::$4 + (byte) 0
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) 0 main::@2/(byte) main::y#4 )
  (byte) main::xd#1 ← phi( main/(byte) 39 )
  (byte) main::yd#1 ← phi( main/(byte) 24 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) 0 main::@2/(byte) main::x#1 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  *((byte*) main::cursor#3) ← (byte) 81
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) main::yd#1
  if((byte) main::xd#1>=(byte) main::e#1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte~) main::$14 ← (byte) 39 + (byte) 1
  if((byte) main::x#1<(byte~) main::$14) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) main::xd#1
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Consolidated constant in assignment main::cursor#0
Multiple usages for variable. Not optimizing sub-constant (byte) main::y#2
Multiple usages for variable. Not optimizing sub-constant (byte*) main::cursor#1
Succesful SSA optimization Pass2ConstantAdditionElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) main::e#0 ← (byte) 24 / (byte) 2
  (byte~) main::$3 ← (byte) 0 * (byte) 40
  (byte*~) main::$4 ← (byte~) main::$3
  (byte*) main::cursor#0 ← (byte*~) main::$4 + (word) 1024
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) 0 main::@2/(byte) main::y#4 )
  (byte) main::xd#1 ← phi( main/(byte) 39 )
  (byte) main::yd#1 ← phi( main/(byte) 24 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) 0 main::@2/(byte) main::x#1 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  *((byte*) main::cursor#3) ← (byte) 81
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) main::yd#1
  if((byte) main::xd#1>=(byte) main::e#1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte~) main::$14 ← (byte) 39 + (byte) 1
  if((byte) main::x#1<(byte~) main::$14) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) main::xd#1
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Alias (byte~) main::$3 = (byte*~) main::$4 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) main::e#0 ← (byte) 24 / (byte) 2
  (byte~) main::$3 ← (byte) 0 * (byte) 40
  (byte*) main::cursor#0 ← (byte~) main::$3 + (word) 1024
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) 0 main::@2/(byte) main::y#4 )
  (byte) main::xd#1 ← phi( main/(byte) 39 )
  (byte) main::yd#1 ← phi( main/(byte) 24 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) 0 main::@2/(byte) main::x#1 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  *((byte*) main::cursor#3) ← (byte) 81
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) main::yd#1
  if((byte) main::xd#1>=(byte) main::e#1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte~) main::$14 ← (byte) 39 + (byte) 1
  if((byte) main::x#1<(byte~) main::$14) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) main::xd#1
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Redundant Phi (byte) main::yd#1 (byte) 24
Redundant Phi (byte) main::xd#1 (byte) 39
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte) main::e#0 ← (byte) 24 / (byte) 2
  (byte~) main::$3 ← (byte) 0 * (byte) 40
  (byte*) main::cursor#0 ← (byte~) main::$3 + (word) 1024
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) 0 main::@2/(byte) main::y#4 )
  (byte) main::e#3 ← phi( main/(byte) main::e#0 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) 0 main::@2/(byte) main::x#1 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  *((byte*) main::cursor#3) ← (byte) 81
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) 24
  if((byte) 39>=(byte) main::e#1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  (byte~) main::$14 ← (byte) 39 + (byte) 1
  if((byte) main::x#1<(byte~) main::$14) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) 39
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Constant (byte) main::e#0 (byte) 12
Constant (byte~) main::$3 (byte) 0
Constant (byte~) main::$14 (byte) 40
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  (byte*) main::cursor#0 ← (byte) 0 + (word) 1024
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) 0 main::@2/(byte) main::y#4 )
  (byte) main::e#3 ← phi( main/(byte) 12 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) 0 main::@2/(byte) main::x#1 )
  (byte*) main::cursor#3 ← phi( main/(byte*) main::cursor#0 main::@2/(byte*) main::cursor#5 )
  *((byte*) main::cursor#3) ← (byte) 81
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) 24
  if((byte) 39>=(byte) main::e#1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  if((byte) main::x#1<(byte) 40) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) 39
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Multiple usages for variable. Not optimizing sub-constant (byte) main::y#2
Multiple usages for variable. Not optimizing sub-constant (byte*) main::cursor#1
Constant (byte*) main::cursor#0 (word) 1024
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::y#2 ← phi( main/(byte) 0 main::@2/(byte) main::y#4 )
  (byte) main::e#3 ← phi( main/(byte) 12 main::@2/(byte) main::e#5 )
  (byte) main::x#2 ← phi( main/(byte) 0 main::@2/(byte) main::x#1 )
  (byte*) main::cursor#3 ← phi( main/(word) 1024 main::@2/(byte*) main::cursor#5 )
  *((byte*) main::cursor#3) ← (byte) 81
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) 24
  if((byte) 39>=(byte) main::e#1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1 main::@3
  (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 )
  (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 )
  (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 )
  if((byte) main::x#1<(byte) 40) goto main::@1
  to:main::@return
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) 39
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@end: scope:[]  from @begin

Multiple usages for variable. Not optimizing sub-constant (byte) main::y#2
Multiple usages for variable. Not optimizing sub-constant (byte*) main::cursor#1
Multiple usages for variable. Not optimizing sub-constant (byte) main::y#2
Multiple usages for variable. Not optimizing sub-constant (byte*) main::cursor#1
FINAL SYMBOL TABLE
(label) @begin
(label) @end
(byte[1000]) SCREEN
(byte) STAR
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(byte*) main::cursor
(byte*) main::cursor#1
(byte*) main::cursor#2
(byte*) main::cursor#3
(byte*) main::cursor#5
(byte) main::e
(byte) main::e#1
(byte) main::e#2
(byte) main::e#3
(byte) main::e#5
(byte) main::x
(byte) main::x#1
(byte) main::x#2
(byte) main::x0
(byte) main::x1
(byte) main::xd
(byte) main::y
(byte) main::y#1
(byte) main::y#2
(byte) main::y#4
(byte) main::y0
(byte) main::y1
(byte) main::yd

Block Sequence Planned @begin @end main main::@1 main::@3 main::@2 main::@return 
Added new block during phi lifting main::@5(between main::@2 and main::@1)
Added new block during phi lifting main::@6(between main::@1 and main::@2)
Block Sequence Planned @begin @end main main::@1 main::@3 main::@2 main::@return main::@5 main::@6 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  call main param-assignment
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  to:main::@1
main::@1: scope:[main]  from main main::@5
  (byte) main::y#2 ← phi( main/(byte) 0 main::@5/(byte~) main::y#5 )
  (byte) main::e#3 ← phi( main/(byte) 12 main::@5/(byte~) main::e#6 )
  (byte) main::x#2 ← phi( main/(byte) 0 main::@5/(byte~) main::x#5 )
  (byte*) main::cursor#3 ← phi( main/(word) 1024 main::@5/(byte*~) main::cursor#6 )
  *((byte*) main::cursor#3) ← (byte) 81
  (byte) main::x#1 ← (byte) main::x#2 + (byte) 1
  (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1
  (byte) main::e#1 ← (byte) main::e#3 + (byte) 24
  if((byte) 39>=(byte) main::e#1) goto main::@6
  to:main::@3
main::@3: scope:[main]  from main::@1
  (byte) main::y#1 ← (byte) main::y#2 + (byte) 1
  (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40
  (byte) main::e#2 ← (byte) main::e#1 - (byte) 39
  (byte*~) main::cursor#8 ← (byte*) main::cursor#2
  (byte~) main::e#8 ← (byte) main::e#2
  (byte~) main::y#7 ← (byte) main::y#1
  to:main::@2
main::@2: scope:[main]  from main::@3 main::@6
  (byte) main::y#4 ← phi( main::@6/(byte~) main::y#6 main::@3/(byte~) main::y#7 )
  (byte) main::e#5 ← phi( main::@6/(byte~) main::e#7 main::@3/(byte~) main::e#8 )
  (byte*) main::cursor#5 ← phi( main::@6/(byte*~) main::cursor#7 main::@3/(byte*~) main::cursor#8 )
  if((byte) main::x#1<(byte) 40) goto main::@5
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
main::@5: scope:[main]  from main::@2
  (byte*~) main::cursor#6 ← (byte*) main::cursor#5
  (byte~) main::x#5 ← (byte) main::x#1
  (byte~) main::e#6 ← (byte) main::e#5
  (byte~) main::y#5 ← (byte) main::y#4
  to:main::@1
main::@6: scope:[main]  from main::@1
  (byte*~) main::cursor#7 ← (byte*) main::cursor#1
  (byte~) main::e#7 ← (byte) main::e#1
  (byte~) main::y#6 ← (byte) main::y#2
  to:main::@2

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [1] (byte) main::y#2 ← phi( main/(byte) 0 main::@5/(byte~) main::y#5 ) [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [1] (byte) main::e#3 ← phi( main/(byte) 12 main::@5/(byte~) main::e#6 ) [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [1] (byte) main::x#2 ← phi( main/(byte) 0 main::@5/(byte~) main::x#5 ) [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [1] (byte*) main::cursor#3 ← phi( main/(word) 1024 main::@5/(byte*~) main::cursor#6 ) [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [3] (byte) main::x#1 ← (byte) main::x#2 + (byte) 1 [ main::cursor#3 main::e#3 main::y#2 main::x#1 ]
  [4] (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1 [ main::e#3 main::y#2 main::cursor#1 main::x#1 ]
  [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::e#1 main::y#2 main::cursor#1 main::x#1 ]
  [6] if((byte) 39>=(byte) main::e#1) goto main::@6 [ main::e#1 main::y#2 main::cursor#1 main::x#1 ]
  to:main::@3
main::@3: scope:[main]  from main::@1
  [7] (byte) main::y#1 ← (byte) main::y#2 + (byte) 1 [ main::e#1 main::cursor#1 main::y#1 main::x#1 ]
  [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::e#1 main::cursor#2 main::y#1 main::x#1 ]
  [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::cursor#2 main::e#2 main::y#1 main::x#1 ]
  [10] (byte*~) main::cursor#8 ← (byte*) main::cursor#2 [ main::e#2 main::y#1 main::cursor#8 main::x#1 ]
  [11] (byte~) main::e#8 ← (byte) main::e#2 [ main::y#1 main::cursor#8 main::e#8 main::x#1 ]
  [12] (byte~) main::y#7 ← (byte) main::y#1 [ main::cursor#8 main::e#8 main::y#7 main::x#1 ]
  to:main::@2
main::@2: scope:[main]  from main::@3 main::@6
  [13] (byte) main::y#4 ← phi( main::@6/(byte~) main::y#6 main::@3/(byte~) main::y#7 ) [ main::x#1 main::cursor#5 main::e#5 main::y#4 ]
  [13] (byte) main::e#5 ← phi( main::@6/(byte~) main::e#7 main::@3/(byte~) main::e#8 ) [ main::x#1 main::cursor#5 main::e#5 main::y#4 ]
  [13] (byte*) main::cursor#5 ← phi( main::@6/(byte*~) main::cursor#7 main::@3/(byte*~) main::cursor#8 ) [ main::x#1 main::cursor#5 main::e#5 main::y#4 ]
  [14] if((byte) main::x#1<(byte) 40) goto main::@5 [ main::x#1 main::cursor#5 main::e#5 main::y#4 ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [15] return  [ ]
  to:@return
main::@5: scope:[main]  from main::@2
  [16] (byte*~) main::cursor#6 ← (byte*) main::cursor#5 [ main::cursor#6 main::x#1 main::e#5 main::y#4 ]
  [17] (byte~) main::x#5 ← (byte) main::x#1 [ main::cursor#6 main::x#5 main::e#5 main::y#4 ]
  [18] (byte~) main::e#6 ← (byte) main::e#5 [ main::cursor#6 main::x#5 main::e#6 main::y#4 ]
  [19] (byte~) main::y#5 ← (byte) main::y#4 [ main::cursor#6 main::x#5 main::e#6 main::y#5 ]
  to:main::@1
main::@6: scope:[main]  from main::@1
  [20] (byte*~) main::cursor#7 ← (byte*) main::cursor#1 [ main::e#1 main::y#2 main::cursor#7 main::x#1 ]
  [21] (byte~) main::e#7 ← (byte) main::e#1 [ main::y#2 main::cursor#7 main::e#7 main::x#1 ]
  [22] (byte~) main::y#6 ← (byte) main::y#2 [ main::cursor#7 main::e#7 main::y#6 main::x#1 ]
  to:main::@2

Created 7 initial phi equivalence classes
Coalesced [10] main::cursor#8 ← main::cursor#2
Coalesced [11] main::e#8 ← main::e#2
Coalesced [12] main::y#7 ← main::y#1
Coalesced [16] main::cursor#6 ← main::cursor#5
Coalesced [17] main::x#5 ← main::x#1
Coalesced [18] main::e#6 ← main::e#5
Coalesced [19] main::y#5 ← main::y#4
Coalesced [20] main::cursor#7 ← main::cursor#1
Coalesced [21] main::e#7 ← main::e#1
Coalesced (already) [22] main::y#6 ← main::y#2
Coalesced down to 4 phi equivalence classes
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@6
Block Sequence Planned @begin @end main main::@1 main::@3 main::@2 main::@return 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [1] (byte) main::y#2 ← phi( main/(byte) 0 main::@2/(byte) main::y#4 ) [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [1] (byte) main::e#3 ← phi( main/(byte) 12 main::@2/(byte) main::e#5 ) [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [1] (byte) main::x#2 ← phi( main/(byte) 0 main::@2/(byte) main::x#1 ) [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [1] (byte*) main::cursor#3 ← phi( main/(word) 1024 main::@2/(byte*) main::cursor#5 ) [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ]
  [3] (byte) main::x#1 ← (byte) main::x#2 + (byte) 1 [ main::x#1 main::cursor#3 main::e#3 main::y#2 ]
  [4] (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1 [ main::x#1 main::e#3 main::y#2 main::cursor#1 ]
  [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ]
  [6] if((byte) 39>=(byte) main::e#1) goto main::@2 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ]
  to:main::@3
main::@3: scope:[main]  from main::@1
  [7] (byte) main::y#1 ← (byte) main::y#2 + (byte) 1 [ main::x#1 main::e#1 main::cursor#1 main::y#1 ]
  [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::x#1 main::e#1 main::cursor#2 main::y#1 ]
  [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::x#1 main::cursor#2 main::e#2 main::y#1 ]
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@3
  [10] (byte) main::y#4 ← phi( main::@1/(byte) main::y#2 main::@3/(byte) main::y#1 ) [ main::cursor#5 main::x#1 main::e#5 main::y#4 ]
  [10] (byte) main::e#5 ← phi( main::@1/(byte) main::e#1 main::@3/(byte) main::e#2 ) [ main::cursor#5 main::x#1 main::e#5 main::y#4 ]
  [10] (byte*) main::cursor#5 ← phi( main::@1/(byte*) main::cursor#1 main::@3/(byte*) main::cursor#2 ) [ main::cursor#5 main::x#1 main::e#5 main::y#4 ]
  [11] if((byte) main::x#1<(byte) 40) goto main::@1 [ main::cursor#5 main::x#1 main::e#5 main::y#4 ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [12] return  [ ]
  to:@return

CALL GRAPH
Calls in [] to 0:main 

DOMINATORS
@begin dominated by  @begin 
@end dominated by  @end @begin 
main dominated by  @begin main 
main::@1 dominated by  @begin main::@1 main 
main::@3 dominated by  @begin main::@1 main::@3 main 
main::@2 dominated by  @begin main::@2 main::@1 main 
main::@return dominated by  main::@return @begin main::@2 main::@1 main 

Found back edge: Loop head: main::@1 tails: main::@2 blocks: null
Populated: Loop head: main::@1 tails: main::@2 blocks: main::@2 main::@1 main::@3 
NATURAL LOOPS
Loop head: main::@1 tails: main::@2 blocks: main::@2 main::@1 main::@3 

Found 0 loops in scope []
Found 1 loops in scope [main]
  Loop head: main::@1 tails: main::@2 blocks: main::@2 main::@1 main::@3 
NATURAL LOOPS WITH DEPTH
Loop head: main::@1 tails: main::@2 blocks: main::@2 main::@1 main::@3  depth: 1


VARIABLE REGISTER WEIGHTS
(byte[1000]) SCREEN
(byte) STAR
(void()) main()
(byte*) main::cursor
(byte*) main::cursor#1 8.25
(byte*) main::cursor#2 11.0
(byte*) main::cursor#3 11.0
(byte*) main::cursor#5 16.5
(byte) main::e
(byte) main::e#1 11.0
(byte) main::e#2 22.0
(byte) main::e#3 5.5
(byte) main::e#5 16.5
(byte) main::x
(byte) main::x#1 3.666666666666667
(byte) main::x#2 11.0
(byte) main::x0
(byte) main::x1
(byte) main::xd
(byte) main::y
(byte) main::y#1 7.333333333333333
(byte) main::y#2 5.5
(byte) main::y#4 16.5
(byte) main::y0
(byte) main::y1
(byte) main::yd

Initial phi equivalence classes
[ main::cursor#3 main::cursor#5 main::cursor#1 main::cursor#2 ]
[ main::x#2 main::x#1 ]
[ main::e#3 main::e#5 main::e#1 main::e#2 ]
[ main::y#2 main::y#4 main::y#1 ]
Complete equivalence classes
[ main::cursor#3 main::cursor#5 main::cursor#1 main::cursor#2 ]
[ main::x#2 main::x#1 ]
[ main::e#3 main::e#5 main::e#1 main::e#2 ]
[ main::y#2 main::y#4 main::y#1 ]
Allocated zp ZP_PTR_BYTE:2 [ main::cursor#3 main::cursor#5 main::cursor#1 main::cursor#2 ]
Allocated zp ZP_BYTE:4 [ main::x#2 main::x#1 ]
Allocated zp ZP_BYTE:5 [ main::e#3 main::e#5 main::e#1 main::e#2 ]
Allocated zp ZP_BYTE:6 [ main::y#2 main::y#4 main::y#1 ]
INITIAL ASM
//SEG0 Global ZP labels
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
  jsr main
  jmp bend
//SEG3 @end
bend:
//SEG4 main
main: {
    .label x = 4
    .label cursor = 2
    .label e = 5
    .label y = 6
  //SEG5 [1] phi from main to main::@1
  b1_from_main:
  //SEG6 [1] phi (byte) main::y#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta y
  //SEG7 [1] phi (byte) main::e#3 = (byte) 12 -- zpby1=coby1 
    lda #$c
    sta e
  //SEG8 [1] phi (byte) main::x#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta x
  //SEG9 [1] phi (byte*) main::cursor#3 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta cursor
    lda #>$400
    sta cursor+$1
    jmp b1
  //SEG10 [1] phi from main::@2 to main::@1
  b1_from_b2:
  //SEG11 [1] phi (byte) main::y#2 = (byte) main::y#4 -- register_copy 
  //SEG12 [1] phi (byte) main::e#3 = (byte) main::e#5 -- register_copy 
  //SEG13 [1] phi (byte) main::x#2 = (byte) main::x#1 -- register_copy 
  //SEG14 [1] phi (byte*) main::cursor#3 = (byte*) main::cursor#5 -- register_copy 
    jmp b1
  //SEG15 main::@1
  b1:
  //SEG16 [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$51
    sta (cursor),y
  //SEG17 [3] (byte) main::x#1 ← (byte) main::x#2 + (byte) 1 [ main::x#1 main::cursor#3 main::e#3 main::y#2 ] -- zpby1=zpby1_plus_1 
    inc x
  //SEG18 [4] (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1 [ main::x#1 main::e#3 main::y#2 main::cursor#1 ] -- zpptrby1=zpptrby1_plus_1 
    inc cursor
    bne !+
    inc cursor+$1
  !:
  //SEG19 [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- zpby1=zpby1_plus_coby1 
    lda e
    clc
    adc #$18
    sta e
  //SEG20 [6] if((byte) 39>=(byte) main::e#1) goto main::@2 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- coby1_ge_zpby1_then_la1 
    lda #$27
    cmp e
    bcs b2_from_b1
    jmp b3
  //SEG21 main::@3
  b3:
  //SEG22 [7] (byte) main::y#1 ← (byte) main::y#2 + (byte) 1 [ main::x#1 main::e#1 main::cursor#1 main::y#1 ] -- zpby1=zpby1_plus_1 
    inc y
  //SEG23 [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::x#1 main::e#1 main::cursor#2 main::y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
    lda cursor
    clc
    adc #$28
    sta cursor
    bcc !+
    inc cursor+$1
  !:
  //SEG24 [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::x#1 main::cursor#2 main::e#2 main::y#1 ] -- zpby1=zpby1_minus_coby1 
    lda e
    sec
    sbc #$27
    sta e
  //SEG25 [10] phi from main::@1 main::@3 to main::@2
  b2_from_b1:
  b2_from_b3:
  //SEG26 [10] phi (byte) main::y#4 = (byte) main::y#2 -- register_copy 
  //SEG27 [10] phi (byte) main::e#5 = (byte) main::e#1 -- register_copy 
  //SEG28 [10] phi (byte*) main::cursor#5 = (byte*) main::cursor#1 -- register_copy 
    jmp b2
  //SEG29 main::@2
  b2:
  //SEG30 [11] if((byte) main::x#1<(byte) 40) goto main::@1 [ main::cursor#5 main::x#1 main::e#5 main::y#4 ] -- zpby1_lt_coby1_then_la1 
    lda x
    cmp #$28
    bcc b1_from_b2
    jmp breturn
  //SEG31 main::@return
  breturn:
  //SEG32 [12] return  [ ]
    rts
}

Statement [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ] always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ main::x#2 main::x#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:4 [ main::x#2 main::x#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ main::e#3 main::e#5 main::e#1 main::e#2 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:5 [ main::e#3 main::e#5 main::e#1 main::e#2 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ main::y#2 main::y#4 main::y#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:6 [ main::y#2 main::y#4 main::y#1 ]
Statement [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] always clobbers reg byte a 
Statement [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::x#1 main::e#1 main::cursor#2 main::y#1 ] always clobbers reg byte a 
Statement [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::x#1 main::cursor#2 main::e#2 main::y#1 ] always clobbers reg byte a 
Statement [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ] always clobbers reg byte a reg byte y 
Statement [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] always clobbers reg byte a 
Statement [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::x#1 main::e#1 main::cursor#2 main::y#1 ] always clobbers reg byte a 
Statement [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::x#1 main::cursor#2 main::e#2 main::y#1 ] always clobbers reg byte a 
REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp ZP_PTR_BYTE:2 [ main::cursor#3 main::cursor#5 main::cursor#1 main::cursor#2 ] : zp ZP_PTR_BYTE:2 , 
Potential registers zp ZP_BYTE:4 [ main::x#2 main::x#1 ] : zp ZP_BYTE:4 , reg byte x , 
Potential registers zp ZP_BYTE:5 [ main::e#3 main::e#5 main::e#1 main::e#2 ] : zp ZP_BYTE:5 , reg byte x , 
Potential registers zp ZP_BYTE:6 [ main::y#2 main::y#4 main::y#1 ] : zp ZP_BYTE:6 , reg byte x , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 55: zp ZP_BYTE:5 [ main::e#3 main::e#5 main::e#1 main::e#2 ] 46.75: zp ZP_PTR_BYTE:2 [ main::cursor#3 main::cursor#5 main::cursor#1 main::cursor#2 ] 29.33: zp ZP_BYTE:6 [ main::y#2 main::y#4 main::y#1 ] 14.67: zp ZP_BYTE:4 [ main::x#2 main::x#1 ] 
Uplift Scope [] 

Uplifting [main] best 1165 combination reg byte x [ main::e#3 main::e#5 main::e#1 main::e#2 ] zp ZP_PTR_BYTE:2 [ main::cursor#3 main::cursor#5 main::cursor#1 main::cursor#2 ] zp ZP_BYTE:6 [ main::y#2 main::y#4 main::y#1 ] zp ZP_BYTE:4 [ main::x#2 main::x#1 ] 
Uplifting [] best 1165 combination 
Allocated (was zp ZP_BYTE:6) zp ZP_BYTE:5 [ main::y#2 main::y#4 main::y#1 ]
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 Global ZP labels
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
  jsr main
//SEG3 @end
bend:
//SEG4 main
main: {
    .label x = 4
    .label cursor = 2
    .label y = 5
  //SEG5 [1] phi from main to main::@1
  b1_from_main:
  //SEG6 [1] phi (byte) main::y#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta y
  //SEG7 [1] phi (byte) main::e#3 = (byte) 12 -- xby=coby1 
    ldx #$c
  //SEG8 [1] phi (byte) main::x#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta x
  //SEG9 [1] phi (byte*) main::cursor#3 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta cursor
    lda #>$400
    sta cursor+$1
    jmp b1
  //SEG10 [1] phi from main::@2 to main::@1
  b1_from_b2:
  //SEG11 [1] phi (byte) main::y#2 = (byte) main::y#4 -- register_copy 
  //SEG12 [1] phi (byte) main::e#3 = (byte) main::e#5 -- register_copy 
  //SEG13 [1] phi (byte) main::x#2 = (byte) main::x#1 -- register_copy 
  //SEG14 [1] phi (byte*) main::cursor#3 = (byte*) main::cursor#5 -- register_copy 
  //SEG15 main::@1
  b1:
  //SEG16 [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$51
    sta (cursor),y
  //SEG17 [3] (byte) main::x#1 ← (byte) main::x#2 + (byte) 1 [ main::x#1 main::cursor#3 main::e#3 main::y#2 ] -- zpby1=zpby1_plus_1 
    inc x
  //SEG18 [4] (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1 [ main::x#1 main::e#3 main::y#2 main::cursor#1 ] -- zpptrby1=zpptrby1_plus_1 
    inc cursor
    bne !+
    inc cursor+$1
  !:
  //SEG19 [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- xby=xby_plus_coby1 
    txa
    clc
    adc #$18
    tax
  //SEG20 [6] if((byte) 39>=(byte) main::e#1) goto main::@2 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- coby1_ge_xby_then_la1 
    cpx #$27
    bcc b2_from_b1
  //SEG21 main::@3
  b3:
  //SEG22 [7] (byte) main::y#1 ← (byte) main::y#2 + (byte) 1 [ main::x#1 main::e#1 main::cursor#1 main::y#1 ] -- zpby1=zpby1_plus_1 
    inc y
  //SEG23 [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::x#1 main::e#1 main::cursor#2 main::y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
    lda cursor
    clc
    adc #$28
    sta cursor
    bcc !+
    inc cursor+$1
  !:
  //SEG24 [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::x#1 main::cursor#2 main::e#2 main::y#1 ] -- xby=xby_minus_coby1 
    txa
    sec
    sbc #$27
    tax
  //SEG25 [10] phi from main::@1 main::@3 to main::@2
  b2_from_b1:
  b2_from_b3:
  //SEG26 [10] phi (byte) main::y#4 = (byte) main::y#2 -- register_copy 
  //SEG27 [10] phi (byte) main::e#5 = (byte) main::e#1 -- register_copy 
  //SEG28 [10] phi (byte*) main::cursor#5 = (byte*) main::cursor#1 -- register_copy 
  //SEG29 main::@2
  b2:
  //SEG30 [11] if((byte) main::x#1<(byte) 40) goto main::@1 [ main::cursor#5 main::x#1 main::e#5 main::y#4 ] -- zpby1_lt_coby1_then_la1 
    lda x
    cmp #$28
    bcc b1_from_b2
  //SEG31 main::@return
  breturn:
  //SEG32 [12] return  [ ]
    rts
}

Replacing label b2_from_b1 with b2
Replacing label b1_from_b2 with b1
Removing instruction b1_from_b2:
Removing instruction b2_from_b1:
Removing instruction b2_from_b3:
Succesful ASM optimization Pass5RedundantLabelElimination
ASSEMBLER
//SEG0 Global ZP labels
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
  jsr main
//SEG3 @end
bend:
//SEG4 main
main: {
    .label x = 4
    .label cursor = 2
    .label y = 5
  //SEG5 [1] phi from main to main::@1
  b1_from_main:
  //SEG6 [1] phi (byte) main::y#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta y
  //SEG7 [1] phi (byte) main::e#3 = (byte) 12 -- xby=coby1 
    ldx #$c
  //SEG8 [1] phi (byte) main::x#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta x
  //SEG9 [1] phi (byte*) main::cursor#3 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta cursor
    lda #>$400
    sta cursor+$1
    jmp b1
  //SEG10 [1] phi from main::@2 to main::@1
  //SEG11 [1] phi (byte) main::y#2 = (byte) main::y#4 -- register_copy 
  //SEG12 [1] phi (byte) main::e#3 = (byte) main::e#5 -- register_copy 
  //SEG13 [1] phi (byte) main::x#2 = (byte) main::x#1 -- register_copy 
  //SEG14 [1] phi (byte*) main::cursor#3 = (byte*) main::cursor#5 -- register_copy 
  //SEG15 main::@1
  b1:
  //SEG16 [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$51
    sta (cursor),y
  //SEG17 [3] (byte) main::x#1 ← (byte) main::x#2 + (byte) 1 [ main::x#1 main::cursor#3 main::e#3 main::y#2 ] -- zpby1=zpby1_plus_1 
    inc x
  //SEG18 [4] (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1 [ main::x#1 main::e#3 main::y#2 main::cursor#1 ] -- zpptrby1=zpptrby1_plus_1 
    inc cursor
    bne !+
    inc cursor+$1
  !:
  //SEG19 [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- xby=xby_plus_coby1 
    txa
    clc
    adc #$18
    tax
  //SEG20 [6] if((byte) 39>=(byte) main::e#1) goto main::@2 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- coby1_ge_xby_then_la1 
    cpx #$27
    bcc b2
  //SEG21 main::@3
  b3:
  //SEG22 [7] (byte) main::y#1 ← (byte) main::y#2 + (byte) 1 [ main::x#1 main::e#1 main::cursor#1 main::y#1 ] -- zpby1=zpby1_plus_1 
    inc y
  //SEG23 [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::x#1 main::e#1 main::cursor#2 main::y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
    lda cursor
    clc
    adc #$28
    sta cursor
    bcc !+
    inc cursor+$1
  !:
  //SEG24 [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::x#1 main::cursor#2 main::e#2 main::y#1 ] -- xby=xby_minus_coby1 
    txa
    sec
    sbc #$27
    tax
  //SEG25 [10] phi from main::@1 main::@3 to main::@2
  //SEG26 [10] phi (byte) main::y#4 = (byte) main::y#2 -- register_copy 
  //SEG27 [10] phi (byte) main::e#5 = (byte) main::e#1 -- register_copy 
  //SEG28 [10] phi (byte*) main::cursor#5 = (byte*) main::cursor#1 -- register_copy 
  //SEG29 main::@2
  b2:
  //SEG30 [11] if((byte) main::x#1<(byte) 40) goto main::@1 [ main::cursor#5 main::x#1 main::e#5 main::y#4 ] -- zpby1_lt_coby1_then_la1 
    lda x
    cmp #$28
    bcc b1
  //SEG31 main::@return
  breturn:
  //SEG32 [12] return  [ ]
    rts
}

Removing instruction bbegin:
Removing instruction bend:
Removing instruction b1_from_main:
Removing instruction b3:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
ASSEMBLER
//SEG0 Global ZP labels
//SEG1 @begin
//SEG2 [0] call main param-assignment [ ]
  jsr main
//SEG3 @end
//SEG4 main
main: {
    .label x = 4
    .label cursor = 2
    .label y = 5
  //SEG5 [1] phi from main to main::@1
  //SEG6 [1] phi (byte) main::y#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta y
  //SEG7 [1] phi (byte) main::e#3 = (byte) 12 -- xby=coby1 
    ldx #$c
  //SEG8 [1] phi (byte) main::x#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta x
  //SEG9 [1] phi (byte*) main::cursor#3 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta cursor
    lda #>$400
    sta cursor+$1
    jmp b1
  //SEG10 [1] phi from main::@2 to main::@1
  //SEG11 [1] phi (byte) main::y#2 = (byte) main::y#4 -- register_copy 
  //SEG12 [1] phi (byte) main::e#3 = (byte) main::e#5 -- register_copy 
  //SEG13 [1] phi (byte) main::x#2 = (byte) main::x#1 -- register_copy 
  //SEG14 [1] phi (byte*) main::cursor#3 = (byte*) main::cursor#5 -- register_copy 
  //SEG15 main::@1
  b1:
  //SEG16 [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$51
    sta (cursor),y
  //SEG17 [3] (byte) main::x#1 ← (byte) main::x#2 + (byte) 1 [ main::x#1 main::cursor#3 main::e#3 main::y#2 ] -- zpby1=zpby1_plus_1 
    inc x
  //SEG18 [4] (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1 [ main::x#1 main::e#3 main::y#2 main::cursor#1 ] -- zpptrby1=zpptrby1_plus_1 
    inc cursor
    bne !+
    inc cursor+$1
  !:
  //SEG19 [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- xby=xby_plus_coby1 
    txa
    clc
    adc #$18
    tax
  //SEG20 [6] if((byte) 39>=(byte) main::e#1) goto main::@2 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- coby1_ge_xby_then_la1 
    cpx #$27
    bcc b2
  //SEG21 main::@3
  //SEG22 [7] (byte) main::y#1 ← (byte) main::y#2 + (byte) 1 [ main::x#1 main::e#1 main::cursor#1 main::y#1 ] -- zpby1=zpby1_plus_1 
    inc y
  //SEG23 [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::x#1 main::e#1 main::cursor#2 main::y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
    lda cursor
    clc
    adc #$28
    sta cursor
    bcc !+
    inc cursor+$1
  !:
  //SEG24 [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::x#1 main::cursor#2 main::e#2 main::y#1 ] -- xby=xby_minus_coby1 
    txa
    sec
    sbc #$27
    tax
  //SEG25 [10] phi from main::@1 main::@3 to main::@2
  //SEG26 [10] phi (byte) main::y#4 = (byte) main::y#2 -- register_copy 
  //SEG27 [10] phi (byte) main::e#5 = (byte) main::e#1 -- register_copy 
  //SEG28 [10] phi (byte*) main::cursor#5 = (byte*) main::cursor#1 -- register_copy 
  //SEG29 main::@2
  b2:
  //SEG30 [11] if((byte) main::x#1<(byte) 40) goto main::@1 [ main::cursor#5 main::x#1 main::e#5 main::y#4 ] -- zpby1_lt_coby1_then_la1 
    lda x
    cmp #$28
    bcc b1
  //SEG31 main::@return
  //SEG32 [12] return  [ ]
    rts
}

Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 Global ZP labels
//SEG1 @begin
//SEG2 [0] call main param-assignment [ ]
  jsr main
//SEG3 @end
//SEG4 main
main: {
    .label x = 4
    .label cursor = 2
    .label y = 5
  //SEG5 [1] phi from main to main::@1
  //SEG6 [1] phi (byte) main::y#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta y
  //SEG7 [1] phi (byte) main::e#3 = (byte) 12 -- xby=coby1 
    ldx #$c
  //SEG8 [1] phi (byte) main::x#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta x
  //SEG9 [1] phi (byte*) main::cursor#3 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta cursor
    lda #>$400
    sta cursor+$1
  //SEG10 [1] phi from main::@2 to main::@1
  //SEG11 [1] phi (byte) main::y#2 = (byte) main::y#4 -- register_copy 
  //SEG12 [1] phi (byte) main::e#3 = (byte) main::e#5 -- register_copy 
  //SEG13 [1] phi (byte) main::x#2 = (byte) main::x#1 -- register_copy 
  //SEG14 [1] phi (byte*) main::cursor#3 = (byte*) main::cursor#5 -- register_copy 
  //SEG15 main::@1
  b1:
  //SEG16 [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$51
    sta (cursor),y
  //SEG17 [3] (byte) main::x#1 ← (byte) main::x#2 + (byte) 1 [ main::x#1 main::cursor#3 main::e#3 main::y#2 ] -- zpby1=zpby1_plus_1 
    inc x
  //SEG18 [4] (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1 [ main::x#1 main::e#3 main::y#2 main::cursor#1 ] -- zpptrby1=zpptrby1_plus_1 
    inc cursor
    bne !+
    inc cursor+$1
  !:
  //SEG19 [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- xby=xby_plus_coby1 
    txa
    clc
    adc #$18
    tax
  //SEG20 [6] if((byte) 39>=(byte) main::e#1) goto main::@2 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- coby1_ge_xby_then_la1 
    cpx #$27
    bcc b2
  //SEG21 main::@3
  //SEG22 [7] (byte) main::y#1 ← (byte) main::y#2 + (byte) 1 [ main::x#1 main::e#1 main::cursor#1 main::y#1 ] -- zpby1=zpby1_plus_1 
    inc y
  //SEG23 [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::x#1 main::e#1 main::cursor#2 main::y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
    lda cursor
    clc
    adc #$28
    sta cursor
    bcc !+
    inc cursor+$1
  !:
  //SEG24 [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::x#1 main::cursor#2 main::e#2 main::y#1 ] -- xby=xby_minus_coby1 
    txa
    sec
    sbc #$27
    tax
  //SEG25 [10] phi from main::@1 main::@3 to main::@2
  //SEG26 [10] phi (byte) main::y#4 = (byte) main::y#2 -- register_copy 
  //SEG27 [10] phi (byte) main::e#5 = (byte) main::e#1 -- register_copy 
  //SEG28 [10] phi (byte*) main::cursor#5 = (byte*) main::cursor#1 -- register_copy 
  //SEG29 main::@2
  b2:
  //SEG30 [11] if((byte) main::x#1<(byte) 40) goto main::@1 [ main::cursor#5 main::x#1 main::e#5 main::y#4 ] -- zpby1_lt_coby1_then_la1 
    lda x
    cmp #$28
    bcc b1
  //SEG31 main::@return
  //SEG32 [12] return  [ ]
    rts
}

FINAL SYMBOL TABLE
(label) @begin
(label) @end
(byte[1000]) SCREEN
(byte) STAR
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(byte*) main::cursor
(byte*) main::cursor#1 cursor zp ZP_PTR_BYTE:2 8.25
(byte*) main::cursor#2 cursor zp ZP_PTR_BYTE:2 11.0
(byte*) main::cursor#3 cursor zp ZP_PTR_BYTE:2 11.0
(byte*) main::cursor#5 cursor zp ZP_PTR_BYTE:2 16.5
(byte) main::e
(byte) main::e#1 reg byte x 11.0
(byte) main::e#2 reg byte x 22.0
(byte) main::e#3 reg byte x 5.5
(byte) main::e#5 reg byte x 16.5
(byte) main::x
(byte) main::x#1 x zp ZP_BYTE:4 3.666666666666667
(byte) main::x#2 x zp ZP_BYTE:4 11.0
(byte) main::x0
(byte) main::x1
(byte) main::xd
(byte) main::y
(byte) main::y#1 y zp ZP_BYTE:5 7.333333333333333
(byte) main::y#2 y zp ZP_BYTE:5 5.5
(byte) main::y#4 y zp ZP_BYTE:5 16.5
(byte) main::y0
(byte) main::y1
(byte) main::yd

zp ZP_PTR_BYTE:2 [ main::cursor#3 main::cursor#5 main::cursor#1 main::cursor#2 ]
zp ZP_BYTE:4 [ main::x#2 main::x#1 ]
reg byte x [ main::e#3 main::e#5 main::e#1 main::e#2 ]
zp ZP_BYTE:5 [ main::y#2 main::y#4 main::y#1 ]

FINAL CODE
//SEG0 Global ZP labels
//SEG1 @begin
//SEG2 [0] call main param-assignment [ ]
  jsr main
//SEG3 @end
//SEG4 main
main: {
    .label x = 4
    .label cursor = 2
    .label y = 5
  //SEG5 [1] phi from main to main::@1
  //SEG6 [1] phi (byte) main::y#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta y
  //SEG7 [1] phi (byte) main::e#3 = (byte) 12 -- xby=coby1 
    ldx #$c
  //SEG8 [1] phi (byte) main::x#2 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta x
  //SEG9 [1] phi (byte*) main::cursor#3 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta cursor
    lda #>$400
    sta cursor+$1
  //SEG10 [1] phi from main::@2 to main::@1
  //SEG11 [1] phi (byte) main::y#2 = (byte) main::y#4 -- register_copy 
  //SEG12 [1] phi (byte) main::e#3 = (byte) main::e#5 -- register_copy 
  //SEG13 [1] phi (byte) main::x#2 = (byte) main::x#1 -- register_copy 
  //SEG14 [1] phi (byte*) main::cursor#3 = (byte*) main::cursor#5 -- register_copy 
  //SEG15 main::@1
  b1:
  //SEG16 [2] *((byte*) main::cursor#3) ← (byte) 81 [ main::cursor#3 main::x#2 main::e#3 main::y#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$51
    sta (cursor),y
  //SEG17 [3] (byte) main::x#1 ← (byte) main::x#2 + (byte) 1 [ main::x#1 main::cursor#3 main::e#3 main::y#2 ] -- zpby1=zpby1_plus_1 
    inc x
  //SEG18 [4] (byte*) main::cursor#1 ← (byte*) main::cursor#3 + (byte) 1 [ main::x#1 main::e#3 main::y#2 main::cursor#1 ] -- zpptrby1=zpptrby1_plus_1 
    inc cursor
    bne !+
    inc cursor+$1
  !:
  //SEG19 [5] (byte) main::e#1 ← (byte) main::e#3 + (byte) 24 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- xby=xby_plus_coby1 
    txa
    clc
    adc #$18
    tax
  //SEG20 [6] if((byte) 39>=(byte) main::e#1) goto main::@2 [ main::x#1 main::e#1 main::y#2 main::cursor#1 ] -- coby1_ge_xby_then_la1 
    cpx #$27
    bcc b2
  //SEG21 main::@3
  //SEG22 [7] (byte) main::y#1 ← (byte) main::y#2 + (byte) 1 [ main::x#1 main::e#1 main::cursor#1 main::y#1 ] -- zpby1=zpby1_plus_1 
    inc y
  //SEG23 [8] (byte*) main::cursor#2 ← (byte*) main::cursor#1 + (byte) 40 [ main::x#1 main::e#1 main::cursor#2 main::y#1 ] -- zpptrby1=zpptrby1_plus_coby1 
    lda cursor
    clc
    adc #$28
    sta cursor
    bcc !+
    inc cursor+$1
  !:
  //SEG24 [9] (byte) main::e#2 ← (byte) main::e#1 - (byte) 39 [ main::x#1 main::cursor#2 main::e#2 main::y#1 ] -- xby=xby_minus_coby1 
    txa
    sec
    sbc #$27
    tax
  //SEG25 [10] phi from main::@1 main::@3 to main::@2
  //SEG26 [10] phi (byte) main::y#4 = (byte) main::y#2 -- register_copy 
  //SEG27 [10] phi (byte) main::e#5 = (byte) main::e#1 -- register_copy 
  //SEG28 [10] phi (byte*) main::cursor#5 = (byte*) main::cursor#1 -- register_copy 
  //SEG29 main::@2
  b2:
  //SEG30 [11] if((byte) main::x#1<(byte) 40) goto main::@1 [ main::cursor#5 main::x#1 main::e#5 main::y#4 ] -- zpby1_lt_coby1_then_la1 
    lda x
    cmp #$28
    bcc b1
  //SEG31 main::@return
  //SEG32 [12] return  [ ]
    rts
}

