Inlined call call __init

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  y#13 = phi( __start::@1/y#12 )
  idx#12 = phi( __start::@1/idx#11 )
  row#13 = phi( __start::@1/row#12 )
  x#14 = phi( __start::@1/x#13 )
  line#0 = 0
  to:main::@1
main::@1: scope:[main]  from main main::@5
  y#11 = phi( main/y#13, main::@5/y#0 )
  idx#10 = phi( main/idx#12, main::@5/idx#13 )
  row#11 = phi( main/row#13, main::@5/row#14 )
  x#11 = phi( main/x#14, main::@5/x#15 )
  line#6 = phi( main/line#0, main::@5/line#1 )
  main::$0 = line#6 < 8
  if(main::$0) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  line#13 = phi( main::@1/line#6 )
  y#14 = phi( main::@1/y#11 )
  idx#14 = phi( main::@1/idx#10 )
  x#6 = phi( main::@1/x#11 )
  x#0 = ++ x#6
  row#0 = 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  line#11 = phi( main::@2/line#13, main::@4/line#14 )
  x#12 = phi( main::@2/x#0, main::@4/x#1 )
  y#10 = phi( main::@2/y#14, main::@4/y#5 )
  idx#9 = phi( main::@2/idx#14, main::@4/idx#0 )
  row#6 = phi( main::@2/row#0, main::@4/row#1 )
  main::$1 = row#6 < 8
  if(main::$1) goto main::@4
  to:main::@5
main::@4: scope:[main]  from main::@3
  line#14 = phi( main::@3/line#11 )
  row#7 = phi( main::@3/row#6 )
  x#7 = phi( main::@3/x#12 )
  y#5 = phi( main::@3/y#10 )
  idx#5 = phi( main::@3/idx#9 )
  main::$2 = idx#5 * SIZEOF_STRUCT_POS
  ((char *)p+OFFSET_STRUCT_POS_Y)[main::$2] = y#5
  main::$3 = idx#5 * SIZEOF_STRUCT_POS
  ((char *)p+OFFSET_STRUCT_POS_X)[main::$3] = x#7
  idx#0 = ++ idx#5
  x#1 = x#7 + XSPACE
  row#1 = ++ row#7
  to:main::@3
main::@5: scope:[main]  from main::@3
  idx#13 = phi( main::@3/idx#9 )
  row#14 = phi( main::@3/row#6 )
  x#15 = phi( main::@3/x#12 )
  line#7 = phi( main::@3/line#11 )
  y#6 = phi( main::@3/y#10 )
  y#0 = y#6 + YSPACE
  line#1 = ++ line#7
  to:main::@1
main::@return: scope:[main]  from main::@1
  y#7 = phi( main::@1/y#11 )
  idx#6 = phi( main::@1/idx#10 )
  row#8 = phi( main::@1/row#11 )
  x#8 = phi( main::@1/x#11 )
  line#8 = phi( main::@1/line#6 )
  line#2 = line#8
  x#2 = x#8
  row#2 = row#8
  idx#1 = idx#6
  y#1 = y#7
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  idx#2 = 0
  line#3 = 0
  row#3 = 0
  x#3 = 0
  y#2 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  y#12 = phi( __start::__init1/y#2 )
  idx#11 = phi( __start::__init1/idx#2 )
  row#12 = phi( __start::__init1/row#3 )
  x#13 = phi( __start::__init1/x#3 )
  line#12 = phi( __start::__init1/line#3 )
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  y#8 = phi( __start::@1/y#1 )
  idx#7 = phi( __start::@1/idx#1 )
  row#9 = phi( __start::@1/row#2 )
  x#9 = phi( __start::@1/x#2 )
  line#9 = phi( __start::@1/line#2 )
  line#4 = line#9
  x#4 = x#9
  row#4 = row#9
  idx#3 = idx#7
  y#3 = y#8
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  y#9 = phi( __start::@2/y#3 )
  x#10 = phi( __start::@2/x#4 )
  row#10 = phi( __start::@2/row#4 )
  line#10 = phi( __start::@2/line#4 )
  idx#8 = phi( __start::@2/idx#3 )
  idx#4 = idx#8
  line#5 = line#10
  row#5 = row#10
  x#5 = x#10
  y#4 = y#9
  return 
  to:@return

SYMBOL TABLE SSA
__constant char OFFSET_STRUCT_POS_X = 0
__constant char OFFSET_STRUCT_POS_Y = 1
__constant char SIZEOF_STRUCT_POS = 2
__constant char XSPACE = $14
__constant char YSPACE = $14
void __start()
char idx
char idx#0
char idx#1
char idx#10
char idx#11
char idx#12
char idx#13
char idx#14
char idx#2
char idx#3
char idx#4
char idx#5
char idx#6
char idx#7
char idx#8
char idx#9
char line
char line#0
char line#1
char line#10
char line#11
char line#12
char line#13
char line#14
char line#2
char line#3
char line#4
char line#5
char line#6
char line#7
char line#8
char line#9
void main()
bool main::$0
bool main::$1
char main::$2
char main::$3
__constant struct pos p[$40] = { fill( $40, 0) }
char row
char row#0
char row#1
char row#10
char row#11
char row#12
char row#13
char row#14
char row#2
char row#3
char row#4
char row#5
char row#6
char row#7
char row#8
char row#9
char x
char x#0
char x#1
char x#10
char x#11
char x#12
char x#13
char x#14
char x#15
char x#2
char x#3
char x#4
char x#5
char x#6
char x#7
char x#8
char x#9
char y
char y#0
char y#1
char y#10
char y#11
char y#12
char y#13
char y#14
char y#2
char y#3
char y#4
char y#5
char y#6
char y#7
char y#8
char y#9

Adding number conversion cast (unumber) 0 in line#0 = 0
Adding number conversion cast (unumber) 8 in main::$0 = line#6 < 8
Adding number conversion cast (unumber) 0 in row#0 = 0
Adding number conversion cast (unumber) 8 in main::$1 = row#6 < 8
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast line#0 = (unumber)0
Inlining cast row#0 = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast 0
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias x#11 = x#6 x#8 x#2 
Alias idx#1 = idx#14 idx#10 idx#6 
Alias y#1 = y#14 y#11 y#7 
Alias line#13 = line#6 line#8 line#2 
Alias idx#13 = idx#5 idx#9 
Alias y#10 = y#5 y#6 
Alias x#12 = x#7 x#15 
Alias row#14 = row#7 row#6 
Alias line#11 = line#14 line#7 
Alias row#11 = row#8 row#2 
Alias line#12 = line#3 
Alias x#13 = x#3 
Alias row#12 = row#3 
Alias idx#11 = idx#2 
Alias y#12 = y#2 
Alias line#10 = line#4 line#9 line#5 
Alias x#10 = x#4 x#9 x#5 
Alias row#10 = row#4 row#9 row#5 
Alias idx#3 = idx#7 idx#8 idx#4 
Alias y#3 = y#8 y#9 y#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values x#14 x#13
Identical Phi Values row#13 row#12
Identical Phi Values idx#12 idx#11
Identical Phi Values y#13 y#12
Identical Phi Values y#10 y#1
Identical Phi Values line#11 line#13
Identical Phi Values line#10 line#13
Identical Phi Values x#10 x#11
Identical Phi Values row#10 row#11
Identical Phi Values idx#3 idx#1
Identical Phi Values y#3 y#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [14] main::$3 = idx#13 * SIZEOF_STRUCT_POS
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition main::$0 [4] if(line#13<8) goto main::@2
Simple Condition main::$1 [9] if(row#14<8) goto main::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant line#0 = 0
Constant row#0 = 0
Constant idx#11 = 0
Constant line#12 = 0
Constant row#12 = 0
Constant x#13 = 0
Constant y#12 = 0
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero (char *)p in [13] ((char *)p+OFFSET_STRUCT_POS_X)[main::$3] = x#12
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable - keeping the phi block row#11
Eliminating unused constant OFFSET_STRUCT_POS_X
Eliminating unused constant line#12
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant row#12
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Alias main::$3 = main::$2 
Successful SSA optimization Pass2AliasElimination
Rewriting multiplication to use shift [5] main::$3 = idx#13 * SIZEOF_STRUCT_POS
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings line#0
Inlining constant with var siblings row#0
Inlining constant with var siblings idx#11
Inlining constant with var siblings x#13
Inlining constant with var siblings y#12
Constant inlined x#13 = 0
Constant inlined idx#11 = 0
Constant inlined y#12 = 0
Constant inlined row#0 = 0
Constant inlined line#0 = 0
Successful SSA optimization Pass2ConstantInlining
Eliminating unused constant SIZEOF_STRUCT_POS
Successful SSA optimization PassNEliminateUnusedVars
Finalized unsigned number type (char) $40
Finalized unsigned number type (char) $40
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main
CALL GRAPH

Created 7 initial phi equivalence classes
Coalesced [5] idx#16 = idx#1
Coalesced [6] x#17 = x#0
Coalesced [11] line#15 = line#1
Coalesced [12] x#16 = x#12
Coalesced (already) [13] idx#15 = idx#13
Coalesced [14] y#15 = y#0
Coalesced [21] row#15 = row#1
Coalesced [22] idx#17 = idx#0
Coalesced [23] x#18 = x#1
Coalesced down to 5 phi equivalence classes
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [1] y#1 = phi( main/0, main::@5/y#0 )
  [1] idx#1 = phi( main/0, main::@5/idx#13 )
  [1] x#11 = phi( main/0, main::@5/x#12 )
  [1] line#13 = phi( main/0, main::@5/line#1 )
  [2] if(line#13<8) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@1
  [3] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [4] x#0 = ++ x#11
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  [5] x#12 = phi( main::@2/x#0, main::@4/x#1 )
  [5] idx#13 = phi( main::@2/idx#1, main::@4/idx#0 )
  [5] row#14 = phi( main::@2/0, main::@4/row#1 )
  [6] if(row#14<8) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@3
  [7] y#0 = y#1 + YSPACE
  [8] line#1 = ++ line#13
  to:main::@1
main::@4: scope:[main]  from main::@3
  [9] main::$3 = idx#13 << 1
  [10] ((char *)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1
  [11] ((char *)p)[main::$3] = x#12
  [12] idx#0 = ++ idx#13
  [13] x#1 = x#12 + XSPACE
  [14] row#1 = ++ row#14
  to:main::@3


VARIABLE REGISTER WEIGHTS
char idx
char idx#0 // 67.33333333333333
char idx#1 // 7.333333333333333
char idx#13 // 46.42857142857143
char line
char line#1 // 22.0
char line#13 // 2.75
void main()
char main::$3 // 151.5
char row
char row#1 // 202.0
char row#14 // 43.285714285714285
char x
char x#0 // 22.0
char x#1 // 101.0
char x#11 // 11.0
char x#12 // 40.625
char y
char y#0 // 11.0
char y#1 // 11.181818181818182

Initial phi equivalence classes
[ line#13 line#1 ]
[ x#11 x#12 x#0 x#1 ]
[ idx#1 idx#13 idx#0 ]
[ y#1 y#0 ]
[ row#14 row#1 ]
Added variable main::$3 to live range equivalence class [ main::$3 ]
Complete equivalence classes
[ line#13 line#1 ]
[ x#11 x#12 x#0 x#1 ]
[ idx#1 idx#13 idx#0 ]
[ y#1 y#0 ]
[ row#14 row#1 ]
[ main::$3 ]
Allocated zp[1]:2 [ row#14 row#1 ]
Allocated zp[1]:3 [ x#11 x#12 x#0 x#1 ]
Allocated zp[1]:4 [ main::$3 ]
Allocated zp[1]:5 [ idx#1 idx#13 idx#0 ]
Allocated zp[1]:6 [ line#13 line#1 ]
Allocated zp[1]:7 [ y#1 y#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [7] y#0 = y#1 + YSPACE [ line#13 x#12 idx#13 y#0 ] (  [ line#13 x#12 idx#13 y#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:6 [ line#13 line#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ x#11 x#12 x#0 x#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:5 [ idx#1 idx#13 idx#0 ]
Statement [9] main::$3 = idx#13 << 1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:7 [ y#1 y#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:2 [ row#14 row#1 ]
Statement [10] ((char *)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ main::$3 ]
Statement [11] ((char *)p)[main::$3] = x#12 [ line#13 y#1 x#12 idx#13 row#14 ] (  [ line#13 y#1 x#12 idx#13 row#14 ] { }  ) always clobbers reg byte a 
Statement [13] x#1 = x#12 + XSPACE [ line#13 y#1 row#14 idx#0 x#1 ] (  [ line#13 y#1 row#14 idx#0 x#1 ] { }  ) always clobbers reg byte a 
Statement [7] y#0 = y#1 + YSPACE [ line#13 x#12 idx#13 y#0 ] (  [ line#13 x#12 idx#13 y#0 ] { }  ) always clobbers reg byte a 
Statement [9] main::$3 = idx#13 << 1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Statement [10] ((char *)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Statement [11] ((char *)p)[main::$3] = x#12 [ line#13 y#1 x#12 idx#13 row#14 ] (  [ line#13 y#1 x#12 idx#13 row#14 ] { }  ) always clobbers reg byte a 
Statement [13] x#1 = x#12 + XSPACE [ line#13 y#1 row#14 idx#0 x#1 ] (  [ line#13 y#1 row#14 idx#0 x#1 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:6 [ line#13 line#1 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ x#11 x#12 x#0 x#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ idx#1 idx#13 idx#0 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ y#1 y#0 ] : zp[1]:7 , reg byte x , reg byte y , 
Potential registers zp[1]:2 [ row#14 row#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ main::$3 ] : zp[1]:4 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 245.29: zp[1]:2 [ row#14 row#1 ] 174.62: zp[1]:3 [ x#11 x#12 x#0 x#1 ] 121.1: zp[1]:5 [ idx#1 idx#13 idx#0 ] 24.75: zp[1]:6 [ line#13 line#1 ] 22.18: zp[1]:7 [ y#1 y#0 ] 
Uplift Scope [main] 151.5: zp[1]:4 [ main::$3 ] 
Uplift Scope [pos] 

Uplifting [] best 7501 combination zp[1]:2 [ row#14 row#1 ] zp[1]:3 [ x#11 x#12 x#0 x#1 ] zp[1]:5 [ idx#1 idx#13 idx#0 ] zp[1]:6 [ line#13 line#1 ] zp[1]:7 [ y#1 y#0 ] 
Limited combination testing to 100 combinations of 243 possible.
Uplifting [main] best 6801 combination reg byte x [ main::$3 ] 
Uplifting [pos] best 6801 combination 
Attempting to uplift remaining variables inzp[1]:2 [ row#14 row#1 ]
Uplifting [] best 5901 combination reg byte y [ row#14 row#1 ] 
Attempting to uplift remaining variables inzp[1]:3 [ x#11 x#12 x#0 x#1 ]
Uplifting [] best 5901 combination zp[1]:3 [ x#11 x#12 x#0 x#1 ] 
Attempting to uplift remaining variables inzp[1]:5 [ idx#1 idx#13 idx#0 ]
Uplifting [] best 5901 combination zp[1]:5 [ idx#1 idx#13 idx#0 ] 
Attempting to uplift remaining variables inzp[1]:6 [ line#13 line#1 ]
Uplifting [] best 5901 combination zp[1]:6 [ line#13 line#1 ] 
Attempting to uplift remaining variables inzp[1]:7 [ y#1 y#0 ]
Uplifting [] best 5901 combination zp[1]:7 [ y#1 y#0 ] 
Allocated (was zp[1]:3) zp[1]:2 [ x#11 x#12 x#0 x#1 ]
Allocated (was zp[1]:5) zp[1]:3 [ idx#1 idx#13 idx#0 ]
Allocated (was zp[1]:6) zp[1]:4 [ line#13 line#1 ]
Allocated (was zp[1]:7) zp[1]:5 [ y#1 y#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Example of structs that can be optimized by going planar
// https://cc65.github.io/mailarchive/2010-09/8593.html?fbclid=IwAR1IF_cTdyWcFeKU93VfL2Un1EuLjkGh7O7dQ4EVj4kpJzJAj01dbmEFQt8
  // Upstart
  // Commodore 64 PRG executable file
.file [name="struct-pos-fill.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const OFFSET_STRUCT_POS_Y = 1
  .const XSPACE = $14
  .const YSPACE = $14
  .label x = 2
  .label idx = 3
  .label y = 5
  .label line = 4
.segment Code
  // main
main: {
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi y#1 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [1] phi idx#1 = 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [1] phi x#11 = 0 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    // [1] phi line#13 = 0 [phi:main->main::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z line
    jmp __b1
    // main::@1
  __b1:
    // [2] if(line#13<8) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z line
    cmp #8
    bcc __b2
    jmp __breturn
    // main::@return
  __breturn:
    // [3] return 
    rts
    // main::@2
  __b2:
    // [4] x#0 = ++ x#11 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [5] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [5] phi x#12 = x#0 [phi:main::@2->main::@3#0] -- register_copy 
    // [5] phi idx#13 = idx#1 [phi:main::@2->main::@3#1] -- register_copy 
    // [5] phi row#14 = 0 [phi:main::@2->main::@3#2] -- vbuyy=vbuc1 
    ldy #0
    jmp __b3
    // main::@3
  __b3:
    // [6] if(row#14<8) goto main::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #8
    bcc __b4
    jmp __b5
    // main::@5
  __b5:
    // [7] y#0 = y#1 + YSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z y
    axs #-[YSPACE]
    stx.z y
    // [8] line#1 = ++ line#13 -- vbuz1=_inc_vbuz1 
    inc.z line
    // [1] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  __b1_from___b5:
    // [1] phi y#1 = y#0 [phi:main::@5->main::@1#0] -- register_copy 
    // [1] phi idx#1 = idx#13 [phi:main::@5->main::@1#1] -- register_copy 
    // [1] phi x#11 = x#12 [phi:main::@5->main::@1#2] -- register_copy 
    // [1] phi line#13 = line#1 [phi:main::@5->main::@1#3] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // [9] main::$3 = idx#13 << 1 -- vbuxx=vbuz1_rol_1 
    lda.z idx
    asl
    tax
    // [10] ((char *)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z y
    sta p+OFFSET_STRUCT_POS_Y,x
    // [11] ((char *)p)[main::$3] = x#12 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z x
    sta p,x
    // [12] idx#0 = ++ idx#13 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // [13] x#1 = x#12 + XSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z x
    axs #-[XSPACE]
    stx.z x
    // [14] row#1 = ++ row#14 -- vbuyy=_inc_vbuyy 
    iny
    // [5] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [5] phi x#12 = x#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [5] phi idx#13 = idx#0 [phi:main::@4->main::@3#1] -- register_copy 
    // [5] phi row#14 = row#1 [phi:main::@4->main::@3#2] -- register_copy 
    jmp __b3
}
  // File Data
.segment Data
  p: .fill 2*$40, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b5
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b1_from_main:
Removing instruction __breturn:
Removing instruction __b3_from___b2:
Removing instruction __b5:
Removing instruction __b1_from___b5:
Removing instruction __b3_from___b4:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
__constant char OFFSET_STRUCT_POS_Y = 1
__constant char XSPACE = $14
__constant char YSPACE = $14
char idx
char idx#0 // idx zp[1]:3 67.33333333333333
char idx#1 // idx zp[1]:3 7.333333333333333
char idx#13 // idx zp[1]:3 46.42857142857143
char line
char line#1 // line zp[1]:4 22.0
char line#13 // line zp[1]:4 2.75
void main()
char main::$3 // reg byte x 151.5
__constant struct pos p[$40] = { fill( $40, 0) }
char row
char row#1 // reg byte y 202.0
char row#14 // reg byte y 43.285714285714285
char x
char x#0 // x zp[1]:2 22.0
char x#1 // x zp[1]:2 101.0
char x#11 // x zp[1]:2 11.0
char x#12 // x zp[1]:2 40.625
char y
char y#0 // y zp[1]:5 11.0
char y#1 // y zp[1]:5 11.181818181818182

zp[1]:4 [ line#13 line#1 ]
zp[1]:2 [ x#11 x#12 x#0 x#1 ]
zp[1]:3 [ idx#1 idx#13 idx#0 ]
zp[1]:5 [ y#1 y#0 ]
reg byte y [ row#14 row#1 ]
reg byte x [ main::$3 ]


FINAL ASSEMBLER
Score: 5181

  // File Comments
// Example of structs that can be optimized by going planar
// https://cc65.github.io/mailarchive/2010-09/8593.html?fbclid=IwAR1IF_cTdyWcFeKU93VfL2Un1EuLjkGh7O7dQ4EVj4kpJzJAj01dbmEFQt8
  // Upstart
  // Commodore 64 PRG executable file
.file [name="struct-pos-fill.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const OFFSET_STRUCT_POS_Y = 1
  .const XSPACE = $14
  .const YSPACE = $14
  .label x = 2
  .label idx = 3
  .label y = 5
  .label line = 4
.segment Code
  // main
main: {
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi y#1 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [1] phi idx#1 = 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    sta.z idx
    // [1] phi x#11 = 0 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    sta.z x
    // [1] phi line#13 = 0 [phi:main->main::@1#3] -- vbuz1=vbuc1 
    sta.z line
    // main::@1
  __b1:
    // for (line=0;line<8;++line)
    // [2] if(line#13<8) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z line
    cmp #8
    bcc __b2
    // main::@return
    // }
    // [3] return 
    rts
    // main::@2
  __b2:
    // ++x;
    // [4] x#0 = ++ x#11 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [5] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // [5] phi x#12 = x#0 [phi:main::@2->main::@3#0] -- register_copy 
    // [5] phi idx#13 = idx#1 [phi:main::@2->main::@3#1] -- register_copy 
    // [5] phi row#14 = 0 [phi:main::@2->main::@3#2] -- vbuyy=vbuc1 
    ldy #0
    // main::@3
  __b3:
    // for (row=0;row<8;++row)
    // [6] if(row#14<8) goto main::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #8
    bcc __b4
    // main::@5
    // y+=YSPACE
    // [7] y#0 = y#1 + YSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z y
    axs #-[YSPACE]
    stx.z y
    // for (line=0;line<8;++line)
    // [8] line#1 = ++ line#13 -- vbuz1=_inc_vbuz1 
    inc.z line
    // [1] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
    // [1] phi y#1 = y#0 [phi:main::@5->main::@1#0] -- register_copy 
    // [1] phi idx#1 = idx#13 [phi:main::@5->main::@1#1] -- register_copy 
    // [1] phi x#11 = x#12 [phi:main::@5->main::@1#2] -- register_copy 
    // [1] phi line#13 = line#1 [phi:main::@5->main::@1#3] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // p[idx].y=y
    // [9] main::$3 = idx#13 << 1 -- vbuxx=vbuz1_rol_1 
    lda.z idx
    asl
    tax
    // [10] ((char *)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z y
    sta p+OFFSET_STRUCT_POS_Y,x
    // p[idx].x=x
    // [11] ((char *)p)[main::$3] = x#12 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z x
    sta p,x
    // ++idx;
    // [12] idx#0 = ++ idx#13 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // x+=XSPACE
    // [13] x#1 = x#12 + XSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z x
    axs #-[XSPACE]
    stx.z x
    // for (row=0;row<8;++row)
    // [14] row#1 = ++ row#14 -- vbuyy=_inc_vbuyy 
    iny
    // [5] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
    // [5] phi x#12 = x#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [5] phi idx#13 = idx#0 [phi:main::@4->main::@3#1] -- register_copy 
    // [5] phi row#14 = row#1 [phi:main::@4->main::@3#2] -- register_copy 
    jmp __b3
}
  // File Data
.segment Data
  p: .fill 2*$40, 0

