byte* COLS = $d800;
byte* BGCOL = $d020;
byte* FGCOL = $d021;
byte* SCROLL = $d016;
byte* D018 = $d018;

byte* D011 = $d011;
byte RST8 = %10000000;
byte ECM =  %01000000;
byte BMM =  %00100000;
byte DEN =  %00010000;
byte RSEL =  %00001000;

byte* D016 = $d016;
byte MCM =  %00010000;
byte CSEL = %00001000;

byte* SCREEN = $400;
const byte* BITMAP = $2000;

byte[] plot_xlo = $1000;
byte[] plot_xhi = $1100;
byte[] plot_ylo = $1200;
byte[] plot_yhi = $1300;
byte[] plot_bit = $1400;

void main() {
    *BGCOL = 0;
    *FGCOL = 0;
    *D011 = BMM|DEN|RSEL|3;
    *D018 = $18; // Needs casting for *D018 = ((word)SCREEN/$40)|((word)BITMAP/$400);
    initscreen();
    initplottables();
    // TODO: Error with constant identification of the parameters!
    line(0,0,20,10);
    line(10,20,40,40);
}

void line(byte x0, byte y0, byte x1, byte y1) {
  byte xd = x1-x0;
  byte yd = y1-y0;
  byte x = x0;
  byte y = y0;
  byte e = yd>>1;
  do  {
      plot(x,y);
      // TODO: Ensure coalescing of plotter#0 and plotter#1 into a single live range equivalence class.
      x = x + 1;
      e = e+yd;
      if(xd<e) {
          y = y+1;
          e = e - xd;
      }
  } while (x<(x1+1))
}

void initscreen() {
    for(byte* b = BITMAP; b!=BITMAP+$2000; b++) {
        *b = 0;
    }
    for(byte* c = SCREEN; c!=SCREEN+$400;c++) {
        *c = $14;
    }
}


void initplottables() {
    byte bit = $80;
    for(byte x : 0..255) {
        plot_xlo[x] = x&$f8;
        plot_xhi[x] = >BITMAP;
        plot_bit[x] = bit;
        bit = bit>>1;
        if(bit==0) {
          bit = $80;
        }
    }
    byte* yoffs = $0;
    for(byte y : 0..255) {
        plot_ylo[y] = y&$7 | <yoffs;
        plot_yhi[y] = >yoffs;
        if((y&$7)==7) {
            yoffs = yoffs + 320; // Needs better constant type inference for yoffs = yoffs + 40*8;
        }
    }
}



void plot(byte x, byte y) {
    // TODO: This assignment is needed - to avoid plotter var being destroyed during compilation. Find a way to eliminate it.
    byte* plotter = BITMAP;
    <plotter = plot_xlo[x]+plot_ylo[y];
    >plotter = plot_xhi[x]+plot_yhi[y];
    // TODO: <plotter can overflow - and carry must then be added to the >plotter part. Requires new logic?
    *plotter = *plotter | plot_bit[x];
}

main();
