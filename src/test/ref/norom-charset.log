Inlined call call _init 

CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from _start::@1
  (byte*~) main::$0 ← (const byte*) CHARSET + (number) 8
  (byte*) main::charset#0 ← (byte*~) main::$0
  (byte) main::c#0 ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main main::@4
  (byte*) main::charset#4 ← phi( main/(byte*) main::charset#0 main::@4/(byte*) main::charset#1 )
  (byte) main::c#2 ← phi( main/(byte) main::c#0 main::@4/(byte) main::c#1 )
  (bool~) main::$4 ← (byte) main::c#2 != (number) 4
  if((bool~) main::$4) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  (byte*) main::charset#2 ← phi( main::@1/(byte*) main::charset#4 )
  (byte) main::c#3 ← phi( main::@1/(byte) main::c#2 )
  (byte~) main::$7 ← (byte) main::c#3 * (const byte) SIZEOF_WORD
  (byte*) gen_char3::dst#0 ← (byte*) main::charset#2
  (word) gen_char3::spec#0 ← *((const word*) charset_spec_row + (byte~) main::$7)
  call gen_char3 
  to:main::@4
main::@4: scope:[main]  from main::@2
  (byte) main::c#4 ← phi( main::@2/(byte) main::c#3 )
  (byte*) main::charset#3 ← phi( main::@2/(byte*) main::charset#2 )
  (byte*~) main::$6 ← (byte*) main::charset#3 + (number) 8
  (byte*) main::charset#1 ← (byte*~) main::$6
  (byte) main::c#1 ← ++ (byte) main::c#4
  to:main::@1
main::@3: scope:[main]  from main::@1
  (word~) main::$8 ← (word)(const byte*) SCREEN
  (number~) main::$1 ← (word~) main::$8 / (number) $40
  (word~) main::$9 ← (word)(const byte*) CHARSET
  (number~) main::$2 ← (word~) main::$9 / (number) $400
  (number~) main::$3 ← (number~) main::$1 | (number~) main::$2
  *((const byte*) VIC_MEMORY) ← (byte)(number~) main::$3
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return

(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
gen_char3: scope:[gen_char3]  from main::@2
  (byte*) gen_char3::dst#6 ← phi( main::@2/(byte*) gen_char3::dst#0 )
  (word) gen_char3::spec#6 ← phi( main::@2/(word) gen_char3::spec#0 )
  (byte) gen_char3::r#0 ← (byte) 0
  to:gen_char3::@1
gen_char3::@1: scope:[gen_char3]  from gen_char3 gen_char3::@5
  (byte) gen_char3::r#6 ← phi( gen_char3/(byte) gen_char3::r#0 gen_char3::@5/(byte) gen_char3::r#1 )
  (byte*) gen_char3::dst#5 ← phi( gen_char3/(byte*) gen_char3::dst#6 gen_char3::@5/(byte*) gen_char3::dst#1 )
  (word) gen_char3::spec#4 ← phi( gen_char3/(word) gen_char3::spec#6 gen_char3::@5/(word) gen_char3::spec#7 )
  (byte) gen_char3::b#0 ← (byte) 0
  (byte) gen_char3::c#0 ← (byte) 0
  to:gen_char3::@2
gen_char3::@2: scope:[gen_char3]  from gen_char3::@1 gen_char3::@3
  (byte) gen_char3::r#4 ← phi( gen_char3::@1/(byte) gen_char3::r#6 gen_char3::@3/(byte) gen_char3::r#3 )
  (byte*) gen_char3::dst#3 ← phi( gen_char3::@1/(byte*) gen_char3::dst#5 gen_char3::@3/(byte*) gen_char3::dst#2 )
  (byte) gen_char3::c#3 ← phi( gen_char3::@1/(byte) gen_char3::c#0 gen_char3::@3/(byte) gen_char3::c#1 )
  (byte) gen_char3::b#6 ← phi( gen_char3::@1/(byte) gen_char3::b#0 gen_char3::@3/(byte) gen_char3::b#1 )
  (word) gen_char3::spec#2 ← phi( gen_char3::@1/(word) gen_char3::spec#4 gen_char3::@3/(word) gen_char3::spec#1 )
  (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2
  (number~) gen_char3::$1 ← (byte~) gen_char3::$0 & (number) $80
  (bool~) gen_char3::$2 ← (number~) gen_char3::$1 != (number) 0
  (bool~) gen_char3::$3 ← ! (bool~) gen_char3::$2
  if((bool~) gen_char3::$3) goto gen_char3::@3
  to:gen_char3::@4
gen_char3::@3: scope:[gen_char3]  from gen_char3::@2 gen_char3::@4
  (byte) gen_char3::r#3 ← phi( gen_char3::@2/(byte) gen_char3::r#4 gen_char3::@4/(byte) gen_char3::r#5 )
  (byte*) gen_char3::dst#2 ← phi( gen_char3::@2/(byte*) gen_char3::dst#3 gen_char3::@4/(byte*) gen_char3::dst#4 )
  (byte) gen_char3::c#2 ← phi( gen_char3::@2/(byte) gen_char3::c#3 gen_char3::@4/(byte) gen_char3::c#4 )
  (word) gen_char3::spec#3 ← phi( gen_char3::@2/(word) gen_char3::spec#2 gen_char3::@4/(word) gen_char3::spec#5 )
  (byte) gen_char3::b#3 ← phi( gen_char3::@2/(byte) gen_char3::b#6 gen_char3::@4/(byte) gen_char3::b#2 )
  (number~) gen_char3::$5 ← (byte) gen_char3::b#3 * (number) 2
  (byte) gen_char3::b#1 ← (number~) gen_char3::$5
  (number~) gen_char3::$6 ← (word) gen_char3::spec#3 * (number) 2
  (word) gen_char3::spec#1 ← (number~) gen_char3::$6
  (byte) gen_char3::c#1 ← (byte) gen_char3::c#2 + rangenext(0,2)
  (bool~) gen_char3::$7 ← (byte) gen_char3::c#1 != rangelast(0,2)
  if((bool~) gen_char3::$7) goto gen_char3::@2
  to:gen_char3::@5
gen_char3::@4: scope:[gen_char3]  from gen_char3::@2
  (byte) gen_char3::r#5 ← phi( gen_char3::@2/(byte) gen_char3::r#4 )
  (byte*) gen_char3::dst#4 ← phi( gen_char3::@2/(byte*) gen_char3::dst#3 )
  (byte) gen_char3::c#4 ← phi( gen_char3::@2/(byte) gen_char3::c#3 )
  (word) gen_char3::spec#5 ← phi( gen_char3::@2/(word) gen_char3::spec#2 )
  (byte) gen_char3::b#4 ← phi( gen_char3::@2/(byte) gen_char3::b#6 )
  (number~) gen_char3::$4 ← (byte) gen_char3::b#4 | (number) 1
  (byte) gen_char3::b#2 ← (number~) gen_char3::$4
  to:gen_char3::@3
gen_char3::@5: scope:[gen_char3]  from gen_char3::@3
  (word) gen_char3::spec#7 ← phi( gen_char3::@3/(word) gen_char3::spec#1 )
  (byte) gen_char3::r#2 ← phi( gen_char3::@3/(byte) gen_char3::r#3 )
  (byte*) gen_char3::dst#1 ← phi( gen_char3::@3/(byte*) gen_char3::dst#2 )
  (byte) gen_char3::b#5 ← phi( gen_char3::@3/(byte) gen_char3::b#1 )
  *((byte*) gen_char3::dst#1 + (byte) gen_char3::r#2) ← (byte) gen_char3::b#5
  (byte) gen_char3::r#1 ← (byte) gen_char3::r#2 + rangenext(0,4)
  (bool~) gen_char3::$8 ← (byte) gen_char3::r#1 != rangelast(0,4)
  if((bool~) gen_char3::$8) goto gen_char3::@1
  to:gen_char3::@return
gen_char3::@return: scope:[gen_char3]  from gen_char3::@5
  return 
  to:@return

(void()) _start()
_start: scope:[_start]  from
  to:_start::_init1
_start::_init1: scope:[_start]  from _start
  to:_start::@1
_start::@1: scope:[_start]  from _start::_init1
  call main 
  to:_start::@2
_start::@2: scope:[_start]  from _start::@1
  to:_start::@return
_start::@return: scope:[_start]  from _start::@2
  return 
  to:@return

SYMBOL TABLE SSA
(const byte*) CHARSET = (byte*)(number) $3000
(const byte*) SCREEN = (byte*)(number) $400
(const byte) SIZEOF_WORD = (byte) 2
(const byte*) VIC_MEMORY = (byte*)(number) $d018
(void()) _start()
(label) _start::@1
(label) _start::@2
(label) _start::@return
(label) _start::_init1
(const word*) charset_spec_row[]  = { (word) $f7da, (word) $f7de, (word) $f24e, (word) $d6de }
(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
(byte~) gen_char3::$0
(number~) gen_char3::$1
(bool~) gen_char3::$2
(bool~) gen_char3::$3
(number~) gen_char3::$4
(number~) gen_char3::$5
(number~) gen_char3::$6
(bool~) gen_char3::$7
(bool~) gen_char3::$8
(label) gen_char3::@1
(label) gen_char3::@2
(label) gen_char3::@3
(label) gen_char3::@4
(label) gen_char3::@5
(label) gen_char3::@return
(byte) gen_char3::b
(byte) gen_char3::b#0
(byte) gen_char3::b#1
(byte) gen_char3::b#2
(byte) gen_char3::b#3
(byte) gen_char3::b#4
(byte) gen_char3::b#5
(byte) gen_char3::b#6
(byte) gen_char3::c
(byte) gen_char3::c#0
(byte) gen_char3::c#1
(byte) gen_char3::c#2
(byte) gen_char3::c#3
(byte) gen_char3::c#4
(byte*) gen_char3::dst
(byte*) gen_char3::dst#0
(byte*) gen_char3::dst#1
(byte*) gen_char3::dst#2
(byte*) gen_char3::dst#3
(byte*) gen_char3::dst#4
(byte*) gen_char3::dst#5
(byte*) gen_char3::dst#6
(byte) gen_char3::r
(byte) gen_char3::r#0
(byte) gen_char3::r#1
(byte) gen_char3::r#2
(byte) gen_char3::r#3
(byte) gen_char3::r#4
(byte) gen_char3::r#5
(byte) gen_char3::r#6
(word) gen_char3::spec
(word) gen_char3::spec#0
(word) gen_char3::spec#1
(word) gen_char3::spec#2
(word) gen_char3::spec#3
(word) gen_char3::spec#4
(word) gen_char3::spec#5
(word) gen_char3::spec#6
(word) gen_char3::spec#7
(void()) main()
(byte*~) main::$0
(number~) main::$1
(number~) main::$2
(number~) main::$3
(bool~) main::$4
(byte*~) main::$6
(byte~) main::$7
(word~) main::$8
(word~) main::$9
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return
(byte) main::c
(byte) main::c#0
(byte) main::c#1
(byte) main::c#2
(byte) main::c#3
(byte) main::c#4
(byte*) main::charset
(byte*) main::charset#0
(byte*) main::charset#1
(byte*) main::charset#2
(byte*) main::charset#3
(byte*) main::charset#4

Adding number conversion cast (unumber) 8 in (byte*~) main::$0 ← (const byte*) CHARSET + (number) 8
Adding number conversion cast (unumber) 4 in (bool~) main::$4 ← (byte) main::c#2 != (number) 4
Adding number conversion cast (unumber) 8 in (byte*~) main::$6 ← (byte*) main::charset#3 + (number) 8
Adding number conversion cast (unumber) $40 in (number~) main::$1 ← (word~) main::$8 / (number) $40
Adding number conversion cast (unumber) main::$1 in (number~) main::$1 ← (word~) main::$8 / (unumber)(number) $40
Adding number conversion cast (unumber) $400 in (number~) main::$2 ← (word~) main::$9 / (number) $400
Adding number conversion cast (unumber) main::$2 in (number~) main::$2 ← (word~) main::$9 / (unumber)(number) $400
Adding number conversion cast (unumber) main::$3 in (number~) main::$3 ← (unumber~) main::$1 | (unumber~) main::$2
Adding number conversion cast (unumber) $80 in (number~) gen_char3::$1 ← (byte~) gen_char3::$0 & (number) $80
Adding number conversion cast (unumber) gen_char3::$1 in (number~) gen_char3::$1 ← (byte~) gen_char3::$0 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) gen_char3::$2 ← (unumber~) gen_char3::$1 != (number) 0
Adding number conversion cast (unumber) 2 in (number~) gen_char3::$5 ← (byte) gen_char3::b#3 * (number) 2
Adding number conversion cast (unumber) gen_char3::$5 in (number~) gen_char3::$5 ← (byte) gen_char3::b#3 * (unumber)(number) 2
Adding number conversion cast (unumber) 2 in (number~) gen_char3::$6 ← (word) gen_char3::spec#3 * (number) 2
Adding number conversion cast (unumber) gen_char3::$6 in (number~) gen_char3::$6 ← (word) gen_char3::spec#3 * (unumber)(number) 2
Adding number conversion cast (unumber) 1 in (number~) gen_char3::$4 ← (byte) gen_char3::b#4 | (number) 1
Adding number conversion cast (unumber) gen_char3::$4 in (number~) gen_char3::$4 ← (byte) gen_char3::b#4 | (unumber)(number) 1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 53272
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 12288
Simplifying constant integer cast 8
Simplifying constant integer cast 4
Simplifying constant integer cast 8
Simplifying constant integer cast $40
Simplifying constant integer cast $400
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $400
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to word in (unumber~) main::$1 ← (word~) main::$8 / (byte) $40
Inferred type updated to word in (unumber~) main::$2 ← (word~) main::$9 / (word) $400
Inferred type updated to word in (unumber~) main::$3 ← (word~) main::$1 | (word~) main::$2
Inferred type updated to byte in (unumber~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80
Inferred type updated to byte in (unumber~) gen_char3::$5 ← (byte) gen_char3::b#3 * (byte) 2
Inferred type updated to word in (unumber~) gen_char3::$6 ← (word) gen_char3::spec#3 * (byte) 2
Inferred type updated to byte in (unumber~) gen_char3::$4 ← (byte) gen_char3::b#4 | (byte) 1
Inversing boolean not [31] (bool~) gen_char3::$3 ← (byte~) gen_char3::$1 == (byte) 0 from [30] (bool~) gen_char3::$2 ← (byte~) gen_char3::$1 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias main::charset#0 = main::$0 
Alias main::c#2 = main::c#3 main::c#4 
Alias main::charset#2 = main::charset#4 main::charset#3 
Alias main::charset#1 = main::$6 
Alias gen_char3::b#1 = gen_char3::$5 gen_char3::b#5 
Alias gen_char3::spec#1 = gen_char3::$6 gen_char3::spec#7 
Alias gen_char3::b#4 = gen_char3::b#6 
Alias gen_char3::spec#2 = gen_char3::spec#5 
Alias gen_char3::c#3 = gen_char3::c#4 
Alias gen_char3::dst#3 = gen_char3::dst#4 
Alias gen_char3::r#4 = gen_char3::r#5 
Alias gen_char3::b#2 = gen_char3::$4 
Alias gen_char3::dst#1 = gen_char3::dst#2 
Alias gen_char3::r#2 = gen_char3::r#3 
Successful SSA optimization Pass2AliasElimination
Alias gen_char3::spec#2 = gen_char3::spec#3 
Alias gen_char3::c#2 = gen_char3::c#3 
Alias gen_char3::dst#1 = gen_char3::dst#3 
Alias gen_char3::r#2 = gen_char3::r#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (word) gen_char3::spec#6 (word) gen_char3::spec#0
Identical Phi Values (byte*) gen_char3::dst#6 (byte*) gen_char3::dst#0
Identical Phi Values (byte*) gen_char3::dst#1 (byte*) gen_char3::dst#5
Identical Phi Values (byte) gen_char3::r#2 (byte) gen_char3::r#6
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte*) gen_char3::dst#5 (byte*) gen_char3::dst#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$4 [4] if((byte) main::c#2!=(byte) 4) goto main::@2
Simple Condition (bool~) gen_char3::$3 [27] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3
Simple Condition (bool~) gen_char3::$7 [33] if((byte) gen_char3::c#1!=rangelast(0,2)) goto gen_char3::@2
Simple Condition (bool~) gen_char3::$8 [38] if((byte) gen_char3::r#1!=rangelast(0,4)) goto gen_char3::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [0] (byte*) main::charset#0 ← (const byte*) CHARSET + (byte) 8
Constant right-side identified [11] (word~) main::$8 ← (word)(const byte*) SCREEN
Constant right-side identified [13] (word~) main::$9 ← (word)(const byte*) CHARSET
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::charset#0 = CHARSET+8
Constant (const byte) main::c#0 = 0
Constant (const word) main::$8 = (word)SCREEN
Constant (const word) main::$9 = (word)CHARSET
Constant (const byte) gen_char3::r#0 = 0
Constant (const byte) gen_char3::b#0 = 0
Constant (const byte) gen_char3::c#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [31] gen_char3::c#1 ← ++ gen_char3::c#2 to ++
Resolved ranged comparison value [33] if(gen_char3::c#1!=rangelast(0,2)) goto gen_char3::@2 to (number) 3
Resolved ranged next value [36] gen_char3::r#1 ← ++ gen_char3::r#6 to ++
Resolved ranged comparison value [38] if(gen_char3::r#1!=rangelast(0,4)) goto gen_char3::@1 to (number) 5
Removing unused procedure _start
Removing unused procedure block _start
Removing unused procedure block _start::_init1
Removing unused procedure block _start::@1
Removing unused procedure block _start::@2
Removing unused procedure block _start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) 3 in [22] if((byte) gen_char3::c#1!=(number) 3) goto gen_char3::@2
Adding number conversion cast (unumber) 5 in [26] if((byte) gen_char3::r#1!=(number) 5) goto gen_char3::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 3
Simplifying constant integer cast 5
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 5
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [8] (word~) main::$1 ← (const word) main::$8 / (byte) $40
Constant right-side identified [9] (word~) main::$2 ← (const word) main::$9 / (word) $400
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::$1 = main::$8/$40
Constant (const word) main::$2 = main::$9/$400
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [8] (word~) main::$3 ← (const word) main::$1 | (const word) main::$2
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::$3 = main::$1|main::$2
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)main::$3 in [9] *((const byte*) VIC_MEMORY) ← (byte)(const word) main::$3
Successful SSA optimization Pass2ConstantValues
Rewriting multiplication to use shift [2] (byte~) main::$7 ← (byte) main::c#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [16] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 * (byte) 2
Rewriting multiplication to use shift [17] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 * (byte) 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte*) main::charset#0
Inlining constant with var siblings (const byte) main::c#0
Inlining constant with var siblings (const byte) gen_char3::r#0
Inlining constant with var siblings (const byte) gen_char3::b#0
Inlining constant with var siblings (const byte) gen_char3::c#0
Constant inlined gen_char3::r#0 = (byte) 0
Constant inlined gen_char3::b#0 = (byte) 0
Constant inlined main::c#0 = (byte) 0
Constant inlined gen_char3::c#0 = (byte) 0
Constant inlined main::$1 = (word)(const byte*) SCREEN/(byte) $40
Constant inlined main::$2 = (word)(const byte*) CHARSET/(word) $400
Constant inlined main::charset#0 = (const byte*) CHARSET+(byte) 8
Constant inlined main::$3 = (word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400
Constant inlined main::$9 = (word)(const byte*) CHARSET
Constant inlined main::$8 = (word)(const byte*) SCREEN
Successful SSA optimization Pass2ConstantInlining
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting gen_char3::@6(between gen_char3::@5 and gen_char3::@1)
Added new block during phi lifting gen_char3::@7(between gen_char3::@3 and gen_char3::@2)
Added new block during phi lifting gen_char3::@8(between gen_char3::@2 and gen_char3::@3)
Adding NOP phi() at start of main
CALL GRAPH
Calls in [main] to gen_char3:8 

Created 8 initial phi equivalence classes
Coalesced [11] main::c#5 ← main::c#1
Coalesced [12] main::charset#5 ← main::charset#1
Coalesced [13] gen_char3::spec#8 ← gen_char3::spec#0
Coalesced [15] gen_char3::spec#10 ← gen_char3::spec#4
Coalesced [21] gen_char3::b#9 ← gen_char3::b#2
Coalesced [31] gen_char3::spec#9 ← gen_char3::spec#1
Coalesced [32] gen_char3::r#7 ← gen_char3::r#1
Coalesced (already) [33] gen_char3::spec#11 ← gen_char3::spec#1
Coalesced [34] gen_char3::b#7 ← gen_char3::b#1
Coalesced [35] gen_char3::c#5 ← gen_char3::c#1
Coalesced [36] gen_char3::b#8 ← gen_char3::b#4
Coalesced down to 6 phi equivalence classes
Culled Empty Block (label) gen_char3::@6
Culled Empty Block (label) gen_char3::@7
Culled Empty Block (label) gen_char3::@8
Adding NOP phi() at start of main
Adding NOP phi() at start of gen_char3

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@4
  [1] (byte*) main::charset#2 ← phi( main/(const byte*) CHARSET+(byte) 8 main::@4/(byte*) main::charset#1 )
  [1] (byte) main::c#2 ← phi( main/(byte) 0 main::@4/(byte) main::c#1 )
  [2] if((byte) main::c#2!=(byte) 4) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [3] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400
  to:main::@return
main::@return: scope:[main]  from main::@3
  [4] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [5] (byte~) main::$7 ← (byte) main::c#2 << (byte) 1
  [6] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2
  [7] (word) gen_char3::spec#0 ← *((const word*) charset_spec_row + (byte~) main::$7)
  [8] call gen_char3 
  to:main::@4
main::@4: scope:[main]  from main::@2
  [9] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8
  [10] (byte) main::c#1 ← ++ (byte) main::c#2
  to:main::@1

(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
gen_char3: scope:[gen_char3]  from main::@2
  [11] phi()
  to:gen_char3::@1
gen_char3::@1: scope:[gen_char3]  from gen_char3 gen_char3::@5
  [12] (byte) gen_char3::r#6 ← phi( gen_char3/(byte) 0 gen_char3::@5/(byte) gen_char3::r#1 )
  [12] (word) gen_char3::spec#4 ← phi( gen_char3/(word) gen_char3::spec#0 gen_char3::@5/(word) gen_char3::spec#1 )
  to:gen_char3::@2
gen_char3::@2: scope:[gen_char3]  from gen_char3::@1 gen_char3::@3
  [13] (byte) gen_char3::c#2 ← phi( gen_char3::@1/(byte) 0 gen_char3::@3/(byte) gen_char3::c#1 )
  [13] (byte) gen_char3::b#4 ← phi( gen_char3::@1/(byte) 0 gen_char3::@3/(byte) gen_char3::b#1 )
  [13] (word) gen_char3::spec#2 ← phi( gen_char3::@1/(word) gen_char3::spec#4 gen_char3::@3/(word) gen_char3::spec#1 )
  [14] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2
  [15] (byte~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80
  [16] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3
  to:gen_char3::@4
gen_char3::@4: scope:[gen_char3]  from gen_char3::@2
  [17] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1
  to:gen_char3::@3
gen_char3::@3: scope:[gen_char3]  from gen_char3::@2 gen_char3::@4
  [18] (byte) gen_char3::b#3 ← phi( gen_char3::@2/(byte) gen_char3::b#4 gen_char3::@4/(byte) gen_char3::b#2 )
  [19] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 << (byte) 1
  [20] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 << (byte) 1
  [21] (byte) gen_char3::c#1 ← ++ (byte) gen_char3::c#2
  [22] if((byte) gen_char3::c#1!=(byte) 3) goto gen_char3::@2
  to:gen_char3::@5
gen_char3::@5: scope:[gen_char3]  from gen_char3::@3
  [23] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1
  [24] (byte) gen_char3::r#1 ← ++ (byte) gen_char3::r#6
  [25] if((byte) gen_char3::r#1!=(byte) 5) goto gen_char3::@1
  to:gen_char3::@return
gen_char3::@return: scope:[gen_char3]  from gen_char3::@5
  [26] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
(byte~) gen_char3::$0 200002.0
(byte~) gen_char3::$1 200002.0
(byte) gen_char3::b
(byte) gen_char3::b#1 52500.75
(byte) gen_char3::b#2 200002.0
(byte) gen_char3::b#3 300003.0
(byte) gen_char3::b#4 75000.75
(byte) gen_char3::c
(byte) gen_char3::c#1 150001.5
(byte) gen_char3::c#2 25000.25
(byte*) gen_char3::dst
(byte*) gen_char3::dst#0 588.9411764705882
(byte) gen_char3::r
(byte) gen_char3::r#1 15001.5
(byte) gen_char3::r#6 2500.25
(word) gen_char3::spec
(word) gen_char3::spec#0 56.0
(word) gen_char3::spec#1 35000.5
(word) gen_char3::spec#2 44286.28571428572
(word) gen_char3::spec#4 20103.0
(void()) main()
(byte~) main::$7 11.0
(byte) main::c
(byte) main::c#1 22.0
(byte) main::c#2 6.285714285714286
(byte*) main::charset
(byte*) main::charset#1 11.0
(byte*) main::charset#2 5.5

Initial phi equivalence classes
[ main::c#2 main::c#1 ]
[ main::charset#2 main::charset#1 ]
[ gen_char3::r#6 gen_char3::r#1 ]
[ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
[ gen_char3::c#2 gen_char3::c#1 ]
[ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
Added variable main::$7 to live range equivalence class [ main::$7 ]
Added variable gen_char3::dst#0 to live range equivalence class [ gen_char3::dst#0 ]
Added variable gen_char3::$0 to live range equivalence class [ gen_char3::$0 ]
Added variable gen_char3::$1 to live range equivalence class [ gen_char3::$1 ]
Complete equivalence classes
[ main::c#2 main::c#1 ]
[ main::charset#2 main::charset#1 ]
[ gen_char3::r#6 gen_char3::r#1 ]
[ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
[ gen_char3::c#2 gen_char3::c#1 ]
[ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
[ main::$7 ]
[ gen_char3::dst#0 ]
[ gen_char3::$0 ]
[ gen_char3::$1 ]
Allocated zp[1]:2 [ main::c#2 main::c#1 ]
Allocated zp[2]:3 [ main::charset#2 main::charset#1 ]
Allocated zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
Allocated zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
Allocated zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ]
Allocated zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
Allocated zp[1]:10 [ main::$7 ]
Allocated zp[2]:11 [ gen_char3::dst#0 ]
Allocated zp[1]:13 [ gen_char3::$0 ]
Allocated zp[1]:14 [ gen_char3::$1 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Generate a charset based on a 5x3 pattern stored in 2 bytes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label VIC_MEMORY = $d018
  .label SCREEN = $400
  .label CHARSET = $3000
  // main
main: {
    .label __7 = $a
    .label charset = 3
    .label c = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi (byte*) main::charset#2 = (const byte*) CHARSET+(byte) 8 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET+8
    sta.z charset
    lda #>CHARSET+8
    sta.z charset+1
    // [1] phi (byte) main::c#2 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    jmp __b1
    // main::@1
  __b1:
    // [2] if((byte) main::c#2!=(byte) 4) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #4
    cmp.z c
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [3] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 -- _deref_pbuc1=vbuc2 
    lda #SCREEN/$40|CHARSET/$400
    sta VIC_MEMORY
    jmp __breturn
    // main::@return
  __breturn:
    // [4] return 
    rts
    // main::@2
  __b2:
    // [5] (byte~) main::$7 ← (byte) main::c#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z c
    asl
    sta.z __7
    // [6] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2 -- pbuz1=pbuz2 
    lda.z charset
    sta.z gen_char3.dst
    lda.z charset+1
    sta.z gen_char3.dst+1
    // [7] (word) gen_char3::spec#0 ← *((const word*) charset_spec_row + (byte~) main::$7) -- vwuz1=pwuc1_derefidx_vbuz2 
    ldy.z __7
    lda charset_spec_row,y
    sta.z gen_char3.spec
    lda charset_spec_row+1,y
    sta.z gen_char3.spec+1
    // [8] call gen_char3 
    // [11] phi from main::@2 to gen_char3 [phi:main::@2->gen_char3]
  gen_char3_from___b2:
    jsr gen_char3
    jmp __b4
    // main::@4
  __b4:
    // [9] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #8
    clc
    adc.z charset
    sta.z charset
    bcc !+
    inc.z charset+1
  !:
    // [10] (byte) main::c#1 ← ++ (byte) main::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [1] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  __b1_from___b4:
    // [1] phi (byte*) main::charset#2 = (byte*) main::charset#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [1] phi (byte) main::c#2 = (byte) main::c#1 [phi:main::@4->main::@1#1] -- register_copy 
    jmp __b1
}
  // gen_char3
// Generate one 5x3 character from a 16-bit char spec
// The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
// gen_char3(byte* zp($b) dst, word zp(6) spec)
gen_char3: {
    .label __0 = $d
    .label __1 = $e
    .label dst = $b
    .label spec = 6
    .label b = 9
    .label c = 8
    .label r = 5
    // [12] phi from gen_char3 to gen_char3::@1 [phi:gen_char3->gen_char3::@1]
  __b1_from_gen_char3:
    // [12] phi (byte) gen_char3::r#6 = (byte) 0 [phi:gen_char3->gen_char3::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    // [12] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#0 [phi:gen_char3->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // [12] phi from gen_char3::@5 to gen_char3::@1 [phi:gen_char3::@5->gen_char3::@1]
  __b1_from___b5:
    // [12] phi (byte) gen_char3::r#6 = (byte) gen_char3::r#1 [phi:gen_char3::@5->gen_char3::@1#0] -- register_copy 
    // [12] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#1 [phi:gen_char3::@5->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // gen_char3::@1
  __b1:
    // [13] phi from gen_char3::@1 to gen_char3::@2 [phi:gen_char3::@1->gen_char3::@2]
  __b2_from___b1:
    // [13] phi (byte) gen_char3::c#2 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    // [13] phi (byte) gen_char3::b#4 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#1] -- vbuz1=vbuc1 
    lda #0
    sta.z b
    // [13] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#4 [phi:gen_char3::@1->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // [13] phi from gen_char3::@3 to gen_char3::@2 [phi:gen_char3::@3->gen_char3::@2]
  __b2_from___b3:
    // [13] phi (byte) gen_char3::c#2 = (byte) gen_char3::c#1 [phi:gen_char3::@3->gen_char3::@2#0] -- register_copy 
    // [13] phi (byte) gen_char3::b#4 = (byte) gen_char3::b#1 [phi:gen_char3::@3->gen_char3::@2#1] -- register_copy 
    // [13] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#1 [phi:gen_char3::@3->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // gen_char3::@2
  __b2:
    // [14] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2 -- vbuz1=_hi_vwuz2 
    lda.z spec+1
    sta.z __0
    // [15] (byte~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and.z __0
    sta.z __1
    // [16] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3 -- vbuz1_eq_0_then_la1 
    lda.z __1
    cmp #0
    beq __b3_from___b2
    jmp __b4
    // gen_char3::@4
  __b4:
    // [17] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 -- vbuz1=vbuz1_bor_vbuc1 
    lda #1
    ora.z b
    sta.z b
    // [18] phi from gen_char3::@2 gen_char3::@4 to gen_char3::@3 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3]
  __b3_from___b2:
  __b3_from___b4:
    // [18] phi (byte) gen_char3::b#3 = (byte) gen_char3::b#4 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3#0] -- register_copy 
    jmp __b3
    // gen_char3::@3
  __b3:
    // [19] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z b
    // [20] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z spec
    rol.z spec+1
    // [21] (byte) gen_char3::c#1 ← ++ (byte) gen_char3::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [22] if((byte) gen_char3::c#1!=(byte) 3) goto gen_char3::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #3
    cmp.z c
    bne __b2_from___b3
    jmp __b5
    // gen_char3::@5
  __b5:
    // [23] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1 -- pbuz1_derefidx_vbuz2=vbuz3 
    lda.z b
    ldy.z r
    sta (dst),y
    // [24] (byte) gen_char3::r#1 ← ++ (byte) gen_char3::r#6 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [25] if((byte) gen_char3::r#1!=(byte) 5) goto gen_char3::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #5
    cmp.z r
    bne __b1_from___b5
    jmp __breturn
    // gen_char3::@return
  __breturn:
    // [26] return 
    rts
}
  // File Data
  // Stores chars as 15 bits (in 2 bytes) specifying the 3x5
  // The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
  charset_spec_row: .word $f7da, $f7de, $f24e, $d6de

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [3] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] (byte~) main::$7 ← (byte) main::c#2 << (byte) 1 [ main::c#2 main::charset#2 main::$7 ] (  [ main::c#2 main::charset#2 main::$7 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::c#2 main::c#1 ]
Statement [6] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2 [ main::c#2 main::charset#2 main::$7 gen_char3::dst#0 ] (  [ main::c#2 main::charset#2 main::$7 gen_char3::dst#0 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ main::$7 ]
Statement [7] (word) gen_char3::spec#0 ← *((const word*) charset_spec_row + (byte~) main::$7) [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] (  [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Statement [9] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 [ main::c#2 main::charset#1 ] (  [ main::c#2 main::charset#1 ] { }  ) always clobbers reg byte a 
Statement [17] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] ( gen_char3:8 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ]
Statement [3] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] (byte~) main::$7 ← (byte) main::c#2 << (byte) 1 [ main::c#2 main::charset#2 main::$7 ] (  [ main::c#2 main::charset#2 main::$7 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Statement [6] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2 [ main::c#2 main::charset#2 main::$7 gen_char3::dst#0 ] (  [ main::c#2 main::charset#2 main::$7 gen_char3::dst#0 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Statement [7] (word) gen_char3::spec#0 ← *((const word*) charset_spec_row + (byte~) main::$7) [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] (  [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Statement [9] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 [ main::c#2 main::charset#1 ] (  [ main::c#2 main::charset#1 ] { }  ) always clobbers reg byte a 
Statement [17] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] ( gen_char3:8 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::c#2 main::c#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[2]:3 [ main::charset#2 main::charset#1 ] : zp[2]:3 , 
Potential registers zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ] : zp[2]:6 , 
Potential registers zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ main::$7 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[2]:11 [ gen_char3::dst#0 ] : zp[2]:11 , 
Potential registers zp[1]:13 [ gen_char3::$0 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ gen_char3::$1 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [gen_char3] 627,506.5: zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ] 200,002: zp[1]:13 [ gen_char3::$0 ] 200,002: zp[1]:14 [ gen_char3::$1 ] 175,001.75: zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ] 99,445.79: zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ] 17,501.75: zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] 588.94: zp[2]:11 [ gen_char3::dst#0 ] 
Uplift Scope [main] 28.29: zp[1]:2 [ main::c#2 main::c#1 ] 16.5: zp[2]:3 [ main::charset#2 main::charset#1 ] 11: zp[1]:10 [ main::$7 ] 
Uplift Scope [] 

Uplifting [gen_char3] best 61700 combination reg byte y [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ] reg byte a [ gen_char3::$0 ] reg byte a [ gen_char3::$1 ] reg byte x [ gen_char3::c#2 gen_char3::c#1 ] zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ] zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] zp[2]:11 [ gen_char3::dst#0 ] 
Limited combination testing to 100 combinations of 576 possible.
Uplifting [main] best 61660 combination zp[1]:2 [ main::c#2 main::c#1 ] zp[2]:3 [ main::charset#2 main::charset#1 ] reg byte x [ main::$7 ] 
Uplifting [] best 61660 combination 
Attempting to uplift remaining variables inzp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
Uplifting [gen_char3] best 61660 combination zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] 
Attempting to uplift remaining variables inzp[1]:2 [ main::c#2 main::c#1 ]
Uplifting [main] best 61660 combination zp[1]:2 [ main::c#2 main::c#1 ] 
Coalescing zero page register [ zp[2]:3 [ main::charset#2 main::charset#1 ] ] with [ zp[2]:11 [ gen_char3::dst#0 ] ] - score: 1

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Generate a charset based on a 5x3 pattern stored in 2 bytes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label VIC_MEMORY = $d018
  .label SCREEN = $400
  .label CHARSET = $3000
  // main
main: {
    .label charset = 3
    .label c = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi (byte*) main::charset#2 = (const byte*) CHARSET+(byte) 8 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET+8
    sta.z charset
    lda #>CHARSET+8
    sta.z charset+1
    // [1] phi (byte) main::c#2 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    jmp __b1
    // main::@1
  __b1:
    // [2] if((byte) main::c#2!=(byte) 4) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #4
    cmp.z c
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [3] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 -- _deref_pbuc1=vbuc2 
    lda #SCREEN/$40|CHARSET/$400
    sta VIC_MEMORY
    jmp __breturn
    // main::@return
  __breturn:
    // [4] return 
    rts
    // main::@2
  __b2:
    // [5] (byte~) main::$7 ← (byte) main::c#2 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda.z c
    asl
    tax
    // [6] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2
    // [7] (word) gen_char3::spec#0 ← *((const word*) charset_spec_row + (byte~) main::$7) -- vwuz1=pwuc1_derefidx_vbuxx 
    lda charset_spec_row,x
    sta.z gen_char3.spec
    lda charset_spec_row+1,x
    sta.z gen_char3.spec+1
    // [8] call gen_char3 
    // [11] phi from main::@2 to gen_char3 [phi:main::@2->gen_char3]
  gen_char3_from___b2:
    jsr gen_char3
    jmp __b4
    // main::@4
  __b4:
    // [9] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #8
    clc
    adc.z charset
    sta.z charset
    bcc !+
    inc.z charset+1
  !:
    // [10] (byte) main::c#1 ← ++ (byte) main::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [1] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  __b1_from___b4:
    // [1] phi (byte*) main::charset#2 = (byte*) main::charset#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [1] phi (byte) main::c#2 = (byte) main::c#1 [phi:main::@4->main::@1#1] -- register_copy 
    jmp __b1
}
  // gen_char3
// Generate one 5x3 character from a 16-bit char spec
// The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
// gen_char3(byte* zp(3) dst, word zp(6) spec)
gen_char3: {
    .label dst = 3
    .label spec = 6
    .label r = 5
    // [12] phi from gen_char3 to gen_char3::@1 [phi:gen_char3->gen_char3::@1]
  __b1_from_gen_char3:
    // [12] phi (byte) gen_char3::r#6 = (byte) 0 [phi:gen_char3->gen_char3::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    // [12] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#0 [phi:gen_char3->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // [12] phi from gen_char3::@5 to gen_char3::@1 [phi:gen_char3::@5->gen_char3::@1]
  __b1_from___b5:
    // [12] phi (byte) gen_char3::r#6 = (byte) gen_char3::r#1 [phi:gen_char3::@5->gen_char3::@1#0] -- register_copy 
    // [12] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#1 [phi:gen_char3::@5->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // gen_char3::@1
  __b1:
    // [13] phi from gen_char3::@1 to gen_char3::@2 [phi:gen_char3::@1->gen_char3::@2]
  __b2_from___b1:
    // [13] phi (byte) gen_char3::c#2 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [13] phi (byte) gen_char3::b#4 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#1] -- vbuyy=vbuc1 
    ldy #0
    // [13] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#4 [phi:gen_char3::@1->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // [13] phi from gen_char3::@3 to gen_char3::@2 [phi:gen_char3::@3->gen_char3::@2]
  __b2_from___b3:
    // [13] phi (byte) gen_char3::c#2 = (byte) gen_char3::c#1 [phi:gen_char3::@3->gen_char3::@2#0] -- register_copy 
    // [13] phi (byte) gen_char3::b#4 = (byte) gen_char3::b#1 [phi:gen_char3::@3->gen_char3::@2#1] -- register_copy 
    // [13] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#1 [phi:gen_char3::@3->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // gen_char3::@2
  __b2:
    // [14] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2 -- vbuaa=_hi_vwuz1 
    lda.z spec+1
    // [15] (byte~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // [16] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3_from___b2
    jmp __b4
    // gen_char3::@4
  __b4:
    // [17] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 -- vbuyy=vbuyy_bor_vbuc1 
    tya
    ora #1
    tay
    // [18] phi from gen_char3::@2 gen_char3::@4 to gen_char3::@3 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3]
  __b3_from___b2:
  __b3_from___b4:
    // [18] phi (byte) gen_char3::b#3 = (byte) gen_char3::b#4 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3#0] -- register_copy 
    jmp __b3
    // gen_char3::@3
  __b3:
    // [19] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 << (byte) 1 -- vbuyy=vbuyy_rol_1 
    tya
    asl
    tay
    // [20] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z spec
    rol.z spec+1
    // [21] (byte) gen_char3::c#1 ← ++ (byte) gen_char3::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // [22] if((byte) gen_char3::c#1!=(byte) 3) goto gen_char3::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #3
    bne __b2_from___b3
    jmp __b5
    // gen_char3::@5
  __b5:
    // [23] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1 -- pbuz1_derefidx_vbuz2=vbuyy 
    tya
    ldy.z r
    sta (dst),y
    // [24] (byte) gen_char3::r#1 ← ++ (byte) gen_char3::r#6 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [25] if((byte) gen_char3::r#1!=(byte) 5) goto gen_char3::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #5
    cmp.z r
    bne __b1_from___b5
    jmp __breturn
    // gen_char3::@return
  __breturn:
    // [26] return 
    rts
}
  // File Data
  // Stores chars as 15 bits (in 2 bytes) specifying the 3x5
  // The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
  charset_spec_row: .word $f7da, $f7de, $f24e, $d6de

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b4
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b3_from___b2 with __b3
Replacing label __b2_from___b3 with __b2
Replacing label __b1_from___b5 with __b1
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b3:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b4:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction gen_char3_from___b2:
Removing instruction __b4:
Removing instruction __b1_from___b4:
Removing instruction __b1_from_gen_char3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b2
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
(const byte*) CHARSET = (byte*) 12288
(const byte*) SCREEN = (byte*) 1024
(const byte*) VIC_MEMORY = (byte*) 53272
(const word*) charset_spec_row[]  = { (word) $f7da, (word) $f7de, (word) $f24e, (word) $d6de }
(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
(byte~) gen_char3::$0 reg byte a 200002.0
(byte~) gen_char3::$1 reg byte a 200002.0
(label) gen_char3::@1
(label) gen_char3::@2
(label) gen_char3::@3
(label) gen_char3::@4
(label) gen_char3::@5
(label) gen_char3::@return
(byte) gen_char3::b
(byte) gen_char3::b#1 reg byte y 52500.75
(byte) gen_char3::b#2 reg byte y 200002.0
(byte) gen_char3::b#3 reg byte y 300003.0
(byte) gen_char3::b#4 reg byte y 75000.75
(byte) gen_char3::c
(byte) gen_char3::c#1 reg byte x 150001.5
(byte) gen_char3::c#2 reg byte x 25000.25
(byte*) gen_char3::dst
(byte*) gen_char3::dst#0 dst zp[2]:3 588.9411764705882
(byte) gen_char3::r
(byte) gen_char3::r#1 r zp[1]:5 15001.5
(byte) gen_char3::r#6 r zp[1]:5 2500.25
(word) gen_char3::spec
(word) gen_char3::spec#0 spec zp[2]:6 56.0
(word) gen_char3::spec#1 spec zp[2]:6 35000.5
(word) gen_char3::spec#2 spec zp[2]:6 44286.28571428572
(word) gen_char3::spec#4 spec zp[2]:6 20103.0
(void()) main()
(byte~) main::$7 reg byte x 11.0
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return
(byte) main::c
(byte) main::c#1 c zp[1]:2 22.0
(byte) main::c#2 c zp[1]:2 6.285714285714286
(byte*) main::charset
(byte*) main::charset#1 charset zp[2]:3 11.0
(byte*) main::charset#2 charset zp[2]:3 5.5

zp[1]:2 [ main::c#2 main::c#1 ]
zp[2]:3 [ main::charset#2 main::charset#1 gen_char3::dst#0 ]
zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
reg byte x [ gen_char3::c#2 gen_char3::c#1 ]
reg byte y [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
reg byte x [ main::$7 ]
reg byte a [ gen_char3::$0 ]
reg byte a [ gen_char3::$1 ]


FINAL ASSEMBLER
Score: 45574

  // File Comments
// Generate a charset based on a 5x3 pattern stored in 2 bytes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label VIC_MEMORY = $d018
  .label SCREEN = $400
  .label CHARSET = $3000
  // main
main: {
    .label charset = 3
    .label c = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi (byte*) main::charset#2 = (const byte*) CHARSET+(byte) 8 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET+8
    sta.z charset
    lda #>CHARSET+8
    sta.z charset+1
    // [1] phi (byte) main::c#2 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    // main::@1
  __b1:
    // for(byte c=0;c!=4;c++)
    // [2] if((byte) main::c#2!=(byte) 4) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #4
    cmp.z c
    bne __b2
    // main::@3
    // *VIC_MEMORY = (byte)(((word)SCREEN/$40)|((word)CHARSET/$400))
    // [3] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 -- _deref_pbuc1=vbuc2 
    lda #SCREEN/$40|CHARSET/$400
    sta VIC_MEMORY
    // main::@return
    // }
    // [4] return 
    rts
    // main::@2
  __b2:
    // gen_char3(charset, charset_spec_row[c])
    // [5] (byte~) main::$7 ← (byte) main::c#2 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda.z c
    asl
    tax
    // [6] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2
    // [7] (word) gen_char3::spec#0 ← *((const word*) charset_spec_row + (byte~) main::$7) -- vwuz1=pwuc1_derefidx_vbuxx 
    lda charset_spec_row,x
    sta.z gen_char3.spec
    lda charset_spec_row+1,x
    sta.z gen_char3.spec+1
    // [8] call gen_char3 
    // [11] phi from main::@2 to gen_char3 [phi:main::@2->gen_char3]
    jsr gen_char3
    // main::@4
    // charset = charset+8
    // [9] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #8
    clc
    adc.z charset
    sta.z charset
    bcc !+
    inc.z charset+1
  !:
    // for(byte c=0;c!=4;c++)
    // [10] (byte) main::c#1 ← ++ (byte) main::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [1] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
    // [1] phi (byte*) main::charset#2 = (byte*) main::charset#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [1] phi (byte) main::c#2 = (byte) main::c#1 [phi:main::@4->main::@1#1] -- register_copy 
    jmp __b1
}
  // gen_char3
// Generate one 5x3 character from a 16-bit char spec
// The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
// gen_char3(byte* zp(3) dst, word zp(6) spec)
gen_char3: {
    .label dst = 3
    .label spec = 6
    .label r = 5
    // [12] phi from gen_char3 to gen_char3::@1 [phi:gen_char3->gen_char3::@1]
    // [12] phi (byte) gen_char3::r#6 = (byte) 0 [phi:gen_char3->gen_char3::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    // [12] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#0 [phi:gen_char3->gen_char3::@1#1] -- register_copy 
    // [12] phi from gen_char3::@5 to gen_char3::@1 [phi:gen_char3::@5->gen_char3::@1]
    // [12] phi (byte) gen_char3::r#6 = (byte) gen_char3::r#1 [phi:gen_char3::@5->gen_char3::@1#0] -- register_copy 
    // [12] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#1 [phi:gen_char3::@5->gen_char3::@1#1] -- register_copy 
    // gen_char3::@1
  __b1:
    // [13] phi from gen_char3::@1 to gen_char3::@2 [phi:gen_char3::@1->gen_char3::@2]
    // [13] phi (byte) gen_char3::c#2 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [13] phi (byte) gen_char3::b#4 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#1] -- vbuyy=vbuc1 
    ldy #0
    // [13] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#4 [phi:gen_char3::@1->gen_char3::@2#2] -- register_copy 
    // [13] phi from gen_char3::@3 to gen_char3::@2 [phi:gen_char3::@3->gen_char3::@2]
    // [13] phi (byte) gen_char3::c#2 = (byte) gen_char3::c#1 [phi:gen_char3::@3->gen_char3::@2#0] -- register_copy 
    // [13] phi (byte) gen_char3::b#4 = (byte) gen_char3::b#1 [phi:gen_char3::@3->gen_char3::@2#1] -- register_copy 
    // [13] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#1 [phi:gen_char3::@3->gen_char3::@2#2] -- register_copy 
    // gen_char3::@2
  __b2:
    // >spec
    // [14] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2 -- vbuaa=_hi_vwuz1 
    lda.z spec+1
    // >spec&$80
    // [15] (byte~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // if((>spec&$80)!=0)
    // [16] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3
    // gen_char3::@4
    // b = b|1
    // [17] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 -- vbuyy=vbuyy_bor_vbuc1 
    tya
    ora #1
    tay
    // [18] phi from gen_char3::@2 gen_char3::@4 to gen_char3::@3 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3]
    // [18] phi (byte) gen_char3::b#3 = (byte) gen_char3::b#4 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3#0] -- register_copy 
    // gen_char3::@3
  __b3:
    // b = b*2
    // [19] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 << (byte) 1 -- vbuyy=vbuyy_rol_1 
    tya
    asl
    tay
    // spec = spec*2
    // [20] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z spec
    rol.z spec+1
    // for(byte c: 0..2 )
    // [21] (byte) gen_char3::c#1 ← ++ (byte) gen_char3::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // [22] if((byte) gen_char3::c#1!=(byte) 3) goto gen_char3::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #3
    bne __b2
    // gen_char3::@5
    // dst[r] = b
    // [23] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1 -- pbuz1_derefidx_vbuz2=vbuyy 
    tya
    ldy.z r
    sta (dst),y
    // for(byte r : 0..4 )
    // [24] (byte) gen_char3::r#1 ← ++ (byte) gen_char3::r#6 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [25] if((byte) gen_char3::r#1!=(byte) 5) goto gen_char3::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #5
    cmp.z r
    bne __b1
    // gen_char3::@return
    // }
    // [26] return 
    rts
}
  // File Data
  // Stores chars as 15 bits (in 2 bytes) specifying the 3x5
  // The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
  charset_spec_row: .word $f7da, $f7de, $f24e, $d6de

