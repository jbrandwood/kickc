Inlined call call __init 

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  i#31 = phi( __start::@1/i#32 )
  main::reg_zp_abs#0 = '.'
  main::reg_mem_abs#0 = '.'
  main::default_zp_abs = '.'
  main::default_mem_abs = '.'
  out::c#0 = main::reg_zp_flex
  call out 
  to:main::@1
main::@1: scope:[main]  from main
  main::reg_mem_abs#3 = phi( main/main::reg_mem_abs#0 )
  main::reg_zp_abs#1 = phi( main/main::reg_zp_abs#0 )
  i#16 = phi( main/i#12 )
  i#0 = i#16
  out::c#1 = main::reg_zp_abs#1
  call out 
  to:main::@2
main::@2: scope:[main]  from main::@1
  main::reg_mem_abs#2 = phi( main::@1/main::reg_mem_abs#3 )
  i#17 = phi( main::@1/i#12 )
  i#1 = i#17
  out::c#2 = main::reg_mem_flex
  call out 
  to:main::@3
main::@3: scope:[main]  from main::@2
  main::reg_mem_abs#1 = phi( main::@2/main::reg_mem_abs#2 )
  i#18 = phi( main::@2/i#12 )
  i#2 = i#18
  out::c#3 = main::reg_mem_abs#1
  call out 
  to:main::@4
main::@4: scope:[main]  from main::@3
  i#19 = phi( main::@3/i#12 )
  i#3 = i#19
  out::c#4 = main::default_default
  call out 
  to:main::@5
main::@5: scope:[main]  from main::@4
  i#20 = phi( main::@4/i#12 )
  i#4 = i#20
  out::c#5 = main::reg_default
  call out 
  to:main::@6
main::@6: scope:[main]  from main::@5
  i#21 = phi( main::@5/i#12 )
  i#5 = i#21
  out::c#6 = main::default_zp_flex
  call out 
  to:main::@7
main::@7: scope:[main]  from main::@6
  i#22 = phi( main::@6/i#12 )
  i#6 = i#22
  out::c#7 = main::default_zp_abs
  call out 
  to:main::@8
main::@8: scope:[main]  from main::@7
  i#23 = phi( main::@7/i#12 )
  i#7 = i#23
  out::c#8 = main::default_mem_flex
  call out 
  to:main::@9
main::@9: scope:[main]  from main::@8
  i#24 = phi( main::@8/i#12 )
  i#8 = i#24
  out::c#9 = main::default_mem_abs
  call out 
  to:main::@10
main::@10: scope:[main]  from main::@9
  i#25 = phi( main::@9/i#12 )
  i#9 = i#25
  to:main::@return
main::@return: scope:[main]  from main::@10
  i#26 = phi( main::@10/i#9 )
  i#10 = i#26
  return 
  to:@return

void out(byte out::c)
out: scope:[out]  from main main::@1 main::@2 main::@3 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  i#27 = phi( main/i#31, main::@1/i#0, main::@2/i#1, main::@3/i#2, main::@4/i#3, main::@5/i#4, main::@6/i#5, main::@7/i#6, main::@8/i#7, main::@9/i#8 )
  out::c#10 = phi( main/out::c#0, main::@1/out::c#1, main::@2/out::c#2, main::@3/out::c#3, main::@4/out::c#4, main::@5/out::c#5, main::@6/out::c#6, main::@7/out::c#7, main::@8/out::c#8, main::@9/out::c#9 )
  SCREEN[i#27] = out::c#10
  i#11 = ++ i#27
  to:out::@return
out::@return: scope:[out]  from out
  i#28 = phi( out/i#11 )
  i#12 = i#28
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  i#13 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  i#32 = phi( __start::__init1/i#13 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  i#29 = phi( __start::@1/i#10 )
  i#14 = i#29
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  i#30 = phi( __start::@2/i#14 )
  i#15 = i#30
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* const SCREEN = (byte*)$400
void __start()
byte i
byte i#0
byte i#1
byte i#10
byte i#11
byte i#12
byte i#13
byte i#14
byte i#15
byte i#16
byte i#17
byte i#18
byte i#19
byte i#2
byte i#20
byte i#21
byte i#22
byte i#23
byte i#24
byte i#25
byte i#26
byte i#27
byte i#28
byte i#29
byte i#3
byte i#30
byte i#31
byte i#32
byte i#4
byte i#5
byte i#6
byte i#7
byte i#8
byte i#9
void main()
constant byte main::default_default = '.'
byte main::default_mem_abs loadstore !mem[-1]:4097
constant byte main::default_mem_flex = '.'
byte main::default_zp_abs loadstore !zp[-1]:17
constant byte main::default_zp_flex = '.'
constant byte main::reg_default = '.'
byte main::reg_mem_abs !mem[-1]:4096
byte main::reg_mem_abs#0 !mem[-1]:4096
byte main::reg_mem_abs#1 !mem[-1]:4096
byte main::reg_mem_abs#2 !mem[-1]:4096
byte main::reg_mem_abs#3 !mem[-1]:4096
constant byte main::reg_mem_flex = '.'
byte main::reg_zp_abs !zp[-1]:16
byte main::reg_zp_abs#0 !zp[-1]:16
byte main::reg_zp_abs#1 !zp[-1]:16
constant byte main::reg_zp_flex = '.'
void out(byte out::c)
byte out::c
byte out::c#0
byte out::c#1
byte out::c#10
byte out::c#2
byte out::c#3
byte out::c#4
byte out::c#5
byte out::c#6
byte out::c#7
byte out::c#8
byte out::c#9

Simplifying constant pointer cast (byte*) 1024
Successful SSA optimization PassNCastSimplification
Alias main::reg_zp_abs#0 = main::reg_zp_abs#1 
Alias main::reg_mem_abs#0 = main::reg_mem_abs#3 main::reg_mem_abs#2 main::reg_mem_abs#1 
Alias i#0 = i#16 
Alias i#1 = i#17 
Alias i#18 = i#2 
Alias i#19 = i#3 
Alias i#20 = i#4 
Alias i#21 = i#5 
Alias i#22 = i#6 
Alias i#23 = i#7 
Alias i#24 = i#8 
Alias i#10 = i#9 i#25 i#26 
Alias i#11 = i#28 i#12 
Alias i#13 = i#32 
Alias i#14 = i#29 i#30 i#15 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values i#31 i#13
Identical Phi Values i#0 i#11
Identical Phi Values i#1 i#11
Identical Phi Values i#18 i#11
Identical Phi Values i#19 i#11
Identical Phi Values i#20 i#11
Identical Phi Values i#21 i#11
Identical Phi Values i#22 i#11
Identical Phi Values i#23 i#11
Identical Phi Values i#24 i#11
Identical Phi Values i#10 i#11
Identical Phi Values i#14 i#10
Successful SSA optimization Pass2IdenticalPhiElimination
Constant out::c#0 = main::reg_zp_flex
Constant out::c#2 = main::reg_mem_flex
Constant out::c#4 = main::default_default
Constant out::c#5 = main::reg_default
Constant out::c#6 = main::default_zp_flex
Constant out::c#8 = main::default_mem_flex
Constant i#13 = 0
Successful SSA optimization Pass2ConstantIdentification
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings out::c#0
Inlining constant with var siblings out::c#2
Inlining constant with var siblings out::c#4
Inlining constant with var siblings out::c#5
Inlining constant with var siblings out::c#6
Inlining constant with var siblings out::c#8
Inlining constant with var siblings i#13
Constant inlined out::c#8 = main::default_mem_flex
Constant inlined out::c#6 = main::default_zp_flex
Constant inlined out::c#0 = main::reg_zp_flex
Constant inlined out::c#4 = main::default_default
Constant inlined i#13 = 0
Constant inlined out::c#5 = main::reg_default
Constant inlined out::c#2 = main::reg_mem_flex
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of main::@10
CALL GRAPH
Calls in [main] to out:4 out:8 out:10 out:14 out:16 out:18 out:20 out:24 out:26 out:30 

Created 2 initial phi equivalence classes
Coalesced [6] out::c#11 = out::c#1
Coalesced [7] i#33 = i#11
Coalesced (already) [9] i#34 = i#11
Coalesced [12] out::c#12 = out::c#3
Coalesced (already) [13] i#35 = i#11
Coalesced (already) [15] i#36 = i#11
Coalesced (already) [17] i#37 = i#11
Coalesced (already) [19] i#38 = i#11
Coalesced [22] out::c#13 = out::c#7
Coalesced (already) [23] i#39 = i#11
Coalesced (already) [25] i#40 = i#11
Coalesced [28] out::c#14 = out::c#9
Coalesced (already) [29] i#41 = i#11
Coalesced down to 2 phi equivalence classes
Culled Empty Block label main::@10
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@8

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] main::reg_zp_abs#0 = '.'
  [1] main::reg_mem_abs#0 = '.'
  [2] main::default_zp_abs = '.'
  [3] main::default_mem_abs = '.'
  [4] call out 
  to:main::@1
main::@1: scope:[main]  from main
  [5] out::c#1 = main::reg_zp_abs#0
  [6] call out 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [7] phi()
  [8] call out 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [9] out::c#3 = main::reg_mem_abs#0
  [10] call out 
  to:main::@4
main::@4: scope:[main]  from main::@3
  [11] phi()
  [12] call out 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [13] phi()
  [14] call out 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [15] phi()
  [16] call out 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [17] out::c#7 = main::default_zp_abs
  [18] call out 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [19] phi()
  [20] call out 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [21] out::c#9 = main::default_mem_abs
  [22] call out 
  to:main::@return
main::@return: scope:[main]  from main::@9
  [23] return 
  to:@return

void out(byte out::c)
out: scope:[out]  from main main::@1 main::@2 main::@3 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  [24] i#27 = phi( main/0, main::@1/i#11, main::@2/i#11, main::@3/i#11, main::@4/i#11, main::@5/i#11, main::@6/i#11, main::@7/i#11, main::@8/i#11, main::@9/i#11 )
  [24] out::c#10 = phi( main/main::reg_zp_flex, main::@1/out::c#1, main::@2/main::reg_mem_flex, main::@3/out::c#3, main::@4/main::default_default, main::@5/main::reg_default, main::@6/main::default_zp_flex, main::@7/out::c#7, main::@8/main::default_mem_flex, main::@9/out::c#9 )
  [25] SCREEN[i#27] = out::c#10
  [26] i#11 = ++ i#27
  to:out::@return
out::@return: scope:[out]  from out
  [27] return 
  to:@return


VARIABLE REGISTER WEIGHTS
byte i
byte i#11 1.45
byte i#27 20.0
void main()
byte main::default_mem_abs loadstore !mem[-1]:4097 0.2222222222222222
byte main::default_zp_abs loadstore !zp[-1]:17 0.26666666666666666
byte main::reg_mem_abs !mem[-1]:4096
byte main::reg_mem_abs#0 !mem[-1]:4096 0.5
byte main::reg_zp_abs !zp[-1]:16
byte main::reg_zp_abs#0 !zp[-1]:16 0.8
void out(byte out::c)
byte out::c
byte out::c#1 4.0
byte out::c#10 19.0
byte out::c#3 4.0
byte out::c#7 4.0
byte out::c#9 4.0

Initial phi equivalence classes
[ out::c#10 out::c#1 out::c#3 out::c#7 out::c#9 ]
[ i#27 i#11 ]
Added variable main::reg_zp_abs#0 to live range equivalence class [ main::reg_zp_abs#0 ]
Added variable main::reg_mem_abs#0 to live range equivalence class [ main::reg_mem_abs#0 ]
Added variable main::default_zp_abs to live range equivalence class [ main::default_zp_abs ]
Added variable main::default_mem_abs to live range equivalence class [ main::default_mem_abs ]
Complete equivalence classes
[ out::c#10 out::c#1 out::c#3 out::c#7 out::c#9 ]
[ i#27 i#11 ]
[ main::reg_zp_abs#0 ]
[ main::reg_mem_abs#0 ]
[ main::default_zp_abs ]
[ main::default_mem_abs ]
Allocated zp[1]:2 [ out::c#10 out::c#1 out::c#3 out::c#7 out::c#9 ]
Allocated zp[1]:3 [ i#27 i#11 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] main::reg_zp_abs#0 = '.' [ main::reg_zp_abs#0 ] (  [ main::reg_zp_abs#0 ] { }  ) always clobbers reg byte a 
Statement [1] main::reg_mem_abs#0 = '.' [ main::reg_zp_abs#0 main::reg_mem_abs#0 ] (  [ main::reg_zp_abs#0 main::reg_mem_abs#0 ] { }  ) always clobbers reg byte a 
Statement [2] main::default_zp_abs = '.' [ main::reg_zp_abs#0 main::reg_mem_abs#0 main::default_zp_abs ] (  [ main::reg_zp_abs#0 main::reg_mem_abs#0 main::default_zp_abs ] { }  ) always clobbers reg byte a 
Statement [3] main::default_mem_abs = '.' [ main::reg_zp_abs#0 main::reg_mem_abs#0 main::default_zp_abs main::default_mem_abs ] (  [ main::reg_zp_abs#0 main::reg_mem_abs#0 main::default_zp_abs main::default_mem_abs ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ out::c#10 out::c#1 out::c#3 out::c#7 out::c#9 ] : zp[1]:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ i#27 i#11 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ main::reg_zp_abs#0 ] : zp[1]:16 , 
Potential registers mem[1]:4096 [ main::reg_mem_abs#0 ] : mem[1]:4096 , 
Potential registers zp[1]:17 [ main::default_zp_abs ] : zp[1]:17 , 
Potential registers mem[1]:4097 [ main::default_mem_abs ] : mem[1]:4097 , 

REGISTER UPLIFT SCOPES
Uplift Scope [out] 35: zp[1]:2 [ out::c#10 out::c#1 out::c#3 out::c#7 out::c#9 ] 
Uplift Scope [] 21.45: zp[1]:3 [ i#27 i#11 ] 
Uplift Scope [main] 0.8: zp[1]:16 [ main::reg_zp_abs#0 ] 0.5: mem[1]:4096 [ main::reg_mem_abs#0 ] 0.27: zp[1]:17 [ main::default_zp_abs ] 0.22: mem[1]:4097 [ main::default_mem_abs ] 

Uplifting [out] best 173 combination reg byte x [ out::c#10 out::c#1 out::c#3 out::c#7 out::c#9 ] 
Uplifting [] best 164 combination reg byte y [ i#27 i#11 ] 
Uplifting [main] best 164 combination zp[1]:16 [ main::reg_zp_abs#0 ] mem[1]:4096 [ main::reg_mem_abs#0 ] zp[1]:17 [ main::default_zp_abs ] mem[1]:4097 [ main::default_mem_abs ] 
Attempting to uplift remaining variables inzp[1]:16 [ main::reg_zp_abs#0 ]
Uplifting [main] best 164 combination zp[1]:16 [ main::reg_zp_abs#0 ] 
Attempting to uplift remaining variables inmem[1]:4096 [ main::reg_mem_abs#0 ]
Uplifting [main] best 164 combination mem[1]:4096 [ main::reg_mem_abs#0 ] 
Attempting to uplift remaining variables inzp[1]:17 [ main::default_zp_abs ]
Uplifting [main] best 164 combination zp[1]:17 [ main::default_zp_abs ] 
Attempting to uplift remaining variables inmem[1]:4097 [ main::default_mem_abs ]
Uplifting [main] best 164 combination mem[1]:4097 [ main::default_mem_abs ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test declaring a variable as "memory", meaning it will be stored in memory and accessed through an implicit pointer (using load/store)
  // Upstart
  // Commodore 64 PRG executable file
.file [name="declared-memory-var-6.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label SCREEN = $400
.segment Code
  // main
main: {
    .const reg_zp_flex = '.'
    .const reg_mem_flex = '.'
    .const default_default = '.'
    .const reg_default = '.'
    .const default_zp_flex = '.'
    .const default_mem_flex = '.'
    .label default_zp_abs = $11
    .label default_mem_abs = $1001
    .label reg_zp_abs = $10
    .label reg_mem_abs = $1000
    // [0] main::reg_zp_abs#0 = '.' -- vbuz1=vbuc1 
    lda #'.'
    sta.z reg_zp_abs
    // [1] main::reg_mem_abs#0 = '.' -- vbum1=vbuc1 
    lda #'.'
    sta reg_mem_abs
    // [2] main::default_zp_abs = '.' -- vbuz1=vbuc1 
    lda #'.'
    sta.z default_zp_abs
    // [3] main::default_mem_abs = '.' -- vbum1=vbuc1 
    lda #'.'
    sta default_mem_abs
    // [4] call out 
    // [24] phi from main to out [phi:main->out]
  out_from_main:
    // [24] phi i#27 = 0 [phi:main->out#0] -- vbuyy=vbuc1 
    ldy #0
    // [24] phi out::c#10 = main::reg_zp_flex [phi:main->out#1] -- vbuxx=vbuc1 
    ldx #reg_zp_flex
    jsr out
    jmp __b1
    // main::@1
  __b1:
    // [5] out::c#1 = main::reg_zp_abs#0 -- vbuxx=vbuz1 
    ldx.z reg_zp_abs
    // [6] call out 
    // [24] phi from main::@1 to out [phi:main::@1->out]
  out_from___b1:
    // [24] phi i#27 = i#11 [phi:main::@1->out#0] -- register_copy 
    // [24] phi out::c#10 = out::c#1 [phi:main::@1->out#1] -- register_copy 
    jsr out
    // [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [8] call out 
    // [24] phi from main::@2 to out [phi:main::@2->out]
  out_from___b2:
    // [24] phi i#27 = i#11 [phi:main::@2->out#0] -- register_copy 
    // [24] phi out::c#10 = main::reg_mem_flex [phi:main::@2->out#1] -- vbuxx=vbuc1 
    ldx #reg_mem_flex
    jsr out
    jmp __b3
    // main::@3
  __b3:
    // [9] out::c#3 = main::reg_mem_abs#0 -- vbuxx=vbum1 
    ldx reg_mem_abs
    // [10] call out 
    // [24] phi from main::@3 to out [phi:main::@3->out]
  out_from___b3:
    // [24] phi i#27 = i#11 [phi:main::@3->out#0] -- register_copy 
    // [24] phi out::c#10 = out::c#3 [phi:main::@3->out#1] -- register_copy 
    jsr out
    // [11] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  __b4_from___b3:
    jmp __b4
    // main::@4
  __b4:
    // [12] call out 
    // [24] phi from main::@4 to out [phi:main::@4->out]
  out_from___b4:
    // [24] phi i#27 = i#11 [phi:main::@4->out#0] -- register_copy 
    // [24] phi out::c#10 = main::default_default [phi:main::@4->out#1] -- vbuxx=vbuc1 
    ldx #default_default
    jsr out
    // [13] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    jmp __b5
    // main::@5
  __b5:
    // [14] call out 
    // [24] phi from main::@5 to out [phi:main::@5->out]
  out_from___b5:
    // [24] phi i#27 = i#11 [phi:main::@5->out#0] -- register_copy 
    // [24] phi out::c#10 = main::reg_default [phi:main::@5->out#1] -- vbuxx=vbuc1 
    ldx #reg_default
    jsr out
    // [15] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    jmp __b6
    // main::@6
  __b6:
    // [16] call out 
    // [24] phi from main::@6 to out [phi:main::@6->out]
  out_from___b6:
    // [24] phi i#27 = i#11 [phi:main::@6->out#0] -- register_copy 
    // [24] phi out::c#10 = main::default_zp_flex [phi:main::@6->out#1] -- vbuxx=vbuc1 
    ldx #default_zp_flex
    jsr out
    jmp __b7
    // main::@7
  __b7:
    // [17] out::c#7 = main::default_zp_abs -- vbuxx=vbuz1 
    ldx.z default_zp_abs
    // [18] call out 
    // [24] phi from main::@7 to out [phi:main::@7->out]
  out_from___b7:
    // [24] phi i#27 = i#11 [phi:main::@7->out#0] -- register_copy 
    // [24] phi out::c#10 = out::c#7 [phi:main::@7->out#1] -- register_copy 
    jsr out
    // [19] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  __b8_from___b7:
    jmp __b8
    // main::@8
  __b8:
    // [20] call out 
    // [24] phi from main::@8 to out [phi:main::@8->out]
  out_from___b8:
    // [24] phi i#27 = i#11 [phi:main::@8->out#0] -- register_copy 
    // [24] phi out::c#10 = main::default_mem_flex [phi:main::@8->out#1] -- vbuxx=vbuc1 
    ldx #default_mem_flex
    jsr out
    jmp __b9
    // main::@9
  __b9:
    // [21] out::c#9 = main::default_mem_abs -- vbuxx=vbum1 
    ldx default_mem_abs
    // [22] call out 
    // [24] phi from main::@9 to out [phi:main::@9->out]
  out_from___b9:
    // [24] phi i#27 = i#11 [phi:main::@9->out#0] -- register_copy 
    // [24] phi out::c#10 = out::c#9 [phi:main::@9->out#1] -- register_copy 
    jsr out
    jmp __breturn
    // main::@return
  __breturn:
    // [23] return 
    rts
}
  // out
// out(byte register(X) c)
out: {
    // [25] SCREEN[i#27] = out::c#10 -- pbuc1_derefidx_vbuyy=vbuxx 
    txa
    sta SCREEN,y
    // [26] i#11 = ++ i#27 -- vbuyy=_inc_vbuyy 
    iny
    jmp __breturn
    // out::@return
  __breturn:
    // [27] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #'.'
Removing instruction lda #'.'
Removing instruction lda #'.'
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b2_from___b1:
Removing instruction out_from___b2:
Removing instruction __b4_from___b3:
Removing instruction out_from___b4:
Removing instruction __b5_from___b4:
Removing instruction out_from___b5:
Removing instruction __b6_from___b5:
Removing instruction out_from___b6:
Removing instruction __b8_from___b7:
Removing instruction out_from___b8:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction out_from_main:
Removing instruction __b1:
Removing instruction out_from___b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction out_from___b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction out_from___b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction out_from___b9:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
constant byte* const SCREEN = (byte*) 1024
byte i
byte i#11 reg byte y 1.45
byte i#27 reg byte y 20.0
void main()
constant byte main::default_default = '.'
byte main::default_mem_abs loadstore !mem[-1]:4097 mem[1]:4097 0.2222222222222222
constant byte main::default_mem_flex = '.'
byte main::default_zp_abs loadstore !zp[-1]:17 zp[1]:17 0.26666666666666666
constant byte main::default_zp_flex = '.'
constant byte main::reg_default = '.'
byte main::reg_mem_abs !mem[-1]:4096
byte main::reg_mem_abs#0 reg_mem_abs !mem[-1]:4096 mem[1]:4096 0.5
constant byte main::reg_mem_flex = '.'
byte main::reg_zp_abs !zp[-1]:16
byte main::reg_zp_abs#0 reg_zp_abs !zp[-1]:16 zp[1]:16 0.8
constant byte main::reg_zp_flex = '.'
void out(byte out::c)
byte out::c
byte out::c#1 reg byte x 4.0
byte out::c#10 reg byte x 19.0
byte out::c#3 reg byte x 4.0
byte out::c#7 reg byte x 4.0
byte out::c#9 reg byte x 4.0

reg byte x [ out::c#10 out::c#1 out::c#3 out::c#7 out::c#9 ]
reg byte y [ i#27 i#11 ]
zp[1]:16 [ main::reg_zp_abs#0 ]
mem[1]:4096 [ main::reg_mem_abs#0 ]
zp[1]:17 [ main::default_zp_abs ]
mem[1]:4097 [ main::default_mem_abs ]


FINAL ASSEMBLER
Score: 125

  // File Comments
// Test declaring a variable as "memory", meaning it will be stored in memory and accessed through an implicit pointer (using load/store)
  // Upstart
  // Commodore 64 PRG executable file
.file [name="declared-memory-var-6.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label SCREEN = $400
.segment Code
  // main
main: {
    .const reg_zp_flex = '.'
    .const reg_mem_flex = '.'
    .const default_default = '.'
    .const reg_default = '.'
    .const default_zp_flex = '.'
    .const default_mem_flex = '.'
    .label default_zp_abs = $11
    .label default_mem_abs = $1001
    .label reg_zp_abs = $10
    .label reg_mem_abs = $1000
    // reg_zp_abs = '.'
    // [0] main::reg_zp_abs#0 = '.' -- vbuz1=vbuc1 
    lda #'.'
    sta.z reg_zp_abs
    // reg_mem_abs = '.'
    // [1] main::reg_mem_abs#0 = '.' -- vbum1=vbuc1 
    sta reg_mem_abs
    // default_zp_abs = '.'
    // [2] main::default_zp_abs = '.' -- vbuz1=vbuc1 
    sta.z default_zp_abs
    // default_mem_abs = '.'
    // [3] main::default_mem_abs = '.' -- vbum1=vbuc1 
    sta default_mem_abs
    // out(reg_zp_flex)
    // [4] call out 
    // [24] phi from main to out [phi:main->out]
    // [24] phi i#27 = 0 [phi:main->out#0] -- vbuyy=vbuc1 
    ldy #0
    // [24] phi out::c#10 = main::reg_zp_flex [phi:main->out#1] -- vbuxx=vbuc1 
    ldx #reg_zp_flex
    jsr out
    // main::@1
    // out(reg_zp_abs)
    // [5] out::c#1 = main::reg_zp_abs#0 -- vbuxx=vbuz1 
    ldx.z reg_zp_abs
    // [6] call out 
    // [24] phi from main::@1 to out [phi:main::@1->out]
    // [24] phi i#27 = i#11 [phi:main::@1->out#0] -- register_copy 
    // [24] phi out::c#10 = out::c#1 [phi:main::@1->out#1] -- register_copy 
    jsr out
    // [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // out(reg_mem_flex)
    // [8] call out 
    // [24] phi from main::@2 to out [phi:main::@2->out]
    // [24] phi i#27 = i#11 [phi:main::@2->out#0] -- register_copy 
    // [24] phi out::c#10 = main::reg_mem_flex [phi:main::@2->out#1] -- vbuxx=vbuc1 
    ldx #reg_mem_flex
    jsr out
    // main::@3
    // out(reg_mem_abs)
    // [9] out::c#3 = main::reg_mem_abs#0 -- vbuxx=vbum1 
    ldx reg_mem_abs
    // [10] call out 
    // [24] phi from main::@3 to out [phi:main::@3->out]
    // [24] phi i#27 = i#11 [phi:main::@3->out#0] -- register_copy 
    // [24] phi out::c#10 = out::c#3 [phi:main::@3->out#1] -- register_copy 
    jsr out
    // [11] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
    // main::@4
    // out(default_default)
    // [12] call out 
    // [24] phi from main::@4 to out [phi:main::@4->out]
    // [24] phi i#27 = i#11 [phi:main::@4->out#0] -- register_copy 
    // [24] phi out::c#10 = main::default_default [phi:main::@4->out#1] -- vbuxx=vbuc1 
    ldx #default_default
    jsr out
    // [13] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
    // main::@5
    // out(reg_default)
    // [14] call out 
    // [24] phi from main::@5 to out [phi:main::@5->out]
    // [24] phi i#27 = i#11 [phi:main::@5->out#0] -- register_copy 
    // [24] phi out::c#10 = main::reg_default [phi:main::@5->out#1] -- vbuxx=vbuc1 
    ldx #reg_default
    jsr out
    // [15] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // main::@6
    // out(default_zp_flex)
    // [16] call out 
    // [24] phi from main::@6 to out [phi:main::@6->out]
    // [24] phi i#27 = i#11 [phi:main::@6->out#0] -- register_copy 
    // [24] phi out::c#10 = main::default_zp_flex [phi:main::@6->out#1] -- vbuxx=vbuc1 
    ldx #default_zp_flex
    jsr out
    // main::@7
    // out(default_zp_abs)
    // [17] out::c#7 = main::default_zp_abs -- vbuxx=vbuz1 
    ldx.z default_zp_abs
    // [18] call out 
    // [24] phi from main::@7 to out [phi:main::@7->out]
    // [24] phi i#27 = i#11 [phi:main::@7->out#0] -- register_copy 
    // [24] phi out::c#10 = out::c#7 [phi:main::@7->out#1] -- register_copy 
    jsr out
    // [19] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
    // main::@8
    // out(default_mem_flex)
    // [20] call out 
    // [24] phi from main::@8 to out [phi:main::@8->out]
    // [24] phi i#27 = i#11 [phi:main::@8->out#0] -- register_copy 
    // [24] phi out::c#10 = main::default_mem_flex [phi:main::@8->out#1] -- vbuxx=vbuc1 
    ldx #default_mem_flex
    jsr out
    // main::@9
    // out(default_mem_abs)
    // [21] out::c#9 = main::default_mem_abs -- vbuxx=vbum1 
    ldx default_mem_abs
    // [22] call out 
    // [24] phi from main::@9 to out [phi:main::@9->out]
    // [24] phi i#27 = i#11 [phi:main::@9->out#0] -- register_copy 
    // [24] phi out::c#10 = out::c#9 [phi:main::@9->out#1] -- register_copy 
    jsr out
    // main::@return
    // }
    // [23] return 
    rts
}
  // out
// out(byte register(X) c)
out: {
    // SCREEN[i++] = c
    // [25] SCREEN[i#27] = out::c#10 -- pbuc1_derefidx_vbuyy=vbuxx 
    txa
    sta SCREEN,y
    // SCREEN[i++] = c;
    // [26] i#11 = ++ i#27 -- vbuyy=_inc_vbuyy 
    iny
    // out::@return
    // }
    // [27] return 
    rts
}
  // File Data

