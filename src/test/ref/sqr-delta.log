Inlined call call __init 

CONTROL FLOW GRAPH SSA

dword ifunc(dword ifunc::a)
ifunc: scope:[ifunc]  from main
  ifunc::a#2 = phi( main/ifunc::a#0 )
  ifunc::x#0 = 1
  ifunc::xsqr#0 = 1
  ifunc::delta#0 = 3
  to:ifunc::@1
ifunc::@1: scope:[ifunc]  from ifunc ifunc::@2
  ifunc::delta#3 = phi( ifunc/ifunc::delta#0, ifunc::@2/ifunc::delta#1 )
  ifunc::x#5 = phi( ifunc/ifunc::x#0, ifunc::@2/ifunc::x#1 )
  ifunc::a#1 = phi( ifunc/ifunc::a#2, ifunc::@2/ifunc::a#3 )
  ifunc::xsqr#2 = phi( ifunc/ifunc::xsqr#0, ifunc::@2/ifunc::xsqr#1 )
  ifunc::$0 = ifunc::xsqr#2 <= ifunc::a#1
  if(ifunc::$0) goto ifunc::@2
  to:ifunc::@3
ifunc::@2: scope:[ifunc]  from ifunc::@1
  ifunc::a#3 = phi( ifunc::@1/ifunc::a#1 )
  ifunc::delta#2 = phi( ifunc::@1/ifunc::delta#3 )
  ifunc::xsqr#3 = phi( ifunc::@1/ifunc::xsqr#2 )
  ifunc::x#3 = phi( ifunc::@1/ifunc::x#5 )
  ifunc::x#1 = ++ ifunc::x#3
  ifunc::xsqr#1 = ifunc::xsqr#3 + ifunc::delta#2
  ifunc::delta#1 = ifunc::delta#2 + 2
  to:ifunc::@1
ifunc::@3: scope:[ifunc]  from ifunc::@1
  ifunc::x#4 = phi( ifunc::@1/ifunc::x#5 )
  ifunc::x#2 = -- ifunc::x#4
  ifunc::return#0 = ifunc::x#2
  to:ifunc::@return
ifunc::@return: scope:[ifunc]  from ifunc::@3
  ifunc::return#3 = phi( ifunc::@3/ifunc::return#0 )
  ifunc::return#1 = ifunc::return#3
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  ifunc::a#0 = 8
  call ifunc 
  ifunc::return#2 = ifunc::return#1
  to:main::@1
main::@1: scope:[main]  from main
  ifunc::return#4 = phi( main/ifunc::return#2 )
  main::$0 = ifunc::return#4
  main::$1 = 0 * SIZEOF_DWORD
  SCREEN[main::$1] = main::$0
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
const dword* SCREEN = (dword*)$400
const byte SIZEOF_DWORD = 4
void __start()
label __start::@1
label __start::@2
label __start::@return
label __start::__init1
dword ifunc(dword ifunc::a)
bool~ ifunc::$0
label ifunc::@1
label ifunc::@2
label ifunc::@3
label ifunc::@return
dword ifunc::a
dword ifunc::a#0
dword ifunc::a#1
dword ifunc::a#2
dword ifunc::a#3
dword ifunc::delta
dword ifunc::delta#0
dword ifunc::delta#1
dword ifunc::delta#2
dword ifunc::delta#3
dword ifunc::return
dword ifunc::return#0
dword ifunc::return#1
dword ifunc::return#2
dword ifunc::return#3
dword ifunc::return#4
dword ifunc::x
dword ifunc::x#0
dword ifunc::x#1
dword ifunc::x#2
dword ifunc::x#3
dword ifunc::x#4
dword ifunc::x#5
dword ifunc::xsqr
dword ifunc::xsqr#0
dword ifunc::xsqr#1
dword ifunc::xsqr#2
dword ifunc::xsqr#3
void main()
dword~ main::$0
number~ main::$1
label main::@1
label main::@return

Adding number conversion cast (unumber) 2 in ifunc::delta#1 = ifunc::delta#2 + 2
Adding number conversion cast (unumber) 8 in ifunc::a#0 = 8
Adding number conversion cast (unumber) 0 in main::$1 = 0 * SIZEOF_DWORD
Adding number conversion cast (unumber) main::$1 in main::$1 = (unumber)0 * SIZEOF_DWORD
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast ifunc::a#0 = (unumber)8
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (dword*) 1024
Simplifying constant integer cast 2
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type 2
Finalized unsigned number type 8
Finalized unsigned number type 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in main::$1 = 0 * SIZEOF_DWORD
Alias ifunc::x#3 = ifunc::x#5 ifunc::x#4 
Alias ifunc::xsqr#2 = ifunc::xsqr#3 
Alias ifunc::delta#2 = ifunc::delta#3 
Alias ifunc::a#1 = ifunc::a#3 
Alias ifunc::return#0 = ifunc::x#2 ifunc::return#3 ifunc::return#1 
Alias ifunc::return#2 = ifunc::return#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values ifunc::a#2 ifunc::a#0
Identical Phi Values ifunc::a#1 ifunc::a#2
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition ifunc::$0 [6] if(ifunc::xsqr#2<=ifunc::a#0) goto ifunc::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [16] main::$1 = 0 * SIZEOF_DWORD
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant ifunc::x#0 = 1
Constant ifunc::xsqr#0 = 1
Constant ifunc::delta#0 = 3
Constant ifunc::a#0 = 8
Constant main::$1 = 0*SIZEOF_DWORD
Successful SSA optimization Pass2ConstantIdentification
Rewriting conditional comparison [6] if(ifunc::xsqr#2<=ifunc::a#0) goto ifunc::@2
Simplifying constant evaluating to zero 0*SIZEOF_DWORD in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero SCREEN in [17] SCREEN[main::$1] = main::$0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant main::$1
Eliminating unused constant SIZEOF_DWORD
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) ifunc::a#0+1 in [1] if(ifunc::xsqr#2<ifunc::a#0+1) goto ifunc::@2
Adding number conversion cast (unumber) 1 in [1] if(ifunc::xsqr#2<(unumber)ifunc::a#0+1) goto ifunc::@2
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast ifunc::a#0+(unumber)1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings ifunc::x#0
Inlining constant with var siblings ifunc::xsqr#0
Inlining constant with var siblings ifunc::delta#0
Constant inlined ifunc::xsqr#0 = 1
Constant inlined ifunc::delta#0 = 3
Constant inlined ifunc::x#0 = 1
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of main
Adding NOP phi() at start of ifunc
CALL GRAPH
Calls in [main] to ifunc:1 

Created 3 initial phi equivalence classes
Coalesced [14] ifunc::xsqr#4 = ifunc::xsqr#1
Coalesced [15] ifunc::x#6 = ifunc::x#1
Coalesced [16] ifunc::delta#4 = ifunc::delta#1
Coalesced down to 3 phi equivalence classes
Adding NOP phi() at start of main
Adding NOP phi() at start of ifunc

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call ifunc 
  [2] ifunc::return#2 = ifunc::return#0
  to:main::@1
main::@1: scope:[main]  from main
  [3] main::$0 = ifunc::return#2
  [4] *SCREEN = main::$0
  to:main::@return
main::@return: scope:[main]  from main::@1
  [5] return 
  to:@return

dword ifunc(dword ifunc::a)
ifunc: scope:[ifunc]  from main
  [6] phi()
  to:ifunc::@1
ifunc::@1: scope:[ifunc]  from ifunc ifunc::@2
  [7] ifunc::delta#2 = phi( ifunc/3, ifunc::@2/ifunc::delta#1 )
  [7] ifunc::x#3 = phi( ifunc/1, ifunc::@2/ifunc::x#1 )
  [7] ifunc::xsqr#2 = phi( ifunc/1, ifunc::@2/ifunc::xsqr#1 )
  [8] if(ifunc::xsqr#2<ifunc::a#0+1) goto ifunc::@2
  to:ifunc::@3
ifunc::@3: scope:[ifunc]  from ifunc::@1
  [9] ifunc::return#0 = -- ifunc::x#3
  to:ifunc::@return
ifunc::@return: scope:[ifunc]  from ifunc::@3
  [10] return 
  to:@return
ifunc::@2: scope:[ifunc]  from ifunc::@1
  [11] ifunc::x#1 = ++ ifunc::x#3
  [12] ifunc::xsqr#1 = ifunc::xsqr#2 + ifunc::delta#2
  [13] ifunc::delta#1 = ifunc::delta#2 + 2
  to:ifunc::@1


VARIABLE REGISTER WEIGHTS
dword ifunc(dword ifunc::a)
dword ifunc::a
dword ifunc::delta
dword ifunc::delta#1 202.0
dword ifunc::delta#2 75.75
dword ifunc::return
dword ifunc::return#0 4.333333333333333
dword ifunc::return#2 4.0
dword ifunc::x
dword ifunc::x#1 67.33333333333333
dword ifunc::x#3 106.5
dword ifunc::xsqr
dword ifunc::xsqr#1 101.0
dword ifunc::xsqr#2 101.0
void main()
dword~ main::$0 4.0

Initial phi equivalence classes
[ ifunc::xsqr#2 ifunc::xsqr#1 ]
[ ifunc::x#3 ifunc::x#1 ]
[ ifunc::delta#2 ifunc::delta#1 ]
Added variable ifunc::return#2 to live range equivalence class [ ifunc::return#2 ]
Added variable main::$0 to live range equivalence class [ main::$0 ]
Added variable ifunc::return#0 to live range equivalence class [ ifunc::return#0 ]
Complete equivalence classes
[ ifunc::xsqr#2 ifunc::xsqr#1 ]
[ ifunc::x#3 ifunc::x#1 ]
[ ifunc::delta#2 ifunc::delta#1 ]
[ ifunc::return#2 ]
[ main::$0 ]
[ ifunc::return#0 ]
Allocated zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ]
Allocated zp[4]:6 [ ifunc::x#3 ifunc::x#1 ]
Allocated zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ]
Allocated zp[4]:14 [ ifunc::return#2 ]
Allocated zp[4]:18 [ main::$0 ]
Allocated zp[4]:22 [ ifunc::return#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] ifunc::return#2 = ifunc::return#0 [ ifunc::return#2 ] (  [ ifunc::return#2 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Statement [3] main::$0 = ifunc::return#2 [ main::$0 ] (  [ main::$0 ] { }  ) always clobbers reg byte a 
Statement [4] *SCREEN = main::$0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] if(ifunc::xsqr#2<ifunc::a#0+1) goto ifunc::@2 [ ifunc::xsqr#2 ifunc::x#3 ifunc::delta#2 ] ( ifunc:1 [ ifunc::xsqr#2 ifunc::x#3 ifunc::delta#2 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Statement [9] ifunc::return#0 = -- ifunc::x#3 [ ifunc::return#0 ] ( ifunc:1 [ ifunc::return#0 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Statement [12] ifunc::xsqr#1 = ifunc::xsqr#2 + ifunc::delta#2 [ ifunc::delta#2 ifunc::xsqr#1 ifunc::x#1 ] ( ifunc:1 [ ifunc::delta#2 ifunc::xsqr#1 ifunc::x#1 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Statement [13] ifunc::delta#1 = ifunc::delta#2 + 2 [ ifunc::xsqr#1 ifunc::x#1 ifunc::delta#1 ] ( ifunc:1 [ ifunc::xsqr#1 ifunc::x#1 ifunc::delta#1 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Potential registers zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ] : zp[4]:2 , 
Potential registers zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] : zp[4]:6 , 
Potential registers zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ] : zp[4]:10 , 
Potential registers zp[4]:14 [ ifunc::return#2 ] : zp[4]:14 , 
Potential registers zp[4]:18 [ main::$0 ] : zp[4]:18 , 
Potential registers zp[4]:22 [ ifunc::return#0 ] : zp[4]:22 , 

REGISTER UPLIFT SCOPES
Uplift Scope [ifunc] 277.75: zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ] 202: zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ] 173.83: zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] 4.33: zp[4]:22 [ ifunc::return#0 ] 4: zp[4]:14 [ ifunc::return#2 ] 
Uplift Scope [main] 4: zp[4]:18 [ main::$0 ] 
Uplift Scope [] 

Uplifting [ifunc] best 2182 combination zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ] zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ] zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] zp[4]:22 [ ifunc::return#0 ] zp[4]:14 [ ifunc::return#2 ] 
Uplifting [main] best 2182 combination zp[4]:18 [ main::$0 ] 
Uplifting [] best 2182 combination 
Coalescing zero page register [ zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] ] with [ zp[4]:22 [ ifunc::return#0 ] ] - score: 1
Coalescing zero page register [ zp[4]:14 [ ifunc::return#2 ] ] with [ zp[4]:18 [ main::$0 ] ] - score: 1
Coalescing zero page register [ zp[4]:6 [ ifunc::x#3 ifunc::x#1 ifunc::return#0 ] ] with [ zp[4]:14 [ ifunc::return#2 main::$0 ] ] - score: 1

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // main
main: {
    .label __0 = 6
    // [1] call ifunc 
    // [6] phi from main to ifunc [phi:main->ifunc]
  ifunc_from_main:
    jsr ifunc
    // [2] ifunc::return#2 = ifunc::return#0
    jmp __b1
    // main::@1
  __b1:
    // [3] main::$0 = ifunc::return#2
    // [4] *SCREEN = main::$0 -- _deref_pduc1=vduz1 
    lda.z __0
    sta SCREEN
    lda.z __0+1
    sta SCREEN+1
    lda.z __0+2
    sta SCREEN+2
    lda.z __0+3
    sta SCREEN+3
    jmp __breturn
    // main::@return
  __breturn:
    // [5] return 
    rts
}
  // ifunc
ifunc: {
    .const a = 8
    .label x = 6
    .label xsqr = 2
    .label delta = $a
    .label return = 6
    // [7] phi from ifunc to ifunc::@1 [phi:ifunc->ifunc::@1]
  __b1_from_ifunc:
    // [7] phi ifunc::delta#2 = 3 [phi:ifunc->ifunc::@1#0] -- vduz1=vduc1 
    lda #<3
    sta.z delta
    lda #>3
    sta.z delta+1
    lda #<3>>$10
    sta.z delta+2
    lda #>3>>$10
    sta.z delta+3
    // [7] phi ifunc::x#3 = 1 [phi:ifunc->ifunc::@1#1] -- vduz1=vduc1 
    lda #<1
    sta.z x
    lda #>1
    sta.z x+1
    lda #<1>>$10
    sta.z x+2
    lda #>1>>$10
    sta.z x+3
    // [7] phi ifunc::xsqr#2 = 1 [phi:ifunc->ifunc::@1#2] -- vduz1=vduc1 
    lda #<1
    sta.z xsqr
    lda #>1
    sta.z xsqr+1
    lda #<1>>$10
    sta.z xsqr+2
    lda #>1>>$10
    sta.z xsqr+3
    jmp __b1
    // ifunc::@1
  __b1:
    // [8] if(ifunc::xsqr#2<ifunc::a#0+1) goto ifunc::@2 -- vduz1_lt_vduc1_then_la1 
    lda.z xsqr+3
    cmp #>a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+2
    cmp #<a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+1
    cmp #>a+1
    bcc __b2
    bne !+
    lda.z xsqr
    cmp #<a+1
    bcc __b2
  !:
    jmp __b3
    // ifunc::@3
  __b3:
    // [9] ifunc::return#0 = -- ifunc::x#3 -- vduz1=_dec_vduz1 
    lda.z return
    sec
    sbc #1
    sta.z return
    lda.z return+1
    sbc #0
    sta.z return+1
    lda.z return+2
    sbc #0
    sta.z return+2
    lda.z return+3
    sbc #0
    sta.z return+3
    jmp __breturn
    // ifunc::@return
  __breturn:
    // [10] return 
    rts
    // ifunc::@2
  __b2:
    // [11] ifunc::x#1 = ++ ifunc::x#3 -- vduz1=_inc_vduz1 
    inc.z x
    bne !+
    inc.z x+1
    bne !+
    inc.z x+2
    bne !+
    inc.z x+3
  !:
    // [12] ifunc::xsqr#1 = ifunc::xsqr#2 + ifunc::delta#2 -- vduz1=vduz1_plus_vduz2 
    lda.z xsqr
    clc
    adc.z delta
    sta.z xsqr
    lda.z xsqr+1
    adc.z delta+1
    sta.z xsqr+1
    lda.z xsqr+2
    adc.z delta+2
    sta.z xsqr+2
    lda.z xsqr+3
    adc.z delta+3
    sta.z xsqr+3
    // [13] ifunc::delta#1 = ifunc::delta#2 + 2 -- vduz1=vduz1_plus_vbuc1 
    lda.z delta
    clc
    adc #2
    sta.z delta
    bcc !+
    inc.z delta+1
    bne !+
    inc.z delta+2
    bne !+
    inc.z delta+3
  !:
    // [7] phi from ifunc::@2 to ifunc::@1 [phi:ifunc::@2->ifunc::@1]
  __b1_from___b2:
    // [7] phi ifunc::delta#2 = ifunc::delta#1 [phi:ifunc::@2->ifunc::@1#0] -- register_copy 
    // [7] phi ifunc::x#3 = ifunc::x#1 [phi:ifunc::@2->ifunc::@1#1] -- register_copy 
    // [7] phi ifunc::xsqr#2 = ifunc::xsqr#1 [phi:ifunc::@2->ifunc::@1#2] -- register_copy 
    jmp __b1
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ifunc_from_main:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b1_from_ifunc:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
const dword* SCREEN = (dword*) 1024
dword ifunc(dword ifunc::a)
label ifunc::@1
label ifunc::@2
label ifunc::@3
label ifunc::@return
dword ifunc::a
const dword ifunc::a#0 a = 8
dword ifunc::delta
dword ifunc::delta#1 delta zp[4]:10 202.0
dword ifunc::delta#2 delta zp[4]:10 75.75
dword ifunc::return
dword ifunc::return#0 return zp[4]:6 4.333333333333333
dword ifunc::return#2 return zp[4]:6 4.0
dword ifunc::x
dword ifunc::x#1 x zp[4]:6 67.33333333333333
dword ifunc::x#3 x zp[4]:6 106.5
dword ifunc::xsqr
dword ifunc::xsqr#1 xsqr zp[4]:2 101.0
dword ifunc::xsqr#2 xsqr zp[4]:2 101.0
void main()
dword~ main::$0 zp[4]:6 4.0
label main::@1
label main::@return

zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ]
zp[4]:6 [ ifunc::x#3 ifunc::x#1 ifunc::return#0 ifunc::return#2 main::$0 ]
zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ]


FINAL ASSEMBLER
Score: 2065

  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // main
main: {
    .label __0 = 6
    // ifunc(8)
    // [1] call ifunc 
    // [6] phi from main to ifunc [phi:main->ifunc]
    jsr ifunc
    // ifunc(8)
    // [2] ifunc::return#2 = ifunc::return#0
    // main::@1
    // [3] main::$0 = ifunc::return#2
    // SCREEN[0] = ifunc(8)
    // [4] *SCREEN = main::$0 -- _deref_pduc1=vduz1 
    lda.z __0
    sta SCREEN
    lda.z __0+1
    sta SCREEN+1
    lda.z __0+2
    sta SCREEN+2
    lda.z __0+3
    sta SCREEN+3
    // main::@return
    // }
    // [5] return 
    rts
}
  // ifunc
ifunc: {
    .const a = 8
    .label x = 6
    .label xsqr = 2
    .label delta = $a
    .label return = 6
    // [7] phi from ifunc to ifunc::@1 [phi:ifunc->ifunc::@1]
    // [7] phi ifunc::delta#2 = 3 [phi:ifunc->ifunc::@1#0] -- vduz1=vduc1 
    lda #<3
    sta.z delta
    lda #>3
    sta.z delta+1
    lda #<3>>$10
    sta.z delta+2
    lda #>3>>$10
    sta.z delta+3
    // [7] phi ifunc::x#3 = 1 [phi:ifunc->ifunc::@1#1] -- vduz1=vduc1 
    lda #<1
    sta.z x
    lda #>1
    sta.z x+1
    lda #<1>>$10
    sta.z x+2
    lda #>1>>$10
    sta.z x+3
    // [7] phi ifunc::xsqr#2 = 1 [phi:ifunc->ifunc::@1#2] -- vduz1=vduc1 
    lda #<1
    sta.z xsqr
    lda #>1
    sta.z xsqr+1
    lda #<1>>$10
    sta.z xsqr+2
    lda #>1>>$10
    sta.z xsqr+3
    // ifunc::@1
  __b1:
    // while(xsqr <=a)
    // [8] if(ifunc::xsqr#2<ifunc::a#0+1) goto ifunc::@2 -- vduz1_lt_vduc1_then_la1 
    lda.z xsqr+3
    cmp #>a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+2
    cmp #<a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+1
    cmp #>a+1
    bcc __b2
    bne !+
    lda.z xsqr
    cmp #<a+1
    bcc __b2
  !:
    // ifunc::@3
    // return --x;
    // [9] ifunc::return#0 = -- ifunc::x#3 -- vduz1=_dec_vduz1 
    lda.z return
    sec
    sbc #1
    sta.z return
    lda.z return+1
    sbc #0
    sta.z return+1
    lda.z return+2
    sbc #0
    sta.z return+2
    lda.z return+3
    sbc #0
    sta.z return+3
    // ifunc::@return
    // }
    // [10] return 
    rts
    // ifunc::@2
  __b2:
    // ++x;
    // [11] ifunc::x#1 = ++ ifunc::x#3 -- vduz1=_inc_vduz1 
    inc.z x
    bne !+
    inc.z x+1
    bne !+
    inc.z x+2
    bne !+
    inc.z x+3
  !:
    // xsqr += delta
    // [12] ifunc::xsqr#1 = ifunc::xsqr#2 + ifunc::delta#2 -- vduz1=vduz1_plus_vduz2 
    lda.z xsqr
    clc
    adc.z delta
    sta.z xsqr
    lda.z xsqr+1
    adc.z delta+1
    sta.z xsqr+1
    lda.z xsqr+2
    adc.z delta+2
    sta.z xsqr+2
    lda.z xsqr+3
    adc.z delta+3
    sta.z xsqr+3
    // delta += 2
    // [13] ifunc::delta#1 = ifunc::delta#2 + 2 -- vduz1=vduz1_plus_vbuc1 
    lda.z delta
    clc
    adc #2
    sta.z delta
    bcc !+
    inc.z delta+1
    bne !+
    inc.z delta+2
    bne !+
    inc.z delta+3
  !:
    // [7] phi from ifunc::@2 to ifunc::@1 [phi:ifunc::@2->ifunc::@1]
    // [7] phi ifunc::delta#2 = ifunc::delta#1 [phi:ifunc::@2->ifunc::@1#0] -- register_copy 
    // [7] phi ifunc::x#3 = ifunc::x#1 [phi:ifunc::@2->ifunc::@1#1] -- register_copy 
    // [7] phi ifunc::xsqr#2 = ifunc::xsqr#1 [phi:ifunc::@2->ifunc::@1#2] -- register_copy 
    jmp __b1
}
  // File Data

