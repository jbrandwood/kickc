// Library Implementation of the Seriously Fast Multiplication
// See http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
// Utilizes the fact that a*b = ((a+b)/2)^2 - ((a-b)/2)^2

// mul_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
// <f(x) = <(( x * x )/4)
byte[512] align($100) mul_sqr1_lo;
// >f(x) = >(( x * x )/4)
byte[512] align($100) mul_sqr1_hi;
// <g(x) =  <((( x - 255) * ( x - 255 ))/4)
byte[512] align($100) mul_sqr2_lo;
// >g(x) = >((( x - 255) * ( x - 255 ))/4)
byte[512] align($100) mul_sqr2_hi;

// Initialize the mul_sqr multiplication tables with f(x)=int(x*x/4)
void init_multiply() {
  // Fill mul_sqr1 = f(x) = int(x*x/4): If f(x) = x*x/4 then f(x+1) = f(x) + x/2 + 1/4
  word sqr = 0; // sqr = (x*x)/4
  byte x_2 = 0; // x/2
  byte c = 0;   // Counter used for determining x%2==0
  byte* sqr1_hi = mul_sqr1_hi+1;
  for(byte* sqr1_lo = mul_sqr1_lo+1; sqr1_lo!=mul_sqr1_lo+512; sqr1_lo++) {
    if((++c&1)==0) {
        x_2++; // increase i/2 on even numbers
        sqr++; // sqr++ on even numbers because 1 = 2*1/4 (from the two previous numbers) + 1/2 (half of the previous uneven number)
    }
    *sqr1_lo = <sqr;
    *sqr1_hi++ = >sqr;
    sqr = sqr + x_2; // sqr = sqr + i/2 (when uneven the 1/2 is not added here - see above)
  }
  // Fill mul_sqr2 = g(x) = f(x-255) : If x-255<0 then g(x)=f(255-x) (because x*x = -x*-x)
  // g(0) = f(255), g(1) = f(254), ..., g(254) = f(1), g(255) = f(0), g(256) = f(1), ..., g(510) = f(255), g(511) = f(256)
  byte x_255 = (byte)-1; //Start with g(0)=f(255)
  byte dir = $ff;  // Decrease or increase x_255 - initially we decrease
  byte* sqr2_hi = mul_sqr2_hi;
  for(byte* sqr2_lo = mul_sqr2_lo; sqr2_lo!=mul_sqr2_lo+511; sqr2_lo++) {
    *sqr2_lo = mul_sqr1_lo[x_255];
    *sqr2_hi++ = mul_sqr1_hi[x_255];
    x_255 = x_255 + dir;
    if(x_255==0) {
      dir = 1; // when x_255=0 then start counting up
    }
  }
  // Set the very last value g(511) = f(256)
  *(mul_sqr2_lo+511) = *(mul_sqr1_lo+256);
  *(mul_sqr2_hi+511) = *(mul_sqr1_hi+256);
}

// Fast multiply two unsigned bytes to a word result
word multiply(byte a, byte b) {
    const byte* memA = $fe;
    const byte* memB = $ff;
    *memA = a;
    *memB = b;
    asm {
        lda memA
        sta sm1+1
        sta sm3+1
        eor #$ff
        sta sm2+1
        sta sm4+1
        ldx memB
        sec
    sm1:
        lda mul_sqr1_lo,x
    sm2:
        sbc mul_sqr2_lo,x
        sta memA
    sm3:
        lda mul_sqr1_hi,x
    sm4:
        sbc mul_sqr2_hi,x
        sta memB
    }
    return { *memB, *memA };
}