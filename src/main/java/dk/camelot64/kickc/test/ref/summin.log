byte s1=sum(1,2);
byte s2=sum(9,13);
byte s3=s1+s2;
byte sum(byte a, byte b) {
  return a+b;
}

PROGRAM
  (byte~) $0 ← call sum (byte) 1 (byte) 2 
  (byte) s1 ← (byte~) $0
  (byte~) $1 ← call sum (byte) 9 (byte) 13 
  (byte) s2 ← (byte~) $1
  (byte~) $2 ← (byte) s1 + (byte) s2
  (byte) s3 ← (byte~) $2
  proc (byte()) sum((byte) sum::a , (byte) sum::b)
  (byte~) sum::$0 ← (byte) sum::a + (byte) sum::b
  (byte) sum::return ← (byte~) sum::$0
  goto sum::@return
sum::@return:
  (byte) sum::return ← (byte) sum::return
  return (byte) sum::return
  endproc // sum()

SYMBOLS
(byte~) $0
(byte~) $1
(byte~) $2
(byte) s1
(byte) s2
(byte) s3
(byte()) sum((byte) sum::a , (byte) sum::b)
(byte~) sum::$0
(label) sum::@return
(byte) sum::a
(byte) sum::b
(byte) sum::return

INITIAL CONTROL FLOW GRAPH
@BEGIN: from
  (byte~) $0 ← call sum (byte) 1 (byte) 2 
  (byte) s1 ← (byte~) $0
  (byte~) $1 ← call sum (byte) 9 (byte) 13 
  (byte) s2 ← (byte~) $1
  (byte~) $2 ← (byte) s1 + (byte) s2
  (byte) s3 ← (byte~) $2
  to:@1
sum: from
  (byte~) sum::$0 ← (byte) sum::a + (byte) sum::b
  (byte) sum::return ← (byte~) sum::$0
  to:sum::@return
sum::@return: from sum sum::@1
  (byte) sum::return ← (byte) sum::return
  return (byte) sum::return
  to:@RETURN
sum::@1: from
  to:sum::@return
@1: from @BEGIN
  to:@END
@END: from @1

Removing empty block sum::@1
Removing empty block @1
CONTROL FLOW GRAPH
@BEGIN: from
  (byte~) $0 ← call sum (byte) 1 (byte) 2 
  (byte) s1 ← (byte~) $0
  (byte~) $1 ← call sum (byte) 9 (byte) 13 
  (byte) s2 ← (byte~) $1
  (byte~) $2 ← (byte) s1 + (byte) s2
  (byte) s3 ← (byte~) $2
  to:@END
sum: from
  (byte~) sum::$0 ← (byte) sum::a + (byte) sum::b
  (byte) sum::return ← (byte~) sum::$0
  to:sum::@return
sum::@return: from sum
  (byte) sum::return ← (byte) sum::return
  return (byte) sum::return
  to:@RETURN
@END: from @BEGIN

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@BEGIN: from
  (byte) sum::a ← (byte) 1
  (byte) sum::b ← (byte) 2
  (byte) sum::return ← call sum param-assignment
  to:@2
@2: from @BEGIN
  (byte~) $0 ← (byte) sum::return
  (byte) s1 ← (byte~) $0
  (byte) sum::a ← (byte) 9
  (byte) sum::b ← (byte) 13
  (byte) sum::return ← call sum param-assignment
  to:@3
@3: from @2
  (byte~) $1 ← (byte) sum::return
  (byte) s2 ← (byte~) $1
  (byte~) $2 ← (byte) s1 + (byte) s2
  (byte) s3 ← (byte~) $2
  to:@END
sum: from @2 @BEGIN
  (byte~) sum::$0 ← (byte) sum::a + (byte) sum::b
  (byte) sum::return ← (byte~) sum::$0
  to:sum::@return
sum::@return: from sum
  (byte) sum::return ← (byte) sum::return
  return (byte) sum::return
  to:@RETURN
@END: from @3

Completing Phi functions...
CONTROL FLOW GRAPH SSA
@BEGIN: from
  (byte) sum::a#0 ← (byte) 1
  (byte) sum::b#0 ← (byte) 2
  (byte) sum::return#0 ← call sum param-assignment
  to:@2
@2: from @BEGIN
  (byte) sum::return#4 ← phi( @BEGIN/(byte) sum::return#0 )
  (byte~) $0 ← (byte) sum::return#4
  (byte) s1#0 ← (byte~) $0
  (byte) sum::a#1 ← (byte) 9
  (byte) sum::b#1 ← (byte) 13
  (byte) sum::return#1 ← call sum param-assignment
  to:@3
@3: from @2
  (byte) s1#1 ← phi( @2/(byte) s1#0 )
  (byte) sum::return#5 ← phi( @2/(byte) sum::return#1 )
  (byte~) $1 ← (byte) sum::return#5
  (byte) s2#0 ← (byte~) $1
  (byte~) $2 ← (byte) s1#1 + (byte) s2#0
  (byte) s3#0 ← (byte~) $2
  to:@END
sum: from @2 @BEGIN
  (byte) sum::b#2 ← phi( @2/(byte) sum::b#1 @BEGIN/(byte) sum::b#0 )
  (byte) sum::a#2 ← phi( @2/(byte) sum::a#1 @BEGIN/(byte) sum::a#0 )
  (byte~) sum::$0 ← (byte) sum::a#2 + (byte) sum::b#2
  (byte) sum::return#2 ← (byte~) sum::$0
  to:sum::@return
sum::@return: from sum
  (byte) sum::return#6 ← phi( sum/(byte) sum::return#2 )
  (byte) sum::return#3 ← (byte) sum::return#6
  return (byte) sum::return#3
  to:@RETURN
@END: from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@BEGIN: from
  (byte) sum::a#0 ← (byte) 1
  (byte) sum::b#0 ← (byte) 2
  call sum param-assignment
  (byte) sum::return#0 ← (byte) sum::return#3
  to:@2
@2: from @BEGIN
  (byte) sum::return#4 ← phi( @BEGIN/(byte) sum::return#0 )
  (byte~) $0 ← (byte) sum::return#4
  (byte) s1#0 ← (byte~) $0
  (byte) sum::a#1 ← (byte) 9
  (byte) sum::b#1 ← (byte) 13
  call sum param-assignment
  (byte) sum::return#1 ← (byte) sum::return#3
  to:@3
@3: from @2
  (byte) s1#1 ← phi( @2/(byte) s1#0 )
  (byte) sum::return#5 ← phi( @2/(byte) sum::return#1 )
  (byte~) $1 ← (byte) sum::return#5
  (byte) s2#0 ← (byte~) $1
  (byte~) $2 ← (byte) s1#1 + (byte) s2#0
  (byte) s3#0 ← (byte~) $2
  to:@END
sum: from @2 @BEGIN
  (byte) sum::b#2 ← phi( @2/(byte) sum::b#1 @BEGIN/(byte) sum::b#0 )
  (byte) sum::a#2 ← phi( @2/(byte) sum::a#1 @BEGIN/(byte) sum::a#0 )
  (byte~) sum::$0 ← (byte) sum::a#2 + (byte) sum::b#2
  (byte) sum::return#2 ← (byte~) sum::$0
  to:sum::@return
sum::@return: from sum
  (byte) sum::return#6 ← phi( sum/(byte) sum::return#2 )
  (byte) sum::return#3 ← (byte) sum::return#6
  return 
  to:@RETURN
@END: from @3

Constant (byte) sum::a#0 (byte) 1
Constant (byte) sum::b#0 (byte) 2
Constant (byte) sum::a#1 (byte) 9
Constant (byte) sum::b#1 (byte) 13
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  call sum param-assignment
  (byte) sum::return#0 ← (byte) sum::return#3
  to:@2
@2: from @BEGIN
  (byte) sum::return#4 ← phi( @BEGIN/(byte) sum::return#0 )
  (byte~) $0 ← (byte) sum::return#4
  (byte) s1#0 ← (byte~) $0
  call sum param-assignment
  (byte) sum::return#1 ← (byte) sum::return#3
  to:@3
@3: from @2
  (byte) s1#1 ← phi( @2/(byte) s1#0 )
  (byte) sum::return#5 ← phi( @2/(byte) sum::return#1 )
  (byte~) $1 ← (byte) sum::return#5
  (byte) s2#0 ← (byte~) $1
  (byte~) $2 ← (byte) s1#1 + (byte) s2#0
  (byte) s3#0 ← (byte~) $2
  to:@END
sum: from @2 @BEGIN
  (byte) sum::b#2 ← phi( @2/(byte) 13 @BEGIN/(byte) 2 )
  (byte) sum::a#2 ← phi( @2/(byte) 9 @BEGIN/(byte) 1 )
  (byte~) sum::$0 ← (byte) sum::a#2 + (byte) sum::b#2
  (byte) sum::return#2 ← (byte~) sum::$0
  to:sum::@return
sum::@return: from sum
  (byte) sum::return#6 ← phi( sum/(byte) sum::return#2 )
  (byte) sum::return#3 ← (byte) sum::return#6
  return 
  to:@RETURN
@END: from @3

Not aliassing across scopes: $0 sum::return#4
Not aliassing across scopes: $1 sum::return#5
Alias (byte) sum::return#0 = (byte) sum::return#3 (byte) sum::return#4 (byte) sum::return#1 (byte) sum::return#5 (byte) sum::return#2 (byte~) sum::$0 (byte) sum::return#6 
Alias (byte) s1#0 = (byte~) $0 (byte) s1#1 
Alias (byte) s2#0 = (byte~) $1 
Alias (byte) s3#0 = (byte~) $2 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call sum param-assignment
  to:@2
@2: from @BEGIN
  (byte) s1#0 ← (byte) sum::return#0
  call sum param-assignment
  to:@3
@3: from @2
  (byte) s2#0 ← (byte) sum::return#0
  (byte) s3#0 ← (byte) s1#0 + (byte) s2#0
  to:@END
sum: from @2 @BEGIN
  (byte) sum::b#2 ← phi( @2/(byte) 13 @BEGIN/(byte) 2 )
  (byte) sum::a#2 ← phi( @2/(byte) 9 @BEGIN/(byte) 1 )
  (byte) sum::return#0 ← (byte) sum::a#2 + (byte) sum::b#2
  to:sum::@return
sum::@return: from sum
  return 
  to:@RETURN
@END: from @3

Not aliassing across scopes: s1#0 sum::return#0
Not aliassing across scopes: s2#0 sum::return#0
Block Sequence Planned @BEGIN @2 @3 @END sum sum::@return 
Block Sequence Planned @BEGIN @2 @3 @END sum sum::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@BEGIN: from
  call sum param-assignment
  to:@2
@2: from @BEGIN
  (byte) s1#0 ← (byte) sum::return#0
  call sum param-assignment
  to:@3
@3: from @2
  (byte) s2#0 ← (byte) sum::return#0
  (byte) s3#0 ← (byte) s1#0 + (byte) s2#0
  to:@END
@END: from @3
sum: from @2 @BEGIN
  (byte) sum::b#2 ← phi( @2/(byte) 13 @BEGIN/(byte) 2 )
  (byte) sum::a#2 ← phi( @2/(byte) 9 @BEGIN/(byte) 1 )
  (byte) sum::return#0 ← (byte) sum::a#2 + (byte) sum::b#2
  to:sum::@return
sum::@return: from sum
  return 
  to:@RETURN

Adding empty live range for unused variable s3#0
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@BEGIN: from
  [0] call sum param-assignment [ sum::return#0 s1#0 ]
  to:@2
@2: from @BEGIN
  [1] (byte) s1#0 ← (byte) sum::return#0 [ sum::return#0 s1#0 ]
  [2] call sum param-assignment [ sum::return#0 s1#0 ]
  to:@3
@3: from @2
  [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ]
  [4] (byte) s3#0 ← (byte) s1#0 + (byte) s2#0 [ ]
  to:@END
@END: from @3
sum: from @2 @BEGIN
  [5] (byte) sum::b#2 ← phi( @2/(byte) 13 @BEGIN/(byte) 2 ) [ s1#0 sum::a#2 sum::b#2 ]
  [5] (byte) sum::a#2 ← phi( @2/(byte) 9 @BEGIN/(byte) 1 ) [ s1#0 sum::a#2 sum::b#2 ]
  [6] (byte) sum::return#0 ← (byte) sum::a#2 + (byte) sum::b#2 [ sum::return#0 s1#0 ]
  to:sum::@return
sum::@return: from sum
  [7] return  [ sum::return#0 s1#0 ]
  to:@RETURN

Created 2 initial phi equivalence classes
Coalesced down to 2 phi equivalence classes
Block Sequence Planned @BEGIN @2 @3 @END sum sum::@return 
Adding empty live range for unused variable s3#0
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@BEGIN: from
  [0] call sum param-assignment [ sum::return#0 s1#0 ]
  to:@2
@2: from @BEGIN
  [1] (byte) s1#0 ← (byte) sum::return#0 [ sum::return#0 s1#0 ]
  [2] call sum param-assignment [ sum::return#0 s1#0 ]
  to:@3
@3: from @2
  [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ]
  [4] (byte) s3#0 ← (byte) s1#0 + (byte) s2#0 [ ]
  to:@END
@END: from @3
sum: from @2 @BEGIN
  [5] (byte) sum::b#2 ← phi( @2/(byte) 13 @BEGIN/(byte) 2 ) [ s1#0 sum::a#2 sum::b#2 ]
  [5] (byte) sum::a#2 ← phi( @2/(byte) 9 @BEGIN/(byte) 1 ) [ s1#0 sum::a#2 sum::b#2 ]
  [6] (byte) sum::return#0 ← (byte) sum::a#2 + (byte) sum::b#2 [ sum::return#0 s1#0 ]
  to:sum::@return
sum::@return: from sum
  [7] return  [ sum::return#0 s1#0 ]
  to:@RETURN

CALL GRAPH
Calls in [] to 0:sum 2:sum 

DOMINATORS
@BEGIN dominated by  @BEGIN 
@2 dominated by  @BEGIN @2 
@3 dominated by  @BEGIN @2 @3 
@END dominated by  @BEGIN @2 @3 @END 
sum dominated by  @BEGIN sum 
sum::@return dominated by  @BEGIN sum::@return sum 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [sum]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(byte) s1
(byte) s1#0 0.5714285714285714
(byte) s2
(byte) s2#0 4.0
(byte) s3
(byte) s3#0 Infinity
(byte()) sum((byte) sum::a , (byte) sum::b)
(byte) sum::a
(byte) sum::a#2 2.0
(byte) sum::b
(byte) sum::b#2 2.0
(byte) sum::return
(byte) sum::return#0 1.2000000000000002

Initial phi equivalence classes
[ sum::a#2 ]
[ sum::b#2 ]
Added variable s1#0 to zero page equivalence class [ s1#0 ]
Added variable s2#0 to zero page equivalence class [ s2#0 ]
Added variable s3#0 to zero page equivalence class [ s3#0 ]
Added variable sum::return#0 to zero page equivalence class [ sum::return#0 ]
Complete equivalence classes
[ sum::a#2 ]
[ sum::b#2 ]
[ s1#0 ]
[ s2#0 ]
[ s3#0 ]
[ sum::return#0 ]
Allocated zp byte:2 to zp byte:2 [ sum::a#2 ]
Allocated zp byte:3 to zp byte:3 [ sum::b#2 ]
Allocated zp byte:4 to zp byte:4 [ s1#0 ]
Allocated zp byte:5 to zp byte:5 [ s2#0 ]
Allocated zp byte:6 to zp byte:6 [ s3#0 ]
Allocated zp byte:7 to zp byte:7 [ sum::return#0 ]
INITIAL ASM
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call sum param-assignment [ sum::return#0 s1#0 ]
//SEG2 [5] phi from @BEGIN to sum
sum_from_BBEGIN:
//SEG3 [5] phi (byte) sum::b#2 = (byte) 2 -- zpby1=coby1 
  lda #2
  sta 3
//SEG4 [5] phi (byte) sum::a#2 = (byte) 1 -- zpby1=coby1 
  lda #1
  sta 2
  jsr sum
  jmp B2
//SEG5 @2
B2:
//SEG6 [1] (byte) s1#0 ← (byte) sum::return#0 [ sum::return#0 s1#0 ] -- zpby1=zpby2 
  lda 7
  sta 4
//SEG7 [2] call sum param-assignment [ sum::return#0 s1#0 ]
//SEG8 [5] phi from @2 to sum
sum_from_B2:
//SEG9 [5] phi (byte) sum::b#2 = (byte) 13 -- zpby1=coby1 
  lda #13
  sta 3
//SEG10 [5] phi (byte) sum::a#2 = (byte) 9 -- zpby1=coby1 
  lda #9
  sta 2
  jsr sum
  jmp B3
//SEG11 @3
B3:
//SEG12 [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ] -- zpby1=zpby2 
  lda 7
  sta 5
//SEG13 [4] (byte) s3#0 ← (byte) s1#0 + (byte) s2#0 [ ] -- zpby1=zpby2_plus_zpby3 
  lda 4
  clc
  adc 5
  sta 6
  jmp BEND
//SEG14 @END
BEND:
//SEG15 sum
sum:
//SEG16 [6] (byte) sum::return#0 ← (byte) sum::a#2 + (byte) sum::b#2 [ sum::return#0 s1#0 ] -- zpby1=zpby2_plus_zpby3 
  lda 2
  clc
  adc 3
  sta 7
  jmp sum__Breturn
//SEG17 sum::@return
sum__Breturn:
//SEG18 [7] return  [ sum::return#0 s1#0 ]
  rts

REGISTER UPLIFT SCOPES
Uplift Scope [] ∞: zp byte:6 [ s3#0 ] 4: zp byte:5 [ s2#0 ] 0.57: zp byte:4 [ s1#0 ] 
Uplift Scope [sum] 2: zp byte:2 [ sum::a#2 ] 2: zp byte:3 [ sum::b#2 ] 1.2: zp byte:7 [ sum::return#0 ] 

Uplift attempt [] 84 allocation: zp byte:6 [ s3#0 ] zp byte:5 [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 81 allocation: reg byte a [ s3#0 ] zp byte:5 [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 83 allocation: reg byte x [ s3#0 ] zp byte:5 [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 83 allocation: reg byte y [ s3#0 ] zp byte:5 [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 73 allocation: reg byte alu [ s3#0 ] zp byte:5 [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 78 allocation: zp byte:6 [ s3#0 ] reg byte a [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 75 allocation: reg byte a [ s3#0 ] reg byte a [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte x [ s3#0 ] reg byte a [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte y [ s3#0 ] reg byte a [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 70 allocation: reg byte alu [ s3#0 ] reg byte a [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 80 allocation: zp byte:6 [ s3#0 ] reg byte x [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte a [ s3#0 ] reg byte x [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte x [ s3#0 ] reg byte x [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte y [ s3#0 ] reg byte x [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 70 allocation: reg byte alu [ s3#0 ] reg byte x [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 80 allocation: zp byte:6 [ s3#0 ] reg byte y [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte a [ s3#0 ] reg byte y [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte x [ s3#0 ] reg byte y [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte y [ s3#0 ] reg byte y [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 70 allocation: reg byte alu [ s3#0 ] reg byte y [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 78 allocation: zp byte:6 [ s3#0 ] reg byte alu [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 75 allocation: reg byte a [ s3#0 ] reg byte alu [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte x [ s3#0 ] reg byte alu [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte y [ s3#0 ] reg byte alu [ s2#0 ] zp byte:4 [ s1#0 ] 
Uplift attempt [] alu not applicable
Uplift attempt [] clobber allocation: zp byte:6 [ s3#0 ] zp byte:5 [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte a [ s3#0 ] zp byte:5 [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte x [ s3#0 ] zp byte:5 [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte y [ s3#0 ] zp byte:5 [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte alu [ s3#0 ] zp byte:5 [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: zp byte:6 [ s3#0 ] reg byte a [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte a [ s3#0 ] reg byte a [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte x [ s3#0 ] reg byte a [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte y [ s3#0 ] reg byte a [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte alu [ s3#0 ] reg byte a [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: zp byte:6 [ s3#0 ] reg byte x [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte a [ s3#0 ] reg byte x [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte x [ s3#0 ] reg byte x [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte y [ s3#0 ] reg byte x [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte alu [ s3#0 ] reg byte x [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: zp byte:6 [ s3#0 ] reg byte y [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte a [ s3#0 ] reg byte y [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte x [ s3#0 ] reg byte y [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte y [ s3#0 ] reg byte y [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte alu [ s3#0 ] reg byte y [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: zp byte:6 [ s3#0 ] reg byte alu [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte a [ s3#0 ] reg byte alu [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte x [ s3#0 ] reg byte alu [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte y [ s3#0 ] reg byte alu [ s2#0 ] reg byte a [ s1#0 ] 
Uplift attempt [] alu not applicable
Uplift attempt [] 80 allocation: zp byte:6 [ s3#0 ] zp byte:5 [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte a [ s3#0 ] zp byte:5 [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte x [ s3#0 ] zp byte:5 [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte y [ s3#0 ] zp byte:5 [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 70 allocation: reg byte alu [ s3#0 ] zp byte:5 [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 78 allocation: zp byte:6 [ s3#0 ] reg byte a [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 75 allocation: reg byte a [ s3#0 ] reg byte a [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte x [ s3#0 ] reg byte a [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte y [ s3#0 ] reg byte a [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 67 allocation: reg byte alu [ s3#0 ] reg byte a [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] clobber allocation: zp byte:6 [ s3#0 ] reg byte x [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte a [ s3#0 ] reg byte x [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte x [ s3#0 ] reg byte x [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte y [ s3#0 ] reg byte x [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte alu [ s3#0 ] reg byte x [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 80 allocation: zp byte:6 [ s3#0 ] reg byte y [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte a [ s3#0 ] reg byte y [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte x [ s3#0 ] reg byte y [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte y [ s3#0 ] reg byte y [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 67 allocation: reg byte alu [ s3#0 ] reg byte y [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 74 allocation: zp byte:6 [ s3#0 ] reg byte alu [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 71 allocation: reg byte a [ s3#0 ] reg byte alu [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 73 allocation: reg byte x [ s3#0 ] reg byte alu [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] 73 allocation: reg byte y [ s3#0 ] reg byte alu [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [] alu not applicable
Uplift attempt [] 80 allocation: zp byte:6 [ s3#0 ] zp byte:5 [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte a [ s3#0 ] zp byte:5 [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte x [ s3#0 ] zp byte:5 [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte y [ s3#0 ] zp byte:5 [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 70 allocation: reg byte alu [ s3#0 ] zp byte:5 [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 78 allocation: zp byte:6 [ s3#0 ] reg byte a [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 75 allocation: reg byte a [ s3#0 ] reg byte a [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte x [ s3#0 ] reg byte a [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte y [ s3#0 ] reg byte a [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 67 allocation: reg byte alu [ s3#0 ] reg byte a [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 80 allocation: zp byte:6 [ s3#0 ] reg byte x [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 77 allocation: reg byte a [ s3#0 ] reg byte x [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte x [ s3#0 ] reg byte x [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 79 allocation: reg byte y [ s3#0 ] reg byte x [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 67 allocation: reg byte alu [ s3#0 ] reg byte x [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] clobber allocation: zp byte:6 [ s3#0 ] reg byte y [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte a [ s3#0 ] reg byte y [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte x [ s3#0 ] reg byte y [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte y [ s3#0 ] reg byte y [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] clobber allocation: reg byte alu [ s3#0 ] reg byte y [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 74 allocation: zp byte:6 [ s3#0 ] reg byte alu [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 71 allocation: reg byte a [ s3#0 ] reg byte alu [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 73 allocation: reg byte x [ s3#0 ] reg byte alu [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] 73 allocation: reg byte y [ s3#0 ] reg byte alu [ s2#0 ] reg byte y [ s1#0 ] 
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplift attempt [] alu not applicable
Uplifting [] best 67 combination reg byte alu [ s3#0 ] reg byte a [ s2#0 ] reg byte x [ s1#0 ] 
Uplift attempt [sum] 67 allocation: zp byte:2 [ sum::a#2 ] zp byte:3 [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] 58 allocation: reg byte a [ sum::a#2 ] zp byte:3 [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte x [ sum::a#2 ] zp byte:3 [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] 60 allocation: reg byte y [ sum::a#2 ] zp byte:3 [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] 58 allocation: zp byte:2 [ sum::a#2 ] reg byte a [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] 49 allocation: reg byte a [ sum::a#2 ] reg byte a [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte x [ sum::a#2 ] reg byte a [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] 55 allocation: reg byte y [ sum::a#2 ] reg byte a [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] clobber allocation: zp byte:2 [ sum::a#2 ] reg byte x [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte a [ sum::a#2 ] reg byte x [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte x [ sum::a#2 ] reg byte x [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte y [ sum::a#2 ] reg byte x [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] 60 allocation: zp byte:2 [ sum::a#2 ] reg byte y [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] 55 allocation: reg byte a [ sum::a#2 ] reg byte y [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte x [ sum::a#2 ] reg byte y [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] 51 allocation: reg byte y [ sum::a#2 ] reg byte y [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] missing fragment xby=aby
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] clobber allocation: zp byte:2 [ sum::a#2 ] zp byte:3 [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte a [ sum::a#2 ] zp byte:3 [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte x [ sum::a#2 ] zp byte:3 [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte y [ sum::a#2 ] zp byte:3 [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] clobber allocation: zp byte:2 [ sum::a#2 ] reg byte a [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte a [ sum::a#2 ] reg byte a [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte x [ sum::a#2 ] reg byte a [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte y [ sum::a#2 ] reg byte a [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] clobber allocation: zp byte:2 [ sum::a#2 ] reg byte x [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte a [ sum::a#2 ] reg byte x [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte x [ sum::a#2 ] reg byte x [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte y [ sum::a#2 ] reg byte x [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] clobber allocation: zp byte:2 [ sum::a#2 ] reg byte y [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte a [ sum::a#2 ] reg byte y [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte x [ sum::a#2 ] reg byte y [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] clobber allocation: reg byte y [ sum::a#2 ] reg byte y [ sum::b#2 ] reg byte x [ sum::return#0 ] 
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] missing fragment xby=yby
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplift attempt [sum] alu not applicable
Uplifting [sum] best 49 combination reg byte a [ sum::a#2 ] reg byte a [ sum::b#2 ] zp byte:7 [ sum::return#0 ] 
MISSING FRAGMENTS
  xby=aby
  xby=yby
Re-allocated ZP register from zp byte:7 to zp byte:2
Removing instruction jmp B2
Removing instruction jmp B3
Removing instruction jmp BEND
Removing instruction jmp sum__Breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call sum param-assignment [ sum::return#0 s1#0 ]
//SEG2 [5] phi from @BEGIN to sum
sum_from_BBEGIN:
//SEG3 [5] phi (byte) sum::b#2 = (byte) 2 -- aby=coby1 
  lda #2
//SEG4 [5] phi (byte) sum::a#2 = (byte) 1 -- aby=coby1 
  lda #1
  jsr sum
//SEG5 @2
B2:
//SEG6 [1] (byte) s1#0 ← (byte) sum::return#0 [ sum::return#0 s1#0 ] -- xby=zpby1 
  ldx 2
//SEG7 [2] call sum param-assignment [ sum::return#0 s1#0 ]
//SEG8 [5] phi from @2 to sum
sum_from_B2:
//SEG9 [5] phi (byte) sum::b#2 = (byte) 13 -- aby=coby1 
  lda #13
//SEG10 [5] phi (byte) sum::a#2 = (byte) 9 -- aby=coby1 
  lda #9
  jsr sum
//SEG11 @3
B3:
//SEG12 [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ] -- aby=zpby1 
  lda 2
//SEG13 [4] (byte) s3#0 ← (byte) s1#0 + (byte) s2#0 [ ]
  // [4] s3#0 ← s1#0 + s2#0  //  ALU
//SEG14 @END
BEND:
//SEG15 sum
sum:
//SEG16 [6] (byte) sum::return#0 ← (byte) sum::a#2 + (byte) sum::b#2 [ sum::return#0 s1#0 ] -- zpby1=aby_plus_aby 
  asl
  sta 2
//SEG17 sum::@return
sum__Breturn:
//SEG18 [7] return  [ sum::return#0 s1#0 ]
  rts

FINAL SYMBOL TABLE
(label) @2
(label) @3
(label) @BEGIN
(label) @END
(byte) s1
(byte) s1#0 reg byte x 0.5714285714285714
(byte) s2
(byte) s2#0 reg byte a 4.0
(byte) s3
(byte) s3#0 reg byte alu Infinity
(byte()) sum((byte) sum::a , (byte) sum::b)
(label) sum::@return
(byte) sum::a
(byte) sum::a#2 reg byte a 2.0
(byte) sum::b
(byte) sum::b#2 reg byte a 2.0
(byte) sum::return
(byte) sum::return#0 zp byte:2 1.2000000000000002

reg byte a [ sum::a#2 ]
reg byte a [ sum::b#2 ]
reg byte x [ s1#0 ]
reg byte a [ s2#0 ]
reg byte alu [ s3#0 ]
zp byte:2 [ sum::return#0 ]

FINAL CODE
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call sum param-assignment [ sum::return#0 s1#0 ]
//SEG2 [5] phi from @BEGIN to sum
sum_from_BBEGIN:
//SEG3 [5] phi (byte) sum::b#2 = (byte) 2 -- aby=coby1 
  lda #2
//SEG4 [5] phi (byte) sum::a#2 = (byte) 1 -- aby=coby1 
  lda #1
  jsr sum
//SEG5 @2
B2:
//SEG6 [1] (byte) s1#0 ← (byte) sum::return#0 [ sum::return#0 s1#0 ] -- xby=zpby1 
  ldx 2
//SEG7 [2] call sum param-assignment [ sum::return#0 s1#0 ]
//SEG8 [5] phi from @2 to sum
sum_from_B2:
//SEG9 [5] phi (byte) sum::b#2 = (byte) 13 -- aby=coby1 
  lda #13
//SEG10 [5] phi (byte) sum::a#2 = (byte) 9 -- aby=coby1 
  lda #9
  jsr sum
//SEG11 @3
B3:
//SEG12 [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ] -- aby=zpby1 
  lda 2
//SEG13 [4] (byte) s3#0 ← (byte) s1#0 + (byte) s2#0 [ ]
  // [4] s3#0 ← s1#0 + s2#0  //  ALU
//SEG14 @END
BEND:
//SEG15 sum
sum:
//SEG16 [6] (byte) sum::return#0 ← (byte) sum::a#2 + (byte) sum::b#2 [ sum::return#0 s1#0 ] -- zpby1=aby_plus_aby 
  asl
  sta 2
//SEG17 sum::@return
sum__Breturn:
//SEG18 [7] return  [ sum::return#0 s1#0 ]
  rts

