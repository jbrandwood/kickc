Fixing pointer array-indexing *((word[SIZE]) x_start + (byte) main::i)
Fixing pointer array-indexing *((word[SIZE]) x_end + (byte) point_init::point_idx)
Fixing pointer array-indexing *((word[SIZE]) x_start + (byte) point_init::point_idx)
Fixing pointer array-indexing *((word[SIZE]) x_start + (byte) point_init::point_idx)
Fixing pointer array-indexing *((word[SIZE]) x_cur + (byte) point_init::point_idx)
Fixing pointer array-indexing *((word[SIZE]) y_cur + (byte) point_init::point_idx)
Identified constant variable (byte*) BITMAP
Identified constant variable (byte*) SCREEN
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call vicSelectGfxBank (byte*) SCREEN 
Inlined call (byte~) main::$4 ← call toD018 (byte*) SCREEN (byte*) BITMAP 
Inlined call (word~) point_init::$6 ← call abs16s (signed word) point_init::x_diff 
Inlined call (word~) point_init::$7 ← call abs16s (signed word) point_init::y_diff 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) divr16u::@7
Culled Empty Block (label) @7
Culled Empty Block (label) @8
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) divr16s::@8
Culled Empty Block (label) divr16s::@10
Culled Empty Block (label) divr16s::@12
Culled Empty Block (label) divr16s::@6
Culled Empty Block (label) divr16s::@13
Culled Empty Block (label) divr16s::@14
Culled Empty Block (label) @11
Culled Empty Block (label) main::vicSelectGfxBank1_toDd001_@1
Culled Empty Block (label) main::vicSelectGfxBank1_@return
Culled Empty Block (label) main::toD0181_@1
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@13
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@14
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@10
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@12
Culled Empty Block (label) @13
Culled Empty Block (label) point_init::abs16s1_@4
Culled Empty Block (label) point_init::abs16s1_@2
Culled Empty Block (label) point_init::abs16s1_@5
Culled Empty Block (label) point_init::abs16s1_@6
Culled Empty Block (label) point_init::abs16s2_@4
Culled Empty Block (label) point_init::abs16s2_@2
Culled Empty Block (label) point_init::abs16s2_@5
Culled Empty Block (label) point_init::abs16s2_@6
Culled Empty Block (label) point_init::@3
Culled Empty Block (label) point_init::@4
Culled Empty Block (label) point_init::@6
Culled Empty Block (label) @14
Culled Empty Block (label) @15
Culled Empty Block (label) screen_fill::@4
Culled Empty Block (label) bitmap_init::@8
Culled Empty Block (label) @17
Culled Empty Block (label) bitmap_clear::@4
Culled Empty Block (label) @18

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) PROCPORT_DDR#0 ← ((byte*)) (number) 0
  (byte) PROCPORT_DDR_MEMORY_MASK#0 ← (number) 7
  (byte*) PROCPORT#0 ← ((byte*)) (number) 1
  (byte) PROCPORT_RAM_IO#0 ← (number) $35
  (byte*) RASTER#0 ← ((byte*)) (number) $d012
  (byte*) BORDERCOL#0 ← ((byte*)) (number) $d020
  (byte*) D011#0 ← ((byte*)) (number) $d011
  (byte) VIC_BMM#0 ← (number) $20
  (byte) VIC_DEN#0 ← (number) $10
  (byte) VIC_RSEL#0 ← (number) 8
  (byte*) D018#0 ← ((byte*)) (number) $d018
  (byte*) CIA2_PORT_A#0 ← ((byte*)) (number) $dd00
  (byte*) CIA2_PORT_A_DDR#0 ← ((byte*)) (number) $dd02
  to:@12
divr16u: scope:[divr16u]  from divr16s::@4
  (word) divr16u::divisor#5 ← phi( divr16s::@4/(word) divr16u::divisor#0 )
  (word) divr16u::dividend#4 ← phi( divr16s::@4/(word) divr16u::dividend#1 )
  (word) divr16u::rem#8 ← phi( divr16s::@4/(word) divr16u::rem#3 )
  (word) divr16u::quotient#0 ← (number) 0
  (byte) divr16u::i#0 ← (byte) 0
  to:divr16u::@1
divr16u::@1: scope:[divr16u]  from divr16u divr16u::@3
  (byte) divr16u::i#5 ← phi( divr16u/(byte) divr16u::i#0 divr16u::@3/(byte) divr16u::i#1 )
  (word) divr16u::divisor#3 ← phi( divr16u/(word) divr16u::divisor#5 divr16u::@3/(word) divr16u::divisor#6 )
  (word) divr16u::quotient#6 ← phi( divr16u/(word) divr16u::quotient#0 divr16u::@3/(word) divr16u::quotient#8 )
  (word) divr16u::dividend#2 ← phi( divr16u/(word) divr16u::dividend#4 divr16u::@3/(word) divr16u::dividend#5 )
  (word) divr16u::rem#4 ← phi( divr16u/(word) divr16u::rem#8 divr16u::@3/(word) divr16u::rem#9 )
  (word~) divr16u::$0 ← (word) divr16u::rem#4 << (number) 1
  (word) divr16u::rem#0 ← (word~) divr16u::$0
  (byte~) divr16u::$1 ← > (word) divr16u::dividend#2
  (number~) divr16u::$2 ← (byte~) divr16u::$1 & (number) $80
  (bool~) divr16u::$3 ← (number~) divr16u::$2 != (number) 0
  (bool~) divr16u::$4 ← ! (bool~) divr16u::$3
  if((bool~) divr16u::$4) goto divr16u::@2
  to:divr16u::@4
divr16u::@2: scope:[divr16u]  from divr16u::@1 divr16u::@4
  (byte) divr16u::i#3 ← phi( divr16u::@1/(byte) divr16u::i#5 divr16u::@4/(byte) divr16u::i#6 )
  (word) divr16u::divisor#1 ← phi( divr16u::@1/(word) divr16u::divisor#3 divr16u::@4/(word) divr16u::divisor#4 )
  (word) divr16u::rem#5 ← phi( divr16u::@1/(word) divr16u::rem#0 divr16u::@4/(word) divr16u::rem#1 )
  (word) divr16u::quotient#3 ← phi( divr16u::@1/(word) divr16u::quotient#6 divr16u::@4/(word) divr16u::quotient#7 )
  (word) divr16u::dividend#3 ← phi( divr16u::@1/(word) divr16u::dividend#2 divr16u::@4/(word) divr16u::dividend#6 )
  (word~) divr16u::$6 ← (word) divr16u::dividend#3 << (number) 1
  (word) divr16u::dividend#0 ← (word~) divr16u::$6
  (word~) divr16u::$7 ← (word) divr16u::quotient#3 << (number) 1
  (word) divr16u::quotient#1 ← (word~) divr16u::$7
  (bool~) divr16u::$8 ← (word) divr16u::rem#5 >= (word) divr16u::divisor#1
  (bool~) divr16u::$9 ← ! (bool~) divr16u::$8
  if((bool~) divr16u::$9) goto divr16u::@3
  to:divr16u::@5
divr16u::@4: scope:[divr16u]  from divr16u::@1
  (byte) divr16u::i#6 ← phi( divr16u::@1/(byte) divr16u::i#5 )
  (word) divr16u::divisor#4 ← phi( divr16u::@1/(word) divr16u::divisor#3 )
  (word) divr16u::quotient#7 ← phi( divr16u::@1/(word) divr16u::quotient#6 )
  (word) divr16u::dividend#6 ← phi( divr16u::@1/(word) divr16u::dividend#2 )
  (word) divr16u::rem#6 ← phi( divr16u::@1/(word) divr16u::rem#0 )
  (number~) divr16u::$5 ← (word) divr16u::rem#6 | (number) 1
  (word) divr16u::rem#1 ← (number~) divr16u::$5
  to:divr16u::@2
divr16u::@3: scope:[divr16u]  from divr16u::@2 divr16u::@5
  (word) divr16u::divisor#6 ← phi( divr16u::@2/(word) divr16u::divisor#1 divr16u::@5/(word) divr16u::divisor#2 )
  (word) divr16u::quotient#8 ← phi( divr16u::@2/(word) divr16u::quotient#1 divr16u::@5/(word) divr16u::quotient#2 )
  (word) divr16u::dividend#5 ← phi( divr16u::@2/(word) divr16u::dividend#0 divr16u::@5/(word) divr16u::dividend#7 )
  (word) divr16u::rem#9 ← phi( divr16u::@2/(word) divr16u::rem#5 divr16u::@5/(word) divr16u::rem#2 )
  (byte) divr16u::i#2 ← phi( divr16u::@2/(byte) divr16u::i#3 divr16u::@5/(byte) divr16u::i#4 )
  (byte) divr16u::i#1 ← (byte) divr16u::i#2 + rangenext(0,$f)
  (bool~) divr16u::$11 ← (byte) divr16u::i#1 != rangelast(0,$f)
  if((bool~) divr16u::$11) goto divr16u::@1
  to:divr16u::@6
divr16u::@5: scope:[divr16u]  from divr16u::@2
  (word) divr16u::dividend#7 ← phi( divr16u::@2/(word) divr16u::dividend#0 )
  (byte) divr16u::i#4 ← phi( divr16u::@2/(byte) divr16u::i#3 )
  (word) divr16u::divisor#2 ← phi( divr16u::@2/(word) divr16u::divisor#1 )
  (word) divr16u::rem#7 ← phi( divr16u::@2/(word) divr16u::rem#5 )
  (word) divr16u::quotient#4 ← phi( divr16u::@2/(word) divr16u::quotient#1 )
  (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#4
  (word~) divr16u::$10 ← (word) divr16u::rem#7 - (word) divr16u::divisor#2
  (word) divr16u::rem#2 ← (word~) divr16u::$10
  to:divr16u::@3
divr16u::@6: scope:[divr16u]  from divr16u::@3
  (word) divr16u::quotient#5 ← phi( divr16u::@3/(word) divr16u::quotient#8 )
  (word) divr16u::return#0 ← (word) divr16u::quotient#5
  to:divr16u::@return
divr16u::@return: scope:[divr16u]  from divr16u::@6
  (word) divr16u::return#3 ← phi( divr16u::@6/(word) divr16u::return#0 )
  (word) divr16u::return#1 ← (word) divr16u::return#3
  return 
  to:@return
divr16s: scope:[divr16s]  from point_init::@8
  (signed word) divr16s::divisor#6 ← phi( point_init::@8/(signed word) divr16s::divisor#0 )
  (signed word) divr16s::rem#1 ← phi( point_init::@8/(signed word) divr16s::rem#0 )
  (signed word) divr16s::dividend#1 ← phi( point_init::@8/(signed word) divr16s::dividend#0 )
  (byte) divr16s::neg#0 ← (number) 0
  (word) divr16s::dividendu#0 ← (number) 0
  (word) divr16s::remu#0 ← (number) 0
  (bool~) divr16s::$0 ← (signed word) divr16s::dividend#1 < (number) 0
  (bool~) divr16s::$1 ← (signed word) divr16s::rem#1 < (number) 0
  (bool~) divr16s::$2 ← (bool~) divr16s::$0 || (bool~) divr16s::$1
  if((bool~) divr16s::$2) goto divr16s::@1
  to:divr16s::@7
divr16s::@1: scope:[divr16s]  from divr16s
  (signed word) divr16s::divisor#4 ← phi( divr16s/(signed word) divr16s::divisor#6 )
  (signed word) divr16s::rem#2 ← phi( divr16s/(signed word) divr16s::rem#1 )
  (signed word) divr16s::dividend#2 ← phi( divr16s/(signed word) divr16s::dividend#1 )
  (signed word~) divr16s::$8 ← - (signed word) divr16s::dividend#2
  (word~) divr16s::$9 ← ((word)) (signed word~) divr16s::$8
  (word) divr16s::dividendu#1 ← (word~) divr16s::$9
  (signed word~) divr16s::$10 ← - (signed word) divr16s::rem#2
  (word~) divr16s::$11 ← ((word)) (signed word~) divr16s::$10
  (word) divr16s::remu#1 ← (word~) divr16s::$11
  (byte) divr16s::neg#1 ← (number) 1
  to:divr16s::@2
divr16s::@7: scope:[divr16s]  from divr16s
  (byte) divr16s::neg#7 ← phi( divr16s/(byte) divr16s::neg#0 )
  (signed word) divr16s::divisor#5 ← phi( divr16s/(signed word) divr16s::divisor#6 )
  (signed word) divr16s::rem#3 ← phi( divr16s/(signed word) divr16s::rem#1 )
  (signed word) divr16s::dividend#3 ← phi( divr16s/(signed word) divr16s::dividend#1 )
  (word~) divr16s::$6 ← ((word)) (signed word) divr16s::dividend#3
  (word) divr16s::dividendu#2 ← (word~) divr16s::$6
  (word~) divr16s::$7 ← ((word)) (signed word) divr16s::rem#3
  (word) divr16s::remu#2 ← (word~) divr16s::$7
  to:divr16s::@2
divr16s::@2: scope:[divr16s]  from divr16s::@1 divr16s::@7
  (word) divr16s::remu#6 ← phi( divr16s::@1/(word) divr16s::remu#1 divr16s::@7/(word) divr16s::remu#2 )
  (word) divr16s::dividendu#6 ← phi( divr16s::@1/(word) divr16s::dividendu#1 divr16s::@7/(word) divr16s::dividendu#2 )
  (byte) divr16s::neg#5 ← phi( divr16s::@1/(byte) divr16s::neg#1 divr16s::@7/(byte) divr16s::neg#7 )
  (signed word) divr16s::divisor#1 ← phi( divr16s::@1/(signed word) divr16s::divisor#4 divr16s::@7/(signed word) divr16s::divisor#5 )
  (word) divr16s::divisoru#0 ← (number) 0
  (bool~) divr16s::$3 ← (signed word) divr16s::divisor#1 < (number) 0
  if((bool~) divr16s::$3) goto divr16s::@3
  to:divr16s::@9
divr16s::@3: scope:[divr16s]  from divr16s::@2
  (word) divr16s::remu#4 ← phi( divr16s::@2/(word) divr16s::remu#6 )
  (word) divr16s::dividendu#4 ← phi( divr16s::@2/(word) divr16s::dividendu#6 )
  (byte) divr16s::neg#3 ← phi( divr16s::@2/(byte) divr16s::neg#5 )
  (signed word) divr16s::divisor#2 ← phi( divr16s::@2/(signed word) divr16s::divisor#1 )
  (signed word~) divr16s::$13 ← - (signed word) divr16s::divisor#2
  (word~) divr16s::$14 ← ((word)) (signed word~) divr16s::$13
  (word) divr16s::divisoru#1 ← (word~) divr16s::$14
  (number~) divr16s::$15 ← (byte) divr16s::neg#3 ^ (number) 1
  (byte) divr16s::neg#2 ← (number~) divr16s::$15
  to:divr16s::@4
divr16s::@9: scope:[divr16s]  from divr16s::@2
  (byte) divr16s::neg#8 ← phi( divr16s::@2/(byte) divr16s::neg#5 )
  (word) divr16s::remu#5 ← phi( divr16s::@2/(word) divr16s::remu#6 )
  (word) divr16s::dividendu#5 ← phi( divr16s::@2/(word) divr16s::dividendu#6 )
  (signed word) divr16s::divisor#3 ← phi( divr16s::@2/(signed word) divr16s::divisor#1 )
  (word~) divr16s::$12 ← ((word)) (signed word) divr16s::divisor#3
  (word) divr16s::divisoru#2 ← (word~) divr16s::$12
  to:divr16s::@4
divr16s::@4: scope:[divr16s]  from divr16s::@3 divr16s::@9
  (byte) divr16s::neg#6 ← phi( divr16s::@3/(byte) divr16s::neg#2 divr16s::@9/(byte) divr16s::neg#8 )
  (word) divr16s::remu#3 ← phi( divr16s::@3/(word) divr16s::remu#4 divr16s::@9/(word) divr16s::remu#5 )
  (word) divr16s::divisoru#3 ← phi( divr16s::@3/(word) divr16s::divisoru#1 divr16s::@9/(word) divr16s::divisoru#2 )
  (word) divr16s::dividendu#3 ← phi( divr16s::@3/(word) divr16s::dividendu#4 divr16s::@9/(word) divr16s::dividendu#5 )
  (word) divr16u::dividend#1 ← (word) divr16s::dividendu#3
  (word) divr16u::divisor#0 ← (word) divr16s::divisoru#3
  (word) divr16u::rem#3 ← (word) divr16s::remu#3
  call divr16u 
  (word) divr16u::return#2 ← (word) divr16u::return#1
  to:divr16s::@15
divr16s::@15: scope:[divr16s]  from divr16s::@4
  (byte) divr16s::neg#4 ← phi( divr16s::@4/(byte) divr16s::neg#6 )
  (word) divr16u::return#4 ← phi( divr16s::@4/(word) divr16u::return#2 )
  (word~) divr16s::$4 ← (word) divr16u::return#4
  (word) divr16s::resultu#0 ← (word~) divr16s::$4
  (bool~) divr16s::$5 ← (byte) divr16s::neg#4 == (number) 0
  if((bool~) divr16s::$5) goto divr16s::@5
  to:divr16s::@11
divr16s::@5: scope:[divr16s]  from divr16s::@15
  (word) divr16s::resultu#1 ← phi( divr16s::@15/(word) divr16s::resultu#0 )
  (signed word~) divr16s::$21 ← ((signed word)) (word) divr16s::resultu#1
  (signed word) divr16s::return#0 ← (signed word~) divr16s::$21
  to:divr16s::@return
divr16s::@11: scope:[divr16s]  from divr16s::@15
  (word) divr16s::resultu#2 ← phi( divr16s::@15/(word) divr16s::resultu#0 )
  (signed word~) divr16s::$18 ← ((signed word)) (word) divr16s::resultu#2
  (signed word~) divr16s::$19 ← - (signed word~) divr16s::$18
  (signed word) divr16s::return#1 ← (signed word~) divr16s::$19
  to:divr16s::@return
divr16s::@return: scope:[divr16s]  from divr16s::@11 divr16s::@5
  (signed word) divr16s::return#4 ← phi( divr16s::@11/(signed word) divr16s::return#1 divr16s::@5/(signed word) divr16s::return#0 )
  (signed word) divr16s::return#2 ← (signed word) divr16s::return#4
  return 
  to:@return
@12: scope:[]  from @begin
  (byte*) BITMAP#0 ← ((byte*)) (number) $a000
  (byte*) SCREEN#0 ← ((byte*)) (number) $8800
  (byte) SIZE#0 ← (number) 4
  (byte) DELAY#0 ← (number) 8
  (word[SIZE#0]) x_start#0 ← { (number) $a, (number) $14, (number) $1e, (number) $1e }
  (byte[SIZE#0]) y_start#0 ← { (number) $a, (number) $a, (number) $a, (number) $14 }
  (word[SIZE#0]) x_end#0 ← { (number) $14, (number) $a, (number) $14, (number) $14 }
  (byte[SIZE#0]) y_end#0 ← { (number) $14, (number) $14, (number) $a, (number) $14 }
  (word[SIZE#0]) x_cur#0 ← { fill( SIZE#0, 0) }
  (word[SIZE#0]) y_cur#0 ← { fill( SIZE#0, 0) }
  (signed byte[SIZE#0]) x_add#0 ← { fill( SIZE#0, 0) }
  (signed byte[SIZE#0]) y_add#0 ← { fill( SIZE#0, 0) }
  (byte[SIZE#0]) delay#0 ← { fill( SIZE#0, 0) }
  to:@16
main: scope:[main]  from @19
  asm { sei  }
  *((byte*) PROCPORT_DDR#0) ← (byte) PROCPORT_DDR_MEMORY_MASK#0
  *((byte*) PROCPORT#0) ← (byte) PROCPORT_RAM_IO#0
  (byte~) main::$0 ← (byte) VIC_BMM#0 | (byte) VIC_DEN#0
  (byte~) main::$1 ← (byte~) main::$0 | (byte) VIC_RSEL#0
  (number~) main::$2 ← (byte~) main::$1 | (number) 3
  *((byte*) D011#0) ← (number~) main::$2
  (byte*) main::vicSelectGfxBank1_gfx#0 ← (byte*) SCREEN#0
  to:main::vicSelectGfxBank1
main::vicSelectGfxBank1: scope:[main]  from main
  (byte*) main::vicSelectGfxBank1_gfx#1 ← phi( main/(byte*) main::vicSelectGfxBank1_gfx#0 )
  *((byte*) CIA2_PORT_A_DDR#0) ← (number) 3
  (byte*) main::vicSelectGfxBank1_toDd001_gfx#0 ← (byte*) main::vicSelectGfxBank1_gfx#1
  to:main::vicSelectGfxBank1_toDd001
main::vicSelectGfxBank1_toDd001: scope:[main]  from main::vicSelectGfxBank1
  (byte*) main::vicSelectGfxBank1_toDd001_gfx#1 ← phi( main::vicSelectGfxBank1/(byte*) main::vicSelectGfxBank1_toDd001_gfx#0 )
  (word~) main::vicSelectGfxBank1_toDd001_$0#0 ← ((word)) (byte*) main::vicSelectGfxBank1_toDd001_gfx#1
  (byte~) main::vicSelectGfxBank1_toDd001_$1#0 ← > (word~) main::vicSelectGfxBank1_toDd001_$0#0
  (number~) main::vicSelectGfxBank1_toDd001_$2#0 ← (byte~) main::vicSelectGfxBank1_toDd001_$1#0 / (number) $40
  (number~) main::vicSelectGfxBank1_toDd001_$3#0 ← (number) 3 ^ (number~) main::vicSelectGfxBank1_toDd001_$2#0
  (byte) main::vicSelectGfxBank1_toDd001_return#0 ← (number~) main::vicSelectGfxBank1_toDd001_$3#0
  to:main::vicSelectGfxBank1_toDd001_@return
main::vicSelectGfxBank1_toDd001_@return: scope:[main]  from main::vicSelectGfxBank1_toDd001
  (byte) main::vicSelectGfxBank1_toDd001_return#2 ← phi( main::vicSelectGfxBank1_toDd001/(byte) main::vicSelectGfxBank1_toDd001_return#0 )
  (byte) main::vicSelectGfxBank1_toDd001_return#1 ← (byte) main::vicSelectGfxBank1_toDd001_return#2
  to:main::vicSelectGfxBank1_@1
main::vicSelectGfxBank1_@1: scope:[main]  from main::vicSelectGfxBank1_toDd001_@return
  (byte) main::vicSelectGfxBank1_toDd001_return#3 ← phi( main::vicSelectGfxBank1_toDd001_@return/(byte) main::vicSelectGfxBank1_toDd001_return#1 )
  (byte~) main::vicSelectGfxBank1_$0#0 ← (byte) main::vicSelectGfxBank1_toDd001_return#3
  *((byte*) CIA2_PORT_A#0) ← (byte~) main::vicSelectGfxBank1_$0#0
  to:main::@15
main::@15: scope:[main]  from main::vicSelectGfxBank1_@1
  (byte*) main::toD0181_screen#0 ← (byte*) SCREEN#0
  (byte*) main::toD0181_gfx#0 ← (byte*) BITMAP#0
  to:main::toD0181
main::toD0181: scope:[main]  from main::@15
  (byte*) main::toD0181_gfx#1 ← phi( main::@15/(byte*) main::toD0181_gfx#0 )
  (byte*) main::toD0181_screen#1 ← phi( main::@15/(byte*) main::toD0181_screen#0 )
  (word~) main::toD0181_$0#0 ← ((word)) (byte*) main::toD0181_screen#1
  (number~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 & (number) $3fff
  (number~) main::toD0181_$2#0 ← (number~) main::toD0181_$1#0 * (number) 4
  (number~) main::toD0181_$3#0 ← > (number~) main::toD0181_$2#0
  (word~) main::toD0181_$4#0 ← ((word)) (byte*) main::toD0181_gfx#1
  (byte~) main::toD0181_$5#0 ← > (word~) main::toD0181_$4#0
  (number~) main::toD0181_$6#0 ← (byte~) main::toD0181_$5#0 / (number) 4
  (number~) main::toD0181_$7#0 ← (number~) main::toD0181_$6#0 & (number) $f
  (number~) main::toD0181_$8#0 ← (number~) main::toD0181_$3#0 | (number~) main::toD0181_$7#0
  (byte) main::toD0181_return#0 ← (number~) main::toD0181_$8#0
  to:main::toD0181_@return
main::toD0181_@return: scope:[main]  from main::toD0181
  (byte) main::toD0181_return#2 ← phi( main::toD0181/(byte) main::toD0181_return#0 )
  (byte) main::toD0181_return#1 ← (byte) main::toD0181_return#2
  to:main::@16
main::@16: scope:[main]  from main::toD0181_@return
  (byte) main::toD0181_return#3 ← phi( main::toD0181_@return/(byte) main::toD0181_return#1 )
  (byte~) main::$4 ← (byte) main::toD0181_return#3
  *((byte*) D018#0) ← (byte~) main::$4
  (byte*) bitmap_init::bitmap#0 ← (byte*) BITMAP#0
  call bitmap_init 
  to:main::@17
main::@17: scope:[main]  from main::@16
  call bitmap_clear 
  to:main::@18
main::@18: scope:[main]  from main::@17
  (byte*) screen_fill::screen#0 ← (byte*) SCREEN#0
  (byte) screen_fill::ch#0 ← (number) $10
  call screen_fill 
  to:main::@19
main::@19: scope:[main]  from main::@18
  (number~) main::$8 ← (byte) SIZE#0 - (number) 1
  (byte) main::i#0 ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main::@19 main::@21
  (byte) main::i#2 ← phi( main::@19/(byte) main::i#0 main::@21/(byte) main::i#1 )
  (byte) point_init::point_idx#0 ← (byte) main::i#2
  call point_init 
  to:main::@20
main::@20: scope:[main]  from main::@1
  (byte) main::i#3 ← phi( main::@1/(byte) main::i#2 )
  (byte~) main::$13 ← (byte) main::i#3 * (const byte) SIZEOF_WORD
  (word) bitmap_plot::x#0 ← *((word[SIZE#0]) x_start#0 + (byte~) main::$13)
  (byte) bitmap_plot::y#0 ← *((byte[SIZE#0]) y_start#0 + (byte) main::i#3)
  call bitmap_plot 
  to:main::@21
main::@21: scope:[main]  from main::@20
  (byte) main::i#4 ← phi( main::@20/(byte) main::i#3 )
  (byte) main::i#1 ← (byte) main::i#4 + rangenext(0,main::$8)
  (bool~) main::$11 ← (byte) main::i#1 != rangelast(0,main::$8)
  if((bool~) main::$11) goto main::@1
  to:main::@3
main::@3: scope:[main]  from main::@21 main::@8
  if(true) goto main::@6
  to:main::@return
main::@6: scope:[main]  from main::@3 main::@6
  (bool~) main::$12 ← *((byte*) RASTER#0) != (number) $ff
  if((bool~) main::$12) goto main::@6
  to:main::@8
main::@8: scope:[main]  from main::@6
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  to:main::@3
main::@return: scope:[main]  from main::@3
  return 
  to:@return
point_init: scope:[point_init]  from main::@1
  (byte) point_init::point_idx#1 ← phi( main::@1/(byte) point_init::point_idx#0 )
  (byte~) point_init::$17 ← (byte) point_init::point_idx#1 * (const byte) SIZEOF_WORD
  (signed word~) point_init::$0 ← ((signed word)) *((word[SIZE#0]) x_end#0 + (byte~) point_init::$17)
  (byte~) point_init::$18 ← (byte) point_init::point_idx#1 * (const byte) SIZEOF_WORD
  (signed word~) point_init::$1 ← ((signed word)) *((word[SIZE#0]) x_start#0 + (byte~) point_init::$18)
  (signed word~) point_init::$2 ← (signed word~) point_init::$0 - (signed word~) point_init::$1
  (signed word) point_init::x_diff#0 ← (signed word~) point_init::$2
  (signed word~) point_init::$3 ← ((signed word)) *((byte[SIZE#0]) y_end#0 + (byte) point_init::point_idx#1)
  (signed word~) point_init::$4 ← ((signed word)) *((byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#1)
  (signed word~) point_init::$5 ← (signed word~) point_init::$3 - (signed word~) point_init::$4
  (signed word) point_init::y_diff#0 ← (signed word~) point_init::$5
  (signed word) point_init::abs16s1_w#0 ← (signed word) point_init::x_diff#0
  to:point_init::abs16s1
point_init::abs16s1: scope:[point_init]  from point_init
  (byte) point_init::point_idx#17 ← phi( point_init/(byte) point_init::point_idx#1 )
  (signed word) point_init::x_diff#14 ← phi( point_init/(signed word) point_init::x_diff#0 )
  (signed word) point_init::y_diff#9 ← phi( point_init/(signed word) point_init::y_diff#0 )
  (signed word) point_init::abs16s1_w#1 ← phi( point_init/(signed word) point_init::abs16s1_w#0 )
  (bool~) point_init::abs16s1_$0#0 ← (signed word) point_init::abs16s1_w#1 < (number) 0
  if((bool~) point_init::abs16s1_$0#0) goto point_init::abs16s1_@1
  to:point_init::abs16s1_@3
point_init::abs16s1_@1: scope:[point_init]  from point_init::abs16s1
  (byte) point_init::point_idx#15 ← phi( point_init::abs16s1/(byte) point_init::point_idx#17 )
  (signed word) point_init::x_diff#12 ← phi( point_init::abs16s1/(signed word) point_init::x_diff#14 )
  (signed word) point_init::y_diff#6 ← phi( point_init::abs16s1/(signed word) point_init::y_diff#9 )
  (signed word) point_init::abs16s1_w#2 ← phi( point_init::abs16s1/(signed word) point_init::abs16s1_w#1 )
  (signed word~) point_init::abs16s1_$2#0 ← - (signed word) point_init::abs16s1_w#2
  (word~) point_init::abs16s1_$3#0 ← ((word)) (signed word~) point_init::abs16s1_$2#0
  (word) point_init::abs16s1_return#0 ← (word~) point_init::abs16s1_$3#0
  to:point_init::abs16s1_@return
point_init::abs16s1_@3: scope:[point_init]  from point_init::abs16s1
  (byte) point_init::point_idx#16 ← phi( point_init::abs16s1/(byte) point_init::point_idx#17 )
  (signed word) point_init::x_diff#13 ← phi( point_init::abs16s1/(signed word) point_init::x_diff#14 )
  (signed word) point_init::y_diff#7 ← phi( point_init::abs16s1/(signed word) point_init::y_diff#9 )
  (signed word) point_init::abs16s1_w#3 ← phi( point_init::abs16s1/(signed word) point_init::abs16s1_w#1 )
  (word~) point_init::abs16s1_$1#0 ← ((word)) (signed word) point_init::abs16s1_w#3
  (word) point_init::abs16s1_return#1 ← (word~) point_init::abs16s1_$1#0
  to:point_init::abs16s1_@return
point_init::abs16s1_@return: scope:[point_init]  from point_init::abs16s1_@1 point_init::abs16s1_@3
  (byte) point_init::point_idx#14 ← phi( point_init::abs16s1_@1/(byte) point_init::point_idx#15 point_init::abs16s1_@3/(byte) point_init::point_idx#16 )
  (signed word) point_init::x_diff#11 ← phi( point_init::abs16s1_@1/(signed word) point_init::x_diff#12 point_init::abs16s1_@3/(signed word) point_init::x_diff#13 )
  (signed word) point_init::y_diff#3 ← phi( point_init::abs16s1_@1/(signed word) point_init::y_diff#6 point_init::abs16s1_@3/(signed word) point_init::y_diff#7 )
  (word) point_init::abs16s1_return#3 ← phi( point_init::abs16s1_@1/(word) point_init::abs16s1_return#0 point_init::abs16s1_@3/(word) point_init::abs16s1_return#1 )
  (word) point_init::abs16s1_return#2 ← (word) point_init::abs16s1_return#3
  to:point_init::@9
point_init::@9: scope:[point_init]  from point_init::abs16s1_@return
  (byte) point_init::point_idx#13 ← phi( point_init::abs16s1_@return/(byte) point_init::point_idx#14 )
  (signed word) point_init::x_diff#10 ← phi( point_init::abs16s1_@return/(signed word) point_init::x_diff#11 )
  (signed word) point_init::y_diff#1 ← phi( point_init::abs16s1_@return/(signed word) point_init::y_diff#3 )
  (word) point_init::abs16s1_return#4 ← phi( point_init::abs16s1_@return/(word) point_init::abs16s1_return#2 )
  (word~) point_init::$6 ← (word) point_init::abs16s1_return#4
  (signed word) point_init::abs16s2_w#0 ← (signed word) point_init::y_diff#1
  to:point_init::abs16s2
point_init::abs16s2: scope:[point_init]  from point_init::@9
  (signed word) point_init::y_diff#14 ← phi( point_init::@9/(signed word) point_init::y_diff#1 )
  (byte) point_init::point_idx#12 ← phi( point_init::@9/(byte) point_init::point_idx#13 )
  (signed word) point_init::x_diff#9 ← phi( point_init::@9/(signed word) point_init::x_diff#10 )
  (signed word) point_init::abs16s2_w#1 ← phi( point_init::@9/(signed word) point_init::abs16s2_w#0 )
  (bool~) point_init::abs16s2_$0#0 ← (signed word) point_init::abs16s2_w#1 < (number) 0
  if((bool~) point_init::abs16s2_$0#0) goto point_init::abs16s2_@1
  to:point_init::abs16s2_@3
point_init::abs16s2_@1: scope:[point_init]  from point_init::abs16s2
  (signed word) point_init::y_diff#12 ← phi( point_init::abs16s2/(signed word) point_init::y_diff#14 )
  (byte) point_init::point_idx#10 ← phi( point_init::abs16s2/(byte) point_init::point_idx#12 )
  (signed word) point_init::x_diff#7 ← phi( point_init::abs16s2/(signed word) point_init::x_diff#9 )
  (signed word) point_init::abs16s2_w#2 ← phi( point_init::abs16s2/(signed word) point_init::abs16s2_w#1 )
  (signed word~) point_init::abs16s2_$2#0 ← - (signed word) point_init::abs16s2_w#2
  (word~) point_init::abs16s2_$3#0 ← ((word)) (signed word~) point_init::abs16s2_$2#0
  (word) point_init::abs16s2_return#0 ← (word~) point_init::abs16s2_$3#0
  to:point_init::abs16s2_@return
point_init::abs16s2_@3: scope:[point_init]  from point_init::abs16s2
  (signed word) point_init::y_diff#13 ← phi( point_init::abs16s2/(signed word) point_init::y_diff#14 )
  (byte) point_init::point_idx#11 ← phi( point_init::abs16s2/(byte) point_init::point_idx#12 )
  (signed word) point_init::x_diff#8 ← phi( point_init::abs16s2/(signed word) point_init::x_diff#9 )
  (signed word) point_init::abs16s2_w#3 ← phi( point_init::abs16s2/(signed word) point_init::abs16s2_w#1 )
  (word~) point_init::abs16s2_$1#0 ← ((word)) (signed word) point_init::abs16s2_w#3
  (word) point_init::abs16s2_return#1 ← (word~) point_init::abs16s2_$1#0
  to:point_init::abs16s2_@return
point_init::abs16s2_@return: scope:[point_init]  from point_init::abs16s2_@1 point_init::abs16s2_@3
  (signed word) point_init::y_diff#11 ← phi( point_init::abs16s2_@1/(signed word) point_init::y_diff#12 point_init::abs16s2_@3/(signed word) point_init::y_diff#13 )
  (byte) point_init::point_idx#9 ← phi( point_init::abs16s2_@1/(byte) point_init::point_idx#10 point_init::abs16s2_@3/(byte) point_init::point_idx#11 )
  (signed word) point_init::x_diff#6 ← phi( point_init::abs16s2_@1/(signed word) point_init::x_diff#7 point_init::abs16s2_@3/(signed word) point_init::x_diff#8 )
  (word) point_init::abs16s2_return#3 ← phi( point_init::abs16s2_@1/(word) point_init::abs16s2_return#0 point_init::abs16s2_@3/(word) point_init::abs16s2_return#1 )
  (word) point_init::abs16s2_return#2 ← (word) point_init::abs16s2_return#3
  to:point_init::@10
point_init::@10: scope:[point_init]  from point_init::abs16s2_@return
  (signed word) point_init::y_diff#10 ← phi( point_init::abs16s2_@return/(signed word) point_init::y_diff#11 )
  (byte) point_init::point_idx#6 ← phi( point_init::abs16s2_@return/(byte) point_init::point_idx#9 )
  (signed word) point_init::x_diff#3 ← phi( point_init::abs16s2_@return/(signed word) point_init::x_diff#6 )
  (word) point_init::abs16s2_return#4 ← phi( point_init::abs16s2_@return/(word) point_init::abs16s2_return#2 )
  (word~) point_init::$7 ← (word) point_init::abs16s2_return#4
  (bool~) point_init::$8 ← (word~) point_init::$6 > (word~) point_init::$7
  if((bool~) point_init::$8) goto point_init::@1
  to:point_init::@2
point_init::@1: scope:[point_init]  from point_init::@10
  (signed word) point_init::y_diff#8 ← phi( point_init::@10/(signed word) point_init::y_diff#10 )
  (byte) point_init::point_idx#7 ← phi( point_init::@10/(byte) point_init::point_idx#6 )
  (signed word) point_init::x_diff#1 ← phi( point_init::@10/(signed word) point_init::x_diff#3 )
  (bool~) point_init::$12 ← (signed word) point_init::x_diff#1 < (number) 0
  if((bool~) point_init::$12) goto point_init::@7
  to:point_init::@5
point_init::@2: scope:[point_init]  from point_init::@10 point_init::@11
  (byte) point_init::point_idx#2 ← phi( point_init::@10/(byte) point_init::point_idx#6 point_init::@11/(byte) point_init::point_idx#5 )
  (byte~) point_init::$19 ← (byte) point_init::point_idx#2 * (const byte) SIZEOF_WORD
  (number~) point_init::$9 ← *((word[SIZE#0]) x_start#0 + (byte~) point_init::$19) * (number) $10
  (byte~) point_init::$20 ← (byte) point_init::point_idx#2 * (const byte) SIZEOF_WORD
  *((word[SIZE#0]) x_cur#0 + (byte~) point_init::$20) ← (number~) point_init::$9
  (word~) point_init::$10 ← ((word)) *((byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#2)
  (number~) point_init::$11 ← (word~) point_init::$10 * (number) $10
  (byte~) point_init::$21 ← (byte) point_init::point_idx#2 * (const byte) SIZEOF_WORD
  *((word[SIZE#0]) y_cur#0 + (byte~) point_init::$21) ← (number~) point_init::$11
  *((byte[SIZE#0]) delay#0 + (byte) point_init::point_idx#2) ← (byte) DELAY#0
  to:point_init::@return
point_init::@7: scope:[point_init]  from point_init::@1
  (signed word) point_init::y_diff#5 ← phi( point_init::@1/(signed word) point_init::y_diff#8 )
  (signed word) point_init::x_diff#5 ← phi( point_init::@1/(signed word) point_init::x_diff#1 )
  (byte) point_init::point_idx#3 ← phi( point_init::@1/(byte) point_init::point_idx#7 )
  *((signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#3) ← (number) -$10
  to:point_init::@8
point_init::@5: scope:[point_init]  from point_init::@1
  (signed word) point_init::y_diff#4 ← phi( point_init::@1/(signed word) point_init::y_diff#8 )
  (signed word) point_init::x_diff#4 ← phi( point_init::@1/(signed word) point_init::x_diff#1 )
  (byte) point_init::point_idx#4 ← phi( point_init::@1/(byte) point_init::point_idx#7 )
  *((signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#4) ← (number) $10
  to:point_init::@8
point_init::@8: scope:[point_init]  from point_init::@5 point_init::@7
  (byte) point_init::point_idx#8 ← phi( point_init::@5/(byte) point_init::point_idx#4 point_init::@7/(byte) point_init::point_idx#3 )
  (signed word) point_init::y_diff#2 ← phi( point_init::@5/(signed word) point_init::y_diff#4 point_init::@7/(signed word) point_init::y_diff#5 )
  (signed word) point_init::x_diff#2 ← phi( point_init::@5/(signed word) point_init::x_diff#4 point_init::@7/(signed word) point_init::x_diff#5 )
  (signed word) divr16s::dividend#0 ← (number) 0
  (signed word) divr16s::divisor#0 ← (signed word) point_init::x_diff#2
  (signed word) divr16s::rem#0 ← (signed word) point_init::y_diff#2
  call divr16s 
  (signed word) divr16s::return#3 ← (signed word) divr16s::return#2
  to:point_init::@11
point_init::@11: scope:[point_init]  from point_init::@8
  (byte) point_init::point_idx#5 ← phi( point_init::@8/(byte) point_init::point_idx#8 )
  (signed word) divr16s::return#5 ← phi( point_init::@8/(signed word) divr16s::return#3 )
  (signed word~) point_init::$13 ← (signed word) divr16s::return#5
  (signed word) point_init::x_stepf#0 ← (signed word~) point_init::$13
  (byte~) point_init::$14 ← > (signed word) point_init::x_stepf#0
  (number~) point_init::$15 ← (byte~) point_init::$14 / (number) $10
  (signed byte~) point_init::$16 ← ((signed byte)) (number~) point_init::$15
  *((signed byte[SIZE#0]) y_add#0 + (byte) point_init::point_idx#5) ← (signed byte~) point_init::$16
  to:point_init::@2
point_init::@return: scope:[point_init]  from point_init::@2
  return 
  to:@return
screen_fill: scope:[screen_fill]  from main::@18
  (byte*) screen_fill::screen#4 ← phi( main::@18/(byte*) screen_fill::screen#0 )
  (byte) screen_fill::ch#3 ← phi( main::@18/(byte) screen_fill::ch#0 )
  (byte) screen_fill::y#0 ← (byte) 0
  to:screen_fill::@1
screen_fill::@1: scope:[screen_fill]  from screen_fill screen_fill::@3
  (byte) screen_fill::y#4 ← phi( screen_fill/(byte) screen_fill::y#0 screen_fill::@3/(byte) screen_fill::y#1 )
  (byte*) screen_fill::screen#3 ← phi( screen_fill/(byte*) screen_fill::screen#4 screen_fill::@3/(byte*) screen_fill::screen#5 )
  (byte) screen_fill::ch#2 ← phi( screen_fill/(byte) screen_fill::ch#3 screen_fill::@3/(byte) screen_fill::ch#4 )
  (byte) screen_fill::x#0 ← (byte) 0
  to:screen_fill::@2
screen_fill::@2: scope:[screen_fill]  from screen_fill::@1 screen_fill::@2
  (byte) screen_fill::y#3 ← phi( screen_fill::@1/(byte) screen_fill::y#4 screen_fill::@2/(byte) screen_fill::y#3 )
  (byte) screen_fill::x#2 ← phi( screen_fill::@1/(byte) screen_fill::x#0 screen_fill::@2/(byte) screen_fill::x#1 )
  (byte*) screen_fill::screen#2 ← phi( screen_fill::@1/(byte*) screen_fill::screen#3 screen_fill::@2/(byte*) screen_fill::screen#1 )
  (byte) screen_fill::ch#1 ← phi( screen_fill::@1/(byte) screen_fill::ch#2 screen_fill::@2/(byte) screen_fill::ch#1 )
  *((byte*) screen_fill::screen#2) ← (byte) screen_fill::ch#1
  (byte*) screen_fill::screen#1 ← ++ (byte*) screen_fill::screen#2
  (byte) screen_fill::x#1 ← (byte) screen_fill::x#2 + rangenext(0,$27)
  (bool~) screen_fill::$0 ← (byte) screen_fill::x#1 != rangelast(0,$27)
  if((bool~) screen_fill::$0) goto screen_fill::@2
  to:screen_fill::@3
screen_fill::@3: scope:[screen_fill]  from screen_fill::@2
  (byte*) screen_fill::screen#5 ← phi( screen_fill::@2/(byte*) screen_fill::screen#1 )
  (byte) screen_fill::ch#4 ← phi( screen_fill::@2/(byte) screen_fill::ch#1 )
  (byte) screen_fill::y#2 ← phi( screen_fill::@2/(byte) screen_fill::y#3 )
  (byte) screen_fill::y#1 ← (byte) screen_fill::y#2 + rangenext(0,$18)
  (bool~) screen_fill::$1 ← (byte) screen_fill::y#1 != rangelast(0,$18)
  if((bool~) screen_fill::$1) goto screen_fill::@1
  to:screen_fill::@return
screen_fill::@return: scope:[screen_fill]  from screen_fill::@3
  return 
  to:@return
@16: scope:[]  from @12
  (byte[$100]) bitmap_plot_ylo#0 ← { fill( $100, 0) }
  (byte[$100]) bitmap_plot_yhi#0 ← { fill( $100, 0) }
  (byte[$100]) bitmap_plot_bit#0 ← { fill( $100, 0) }
  to:@19
bitmap_init: scope:[bitmap_init]  from main::@16
  (byte*) bitmap_init::bitmap#5 ← phi( main::@16/(byte*) bitmap_init::bitmap#0 )
  (byte) bitmap_init::bits#0 ← (number) $80
  (byte) bitmap_init::x#0 ← (byte) 0
  to:bitmap_init::@1
bitmap_init::@1: scope:[bitmap_init]  from bitmap_init bitmap_init::@2
  (byte*) bitmap_init::bitmap#3 ← phi( bitmap_init/(byte*) bitmap_init::bitmap#5 bitmap_init::@2/(byte*) bitmap_init::bitmap#2 )
  (byte) bitmap_init::x#2 ← phi( bitmap_init/(byte) bitmap_init::x#0 bitmap_init::@2/(byte) bitmap_init::x#1 )
  (byte) bitmap_init::bits#3 ← phi( bitmap_init/(byte) bitmap_init::bits#0 bitmap_init::@2/(byte) bitmap_init::bits#4 )
  *((byte[$100]) bitmap_plot_bit#0 + (byte) bitmap_init::x#2) ← (byte) bitmap_init::bits#3
  (byte) bitmap_init::bits#1 ← (byte) bitmap_init::bits#3 >> (number) 1
  (bool~) bitmap_init::$0 ← (byte) bitmap_init::bits#1 == (number) 0
  (bool~) bitmap_init::$1 ← ! (bool~) bitmap_init::$0
  if((bool~) bitmap_init::$1) goto bitmap_init::@2
  to:bitmap_init::@3
bitmap_init::@2: scope:[bitmap_init]  from bitmap_init::@1 bitmap_init::@3
  (byte*) bitmap_init::bitmap#2 ← phi( bitmap_init::@1/(byte*) bitmap_init::bitmap#3 bitmap_init::@3/(byte*) bitmap_init::bitmap#4 )
  (byte) bitmap_init::bits#4 ← phi( bitmap_init::@1/(byte) bitmap_init::bits#1 bitmap_init::@3/(byte) bitmap_init::bits#2 )
  (byte) bitmap_init::x#3 ← phi( bitmap_init::@1/(byte) bitmap_init::x#2 bitmap_init::@3/(byte) bitmap_init::x#4 )
  (byte) bitmap_init::x#1 ← (byte) bitmap_init::x#3 + rangenext(0,$ff)
  (bool~) bitmap_init::$2 ← (byte) bitmap_init::x#1 != rangelast(0,$ff)
  if((bool~) bitmap_init::$2) goto bitmap_init::@1
  to:bitmap_init::@4
bitmap_init::@3: scope:[bitmap_init]  from bitmap_init::@1
  (byte*) bitmap_init::bitmap#4 ← phi( bitmap_init::@1/(byte*) bitmap_init::bitmap#3 )
  (byte) bitmap_init::x#4 ← phi( bitmap_init::@1/(byte) bitmap_init::x#2 )
  (byte) bitmap_init::bits#2 ← (number) $80
  to:bitmap_init::@2
bitmap_init::@4: scope:[bitmap_init]  from bitmap_init::@2
  (byte*) bitmap_init::bitmap#1 ← phi( bitmap_init::@2/(byte*) bitmap_init::bitmap#2 )
  (byte*) bitmap_init::yoffs#0 ← (byte*) bitmap_init::bitmap#1
  (byte) bitmap_init::y#0 ← (byte) 0
  to:bitmap_init::@5
bitmap_init::@5: scope:[bitmap_init]  from bitmap_init::@4 bitmap_init::@6
  (byte*) bitmap_init::yoffs#2 ← phi( bitmap_init::@4/(byte*) bitmap_init::yoffs#0 bitmap_init::@6/(byte*) bitmap_init::yoffs#4 )
  (byte) bitmap_init::y#2 ← phi( bitmap_init::@4/(byte) bitmap_init::y#0 bitmap_init::@6/(byte) bitmap_init::y#1 )
  (number~) bitmap_init::$3 ← (byte) bitmap_init::y#2 & (number) 7
  (byte~) bitmap_init::$4 ← < (byte*) bitmap_init::yoffs#2
  (number~) bitmap_init::$5 ← (number~) bitmap_init::$3 | (byte~) bitmap_init::$4
  *((byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_init::y#2) ← (number~) bitmap_init::$5
  (byte~) bitmap_init::$6 ← > (byte*) bitmap_init::yoffs#2
  *((byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_init::y#2) ← (byte~) bitmap_init::$6
  (number~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (number) 7
  (bool~) bitmap_init::$8 ← (number~) bitmap_init::$7 == (number) 7
  (bool~) bitmap_init::$9 ← ! (bool~) bitmap_init::$8
  if((bool~) bitmap_init::$9) goto bitmap_init::@6
  to:bitmap_init::@7
bitmap_init::@6: scope:[bitmap_init]  from bitmap_init::@5 bitmap_init::@7
  (byte*) bitmap_init::yoffs#4 ← phi( bitmap_init::@5/(byte*) bitmap_init::yoffs#2 bitmap_init::@7/(byte*) bitmap_init::yoffs#1 )
  (byte) bitmap_init::y#3 ← phi( bitmap_init::@5/(byte) bitmap_init::y#2 bitmap_init::@7/(byte) bitmap_init::y#4 )
  (byte) bitmap_init::y#1 ← (byte) bitmap_init::y#3 + rangenext(0,$ff)
  (bool~) bitmap_init::$11 ← (byte) bitmap_init::y#1 != rangelast(0,$ff)
  if((bool~) bitmap_init::$11) goto bitmap_init::@5
  to:bitmap_init::@return
bitmap_init::@7: scope:[bitmap_init]  from bitmap_init::@5
  (byte) bitmap_init::y#4 ← phi( bitmap_init::@5/(byte) bitmap_init::y#2 )
  (byte*) bitmap_init::yoffs#3 ← phi( bitmap_init::@5/(byte*) bitmap_init::yoffs#2 )
  (byte*~) bitmap_init::$10 ← (byte*) bitmap_init::yoffs#3 + (number) $28*(number) 8
  (byte*) bitmap_init::yoffs#1 ← (byte*~) bitmap_init::$10
  to:bitmap_init::@6
bitmap_init::@return: scope:[bitmap_init]  from bitmap_init::@6
  return 
  to:@return
bitmap_clear: scope:[bitmap_clear]  from main::@17
  (byte*~) bitmap_clear::$0 ← ((byte*)) { *((byte[$100]) bitmap_plot_yhi#0 + (number) 0), *((byte[$100]) bitmap_plot_ylo#0 + (number) 0) }
  (byte*) bitmap_clear::bitmap#0 ← (byte*~) bitmap_clear::$0
  (byte) bitmap_clear::y#0 ← (byte) 0
  to:bitmap_clear::@1
bitmap_clear::@1: scope:[bitmap_clear]  from bitmap_clear bitmap_clear::@3
  (byte) bitmap_clear::y#4 ← phi( bitmap_clear/(byte) bitmap_clear::y#0 bitmap_clear::@3/(byte) bitmap_clear::y#1 )
  (byte*) bitmap_clear::bitmap#3 ← phi( bitmap_clear/(byte*) bitmap_clear::bitmap#0 bitmap_clear::@3/(byte*) bitmap_clear::bitmap#4 )
  (byte) bitmap_clear::x#0 ← (byte) 0
  to:bitmap_clear::@2
bitmap_clear::@2: scope:[bitmap_clear]  from bitmap_clear::@1 bitmap_clear::@2
  (byte) bitmap_clear::y#3 ← phi( bitmap_clear::@1/(byte) bitmap_clear::y#4 bitmap_clear::@2/(byte) bitmap_clear::y#3 )
  (byte) bitmap_clear::x#2 ← phi( bitmap_clear::@1/(byte) bitmap_clear::x#0 bitmap_clear::@2/(byte) bitmap_clear::x#1 )
  (byte*) bitmap_clear::bitmap#2 ← phi( bitmap_clear::@1/(byte*) bitmap_clear::bitmap#3 bitmap_clear::@2/(byte*) bitmap_clear::bitmap#1 )
  *((byte*) bitmap_clear::bitmap#2) ← (number) 0
  (byte*) bitmap_clear::bitmap#1 ← ++ (byte*) bitmap_clear::bitmap#2
  (byte) bitmap_clear::x#1 ← (byte) bitmap_clear::x#2 + rangenext(0,$c7)
  (bool~) bitmap_clear::$1 ← (byte) bitmap_clear::x#1 != rangelast(0,$c7)
  if((bool~) bitmap_clear::$1) goto bitmap_clear::@2
  to:bitmap_clear::@3
bitmap_clear::@3: scope:[bitmap_clear]  from bitmap_clear::@2
  (byte*) bitmap_clear::bitmap#4 ← phi( bitmap_clear::@2/(byte*) bitmap_clear::bitmap#1 )
  (byte) bitmap_clear::y#2 ← phi( bitmap_clear::@2/(byte) bitmap_clear::y#3 )
  (byte) bitmap_clear::y#1 ← (byte) bitmap_clear::y#2 + rangenext(0,$27)
  (bool~) bitmap_clear::$2 ← (byte) bitmap_clear::y#1 != rangelast(0,$27)
  if((bool~) bitmap_clear::$2) goto bitmap_clear::@1
  to:bitmap_clear::@return
bitmap_clear::@return: scope:[bitmap_clear]  from bitmap_clear::@3
  return 
  to:@return
bitmap_plot: scope:[bitmap_plot]  from main::@20
  (word) bitmap_plot::x#1 ← phi( main::@20/(word) bitmap_plot::x#0 )
  (byte) bitmap_plot::y#1 ← phi( main::@20/(byte) bitmap_plot::y#0 )
  (byte*~) bitmap_plot::$0 ← ((byte*)) { *((byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_plot::y#1), *((byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_plot::y#1) }
  (byte*) bitmap_plot::plotter#0 ← (byte*~) bitmap_plot::$0
  (number~) bitmap_plot::$1 ← (word) bitmap_plot::x#1 & (number) $fff8
  (byte*) bitmap_plot::plotter#1 ← (byte*) bitmap_plot::plotter#0 + (number~) bitmap_plot::$1
  (byte~) bitmap_plot::$2 ← < (word) bitmap_plot::x#1
  *((byte*) bitmap_plot::plotter#1) ← *((byte*) bitmap_plot::plotter#1) | *((byte[$100]) bitmap_plot_bit#0 + (byte~) bitmap_plot::$2)
  to:bitmap_plot::@return
bitmap_plot::@return: scope:[bitmap_plot]  from bitmap_plot
  return 
  to:@return
@19: scope:[]  from @16
  call main 
  to:@20
@20: scope:[]  from @19
  to:@end
@end: scope:[]  from @20

SYMBOL TABLE SSA
(label) @12
(label) @16
(label) @19
(label) @20
(label) @begin
(label) @end
(byte*) BITMAP
(byte*) BITMAP#0
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte*) CIA2_PORT_A
(byte*) CIA2_PORT_A#0
(byte*) CIA2_PORT_A_DDR
(byte*) CIA2_PORT_A_DDR#0
(byte*) D011
(byte*) D011#0
(byte*) D018
(byte*) D018#0
(byte) DELAY
(byte) DELAY#0
(byte*) PROCPORT
(byte*) PROCPORT#0
(byte*) PROCPORT_DDR
(byte*) PROCPORT_DDR#0
(byte) PROCPORT_DDR_MEMORY_MASK
(byte) PROCPORT_DDR_MEMORY_MASK#0
(byte) PROCPORT_RAM_IO
(byte) PROCPORT_RAM_IO#0
(byte*) RASTER
(byte*) RASTER#0
(byte*) SCREEN
(byte*) SCREEN#0
(byte) SIZE
(byte) SIZE#0
(const byte) SIZEOF_WORD = (byte) 2
(byte) VIC_BMM
(byte) VIC_BMM#0
(byte) VIC_DEN
(byte) VIC_DEN#0
(byte) VIC_RSEL
(byte) VIC_RSEL#0
(void()) bitmap_clear()
(byte*~) bitmap_clear::$0
(bool~) bitmap_clear::$1
(bool~) bitmap_clear::$2
(label) bitmap_clear::@1
(label) bitmap_clear::@2
(label) bitmap_clear::@3
(label) bitmap_clear::@return
(byte*) bitmap_clear::bitmap
(byte*) bitmap_clear::bitmap#0
(byte*) bitmap_clear::bitmap#1
(byte*) bitmap_clear::bitmap#2
(byte*) bitmap_clear::bitmap#3
(byte*) bitmap_clear::bitmap#4
(byte) bitmap_clear::x
(byte) bitmap_clear::x#0
(byte) bitmap_clear::x#1
(byte) bitmap_clear::x#2
(byte) bitmap_clear::y
(byte) bitmap_clear::y#0
(byte) bitmap_clear::y#1
(byte) bitmap_clear::y#2
(byte) bitmap_clear::y#3
(byte) bitmap_clear::y#4
(void()) bitmap_init((byte*) bitmap_init::bitmap)
(bool~) bitmap_init::$0
(bool~) bitmap_init::$1
(byte*~) bitmap_init::$10
(bool~) bitmap_init::$11
(bool~) bitmap_init::$2
(number~) bitmap_init::$3
(byte~) bitmap_init::$4
(number~) bitmap_init::$5
(byte~) bitmap_init::$6
(number~) bitmap_init::$7
(bool~) bitmap_init::$8
(bool~) bitmap_init::$9
(label) bitmap_init::@1
(label) bitmap_init::@2
(label) bitmap_init::@3
(label) bitmap_init::@4
(label) bitmap_init::@5
(label) bitmap_init::@6
(label) bitmap_init::@7
(label) bitmap_init::@return
(byte*) bitmap_init::bitmap
(byte*) bitmap_init::bitmap#0
(byte*) bitmap_init::bitmap#1
(byte*) bitmap_init::bitmap#2
(byte*) bitmap_init::bitmap#3
(byte*) bitmap_init::bitmap#4
(byte*) bitmap_init::bitmap#5
(byte) bitmap_init::bits
(byte) bitmap_init::bits#0
(byte) bitmap_init::bits#1
(byte) bitmap_init::bits#2
(byte) bitmap_init::bits#3
(byte) bitmap_init::bits#4
(byte) bitmap_init::x
(byte) bitmap_init::x#0
(byte) bitmap_init::x#1
(byte) bitmap_init::x#2
(byte) bitmap_init::x#3
(byte) bitmap_init::x#4
(byte) bitmap_init::y
(byte) bitmap_init::y#0
(byte) bitmap_init::y#1
(byte) bitmap_init::y#2
(byte) bitmap_init::y#3
(byte) bitmap_init::y#4
(byte*) bitmap_init::yoffs
(byte*) bitmap_init::yoffs#0
(byte*) bitmap_init::yoffs#1
(byte*) bitmap_init::yoffs#2
(byte*) bitmap_init::yoffs#3
(byte*) bitmap_init::yoffs#4
(void()) bitmap_plot((word) bitmap_plot::x , (byte) bitmap_plot::y)
(byte*~) bitmap_plot::$0
(number~) bitmap_plot::$1
(byte~) bitmap_plot::$2
(label) bitmap_plot::@return
(byte*) bitmap_plot::plotter
(byte*) bitmap_plot::plotter#0
(byte*) bitmap_plot::plotter#1
(word) bitmap_plot::x
(word) bitmap_plot::x#0
(word) bitmap_plot::x#1
(byte) bitmap_plot::y
(byte) bitmap_plot::y#0
(byte) bitmap_plot::y#1
(byte[$100]) bitmap_plot_bit
(byte[$100]) bitmap_plot_bit#0
(byte[$100]) bitmap_plot_yhi
(byte[$100]) bitmap_plot_yhi#0
(byte[$100]) bitmap_plot_ylo
(byte[$100]) bitmap_plot_ylo#0
(byte[SIZE#0]) delay
(byte[SIZE#0]) delay#0
(signed word()) divr16s((signed word) divr16s::dividend , (signed word) divr16s::divisor , (signed word) divr16s::rem)
(bool~) divr16s::$0
(bool~) divr16s::$1
(signed word~) divr16s::$10
(word~) divr16s::$11
(word~) divr16s::$12
(signed word~) divr16s::$13
(word~) divr16s::$14
(number~) divr16s::$15
(signed word~) divr16s::$18
(signed word~) divr16s::$19
(bool~) divr16s::$2
(signed word~) divr16s::$21
(bool~) divr16s::$3
(word~) divr16s::$4
(bool~) divr16s::$5
(word~) divr16s::$6
(word~) divr16s::$7
(signed word~) divr16s::$8
(word~) divr16s::$9
(label) divr16s::@1
(label) divr16s::@11
(label) divr16s::@15
(label) divr16s::@2
(label) divr16s::@3
(label) divr16s::@4
(label) divr16s::@5
(label) divr16s::@7
(label) divr16s::@9
(label) divr16s::@return
(signed word) divr16s::dividend
(signed word) divr16s::dividend#0
(signed word) divr16s::dividend#1
(signed word) divr16s::dividend#2
(signed word) divr16s::dividend#3
(word) divr16s::dividendu
(word) divr16s::dividendu#0
(word) divr16s::dividendu#1
(word) divr16s::dividendu#2
(word) divr16s::dividendu#3
(word) divr16s::dividendu#4
(word) divr16s::dividendu#5
(word) divr16s::dividendu#6
(signed word) divr16s::divisor
(signed word) divr16s::divisor#0
(signed word) divr16s::divisor#1
(signed word) divr16s::divisor#2
(signed word) divr16s::divisor#3
(signed word) divr16s::divisor#4
(signed word) divr16s::divisor#5
(signed word) divr16s::divisor#6
(word) divr16s::divisoru
(word) divr16s::divisoru#0
(word) divr16s::divisoru#1
(word) divr16s::divisoru#2
(word) divr16s::divisoru#3
(byte) divr16s::neg
(byte) divr16s::neg#0
(byte) divr16s::neg#1
(byte) divr16s::neg#2
(byte) divr16s::neg#3
(byte) divr16s::neg#4
(byte) divr16s::neg#5
(byte) divr16s::neg#6
(byte) divr16s::neg#7
(byte) divr16s::neg#8
(signed word) divr16s::rem
(signed word) divr16s::rem#0
(signed word) divr16s::rem#1
(signed word) divr16s::rem#2
(signed word) divr16s::rem#3
(word) divr16s::remu
(word) divr16s::remu#0
(word) divr16s::remu#1
(word) divr16s::remu#2
(word) divr16s::remu#3
(word) divr16s::remu#4
(word) divr16s::remu#5
(word) divr16s::remu#6
(word) divr16s::resultu
(word) divr16s::resultu#0
(word) divr16s::resultu#1
(word) divr16s::resultu#2
(signed word) divr16s::return
(signed word) divr16s::return#0
(signed word) divr16s::return#1
(signed word) divr16s::return#2
(signed word) divr16s::return#3
(signed word) divr16s::return#4
(signed word) divr16s::return#5
(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
(word~) divr16u::$0
(byte~) divr16u::$1
(word~) divr16u::$10
(bool~) divr16u::$11
(number~) divr16u::$2
(bool~) divr16u::$3
(bool~) divr16u::$4
(number~) divr16u::$5
(word~) divr16u::$6
(word~) divr16u::$7
(bool~) divr16u::$8
(bool~) divr16u::$9
(label) divr16u::@1
(label) divr16u::@2
(label) divr16u::@3
(label) divr16u::@4
(label) divr16u::@5
(label) divr16u::@6
(label) divr16u::@return
(word) divr16u::dividend
(word) divr16u::dividend#0
(word) divr16u::dividend#1
(word) divr16u::dividend#2
(word) divr16u::dividend#3
(word) divr16u::dividend#4
(word) divr16u::dividend#5
(word) divr16u::dividend#6
(word) divr16u::dividend#7
(word) divr16u::divisor
(word) divr16u::divisor#0
(word) divr16u::divisor#1
(word) divr16u::divisor#2
(word) divr16u::divisor#3
(word) divr16u::divisor#4
(word) divr16u::divisor#5
(word) divr16u::divisor#6
(byte) divr16u::i
(byte) divr16u::i#0
(byte) divr16u::i#1
(byte) divr16u::i#2
(byte) divr16u::i#3
(byte) divr16u::i#4
(byte) divr16u::i#5
(byte) divr16u::i#6
(word) divr16u::quotient
(word) divr16u::quotient#0
(word) divr16u::quotient#1
(word) divr16u::quotient#2
(word) divr16u::quotient#3
(word) divr16u::quotient#4
(word) divr16u::quotient#5
(word) divr16u::quotient#6
(word) divr16u::quotient#7
(word) divr16u::quotient#8
(word) divr16u::rem
(word) divr16u::rem#0
(word) divr16u::rem#1
(word) divr16u::rem#2
(word) divr16u::rem#3
(word) divr16u::rem#4
(word) divr16u::rem#5
(word) divr16u::rem#6
(word) divr16u::rem#7
(word) divr16u::rem#8
(word) divr16u::rem#9
(word) divr16u::return
(word) divr16u::return#0
(word) divr16u::return#1
(word) divr16u::return#2
(word) divr16u::return#3
(word) divr16u::return#4
(void()) main()
(byte~) main::$0
(byte~) main::$1
(bool~) main::$11
(bool~) main::$12
(byte~) main::$13
(number~) main::$2
(byte~) main::$4
(number~) main::$8
(label) main::@1
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@20
(label) main::@21
(label) main::@3
(label) main::@6
(label) main::@8
(label) main::@return
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte) main::i#3
(byte) main::i#4
(label) main::toD0181
(word~) main::toD0181_$0
(word~) main::toD0181_$0#0
(number~) main::toD0181_$1
(number~) main::toD0181_$1#0
(number~) main::toD0181_$2
(number~) main::toD0181_$2#0
(number~) main::toD0181_$3
(number~) main::toD0181_$3#0
(word~) main::toD0181_$4
(word~) main::toD0181_$4#0
(byte~) main::toD0181_$5
(byte~) main::toD0181_$5#0
(number~) main::toD0181_$6
(number~) main::toD0181_$6#0
(number~) main::toD0181_$7
(number~) main::toD0181_$7#0
(number~) main::toD0181_$8
(number~) main::toD0181_$8#0
(label) main::toD0181_@return
(byte*) main::toD0181_gfx
(byte*) main::toD0181_gfx#0
(byte*) main::toD0181_gfx#1
(byte) main::toD0181_return
(byte) main::toD0181_return#0
(byte) main::toD0181_return#1
(byte) main::toD0181_return#2
(byte) main::toD0181_return#3
(byte*) main::toD0181_screen
(byte*) main::toD0181_screen#0
(byte*) main::toD0181_screen#1
(label) main::vicSelectGfxBank1
(byte~) main::vicSelectGfxBank1_$0
(byte~) main::vicSelectGfxBank1_$0#0
(label) main::vicSelectGfxBank1_@1
(byte*) main::vicSelectGfxBank1_gfx
(byte*) main::vicSelectGfxBank1_gfx#0
(byte*) main::vicSelectGfxBank1_gfx#1
(label) main::vicSelectGfxBank1_toDd001
(word~) main::vicSelectGfxBank1_toDd001_$0
(word~) main::vicSelectGfxBank1_toDd001_$0#0
(byte~) main::vicSelectGfxBank1_toDd001_$1
(byte~) main::vicSelectGfxBank1_toDd001_$1#0
(number~) main::vicSelectGfxBank1_toDd001_$2
(number~) main::vicSelectGfxBank1_toDd001_$2#0
(number~) main::vicSelectGfxBank1_toDd001_$3
(number~) main::vicSelectGfxBank1_toDd001_$3#0
(label) main::vicSelectGfxBank1_toDd001_@return
(byte*) main::vicSelectGfxBank1_toDd001_gfx
(byte*) main::vicSelectGfxBank1_toDd001_gfx#0
(byte*) main::vicSelectGfxBank1_toDd001_gfx#1
(byte) main::vicSelectGfxBank1_toDd001_return
(byte) main::vicSelectGfxBank1_toDd001_return#0
(byte) main::vicSelectGfxBank1_toDd001_return#1
(byte) main::vicSelectGfxBank1_toDd001_return#2
(byte) main::vicSelectGfxBank1_toDd001_return#3
(void()) point_init((byte) point_init::point_idx)
(signed word~) point_init::$0
(signed word~) point_init::$1
(word~) point_init::$10
(number~) point_init::$11
(bool~) point_init::$12
(signed word~) point_init::$13
(byte~) point_init::$14
(number~) point_init::$15
(signed byte~) point_init::$16
(byte~) point_init::$17
(byte~) point_init::$18
(byte~) point_init::$19
(signed word~) point_init::$2
(byte~) point_init::$20
(byte~) point_init::$21
(signed word~) point_init::$3
(signed word~) point_init::$4
(signed word~) point_init::$5
(word~) point_init::$6
(word~) point_init::$7
(bool~) point_init::$8
(number~) point_init::$9
(label) point_init::@1
(label) point_init::@10
(label) point_init::@11
(label) point_init::@2
(label) point_init::@5
(label) point_init::@7
(label) point_init::@8
(label) point_init::@9
(label) point_init::@return
(label) point_init::abs16s1
(bool~) point_init::abs16s1_$0
(bool~) point_init::abs16s1_$0#0
(word~) point_init::abs16s1_$1
(word~) point_init::abs16s1_$1#0
(signed word~) point_init::abs16s1_$2
(signed word~) point_init::abs16s1_$2#0
(word~) point_init::abs16s1_$3
(word~) point_init::abs16s1_$3#0
(label) point_init::abs16s1_@1
(label) point_init::abs16s1_@3
(label) point_init::abs16s1_@return
(word) point_init::abs16s1_return
(word) point_init::abs16s1_return#0
(word) point_init::abs16s1_return#1
(word) point_init::abs16s1_return#2
(word) point_init::abs16s1_return#3
(word) point_init::abs16s1_return#4
(signed word) point_init::abs16s1_w
(signed word) point_init::abs16s1_w#0
(signed word) point_init::abs16s1_w#1
(signed word) point_init::abs16s1_w#2
(signed word) point_init::abs16s1_w#3
(label) point_init::abs16s2
(bool~) point_init::abs16s2_$0
(bool~) point_init::abs16s2_$0#0
(word~) point_init::abs16s2_$1
(word~) point_init::abs16s2_$1#0
(signed word~) point_init::abs16s2_$2
(signed word~) point_init::abs16s2_$2#0
(word~) point_init::abs16s2_$3
(word~) point_init::abs16s2_$3#0
(label) point_init::abs16s2_@1
(label) point_init::abs16s2_@3
(label) point_init::abs16s2_@return
(word) point_init::abs16s2_return
(word) point_init::abs16s2_return#0
(word) point_init::abs16s2_return#1
(word) point_init::abs16s2_return#2
(word) point_init::abs16s2_return#3
(word) point_init::abs16s2_return#4
(signed word) point_init::abs16s2_w
(signed word) point_init::abs16s2_w#0
(signed word) point_init::abs16s2_w#1
(signed word) point_init::abs16s2_w#2
(signed word) point_init::abs16s2_w#3
(byte) point_init::point_idx
(byte) point_init::point_idx#0
(byte) point_init::point_idx#1
(byte) point_init::point_idx#10
(byte) point_init::point_idx#11
(byte) point_init::point_idx#12
(byte) point_init::point_idx#13
(byte) point_init::point_idx#14
(byte) point_init::point_idx#15
(byte) point_init::point_idx#16
(byte) point_init::point_idx#17
(byte) point_init::point_idx#2
(byte) point_init::point_idx#3
(byte) point_init::point_idx#4
(byte) point_init::point_idx#5
(byte) point_init::point_idx#6
(byte) point_init::point_idx#7
(byte) point_init::point_idx#8
(byte) point_init::point_idx#9
(signed word) point_init::x_diff
(signed word) point_init::x_diff#0
(signed word) point_init::x_diff#1
(signed word) point_init::x_diff#10
(signed word) point_init::x_diff#11
(signed word) point_init::x_diff#12
(signed word) point_init::x_diff#13
(signed word) point_init::x_diff#14
(signed word) point_init::x_diff#2
(signed word) point_init::x_diff#3
(signed word) point_init::x_diff#4
(signed word) point_init::x_diff#5
(signed word) point_init::x_diff#6
(signed word) point_init::x_diff#7
(signed word) point_init::x_diff#8
(signed word) point_init::x_diff#9
(signed word) point_init::x_stepf
(signed word) point_init::x_stepf#0
(signed word) point_init::y_diff
(signed word) point_init::y_diff#0
(signed word) point_init::y_diff#1
(signed word) point_init::y_diff#10
(signed word) point_init::y_diff#11
(signed word) point_init::y_diff#12
(signed word) point_init::y_diff#13
(signed word) point_init::y_diff#14
(signed word) point_init::y_diff#2
(signed word) point_init::y_diff#3
(signed word) point_init::y_diff#4
(signed word) point_init::y_diff#5
(signed word) point_init::y_diff#6
(signed word) point_init::y_diff#7
(signed word) point_init::y_diff#8
(signed word) point_init::y_diff#9
(void()) screen_fill((byte*) screen_fill::screen , (byte) screen_fill::ch)
(bool~) screen_fill::$0
(bool~) screen_fill::$1
(label) screen_fill::@1
(label) screen_fill::@2
(label) screen_fill::@3
(label) screen_fill::@return
(byte) screen_fill::ch
(byte) screen_fill::ch#0
(byte) screen_fill::ch#1
(byte) screen_fill::ch#2
(byte) screen_fill::ch#3
(byte) screen_fill::ch#4
(byte*) screen_fill::screen
(byte*) screen_fill::screen#0
(byte*) screen_fill::screen#1
(byte*) screen_fill::screen#2
(byte*) screen_fill::screen#3
(byte*) screen_fill::screen#4
(byte*) screen_fill::screen#5
(byte) screen_fill::x
(byte) screen_fill::x#0
(byte) screen_fill::x#1
(byte) screen_fill::x#2
(byte) screen_fill::y
(byte) screen_fill::y#0
(byte) screen_fill::y#1
(byte) screen_fill::y#2
(byte) screen_fill::y#3
(byte) screen_fill::y#4
(signed byte[SIZE#0]) x_add
(signed byte[SIZE#0]) x_add#0
(word[SIZE#0]) x_cur
(word[SIZE#0]) x_cur#0
(word[SIZE#0]) x_end
(word[SIZE#0]) x_end#0
(word[SIZE#0]) x_start
(word[SIZE#0]) x_start#0
(signed byte[SIZE#0]) y_add
(signed byte[SIZE#0]) y_add#0
(word[SIZE#0]) y_cur
(word[SIZE#0]) y_cur#0
(byte[SIZE#0]) y_end
(byte[SIZE#0]) y_end#0
(byte[SIZE#0]) y_start
(byte[SIZE#0]) y_start#0

Fixing inline constructor with bitmap_clear::$3 ← (byte)*(bitmap_plot_yhi#0 + 0) w= (byte)*(bitmap_plot_ylo#0 + 0)
Fixing inline constructor with bitmap_plot::$3 ← (byte)*(bitmap_plot_yhi#0 + bitmap_plot::y#1) w= (byte)*(bitmap_plot_ylo#0 + bitmap_plot::y#1)
Successful SSA optimization Pass2FixInlineConstructors
Adding number conversion cast (unumber) 7 in (byte) PROCPORT_DDR_MEMORY_MASK#0 ← (number) 7
Adding number conversion cast (unumber) $35 in (byte) PROCPORT_RAM_IO#0 ← (number) $35
Adding number conversion cast (unumber) $20 in (byte) VIC_BMM#0 ← (number) $20
Adding number conversion cast (unumber) $10 in (byte) VIC_DEN#0 ← (number) $10
Adding number conversion cast (unumber) 8 in (byte) VIC_RSEL#0 ← (number) 8
Adding number conversion cast (unumber) 0 in (word) divr16u::quotient#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (word~) divr16u::$0 ← (word) divr16u::rem#4 << (number) 1
Adding number conversion cast (unumber) $80 in (number~) divr16u::$2 ← (byte~) divr16u::$1 & (number) $80
Adding number conversion cast (unumber) divr16u::$2 in (number~) divr16u::$2 ← (byte~) divr16u::$1 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) divr16u::$3 ← (unumber~) divr16u::$2 != (number) 0
Adding number conversion cast (unumber) 1 in (word~) divr16u::$6 ← (word) divr16u::dividend#3 << (number) 1
Adding number conversion cast (unumber) 1 in (word~) divr16u::$7 ← (word) divr16u::quotient#3 << (number) 1
Adding number conversion cast (unumber) 1 in (number~) divr16u::$5 ← (word) divr16u::rem#6 | (number) 1
Adding number conversion cast (unumber) divr16u::$5 in (number~) divr16u::$5 ← (word) divr16u::rem#6 | (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (byte) divr16s::neg#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (word) divr16s::dividendu#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (word) divr16s::remu#0 ← (number) 0
Adding number conversion cast (snumber) 0 in (bool~) divr16s::$0 ← (signed word) divr16s::dividend#1 < (number) 0
Adding number conversion cast (snumber) 0 in (bool~) divr16s::$1 ← (signed word) divr16s::rem#1 < (number) 0
Adding number conversion cast (unumber) 1 in (byte) divr16s::neg#1 ← (number) 1
Adding number conversion cast (unumber) 0 in (word) divr16s::divisoru#0 ← (number) 0
Adding number conversion cast (snumber) 0 in (bool~) divr16s::$3 ← (signed word) divr16s::divisor#1 < (number) 0
Adding number conversion cast (unumber) 1 in (number~) divr16s::$15 ← (byte) divr16s::neg#3 ^ (number) 1
Adding number conversion cast (unumber) divr16s::$15 in (number~) divr16s::$15 ← (byte) divr16s::neg#3 ^ (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) divr16s::$5 ← (byte) divr16s::neg#4 == (number) 0
Adding number conversion cast (unumber) 4 in (byte) SIZE#0 ← (number) 4
Adding number conversion cast (unumber) 8 in (byte) DELAY#0 ← (number) 8
Adding number conversion cast (unumber) 3 in (number~) main::$2 ← (byte~) main::$1 | (number) 3
Adding number conversion cast (unumber) main::$2 in (number~) main::$2 ← (byte~) main::$1 | (unumber)(number) 3
Adding number conversion cast (unumber) 3 in *((byte*) CIA2_PORT_A_DDR#0) ← (number) 3
Adding number conversion cast (unumber) $40 in (number~) main::vicSelectGfxBank1_toDd001_$2#0 ← (byte~) main::vicSelectGfxBank1_toDd001_$1#0 / (number) $40
Adding number conversion cast (unumber) main::vicSelectGfxBank1_toDd001_$2#0 in (number~) main::vicSelectGfxBank1_toDd001_$2#0 ← (byte~) main::vicSelectGfxBank1_toDd001_$1#0 / (unumber)(number) $40
Adding number conversion cast (unumber) 3 in (number~) main::vicSelectGfxBank1_toDd001_$3#0 ← (number) 3 ^ (unumber~) main::vicSelectGfxBank1_toDd001_$2#0
Adding number conversion cast (unumber) main::vicSelectGfxBank1_toDd001_$3#0 in (number~) main::vicSelectGfxBank1_toDd001_$3#0 ← (unumber)(number) 3 ^ (unumber~) main::vicSelectGfxBank1_toDd001_$2#0
Adding number conversion cast (unumber) $3fff in (number~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 & (number) $3fff
Adding number conversion cast (unumber) main::toD0181_$1#0 in (number~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$2#0 ← (unumber~) main::toD0181_$1#0 * (number) 4
Adding number conversion cast (unumber) main::toD0181_$2#0 in (number~) main::toD0181_$2#0 ← (unumber~) main::toD0181_$1#0 * (unumber)(number) 4
Adding number conversion cast (unumber) main::toD0181_$3#0 in (number~) main::toD0181_$3#0 ← > (unumber~) main::toD0181_$2#0
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$6#0 ← (byte~) main::toD0181_$5#0 / (number) 4
Adding number conversion cast (unumber) main::toD0181_$6#0 in (number~) main::toD0181_$6#0 ← (byte~) main::toD0181_$5#0 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) main::toD0181_$7#0 ← (unumber~) main::toD0181_$6#0 & (number) $f
Adding number conversion cast (unumber) main::toD0181_$7#0 in (number~) main::toD0181_$7#0 ← (unumber~) main::toD0181_$6#0 & (unumber)(number) $f
Adding number conversion cast (unumber) main::toD0181_$8#0 in (number~) main::toD0181_$8#0 ← (unumber~) main::toD0181_$3#0 | (unumber~) main::toD0181_$7#0
Adding number conversion cast (unumber) $10 in (byte) screen_fill::ch#0 ← (number) $10
Adding number conversion cast (unumber) 1 in (number~) main::$8 ← (byte) SIZE#0 - (number) 1
Adding number conversion cast (unumber) main::$8 in (number~) main::$8 ← (byte) SIZE#0 - (unumber)(number) 1
Adding number conversion cast (unumber) $ff in (bool~) main::$12 ← *((byte*) RASTER#0) != (number) $ff
Adding number conversion cast (snumber) 0 in (bool~) point_init::abs16s1_$0#0 ← (signed word) point_init::abs16s1_w#1 < (number) 0
Adding number conversion cast (snumber) 0 in (bool~) point_init::abs16s2_$0#0 ← (signed word) point_init::abs16s2_w#1 < (number) 0
Adding number conversion cast (snumber) 0 in (bool~) point_init::$12 ← (signed word) point_init::x_diff#1 < (number) 0
Adding number conversion cast (unumber) $10 in (number~) point_init::$9 ← *((word[SIZE#0]) x_start#0 + (byte~) point_init::$19) * (number) $10
Adding number conversion cast (unumber) point_init::$9 in (number~) point_init::$9 ← *((word[SIZE#0]) x_start#0 + (byte~) point_init::$19) * (unumber)(number) $10
Adding number conversion cast (unumber) $10 in (number~) point_init::$11 ← (word~) point_init::$10 * (number) $10
Adding number conversion cast (unumber) point_init::$11 in (number~) point_init::$11 ← (word~) point_init::$10 * (unumber)(number) $10
Adding number conversion cast (snumber) -$10 in *((signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#3) ← (number) -$10
Adding number conversion cast (snumber) $10 in *((signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#4) ← (number) $10
Adding number conversion cast (snumber) 0 in (signed word) divr16s::dividend#0 ← (number) 0
Adding number conversion cast (unumber) $10 in (number~) point_init::$15 ← (byte~) point_init::$14 / (number) $10
Adding number conversion cast (unumber) point_init::$15 in (number~) point_init::$15 ← (byte~) point_init::$14 / (unumber)(number) $10
Adding number conversion cast (unumber) $80 in (byte) bitmap_init::bits#0 ← (number) $80
Adding number conversion cast (unumber) 1 in (byte) bitmap_init::bits#1 ← (byte) bitmap_init::bits#3 >> (number) 1
Adding number conversion cast (unumber) 0 in (bool~) bitmap_init::$0 ← (byte) bitmap_init::bits#1 == (number) 0
Adding number conversion cast (unumber) $80 in (byte) bitmap_init::bits#2 ← (number) $80
Adding number conversion cast (unumber) 7 in (number~) bitmap_init::$3 ← (byte) bitmap_init::y#2 & (number) 7
Adding number conversion cast (unumber) bitmap_init::$3 in (number~) bitmap_init::$3 ← (byte) bitmap_init::y#2 & (unumber)(number) 7
Adding number conversion cast (unumber) bitmap_init::$5 in (number~) bitmap_init::$5 ← (unumber~) bitmap_init::$3 | (byte~) bitmap_init::$4
Adding number conversion cast (unumber) 7 in (number~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (number) 7
Adding number conversion cast (unumber) bitmap_init::$7 in (number~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (unumber)(number) 7
Adding number conversion cast (unumber) 7 in (bool~) bitmap_init::$8 ← (unumber~) bitmap_init::$7 == (number) 7
Adding number conversion cast (unumber) $28*8 in (byte*~) bitmap_init::$10 ← (byte*) bitmap_init::yoffs#3 + (number) $28*(number) 8
Adding number conversion cast (unumber) 0 in (var) bitmap_clear::$3 ← (byte)*((byte[$100]) bitmap_plot_yhi#0 + (number) 0) w= (byte)*((byte[$100]) bitmap_plot_ylo#0 + (number) 0)
Adding number conversion cast (unumber) 0 in (var) bitmap_clear::$3 ← (byte)*((byte[$100]) bitmap_plot_yhi#0 + (unumber)(number) 0) w= (byte)*((byte[$100]) bitmap_plot_ylo#0 + (number) 0)
Adding number conversion cast (unumber) 0 in *((byte*) bitmap_clear::bitmap#2) ← (number) 0
Adding number conversion cast (unumber) $fff8 in (number~) bitmap_plot::$1 ← (word) bitmap_plot::x#1 & (number) $fff8
Adding number conversion cast (unumber) bitmap_plot::$1 in (number~) bitmap_plot::$1 ← (word) bitmap_plot::x#1 & (unumber)(number) $fff8
Successful SSA optimization PassNAddNumberTypeConversions
Adding number conversion cast (word) to elements in (word[SIZE#0]) x_start#0 ← { (word)(number) $a, (word)(number) $14, (word)(number) $1e, (word)(number) $1e }
Adding number conversion cast (byte) to elements in (byte[SIZE#0]) y_start#0 ← { (byte)(number) $a, (byte)(number) $a, (byte)(number) $a, (byte)(number) $14 }
Adding number conversion cast (word) to elements in (word[SIZE#0]) x_end#0 ← { (word)(number) $14, (word)(number) $a, (word)(number) $14, (word)(number) $14 }
Adding number conversion cast (byte) to elements in (byte[SIZE#0]) y_end#0 ← { (byte)(number) $14, (byte)(number) $14, (byte)(number) $a, (byte)(number) $14 }
Successful SSA optimization PassNAddArrayNumberTypeConversions
Inlining cast (byte*) PROCPORT_DDR#0 ← (byte*)(number) 0
Inlining cast (byte) PROCPORT_DDR_MEMORY_MASK#0 ← (unumber)(number) 7
Inlining cast (byte*) PROCPORT#0 ← (byte*)(number) 1
Inlining cast (byte) PROCPORT_RAM_IO#0 ← (unumber)(number) $35
Inlining cast (byte*) RASTER#0 ← (byte*)(number) $d012
Inlining cast (byte*) BORDERCOL#0 ← (byte*)(number) $d020
Inlining cast (byte*) D011#0 ← (byte*)(number) $d011
Inlining cast (byte) VIC_BMM#0 ← (unumber)(number) $20
Inlining cast (byte) VIC_DEN#0 ← (unumber)(number) $10
Inlining cast (byte) VIC_RSEL#0 ← (unumber)(number) 8
Inlining cast (byte*) D018#0 ← (byte*)(number) $d018
Inlining cast (byte*) CIA2_PORT_A#0 ← (byte*)(number) $dd00
Inlining cast (byte*) CIA2_PORT_A_DDR#0 ← (byte*)(number) $dd02
Inlining cast (word) divr16u::quotient#0 ← (unumber)(number) 0
Inlining cast (byte) divr16s::neg#0 ← (unumber)(number) 0
Inlining cast (word) divr16s::dividendu#0 ← (unumber)(number) 0
Inlining cast (word) divr16s::remu#0 ← (unumber)(number) 0
Inlining cast (word~) divr16s::$9 ← (word)(signed word~) divr16s::$8
Inlining cast (word~) divr16s::$11 ← (word)(signed word~) divr16s::$10
Inlining cast (byte) divr16s::neg#1 ← (unumber)(number) 1
Inlining cast (word~) divr16s::$6 ← (word)(signed word) divr16s::dividend#3
Inlining cast (word~) divr16s::$7 ← (word)(signed word) divr16s::rem#3
Inlining cast (word) divr16s::divisoru#0 ← (unumber)(number) 0
Inlining cast (word~) divr16s::$14 ← (word)(signed word~) divr16s::$13
Inlining cast (word~) divr16s::$12 ← (word)(signed word) divr16s::divisor#3
Inlining cast (signed word~) divr16s::$21 ← (signed word)(word) divr16s::resultu#1
Inlining cast (signed word~) divr16s::$18 ← (signed word)(word) divr16s::resultu#2
Inlining cast (byte*) BITMAP#0 ← (byte*)(number) $a000
Inlining cast (byte*) SCREEN#0 ← (byte*)(number) $8800
Inlining cast (byte) SIZE#0 ← (unumber)(number) 4
Inlining cast (byte) DELAY#0 ← (unumber)(number) 8
Inlining cast *((byte*) CIA2_PORT_A_DDR#0) ← (unumber)(number) 3
Inlining cast (word~) main::vicSelectGfxBank1_toDd001_$0#0 ← (word)(byte*) main::vicSelectGfxBank1_toDd001_gfx#1
Inlining cast (word~) main::toD0181_$0#0 ← (word)(byte*) main::toD0181_screen#1
Inlining cast (word~) main::toD0181_$4#0 ← (word)(byte*) main::toD0181_gfx#1
Inlining cast (byte) screen_fill::ch#0 ← (unumber)(number) $10
Inlining cast (signed word~) point_init::$0 ← (signed word)*((word[SIZE#0]) x_end#0 + (byte~) point_init::$17)
Inlining cast (signed word~) point_init::$1 ← (signed word)*((word[SIZE#0]) x_start#0 + (byte~) point_init::$18)
Inlining cast (signed word~) point_init::$3 ← (signed word)*((byte[SIZE#0]) y_end#0 + (byte) point_init::point_idx#1)
Inlining cast (signed word~) point_init::$4 ← (signed word)*((byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#1)
Inlining cast (word~) point_init::abs16s1_$3#0 ← (word)(signed word~) point_init::abs16s1_$2#0
Inlining cast (word~) point_init::abs16s1_$1#0 ← (word)(signed word) point_init::abs16s1_w#3
Inlining cast (word~) point_init::abs16s2_$3#0 ← (word)(signed word~) point_init::abs16s2_$2#0
Inlining cast (word~) point_init::abs16s2_$1#0 ← (word)(signed word) point_init::abs16s2_w#3
Inlining cast (word~) point_init::$10 ← (word)*((byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#2)
Inlining cast *((signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#3) ← (snumber)(number) -$10
Inlining cast *((signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#4) ← (snumber)(number) $10
Inlining cast (signed word) divr16s::dividend#0 ← (snumber)(number) 0
Inlining cast (signed byte~) point_init::$16 ← (signed byte)(unumber~) point_init::$15
Inlining cast (byte) bitmap_init::bits#0 ← (unumber)(number) $80
Inlining cast (byte) bitmap_init::bits#2 ← (unumber)(number) $80
Inlining cast *((byte*) bitmap_clear::bitmap#2) ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 0
Simplifying constant integer cast 7
Simplifying constant pointer cast (byte*) 1
Simplifying constant integer cast $35
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53265
Simplifying constant integer cast $20
Simplifying constant integer cast $10
Simplifying constant integer cast 8
Simplifying constant pointer cast (byte*) 53272
Simplifying constant pointer cast (byte*) 56576
Simplifying constant pointer cast (byte*) 56578
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 40960
Simplifying constant pointer cast (byte*) 34816
Simplifying constant integer cast 4
Simplifying constant integer cast 8
Simplifying constant integer cast $a
Simplifying constant integer cast $14
Simplifying constant integer cast $1e
Simplifying constant integer cast $1e
Simplifying constant integer cast $a
Simplifying constant integer cast $a
Simplifying constant integer cast $a
Simplifying constant integer cast $14
Simplifying constant integer cast $14
Simplifying constant integer cast $a
Simplifying constant integer cast $14
Simplifying constant integer cast $14
Simplifying constant integer cast $14
Simplifying constant integer cast $14
Simplifying constant integer cast $a
Simplifying constant integer cast $14
Simplifying constant integer cast 3
Simplifying constant integer cast 3
Simplifying constant integer cast $40
Simplifying constant integer cast 3
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $10
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $10
Simplifying constant integer cast $10
Simplifying constant integer cast -$10
Simplifying constant integer cast $10
Simplifying constant integer cast 0
Simplifying constant integer cast $10
Simplifying constant integer cast $80
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $80
Simplifying constant integer cast 7
Simplifying constant integer cast 7
Simplifying constant integer cast 7
Simplifying constant integer cast *((byte[$100]) bitmap_plot_yhi#0 + (unumber)(number) 0)
Simplifying constant integer cast 0
Simplifying constant integer cast *((byte[$100]) bitmap_plot_ylo#0 + (unumber)(number) 0)
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast *((byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_plot::y#1)
Simplifying constant integer cast *((byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_plot::y#1)
Simplifying constant integer cast $fff8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) $35
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized signed number type (signed byte) 0
Finalized signed number type (signed byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized signed number type (signed byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 3
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized signed number type (signed byte) 0
Finalized signed number type (signed byte) 0
Finalized signed number type (signed byte) 0
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $10
Finalized signed number type (signed byte) -$10
Finalized signed number type (signed byte) $10
Finalized signed number type (signed byte) 0
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $fff8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80
Inferred type updated to word in (unumber~) divr16u::$5 ← (word) divr16u::rem#6 | (byte) 1
Inferred type updated to byte in (unumber~) divr16s::$15 ← (byte) divr16s::neg#3 ^ (byte) 1
Inferred type updated to byte in (unumber~) main::$2 ← (byte~) main::$1 | (byte) 3
Inferred type updated to byte in (unumber~) main::vicSelectGfxBank1_toDd001_$2#0 ← (byte~) main::vicSelectGfxBank1_toDd001_$1#0 / (byte) $40
Inferred type updated to byte in (unumber~) main::vicSelectGfxBank1_toDd001_$3#0 ← (byte) 3 ^ (byte~) main::vicSelectGfxBank1_toDd001_$2#0
Inferred type updated to word in (unumber~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 & (word) $3fff
Inferred type updated to word in (unumber~) main::toD0181_$2#0 ← (word~) main::toD0181_$1#0 * (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$3#0 ← > (word~) main::toD0181_$2#0
Inferred type updated to byte in (unumber~) main::toD0181_$6#0 ← (byte~) main::toD0181_$5#0 / (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$7#0 ← (byte~) main::toD0181_$6#0 & (byte) $f
Inferred type updated to byte in (unumber~) main::toD0181_$8#0 ← (byte~) main::toD0181_$3#0 | (byte~) main::toD0181_$7#0
Inferred type updated to byte in (unumber~) main::$8 ← (byte) SIZE#0 - (byte) 1
Inferred type updated to word in (unumber~) point_init::$9 ← *((word[SIZE#0]) x_start#0 + (byte~) point_init::$19) * (byte) $10
Inferred type updated to word in (unumber~) point_init::$11 ← (word~) point_init::$10 * (byte) $10
Inferred type updated to byte in (unumber~) point_init::$15 ← (byte~) point_init::$14 / (byte) $10
Inferred type updated to byte in (unumber~) bitmap_init::$3 ← (byte) bitmap_init::y#2 & (byte) 7
Inferred type updated to byte in (unumber~) bitmap_init::$5 ← (byte~) bitmap_init::$3 | (byte~) bitmap_init::$4
Inferred type updated to byte in (unumber~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (byte) 7
Inferred type updated to word in (unumber~) bitmap_plot::$1 ← (word) bitmap_plot::x#1 & (word) $fff8
Adding pointer type conversion cast (byte*) bitmap_clear::$0 in (byte*~) bitmap_clear::$0 ← (word~) bitmap_clear::$3
Adding pointer type conversion cast (byte*) bitmap_plot::$0 in (byte*~) bitmap_plot::$0 ← (word~) bitmap_plot::$3
Successful SSA optimization PassNAddTypeConversionAssignment
Inversing boolean not [22] (bool~) divr16u::$4 ← (byte~) divr16u::$2 == (byte) 0 from [21] (bool~) divr16u::$3 ← (byte~) divr16u::$2 != (byte) 0
Inversing boolean not [30] (bool~) divr16u::$9 ← (word) divr16u::rem#5 < (word) divr16u::divisor#1 from [29] (bool~) divr16u::$8 ← (word) divr16u::rem#5 >= (word) divr16u::divisor#1
Inversing boolean not [280] (bool~) bitmap_init::$1 ← (byte) bitmap_init::bits#1 != (byte) 0 from [279] (bool~) bitmap_init::$0 ← (byte) bitmap_init::bits#1 == (byte) 0
Inversing boolean not [300] (bool~) bitmap_init::$9 ← (byte~) bitmap_init::$7 != (byte) 7 from [299] (bool~) bitmap_init::$8 ← (byte~) bitmap_init::$7 == (byte) 7
Successful SSA optimization Pass2UnaryNotSimplification
Alias (word) divr16u::rem#0 = (word~) divr16u::$0 (word) divr16u::rem#6 
Alias (word) divr16u::dividend#0 = (word~) divr16u::$6 (word) divr16u::dividend#7 
Alias (word) divr16u::quotient#1 = (word~) divr16u::$7 (word) divr16u::quotient#4 
Alias (word) divr16u::dividend#2 = (word) divr16u::dividend#6 
Alias (word) divr16u::quotient#6 = (word) divr16u::quotient#7 
Alias (word) divr16u::divisor#3 = (word) divr16u::divisor#4 
Alias (byte) divr16u::i#5 = (byte) divr16u::i#6 
Alias (word) divr16u::rem#1 = (word~) divr16u::$5 
Alias (word) divr16u::rem#5 = (word) divr16u::rem#7 
Alias (word) divr16u::divisor#1 = (word) divr16u::divisor#2 
Alias (byte) divr16u::i#3 = (byte) divr16u::i#4 
Alias (word) divr16u::rem#2 = (word~) divr16u::$10 
Alias (word) divr16u::return#0 = (word) divr16u::quotient#5 (word) divr16u::quotient#8 (word) divr16u::return#3 (word) divr16u::return#1 
Alias (signed word) divr16s::dividend#1 = (signed word) divr16s::dividend#2 (signed word) divr16s::dividend#3 
Alias (signed word) divr16s::rem#1 = (signed word) divr16s::rem#2 (signed word) divr16s::rem#3 
Alias (signed word) divr16s::divisor#4 = (signed word) divr16s::divisor#6 (signed word) divr16s::divisor#5 
Alias (word) divr16s::dividendu#1 = (word~) divr16s::$9 
Alias (word) divr16s::remu#1 = (word~) divr16s::$11 
Alias (byte) divr16s::neg#0 = (byte) divr16s::neg#7 
Alias (word) divr16s::dividendu#2 = (word~) divr16s::$6 
Alias (word) divr16s::remu#2 = (word~) divr16s::$7 
Alias (signed word) divr16s::divisor#1 = (signed word) divr16s::divisor#2 (signed word) divr16s::divisor#3 
Alias (byte) divr16s::neg#3 = (byte) divr16s::neg#5 (byte) divr16s::neg#8 
Alias (word) divr16s::dividendu#4 = (word) divr16s::dividendu#6 (word) divr16s::dividendu#5 
Alias (word) divr16s::remu#4 = (word) divr16s::remu#6 (word) divr16s::remu#5 
Alias (word) divr16s::divisoru#1 = (word~) divr16s::$14 
Alias (byte) divr16s::neg#2 = (byte~) divr16s::$15 
Alias (word) divr16s::divisoru#2 = (word~) divr16s::$12 
Alias (word) divr16u::return#2 = (word) divr16u::return#4 
Alias (byte) divr16s::neg#4 = (byte) divr16s::neg#6 
Alias (word) divr16s::resultu#0 = (word~) divr16s::$4 (word) divr16s::resultu#1 (word) divr16s::resultu#2 
Alias (signed word) divr16s::return#0 = (signed word~) divr16s::$21 
Alias (signed word) divr16s::return#1 = (signed word~) divr16s::$19 
Alias (signed word) divr16s::return#2 = (signed word) divr16s::return#4 
Alias (byte*) main::vicSelectGfxBank1_gfx#0 = (byte*) main::vicSelectGfxBank1_gfx#1 (byte*) main::vicSelectGfxBank1_toDd001_gfx#0 (byte*) main::vicSelectGfxBank1_toDd001_gfx#1 
Alias (byte) main::vicSelectGfxBank1_toDd001_return#0 = (byte~) main::vicSelectGfxBank1_toDd001_$3#0 (byte) main::vicSelectGfxBank1_toDd001_return#2 (byte) main::vicSelectGfxBank1_toDd001_return#1 (byte) main::vicSelectGfxBank1_toDd001_return#3 (byte~) main::vicSelectGfxBank1_$0#0 
Alias (byte*) main::toD0181_screen#0 = (byte*) main::toD0181_screen#1 
Alias (byte*) main::toD0181_gfx#0 = (byte*) main::toD0181_gfx#1 
Alias (byte) main::toD0181_return#0 = (byte~) main::toD0181_$8#0 (byte) main::toD0181_return#2 (byte) main::toD0181_return#1 (byte) main::toD0181_return#3 (byte~) main::$4 
Alias (byte) main::i#2 = (byte) main::i#3 (byte) main::i#4 
Alias (signed word) point_init::abs16s1_w#0 = (signed word) point_init::x_diff#0 (signed word~) point_init::$2 (signed word) point_init::abs16s1_w#1 (signed word) point_init::x_diff#14 (signed word) point_init::abs16s1_w#2 (signed word) point_init::x_diff#12 (signed word) point_init::abs16s1_w#3 (signed word) point_init::x_diff#13 
Alias (signed word) point_init::y_diff#0 = (signed word~) point_init::$5 (signed word) point_init::y_diff#9 (signed word) point_init::y_diff#6 (signed word) point_init::y_diff#7 
Alias (byte) point_init::point_idx#1 = (byte) point_init::point_idx#17 (byte) point_init::point_idx#15 (byte) point_init::point_idx#16 
Alias (word) point_init::abs16s1_return#0 = (word~) point_init::abs16s1_$3#0 
Alias (word) point_init::abs16s1_return#1 = (word~) point_init::abs16s1_$1#0 
Alias (word) point_init::abs16s1_return#2 = (word) point_init::abs16s1_return#3 (word) point_init::abs16s1_return#4 (word~) point_init::$6 
Alias (signed word) point_init::y_diff#1 = (signed word) point_init::y_diff#3 (signed word) point_init::abs16s2_w#0 (signed word) point_init::abs16s2_w#1 (signed word) point_init::y_diff#14 (signed word) point_init::abs16s2_w#2 (signed word) point_init::y_diff#12 (signed word) point_init::abs16s2_w#3 (signed word) point_init::y_diff#13 
Alias (signed word) point_init::x_diff#10 = (signed word) point_init::x_diff#11 (signed word) point_init::x_diff#9 (signed word) point_init::x_diff#7 (signed word) point_init::x_diff#8 
Alias (byte) point_init::point_idx#10 = (byte) point_init::point_idx#13 (byte) point_init::point_idx#14 (byte) point_init::point_idx#12 (byte) point_init::point_idx#11 
Alias (word) point_init::abs16s2_return#0 = (word~) point_init::abs16s2_$3#0 
Alias (word) point_init::abs16s2_return#1 = (word~) point_init::abs16s2_$1#0 
Alias (word) point_init::abs16s2_return#2 = (word) point_init::abs16s2_return#3 (word) point_init::abs16s2_return#4 (word~) point_init::$7 
Alias (signed word) point_init::x_diff#1 = (signed word) point_init::x_diff#3 (signed word) point_init::x_diff#6 (signed word) point_init::x_diff#5 (signed word) point_init::x_diff#4 
Alias (byte) point_init::point_idx#3 = (byte) point_init::point_idx#6 (byte) point_init::point_idx#9 (byte) point_init::point_idx#7 (byte) point_init::point_idx#4 
Alias (signed word) point_init::y_diff#10 = (signed word) point_init::y_diff#11 (signed word) point_init::y_diff#8 (signed word) point_init::y_diff#5 (signed word) point_init::y_diff#4 
Alias (signed word) divr16s::return#3 = (signed word) divr16s::return#5 
Alias (byte) point_init::point_idx#5 = (byte) point_init::point_idx#8 
Alias (signed word) point_init::x_stepf#0 = (signed word~) point_init::$13 
Alias (byte) screen_fill::y#2 = (byte) screen_fill::y#3 
Alias (byte) screen_fill::ch#1 = (byte) screen_fill::ch#4 
Alias (byte*) screen_fill::screen#1 = (byte*) screen_fill::screen#5 
Alias (byte) bitmap_init::x#2 = (byte) bitmap_init::x#4 
Alias (byte*) bitmap_init::bitmap#3 = (byte*) bitmap_init::bitmap#4 
Alias (byte*) bitmap_init::bitmap#1 = (byte*) bitmap_init::bitmap#2 (byte*) bitmap_init::yoffs#0 
Alias (byte*) bitmap_init::yoffs#2 = (byte*) bitmap_init::yoffs#3 
Alias (byte) bitmap_init::y#2 = (byte) bitmap_init::y#4 
Alias (byte*) bitmap_init::yoffs#1 = (byte*~) bitmap_init::$10 
Alias (byte*) bitmap_clear::bitmap#0 = (byte*~) bitmap_clear::$0 
Alias (byte) bitmap_clear::y#2 = (byte) bitmap_clear::y#3 
Alias (byte*) bitmap_clear::bitmap#1 = (byte*) bitmap_clear::bitmap#4 
Alias (byte*) bitmap_plot::plotter#0 = (byte*~) bitmap_plot::$0 
Successful SSA optimization Pass2AliasElimination
Alias (word) divr16u::dividend#2 = (word) divr16u::dividend#3 
Alias (word) divr16u::quotient#3 = (word) divr16u::quotient#6 
Alias (word) divr16u::divisor#1 = (word) divr16u::divisor#3 (word) divr16u::divisor#6 
Alias (byte) divr16u::i#2 = (byte) divr16u::i#3 (byte) divr16u::i#5 
Alias (word) divr16u::dividend#0 = (word) divr16u::dividend#5 
Alias (signed word) divr16s::divisor#1 = (signed word) divr16s::divisor#4 
Alias (word) divr16s::dividendu#3 = (word) divr16s::dividendu#4 
Alias (word) divr16s::remu#3 = (word) divr16s::remu#4 
Alias (signed word) point_init::y_diff#0 = (signed word) point_init::y_diff#1 (signed word) point_init::y_diff#10 (signed word) point_init::y_diff#2 
Alias (signed word) point_init::x_diff#1 = (signed word) point_init::x_diff#10 (signed word) point_init::abs16s1_w#0 (signed word) point_init::x_diff#2 
Alias (byte) point_init::point_idx#1 = (byte) point_init::point_idx#10 (byte) point_init::point_idx#3 (byte) point_init::point_idx#5 
Alias (byte) bitmap_init::x#2 = (byte) bitmap_init::x#3 
Alias (byte*) bitmap_init::bitmap#1 = (byte*) bitmap_init::bitmap#3 
Alias (byte) bitmap_init::y#2 = (byte) bitmap_init::y#3 
Successful SSA optimization Pass2AliasElimination
Alias (byte) point_init::point_idx#1 = (byte) point_init::point_idx#2 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (word) divr16u::rem#8 (word) divr16u::rem#3
Identical Phi Values (word) divr16u::dividend#4 (word) divr16u::dividend#1
Identical Phi Values (word) divr16u::divisor#5 (word) divr16u::divisor#0
Identical Phi Values (word) divr16u::divisor#1 (word) divr16u::divisor#5
Identical Phi Values (signed word) divr16s::dividend#1 (signed word) divr16s::dividend#0
Identical Phi Values (signed word) divr16s::rem#1 (signed word) divr16s::rem#0
Identical Phi Values (signed word) divr16s::divisor#1 (signed word) divr16s::divisor#0
Identical Phi Values (byte) point_init::point_idx#1 (byte) point_init::point_idx#0
Identical Phi Values (byte) screen_fill::ch#3 (byte) screen_fill::ch#0
Identical Phi Values (byte*) screen_fill::screen#4 (byte*) screen_fill::screen#0
Identical Phi Values (byte) screen_fill::ch#1 (byte) screen_fill::ch#2
Identical Phi Values (byte) screen_fill::y#2 (byte) screen_fill::y#4
Identical Phi Values (byte*) bitmap_init::bitmap#5 (byte*) bitmap_init::bitmap#0
Identical Phi Values (byte*) bitmap_init::bitmap#1 (byte*) bitmap_init::bitmap#5
Identical Phi Values (byte) bitmap_clear::y#2 (byte) bitmap_clear::y#4
Identical Phi Values (byte) bitmap_plot::y#1 (byte) bitmap_plot::y#0
Identical Phi Values (word) bitmap_plot::x#1 (word) bitmap_plot::x#0
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte) screen_fill::ch#2 (byte) screen_fill::ch#0
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [184] (byte~) point_init::$18 ← (byte) point_init::point_idx#0 * (const byte) SIZEOF_WORD
Identified duplicate assignment right side [230] (byte~) point_init::$20 ← (byte) point_init::point_idx#0 * (const byte) SIZEOF_WORD
Identified duplicate assignment right side [234] (byte~) point_init::$21 ← (byte) point_init::point_idx#0 * (const byte) SIZEOF_WORD
Identified duplicate assignment right side [298] (byte~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (byte) 7
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) divr16u::$4 [23] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2
Simple Condition (bool~) divr16u::$9 [31] if((word) divr16u::rem#5<(word) divr16u::divisor#0) goto divr16u::@3
Simple Condition (bool~) divr16u::$11 [38] if((byte) divr16u::i#1!=rangelast(0,$f)) goto divr16u::@1
Simple Condition (bool~) divr16s::$3 [72] if((signed word) divr16s::divisor#0<(signed byte) 0) goto divr16s::@3
Simple Condition (bool~) divr16s::$5 [92] if((byte) divr16s::neg#4==(byte) 0) goto divr16s::@5
Simple Condition (bool~) main::$11 [175] if((byte) main::i#1!=rangelast(0,main::$8)) goto main::@1
Simple Condition (bool~) main::$12 [178] if(*((byte*) RASTER#0)!=(byte) $ff) goto main::@6
Simple Condition (bool~) point_init::abs16s1_$0#0 [195] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::abs16s1_@1
Simple Condition (bool~) point_init::abs16s2_$0#0 [210] if((signed word) point_init::y_diff#0<(signed byte) 0) goto point_init::abs16s2_@1
Simple Condition (bool~) point_init::$8 [223] if((word) point_init::abs16s1_return#2>(word) point_init::abs16s2_return#2) goto point_init::@1
Simple Condition (bool~) point_init::$12 [226] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::@7
Simple Condition (bool~) screen_fill::$0 [264] if((byte) screen_fill::x#1!=rangelast(0,$27)) goto screen_fill::@2
Simple Condition (bool~) screen_fill::$1 [268] if((byte) screen_fill::y#1!=rangelast(0,$18)) goto screen_fill::@1
Simple Condition (bool~) bitmap_init::$1 [281] if((byte) bitmap_init::bits#1!=(byte) 0) goto bitmap_init::@2
Simple Condition (bool~) bitmap_init::$2 [285] if((byte) bitmap_init::x#1!=rangelast(0,$ff)) goto bitmap_init::@1
Simple Condition (bool~) bitmap_init::$9 [301] if((byte~) bitmap_init::$7!=(byte) 7) goto bitmap_init::@6
Simple Condition (bool~) bitmap_init::$11 [305] if((byte) bitmap_init::y#1!=rangelast(0,$ff)) goto bitmap_init::@5
Simple Condition (bool~) bitmap_clear::$1 [321] if((byte) bitmap_clear::x#1!=rangelast(0,$c7)) goto bitmap_clear::@2
Simple Condition (bool~) bitmap_clear::$2 [325] if((byte) bitmap_clear::y#1!=rangelast(0,$27)) goto bitmap_clear::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting || if()-condition to two if()s [54] (bool~) divr16s::$2 ← (bool~) divr16s::$0 || (bool~) divr16s::$1
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant right-side identified [107] (word[SIZE#0]) x_start#0 ← { (word) $a, (word) $14, (word) $1e, (word) $1e }
Constant right-side identified [108] (byte[SIZE#0]) y_start#0 ← { (byte) $a, (byte) $a, (byte) $a, (byte) $14 }
Constant right-side identified [109] (word[SIZE#0]) x_end#0 ← { (word) $14, (word) $a, (word) $14, (word) $14 }
Constant right-side identified [110] (byte[SIZE#0]) y_end#0 ← { (byte) $14, (byte) $14, (byte) $a, (byte) $14 }
Constant right-side identified [270] (byte[$100]) bitmap_plot_ylo#0 ← { fill( $100, 0) }
Constant right-side identified [271] (byte[$100]) bitmap_plot_yhi#0 ← { fill( $100, 0) }
Constant right-side identified [272] (byte[$100]) bitmap_plot_bit#0 ← { fill( $100, 0) }
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) PROCPORT_DDR#0 = (byte*) 0
Constant (const byte) PROCPORT_DDR_MEMORY_MASK#0 = 7
Constant (const byte*) PROCPORT#0 = (byte*) 1
Constant (const byte) PROCPORT_RAM_IO#0 = $35
Constant (const byte*) RASTER#0 = (byte*) 53266
Constant (const byte*) BORDERCOL#0 = (byte*) 53280
Constant (const byte*) D011#0 = (byte*) 53265
Constant (const byte) VIC_BMM#0 = $20
Constant (const byte) VIC_DEN#0 = $10
Constant (const byte) VIC_RSEL#0 = 8
Constant (const byte*) D018#0 = (byte*) 53272
Constant (const byte*) CIA2_PORT_A#0 = (byte*) 56576
Constant (const byte*) CIA2_PORT_A_DDR#0 = (byte*) 56578
Constant (const word) divr16u::quotient#0 = 0
Constant (const byte) divr16u::i#0 = 0
Constant (const byte) divr16s::neg#0 = 0
Constant (const word) divr16s::dividendu#0 = 0
Constant (const word) divr16s::remu#0 = 0
Constant (const byte) divr16s::neg#1 = 1
Constant (const word) divr16s::divisoru#0 = 0
Constant (const byte*) BITMAP#0 = (byte*) 40960
Constant (const byte*) SCREEN#0 = (byte*) 34816
Constant (const byte) SIZE#0 = 4
Constant (const byte) DELAY#0 = 8
Constant (const word[SIZE#0]) x_start#0 = { $a, $14, $1e, $1e }
Constant (const byte[SIZE#0]) y_start#0 = { $a, $a, $a, $14 }
Constant (const word[SIZE#0]) x_end#0 = { $14, $a, $14, $14 }
Constant (const byte[SIZE#0]) y_end#0 = { $14, $14, $a, $14 }
Constant (const byte) screen_fill::ch#0 = $10
Constant (const byte) main::i#0 = 0
Constant (const signed word) divr16s::dividend#0 = 0
Constant (const byte) screen_fill::y#0 = 0
Constant (const byte) screen_fill::x#0 = 0
Constant (const byte[$100]) bitmap_plot_ylo#0 = { fill( $100, 0) }
Constant (const byte[$100]) bitmap_plot_yhi#0 = { fill( $100, 0) }
Constant (const byte[$100]) bitmap_plot_bit#0 = { fill( $100, 0) }
Constant (const byte) bitmap_init::bits#0 = $80
Constant (const byte) bitmap_init::x#0 = 0
Constant (const byte) bitmap_init::bits#2 = $80
Constant (const byte) bitmap_init::y#0 = 0
Constant (const byte) bitmap_clear::y#0 = 0
Constant (const byte) bitmap_clear::x#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) main::vicSelectGfxBank1_gfx#0 = SCREEN#0
Constant (const byte*) main::toD0181_screen#0 = SCREEN#0
Constant (const byte*) main::toD0181_gfx#0 = BITMAP#0
Constant (const byte*) bitmap_init::bitmap#0 = BITMAP#0
Constant (const byte*) screen_fill::screen#0 = SCREEN#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)divr16s::dividend#0 in [65] (word) divr16s::dividendu#2 ← (word)(const signed word) divr16s::dividend#0
Constant value identified { fill( SIZE#0, 0) } in [111] (word[SIZE#0]) x_cur#0 ← { fill( SIZE#0, 0) }
Constant value identified { fill( SIZE#0, 0) } in [112] (word[SIZE#0]) y_cur#0 ← { fill( SIZE#0, 0) }
Constant value identified { fill( SIZE#0, 0) } in [113] (signed byte[SIZE#0]) x_add#0 ← { fill( SIZE#0, 0) }
Constant value identified { fill( SIZE#0, 0) } in [114] (signed byte[SIZE#0]) y_add#0 ← { fill( SIZE#0, 0) }
Constant value identified { fill( SIZE#0, 0) } in [115] (byte[SIZE#0]) delay#0 ← { fill( SIZE#0, 0) }
Constant value identified (word)main::vicSelectGfxBank1_gfx#0 in [128] (word~) main::vicSelectGfxBank1_toDd001_$0#0 ← (word)(const byte*) main::vicSelectGfxBank1_gfx#0
Constant value identified (word)main::toD0181_screen#0 in [141] (word~) main::toD0181_$0#0 ← (word)(const byte*) main::toD0181_screen#0
Constant value identified (word)main::toD0181_gfx#0 in [145] (word~) main::toD0181_$4#0 ← (word)(const byte*) main::toD0181_gfx#0
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [176] if(true) goto main::@6
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [36] divr16u::i#1 ← ++ divr16u::i#2 to ++
Resolved ranged comparison value [38] if(divr16u::i#1!=rangelast(0,$f)) goto divr16u::@1 to (number) $10
Resolved ranged next value [262] screen_fill::x#1 ← ++ screen_fill::x#2 to ++
Resolved ranged comparison value [264] if(screen_fill::x#1!=rangelast(0,$27)) goto screen_fill::@2 to (number) $28
Resolved ranged next value [266] screen_fill::y#1 ← ++ screen_fill::y#4 to ++
Resolved ranged comparison value [268] if(screen_fill::y#1!=rangelast(0,$18)) goto screen_fill::@1 to (number) $19
Resolved ranged next value [283] bitmap_init::x#1 ← ++ bitmap_init::x#2 to ++
Resolved ranged comparison value [285] if(bitmap_init::x#1!=rangelast(0,$ff)) goto bitmap_init::@1 to (number) 0
Resolved ranged next value [303] bitmap_init::y#1 ← ++ bitmap_init::y#2 to ++
Resolved ranged comparison value [305] if(bitmap_init::y#1!=rangelast(0,$ff)) goto bitmap_init::@5 to (number) 0
Resolved ranged next value [319] bitmap_clear::x#1 ← ++ bitmap_clear::x#2 to ++
Resolved ranged comparison value [321] if(bitmap_clear::x#1!=rangelast(0,$c7)) goto bitmap_clear::@2 to (number) $c8
Resolved ranged next value [323] bitmap_clear::y#1 ← ++ bitmap_clear::y#4 to ++
Resolved ranged comparison value [325] if(bitmap_clear::y#1!=rangelast(0,$27)) goto bitmap_clear::@1 to (number) $28
Simplifying constant evaluating to zero (word)(const signed word) divr16s::dividend#0 in [65] (word) divr16s::dividendu#2 ← (word)(const signed word) divr16s::dividend#0
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero bitmap_plot_yhi#0 in [310] (word~) bitmap_clear::$3 ← *((const byte[$100]) bitmap_plot_yhi#0 + (byte) 0) w= *((const byte[$100]) bitmap_plot_ylo#0 + (byte) 0)
Simplifying expression containing zero bitmap_plot_ylo#0 in [310] (word~) bitmap_clear::$3 ← *((const byte[$100]) bitmap_plot_yhi#0) w= *((const byte[$100]) bitmap_plot_ylo#0 + (byte) 0)
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const word) divr16s::dividendu#0
Eliminating unused constant (const word) divr16s::remu#0
Eliminating unused constant (const word) divr16s::divisoru#0
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) $10 in if((byte) divr16u::i#1!=(number) $10) goto divr16u::@1
Adding number conversion cast (unumber) $28 in if((byte) screen_fill::x#1!=(number) $28) goto screen_fill::@2
Adding number conversion cast (unumber) $19 in if((byte) screen_fill::y#1!=(number) $19) goto screen_fill::@1
Adding number conversion cast (unumber) 0 in if((byte) bitmap_init::x#1!=(number) 0) goto bitmap_init::@1
Adding number conversion cast (unumber) 0 in if((byte) bitmap_init::y#1!=(number) 0) goto bitmap_init::@5
Adding number conversion cast (unumber) $c8 in if((byte) bitmap_clear::x#1!=(number) $c8) goto bitmap_clear::@2
Adding number conversion cast (unumber) $28 in if((byte) bitmap_clear::y#1!=(number) $28) goto bitmap_clear::@1
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) bitmap_clear::bitmap#0 ← (byte*)(word~) bitmap_clear::$3
Inlining cast (byte*) bitmap_plot::plotter#0 ← (byte*)(word~) bitmap_plot::$3
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast $10
Simplifying constant integer cast $28
Simplifying constant integer cast $19
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $c8
Simplifying constant integer cast $28
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (byte) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias (byte~) point_init::$18 = (byte~) point_init::$17 
Alias (byte~) point_init::$20 = (byte~) point_init::$19 (byte~) point_init::$21 
Alias (byte~) bitmap_init::$7 = (byte~) bitmap_init::$3 
Successful SSA optimization Pass2AliasElimination
Simple Condition (bool~) divr16s::$0 [18] if((const signed word) divr16s::dividend#0<(signed byte) 0) goto divr16s::@1
Simple Condition (bool~) divr16s::$1 [177] if((signed word) divr16s::rem#0<(signed byte) 0) goto divr16s::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [19] (signed word~) divr16s::$8 ← - (const signed word) divr16s::dividend#0
Constant right-side identified [52] (byte~) main::$0 ← (const byte) VIC_BMM#0 | (const byte) VIC_DEN#0
Constant right-side identified [75] (byte~) main::$8 ← (const byte) SIZE#0 - (byte) 1
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const signed word) divr16s::$8 = -divr16s::dividend#0
Constant (const word) divr16s::dividendu#2 = 0
Constant (const word[SIZE#0]) x_cur#0 = { fill( SIZE#0, 0) }
Constant (const word[SIZE#0]) y_cur#0 = { fill( SIZE#0, 0) }
Constant (const signed byte[SIZE#0]) x_add#0 = { fill( SIZE#0, 0) }
Constant (const signed byte[SIZE#0]) y_add#0 = { fill( SIZE#0, 0) }
Constant (const byte[SIZE#0]) delay#0 = { fill( SIZE#0, 0) }
Constant (const byte) main::$0 = VIC_BMM#0|VIC_DEN#0
Constant (const word) main::vicSelectGfxBank1_toDd001_$0#0 = (word)main::vicSelectGfxBank1_gfx#0
Constant (const word) main::toD0181_$0#0 = (word)main::toD0181_screen#0
Constant (const word) main::toD0181_$4#0 = (word)main::toD0181_gfx#0
Constant (const byte) main::$8 = SIZE#0-1
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)divr16s::$8 in [20] (word) divr16s::dividendu#1 ← (word)(const signed word) divr16s::$8
Successful SSA optimization Pass2ConstantValues
if() condition always false - eliminating [18] if((const signed word) divr16s::dividend#0<(signed byte) 0) goto divr16s::@1
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [83] main::i#1 ← ++ main::i#2 to ++
Resolved ranged comparison value [84] if(main::i#1!=rangelast(0,main::$8)) goto main::@1 to (const byte) main::$8+(number) 1
Simplifying constant evaluating to zero -(const signed word) divr16s::dividend#0 in 
Simplifying constant evaluating to zero (word)(const signed word) divr16s::$8 in [20] (word) divr16s::dividendu#1 ← (word)(const signed word) divr16s::$8
Successful SSA optimization PassNSimplifyConstantZero
Eliminating unused constant (const signed word) divr16s::dividend#0
Eliminating unused constant (const signed word) divr16s::$8
Successful SSA optimization PassNEliminateUnusedVars
Adding number conversion cast (unumber) main::$8+1 in if((byte) main::i#1!=(const byte) main::$8+(number) 1) goto main::@1
Adding number conversion cast (unumber) 1 in if((byte) main::i#1!=(unumber)(const byte) main::$8+(number) 1) goto main::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const byte) main::$8+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [42] (byte~) main::$1 ← (const byte) main::$0 | (const byte) VIC_RSEL#0
Constant right-side identified [46] (byte~) main::vicSelectGfxBank1_toDd001_$1#0 ← > (const word) main::vicSelectGfxBank1_toDd001_$0#0
Constant right-side identified [50] (word~) main::toD0181_$1#0 ← (const word) main::toD0181_$0#0 & (word) $3fff
Constant right-side identified [53] (byte~) main::toD0181_$5#0 ← > (const word) main::toD0181_$4#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) divr16s::dividendu#1 = 0
Constant (const byte) main::$1 = main::$0|VIC_RSEL#0
Constant (const byte) main::vicSelectGfxBank1_toDd001_$1#0 = >main::vicSelectGfxBank1_toDd001_$0#0
Constant (const word) main::toD0181_$1#0 = main::toD0181_$0#0&$3fff
Constant (const byte) main::toD0181_$5#0 = >main::toD0181_$4#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [41] (byte~) main::$2 ← (const byte) main::$1 | (byte) 3
Constant right-side identified [44] (byte~) main::vicSelectGfxBank1_toDd001_$2#0 ← (const byte) main::vicSelectGfxBank1_toDd001_$1#0 / (byte) $40
Constant right-side identified [47] (word~) main::toD0181_$2#0 ← (const word) main::toD0181_$1#0 * (byte) 4
Constant right-side identified [49] (byte~) main::toD0181_$6#0 ← (const byte) main::toD0181_$5#0 / (byte) 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::$2 = main::$1|3
Constant (const byte) main::vicSelectGfxBank1_toDd001_$2#0 = main::vicSelectGfxBank1_toDd001_$1#0/$40
Constant (const word) main::toD0181_$2#0 = main::toD0181_$1#0*4
Constant (const byte) main::toD0181_$6#0 = main::toD0181_$5#0/4
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [43] (byte) main::vicSelectGfxBank1_toDd001_return#0 ← (byte) 3 ^ (const byte) main::vicSelectGfxBank1_toDd001_$2#0
Constant right-side identified [45] (byte~) main::toD0181_$3#0 ← > (const word) main::toD0181_$2#0
Constant right-side identified [46] (byte~) main::toD0181_$7#0 ← (const byte) main::toD0181_$6#0 & (byte) $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::vicSelectGfxBank1_toDd001_return#0 = 3^main::vicSelectGfxBank1_toDd001_$2#0
Constant (const byte) main::toD0181_$3#0 = >main::toD0181_$2#0
Constant (const byte) main::toD0181_$7#0 = main::toD0181_$6#0&$f
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [44] (byte) main::toD0181_return#0 ← (const byte) main::toD0181_$3#0 | (const byte) main::toD0181_$7#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::toD0181_return#0 = main::toD0181_$3#0|main::toD0181_$7#0
Successful SSA optimization Pass2ConstantIdentification
Inlining Noop Cast [17] (word) divr16s::remu#1 ← (word)(signed word~) divr16s::$10 keeping divr16s::remu#1
Inlining Noop Cast [22] (word) divr16s::divisoru#1 ← (word)(signed word~) divr16s::$13 keeping divr16s::divisoru#1
Inlining Noop Cast [68] (word) point_init::abs16s1_return#0 ← (word)(signed word~) point_init::abs16s1_$2#0 keeping point_init::abs16s1_return#0
Inlining Noop Cast [73] (word) point_init::abs16s2_return#0 ← (word)(signed word~) point_init::abs16s2_$2#0 keeping point_init::abs16s2_return#0
Inlining Noop Cast [94] (signed byte~) point_init::$16 ← (signed byte)(byte~) point_init::$15 keeping point_init::$16
Inlining Noop Cast [127] (byte*) bitmap_clear::bitmap#0 ← (byte*)(word~) bitmap_clear::$3 keeping bitmap_clear::bitmap#0
Inlining Noop Cast [138] (byte*) bitmap_plot::plotter#0 ← (byte*)(word~) bitmap_plot::$3 keeping bitmap_plot::plotter#0
Successful SSA optimization Pass2NopCastInlining
Inlining Noop Cast [18] (word) divr16s::remu#2 ← (word)(signed word) divr16s::rem#0 keeping divr16s::rem#0
Inlining Noop Cast [24] (word) divr16s::divisoru#2 ← (word)(signed word) divr16s::divisor#0 keeping divr16s::divisor#0
Inlining Noop Cast [33] (signed word) divr16s::return#0 ← (signed word)(word) divr16s::resultu#0 keeping divr16s::resultu#0
Inlining Noop Cast [34] (signed word~) divr16s::$18 ← (signed word)(word) divr16s::resultu#0 keeping divr16s::resultu#0
Inlining Noop Cast [60] (signed word~) point_init::$0 ← (signed word)*((const word[SIZE#0]) x_end#0 + (byte~) point_init::$18) keeping *(x_end#0 + point_init::$18)
Inlining Noop Cast [61] (signed word~) point_init::$1 ← (signed word)*((const word[SIZE#0]) x_start#0 + (byte~) point_init::$18) keeping *(x_start#0 + point_init::$18)
Inlining Noop Cast [69] (word) point_init::abs16s1_return#1 ← (word)(signed word) point_init::x_diff#1 keeping point_init::x_diff#1
Inlining Noop Cast [74] (word) point_init::abs16s2_return#1 ← (word)(signed word) point_init::y_diff#0 keeping point_init::y_diff#0
Successful SSA optimization Pass2NopCastInlining
Rewriting multiplication to use shift [51] (byte~) main::$13 ← (byte) main::i#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [59] (byte~) point_init::$18 ← (byte) point_init::point_idx#0 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [78] (byte~) point_init::$20 ← (byte) point_init::point_idx#0 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [79] (word~) point_init::$9 ← *((const word[SIZE#0]) x_start#0 + (byte~) point_init::$20) * (byte) $10
Rewriting multiplication to use shift [82] (word~) point_init::$11 ← (word~) point_init::$10 * (byte) $10
Rewriting division to use shift [93] (byte~) point_init::$16 ← (byte~) point_init::$14 / (byte) $10
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const word) divr16u::quotient#0
Inlining constant with var siblings (const byte) divr16u::i#0
Inlining constant with var siblings (const byte) divr16s::neg#0
Inlining constant with var siblings (const byte) divr16s::neg#1
Inlining constant with var siblings (const word) divr16s::dividendu#2
Inlining constant with var siblings (const word) divr16s::dividendu#1
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with var siblings (const byte) screen_fill::y#0
Inlining constant with var siblings (const byte) screen_fill::x#0
Inlining constant with var siblings (const byte*) screen_fill::screen#0
Inlining constant with var siblings (const byte) bitmap_init::bits#0
Inlining constant with var siblings (const byte) bitmap_init::x#0
Inlining constant with var siblings (const byte) bitmap_init::bits#2
Inlining constant with var siblings (const byte) bitmap_init::y#0
Inlining constant with var siblings (const byte) bitmap_clear::y#0
Inlining constant with var siblings (const byte) bitmap_clear::x#0
Constant inlined main::toD0181_screen#0 = (const byte*) SCREEN#0
Constant inlined main::toD0181_gfx#0 = (const byte*) BITMAP#0
Constant inlined divr16u::i#0 = (byte) 0
Constant inlined divr16s::dividendu#1 = (word) 0
Constant inlined divr16s::dividendu#2 = (word) 0
Constant inlined bitmap_init::bits#0 = (byte) $80
Constant inlined bitmap_init::bits#2 = (byte) $80
Constant inlined divr16s::neg#1 = (byte) 1
Constant inlined divr16s::neg#0 = (byte) 0
Constant inlined divr16u::quotient#0 = (byte) 0
Constant inlined main::i#0 = (byte) 0
Constant inlined main::vicSelectGfxBank1_toDd001_$2#0 = >(word)(const byte*) SCREEN#0/(byte) $40
Constant inlined screen_fill::x#0 = (byte) 0
Constant inlined main::vicSelectGfxBank1_toDd001_$1#0 = >(word)(const byte*) SCREEN#0
Constant inlined main::vicSelectGfxBank1_toDd001_$0#0 = (word)(const byte*) SCREEN#0
Constant inlined bitmap_clear::x#0 = (byte) 0
Constant inlined bitmap_clear::y#0 = (byte) 0
Constant inlined main::toD0181_$0#0 = (word)(const byte*) SCREEN#0
Constant inlined main::toD0181_$1#0 = (word)(const byte*) SCREEN#0&(word) $3fff
Constant inlined main::toD0181_$6#0 = >(word)(const byte*) BITMAP#0/(byte) 4
Constant inlined main::toD0181_$7#0 = >(word)(const byte*) BITMAP#0/(byte) 4&(byte) $f
Constant inlined screen_fill::screen#0 = (const byte*) SCREEN#0
Constant inlined main::$1 = (const byte) VIC_BMM#0|(const byte) VIC_DEN#0|(const byte) VIC_RSEL#0
Constant inlined main::toD0181_$2#0 = (word)(const byte*) SCREEN#0&(word) $3fff*(byte) 4
Constant inlined main::$2 = (const byte) VIC_BMM#0|(const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3
Constant inlined main::toD0181_$3#0 = >(word)(const byte*) SCREEN#0&(word) $3fff*(byte) 4
Constant inlined main::toD0181_$4#0 = (word)(const byte*) BITMAP#0
Constant inlined main::$0 = (const byte) VIC_BMM#0|(const byte) VIC_DEN#0
Constant inlined main::toD0181_$5#0 = >(word)(const byte*) BITMAP#0
Constant inlined main::vicSelectGfxBank1_gfx#0 = (const byte*) SCREEN#0
Constant inlined bitmap_init::y#0 = (byte) 0
Constant inlined screen_fill::y#0 = (byte) 0
Constant inlined bitmap_init::x#0 = (byte) 0
Constant inlined bitmap_init::bitmap#0 = (const byte*) BITMAP#0
Constant inlined main::$8 = (const byte) SIZE#0-(byte) 1
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values (word) divr16s::dividendu#3 (word) 0
Successful SSA optimization Pass2IdenticalPhiElimination
Constant (const word) divr16u::dividend#1 = 0
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Inlining constant with var siblings (const word) divr16u::dividend#1
Constant inlined divr16u::dividend#1 = (word) 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting divr16u::@8(between divr16u::@3 and divr16u::@1)
Added new block during phi lifting divr16u::@9(between divr16u::@1 and divr16u::@2)
Added new block during phi lifting divr16u::@10(between divr16u::@2 and divr16u::@3)
Added new block during phi lifting main::@22(between main::@21 and main::@1)
Added new block during phi lifting screen_fill::@5(between screen_fill::@3 and screen_fill::@1)
Added new block during phi lifting screen_fill::@6(between screen_fill::@2 and screen_fill::@2)
Added new block during phi lifting bitmap_init::@9(between bitmap_init::@2 and bitmap_init::@1)
Added new block during phi lifting bitmap_init::@10(between bitmap_init::@1 and bitmap_init::@2)
Added new block during phi lifting bitmap_init::@11(between bitmap_init::@6 and bitmap_init::@5)
Added new block during phi lifting bitmap_init::@12(between bitmap_init::@5 and bitmap_init::@6)
Added new block during phi lifting bitmap_clear::@5(between bitmap_clear::@3 and bitmap_clear::@1)
Added new block during phi lifting bitmap_clear::@6(between bitmap_clear::@2 and bitmap_clear::@2)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @12
Adding NOP phi() at start of @16
Adding NOP phi() at start of @19
Adding NOP phi() at start of @20
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::vicSelectGfxBank1_toDd001
Adding NOP phi() at start of main::vicSelectGfxBank1_toDd001_@return
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0181_@return
Adding NOP phi() at start of main::@17
Adding NOP phi() at start of main::@18
Adding NOP phi() at start of main::@19
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of point_init::@9
Adding NOP phi() at start of divr16s
Adding NOP phi() at start of divr16u::@6
Adding NOP phi() at start of screen_fill
Adding NOP phi() at start of bitmap_init
Adding NOP phi() at start of bitmap_init::@3
Adding NOP phi() at start of bitmap_init::@4
CALL GRAPH
Calls in [] to main:4 
Calls in [main] to bitmap_init:19 bitmap_clear:21 screen_fill:23 point_init:27 bitmap_plot:31 
Calls in [point_init] to divr16s:69 
Calls in [divr16s] to divr16u:90 

Created 29 initial phi equivalence classes
Coalesced [37] main::i#5 ← main::i#1
Coalesced [86] divr16s::neg#10 ← divr16s::neg#3
Coalesced [95] divr16s::return#6 ← divr16s::return#1
Coalesced [102] divr16s::neg#9 ← divr16s::neg#2
Coalesced [105] divr16u::rem#10 ← divr16u::rem#3
Coalesced [112] divr16u::rem#13 ← divr16u::rem#1
Coalesced [119] divr16u::rem#15 ← divr16u::rem#2
Coalesced [120] divr16u::return#6 ← divr16u::quotient#2
Coalesced [126] divr16u::rem#11 ← divr16u::rem#9
Coalesced [127] divr16u::dividend#8 ← divr16u::dividend#0
Coalesced [128] divr16u::quotient#9 ← divr16u::return#0
Coalesced [129] divr16u::i#7 ← divr16u::i#1
Coalesced [130] divr16u::rem#14 ← divr16u::rem#5
Coalesced [131] divr16u::return#5 ← divr16u::quotient#1
Coalesced [132] divr16u::rem#12 ← divr16u::rem#0
Coalesced [135] screen_fill::screen#7 ← screen_fill::screen#3
Coalesced [144] screen_fill::screen#6 ← screen_fill::screen#1
Coalesced [145] screen_fill::y#5 ← screen_fill::y#1
Coalesced (already) [146] screen_fill::screen#8 ← screen_fill::screen#1
Coalesced [147] screen_fill::x#3 ← screen_fill::x#1
Coalesced [151] bitmap_clear::bitmap#7 ← bitmap_clear::bitmap#3
Coalesced [160] bitmap_clear::bitmap#6 ← bitmap_clear::bitmap#1
Coalesced [161] bitmap_clear::y#5 ← bitmap_clear::y#1
Coalesced (already) [162] bitmap_clear::bitmap#8 ← bitmap_clear::bitmap#1
Coalesced [163] bitmap_clear::x#3 ← bitmap_clear::x#1
Coalesced [183] bitmap_init::yoffs#7 ← bitmap_init::yoffs#1
Coalesced [188] bitmap_init::y#5 ← bitmap_init::y#1
Coalesced [189] bitmap_init::yoffs#5 ← bitmap_init::yoffs#4
Coalesced (already) [190] bitmap_init::yoffs#6 ← bitmap_init::yoffs#2
Coalesced [191] bitmap_init::bits#5 ← bitmap_init::bits#4
Coalesced [192] bitmap_init::x#5 ← bitmap_init::x#1
Coalesced [193] bitmap_init::bits#6 ← bitmap_init::bits#1
Coalesced down to 21 phi equivalence classes
Culled Empty Block (label) @12
Culled Empty Block (label) @16
Culled Empty Block (label) @20
Culled Empty Block (label) main::vicSelectGfxBank1_toDd001_@return
Culled Empty Block (label) main::@15
Culled Empty Block (label) main::toD0181_@return
Culled Empty Block (label) main::@19
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@22
Culled Empty Block (label) point_init::@9
Culled Empty Block (label) divr16u::@6
Culled Empty Block (label) divr16u::@8
Culled Empty Block (label) divr16u::@10
Culled Empty Block (label) divr16u::@9
Culled Empty Block (label) screen_fill::@5
Culled Empty Block (label) screen_fill::@6
Culled Empty Block (label) bitmap_clear::@5
Culled Empty Block (label) bitmap_clear::@6
Culled Empty Block (label) bitmap_init::@3
Culled Empty Block (label) bitmap_init::@4
Culled Empty Block (label) bitmap_init::@11
Culled Empty Block (label) bitmap_init::@12
Culled Empty Block (label) bitmap_init::@9
Renumbering block @19 to @1
Renumbering block divr16s::@7 to divr16s::@6
Renumbering block divr16s::@9 to divr16s::@7
Renumbering block divr16s::@11 to divr16s::@8
Renumbering block divr16s::@15 to divr16s::@9
Renumbering block divr16s::@16 to divr16s::@10
Renumbering block main::@6 to main::@2
Renumbering block main::@8 to main::@3
Renumbering block main::@16 to main::@4
Renumbering block main::@17 to main::@5
Renumbering block main::@18 to main::@6
Renumbering block main::@20 to main::@7
Renumbering block main::@21 to main::@8
Renumbering block point_init::@5 to point_init::@3
Renumbering block point_init::@7 to point_init::@4
Renumbering block point_init::@8 to point_init::@5
Renumbering block point_init::@10 to point_init::@6
Renumbering block point_init::@11 to point_init::@7
Renumbering block bitmap_init::@5 to bitmap_init::@3
Renumbering block bitmap_init::@6 to bitmap_init::@4
Renumbering block bitmap_init::@7 to bitmap_init::@5
Renumbering block bitmap_init::@10 to bitmap_init::@6
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::vicSelectGfxBank1_toDd001
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of divr16s
Adding NOP phi() at start of divr16u
Adding NOP phi() at start of screen_fill
Adding NOP phi() at start of bitmap_init
Adding NOP phi() at start of bitmap_init::@6

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  asm { sei  }
  [5] *((const byte*) PROCPORT_DDR#0) ← (const byte) PROCPORT_DDR_MEMORY_MASK#0
  [6] *((const byte*) PROCPORT#0) ← (const byte) PROCPORT_RAM_IO#0
  [7] *((const byte*) D011#0) ← (const byte) VIC_BMM#0|(const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3
  to:main::vicSelectGfxBank1
main::vicSelectGfxBank1: scope:[main]  from main
  [8] *((const byte*) CIA2_PORT_A_DDR#0) ← (byte) 3
  to:main::vicSelectGfxBank1_toDd001
main::vicSelectGfxBank1_toDd001: scope:[main]  from main::vicSelectGfxBank1
  [9] phi()
  to:main::vicSelectGfxBank1_@1
main::vicSelectGfxBank1_@1: scope:[main]  from main::vicSelectGfxBank1_toDd001
  [10] *((const byte*) CIA2_PORT_A#0) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0
  to:main::toD0181
main::toD0181: scope:[main]  from main::vicSelectGfxBank1_@1
  [11] phi()
  to:main::@4
main::@4: scope:[main]  from main::toD0181
  [12] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0
  [13] call bitmap_init 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [14] phi()
  [15] call bitmap_clear 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [16] phi()
  [17] call screen_fill 
  to:main::@1
main::@1: scope:[main]  from main::@6 main::@8
  [18] (byte) main::i#2 ← phi( main::@6/(byte) 0 main::@8/(byte) main::i#1 )
  [19] (byte) point_init::point_idx#0 ← (byte) main::i#2
  [20] call point_init 
  to:main::@7
main::@7: scope:[main]  from main::@1
  [21] (byte~) main::$13 ← (byte) main::i#2 << (byte) 1
  [22] (word) bitmap_plot::x#0 ← *((const word[SIZE#0]) x_start#0 + (byte~) main::$13)
  [23] (byte) bitmap_plot::y#0 ← *((const byte[SIZE#0]) y_start#0 + (byte) main::i#2)
  [24] call bitmap_plot 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [25] (byte) main::i#1 ← ++ (byte) main::i#2
  [26] if((byte) main::i#1!=(const byte) SIZE#0-(byte) 1+(byte) 1) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@2 main::@3 main::@8
  [27] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@2
  [28] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  to:main::@2
bitmap_plot: scope:[bitmap_plot]  from main::@7
  [29] (word) bitmap_plot::plotter#0 ← *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_plot::y#0) w= *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_plot::y#0)
  [30] (word~) bitmap_plot::$1 ← (word) bitmap_plot::x#0 & (word) $fff8
  [31] (byte*) bitmap_plot::plotter#1 ← (byte*)(word) bitmap_plot::plotter#0 + (word~) bitmap_plot::$1
  [32] (byte~) bitmap_plot::$2 ← < (word) bitmap_plot::x#0
  [33] *((byte*) bitmap_plot::plotter#1) ← *((byte*) bitmap_plot::plotter#1) | *((const byte[$100]) bitmap_plot_bit#0 + (byte~) bitmap_plot::$2)
  to:bitmap_plot::@return
bitmap_plot::@return: scope:[bitmap_plot]  from bitmap_plot
  [34] return 
  to:@return
point_init: scope:[point_init]  from main::@1
  [35] (byte~) point_init::$18 ← (byte) point_init::point_idx#0 << (byte) 1
  [36] (signed word) point_init::x_diff#1 ← (signed word)*((const word[SIZE#0]) x_end#0 + (byte~) point_init::$18) - (signed word)*((const word[SIZE#0]) x_start#0 + (byte~) point_init::$18)
  [37] (signed word~) point_init::$3 ← (signed word)*((const byte[SIZE#0]) y_end#0 + (byte) point_init::point_idx#0)
  [38] (signed word~) point_init::$4 ← (signed word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0)
  [39] (signed word) point_init::y_diff#0 ← (signed word~) point_init::$3 - (signed word~) point_init::$4
  to:point_init::abs16s1
point_init::abs16s1: scope:[point_init]  from point_init
  [40] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::abs16s1_@1
  to:point_init::abs16s1_@3
point_init::abs16s1_@3: scope:[point_init]  from point_init::abs16s1
  [41] (word~) point_init::abs16s1_return#6 ← (word)(signed word) point_init::x_diff#1
  to:point_init::abs16s1_@return
point_init::abs16s1_@return: scope:[point_init]  from point_init::abs16s1_@1 point_init::abs16s1_@3
  [42] (word) point_init::abs16s1_return#2 ← phi( point_init::abs16s1_@1/(word~) point_init::abs16s1_return#5 point_init::abs16s1_@3/(word~) point_init::abs16s1_return#6 )
  to:point_init::abs16s2
point_init::abs16s2: scope:[point_init]  from point_init::abs16s1_@return
  [43] if((signed word) point_init::y_diff#0<(signed byte) 0) goto point_init::abs16s2_@1
  to:point_init::abs16s2_@3
point_init::abs16s2_@3: scope:[point_init]  from point_init::abs16s2
  [44] (word~) point_init::abs16s2_return#6 ← (word)(signed word) point_init::y_diff#0
  to:point_init::abs16s2_@return
point_init::abs16s2_@return: scope:[point_init]  from point_init::abs16s2_@1 point_init::abs16s2_@3
  [45] (word) point_init::abs16s2_return#2 ← phi( point_init::abs16s2_@1/(word~) point_init::abs16s2_return#5 point_init::abs16s2_@3/(word~) point_init::abs16s2_return#6 )
  to:point_init::@6
point_init::@6: scope:[point_init]  from point_init::abs16s2_@return
  [46] if((word) point_init::abs16s1_return#2>(word) point_init::abs16s2_return#2) goto point_init::@1
  to:point_init::@2
point_init::@2: scope:[point_init]  from point_init::@6 point_init::@7
  [47] (byte~) point_init::$20 ← (byte) point_init::point_idx#0 << (byte) 1
  [48] (word~) point_init::$9 ← *((const word[SIZE#0]) x_start#0 + (byte~) point_init::$20) << (byte) 4
  [49] *((const word[SIZE#0]) x_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$9
  [50] (word~) point_init::$10 ← (word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0)
  [51] (word~) point_init::$11 ← (word~) point_init::$10 << (byte) 4
  [52] *((const word[SIZE#0]) y_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$11
  [53] *((const byte[SIZE#0]) delay#0 + (byte) point_init::point_idx#0) ← (const byte) DELAY#0
  to:point_init::@return
point_init::@return: scope:[point_init]  from point_init::@2
  [54] return 
  to:@return
point_init::@1: scope:[point_init]  from point_init::@6
  [55] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::@4
  to:point_init::@3
point_init::@3: scope:[point_init]  from point_init::@1
  [56] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) $10
  to:point_init::@5
point_init::@5: scope:[point_init]  from point_init::@3 point_init::@4
  [57] (signed word) divr16s::divisor#0 ← (signed word) point_init::x_diff#1
  [58] (signed word) divr16s::rem#0 ← (signed word) point_init::y_diff#0
  [59] call divr16s 
  [60] (signed word) divr16s::return#3 ← (signed word) divr16s::return#2
  to:point_init::@7
point_init::@7: scope:[point_init]  from point_init::@5
  [61] (signed word) point_init::x_stepf#0 ← (signed word) divr16s::return#3
  [62] (byte~) point_init::$14 ← > (signed word) point_init::x_stepf#0
  [63] (byte~) point_init::$16 ← (byte~) point_init::$14 >> (byte) 4
  [64] *((const signed byte[SIZE#0]) y_add#0 + (byte) point_init::point_idx#0) ← (signed byte)(byte~) point_init::$16
  to:point_init::@2
point_init::@4: scope:[point_init]  from point_init::@1
  [65] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) -$10
  to:point_init::@5
point_init::abs16s2_@1: scope:[point_init]  from point_init::abs16s2
  [66] (signed word) point_init::abs16s2_return#0 ← - (signed word) point_init::y_diff#0
  [67] (word~) point_init::abs16s2_return#5 ← (word)(signed word) point_init::abs16s2_return#0
  to:point_init::abs16s2_@return
point_init::abs16s1_@1: scope:[point_init]  from point_init::abs16s1
  [68] (signed word) point_init::abs16s1_return#0 ← - (signed word) point_init::x_diff#1
  [69] (word~) point_init::abs16s1_return#5 ← (word)(signed word) point_init::abs16s1_return#0
  to:point_init::abs16s1_@return
divr16s: scope:[divr16s]  from point_init::@5
  [70] phi()
  to:divr16s::@10
divr16s::@10: scope:[divr16s]  from divr16s
  [71] if((signed word) divr16s::rem#0<(signed byte) 0) goto divr16s::@1
  to:divr16s::@6
divr16s::@6: scope:[divr16s]  from divr16s::@10
  [72] (word~) divr16s::remu#8 ← (word)(signed word) divr16s::rem#0
  to:divr16s::@2
divr16s::@2: scope:[divr16s]  from divr16s::@1 divr16s::@6
  [73] (word) divr16s::remu#3 ← phi( divr16s::@1/(word~) divr16s::remu#7 divr16s::@6/(word~) divr16s::remu#8 )
  [73] (byte) divr16s::neg#3 ← phi( divr16s::@1/(byte) 1 divr16s::@6/(byte) 0 )
  [74] if((signed word) divr16s::divisor#0<(signed byte) 0) goto divr16s::@3
  to:divr16s::@7
divr16s::@7: scope:[divr16s]  from divr16s::@2
  [75] (word~) divr16s::divisoru#5 ← (word)(signed word) divr16s::divisor#0
  to:divr16s::@4
divr16s::@4: scope:[divr16s]  from divr16s::@3 divr16s::@7
  [76] (byte) divr16s::neg#4 ← phi( divr16s::@3/(byte) divr16s::neg#2 divr16s::@7/(byte) divr16s::neg#3 )
  [76] (word) divr16s::divisoru#3 ← phi( divr16s::@3/(word~) divr16s::divisoru#4 divr16s::@7/(word~) divr16s::divisoru#5 )
  [77] (word) divr16u::divisor#0 ← (word) divr16s::divisoru#3
  [78] (word) divr16u::rem#3 ← (word) divr16s::remu#3
  [79] call divr16u 
  [80] (word) divr16u::return#2 ← (word) divr16u::return#0
  to:divr16s::@9
divr16s::@9: scope:[divr16s]  from divr16s::@4
  [81] (word) divr16s::resultu#0 ← (word) divr16u::return#2
  [82] if((byte) divr16s::neg#4==(byte) 0) goto divr16s::@5
  to:divr16s::@8
divr16s::@8: scope:[divr16s]  from divr16s::@9
  [83] (signed word) divr16s::return#1 ← - (signed word)(word) divr16s::resultu#0
  to:divr16s::@return
divr16s::@return: scope:[divr16s]  from divr16s::@5 divr16s::@8
  [84] (signed word) divr16s::return#2 ← phi( divr16s::@8/(signed word) divr16s::return#1 divr16s::@5/(signed word~) divr16s::return#7 )
  [85] return 
  to:@return
divr16s::@5: scope:[divr16s]  from divr16s::@9
  [86] (signed word~) divr16s::return#7 ← (signed word)(word) divr16s::resultu#0
  to:divr16s::@return
divr16s::@3: scope:[divr16s]  from divr16s::@2
  [87] (signed word) divr16s::divisoru#1 ← - (signed word) divr16s::divisor#0
  [88] (byte) divr16s::neg#2 ← (byte) divr16s::neg#3 ^ (byte) 1
  [89] (word~) divr16s::divisoru#4 ← (word)(signed word) divr16s::divisoru#1
  to:divr16s::@4
divr16s::@1: scope:[divr16s]  from divr16s::@10
  [90] (signed word) divr16s::remu#1 ← - (signed word) divr16s::rem#0
  [91] (word~) divr16s::remu#7 ← (word)(signed word) divr16s::remu#1
  to:divr16s::@2
divr16u: scope:[divr16u]  from divr16s::@4
  [92] phi()
  to:divr16u::@1
divr16u::@1: scope:[divr16u]  from divr16u divr16u::@3
  [93] (byte) divr16u::i#2 ← phi( divr16u/(byte) 0 divr16u::@3/(byte) divr16u::i#1 )
  [93] (word) divr16u::quotient#3 ← phi( divr16u/(byte) 0 divr16u::@3/(word) divr16u::return#0 )
  [93] (word) divr16u::dividend#2 ← phi( divr16u/(word) 0 divr16u::@3/(word) divr16u::dividend#0 )
  [93] (word) divr16u::rem#4 ← phi( divr16u/(word) divr16u::rem#3 divr16u::@3/(word) divr16u::rem#9 )
  [94] (word) divr16u::rem#0 ← (word) divr16u::rem#4 << (byte) 1
  [95] (byte~) divr16u::$1 ← > (word) divr16u::dividend#2
  [96] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80
  [97] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2
  to:divr16u::@4
divr16u::@4: scope:[divr16u]  from divr16u::@1
  [98] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1
  to:divr16u::@2
divr16u::@2: scope:[divr16u]  from divr16u::@1 divr16u::@4
  [99] (word) divr16u::rem#5 ← phi( divr16u::@1/(word) divr16u::rem#0 divr16u::@4/(word) divr16u::rem#1 )
  [100] (word) divr16u::dividend#0 ← (word) divr16u::dividend#2 << (byte) 1
  [101] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1
  [102] if((word) divr16u::rem#5<(word) divr16u::divisor#0) goto divr16u::@3
  to:divr16u::@5
divr16u::@5: scope:[divr16u]  from divr16u::@2
  [103] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1
  [104] (word) divr16u::rem#2 ← (word) divr16u::rem#5 - (word) divr16u::divisor#0
  to:divr16u::@3
divr16u::@3: scope:[divr16u]  from divr16u::@2 divr16u::@5
  [105] (word) divr16u::return#0 ← phi( divr16u::@2/(word) divr16u::quotient#1 divr16u::@5/(word) divr16u::quotient#2 )
  [105] (word) divr16u::rem#9 ← phi( divr16u::@2/(word) divr16u::rem#5 divr16u::@5/(word) divr16u::rem#2 )
  [106] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2
  [107] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1
  to:divr16u::@return
divr16u::@return: scope:[divr16u]  from divr16u::@3
  [108] return 
  to:@return
screen_fill: scope:[screen_fill]  from main::@6
  [109] phi()
  to:screen_fill::@1
screen_fill::@1: scope:[screen_fill]  from screen_fill screen_fill::@3
  [110] (byte) screen_fill::y#4 ← phi( screen_fill/(byte) 0 screen_fill::@3/(byte) screen_fill::y#1 )
  [110] (byte*) screen_fill::screen#3 ← phi( screen_fill/(const byte*) SCREEN#0 screen_fill::@3/(byte*) screen_fill::screen#1 )
  to:screen_fill::@2
screen_fill::@2: scope:[screen_fill]  from screen_fill::@1 screen_fill::@2
  [111] (byte) screen_fill::x#2 ← phi( screen_fill::@1/(byte) 0 screen_fill::@2/(byte) screen_fill::x#1 )
  [111] (byte*) screen_fill::screen#2 ← phi( screen_fill::@1/(byte*) screen_fill::screen#3 screen_fill::@2/(byte*) screen_fill::screen#1 )
  [112] *((byte*) screen_fill::screen#2) ← (const byte) screen_fill::ch#0
  [113] (byte*) screen_fill::screen#1 ← ++ (byte*) screen_fill::screen#2
  [114] (byte) screen_fill::x#1 ← ++ (byte) screen_fill::x#2
  [115] if((byte) screen_fill::x#1!=(byte) $28) goto screen_fill::@2
  to:screen_fill::@3
screen_fill::@3: scope:[screen_fill]  from screen_fill::@2
  [116] (byte) screen_fill::y#1 ← ++ (byte) screen_fill::y#4
  [117] if((byte) screen_fill::y#1!=(byte) $19) goto screen_fill::@1
  to:screen_fill::@return
screen_fill::@return: scope:[screen_fill]  from screen_fill::@3
  [118] return 
  to:@return
bitmap_clear: scope:[bitmap_clear]  from main::@5
  [119] (word) bitmap_clear::bitmap#0 ← *((const byte[$100]) bitmap_plot_yhi#0) w= *((const byte[$100]) bitmap_plot_ylo#0)
  [120] (byte*~) bitmap_clear::bitmap#5 ← (byte*)(word) bitmap_clear::bitmap#0
  to:bitmap_clear::@1
bitmap_clear::@1: scope:[bitmap_clear]  from bitmap_clear bitmap_clear::@3
  [121] (byte) bitmap_clear::y#4 ← phi( bitmap_clear/(byte) 0 bitmap_clear::@3/(byte) bitmap_clear::y#1 )
  [121] (byte*) bitmap_clear::bitmap#3 ← phi( bitmap_clear/(byte*~) bitmap_clear::bitmap#5 bitmap_clear::@3/(byte*) bitmap_clear::bitmap#1 )
  to:bitmap_clear::@2
bitmap_clear::@2: scope:[bitmap_clear]  from bitmap_clear::@1 bitmap_clear::@2
  [122] (byte) bitmap_clear::x#2 ← phi( bitmap_clear::@1/(byte) 0 bitmap_clear::@2/(byte) bitmap_clear::x#1 )
  [122] (byte*) bitmap_clear::bitmap#2 ← phi( bitmap_clear::@1/(byte*) bitmap_clear::bitmap#3 bitmap_clear::@2/(byte*) bitmap_clear::bitmap#1 )
  [123] *((byte*) bitmap_clear::bitmap#2) ← (byte) 0
  [124] (byte*) bitmap_clear::bitmap#1 ← ++ (byte*) bitmap_clear::bitmap#2
  [125] (byte) bitmap_clear::x#1 ← ++ (byte) bitmap_clear::x#2
  [126] if((byte) bitmap_clear::x#1!=(byte) $c8) goto bitmap_clear::@2
  to:bitmap_clear::@3
bitmap_clear::@3: scope:[bitmap_clear]  from bitmap_clear::@2
  [127] (byte) bitmap_clear::y#1 ← ++ (byte) bitmap_clear::y#4
  [128] if((byte) bitmap_clear::y#1!=(byte) $28) goto bitmap_clear::@1
  to:bitmap_clear::@return
bitmap_clear::@return: scope:[bitmap_clear]  from bitmap_clear::@3
  [129] return 
  to:@return
bitmap_init: scope:[bitmap_init]  from main::@4
  [130] phi()
  to:bitmap_init::@1
bitmap_init::@1: scope:[bitmap_init]  from bitmap_init bitmap_init::@2
  [131] (byte) bitmap_init::x#2 ← phi( bitmap_init/(byte) 0 bitmap_init::@2/(byte) bitmap_init::x#1 )
  [131] (byte) bitmap_init::bits#3 ← phi( bitmap_init/(byte) $80 bitmap_init::@2/(byte) bitmap_init::bits#4 )
  [132] *((const byte[$100]) bitmap_plot_bit#0 + (byte) bitmap_init::x#2) ← (byte) bitmap_init::bits#3
  [133] (byte) bitmap_init::bits#1 ← (byte) bitmap_init::bits#3 >> (byte) 1
  [134] if((byte) bitmap_init::bits#1!=(byte) 0) goto bitmap_init::@6
  to:bitmap_init::@2
bitmap_init::@6: scope:[bitmap_init]  from bitmap_init::@1
  [135] phi()
  to:bitmap_init::@2
bitmap_init::@2: scope:[bitmap_init]  from bitmap_init::@1 bitmap_init::@6
  [136] (byte) bitmap_init::bits#4 ← phi( bitmap_init::@6/(byte) bitmap_init::bits#1 bitmap_init::@1/(byte) $80 )
  [137] (byte) bitmap_init::x#1 ← ++ (byte) bitmap_init::x#2
  [138] if((byte) bitmap_init::x#1!=(byte) 0) goto bitmap_init::@1
  to:bitmap_init::@3
bitmap_init::@3: scope:[bitmap_init]  from bitmap_init::@2 bitmap_init::@4
  [139] (byte*) bitmap_init::yoffs#2 ← phi( bitmap_init::@2/(const byte*) BITMAP#0 bitmap_init::@4/(byte*) bitmap_init::yoffs#4 )
  [139] (byte) bitmap_init::y#2 ← phi( bitmap_init::@2/(byte) 0 bitmap_init::@4/(byte) bitmap_init::y#1 )
  [140] (byte~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (byte) 7
  [141] (byte~) bitmap_init::$4 ← < (byte*) bitmap_init::yoffs#2
  [142] (byte~) bitmap_init::$5 ← (byte~) bitmap_init::$7 | (byte~) bitmap_init::$4
  [143] *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_init::y#2) ← (byte~) bitmap_init::$5
  [144] (byte~) bitmap_init::$6 ← > (byte*) bitmap_init::yoffs#2
  [145] *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_init::y#2) ← (byte~) bitmap_init::$6
  [146] if((byte~) bitmap_init::$7!=(byte) 7) goto bitmap_init::@4
  to:bitmap_init::@5
bitmap_init::@5: scope:[bitmap_init]  from bitmap_init::@3
  [147] (byte*) bitmap_init::yoffs#1 ← (byte*) bitmap_init::yoffs#2 + (word)(number) $28*(number) 8
  to:bitmap_init::@4
bitmap_init::@4: scope:[bitmap_init]  from bitmap_init::@3 bitmap_init::@5
  [148] (byte*) bitmap_init::yoffs#4 ← phi( bitmap_init::@3/(byte*) bitmap_init::yoffs#2 bitmap_init::@5/(byte*) bitmap_init::yoffs#1 )
  [149] (byte) bitmap_init::y#1 ← ++ (byte) bitmap_init::y#2
  [150] if((byte) bitmap_init::y#1!=(byte) 0) goto bitmap_init::@3
  to:bitmap_init::@return
bitmap_init::@return: scope:[bitmap_init]  from bitmap_init::@4
  [151] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte*) BITMAP
(byte*) BORDERCOL
(byte*) CIA2_PORT_A
(byte*) CIA2_PORT_A_DDR
(byte*) D011
(byte*) D018
(byte) DELAY
(byte*) PROCPORT
(byte*) PROCPORT_DDR
(byte) PROCPORT_DDR_MEMORY_MASK
(byte) PROCPORT_RAM_IO
(byte*) RASTER
(byte*) SCREEN
(byte) SIZE
(byte) VIC_BMM
(byte) VIC_DEN
(byte) VIC_RSEL
(void()) bitmap_clear()
(byte*) bitmap_clear::bitmap
(word) bitmap_clear::bitmap#0 2.0
(byte*) bitmap_clear::bitmap#1 42.599999999999994
(byte*) bitmap_clear::bitmap#2 157.0
(byte*) bitmap_clear::bitmap#3 24.0
(byte*~) bitmap_clear::bitmap#5 4.0
(byte) bitmap_clear::x
(byte) bitmap_clear::x#1 151.5
(byte) bitmap_clear::x#2 67.33333333333333
(byte) bitmap_clear::y
(byte) bitmap_clear::y#1 16.5
(byte) bitmap_clear::y#4 3.6666666666666665
(void()) bitmap_init((byte*) bitmap_init::bitmap)
(byte~) bitmap_init::$4 22.0
(byte~) bitmap_init::$5 22.0
(byte~) bitmap_init::$6 22.0
(byte~) bitmap_init::$7 5.5
(byte*) bitmap_init::bitmap
(byte) bitmap_init::bits
(byte) bitmap_init::bits#1 11.0
(byte) bitmap_init::bits#3 16.5
(byte) bitmap_init::bits#4 7.333333333333333
(byte) bitmap_init::x
(byte) bitmap_init::x#1 16.5
(byte) bitmap_init::x#2 5.5
(byte) bitmap_init::y
(byte) bitmap_init::y#1 16.5
(byte) bitmap_init::y#2 5.5
(byte*) bitmap_init::yoffs
(byte*) bitmap_init::yoffs#1 22.0
(byte*) bitmap_init::yoffs#2 6.875
(byte*) bitmap_init::yoffs#4 11.0
(void()) bitmap_plot((word) bitmap_plot::x , (byte) bitmap_plot::y)
(word~) bitmap_plot::$1 4.0
(byte~) bitmap_plot::$2 4.0
(byte*) bitmap_plot::plotter
(word) bitmap_plot::plotter#0 1.0
(byte*) bitmap_plot::plotter#1 3.0
(word) bitmap_plot::x
(word) bitmap_plot::x#0 3.0
(byte) bitmap_plot::y
(byte) bitmap_plot::y#0 15.0
(byte[$100]) bitmap_plot_bit
(byte[$100]) bitmap_plot_yhi
(byte[$100]) bitmap_plot_ylo
(byte[SIZE#0]) delay
(signed word()) divr16s((signed word) divr16s::dividend , (signed word) divr16s::divisor , (signed word) divr16s::rem)
(signed word) divr16s::dividend
(word) divr16s::dividendu
(signed word) divr16s::divisor
(signed word) divr16s::divisor#0 0.6666666666666666
(word) divr16s::divisoru
(signed word) divr16s::divisoru#1 1.0
(word) divr16s::divisoru#3 6.0
(word~) divr16s::divisoru#4 4.0
(word~) divr16s::divisoru#5 4.0
(byte) divr16s::neg
(byte) divr16s::neg#2 2.0
(byte) divr16s::neg#3 1.0
(byte) divr16s::neg#4 1.0
(signed word) divr16s::rem
(signed word) divr16s::rem#0 2.0
(word) divr16s::remu
(signed word) divr16s::remu#1 2.0
(word) divr16s::remu#3 0.75
(word~) divr16s::remu#7 4.0
(word~) divr16s::remu#8 4.0
(word) divr16s::resultu
(word) divr16s::resultu#0 1.0
(signed word) divr16s::return
(signed word) divr16s::return#1 4.0
(signed word) divr16s::return#2 2.0
(signed word) divr16s::return#3 4.0
(signed word~) divr16s::return#7 4.0
(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
(byte~) divr16u::$1 202.0
(byte~) divr16u::$2 202.0
(word) divr16u::dividend
(word) divr16u::dividend#0 25.25
(word) divr16u::dividend#2 43.285714285714285
(word) divr16u::divisor
(word) divr16u::divisor#0 11.333333333333332
(byte) divr16u::i
(byte) divr16u::i#1 151.5
(byte) divr16u::i#2 15.538461538461538
(word) divr16u::quotient
(word) divr16u::quotient#1 151.5
(word) divr16u::quotient#2 101.0
(word) divr16u::quotient#3 25.25
(word) divr16u::rem
(word) divr16u::rem#0 75.75
(word) divr16u::rem#1 202.0
(word) divr16u::rem#2 202.0
(word) divr16u::rem#3 2.0
(word) divr16u::rem#4 204.0
(word) divr16u::rem#5 101.0
(word) divr16u::rem#9 101.0
(word) divr16u::return
(word) divr16u::return#0 61.0
(word) divr16u::return#2 4.0
(void()) main()
(byte~) main::$13 22.0
(byte) main::i
(byte) main::i#1 16.5
(byte) main::i#2 7.857142857142857
(word~) main::toD0181_$0
(number~) main::toD0181_$1
(number~) main::toD0181_$2
(number~) main::toD0181_$3
(word~) main::toD0181_$4
(byte~) main::toD0181_$5
(number~) main::toD0181_$6
(number~) main::toD0181_$7
(number~) main::toD0181_$8
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(byte*) main::toD0181_screen
(byte~) main::vicSelectGfxBank1_$0
(byte*) main::vicSelectGfxBank1_gfx
(word~) main::vicSelectGfxBank1_toDd001_$0
(byte~) main::vicSelectGfxBank1_toDd001_$1
(number~) main::vicSelectGfxBank1_toDd001_$2
(number~) main::vicSelectGfxBank1_toDd001_$3
(byte*) main::vicSelectGfxBank1_toDd001_gfx
(byte) main::vicSelectGfxBank1_toDd001_return
(void()) point_init((byte) point_init::point_idx)
(word~) point_init::$10 4.0
(word~) point_init::$11 4.0
(byte~) point_init::$14 4.0
(byte~) point_init::$16 2.0
(byte~) point_init::$18 2.0
(byte~) point_init::$20 1.6
(signed word~) point_init::$3 2.0
(signed word~) point_init::$4 4.0
(word~) point_init::$9 4.0
(bool~) point_init::abs16s1_$0
(word~) point_init::abs16s1_$1
(signed word~) point_init::abs16s1_$2
(word~) point_init::abs16s1_$3
(word) point_init::abs16s1_return
(signed word) point_init::abs16s1_return#0 2.0
(word) point_init::abs16s1_return#2 1.0
(word~) point_init::abs16s1_return#5 4.0
(word~) point_init::abs16s1_return#6 4.0
(signed word) point_init::abs16s1_w
(bool~) point_init::abs16s2_$0
(word~) point_init::abs16s2_$1
(signed word~) point_init::abs16s2_$2
(word~) point_init::abs16s2_$3
(word) point_init::abs16s2_return
(signed word) point_init::abs16s2_return#0 2.0
(word) point_init::abs16s2_return#2 6.0
(word~) point_init::abs16s2_return#5 4.0
(word~) point_init::abs16s2_return#6 4.0
(signed word) point_init::abs16s2_w
(byte) point_init::point_idx
(byte) point_init::point_idx#0 0.6764705882352942
(signed word) point_init::x_diff
(signed word) point_init::x_diff#1 0.5555555555555556
(signed word) point_init::x_stepf
(signed word) point_init::x_stepf#0 4.0
(signed word) point_init::y_diff
(signed word) point_init::y_diff#0 0.5
(void()) screen_fill((byte*) screen_fill::screen , (byte) screen_fill::ch)
(byte) screen_fill::ch
(byte*) screen_fill::screen
(byte*) screen_fill::screen#1 42.599999999999994
(byte*) screen_fill::screen#2 157.0
(byte*) screen_fill::screen#3 22.0
(byte) screen_fill::x
(byte) screen_fill::x#1 151.5
(byte) screen_fill::x#2 67.33333333333333
(byte) screen_fill::y
(byte) screen_fill::y#1 16.5
(byte) screen_fill::y#4 3.6666666666666665
(signed byte[SIZE#0]) x_add
(word[SIZE#0]) x_cur
(word[SIZE#0]) x_end
(word[SIZE#0]) x_start
(signed byte[SIZE#0]) y_add
(word[SIZE#0]) y_cur
(byte[SIZE#0]) y_end
(byte[SIZE#0]) y_start

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ point_init::abs16s1_return#2 point_init::abs16s1_return#5 point_init::abs16s1_return#6 ]
[ point_init::abs16s2_return#2 point_init::abs16s2_return#5 point_init::abs16s2_return#6 ]
[ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 ]
[ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 ]
[ divr16s::neg#4 divr16s::neg#2 divr16s::neg#3 ]
[ divr16s::return#2 divr16s::return#1 divr16s::return#7 ]
[ divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ]
[ divr16u::dividend#2 divr16u::dividend#0 ]
[ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ]
[ divr16u::i#2 divr16u::i#1 ]
[ screen_fill::y#4 screen_fill::y#1 ]
[ screen_fill::screen#2 screen_fill::screen#3 screen_fill::screen#1 ]
[ screen_fill::x#2 screen_fill::x#1 ]
[ bitmap_clear::y#4 bitmap_clear::y#1 ]
[ bitmap_clear::bitmap#2 bitmap_clear::bitmap#3 bitmap_clear::bitmap#5 bitmap_clear::bitmap#1 ]
[ bitmap_clear::x#2 bitmap_clear::x#1 ]
[ bitmap_init::bits#3 bitmap_init::bits#4 bitmap_init::bits#1 ]
[ bitmap_init::x#2 bitmap_init::x#1 ]
[ bitmap_init::y#2 bitmap_init::y#1 ]
[ bitmap_init::yoffs#2 bitmap_init::yoffs#4 bitmap_init::yoffs#1 ]
Added variable point_init::point_idx#0 to zero page equivalence class [ point_init::point_idx#0 ]
Added variable main::$13 to zero page equivalence class [ main::$13 ]
Added variable bitmap_plot::x#0 to zero page equivalence class [ bitmap_plot::x#0 ]
Added variable bitmap_plot::y#0 to zero page equivalence class [ bitmap_plot::y#0 ]
Added variable bitmap_plot::plotter#0 to zero page equivalence class [ bitmap_plot::plotter#0 ]
Added variable bitmap_plot::$1 to zero page equivalence class [ bitmap_plot::$1 ]
Added variable bitmap_plot::plotter#1 to zero page equivalence class [ bitmap_plot::plotter#1 ]
Added variable bitmap_plot::$2 to zero page equivalence class [ bitmap_plot::$2 ]
Added variable point_init::$18 to zero page equivalence class [ point_init::$18 ]
Added variable point_init::x_diff#1 to zero page equivalence class [ point_init::x_diff#1 ]
Added variable point_init::$3 to zero page equivalence class [ point_init::$3 ]
Added variable point_init::$4 to zero page equivalence class [ point_init::$4 ]
Added variable point_init::y_diff#0 to zero page equivalence class [ point_init::y_diff#0 ]
Added variable point_init::$20 to zero page equivalence class [ point_init::$20 ]
Added variable point_init::$9 to zero page equivalence class [ point_init::$9 ]
Added variable point_init::$10 to zero page equivalence class [ point_init::$10 ]
Added variable point_init::$11 to zero page equivalence class [ point_init::$11 ]
Added variable divr16s::divisor#0 to zero page equivalence class [ divr16s::divisor#0 ]
Added variable divr16s::rem#0 to zero page equivalence class [ divr16s::rem#0 ]
Added variable divr16s::return#3 to zero page equivalence class [ divr16s::return#3 ]
Added variable point_init::x_stepf#0 to zero page equivalence class [ point_init::x_stepf#0 ]
Added variable point_init::$14 to zero page equivalence class [ point_init::$14 ]
Added variable point_init::$16 to zero page equivalence class [ point_init::$16 ]
Added variable point_init::abs16s2_return#0 to zero page equivalence class [ point_init::abs16s2_return#0 ]
Added variable point_init::abs16s1_return#0 to zero page equivalence class [ point_init::abs16s1_return#0 ]
Added variable divr16u::divisor#0 to zero page equivalence class [ divr16u::divisor#0 ]
Added variable divr16u::return#2 to zero page equivalence class [ divr16u::return#2 ]
Added variable divr16s::resultu#0 to zero page equivalence class [ divr16s::resultu#0 ]
Added variable divr16s::divisoru#1 to zero page equivalence class [ divr16s::divisoru#1 ]
Added variable divr16s::remu#1 to zero page equivalence class [ divr16s::remu#1 ]
Added variable divr16u::$1 to zero page equivalence class [ divr16u::$1 ]
Added variable divr16u::$2 to zero page equivalence class [ divr16u::$2 ]
Added variable bitmap_clear::bitmap#0 to zero page equivalence class [ bitmap_clear::bitmap#0 ]
Added variable bitmap_init::$7 to zero page equivalence class [ bitmap_init::$7 ]
Added variable bitmap_init::$4 to zero page equivalence class [ bitmap_init::$4 ]
Added variable bitmap_init::$5 to zero page equivalence class [ bitmap_init::$5 ]
Added variable bitmap_init::$6 to zero page equivalence class [ bitmap_init::$6 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ point_init::abs16s1_return#2 point_init::abs16s1_return#5 point_init::abs16s1_return#6 ]
[ point_init::abs16s2_return#2 point_init::abs16s2_return#5 point_init::abs16s2_return#6 ]
[ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 ]
[ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 ]
[ divr16s::neg#4 divr16s::neg#2 divr16s::neg#3 ]
[ divr16s::return#2 divr16s::return#1 divr16s::return#7 ]
[ divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ]
[ divr16u::dividend#2 divr16u::dividend#0 ]
[ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ]
[ divr16u::i#2 divr16u::i#1 ]
[ screen_fill::y#4 screen_fill::y#1 ]
[ screen_fill::screen#2 screen_fill::screen#3 screen_fill::screen#1 ]
[ screen_fill::x#2 screen_fill::x#1 ]
[ bitmap_clear::y#4 bitmap_clear::y#1 ]
[ bitmap_clear::bitmap#2 bitmap_clear::bitmap#3 bitmap_clear::bitmap#5 bitmap_clear::bitmap#1 ]
[ bitmap_clear::x#2 bitmap_clear::x#1 ]
[ bitmap_init::bits#3 bitmap_init::bits#4 bitmap_init::bits#1 ]
[ bitmap_init::x#2 bitmap_init::x#1 ]
[ bitmap_init::y#2 bitmap_init::y#1 ]
[ bitmap_init::yoffs#2 bitmap_init::yoffs#4 bitmap_init::yoffs#1 ]
[ point_init::point_idx#0 ]
[ main::$13 ]
[ bitmap_plot::x#0 ]
[ bitmap_plot::y#0 ]
[ bitmap_plot::plotter#0 ]
[ bitmap_plot::$1 ]
[ bitmap_plot::plotter#1 ]
[ bitmap_plot::$2 ]
[ point_init::$18 ]
[ point_init::x_diff#1 ]
[ point_init::$3 ]
[ point_init::$4 ]
[ point_init::y_diff#0 ]
[ point_init::$20 ]
[ point_init::$9 ]
[ point_init::$10 ]
[ point_init::$11 ]
[ divr16s::divisor#0 ]
[ divr16s::rem#0 ]
[ divr16s::return#3 ]
[ point_init::x_stepf#0 ]
[ point_init::$14 ]
[ point_init::$16 ]
[ point_init::abs16s2_return#0 ]
[ point_init::abs16s1_return#0 ]
[ divr16u::divisor#0 ]
[ divr16u::return#2 ]
[ divr16s::resultu#0 ]
[ divr16s::divisoru#1 ]
[ divr16s::remu#1 ]
[ divr16u::$1 ]
[ divr16u::$2 ]
[ bitmap_clear::bitmap#0 ]
[ bitmap_init::$7 ]
[ bitmap_init::$4 ]
[ bitmap_init::$5 ]
[ bitmap_init::$6 ]
Allocated zp ZP_BYTE:2 [ main::i#2 main::i#1 ]
Allocated zp ZP_WORD:3 [ point_init::abs16s1_return#2 point_init::abs16s1_return#5 point_init::abs16s1_return#6 ]
Allocated zp ZP_WORD:5 [ point_init::abs16s2_return#2 point_init::abs16s2_return#5 point_init::abs16s2_return#6 ]
Allocated zp ZP_WORD:7 [ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 ]
Allocated zp ZP_WORD:9 [ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 ]
Allocated zp ZP_BYTE:11 [ divr16s::neg#4 divr16s::neg#2 divr16s::neg#3 ]
Allocated zp ZP_WORD:12 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 ]
Allocated zp ZP_WORD:14 [ divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ]
Allocated zp ZP_WORD:16 [ divr16u::dividend#2 divr16u::dividend#0 ]
Allocated zp ZP_WORD:18 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ]
Allocated zp ZP_BYTE:20 [ divr16u::i#2 divr16u::i#1 ]
Allocated zp ZP_BYTE:21 [ screen_fill::y#4 screen_fill::y#1 ]
Allocated zp ZP_WORD:22 [ screen_fill::screen#2 screen_fill::screen#3 screen_fill::screen#1 ]
Allocated zp ZP_BYTE:24 [ screen_fill::x#2 screen_fill::x#1 ]
Allocated zp ZP_BYTE:25 [ bitmap_clear::y#4 bitmap_clear::y#1 ]
Allocated zp ZP_WORD:26 [ bitmap_clear::bitmap#2 bitmap_clear::bitmap#3 bitmap_clear::bitmap#5 bitmap_clear::bitmap#1 ]
Allocated zp ZP_BYTE:28 [ bitmap_clear::x#2 bitmap_clear::x#1 ]
Allocated zp ZP_BYTE:29 [ bitmap_init::bits#3 bitmap_init::bits#4 bitmap_init::bits#1 ]
Allocated zp ZP_BYTE:30 [ bitmap_init::x#2 bitmap_init::x#1 ]
Allocated zp ZP_BYTE:31 [ bitmap_init::y#2 bitmap_init::y#1 ]
Allocated zp ZP_WORD:32 [ bitmap_init::yoffs#2 bitmap_init::yoffs#4 bitmap_init::yoffs#1 ]
Allocated zp ZP_BYTE:34 [ point_init::point_idx#0 ]
Allocated zp ZP_BYTE:35 [ main::$13 ]
Allocated zp ZP_WORD:36 [ bitmap_plot::x#0 ]
Allocated zp ZP_BYTE:38 [ bitmap_plot::y#0 ]
Allocated zp ZP_WORD:39 [ bitmap_plot::plotter#0 ]
Allocated zp ZP_WORD:41 [ bitmap_plot::$1 ]
Allocated zp ZP_WORD:43 [ bitmap_plot::plotter#1 ]
Allocated zp ZP_BYTE:45 [ bitmap_plot::$2 ]
Allocated zp ZP_BYTE:46 [ point_init::$18 ]
Allocated zp ZP_WORD:47 [ point_init::x_diff#1 ]
Allocated zp ZP_WORD:49 [ point_init::$3 ]
Allocated zp ZP_WORD:51 [ point_init::$4 ]
Allocated zp ZP_WORD:53 [ point_init::y_diff#0 ]
Allocated zp ZP_BYTE:55 [ point_init::$20 ]
Allocated zp ZP_WORD:56 [ point_init::$9 ]
Allocated zp ZP_WORD:58 [ point_init::$10 ]
Allocated zp ZP_WORD:60 [ point_init::$11 ]
Allocated zp ZP_WORD:62 [ divr16s::divisor#0 ]
Allocated zp ZP_WORD:64 [ divr16s::rem#0 ]
Allocated zp ZP_WORD:66 [ divr16s::return#3 ]
Allocated zp ZP_WORD:68 [ point_init::x_stepf#0 ]
Allocated zp ZP_BYTE:70 [ point_init::$14 ]
Allocated zp ZP_BYTE:71 [ point_init::$16 ]
Allocated zp ZP_WORD:72 [ point_init::abs16s2_return#0 ]
Allocated zp ZP_WORD:74 [ point_init::abs16s1_return#0 ]
Allocated zp ZP_WORD:76 [ divr16u::divisor#0 ]
Allocated zp ZP_WORD:78 [ divr16u::return#2 ]
Allocated zp ZP_WORD:80 [ divr16s::resultu#0 ]
Allocated zp ZP_WORD:82 [ divr16s::divisoru#1 ]
Allocated zp ZP_WORD:84 [ divr16s::remu#1 ]
Allocated zp ZP_BYTE:86 [ divr16u::$1 ]
Allocated zp ZP_BYTE:87 [ divr16u::$2 ]
Allocated zp ZP_WORD:88 [ bitmap_clear::bitmap#0 ]
Allocated zp ZP_BYTE:90 [ bitmap_init::$7 ]
Allocated zp ZP_BYTE:91 [ bitmap_init::$4 ]
Allocated zp ZP_BYTE:92 [ bitmap_init::$5 ]
Allocated zp ZP_BYTE:93 [ bitmap_init::$6 ]

INITIAL ASM
Target platform is c64basic
  // File Comments
// Animated lines drawn on a single color bitmap
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // RAM in $A000, $E000 I/O in $D000
  .const PROCPORT_RAM_IO = $35
  .label RASTER = $d012
  .label BORDERCOL = $d020
  .label D011 = $d011
  .const VIC_BMM = $20
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  .label D018 = $d018
  // CIA#2 Port A: Serial bus, RS-232, VIC memory bank
  .label CIA2_PORT_A = $dd00
  // CIA #2 Port A data direction register.
  .label CIA2_PORT_A_DDR = $dd02
  .label BITMAP = $a000
  .label SCREEN = $8800
  // The number of points
  .const SIZE = 4
  // The delay between pixels
  .const DELAY = 8
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .const vicSelectGfxBank1_toDd001_return = 3^(>SCREEN)/$40
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>BITMAP)/4&$f
    .label _13 = $23
    .label i = 2
    // asm { sei  }
    // Disable normal interrupt
    sei
    // [5] *((const byte*) PROCPORT_DDR#0) ← (const byte) PROCPORT_DDR_MEMORY_MASK#0 -- _deref_pbuc1=vbuc2 
    // Disable kernal & basic
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // [6] *((const byte*) PROCPORT#0) ← (const byte) PROCPORT_RAM_IO#0 -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // [7] *((const byte*) D011#0) ← (const byte) VIC_BMM#0|(const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_BMM|VIC_DEN|VIC_RSEL|3
    sta D011
    jmp vicSelectGfxBank1
    // main::vicSelectGfxBank1
  vicSelectGfxBank1:
    // [8] *((const byte*) CIA2_PORT_A_DDR#0) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta CIA2_PORT_A_DDR
    // [9] phi from main::vicSelectGfxBank1 to main::vicSelectGfxBank1_toDd001 [phi:main::vicSelectGfxBank1->main::vicSelectGfxBank1_toDd001]
  vicSelectGfxBank1_toDd001_from_vicSelectGfxBank1:
    jmp vicSelectGfxBank1_toDd001
    // main::vicSelectGfxBank1_toDd001
  vicSelectGfxBank1_toDd001:
    jmp vicSelectGfxBank1_b1
    // main::vicSelectGfxBank1_@1
  vicSelectGfxBank1_b1:
    // [10] *((const byte*) CIA2_PORT_A#0) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 -- _deref_pbuc1=vbuc2 
    lda #vicSelectGfxBank1_toDd001_return
    sta CIA2_PORT_A
    // [11] phi from main::vicSelectGfxBank1_@1 to main::toD0181 [phi:main::vicSelectGfxBank1_@1->main::toD0181]
  toD0181_from_vicSelectGfxBank1_b1:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp b4
    // main::@4
  b4:
    // [12] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // [13] call bitmap_init 
    // [130] phi from main::@4 to bitmap_init [phi:main::@4->bitmap_init]
  bitmap_init_from_b4:
    jsr bitmap_init
    // [14] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  b5_from_b4:
    jmp b5
    // main::@5
  b5:
    // [15] call bitmap_clear 
    jsr bitmap_clear
    // [16] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  b6_from_b5:
    jmp b6
    // main::@6
  b6:
    // [17] call screen_fill 
    // [109] phi from main::@6 to screen_fill [phi:main::@6->screen_fill]
  screen_fill_from_b6:
    jsr screen_fill
    // [18] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
  b1_from_b6:
    // [18] phi (byte) main::i#2 = (byte) 0 [phi:main::@6->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b1
    // [18] phi from main::@8 to main::@1 [phi:main::@8->main::@1]
  b1_from_b8:
    // [18] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@8->main::@1#0] -- register_copy 
    jmp b1
    // main::@1
  b1:
    // [19] (byte) point_init::point_idx#0 ← (byte) main::i#2 -- vbuz1=vbuz2 
    lda i
    sta point_init.point_idx
    // [20] call point_init 
    jsr point_init
    jmp b7
    // main::@7
  b7:
    // [21] (byte~) main::$13 ← (byte) main::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda i
    asl
    sta _13
    // [22] (word) bitmap_plot::x#0 ← *((const word[SIZE#0]) x_start#0 + (byte~) main::$13) -- vwuz1=pwuc1_derefidx_vbuz2 
    ldy _13
    lda x_start,y
    sta bitmap_plot.x
    lda x_start+1,y
    sta bitmap_plot.x+1
    // [23] (byte) bitmap_plot::y#0 ← *((const byte[SIZE#0]) y_start#0 + (byte) main::i#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy i
    lda y_start,y
    sta bitmap_plot.y
    // [24] call bitmap_plot 
    jsr bitmap_plot
    jmp b8
    // main::@8
  b8:
    // [25] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
    // [26] if((byte) main::i#1!=(const byte) SIZE#0-(byte) 1+(byte) 1) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #SIZE-1+1
    cmp i
    bne b1_from_b8
    jmp b2
    // main::@2
  b2:
    // [27] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    jmp b3
    // main::@3
  b3:
    // [28] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    jmp b2
}
  // bitmap_plot
// Plot a single dot in the bitmap
// bitmap_plot(word zeropage($24) x, byte zeropage($26) y)
bitmap_plot: {
    .label _1 = $29
    .label _2 = $2d
    .label x = $24
    .label y = $26
    .label plotter = $27
    .label plotter_1 = $2b
    // [29] (word) bitmap_plot::plotter#0 ← *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_plot::y#0) w= *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_plot::y#0) -- vwuz1=pbuc1_derefidx_vbuz2_word_pbuc2_derefidx_vbuz2 
    ldy y
    lda bitmap_plot_yhi,y
    sta plotter+1
    lda bitmap_plot_ylo,y
    sta plotter
    // [30] (word~) bitmap_plot::$1 ← (word) bitmap_plot::x#0 & (word) $fff8 -- vwuz1=vwuz2_band_vwuc1 
    lda x
    and #<$fff8
    sta _1
    lda x+1
    and #>$fff8
    sta _1+1
    // [31] (byte*) bitmap_plot::plotter#1 ← (byte*)(word) bitmap_plot::plotter#0 + (word~) bitmap_plot::$1 -- pbuz1=pbuz2_plus_vwuz3 
    lda plotter
    clc
    adc _1
    sta plotter_1
    lda plotter+1
    adc _1+1
    sta plotter_1+1
    // [32] (byte~) bitmap_plot::$2 ← < (word) bitmap_plot::x#0 -- vbuz1=_lo_vwuz2 
    lda x
    sta _2
    // [33] *((byte*) bitmap_plot::plotter#1) ← *((byte*) bitmap_plot::plotter#1) | *((const byte[$100]) bitmap_plot_bit#0 + (byte~) bitmap_plot::$2) -- _deref_pbuz1=_deref_pbuz1_bor_pbuc1_derefidx_vbuz2 
    ldy #0
    lda (plotter_1),y
    ldy _2
    ora bitmap_plot_bit,y
    ldy #0
    sta (plotter_1),y
    jmp breturn
    // bitmap_plot::@return
  breturn:
    // [34] return 
    rts
}
  // point_init
// Initialize the points to be animated
// point_init(byte zeropage($22) point_idx)
point_init: {
    .label _3 = $31
    .label _4 = $33
    .label _9 = $38
    .label _10 = $3a
    .label _11 = $3c
    .label _14 = $46
    .label _16 = $47
    .label _18 = $2e
    .label _20 = $37
    .label point_idx = $22
    .label y_diff = $35
    .label abs16s1_return = $4a
    .label abs16s1_return_2 = 3
    .label abs16s2_return = $48
    .label abs16s2_return_2 = 5
    .label x_stepf = $44
    .label x_diff = $2f
    .label abs16s1_return_5 = 3
    .label abs16s1_return_6 = 3
    .label abs16s2_return_5 = 5
    .label abs16s2_return_6 = 5
    // [35] (byte~) point_init::$18 ← (byte) point_init::point_idx#0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda point_idx
    asl
    sta _18
    // [36] (signed word) point_init::x_diff#1 ← (signed word)*((const word[SIZE#0]) x_end#0 + (byte~) point_init::$18) - (signed word)*((const word[SIZE#0]) x_start#0 + (byte~) point_init::$18) -- vwsz1=pwsc1_derefidx_vbuz2_minus_pwsc2_derefidx_vbuz2 
    ldy _18
    sec
    lda x_end,y
    sbc x_start,y
    sta x_diff
    lda x_end+1,y
    sbc x_start+1,y
    sta x_diff+1
    // [37] (signed word~) point_init::$3 ← (signed word)*((const byte[SIZE#0]) y_end#0 + (byte) point_init::point_idx#0) -- vwsz1=_sword_pbuc1_derefidx_vbuz2 
    ldy point_idx
    lda y_end,y
    sta _3
    lda #0
    sta _3+1
    // [38] (signed word~) point_init::$4 ← (signed word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) -- vwsz1=_sword_pbuc1_derefidx_vbuz2 
    ldy point_idx
    lda y_start,y
    sta _4
    lda #0
    sta _4+1
    // [39] (signed word) point_init::y_diff#0 ← (signed word~) point_init::$3 - (signed word~) point_init::$4 -- vwsz1=vwsz2_minus_vwsz3 
    lda _3
    sec
    sbc _4
    sta y_diff
    lda _3+1
    sbc _4+1
    sta y_diff+1
    jmp abs16s1
    // point_init::abs16s1
  abs16s1:
    // [40] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::abs16s1_@1 -- vwsz1_lt_0_then_la1 
    lda x_diff+1
    bmi abs16s1_b1
    jmp abs16s1_b3
    // point_init::abs16s1_@3
  abs16s1_b3:
    // [41] (word~) point_init::abs16s1_return#6 ← (word)(signed word) point_init::x_diff#1 -- vwuz1=vwuz2 
    lda x_diff
    sta abs16s1_return_6
    lda x_diff+1
    sta abs16s1_return_6+1
    // [42] phi from point_init::abs16s1_@1 point_init::abs16s1_@3 to point_init::abs16s1_@return [phi:point_init::abs16s1_@1/point_init::abs16s1_@3->point_init::abs16s1_@return]
  abs16s1_breturn_from_abs16s1_b1:
  abs16s1_breturn_from_abs16s1_b3:
    // [42] phi (word) point_init::abs16s1_return#2 = (word~) point_init::abs16s1_return#5 [phi:point_init::abs16s1_@1/point_init::abs16s1_@3->point_init::abs16s1_@return#0] -- register_copy 
    jmp abs16s1_breturn
    // point_init::abs16s1_@return
  abs16s1_breturn:
    jmp abs16s2
    // point_init::abs16s2
  abs16s2:
    // [43] if((signed word) point_init::y_diff#0<(signed byte) 0) goto point_init::abs16s2_@1 -- vwsz1_lt_0_then_la1 
    lda y_diff+1
    bmi abs16s2_b1
    jmp abs16s2_b3
    // point_init::abs16s2_@3
  abs16s2_b3:
    // [44] (word~) point_init::abs16s2_return#6 ← (word)(signed word) point_init::y_diff#0 -- vwuz1=vwuz2 
    lda y_diff
    sta abs16s2_return_6
    lda y_diff+1
    sta abs16s2_return_6+1
    // [45] phi from point_init::abs16s2_@1 point_init::abs16s2_@3 to point_init::abs16s2_@return [phi:point_init::abs16s2_@1/point_init::abs16s2_@3->point_init::abs16s2_@return]
  abs16s2_breturn_from_abs16s2_b1:
  abs16s2_breturn_from_abs16s2_b3:
    // [45] phi (word) point_init::abs16s2_return#2 = (word~) point_init::abs16s2_return#5 [phi:point_init::abs16s2_@1/point_init::abs16s2_@3->point_init::abs16s2_@return#0] -- register_copy 
    jmp abs16s2_breturn
    // point_init::abs16s2_@return
  abs16s2_breturn:
    jmp b6
    // point_init::@6
  b6:
    // [46] if((word) point_init::abs16s1_return#2>(word) point_init::abs16s2_return#2) goto point_init::@1 -- vwuz1_gt_vwuz2_then_la1 
    lda abs16s2_return_2+1
    cmp abs16s1_return_2+1
    bcc b1
    bne !+
    lda abs16s2_return_2
    cmp abs16s1_return_2
    bcc b1
  !:
    jmp b2
    // point_init::@2
  b2:
    // [47] (byte~) point_init::$20 ← (byte) point_init::point_idx#0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda point_idx
    asl
    sta _20
    // [48] (word~) point_init::$9 ← *((const word[SIZE#0]) x_start#0 + (byte~) point_init::$20) << (byte) 4 -- vwuz1=pwuc1_derefidx_vbuz2_rol_4 
    ldy _20
    lda x_start,y
    sta _9
    lda x_start+1,y
    sta _9+1
    asl _9
    rol _9+1
    asl _9
    rol _9+1
    asl _9
    rol _9+1
    asl _9
    rol _9+1
    // [49] *((const word[SIZE#0]) x_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$9 -- pwuc1_derefidx_vbuz1=vwuz2 
    ldy _20
    lda _9
    sta x_cur,y
    lda _9+1
    sta x_cur+1,y
    // [50] (word~) point_init::$10 ← (word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) -- vwuz1=_word_pbuc1_derefidx_vbuz2 
    ldy point_idx
    lda y_start,y
    sta _10
    lda #0
    sta _10+1
    // [51] (word~) point_init::$11 ← (word~) point_init::$10 << (byte) 4 -- vwuz1=vwuz2_rol_4 
    lda _10
    asl
    sta _11
    lda _10+1
    rol
    sta _11+1
    asl _11
    rol _11+1
    asl _11
    rol _11+1
    asl _11
    rol _11+1
    // [52] *((const word[SIZE#0]) y_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$11 -- pwuc1_derefidx_vbuz1=vwuz2 
    ldy _20
    lda _11
    sta y_cur,y
    lda _11+1
    sta y_cur+1,y
    // [53] *((const byte[SIZE#0]) delay#0 + (byte) point_init::point_idx#0) ← (const byte) DELAY#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #DELAY
    ldy point_idx
    sta delay,y
    jmp breturn
    // point_init::@return
  breturn:
    // [54] return 
    rts
    // point_init::@1
  b1:
    // [55] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::@4 -- vwsz1_lt_0_then_la1 
    // X is driver - abs(y/x) is < 1
    lda x_diff+1
    bmi b4
    jmp b3
    // point_init::@3
  b3:
    // [56] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) $10 -- pbsc1_derefidx_vbuz1=vbsc2 
    // x add = 1.0
    lda #$10
    ldy point_idx
    sta x_add,y
    jmp b5
    // point_init::@5
  b5:
    // [57] (signed word) divr16s::divisor#0 ← (signed word) point_init::x_diff#1 -- vwsz1=vwsz2 
    lda x_diff
    sta divr16s.divisor
    lda x_diff+1
    sta divr16s.divisor+1
    // [58] (signed word) divr16s::rem#0 ← (signed word) point_init::y_diff#0 -- vwsz1=vwsz2 
    lda y_diff
    sta divr16s.rem
    lda y_diff+1
    sta divr16s.rem+1
    // [59] call divr16s 
    // [70] phi from point_init::@5 to divr16s [phi:point_init::@5->divr16s]
  divr16s_from_b5:
    jsr divr16s
    // [60] (signed word) divr16s::return#3 ← (signed word) divr16s::return#2 -- vwsz1=vwsz2 
    lda divr16s.return
    sta divr16s.return_3
    lda divr16s.return+1
    sta divr16s.return_3+1
    jmp b7
    // point_init::@7
  b7:
    // [61] (signed word) point_init::x_stepf#0 ← (signed word) divr16s::return#3 -- vwsz1=vwsz2 
    lda divr16s.return_3
    sta x_stepf
    lda divr16s.return_3+1
    sta x_stepf+1
    // [62] (byte~) point_init::$14 ← > (signed word) point_init::x_stepf#0 -- vbuz1=_hi_vwsz2 
    lda x_stepf+1
    sta _14
    // [63] (byte~) point_init::$16 ← (byte~) point_init::$14 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda _14
    lsr
    lsr
    lsr
    lsr
    sta _16
    // [64] *((const signed byte[SIZE#0]) y_add#0 + (byte) point_init::point_idx#0) ← (signed byte)(byte~) point_init::$16 -- pbsc1_derefidx_vbuz1=vbsz2 
    lda _16
    ldy point_idx
    sta y_add,y
    jmp b2
    // point_init::@4
  b4:
    // [65] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) -$10 -- pbsc1_derefidx_vbuz1=vbsc2 
    // x add = -1.0
    lda #-$10
    ldy point_idx
    sta x_add,y
    jmp b5
    // point_init::abs16s2_@1
  abs16s2_b1:
    // [66] (signed word) point_init::abs16s2_return#0 ← - (signed word) point_init::y_diff#0 -- vwsz1=_neg_vwsz2 
    sec
    lda #0
    sbc y_diff
    sta abs16s2_return
    lda #0
    sbc y_diff+1
    sta abs16s2_return+1
    // [67] (word~) point_init::abs16s2_return#5 ← (word)(signed word) point_init::abs16s2_return#0 -- vwuz1=vwuz2 
    lda abs16s2_return
    sta abs16s2_return_5
    lda abs16s2_return+1
    sta abs16s2_return_5+1
    jmp abs16s2_breturn_from_abs16s2_b1
    // point_init::abs16s1_@1
  abs16s1_b1:
    // [68] (signed word) point_init::abs16s1_return#0 ← - (signed word) point_init::x_diff#1 -- vwsz1=_neg_vwsz2 
    sec
    lda #0
    sbc x_diff
    sta abs16s1_return
    lda #0
    sbc x_diff+1
    sta abs16s1_return+1
    // [69] (word~) point_init::abs16s1_return#5 ← (word)(signed word) point_init::abs16s1_return#0 -- vwuz1=vwuz2 
    lda abs16s1_return
    sta abs16s1_return_5
    lda abs16s1_return+1
    sta abs16s1_return_5+1
    jmp abs16s1_breturn_from_abs16s1_b1
}
  // divr16s
// Perform division on two signed 16-bit numbers with an initial remainder.
// Returns dividend/divisor. The remainder will be set into the global variable rem16s.
// Implemented using simple binary division
// Follows the C99 standard by truncating toward zero on negative results.
// See http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf section 6.5.5
// divr16s(signed word zeropage($3e) divisor, signed word zeropage($40) rem)
divr16s: {
    .label remu = $54
    .label divisoru = $52
    .label neg = $b
    .label resultu = $50
    .label return = $c
    .label divisor = $3e
    .label rem = $40
    .label return_3 = $42
    .label divisoru_3 = 9
    .label remu_3 = 7
    .label remu_7 = 7
    .label remu_8 = 7
    .label divisoru_4 = 9
    .label divisoru_5 = 9
    jmp b10
    // divr16s::@10
  b10:
    // [71] if((signed word) divr16s::rem#0<(signed byte) 0) goto divr16s::@1 -- vwsz1_lt_0_then_la1 
    lda rem+1
    bmi b1
    jmp b6
    // divr16s::@6
  b6:
    // [72] (word~) divr16s::remu#8 ← (word)(signed word) divr16s::rem#0 -- vwuz1=vwuz2 
    lda rem
    sta remu_8
    lda rem+1
    sta remu_8+1
    // [73] phi from divr16s::@6 to divr16s::@2 [phi:divr16s::@6->divr16s::@2]
  b2_from_b6:
    // [73] phi (word) divr16s::remu#3 = (word~) divr16s::remu#8 [phi:divr16s::@6->divr16s::@2#0] -- register_copy 
    // [73] phi (byte) divr16s::neg#3 = (byte) 0 [phi:divr16s::@6->divr16s::@2#1] -- vbuz1=vbuc1 
    lda #0
    sta neg
    jmp b2
    // divr16s::@2
  b2:
    // [74] if((signed word) divr16s::divisor#0<(signed byte) 0) goto divr16s::@3 -- vwsz1_lt_0_then_la1 
    lda divisor+1
    bmi b3
    jmp b7
    // divr16s::@7
  b7:
    // [75] (word~) divr16s::divisoru#5 ← (word)(signed word) divr16s::divisor#0 -- vwuz1=vwuz2 
    lda divisor
    sta divisoru_5
    lda divisor+1
    sta divisoru_5+1
    // [76] phi from divr16s::@3 divr16s::@7 to divr16s::@4 [phi:divr16s::@3/divr16s::@7->divr16s::@4]
  b4_from_b3:
  b4_from_b7:
    // [76] phi (byte) divr16s::neg#4 = (byte) divr16s::neg#2 [phi:divr16s::@3/divr16s::@7->divr16s::@4#0] -- register_copy 
    // [76] phi (word) divr16s::divisoru#3 = (word~) divr16s::divisoru#4 [phi:divr16s::@3/divr16s::@7->divr16s::@4#1] -- register_copy 
    jmp b4
    // divr16s::@4
  b4:
    // [77] (word) divr16u::divisor#0 ← (word) divr16s::divisoru#3 -- vwuz1=vwuz2 
    lda divisoru_3
    sta divr16u.divisor
    lda divisoru_3+1
    sta divr16u.divisor+1
    // [78] (word) divr16u::rem#3 ← (word) divr16s::remu#3 -- vwuz1=vwuz2 
    lda remu_3
    sta divr16u.rem
    lda remu_3+1
    sta divr16u.rem+1
    // [79] call divr16u 
    // [92] phi from divr16s::@4 to divr16u [phi:divr16s::@4->divr16u]
  divr16u_from_b4:
    jsr divr16u
    // [80] (word) divr16u::return#2 ← (word) divr16u::return#0 -- vwuz1=vwuz2 
    lda divr16u.return
    sta divr16u.return_2
    lda divr16u.return+1
    sta divr16u.return_2+1
    jmp b9
    // divr16s::@9
  b9:
    // [81] (word) divr16s::resultu#0 ← (word) divr16u::return#2 -- vwuz1=vwuz2 
    lda divr16u.return_2
    sta resultu
    lda divr16u.return_2+1
    sta resultu+1
    // [82] if((byte) divr16s::neg#4==(byte) 0) goto divr16s::@5 -- vbuz1_eq_0_then_la1 
    lda neg
    cmp #0
    beq b5
    jmp b8
    // divr16s::@8
  b8:
    // [83] (signed word) divr16s::return#1 ← - (signed word)(word) divr16s::resultu#0 -- vwsz1=_neg_vwsz2 
    sec
    lda #0
    sbc resultu
    sta return
    lda #0
    sbc resultu+1
    sta return+1
    // [84] phi from divr16s::@5 divr16s::@8 to divr16s::@return [phi:divr16s::@5/divr16s::@8->divr16s::@return]
  breturn_from_b5:
  breturn_from_b8:
    // [84] phi (signed word) divr16s::return#2 = (signed word~) divr16s::return#7 [phi:divr16s::@5/divr16s::@8->divr16s::@return#0] -- register_copy 
    jmp breturn
    // divr16s::@return
  breturn:
    // [85] return 
    rts
    // divr16s::@5
  b5:
    // [86] (signed word~) divr16s::return#7 ← (signed word)(word) divr16s::resultu#0 -- vwsz1=vwsz2 
    lda resultu
    sta return
    lda resultu+1
    sta return+1
    jmp breturn_from_b5
    // divr16s::@3
  b3:
    // [87] (signed word) divr16s::divisoru#1 ← - (signed word) divr16s::divisor#0 -- vwsz1=_neg_vwsz2 
    sec
    lda #0
    sbc divisor
    sta divisoru
    lda #0
    sbc divisor+1
    sta divisoru+1
    // [88] (byte) divr16s::neg#2 ← (byte) divr16s::neg#3 ^ (byte) 1 -- vbuz1=vbuz1_bxor_vbuc1 
    lda #1
    eor neg
    sta neg
    // [89] (word~) divr16s::divisoru#4 ← (word)(signed word) divr16s::divisoru#1 -- vwuz1=vwuz2 
    lda divisoru
    sta divisoru_4
    lda divisoru+1
    sta divisoru_4+1
    jmp b4_from_b3
    // divr16s::@1
  b1:
    // [90] (signed word) divr16s::remu#1 ← - (signed word) divr16s::rem#0 -- vwsz1=_neg_vwsz2 
    sec
    lda #0
    sbc rem
    sta remu
    lda #0
    sbc rem+1
    sta remu+1
    // [91] (word~) divr16s::remu#7 ← (word)(signed word) divr16s::remu#1 -- vwuz1=vwuz2 
    lda remu
    sta remu_7
    lda remu+1
    sta remu_7+1
    // [73] phi from divr16s::@1 to divr16s::@2 [phi:divr16s::@1->divr16s::@2]
  b2_from_b1:
    // [73] phi (word) divr16s::remu#3 = (word~) divr16s::remu#7 [phi:divr16s::@1->divr16s::@2#0] -- register_copy 
    // [73] phi (byte) divr16s::neg#3 = (byte) 1 [phi:divr16s::@1->divr16s::@2#1] -- vbuz1=vbuc1 
    lda #1
    sta neg
    jmp b2
}
  // divr16u
// Performs division on two 16 bit unsigned words and an initial remainder
// Returns the quotient dividend/divisor.
// The final remainder will be set into the global variable rem16u
// Implemented using simple binary division
// divr16u(word zeropage($10) dividend, word zeropage($4c) divisor, word zeropage($e) rem)
divr16u: {
    .label _1 = $56
    .label _2 = $57
    .label rem = $e
    .label dividend = $10
    .label quotient = $12
    .label i = $14
    .label return = $12
    .label divisor = $4c
    .label return_2 = $4e
    // [93] phi from divr16u to divr16u::@1 [phi:divr16u->divr16u::@1]
  b1_from_divr16u:
    // [93] phi (byte) divr16u::i#2 = (byte) 0 [phi:divr16u->divr16u::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    // [93] phi (word) divr16u::quotient#3 = (byte) 0 [phi:divr16u->divr16u::@1#1] -- vwuz1=vbuc1 
    lda #<0
    sta quotient
    lda #>0
    sta quotient+1
    // [93] phi (word) divr16u::dividend#2 = (word) 0 [phi:divr16u->divr16u::@1#2] -- vwuz1=vwuc1 
    lda #<0
    sta dividend
    lda #>0
    sta dividend+1
    // [93] phi (word) divr16u::rem#4 = (word) divr16u::rem#3 [phi:divr16u->divr16u::@1#3] -- register_copy 
    jmp b1
    // [93] phi from divr16u::@3 to divr16u::@1 [phi:divr16u::@3->divr16u::@1]
  b1_from_b3:
    // [93] phi (byte) divr16u::i#2 = (byte) divr16u::i#1 [phi:divr16u::@3->divr16u::@1#0] -- register_copy 
    // [93] phi (word) divr16u::quotient#3 = (word) divr16u::return#0 [phi:divr16u::@3->divr16u::@1#1] -- register_copy 
    // [93] phi (word) divr16u::dividend#2 = (word) divr16u::dividend#0 [phi:divr16u::@3->divr16u::@1#2] -- register_copy 
    // [93] phi (word) divr16u::rem#4 = (word) divr16u::rem#9 [phi:divr16u::@3->divr16u::@1#3] -- register_copy 
    jmp b1
    // divr16u::@1
  b1:
    // [94] (word) divr16u::rem#0 ← (word) divr16u::rem#4 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl rem
    rol rem+1
    // [95] (byte~) divr16u::$1 ← > (word) divr16u::dividend#2 -- vbuz1=_hi_vwuz2 
    lda dividend+1
    sta _1
    // [96] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and _1
    sta _2
    // [97] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2 -- vbuz1_eq_0_then_la1 
    lda _2
    cmp #0
    beq b2_from_b1
    jmp b4
    // divr16u::@4
  b4:
    // [98] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 -- vwuz1=vwuz1_bor_vbuc1 
    lda #1
    ora rem
    sta rem
    // [99] phi from divr16u::@1 divr16u::@4 to divr16u::@2 [phi:divr16u::@1/divr16u::@4->divr16u::@2]
  b2_from_b1:
  b2_from_b4:
    // [99] phi (word) divr16u::rem#5 = (word) divr16u::rem#0 [phi:divr16u::@1/divr16u::@4->divr16u::@2#0] -- register_copy 
    jmp b2
    // divr16u::@2
  b2:
    // [100] (word) divr16u::dividend#0 ← (word) divr16u::dividend#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl dividend
    rol dividend+1
    // [101] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl quotient
    rol quotient+1
    // [102] if((word) divr16u::rem#5<(word) divr16u::divisor#0) goto divr16u::@3 -- vwuz1_lt_vwuz2_then_la1 
    lda rem+1
    cmp divisor+1
    bcc b3_from_b2
    bne !+
    lda rem
    cmp divisor
    bcc b3_from_b2
  !:
    jmp b5
    // divr16u::@5
  b5:
    // [103] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1 -- vwuz1=_inc_vwuz1 
    inc quotient
    bne !+
    inc quotient+1
  !:
    // [104] (word) divr16u::rem#2 ← (word) divr16u::rem#5 - (word) divr16u::divisor#0 -- vwuz1=vwuz1_minus_vwuz2 
    lda rem
    sec
    sbc divisor
    sta rem
    lda rem+1
    sbc divisor+1
    sta rem+1
    // [105] phi from divr16u::@2 divr16u::@5 to divr16u::@3 [phi:divr16u::@2/divr16u::@5->divr16u::@3]
  b3_from_b2:
  b3_from_b5:
    // [105] phi (word) divr16u::return#0 = (word) divr16u::quotient#1 [phi:divr16u::@2/divr16u::@5->divr16u::@3#0] -- register_copy 
    // [105] phi (word) divr16u::rem#9 = (word) divr16u::rem#5 [phi:divr16u::@2/divr16u::@5->divr16u::@3#1] -- register_copy 
    jmp b3
    // divr16u::@3
  b3:
    // [106] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2 -- vbuz1=_inc_vbuz1 
    inc i
    // [107] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$10
    cmp i
    bne b1_from_b3
    jmp breturn
    // divr16u::@return
  breturn:
    // [108] return 
    rts
}
  // screen_fill
// Fill the screen with a specific char
// screen_fill(byte* zeropage($16) screen)
screen_fill: {
    .const ch = $10
    .label screen = $16
    .label x = $18
    .label y = $15
    // [110] phi from screen_fill to screen_fill::@1 [phi:screen_fill->screen_fill::@1]
  b1_from_screen_fill:
    // [110] phi (byte) screen_fill::y#4 = (byte) 0 [phi:screen_fill->screen_fill::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    // [110] phi (byte*) screen_fill::screen#3 = (const byte*) SCREEN#0 [phi:screen_fill->screen_fill::@1#1] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta screen
    lda #>SCREEN
    sta screen+1
    jmp b1
    // [110] phi from screen_fill::@3 to screen_fill::@1 [phi:screen_fill::@3->screen_fill::@1]
  b1_from_b3:
    // [110] phi (byte) screen_fill::y#4 = (byte) screen_fill::y#1 [phi:screen_fill::@3->screen_fill::@1#0] -- register_copy 
    // [110] phi (byte*) screen_fill::screen#3 = (byte*) screen_fill::screen#1 [phi:screen_fill::@3->screen_fill::@1#1] -- register_copy 
    jmp b1
    // screen_fill::@1
  b1:
    // [111] phi from screen_fill::@1 to screen_fill::@2 [phi:screen_fill::@1->screen_fill::@2]
  b2_from_b1:
    // [111] phi (byte) screen_fill::x#2 = (byte) 0 [phi:screen_fill::@1->screen_fill::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta x
    // [111] phi (byte*) screen_fill::screen#2 = (byte*) screen_fill::screen#3 [phi:screen_fill::@1->screen_fill::@2#1] -- register_copy 
    jmp b2
    // [111] phi from screen_fill::@2 to screen_fill::@2 [phi:screen_fill::@2->screen_fill::@2]
  b2_from_b2:
    // [111] phi (byte) screen_fill::x#2 = (byte) screen_fill::x#1 [phi:screen_fill::@2->screen_fill::@2#0] -- register_copy 
    // [111] phi (byte*) screen_fill::screen#2 = (byte*) screen_fill::screen#1 [phi:screen_fill::@2->screen_fill::@2#1] -- register_copy 
    jmp b2
    // screen_fill::@2
  b2:
    // [112] *((byte*) screen_fill::screen#2) ← (const byte) screen_fill::ch#0 -- _deref_pbuz1=vbuc1 
    lda #ch
    ldy #0
    sta (screen),y
    // [113] (byte*) screen_fill::screen#1 ← ++ (byte*) screen_fill::screen#2 -- pbuz1=_inc_pbuz1 
    inc screen
    bne !+
    inc screen+1
  !:
    // [114] (byte) screen_fill::x#1 ← ++ (byte) screen_fill::x#2 -- vbuz1=_inc_vbuz1 
    inc x
    // [115] if((byte) screen_fill::x#1!=(byte) $28) goto screen_fill::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp x
    bne b2_from_b2
    jmp b3
    // screen_fill::@3
  b3:
    // [116] (byte) screen_fill::y#1 ← ++ (byte) screen_fill::y#4 -- vbuz1=_inc_vbuz1 
    inc y
    // [117] if((byte) screen_fill::y#1!=(byte) $19) goto screen_fill::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp y
    bne b1_from_b3
    jmp breturn
    // screen_fill::@return
  breturn:
    // [118] return 
    rts
}
  // bitmap_clear
// Clear all graphics on the bitmap
bitmap_clear: {
    .label bitmap = $58
    .label bitmap_1 = $1a
    .label x = $1c
    .label y = $19
    .label bitmap_2 = $1a
    .label bitmap_3 = $1a
    .label bitmap_5 = $1a
    // [119] (word) bitmap_clear::bitmap#0 ← *((const byte[$100]) bitmap_plot_yhi#0) w= *((const byte[$100]) bitmap_plot_ylo#0) -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda bitmap_plot_ylo
    sta bitmap
    lda bitmap_plot_yhi
    sta bitmap+1
    // [120] (byte*~) bitmap_clear::bitmap#5 ← (byte*)(word) bitmap_clear::bitmap#0 -- pbuz1=pbuz2 
    lda bitmap
    sta bitmap_5
    lda bitmap+1
    sta bitmap_5+1
    // [121] phi from bitmap_clear to bitmap_clear::@1 [phi:bitmap_clear->bitmap_clear::@1]
  b1_from_bitmap_clear:
    // [121] phi (byte) bitmap_clear::y#4 = (byte) 0 [phi:bitmap_clear->bitmap_clear::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    // [121] phi (byte*) bitmap_clear::bitmap#3 = (byte*~) bitmap_clear::bitmap#5 [phi:bitmap_clear->bitmap_clear::@1#1] -- register_copy 
    jmp b1
    // [121] phi from bitmap_clear::@3 to bitmap_clear::@1 [phi:bitmap_clear::@3->bitmap_clear::@1]
  b1_from_b3:
    // [121] phi (byte) bitmap_clear::y#4 = (byte) bitmap_clear::y#1 [phi:bitmap_clear::@3->bitmap_clear::@1#0] -- register_copy 
    // [121] phi (byte*) bitmap_clear::bitmap#3 = (byte*) bitmap_clear::bitmap#1 [phi:bitmap_clear::@3->bitmap_clear::@1#1] -- register_copy 
    jmp b1
    // bitmap_clear::@1
  b1:
    // [122] phi from bitmap_clear::@1 to bitmap_clear::@2 [phi:bitmap_clear::@1->bitmap_clear::@2]
  b2_from_b1:
    // [122] phi (byte) bitmap_clear::x#2 = (byte) 0 [phi:bitmap_clear::@1->bitmap_clear::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta x
    // [122] phi (byte*) bitmap_clear::bitmap#2 = (byte*) bitmap_clear::bitmap#3 [phi:bitmap_clear::@1->bitmap_clear::@2#1] -- register_copy 
    jmp b2
    // [122] phi from bitmap_clear::@2 to bitmap_clear::@2 [phi:bitmap_clear::@2->bitmap_clear::@2]
  b2_from_b2:
    // [122] phi (byte) bitmap_clear::x#2 = (byte) bitmap_clear::x#1 [phi:bitmap_clear::@2->bitmap_clear::@2#0] -- register_copy 
    // [122] phi (byte*) bitmap_clear::bitmap#2 = (byte*) bitmap_clear::bitmap#1 [phi:bitmap_clear::@2->bitmap_clear::@2#1] -- register_copy 
    jmp b2
    // bitmap_clear::@2
  b2:
    // [123] *((byte*) bitmap_clear::bitmap#2) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (bitmap_2),y
    // [124] (byte*) bitmap_clear::bitmap#1 ← ++ (byte*) bitmap_clear::bitmap#2 -- pbuz1=_inc_pbuz1 
    inc bitmap_1
    bne !+
    inc bitmap_1+1
  !:
    // [125] (byte) bitmap_clear::x#1 ← ++ (byte) bitmap_clear::x#2 -- vbuz1=_inc_vbuz1 
    inc x
    // [126] if((byte) bitmap_clear::x#1!=(byte) $c8) goto bitmap_clear::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$c8
    cmp x
    bne b2_from_b2
    jmp b3
    // bitmap_clear::@3
  b3:
    // [127] (byte) bitmap_clear::y#1 ← ++ (byte) bitmap_clear::y#4 -- vbuz1=_inc_vbuz1 
    inc y
    // [128] if((byte) bitmap_clear::y#1!=(byte) $28) goto bitmap_clear::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp y
    bne b1_from_b3
    jmp breturn
    // bitmap_clear::@return
  breturn:
    // [129] return 
    rts
}
  // bitmap_init
bitmap_init: {
    .label _4 = $5b
    .label _5 = $5c
    .label _6 = $5d
    .label _7 = $5a
    .label bits = $1d
    .label x = $1e
    .label y = $1f
    .label yoffs = $20
    // [131] phi from bitmap_init to bitmap_init::@1 [phi:bitmap_init->bitmap_init::@1]
  b1_from_bitmap_init:
    // [131] phi (byte) bitmap_init::x#2 = (byte) 0 [phi:bitmap_init->bitmap_init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x
    // [131] phi (byte) bitmap_init::bits#3 = (byte) $80 [phi:bitmap_init->bitmap_init::@1#1] -- vbuz1=vbuc1 
    lda #$80
    sta bits
    jmp b1
    // [131] phi from bitmap_init::@2 to bitmap_init::@1 [phi:bitmap_init::@2->bitmap_init::@1]
  b1_from_b2:
    // [131] phi (byte) bitmap_init::x#2 = (byte) bitmap_init::x#1 [phi:bitmap_init::@2->bitmap_init::@1#0] -- register_copy 
    // [131] phi (byte) bitmap_init::bits#3 = (byte) bitmap_init::bits#4 [phi:bitmap_init::@2->bitmap_init::@1#1] -- register_copy 
    jmp b1
    // bitmap_init::@1
  b1:
    // [132] *((const byte[$100]) bitmap_plot_bit#0 + (byte) bitmap_init::x#2) ← (byte) bitmap_init::bits#3 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda bits
    ldy x
    sta bitmap_plot_bit,y
    // [133] (byte) bitmap_init::bits#1 ← (byte) bitmap_init::bits#3 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr bits
    // [134] if((byte) bitmap_init::bits#1!=(byte) 0) goto bitmap_init::@6 -- vbuz1_neq_0_then_la1 
    lda bits
    cmp #0
    bne b6_from_b1
    // [136] phi from bitmap_init::@1 to bitmap_init::@2 [phi:bitmap_init::@1->bitmap_init::@2]
  b2_from_b1:
    // [136] phi (byte) bitmap_init::bits#4 = (byte) $80 [phi:bitmap_init::@1->bitmap_init::@2#0] -- vbuz1=vbuc1 
    lda #$80
    sta bits
    jmp b2
    // [135] phi from bitmap_init::@1 to bitmap_init::@6 [phi:bitmap_init::@1->bitmap_init::@6]
  b6_from_b1:
    jmp b6
    // bitmap_init::@6
  b6:
    // [136] phi from bitmap_init::@6 to bitmap_init::@2 [phi:bitmap_init::@6->bitmap_init::@2]
  b2_from_b6:
    // [136] phi (byte) bitmap_init::bits#4 = (byte) bitmap_init::bits#1 [phi:bitmap_init::@6->bitmap_init::@2#0] -- register_copy 
    jmp b2
    // bitmap_init::@2
  b2:
    // [137] (byte) bitmap_init::x#1 ← ++ (byte) bitmap_init::x#2 -- vbuz1=_inc_vbuz1 
    inc x
    // [138] if((byte) bitmap_init::x#1!=(byte) 0) goto bitmap_init::@1 -- vbuz1_neq_0_then_la1 
    lda x
    cmp #0
    bne b1_from_b2
    // [139] phi from bitmap_init::@2 to bitmap_init::@3 [phi:bitmap_init::@2->bitmap_init::@3]
  b3_from_b2:
    // [139] phi (byte*) bitmap_init::yoffs#2 = (const byte*) BITMAP#0 [phi:bitmap_init::@2->bitmap_init::@3#0] -- pbuz1=pbuc1 
    lda #<BITMAP
    sta yoffs
    lda #>BITMAP
    sta yoffs+1
    // [139] phi (byte) bitmap_init::y#2 = (byte) 0 [phi:bitmap_init::@2->bitmap_init::@3#1] -- vbuz1=vbuc1 
    lda #0
    sta y
    jmp b3
    // [139] phi from bitmap_init::@4 to bitmap_init::@3 [phi:bitmap_init::@4->bitmap_init::@3]
  b3_from_b4:
    // [139] phi (byte*) bitmap_init::yoffs#2 = (byte*) bitmap_init::yoffs#4 [phi:bitmap_init::@4->bitmap_init::@3#0] -- register_copy 
    // [139] phi (byte) bitmap_init::y#2 = (byte) bitmap_init::y#1 [phi:bitmap_init::@4->bitmap_init::@3#1] -- register_copy 
    jmp b3
    // bitmap_init::@3
  b3:
    // [140] (byte~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and y
    sta _7
    // [141] (byte~) bitmap_init::$4 ← < (byte*) bitmap_init::yoffs#2 -- vbuz1=_lo_pbuz2 
    lda yoffs
    sta _4
    // [142] (byte~) bitmap_init::$5 ← (byte~) bitmap_init::$7 | (byte~) bitmap_init::$4 -- vbuz1=vbuz2_bor_vbuz3 
    lda _7
    ora _4
    sta _5
    // [143] *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_init::y#2) ← (byte~) bitmap_init::$5 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _5
    ldy y
    sta bitmap_plot_ylo,y
    // [144] (byte~) bitmap_init::$6 ← > (byte*) bitmap_init::yoffs#2 -- vbuz1=_hi_pbuz2 
    lda yoffs+1
    sta _6
    // [145] *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_init::y#2) ← (byte~) bitmap_init::$6 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _6
    ldy y
    sta bitmap_plot_yhi,y
    // [146] if((byte~) bitmap_init::$7!=(byte) 7) goto bitmap_init::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #7
    cmp _7
    bne b4_from_b3
    jmp b5
    // bitmap_init::@5
  b5:
    // [147] (byte*) bitmap_init::yoffs#1 ← (byte*) bitmap_init::yoffs#2 + (word)(number) $28*(number) 8 -- pbuz1=pbuz1_plus_vwuc1 
    clc
    lda yoffs
    adc #<$28*8
    sta yoffs
    lda yoffs+1
    adc #>$28*8
    sta yoffs+1
    // [148] phi from bitmap_init::@3 bitmap_init::@5 to bitmap_init::@4 [phi:bitmap_init::@3/bitmap_init::@5->bitmap_init::@4]
  b4_from_b3:
  b4_from_b5:
    // [148] phi (byte*) bitmap_init::yoffs#4 = (byte*) bitmap_init::yoffs#2 [phi:bitmap_init::@3/bitmap_init::@5->bitmap_init::@4#0] -- register_copy 
    jmp b4
    // bitmap_init::@4
  b4:
    // [149] (byte) bitmap_init::y#1 ← ++ (byte) bitmap_init::y#2 -- vbuz1=_inc_vbuz1 
    inc y
    // [150] if((byte) bitmap_init::y#1!=(byte) 0) goto bitmap_init::@3 -- vbuz1_neq_0_then_la1 
    lda y
    cmp #0
    bne b3_from_b4
    jmp breturn
    // bitmap_init::@return
  breturn:
    // [151] return 
    rts
}
  // File Data
  // The coordinates of the lines to animate
  x_start: .word $a, $14, $1e, $1e
  y_start: .byte $a, $a, $a, $14
  x_end: .word $14, $a, $14, $14
  y_end: .byte $14, $14, $a, $14
  // Tables for the plotter - initialized by calling bitmap_init();
  bitmap_plot_ylo: .fill $100, 0
  bitmap_plot_yhi: .fill $100, 0
  bitmap_plot_bit: .fill $100, 0
  // Current x position fixed point [12.4]
  x_cur: .fill 2*SIZE, 0
  // Current y position fixed point [12.4]
  y_cur: .fill 2*SIZE, 0
  // X position addition per frame s[3.4]
  x_add: .fill SIZE, 0
  // Y position addition per frame s[3.4]
  y_add: .fill SIZE, 0
  // Frame delay (counted down to 0)
  delay: .fill SIZE, 0

REGISTER UPLIFT POTENTIAL REGISTERS
Equivalence Class zp ZP_BYTE:91 [ bitmap_init::$4 ] has ALU potential.
Statement [5] *((const byte*) PROCPORT_DDR#0) ← (const byte) PROCPORT_DDR_MEMORY_MASK#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [6] *((const byte*) PROCPORT#0) ← (const byte) PROCPORT_RAM_IO#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((const byte*) D011#0) ← (const byte) VIC_BMM#0|(const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [8] *((const byte*) CIA2_PORT_A_DDR#0) ← (byte) 3 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [10] *((const byte*) CIA2_PORT_A#0) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [21] (byte~) main::$13 ← (byte) main::i#2 << (byte) 1 [ main::i#2 main::$13 ] ( main:2 [ main::i#2 main::$13 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::i#2 main::i#1 ]
Statement [22] (word) bitmap_plot::x#0 ← *((const word[SIZE#0]) x_start#0 + (byte~) main::$13) [ main::i#2 bitmap_plot::x#0 ] ( main:2 [ main::i#2 bitmap_plot::x#0 ] ) always clobbers reg byte a 
Statement [27] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@2 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [29] (word) bitmap_plot::plotter#0 ← *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_plot::y#0) w= *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_plot::y#0) [ bitmap_plot::x#0 bitmap_plot::plotter#0 ] ( main:2::bitmap_plot:24 [ main::i#2 bitmap_plot::x#0 bitmap_plot::plotter#0 ] ) always clobbers reg byte a 
Statement [30] (word~) bitmap_plot::$1 ← (word) bitmap_plot::x#0 & (word) $fff8 [ bitmap_plot::x#0 bitmap_plot::plotter#0 bitmap_plot::$1 ] ( main:2::bitmap_plot:24 [ main::i#2 bitmap_plot::x#0 bitmap_plot::plotter#0 bitmap_plot::$1 ] ) always clobbers reg byte a 
Statement [31] (byte*) bitmap_plot::plotter#1 ← (byte*)(word) bitmap_plot::plotter#0 + (word~) bitmap_plot::$1 [ bitmap_plot::x#0 bitmap_plot::plotter#1 ] ( main:2::bitmap_plot:24 [ main::i#2 bitmap_plot::x#0 bitmap_plot::plotter#1 ] ) always clobbers reg byte a 
Statement [32] (byte~) bitmap_plot::$2 ← < (word) bitmap_plot::x#0 [ bitmap_plot::plotter#1 bitmap_plot::$2 ] ( main:2::bitmap_plot:24 [ main::i#2 bitmap_plot::plotter#1 bitmap_plot::$2 ] ) always clobbers reg byte a 
Statement [33] *((byte*) bitmap_plot::plotter#1) ← *((byte*) bitmap_plot::plotter#1) | *((const byte[$100]) bitmap_plot_bit#0 + (byte~) bitmap_plot::$2) [ ] ( main:2::bitmap_plot:24 [ main::i#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:2 [ main::i#2 main::i#1 ]
Statement [35] (byte~) point_init::$18 ← (byte) point_init::point_idx#0 << (byte) 1 [ point_init::point_idx#0 point_init::$18 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$18 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:34 [ point_init::point_idx#0 ]
Statement [36] (signed word) point_init::x_diff#1 ← (signed word)*((const word[SIZE#0]) x_end#0 + (byte~) point_init::$18) - (signed word)*((const word[SIZE#0]) x_start#0 + (byte~) point_init::$18) [ point_init::point_idx#0 point_init::x_diff#1 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 ] ) always clobbers reg byte a 
Statement [37] (signed word~) point_init::$3 ← (signed word)*((const byte[SIZE#0]) y_end#0 + (byte) point_init::point_idx#0) [ point_init::point_idx#0 point_init::x_diff#1 point_init::$3 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::$3 ] ) always clobbers reg byte a 
Statement [38] (signed word~) point_init::$4 ← (signed word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) [ point_init::point_idx#0 point_init::x_diff#1 point_init::$3 point_init::$4 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::$3 point_init::$4 ] ) always clobbers reg byte a 
Statement [39] (signed word) point_init::y_diff#0 ← (signed word~) point_init::$3 - (signed word~) point_init::$4 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [40] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::abs16s1_@1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [41] (word~) point_init::abs16s1_return#6 ← (word)(signed word) point_init::x_diff#1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#6 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#6 ] ) always clobbers reg byte a 
Statement [43] if((signed word) point_init::y_diff#0<(signed byte) 0) goto point_init::abs16s2_@1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 ] ) always clobbers reg byte a 
Statement [44] (word~) point_init::abs16s2_return#6 ← (word)(signed word) point_init::y_diff#0 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#6 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#6 ] ) always clobbers reg byte a 
Statement [46] if((word) point_init::abs16s1_return#2>(word) point_init::abs16s2_return#2) goto point_init::@1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [47] (byte~) point_init::$20 ← (byte) point_init::point_idx#0 << (byte) 1 [ point_init::point_idx#0 point_init::$20 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 ] ) always clobbers reg byte a 
Statement [48] (word~) point_init::$9 ← *((const word[SIZE#0]) x_start#0 + (byte~) point_init::$20) << (byte) 4 [ point_init::point_idx#0 point_init::$20 point_init::$9 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 point_init::$9 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:55 [ point_init::$20 ]
Statement [49] *((const word[SIZE#0]) x_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$9 [ point_init::point_idx#0 point_init::$20 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 ] ) always clobbers reg byte a 
Statement [50] (word~) point_init::$10 ← (word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) [ point_init::point_idx#0 point_init::$20 point_init::$10 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 point_init::$10 ] ) always clobbers reg byte a 
Statement [51] (word~) point_init::$11 ← (word~) point_init::$10 << (byte) 4 [ point_init::point_idx#0 point_init::$20 point_init::$11 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 point_init::$11 ] ) always clobbers reg byte a 
Statement [52] *((const word[SIZE#0]) y_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$11 [ point_init::point_idx#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 ] ) always clobbers reg byte a 
Statement [53] *((const byte[SIZE#0]) delay#0 + (byte) point_init::point_idx#0) ← (const byte) DELAY#0 [ ] ( main:2::point_init:20 [ main::i#2 ] ) always clobbers reg byte a 
Statement [55] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::@4 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [56] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) $10 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [57] (signed word) divr16s::divisor#0 ← (signed word) point_init::x_diff#1 [ point_init::point_idx#0 point_init::y_diff#0 divr16s::divisor#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::y_diff#0 divr16s::divisor#0 ] ) always clobbers reg byte a 
Statement [58] (signed word) divr16s::rem#0 ← (signed word) point_init::y_diff#0 [ point_init::point_idx#0 divr16s::divisor#0 divr16s::rem#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::rem#0 ] ) always clobbers reg byte a 
Statement [60] (signed word) divr16s::return#3 ← (signed word) divr16s::return#2 [ point_init::point_idx#0 divr16s::return#3 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 divr16s::return#3 ] ) always clobbers reg byte a 
Statement [61] (signed word) point_init::x_stepf#0 ← (signed word) divr16s::return#3 [ point_init::point_idx#0 point_init::x_stepf#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_stepf#0 ] ) always clobbers reg byte a 
Statement [62] (byte~) point_init::$14 ← > (signed word) point_init::x_stepf#0 [ point_init::point_idx#0 point_init::$14 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$14 ] ) always clobbers reg byte a 
Statement [63] (byte~) point_init::$16 ← (byte~) point_init::$14 >> (byte) 4 [ point_init::point_idx#0 point_init::$16 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$16 ] ) always clobbers reg byte a 
Statement [65] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) -$10 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [66] (signed word) point_init::abs16s2_return#0 ← - (signed word) point_init::y_diff#0 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#0 ] ) always clobbers reg byte a 
Statement [67] (word~) point_init::abs16s2_return#5 ← (word)(signed word) point_init::abs16s2_return#0 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#5 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#5 ] ) always clobbers reg byte a 
Statement [68] (signed word) point_init::abs16s1_return#0 ← - (signed word) point_init::x_diff#1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#0 ] ) always clobbers reg byte a 
Statement [69] (word~) point_init::abs16s1_return#5 ← (word)(signed word) point_init::abs16s1_return#0 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#5 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#5 ] ) always clobbers reg byte a 
Statement [71] if((signed word) divr16s::rem#0<(signed byte) 0) goto divr16s::@1 [ divr16s::divisor#0 divr16s::rem#0 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::rem#0 ] ) always clobbers reg byte a 
Statement [72] (word~) divr16s::remu#8 ← (word)(signed word) divr16s::rem#0 [ divr16s::divisor#0 divr16s::remu#8 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::remu#8 ] ) always clobbers reg byte a 
Statement [74] if((signed word) divr16s::divisor#0<(signed byte) 0) goto divr16s::@3 [ divr16s::divisor#0 divr16s::neg#3 divr16s::remu#3 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::neg#3 divr16s::remu#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:11 [ divr16s::neg#4 divr16s::neg#2 divr16s::neg#3 ]
Statement [75] (word~) divr16s::divisoru#5 ← (word)(signed word) divr16s::divisor#0 [ divr16s::neg#3 divr16s::remu#3 divr16s::divisoru#5 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#3 divr16s::remu#3 divr16s::divisoru#5 ] ) always clobbers reg byte a 
Statement [77] (word) divr16u::divisor#0 ← (word) divr16s::divisoru#3 [ divr16s::remu#3 divr16s::neg#4 divr16u::divisor#0 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::remu#3 divr16s::neg#4 divr16u::divisor#0 ] ) always clobbers reg byte a 
Statement [78] (word) divr16u::rem#3 ← (word) divr16s::remu#3 [ divr16s::neg#4 divr16u::divisor#0 divr16u::rem#3 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::rem#3 ] ) always clobbers reg byte a 
Statement [80] (word) divr16u::return#2 ← (word) divr16u::return#0 [ divr16s::neg#4 divr16u::return#2 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::return#2 ] ) always clobbers reg byte a 
Statement [81] (word) divr16s::resultu#0 ← (word) divr16u::return#2 [ divr16s::neg#4 divr16s::resultu#0 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16s::resultu#0 ] ) always clobbers reg byte a 
Statement [83] (signed word) divr16s::return#1 ← - (signed word)(word) divr16s::resultu#0 [ divr16s::return#1 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::return#1 ] ) always clobbers reg byte a 
Statement [86] (signed word~) divr16s::return#7 ← (signed word)(word) divr16s::resultu#0 [ divr16s::return#7 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::return#7 ] ) always clobbers reg byte a 
Statement [87] (signed word) divr16s::divisoru#1 ← - (signed word) divr16s::divisor#0 [ divr16s::neg#3 divr16s::remu#3 divr16s::divisoru#1 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#3 divr16s::remu#3 divr16s::divisoru#1 ] ) always clobbers reg byte a 
Statement [88] (byte) divr16s::neg#2 ← (byte) divr16s::neg#3 ^ (byte) 1 [ divr16s::remu#3 divr16s::neg#2 divr16s::divisoru#1 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::remu#3 divr16s::neg#2 divr16s::divisoru#1 ] ) always clobbers reg byte a 
Statement [89] (word~) divr16s::divisoru#4 ← (word)(signed word) divr16s::divisoru#1 [ divr16s::remu#3 divr16s::divisoru#4 divr16s::neg#2 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::remu#3 divr16s::divisoru#4 divr16s::neg#2 ] ) always clobbers reg byte a 
Statement [90] (signed word) divr16s::remu#1 ← - (signed word) divr16s::rem#0 [ divr16s::divisor#0 divr16s::remu#1 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::remu#1 ] ) always clobbers reg byte a 
Statement [91] (word~) divr16s::remu#7 ← (word)(signed word) divr16s::remu#1 [ divr16s::divisor#0 divr16s::remu#7 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::remu#7 ] ) always clobbers reg byte a 
Statement [95] (byte~) divr16u::$1 ← > (word) divr16u::dividend#2 [ divr16u::divisor#0 divr16u::dividend#2 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ( main:2::point_init:20::divr16s:59::divr16u:79 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::dividend#2 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:20 [ divr16u::i#2 divr16u::i#1 ]
Statement [98] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 [ divr16u::divisor#0 divr16u::dividend#2 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ( main:2::point_init:20::divr16s:59::divr16u:79 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::dividend#2 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ) always clobbers reg byte a 
Statement [102] if((word) divr16u::rem#5<(word) divr16u::divisor#0) goto divr16u::@3 [ divr16u::divisor#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#5 divr16u::quotient#1 ] ( main:2::point_init:20::divr16s:59::divr16u:79 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#5 divr16u::quotient#1 ] ) always clobbers reg byte a 
Statement [104] (word) divr16u::rem#2 ← (word) divr16u::rem#5 - (word) divr16u::divisor#0 [ divr16u::divisor#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ( main:2::point_init:20::divr16s:59::divr16u:79 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ) always clobbers reg byte a 
Statement [112] *((byte*) screen_fill::screen#2) ← (const byte) screen_fill::ch#0 [ screen_fill::y#4 screen_fill::screen#2 screen_fill::x#2 ] ( main:2::screen_fill:17 [ screen_fill::y#4 screen_fill::screen#2 screen_fill::x#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:21 [ screen_fill::y#4 screen_fill::y#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:21 [ screen_fill::y#4 screen_fill::y#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:24 [ screen_fill::x#2 screen_fill::x#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:24 [ screen_fill::x#2 screen_fill::x#1 ]
Statement [119] (word) bitmap_clear::bitmap#0 ← *((const byte[$100]) bitmap_plot_yhi#0) w= *((const byte[$100]) bitmap_plot_ylo#0) [ bitmap_clear::bitmap#0 ] ( main:2::bitmap_clear:15 [ bitmap_clear::bitmap#0 ] ) always clobbers reg byte a 
Statement [120] (byte*~) bitmap_clear::bitmap#5 ← (byte*)(word) bitmap_clear::bitmap#0 [ bitmap_clear::bitmap#5 ] ( main:2::bitmap_clear:15 [ bitmap_clear::bitmap#5 ] ) always clobbers reg byte a 
Statement [123] *((byte*) bitmap_clear::bitmap#2) ← (byte) 0 [ bitmap_clear::y#4 bitmap_clear::bitmap#2 bitmap_clear::x#2 ] ( main:2::bitmap_clear:15 [ bitmap_clear::y#4 bitmap_clear::bitmap#2 bitmap_clear::x#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:25 [ bitmap_clear::y#4 bitmap_clear::y#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:25 [ bitmap_clear::y#4 bitmap_clear::y#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:28 [ bitmap_clear::x#2 bitmap_clear::x#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:28 [ bitmap_clear::x#2 bitmap_clear::x#1 ]
Statement [147] (byte*) bitmap_init::yoffs#1 ← (byte*) bitmap_init::yoffs#2 + (word)(number) $28*(number) 8 [ bitmap_init::y#2 bitmap_init::yoffs#1 ] ( main:2::bitmap_init:13 [ bitmap_init::y#2 bitmap_init::yoffs#1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:31 [ bitmap_init::y#2 bitmap_init::y#1 ]
Statement [5] *((const byte*) PROCPORT_DDR#0) ← (const byte) PROCPORT_DDR_MEMORY_MASK#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [6] *((const byte*) PROCPORT#0) ← (const byte) PROCPORT_RAM_IO#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((const byte*) D011#0) ← (const byte) VIC_BMM#0|(const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [8] *((const byte*) CIA2_PORT_A_DDR#0) ← (byte) 3 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [10] *((const byte*) CIA2_PORT_A#0) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [21] (byte~) main::$13 ← (byte) main::i#2 << (byte) 1 [ main::i#2 main::$13 ] ( main:2 [ main::i#2 main::$13 ] ) always clobbers reg byte a 
Statement [22] (word) bitmap_plot::x#0 ← *((const word[SIZE#0]) x_start#0 + (byte~) main::$13) [ main::i#2 bitmap_plot::x#0 ] ( main:2 [ main::i#2 bitmap_plot::x#0 ] ) always clobbers reg byte a 
Statement [27] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@2 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [29] (word) bitmap_plot::plotter#0 ← *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_plot::y#0) w= *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_plot::y#0) [ bitmap_plot::x#0 bitmap_plot::plotter#0 ] ( main:2::bitmap_plot:24 [ main::i#2 bitmap_plot::x#0 bitmap_plot::plotter#0 ] ) always clobbers reg byte a 
Statement [30] (word~) bitmap_plot::$1 ← (word) bitmap_plot::x#0 & (word) $fff8 [ bitmap_plot::x#0 bitmap_plot::plotter#0 bitmap_plot::$1 ] ( main:2::bitmap_plot:24 [ main::i#2 bitmap_plot::x#0 bitmap_plot::plotter#0 bitmap_plot::$1 ] ) always clobbers reg byte a 
Statement [31] (byte*) bitmap_plot::plotter#1 ← (byte*)(word) bitmap_plot::plotter#0 + (word~) bitmap_plot::$1 [ bitmap_plot::x#0 bitmap_plot::plotter#1 ] ( main:2::bitmap_plot:24 [ main::i#2 bitmap_plot::x#0 bitmap_plot::plotter#1 ] ) always clobbers reg byte a 
Statement [32] (byte~) bitmap_plot::$2 ← < (word) bitmap_plot::x#0 [ bitmap_plot::plotter#1 bitmap_plot::$2 ] ( main:2::bitmap_plot:24 [ main::i#2 bitmap_plot::plotter#1 bitmap_plot::$2 ] ) always clobbers reg byte a 
Statement [33] *((byte*) bitmap_plot::plotter#1) ← *((byte*) bitmap_plot::plotter#1) | *((const byte[$100]) bitmap_plot_bit#0 + (byte~) bitmap_plot::$2) [ ] ( main:2::bitmap_plot:24 [ main::i#2 ] ) always clobbers reg byte a reg byte y 
Statement [35] (byte~) point_init::$18 ← (byte) point_init::point_idx#0 << (byte) 1 [ point_init::point_idx#0 point_init::$18 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$18 ] ) always clobbers reg byte a 
Statement [36] (signed word) point_init::x_diff#1 ← (signed word)*((const word[SIZE#0]) x_end#0 + (byte~) point_init::$18) - (signed word)*((const word[SIZE#0]) x_start#0 + (byte~) point_init::$18) [ point_init::point_idx#0 point_init::x_diff#1 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 ] ) always clobbers reg byte a 
Statement [37] (signed word~) point_init::$3 ← (signed word)*((const byte[SIZE#0]) y_end#0 + (byte) point_init::point_idx#0) [ point_init::point_idx#0 point_init::x_diff#1 point_init::$3 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::$3 ] ) always clobbers reg byte a 
Statement [38] (signed word~) point_init::$4 ← (signed word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) [ point_init::point_idx#0 point_init::x_diff#1 point_init::$3 point_init::$4 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::$3 point_init::$4 ] ) always clobbers reg byte a 
Statement [39] (signed word) point_init::y_diff#0 ← (signed word~) point_init::$3 - (signed word~) point_init::$4 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [40] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::abs16s1_@1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [41] (word~) point_init::abs16s1_return#6 ← (word)(signed word) point_init::x_diff#1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#6 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#6 ] ) always clobbers reg byte a 
Statement [43] if((signed word) point_init::y_diff#0<(signed byte) 0) goto point_init::abs16s2_@1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 ] ) always clobbers reg byte a 
Statement [44] (word~) point_init::abs16s2_return#6 ← (word)(signed word) point_init::y_diff#0 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#6 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#6 ] ) always clobbers reg byte a 
Statement [46] if((word) point_init::abs16s1_return#2>(word) point_init::abs16s2_return#2) goto point_init::@1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [47] (byte~) point_init::$20 ← (byte) point_init::point_idx#0 << (byte) 1 [ point_init::point_idx#0 point_init::$20 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 ] ) always clobbers reg byte a 
Statement [48] (word~) point_init::$9 ← *((const word[SIZE#0]) x_start#0 + (byte~) point_init::$20) << (byte) 4 [ point_init::point_idx#0 point_init::$20 point_init::$9 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 point_init::$9 ] ) always clobbers reg byte a 
Statement [49] *((const word[SIZE#0]) x_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$9 [ point_init::point_idx#0 point_init::$20 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 ] ) always clobbers reg byte a 
Statement [50] (word~) point_init::$10 ← (word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) [ point_init::point_idx#0 point_init::$20 point_init::$10 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 point_init::$10 ] ) always clobbers reg byte a 
Statement [51] (word~) point_init::$11 ← (word~) point_init::$10 << (byte) 4 [ point_init::point_idx#0 point_init::$20 point_init::$11 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$20 point_init::$11 ] ) always clobbers reg byte a 
Statement [52] *((const word[SIZE#0]) y_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$11 [ point_init::point_idx#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 ] ) always clobbers reg byte a 
Statement [53] *((const byte[SIZE#0]) delay#0 + (byte) point_init::point_idx#0) ← (const byte) DELAY#0 [ ] ( main:2::point_init:20 [ main::i#2 ] ) always clobbers reg byte a 
Statement [55] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::@4 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [56] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) $10 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [57] (signed word) divr16s::divisor#0 ← (signed word) point_init::x_diff#1 [ point_init::point_idx#0 point_init::y_diff#0 divr16s::divisor#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::y_diff#0 divr16s::divisor#0 ] ) always clobbers reg byte a 
Statement [58] (signed word) divr16s::rem#0 ← (signed word) point_init::y_diff#0 [ point_init::point_idx#0 divr16s::divisor#0 divr16s::rem#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::rem#0 ] ) always clobbers reg byte a 
Statement [60] (signed word) divr16s::return#3 ← (signed word) divr16s::return#2 [ point_init::point_idx#0 divr16s::return#3 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 divr16s::return#3 ] ) always clobbers reg byte a 
Statement [61] (signed word) point_init::x_stepf#0 ← (signed word) divr16s::return#3 [ point_init::point_idx#0 point_init::x_stepf#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_stepf#0 ] ) always clobbers reg byte a 
Statement [62] (byte~) point_init::$14 ← > (signed word) point_init::x_stepf#0 [ point_init::point_idx#0 point_init::$14 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$14 ] ) always clobbers reg byte a 
Statement [63] (byte~) point_init::$16 ← (byte~) point_init::$14 >> (byte) 4 [ point_init::point_idx#0 point_init::$16 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::$16 ] ) always clobbers reg byte a 
Statement [65] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) -$10 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 ] ) always clobbers reg byte a 
Statement [66] (signed word) point_init::abs16s2_return#0 ← - (signed word) point_init::y_diff#0 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#0 ] ) always clobbers reg byte a 
Statement [67] (word~) point_init::abs16s2_return#5 ← (word)(signed word) point_init::abs16s2_return#0 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#5 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#2 point_init::abs16s2_return#5 ] ) always clobbers reg byte a 
Statement [68] (signed word) point_init::abs16s1_return#0 ← - (signed word) point_init::x_diff#1 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#0 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#0 ] ) always clobbers reg byte a 
Statement [69] (word~) point_init::abs16s1_return#5 ← (word)(signed word) point_init::abs16s1_return#0 [ point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#5 ] ( main:2::point_init:20 [ main::i#2 point_init::point_idx#0 point_init::x_diff#1 point_init::y_diff#0 point_init::abs16s1_return#5 ] ) always clobbers reg byte a 
Statement [71] if((signed word) divr16s::rem#0<(signed byte) 0) goto divr16s::@1 [ divr16s::divisor#0 divr16s::rem#0 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::rem#0 ] ) always clobbers reg byte a 
Statement [72] (word~) divr16s::remu#8 ← (word)(signed word) divr16s::rem#0 [ divr16s::divisor#0 divr16s::remu#8 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::remu#8 ] ) always clobbers reg byte a 
Statement [74] if((signed word) divr16s::divisor#0<(signed byte) 0) goto divr16s::@3 [ divr16s::divisor#0 divr16s::neg#3 divr16s::remu#3 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::neg#3 divr16s::remu#3 ] ) always clobbers reg byte a 
Statement [75] (word~) divr16s::divisoru#5 ← (word)(signed word) divr16s::divisor#0 [ divr16s::neg#3 divr16s::remu#3 divr16s::divisoru#5 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#3 divr16s::remu#3 divr16s::divisoru#5 ] ) always clobbers reg byte a 
Statement [77] (word) divr16u::divisor#0 ← (word) divr16s::divisoru#3 [ divr16s::remu#3 divr16s::neg#4 divr16u::divisor#0 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::remu#3 divr16s::neg#4 divr16u::divisor#0 ] ) always clobbers reg byte a 
Statement [78] (word) divr16u::rem#3 ← (word) divr16s::remu#3 [ divr16s::neg#4 divr16u::divisor#0 divr16u::rem#3 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::rem#3 ] ) always clobbers reg byte a 
Statement [80] (word) divr16u::return#2 ← (word) divr16u::return#0 [ divr16s::neg#4 divr16u::return#2 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::return#2 ] ) always clobbers reg byte a 
Statement [81] (word) divr16s::resultu#0 ← (word) divr16u::return#2 [ divr16s::neg#4 divr16s::resultu#0 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16s::resultu#0 ] ) always clobbers reg byte a 
Statement [83] (signed word) divr16s::return#1 ← - (signed word)(word) divr16s::resultu#0 [ divr16s::return#1 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::return#1 ] ) always clobbers reg byte a 
Statement [86] (signed word~) divr16s::return#7 ← (signed word)(word) divr16s::resultu#0 [ divr16s::return#7 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::return#7 ] ) always clobbers reg byte a 
Statement [87] (signed word) divr16s::divisoru#1 ← - (signed word) divr16s::divisor#0 [ divr16s::neg#3 divr16s::remu#3 divr16s::divisoru#1 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::neg#3 divr16s::remu#3 divr16s::divisoru#1 ] ) always clobbers reg byte a 
Statement [88] (byte) divr16s::neg#2 ← (byte) divr16s::neg#3 ^ (byte) 1 [ divr16s::remu#3 divr16s::neg#2 divr16s::divisoru#1 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::remu#3 divr16s::neg#2 divr16s::divisoru#1 ] ) always clobbers reg byte a 
Statement [89] (word~) divr16s::divisoru#4 ← (word)(signed word) divr16s::divisoru#1 [ divr16s::remu#3 divr16s::divisoru#4 divr16s::neg#2 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::remu#3 divr16s::divisoru#4 divr16s::neg#2 ] ) always clobbers reg byte a 
Statement [90] (signed word) divr16s::remu#1 ← - (signed word) divr16s::rem#0 [ divr16s::divisor#0 divr16s::remu#1 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::remu#1 ] ) always clobbers reg byte a 
Statement [91] (word~) divr16s::remu#7 ← (word)(signed word) divr16s::remu#1 [ divr16s::divisor#0 divr16s::remu#7 ] ( main:2::point_init:20::divr16s:59 [ main::i#2 point_init::point_idx#0 divr16s::divisor#0 divr16s::remu#7 ] ) always clobbers reg byte a 
Statement [95] (byte~) divr16u::$1 ← > (word) divr16u::dividend#2 [ divr16u::divisor#0 divr16u::dividend#2 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ( main:2::point_init:20::divr16s:59::divr16u:79 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::dividend#2 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ) always clobbers reg byte a 
Statement [98] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 [ divr16u::divisor#0 divr16u::dividend#2 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ( main:2::point_init:20::divr16s:59::divr16u:79 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::dividend#2 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ) always clobbers reg byte a 
Statement [102] if((word) divr16u::rem#5<(word) divr16u::divisor#0) goto divr16u::@3 [ divr16u::divisor#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#5 divr16u::quotient#1 ] ( main:2::point_init:20::divr16s:59::divr16u:79 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#5 divr16u::quotient#1 ] ) always clobbers reg byte a 
Statement [104] (word) divr16u::rem#2 ← (word) divr16u::rem#5 - (word) divr16u::divisor#0 [ divr16u::divisor#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ( main:2::point_init:20::divr16s:59::divr16u:79 [ main::i#2 point_init::point_idx#0 divr16s::neg#4 divr16u::divisor#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ) always clobbers reg byte a 
Statement [112] *((byte*) screen_fill::screen#2) ← (const byte) screen_fill::ch#0 [ screen_fill::y#4 screen_fill::screen#2 screen_fill::x#2 ] ( main:2::screen_fill:17 [ screen_fill::y#4 screen_fill::screen#2 screen_fill::x#2 ] ) always clobbers reg byte a reg byte y 
Statement [119] (word) bitmap_clear::bitmap#0 ← *((const byte[$100]) bitmap_plot_yhi#0) w= *((const byte[$100]) bitmap_plot_ylo#0) [ bitmap_clear::bitmap#0 ] ( main:2::bitmap_clear:15 [ bitmap_clear::bitmap#0 ] ) always clobbers reg byte a 
Statement [120] (byte*~) bitmap_clear::bitmap#5 ← (byte*)(word) bitmap_clear::bitmap#0 [ bitmap_clear::bitmap#5 ] ( main:2::bitmap_clear:15 [ bitmap_clear::bitmap#5 ] ) always clobbers reg byte a 
Statement [123] *((byte*) bitmap_clear::bitmap#2) ← (byte) 0 [ bitmap_clear::y#4 bitmap_clear::bitmap#2 bitmap_clear::x#2 ] ( main:2::bitmap_clear:15 [ bitmap_clear::y#4 bitmap_clear::bitmap#2 bitmap_clear::x#2 ] ) always clobbers reg byte a reg byte y 
Statement [140] (byte~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (byte) 7 [ bitmap_init::y#2 bitmap_init::yoffs#2 bitmap_init::$7 ] ( main:2::bitmap_init:13 [ bitmap_init::y#2 bitmap_init::yoffs#2 bitmap_init::$7 ] ) always clobbers reg byte a 
Statement [147] (byte*) bitmap_init::yoffs#1 ← (byte*) bitmap_init::yoffs#2 + (word)(number) $28*(number) 8 [ bitmap_init::y#2 bitmap_init::yoffs#1 ] ( main:2::bitmap_init:13 [ bitmap_init::y#2 bitmap_init::yoffs#1 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::i#2 main::i#1 ] : zp ZP_BYTE:2 , reg byte x , 
Potential registers zp ZP_WORD:3 [ point_init::abs16s1_return#2 point_init::abs16s1_return#5 point_init::abs16s1_return#6 ] : zp ZP_WORD:3 , 
Potential registers zp ZP_WORD:5 [ point_init::abs16s2_return#2 point_init::abs16s2_return#5 point_init::abs16s2_return#6 ] : zp ZP_WORD:5 , 
Potential registers zp ZP_WORD:7 [ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 ] : zp ZP_WORD:7 , 
Potential registers zp ZP_WORD:9 [ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 ] : zp ZP_WORD:9 , 
Potential registers zp ZP_BYTE:11 [ divr16s::neg#4 divr16s::neg#2 divr16s::neg#3 ] : zp ZP_BYTE:11 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:12 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 ] : zp ZP_WORD:12 , 
Potential registers zp ZP_WORD:14 [ divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] : zp ZP_WORD:14 , 
Potential registers zp ZP_WORD:16 [ divr16u::dividend#2 divr16u::dividend#0 ] : zp ZP_WORD:16 , 
Potential registers zp ZP_WORD:18 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] : zp ZP_WORD:18 , 
Potential registers zp ZP_BYTE:20 [ divr16u::i#2 divr16u::i#1 ] : zp ZP_BYTE:20 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:21 [ screen_fill::y#4 screen_fill::y#1 ] : zp ZP_BYTE:21 , reg byte x , 
Potential registers zp ZP_WORD:22 [ screen_fill::screen#2 screen_fill::screen#3 screen_fill::screen#1 ] : zp ZP_WORD:22 , 
Potential registers zp ZP_BYTE:24 [ screen_fill::x#2 screen_fill::x#1 ] : zp ZP_BYTE:24 , reg byte x , 
Potential registers zp ZP_BYTE:25 [ bitmap_clear::y#4 bitmap_clear::y#1 ] : zp ZP_BYTE:25 , reg byte x , 
Potential registers zp ZP_WORD:26 [ bitmap_clear::bitmap#2 bitmap_clear::bitmap#3 bitmap_clear::bitmap#5 bitmap_clear::bitmap#1 ] : zp ZP_WORD:26 , 
Potential registers zp ZP_BYTE:28 [ bitmap_clear::x#2 bitmap_clear::x#1 ] : zp ZP_BYTE:28 , reg byte x , 
Potential registers zp ZP_BYTE:29 [ bitmap_init::bits#3 bitmap_init::bits#4 bitmap_init::bits#1 ] : zp ZP_BYTE:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:30 [ bitmap_init::x#2 bitmap_init::x#1 ] : zp ZP_BYTE:30 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:31 [ bitmap_init::y#2 bitmap_init::y#1 ] : zp ZP_BYTE:31 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:32 [ bitmap_init::yoffs#2 bitmap_init::yoffs#4 bitmap_init::yoffs#1 ] : zp ZP_WORD:32 , 
Potential registers zp ZP_BYTE:34 [ point_init::point_idx#0 ] : zp ZP_BYTE:34 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:35 [ main::$13 ] : zp ZP_BYTE:35 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:36 [ bitmap_plot::x#0 ] : zp ZP_WORD:36 , 
Potential registers zp ZP_BYTE:38 [ bitmap_plot::y#0 ] : zp ZP_BYTE:38 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:39 [ bitmap_plot::plotter#0 ] : zp ZP_WORD:39 , 
Potential registers zp ZP_WORD:41 [ bitmap_plot::$1 ] : zp ZP_WORD:41 , 
Potential registers zp ZP_WORD:43 [ bitmap_plot::plotter#1 ] : zp ZP_WORD:43 , 
Potential registers zp ZP_BYTE:45 [ bitmap_plot::$2 ] : zp ZP_BYTE:45 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:46 [ point_init::$18 ] : zp ZP_BYTE:46 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:47 [ point_init::x_diff#1 ] : zp ZP_WORD:47 , 
Potential registers zp ZP_WORD:49 [ point_init::$3 ] : zp ZP_WORD:49 , 
Potential registers zp ZP_WORD:51 [ point_init::$4 ] : zp ZP_WORD:51 , 
Potential registers zp ZP_WORD:53 [ point_init::y_diff#0 ] : zp ZP_WORD:53 , 
Potential registers zp ZP_BYTE:55 [ point_init::$20 ] : zp ZP_BYTE:55 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:56 [ point_init::$9 ] : zp ZP_WORD:56 , 
Potential registers zp ZP_WORD:58 [ point_init::$10 ] : zp ZP_WORD:58 , 
Potential registers zp ZP_WORD:60 [ point_init::$11 ] : zp ZP_WORD:60 , 
Potential registers zp ZP_WORD:62 [ divr16s::divisor#0 ] : zp ZP_WORD:62 , 
Potential registers zp ZP_WORD:64 [ divr16s::rem#0 ] : zp ZP_WORD:64 , 
Potential registers zp ZP_WORD:66 [ divr16s::return#3 ] : zp ZP_WORD:66 , 
Potential registers zp ZP_WORD:68 [ point_init::x_stepf#0 ] : zp ZP_WORD:68 , 
Potential registers zp ZP_BYTE:70 [ point_init::$14 ] : zp ZP_BYTE:70 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:71 [ point_init::$16 ] : zp ZP_BYTE:71 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:72 [ point_init::abs16s2_return#0 ] : zp ZP_WORD:72 , 
Potential registers zp ZP_WORD:74 [ point_init::abs16s1_return#0 ] : zp ZP_WORD:74 , 
Potential registers zp ZP_WORD:76 [ divr16u::divisor#0 ] : zp ZP_WORD:76 , 
Potential registers zp ZP_WORD:78 [ divr16u::return#2 ] : zp ZP_WORD:78 , 
Potential registers zp ZP_WORD:80 [ divr16s::resultu#0 ] : zp ZP_WORD:80 , 
Potential registers zp ZP_WORD:82 [ divr16s::divisoru#1 ] : zp ZP_WORD:82 , 
Potential registers zp ZP_WORD:84 [ divr16s::remu#1 ] : zp ZP_WORD:84 , 
Potential registers zp ZP_BYTE:86 [ divr16u::$1 ] : zp ZP_BYTE:86 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:87 [ divr16u::$2 ] : zp ZP_BYTE:87 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:88 [ bitmap_clear::bitmap#0 ] : zp ZP_WORD:88 , 
Potential registers zp ZP_BYTE:90 [ bitmap_init::$7 ] : zp ZP_BYTE:90 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:91 [ bitmap_init::$4 ] : zp ZP_BYTE:91 , reg byte a , reg byte x , reg byte y , reg byte alu , 
Potential registers zp ZP_BYTE:92 [ bitmap_init::$5 ] : zp ZP_BYTE:92 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:93 [ bitmap_init::$6 ] : zp ZP_BYTE:93 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [divr16u] 887.75: zp ZP_WORD:14 [ divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] 338.75: zp ZP_WORD:18 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] 202: zp ZP_BYTE:86 [ divr16u::$1 ] 202: zp ZP_BYTE:87 [ divr16u::$2 ] 167.04: zp ZP_BYTE:20 [ divr16u::i#2 divr16u::i#1 ] 68.54: zp ZP_WORD:16 [ divr16u::dividend#2 divr16u::dividend#0 ] 11.33: zp ZP_WORD:76 [ divr16u::divisor#0 ] 4: zp ZP_WORD:78 [ divr16u::return#2 ] 
Uplift Scope [bitmap_clear] 227.6: zp ZP_WORD:26 [ bitmap_clear::bitmap#2 bitmap_clear::bitmap#3 bitmap_clear::bitmap#5 bitmap_clear::bitmap#1 ] 218.83: zp ZP_BYTE:28 [ bitmap_clear::x#2 bitmap_clear::x#1 ] 20.17: zp ZP_BYTE:25 [ bitmap_clear::y#4 bitmap_clear::y#1 ] 2: zp ZP_WORD:88 [ bitmap_clear::bitmap#0 ] 
Uplift Scope [screen_fill] 221.6: zp ZP_WORD:22 [ screen_fill::screen#2 screen_fill::screen#3 screen_fill::screen#1 ] 218.83: zp ZP_BYTE:24 [ screen_fill::x#2 screen_fill::x#1 ] 20.17: zp ZP_BYTE:21 [ screen_fill::y#4 screen_fill::y#1 ] 
Uplift Scope [bitmap_init] 39.88: zp ZP_WORD:32 [ bitmap_init::yoffs#2 bitmap_init::yoffs#4 bitmap_init::yoffs#1 ] 34.83: zp ZP_BYTE:29 [ bitmap_init::bits#3 bitmap_init::bits#4 bitmap_init::bits#1 ] 22: zp ZP_BYTE:30 [ bitmap_init::x#2 bitmap_init::x#1 ] 22: zp ZP_BYTE:31 [ bitmap_init::y#2 bitmap_init::y#1 ] 22: zp ZP_BYTE:91 [ bitmap_init::$4 ] 22: zp ZP_BYTE:92 [ bitmap_init::$5 ] 22: zp ZP_BYTE:93 [ bitmap_init::$6 ] 5.5: zp ZP_BYTE:90 [ bitmap_init::$7 ] 
Uplift Scope [point_init] 14: zp ZP_WORD:5 [ point_init::abs16s2_return#2 point_init::abs16s2_return#5 point_init::abs16s2_return#6 ] 9: zp ZP_WORD:3 [ point_init::abs16s1_return#2 point_init::abs16s1_return#5 point_init::abs16s1_return#6 ] 4: zp ZP_WORD:51 [ point_init::$4 ] 4: zp ZP_WORD:56 [ point_init::$9 ] 4: zp ZP_WORD:58 [ point_init::$10 ] 4: zp ZP_WORD:60 [ point_init::$11 ] 4: zp ZP_WORD:68 [ point_init::x_stepf#0 ] 4: zp ZP_BYTE:70 [ point_init::$14 ] 2: zp ZP_BYTE:46 [ point_init::$18 ] 2: zp ZP_WORD:49 [ point_init::$3 ] 2: zp ZP_BYTE:71 [ point_init::$16 ] 2: zp ZP_WORD:72 [ point_init::abs16s2_return#0 ] 2: zp ZP_WORD:74 [ point_init::abs16s1_return#0 ] 1.6: zp ZP_BYTE:55 [ point_init::$20 ] 0.68: zp ZP_BYTE:34 [ point_init::point_idx#0 ] 0.56: zp ZP_WORD:47 [ point_init::x_diff#1 ] 0.5: zp ZP_WORD:53 [ point_init::y_diff#0 ] 
Uplift Scope [divr16s] 14: zp ZP_WORD:9 [ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 ] 10: zp ZP_WORD:12 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 ] 8.75: zp ZP_WORD:7 [ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 ] 4: zp ZP_BYTE:11 [ divr16s::neg#4 divr16s::neg#2 divr16s::neg#3 ] 4: zp ZP_WORD:66 [ divr16s::return#3 ] 2: zp ZP_WORD:64 [ divr16s::rem#0 ] 2: zp ZP_WORD:84 [ divr16s::remu#1 ] 1: zp ZP_WORD:80 [ divr16s::resultu#0 ] 1: zp ZP_WORD:82 [ divr16s::divisoru#1 ] 0.67: zp ZP_WORD:62 [ divr16s::divisor#0 ] 
Uplift Scope [main] 24.36: zp ZP_BYTE:2 [ main::i#2 main::i#1 ] 22: zp ZP_BYTE:35 [ main::$13 ] 
Uplift Scope [bitmap_plot] 15: zp ZP_BYTE:38 [ bitmap_plot::y#0 ] 4: zp ZP_WORD:41 [ bitmap_plot::$1 ] 4: zp ZP_BYTE:45 [ bitmap_plot::$2 ] 3: zp ZP_WORD:36 [ bitmap_plot::x#0 ] 3: zp ZP_WORD:43 [ bitmap_plot::plotter#1 ] 1: zp ZP_WORD:39 [ bitmap_plot::plotter#0 ] 
Uplift Scope [] 

Uplifting [divr16u] best 30437 combination zp ZP_WORD:14 [ divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] zp ZP_WORD:18 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] reg byte a [ divr16u::$1 ] reg byte a [ divr16u::$2 ] reg byte x [ divr16u::i#2 divr16u::i#1 ] zp ZP_WORD:16 [ divr16u::dividend#2 divr16u::dividend#0 ] zp ZP_WORD:76 [ divr16u::divisor#0 ] zp ZP_WORD:78 [ divr16u::return#2 ] 
Uplifting [bitmap_clear] best 29537 combination zp ZP_WORD:26 [ bitmap_clear::bitmap#2 bitmap_clear::bitmap#3 bitmap_clear::bitmap#5 bitmap_clear::bitmap#1 ] reg byte x [ bitmap_clear::x#2 bitmap_clear::x#1 ] zp ZP_BYTE:25 [ bitmap_clear::y#4 bitmap_clear::y#1 ] zp ZP_WORD:88 [ bitmap_clear::bitmap#0 ] 
Uplifting [screen_fill] best 28637 combination zp ZP_WORD:22 [ screen_fill::screen#2 screen_fill::screen#3 screen_fill::screen#1 ] reg byte x [ screen_fill::x#2 screen_fill::x#1 ] zp ZP_BYTE:21 [ screen_fill::y#4 screen_fill::y#1 ] 
Uplifting [bitmap_init] best 28127 combination zp ZP_WORD:32 [ bitmap_init::yoffs#2 bitmap_init::yoffs#4 bitmap_init::yoffs#1 ] reg byte a [ bitmap_init::bits#3 bitmap_init::bits#4 bitmap_init::bits#1 ] reg byte x [ bitmap_init::x#2 bitmap_init::x#1 ] reg byte x [ bitmap_init::y#2 bitmap_init::y#1 ] reg byte a [ bitmap_init::$4 ] zp ZP_BYTE:92 [ bitmap_init::$5 ] zp ZP_BYTE:93 [ bitmap_init::$6 ] zp ZP_BYTE:90 [ bitmap_init::$7 ] 
Limited combination testing to 100 combinations of 15360 possible.
Uplifting [point_init] best 28101 combination zp ZP_WORD:5 [ point_init::abs16s2_return#2 point_init::abs16s2_return#5 point_init::abs16s2_return#6 ] zp ZP_WORD:3 [ point_init::abs16s1_return#2 point_init::abs16s1_return#5 point_init::abs16s1_return#6 ] zp ZP_WORD:51 [ point_init::$4 ] zp ZP_WORD:56 [ point_init::$9 ] zp ZP_WORD:58 [ point_init::$10 ] zp ZP_WORD:60 [ point_init::$11 ] zp ZP_WORD:68 [ point_init::x_stepf#0 ] reg byte a [ point_init::$14 ] reg byte a [ point_init::$18 ] zp ZP_WORD:49 [ point_init::$3 ] reg byte a [ point_init::$16 ] zp ZP_WORD:72 [ point_init::abs16s2_return#0 ] zp ZP_WORD:74 [ point_init::abs16s1_return#0 ] reg byte x [ point_init::$20 ] zp ZP_BYTE:34 [ point_init::point_idx#0 ] zp ZP_WORD:47 [ point_init::x_diff#1 ] zp ZP_WORD:53 [ point_init::y_diff#0 ] 
Limited combination testing to 100 combinations of 576 possible.
Uplifting [divr16s] best 28090 combination zp ZP_WORD:9 [ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 ] zp ZP_WORD:12 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 ] zp ZP_WORD:7 [ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 ] reg byte y [ divr16s::neg#4 divr16s::neg#2 divr16s::neg#3 ] zp ZP_WORD:66 [ divr16s::return#3 ] zp ZP_WORD:64 [ divr16s::rem#0 ] zp ZP_WORD:84 [ divr16s::remu#1 ] zp ZP_WORD:80 [ divr16s::resultu#0 ] zp ZP_WORD:82 [ divr16s::divisoru#1 ] zp ZP_WORD:62 [ divr16s::divisor#0 ] 
Uplifting [main] best 28050 combination zp ZP_BYTE:2 [ main::i#2 main::i#1 ] reg byte a [ main::$13 ] 
Uplifting [bitmap_plot] best 28013 combination reg byte x [ bitmap_plot::y#0 ] zp ZP_WORD:41 [ bitmap_plot::$1 ] reg byte a [ bitmap_plot::$2 ] zp ZP_WORD:36 [ bitmap_plot::x#0 ] zp ZP_WORD:43 [ bitmap_plot::plotter#1 ] zp ZP_WORD:39 [ bitmap_plot::plotter#0 ] 
Uplifting [] best 28013 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ main::i#2 main::i#1 ]
Uplifting [main] best 28013 combination zp ZP_BYTE:2 [ main::i#2 main::i#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:92 [ bitmap_init::$5 ]
Uplifting [bitmap_init] best 27953 combination reg byte a [ bitmap_init::$5 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:93 [ bitmap_init::$6 ]
Uplifting [bitmap_init] best 27893 combination reg byte a [ bitmap_init::$6 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:21 [ screen_fill::y#4 screen_fill::y#1 ]
Uplifting [screen_fill] best 27893 combination zp ZP_BYTE:21 [ screen_fill::y#4 screen_fill::y#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:25 [ bitmap_clear::y#4 bitmap_clear::y#1 ]
Uplifting [bitmap_clear] best 27893 combination zp ZP_BYTE:25 [ bitmap_clear::y#4 bitmap_clear::y#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:90 [ bitmap_init::$7 ]
Uplifting [bitmap_init] best 27893 combination zp ZP_BYTE:90 [ bitmap_init::$7 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:34 [ point_init::point_idx#0 ]
Uplifting [point_init] best 27893 combination zp ZP_BYTE:34 [ point_init::point_idx#0 ] 
Coalescing zero page register with common assignment [ zp ZP_WORD:12 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 ] ] with [ zp ZP_WORD:80 [ divr16s::resultu#0 ] ] - score: 2
Coalescing zero page register with common assignment [ zp ZP_BYTE:2 [ main::i#2 main::i#1 ] ] with [ zp ZP_BYTE:34 [ point_init::point_idx#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:3 [ point_init::abs16s1_return#2 point_init::abs16s1_return#5 point_init::abs16s1_return#6 ] ] with [ zp ZP_WORD:74 [ point_init::abs16s1_return#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:5 [ point_init::abs16s2_return#2 point_init::abs16s2_return#5 point_init::abs16s2_return#6 ] ] with [ zp ZP_WORD:72 [ point_init::abs16s2_return#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:7 [ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 ] ] with [ zp ZP_WORD:14 [ divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:7 [ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] ] with [ zp ZP_WORD:64 [ divr16s::rem#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:7 [ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 divr16s::rem#0 ] ] with [ zp ZP_WORD:84 [ divr16s::remu#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:9 [ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 ] ] with [ zp ZP_WORD:62 [ divr16s::divisor#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:9 [ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 divr16s::divisor#0 ] ] with [ zp ZP_WORD:76 [ divr16u::divisor#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:9 [ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 divr16s::divisor#0 divr16u::divisor#0 ] ] with [ zp ZP_WORD:82 [ divr16s::divisoru#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:12 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 divr16s::resultu#0 ] ] with [ zp ZP_WORD:66 [ divr16s::return#3 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:18 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] ] with [ zp ZP_WORD:78 [ divr16u::return#2 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:26 [ bitmap_clear::bitmap#2 bitmap_clear::bitmap#3 bitmap_clear::bitmap#5 bitmap_clear::bitmap#1 ] ] with [ zp ZP_WORD:88 [ bitmap_clear::bitmap#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:39 [ bitmap_plot::plotter#0 ] ] with [ zp ZP_WORD:43 [ bitmap_plot::plotter#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:49 [ point_init::$3 ] ] with [ zp ZP_WORD:53 [ point_init::y_diff#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:58 [ point_init::$10 ] ] with [ zp ZP_WORD:60 [ point_init::$11 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:7 [ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 divr16s::rem#0 divr16s::remu#1 ] ] with [ zp ZP_WORD:49 [ point_init::$3 point_init::y_diff#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:9 [ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 divr16s::divisor#0 divr16u::divisor#0 divr16s::divisoru#1 ] ] with [ zp ZP_WORD:47 [ point_init::x_diff#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:12 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 divr16s::resultu#0 divr16s::return#3 ] ] with [ zp ZP_WORD:18 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:12 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 divr16s::resultu#0 divr16s::return#3 divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 ] ] with [ zp ZP_WORD:68 [ point_init::x_stepf#0 ] ] - score: 1
Allocated (was zp ZP_WORD:12) zp ZP_WORD:11 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 divr16s::resultu#0 divr16s::return#3 divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 point_init::x_stepf#0 ]
Allocated (was zp ZP_WORD:16) zp ZP_WORD:13 [ divr16u::dividend#2 divr16u::dividend#0 ]
Allocated (was zp ZP_BYTE:21) zp ZP_BYTE:15 [ screen_fill::y#4 screen_fill::y#1 ]
Allocated (was zp ZP_WORD:22) zp ZP_WORD:16 [ screen_fill::screen#2 screen_fill::screen#3 screen_fill::screen#1 ]
Allocated (was zp ZP_BYTE:25) zp ZP_BYTE:18 [ bitmap_clear::y#4 bitmap_clear::y#1 ]
Allocated (was zp ZP_WORD:26) zp ZP_WORD:19 [ bitmap_clear::bitmap#2 bitmap_clear::bitmap#3 bitmap_clear::bitmap#5 bitmap_clear::bitmap#1 bitmap_clear::bitmap#0 ]
Allocated (was zp ZP_WORD:32) zp ZP_WORD:21 [ bitmap_init::yoffs#2 bitmap_init::yoffs#4 bitmap_init::yoffs#1 ]
Allocated (was zp ZP_WORD:36) zp ZP_WORD:23 [ bitmap_plot::x#0 ]
Allocated (was zp ZP_WORD:39) zp ZP_WORD:25 [ bitmap_plot::plotter#0 bitmap_plot::plotter#1 ]
Allocated (was zp ZP_WORD:41) zp ZP_WORD:27 [ bitmap_plot::$1 ]
Allocated (was zp ZP_WORD:51) zp ZP_WORD:29 [ point_init::$4 ]
Allocated (was zp ZP_WORD:56) zp ZP_WORD:31 [ point_init::$9 ]
Allocated (was zp ZP_WORD:58) zp ZP_WORD:33 [ point_init::$10 point_init::$11 ]
Allocated (was zp ZP_BYTE:90) zp ZP_BYTE:35 [ bitmap_init::$7 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Animated lines drawn on a single color bitmap
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // RAM in $A000, $E000 I/O in $D000
  .const PROCPORT_RAM_IO = $35
  .label RASTER = $d012
  .label BORDERCOL = $d020
  .label D011 = $d011
  .const VIC_BMM = $20
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  .label D018 = $d018
  // CIA#2 Port A: Serial bus, RS-232, VIC memory bank
  .label CIA2_PORT_A = $dd00
  // CIA #2 Port A data direction register.
  .label CIA2_PORT_A_DDR = $dd02
  .label BITMAP = $a000
  .label SCREEN = $8800
  // The number of points
  .const SIZE = 4
  // The delay between pixels
  .const DELAY = 8
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .const vicSelectGfxBank1_toDd001_return = 3^(>SCREEN)/$40
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>BITMAP)/4&$f
    .label i = 2
    // asm { sei  }
    // Disable normal interrupt
    sei
    // [5] *((const byte*) PROCPORT_DDR#0) ← (const byte) PROCPORT_DDR_MEMORY_MASK#0 -- _deref_pbuc1=vbuc2 
    // Disable kernal & basic
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // [6] *((const byte*) PROCPORT#0) ← (const byte) PROCPORT_RAM_IO#0 -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // [7] *((const byte*) D011#0) ← (const byte) VIC_BMM#0|(const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_BMM|VIC_DEN|VIC_RSEL|3
    sta D011
    jmp vicSelectGfxBank1
    // main::vicSelectGfxBank1
  vicSelectGfxBank1:
    // [8] *((const byte*) CIA2_PORT_A_DDR#0) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta CIA2_PORT_A_DDR
    // [9] phi from main::vicSelectGfxBank1 to main::vicSelectGfxBank1_toDd001 [phi:main::vicSelectGfxBank1->main::vicSelectGfxBank1_toDd001]
  vicSelectGfxBank1_toDd001_from_vicSelectGfxBank1:
    jmp vicSelectGfxBank1_toDd001
    // main::vicSelectGfxBank1_toDd001
  vicSelectGfxBank1_toDd001:
    jmp vicSelectGfxBank1_b1
    // main::vicSelectGfxBank1_@1
  vicSelectGfxBank1_b1:
    // [10] *((const byte*) CIA2_PORT_A#0) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 -- _deref_pbuc1=vbuc2 
    lda #vicSelectGfxBank1_toDd001_return
    sta CIA2_PORT_A
    // [11] phi from main::vicSelectGfxBank1_@1 to main::toD0181 [phi:main::vicSelectGfxBank1_@1->main::toD0181]
  toD0181_from_vicSelectGfxBank1_b1:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp b4
    // main::@4
  b4:
    // [12] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // [13] call bitmap_init 
    // [130] phi from main::@4 to bitmap_init [phi:main::@4->bitmap_init]
  bitmap_init_from_b4:
    jsr bitmap_init
    // [14] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  b5_from_b4:
    jmp b5
    // main::@5
  b5:
    // [15] call bitmap_clear 
    jsr bitmap_clear
    // [16] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  b6_from_b5:
    jmp b6
    // main::@6
  b6:
    // [17] call screen_fill 
    // [109] phi from main::@6 to screen_fill [phi:main::@6->screen_fill]
  screen_fill_from_b6:
    jsr screen_fill
    // [18] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
  b1_from_b6:
    // [18] phi (byte) main::i#2 = (byte) 0 [phi:main::@6->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b1
    // [18] phi from main::@8 to main::@1 [phi:main::@8->main::@1]
  b1_from_b8:
    // [18] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@8->main::@1#0] -- register_copy 
    jmp b1
    // main::@1
  b1:
    // [19] (byte) point_init::point_idx#0 ← (byte) main::i#2
    // [20] call point_init 
    jsr point_init
    jmp b7
    // main::@7
  b7:
    // [21] (byte~) main::$13 ← (byte) main::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda i
    asl
    // [22] (word) bitmap_plot::x#0 ← *((const word[SIZE#0]) x_start#0 + (byte~) main::$13) -- vwuz1=pwuc1_derefidx_vbuaa 
    tay
    lda x_start,y
    sta bitmap_plot.x
    lda x_start+1,y
    sta bitmap_plot.x+1
    // [23] (byte) bitmap_plot::y#0 ← *((const byte[SIZE#0]) y_start#0 + (byte) main::i#2) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy i
    ldx y_start,y
    // [24] call bitmap_plot 
    jsr bitmap_plot
    jmp b8
    // main::@8
  b8:
    // [25] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
    // [26] if((byte) main::i#1!=(const byte) SIZE#0-(byte) 1+(byte) 1) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #SIZE-1+1
    cmp i
    bne b1_from_b8
    jmp b2
    // main::@2
  b2:
    // [27] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    jmp b3
    // main::@3
  b3:
    // [28] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    jmp b2
}
  // bitmap_plot
// Plot a single dot in the bitmap
// bitmap_plot(word zeropage($17) x, byte register(X) y)
bitmap_plot: {
    .label _1 = $1b
    .label x = $17
    .label plotter = $19
    // [29] (word) bitmap_plot::plotter#0 ← *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_plot::y#0) w= *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_plot::y#0) -- vwuz1=pbuc1_derefidx_vbuxx_word_pbuc2_derefidx_vbuxx 
    lda bitmap_plot_yhi,x
    sta plotter+1
    lda bitmap_plot_ylo,x
    sta plotter
    // [30] (word~) bitmap_plot::$1 ← (word) bitmap_plot::x#0 & (word) $fff8 -- vwuz1=vwuz2_band_vwuc1 
    lda x
    and #<$fff8
    sta _1
    lda x+1
    and #>$fff8
    sta _1+1
    // [31] (byte*) bitmap_plot::plotter#1 ← (byte*)(word) bitmap_plot::plotter#0 + (word~) bitmap_plot::$1 -- pbuz1=pbuz1_plus_vwuz2 
    lda plotter
    clc
    adc _1
    sta plotter
    lda plotter+1
    adc _1+1
    sta plotter+1
    // [32] (byte~) bitmap_plot::$2 ← < (word) bitmap_plot::x#0 -- vbuaa=_lo_vwuz1 
    lda x
    // [33] *((byte*) bitmap_plot::plotter#1) ← *((byte*) bitmap_plot::plotter#1) | *((const byte[$100]) bitmap_plot_bit#0 + (byte~) bitmap_plot::$2) -- _deref_pbuz1=_deref_pbuz1_bor_pbuc1_derefidx_vbuaa 
    tay
    lda bitmap_plot_bit,y
    ldy #0
    ora (plotter),y
    ldy #0
    sta (plotter),y
    jmp breturn
    // bitmap_plot::@return
  breturn:
    // [34] return 
    rts
}
  // point_init
// Initialize the points to be animated
// point_init(byte zeropage(2) point_idx)
point_init: {
    .label _3 = 7
    .label _4 = $1d
    .label _9 = $1f
    .label _10 = $21
    .label _11 = $21
    .label point_idx = 2
    .label y_diff = 7
    .label abs16s1_return = 3
    .label abs16s2_return = 5
    .label x_stepf = $b
    .label x_diff = 9
    // [35] (byte~) point_init::$18 ← (byte) point_init::point_idx#0 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda point_idx
    asl
    // [36] (signed word) point_init::x_diff#1 ← (signed word)*((const word[SIZE#0]) x_end#0 + (byte~) point_init::$18) - (signed word)*((const word[SIZE#0]) x_start#0 + (byte~) point_init::$18) -- vwsz1=pwsc1_derefidx_vbuaa_minus_pwsc2_derefidx_vbuaa 
    tay
    sec
    lda x_end,y
    sbc x_start,y
    sta x_diff
    lda x_end+1,y
    sbc x_start+1,y
    sta x_diff+1
    // [37] (signed word~) point_init::$3 ← (signed word)*((const byte[SIZE#0]) y_end#0 + (byte) point_init::point_idx#0) -- vwsz1=_sword_pbuc1_derefidx_vbuz2 
    ldy point_idx
    lda y_end,y
    sta _3
    lda #0
    sta _3+1
    // [38] (signed word~) point_init::$4 ← (signed word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) -- vwsz1=_sword_pbuc1_derefidx_vbuz2 
    ldy point_idx
    lda y_start,y
    sta _4
    lda #0
    sta _4+1
    // [39] (signed word) point_init::y_diff#0 ← (signed word~) point_init::$3 - (signed word~) point_init::$4 -- vwsz1=vwsz1_minus_vwsz2 
    lda y_diff
    sec
    sbc _4
    sta y_diff
    lda y_diff+1
    sbc _4+1
    sta y_diff+1
    jmp abs16s1
    // point_init::abs16s1
  abs16s1:
    // [40] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::abs16s1_@1 -- vwsz1_lt_0_then_la1 
    lda x_diff+1
    bmi abs16s1_b1
    jmp abs16s1_b3
    // point_init::abs16s1_@3
  abs16s1_b3:
    // [41] (word~) point_init::abs16s1_return#6 ← (word)(signed word) point_init::x_diff#1 -- vwuz1=vwuz2 
    lda x_diff
    sta abs16s1_return
    lda x_diff+1
    sta abs16s1_return+1
    // [42] phi from point_init::abs16s1_@1 point_init::abs16s1_@3 to point_init::abs16s1_@return [phi:point_init::abs16s1_@1/point_init::abs16s1_@3->point_init::abs16s1_@return]
  abs16s1_breturn_from_abs16s1_b1:
  abs16s1_breturn_from_abs16s1_b3:
    // [42] phi (word) point_init::abs16s1_return#2 = (word~) point_init::abs16s1_return#5 [phi:point_init::abs16s1_@1/point_init::abs16s1_@3->point_init::abs16s1_@return#0] -- register_copy 
    jmp abs16s1_breturn
    // point_init::abs16s1_@return
  abs16s1_breturn:
    jmp abs16s2
    // point_init::abs16s2
  abs16s2:
    // [43] if((signed word) point_init::y_diff#0<(signed byte) 0) goto point_init::abs16s2_@1 -- vwsz1_lt_0_then_la1 
    lda y_diff+1
    bmi abs16s2_b1
    jmp abs16s2_b3
    // point_init::abs16s2_@3
  abs16s2_b3:
    // [44] (word~) point_init::abs16s2_return#6 ← (word)(signed word) point_init::y_diff#0 -- vwuz1=vwuz2 
    lda y_diff
    sta abs16s2_return
    lda y_diff+1
    sta abs16s2_return+1
    // [45] phi from point_init::abs16s2_@1 point_init::abs16s2_@3 to point_init::abs16s2_@return [phi:point_init::abs16s2_@1/point_init::abs16s2_@3->point_init::abs16s2_@return]
  abs16s2_breturn_from_abs16s2_b1:
  abs16s2_breturn_from_abs16s2_b3:
    // [45] phi (word) point_init::abs16s2_return#2 = (word~) point_init::abs16s2_return#5 [phi:point_init::abs16s2_@1/point_init::abs16s2_@3->point_init::abs16s2_@return#0] -- register_copy 
    jmp abs16s2_breturn
    // point_init::abs16s2_@return
  abs16s2_breturn:
    jmp b6
    // point_init::@6
  b6:
    // [46] if((word) point_init::abs16s1_return#2>(word) point_init::abs16s2_return#2) goto point_init::@1 -- vwuz1_gt_vwuz2_then_la1 
    lda abs16s2_return+1
    cmp abs16s1_return+1
    bcc b1
    bne !+
    lda abs16s2_return
    cmp abs16s1_return
    bcc b1
  !:
    jmp b2
    // point_init::@2
  b2:
    // [47] (byte~) point_init::$20 ← (byte) point_init::point_idx#0 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda point_idx
    asl
    tax
    // [48] (word~) point_init::$9 ← *((const word[SIZE#0]) x_start#0 + (byte~) point_init::$20) << (byte) 4 -- vwuz1=pwuc1_derefidx_vbuxx_rol_4 
    lda x_start,x
    sta _9
    lda x_start+1,x
    sta _9+1
    asl _9
    rol _9+1
    asl _9
    rol _9+1
    asl _9
    rol _9+1
    asl _9
    rol _9+1
    // [49] *((const word[SIZE#0]) x_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$9 -- pwuc1_derefidx_vbuxx=vwuz1 
    lda _9
    sta x_cur,x
    lda _9+1
    sta x_cur+1,x
    // [50] (word~) point_init::$10 ← (word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) -- vwuz1=_word_pbuc1_derefidx_vbuz2 
    ldy point_idx
    lda y_start,y
    sta _10
    lda #0
    sta _10+1
    // [51] (word~) point_init::$11 ← (word~) point_init::$10 << (byte) 4 -- vwuz1=vwuz1_rol_4 
    asl _11
    rol _11+1
    asl _11
    rol _11+1
    asl _11
    rol _11+1
    asl _11
    rol _11+1
    // [52] *((const word[SIZE#0]) y_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$11 -- pwuc1_derefidx_vbuxx=vwuz1 
    lda _11
    sta y_cur,x
    lda _11+1
    sta y_cur+1,x
    // [53] *((const byte[SIZE#0]) delay#0 + (byte) point_init::point_idx#0) ← (const byte) DELAY#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #DELAY
    ldy point_idx
    sta delay,y
    jmp breturn
    // point_init::@return
  breturn:
    // [54] return 
    rts
    // point_init::@1
  b1:
    // [55] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::@4 -- vwsz1_lt_0_then_la1 
    // X is driver - abs(y/x) is < 1
    lda x_diff+1
    bmi b4
    jmp b3
    // point_init::@3
  b3:
    // [56] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) $10 -- pbsc1_derefidx_vbuz1=vbsc2 
    // x add = 1.0
    lda #$10
    ldy point_idx
    sta x_add,y
    jmp b5
    // point_init::@5
  b5:
    // [57] (signed word) divr16s::divisor#0 ← (signed word) point_init::x_diff#1
    // [58] (signed word) divr16s::rem#0 ← (signed word) point_init::y_diff#0
    // [59] call divr16s 
    // [70] phi from point_init::@5 to divr16s [phi:point_init::@5->divr16s]
  divr16s_from_b5:
    jsr divr16s
    // [60] (signed word) divr16s::return#3 ← (signed word) divr16s::return#2
    jmp b7
    // point_init::@7
  b7:
    // [61] (signed word) point_init::x_stepf#0 ← (signed word) divr16s::return#3
    // [62] (byte~) point_init::$14 ← > (signed word) point_init::x_stepf#0 -- vbuaa=_hi_vwsz1 
    lda x_stepf+1
    // [63] (byte~) point_init::$16 ← (byte~) point_init::$14 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [64] *((const signed byte[SIZE#0]) y_add#0 + (byte) point_init::point_idx#0) ← (signed byte)(byte~) point_init::$16 -- pbsc1_derefidx_vbuz1=vbsaa 
    ldy point_idx
    sta y_add,y
    jmp b2
    // point_init::@4
  b4:
    // [65] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) -$10 -- pbsc1_derefidx_vbuz1=vbsc2 
    // x add = -1.0
    lda #-$10
    ldy point_idx
    sta x_add,y
    jmp b5
    // point_init::abs16s2_@1
  abs16s2_b1:
    // [66] (signed word) point_init::abs16s2_return#0 ← - (signed word) point_init::y_diff#0 -- vwsz1=_neg_vwsz2 
    sec
    lda #0
    sbc y_diff
    sta abs16s2_return
    lda #0
    sbc y_diff+1
    sta abs16s2_return+1
    // [67] (word~) point_init::abs16s2_return#5 ← (word)(signed word) point_init::abs16s2_return#0
    jmp abs16s2_breturn_from_abs16s2_b1
    // point_init::abs16s1_@1
  abs16s1_b1:
    // [68] (signed word) point_init::abs16s1_return#0 ← - (signed word) point_init::x_diff#1 -- vwsz1=_neg_vwsz2 
    sec
    lda #0
    sbc x_diff
    sta abs16s1_return
    lda #0
    sbc x_diff+1
    sta abs16s1_return+1
    // [69] (word~) point_init::abs16s1_return#5 ← (word)(signed word) point_init::abs16s1_return#0
    jmp abs16s1_breturn_from_abs16s1_b1
}
  // divr16s
// Perform division on two signed 16-bit numbers with an initial remainder.
// Returns dividend/divisor. The remainder will be set into the global variable rem16s.
// Implemented using simple binary division
// Follows the C99 standard by truncating toward zero on negative results.
// See http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf section 6.5.5
// divr16s(signed word zeropage(9) divisor, signed word zeropage(7) rem)
divr16s: {
    .label remu = 7
    .label divisoru = 9
    .label resultu = $b
    .label return = $b
    .label divisor = 9
    .label rem = 7
    jmp b10
    // divr16s::@10
  b10:
    // [71] if((signed word) divr16s::rem#0<(signed byte) 0) goto divr16s::@1 -- vwsz1_lt_0_then_la1 
    lda rem+1
    bmi b1
    jmp b6
    // divr16s::@6
  b6:
    // [72] (word~) divr16s::remu#8 ← (word)(signed word) divr16s::rem#0
    // [73] phi from divr16s::@6 to divr16s::@2 [phi:divr16s::@6->divr16s::@2]
  b2_from_b6:
    // [73] phi (word) divr16s::remu#3 = (word~) divr16s::remu#8 [phi:divr16s::@6->divr16s::@2#0] -- register_copy 
    // [73] phi (byte) divr16s::neg#3 = (byte) 0 [phi:divr16s::@6->divr16s::@2#1] -- vbuyy=vbuc1 
    ldy #0
    jmp b2
    // divr16s::@2
  b2:
    // [74] if((signed word) divr16s::divisor#0<(signed byte) 0) goto divr16s::@3 -- vwsz1_lt_0_then_la1 
    lda divisor+1
    bmi b3
    jmp b7
    // divr16s::@7
  b7:
    // [75] (word~) divr16s::divisoru#5 ← (word)(signed word) divr16s::divisor#0
    // [76] phi from divr16s::@3 divr16s::@7 to divr16s::@4 [phi:divr16s::@3/divr16s::@7->divr16s::@4]
  b4_from_b3:
  b4_from_b7:
    // [76] phi (byte) divr16s::neg#4 = (byte) divr16s::neg#2 [phi:divr16s::@3/divr16s::@7->divr16s::@4#0] -- register_copy 
    // [76] phi (word) divr16s::divisoru#3 = (word~) divr16s::divisoru#4 [phi:divr16s::@3/divr16s::@7->divr16s::@4#1] -- register_copy 
    jmp b4
    // divr16s::@4
  b4:
    // [77] (word) divr16u::divisor#0 ← (word) divr16s::divisoru#3
    // [78] (word) divr16u::rem#3 ← (word) divr16s::remu#3
    // [79] call divr16u 
    // [92] phi from divr16s::@4 to divr16u [phi:divr16s::@4->divr16u]
  divr16u_from_b4:
    jsr divr16u
    // [80] (word) divr16u::return#2 ← (word) divr16u::return#0
    jmp b9
    // divr16s::@9
  b9:
    // [81] (word) divr16s::resultu#0 ← (word) divr16u::return#2
    // [82] if((byte) divr16s::neg#4==(byte) 0) goto divr16s::@5 -- vbuyy_eq_0_then_la1 
    cpy #0
    beq b5
    jmp b8
    // divr16s::@8
  b8:
    // [83] (signed word) divr16s::return#1 ← - (signed word)(word) divr16s::resultu#0 -- vwsz1=_neg_vwsz1 
    sec
    lda #0
    sbc return
    sta return
    lda #0
    sbc return+1
    sta return+1
    // [84] phi from divr16s::@5 divr16s::@8 to divr16s::@return [phi:divr16s::@5/divr16s::@8->divr16s::@return]
  breturn_from_b5:
  breturn_from_b8:
    // [84] phi (signed word) divr16s::return#2 = (signed word~) divr16s::return#7 [phi:divr16s::@5/divr16s::@8->divr16s::@return#0] -- register_copy 
    jmp breturn
    // divr16s::@return
  breturn:
    // [85] return 
    rts
    // divr16s::@5
  b5:
    // [86] (signed word~) divr16s::return#7 ← (signed word)(word) divr16s::resultu#0
    jmp breturn_from_b5
    // divr16s::@3
  b3:
    // [87] (signed word) divr16s::divisoru#1 ← - (signed word) divr16s::divisor#0 -- vwsz1=_neg_vwsz1 
    sec
    lda #0
    sbc divisoru
    sta divisoru
    lda #0
    sbc divisoru+1
    sta divisoru+1
    // [88] (byte) divr16s::neg#2 ← (byte) divr16s::neg#3 ^ (byte) 1 -- vbuyy=vbuyy_bxor_vbuc1 
    tya
    eor #1
    tay
    // [89] (word~) divr16s::divisoru#4 ← (word)(signed word) divr16s::divisoru#1
    jmp b4_from_b3
    // divr16s::@1
  b1:
    // [90] (signed word) divr16s::remu#1 ← - (signed word) divr16s::rem#0 -- vwsz1=_neg_vwsz1 
    sec
    lda #0
    sbc remu
    sta remu
    lda #0
    sbc remu+1
    sta remu+1
    // [91] (word~) divr16s::remu#7 ← (word)(signed word) divr16s::remu#1
    // [73] phi from divr16s::@1 to divr16s::@2 [phi:divr16s::@1->divr16s::@2]
  b2_from_b1:
    // [73] phi (word) divr16s::remu#3 = (word~) divr16s::remu#7 [phi:divr16s::@1->divr16s::@2#0] -- register_copy 
    // [73] phi (byte) divr16s::neg#3 = (byte) 1 [phi:divr16s::@1->divr16s::@2#1] -- vbuyy=vbuc1 
    ldy #1
    jmp b2
}
  // divr16u
// Performs division on two 16 bit unsigned words and an initial remainder
// Returns the quotient dividend/divisor.
// The final remainder will be set into the global variable rem16u
// Implemented using simple binary division
// divr16u(word zeropage($d) dividend, word zeropage(9) divisor, word zeropage(7) rem)
divr16u: {
    .label rem = 7
    .label dividend = $d
    .label quotient = $b
    .label return = $b
    .label divisor = 9
    // [93] phi from divr16u to divr16u::@1 [phi:divr16u->divr16u::@1]
  b1_from_divr16u:
    // [93] phi (byte) divr16u::i#2 = (byte) 0 [phi:divr16u->divr16u::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [93] phi (word) divr16u::quotient#3 = (byte) 0 [phi:divr16u->divr16u::@1#1] -- vwuz1=vbuc1 
    lda #<0
    sta quotient
    lda #>0
    sta quotient+1
    // [93] phi (word) divr16u::dividend#2 = (word) 0 [phi:divr16u->divr16u::@1#2] -- vwuz1=vwuc1 
    lda #<0
    sta dividend
    lda #>0
    sta dividend+1
    // [93] phi (word) divr16u::rem#4 = (word) divr16u::rem#3 [phi:divr16u->divr16u::@1#3] -- register_copy 
    jmp b1
    // [93] phi from divr16u::@3 to divr16u::@1 [phi:divr16u::@3->divr16u::@1]
  b1_from_b3:
    // [93] phi (byte) divr16u::i#2 = (byte) divr16u::i#1 [phi:divr16u::@3->divr16u::@1#0] -- register_copy 
    // [93] phi (word) divr16u::quotient#3 = (word) divr16u::return#0 [phi:divr16u::@3->divr16u::@1#1] -- register_copy 
    // [93] phi (word) divr16u::dividend#2 = (word) divr16u::dividend#0 [phi:divr16u::@3->divr16u::@1#2] -- register_copy 
    // [93] phi (word) divr16u::rem#4 = (word) divr16u::rem#9 [phi:divr16u::@3->divr16u::@1#3] -- register_copy 
    jmp b1
    // divr16u::@1
  b1:
    // [94] (word) divr16u::rem#0 ← (word) divr16u::rem#4 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl rem
    rol rem+1
    // [95] (byte~) divr16u::$1 ← > (word) divr16u::dividend#2 -- vbuaa=_hi_vwuz1 
    lda dividend+1
    // [96] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // [97] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b2_from_b1
    jmp b4
    // divr16u::@4
  b4:
    // [98] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 -- vwuz1=vwuz1_bor_vbuc1 
    lda #1
    ora rem
    sta rem
    // [99] phi from divr16u::@1 divr16u::@4 to divr16u::@2 [phi:divr16u::@1/divr16u::@4->divr16u::@2]
  b2_from_b1:
  b2_from_b4:
    // [99] phi (word) divr16u::rem#5 = (word) divr16u::rem#0 [phi:divr16u::@1/divr16u::@4->divr16u::@2#0] -- register_copy 
    jmp b2
    // divr16u::@2
  b2:
    // [100] (word) divr16u::dividend#0 ← (word) divr16u::dividend#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl dividend
    rol dividend+1
    // [101] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl quotient
    rol quotient+1
    // [102] if((word) divr16u::rem#5<(word) divr16u::divisor#0) goto divr16u::@3 -- vwuz1_lt_vwuz2_then_la1 
    lda rem+1
    cmp divisor+1
    bcc b3_from_b2
    bne !+
    lda rem
    cmp divisor
    bcc b3_from_b2
  !:
    jmp b5
    // divr16u::@5
  b5:
    // [103] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1 -- vwuz1=_inc_vwuz1 
    inc quotient
    bne !+
    inc quotient+1
  !:
    // [104] (word) divr16u::rem#2 ← (word) divr16u::rem#5 - (word) divr16u::divisor#0 -- vwuz1=vwuz1_minus_vwuz2 
    lda rem
    sec
    sbc divisor
    sta rem
    lda rem+1
    sbc divisor+1
    sta rem+1
    // [105] phi from divr16u::@2 divr16u::@5 to divr16u::@3 [phi:divr16u::@2/divr16u::@5->divr16u::@3]
  b3_from_b2:
  b3_from_b5:
    // [105] phi (word) divr16u::return#0 = (word) divr16u::quotient#1 [phi:divr16u::@2/divr16u::@5->divr16u::@3#0] -- register_copy 
    // [105] phi (word) divr16u::rem#9 = (word) divr16u::rem#5 [phi:divr16u::@2/divr16u::@5->divr16u::@3#1] -- register_copy 
    jmp b3
    // divr16u::@3
  b3:
    // [106] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [107] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$10
    bne b1_from_b3
    jmp breturn
    // divr16u::@return
  breturn:
    // [108] return 
    rts
}
  // screen_fill
// Fill the screen with a specific char
// screen_fill(byte* zeropage($10) screen)
screen_fill: {
    .const ch = $10
    .label screen = $10
    .label y = $f
    // [110] phi from screen_fill to screen_fill::@1 [phi:screen_fill->screen_fill::@1]
  b1_from_screen_fill:
    // [110] phi (byte) screen_fill::y#4 = (byte) 0 [phi:screen_fill->screen_fill::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    // [110] phi (byte*) screen_fill::screen#3 = (const byte*) SCREEN#0 [phi:screen_fill->screen_fill::@1#1] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta screen
    lda #>SCREEN
    sta screen+1
    jmp b1
    // [110] phi from screen_fill::@3 to screen_fill::@1 [phi:screen_fill::@3->screen_fill::@1]
  b1_from_b3:
    // [110] phi (byte) screen_fill::y#4 = (byte) screen_fill::y#1 [phi:screen_fill::@3->screen_fill::@1#0] -- register_copy 
    // [110] phi (byte*) screen_fill::screen#3 = (byte*) screen_fill::screen#1 [phi:screen_fill::@3->screen_fill::@1#1] -- register_copy 
    jmp b1
    // screen_fill::@1
  b1:
    // [111] phi from screen_fill::@1 to screen_fill::@2 [phi:screen_fill::@1->screen_fill::@2]
  b2_from_b1:
    // [111] phi (byte) screen_fill::x#2 = (byte) 0 [phi:screen_fill::@1->screen_fill::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [111] phi (byte*) screen_fill::screen#2 = (byte*) screen_fill::screen#3 [phi:screen_fill::@1->screen_fill::@2#1] -- register_copy 
    jmp b2
    // [111] phi from screen_fill::@2 to screen_fill::@2 [phi:screen_fill::@2->screen_fill::@2]
  b2_from_b2:
    // [111] phi (byte) screen_fill::x#2 = (byte) screen_fill::x#1 [phi:screen_fill::@2->screen_fill::@2#0] -- register_copy 
    // [111] phi (byte*) screen_fill::screen#2 = (byte*) screen_fill::screen#1 [phi:screen_fill::@2->screen_fill::@2#1] -- register_copy 
    jmp b2
    // screen_fill::@2
  b2:
    // [112] *((byte*) screen_fill::screen#2) ← (const byte) screen_fill::ch#0 -- _deref_pbuz1=vbuc1 
    lda #ch
    ldy #0
    sta (screen),y
    // [113] (byte*) screen_fill::screen#1 ← ++ (byte*) screen_fill::screen#2 -- pbuz1=_inc_pbuz1 
    inc screen
    bne !+
    inc screen+1
  !:
    // [114] (byte) screen_fill::x#1 ← ++ (byte) screen_fill::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [115] if((byte) screen_fill::x#1!=(byte) $28) goto screen_fill::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne b2_from_b2
    jmp b3
    // screen_fill::@3
  b3:
    // [116] (byte) screen_fill::y#1 ← ++ (byte) screen_fill::y#4 -- vbuz1=_inc_vbuz1 
    inc y
    // [117] if((byte) screen_fill::y#1!=(byte) $19) goto screen_fill::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp y
    bne b1_from_b3
    jmp breturn
    // screen_fill::@return
  breturn:
    // [118] return 
    rts
}
  // bitmap_clear
// Clear all graphics on the bitmap
bitmap_clear: {
    .label bitmap = $13
    .label y = $12
    // [119] (word) bitmap_clear::bitmap#0 ← *((const byte[$100]) bitmap_plot_yhi#0) w= *((const byte[$100]) bitmap_plot_ylo#0) -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda bitmap_plot_ylo
    sta bitmap
    lda bitmap_plot_yhi
    sta bitmap+1
    // [120] (byte*~) bitmap_clear::bitmap#5 ← (byte*)(word) bitmap_clear::bitmap#0
    // [121] phi from bitmap_clear to bitmap_clear::@1 [phi:bitmap_clear->bitmap_clear::@1]
  b1_from_bitmap_clear:
    // [121] phi (byte) bitmap_clear::y#4 = (byte) 0 [phi:bitmap_clear->bitmap_clear::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    // [121] phi (byte*) bitmap_clear::bitmap#3 = (byte*~) bitmap_clear::bitmap#5 [phi:bitmap_clear->bitmap_clear::@1#1] -- register_copy 
    jmp b1
    // [121] phi from bitmap_clear::@3 to bitmap_clear::@1 [phi:bitmap_clear::@3->bitmap_clear::@1]
  b1_from_b3:
    // [121] phi (byte) bitmap_clear::y#4 = (byte) bitmap_clear::y#1 [phi:bitmap_clear::@3->bitmap_clear::@1#0] -- register_copy 
    // [121] phi (byte*) bitmap_clear::bitmap#3 = (byte*) bitmap_clear::bitmap#1 [phi:bitmap_clear::@3->bitmap_clear::@1#1] -- register_copy 
    jmp b1
    // bitmap_clear::@1
  b1:
    // [122] phi from bitmap_clear::@1 to bitmap_clear::@2 [phi:bitmap_clear::@1->bitmap_clear::@2]
  b2_from_b1:
    // [122] phi (byte) bitmap_clear::x#2 = (byte) 0 [phi:bitmap_clear::@1->bitmap_clear::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [122] phi (byte*) bitmap_clear::bitmap#2 = (byte*) bitmap_clear::bitmap#3 [phi:bitmap_clear::@1->bitmap_clear::@2#1] -- register_copy 
    jmp b2
    // [122] phi from bitmap_clear::@2 to bitmap_clear::@2 [phi:bitmap_clear::@2->bitmap_clear::@2]
  b2_from_b2:
    // [122] phi (byte) bitmap_clear::x#2 = (byte) bitmap_clear::x#1 [phi:bitmap_clear::@2->bitmap_clear::@2#0] -- register_copy 
    // [122] phi (byte*) bitmap_clear::bitmap#2 = (byte*) bitmap_clear::bitmap#1 [phi:bitmap_clear::@2->bitmap_clear::@2#1] -- register_copy 
    jmp b2
    // bitmap_clear::@2
  b2:
    // [123] *((byte*) bitmap_clear::bitmap#2) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (bitmap),y
    // [124] (byte*) bitmap_clear::bitmap#1 ← ++ (byte*) bitmap_clear::bitmap#2 -- pbuz1=_inc_pbuz1 
    inc bitmap
    bne !+
    inc bitmap+1
  !:
    // [125] (byte) bitmap_clear::x#1 ← ++ (byte) bitmap_clear::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [126] if((byte) bitmap_clear::x#1!=(byte) $c8) goto bitmap_clear::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$c8
    bne b2_from_b2
    jmp b3
    // bitmap_clear::@3
  b3:
    // [127] (byte) bitmap_clear::y#1 ← ++ (byte) bitmap_clear::y#4 -- vbuz1=_inc_vbuz1 
    inc y
    // [128] if((byte) bitmap_clear::y#1!=(byte) $28) goto bitmap_clear::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp y
    bne b1_from_b3
    jmp breturn
    // bitmap_clear::@return
  breturn:
    // [129] return 
    rts
}
  // bitmap_init
bitmap_init: {
    .label _7 = $23
    .label yoffs = $15
    // [131] phi from bitmap_init to bitmap_init::@1 [phi:bitmap_init->bitmap_init::@1]
  b1_from_bitmap_init:
    // [131] phi (byte) bitmap_init::x#2 = (byte) 0 [phi:bitmap_init->bitmap_init::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [131] phi (byte) bitmap_init::bits#3 = (byte) $80 [phi:bitmap_init->bitmap_init::@1#1] -- vbuaa=vbuc1 
    lda #$80
    jmp b1
    // [131] phi from bitmap_init::@2 to bitmap_init::@1 [phi:bitmap_init::@2->bitmap_init::@1]
  b1_from_b2:
    // [131] phi (byte) bitmap_init::x#2 = (byte) bitmap_init::x#1 [phi:bitmap_init::@2->bitmap_init::@1#0] -- register_copy 
    // [131] phi (byte) bitmap_init::bits#3 = (byte) bitmap_init::bits#4 [phi:bitmap_init::@2->bitmap_init::@1#1] -- register_copy 
    jmp b1
    // bitmap_init::@1
  b1:
    // [132] *((const byte[$100]) bitmap_plot_bit#0 + (byte) bitmap_init::x#2) ← (byte) bitmap_init::bits#3 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta bitmap_plot_bit,x
    // [133] (byte) bitmap_init::bits#1 ← (byte) bitmap_init::bits#3 >> (byte) 1 -- vbuaa=vbuaa_ror_1 
    lsr
    // [134] if((byte) bitmap_init::bits#1!=(byte) 0) goto bitmap_init::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b6_from_b1
    // [136] phi from bitmap_init::@1 to bitmap_init::@2 [phi:bitmap_init::@1->bitmap_init::@2]
  b2_from_b1:
    // [136] phi (byte) bitmap_init::bits#4 = (byte) $80 [phi:bitmap_init::@1->bitmap_init::@2#0] -- vbuaa=vbuc1 
    lda #$80
    jmp b2
    // [135] phi from bitmap_init::@1 to bitmap_init::@6 [phi:bitmap_init::@1->bitmap_init::@6]
  b6_from_b1:
    jmp b6
    // bitmap_init::@6
  b6:
    // [136] phi from bitmap_init::@6 to bitmap_init::@2 [phi:bitmap_init::@6->bitmap_init::@2]
  b2_from_b6:
    // [136] phi (byte) bitmap_init::bits#4 = (byte) bitmap_init::bits#1 [phi:bitmap_init::@6->bitmap_init::@2#0] -- register_copy 
    jmp b2
    // bitmap_init::@2
  b2:
    // [137] (byte) bitmap_init::x#1 ← ++ (byte) bitmap_init::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [138] if((byte) bitmap_init::x#1!=(byte) 0) goto bitmap_init::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b1_from_b2
    // [139] phi from bitmap_init::@2 to bitmap_init::@3 [phi:bitmap_init::@2->bitmap_init::@3]
  b3_from_b2:
    // [139] phi (byte*) bitmap_init::yoffs#2 = (const byte*) BITMAP#0 [phi:bitmap_init::@2->bitmap_init::@3#0] -- pbuz1=pbuc1 
    lda #<BITMAP
    sta yoffs
    lda #>BITMAP
    sta yoffs+1
    // [139] phi (byte) bitmap_init::y#2 = (byte) 0 [phi:bitmap_init::@2->bitmap_init::@3#1] -- vbuxx=vbuc1 
    ldx #0
    jmp b3
    // [139] phi from bitmap_init::@4 to bitmap_init::@3 [phi:bitmap_init::@4->bitmap_init::@3]
  b3_from_b4:
    // [139] phi (byte*) bitmap_init::yoffs#2 = (byte*) bitmap_init::yoffs#4 [phi:bitmap_init::@4->bitmap_init::@3#0] -- register_copy 
    // [139] phi (byte) bitmap_init::y#2 = (byte) bitmap_init::y#1 [phi:bitmap_init::@4->bitmap_init::@3#1] -- register_copy 
    jmp b3
    // bitmap_init::@3
  b3:
    // [140] (byte~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax _7
    // [141] (byte~) bitmap_init::$4 ← < (byte*) bitmap_init::yoffs#2 -- vbuaa=_lo_pbuz1 
    lda yoffs
    // [142] (byte~) bitmap_init::$5 ← (byte~) bitmap_init::$7 | (byte~) bitmap_init::$4 -- vbuaa=vbuz1_bor_vbuaa 
    ora _7
    // [143] *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_init::y#2) ← (byte~) bitmap_init::$5 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta bitmap_plot_ylo,x
    // [144] (byte~) bitmap_init::$6 ← > (byte*) bitmap_init::yoffs#2 -- vbuaa=_hi_pbuz1 
    lda yoffs+1
    // [145] *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_init::y#2) ← (byte~) bitmap_init::$6 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta bitmap_plot_yhi,x
    // [146] if((byte~) bitmap_init::$7!=(byte) 7) goto bitmap_init::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #7
    cmp _7
    bne b4_from_b3
    jmp b5
    // bitmap_init::@5
  b5:
    // [147] (byte*) bitmap_init::yoffs#1 ← (byte*) bitmap_init::yoffs#2 + (word)(number) $28*(number) 8 -- pbuz1=pbuz1_plus_vwuc1 
    clc
    lda yoffs
    adc #<$28*8
    sta yoffs
    lda yoffs+1
    adc #>$28*8
    sta yoffs+1
    // [148] phi from bitmap_init::@3 bitmap_init::@5 to bitmap_init::@4 [phi:bitmap_init::@3/bitmap_init::@5->bitmap_init::@4]
  b4_from_b3:
  b4_from_b5:
    // [148] phi (byte*) bitmap_init::yoffs#4 = (byte*) bitmap_init::yoffs#2 [phi:bitmap_init::@3/bitmap_init::@5->bitmap_init::@4#0] -- register_copy 
    jmp b4
    // bitmap_init::@4
  b4:
    // [149] (byte) bitmap_init::y#1 ← ++ (byte) bitmap_init::y#2 -- vbuxx=_inc_vbuxx 
    inx
    // [150] if((byte) bitmap_init::y#1!=(byte) 0) goto bitmap_init::@3 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b3_from_b4
    jmp breturn
    // bitmap_init::@return
  breturn:
    // [151] return 
    rts
}
  // File Data
  // The coordinates of the lines to animate
  x_start: .word $a, $14, $1e, $1e
  y_start: .byte $a, $a, $a, $14
  x_end: .word $14, $a, $14, $14
  y_end: .byte $14, $14, $a, $14
  // Tables for the plotter - initialized by calling bitmap_init();
  bitmap_plot_ylo: .fill $100, 0
  bitmap_plot_yhi: .fill $100, 0
  bitmap_plot_bit: .fill $100, 0
  // Current x position fixed point [12.4]
  x_cur: .fill 2*SIZE, 0
  // Current y position fixed point [12.4]
  y_cur: .fill 2*SIZE, 0
  // X position addition per frame s[3.4]
  x_add: .fill SIZE, 0
  // Y position addition per frame s[3.4]
  y_add: .fill SIZE, 0
  // Frame delay (counted down to 0)
  delay: .fill SIZE, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp vicSelectGfxBank1
Removing instruction jmp vicSelectGfxBank1_toDd001
Removing instruction jmp vicSelectGfxBank1_b1
Removing instruction jmp toD0181
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b6
Removing instruction jmp b1
Removing instruction jmp b7
Removing instruction jmp b8
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp abs16s1
Removing instruction jmp abs16s1_b3
Removing instruction jmp abs16s1_breturn
Removing instruction jmp abs16s2
Removing instruction jmp abs16s2_b3
Removing instruction jmp abs16s2_breturn
Removing instruction jmp b6
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp b3
Removing instruction jmp b5
Removing instruction jmp b7
Removing instruction jmp b10
Removing instruction jmp b6
Removing instruction jmp b2
Removing instruction jmp b7
Removing instruction jmp b4
Removing instruction jmp b9
Removing instruction jmp b8
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b4
Removing instruction jmp b2
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b6
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b5
Removing instruction jmp b4
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy #0
Removing instruction ldy point_idx
Removing instruction ldy point_idx
Replacing instruction lda #<0 with TXA
Removing instruction lda #>0
Removing instruction lda #<0
Removing instruction lda #>0
Replacing instruction ldy #0 with TAY
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b1_from_b8 with b1
Replacing label abs16s2_breturn_from_abs16s2_b1 with b6
Replacing label abs16s1_breturn_from_abs16s1_b1 with abs16s2
Replacing label breturn_from_b5 with breturn
Replacing label b4_from_b3 with b4
Replacing label b2_from_b1 with b2
Replacing label b3_from_b2 with b3
Replacing label b3_from_b2 with b3
Replacing label b1_from_b3 with b1
Replacing label b2_from_b2 with b2
Replacing label b1_from_b3 with b1
Replacing label b2_from_b2 with b2
Replacing label b1_from_b3 with b1
Replacing label b6_from_b1 with b2
Replacing label b1_from_b2 with b1
Replacing label b4_from_b3 with b4
Replacing label b3_from_b4 with b3
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction bend_from_b1:
Removing instruction vicSelectGfxBank1_toDd001_from_vicSelectGfxBank1:
Removing instruction vicSelectGfxBank1_toDd001:
Removing instruction toD0181_from_vicSelectGfxBank1_b1:
Removing instruction toD0181:
Removing instruction b5_from_b4:
Removing instruction b6_from_b5:
Removing instruction screen_fill_from_b6:
Removing instruction b1_from_b8:
Removing instruction abs16s1_breturn_from_abs16s1_b1:
Removing instruction abs16s1_breturn_from_abs16s1_b3:
Removing instruction abs16s1_breturn:
Removing instruction abs16s2_breturn_from_abs16s2_b1:
Removing instruction abs16s2_breturn_from_abs16s2_b3:
Removing instruction abs16s2_breturn:
Removing instruction divr16s_from_b5:
Removing instruction b2_from_b6:
Removing instruction b7:
Removing instruction b4_from_b3:
Removing instruction b4_from_b7:
Removing instruction divr16u_from_b4:
Removing instruction breturn_from_b5:
Removing instruction breturn_from_b8:
Removing instruction b1_from_b3:
Removing instruction b2_from_b1:
Removing instruction b2_from_b4:
Removing instruction b3_from_b2:
Removing instruction b3_from_b5:
Removing instruction b1_from_b3:
Removing instruction b2_from_b1:
Removing instruction b2_from_b2:
Removing instruction b1_from_b3:
Removing instruction b2_from_b1:
Removing instruction b2_from_b2:
Removing instruction b1_from_b2:
Removing instruction b6_from_b1:
Removing instruction b6:
Removing instruction b2_from_b6:
Removing instruction b3_from_b4:
Removing instruction b4_from_b3:
Removing instruction b4_from_b5:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction vicSelectGfxBank1:
Removing instruction vicSelectGfxBank1_b1:
Removing instruction b4:
Removing instruction bitmap_init_from_b4:
Removing instruction b5:
Removing instruction b6:
Removing instruction b1_from_b6:
Removing instruction b7:
Removing instruction b8:
Removing instruction b3:
Removing instruction breturn:
Removing instruction abs16s1:
Removing instruction abs16s1_b3:
Removing instruction abs16s2_b3:
Removing instruction breturn:
Removing instruction b3:
Removing instruction b7:
Removing instruction b10:
Removing instruction b6:
Removing instruction b9:
Removing instruction b8:
Removing instruction b2_from_b1:
Removing instruction b1_from_divr16u:
Removing instruction b4:
Removing instruction b5:
Removing instruction breturn:
Removing instruction b1_from_screen_fill:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b1_from_bitmap_clear:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b1_from_bitmap_init:
Removing instruction b2_from_b1:
Removing instruction b3_from_b2:
Removing instruction b5:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Skipping double jump to breturn in beq b5
Replacing jump to rts with rts in jmp breturn
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction jmp b1
Removing instruction jmp b1
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Removing instruction b5:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing unreachable instruction rts
Succesful ASM optimization Pass5UnreachableCodeElimination
Fixing long branch [148] bmi abs16s1_b1 to bpl
Fixing long branch [157] bmi abs16s2_b1 to bpl

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) BITMAP
(const byte*) BITMAP#0 BITMAP = (byte*) 40960
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = (byte*) 53280
(byte*) CIA2_PORT_A
(const byte*) CIA2_PORT_A#0 CIA2_PORT_A = (byte*) 56576
(byte*) CIA2_PORT_A_DDR
(const byte*) CIA2_PORT_A_DDR#0 CIA2_PORT_A_DDR = (byte*) 56578
(byte*) D011
(const byte*) D011#0 D011 = (byte*) 53265
(byte*) D018
(const byte*) D018#0 D018 = (byte*) 53272
(byte) DELAY
(const byte) DELAY#0 DELAY = (byte) 8
(byte*) PROCPORT
(const byte*) PROCPORT#0 PROCPORT = (byte*) 1
(byte*) PROCPORT_DDR
(const byte*) PROCPORT_DDR#0 PROCPORT_DDR = (byte*) 0
(byte) PROCPORT_DDR_MEMORY_MASK
(const byte) PROCPORT_DDR_MEMORY_MASK#0 PROCPORT_DDR_MEMORY_MASK = (byte) 7
(byte) PROCPORT_RAM_IO
(const byte) PROCPORT_RAM_IO#0 PROCPORT_RAM_IO = (byte) $35
(byte*) RASTER
(const byte*) RASTER#0 RASTER = (byte*) 53266
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = (byte*) 34816
(byte) SIZE
(const byte) SIZE#0 SIZE = (byte) 4
(byte) VIC_BMM
(const byte) VIC_BMM#0 VIC_BMM = (byte) $20
(byte) VIC_DEN
(const byte) VIC_DEN#0 VIC_DEN = (byte) $10
(byte) VIC_RSEL
(const byte) VIC_RSEL#0 VIC_RSEL = (byte) 8
(void()) bitmap_clear()
(label) bitmap_clear::@1
(label) bitmap_clear::@2
(label) bitmap_clear::@3
(label) bitmap_clear::@return
(byte*) bitmap_clear::bitmap
(word) bitmap_clear::bitmap#0 bitmap zp ZP_WORD:19 2.0
(byte*) bitmap_clear::bitmap#1 bitmap zp ZP_WORD:19 42.599999999999994
(byte*) bitmap_clear::bitmap#2 bitmap zp ZP_WORD:19 157.0
(byte*) bitmap_clear::bitmap#3 bitmap zp ZP_WORD:19 24.0
(byte*~) bitmap_clear::bitmap#5 bitmap zp ZP_WORD:19 4.0
(byte) bitmap_clear::x
(byte) bitmap_clear::x#1 reg byte x 151.5
(byte) bitmap_clear::x#2 reg byte x 67.33333333333333
(byte) bitmap_clear::y
(byte) bitmap_clear::y#1 y zp ZP_BYTE:18 16.5
(byte) bitmap_clear::y#4 y zp ZP_BYTE:18 3.6666666666666665
(void()) bitmap_init((byte*) bitmap_init::bitmap)
(byte~) bitmap_init::$4 reg byte a 22.0
(byte~) bitmap_init::$5 reg byte a 22.0
(byte~) bitmap_init::$6 reg byte a 22.0
(byte~) bitmap_init::$7 $7 zp ZP_BYTE:35 5.5
(label) bitmap_init::@1
(label) bitmap_init::@2
(label) bitmap_init::@3
(label) bitmap_init::@4
(label) bitmap_init::@5
(label) bitmap_init::@6
(label) bitmap_init::@return
(byte*) bitmap_init::bitmap
(byte) bitmap_init::bits
(byte) bitmap_init::bits#1 reg byte a 11.0
(byte) bitmap_init::bits#3 reg byte a 16.5
(byte) bitmap_init::bits#4 reg byte a 7.333333333333333
(byte) bitmap_init::x
(byte) bitmap_init::x#1 reg byte x 16.5
(byte) bitmap_init::x#2 reg byte x 5.5
(byte) bitmap_init::y
(byte) bitmap_init::y#1 reg byte x 16.5
(byte) bitmap_init::y#2 reg byte x 5.5
(byte*) bitmap_init::yoffs
(byte*) bitmap_init::yoffs#1 yoffs zp ZP_WORD:21 22.0
(byte*) bitmap_init::yoffs#2 yoffs zp ZP_WORD:21 6.875
(byte*) bitmap_init::yoffs#4 yoffs zp ZP_WORD:21 11.0
(void()) bitmap_plot((word) bitmap_plot::x , (byte) bitmap_plot::y)
(word~) bitmap_plot::$1 $1 zp ZP_WORD:27 4.0
(byte~) bitmap_plot::$2 reg byte a 4.0
(label) bitmap_plot::@return
(byte*) bitmap_plot::plotter
(word) bitmap_plot::plotter#0 plotter zp ZP_WORD:25 1.0
(byte*) bitmap_plot::plotter#1 plotter zp ZP_WORD:25 3.0
(word) bitmap_plot::x
(word) bitmap_plot::x#0 x zp ZP_WORD:23 3.0
(byte) bitmap_plot::y
(byte) bitmap_plot::y#0 reg byte x 15.0
(byte[$100]) bitmap_plot_bit
(const byte[$100]) bitmap_plot_bit#0 bitmap_plot_bit = { fill( $100, 0) }
(byte[$100]) bitmap_plot_yhi
(const byte[$100]) bitmap_plot_yhi#0 bitmap_plot_yhi = { fill( $100, 0) }
(byte[$100]) bitmap_plot_ylo
(const byte[$100]) bitmap_plot_ylo#0 bitmap_plot_ylo = { fill( $100, 0) }
(byte[SIZE#0]) delay
(const byte[SIZE#0]) delay#0 delay = { fill( SIZE#0, 0) }
(signed word()) divr16s((signed word) divr16s::dividend , (signed word) divr16s::divisor , (signed word) divr16s::rem)
(label) divr16s::@1
(label) divr16s::@10
(label) divr16s::@2
(label) divr16s::@3
(label) divr16s::@4
(label) divr16s::@5
(label) divr16s::@6
(label) divr16s::@7
(label) divr16s::@8
(label) divr16s::@9
(label) divr16s::@return
(signed word) divr16s::dividend
(word) divr16s::dividendu
(signed word) divr16s::divisor
(signed word) divr16s::divisor#0 divisor zp ZP_WORD:9 0.6666666666666666
(word) divr16s::divisoru
(signed word) divr16s::divisoru#1 divisoru zp ZP_WORD:9 1.0
(word) divr16s::divisoru#3 divisoru zp ZP_WORD:9 6.0
(word~) divr16s::divisoru#4 divisoru zp ZP_WORD:9 4.0
(word~) divr16s::divisoru#5 divisoru zp ZP_WORD:9 4.0
(byte) divr16s::neg
(byte) divr16s::neg#2 reg byte y 2.0
(byte) divr16s::neg#3 reg byte y 1.0
(byte) divr16s::neg#4 reg byte y 1.0
(signed word) divr16s::rem
(signed word) divr16s::rem#0 rem zp ZP_WORD:7 2.0
(word) divr16s::remu
(signed word) divr16s::remu#1 remu zp ZP_WORD:7 2.0
(word) divr16s::remu#3 remu zp ZP_WORD:7 0.75
(word~) divr16s::remu#7 remu zp ZP_WORD:7 4.0
(word~) divr16s::remu#8 remu zp ZP_WORD:7 4.0
(word) divr16s::resultu
(word) divr16s::resultu#0 resultu zp ZP_WORD:11 1.0
(signed word) divr16s::return
(signed word) divr16s::return#1 return zp ZP_WORD:11 4.0
(signed word) divr16s::return#2 return zp ZP_WORD:11 2.0
(signed word) divr16s::return#3 return zp ZP_WORD:11 4.0
(signed word~) divr16s::return#7 return zp ZP_WORD:11 4.0
(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
(byte~) divr16u::$1 reg byte a 202.0
(byte~) divr16u::$2 reg byte a 202.0
(label) divr16u::@1
(label) divr16u::@2
(label) divr16u::@3
(label) divr16u::@4
(label) divr16u::@5
(label) divr16u::@return
(word) divr16u::dividend
(word) divr16u::dividend#0 dividend zp ZP_WORD:13 25.25
(word) divr16u::dividend#2 dividend zp ZP_WORD:13 43.285714285714285
(word) divr16u::divisor
(word) divr16u::divisor#0 divisor zp ZP_WORD:9 11.333333333333332
(byte) divr16u::i
(byte) divr16u::i#1 reg byte x 151.5
(byte) divr16u::i#2 reg byte x 15.538461538461538
(word) divr16u::quotient
(word) divr16u::quotient#1 quotient zp ZP_WORD:11 151.5
(word) divr16u::quotient#2 quotient zp ZP_WORD:11 101.0
(word) divr16u::quotient#3 quotient zp ZP_WORD:11 25.25
(word) divr16u::rem
(word) divr16u::rem#0 rem zp ZP_WORD:7 75.75
(word) divr16u::rem#1 rem zp ZP_WORD:7 202.0
(word) divr16u::rem#2 rem zp ZP_WORD:7 202.0
(word) divr16u::rem#3 rem zp ZP_WORD:7 2.0
(word) divr16u::rem#4 rem zp ZP_WORD:7 204.0
(word) divr16u::rem#5 rem zp ZP_WORD:7 101.0
(word) divr16u::rem#9 rem zp ZP_WORD:7 101.0
(word) divr16u::return
(word) divr16u::return#0 return zp ZP_WORD:11 61.0
(word) divr16u::return#2 return zp ZP_WORD:11 4.0
(void()) main()
(byte~) main::$13 reg byte a 22.0
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(byte) main::i
(byte) main::i#1 i zp ZP_BYTE:2 16.5
(byte) main::i#2 i zp ZP_BYTE:2 7.857142857142857
(label) main::toD0181
(word~) main::toD0181_$0
(number~) main::toD0181_$1
(number~) main::toD0181_$2
(number~) main::toD0181_$3
(word~) main::toD0181_$4
(byte~) main::toD0181_$5
(number~) main::toD0181_$6
(number~) main::toD0181_$7
(number~) main::toD0181_$8
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(const byte) main::toD0181_return#0 toD0181_return = >(word)(const byte*) SCREEN#0&(word) $3fff*(byte) 4|>(word)(const byte*) BITMAP#0/(byte) 4&(byte) $f
(byte*) main::toD0181_screen
(label) main::vicSelectGfxBank1
(byte~) main::vicSelectGfxBank1_$0
(label) main::vicSelectGfxBank1_@1
(byte*) main::vicSelectGfxBank1_gfx
(label) main::vicSelectGfxBank1_toDd001
(word~) main::vicSelectGfxBank1_toDd001_$0
(byte~) main::vicSelectGfxBank1_toDd001_$1
(number~) main::vicSelectGfxBank1_toDd001_$2
(number~) main::vicSelectGfxBank1_toDd001_$3
(byte*) main::vicSelectGfxBank1_toDd001_gfx
(byte) main::vicSelectGfxBank1_toDd001_return
(const byte) main::vicSelectGfxBank1_toDd001_return#0 vicSelectGfxBank1_toDd001_return = (byte) 3^>(word)(const byte*) SCREEN#0/(byte) $40
(void()) point_init((byte) point_init::point_idx)
(word~) point_init::$10 $10 zp ZP_WORD:33 4.0
(word~) point_init::$11 $11 zp ZP_WORD:33 4.0
(byte~) point_init::$14 reg byte a 4.0
(byte~) point_init::$16 reg byte a 2.0
(byte~) point_init::$18 reg byte a 2.0
(byte~) point_init::$20 reg byte x 1.6
(signed word~) point_init::$3 $3 zp ZP_WORD:7 2.0
(signed word~) point_init::$4 $4 zp ZP_WORD:29 4.0
(word~) point_init::$9 $9 zp ZP_WORD:31 4.0
(label) point_init::@1
(label) point_init::@2
(label) point_init::@3
(label) point_init::@4
(label) point_init::@5
(label) point_init::@6
(label) point_init::@7
(label) point_init::@return
(label) point_init::abs16s1
(bool~) point_init::abs16s1_$0
(word~) point_init::abs16s1_$1
(signed word~) point_init::abs16s1_$2
(word~) point_init::abs16s1_$3
(label) point_init::abs16s1_@1
(label) point_init::abs16s1_@3
(label) point_init::abs16s1_@return
(word) point_init::abs16s1_return
(signed word) point_init::abs16s1_return#0 abs16s1_return zp ZP_WORD:3 2.0
(word) point_init::abs16s1_return#2 abs16s1_return zp ZP_WORD:3 1.0
(word~) point_init::abs16s1_return#5 abs16s1_return zp ZP_WORD:3 4.0
(word~) point_init::abs16s1_return#6 abs16s1_return zp ZP_WORD:3 4.0
(signed word) point_init::abs16s1_w
(label) point_init::abs16s2
(bool~) point_init::abs16s2_$0
(word~) point_init::abs16s2_$1
(signed word~) point_init::abs16s2_$2
(word~) point_init::abs16s2_$3
(label) point_init::abs16s2_@1
(label) point_init::abs16s2_@3
(label) point_init::abs16s2_@return
(word) point_init::abs16s2_return
(signed word) point_init::abs16s2_return#0 abs16s2_return zp ZP_WORD:5 2.0
(word) point_init::abs16s2_return#2 abs16s2_return zp ZP_WORD:5 6.0
(word~) point_init::abs16s2_return#5 abs16s2_return zp ZP_WORD:5 4.0
(word~) point_init::abs16s2_return#6 abs16s2_return zp ZP_WORD:5 4.0
(signed word) point_init::abs16s2_w
(byte) point_init::point_idx
(byte) point_init::point_idx#0 point_idx zp ZP_BYTE:2 0.6764705882352942
(signed word) point_init::x_diff
(signed word) point_init::x_diff#1 x_diff zp ZP_WORD:9 0.5555555555555556
(signed word) point_init::x_stepf
(signed word) point_init::x_stepf#0 x_stepf zp ZP_WORD:11 4.0
(signed word) point_init::y_diff
(signed word) point_init::y_diff#0 y_diff zp ZP_WORD:7 0.5
(void()) screen_fill((byte*) screen_fill::screen , (byte) screen_fill::ch)
(label) screen_fill::@1
(label) screen_fill::@2
(label) screen_fill::@3
(label) screen_fill::@return
(byte) screen_fill::ch
(const byte) screen_fill::ch#0 ch = (byte) $10
(byte*) screen_fill::screen
(byte*) screen_fill::screen#1 screen zp ZP_WORD:16 42.599999999999994
(byte*) screen_fill::screen#2 screen zp ZP_WORD:16 157.0
(byte*) screen_fill::screen#3 screen zp ZP_WORD:16 22.0
(byte) screen_fill::x
(byte) screen_fill::x#1 reg byte x 151.5
(byte) screen_fill::x#2 reg byte x 67.33333333333333
(byte) screen_fill::y
(byte) screen_fill::y#1 y zp ZP_BYTE:15 16.5
(byte) screen_fill::y#4 y zp ZP_BYTE:15 3.6666666666666665
(signed byte[SIZE#0]) x_add
(const signed byte[SIZE#0]) x_add#0 x_add = { fill( SIZE#0, 0) }
(word[SIZE#0]) x_cur
(const word[SIZE#0]) x_cur#0 x_cur = { fill( SIZE#0, 0) }
(word[SIZE#0]) x_end
(const word[SIZE#0]) x_end#0 x_end = { (word) $14, (word) $a, (word) $14, (word) $14 }
(word[SIZE#0]) x_start
(const word[SIZE#0]) x_start#0 x_start = { (word) $a, (word) $14, (word) $1e, (word) $1e }
(signed byte[SIZE#0]) y_add
(const signed byte[SIZE#0]) y_add#0 y_add = { fill( SIZE#0, 0) }
(word[SIZE#0]) y_cur
(const word[SIZE#0]) y_cur#0 y_cur = { fill( SIZE#0, 0) }
(byte[SIZE#0]) y_end
(const byte[SIZE#0]) y_end#0 y_end = { (byte) $14, (byte) $14, (byte) $a, (byte) $14 }
(byte[SIZE#0]) y_start
(const byte[SIZE#0]) y_start#0 y_start = { (byte) $a, (byte) $a, (byte) $a, (byte) $14 }

zp ZP_BYTE:2 [ main::i#2 main::i#1 point_init::point_idx#0 ]
zp ZP_WORD:3 [ point_init::abs16s1_return#2 point_init::abs16s1_return#5 point_init::abs16s1_return#6 point_init::abs16s1_return#0 ]
zp ZP_WORD:5 [ point_init::abs16s2_return#2 point_init::abs16s2_return#5 point_init::abs16s2_return#6 point_init::abs16s2_return#0 ]
zp ZP_WORD:7 [ divr16s::remu#3 divr16s::remu#7 divr16s::remu#8 divr16u::rem#4 divr16u::rem#3 divr16u::rem#9 divr16u::rem#5 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 divr16s::rem#0 divr16s::remu#1 point_init::$3 point_init::y_diff#0 ]
zp ZP_WORD:9 [ divr16s::divisoru#3 divr16s::divisoru#4 divr16s::divisoru#5 divr16s::divisor#0 divr16u::divisor#0 divr16s::divisoru#1 point_init::x_diff#1 ]
reg byte y [ divr16s::neg#4 divr16s::neg#2 divr16s::neg#3 ]
zp ZP_WORD:11 [ divr16s::return#2 divr16s::return#1 divr16s::return#7 divr16s::resultu#0 divr16s::return#3 divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 point_init::x_stepf#0 ]
zp ZP_WORD:13 [ divr16u::dividend#2 divr16u::dividend#0 ]
reg byte x [ divr16u::i#2 divr16u::i#1 ]
zp ZP_BYTE:15 [ screen_fill::y#4 screen_fill::y#1 ]
zp ZP_WORD:16 [ screen_fill::screen#2 screen_fill::screen#3 screen_fill::screen#1 ]
reg byte x [ screen_fill::x#2 screen_fill::x#1 ]
zp ZP_BYTE:18 [ bitmap_clear::y#4 bitmap_clear::y#1 ]
zp ZP_WORD:19 [ bitmap_clear::bitmap#2 bitmap_clear::bitmap#3 bitmap_clear::bitmap#5 bitmap_clear::bitmap#1 bitmap_clear::bitmap#0 ]
reg byte x [ bitmap_clear::x#2 bitmap_clear::x#1 ]
reg byte a [ bitmap_init::bits#3 bitmap_init::bits#4 bitmap_init::bits#1 ]
reg byte x [ bitmap_init::x#2 bitmap_init::x#1 ]
reg byte x [ bitmap_init::y#2 bitmap_init::y#1 ]
zp ZP_WORD:21 [ bitmap_init::yoffs#2 bitmap_init::yoffs#4 bitmap_init::yoffs#1 ]
reg byte a [ main::$13 ]
zp ZP_WORD:23 [ bitmap_plot::x#0 ]
reg byte x [ bitmap_plot::y#0 ]
zp ZP_WORD:25 [ bitmap_plot::plotter#0 bitmap_plot::plotter#1 ]
zp ZP_WORD:27 [ bitmap_plot::$1 ]
reg byte a [ bitmap_plot::$2 ]
reg byte a [ point_init::$18 ]
zp ZP_WORD:29 [ point_init::$4 ]
reg byte x [ point_init::$20 ]
zp ZP_WORD:31 [ point_init::$9 ]
zp ZP_WORD:33 [ point_init::$10 point_init::$11 ]
reg byte a [ point_init::$14 ]
reg byte a [ point_init::$16 ]
reg byte a [ divr16u::$1 ]
reg byte a [ divr16u::$2 ]
zp ZP_BYTE:35 [ bitmap_init::$7 ]
reg byte a [ bitmap_init::$4 ]
reg byte a [ bitmap_init::$5 ]
reg byte a [ bitmap_init::$6 ]


FINAL ASSEMBLER
Score: 21969

  // File Comments
// Animated lines drawn on a single color bitmap
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // RAM in $A000, $E000 I/O in $D000
  .const PROCPORT_RAM_IO = $35
  .label RASTER = $d012
  .label BORDERCOL = $d020
  .label D011 = $d011
  .const VIC_BMM = $20
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  .label D018 = $d018
  // CIA#2 Port A: Serial bus, RS-232, VIC memory bank
  .label CIA2_PORT_A = $dd00
  // CIA #2 Port A data direction register.
  .label CIA2_PORT_A_DDR = $dd02
  .label BITMAP = $a000
  .label SCREEN = $8800
  // The number of points
  .const SIZE = 4
  // The delay between pixels
  .const DELAY = 8
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .const vicSelectGfxBank1_toDd001_return = 3^(>SCREEN)/$40
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>BITMAP)/4&$f
    .label i = 2
    // asm
    // asm { sei  }
    // Disable normal interrupt
    sei
    // *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK
    // [5] *((const byte*) PROCPORT_DDR#0) ← (const byte) PROCPORT_DDR_MEMORY_MASK#0 -- _deref_pbuc1=vbuc2 
    // Disable kernal & basic
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // *PROCPORT = PROCPORT_RAM_IO
    // [6] *((const byte*) PROCPORT#0) ← (const byte) PROCPORT_RAM_IO#0 -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // *D011 = VIC_BMM|VIC_DEN|VIC_RSEL|3
    // [7] *((const byte*) D011#0) ← (const byte) VIC_BMM#0|(const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_BMM|VIC_DEN|VIC_RSEL|3
    sta D011
    // main::vicSelectGfxBank1
    // *CIA2_PORT_A_DDR = %00000011
    // [8] *((const byte*) CIA2_PORT_A_DDR#0) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta CIA2_PORT_A_DDR
    // [9] phi from main::vicSelectGfxBank1 to main::vicSelectGfxBank1_toDd001 [phi:main::vicSelectGfxBank1->main::vicSelectGfxBank1_toDd001]
    // main::vicSelectGfxBank1_toDd001
    // main::vicSelectGfxBank1_@1
    // *CIA2_PORT_A = toDd00(gfx)
    // [10] *((const byte*) CIA2_PORT_A#0) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 -- _deref_pbuc1=vbuc2 
    lda #vicSelectGfxBank1_toDd001_return
    sta CIA2_PORT_A
    // [11] phi from main::vicSelectGfxBank1_@1 to main::toD0181 [phi:main::vicSelectGfxBank1_@1->main::toD0181]
    // main::toD0181
    // main::@4
    // *D018 =  toD018(SCREEN, BITMAP)
    // [12] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // bitmap_init(BITMAP)
    // [13] call bitmap_init 
    // [130] phi from main::@4 to bitmap_init [phi:main::@4->bitmap_init]
    jsr bitmap_init
    // [14] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
    // main::@5
    // bitmap_clear()
    // [15] call bitmap_clear 
    jsr bitmap_clear
    // [16] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // main::@6
    // screen_fill(SCREEN, $10)
    // [17] call screen_fill 
    // [109] phi from main::@6 to screen_fill [phi:main::@6->screen_fill]
    jsr screen_fill
    // [18] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
    // [18] phi (byte) main::i#2 = (byte) 0 [phi:main::@6->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    // [18] phi from main::@8 to main::@1 [phi:main::@8->main::@1]
    // [18] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@8->main::@1#0] -- register_copy 
    // main::@1
  b1:
    // point_init(i)
    // [19] (byte) point_init::point_idx#0 ← (byte) main::i#2
    // [20] call point_init 
    jsr point_init
    // main::@7
    // bitmap_plot(x_start[i], y_start[i])
    // [21] (byte~) main::$13 ← (byte) main::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda i
    asl
    // [22] (word) bitmap_plot::x#0 ← *((const word[SIZE#0]) x_start#0 + (byte~) main::$13) -- vwuz1=pwuc1_derefidx_vbuaa 
    tay
    lda x_start,y
    sta bitmap_plot.x
    lda x_start+1,y
    sta bitmap_plot.x+1
    // [23] (byte) bitmap_plot::y#0 ← *((const byte[SIZE#0]) y_start#0 + (byte) main::i#2) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy i
    ldx y_start,y
    // [24] call bitmap_plot 
    jsr bitmap_plot
    // main::@8
    // for( byte i : 0..SIZE-1)
    // [25] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
    // [26] if((byte) main::i#1!=(const byte) SIZE#0-(byte) 1+(byte) 1) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #SIZE-1+1
    cmp i
    bne b1
    // main::@2
  b2:
    // while(*RASTER!=$ff)
    // [27] if(*((const byte*) RASTER#0)!=(byte) $ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    // main::@3
    // (*BORDERCOL)++;
    // [28] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    jmp b2
}
  // bitmap_plot
// Plot a single dot in the bitmap
// bitmap_plot(word zeropage($17) x, byte register(X) y)
bitmap_plot: {
    .label _1 = $1b
    .label x = $17
    .label plotter = $19
    // (byte*) { bitmap_plot_yhi[y], bitmap_plot_ylo[y] }
    // [29] (word) bitmap_plot::plotter#0 ← *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_plot::y#0) w= *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_plot::y#0) -- vwuz1=pbuc1_derefidx_vbuxx_word_pbuc2_derefidx_vbuxx 
    lda bitmap_plot_yhi,x
    sta plotter+1
    lda bitmap_plot_ylo,x
    sta plotter
    // x & $fff8
    // [30] (word~) bitmap_plot::$1 ← (word) bitmap_plot::x#0 & (word) $fff8 -- vwuz1=vwuz2_band_vwuc1 
    lda x
    and #<$fff8
    sta _1
    lda x+1
    and #>$fff8
    sta _1+1
    // plotter += ( x & $fff8 )
    // [31] (byte*) bitmap_plot::plotter#1 ← (byte*)(word) bitmap_plot::plotter#0 + (word~) bitmap_plot::$1 -- pbuz1=pbuz1_plus_vwuz2 
    lda plotter
    clc
    adc _1
    sta plotter
    lda plotter+1
    adc _1+1
    sta plotter+1
    // <x
    // [32] (byte~) bitmap_plot::$2 ← < (word) bitmap_plot::x#0 -- vbuaa=_lo_vwuz1 
    lda x
    // *plotter |= bitmap_plot_bit[<x]
    // [33] *((byte*) bitmap_plot::plotter#1) ← *((byte*) bitmap_plot::plotter#1) | *((const byte[$100]) bitmap_plot_bit#0 + (byte~) bitmap_plot::$2) -- _deref_pbuz1=_deref_pbuz1_bor_pbuc1_derefidx_vbuaa 
    tay
    lda bitmap_plot_bit,y
    ldy #0
    ora (plotter),y
    sta (plotter),y
    // bitmap_plot::@return
    // }
    // [34] return 
    rts
}
  // point_init
// Initialize the points to be animated
// point_init(byte zeropage(2) point_idx)
point_init: {
    .label _3 = 7
    .label _4 = $1d
    .label _9 = $1f
    .label _10 = $21
    .label _11 = $21
    .label point_idx = 2
    .label y_diff = 7
    .label abs16s1_return = 3
    .label abs16s2_return = 5
    .label x_stepf = $b
    .label x_diff = 9
    // (signed word)x_end[point_idx]
    // [35] (byte~) point_init::$18 ← (byte) point_init::point_idx#0 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda point_idx
    asl
    // ((signed word)x_end[point_idx])-((signed word)x_start[point_idx])
    // [36] (signed word) point_init::x_diff#1 ← (signed word)*((const word[SIZE#0]) x_end#0 + (byte~) point_init::$18) - (signed word)*((const word[SIZE#0]) x_start#0 + (byte~) point_init::$18) -- vwsz1=pwsc1_derefidx_vbuaa_minus_pwsc2_derefidx_vbuaa 
    tay
    sec
    lda x_end,y
    sbc x_start,y
    sta x_diff
    lda x_end+1,y
    sbc x_start+1,y
    sta x_diff+1
    // (signed word)y_end[point_idx]
    // [37] (signed word~) point_init::$3 ← (signed word)*((const byte[SIZE#0]) y_end#0 + (byte) point_init::point_idx#0) -- vwsz1=_sword_pbuc1_derefidx_vbuz2 
    ldy point_idx
    lda y_end,y
    sta _3
    lda #0
    sta _3+1
    // (signed word)y_start[point_idx]
    // [38] (signed word~) point_init::$4 ← (signed word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) -- vwsz1=_sword_pbuc1_derefidx_vbuz2 
    lda y_start,y
    sta _4
    lda #0
    sta _4+1
    // y_diff = ((signed word)y_end[point_idx])-((signed word)y_start[point_idx])
    // [39] (signed word) point_init::y_diff#0 ← (signed word~) point_init::$3 - (signed word~) point_init::$4 -- vwsz1=vwsz1_minus_vwsz2 
    lda y_diff
    sec
    sbc _4
    sta y_diff
    lda y_diff+1
    sbc _4+1
    sta y_diff+1
    // point_init::abs16s1
    // if(w<0)
    // [40] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::abs16s1_@1 -- vwsz1_lt_0_then_la1 
    lda x_diff+1
    bpl !abs16s1_b1+
    jmp abs16s1_b1
  !abs16s1_b1:
    // point_init::abs16s1_@3
    // [41] (word~) point_init::abs16s1_return#6 ← (word)(signed word) point_init::x_diff#1 -- vwuz1=vwuz2 
    lda x_diff
    sta abs16s1_return
    lda x_diff+1
    sta abs16s1_return+1
    // [42] phi from point_init::abs16s1_@1 point_init::abs16s1_@3 to point_init::abs16s1_@return [phi:point_init::abs16s1_@1/point_init::abs16s1_@3->point_init::abs16s1_@return]
    // [42] phi (word) point_init::abs16s1_return#2 = (word~) point_init::abs16s1_return#5 [phi:point_init::abs16s1_@1/point_init::abs16s1_@3->point_init::abs16s1_@return#0] -- register_copy 
    // point_init::abs16s1_@return
    // point_init::abs16s2
  abs16s2:
    // if(w<0)
    // [43] if((signed word) point_init::y_diff#0<(signed byte) 0) goto point_init::abs16s2_@1 -- vwsz1_lt_0_then_la1 
    lda y_diff+1
    bpl !abs16s2_b1+
    jmp abs16s2_b1
  !abs16s2_b1:
    // point_init::abs16s2_@3
    // [44] (word~) point_init::abs16s2_return#6 ← (word)(signed word) point_init::y_diff#0 -- vwuz1=vwuz2 
    lda y_diff
    sta abs16s2_return
    lda y_diff+1
    sta abs16s2_return+1
    // [45] phi from point_init::abs16s2_@1 point_init::abs16s2_@3 to point_init::abs16s2_@return [phi:point_init::abs16s2_@1/point_init::abs16s2_@3->point_init::abs16s2_@return]
    // [45] phi (word) point_init::abs16s2_return#2 = (word~) point_init::abs16s2_return#5 [phi:point_init::abs16s2_@1/point_init::abs16s2_@3->point_init::abs16s2_@return#0] -- register_copy 
    // point_init::abs16s2_@return
    // point_init::@6
  b6:
    // if(abs16s(x_diff)>abs16s(y_diff))
    // [46] if((word) point_init::abs16s1_return#2>(word) point_init::abs16s2_return#2) goto point_init::@1 -- vwuz1_gt_vwuz2_then_la1 
    lda abs16s2_return+1
    cmp abs16s1_return+1
    bcc b1
    bne !+
    lda abs16s2_return
    cmp abs16s1_return
    bcc b1
  !:
    // point_init::@2
  b2:
    // x_start[point_idx]*$10
    // [47] (byte~) point_init::$20 ← (byte) point_init::point_idx#0 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda point_idx
    asl
    tax
    // [48] (word~) point_init::$9 ← *((const word[SIZE#0]) x_start#0 + (byte~) point_init::$20) << (byte) 4 -- vwuz1=pwuc1_derefidx_vbuxx_rol_4 
    lda x_start,x
    sta _9
    lda x_start+1,x
    sta _9+1
    asl _9
    rol _9+1
    asl _9
    rol _9+1
    asl _9
    rol _9+1
    asl _9
    rol _9+1
    // x_cur[point_idx] = x_start[point_idx]*$10
    // [49] *((const word[SIZE#0]) x_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$9 -- pwuc1_derefidx_vbuxx=vwuz1 
    lda _9
    sta x_cur,x
    lda _9+1
    sta x_cur+1,x
    // (word)y_start[point_idx]
    // [50] (word~) point_init::$10 ← (word)*((const byte[SIZE#0]) y_start#0 + (byte) point_init::point_idx#0) -- vwuz1=_word_pbuc1_derefidx_vbuz2 
    ldy point_idx
    lda y_start,y
    sta _10
    lda #0
    sta _10+1
    // ((word)y_start[point_idx])*$10
    // [51] (word~) point_init::$11 ← (word~) point_init::$10 << (byte) 4 -- vwuz1=vwuz1_rol_4 
    asl _11
    rol _11+1
    asl _11
    rol _11+1
    asl _11
    rol _11+1
    asl _11
    rol _11+1
    // y_cur[point_idx] = ((word)y_start[point_idx])*$10
    // [52] *((const word[SIZE#0]) y_cur#0 + (byte~) point_init::$20) ← (word~) point_init::$11 -- pwuc1_derefidx_vbuxx=vwuz1 
    lda _11
    sta y_cur,x
    lda _11+1
    sta y_cur+1,x
    // delay[point_idx] = DELAY
    // [53] *((const byte[SIZE#0]) delay#0 + (byte) point_init::point_idx#0) ← (const byte) DELAY#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #DELAY
    sta delay,y
    // point_init::@return
    // }
    // [54] return 
    rts
    // point_init::@1
  b1:
    // if(x_diff<0)
    // [55] if((signed word) point_init::x_diff#1<(signed byte) 0) goto point_init::@4 -- vwsz1_lt_0_then_la1 
    // X is driver - abs(y/x) is < 1
    lda x_diff+1
    bmi b4
    // point_init::@3
    // x_add[point_idx] = $10
    // [56] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) $10 -- pbsc1_derefidx_vbuz1=vbsc2 
    // x add = 1.0
    lda #$10
    ldy point_idx
    sta x_add,y
    // point_init::@5
  b5:
    // divr16s(0, x_diff, y_diff)
    // [57] (signed word) divr16s::divisor#0 ← (signed word) point_init::x_diff#1
    // [58] (signed word) divr16s::rem#0 ← (signed word) point_init::y_diff#0
    // [59] call divr16s 
    // [70] phi from point_init::@5 to divr16s [phi:point_init::@5->divr16s]
    jsr divr16s
    // divr16s(0, x_diff, y_diff)
    // [60] (signed word) divr16s::return#3 ← (signed word) divr16s::return#2
    // point_init::@7
    // x_stepf = divr16s(0, x_diff, y_diff)
    // [61] (signed word) point_init::x_stepf#0 ← (signed word) divr16s::return#3
    // >x_stepf
    // [62] (byte~) point_init::$14 ← > (signed word) point_init::x_stepf#0 -- vbuaa=_hi_vwsz1 
    lda x_stepf+1
    // (>x_stepf)/$10
    // [63] (byte~) point_init::$16 ← (byte~) point_init::$14 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // y_add[point_idx] = (signed byte)((>x_stepf)/$10)
    // [64] *((const signed byte[SIZE#0]) y_add#0 + (byte) point_init::point_idx#0) ← (signed byte)(byte~) point_init::$16 -- pbsc1_derefidx_vbuz1=vbsaa 
    ldy point_idx
    sta y_add,y
    jmp b2
    // point_init::@4
  b4:
    // x_add[point_idx] = -$10
    // [65] *((const signed byte[SIZE#0]) x_add#0 + (byte) point_init::point_idx#0) ← (signed byte) -$10 -- pbsc1_derefidx_vbuz1=vbsc2 
    // x add = -1.0
    lda #-$10
    ldy point_idx
    sta x_add,y
    jmp b5
    // point_init::abs16s2_@1
  abs16s2_b1:
    // -w
    // [66] (signed word) point_init::abs16s2_return#0 ← - (signed word) point_init::y_diff#0 -- vwsz1=_neg_vwsz2 
    sec
    lda #0
    sbc y_diff
    sta abs16s2_return
    lda #0
    sbc y_diff+1
    sta abs16s2_return+1
    // [67] (word~) point_init::abs16s2_return#5 ← (word)(signed word) point_init::abs16s2_return#0
    jmp b6
    // point_init::abs16s1_@1
  abs16s1_b1:
    // -w
    // [68] (signed word) point_init::abs16s1_return#0 ← - (signed word) point_init::x_diff#1 -- vwsz1=_neg_vwsz2 
    sec
    lda #0
    sbc x_diff
    sta abs16s1_return
    lda #0
    sbc x_diff+1
    sta abs16s1_return+1
    // [69] (word~) point_init::abs16s1_return#5 ← (word)(signed word) point_init::abs16s1_return#0
    jmp abs16s2
}
  // divr16s
// Perform division on two signed 16-bit numbers with an initial remainder.
// Returns dividend/divisor. The remainder will be set into the global variable rem16s.
// Implemented using simple binary division
// Follows the C99 standard by truncating toward zero on negative results.
// See http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf section 6.5.5
// divr16s(signed word zeropage(9) divisor, signed word zeropage(7) rem)
divr16s: {
    .label remu = 7
    .label divisoru = 9
    .label resultu = $b
    .label return = $b
    .label divisor = 9
    .label rem = 7
    // divr16s::@10
    // if(dividend<0 || rem<0)
    // [71] if((signed word) divr16s::rem#0<(signed byte) 0) goto divr16s::@1 -- vwsz1_lt_0_then_la1 
    lda rem+1
    bmi b1
    // divr16s::@6
    // [72] (word~) divr16s::remu#8 ← (word)(signed word) divr16s::rem#0
    // [73] phi from divr16s::@6 to divr16s::@2 [phi:divr16s::@6->divr16s::@2]
    // [73] phi (word) divr16s::remu#3 = (word~) divr16s::remu#8 [phi:divr16s::@6->divr16s::@2#0] -- register_copy 
    // [73] phi (byte) divr16s::neg#3 = (byte) 0 [phi:divr16s::@6->divr16s::@2#1] -- vbuyy=vbuc1 
    ldy #0
    // divr16s::@2
  b2:
    // if(divisor<0)
    // [74] if((signed word) divr16s::divisor#0<(signed byte) 0) goto divr16s::@3 -- vwsz1_lt_0_then_la1 
    lda divisor+1
    bmi b3
    // divr16s::@7
    // [75] (word~) divr16s::divisoru#5 ← (word)(signed word) divr16s::divisor#0
    // [76] phi from divr16s::@3 divr16s::@7 to divr16s::@4 [phi:divr16s::@3/divr16s::@7->divr16s::@4]
    // [76] phi (byte) divr16s::neg#4 = (byte) divr16s::neg#2 [phi:divr16s::@3/divr16s::@7->divr16s::@4#0] -- register_copy 
    // [76] phi (word) divr16s::divisoru#3 = (word~) divr16s::divisoru#4 [phi:divr16s::@3/divr16s::@7->divr16s::@4#1] -- register_copy 
    // divr16s::@4
  b4:
    // divr16u(dividendu, divisoru, remu)
    // [77] (word) divr16u::divisor#0 ← (word) divr16s::divisoru#3
    // [78] (word) divr16u::rem#3 ← (word) divr16s::remu#3
    // [79] call divr16u 
    // [92] phi from divr16s::@4 to divr16u [phi:divr16s::@4->divr16u]
    jsr divr16u
    // divr16u(dividendu, divisoru, remu)
    // [80] (word) divr16u::return#2 ← (word) divr16u::return#0
    // divr16s::@9
    // resultu = divr16u(dividendu, divisoru, remu)
    // [81] (word) divr16s::resultu#0 ← (word) divr16u::return#2
    // if(neg==0)
    // [82] if((byte) divr16s::neg#4==(byte) 0) goto divr16s::@5 -- vbuyy_eq_0_then_la1 
    cpy #0
    beq breturn
    // divr16s::@8
    // return -(signed word)resultu;
    // [83] (signed word) divr16s::return#1 ← - (signed word)(word) divr16s::resultu#0 -- vwsz1=_neg_vwsz1 
    sec
    lda #0
    sbc return
    sta return
    lda #0
    sbc return+1
    sta return+1
    // [84] phi from divr16s::@5 divr16s::@8 to divr16s::@return [phi:divr16s::@5/divr16s::@8->divr16s::@return]
    // [84] phi (signed word) divr16s::return#2 = (signed word~) divr16s::return#7 [phi:divr16s::@5/divr16s::@8->divr16s::@return#0] -- register_copy 
    // divr16s::@return
  breturn:
    // }
    // [85] return 
    rts
    // divr16s::@5
    // [86] (signed word~) divr16s::return#7 ← (signed word)(word) divr16s::resultu#0
    // divr16s::@3
  b3:
    // -divisor
    // [87] (signed word) divr16s::divisoru#1 ← - (signed word) divr16s::divisor#0 -- vwsz1=_neg_vwsz1 
    sec
    lda #0
    sbc divisoru
    sta divisoru
    lda #0
    sbc divisoru+1
    sta divisoru+1
    // neg = neg ^ 1
    // [88] (byte) divr16s::neg#2 ← (byte) divr16s::neg#3 ^ (byte) 1 -- vbuyy=vbuyy_bxor_vbuc1 
    tya
    eor #1
    tay
    // [89] (word~) divr16s::divisoru#4 ← (word)(signed word) divr16s::divisoru#1
    jmp b4
    // divr16s::@1
  b1:
    // -rem
    // [90] (signed word) divr16s::remu#1 ← - (signed word) divr16s::rem#0 -- vwsz1=_neg_vwsz1 
    sec
    lda #0
    sbc remu
    sta remu
    lda #0
    sbc remu+1
    sta remu+1
    // [91] (word~) divr16s::remu#7 ← (word)(signed word) divr16s::remu#1
    // [73] phi from divr16s::@1 to divr16s::@2 [phi:divr16s::@1->divr16s::@2]
    // [73] phi (word) divr16s::remu#3 = (word~) divr16s::remu#7 [phi:divr16s::@1->divr16s::@2#0] -- register_copy 
    // [73] phi (byte) divr16s::neg#3 = (byte) 1 [phi:divr16s::@1->divr16s::@2#1] -- vbuyy=vbuc1 
    ldy #1
    jmp b2
}
  // divr16u
// Performs division on two 16 bit unsigned words and an initial remainder
// Returns the quotient dividend/divisor.
// The final remainder will be set into the global variable rem16u
// Implemented using simple binary division
// divr16u(word zeropage($d) dividend, word zeropage(9) divisor, word zeropage(7) rem)
divr16u: {
    .label rem = 7
    .label dividend = $d
    .label quotient = $b
    .label return = $b
    .label divisor = 9
    // [93] phi from divr16u to divr16u::@1 [phi:divr16u->divr16u::@1]
    // [93] phi (byte) divr16u::i#2 = (byte) 0 [phi:divr16u->divr16u::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [93] phi (word) divr16u::quotient#3 = (byte) 0 [phi:divr16u->divr16u::@1#1] -- vwuz1=vbuc1 
    txa
    sta quotient
    sta quotient+1
    // [93] phi (word) divr16u::dividend#2 = (word) 0 [phi:divr16u->divr16u::@1#2] -- vwuz1=vwuc1 
    sta dividend
    sta dividend+1
    // [93] phi (word) divr16u::rem#4 = (word) divr16u::rem#3 [phi:divr16u->divr16u::@1#3] -- register_copy 
    // [93] phi from divr16u::@3 to divr16u::@1 [phi:divr16u::@3->divr16u::@1]
    // [93] phi (byte) divr16u::i#2 = (byte) divr16u::i#1 [phi:divr16u::@3->divr16u::@1#0] -- register_copy 
    // [93] phi (word) divr16u::quotient#3 = (word) divr16u::return#0 [phi:divr16u::@3->divr16u::@1#1] -- register_copy 
    // [93] phi (word) divr16u::dividend#2 = (word) divr16u::dividend#0 [phi:divr16u::@3->divr16u::@1#2] -- register_copy 
    // [93] phi (word) divr16u::rem#4 = (word) divr16u::rem#9 [phi:divr16u::@3->divr16u::@1#3] -- register_copy 
    // divr16u::@1
  b1:
    // rem = rem << 1
    // [94] (word) divr16u::rem#0 ← (word) divr16u::rem#4 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl rem
    rol rem+1
    // >dividend
    // [95] (byte~) divr16u::$1 ← > (word) divr16u::dividend#2 -- vbuaa=_hi_vwuz1 
    lda dividend+1
    // >dividend & $80
    // [96] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // if( (>dividend & $80) != 0 )
    // [97] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b2
    // divr16u::@4
    // rem = rem | 1
    // [98] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 -- vwuz1=vwuz1_bor_vbuc1 
    lda #1
    ora rem
    sta rem
    // [99] phi from divr16u::@1 divr16u::@4 to divr16u::@2 [phi:divr16u::@1/divr16u::@4->divr16u::@2]
    // [99] phi (word) divr16u::rem#5 = (word) divr16u::rem#0 [phi:divr16u::@1/divr16u::@4->divr16u::@2#0] -- register_copy 
    // divr16u::@2
  b2:
    // dividend = dividend << 1
    // [100] (word) divr16u::dividend#0 ← (word) divr16u::dividend#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl dividend
    rol dividend+1
    // quotient = quotient << 1
    // [101] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl quotient
    rol quotient+1
    // if(rem>=divisor)
    // [102] if((word) divr16u::rem#5<(word) divr16u::divisor#0) goto divr16u::@3 -- vwuz1_lt_vwuz2_then_la1 
    lda rem+1
    cmp divisor+1
    bcc b3
    bne !+
    lda rem
    cmp divisor
    bcc b3
  !:
    // divr16u::@5
    // quotient++;
    // [103] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1 -- vwuz1=_inc_vwuz1 
    inc quotient
    bne !+
    inc quotient+1
  !:
    // rem = rem - divisor
    // [104] (word) divr16u::rem#2 ← (word) divr16u::rem#5 - (word) divr16u::divisor#0 -- vwuz1=vwuz1_minus_vwuz2 
    lda rem
    sec
    sbc divisor
    sta rem
    lda rem+1
    sbc divisor+1
    sta rem+1
    // [105] phi from divr16u::@2 divr16u::@5 to divr16u::@3 [phi:divr16u::@2/divr16u::@5->divr16u::@3]
    // [105] phi (word) divr16u::return#0 = (word) divr16u::quotient#1 [phi:divr16u::@2/divr16u::@5->divr16u::@3#0] -- register_copy 
    // [105] phi (word) divr16u::rem#9 = (word) divr16u::rem#5 [phi:divr16u::@2/divr16u::@5->divr16u::@3#1] -- register_copy 
    // divr16u::@3
  b3:
    // for( byte i : 0..15)
    // [106] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [107] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$10
    bne b1
    // divr16u::@return
    // }
    // [108] return 
    rts
}
  // screen_fill
// Fill the screen with a specific char
// screen_fill(byte* zeropage($10) screen)
screen_fill: {
    .const ch = $10
    .label screen = $10
    .label y = $f
    // [110] phi from screen_fill to screen_fill::@1 [phi:screen_fill->screen_fill::@1]
    // [110] phi (byte) screen_fill::y#4 = (byte) 0 [phi:screen_fill->screen_fill::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    // [110] phi (byte*) screen_fill::screen#3 = (const byte*) SCREEN#0 [phi:screen_fill->screen_fill::@1#1] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta screen
    lda #>SCREEN
    sta screen+1
    // [110] phi from screen_fill::@3 to screen_fill::@1 [phi:screen_fill::@3->screen_fill::@1]
    // [110] phi (byte) screen_fill::y#4 = (byte) screen_fill::y#1 [phi:screen_fill::@3->screen_fill::@1#0] -- register_copy 
    // [110] phi (byte*) screen_fill::screen#3 = (byte*) screen_fill::screen#1 [phi:screen_fill::@3->screen_fill::@1#1] -- register_copy 
    // screen_fill::@1
  b1:
    // [111] phi from screen_fill::@1 to screen_fill::@2 [phi:screen_fill::@1->screen_fill::@2]
    // [111] phi (byte) screen_fill::x#2 = (byte) 0 [phi:screen_fill::@1->screen_fill::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [111] phi (byte*) screen_fill::screen#2 = (byte*) screen_fill::screen#3 [phi:screen_fill::@1->screen_fill::@2#1] -- register_copy 
    // [111] phi from screen_fill::@2 to screen_fill::@2 [phi:screen_fill::@2->screen_fill::@2]
    // [111] phi (byte) screen_fill::x#2 = (byte) screen_fill::x#1 [phi:screen_fill::@2->screen_fill::@2#0] -- register_copy 
    // [111] phi (byte*) screen_fill::screen#2 = (byte*) screen_fill::screen#1 [phi:screen_fill::@2->screen_fill::@2#1] -- register_copy 
    // screen_fill::@2
  b2:
    // *screen++ = ch
    // [112] *((byte*) screen_fill::screen#2) ← (const byte) screen_fill::ch#0 -- _deref_pbuz1=vbuc1 
    lda #ch
    ldy #0
    sta (screen),y
    // *screen++ = ch;
    // [113] (byte*) screen_fill::screen#1 ← ++ (byte*) screen_fill::screen#2 -- pbuz1=_inc_pbuz1 
    inc screen
    bne !+
    inc screen+1
  !:
    // for(byte x:0..39)
    // [114] (byte) screen_fill::x#1 ← ++ (byte) screen_fill::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [115] if((byte) screen_fill::x#1!=(byte) $28) goto screen_fill::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne b2
    // screen_fill::@3
    // for( byte y: 0..24)
    // [116] (byte) screen_fill::y#1 ← ++ (byte) screen_fill::y#4 -- vbuz1=_inc_vbuz1 
    inc y
    // [117] if((byte) screen_fill::y#1!=(byte) $19) goto screen_fill::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp y
    bne b1
    // screen_fill::@return
    // }
    // [118] return 
    rts
}
  // bitmap_clear
// Clear all graphics on the bitmap
bitmap_clear: {
    .label bitmap = $13
    .label y = $12
    // (byte*) { bitmap_plot_yhi[0], bitmap_plot_ylo[0] }
    // [119] (word) bitmap_clear::bitmap#0 ← *((const byte[$100]) bitmap_plot_yhi#0) w= *((const byte[$100]) bitmap_plot_ylo#0) -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda bitmap_plot_ylo
    sta bitmap
    lda bitmap_plot_yhi
    sta bitmap+1
    // [120] (byte*~) bitmap_clear::bitmap#5 ← (byte*)(word) bitmap_clear::bitmap#0
    // [121] phi from bitmap_clear to bitmap_clear::@1 [phi:bitmap_clear->bitmap_clear::@1]
    // [121] phi (byte) bitmap_clear::y#4 = (byte) 0 [phi:bitmap_clear->bitmap_clear::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    // [121] phi (byte*) bitmap_clear::bitmap#3 = (byte*~) bitmap_clear::bitmap#5 [phi:bitmap_clear->bitmap_clear::@1#1] -- register_copy 
    // [121] phi from bitmap_clear::@3 to bitmap_clear::@1 [phi:bitmap_clear::@3->bitmap_clear::@1]
    // [121] phi (byte) bitmap_clear::y#4 = (byte) bitmap_clear::y#1 [phi:bitmap_clear::@3->bitmap_clear::@1#0] -- register_copy 
    // [121] phi (byte*) bitmap_clear::bitmap#3 = (byte*) bitmap_clear::bitmap#1 [phi:bitmap_clear::@3->bitmap_clear::@1#1] -- register_copy 
    // bitmap_clear::@1
  b1:
    // [122] phi from bitmap_clear::@1 to bitmap_clear::@2 [phi:bitmap_clear::@1->bitmap_clear::@2]
    // [122] phi (byte) bitmap_clear::x#2 = (byte) 0 [phi:bitmap_clear::@1->bitmap_clear::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [122] phi (byte*) bitmap_clear::bitmap#2 = (byte*) bitmap_clear::bitmap#3 [phi:bitmap_clear::@1->bitmap_clear::@2#1] -- register_copy 
    // [122] phi from bitmap_clear::@2 to bitmap_clear::@2 [phi:bitmap_clear::@2->bitmap_clear::@2]
    // [122] phi (byte) bitmap_clear::x#2 = (byte) bitmap_clear::x#1 [phi:bitmap_clear::@2->bitmap_clear::@2#0] -- register_copy 
    // [122] phi (byte*) bitmap_clear::bitmap#2 = (byte*) bitmap_clear::bitmap#1 [phi:bitmap_clear::@2->bitmap_clear::@2#1] -- register_copy 
    // bitmap_clear::@2
  b2:
    // *bitmap++ = 0
    // [123] *((byte*) bitmap_clear::bitmap#2) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (bitmap),y
    // *bitmap++ = 0;
    // [124] (byte*) bitmap_clear::bitmap#1 ← ++ (byte*) bitmap_clear::bitmap#2 -- pbuz1=_inc_pbuz1 
    inc bitmap
    bne !+
    inc bitmap+1
  !:
    // for( byte x: 0..199 )
    // [125] (byte) bitmap_clear::x#1 ← ++ (byte) bitmap_clear::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [126] if((byte) bitmap_clear::x#1!=(byte) $c8) goto bitmap_clear::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$c8
    bne b2
    // bitmap_clear::@3
    // for( byte y: 0..39 )
    // [127] (byte) bitmap_clear::y#1 ← ++ (byte) bitmap_clear::y#4 -- vbuz1=_inc_vbuz1 
    inc y
    // [128] if((byte) bitmap_clear::y#1!=(byte) $28) goto bitmap_clear::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp y
    bne b1
    // bitmap_clear::@return
    // }
    // [129] return 
    rts
}
  // bitmap_init
bitmap_init: {
    .label _7 = $23
    .label yoffs = $15
    // [131] phi from bitmap_init to bitmap_init::@1 [phi:bitmap_init->bitmap_init::@1]
    // [131] phi (byte) bitmap_init::x#2 = (byte) 0 [phi:bitmap_init->bitmap_init::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [131] phi (byte) bitmap_init::bits#3 = (byte) $80 [phi:bitmap_init->bitmap_init::@1#1] -- vbuaa=vbuc1 
    lda #$80
    // [131] phi from bitmap_init::@2 to bitmap_init::@1 [phi:bitmap_init::@2->bitmap_init::@1]
    // [131] phi (byte) bitmap_init::x#2 = (byte) bitmap_init::x#1 [phi:bitmap_init::@2->bitmap_init::@1#0] -- register_copy 
    // [131] phi (byte) bitmap_init::bits#3 = (byte) bitmap_init::bits#4 [phi:bitmap_init::@2->bitmap_init::@1#1] -- register_copy 
    // bitmap_init::@1
  b1:
    // bitmap_plot_bit[x] = bits
    // [132] *((const byte[$100]) bitmap_plot_bit#0 + (byte) bitmap_init::x#2) ← (byte) bitmap_init::bits#3 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta bitmap_plot_bit,x
    // bits >>= 1
    // [133] (byte) bitmap_init::bits#1 ← (byte) bitmap_init::bits#3 >> (byte) 1 -- vbuaa=vbuaa_ror_1 
    lsr
    // if(bits==0)
    // [134] if((byte) bitmap_init::bits#1!=(byte) 0) goto bitmap_init::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b2
    // [136] phi from bitmap_init::@1 to bitmap_init::@2 [phi:bitmap_init::@1->bitmap_init::@2]
    // [136] phi (byte) bitmap_init::bits#4 = (byte) $80 [phi:bitmap_init::@1->bitmap_init::@2#0] -- vbuaa=vbuc1 
    lda #$80
    // [135] phi from bitmap_init::@1 to bitmap_init::@6 [phi:bitmap_init::@1->bitmap_init::@6]
    // bitmap_init::@6
    // [136] phi from bitmap_init::@6 to bitmap_init::@2 [phi:bitmap_init::@6->bitmap_init::@2]
    // [136] phi (byte) bitmap_init::bits#4 = (byte) bitmap_init::bits#1 [phi:bitmap_init::@6->bitmap_init::@2#0] -- register_copy 
    // bitmap_init::@2
  b2:
    // for(byte x : 0..255)
    // [137] (byte) bitmap_init::x#1 ← ++ (byte) bitmap_init::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [138] if((byte) bitmap_init::x#1!=(byte) 0) goto bitmap_init::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b1
    // [139] phi from bitmap_init::@2 to bitmap_init::@3 [phi:bitmap_init::@2->bitmap_init::@3]
    // [139] phi (byte*) bitmap_init::yoffs#2 = (const byte*) BITMAP#0 [phi:bitmap_init::@2->bitmap_init::@3#0] -- pbuz1=pbuc1 
    lda #<BITMAP
    sta yoffs
    lda #>BITMAP
    sta yoffs+1
    // [139] phi (byte) bitmap_init::y#2 = (byte) 0 [phi:bitmap_init::@2->bitmap_init::@3#1] -- vbuxx=vbuc1 
    ldx #0
    // [139] phi from bitmap_init::@4 to bitmap_init::@3 [phi:bitmap_init::@4->bitmap_init::@3]
    // [139] phi (byte*) bitmap_init::yoffs#2 = (byte*) bitmap_init::yoffs#4 [phi:bitmap_init::@4->bitmap_init::@3#0] -- register_copy 
    // [139] phi (byte) bitmap_init::y#2 = (byte) bitmap_init::y#1 [phi:bitmap_init::@4->bitmap_init::@3#1] -- register_copy 
    // bitmap_init::@3
  b3:
    // y&$7
    // [140] (byte~) bitmap_init::$7 ← (byte) bitmap_init::y#2 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax _7
    // <yoffs
    // [141] (byte~) bitmap_init::$4 ← < (byte*) bitmap_init::yoffs#2 -- vbuaa=_lo_pbuz1 
    lda yoffs
    // y&$7 | <yoffs
    // [142] (byte~) bitmap_init::$5 ← (byte~) bitmap_init::$7 | (byte~) bitmap_init::$4 -- vbuaa=vbuz1_bor_vbuaa 
    ora _7
    // bitmap_plot_ylo[y] = y&$7 | <yoffs
    // [143] *((const byte[$100]) bitmap_plot_ylo#0 + (byte) bitmap_init::y#2) ← (byte~) bitmap_init::$5 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta bitmap_plot_ylo,x
    // >yoffs
    // [144] (byte~) bitmap_init::$6 ← > (byte*) bitmap_init::yoffs#2 -- vbuaa=_hi_pbuz1 
    lda yoffs+1
    // bitmap_plot_yhi[y] = >yoffs
    // [145] *((const byte[$100]) bitmap_plot_yhi#0 + (byte) bitmap_init::y#2) ← (byte~) bitmap_init::$6 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta bitmap_plot_yhi,x
    // if((y&$7)==7)
    // [146] if((byte~) bitmap_init::$7!=(byte) 7) goto bitmap_init::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #7
    cmp _7
    bne b4
    // bitmap_init::@5
    // yoffs = yoffs + 40*8
    // [147] (byte*) bitmap_init::yoffs#1 ← (byte*) bitmap_init::yoffs#2 + (word)(number) $28*(number) 8 -- pbuz1=pbuz1_plus_vwuc1 
    clc
    lda yoffs
    adc #<$28*8
    sta yoffs
    lda yoffs+1
    adc #>$28*8
    sta yoffs+1
    // [148] phi from bitmap_init::@3 bitmap_init::@5 to bitmap_init::@4 [phi:bitmap_init::@3/bitmap_init::@5->bitmap_init::@4]
    // [148] phi (byte*) bitmap_init::yoffs#4 = (byte*) bitmap_init::yoffs#2 [phi:bitmap_init::@3/bitmap_init::@5->bitmap_init::@4#0] -- register_copy 
    // bitmap_init::@4
  b4:
    // for(byte y : 0..255)
    // [149] (byte) bitmap_init::y#1 ← ++ (byte) bitmap_init::y#2 -- vbuxx=_inc_vbuxx 
    inx
    // [150] if((byte) bitmap_init::y#1!=(byte) 0) goto bitmap_init::@3 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b3
    // bitmap_init::@return
    // }
    // [151] return 
    rts
}
  // File Data
  // The coordinates of the lines to animate
  x_start: .word $a, $14, $1e, $1e
  y_start: .byte $a, $a, $a, $14
  x_end: .word $14, $a, $14, $14
  y_end: .byte $14, $14, $a, $14
  // Tables for the plotter - initialized by calling bitmap_init();
  bitmap_plot_ylo: .fill $100, 0
  bitmap_plot_yhi: .fill $100, 0
  bitmap_plot_bit: .fill $100, 0
  // Current x position fixed point [12.4]
  x_cur: .fill 2*SIZE, 0
  // Current y position fixed point [12.4]
  y_cur: .fill 2*SIZE, 0
  // X position addition per frame s[3.4]
  x_add: .fill SIZE, 0
  // Y position addition per frame s[3.4]
  y_add: .fill SIZE, 0
  // Frame delay (counted down to 0)
  delay: .fill SIZE, 0

