Resolved forward reference c2 to (volatile byte) c2

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (volatile byte) c1 ← (byte) 'x'
  to:@4

(void()) main()
main: scope:[main]  from @3
  *((const nomodify byte*) SCREEN + (number) 0) ← (volatile byte) c1
  *((const nomodify byte*) SCREEN + (number) 0) ← (volatile byte) c2
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
@4: scope:[]  from @begin
  if((const nomodify byte*) SCREEN>(number) $3e8) goto @1
  to:@2
@1: scope:[]  from @4
  (byte~) $1 ← (byte) 's'
  to:@3
@2: scope:[]  from @4
  (byte~) $0 ← (byte) 'm'
  to:@3
@3: scope:[]  from @1 @2
  (byte~) $2 ← phi( @1/(byte~) $1 @2/(byte~) $0 )
  (volatile byte) c2 ← (byte~) $2
  call main 
  to:@5
@5: scope:[]  from @3
  to:@end
@end: scope:[]  from @5

SYMBOL TABLE SSA
(byte~) $0
(byte~) $1
(byte~) $2
(label) @1
(label) @2
(label) @3
(label) @4
(label) @5
(label) @begin
(label) @end
(const nomodify byte*) SCREEN = (byte*)(number) $400
(volatile byte) c1 loadstore
(volatile byte) c2 loadstore
(void()) main()
(label) main::@return

Adding number conversion cast (unumber) 0 in *((const nomodify byte*) SCREEN + (number) 0) ← (volatile byte) c1
Adding number conversion cast (unumber) 0 in *((const nomodify byte*) SCREEN + (number) 0) ← (volatile byte) c2
Adding number conversion cast (unumber) $3e8 in if((const nomodify byte*) SCREEN>(number) $3e8) goto @1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $3e8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3e8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)c2 = $2 
Constant (const byte) $1 = 's'
Constant (const byte) $0 = 'm'
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [4] if((const nomodify byte*) SCREEN>(word) $3e8) goto @1
Successful SSA optimization Pass2ConstantIfs
Simplifying expression containing zero SCREEN in [1] *((const nomodify byte*) SCREEN + (byte) 0) ← (volatile byte) c1
Simplifying expression containing zero SCREEN in [2] *((const nomodify byte*) SCREEN + (byte) 0) ← (volatile byte) c2
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing PHI-reference to removed block (@2) in block @3
Removing unused block @2
Successful SSA optimization Pass2EliminateUnusedBlocks
Alias candidate removed (volatile)c2 = $2 
Identical Phi Values (byte~) $2 (const byte) $1
Successful SSA optimization Pass2IdenticalPhiElimination
Eliminating unused constant (const byte) $0
Successful SSA optimization PassNEliminateUnusedVars
Constant inlined $1 = (byte) 's'
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @4
Adding NOP phi() at start of @1
Adding NOP phi() at start of @5
Adding NOP phi() at start of @end
CALL GRAPH
Calls in [] to main:4 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @1
Culled Empty Block (label) @5
Renumbering block @3 to @1
Adding NOP phi() at start of @end

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] (volatile byte) c1 ← (byte) 'x'
  to:@1
@1: scope:[]  from @begin
  [1] (volatile byte) c2 ← (byte) 's'
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] *((const nomodify byte*) SCREEN) ← (volatile byte) c1
  [5] *((const nomodify byte*) SCREEN) ← (volatile byte) c2
  to:main::@return
main::@return: scope:[main]  from main
  [6] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(volatile byte) c1 loadstore 6.5
(volatile byte) c2 loadstore 6.5
(void()) main()

Initial phi equivalence classes
Added variable c1 to live range equivalence class [ c1 ]
Added variable c2 to live range equivalence class [ c2 ]
Complete equivalence classes
[ c1 ]
[ c2 ]
Allocated zp[1]:2 [ c1 ]
Allocated zp[1]:3 [ c2 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Tests static initialization code
// Currently placed outside any function scope and pushed into @begin block.
// To be put into an initializer function.
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label c1 = 2
  .label c2 = 3
  // @begin
__bbegin:
  // [0] (volatile byte) c1 ← (byte) 'x' -- vbuz1=vbuc1 
  // Initialize a volatile ZP-variable (will be done in the initializer)
  lda #'x'
  sta.z c1
  jmp __b1
  // @1
__b1:
  // [1] (volatile byte) c2 ← (byte) 's' -- vbuz1=vbuc1 
  // Initialize another volatile ZP-variable (will be done in the initializer)
  lda #'s'
  sta.z c2
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // [4] *((const nomodify byte*) SCREEN) ← (volatile byte) c1 -- _deref_pbuc1=vbuz1 
    lda.z c1
    sta SCREEN
    // [5] *((const nomodify byte*) SCREEN) ← (volatile byte) c2 -- _deref_pbuc1=vbuz1 
    lda.z c2
    sta SCREEN
    jmp __breturn
    // main::@return
  __breturn:
    // [6] return 
    rts
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] (volatile byte) c1 ← (byte) 'x' [ c1 ] (  [ c1 ] { }  ) always clobbers reg byte a 
Statement [1] (volatile byte) c2 ← (byte) 's' [ c1 c2 ] (  [ c1 c2 ] { }  ) always clobbers reg byte a 
Statement [4] *((const nomodify byte*) SCREEN) ← (volatile byte) c1 [ c2 ] ( main:2 [ c2 ] { }  ) always clobbers reg byte a 
Statement [5] *((const nomodify byte*) SCREEN) ← (volatile byte) c2 [ ] ( main:2 [ ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ c1 ] : zp[1]:2 , 
Potential registers zp[1]:3 [ c2 ] : zp[1]:3 , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 6.5: zp[1]:2 [ c1 ] 6.5: zp[1]:3 [ c2 ] 
Uplift Scope [main] 

Uplifting [] best 45 combination zp[1]:2 [ c1 ] zp[1]:3 [ c2 ] 
Uplifting [main] best 45 combination 
Attempting to uplift remaining variables inzp[1]:2 [ c1 ]
Uplifting [] best 45 combination zp[1]:2 [ c1 ] 
Attempting to uplift remaining variables inzp[1]:3 [ c2 ]
Uplifting [] best 45 combination zp[1]:3 [ c2 ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests static initialization code
// Currently placed outside any function scope and pushed into @begin block.
// To be put into an initializer function.
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label c1 = 2
  .label c2 = 3
  // @begin
__bbegin:
  // [0] (volatile byte) c1 ← (byte) 'x' -- vbuz1=vbuc1 
  // Initialize a volatile ZP-variable (will be done in the initializer)
  lda #'x'
  sta.z c1
  jmp __b1
  // @1
__b1:
  // [1] (volatile byte) c2 ← (byte) 's' -- vbuz1=vbuc1 
  // Initialize another volatile ZP-variable (will be done in the initializer)
  lda #'s'
  sta.z c2
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // [4] *((const nomodify byte*) SCREEN) ← (volatile byte) c1 -- _deref_pbuc1=vbuz1 
    lda.z c1
    sta SCREEN
    // [5] *((const nomodify byte*) SCREEN) ← (volatile byte) c2 -- _deref_pbuc1=vbuz1 
    lda.z c2
    sta SCREEN
    jmp __breturn
    // main::@return
  __breturn:
    // [6] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __bend_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1:
Removing instruction __bend:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const nomodify byte*) SCREEN = (byte*) 1024
(volatile byte) c1 loadstore zp[1]:2 6.5
(volatile byte) c2 loadstore zp[1]:3 6.5
(void()) main()
(label) main::@return

zp[1]:2 [ c1 ]
zp[1]:3 [ c2 ]


FINAL ASSEMBLER
Score: 42

  // File Comments
// Tests static initialization code
// Currently placed outside any function scope and pushed into @begin block.
// To be put into an initializer function.
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label c1 = 2
  .label c2 = 3
  // @begin
__bbegin:
  // c1 = 'x'
  // [0] (volatile byte) c1 ← (byte) 'x' -- vbuz1=vbuc1 
  // Initialize a volatile ZP-variable (will be done in the initializer)
  lda #'x'
  sta.z c1
  // @1
  // c2 = SCREEN>1000?'s':'m'
  // [1] (volatile byte) c2 ← (byte) 's' -- vbuz1=vbuc1 
  // Initialize another volatile ZP-variable (will be done in the initializer)
  lda #'s'
  sta.z c2
  // [2] call main 
  jsr main
  rts
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // SCREEN[0] = c1
    // [4] *((const nomodify byte*) SCREEN) ← (volatile byte) c1 -- _deref_pbuc1=vbuz1 
    lda.z c1
    sta SCREEN
    // SCREEN[0] = c2
    // [5] *((const nomodify byte*) SCREEN) ← (volatile byte) c2 -- _deref_pbuc1=vbuz1 
    lda.z c2
    sta SCREEN
    // main::@return
    // }
    // [6] return 
    rts
}
  // File Data

