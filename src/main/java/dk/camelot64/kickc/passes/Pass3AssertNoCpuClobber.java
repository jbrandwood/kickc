package dk.camelot64.kickc.passes;

import dk.camelot64.kickc.asm.AsmInstruction;
import dk.camelot64.kickc.asm.AsmLine;
import dk.camelot64.kickc.asm.AsmProgram;
import dk.camelot64.kickc.asm.parser.AsmClobber;
import dk.camelot64.kickc.icl.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/*** Ensures that no statement clobbers a CPU register used by an alive variable - and that assigning statements clobber the CPU registers they assign to */
public class Pass3AssertNoCpuClobber extends Pass2Base {

   public Pass3AssertNoCpuClobber(Program program) {
      super(program);
   }

   /** Check that no statement clobbers a CPU register used by an alive variable */
   public void check() {
      if(hasClobberProblem(true, null)) {
         throw new RuntimeException("CLOBBER ERROR! See log for more info.");
      }
   }

   /**
    * Determines whether any statement in the program clobbers a CPU register used by an alive variable
    * @return true if there is a clobber problem in the program
    */
   public boolean hasClobberProblem(boolean verbose, RegisterAllocation.Register register) {
      RegisterAllocation allocation = getProgram().getAllocation();
      LiveRangeVariables liveRangeVariables = getProgram().getLiveRangeVariables();
      boolean clobberProblem = false;
      Pass4CodeGeneration.AsmCodegenAluState aluState = new Pass4CodeGeneration.AsmCodegenAluState();
      int registerCycles = 0;
      for (ControlFlowBlock block : getGraph().getAllBlocks()) {
         for (Statement statement : block.getStatements()) {

            // Generate ASM and find clobber
            AsmProgram asm = getAsmProgram(statement, block, aluState);
            Collection<RegisterAllocation.Register> clobberRegisters = getClobberedRegisters(asm);

            // Find alive variables
            List<VariableRef> aliveVars = new ArrayList<>(liveRangeVariables.getAlive(statement));

            // Find vars assignedVars to
            Collection<VariableRef> assignedVars = getAssignedVars(statement);

            for (VariableRef aliveVar : aliveVars) {
               RegisterAllocation.Register aliveVarRegister = allocation.getRegister(aliveVar);
               if(aliveVarRegister.isZp()) {
                  // No need to check a zp-register - here we are only interested in CPU registers
                  continue;
               }
               if(aliveVarRegister.equals(register)) {
                  registerCycles += countCycles(asm);
               }
               if(assignedVars.contains(aliveVar)) {
                  // No need to register that is assigned by the statement - it will be clobbered
                  continue;
               }
               // Alive and not assigned to - clobber not allowed!
               if(clobberRegisters.contains(aliveVarRegister)) {
                  if(verbose) {
                     getLog().append("Error! Alive variable " + aliveVar + " register " + aliveVarRegister + " clobbered by the ASM generated by statement " + statement);
                     getLog().append(asm.toString(false));
                  }
                  clobberProblem = true;
               }
            }
         }
      }
      if(!clobberProblem && register!=null) {
         getLog().append("Register Cycles: "+register+" "+registerCycles);
      }
      return clobberProblem;
   }

   private int countCycles(AsmProgram asm) {
      int instructionCycles = 0;
      for (AsmLine asmLine : asm.getLines()) {
         if(asmLine instanceof AsmInstruction) {
            double lineCycles = ((AsmInstruction) asmLine).getType().getCycles();
            instructionCycles += lineCycles;
         }
      }
      return instructionCycles;
   }


   /**
    * Get the variables assigned to by a specific statement
    *
    * @param statement The statement
    * @return The variables assigned by the statement
    */
   private Collection<VariableRef> getAssignedVars(Statement statement) {
      List<VariableRef> assignedVars = new ArrayList<>();
      if(statement instanceof StatementAssignment) {
         StatementAssignment assignment = (StatementAssignment) statement;
         if(assignment.getlValue() instanceof VariableRef) {
            assignedVars.add((VariableRef) assignment.getlValue());
         }
      } else if(statement instanceof StatementPhiBlock) {
         StatementPhiBlock phi = (StatementPhiBlock) statement;
         for (StatementPhiBlock.PhiVariable phiVariable : phi.getPhiVariables()) {
            assignedVars.add(phiVariable.getVariable());
         }
      }
      return assignedVars;
   }

   /**
    * Get all CPU registers clobbered by the ASM generated from a specific statement in the program
    *
    * @param asm The assembler to check
    * @return The clobbered CPU registers
    */
   private Collection<RegisterAllocation.Register> getClobberedRegisters(AsmProgram asm) {
      AsmClobber clobber = asm.getClobber();
      List<RegisterAllocation.Register> clobberRegisters = new ArrayList<>();
      if(clobber.isClobberA()) {
         clobberRegisters.add(RegisterAllocation.getRegisterA());
      }
      if(clobber.isClobberX()) {
         clobberRegisters.add(RegisterAllocation.getRegisterX());
      }
      if(clobber.isClobberY()) {
         clobberRegisters.add(RegisterAllocation.getRegisterY());
      }
      return clobberRegisters;
   }

   /**
    * Get the ASM program generated by a specific statement in the program
    *
    * @param statement The statement
    * @param block The block containing the statement
    * @return The ASM code
    */
   private AsmProgram getAsmProgram(Statement statement, ControlFlowBlock block, Pass4CodeGeneration.AsmCodegenAluState aluState) {
      Pass4CodeGeneration codegen = new Pass4CodeGeneration(getProgram());
      AsmProgram asm = new AsmProgram();
      codegen.generateStatementAsm(asm, block, statement, aluState);
      return asm;
   }

}
