Resolved forward reference irq to interrupt(KERNEL_MIN)(void()) irq()
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@12
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@10
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) sub_main::@6
Culled Empty Block (label) @3
Culled Empty Block (label) sub_irq::@6

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@4

(void()) main()
main: scope:[main]  from @4
  asm { sei  }
  *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR
  *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (number) $7f
  *((const byte*) RASTER) ← (number) $fd
  *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER
  *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq()
  asm { cli  }
  to:main::@1
main::@1: scope:[main]  from main main::@8
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  (byte) main::i#0 ← (byte) 0
  to:main::@4
main::@4: scope:[main]  from main::@2 main::@8
  (byte) main::i#7 ← phi( main::@2/(byte) main::i#0 main::@8/(byte) main::i#1 )
  (byte) main::j#0 ← (byte) 0
  to:main::@5
main::@5: scope:[main]  from main::@4 main::@7
  (byte) main::j#5 ← phi( main::@4/(byte) main::j#0 main::@7/(byte) main::j#1 )
  (byte) main::i#5 ← phi( main::@4/(byte) main::i#7 main::@7/(byte) main::i#6 )
  (byte) main::k#0 ← (byte) 0
  to:main::@6
main::@6: scope:[main]  from main::@13 main::@5
  (byte) main::k#2 ← phi( main::@13/(byte) main::k#1 main::@5/(byte) main::k#0 )
  (byte) main::j#2 ← phi( main::@13/(byte) main::j#4 main::@5/(byte) main::j#5 )
  (byte) main::i#2 ← phi( main::@13/(byte) main::i#4 main::@5/(byte) main::i#5 )
  (byte~) main::$0 ← (byte) main::i#2 + (byte) main::j#2
  (byte~) main::$1 ← (byte~) main::$0 + (byte) main::k#2
  *((const byte*) FGCOL) ← (byte~) main::$1
  call sub_main 
  to:main::@13
main::@13: scope:[main]  from main::@6
  (byte) main::j#4 ← phi( main::@6/(byte) main::j#2 )
  (byte) main::i#4 ← phi( main::@6/(byte) main::i#2 )
  (byte) main::k#3 ← phi( main::@6/(byte) main::k#2 )
  (byte) main::k#1 ← (byte) main::k#3 + rangenext(0,$a)
  (bool~) main::$3 ← (byte) main::k#1 != rangelast(0,$a)
  if((bool~) main::$3) goto main::@6
  to:main::@7
main::@7: scope:[main]  from main::@13
  (byte) main::i#6 ← phi( main::@13/(byte) main::i#4 )
  (byte) main::j#3 ← phi( main::@13/(byte) main::j#4 )
  (byte) main::j#1 ← (byte) main::j#3 + rangenext(0,$a)
  (bool~) main::$4 ← (byte) main::j#1 != rangelast(0,$a)
  if((bool~) main::$4) goto main::@5
  to:main::@8
main::@8: scope:[main]  from main::@7
  (byte) main::i#3 ← phi( main::@7/(byte) main::i#6 )
  (byte) main::i#1 ← (byte) main::i#3 + rangenext(0,$a)
  (bool~) main::$5 ← (byte) main::i#1 != rangelast(0,$a)
  if((bool~) main::$5) goto main::@4
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return

interrupt(KERNEL_MIN)(void()) irq()
irq: scope:[irq]  from
  *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL)
  (byte) irq::i#0 ← (byte) 0
  to:irq::@1
irq::@1: scope:[irq]  from irq irq::@5
  (byte) irq::i#7 ← phi( irq/(byte) irq::i#0 irq::@5/(byte) irq::i#1 )
  (byte) irq::j#0 ← (byte) 0
  to:irq::@2
irq::@2: scope:[irq]  from irq::@1 irq::@4
  (byte) irq::j#4 ← phi( irq::@1/(byte) irq::j#0 irq::@4/(byte) irq::j#1 )
  (byte) irq::i#4 ← phi( irq::@1/(byte) irq::i#7 irq::@4/(byte) irq::i#6 )
  (byte) irq::k#0 ← (byte) 0
  to:irq::@3
irq::@3: scope:[irq]  from irq::@2 irq::@7
  (byte) irq::k#2 ← phi( irq::@2/(byte) irq::k#0 irq::@7/(byte) irq::k#1 )
  (byte) irq::j#2 ← phi( irq::@2/(byte) irq::j#4 irq::@7/(byte) irq::j#5 )
  (byte) irq::i#2 ← phi( irq::@2/(byte) irq::i#4 irq::@7/(byte) irq::i#5 )
  (byte~) irq::$2 ← (byte) irq::i#2 + (byte) irq::j#2
  (byte~) irq::$3 ← (byte~) irq::$2 + (byte) irq::k#2
  *((const byte*) FGCOL) ← (byte~) irq::$3
  call sub_irq 
  to:irq::@7
irq::@7: scope:[irq]  from irq::@3
  (byte) irq::j#5 ← phi( irq::@3/(byte) irq::j#2 )
  (byte) irq::i#5 ← phi( irq::@3/(byte) irq::i#2 )
  (byte) irq::k#3 ← phi( irq::@3/(byte) irq::k#2 )
  (byte) irq::k#1 ← (byte) irq::k#3 + rangenext(0,$a)
  (bool~) irq::$5 ← (byte) irq::k#1 != rangelast(0,$a)
  if((bool~) irq::$5) goto irq::@3
  to:irq::@4
irq::@4: scope:[irq]  from irq::@7
  (byte) irq::i#6 ← phi( irq::@7/(byte) irq::i#5 )
  (byte) irq::j#3 ← phi( irq::@7/(byte) irq::j#5 )
  (byte) irq::j#1 ← (byte) irq::j#3 + rangenext(0,$a)
  (bool~) irq::$6 ← (byte) irq::j#1 != rangelast(0,$a)
  if((bool~) irq::$6) goto irq::@2
  to:irq::@5
irq::@5: scope:[irq]  from irq::@4
  (byte) irq::i#3 ← phi( irq::@4/(byte) irq::i#6 )
  (byte) irq::i#1 ← (byte) irq::i#3 + rangenext(0,$a)
  (bool~) irq::$7 ← (byte) irq::i#1 != rangelast(0,$a)
  if((bool~) irq::$7) goto irq::@1
  to:irq::@6
irq::@6: scope:[irq]  from irq::@5
  *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER
  *((const byte*) BGCOL) ← -- *((const byte*) BGCOL)
  to:irq::@return
irq::@return: scope:[irq]  from irq::@6
  return 
  to:@return

(void()) sub_main()
sub_main: scope:[sub_main]  from main::@6
  (byte) sub_main::i#0 ← (byte) 0
  to:sub_main::@1
sub_main::@1: scope:[sub_main]  from sub_main sub_main::@5
  (byte) sub_main::i#6 ← phi( sub_main/(byte) sub_main::i#0 sub_main::@5/(byte) sub_main::i#1 )
  (byte) sub_main::j#0 ← (byte) 0
  to:sub_main::@2
sub_main::@2: scope:[sub_main]  from sub_main::@1 sub_main::@4
  (byte) sub_main::j#4 ← phi( sub_main::@1/(byte) sub_main::j#0 sub_main::@4/(byte) sub_main::j#1 )
  (byte) sub_main::i#4 ← phi( sub_main::@1/(byte) sub_main::i#6 sub_main::@4/(byte) sub_main::i#5 )
  (byte) sub_main::k#0 ← (byte) 0
  to:sub_main::@3
sub_main::@3: scope:[sub_main]  from sub_main::@2 sub_main::@3
  (byte) sub_main::k#2 ← phi( sub_main::@2/(byte) sub_main::k#0 sub_main::@3/(byte) sub_main::k#1 )
  (byte) sub_main::j#2 ← phi( sub_main::@2/(byte) sub_main::j#4 sub_main::@3/(byte) sub_main::j#2 )
  (byte) sub_main::i#2 ← phi( sub_main::@2/(byte) sub_main::i#4 sub_main::@3/(byte) sub_main::i#2 )
  (byte~) sub_main::$0 ← (byte) sub_main::i#2 + (byte) sub_main::j#2
  (byte~) sub_main::$1 ← (byte~) sub_main::$0 + (byte) sub_main::k#2
  *((const byte*) BGCOL) ← (byte~) sub_main::$1
  (byte) sub_main::k#1 ← (byte) sub_main::k#2 + rangenext(0,$a)
  (bool~) sub_main::$2 ← (byte) sub_main::k#1 != rangelast(0,$a)
  if((bool~) sub_main::$2) goto sub_main::@3
  to:sub_main::@4
sub_main::@4: scope:[sub_main]  from sub_main::@3
  (byte) sub_main::i#5 ← phi( sub_main::@3/(byte) sub_main::i#2 )
  (byte) sub_main::j#3 ← phi( sub_main::@3/(byte) sub_main::j#2 )
  (byte) sub_main::j#1 ← (byte) sub_main::j#3 + rangenext(0,$a)
  (bool~) sub_main::$3 ← (byte) sub_main::j#1 != rangelast(0,$a)
  if((bool~) sub_main::$3) goto sub_main::@2
  to:sub_main::@5
sub_main::@5: scope:[sub_main]  from sub_main::@4
  (byte) sub_main::i#3 ← phi( sub_main::@4/(byte) sub_main::i#5 )
  (byte) sub_main::i#1 ← (byte) sub_main::i#3 + rangenext(0,$a)
  (bool~) sub_main::$4 ← (byte) sub_main::i#1 != rangelast(0,$a)
  if((bool~) sub_main::$4) goto sub_main::@1
  to:sub_main::@return
sub_main::@return: scope:[sub_main]  from sub_main::@5
  return 
  to:@return

(void()) sub_irq()
sub_irq: scope:[sub_irq]  from irq::@3
  (byte) sub_irq::i#0 ← (byte) 0
  to:sub_irq::@1
sub_irq::@1: scope:[sub_irq]  from sub_irq sub_irq::@5
  (byte) sub_irq::i#6 ← phi( sub_irq/(byte) sub_irq::i#0 sub_irq::@5/(byte) sub_irq::i#1 )
  (byte) sub_irq::j#0 ← (byte) 0
  to:sub_irq::@2
sub_irq::@2: scope:[sub_irq]  from sub_irq::@1 sub_irq::@4
  (byte) sub_irq::j#4 ← phi( sub_irq::@1/(byte) sub_irq::j#0 sub_irq::@4/(byte) sub_irq::j#1 )
  (byte) sub_irq::i#4 ← phi( sub_irq::@1/(byte) sub_irq::i#6 sub_irq::@4/(byte) sub_irq::i#5 )
  (byte) sub_irq::k#0 ← (byte) 0
  to:sub_irq::@3
sub_irq::@3: scope:[sub_irq]  from sub_irq::@2 sub_irq::@3
  (byte) sub_irq::k#2 ← phi( sub_irq::@2/(byte) sub_irq::k#0 sub_irq::@3/(byte) sub_irq::k#1 )
  (byte) sub_irq::j#2 ← phi( sub_irq::@2/(byte) sub_irq::j#4 sub_irq::@3/(byte) sub_irq::j#2 )
  (byte) sub_irq::i#2 ← phi( sub_irq::@2/(byte) sub_irq::i#4 sub_irq::@3/(byte) sub_irq::i#2 )
  (byte~) sub_irq::$0 ← (byte) sub_irq::i#2 + (byte) sub_irq::j#2
  (byte~) sub_irq::$1 ← (byte~) sub_irq::$0 + (byte) sub_irq::k#2
  *((const byte*) BGCOL) ← (byte~) sub_irq::$1
  (byte) sub_irq::k#1 ← (byte) sub_irq::k#2 + rangenext(0,$a)
  (bool~) sub_irq::$2 ← (byte) sub_irq::k#1 != rangelast(0,$a)
  if((bool~) sub_irq::$2) goto sub_irq::@3
  to:sub_irq::@4
sub_irq::@4: scope:[sub_irq]  from sub_irq::@3
  (byte) sub_irq::i#5 ← phi( sub_irq::@3/(byte) sub_irq::i#2 )
  (byte) sub_irq::j#3 ← phi( sub_irq::@3/(byte) sub_irq::j#2 )
  (byte) sub_irq::j#1 ← (byte) sub_irq::j#3 + rangenext(0,$a)
  (bool~) sub_irq::$3 ← (byte) sub_irq::j#1 != rangelast(0,$a)
  if((bool~) sub_irq::$3) goto sub_irq::@2
  to:sub_irq::@5
sub_irq::@5: scope:[sub_irq]  from sub_irq::@4
  (byte) sub_irq::i#3 ← phi( sub_irq::@4/(byte) sub_irq::i#5 )
  (byte) sub_irq::i#1 ← (byte) sub_irq::i#3 + rangenext(0,$a)
  (bool~) sub_irq::$4 ← (byte) sub_irq::i#1 != rangelast(0,$a)
  if((bool~) sub_irq::$4) goto sub_irq::@1
  to:sub_irq::@return
sub_irq::@return: scope:[sub_irq]  from sub_irq::@5
  return 
  to:@return
@4: scope:[]  from @begin
  call main 
  to:@5
@5: scope:[]  from @4
  to:@end
@end: scope:[]  from @5

SYMBOL TABLE SSA
(label) @4
(label) @5
(label) @begin
(label) @end
(const byte*) BGCOL = (byte*)(number) $d020
(const byte*) CIA1_INTERRUPT = (byte*)(number) $dc0d
(const byte) CIA_INTERRUPT_CLEAR = (byte) $7f
(const byte*) FGCOL = (byte*)(number) $d021
(const byte*) IRQ_ENABLE = (byte*)(number) $d01a
(const byte) IRQ_RASTER = (byte) 1
(const byte*) IRQ_STATUS = (byte*)(number) $d019
(const void()**) KERNEL_IRQ = (void()**)(number) $314
(const byte*) RASTER = (byte*)(number) $d012
(const byte*) VIC_CONTROL = (byte*)(number) $d011
interrupt(KERNEL_MIN)(void()) irq()
(byte~) irq::$2
(byte~) irq::$3
(bool~) irq::$5
(bool~) irq::$6
(bool~) irq::$7
(label) irq::@1
(label) irq::@2
(label) irq::@3
(label) irq::@4
(label) irq::@5
(label) irq::@6
(label) irq::@7
(label) irq::@return
(byte) irq::i
(byte) irq::i#0
(byte) irq::i#1
(byte) irq::i#2
(byte) irq::i#3
(byte) irq::i#4
(byte) irq::i#5
(byte) irq::i#6
(byte) irq::i#7
(byte) irq::j
(byte) irq::j#0
(byte) irq::j#1
(byte) irq::j#2
(byte) irq::j#3
(byte) irq::j#4
(byte) irq::j#5
(byte) irq::k
(byte) irq::k#0
(byte) irq::k#1
(byte) irq::k#2
(byte) irq::k#3
(void()) main()
(byte~) main::$0
(byte~) main::$1
(bool~) main::$3
(bool~) main::$4
(bool~) main::$5
(label) main::@1
(label) main::@13
(label) main::@2
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@return
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte) main::i#3
(byte) main::i#4
(byte) main::i#5
(byte) main::i#6
(byte) main::i#7
(byte) main::j
(byte) main::j#0
(byte) main::j#1
(byte) main::j#2
(byte) main::j#3
(byte) main::j#4
(byte) main::j#5
(byte) main::k
(byte) main::k#0
(byte) main::k#1
(byte) main::k#2
(byte) main::k#3
(void()) sub_irq()
(byte~) sub_irq::$0
(byte~) sub_irq::$1
(bool~) sub_irq::$2
(bool~) sub_irq::$3
(bool~) sub_irq::$4
(label) sub_irq::@1
(label) sub_irq::@2
(label) sub_irq::@3
(label) sub_irq::@4
(label) sub_irq::@5
(label) sub_irq::@return
(byte) sub_irq::i
(byte) sub_irq::i#0
(byte) sub_irq::i#1
(byte) sub_irq::i#2
(byte) sub_irq::i#3
(byte) sub_irq::i#4
(byte) sub_irq::i#5
(byte) sub_irq::i#6
(byte) sub_irq::j
(byte) sub_irq::j#0
(byte) sub_irq::j#1
(byte) sub_irq::j#2
(byte) sub_irq::j#3
(byte) sub_irq::j#4
(byte) sub_irq::k
(byte) sub_irq::k#0
(byte) sub_irq::k#1
(byte) sub_irq::k#2
(void()) sub_main()
(byte~) sub_main::$0
(byte~) sub_main::$1
(bool~) sub_main::$2
(bool~) sub_main::$3
(bool~) sub_main::$4
(label) sub_main::@1
(label) sub_main::@2
(label) sub_main::@3
(label) sub_main::@4
(label) sub_main::@5
(label) sub_main::@return
(byte) sub_main::i
(byte) sub_main::i#0
(byte) sub_main::i#1
(byte) sub_main::i#2
(byte) sub_main::i#3
(byte) sub_main::i#4
(byte) sub_main::i#5
(byte) sub_main::i#6
(byte) sub_main::j
(byte) sub_main::j#0
(byte) sub_main::j#1
(byte) sub_main::j#2
(byte) sub_main::j#3
(byte) sub_main::j#4
(byte) sub_main::k
(byte) sub_main::k#0
(byte) sub_main::k#1
(byte) sub_main::k#2

Adding number conversion cast (unumber) $7f in *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (number) $7f
Adding number conversion cast (unumber) $fd in *((const byte*) RASTER) ← (number) $fd
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((const byte*) RASTER) ← (unumber)(number) $fd
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (void()**) 788
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (byte*) 53273
Simplifying constant pointer cast (byte*) 53274
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53281
Simplifying constant pointer cast (byte*) 56333
Simplifying constant integer cast $7f
Simplifying constant integer cast $fd
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) $fd
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias main::k#2 = main::k#3 
Alias main::i#2 = main::i#4 main::i#6 main::i#3 
Alias main::j#2 = main::j#4 main::j#3 
Alias irq::k#2 = irq::k#3 
Alias irq::i#2 = irq::i#5 irq::i#6 irq::i#3 
Alias irq::j#2 = irq::j#5 irq::j#3 
Alias sub_main::j#2 = sub_main::j#3 
Alias sub_main::i#2 = sub_main::i#5 sub_main::i#3 
Alias sub_irq::j#2 = sub_irq::j#3 
Alias sub_irq::i#2 = sub_irq::i#5 sub_irq::i#3 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) main::i#2 (byte) main::i#5
Identical Phi Values (byte) main::j#2 (byte) main::j#5
Identical Phi Values (byte) irq::i#2 (byte) irq::i#4
Identical Phi Values (byte) irq::j#2 (byte) irq::j#4
Identical Phi Values (byte) sub_main::i#2 (byte) sub_main::i#4
Identical Phi Values (byte) sub_main::j#2 (byte) sub_main::j#4
Identical Phi Values (byte) sub_irq::i#2 (byte) sub_irq::i#4
Identical Phi Values (byte) sub_irq::j#2 (byte) sub_irq::j#4
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte) main::i#5 (byte) main::i#7
Identical Phi Values (byte) irq::i#4 (byte) irq::i#7
Identical Phi Values (byte) sub_main::i#4 (byte) sub_main::i#6
Identical Phi Values (byte) sub_irq::i#4 (byte) sub_irq::i#6
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$3 [20] if((byte) main::k#1!=rangelast(0,$a)) goto main::@6
Simple Condition (bool~) main::$4 [23] if((byte) main::j#1!=rangelast(0,$a)) goto main::@5
Simple Condition (bool~) main::$5 [26] if((byte) main::i#1!=rangelast(0,$a)) goto main::@4
Simple Condition (bool~) irq::$5 [41] if((byte) irq::k#1!=rangelast(0,$a)) goto irq::@3
Simple Condition (bool~) irq::$6 [44] if((byte) irq::j#1!=rangelast(0,$a)) goto irq::@2
Simple Condition (bool~) irq::$7 [47] if((byte) irq::i#1!=rangelast(0,$a)) goto irq::@1
Simple Condition (bool~) sub_main::$2 [62] if((byte) sub_main::k#1!=rangelast(0,$a)) goto sub_main::@3
Simple Condition (bool~) sub_main::$3 [65] if((byte) sub_main::j#1!=rangelast(0,$a)) goto sub_main::@2
Simple Condition (bool~) sub_main::$4 [68] if((byte) sub_main::i#1!=rangelast(0,$a)) goto sub_main::@1
Simple Condition (bool~) sub_irq::$2 [81] if((byte) sub_irq::k#1!=rangelast(0,$a)) goto sub_irq::@3
Simple Condition (bool~) sub_irq::$3 [84] if((byte) sub_irq::j#1!=rangelast(0,$a)) goto sub_irq::@2
Simple Condition (bool~) sub_irq::$4 [87] if((byte) sub_irq::i#1!=rangelast(0,$a)) goto sub_irq::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte) main::i#0 = 0
Constant (const byte) main::j#0 = 0
Constant (const byte) main::k#0 = 0
Constant (const byte) irq::i#0 = 0
Constant (const byte) irq::j#0 = 0
Constant (const byte) irq::k#0 = 0
Constant (const byte) sub_main::i#0 = 0
Constant (const byte) sub_main::j#0 = 0
Constant (const byte) sub_main::k#0 = 0
Constant (const byte) sub_irq::i#0 = 0
Constant (const byte) sub_irq::j#0 = 0
Constant (const byte) sub_irq::k#0 = 0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [7] if(true) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [18] main::k#1 ← ++ main::k#2 to ++
Resolved ranged comparison value [20] if(main::k#1!=rangelast(0,$a)) goto main::@6 to (number) $b
Resolved ranged next value [21] main::j#1 ← ++ main::j#5 to ++
Resolved ranged comparison value [23] if(main::j#1!=rangelast(0,$a)) goto main::@5 to (number) $b
Resolved ranged next value [24] main::i#1 ← ++ main::i#7 to ++
Resolved ranged comparison value [26] if(main::i#1!=rangelast(0,$a)) goto main::@4 to (number) $b
Resolved ranged next value [39] irq::k#1 ← ++ irq::k#2 to ++
Resolved ranged comparison value [41] if(irq::k#1!=rangelast(0,$a)) goto irq::@3 to (number) $b
Resolved ranged next value [42] irq::j#1 ← ++ irq::j#4 to ++
Resolved ranged comparison value [44] if(irq::j#1!=rangelast(0,$a)) goto irq::@2 to (number) $b
Resolved ranged next value [45] irq::i#1 ← ++ irq::i#7 to ++
Resolved ranged comparison value [47] if(irq::i#1!=rangelast(0,$a)) goto irq::@1 to (number) $b
Resolved ranged next value [60] sub_main::k#1 ← ++ sub_main::k#2 to ++
Resolved ranged comparison value [62] if(sub_main::k#1!=rangelast(0,$a)) goto sub_main::@3 to (number) $b
Resolved ranged next value [63] sub_main::j#1 ← ++ sub_main::j#4 to ++
Resolved ranged comparison value [65] if(sub_main::j#1!=rangelast(0,$a)) goto sub_main::@2 to (number) $b
Resolved ranged next value [66] sub_main::i#1 ← ++ sub_main::i#6 to ++
Resolved ranged comparison value [68] if(sub_main::i#1!=rangelast(0,$a)) goto sub_main::@1 to (number) $b
Resolved ranged next value [79] sub_irq::k#1 ← ++ sub_irq::k#2 to ++
Resolved ranged comparison value [81] if(sub_irq::k#1!=rangelast(0,$a)) goto sub_irq::@3 to (number) $b
Resolved ranged next value [82] sub_irq::j#1 ← ++ sub_irq::j#4 to ++
Resolved ranged comparison value [84] if(sub_irq::j#1!=rangelast(0,$a)) goto sub_irq::@2 to (number) $b
Resolved ranged next value [85] sub_irq::i#1 ← ++ sub_irq::i#6 to ++
Resolved ranged comparison value [87] if(sub_irq::i#1!=rangelast(0,$a)) goto sub_irq::@1 to (number) $b
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) $b in if((byte) main::k#1!=(number) $b) goto main::@6
Adding number conversion cast (unumber) $b in if((byte) main::j#1!=(number) $b) goto main::@5
Adding number conversion cast (unumber) $b in if((byte) main::i#1!=(number) $b) goto main::@4
Adding number conversion cast (unumber) $b in if((byte) irq::k#1!=(number) $b) goto irq::@3
Adding number conversion cast (unumber) $b in if((byte) irq::j#1!=(number) $b) goto irq::@2
Adding number conversion cast (unumber) $b in if((byte) irq::i#1!=(number) $b) goto irq::@1
Adding number conversion cast (unumber) $b in if((byte) sub_main::k#1!=(number) $b) goto sub_main::@3
Adding number conversion cast (unumber) $b in if((byte) sub_main::j#1!=(number) $b) goto sub_main::@2
Adding number conversion cast (unumber) $b in if((byte) sub_main::i#1!=(number) $b) goto sub_main::@1
Adding number conversion cast (unumber) $b in if((byte) sub_irq::k#1!=(number) $b) goto sub_irq::@3
Adding number conversion cast (unumber) $b in if((byte) sub_irq::j#1!=(number) $b) goto sub_irq::@2
Adding number conversion cast (unumber) $b in if((byte) sub_irq::i#1!=(number) $b) goto sub_irq::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Simplifying constant integer cast $b
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $b
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with var siblings (const byte) main::j#0
Inlining constant with var siblings (const byte) main::k#0
Inlining constant with var siblings (const byte) irq::i#0
Inlining constant with var siblings (const byte) irq::j#0
Inlining constant with var siblings (const byte) irq::k#0
Inlining constant with var siblings (const byte) sub_main::i#0
Inlining constant with var siblings (const byte) sub_main::j#0
Inlining constant with var siblings (const byte) sub_main::k#0
Inlining constant with var siblings (const byte) sub_irq::i#0
Inlining constant with var siblings (const byte) sub_irq::j#0
Inlining constant with var siblings (const byte) sub_irq::k#0
Constant inlined sub_main::j#0 = (byte) 0
Constant inlined sub_main::i#0 = (byte) 0
Constant inlined irq::i#0 = (byte) 0
Constant inlined irq::j#0 = (byte) 0
Constant inlined irq::k#0 = (byte) 0
Constant inlined sub_irq::i#0 = (byte) 0
Constant inlined sub_irq::j#0 = (byte) 0
Constant inlined sub_irq::k#0 = (byte) 0
Constant inlined main::i#0 = (byte) 0
Constant inlined main::k#0 = (byte) 0
Constant inlined main::j#0 = (byte) 0
Constant inlined sub_main::k#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@14(between main::@8 and main::@4)
Added new block during phi lifting main::@15(between main::@7 and main::@5)
Added new block during phi lifting main::@16(between main::@13 and main::@6)
Added new block during phi lifting irq::@8(between irq::@5 and irq::@1)
Added new block during phi lifting irq::@9(between irq::@4 and irq::@2)
Added new block during phi lifting irq::@10(between irq::@7 and irq::@3)
Added new block during phi lifting sub_main::@7(between sub_main::@5 and sub_main::@1)
Added new block during phi lifting sub_main::@8(between sub_main::@4 and sub_main::@2)
Added new block during phi lifting sub_main::@9(between sub_main::@3 and sub_main::@3)
Added new block during phi lifting sub_irq::@7(between sub_irq::@5 and sub_irq::@1)
Added new block during phi lifting sub_irq::@8(between sub_irq::@4 and sub_irq::@2)
Added new block during phi lifting sub_irq::@9(between sub_irq::@3 and sub_irq::@3)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @5
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of sub_main
Adding NOP phi() at start of sub_irq
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to sub_main:20 
Calls in [irq] to sub_irq:54 

Created 12 initial phi equivalence classes
Coalesced [27] main::i#8 ← main::i#1
Coalesced [28] main::j#6 ← main::j#1
Coalesced [29] main::k#4 ← main::k#1
Coalesced [44] sub_main::i#7 ← sub_main::i#1
Coalesced [45] sub_main::j#5 ← sub_main::j#1
Coalesced [46] sub_main::k#3 ← sub_main::k#1
Coalesced [64] irq::i#8 ← irq::i#1
Coalesced [65] irq::j#6 ← irq::j#1
Coalesced [66] irq::k#4 ← irq::k#1
Coalesced [81] sub_irq::i#7 ← sub_irq::i#1
Coalesced [82] sub_irq::j#5 ← sub_irq::j#1
Coalesced [83] sub_irq::k#3 ← sub_irq::k#1
Coalesced down to 12 phi equivalence classes
Culled Empty Block (label) @5
Culled Empty Block (label) main::@1
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@15
Culled Empty Block (label) main::@16
Culled Empty Block (label) sub_main::@7
Culled Empty Block (label) sub_main::@8
Culled Empty Block (label) sub_main::@9
Culled Empty Block (label) irq::@8
Culled Empty Block (label) irq::@9
Culled Empty Block (label) irq::@10
Culled Empty Block (label) sub_irq::@7
Culled Empty Block (label) sub_irq::@8
Culled Empty Block (label) sub_irq::@9
Renumbering block @4 to @1
Renumbering block main::@4 to main::@1
Renumbering block main::@5 to main::@2
Renumbering block main::@6 to main::@3
Renumbering block main::@7 to main::@4
Renumbering block main::@8 to main::@5
Renumbering block main::@13 to main::@6
Renumbering block main::@14 to main::@7
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of sub_main
Adding NOP phi() at start of sub_irq

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  asm { sei  }
  [5] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR
  [6] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f
  [7] *((const byte*) RASTER) ← (byte) $fd
  [8] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER
  [9] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq()
  asm { cli  }
  to:main::@1
main::@1: scope:[main]  from main main::@5 main::@7
  [11] (byte) main::i#7 ← phi( main/(byte) 0 main::@7/(byte) main::i#1 main::@5/(byte) 0 )
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@4
  [12] (byte) main::j#5 ← phi( main::@1/(byte) 0 main::@4/(byte) main::j#1 )
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@6
  [13] (byte) main::k#2 ← phi( main::@6/(byte) main::k#1 main::@2/(byte) 0 )
  [14] (byte~) main::$0 ← (byte) main::i#7 + (byte) main::j#5
  [15] (byte~) main::$1 ← (byte~) main::$0 + (byte) main::k#2
  [16] *((const byte*) FGCOL) ← (byte~) main::$1
  [17] call sub_main 
  to:main::@6
main::@6: scope:[main]  from main::@3
  [18] (byte) main::k#1 ← ++ (byte) main::k#2
  [19] if((byte) main::k#1!=(byte) $b) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@6
  [20] (byte) main::j#1 ← ++ (byte) main::j#5
  [21] if((byte) main::j#1!=(byte) $b) goto main::@2
  to:main::@5
main::@5: scope:[main]  from main::@4
  [22] (byte) main::i#1 ← ++ (byte) main::i#7
  [23] if((byte) main::i#1!=(byte) $b) goto main::@7
  to:main::@1
main::@7: scope:[main]  from main::@5
  [24] phi()
  to:main::@1

(void()) sub_main()
sub_main: scope:[sub_main]  from main::@3
  [25] phi()
  to:sub_main::@1
sub_main::@1: scope:[sub_main]  from sub_main sub_main::@5
  [26] (byte) sub_main::i#6 ← phi( sub_main/(byte) 0 sub_main::@5/(byte) sub_main::i#1 )
  to:sub_main::@2
sub_main::@2: scope:[sub_main]  from sub_main::@1 sub_main::@4
  [27] (byte) sub_main::j#4 ← phi( sub_main::@1/(byte) 0 sub_main::@4/(byte) sub_main::j#1 )
  to:sub_main::@3
sub_main::@3: scope:[sub_main]  from sub_main::@2 sub_main::@3
  [28] (byte) sub_main::k#2 ← phi( sub_main::@2/(byte) 0 sub_main::@3/(byte) sub_main::k#1 )
  [29] (byte~) sub_main::$0 ← (byte) sub_main::i#6 + (byte) sub_main::j#4
  [30] (byte~) sub_main::$1 ← (byte~) sub_main::$0 + (byte) sub_main::k#2
  [31] *((const byte*) BGCOL) ← (byte~) sub_main::$1
  [32] (byte) sub_main::k#1 ← ++ (byte) sub_main::k#2
  [33] if((byte) sub_main::k#1!=(byte) $b) goto sub_main::@3
  to:sub_main::@4
sub_main::@4: scope:[sub_main]  from sub_main::@3
  [34] (byte) sub_main::j#1 ← ++ (byte) sub_main::j#4
  [35] if((byte) sub_main::j#1!=(byte) $b) goto sub_main::@2
  to:sub_main::@5
sub_main::@5: scope:[sub_main]  from sub_main::@4
  [36] (byte) sub_main::i#1 ← ++ (byte) sub_main::i#6
  [37] if((byte) sub_main::i#1!=(byte) $b) goto sub_main::@1
  to:sub_main::@return
sub_main::@return: scope:[sub_main]  from sub_main::@5
  [38] return 
  to:@return

interrupt(KERNEL_MIN)(void()) irq()
irq: scope:[irq]  from
  [39] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL)
  to:irq::@1
irq::@1: scope:[irq]  from irq irq::@5
  [40] (byte) irq::i#7 ← phi( irq/(byte) 0 irq::@5/(byte) irq::i#1 )
  to:irq::@2
irq::@2: scope:[irq]  from irq::@1 irq::@4
  [41] (byte) irq::j#4 ← phi( irq::@1/(byte) 0 irq::@4/(byte) irq::j#1 )
  to:irq::@3
irq::@3: scope:[irq]  from irq::@2 irq::@7
  [42] (byte) irq::k#2 ← phi( irq::@2/(byte) 0 irq::@7/(byte) irq::k#1 )
  [43] (byte~) irq::$2 ← (byte) irq::i#7 + (byte) irq::j#4
  [44] (byte~) irq::$3 ← (byte~) irq::$2 + (byte) irq::k#2
  [45] *((const byte*) FGCOL) ← (byte~) irq::$3
  [46] call sub_irq 
  to:irq::@7
irq::@7: scope:[irq]  from irq::@3
  [47] (byte) irq::k#1 ← ++ (byte) irq::k#2
  [48] if((byte) irq::k#1!=(byte) $b) goto irq::@3
  to:irq::@4
irq::@4: scope:[irq]  from irq::@7
  [49] (byte) irq::j#1 ← ++ (byte) irq::j#4
  [50] if((byte) irq::j#1!=(byte) $b) goto irq::@2
  to:irq::@5
irq::@5: scope:[irq]  from irq::@4
  [51] (byte) irq::i#1 ← ++ (byte) irq::i#7
  [52] if((byte) irq::i#1!=(byte) $b) goto irq::@1
  to:irq::@6
irq::@6: scope:[irq]  from irq::@5
  [53] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER
  [54] *((const byte*) BGCOL) ← -- *((const byte*) BGCOL)
  to:irq::@return
irq::@return: scope:[irq]  from irq::@6
  [55] return 
  to:@return

(void()) sub_irq()
sub_irq: scope:[sub_irq]  from irq::@3
  [56] phi()
  to:sub_irq::@1
sub_irq::@1: scope:[sub_irq]  from sub_irq sub_irq::@5
  [57] (byte) sub_irq::i#6 ← phi( sub_irq/(byte) 0 sub_irq::@5/(byte) sub_irq::i#1 )
  to:sub_irq::@2
sub_irq::@2: scope:[sub_irq]  from sub_irq::@1 sub_irq::@4
  [58] (byte) sub_irq::j#4 ← phi( sub_irq::@1/(byte) 0 sub_irq::@4/(byte) sub_irq::j#1 )
  to:sub_irq::@3
sub_irq::@3: scope:[sub_irq]  from sub_irq::@2 sub_irq::@3
  [59] (byte) sub_irq::k#2 ← phi( sub_irq::@2/(byte) 0 sub_irq::@3/(byte) sub_irq::k#1 )
  [60] (byte~) sub_irq::$0 ← (byte) sub_irq::i#6 + (byte) sub_irq::j#4
  [61] (byte~) sub_irq::$1 ← (byte~) sub_irq::$0 + (byte) sub_irq::k#2
  [62] *((const byte*) BGCOL) ← (byte~) sub_irq::$1
  [63] (byte) sub_irq::k#1 ← ++ (byte) sub_irq::k#2
  [64] if((byte) sub_irq::k#1!=(byte) $b) goto sub_irq::@3
  to:sub_irq::@4
sub_irq::@4: scope:[sub_irq]  from sub_irq::@3
  [65] (byte) sub_irq::j#1 ← ++ (byte) sub_irq::j#4
  [66] if((byte) sub_irq::j#1!=(byte) $b) goto sub_irq::@2
  to:sub_irq::@5
sub_irq::@5: scope:[sub_irq]  from sub_irq::@4
  [67] (byte) sub_irq::i#1 ← ++ (byte) sub_irq::i#6
  [68] if((byte) sub_irq::i#1!=(byte) $b) goto sub_irq::@1
  to:sub_irq::@return
sub_irq::@return: scope:[sub_irq]  from sub_irq::@5
  [69] return 
  to:@return


VARIABLE REGISTER WEIGHTS
interrupt(KERNEL_MIN)(void()) irq()
(byte~) irq::$2 2002.0
(byte~) irq::$3 2002.0
(byte) irq::i
(byte) irq::i#1 16.5
(byte) irq::i#7 93.0
(byte) irq::j
(byte) irq::j#1 151.5
(byte) irq::j#4 150.375
(byte) irq::k
(byte) irq::k#1 1501.5
(byte) irq::k#2 600.5999999999999
(void()) main()
(byte~) main::$0 200002.0
(byte~) main::$1 200002.0
(byte) main::i
(byte) main::i#1 701.0
(byte) main::i#7 9191.181818181818
(byte) main::j
(byte) main::j#1 15001.5
(byte) main::j#5 15000.375
(byte) main::k
(byte) main::k#1 150001.5
(byte) main::k#2 60000.600000000006
(void()) sub_irq()
(byte~) sub_irq::$0 2.0000000002E10
(byte~) sub_irq::$1 2.0000000002E10
(byte) sub_irq::i
(byte) sub_irq::i#1 1.500000015E8
(byte) sub_irq::i#6 1.0200000003000001E9
(byte) sub_irq::j
(byte) sub_irq::j#1 1.5000000015E9
(byte) sub_irq::j#4 1.7142857147142856E9
(byte) sub_irq::k
(byte) sub_irq::k#1 1.50000000015E10
(byte) sub_irq::k#2 7.50000000075E9
(void()) sub_main()
(byte~) sub_main::$0 2.0000000000002E13
(byte~) sub_main::$1 2.0000000000002E13
(byte) sub_main::i
(byte) sub_main::i#1 1.500000000015E11
(byte) sub_main::i#6 1.0200000000002999E12
(byte) sub_main::j
(byte) sub_main::j#1 1.5000000000015E12
(byte) sub_main::j#4 1.7142857142861428E12
(byte) sub_main::k
(byte) sub_main::k#1 1.50000000000015E13
(byte) sub_main::k#2 7.50000000000075E12

Initial phi equivalence classes
[ main::i#7 main::i#1 ]
[ main::j#5 main::j#1 ]
[ main::k#2 main::k#1 ]
[ sub_main::i#6 sub_main::i#1 ]
[ sub_main::j#4 sub_main::j#1 ]
[ sub_main::k#2 sub_main::k#1 ]
[ irq::i#7 irq::i#1 ]
[ irq::j#4 irq::j#1 ]
[ irq::k#2 irq::k#1 ]
[ sub_irq::i#6 sub_irq::i#1 ]
[ sub_irq::j#4 sub_irq::j#1 ]
[ sub_irq::k#2 sub_irq::k#1 ]
Added variable main::$0 to live range equivalence class [ main::$0 ]
Added variable main::$1 to live range equivalence class [ main::$1 ]
Added variable sub_main::$0 to live range equivalence class [ sub_main::$0 ]
Added variable sub_main::$1 to live range equivalence class [ sub_main::$1 ]
Added variable irq::$2 to live range equivalence class [ irq::$2 ]
Added variable irq::$3 to live range equivalence class [ irq::$3 ]
Added variable sub_irq::$0 to live range equivalence class [ sub_irq::$0 ]
Added variable sub_irq::$1 to live range equivalence class [ sub_irq::$1 ]
Complete equivalence classes
[ main::i#7 main::i#1 ]
[ main::j#5 main::j#1 ]
[ main::k#2 main::k#1 ]
[ sub_main::i#6 sub_main::i#1 ]
[ sub_main::j#4 sub_main::j#1 ]
[ sub_main::k#2 sub_main::k#1 ]
[ irq::i#7 irq::i#1 ]
[ irq::j#4 irq::j#1 ]
[ irq::k#2 irq::k#1 ]
[ sub_irq::i#6 sub_irq::i#1 ]
[ sub_irq::j#4 sub_irq::j#1 ]
[ sub_irq::k#2 sub_irq::k#1 ]
[ main::$0 ]
[ main::$1 ]
[ sub_main::$0 ]
[ sub_main::$1 ]
[ irq::$2 ]
[ irq::$3 ]
[ sub_irq::$0 ]
[ sub_irq::$1 ]
Allocated zp[1]:2 [ main::i#7 main::i#1 ]
Allocated zp[1]:3 [ main::j#5 main::j#1 ]
Allocated zp[1]:4 [ main::k#2 main::k#1 ]
Allocated zp[1]:5 [ sub_main::i#6 sub_main::i#1 ]
Allocated zp[1]:6 [ sub_main::j#4 sub_main::j#1 ]
Allocated zp[1]:7 [ sub_main::k#2 sub_main::k#1 ]
Allocated zp[1]:8 [ irq::i#7 irq::i#1 ]
Allocated zp[1]:9 [ irq::j#4 irq::j#1 ]
Allocated zp[1]:10 [ irq::k#2 irq::k#1 ]
Allocated zp[1]:11 [ sub_irq::i#6 sub_irq::i#1 ]
Allocated zp[1]:12 [ sub_irq::j#4 sub_irq::j#1 ]
Allocated zp[1]:13 [ sub_irq::k#2 sub_irq::k#1 ]
Allocated zp[1]:14 [ main::$0 ]
Allocated zp[1]:15 [ main::$1 ]
Allocated zp[1]:16 [ sub_main::$0 ]
Allocated zp[1]:17 [ sub_main::$1 ]
Allocated zp[1]:18 [ irq::$2 ]
Allocated zp[1]:19 [ irq::$3 ]
Allocated zp[1]:20 [ sub_irq::$0 ]
Allocated zp[1]:21 [ sub_irq::$1 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Illustrates a problem where local variables inside an IRQ are assigned the same zeropage as a variable outside the IRQ
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label KERNEL_IRQ = $314
  .label RASTER = $d012
  .label VIC_CONTROL = $d011
  .label IRQ_STATUS = $d019
  .label IRQ_ENABLE = $d01a
  .const IRQ_RASTER = 1
  .label BGCOL = $d020
  .label FGCOL = $d021
  .label CIA1_INTERRUPT = $dc0d
  .const CIA_INTERRUPT_CLEAR = $7f
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label __0 = $e
    .label __1 = $f
    .label k = 4
    .label j = 3
    .label i = 2
    // asm { sei  }
    sei
    // [5] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
    // [6] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line to $0fd
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
    // [7] *((const byte*) RASTER) ← (byte) $fd -- _deref_pbuc1=vbuc2 
    lda #$fd
    sta RASTER
    // [8] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // [9] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq() -- _deref_pptc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta KERNEL_IRQ
    lda #>irq
    sta KERNEL_IRQ+1
    // asm { cli  }
    cli
    // [11] phi from main main::@5 to main::@1 [phi:main/main::@5->main::@1]
  __b1_from_main:
  __b1_from___b5:
    // [11] phi (byte) main::i#7 = (byte) 0 [phi:main/main::@5->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // main::@1
  __b1:
    // [12] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    // [12] phi (byte) main::j#5 = (byte) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    jmp __b2
    // [12] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  __b2_from___b4:
    // [12] phi (byte) main::j#5 = (byte) main::j#1 [phi:main::@4->main::@2#0] -- register_copy 
    jmp __b2
    // main::@2
  __b2:
    // [13] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [13] phi (byte) main::k#2 = (byte) 0 [phi:main::@2->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    jmp __b3
    // [13] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  __b3_from___b6:
    // [13] phi (byte) main::k#2 = (byte) main::k#1 [phi:main::@6->main::@3#0] -- register_copy 
    jmp __b3
    // main::@3
  __b3:
    // [14] (byte~) main::$0 ← (byte) main::i#7 + (byte) main::j#5 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z i
    clc
    adc.z j
    sta.z __0
    // [15] (byte~) main::$1 ← (byte~) main::$0 + (byte) main::k#2 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z __0
    clc
    adc.z k
    sta.z __1
    // [16] *((const byte*) FGCOL) ← (byte~) main::$1 -- _deref_pbuc1=vbuz1 
    lda.z __1
    sta FGCOL
    // [17] call sub_main 
    // [25] phi from main::@3 to sub_main [phi:main::@3->sub_main]
  sub_main_from___b3:
    jsr sub_main
    jmp __b6
    // main::@6
  __b6:
    // [18] (byte) main::k#1 ← ++ (byte) main::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [19] if((byte) main::k#1!=(byte) $b) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3_from___b6
    jmp __b4
    // main::@4
  __b4:
    // [20] (byte) main::j#1 ← ++ (byte) main::j#5 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [21] if((byte) main::j#1!=(byte) $b) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z j
    bne __b2_from___b4
    jmp __b5
    // main::@5
  __b5:
    // [22] (byte) main::i#1 ← ++ (byte) main::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [23] if((byte) main::i#1!=(byte) $b) goto main::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b7_from___b5
    jmp __b1_from___b5
    // [24] phi from main::@5 to main::@7 [phi:main::@5->main::@7]
  __b7_from___b5:
    jmp __b7
    // main::@7
  __b7:
    // [11] phi from main::@7 to main::@1 [phi:main::@7->main::@1]
  __b1_from___b7:
    // [11] phi (byte) main::i#7 = (byte) main::i#1 [phi:main::@7->main::@1#0] -- register_copy 
    jmp __b1
}
  // sub_main
sub_main: {
    .label __0 = $10
    .label __1 = $11
    .label k = 7
    .label j = 6
    .label i = 5
    // [26] phi from sub_main to sub_main::@1 [phi:sub_main->sub_main::@1]
  __b1_from_sub_main:
    // [26] phi (byte) sub_main::i#6 = (byte) 0 [phi:sub_main->sub_main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [26] phi from sub_main::@5 to sub_main::@1 [phi:sub_main::@5->sub_main::@1]
  __b1_from___b5:
    // [26] phi (byte) sub_main::i#6 = (byte) sub_main::i#1 [phi:sub_main::@5->sub_main::@1#0] -- register_copy 
    jmp __b1
    // sub_main::@1
  __b1:
    // [27] phi from sub_main::@1 to sub_main::@2 [phi:sub_main::@1->sub_main::@2]
  __b2_from___b1:
    // [27] phi (byte) sub_main::j#4 = (byte) 0 [phi:sub_main::@1->sub_main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    jmp __b2
    // [27] phi from sub_main::@4 to sub_main::@2 [phi:sub_main::@4->sub_main::@2]
  __b2_from___b4:
    // [27] phi (byte) sub_main::j#4 = (byte) sub_main::j#1 [phi:sub_main::@4->sub_main::@2#0] -- register_copy 
    jmp __b2
    // sub_main::@2
  __b2:
    // [28] phi from sub_main::@2 to sub_main::@3 [phi:sub_main::@2->sub_main::@3]
  __b3_from___b2:
    // [28] phi (byte) sub_main::k#2 = (byte) 0 [phi:sub_main::@2->sub_main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    jmp __b3
    // [28] phi from sub_main::@3 to sub_main::@3 [phi:sub_main::@3->sub_main::@3]
  __b3_from___b3:
    // [28] phi (byte) sub_main::k#2 = (byte) sub_main::k#1 [phi:sub_main::@3->sub_main::@3#0] -- register_copy 
    jmp __b3
    // sub_main::@3
  __b3:
    // [29] (byte~) sub_main::$0 ← (byte) sub_main::i#6 + (byte) sub_main::j#4 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z i
    clc
    adc.z j
    sta.z __0
    // [30] (byte~) sub_main::$1 ← (byte~) sub_main::$0 + (byte) sub_main::k#2 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z __0
    clc
    adc.z k
    sta.z __1
    // [31] *((const byte*) BGCOL) ← (byte~) sub_main::$1 -- _deref_pbuc1=vbuz1 
    lda.z __1
    sta BGCOL
    // [32] (byte) sub_main::k#1 ← ++ (byte) sub_main::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [33] if((byte) sub_main::k#1!=(byte) $b) goto sub_main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3_from___b3
    jmp __b4
    // sub_main::@4
  __b4:
    // [34] (byte) sub_main::j#1 ← ++ (byte) sub_main::j#4 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [35] if((byte) sub_main::j#1!=(byte) $b) goto sub_main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z j
    bne __b2_from___b4
    jmp __b5
    // sub_main::@5
  __b5:
    // [36] (byte) sub_main::i#1 ← ++ (byte) sub_main::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [37] if((byte) sub_main::i#1!=(byte) $b) goto sub_main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1_from___b5
    jmp __breturn
    // sub_main::@return
  __breturn:
    // [38] return 
    rts
}
  // irq
irq: {
    .label __2 = $12
    .label __3 = $13
    .label k = $a
    .label j = 9
    .label i = 8
    // entry interrupt(KERNEL_MIN)
    // [39] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [40] phi from irq to irq::@1 [phi:irq->irq::@1]
  __b1_from_irq:
    // [40] phi (byte) irq::i#7 = (byte) 0 [phi:irq->irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [40] phi from irq::@5 to irq::@1 [phi:irq::@5->irq::@1]
  __b1_from___b5:
    // [40] phi (byte) irq::i#7 = (byte) irq::i#1 [phi:irq::@5->irq::@1#0] -- register_copy 
    jmp __b1
    // irq::@1
  __b1:
    // [41] phi from irq::@1 to irq::@2 [phi:irq::@1->irq::@2]
  __b2_from___b1:
    // [41] phi (byte) irq::j#4 = (byte) 0 [phi:irq::@1->irq::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    jmp __b2
    // [41] phi from irq::@4 to irq::@2 [phi:irq::@4->irq::@2]
  __b2_from___b4:
    // [41] phi (byte) irq::j#4 = (byte) irq::j#1 [phi:irq::@4->irq::@2#0] -- register_copy 
    jmp __b2
    // irq::@2
  __b2:
    // [42] phi from irq::@2 to irq::@3 [phi:irq::@2->irq::@3]
  __b3_from___b2:
    // [42] phi (byte) irq::k#2 = (byte) 0 [phi:irq::@2->irq::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    jmp __b3
    // [42] phi from irq::@7 to irq::@3 [phi:irq::@7->irq::@3]
  __b3_from___b7:
    // [42] phi (byte) irq::k#2 = (byte) irq::k#1 [phi:irq::@7->irq::@3#0] -- register_copy 
    jmp __b3
    // irq::@3
  __b3:
    // [43] (byte~) irq::$2 ← (byte) irq::i#7 + (byte) irq::j#4 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z i
    clc
    adc.z j
    sta.z __2
    // [44] (byte~) irq::$3 ← (byte~) irq::$2 + (byte) irq::k#2 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z __2
    clc
    adc.z k
    sta.z __3
    // [45] *((const byte*) FGCOL) ← (byte~) irq::$3 -- _deref_pbuc1=vbuz1 
    lda.z __3
    sta FGCOL
    // [46] call sub_irq 
    // [56] phi from irq::@3 to sub_irq [phi:irq::@3->sub_irq]
  sub_irq_from___b3:
    jsr sub_irq
    jmp __b7
    // irq::@7
  __b7:
    // [47] (byte) irq::k#1 ← ++ (byte) irq::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [48] if((byte) irq::k#1!=(byte) $b) goto irq::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3_from___b7
    jmp __b4
    // irq::@4
  __b4:
    // [49] (byte) irq::j#1 ← ++ (byte) irq::j#4 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [50] if((byte) irq::j#1!=(byte) $b) goto irq::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z j
    bne __b2_from___b4
    jmp __b5
    // irq::@5
  __b5:
    // [51] (byte) irq::i#1 ← ++ (byte) irq::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [52] if((byte) irq::i#1!=(byte) $b) goto irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1_from___b5
    jmp __b6
    // irq::@6
  __b6:
    // [53] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // [54] *((const byte*) BGCOL) ← -- *((const byte*) BGCOL) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec BGCOL
    jmp __breturn
    // irq::@return
  __breturn:
    // [55] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
}
  // sub_irq
sub_irq: {
    .label __0 = $14
    .label __1 = $15
    .label k = $d
    .label j = $c
    .label i = $b
    // [57] phi from sub_irq to sub_irq::@1 [phi:sub_irq->sub_irq::@1]
  __b1_from_sub_irq:
    // [57] phi (byte) sub_irq::i#6 = (byte) 0 [phi:sub_irq->sub_irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [57] phi from sub_irq::@5 to sub_irq::@1 [phi:sub_irq::@5->sub_irq::@1]
  __b1_from___b5:
    // [57] phi (byte) sub_irq::i#6 = (byte) sub_irq::i#1 [phi:sub_irq::@5->sub_irq::@1#0] -- register_copy 
    jmp __b1
    // sub_irq::@1
  __b1:
    // [58] phi from sub_irq::@1 to sub_irq::@2 [phi:sub_irq::@1->sub_irq::@2]
  __b2_from___b1:
    // [58] phi (byte) sub_irq::j#4 = (byte) 0 [phi:sub_irq::@1->sub_irq::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    jmp __b2
    // [58] phi from sub_irq::@4 to sub_irq::@2 [phi:sub_irq::@4->sub_irq::@2]
  __b2_from___b4:
    // [58] phi (byte) sub_irq::j#4 = (byte) sub_irq::j#1 [phi:sub_irq::@4->sub_irq::@2#0] -- register_copy 
    jmp __b2
    // sub_irq::@2
  __b2:
    // [59] phi from sub_irq::@2 to sub_irq::@3 [phi:sub_irq::@2->sub_irq::@3]
  __b3_from___b2:
    // [59] phi (byte) sub_irq::k#2 = (byte) 0 [phi:sub_irq::@2->sub_irq::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    jmp __b3
    // [59] phi from sub_irq::@3 to sub_irq::@3 [phi:sub_irq::@3->sub_irq::@3]
  __b3_from___b3:
    // [59] phi (byte) sub_irq::k#2 = (byte) sub_irq::k#1 [phi:sub_irq::@3->sub_irq::@3#0] -- register_copy 
    jmp __b3
    // sub_irq::@3
  __b3:
    // [60] (byte~) sub_irq::$0 ← (byte) sub_irq::i#6 + (byte) sub_irq::j#4 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z i
    clc
    adc.z j
    sta.z __0
    // [61] (byte~) sub_irq::$1 ← (byte~) sub_irq::$0 + (byte) sub_irq::k#2 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z __0
    clc
    adc.z k
    sta.z __1
    // [62] *((const byte*) BGCOL) ← (byte~) sub_irq::$1 -- _deref_pbuc1=vbuz1 
    lda.z __1
    sta BGCOL
    // [63] (byte) sub_irq::k#1 ← ++ (byte) sub_irq::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [64] if((byte) sub_irq::k#1!=(byte) $b) goto sub_irq::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3_from___b3
    jmp __b4
    // sub_irq::@4
  __b4:
    // [65] (byte) sub_irq::j#1 ← ++ (byte) sub_irq::j#4 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [66] if((byte) sub_irq::j#1!=(byte) $b) goto sub_irq::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z j
    bne __b2_from___b4
    jmp __b5
    // sub_irq::@5
  __b5:
    // [67] (byte) sub_irq::i#1 ← ++ (byte) sub_irq::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [68] if((byte) sub_irq::i#1!=(byte) $b) goto sub_irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1_from___b5
    jmp __breturn
    // sub_irq::@return
  __breturn:
    // [69] return 
    rts
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [5] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [7] *((const byte*) RASTER) ← (byte) $fd [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq() [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [14] (byte~) main::$0 ← (byte) main::i#7 + (byte) main::j#5 [ main::i#7 main::j#5 main::k#2 main::$0 ] (  [ main::i#7 main::j#5 main::k#2 main::$0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::i#7 main::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ main::j#5 main::j#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:4 [ main::k#2 main::k#1 ]
Statement [15] (byte~) main::$1 ← (byte~) main::$0 + (byte) main::k#2 [ main::i#7 main::j#5 main::k#2 main::$1 ] (  [ main::i#7 main::j#5 main::k#2 main::$1 ] { }  ) always clobbers reg byte a 
Statement [29] (byte~) sub_main::$0 ← (byte) sub_main::i#6 + (byte) sub_main::j#4 [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$0 ] (  [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$0 main::i#7 main::j#5 main::k#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ sub_main::i#6 sub_main::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ sub_main::j#4 sub_main::j#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ sub_main::k#2 sub_main::k#1 ]
Statement [30] (byte~) sub_main::$1 ← (byte~) sub_main::$0 + (byte) sub_main::k#2 [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$1 ] (  [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$1 main::i#7 main::j#5 main::k#2 ] { }  ) always clobbers reg byte a 
Statement [43] (byte~) irq::$2 ← (byte) irq::i#7 + (byte) irq::j#4 [ irq::i#7 irq::j#4 irq::k#2 irq::$2 ] (  [ irq::i#7 irq::j#4 irq::k#2 irq::$2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:8 [ irq::i#7 irq::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:9 [ irq::j#4 irq::j#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:10 [ irq::k#2 irq::k#1 ]
Statement [44] (byte~) irq::$3 ← (byte~) irq::$2 + (byte) irq::k#2 [ irq::i#7 irq::j#4 irq::k#2 irq::$3 ] (  [ irq::i#7 irq::j#4 irq::k#2 irq::$3 ] { }  ) always clobbers reg byte a 
Statement [53] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [60] (byte~) sub_irq::$0 ← (byte) sub_irq::i#6 + (byte) sub_irq::j#4 [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$0 ] (  [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$0 irq::i#7 irq::j#4 irq::k#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:11 [ sub_irq::i#6 sub_irq::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:12 [ sub_irq::j#4 sub_irq::j#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:13 [ sub_irq::k#2 sub_irq::k#1 ]
Statement [61] (byte~) sub_irq::$1 ← (byte~) sub_irq::$0 + (byte) sub_irq::k#2 [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$1 ] (  [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$1 irq::i#7 irq::j#4 irq::k#2 ] { }  ) always clobbers reg byte a 
Statement [5] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [7] *((const byte*) RASTER) ← (byte) $fd [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq() [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [14] (byte~) main::$0 ← (byte) main::i#7 + (byte) main::j#5 [ main::i#7 main::j#5 main::k#2 main::$0 ] (  [ main::i#7 main::j#5 main::k#2 main::$0 ] { }  ) always clobbers reg byte a 
Statement [15] (byte~) main::$1 ← (byte~) main::$0 + (byte) main::k#2 [ main::i#7 main::j#5 main::k#2 main::$1 ] (  [ main::i#7 main::j#5 main::k#2 main::$1 ] { }  ) always clobbers reg byte a 
Statement [29] (byte~) sub_main::$0 ← (byte) sub_main::i#6 + (byte) sub_main::j#4 [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$0 ] (  [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$0 main::i#7 main::j#5 main::k#2 ] { }  ) always clobbers reg byte a 
Statement [30] (byte~) sub_main::$1 ← (byte~) sub_main::$0 + (byte) sub_main::k#2 [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$1 ] (  [ sub_main::i#6 sub_main::j#4 sub_main::k#2 sub_main::$1 main::i#7 main::j#5 main::k#2 ] { }  ) always clobbers reg byte a 
Statement [43] (byte~) irq::$2 ← (byte) irq::i#7 + (byte) irq::j#4 [ irq::i#7 irq::j#4 irq::k#2 irq::$2 ] (  [ irq::i#7 irq::j#4 irq::k#2 irq::$2 ] { }  ) always clobbers reg byte a 
Statement [44] (byte~) irq::$3 ← (byte~) irq::$2 + (byte) irq::k#2 [ irq::i#7 irq::j#4 irq::k#2 irq::$3 ] (  [ irq::i#7 irq::j#4 irq::k#2 irq::$3 ] { }  ) always clobbers reg byte a 
Statement [53] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [60] (byte~) sub_irq::$0 ← (byte) sub_irq::i#6 + (byte) sub_irq::j#4 [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$0 ] (  [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$0 irq::i#7 irq::j#4 irq::k#2 ] { }  ) always clobbers reg byte a 
Statement [61] (byte~) sub_irq::$1 ← (byte~) sub_irq::$0 + (byte) sub_irq::k#2 [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$1 ] (  [ sub_irq::i#6 sub_irq::j#4 sub_irq::k#2 sub_irq::$1 irq::i#7 irq::j#4 irq::k#2 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::i#7 main::i#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ main::j#5 main::j#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ main::k#2 main::k#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ sub_main::i#6 sub_main::i#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ sub_main::j#4 sub_main::j#1 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ sub_main::k#2 sub_main::k#1 ] : zp[1]:7 , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ irq::i#7 irq::i#1 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ irq::j#4 irq::j#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ irq::k#2 irq::k#1 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ sub_irq::i#6 sub_irq::i#1 ] : zp[1]:11 , reg byte x , reg byte y , 
Potential registers zp[1]:12 [ sub_irq::j#4 sub_irq::j#1 ] : zp[1]:12 , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ sub_irq::k#2 sub_irq::k#1 ] : zp[1]:13 , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ main::$0 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ main::$1 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ sub_main::$0 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ sub_main::$1 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:18 [ irq::$2 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:19 [ irq::$3 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:20 [ sub_irq::$0 ] : zp[1]:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:21 [ sub_irq::$1 ] : zp[1]:21 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [sub_main] 22,500,000,000,002.25: zp[1]:7 [ sub_main::k#2 sub_main::k#1 ] 20,000,000,000,002: zp[1]:16 [ sub_main::$0 ] 20,000,000,000,002: zp[1]:17 [ sub_main::$1 ] 3,214,285,714,287.64: zp[1]:6 [ sub_main::j#4 sub_main::j#1 ] 1,170,000,000,001.8: zp[1]:5 [ sub_main::i#6 sub_main::i#1 ] 
Uplift Scope [sub_irq] 22,500,000,002.25: zp[1]:13 [ sub_irq::k#2 sub_irq::k#1 ] 20,000,000,002: zp[1]:20 [ sub_irq::$0 ] 20,000,000,002: zp[1]:21 [ sub_irq::$1 ] 3,214,285,716.21: zp[1]:12 [ sub_irq::j#4 sub_irq::j#1 ] 1,170,000,001.8: zp[1]:11 [ sub_irq::i#6 sub_irq::i#1 ] 
Uplift Scope [main] 210,002.1: zp[1]:4 [ main::k#2 main::k#1 ] 200,002: zp[1]:14 [ main::$0 ] 200,002: zp[1]:15 [ main::$1 ] 30,001.88: zp[1]:3 [ main::j#5 main::j#1 ] 9,892.18: zp[1]:2 [ main::i#7 main::i#1 ] 
Uplift Scope [irq] 2,102.1: zp[1]:10 [ irq::k#2 irq::k#1 ] 2,002: zp[1]:18 [ irq::$2 ] 2,002: zp[1]:19 [ irq::$3 ] 301.88: zp[1]:9 [ irq::j#4 irq::j#1 ] 109.5: zp[1]:8 [ irq::i#7 irq::i#1 ] 
Uplift Scope [] 

Uplifting [sub_main] best 444207705 combination reg byte y [ sub_main::k#2 sub_main::k#1 ] reg byte a [ sub_main::$0 ] reg byte a [ sub_main::$1 ] reg byte x [ sub_main::j#4 sub_main::j#1 ] zp[1]:5 [ sub_main::i#6 sub_main::i#1 ] 
Limited combination testing to 100 combinations of 432 possible.
Uplifting [sub_irq] best 424307705 combination reg byte y [ sub_irq::k#2 sub_irq::k#1 ] reg byte a [ sub_irq::$0 ] reg byte a [ sub_irq::$1 ] reg byte x [ sub_irq::j#4 sub_irq::j#1 ] zp[1]:11 [ sub_irq::i#6 sub_irq::i#1 ] 
Limited combination testing to 100 combinations of 432 possible.
Uplifting [main] best 424187705 combination zp[1]:4 [ main::k#2 main::k#1 ] reg byte a [ main::$0 ] reg byte a [ main::$1 ] zp[1]:3 [ main::j#5 main::j#1 ] zp[1]:2 [ main::i#7 main::i#1 ] 
Limited combination testing to 100 combinations of 432 possible.
Uplifting [irq] best 424175705 combination zp[1]:10 [ irq::k#2 irq::k#1 ] reg byte a [ irq::$2 ] reg byte a [ irq::$3 ] zp[1]:9 [ irq::j#4 irq::j#1 ] zp[1]:8 [ irq::i#7 irq::i#1 ] 
Limited combination testing to 100 combinations of 432 possible.
Uplifting [] best 424175705 combination 
Attempting to uplift remaining variables inzp[1]:5 [ sub_main::i#6 sub_main::i#1 ]
Uplifting [sub_main] best 424175705 combination zp[1]:5 [ sub_main::i#6 sub_main::i#1 ] 
Attempting to uplift remaining variables inzp[1]:11 [ sub_irq::i#6 sub_irq::i#1 ]
Uplifting [sub_irq] best 424175705 combination zp[1]:11 [ sub_irq::i#6 sub_irq::i#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ main::k#2 main::k#1 ]
Uplifting [main] best 424175705 combination zp[1]:4 [ main::k#2 main::k#1 ] 
Attempting to uplift remaining variables inzp[1]:3 [ main::j#5 main::j#1 ]
Uplifting [main] best 424175705 combination zp[1]:3 [ main::j#5 main::j#1 ] 
Attempting to uplift remaining variables inzp[1]:2 [ main::i#7 main::i#1 ]
Uplifting [main] best 424175705 combination zp[1]:2 [ main::i#7 main::i#1 ] 
Attempting to uplift remaining variables inzp[1]:10 [ irq::k#2 irq::k#1 ]
Uplifting [irq] best 424175705 combination zp[1]:10 [ irq::k#2 irq::k#1 ] 
Attempting to uplift remaining variables inzp[1]:9 [ irq::j#4 irq::j#1 ]
Uplifting [irq] best 424175705 combination zp[1]:9 [ irq::j#4 irq::j#1 ] 
Attempting to uplift remaining variables inzp[1]:8 [ irq::i#7 irq::i#1 ]
Uplifting [irq] best 424175705 combination zp[1]:8 [ irq::i#7 irq::i#1 ] 
Allocated (was zp[1]:8) zp[1]:6 [ irq::i#7 irq::i#1 ]
Allocated (was zp[1]:9) zp[1]:7 [ irq::j#4 irq::j#1 ]
Allocated (was zp[1]:10) zp[1]:8 [ irq::k#2 irq::k#1 ]
Allocated (was zp[1]:11) zp[1]:9 [ sub_irq::i#6 sub_irq::i#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Illustrates a problem where local variables inside an IRQ are assigned the same zeropage as a variable outside the IRQ
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label KERNEL_IRQ = $314
  .label RASTER = $d012
  .label VIC_CONTROL = $d011
  .label IRQ_STATUS = $d019
  .label IRQ_ENABLE = $d01a
  .const IRQ_RASTER = 1
  .label BGCOL = $d020
  .label FGCOL = $d021
  .label CIA1_INTERRUPT = $dc0d
  .const CIA_INTERRUPT_CLEAR = $7f
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label k = 4
    .label j = 3
    .label i = 2
    // asm { sei  }
    sei
    // [5] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
    // [6] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line to $0fd
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
    // [7] *((const byte*) RASTER) ← (byte) $fd -- _deref_pbuc1=vbuc2 
    lda #$fd
    sta RASTER
    // [8] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // [9] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq() -- _deref_pptc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta KERNEL_IRQ
    lda #>irq
    sta KERNEL_IRQ+1
    // asm { cli  }
    cli
    // [11] phi from main main::@5 to main::@1 [phi:main/main::@5->main::@1]
  __b1_from_main:
  __b1_from___b5:
    // [11] phi (byte) main::i#7 = (byte) 0 [phi:main/main::@5->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // main::@1
  __b1:
    // [12] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    // [12] phi (byte) main::j#5 = (byte) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    jmp __b2
    // [12] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  __b2_from___b4:
    // [12] phi (byte) main::j#5 = (byte) main::j#1 [phi:main::@4->main::@2#0] -- register_copy 
    jmp __b2
    // main::@2
  __b2:
    // [13] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [13] phi (byte) main::k#2 = (byte) 0 [phi:main::@2->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    jmp __b3
    // [13] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  __b3_from___b6:
    // [13] phi (byte) main::k#2 = (byte) main::k#1 [phi:main::@6->main::@3#0] -- register_copy 
    jmp __b3
    // main::@3
  __b3:
    // [14] (byte~) main::$0 ← (byte) main::i#7 + (byte) main::j#5 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z i
    clc
    adc.z j
    // [15] (byte~) main::$1 ← (byte~) main::$0 + (byte) main::k#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z k
    // [16] *((const byte*) FGCOL) ← (byte~) main::$1 -- _deref_pbuc1=vbuaa 
    sta FGCOL
    // [17] call sub_main 
    // [25] phi from main::@3 to sub_main [phi:main::@3->sub_main]
  sub_main_from___b3:
    jsr sub_main
    jmp __b6
    // main::@6
  __b6:
    // [18] (byte) main::k#1 ← ++ (byte) main::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [19] if((byte) main::k#1!=(byte) $b) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3_from___b6
    jmp __b4
    // main::@4
  __b4:
    // [20] (byte) main::j#1 ← ++ (byte) main::j#5 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [21] if((byte) main::j#1!=(byte) $b) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z j
    bne __b2_from___b4
    jmp __b5
    // main::@5
  __b5:
    // [22] (byte) main::i#1 ← ++ (byte) main::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [23] if((byte) main::i#1!=(byte) $b) goto main::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b7_from___b5
    jmp __b1_from___b5
    // [24] phi from main::@5 to main::@7 [phi:main::@5->main::@7]
  __b7_from___b5:
    jmp __b7
    // main::@7
  __b7:
    // [11] phi from main::@7 to main::@1 [phi:main::@7->main::@1]
  __b1_from___b7:
    // [11] phi (byte) main::i#7 = (byte) main::i#1 [phi:main::@7->main::@1#0] -- register_copy 
    jmp __b1
}
  // sub_main
sub_main: {
    .label i = 5
    // [26] phi from sub_main to sub_main::@1 [phi:sub_main->sub_main::@1]
  __b1_from_sub_main:
    // [26] phi (byte) sub_main::i#6 = (byte) 0 [phi:sub_main->sub_main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [26] phi from sub_main::@5 to sub_main::@1 [phi:sub_main::@5->sub_main::@1]
  __b1_from___b5:
    // [26] phi (byte) sub_main::i#6 = (byte) sub_main::i#1 [phi:sub_main::@5->sub_main::@1#0] -- register_copy 
    jmp __b1
    // sub_main::@1
  __b1:
    // [27] phi from sub_main::@1 to sub_main::@2 [phi:sub_main::@1->sub_main::@2]
  __b2_from___b1:
    // [27] phi (byte) sub_main::j#4 = (byte) 0 [phi:sub_main::@1->sub_main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b2
    // [27] phi from sub_main::@4 to sub_main::@2 [phi:sub_main::@4->sub_main::@2]
  __b2_from___b4:
    // [27] phi (byte) sub_main::j#4 = (byte) sub_main::j#1 [phi:sub_main::@4->sub_main::@2#0] -- register_copy 
    jmp __b2
    // sub_main::@2
  __b2:
    // [28] phi from sub_main::@2 to sub_main::@3 [phi:sub_main::@2->sub_main::@3]
  __b3_from___b2:
    // [28] phi (byte) sub_main::k#2 = (byte) 0 [phi:sub_main::@2->sub_main::@3#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b3
    // [28] phi from sub_main::@3 to sub_main::@3 [phi:sub_main::@3->sub_main::@3]
  __b3_from___b3:
    // [28] phi (byte) sub_main::k#2 = (byte) sub_main::k#1 [phi:sub_main::@3->sub_main::@3#0] -- register_copy 
    jmp __b3
    // sub_main::@3
  __b3:
    // [29] (byte~) sub_main::$0 ← (byte) sub_main::i#6 + (byte) sub_main::j#4 -- vbuaa=vbuz1_plus_vbuxx 
    txa
    clc
    adc.z i
    // [30] (byte~) sub_main::$1 ← (byte~) sub_main::$0 + (byte) sub_main::k#2 -- vbuaa=vbuaa_plus_vbuyy 
    sty.z $ff
    clc
    adc.z $ff
    // [31] *((const byte*) BGCOL) ← (byte~) sub_main::$1 -- _deref_pbuc1=vbuaa 
    sta BGCOL
    // [32] (byte) sub_main::k#1 ← ++ (byte) sub_main::k#2 -- vbuyy=_inc_vbuyy 
    iny
    // [33] if((byte) sub_main::k#1!=(byte) $b) goto sub_main::@3 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne __b3_from___b3
    jmp __b4
    // sub_main::@4
  __b4:
    // [34] (byte) sub_main::j#1 ← ++ (byte) sub_main::j#4 -- vbuxx=_inc_vbuxx 
    inx
    // [35] if((byte) sub_main::j#1!=(byte) $b) goto sub_main::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne __b2_from___b4
    jmp __b5
    // sub_main::@5
  __b5:
    // [36] (byte) sub_main::i#1 ← ++ (byte) sub_main::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [37] if((byte) sub_main::i#1!=(byte) $b) goto sub_main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1_from___b5
    jmp __breturn
    // sub_main::@return
  __breturn:
    // [38] return 
    rts
}
  // irq
irq: {
    .label k = 8
    .label j = 7
    .label i = 6
    // entry interrupt(KERNEL_MIN)
    // [39] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [40] phi from irq to irq::@1 [phi:irq->irq::@1]
  __b1_from_irq:
    // [40] phi (byte) irq::i#7 = (byte) 0 [phi:irq->irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [40] phi from irq::@5 to irq::@1 [phi:irq::@5->irq::@1]
  __b1_from___b5:
    // [40] phi (byte) irq::i#7 = (byte) irq::i#1 [phi:irq::@5->irq::@1#0] -- register_copy 
    jmp __b1
    // irq::@1
  __b1:
    // [41] phi from irq::@1 to irq::@2 [phi:irq::@1->irq::@2]
  __b2_from___b1:
    // [41] phi (byte) irq::j#4 = (byte) 0 [phi:irq::@1->irq::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    jmp __b2
    // [41] phi from irq::@4 to irq::@2 [phi:irq::@4->irq::@2]
  __b2_from___b4:
    // [41] phi (byte) irq::j#4 = (byte) irq::j#1 [phi:irq::@4->irq::@2#0] -- register_copy 
    jmp __b2
    // irq::@2
  __b2:
    // [42] phi from irq::@2 to irq::@3 [phi:irq::@2->irq::@3]
  __b3_from___b2:
    // [42] phi (byte) irq::k#2 = (byte) 0 [phi:irq::@2->irq::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    jmp __b3
    // [42] phi from irq::@7 to irq::@3 [phi:irq::@7->irq::@3]
  __b3_from___b7:
    // [42] phi (byte) irq::k#2 = (byte) irq::k#1 [phi:irq::@7->irq::@3#0] -- register_copy 
    jmp __b3
    // irq::@3
  __b3:
    // [43] (byte~) irq::$2 ← (byte) irq::i#7 + (byte) irq::j#4 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z i
    clc
    adc.z j
    // [44] (byte~) irq::$3 ← (byte~) irq::$2 + (byte) irq::k#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z k
    // [45] *((const byte*) FGCOL) ← (byte~) irq::$3 -- _deref_pbuc1=vbuaa 
    sta FGCOL
    // [46] call sub_irq 
    // [56] phi from irq::@3 to sub_irq [phi:irq::@3->sub_irq]
  sub_irq_from___b3:
    jsr sub_irq
    jmp __b7
    // irq::@7
  __b7:
    // [47] (byte) irq::k#1 ← ++ (byte) irq::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [48] if((byte) irq::k#1!=(byte) $b) goto irq::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3_from___b7
    jmp __b4
    // irq::@4
  __b4:
    // [49] (byte) irq::j#1 ← ++ (byte) irq::j#4 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [50] if((byte) irq::j#1!=(byte) $b) goto irq::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z j
    bne __b2_from___b4
    jmp __b5
    // irq::@5
  __b5:
    // [51] (byte) irq::i#1 ← ++ (byte) irq::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [52] if((byte) irq::i#1!=(byte) $b) goto irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1_from___b5
    jmp __b6
    // irq::@6
  __b6:
    // [53] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // [54] *((const byte*) BGCOL) ← -- *((const byte*) BGCOL) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec BGCOL
    jmp __breturn
    // irq::@return
  __breturn:
    // [55] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
}
  // sub_irq
sub_irq: {
    .label i = 9
    // [57] phi from sub_irq to sub_irq::@1 [phi:sub_irq->sub_irq::@1]
  __b1_from_sub_irq:
    // [57] phi (byte) sub_irq::i#6 = (byte) 0 [phi:sub_irq->sub_irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [57] phi from sub_irq::@5 to sub_irq::@1 [phi:sub_irq::@5->sub_irq::@1]
  __b1_from___b5:
    // [57] phi (byte) sub_irq::i#6 = (byte) sub_irq::i#1 [phi:sub_irq::@5->sub_irq::@1#0] -- register_copy 
    jmp __b1
    // sub_irq::@1
  __b1:
    // [58] phi from sub_irq::@1 to sub_irq::@2 [phi:sub_irq::@1->sub_irq::@2]
  __b2_from___b1:
    // [58] phi (byte) sub_irq::j#4 = (byte) 0 [phi:sub_irq::@1->sub_irq::@2#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b2
    // [58] phi from sub_irq::@4 to sub_irq::@2 [phi:sub_irq::@4->sub_irq::@2]
  __b2_from___b4:
    // [58] phi (byte) sub_irq::j#4 = (byte) sub_irq::j#1 [phi:sub_irq::@4->sub_irq::@2#0] -- register_copy 
    jmp __b2
    // sub_irq::@2
  __b2:
    // [59] phi from sub_irq::@2 to sub_irq::@3 [phi:sub_irq::@2->sub_irq::@3]
  __b3_from___b2:
    // [59] phi (byte) sub_irq::k#2 = (byte) 0 [phi:sub_irq::@2->sub_irq::@3#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b3
    // [59] phi from sub_irq::@3 to sub_irq::@3 [phi:sub_irq::@3->sub_irq::@3]
  __b3_from___b3:
    // [59] phi (byte) sub_irq::k#2 = (byte) sub_irq::k#1 [phi:sub_irq::@3->sub_irq::@3#0] -- register_copy 
    jmp __b3
    // sub_irq::@3
  __b3:
    // [60] (byte~) sub_irq::$0 ← (byte) sub_irq::i#6 + (byte) sub_irq::j#4 -- vbuaa=vbuz1_plus_vbuxx 
    txa
    clc
    adc.z i
    // [61] (byte~) sub_irq::$1 ← (byte~) sub_irq::$0 + (byte) sub_irq::k#2 -- vbuaa=vbuaa_plus_vbuyy 
    sty.z $ff
    clc
    adc.z $ff
    // [62] *((const byte*) BGCOL) ← (byte~) sub_irq::$1 -- _deref_pbuc1=vbuaa 
    sta BGCOL
    // [63] (byte) sub_irq::k#1 ← ++ (byte) sub_irq::k#2 -- vbuyy=_inc_vbuyy 
    iny
    // [64] if((byte) sub_irq::k#1!=(byte) $b) goto sub_irq::@3 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne __b3_from___b3
    jmp __b4
    // sub_irq::@4
  __b4:
    // [65] (byte) sub_irq::j#1 ← ++ (byte) sub_irq::j#4 -- vbuxx=_inc_vbuxx 
    inx
    // [66] if((byte) sub_irq::j#1!=(byte) $b) goto sub_irq::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne __b2_from___b4
    jmp __b5
    // sub_irq::@5
  __b5:
    // [67] (byte) sub_irq::i#1 ← ++ (byte) sub_irq::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [68] if((byte) sub_irq::i#1!=(byte) $b) goto sub_irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1_from___b5
    jmp __breturn
    // sub_irq::@return
  __breturn:
    // [69] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b6
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b7
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b3_from___b6 with __b3
Replacing label __b2_from___b4 with __b2
Replacing label __b7_from___b5 with __b7
Replacing label __b3_from___b3 with __b3
Replacing label __b2_from___b4 with __b2
Replacing label __b1_from___b5 with __b1
Replacing label __b3_from___b7 with __b3
Replacing label __b2_from___b4 with __b2
Replacing label __b1_from___b5 with __b1
Replacing label __b3_from___b3 with __b3
Replacing label __b2_from___b4 with __b2
Replacing label __b1_from___b5 with __b1
Removing instruction __b1_from___bbegin:
Removing instruction __b1:
Removing instruction __bend_from___b1:
Removing instruction __b1_from_main:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b6:
Removing instruction __b7_from___b5:
Removing instruction __b1_from___b7:
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b3:
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b7:
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction sub_main_from___b3:
Removing instruction __b6:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b1_from_sub_main:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __breturn:
Removing instruction __b1_from_irq:
Removing instruction sub_irq_from___b3:
Removing instruction __b7:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __breturn:
Removing instruction __b1_from_sub_irq:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Skipping double jump to __b1 in bne __b7
Succesful ASM optimization Pass5DoubleJumpElimination
Relabelling long label __b1_from___b5 to b1
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #$b
Removing instruction lda #$b
Removing instruction lda #$b
Removing instruction lda #$b
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __bbegin:
Removing instruction __b7:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing unreachable instruction jmp __b1
Succesful ASM optimization Pass5UnreachableCodeElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) BGCOL = (byte*) 53280
(const byte*) CIA1_INTERRUPT = (byte*) 56333
(const byte) CIA_INTERRUPT_CLEAR = (byte) $7f
(const byte*) FGCOL = (byte*) 53281
(const byte*) IRQ_ENABLE = (byte*) 53274
(const byte) IRQ_RASTER = (byte) 1
(const byte*) IRQ_STATUS = (byte*) 53273
(const void()**) KERNEL_IRQ = (void()**) 788
(const byte*) RASTER = (byte*) 53266
(const byte*) VIC_CONTROL = (byte*) 53265
interrupt(KERNEL_MIN)(void()) irq()
(byte~) irq::$2 reg byte a 2002.0
(byte~) irq::$3 reg byte a 2002.0
(label) irq::@1
(label) irq::@2
(label) irq::@3
(label) irq::@4
(label) irq::@5
(label) irq::@6
(label) irq::@7
(label) irq::@return
(byte) irq::i
(byte) irq::i#1 i zp[1]:6 16.5
(byte) irq::i#7 i zp[1]:6 93.0
(byte) irq::j
(byte) irq::j#1 j zp[1]:7 151.5
(byte) irq::j#4 j zp[1]:7 150.375
(byte) irq::k
(byte) irq::k#1 k zp[1]:8 1501.5
(byte) irq::k#2 k zp[1]:8 600.5999999999999
(void()) main()
(byte~) main::$0 reg byte a 200002.0
(byte~) main::$1 reg byte a 200002.0
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(byte) main::i
(byte) main::i#1 i zp[1]:2 701.0
(byte) main::i#7 i zp[1]:2 9191.181818181818
(byte) main::j
(byte) main::j#1 j zp[1]:3 15001.5
(byte) main::j#5 j zp[1]:3 15000.375
(byte) main::k
(byte) main::k#1 k zp[1]:4 150001.5
(byte) main::k#2 k zp[1]:4 60000.600000000006
(void()) sub_irq()
(byte~) sub_irq::$0 reg byte a 2.0000000002E10
(byte~) sub_irq::$1 reg byte a 2.0000000002E10
(label) sub_irq::@1
(label) sub_irq::@2
(label) sub_irq::@3
(label) sub_irq::@4
(label) sub_irq::@5
(label) sub_irq::@return
(byte) sub_irq::i
(byte) sub_irq::i#1 i zp[1]:9 1.500000015E8
(byte) sub_irq::i#6 i zp[1]:9 1.0200000003000001E9
(byte) sub_irq::j
(byte) sub_irq::j#1 reg byte x 1.5000000015E9
(byte) sub_irq::j#4 reg byte x 1.7142857147142856E9
(byte) sub_irq::k
(byte) sub_irq::k#1 reg byte y 1.50000000015E10
(byte) sub_irq::k#2 reg byte y 7.50000000075E9
(void()) sub_main()
(byte~) sub_main::$0 reg byte a 2.0000000000002E13
(byte~) sub_main::$1 reg byte a 2.0000000000002E13
(label) sub_main::@1
(label) sub_main::@2
(label) sub_main::@3
(label) sub_main::@4
(label) sub_main::@5
(label) sub_main::@return
(byte) sub_main::i
(byte) sub_main::i#1 i zp[1]:5 1.500000000015E11
(byte) sub_main::i#6 i zp[1]:5 1.0200000000002999E12
(byte) sub_main::j
(byte) sub_main::j#1 reg byte x 1.5000000000015E12
(byte) sub_main::j#4 reg byte x 1.7142857142861428E12
(byte) sub_main::k
(byte) sub_main::k#1 reg byte y 1.50000000000015E13
(byte) sub_main::k#2 reg byte y 7.50000000000075E12

zp[1]:2 [ main::i#7 main::i#1 ]
zp[1]:3 [ main::j#5 main::j#1 ]
zp[1]:4 [ main::k#2 main::k#1 ]
zp[1]:5 [ sub_main::i#6 sub_main::i#1 ]
reg byte x [ sub_main::j#4 sub_main::j#1 ]
reg byte y [ sub_main::k#2 sub_main::k#1 ]
zp[1]:6 [ irq::i#7 irq::i#1 ]
zp[1]:7 [ irq::j#4 irq::j#1 ]
zp[1]:8 [ irq::k#2 irq::k#1 ]
zp[1]:9 [ sub_irq::i#6 sub_irq::i#1 ]
reg byte x [ sub_irq::j#4 sub_irq::j#1 ]
reg byte y [ sub_irq::k#2 sub_irq::k#1 ]
reg byte a [ main::$0 ]
reg byte a [ main::$1 ]
reg byte a [ sub_main::$0 ]
reg byte a [ sub_main::$1 ]
reg byte a [ irq::$2 ]
reg byte a [ irq::$3 ]
reg byte a [ sub_irq::$0 ]
reg byte a [ sub_irq::$1 ]


FINAL ASSEMBLER
Score: 314173644

  // File Comments
// Illustrates a problem where local variables inside an IRQ are assigned the same zeropage as a variable outside the IRQ
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label KERNEL_IRQ = $314
  .label RASTER = $d012
  .label VIC_CONTROL = $d011
  .label IRQ_STATUS = $d019
  .label IRQ_ENABLE = $d01a
  .const IRQ_RASTER = 1
  .label BGCOL = $d020
  .label FGCOL = $d021
  .label CIA1_INTERRUPT = $dc0d
  .const CIA_INTERRUPT_CLEAR = $7f
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label k = 4
    .label j = 3
    .label i = 2
    // asm
    // asm { sei  }
    sei
    // *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR
    // [5] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
    // *VIC_CONTROL &=$7f
    // [6] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line to $0fd
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
    // *RASTER = $fd
    // [7] *((const byte*) RASTER) ← (byte) $fd -- _deref_pbuc1=vbuc2 
    lda #$fd
    sta RASTER
    // *IRQ_ENABLE = IRQ_RASTER
    // [8] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // *KERNEL_IRQ = &irq
    // [9] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq() -- _deref_pptc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta KERNEL_IRQ
    lda #>irq
    sta KERNEL_IRQ+1
    // asm
    // asm { cli  }
    cli
    // [11] phi from main main::@5 to main::@1 [phi:main/main::@5->main::@1]
  b1:
    // [11] phi (byte) main::i#7 = (byte) 0 [phi:main/main::@5->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // main::@1
  __b1:
    // [12] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // [12] phi (byte) main::j#5 = (byte) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    // [12] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
    // [12] phi (byte) main::j#5 = (byte) main::j#1 [phi:main::@4->main::@2#0] -- register_copy 
    // main::@2
  __b2:
    // [13] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // [13] phi (byte) main::k#2 = (byte) 0 [phi:main::@2->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    // [13] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
    // [13] phi (byte) main::k#2 = (byte) main::k#1 [phi:main::@6->main::@3#0] -- register_copy 
    // main::@3
  __b3:
    // i+j
    // [14] (byte~) main::$0 ← (byte) main::i#7 + (byte) main::j#5 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z i
    clc
    adc.z j
    // i+j+k
    // [15] (byte~) main::$1 ← (byte~) main::$0 + (byte) main::k#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z k
    // *FGCOL = i+j+k
    // [16] *((const byte*) FGCOL) ← (byte~) main::$1 -- _deref_pbuc1=vbuaa 
    sta FGCOL
    // sub_main()
    // [17] call sub_main 
    // [25] phi from main::@3 to sub_main [phi:main::@3->sub_main]
    jsr sub_main
    // main::@6
    // for( byte k: 0..10 )
    // [18] (byte) main::k#1 ← ++ (byte) main::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [19] if((byte) main::k#1!=(byte) $b) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3
    // main::@4
    // for( byte j: 0..10 )
    // [20] (byte) main::j#1 ← ++ (byte) main::j#5 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [21] if((byte) main::j#1!=(byte) $b) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    cmp.z j
    bne __b2
    // main::@5
    // for( byte i: 0..10 )
    // [22] (byte) main::i#1 ← ++ (byte) main::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [23] if((byte) main::i#1!=(byte) $b) goto main::@7 -- vbuz1_neq_vbuc1_then_la1 
    cmp.z i
    bne __b1
    jmp b1
    // [24] phi from main::@5 to main::@7 [phi:main::@5->main::@7]
    // main::@7
    // [11] phi from main::@7 to main::@1 [phi:main::@7->main::@1]
    // [11] phi (byte) main::i#7 = (byte) main::i#1 [phi:main::@7->main::@1#0] -- register_copy 
}
  // sub_main
sub_main: {
    .label i = 5
    // [26] phi from sub_main to sub_main::@1 [phi:sub_main->sub_main::@1]
    // [26] phi (byte) sub_main::i#6 = (byte) 0 [phi:sub_main->sub_main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [26] phi from sub_main::@5 to sub_main::@1 [phi:sub_main::@5->sub_main::@1]
    // [26] phi (byte) sub_main::i#6 = (byte) sub_main::i#1 [phi:sub_main::@5->sub_main::@1#0] -- register_copy 
    // sub_main::@1
  __b1:
    // [27] phi from sub_main::@1 to sub_main::@2 [phi:sub_main::@1->sub_main::@2]
    // [27] phi (byte) sub_main::j#4 = (byte) 0 [phi:sub_main::@1->sub_main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [27] phi from sub_main::@4 to sub_main::@2 [phi:sub_main::@4->sub_main::@2]
    // [27] phi (byte) sub_main::j#4 = (byte) sub_main::j#1 [phi:sub_main::@4->sub_main::@2#0] -- register_copy 
    // sub_main::@2
  __b2:
    // [28] phi from sub_main::@2 to sub_main::@3 [phi:sub_main::@2->sub_main::@3]
    // [28] phi (byte) sub_main::k#2 = (byte) 0 [phi:sub_main::@2->sub_main::@3#0] -- vbuyy=vbuc1 
    ldy #0
    // [28] phi from sub_main::@3 to sub_main::@3 [phi:sub_main::@3->sub_main::@3]
    // [28] phi (byte) sub_main::k#2 = (byte) sub_main::k#1 [phi:sub_main::@3->sub_main::@3#0] -- register_copy 
    // sub_main::@3
  __b3:
    // i+j
    // [29] (byte~) sub_main::$0 ← (byte) sub_main::i#6 + (byte) sub_main::j#4 -- vbuaa=vbuz1_plus_vbuxx 
    txa
    clc
    adc.z i
    // i+j+k
    // [30] (byte~) sub_main::$1 ← (byte~) sub_main::$0 + (byte) sub_main::k#2 -- vbuaa=vbuaa_plus_vbuyy 
    sty.z $ff
    clc
    adc.z $ff
    // *BGCOL = i+j+k
    // [31] *((const byte*) BGCOL) ← (byte~) sub_main::$1 -- _deref_pbuc1=vbuaa 
    sta BGCOL
    // for( byte k: 0..10 )
    // [32] (byte) sub_main::k#1 ← ++ (byte) sub_main::k#2 -- vbuyy=_inc_vbuyy 
    iny
    // [33] if((byte) sub_main::k#1!=(byte) $b) goto sub_main::@3 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne __b3
    // sub_main::@4
    // for( byte j: 0..10 )
    // [34] (byte) sub_main::j#1 ← ++ (byte) sub_main::j#4 -- vbuxx=_inc_vbuxx 
    inx
    // [35] if((byte) sub_main::j#1!=(byte) $b) goto sub_main::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne __b2
    // sub_main::@5
    // for( byte i: 0..10 )
    // [36] (byte) sub_main::i#1 ← ++ (byte) sub_main::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [37] if((byte) sub_main::i#1!=(byte) $b) goto sub_main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1
    // sub_main::@return
    // }
    // [38] return 
    rts
}
  // irq
irq: {
    .label k = 8
    .label j = 7
    .label i = 6
    // entry interrupt(KERNEL_MIN)
    // (*BGCOL)++;
    // [39] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [40] phi from irq to irq::@1 [phi:irq->irq::@1]
    // [40] phi (byte) irq::i#7 = (byte) 0 [phi:irq->irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [40] phi from irq::@5 to irq::@1 [phi:irq::@5->irq::@1]
    // [40] phi (byte) irq::i#7 = (byte) irq::i#1 [phi:irq::@5->irq::@1#0] -- register_copy 
    // irq::@1
  __b1:
    // [41] phi from irq::@1 to irq::@2 [phi:irq::@1->irq::@2]
    // [41] phi (byte) irq::j#4 = (byte) 0 [phi:irq::@1->irq::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z j
    // [41] phi from irq::@4 to irq::@2 [phi:irq::@4->irq::@2]
    // [41] phi (byte) irq::j#4 = (byte) irq::j#1 [phi:irq::@4->irq::@2#0] -- register_copy 
    // irq::@2
  __b2:
    // [42] phi from irq::@2 to irq::@3 [phi:irq::@2->irq::@3]
    // [42] phi (byte) irq::k#2 = (byte) 0 [phi:irq::@2->irq::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z k
    // [42] phi from irq::@7 to irq::@3 [phi:irq::@7->irq::@3]
    // [42] phi (byte) irq::k#2 = (byte) irq::k#1 [phi:irq::@7->irq::@3#0] -- register_copy 
    // irq::@3
  __b3:
    // i+j
    // [43] (byte~) irq::$2 ← (byte) irq::i#7 + (byte) irq::j#4 -- vbuaa=vbuz1_plus_vbuz2 
    lda.z i
    clc
    adc.z j
    // i+j+k
    // [44] (byte~) irq::$3 ← (byte~) irq::$2 + (byte) irq::k#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z k
    // *FGCOL = i+j+k
    // [45] *((const byte*) FGCOL) ← (byte~) irq::$3 -- _deref_pbuc1=vbuaa 
    sta FGCOL
    // sub_irq()
    // [46] call sub_irq 
    // [56] phi from irq::@3 to sub_irq [phi:irq::@3->sub_irq]
    jsr sub_irq
    // irq::@7
    // for( byte k: 0..10 )
    // [47] (byte) irq::k#1 ← ++ (byte) irq::k#2 -- vbuz1=_inc_vbuz1 
    inc.z k
    // [48] if((byte) irq::k#1!=(byte) $b) goto irq::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z k
    bne __b3
    // irq::@4
    // for( byte j: 0..10 )
    // [49] (byte) irq::j#1 ← ++ (byte) irq::j#4 -- vbuz1=_inc_vbuz1 
    inc.z j
    // [50] if((byte) irq::j#1!=(byte) $b) goto irq::@2 -- vbuz1_neq_vbuc1_then_la1 
    cmp.z j
    bne __b2
    // irq::@5
    // for( byte i: 0..10 )
    // [51] (byte) irq::i#1 ← ++ (byte) irq::i#7 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [52] if((byte) irq::i#1!=(byte) $b) goto irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    cmp.z i
    bne __b1
    // irq::@6
    // *IRQ_STATUS = IRQ_RASTER
    // [53] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // (*BGCOL)--;
    // [54] *((const byte*) BGCOL) ← -- *((const byte*) BGCOL) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec BGCOL
    // irq::@return
    // }
    // [55] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
}
  // sub_irq
sub_irq: {
    .label i = 9
    // [57] phi from sub_irq to sub_irq::@1 [phi:sub_irq->sub_irq::@1]
    // [57] phi (byte) sub_irq::i#6 = (byte) 0 [phi:sub_irq->sub_irq::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [57] phi from sub_irq::@5 to sub_irq::@1 [phi:sub_irq::@5->sub_irq::@1]
    // [57] phi (byte) sub_irq::i#6 = (byte) sub_irq::i#1 [phi:sub_irq::@5->sub_irq::@1#0] -- register_copy 
    // sub_irq::@1
  __b1:
    // [58] phi from sub_irq::@1 to sub_irq::@2 [phi:sub_irq::@1->sub_irq::@2]
    // [58] phi (byte) sub_irq::j#4 = (byte) 0 [phi:sub_irq::@1->sub_irq::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [58] phi from sub_irq::@4 to sub_irq::@2 [phi:sub_irq::@4->sub_irq::@2]
    // [58] phi (byte) sub_irq::j#4 = (byte) sub_irq::j#1 [phi:sub_irq::@4->sub_irq::@2#0] -- register_copy 
    // sub_irq::@2
  __b2:
    // [59] phi from sub_irq::@2 to sub_irq::@3 [phi:sub_irq::@2->sub_irq::@3]
    // [59] phi (byte) sub_irq::k#2 = (byte) 0 [phi:sub_irq::@2->sub_irq::@3#0] -- vbuyy=vbuc1 
    ldy #0
    // [59] phi from sub_irq::@3 to sub_irq::@3 [phi:sub_irq::@3->sub_irq::@3]
    // [59] phi (byte) sub_irq::k#2 = (byte) sub_irq::k#1 [phi:sub_irq::@3->sub_irq::@3#0] -- register_copy 
    // sub_irq::@3
  __b3:
    // i+j
    // [60] (byte~) sub_irq::$0 ← (byte) sub_irq::i#6 + (byte) sub_irq::j#4 -- vbuaa=vbuz1_plus_vbuxx 
    txa
    clc
    adc.z i
    // i+j+k
    // [61] (byte~) sub_irq::$1 ← (byte~) sub_irq::$0 + (byte) sub_irq::k#2 -- vbuaa=vbuaa_plus_vbuyy 
    sty.z $ff
    clc
    adc.z $ff
    // *BGCOL = i+j+k
    // [62] *((const byte*) BGCOL) ← (byte~) sub_irq::$1 -- _deref_pbuc1=vbuaa 
    sta BGCOL
    // for( byte k: 0..10 )
    // [63] (byte) sub_irq::k#1 ← ++ (byte) sub_irq::k#2 -- vbuyy=_inc_vbuyy 
    iny
    // [64] if((byte) sub_irq::k#1!=(byte) $b) goto sub_irq::@3 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne __b3
    // sub_irq::@4
    // for( byte j: 0..10 )
    // [65] (byte) sub_irq::j#1 ← ++ (byte) sub_irq::j#4 -- vbuxx=_inc_vbuxx 
    inx
    // [66] if((byte) sub_irq::j#1!=(byte) $b) goto sub_irq::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne __b2
    // sub_irq::@5
    // for( byte i: 0..10 )
    // [67] (byte) sub_irq::i#1 ← ++ (byte) sub_irq::i#6 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [68] if((byte) sub_irq::i#1!=(byte) $b) goto sub_irq::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$b
    cmp.z i
    bne __b1
    // sub_irq::@return
    // }
    // [69] return 
    rts
}
  // File Data

