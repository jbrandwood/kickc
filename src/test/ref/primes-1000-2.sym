__constant char DIGITS[] = "0123456789abcdef"z
__constant unsigned int PRIMES[$3e8] = { fill( $3e8, 0) }
__constant char RADIX::BINARY = 2
__constant char RADIX::DECIMAL = $a
__constant char RADIX::HEXADECIMAL = $10
__constant char RADIX::OCTAL = 8
__constant unsigned int RADIX_DECIMAL_VALUES[] = { $2710, $3e8, $64, $a }
__constant char SIZEOF_UNSIGNED_INT = 2
__constant char decimal_digits[6] = { fill( 6, 0) }
unsigned int div16u8u(unsigned int dividend , char divisor)
unsigned int div16u8u::dividend
unsigned int div16u8u::dividend#0 // dividend zp[2]:16 420.59999999999997
char div16u8u::divisor
char div16u8u::divisor#0 // divisor zp[1]:8 420.59999999999997
unsigned int div16u8u::quotient
char div16u8u::quotient_hi
char div16u8u::quotient_lo
unsigned int div16u8u::return
char divr8u(char dividend , char divisor , char rem)
char divr8u::$1 // reg byte a 2.0000002E7
char divr8u::dividend
char divr8u::dividend#0 // dividend zp[1]:7 2500000.25
char divr8u::dividend#1 // dividend zp[1]:7 1001.0
char divr8u::dividend#2 // dividend zp[1]:7 667.3333333333334
char divr8u::dividend#3 // dividend zp[1]:7 5001667.333333333
char divr8u::dividend#5 // dividend zp[1]:7 12003.0
char divr8u::divisor
char divr8u::divisor#0 // divisor zp[1]:8 2002.0
char divr8u::divisor#1 // divisor zp[1]:8 1001.0
char divr8u::divisor#6 // divisor zp[1]:8 1333466.933333333
char divr8u::i
char divr8u::i#1 // reg byte x 1.50000015E7
char divr8u::i#2 // reg byte x 1666666.8333333333
char divr8u::quotient
char divr8u::quotient#1 // quotient zp[1]:6 1.50000015E7
char divr8u::quotient#2 // quotient zp[1]:6 1.0000001E7
char divr8u::quotient#3 // quotient zp[1]:6 2857143.1428571427
char divr8u::rem
char divr8u::rem#0 // reg byte y 1.0000001E7
char divr8u::rem#1 // reg byte y 2.0000002E7
char divr8u::rem#10 // reg byte y 11002.0
char divr8u::rem#11 // reg byte y 1.0003334666666666E7
char divr8u::rem#2 // reg byte y 2.0000002E7
char divr8u::rem#4 // reg byte y 2002.0
char divr8u::rem#5 // reg byte y 2.0010003E7
char divr8u::rem#6 // reg byte y 1.0000001E7
char divr8u::return
char divr8u::return#0 // return zp[1]:6 1.0000001E7
void main()
unsigned int main::$0 // zp[2]:14 22.0
char main::$12 // reg byte a 11.0
char main::$13 // reg byte x 50.5
unsigned int main::$14 // zp[2]:2 22.0
unsigned int *main::$15 // zp[2]:2 22.0
char main::p
char main::p#0 // reg byte a 16.5
unsigned int mul8u(char a , char b)
char mul8u::$1 // reg byte a 20002.0
char mul8u::a
char mul8u::a#0 // reg byte x 10001.0
char mul8u::a#1 // reg byte x 37.33333333333333
char mul8u::a#2 // reg byte x 6684.166666666666
char mul8u::b
char mul8u::b#0 // reg byte a 11.0
unsigned int mul8u::mb
unsigned int mul8u::mb#0 // mb zp[2]:2 202.0
unsigned int mul8u::mb#1 // mb zp[2]:2 20002.0
unsigned int mul8u::mb#2 // mb zp[2]:2 4300.571428571429
unsigned int mul8u::res
unsigned int mul8u::res#1 // res zp[2]:14 20002.0
unsigned int mul8u::res#2 // res zp[2]:14 5002.333333333333
unsigned int mul8u::res#6 // res zp[2]:14 10001.0
unsigned int mul8u::return
unsigned int mul8u::return#2 // return zp[2]:14 22.0
unsigned int potential
unsigned int potential#1 // potential zp[2]:16 22.0
unsigned int potential#10 // potential zp[2]:16 59.28571428571429
unsigned int potential#11 // potential zp[2]:16 30.545454545454547
unsigned int potential#15 // potential zp[2]:16 3.0
unsigned int potential#2 // potential zp[2]:16 202.0
unsigned int prime_idx
unsigned int prime_idx#1 // prime_idx zp[2]:19 4.888888888888889
unsigned int prime_idx#17 // prime_idx zp[2]:19 1.0
void print_char(char ch)
char print_char::ch
char print_char::ch#0 // reg byte a 200002.0
char print_char::ch#2 // reg byte a 1100002.0
char *print_char_cursor
char *print_char_cursor#1 // print_char_cursor zp[2]:11 210100.40000000002
char *print_char_cursor#17 // print_char_cursor zp[2]:11 183335.50000000003
char *print_char_cursor#34 // print_char_cursor zp[2]:11 32.64516129032258
char *print_line_cursor
char *print_screen
__constant char *print_screen#0 = (char *) 1024 // print_screen
void print_str(char *str)
char *print_str::str
char *print_str::str#0 // str zp[2]:9 200002.0
char *print_str::str#2 // str zp[2]:9 100001.0
void print_uint_decimal(unsigned int w)
unsigned int print_uint_decimal::w
unsigned int print_uint_decimal::w#0 // w zp[2]:16 112.0
char rem8u
char rem8u#0 // reg byte y 1233.6666666666665
char test_idx
char test_idx#1 // test_idx zp[1]:13 101.0
char test_idx#10 // test_idx zp[1]:13 151.5
char test_idx#7 // test_idx zp[1]:13 60.599999999999994
char test_last
char test_last#1 // test_last zp[1]:18 22.0
char test_last#13 // test_last zp[1]:18 4.888888888888889
char test_last#19 // test_last zp[1]:18 6.380952380952381
void utoa(unsigned int value , char *buffer , char radix)
char utoa::$10 // reg byte a 200002.0
char utoa::$11 // reg byte x 2002.0
char *utoa::buffer
char *utoa::buffer#11 // buffer zp[2]:9 28714.714285714286
char *utoa::buffer#14 // buffer zp[2]:9 150001.5
char *utoa::buffer#4 // buffer zp[2]:9 2002.0
char *utoa::buffer#5 // buffer zp[2]:9 200002.0
char utoa::digit
char utoa::digit#1 // digit zp[1]:13 200002.0
char utoa::digit#2 // digit zp[1]:13 28571.714285714286
unsigned int utoa::digit_value
unsigned int utoa::digit_value#0 // digit_value zp[2]:4 60000.600000000006
unsigned int *utoa::digit_values
char utoa::max_digits
__constant char utoa::max_digits#1 = 5 // max_digits
char utoa::radix
char utoa::started
char utoa::started#2 // reg byte x 50000.5
char utoa::started#4 // reg byte x 100001.0
unsigned int utoa::value
unsigned int utoa::value#0 // value zp[2]:2 551.0
unsigned int utoa::value#1 // value zp[2]:2 100001.0
unsigned int utoa::value#2 // value zp[2]:2 57286.42857142857
unsigned int utoa::value#6 // value zp[2]:2 150001.5
unsigned int utoa_append(char *buffer , unsigned int value , unsigned int sub)
char *utoa_append::buffer
char *utoa_append::buffer#0 // buffer zp[2]:9 137500.25
char utoa_append::digit
char utoa_append::digit#1 // reg byte x 1.000000001E9
char utoa_append::digit#2 // reg byte x 1.0005000015E9
unsigned int utoa_append::return
unsigned int utoa_append::return#0 // return zp[2]:2 200002.0
unsigned int utoa_append::sub
unsigned int utoa_append::sub#0 // sub zp[2]:4 3.333500005E8
unsigned int utoa_append::value
unsigned int utoa_append::value#0 // value zp[2]:2 366667.3333333334
unsigned int utoa_append::value#1 // value zp[2]:2 2.000000002E9
unsigned int utoa_append::value#2 // value zp[2]:2 5.0018333416666675E8

zp[1]:18 [ test_last#13 test_last#19 test_last#1 ]
zp[2]:19 [ prime_idx#17 prime_idx#1 ]
zp[2]:16 [ potential#10 potential#1 potential#15 potential#11 potential#2 div16u8u::dividend#0 print_uint_decimal::w#0 ]
reg byte x [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
zp[2]:14 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 main::$0 ]
reg byte a [ print_char::ch#2 print_char::ch#0 ]
zp[1]:8 [ divr8u::divisor#6 divr8u::divisor#0 divr8u::divisor#1 div16u8u::divisor#0 ]
reg byte y [ divr8u::rem#5 divr8u::rem#10 divr8u::rem#4 divr8u::rem#11 divr8u::rem#6 divr8u::rem#0 divr8u::rem#1 divr8u::rem#2 ]
zp[1]:7 [ divr8u::dividend#3 divr8u::dividend#5 divr8u::dividend#1 divr8u::dividend#2 divr8u::dividend#0 ]
zp[1]:6 [ divr8u::quotient#3 divr8u::return#0 divr8u::quotient#1 divr8u::quotient#2 ]
reg byte x [ divr8u::i#2 divr8u::i#1 ]
zp[1]:13 [ utoa::digit#2 utoa::digit#1 test_idx#7 test_idx#10 test_idx#1 ]
reg byte x [ utoa::started#2 utoa::started#4 ]
zp[2]:9 [ print_str::str#2 print_str::str#0 utoa::buffer#11 utoa::buffer#14 utoa::buffer#5 utoa::buffer#4 utoa_append::buffer#0 ]
zp[2]:11 [ print_char_cursor#1 print_char_cursor#34 print_char_cursor#17 ]
reg byte x [ utoa_append::digit#2 utoa_append::digit#1 ]
reg byte a [ main::$12 ]
reg byte a [ main::p#0 ]
reg byte a [ mul8u::b#0 ]
reg byte x [ main::$13 ]
zp[2]:2 [ main::$14 main::$15 utoa::value#2 utoa::value#6 utoa::value#0 utoa::value#1 utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 utoa_append::return#0 mul8u::mb#2 mul8u::mb#0 mul8u::mb#1 ]
reg byte a [ mul8u::$1 ]
reg byte a [ divr8u::$1 ]
reg byte y [ rem8u#0 ]
reg byte x [ utoa::$11 ]
reg byte a [ utoa::$10 ]
zp[2]:4 [ utoa::digit_value#0 utoa_append::sub#0 ]
