
(void()) main()
main: scope:[main]  from
  asm { sei  }
  [1] call cls 
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@3
  [2] (byte~) main::$1 ← *((const nomodify byte*) control) & (byte) $80
  [3] (byte~) main::$2 ← *((const nomodify byte*) raster) >> (byte) 1
  [4] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2
  [5] if((byte) main::rst#0!=(byte) $30) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [6] *((const nomodify byte*) BORDER_COLOR) ← (byte) 1
  [7] (byte) main::time_start#0 ← *((const nomodify byte*) raster)
  [8] (volatile byte*) utoa16w::dst ← (byte*) 1024
  [9] call utoa16w 
  to:main::@5
main::@5: scope:[main]  from main::@2
  [10] *((const nomodify byte*) BORDER_COLOR) ← ++ *((const nomodify byte*) BORDER_COLOR)
  [11] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28
  [12] call utoa16w 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [13] *((const nomodify byte*) BORDER_COLOR) ← ++ *((const nomodify byte*) BORDER_COLOR)
  [14] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28
  [15] call utoa16w 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [16] *((const nomodify byte*) BORDER_COLOR) ← ++ *((const nomodify byte*) BORDER_COLOR)
  [17] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28
  [18] call utoa16w 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [19] *((const nomodify byte*) BORDER_COLOR) ← ++ *((const nomodify byte*) BORDER_COLOR)
  [20] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28
  [21] call utoa16w 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [22] (byte) main::time_end#0 ← *((const nomodify byte*) raster)
  [23] *((const nomodify byte*) BORDER_COLOR) ← (byte) 0
  [24] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0
  [25] (word) utoa10w::value#0 ← (word)(byte) main::time#0
  [26] call utoa10w 
  to:main::@3
main::@3: scope:[main]  from main::@4 main::@9
  [27] (byte) main::i#2 ← phi( main::@9/(byte) 0 main::@4/(byte) main::i#1 )
  [28] if(*((const byte*) main::msg + (byte) main::i#2)!=(byte) 0) goto main::@4
  to:main::@1
main::@4: scope:[main]  from main::@3
  [29] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte*) main::msg + (byte) main::i#2)
  [30] (byte) main::i#1 ← ++ (byte) main::i#2
  to:main::@3

(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
utoa10w: scope:[utoa10w]  from main::@9
  [31] phi()
  to:utoa10w::@1
utoa10w::@1: scope:[utoa10w]  from utoa10w utoa10w::@2 utoa10w::@6
  [32] (byte*) utoa10w::dst#11 ← phi( utoa10w/(byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 utoa10w::@2/(byte*) utoa10w::dst#11 utoa10w::@6/(byte*) utoa10w::dst#4 )
  [32] (byte) utoa10w::bStarted#2 ← phi( utoa10w/(byte) 0 utoa10w::@2/(byte) 1 utoa10w::@6/(byte) utoa10w::bStarted#2 )
  [32] (byte) utoa10w::digit#3 ← phi( utoa10w/(byte) 0 utoa10w::@2/(byte) utoa10w::digit#1 utoa10w::@6/(byte) utoa10w::digit#7 )
  [32] (word) utoa10w::value#10 ← phi( utoa10w/(word) utoa10w::value#0 utoa10w::@2/(word) utoa10w::value#1 utoa10w::@6/(word) utoa10w::value#10 )
  [32] (byte) utoa10w::i#2 ← phi( utoa10w/(byte) 0 utoa10w::@2/(byte) utoa10w::i#2 utoa10w::@6/(byte) utoa10w::i#1 )
  [33] (byte~) utoa10w::$7 ← (byte) utoa10w::i#2 << (byte) 1
  [34] if((word) utoa10w::value#10>=*((const word*) UTOA10_SUB + (byte~) utoa10w::$7)) goto utoa10w::@2
  to:utoa10w::@3
utoa10w::@3: scope:[utoa10w]  from utoa10w::@1
  [35] (byte~) utoa10w::$1 ← (byte) utoa10w::i#2 & (byte) 1
  [36] if((byte~) utoa10w::$1==(byte) 0) goto utoa10w::@6
  to:utoa10w::@4
utoa10w::@4: scope:[utoa10w]  from utoa10w::@3
  [37] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7
  to:utoa10w::@5
utoa10w::@5: scope:[utoa10w]  from utoa10w::@4
  [38] *((byte*) utoa10w::dst#11) ← *((const byte*) DIGITS + (byte) utoa10w::digit#3)
  [39] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11
  to:utoa10w::@7
utoa10w::@7: scope:[utoa10w]  from utoa10w::@4 utoa10w::@5
  [40] (byte*) utoa10w::dst#8 ← phi( utoa10w::@4/(byte*) utoa10w::dst#11 utoa10w::@5/(byte*) utoa10w::dst#1 )
  to:utoa10w::@6
utoa10w::@6: scope:[utoa10w]  from utoa10w::@3 utoa10w::@7
  [41] (byte) utoa10w::digit#7 ← phi( utoa10w::@3/(byte) utoa10w::digit#3 utoa10w::@7/(byte) 0 )
  [41] (byte*) utoa10w::dst#4 ← phi( utoa10w::@3/(byte*) utoa10w::dst#11 utoa10w::@7/(byte*) utoa10w::dst#8 )
  [42] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2
  [43] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1
  to:utoa10w::@8
utoa10w::@8: scope:[utoa10w]  from utoa10w::@6
  [44] (byte~) utoa10w::$9 ← (byte)(word) utoa10w::value#10
  [45] *((byte*) utoa10w::dst#4) ← *((const byte*) DIGITS + (byte~) utoa10w::$9)
  [46] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4
  [47] *((byte*) utoa10w::dst#2) ← (byte) 0
  to:utoa10w::@return
utoa10w::@return: scope:[utoa10w]  from utoa10w::@8
  [48] return 
  to:@return
utoa10w::@2: scope:[utoa10w]  from utoa10w::@1
  [49] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte*) UTOA10_VAL + (byte) utoa10w::i#2)
  [50] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1
  [51] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word*) UTOA10_SUB + (byte~) utoa10w::$8)
  to:utoa10w::@1

(void()) utoa16w((word) utoa16w::value , (volatile byte*) utoa16w::dst)
utoa16w: scope:[utoa16w]  from main::@2 main::@5 main::@6 main::@7 main::@8
  [52] (word) utoa16w::value#5 ← phi( main::@8/(word) $e608 main::@2/(byte) 0 main::@5/(word) $4d2 main::@6/(word) $162e main::@7/(word) $270f )
  [53] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5
  [54] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4
  [55] call utoa16n 
  [56] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  [57] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
  [58] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5
  [59] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$3 & (byte) $f
  [60] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  [61] call utoa16n 
  [62] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  [63] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
  [64] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5
  [65] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4
  [66] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  [67] call utoa16n 
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  [68] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5
  [69] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$9 & (byte) $f
  [70] call utoa16n 
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  [71] *((volatile byte*) utoa16w::dst) ← (byte) 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  [72] return 
  to:@return

(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  [73] (byte) utoa16n::started#7 ← phi( utoa16w/(byte) 0 utoa16w::@1/(byte) utoa16n::started#1 utoa16w::@2/(byte) utoa16n::started#2 utoa16w::@3/(byte) 1 )
  [73] (byte) utoa16n::nybble#4 ← phi( utoa16w/(byte) utoa16n::nybble#0 utoa16w::@1/(byte) utoa16n::nybble#1 utoa16w::@2/(byte) utoa16n::nybble#2 utoa16w::@3/(byte) utoa16n::nybble#3 )
  [74] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3
  to:utoa16n::@1
utoa16n::@3: scope:[utoa16n]  from utoa16n
  [75] phi()
  to:utoa16n::@1
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  [76] (byte) utoa16n::return#4 ← phi( utoa16n::@3/(byte) utoa16n::started#7 utoa16n/(byte) 1 )
  [77] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return
  to:utoa16n::@2
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1
  [78] *(*(&(volatile byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4)
  [79] *(&(volatile byte*) utoa16w::dst) ← ++ *(&(volatile byte*) utoa16w::dst)
  to:utoa16n::@return
utoa16n::@return: scope:[utoa16n]  from utoa16n::@1 utoa16n::@2
  [80] return 
  to:@return

(void()) cls()
cls: scope:[cls]  from main
  [81] phi()
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  [82] (byte*) cls::sc#2 ← phi( cls/(const byte*) cls::screen cls::@1/(byte*) cls::sc#1 )
  [83] *((byte*) cls::sc#2) ← (byte) ' '
  [84] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2
  [85] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  [86] return 
  to:@return
