const nomodify byte BLACK = 0
const nomodify struct MOS6526_CIA* CIA1 = (struct MOS6526_CIA*) 56320
const nomodify byte* CIA1_INTERRUPT = (byte*) 56333
const nomodify struct MOS6526_CIA* CIA2 = (struct MOS6526_CIA*) 56576
const nomodify byte CIA_INTERRUPT_CLEAR = $7f
const nomodify byte* D018 = (byte*) 53272
const nomodify void()** HARDWARE_IRQ = (void()**) 65534
const nomodify byte* IRQ_ENABLE = (byte*) 53274
const nomodify byte IRQ_RASTER = 1
const nomodify byte IRQ_RASTER_FIRST = SPRITES_FIRST_YPOS+$13
const nomodify byte* IRQ_STATUS = (byte*) 53273
const byte OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
const byte OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = 2
const byte* PLAYFIELD_CHARSET[]  = kickasm {{ .fill 8,$00 // Place a filled char at the start of the charset
    .import binary "playfield-screen.imap"
 }}
const nomodify byte* PLAYFIELD_SCREEN_1 = (byte*) 1024
const nomodify byte* PLAYFIELD_SCREEN_2 = (byte*) 11264
const byte* PLAYFIELD_SPRITES[$1e*$40]  = kickasm {{ .var sprites = LoadPicture("playfield-sprites.png", List().add($010101, $000000))
	// Put the sprites into memory
	.for(var sy=0;sy<10;sy++) {
	    .var sprite_gfx_y = sy*20
		.for(var sx=0;sx<3;sx++) {
	    	.for (var y=0;y<21; y++) {
	    	    .var gfx_y =  sprite_gfx_y + mod(2100+y-sprite_gfx_y,21)
		    	.for (var c=0; c<3; c++) {
	            	.byte sprites.getSinglecolorByte(sx*3+c,gfx_y)
	            }
	        }
	    	.byte 0
	  	}
	}
 }}
const nomodify byte* PLAYFIELD_SPRITE_PTRS_1 = PLAYFIELD_SCREEN_1+SPRITE_PTRS
const nomodify byte* PLAYFIELD_SPRITE_PTRS_2 = PLAYFIELD_SCREEN_2+SPRITE_PTRS
const nomodify byte* PROCPORT = (byte*) 1
const nomodify byte* PROCPORT_DDR = (byte*) 0
const nomodify byte PROCPORT_DDR_MEMORY_MASK = 7
const nomodify byte PROCPORT_RAM_IO = 5
const nomodify byte* RASTER = (byte*) 53266
const byte* SIN[$100]  = kickasm {{ .var AMPL = 200-21
    .for(var i=0; i<256; i++) {
  	  .byte 51+AMPL/2+sin(toRadians([i*360]/256))*AMPL/2
    }
 }}
const byte* SIN_SPRITE[$40]  = kickasm {{ .fill $40, $ff
 }}
const nomodify byte* SPRITES_COLOR = (byte*) 53287
const nomodify byte* SPRITES_ENABLE = (byte*) 53269
const nomodify byte* SPRITES_EXPAND_X = (byte*) 53277
const nomodify byte* SPRITES_EXPAND_Y = (byte*) 53271
const nomodify byte SPRITES_FIRST_YPOS = $31
const nomodify byte* SPRITES_MC = (byte*) 53276
const nomodify byte* SPRITES_XPOS = (byte*) 53248
const nomodify byte* SPRITES_YPOS = (byte*) 53249
const nomodify word SPRITE_PTRS = $3f8
const nomodify byte* VIC_CONTROL = (byte*) 53265
void __start()
byte __start::__init1_toSpritePtr1_return
const byte __start::__init1_toSpritePtr1_return#0 __init1_toSpritePtr1_return = (byte)(word)PLAYFIELD_SPRITES/$40
byte* __start::__init1_toSpritePtr1_sprite
volatile byte irq_cnt loadstore zp[1]:10 0.48000000000000004
volatile byte irq_raster_next loadstore zp[1]:7 0.44444444444444453
volatile byte irq_sprite_ptr loadstore zp[1]:9 0.45161290322580644
volatile byte irq_sprite_ypos loadstore zp[1]:8 0.48275862068965525
void loop()
byte~ loop::$1 reg byte a 20002.0
byte loop::idx
byte loop::idx#0 reg byte x 2002.0
byte loop::idx#1 reg byte x 6667.333333333333
byte loop::idx#2 reg byte x 10334.666666666666
byte loop::s
byte loop::s#1 s zp[1]:5 15001.5
byte loop::s#2 s zp[1]:5 7500.75
void main()
byte~ main::$6 reg byte a 202.0
byte main::s
byte main::s#1 reg byte y 151.5
byte main::s#2 reg byte y 60.6
byte main::s2
byte main::s2#0 reg byte x 151.5
byte* main::toD0181_gfx
byte main::toD0181_return
const byte main::toD0181_return#0 toD0181_return = >(word)PLAYFIELD_SCREEN_1&$3fff*4|>(word)PLAYFIELD_CHARSET/4&$f
byte* main::toD0181_screen
byte main::toSpritePtr1_return
const byte main::toSpritePtr1_return#0 toSpritePtr1_return = (byte)(word)SIN_SPRITE/$40
byte* main::toSpritePtr1_sprite
byte* main::vicSelectGfxBank1_gfx
byte* main::vicSelectGfxBank1_toDd001_gfx
byte main::vicSelectGfxBank1_toDd001_return
const byte main::vicSelectGfxBank1_toDd001_return#0 vicSelectGfxBank1_toDd001_return = 3
byte main::xpos
byte main::xpos#1 xpos zp[1]:2 50.5
byte main::xpos#2 xpos zp[1]:2 37.875
byte main::ypos
byte main::ypos#1 ypos zp[1]:3 67.33333333333333
byte main::ypos#2 ypos zp[1]:3 33.666666666666664
volatile byte render_screen_showing loadstore zp[1]:6 0.4
byte sin_idx
byte sin_idx#11 sin_idx zp[1]:4 333.6666666666667
byte sin_idx#2 sin_idx zp[1]:4 2002.0
void sprites_init()
byte sprites_init::s
byte sprites_init::s#1 reg byte y 1501.5
byte sprites_init::s#2 reg byte y 800.8
byte sprites_init::s2
byte sprites_init::s2#0 reg byte x 2002.0
byte sprites_init::xpos
byte sprites_init::xpos#1 xpos zp[1]:5 667.3333333333334
byte sprites_init::xpos#2 xpos zp[1]:5 750.75
interrupt(HARDWARE_CLOBBER) void sprites_irq()
byte~ sprites_irq::$0 reg byte x 4.0
byte sprites_irq::ptr
byte sprites_irq::ptr#0 reg byte x 2.5
byte sprites_irq::ptr#1 reg byte x 2.6666666666666665
byte sprites_irq::ptr#2 reg byte a 4.0
byte sprites_irq::ptr#3 reg byte a 2.6666666666666665
byte sprites_irq::ptr#4 reg byte a 4.0
volatile byte sprites_irq::raster_sprite_gfx_modify loadstore zp[1]:11 6.5
byte sprites_irq::toSpritePtr1_return
const byte sprites_irq::toSpritePtr1_return#0 toSpritePtr1_return = (byte)(word)PLAYFIELD_SPRITES/$40
byte* sprites_irq::toSpritePtr1_sprite
byte sprites_irq::ypos
byte sprites_irq::ypos#0 reg byte a 2.5
void sprites_irq_init()

reg byte y [ main::s#2 main::s#1 ]
zp[1]:2 [ main::xpos#2 main::xpos#1 ]
zp[1]:3 [ main::ypos#2 main::ypos#1 ]
reg byte y [ sprites_init::s#2 sprites_init::s#1 ]
zp[1]:4 [ sin_idx#11 sin_idx#2 ]
zp[1]:5 [ loop::s#2 loop::s#1 sprites_init::xpos#2 sprites_init::xpos#1 ]
reg byte x [ loop::idx#2 loop::idx#0 loop::idx#1 ]
zp[1]:6 [ render_screen_showing ]
zp[1]:7 [ irq_raster_next ]
zp[1]:8 [ irq_sprite_ypos ]
zp[1]:9 [ irq_sprite_ptr ]
zp[1]:10 [ irq_cnt ]
reg byte a [ sprites_irq::ypos#0 ]
reg byte x [ sprites_irq::$0 ]
zp[1]:11 [ sprites_irq::raster_sprite_gfx_modify ]
reg byte x [ sprites_irq::ptr#0 ]
reg byte a [ sprites_irq::ptr#3 ]
reg byte a [ sprites_irq::ptr#4 ]
reg byte x [ sprites_irq::ptr#1 ]
reg byte a [ sprites_irq::ptr#2 ]
reg byte x [ main::s2#0 ]
reg byte a [ main::$6 ]
reg byte x [ sprites_init::s2#0 ]
reg byte a [ loop::$1 ]
