Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) @5
Culled Empty Block (label) keyboard_matrix_read::@1
Culled Empty Block (label) @6
Culled Empty Block (label) keyboard_key_pressed::@1
Culled Empty Block (label) @7
Culled Empty Block (label) @8
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@10
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@12

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@12

(void()) keyboard_init()
keyboard_init: scope:[keyboard_init]  from main
  *((const byte*) CIA1_PORT_A_DDR) ← (number) $ff
  *((const byte*) CIA1_PORT_B_DDR) ← (number) 0
  to:keyboard_init::@return
keyboard_init::@return: scope:[keyboard_init]  from keyboard_init
  return 
  to:@return

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  (byte) keyboard_matrix_read::rowid#1 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::rowid#0 )
  *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#1)
  (byte~) keyboard_matrix_read::$0 ← ~ *((const byte*) CIA1_PORT_B)
  (byte) keyboard_matrix_read::row_pressed_bits#0 ← (byte~) keyboard_matrix_read::$0
  (byte) keyboard_matrix_read::return#0 ← (byte) keyboard_matrix_read::row_pressed_bits#0
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  (byte) keyboard_matrix_read::return#3 ← phi( keyboard_matrix_read/(byte) keyboard_matrix_read::return#0 )
  (byte) keyboard_matrix_read::return#1 ← (byte) keyboard_matrix_read::return#3
  return 
  to:@return

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from main::@5
  (byte) keyboard_key_pressed::key#1 ← phi( main::@5/(byte) keyboard_key_pressed::key#0 )
  (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (number) 7
  (byte) keyboard_key_pressed::colidx#0 ← (number~) keyboard_key_pressed::$0
  (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#1 >> (number) 3
  (byte) keyboard_key_pressed::rowidx#0 ← (byte~) keyboard_key_pressed::$1
  (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  call keyboard_matrix_read 
  (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#1
  to:keyboard_key_pressed::@2
keyboard_key_pressed::@2: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  (byte) keyboard_key_pressed::colidx#1 ← phi( keyboard_key_pressed/(byte) keyboard_key_pressed::colidx#0 )
  (byte) keyboard_matrix_read::return#4 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::return#2 )
  (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#4
  (byte~) keyboard_key_pressed::$3 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#1)
  (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$3
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@2
  (byte) keyboard_key_pressed::return#3 ← phi( keyboard_key_pressed::@2/(byte) keyboard_key_pressed::return#0 )
  (byte) keyboard_key_pressed::return#1 ← (byte) keyboard_key_pressed::return#3
  return 
  to:@return

(void()) main()
main: scope:[main]  from @12
  call keyboard_init 
  to:main::@13
main::@13: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@13 main::@6 main::@8
  if(true) goto main::@4
  to:main::@return
main::@4: scope:[main]  from main::@1 main::@4
  (bool~) main::$1 ← *((const byte*) RASTER) != (number) $ff
  if((bool~) main::$1) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@4
  (byte) keyboard_key_pressed::key#0 ← (const byte) KEY_SPACE
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#1
  to:main::@14
main::@14: scope:[main]  from main::@5
  (byte) keyboard_key_pressed::return#4 ← phi( main::@5/(byte) keyboard_key_pressed::return#2 )
  (byte~) main::$2 ← (byte) keyboard_key_pressed::return#4
  (bool~) main::$3 ← (byte~) main::$2 != (number) 0
  if((bool~) main::$3) goto main::@8
  to:main::@6
main::@8: scope:[main]  from main::@14
  *((const byte*) BGCOL) ← (const byte) GREEN
  to:main::@1
main::@6: scope:[main]  from main::@14
  *((const byte*) BGCOL) ← (const byte) BLUE
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return
@12: scope:[]  from @begin
  call main 
  to:@13
@13: scope:[]  from @12
  to:@end
@end: scope:[]  from @13

SYMBOL TABLE SSA
(label) @12
(label) @13
(label) @begin
(label) @end
(const byte*) BGCOL = (byte*)(number) $d021
(const byte) BLUE = (byte) 6
(const byte*) CIA1_PORT_A = (byte*)(number) $dc00
(const byte*) CIA1_PORT_A_DDR = (byte*)(number) $dc02
(const byte*) CIA1_PORT_B = (byte*)(number) $dc01
(const byte*) CIA1_PORT_B_DDR = (byte*)(number) $dc03
(const byte) GREEN = (byte) 5
(const byte) KEY_SPACE = (byte) $3c
(const byte*) RASTER = (byte*)(number) $d012
(void()) keyboard_init()
(label) keyboard_init::@return
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(number~) keyboard_key_pressed::$0
(byte~) keyboard_key_pressed::$1
(byte~) keyboard_key_pressed::$2
(byte~) keyboard_key_pressed::$3
(label) keyboard_key_pressed::@2
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0
(byte) keyboard_key_pressed::colidx#1
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0
(byte) keyboard_key_pressed::key#1
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0
(byte) keyboard_key_pressed::return#1
(byte) keyboard_key_pressed::return#2
(byte) keyboard_key_pressed::return#3
(byte) keyboard_key_pressed::return#4
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0
(const byte*) keyboard_matrix_col_bitmask[(number) 8]  = { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte~) keyboard_matrix_read::$0
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0
(byte) keyboard_matrix_read::return#1
(byte) keyboard_matrix_read::return#2
(byte) keyboard_matrix_read::return#3
(byte) keyboard_matrix_read::return#4
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::row_pressed_bits#0
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0
(byte) keyboard_matrix_read::rowid#1
(const byte*) keyboard_matrix_row_bitmask[(number) 8]  = { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
(void()) main()
(bool~) main::$1
(byte~) main::$2
(bool~) main::$3
(label) main::@1
(label) main::@13
(label) main::@14
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@8
(label) main::@return

Adding number conversion cast (unumber) $ff in *((const byte*) CIA1_PORT_A_DDR) ← (number) $ff
Adding number conversion cast (unumber) 0 in *((const byte*) CIA1_PORT_B_DDR) ← (number) 0
Adding number conversion cast (unumber) 7 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (number) 7
Adding number conversion cast (unumber) keyboard_key_pressed::$0 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (unumber)(number) 7
Adding number conversion cast (unumber) 3 in (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#1 >> (number) 3
Adding number conversion cast (unumber) $ff in (bool~) main::$1 ← *((const byte*) RASTER) != (number) $ff
Adding number conversion cast (unumber) 0 in (bool~) main::$3 ← (byte~) main::$2 != (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((const byte*) CIA1_PORT_A_DDR) ← (unumber)(number) $ff
Inlining cast *((const byte*) CIA1_PORT_B_DDR) ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53281
Simplifying constant pointer cast (byte*) 56320
Simplifying constant pointer cast (byte*) 56321
Simplifying constant pointer cast (byte*) 56322
Simplifying constant pointer cast (byte*) 56323
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 7
Simplifying constant integer cast 3
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (byte) 7
Alias keyboard_matrix_read::return#0 = keyboard_matrix_read::row_pressed_bits#0 keyboard_matrix_read::$0 keyboard_matrix_read::return#3 keyboard_matrix_read::return#1 
Alias keyboard_key_pressed::colidx#0 = keyboard_key_pressed::$0 keyboard_key_pressed::colidx#1 
Alias keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::$1 
Alias keyboard_matrix_read::return#2 = keyboard_matrix_read::return#4 
Alias keyboard_key_pressed::return#0 = keyboard_key_pressed::$3 keyboard_key_pressed::return#3 keyboard_key_pressed::return#1 
Alias keyboard_key_pressed::return#2 = keyboard_key_pressed::return#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) keyboard_matrix_read::rowid#1 (byte) keyboard_matrix_read::rowid#0
Identical Phi Values (byte) keyboard_key_pressed::key#1 (byte) keyboard_key_pressed::key#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$1 [19] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@4
Simple Condition (bool~) main::$3 [25] if((byte~) main::$2!=(byte) 0) goto main::@8
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte) keyboard_key_pressed::key#0 = KEY_SPACE
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [17] if(true) goto main::@4
Successful SSA optimization Pass2ConstantIfs
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Constant right-side identified [6] (byte) keyboard_key_pressed::colidx#0 ← (const byte) keyboard_key_pressed::key#0 & (byte) 7
Constant right-side identified [7] (byte) keyboard_key_pressed::rowidx#0 ← (const byte) keyboard_key_pressed::key#0 >> (byte) 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) keyboard_key_pressed::colidx#0 = keyboard_key_pressed::key#0&7
Constant (const byte) keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::key#0>>3
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0
Successful SSA optimization Pass2ConstantIdentification
Constant inlined keyboard_key_pressed::key#0 = (const byte) KEY_SPACE
Constant inlined keyboard_matrix_read::rowid#0 = (const byte) keyboard_key_pressed::rowidx#0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(keyboard_matrix_row_bitmask+keyboard_key_pressed::rowidx#0)
Consolidated array index constant in *(keyboard_matrix_col_bitmask+keyboard_key_pressed::colidx#0)
Successful SSA optimization Pass2ConstantAdditionElimination
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @12
Adding NOP phi() at start of @13
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of keyboard_key_pressed
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to keyboard_init:6 keyboard_key_pressed:11 
Calls in [keyboard_key_pressed] to keyboard_matrix_read:18 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block (label) @13
Culled Empty Block (label) main::@13
Culled Empty Block (label) main::@1
Renumbering block @12 to @1
Renumbering block keyboard_key_pressed::@2 to keyboard_key_pressed::@1
Renumbering block main::@4 to main::@1
Renumbering block main::@5 to main::@2
Renumbering block main::@6 to main::@3
Renumbering block main::@8 to main::@4
Renumbering block main::@14 to main::@5
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of keyboard_key_pressed

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  [5] call keyboard_init 
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@3 main::@4
  [6] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [7] phi()
  [8] call keyboard_key_pressed 
  [9] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
  to:main::@5
main::@5: scope:[main]  from main::@2
  [10] (byte~) main::$2 ← (byte) keyboard_key_pressed::return#2
  [11] if((byte~) main::$2!=(byte) 0) goto main::@4
  to:main::@3
main::@3: scope:[main]  from main::@5
  [12] *((const byte*) BGCOL) ← (const byte) BLUE
  to:main::@1
main::@4: scope:[main]  from main::@5
  [13] *((const byte*) BGCOL) ← (const byte) GREEN
  to:main::@1

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from main::@2
  [14] phi()
  [15] call keyboard_matrix_read 
  [16] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  [17] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
  [18] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask+(const byte) keyboard_key_pressed::colidx#0)
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  [19] return 
  to:@return

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  [20] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0)
  [21] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B)
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  [22] return 
  to:@return

(void()) keyboard_init()
keyboard_init: scope:[keyboard_init]  from main
  [23] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff
  [24] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0
  to:keyboard_init::@return
keyboard_init::@return: scope:[keyboard_init]  from keyboard_init
  [25] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) keyboard_init()
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 2002.0
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 367.33333333333337
(byte) keyboard_key_pressed::return#2 202.0
(byte) keyboard_key_pressed::rowidx
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 3667.333333333333
(byte) keyboard_matrix_read::return#2 2002.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(void()) main()
(byte~) main::$2 202.0

Initial phi equivalence classes
Added variable keyboard_key_pressed::return#2 to live range equivalence class [ keyboard_key_pressed::return#2 ]
Added variable main::$2 to live range equivalence class [ main::$2 ]
Added variable keyboard_matrix_read::return#2 to live range equivalence class [ keyboard_matrix_read::return#2 ]
Added variable keyboard_key_pressed::$2 to live range equivalence class [ keyboard_key_pressed::$2 ]
Added variable keyboard_key_pressed::return#0 to live range equivalence class [ keyboard_key_pressed::return#0 ]
Added variable keyboard_matrix_read::return#0 to live range equivalence class [ keyboard_matrix_read::return#0 ]
Complete equivalence classes
[ keyboard_key_pressed::return#2 ]
[ main::$2 ]
[ keyboard_matrix_read::return#2 ]
[ keyboard_key_pressed::$2 ]
[ keyboard_key_pressed::return#0 ]
[ keyboard_matrix_read::return#0 ]
Allocated zp[1]:2 [ keyboard_key_pressed::return#2 ]
Allocated zp[1]:3 [ main::$2 ]
Allocated zp[1]:4 [ keyboard_matrix_read::return#2 ]
Allocated zp[1]:5 [ keyboard_key_pressed::$2 ]
Allocated zp[1]:6 [ keyboard_key_pressed::return#0 ]
Allocated zp[1]:7 [ keyboard_matrix_read::return#0 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Test keyboard input - test the space bar
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label RASTER = $d012
  .label BGCOL = $d021
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  // CIA #1 Port A data direction register.
  .label CIA1_PORT_A_DDR = $dc02
  // CIA #1 Port B data direction register.
  .label CIA1_PORT_B_DDR = $dc03
  .const GREEN = 5
  .const BLUE = 6
  .const KEY_SPACE = $3c
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label __2 = 3
    // [5] call keyboard_init 
    jsr keyboard_init
    jmp __b1
    // main::@1
  __b1:
    // [6] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b1
    // [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [8] call keyboard_key_pressed 
    // [14] phi from main::@2 to keyboard_key_pressed [phi:main::@2->keyboard_key_pressed]
  keyboard_key_pressed_from___b2:
    jsr keyboard_key_pressed
    // [9] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_1
    jmp __b5
    // main::@5
  __b5:
    // [10] (byte~) main::$2 ← (byte) keyboard_key_pressed::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_1
    sta.z __2
    // [11] if((byte~) main::$2!=(byte) 0) goto main::@4 -- vbuz1_neq_0_then_la1 
    lda.z __2
    cmp #0
    bne __b4
    jmp __b3
    // main::@3
  __b3:
    // [12] *((const byte*) BGCOL) ← (const byte) BLUE -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL
    jmp __b1
    // main::@4
  __b4:
    // [13] *((const byte*) BGCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
keyboard_key_pressed: {
    .const colidx = KEY_SPACE&7
    .label rowidx = KEY_SPACE>>3
    .label __2 = 5
    .label return = 6
    .label return_1 = 2
    // [15] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [16] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return
    sta.z keyboard_matrix_read.return_1
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [17] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return_1
    sta.z __2
    // [18] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask+(const byte) keyboard_key_pressed::colidx#0) -- vbuz1=vbuz2_band__deref_pbuc1 
    lda keyboard_matrix_col_bitmask+colidx
    and.z __2
    sta.z return
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [19] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
keyboard_matrix_read: {
    .label return = 7
    .label return_1 = 4
    // [20] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0) -- _deref_pbuc1=_deref_pbuc2 
    lda keyboard_matrix_row_bitmask+keyboard_key_pressed.rowidx
    sta CIA1_PORT_A
    // [21] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuz1=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    sta.z return
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [22] return 
    rts
}
  // keyboard_init
// Initialize keyboard reading by setting CIA#$ Data Direction Registers
keyboard_init: {
    // [23] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Write Mode
    lda #$ff
    sta CIA1_PORT_A_DDR
    // [24] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Read Mode
    lda #0
    sta CIA1_PORT_B_DDR
    jmp __breturn
    // keyboard_init::@return
  __breturn:
    // [25] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [12] *((const byte*) BGCOL) ← (const byte) BLUE [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [13] *((const byte*) BGCOL) ← (const byte) GREEN [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [20] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [21] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) [ keyboard_matrix_read::return#0 ] (  [ keyboard_matrix_read::return#0 ] { }  ) always clobbers reg byte a 
Statement [23] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [24] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ keyboard_key_pressed::return#2 ] : zp[1]:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ main::$2 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ keyboard_matrix_read::return#2 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ keyboard_key_pressed::$2 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ keyboard_key_pressed::return#0 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ keyboard_matrix_read::return#0 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [keyboard_matrix_read] 3,667.33: zp[1]:7 [ keyboard_matrix_read::return#0 ] 2,002: zp[1]:4 [ keyboard_matrix_read::return#2 ] 
Uplift Scope [keyboard_key_pressed] 2,002: zp[1]:5 [ keyboard_key_pressed::$2 ] 367.33: zp[1]:6 [ keyboard_key_pressed::return#0 ] 202: zp[1]:2 [ keyboard_key_pressed::return#2 ] 
Uplift Scope [main] 202: zp[1]:3 [ main::$2 ] 
Uplift Scope [keyboard_init] 
Uplift Scope [] 

Uplifting [keyboard_matrix_read] best 1417 combination reg byte a [ keyboard_matrix_read::return#0 ] reg byte a [ keyboard_matrix_read::return#2 ] 
Uplifting [keyboard_key_pressed] best 1318 combination reg byte a [ keyboard_key_pressed::$2 ] reg byte a [ keyboard_key_pressed::return#0 ] reg byte a [ keyboard_key_pressed::return#2 ] 
Uplifting [main] best 1258 combination reg byte a [ main::$2 ] 
Uplifting [keyboard_init] best 1258 combination 
Uplifting [] best 1258 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test keyboard input - test the space bar
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label RASTER = $d012
  .label BGCOL = $d021
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  // CIA #1 Port A data direction register.
  .label CIA1_PORT_A_DDR = $dc02
  // CIA #1 Port B data direction register.
  .label CIA1_PORT_B_DDR = $dc03
  .const GREEN = 5
  .const BLUE = 6
  .const KEY_SPACE = $3c
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // [5] call keyboard_init 
    jsr keyboard_init
    jmp __b1
    // main::@1
  __b1:
    // [6] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b1
    // [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [8] call keyboard_key_pressed 
    // [14] phi from main::@2 to keyboard_key_pressed [phi:main::@2->keyboard_key_pressed]
  keyboard_key_pressed_from___b2:
    jsr keyboard_key_pressed
    // [9] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    jmp __b5
    // main::@5
  __b5:
    // [10] (byte~) main::$2 ← (byte) keyboard_key_pressed::return#2
    // [11] if((byte~) main::$2!=(byte) 0) goto main::@4 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b4
    jmp __b3
    // main::@3
  __b3:
    // [12] *((const byte*) BGCOL) ← (const byte) BLUE -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL
    jmp __b1
    // main::@4
  __b4:
    // [13] *((const byte*) BGCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
keyboard_key_pressed: {
    .const colidx = KEY_SPACE&7
    .label rowidx = KEY_SPACE>>3
    // [15] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [16] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [17] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // [18] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask+(const byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band__deref_pbuc1 
    and keyboard_matrix_col_bitmask+colidx
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [19] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
keyboard_matrix_read: {
    // [20] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0) -- _deref_pbuc1=_deref_pbuc2 
    lda keyboard_matrix_row_bitmask+keyboard_key_pressed.rowidx
    sta CIA1_PORT_A
    // [21] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [22] return 
    rts
}
  // keyboard_init
// Initialize keyboard reading by setting CIA#$ Data Direction Registers
keyboard_init: {
    // [23] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Write Mode
    lda #$ff
    sta CIA1_PORT_A_DDR
    // [24] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Read Mode
    lda #0
    sta CIA1_PORT_B_DDR
    jmp __breturn
    // keyboard_init::@return
  __breturn:
    // [25] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b1_from___bbegin:
Removing instruction __b1:
Removing instruction main_from___b1:
Removing instruction __bend_from___b1:
Removing instruction __b2_from___b1:
Removing instruction keyboard_key_pressed_from___b2:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction __b2:
Removing instruction __b5:
Removing instruction __b3:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction __bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) BGCOL = (byte*) 53281
(const byte) BLUE = (byte) 6
(const byte*) CIA1_PORT_A = (byte*) 56320
(const byte*) CIA1_PORT_A_DDR = (byte*) 56322
(const byte*) CIA1_PORT_B = (byte*) 56321
(const byte*) CIA1_PORT_B_DDR = (byte*) 56323
(const byte) GREEN = (byte) 5
(const byte) KEY_SPACE = (byte) $3c
(const byte*) RASTER = (byte*) 53266
(void()) keyboard_init()
(label) keyboard_init::@return
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 reg byte a 2002.0
(label) keyboard_key_pressed::@1
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(const byte) keyboard_key_pressed::colidx#0 colidx = (const byte) KEY_SPACE&(byte) 7
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 reg byte a 367.33333333333337
(byte) keyboard_key_pressed::return#2 reg byte a 202.0
(byte) keyboard_key_pressed::rowidx
(const byte) keyboard_key_pressed::rowidx#0 rowidx = (const byte) KEY_SPACE>>(byte) 3
(const byte*) keyboard_matrix_col_bitmask[(number) 8]  = { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 reg byte a 3667.333333333333
(byte) keyboard_matrix_read::return#2 reg byte a 2002.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(const byte*) keyboard_matrix_row_bitmask[(number) 8]  = { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
(void()) main()
(byte~) main::$2 reg byte a 202.0
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5

reg byte a [ keyboard_key_pressed::return#2 ]
reg byte a [ main::$2 ]
reg byte a [ keyboard_matrix_read::return#2 ]
reg byte a [ keyboard_key_pressed::$2 ]
reg byte a [ keyboard_key_pressed::return#0 ]
reg byte a [ keyboard_matrix_read::return#0 ]


FINAL ASSEMBLER
Score: 1141

  // File Comments
// Test keyboard input - test the space bar
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label RASTER = $d012
  .label BGCOL = $d021
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  // CIA #1 Port A data direction register.
  .label CIA1_PORT_A_DDR = $dc02
  // CIA #1 Port B data direction register.
  .label CIA1_PORT_B_DDR = $dc03
  .const GREEN = 5
  .const BLUE = 6
  .const KEY_SPACE = $3c
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // keyboard_init()
    // [5] call keyboard_init 
    jsr keyboard_init
    // main::@1
  __b1:
    // while (*RASTER!=$ff)
    // [6] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b1
    // [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // keyboard_key_pressed(KEY_SPACE)
    // [8] call keyboard_key_pressed 
    // [14] phi from main::@2 to keyboard_key_pressed [phi:main::@2->keyboard_key_pressed]
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_SPACE)
    // [9] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    // main::@5
    // [10] (byte~) main::$2 ← (byte) keyboard_key_pressed::return#2
    // if(keyboard_key_pressed(KEY_SPACE)!=0)
    // [11] if((byte~) main::$2!=(byte) 0) goto main::@4 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b4
    // main::@3
    // *BGCOL = BLUE
    // [12] *((const byte*) BGCOL) ← (const byte) BLUE -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL
    jmp __b1
    // main::@4
  __b4:
    // *BGCOL = GREEN
    // [13] *((const byte*) BGCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
keyboard_key_pressed: {
    .const colidx = KEY_SPACE&7
    .label rowidx = KEY_SPACE>>3
    // keyboard_matrix_read(rowidx)
    // [15] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [16] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    // keyboard_key_pressed::@1
    // [17] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // keyboard_matrix_read(rowidx) & keyboard_matrix_col_bitmask[colidx]
    // [18] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask+(const byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band__deref_pbuc1 
    and keyboard_matrix_col_bitmask+colidx
    // keyboard_key_pressed::@return
    // }
    // [19] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
keyboard_matrix_read: {
    // *CIA1_PORT_A = keyboard_matrix_row_bitmask[rowid]
    // [20] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0) -- _deref_pbuc1=_deref_pbuc2 
    lda keyboard_matrix_row_bitmask+keyboard_key_pressed.rowidx
    sta CIA1_PORT_A
    // ~*CIA1_PORT_B
    // [21] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    // keyboard_matrix_read::@return
    // }
    // [22] return 
    rts
}
  // keyboard_init
// Initialize keyboard reading by setting CIA#$ Data Direction Registers
keyboard_init: {
    // *CIA1_PORT_A_DDR = $ff
    // [23] *((const byte*) CIA1_PORT_A_DDR) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Write Mode
    lda #$ff
    sta CIA1_PORT_A_DDR
    // *CIA1_PORT_B_DDR = $00
    // [24] *((const byte*) CIA1_PORT_B_DDR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Read Mode
    lda #0
    sta CIA1_PORT_B_DDR
    // keyboard_init::@return
    // }
    // [25] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

