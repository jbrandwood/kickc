// Illustrates problem where volatiles reuse ZP addresses of other variables - and reuses the same address for multiple volatiles
const void()** KERNEL_IRQ = $0314;
const byte* BORDERCOL = $d021;
const byte* BGCOL = $d020;
volatile byte col1 = 0;
volatile byte col2 = 8;
void main() {
    byte* SCREEN=$400;
    byte qwe = 32;
    byte asd = 0;
    byte row = 12;
    for(byte x:0..10) {
        SCREEN[x] = ++row;
        ++qwe;
        asd += qwe;
    }
    SCREEN[0] = qwe;
    SCREEN[1] = asd;
    *KERNEL_IRQ = &irq;
}

interrupt(kernel_min) void irq() {
    asm {
        lda $dc0d
    }
    *BGCOL = col1++;
    *BORDERCOL = col2++;
}
