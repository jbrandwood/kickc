PARSING src/test/java/dk/camelot64/kickc/test/kc/showlogo.kc
import "c64.kc"

byte* SCREEN = $400;
byte* LOGO = $2000;

void main() {
    *BORDERCOL = WHITE;
    *BGCOL = *BGCOL2 = DARK_GREY;
    *BGCOL3 = BLACK;
    *D018 = toD018(SCREEN, LOGO);
    *D016 = VIC_MCM | VIC_CSEL;
    fill(SCREEN, 40*25, BLACK);
    fill(COLS, 40*25, WHITE|8);
    for(byte ch: 0..239) {
        SCREEN[ch] = ch;
    }
    while(true) {
        (*(SCREEN+999))++;
        kickasm {{ inc $d020 }}
    }
}

// Fill some memory with a value
void fill(byte* start, word size, byte val) {
    byte* end = start + size;
    for(byte* addr = start; addr!=end; addr++) {
        *addr = val;
    }
}

kickasm(resources "logo.png" ) {{
    .label pc_restore = *
    .pc = $2000
    logo:
    .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))
    .for (var y=0; y<6	; y++)
        .for (var x=0;x<40; x++)
            .for(var cp=0; cp<8; cp++)
                .byte logoPic.getMulticolorByte(x,cp+y*8)
    .pc = pc_restore
}}

Importing c64.kc
PARSING src/test/java/dk/camelot64/kickc/test/kc/c64.kc
// Commodore 64 Registers and Constants

// Processor port data direction register
const byte* PROCPORT_DDR = $00;
// Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
const byte PROCPORT_DDR_MEMORY_MASK = %00000111;

// Processor Port Register controlling RAM/ROM configuration and the datasette
const byte* PROCPORT = $01;
// RAM in all three areas $A000, $D000, $E000
const byte PROCPORT_RAM_ALL         = %00110000;
// RAM in $A000, $E000 I/O in $D000
const byte PROCPORT_RAM_IO          = %00110101;
// RAM in $A000, $E000 CHAR ROM in $D000
const byte PROCPORT_RAM_CHARROM     = %00110001;
// RAM in $A000, I/O in $D000, KERNEL in $E000
const byte PROCPORT_KERNEL_IO       = %00110110;
// BASIC in $A000, I/O in $D000, KERNEL in $E000
const byte PROCPORT_BASIC_KERNEL_IO = %00110111;

const byte* CHARGEN = $d000;

const byte* SPRITES_XPOS = $d000;
const byte* SPRITES_YPOS = $d001;
const byte* SPRITES_XMSB = $d010;
const byte* RASTER = $d012;
const byte* SPRITES_ENABLE = $d015;
const byte* SPRITES_EXPAND_Y = $d017;
const byte* SPRITES_PRIORITY = $d01b;
const byte* SPRITES_MC = $d01c;
const byte* SPRITES_EXPAND_X = $d01d;
const byte* BORDERCOL = $d020;
const byte* BGCOL = $d021;
const byte* BGCOL1 = $d021;
const byte* BGCOL2 = $d022;
const byte* BGCOL3 = $d023;
const byte* BGCOL4 = $d024;
const byte* SPRITES_MC1 = $d025;
const byte* SPRITES_MC2 = $d026;
const byte* SPRITES_COLS = $d027;

const byte* VIC_CONTROL = $d011;
const byte* D011 = $d011;
const byte VIC_RST8 = %10000000;
const byte VIC_ECM =  %01000000;
const byte VIC_BMM =  %00100000;
const byte VIC_DEN =  %00010000;
const byte VIC_RSEL = %00001000;

const byte* VIC_CONTROL2 = $d016;
const byte* D016 = $d016;
const byte VIC_MCM =  %00010000;
const byte VIC_CSEL = %00001000;

const byte* D018 = $d018;
const byte* VIC_MEMORY = $d018;

const byte* COLS = $d800;

// CIA#1 Port A: keyboard matrix columns and joystick #2
const byte* CIA1_PORT_A = $dc00;
// CIA#1 Port B: keyboard matrix rows and joystick #1.
const byte* CIA1_PORT_B = $dc01;
// CIA #1 Port A data direction register.
const byte* CIA1_PORT_A_DDR = $dc02;
// CIA #1 Port B data direction register.
const byte* CIA1_PORT_B_DDR = $dc03;

// CIA#2 Port A: Serial bus, RS-232, VIC memory bank
const byte* CIA2_PORT_A = $dd00;
// CIA#2 Port B: RS-232
const byte* CIA2_PORT_B = $dd01;
// CIA #2 Port A data direction register.
const byte* CIA2_PORT_A_DDR = $dd02;
// CIA #2 Port B data direction register.
const byte* CIA2_PORT_B_DDR = $dd03;

const byte BLACK = $0;
const byte WHITE = $1;
const byte RED = $2;
const byte CYAN = $3;
const byte PURPLE = $4;
const byte GREEN = $5;
const byte BLUE = $6;
const byte YELLOW = $7;
const byte ORANGE = $8;
const byte BROWN = $9;
const byte PINK = $a;
const byte DARK_GREY= $b;
const byte GREY = $c;
const byte LIGHT_GREEN = $d;
const byte LIGHT_BLUE = $e;
const byte LIGHT_GREY = $f;

// Get the value to store into D018 to display a specific screen and charset/bitmap
// Optimized for ASM from (byte)((((word)screen&$3fff)/$40)|(((word)charset&$3fff)/$400));
inline byte toD018(byte* screen, byte* gfx) {
    return (>((((word)screen&$3fff)<<2)))|(((>((word)gfx))>>2)&$f);
}

// Get the value to store into DD00 (CIA 2 port A) to choose a specific VIC bank
// Optimized for ASM from %00000011 ^ (byte)((word)gfx/$4000)
inline byte toDd00(byte* gfx) {
    return %00000011 ^ (>((word)gfx))>>6;
}

// Select a specific VIC graphics bank by setting the CIA 2 port A ($dd00) as needed
inline void vicSelectGfxBank(byte* gfx) {
    *CIA2_PORT_A_DDR = %00000011;
    *CIA2_PORT_A = toDd00(gfx);
}

Adding pre/post-modifier *((var) main::$10) ← ++ *((var) main::$10)
Adding pre/post-modifier (byte*) fill::addr ← ++ (byte*) fill::addr
Added resource src/test/java/dk/camelot64/kickc/test/kc/logo.png
SYMBOLS
(label) @1
(label) @2
(label) @3
(label) @4
(label) @5
(label) @begin
(label) @end
(byte*) BGCOL
(byte*) BGCOL1
(byte*) BGCOL2
(byte*) BGCOL3
(byte*) BGCOL4
(byte) BLACK
(byte) BLUE
(byte*) BORDERCOL
(byte) BROWN
(byte*) CHARGEN
(byte*) CIA1_PORT_A
(byte*) CIA1_PORT_A_DDR
(byte*) CIA1_PORT_B
(byte*) CIA1_PORT_B_DDR
(byte*) CIA2_PORT_A
(byte*) CIA2_PORT_A_DDR
(byte*) CIA2_PORT_B
(byte*) CIA2_PORT_B_DDR
(byte*) COLS
(byte) CYAN
(byte*) D011
(byte*) D016
(byte*) D018
(byte) DARK_GREY
(byte) GREEN
(byte) GREY
(byte) LIGHT_BLUE
(byte) LIGHT_GREEN
(byte) LIGHT_GREY
(byte*) LOGO
(byte) ORANGE
(byte) PINK
(byte*) PROCPORT
(byte) PROCPORT_BASIC_KERNEL_IO
(byte*) PROCPORT_DDR
(byte) PROCPORT_DDR_MEMORY_MASK
(byte) PROCPORT_KERNEL_IO
(byte) PROCPORT_RAM_ALL
(byte) PROCPORT_RAM_CHARROM
(byte) PROCPORT_RAM_IO
(byte) PURPLE
(byte*) RASTER
(byte) RED
(byte*) SCREEN
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_MC
(byte*) SPRITES_MC1
(byte*) SPRITES_MC2
(byte*) SPRITES_PRIORITY
(byte*) SPRITES_XMSB
(byte*) SPRITES_XPOS
(byte*) SPRITES_YPOS
(byte) VIC_BMM
(byte*) VIC_CONTROL
(byte*) VIC_CONTROL2
(byte) VIC_CSEL
(byte) VIC_DEN
(byte) VIC_ECM
(byte) VIC_MCM
(byte*) VIC_MEMORY
(byte) VIC_RSEL
(byte) VIC_RST8
(byte) WHITE
(byte) YELLOW
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(byte*~) fill::$0
(bool~) fill::$1
(label) fill::@1
(label) fill::@2
(label) fill::@return
(byte*) fill::addr
(byte*) fill::end
(word) fill::size
(byte*) fill::start
(byte) fill::val
(void()) main()
(byte~) main::$0
(byte~) main::$1
(byte*~) main::$10
(word/signed word/dword/signed dword~) main::$2
(void~) main::$3
(word/signed word/dword/signed dword~) main::$4
(byte/word/dword~) main::$5
(void~) main::$6
(bool~) main::$7
(byte*~) main::$8
(byte*~) main::$9
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@return
(byte) main::ch
inline (byte()) toD018((byte*) toD018::screen , (byte*) toD018::gfx)
(word~) toD018::$0
(word~) toD018::$1
(word~) toD018::$2
(byte~) toD018::$3
(word~) toD018::$4
(byte~) toD018::$5
(byte~) toD018::$6
(byte~) toD018::$7
(byte~) toD018::$8
(label) toD018::@1
(label) toD018::@return
(byte*) toD018::gfx
(byte) toD018::return
(byte*) toD018::screen
inline (byte()) toDd00((byte*) toDd00::gfx)
(word~) toDd00::$0
(byte~) toDd00::$1
(byte~) toDd00::$2
(byte/word/dword~) toDd00::$3
(label) toDd00::@1
(label) toDd00::@return
(byte*) toDd00::gfx
(byte) toDd00::return
inline (void()) vicSelectGfxBank((byte*) vicSelectGfxBank::gfx)
(byte~) vicSelectGfxBank::$0
(label) vicSelectGfxBank::@return
(byte*) vicSelectGfxBank::gfx

Promoting byte/signed byte/word/signed word/dword/signed dword to byte* in PROCPORT_DDR ← ((byte*)) 0
Promoting byte/signed byte/word/signed word/dword/signed dword to byte* in PROCPORT ← ((byte*)) 1
Promoting word/dword/signed dword to byte* in CHARGEN ← ((byte*)) 53248
Promoting word/dword/signed dword to byte* in SPRITES_XPOS ← ((byte*)) 53248
Promoting word/dword/signed dword to byte* in SPRITES_YPOS ← ((byte*)) 53249
Promoting word/dword/signed dword to byte* in SPRITES_XMSB ← ((byte*)) 53264
Promoting word/dword/signed dword to byte* in RASTER ← ((byte*)) 53266
Promoting word/dword/signed dword to byte* in SPRITES_ENABLE ← ((byte*)) 53269
Promoting word/dword/signed dword to byte* in SPRITES_EXPAND_Y ← ((byte*)) 53271
Promoting word/dword/signed dword to byte* in SPRITES_PRIORITY ← ((byte*)) 53275
Promoting word/dword/signed dword to byte* in SPRITES_MC ← ((byte*)) 53276
Promoting word/dword/signed dword to byte* in SPRITES_EXPAND_X ← ((byte*)) 53277
Promoting word/dword/signed dword to byte* in BORDERCOL ← ((byte*)) 53280
Promoting word/dword/signed dword to byte* in BGCOL ← ((byte*)) 53281
Promoting word/dword/signed dword to byte* in BGCOL1 ← ((byte*)) 53281
Promoting word/dword/signed dword to byte* in BGCOL2 ← ((byte*)) 53282
Promoting word/dword/signed dword to byte* in BGCOL3 ← ((byte*)) 53283
Promoting word/dword/signed dword to byte* in BGCOL4 ← ((byte*)) 53284
Promoting word/dword/signed dword to byte* in SPRITES_MC1 ← ((byte*)) 53285
Promoting word/dword/signed dword to byte* in SPRITES_MC2 ← ((byte*)) 53286
Promoting word/dword/signed dword to byte* in SPRITES_COLS ← ((byte*)) 53287
Promoting word/dword/signed dword to byte* in VIC_CONTROL ← ((byte*)) 53265
Promoting word/dword/signed dword to byte* in D011 ← ((byte*)) 53265
Promoting word/dword/signed dword to byte* in VIC_CONTROL2 ← ((byte*)) 53270
Promoting word/dword/signed dword to byte* in D016 ← ((byte*)) 53270
Promoting word/dword/signed dword to byte* in D018 ← ((byte*)) 53272
Promoting word/dword/signed dword to byte* in VIC_MEMORY ← ((byte*)) 53272
Promoting word/dword/signed dword to byte* in COLS ← ((byte*)) 55296
Promoting word/dword/signed dword to byte* in CIA1_PORT_A ← ((byte*)) 56320
Promoting word/dword/signed dword to byte* in CIA1_PORT_B ← ((byte*)) 56321
Promoting word/dword/signed dword to byte* in CIA1_PORT_A_DDR ← ((byte*)) 56322
Promoting word/dword/signed dword to byte* in CIA1_PORT_B_DDR ← ((byte*)) 56323
Promoting word/dword/signed dword to byte* in CIA2_PORT_A ← ((byte*)) 56576
Promoting word/dword/signed dword to byte* in CIA2_PORT_B ← ((byte*)) 56577
Promoting word/dword/signed dword to byte* in CIA2_PORT_A_DDR ← ((byte*)) 56578
Promoting word/dword/signed dword to byte* in CIA2_PORT_B_DDR ← ((byte*)) 56579
Promoting word/signed word/dword/signed dword to byte* in SCREEN ← ((byte*)) 1024
Promoting word/signed word/dword/signed dword to byte* in LOGO ← ((byte*)) 8192
INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte*) PROCPORT_DDR ← ((byte*)) (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) PROCPORT_DDR_MEMORY_MASK ← (byte/signed byte/word/signed word/dword/signed dword) 7
  (byte*) PROCPORT ← ((byte*)) (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) PROCPORT_RAM_ALL ← (byte/signed byte/word/signed word/dword/signed dword) 48
  (byte) PROCPORT_RAM_IO ← (byte/signed byte/word/signed word/dword/signed dword) 53
  (byte) PROCPORT_RAM_CHARROM ← (byte/signed byte/word/signed word/dword/signed dword) 49
  (byte) PROCPORT_KERNEL_IO ← (byte/signed byte/word/signed word/dword/signed dword) 54
  (byte) PROCPORT_BASIC_KERNEL_IO ← (byte/signed byte/word/signed word/dword/signed dword) 55
  (byte*) CHARGEN ← ((byte*)) (word/dword/signed dword) 53248
  (byte*) SPRITES_XPOS ← ((byte*)) (word/dword/signed dword) 53248
  (byte*) SPRITES_YPOS ← ((byte*)) (word/dword/signed dword) 53249
  (byte*) SPRITES_XMSB ← ((byte*)) (word/dword/signed dword) 53264
  (byte*) RASTER ← ((byte*)) (word/dword/signed dword) 53266
  (byte*) SPRITES_ENABLE ← ((byte*)) (word/dword/signed dword) 53269
  (byte*) SPRITES_EXPAND_Y ← ((byte*)) (word/dword/signed dword) 53271
  (byte*) SPRITES_PRIORITY ← ((byte*)) (word/dword/signed dword) 53275
  (byte*) SPRITES_MC ← ((byte*)) (word/dword/signed dword) 53276
  (byte*) SPRITES_EXPAND_X ← ((byte*)) (word/dword/signed dword) 53277
  (byte*) BORDERCOL ← ((byte*)) (word/dword/signed dword) 53280
  (byte*) BGCOL ← ((byte*)) (word/dword/signed dword) 53281
  (byte*) BGCOL1 ← ((byte*)) (word/dword/signed dword) 53281
  (byte*) BGCOL2 ← ((byte*)) (word/dword/signed dword) 53282
  (byte*) BGCOL3 ← ((byte*)) (word/dword/signed dword) 53283
  (byte*) BGCOL4 ← ((byte*)) (word/dword/signed dword) 53284
  (byte*) SPRITES_MC1 ← ((byte*)) (word/dword/signed dword) 53285
  (byte*) SPRITES_MC2 ← ((byte*)) (word/dword/signed dword) 53286
  (byte*) SPRITES_COLS ← ((byte*)) (word/dword/signed dword) 53287
  (byte*) VIC_CONTROL ← ((byte*)) (word/dword/signed dword) 53265
  (byte*) D011 ← ((byte*)) (word/dword/signed dword) 53265
  (byte) VIC_RST8 ← (byte/word/signed word/dword/signed dword) 128
  (byte) VIC_ECM ← (byte/signed byte/word/signed word/dword/signed dword) 64
  (byte) VIC_BMM ← (byte/signed byte/word/signed word/dword/signed dword) 32
  (byte) VIC_DEN ← (byte/signed byte/word/signed word/dword/signed dword) 16
  (byte) VIC_RSEL ← (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte*) VIC_CONTROL2 ← ((byte*)) (word/dword/signed dword) 53270
  (byte*) D016 ← ((byte*)) (word/dword/signed dword) 53270
  (byte) VIC_MCM ← (byte/signed byte/word/signed word/dword/signed dword) 16
  (byte) VIC_CSEL ← (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte*) D018 ← ((byte*)) (word/dword/signed dword) 53272
  (byte*) VIC_MEMORY ← ((byte*)) (word/dword/signed dword) 53272
  (byte*) COLS ← ((byte*)) (word/dword/signed dword) 55296
  (byte*) CIA1_PORT_A ← ((byte*)) (word/dword/signed dword) 56320
  (byte*) CIA1_PORT_B ← ((byte*)) (word/dword/signed dword) 56321
  (byte*) CIA1_PORT_A_DDR ← ((byte*)) (word/dword/signed dword) 56322
  (byte*) CIA1_PORT_B_DDR ← ((byte*)) (word/dword/signed dword) 56323
  (byte*) CIA2_PORT_A ← ((byte*)) (word/dword/signed dword) 56576
  (byte*) CIA2_PORT_B ← ((byte*)) (word/dword/signed dword) 56577
  (byte*) CIA2_PORT_A_DDR ← ((byte*)) (word/dword/signed dword) 56578
  (byte*) CIA2_PORT_B_DDR ← ((byte*)) (word/dword/signed dword) 56579
  (byte) BLACK ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) WHITE ← (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) RED ← (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte) CYAN ← (byte/signed byte/word/signed word/dword/signed dword) 3
  (byte) PURPLE ← (byte/signed byte/word/signed word/dword/signed dword) 4
  (byte) GREEN ← (byte/signed byte/word/signed word/dword/signed dword) 5
  (byte) BLUE ← (byte/signed byte/word/signed word/dword/signed dword) 6
  (byte) YELLOW ← (byte/signed byte/word/signed word/dword/signed dword) 7
  (byte) ORANGE ← (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte) BROWN ← (byte/signed byte/word/signed word/dword/signed dword) 9
  (byte) PINK ← (byte/signed byte/word/signed word/dword/signed dword) 10
  (byte) DARK_GREY ← (byte/signed byte/word/signed word/dword/signed dword) 11
  (byte) GREY ← (byte/signed byte/word/signed word/dword/signed dword) 12
  (byte) LIGHT_GREEN ← (byte/signed byte/word/signed word/dword/signed dword) 13
  (byte) LIGHT_BLUE ← (byte/signed byte/word/signed word/dword/signed dword) 14
  (byte) LIGHT_GREY ← (byte/signed byte/word/signed word/dword/signed dword) 15
  to:@1
toD018: scope:[toD018]  from
  (word~) toD018::$0 ← ((word)) (byte*) toD018::screen
  (word~) toD018::$1 ← (word~) toD018::$0 & (word/signed word/dword/signed dword) 16383
  (word~) toD018::$2 ← (word~) toD018::$1 << (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte~) toD018::$3 ← > (word~) toD018::$2
  (word~) toD018::$4 ← ((word)) (byte*) toD018::gfx
  (byte~) toD018::$5 ← > (word~) toD018::$4
  (byte~) toD018::$6 ← (byte~) toD018::$5 >> (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte~) toD018::$7 ← (byte~) toD018::$6 & (byte/signed byte/word/signed word/dword/signed dword) 15
  (byte~) toD018::$8 ← (byte~) toD018::$3 | (byte~) toD018::$7
  (byte) toD018::return ← (byte~) toD018::$8
  to:toD018::@return
toD018::@return: scope:[toD018]  from toD018 toD018::@1
  (byte) toD018::return ← (byte) toD018::return
  return (byte) toD018::return
  to:@return
toD018::@1: scope:[toD018]  from
  to:toD018::@return
@1: scope:[]  from @begin
  to:@2
toDd00: scope:[toDd00]  from
  (word~) toDd00::$0 ← ((word)) (byte*) toDd00::gfx
  (byte~) toDd00::$1 ← > (word~) toDd00::$0
  (byte~) toDd00::$2 ← (byte~) toDd00::$1 >> (byte/signed byte/word/signed word/dword/signed dword) 6
  (byte/word/dword~) toDd00::$3 ← (byte/signed byte/word/signed word/dword/signed dword) 3 ^ (byte~) toDd00::$2
  (byte) toDd00::return ← (byte/word/dword~) toDd00::$3
  to:toDd00::@return
toDd00::@return: scope:[toDd00]  from toDd00 toDd00::@1
  (byte) toDd00::return ← (byte) toDd00::return
  return (byte) toDd00::return
  to:@return
toDd00::@1: scope:[toDd00]  from
  to:toDd00::@return
@2: scope:[]  from @1
  to:@3
vicSelectGfxBank: scope:[vicSelectGfxBank]  from
  *((byte*) CIA2_PORT_A_DDR) ← (byte/signed byte/word/signed word/dword/signed dword) 3
  (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
  *((byte*) CIA2_PORT_A) ← (byte~) vicSelectGfxBank::$0
  to:vicSelectGfxBank::@return
vicSelectGfxBank::@return: scope:[vicSelectGfxBank]  from vicSelectGfxBank
  return 
  to:@return
@3: scope:[]  from @2
  (byte*) SCREEN ← ((byte*)) (word/signed word/dword/signed dword) 1024
  (byte*) LOGO ← ((byte*)) (word/signed word/dword/signed dword) 8192
  to:@4
main: scope:[main]  from
  *((byte*) BORDERCOL) ← (byte) WHITE
  *((byte*) BGCOL2) ← (byte) DARK_GREY
  *((byte*) BGCOL) ← *((byte*) BGCOL2)
  *((byte*) BGCOL3) ← (byte) BLACK
  (byte~) main::$0 ← call toD018 (byte*) SCREEN (byte*) LOGO 
  *((byte*) D018) ← (byte~) main::$0
  (byte~) main::$1 ← (byte) VIC_MCM | (byte) VIC_CSEL
  *((byte*) D016) ← (byte~) main::$1
  (word/signed word/dword/signed dword~) main::$2 ← (byte/signed byte/word/signed word/dword/signed dword) 40 * (byte/signed byte/word/signed word/dword/signed dword) 25
  (void~) main::$3 ← call fill (byte*) SCREEN (word/signed word/dword/signed dword~) main::$2 (byte) BLACK 
  (word/signed word/dword/signed dword~) main::$4 ← (byte/signed byte/word/signed word/dword/signed dword) 40 * (byte/signed byte/word/signed word/dword/signed dword) 25
  (byte/word/dword~) main::$5 ← (byte) WHITE | (byte/signed byte/word/signed word/dword/signed dword) 8
  (void~) main::$6 ← call fill (byte*) COLS (word/signed word/dword/signed dword~) main::$4 (byte/word/dword~) main::$5 
  (byte) main::ch ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  *((byte*) SCREEN + (byte) main::ch) ← (byte) main::ch
  (byte) main::ch ← (byte) main::ch + rangenext(0,239)
  (bool~) main::$7 ← (byte) main::ch != rangelast(0,239)
  if((bool~) main::$7) goto main::@1
  to:main::@5
main::@5: scope:[main]  from main::@1
  to:main::@2
main::@2: scope:[main]  from main::@3 main::@5
  if(true) goto main::@3
  to:main::@6
main::@3: scope:[main]  from main::@2 main::@7
  (byte*~) main::$8 ← (byte*) SCREEN + (word/signed word/dword/signed dword) 999
  (byte*~) main::$9 ← (byte*) SCREEN + (word/signed word/dword/signed dword) 999
  (byte*~) main::$10 ← (byte*) SCREEN + (word/signed word/dword/signed dword) 999
  *((byte*~) main::$10) ← ++ *((byte*~) main::$10)
  kickasm {{ inc $d020  }}
  to:main::@2
main::@6: scope:[main]  from main::@2
  to:main::@4
main::@4: scope:[main]  from main::@6 main::@8
  to:main::@return
main::@7: scope:[main]  from
  to:main::@3
main::@8: scope:[main]  from
  to:main::@4
main::@return: scope:[main]  from main::@4
  return 
  to:@return
@4: scope:[]  from @3
  to:@5
fill: scope:[fill]  from
  (byte*~) fill::$0 ← (byte*) fill::start + (word) fill::size
  (byte*) fill::end ← (byte*~) fill::$0
  (byte*) fill::addr ← (byte*) fill::start
  to:fill::@1
fill::@1: scope:[fill]  from fill fill::@1
  *((byte*) fill::addr) ← (byte) fill::val
  (byte*) fill::addr ← ++ (byte*) fill::addr
  (bool~) fill::$1 ← (byte*) fill::addr != (byte*) fill::end
  if((bool~) fill::$1) goto fill::@1
  to:fill::@2
fill::@2: scope:[fill]  from fill::@1
  to:fill::@return
fill::@return: scope:[fill]  from fill::@2
  return 
  to:@return
@5: scope:[]  from @4
  kickasm {{ .label pc_restore = *
    .pc = $2000
    logo:
    .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))
    .for (var y=0; y<6	; y++)
        .for (var x=0;x<40; x++)
            .for(var cp=0; cp<8; cp++)
                .byte logoPic.getMulticolorByte(x,cp+y*8)
    .pc = pc_restore
 }}
  call main 
  to:@end
@end: scope:[]  from @5

Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call (byte~) main::$0 ← call toD018 (byte*) SCREEN (byte*) LOGO 
Removing unused procedure toD018
Removing unused procedure toDd00
Removing unused procedure vicSelectGfxBank
Eliminating unused variable (byte*) PROCPORT_DDR and assignment [0] (byte*) PROCPORT_DDR ← ((byte*)) (byte/signed byte/word/signed word/dword/signed dword) 0
Eliminating unused variable (byte) PROCPORT_DDR_MEMORY_MASK and assignment [1] (byte) PROCPORT_DDR_MEMORY_MASK ← (byte/signed byte/word/signed word/dword/signed dword) 7
Eliminating unused variable (byte*) PROCPORT and assignment [2] (byte*) PROCPORT ← ((byte*)) (byte/signed byte/word/signed word/dword/signed dword) 1
Eliminating unused variable (byte) PROCPORT_RAM_ALL and assignment [3] (byte) PROCPORT_RAM_ALL ← (byte/signed byte/word/signed word/dword/signed dword) 48
Eliminating unused variable (byte) PROCPORT_RAM_IO and assignment [4] (byte) PROCPORT_RAM_IO ← (byte/signed byte/word/signed word/dword/signed dword) 53
Eliminating unused variable (byte) PROCPORT_RAM_CHARROM and assignment [5] (byte) PROCPORT_RAM_CHARROM ← (byte/signed byte/word/signed word/dword/signed dword) 49
Eliminating unused variable (byte) PROCPORT_KERNEL_IO and assignment [6] (byte) PROCPORT_KERNEL_IO ← (byte/signed byte/word/signed word/dword/signed dword) 54
Eliminating unused variable (byte) PROCPORT_BASIC_KERNEL_IO and assignment [7] (byte) PROCPORT_BASIC_KERNEL_IO ← (byte/signed byte/word/signed word/dword/signed dword) 55
Eliminating unused variable (byte*) CHARGEN and assignment [8] (byte*) CHARGEN ← ((byte*)) (word/dword/signed dword) 53248
Eliminating unused variable (byte*) SPRITES_XPOS and assignment [9] (byte*) SPRITES_XPOS ← ((byte*)) (word/dword/signed dword) 53248
Eliminating unused variable (byte*) SPRITES_YPOS and assignment [10] (byte*) SPRITES_YPOS ← ((byte*)) (word/dword/signed dword) 53249
Eliminating unused variable (byte*) SPRITES_XMSB and assignment [11] (byte*) SPRITES_XMSB ← ((byte*)) (word/dword/signed dword) 53264
Eliminating unused variable (byte*) RASTER and assignment [12] (byte*) RASTER ← ((byte*)) (word/dword/signed dword) 53266
Eliminating unused variable (byte*) SPRITES_ENABLE and assignment [13] (byte*) SPRITES_ENABLE ← ((byte*)) (word/dword/signed dword) 53269
Eliminating unused variable (byte*) SPRITES_EXPAND_Y and assignment [14] (byte*) SPRITES_EXPAND_Y ← ((byte*)) (word/dword/signed dword) 53271
Eliminating unused variable (byte*) SPRITES_PRIORITY and assignment [15] (byte*) SPRITES_PRIORITY ← ((byte*)) (word/dword/signed dword) 53275
Eliminating unused variable (byte*) SPRITES_MC and assignment [16] (byte*) SPRITES_MC ← ((byte*)) (word/dword/signed dword) 53276
Eliminating unused variable (byte*) SPRITES_EXPAND_X and assignment [17] (byte*) SPRITES_EXPAND_X ← ((byte*)) (word/dword/signed dword) 53277
Eliminating unused variable (byte*) BGCOL1 and assignment [20] (byte*) BGCOL1 ← ((byte*)) (word/dword/signed dword) 53281
Eliminating unused variable (byte*) BGCOL4 and assignment [23] (byte*) BGCOL4 ← ((byte*)) (word/dword/signed dword) 53284
Eliminating unused variable (byte*) SPRITES_MC1 and assignment [24] (byte*) SPRITES_MC1 ← ((byte*)) (word/dword/signed dword) 53285
Eliminating unused variable (byte*) SPRITES_MC2 and assignment [25] (byte*) SPRITES_MC2 ← ((byte*)) (word/dword/signed dword) 53286
Eliminating unused variable (byte*) SPRITES_COLS and assignment [26] (byte*) SPRITES_COLS ← ((byte*)) (word/dword/signed dword) 53287
Eliminating unused variable (byte*) VIC_CONTROL and assignment [27] (byte*) VIC_CONTROL ← ((byte*)) (word/dword/signed dword) 53265
Eliminating unused variable (byte*) D011 and assignment [28] (byte*) D011 ← ((byte*)) (word/dword/signed dword) 53265
Eliminating unused variable (byte) VIC_RST8 and assignment [29] (byte) VIC_RST8 ← (byte/word/signed word/dword/signed dword) 128
Eliminating unused variable (byte) VIC_ECM and assignment [30] (byte) VIC_ECM ← (byte/signed byte/word/signed word/dword/signed dword) 64
Eliminating unused variable (byte) VIC_BMM and assignment [31] (byte) VIC_BMM ← (byte/signed byte/word/signed word/dword/signed dword) 32
Eliminating unused variable (byte) VIC_DEN and assignment [32] (byte) VIC_DEN ← (byte/signed byte/word/signed word/dword/signed dword) 16
Eliminating unused variable (byte) VIC_RSEL and assignment [33] (byte) VIC_RSEL ← (byte/signed byte/word/signed word/dword/signed dword) 8
Eliminating unused variable (byte*) VIC_CONTROL2 and assignment [34] (byte*) VIC_CONTROL2 ← ((byte*)) (word/dword/signed dword) 53270
Eliminating unused variable (byte*) VIC_MEMORY and assignment [39] (byte*) VIC_MEMORY ← ((byte*)) (word/dword/signed dword) 53272
Eliminating unused variable (byte*) CIA1_PORT_A and assignment [41] (byte*) CIA1_PORT_A ← ((byte*)) (word/dword/signed dword) 56320
Eliminating unused variable (byte*) CIA1_PORT_B and assignment [42] (byte*) CIA1_PORT_B ← ((byte*)) (word/dword/signed dword) 56321
Eliminating unused variable (byte*) CIA1_PORT_A_DDR and assignment [43] (byte*) CIA1_PORT_A_DDR ← ((byte*)) (word/dword/signed dword) 56322
Eliminating unused variable (byte*) CIA1_PORT_B_DDR and assignment [44] (byte*) CIA1_PORT_B_DDR ← ((byte*)) (word/dword/signed dword) 56323
Eliminating unused variable (byte*) CIA2_PORT_A and assignment [45] (byte*) CIA2_PORT_A ← ((byte*)) (word/dword/signed dword) 56576
Eliminating unused variable (byte*) CIA2_PORT_B and assignment [46] (byte*) CIA2_PORT_B ← ((byte*)) (word/dword/signed dword) 56577
Eliminating unused variable (byte*) CIA2_PORT_A_DDR and assignment [47] (byte*) CIA2_PORT_A_DDR ← ((byte*)) (word/dword/signed dword) 56578
Eliminating unused variable (byte*) CIA2_PORT_B_DDR and assignment [48] (byte*) CIA2_PORT_B_DDR ← ((byte*)) (word/dword/signed dword) 56579
Eliminating unused variable (byte) RED and assignment [51] (byte) RED ← (byte/signed byte/word/signed word/dword/signed dword) 2
Eliminating unused variable (byte) CYAN and assignment [52] (byte) CYAN ← (byte/signed byte/word/signed word/dword/signed dword) 3
Eliminating unused variable (byte) PURPLE and assignment [53] (byte) PURPLE ← (byte/signed byte/word/signed word/dword/signed dword) 4
Eliminating unused variable (byte) GREEN and assignment [54] (byte) GREEN ← (byte/signed byte/word/signed word/dword/signed dword) 5
Eliminating unused variable (byte) BLUE and assignment [55] (byte) BLUE ← (byte/signed byte/word/signed word/dword/signed dword) 6
Eliminating unused variable (byte) YELLOW and assignment [56] (byte) YELLOW ← (byte/signed byte/word/signed word/dword/signed dword) 7
Eliminating unused variable (byte) ORANGE and assignment [57] (byte) ORANGE ← (byte/signed byte/word/signed word/dword/signed dword) 8
Eliminating unused variable (byte) BROWN and assignment [58] (byte) BROWN ← (byte/signed byte/word/signed word/dword/signed dword) 9
Eliminating unused variable (byte) PINK and assignment [59] (byte) PINK ← (byte/signed byte/word/signed word/dword/signed dword) 10
Eliminating unused variable (byte) GREY and assignment [61] (byte) GREY ← (byte/signed byte/word/signed word/dword/signed dword) 12
Eliminating unused variable (byte) LIGHT_GREEN and assignment [62] (byte) LIGHT_GREEN ← (byte/signed byte/word/signed word/dword/signed dword) 13
Eliminating unused variable (byte) LIGHT_BLUE and assignment [63] (byte) LIGHT_BLUE ← (byte/signed byte/word/signed word/dword/signed dword) 14
Eliminating unused variable (byte) LIGHT_GREY and assignment [64] (byte) LIGHT_GREY ← (byte/signed byte/word/signed word/dword/signed dword) 15
Eliminating unused variable - keeping the call (void~) main::$3
Eliminating unused variable - keeping the call (void~) main::$6
Eliminating unused variable (byte*~) main::$8 and assignment [99] (byte*~) main::$8 ← (byte*) SCREEN + (word/signed word/dword/signed dword) 999
Eliminating unused variable (byte*~) main::$9 and assignment [100] (byte*~) main::$9 ← (byte*) SCREEN + (word/signed word/dword/signed dword) 999
Removing empty block @1
Removing empty block @2
Removing empty block main::toD0181_@1
Removing empty block main::@5
Removing empty block main::@6
Removing empty block main::@4
Removing empty block main::@7
Removing empty block main::@8
Removing empty block @4
Removing empty block fill::@2
PROCEDURE MODIFY VARIABLE ANALYSIS

Completing Phi functions...
Completing Phi functions...
Completing Phi functions...

CONTROL FLOW GRAPH SSA WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (byte*) BORDERCOL#0 ← ((byte*)) (word/dword/signed dword) 53280
  (byte*) BGCOL#0 ← ((byte*)) (word/dword/signed dword) 53281
  (byte*) BGCOL2#0 ← ((byte*)) (word/dword/signed dword) 53282
  (byte*) BGCOL3#0 ← ((byte*)) (word/dword/signed dword) 53283
  (byte*) D016#0 ← ((byte*)) (word/dword/signed dword) 53270
  (byte) VIC_MCM#0 ← (byte/signed byte/word/signed word/dword/signed dword) 16
  (byte) VIC_CSEL#0 ← (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte*) D018#0 ← ((byte*)) (word/dword/signed dword) 53272
  (byte*) COLS#0 ← ((byte*)) (word/dword/signed dword) 55296
  (byte) BLACK#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) WHITE#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) DARK_GREY#0 ← (byte/signed byte/word/signed word/dword/signed dword) 11
  to:@3
@3: scope:[]  from @begin
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word/dword/signed dword) 1024
  (byte*) LOGO#0 ← ((byte*)) (word/signed word/dword/signed dword) 8192
  to:@5
main: scope:[main]  from @5
  (byte*) LOGO#1 ← phi( @5/(byte*) LOGO#2 )
  (byte*) SCREEN#1 ← phi( @5/(byte*) SCREEN#5 )
  *((byte*) BORDERCOL#0) ← (byte) WHITE#0
  *((byte*) BGCOL2#0) ← (byte) DARK_GREY#0
  *((byte*) BGCOL#0) ← *((byte*) BGCOL2#0)
  *((byte*) BGCOL3#0) ← (byte) BLACK#0
  (byte*) main::toD0181_screen#0 ← (byte*) SCREEN#1
  (byte*) main::toD0181_gfx#0 ← (byte*) LOGO#1
  to:main::toD0181
main::toD0181: scope:[main]  from main
  (byte*) SCREEN#9 ← phi( main/(byte*) SCREEN#1 )
  (byte*) main::toD0181_gfx#1 ← phi( main/(byte*) main::toD0181_gfx#0 )
  (byte*) main::toD0181_screen#1 ← phi( main/(byte*) main::toD0181_screen#0 )
  (word) main::toD0181_$0#0 ← ((word)) (byte*) main::toD0181_screen#1
  (word) main::toD0181_$1#0 ← (word) main::toD0181_$0#0 & (word/signed word/dword/signed dword) 16383
  (word) main::toD0181_$2#0 ← (word) main::toD0181_$1#0 << (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte) main::toD0181_$3#0 ← > (word) main::toD0181_$2#0
  (word) main::toD0181_$4#0 ← ((word)) (byte*) main::toD0181_gfx#1
  (byte) main::toD0181_$5#0 ← > (word) main::toD0181_$4#0
  (byte) main::toD0181_$6#0 ← (byte) main::toD0181_$5#0 >> (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte) main::toD0181_$7#0 ← (byte) main::toD0181_$6#0 & (byte/signed byte/word/signed word/dword/signed dword) 15
  (byte) main::toD0181_$8#0 ← (byte) main::toD0181_$3#0 | (byte) main::toD0181_$7#0
  (byte) main::toD0181_return#0 ← (byte) main::toD0181_$8#0
  to:main::toD0181_@return
main::toD0181_@return: scope:[main]  from main::toD0181
  (byte*) SCREEN#6 ← phi( main::toD0181/(byte*) SCREEN#9 )
  (byte) main::toD0181_return#2 ← phi( main::toD0181/(byte) main::toD0181_return#0 )
  (byte) main::toD0181_return#1 ← (byte) main::toD0181_return#2
  to:main::@9
main::@9: scope:[main]  from main::toD0181_@return
  (byte*) SCREEN#2 ← phi( main::toD0181_@return/(byte*) SCREEN#6 )
  (byte) main::toD0181_return#3 ← phi( main::toD0181_@return/(byte) main::toD0181_return#1 )
  (byte~) main::$0 ← (byte) main::toD0181_return#3
  *((byte*) D018#0) ← (byte~) main::$0
  (byte~) main::$1 ← (byte) VIC_MCM#0 | (byte) VIC_CSEL#0
  *((byte*) D016#0) ← (byte~) main::$1
  (word/signed word/dword/signed dword~) main::$2 ← (byte/signed byte/word/signed word/dword/signed dword) 40 * (byte/signed byte/word/signed word/dword/signed dword) 25
  (byte*) fill::start#0 ← (byte*) SCREEN#2
  (word) fill::size#0 ← (word/signed word/dword/signed dword~) main::$2
  (byte) fill::val#0 ← (byte) BLACK#0
  call fill 
  to:main::@10
main::@10: scope:[main]  from main::@9
  (byte*) SCREEN#10 ← phi( main::@9/(byte*) SCREEN#2 )
  (word/signed word/dword/signed dword~) main::$4 ← (byte/signed byte/word/signed word/dword/signed dword) 40 * (byte/signed byte/word/signed word/dword/signed dword) 25
  (byte/word/dword~) main::$5 ← (byte) WHITE#0 | (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte*) fill::start#1 ← (byte*) COLS#0
  (word) fill::size#1 ← (word/signed word/dword/signed dword~) main::$4
  (byte) fill::val#1 ← (byte/word/dword~) main::$5
  call fill 
  to:main::@11
main::@11: scope:[main]  from main::@10
  (byte*) SCREEN#7 ← phi( main::@10/(byte*) SCREEN#10 )
  (byte) main::ch#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@11
  (byte*) SCREEN#3 ← phi( main::@1/(byte*) SCREEN#3 main::@11/(byte*) SCREEN#7 )
  (byte) main::ch#2 ← phi( main::@1/(byte) main::ch#1 main::@11/(byte) main::ch#0 )
  *((byte*) SCREEN#3 + (byte) main::ch#2) ← (byte) main::ch#2
  (byte) main::ch#1 ← (byte) main::ch#2 + rangenext(0,239)
  (bool~) main::$7 ← (byte) main::ch#1 != rangelast(0,239)
  if((bool~) main::$7) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@3
  (byte*) SCREEN#8 ← phi( main::@1/(byte*) SCREEN#3 main::@3/(byte*) SCREEN#4 )
  if(true) goto main::@3
  to:main::@return
main::@3: scope:[main]  from main::@2
  (byte*) SCREEN#4 ← phi( main::@2/(byte*) SCREEN#8 )
  (byte*~) main::$10 ← (byte*) SCREEN#4 + (word/signed word/dword/signed dword) 999
  *((byte*~) main::$10) ← ++ *((byte*~) main::$10)
  kickasm {{ inc $d020  }}
  to:main::@2
main::@return: scope:[main]  from main::@2
  return 
  to:@return
fill: scope:[fill]  from main::@10 main::@9
  (byte) fill::val#3 ← phi( main::@10/(byte) fill::val#1 main::@9/(byte) fill::val#0 )
  (word) fill::size#2 ← phi( main::@10/(word) fill::size#1 main::@9/(word) fill::size#0 )
  (byte*) fill::start#2 ← phi( main::@10/(byte*) fill::start#1 main::@9/(byte*) fill::start#0 )
  (byte*~) fill::$0 ← (byte*) fill::start#2 + (word) fill::size#2
  (byte*) fill::end#0 ← (byte*~) fill::$0
  (byte*) fill::addr#0 ← (byte*) fill::start#2
  to:fill::@1
fill::@1: scope:[fill]  from fill fill::@1
  (byte*) fill::end#1 ← phi( fill/(byte*) fill::end#0 fill::@1/(byte*) fill::end#1 )
  (byte*) fill::addr#2 ← phi( fill/(byte*) fill::addr#0 fill::@1/(byte*) fill::addr#1 )
  (byte) fill::val#2 ← phi( fill/(byte) fill::val#3 fill::@1/(byte) fill::val#2 )
  *((byte*) fill::addr#2) ← (byte) fill::val#2
  (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2
  (bool~) fill::$1 ← (byte*) fill::addr#1 != (byte*) fill::end#1
  if((bool~) fill::$1) goto fill::@1
  to:fill::@return
fill::@return: scope:[fill]  from fill::@1
  return 
  to:@return
@5: scope:[]  from @3
  (byte*) LOGO#2 ← phi( @3/(byte*) LOGO#0 )
  (byte*) SCREEN#5 ← phi( @3/(byte*) SCREEN#0 )
  kickasm {{ .label pc_restore = *
    .pc = $2000
    logo:
    .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))
    .for (var y=0; y<6	; y++)
        .for (var x=0;x<40; x++)
            .for(var cp=0; cp<8; cp++)
                .byte logoPic.getMulticolorByte(x,cp+y*8)
    .pc = pc_restore
 }}
  call main 
  to:@6
@6: scope:[]  from @5
  to:@end
@end: scope:[]  from @6

SYMBOL TABLE SSA
(label) @3
(label) @5
(label) @6
(label) @begin
(label) @end
(byte*) BGCOL
(byte*) BGCOL#0
(byte*) BGCOL2
(byte*) BGCOL2#0
(byte*) BGCOL3
(byte*) BGCOL3#0
(byte) BLACK
(byte) BLACK#0
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte*) COLS
(byte*) COLS#0
(byte*) D016
(byte*) D016#0
(byte*) D018
(byte*) D018#0
(byte) DARK_GREY
(byte) DARK_GREY#0
(byte*) LOGO
(byte*) LOGO#0
(byte*) LOGO#1
(byte*) LOGO#2
(byte*) SCREEN
(byte*) SCREEN#0
(byte*) SCREEN#1
(byte*) SCREEN#10
(byte*) SCREEN#2
(byte*) SCREEN#3
(byte*) SCREEN#4
(byte*) SCREEN#5
(byte*) SCREEN#6
(byte*) SCREEN#7
(byte*) SCREEN#8
(byte*) SCREEN#9
(byte) VIC_CSEL
(byte) VIC_CSEL#0
(byte) VIC_MCM
(byte) VIC_MCM#0
(byte) WHITE
(byte) WHITE#0
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(byte*~) fill::$0
(bool~) fill::$1
(label) fill::@1
(label) fill::@return
(byte*) fill::addr
(byte*) fill::addr#0
(byte*) fill::addr#1
(byte*) fill::addr#2
(byte*) fill::end
(byte*) fill::end#0
(byte*) fill::end#1
(word) fill::size
(word) fill::size#0
(word) fill::size#1
(word) fill::size#2
(byte*) fill::start
(byte*) fill::start#0
(byte*) fill::start#1
(byte*) fill::start#2
(byte) fill::val
(byte) fill::val#0
(byte) fill::val#1
(byte) fill::val#2
(byte) fill::val#3
(void()) main()
(byte~) main::$0
(byte~) main::$1
(byte*~) main::$10
(word/signed word/dword/signed dword~) main::$2
(word/signed word/dword/signed dword~) main::$4
(byte/word/dword~) main::$5
(bool~) main::$7
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@2
(label) main::@3
(label) main::@9
(label) main::@return
(byte) main::ch
(byte) main::ch#0
(byte) main::ch#1
(byte) main::ch#2
(label) main::toD0181
(word~) main::toD0181_$0
(word) main::toD0181_$0#0
(word~) main::toD0181_$1
(word) main::toD0181_$1#0
(word~) main::toD0181_$2
(word) main::toD0181_$2#0
(byte~) main::toD0181_$3
(byte) main::toD0181_$3#0
(word~) main::toD0181_$4
(word) main::toD0181_$4#0
(byte~) main::toD0181_$5
(byte) main::toD0181_$5#0
(byte~) main::toD0181_$6
(byte) main::toD0181_$6#0
(byte~) main::toD0181_$7
(byte) main::toD0181_$7#0
(byte~) main::toD0181_$8
(byte) main::toD0181_$8#0
(label) main::toD0181_@return
(byte*) main::toD0181_gfx
(byte*) main::toD0181_gfx#0
(byte*) main::toD0181_gfx#1
(byte) main::toD0181_return
(byte) main::toD0181_return#0
(byte) main::toD0181_return#1
(byte) main::toD0181_return#2
(byte) main::toD0181_return#3
(byte*) main::toD0181_screen
(byte*) main::toD0181_screen#0
(byte*) main::toD0181_screen#1

OPTIMIZING CONTROL FLOW GRAPH
Culled Empty Block (label) @6
Succesful SSA optimization Pass2CullEmptyBlocks
Not aliassing across scopes: SCREEN#1 SCREEN#5
Not aliassing across scopes: LOGO#1 LOGO#2
Not aliassing across scopes: main::toD0181_screen#0 SCREEN#1
Not aliassing across scopes: main::toD0181_gfx#0 LOGO#1
Not aliassing across scopes: fill::start#0 SCREEN#2
Not aliassing across scopes: fill::val#0 BLACK#0
Not aliassing across scopes: fill::start#1 COLS#0
Not aliassing identity: SCREEN#3 SCREEN#3
Not aliassing across scopes: fill::start#2 fill::start#1
Not aliassing across scopes: fill::size#2 fill::size#1
Not aliassing across scopes: fill::val#3 fill::val#1
Alias (byte*) main::toD0181_screen#0 = (byte*) main::toD0181_screen#1 
Alias (byte*) main::toD0181_gfx#0 = (byte*) main::toD0181_gfx#1 
Alias (byte*) SCREEN#1 = (byte*) SCREEN#9 (byte*) SCREEN#6 (byte*) SCREEN#2 (byte*) SCREEN#10 (byte*) SCREEN#7 
Alias (byte) main::toD0181_return#0 = (byte) main::toD0181_$8#0 (byte) main::toD0181_return#2 (byte) main::toD0181_return#1 (byte) main::toD0181_return#3 (byte~) main::$0 
Alias (word) fill::size#0 = (word/signed word/dword/signed dword~) main::$2 
Alias (word) fill::size#1 = (word/signed word/dword/signed dword~) main::$4 
Alias (byte) fill::val#1 = (byte/word/dword~) main::$5 
Alias (byte*) SCREEN#4 = (byte*) SCREEN#8 
Alias (byte*) fill::end#0 = (byte*~) fill::$0 
Alias (byte*) fill::addr#0 = (byte*) fill::start#2 
Alias (byte*) SCREEN#0 = (byte*) SCREEN#5 
Alias (byte*) LOGO#0 = (byte*) LOGO#2 
Succesful SSA optimization Pass2AliasElimination
Not aliassing across scopes: SCREEN#1 SCREEN#0
Not aliassing across scopes: LOGO#1 LOGO#0
Not aliassing across scopes: main::toD0181_screen#0 SCREEN#1
Not aliassing across scopes: main::toD0181_gfx#0 LOGO#1
Not aliassing across scopes: fill::start#0 SCREEN#1
Not aliassing across scopes: fill::val#0 BLACK#0
Not aliassing across scopes: fill::start#1 COLS#0
Not aliassing identity: SCREEN#3 SCREEN#3
Not aliassing across scopes: fill::addr#0 fill::start#1
Not aliassing across scopes: fill::size#2 fill::size#1
Not aliassing across scopes: fill::val#3 fill::val#1
Self Phi Eliminated (byte*) SCREEN#3
Self Phi Eliminated (byte*) SCREEN#4
Self Phi Eliminated (byte) fill::val#2
Self Phi Eliminated (byte*) fill::end#1
Succesful SSA optimization Pass2SelfPhiElimination
Redundant Phi (byte*) SCREEN#1 (byte*) SCREEN#0
Redundant Phi (byte*) LOGO#1 (byte*) LOGO#0
Redundant Phi (byte*) SCREEN#3 (byte*) SCREEN#1
Redundant Phi (byte*) SCREEN#4 (byte*) SCREEN#3
Redundant Phi (byte) fill::val#2 (byte) fill::val#3
Redundant Phi (byte*) fill::end#1 (byte*) fill::end#0
Succesful SSA optimization Pass2RedundantPhiElimination
Simple Condition (bool~) main::$7 if((byte) main::ch#1!=rangelast(0,239)) goto main::@1
Simple Condition (bool~) fill::$1 if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1
Succesful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) BORDERCOL#0 = ((byte*))53280
Constant (const byte*) BGCOL#0 = ((byte*))53281
Constant (const byte*) BGCOL2#0 = ((byte*))53282
Constant (const byte*) BGCOL3#0 = ((byte*))53283
Constant (const byte*) D016#0 = ((byte*))53270
Constant (const byte) VIC_MCM#0 = 16
Constant (const byte) VIC_CSEL#0 = 8
Constant (const byte*) D018#0 = ((byte*))53272
Constant (const byte*) COLS#0 = ((byte*))55296
Constant (const byte) BLACK#0 = 0
Constant (const byte) WHITE#0 = 1
Constant (const byte) DARK_GREY#0 = 11
Constant (const byte*) SCREEN#0 = ((byte*))1024
Constant (const byte*) LOGO#0 = ((byte*))8192
Constant (const word) fill::size#0 = 40*25
Constant (const word) fill::size#1 = 40*25
Constant (const byte) main::ch#0 = 0
Succesful SSA optimization Pass2ConstantIdentification
Constant (const byte*) main::toD0181_screen#0 = SCREEN#0
Constant (const byte*) main::toD0181_gfx#0 = LOGO#0
Constant (const byte) main::$1 = VIC_MCM#0|VIC_CSEL#0
Constant (const byte*) fill::start#0 = SCREEN#0
Constant (const byte) fill::val#0 = BLACK#0
Constant (const byte) fill::val#1 = WHITE#0|8
Constant (const byte*) fill::start#1 = COLS#0
Constant (const byte*) main::$10 = SCREEN#0+999
Succesful SSA optimization Pass2ConstantIdentification
Constant (const word) main::toD0181_$0#0 = ((word))main::toD0181_screen#0
Constant (const word) main::toD0181_$4#0 = ((word))main::toD0181_gfx#0
Succesful SSA optimization Pass2ConstantIdentification
Constant (const word) main::toD0181_$1#0 = main::toD0181_$0#0&16383
Constant (const byte) main::toD0181_$5#0 = >main::toD0181_$4#0
Succesful SSA optimization Pass2ConstantIdentification
Constant (const word) main::toD0181_$2#0 = main::toD0181_$1#0<<2
Constant (const byte) main::toD0181_$6#0 = main::toD0181_$5#0>>2
Succesful SSA optimization Pass2ConstantIdentification
Constant (const byte) main::toD0181_$3#0 = >main::toD0181_$2#0
Constant (const byte) main::toD0181_$7#0 = main::toD0181_$6#0&15
Succesful SSA optimization Pass2ConstantIdentification
Constant (const byte) main::toD0181_return#0 = main::toD0181_$3#0|main::toD0181_$7#0
Succesful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination if(true) goto main::@3
Succesful SSA optimization Pass2ConstantIfs
Removing unused block main::@return
Succesful SSA optimization Pass2EliminateUnusedBlocks
Resolved ranged next value main::ch#1 ← ++ main::ch#2 to ++
Resolved ranged comparison value if(main::ch#1!=rangelast(0,239)) goto main::@1 to (byte/word/signed word/dword/signed dword) 240
Culled Empty Block (label) @3
Culled Empty Block (label) main::toD0181_@return
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@2
Succesful SSA optimization Pass2CullEmptyBlocks
OPTIMIZING CONTROL FLOW GRAPH
Inlining constant with var siblings (const byte) main::ch#0
Inlining constant with var siblings (const byte) main::ch#0
Inlining constant with var siblings (const word) fill::size#0
Inlining constant with different constant siblings (const word) fill::size#0
Inlining constant with var siblings (const word) fill::size#1
Inlining constant with different constant siblings (const word) fill::size#1
Inlining constant with var siblings (const byte) fill::val#0
Inlining constant with different constant siblings (const byte) fill::val#0
Inlining constant with var siblings (const byte) fill::val#1
Constant inlined fill::val#0 = (const byte) BLACK#0
Constant inlined main::toD0181_screen#0 = (const byte*) SCREEN#0
Constant inlined main::toD0181_gfx#0 = (const byte*) LOGO#0
Constant inlined fill::val#1 = (const byte) WHITE#0|(byte/signed byte/word/signed word/dword/signed dword) 8
Constant inlined fill::size#1 = (byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25
Constant inlined main::toD0181_$0#0 = ((word))(const byte*) SCREEN#0
Constant inlined fill::size#0 = (byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25
Constant inlined main::toD0181_$1#0 = ((word))(const byte*) SCREEN#0&(word/signed word/dword/signed dword) 16383
Constant inlined main::$10 = (const byte*) SCREEN#0+(word/signed word/dword/signed dword) 999
Constant inlined main::toD0181_$6#0 = >((word))(const byte*) LOGO#0>>(byte/signed byte/word/signed word/dword/signed dword) 2
Constant inlined main::toD0181_$7#0 = >((word))(const byte*) LOGO#0>>(byte/signed byte/word/signed word/dword/signed dword) 2&(byte/signed byte/word/signed word/dword/signed dword) 15
Constant inlined main::$1 = (const byte) VIC_MCM#0|(const byte) VIC_CSEL#0
Constant inlined main::toD0181_$2#0 = ((word))(const byte*) SCREEN#0&(word/signed word/dword/signed dword) 16383<<(byte/signed byte/word/signed word/dword/signed dword) 2
Constant inlined fill::start#1 = (const byte*) COLS#0
Constant inlined main::toD0181_$3#0 = >((word))(const byte*) SCREEN#0&(word/signed word/dword/signed dword) 16383<<(byte/signed byte/word/signed word/dword/signed dword) 2
Constant inlined fill::start#0 = (const byte*) SCREEN#0
Constant inlined main::toD0181_$4#0 = ((word))(const byte*) LOGO#0
Constant inlined main::toD0181_$5#0 = >((word))(const byte*) LOGO#0
Constant inlined main::ch#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Succesful SSA optimization Pass2ConstantInlining
Block Sequence Planned @begin @5 @end main main::toD0181 main::@9 main::@10 main::@1 main::@3 fill fill::@1 fill::@return 
Added new block during phi lifting main::@12(between main::@1 and main::@1)
Added new block during phi lifting fill::@3(between fill::@1 and fill::@1)
Block Sequence Planned @begin @5 @end main main::toD0181 main::@9 main::@10 main::@1 main::@3 main::@12 fill fill::@1 fill::@return fill::@3 
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::@10
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to fill:11 fill:13 

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Created 5 initial phi equivalence classes
Coalesced [20] main::ch#3 ← main::ch#1
Coalesced [23] fill::addr#3 ← fill::addr#0
Coalesced [29] fill::addr#4 ← fill::addr#1
Coalesced down to 4 phi equivalence classes
Culled Empty Block (label) main::@12
Culled Empty Block (label) fill::@3
Block Sequence Planned @begin @5 @end main main::toD0181 main::@9 main::@10 main::@1 main::@3 fill fill::@1 fill::@return 
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::@10
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi() [ ] ( )
  to:@5
@5: scope:[]  from @begin
  kickasm {{ .label pc_restore = *
    .pc = $2000
    logo:
    .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))
    .for (var y=0; y<6	; y++)
        .for (var x=0;x<40; x++)
            .for(var cp=0; cp<8; cp++)
                .byte logoPic.getMulticolorByte(x,cp+y*8)
    .pc = pc_restore
 }}
  [2] call main  [ ] ( )
  to:@end
@end: scope:[]  from @5
  [3] phi() [ ] ( )
main: scope:[main]  from @5
  [4] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ ] ( main:2 [ ] )
  [5] *((const byte*) BGCOL2#0) ← (const byte) DARK_GREY#0 [ ] ( main:2 [ ] )
  [6] *((const byte*) BGCOL#0) ← *((const byte*) BGCOL2#0) [ ] ( main:2 [ ] )
  [7] *((const byte*) BGCOL3#0) ← (const byte) BLACK#0 [ ] ( main:2 [ ] )
  to:main::toD0181
main::toD0181: scope:[main]  from main
  [8] phi() [ ] ( main:2 [ ] )
  to:main::@9
main::@9: scope:[main]  from main::toD0181
  [9] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] )
  [10] *((const byte*) D016#0) ← (const byte) VIC_MCM#0|(const byte) VIC_CSEL#0 [ ] ( main:2 [ ] )
  [11] call fill  [ ] ( main:2 [ ] )
  to:main::@10
main::@10: scope:[main]  from main::@9
  [12] phi() [ ] ( main:2 [ ] )
  [13] call fill  [ ] ( main:2 [ ] )
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@10
  [14] (byte) main::ch#2 ← phi( main::@1/(byte) main::ch#1 main::@10/(byte/signed byte/word/signed word/dword/signed dword) 0 ) [ main::ch#2 ] ( main:2 [ main::ch#2 ] )
  [15] *((const byte*) SCREEN#0 + (byte) main::ch#2) ← (byte) main::ch#2 [ main::ch#2 ] ( main:2 [ main::ch#2 ] )
  [16] (byte) main::ch#1 ← ++ (byte) main::ch#2 [ main::ch#1 ] ( main:2 [ main::ch#1 ] )
  [17] if((byte) main::ch#1!=(byte/word/signed word/dword/signed dword) 240) goto main::@1 [ main::ch#1 ] ( main:2 [ main::ch#1 ] )
  to:main::@3
main::@3: scope:[main]  from main::@1 main::@3
  [18] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) 999) ← ++ *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) 999) [ ] ( main:2 [ ] )
  kickasm {{ inc $d020  }}
  to:main::@3
fill: scope:[fill]  from main::@10 main::@9
  [20] (byte) fill::val#3 ← phi( main::@10/(const byte) WHITE#0|(byte/signed byte/word/signed word/dword/signed dword) 8 main::@9/(const byte) BLACK#0 ) [ fill::addr#0 fill::size#2 fill::val#3 ] ( main:2::fill:11 [ fill::addr#0 fill::size#2 fill::val#3 ] main:2::fill:13 [ fill::addr#0 fill::size#2 fill::val#3 ] )
  [20] (word) fill::size#2 ← phi( main::@10/(byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25 main::@9/(byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25 ) [ fill::addr#0 fill::size#2 fill::val#3 ] ( main:2::fill:11 [ fill::addr#0 fill::size#2 fill::val#3 ] main:2::fill:13 [ fill::addr#0 fill::size#2 fill::val#3 ] )
  [20] (byte*) fill::addr#0 ← phi( main::@10/(const byte*) COLS#0 main::@9/(const byte*) SCREEN#0 ) [ fill::addr#0 fill::size#2 fill::val#3 ] ( main:2::fill:11 [ fill::addr#0 fill::size#2 fill::val#3 ] main:2::fill:13 [ fill::addr#0 fill::size#2 fill::val#3 ] )
  [21] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) fill::size#2 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::fill:11 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::fill:13 [ fill::addr#0 fill::val#3 fill::end#0 ] )
  to:fill::@1
fill::@1: scope:[fill]  from fill fill::@1
  [22] (byte*) fill::addr#2 ← phi( fill/(byte*) fill::addr#0 fill::@1/(byte*) fill::addr#1 ) [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#2 ] )
  [23] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#2 ] )
  [24] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] )
  [25] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] )
  to:fill::@return
fill::@return: scope:[fill]  from fill::@1
  [26] return  [ ] ( main:2::fill:11 [ ] main:2::fill:13 [ ] )
  to:@return

DOMINATORS
@begin dominated by  @begin 
@5 dominated by  @begin @5 
@end dominated by  @begin @5 @end 
main dominated by  @begin @5 main 
main::toD0181 dominated by  @begin @5 main::toD0181 main 
main::@9 dominated by  main::@9 @begin @5 main::toD0181 main 
main::@10 dominated by  main::@9 @begin main::@10 @5 main::toD0181 main 
main::@1 dominated by  main::@9 @begin main::@10 @5 main::toD0181 main::@1 main 
main::@3 dominated by  main::@9 @begin main::@10 @5 main::toD0181 main::@1 main main::@3 
fill dominated by  main::@9 @begin @5 main::toD0181 main fill 
fill::@1 dominated by  main::@9 @begin @5 main::toD0181 main fill::@1 fill 
fill::@return dominated by  main::@9 @begin @5 main::toD0181 fill::@return main fill::@1 fill 

NATURAL LOOPS
Found back edge: Loop head: main::@1 tails: main::@1 blocks: null
Found back edge: Loop head: main::@3 tails: main::@3 blocks: null
Found back edge: Loop head: fill::@1 tails: fill::@1 blocks: null
Populated: Loop head: main::@1 tails: main::@1 blocks: main::@1 
Populated: Loop head: main::@3 tails: main::@3 blocks: main::@3 
Populated: Loop head: fill::@1 tails: fill::@1 blocks: fill::@1 
Loop head: main::@1 tails: main::@1 blocks: main::@1 
Loop head: main::@3 tails: main::@3 blocks: main::@3 
Loop head: fill::@1 tails: fill::@1 blocks: fill::@1 

NATURAL LOOPS WITH DEPTH
Found 0 loops in scope []
Found 2 loops in scope [main]
  Loop head: main::@1 tails: main::@1 blocks: main::@1 
  Loop head: main::@3 tails: main::@3 blocks: main::@3 
Found 1 loops in scope [fill]
  Loop head: fill::@1 tails: fill::@1 blocks: fill::@1 
Loop head: main::@1 tails: main::@1 blocks: main::@1  depth: 1
Loop head: main::@3 tails: main::@3 blocks: main::@3  depth: 1
Loop head: fill::@1 tails: fill::@1 blocks: fill::@1  depth: 1


VARIABLE REGISTER WEIGHTS
(byte*) BGCOL
(byte*) BGCOL2
(byte*) BGCOL3
(byte) BLACK
(byte*) BORDERCOL
(byte*) COLS
(byte*) D016
(byte*) D018
(byte) DARK_GREY
(byte*) LOGO
(byte*) SCREEN
(byte) VIC_CSEL
(byte) VIC_MCM
(byte) WHITE
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(byte*) fill::addr
(byte*) fill::addr#0 2.0
(byte*) fill::addr#1 16.5
(byte*) fill::addr#2 17.5
(byte*) fill::end
(byte*) fill::end#0 2.6
(word) fill::size
(word) fill::size#2 2.0
(byte*) fill::start
(byte) fill::val
(byte) fill::val#3 1.8333333333333333
(void()) main()
(byte) main::ch
(byte) main::ch#1 16.5
(byte) main::ch#2 22.0
(word~) main::toD0181_$0
(word~) main::toD0181_$1
(word~) main::toD0181_$2
(byte~) main::toD0181_$3
(word~) main::toD0181_$4
(byte~) main::toD0181_$5
(byte~) main::toD0181_$6
(byte~) main::toD0181_$7
(byte~) main::toD0181_$8
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(byte*) main::toD0181_screen

Initial phi equivalence classes
[ main::ch#2 main::ch#1 ]
[ fill::size#2 ]
[ fill::val#3 ]
[ fill::addr#2 fill::addr#0 fill::addr#1 ]
Added variable fill::end#0 to zero page equivalence class [ fill::end#0 ]
Complete equivalence classes
[ main::ch#2 main::ch#1 ]
[ fill::size#2 ]
[ fill::val#3 ]
[ fill::addr#2 fill::addr#0 fill::addr#1 ]
[ fill::end#0 ]
Allocated zp ZP_BYTE:2 [ main::ch#2 main::ch#1 ]
Allocated zp ZP_WORD:3 [ fill::size#2 ]
Allocated zp ZP_BYTE:5 [ fill::val#3 ]
Allocated zp ZP_WORD:6 [ fill::addr#2 fill::addr#0 fill::addr#1 ]
Allocated zp ZP_WORD:8 [ fill::end#0 ]

INITIAL ASM
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label BORDERCOL = $d020
  .label BGCOL = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label D016 = $d016
  .const VIC_MCM = $10
  .const VIC_CSEL = 8
  .label D018 = $d018
  .label COLS = $d800
  .const BLACK = 0
  .const WHITE = 1
  .const DARK_GREY = $b
  .label SCREEN = $400
  .label LOGO = $2000
//SEG2 @begin
bbegin:
  jmp b5
//SEG3 @5
b5:
//SEG4 kickasm {{ .label pc_restore = *     .pc = $2000     logo:     .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))     .for (var y=0; y<6	; y++)         .for (var x=0;x<40; x++)             .for(var cp=0; cp<8; cp++)                 .byte logoPic.getMulticolorByte(x,cp+y*8)     .pc = pc_restore  }}
  .label pc_restore = *
    .pc = $2000
    logo:
    .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))
    .for (var y=0; y<6	; y++)
        .for (var x=0;x<40; x++)
            .for(var cp=0; cp<8; cp++)
                .byte logoPic.getMulticolorByte(x,cp+y*8)
    .pc = pc_restore

//SEG5 [2] call main  [ ] ( )
  jsr main
//SEG6 [3] phi from @5 to @end [phi:@5->@end]
bend_from_b5:
  jmp bend
//SEG7 @end
bend:
//SEG8 main
main: {
    .const toD0181_return = (>(SCREEN&$3fff)<<2)|(>LOGO)>>2&$f
    .label ch = 2
  //SEG9 [4] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
  //SEG10 [5] *((const byte*) BGCOL2#0) ← (const byte) DARK_GREY#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #DARK_GREY
    sta BGCOL2
  //SEG11 [6] *((const byte*) BGCOL#0) ← *((const byte*) BGCOL2#0) [ ] ( main:2 [ ] ) -- _deref_pbuc1=_deref_pbuc2 
    lda BGCOL2
    sta BGCOL
  //SEG12 [7] *((const byte*) BGCOL3#0) ← (const byte) BLACK#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BGCOL3
  //SEG13 [8] phi from main to main::toD0181 [phi:main->main::toD0181]
  toD0181_from_main:
    jmp toD0181
  //SEG14 main::toD0181
  toD0181:
    jmp b9
  //SEG15 main::@9
  b9:
  //SEG16 [9] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG17 [10] *((const byte*) D016#0) ← (const byte) VIC_MCM#0|(const byte) VIC_CSEL#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #VIC_MCM|VIC_CSEL
    sta D016
  //SEG18 [11] call fill  [ ] ( main:2 [ ] )
  //SEG19 [20] phi from main::@9 to fill [phi:main::@9->fill]
  fill_from_b9:
  //SEG20 [20] phi (byte) fill::val#3 = (const byte) BLACK#0 [phi:main::@9->fill#0] -- vbuz1=vbuc1 
    lda #BLACK
    sta fill.val
  //SEG21 [20] phi (word) fill::size#2 = (byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25 [phi:main::@9->fill#1] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta fill.size
    lda #>$28*$19
    sta fill.size+1
  //SEG22 [20] phi (byte*) fill::addr#0 = (const byte*) SCREEN#0 [phi:main::@9->fill#2] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta fill.addr
    lda #>SCREEN
    sta fill.addr+1
    jsr fill
  //SEG23 [12] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  b10_from_b9:
    jmp b10
  //SEG24 main::@10
  b10:
  //SEG25 [13] call fill  [ ] ( main:2 [ ] )
  //SEG26 [20] phi from main::@10 to fill [phi:main::@10->fill]
  fill_from_b10:
  //SEG27 [20] phi (byte) fill::val#3 = (const byte) WHITE#0|(byte/signed byte/word/signed word/dword/signed dword) 8 [phi:main::@10->fill#0] -- vbuz1=vbuc1 
    lda #WHITE|8
    sta fill.val
  //SEG28 [20] phi (word) fill::size#2 = (byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25 [phi:main::@10->fill#1] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta fill.size
    lda #>$28*$19
    sta fill.size+1
  //SEG29 [20] phi (byte*) fill::addr#0 = (const byte*) COLS#0 [phi:main::@10->fill#2] -- pbuz1=pbuc1 
    lda #<COLS
    sta fill.addr
    lda #>COLS
    sta fill.addr+1
    jsr fill
  //SEG30 [14] phi from main::@10 to main::@1 [phi:main::@10->main::@1]
  b1_from_b10:
  //SEG31 [14] phi (byte) main::ch#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@10->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta ch
    jmp b1
  //SEG32 [14] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
  //SEG33 [14] phi (byte) main::ch#2 = (byte) main::ch#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
  //SEG34 main::@1
  b1:
  //SEG35 [15] *((const byte*) SCREEN#0 + (byte) main::ch#2) ← (byte) main::ch#2 [ main::ch#2 ] ( main:2 [ main::ch#2 ] ) -- pbuc1_derefidx_vbuz1=vbuz1 
    ldy ch
    tya
    sta SCREEN,y
  //SEG36 [16] (byte) main::ch#1 ← ++ (byte) main::ch#2 [ main::ch#1 ] ( main:2 [ main::ch#1 ] ) -- vbuz1=_inc_vbuz1 
    inc ch
  //SEG37 [17] if((byte) main::ch#1!=(byte/word/signed word/dword/signed dword) 240) goto main::@1 [ main::ch#1 ] ( main:2 [ main::ch#1 ] ) -- vbuz1_neq_vbuc1_then_la1 
    lda ch
    cmp #$f0
    bne b1_from_b1
    jmp b3
  //SEG38 main::@3
  b3:
  //SEG39 [18] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) 999) ← ++ *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) 999) [ ] ( main:2 [ ] ) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN+$3e7
  //SEG40 kickasm {{ inc $d020  }}
    inc $d020 
    jmp b3
}
//SEG41 fill
fill: {
    .label end = 8
    .label addr = 6
    .label size = 3
    .label val = 5
  //SEG42 [21] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) fill::size#2 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::fill:11 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::fill:13 [ fill::addr#0 fill::val#3 fill::end#0 ] ) -- pbuz1=pbuz2_plus_vwuz3 
    lda end
    clc
    adc addr
    sta size
    lda end+1
    adc addr+1
    sta size+1
  //SEG43 [22] phi from fill fill::@1 to fill::@1 [phi:fill/fill::@1->fill::@1]
  b1_from_fill:
  b1_from_b1:
  //SEG44 [22] phi (byte*) fill::addr#2 = (byte*) fill::addr#0 [phi:fill/fill::@1->fill::@1#0] -- register_copy 
    jmp b1
  //SEG45 fill::@1
  b1:
  //SEG46 [23] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#2 ] ) -- _deref_pbuz1=vbuz2 
    lda val
    ldy #0
    sta (addr),y
  //SEG47 [24] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] ) -- pbuz1=_inc_pbuz1 
    inc addr
    bne !+
    inc addr+1
  !:
  //SEG48 [25] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] ) -- pbuz1_neq_pbuz2_then_la1 
    lda addr+1
    cmp end+1
    bne b1_from_b1
    lda addr
    cmp end
    bne b1_from_b1
    jmp breturn
  //SEG49 fill::@return
  breturn:
  //SEG50 [26] return  [ ] ( main:2::fill:11 [ ] main:2::fill:13 [ ] )
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [4] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [5] *((const byte*) BGCOL2#0) ← (const byte) DARK_GREY#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [6] *((const byte*) BGCOL#0) ← *((const byte*) BGCOL2#0) [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((const byte*) BGCOL3#0) ← (const byte) BLACK#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [9] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [10] *((const byte*) D016#0) ← (const byte) VIC_MCM#0|(const byte) VIC_CSEL#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [21] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) fill::size#2 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::fill:11 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::fill:13 [ fill::addr#0 fill::val#3 fill::end#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ fill::val#3 ]
Statement [23] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:5 [ fill::val#3 ]
Statement [25] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] ) always clobbers reg byte a 
Statement [4] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [5] *((const byte*) BGCOL2#0) ← (const byte) DARK_GREY#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [6] *((const byte*) BGCOL#0) ← *((const byte*) BGCOL2#0) [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((const byte*) BGCOL3#0) ← (const byte) BLACK#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [9] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [10] *((const byte*) D016#0) ← (const byte) VIC_MCM#0|(const byte) VIC_CSEL#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [21] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) fill::size#2 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::fill:11 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::fill:13 [ fill::addr#0 fill::val#3 fill::end#0 ] ) always clobbers reg byte a 
Statement [23] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#2 ] ) always clobbers reg byte a reg byte y 
Statement [25] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::ch#2 main::ch#1 ] : zp ZP_BYTE:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:3 [ fill::size#2 ] : zp ZP_WORD:3 , 
Potential registers zp ZP_BYTE:5 [ fill::val#3 ] : zp ZP_BYTE:5 , reg byte x , 
Potential registers zp ZP_WORD:6 [ fill::addr#2 fill::addr#0 fill::addr#1 ] : zp ZP_WORD:6 , 
Potential registers zp ZP_WORD:8 [ fill::end#0 ] : zp ZP_WORD:8 , 

REGISTER UPLIFT SCOPES
Uplift Scope [fill] 36: zp ZP_WORD:6 [ fill::addr#2 fill::addr#0 fill::addr#1 ] 2.6: zp ZP_WORD:8 [ fill::end#0 ] 2: zp ZP_WORD:3 [ fill::size#2 ] 1.83: zp ZP_BYTE:5 [ fill::val#3 ] 
Uplift Scope [main] 38.5: zp ZP_BYTE:2 [ main::ch#2 main::ch#1 ] 
Uplift Scope [] 

Uplifting [fill] best 3921 combination zp ZP_WORD:6 [ fill::addr#2 fill::addr#0 fill::addr#1 ] zp ZP_WORD:8 [ fill::end#0 ] zp ZP_WORD:3 [ fill::size#2 ] reg byte x [ fill::val#3 ] 
Uplifting [main] best 3801 combination reg byte x [ main::ch#2 main::ch#1 ] 
Uplifting [] best 3801 combination 
Coalescing zero page register with common assignment [ zp ZP_WORD:3 [ fill::size#2 ] ] with [ zp ZP_WORD:8 [ fill::end#0 ] ] - score: 1
Allocated (was zp ZP_WORD:3) zp ZP_WORD:2 [ fill::size#2 fill::end#0 ]
Allocated (was zp ZP_WORD:6) zp ZP_WORD:4 [ fill::addr#2 fill::addr#0 fill::addr#1 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label BORDERCOL = $d020
  .label BGCOL = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label D016 = $d016
  .const VIC_MCM = $10
  .const VIC_CSEL = 8
  .label D018 = $d018
  .label COLS = $d800
  .const BLACK = 0
  .const WHITE = 1
  .const DARK_GREY = $b
  .label SCREEN = $400
  .label LOGO = $2000
//SEG2 @begin
bbegin:
  jmp b5
//SEG3 @5
b5:
//SEG4 kickasm {{ .label pc_restore = *     .pc = $2000     logo:     .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))     .for (var y=0; y<6	; y++)         .for (var x=0;x<40; x++)             .for(var cp=0; cp<8; cp++)                 .byte logoPic.getMulticolorByte(x,cp+y*8)     .pc = pc_restore  }}
  .label pc_restore = *
    .pc = $2000
    logo:
    .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))
    .for (var y=0; y<6	; y++)
        .for (var x=0;x<40; x++)
            .for(var cp=0; cp<8; cp++)
                .byte logoPic.getMulticolorByte(x,cp+y*8)
    .pc = pc_restore

//SEG5 [2] call main  [ ] ( )
  jsr main
//SEG6 [3] phi from @5 to @end [phi:@5->@end]
bend_from_b5:
  jmp bend
//SEG7 @end
bend:
//SEG8 main
main: {
    .const toD0181_return = (>(SCREEN&$3fff)<<2)|(>LOGO)>>2&$f
  //SEG9 [4] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
  //SEG10 [5] *((const byte*) BGCOL2#0) ← (const byte) DARK_GREY#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #DARK_GREY
    sta BGCOL2
  //SEG11 [6] *((const byte*) BGCOL#0) ← *((const byte*) BGCOL2#0) [ ] ( main:2 [ ] ) -- _deref_pbuc1=_deref_pbuc2 
    lda BGCOL2
    sta BGCOL
  //SEG12 [7] *((const byte*) BGCOL3#0) ← (const byte) BLACK#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BGCOL3
  //SEG13 [8] phi from main to main::toD0181 [phi:main->main::toD0181]
  toD0181_from_main:
    jmp toD0181
  //SEG14 main::toD0181
  toD0181:
    jmp b9
  //SEG15 main::@9
  b9:
  //SEG16 [9] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG17 [10] *((const byte*) D016#0) ← (const byte) VIC_MCM#0|(const byte) VIC_CSEL#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #VIC_MCM|VIC_CSEL
    sta D016
  //SEG18 [11] call fill  [ ] ( main:2 [ ] )
  //SEG19 [20] phi from main::@9 to fill [phi:main::@9->fill]
  fill_from_b9:
  //SEG20 [20] phi (byte) fill::val#3 = (const byte) BLACK#0 [phi:main::@9->fill#0] -- vbuxx=vbuc1 
    ldx #BLACK
  //SEG21 [20] phi (word) fill::size#2 = (byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25 [phi:main::@9->fill#1] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta fill.size
    lda #>$28*$19
    sta fill.size+1
  //SEG22 [20] phi (byte*) fill::addr#0 = (const byte*) SCREEN#0 [phi:main::@9->fill#2] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta fill.addr
    lda #>SCREEN
    sta fill.addr+1
    jsr fill
  //SEG23 [12] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  b10_from_b9:
    jmp b10
  //SEG24 main::@10
  b10:
  //SEG25 [13] call fill  [ ] ( main:2 [ ] )
  //SEG26 [20] phi from main::@10 to fill [phi:main::@10->fill]
  fill_from_b10:
  //SEG27 [20] phi (byte) fill::val#3 = (const byte) WHITE#0|(byte/signed byte/word/signed word/dword/signed dword) 8 [phi:main::@10->fill#0] -- vbuxx=vbuc1 
    ldx #WHITE|8
  //SEG28 [20] phi (word) fill::size#2 = (byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25 [phi:main::@10->fill#1] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta fill.size
    lda #>$28*$19
    sta fill.size+1
  //SEG29 [20] phi (byte*) fill::addr#0 = (const byte*) COLS#0 [phi:main::@10->fill#2] -- pbuz1=pbuc1 
    lda #<COLS
    sta fill.addr
    lda #>COLS
    sta fill.addr+1
    jsr fill
  //SEG30 [14] phi from main::@10 to main::@1 [phi:main::@10->main::@1]
  b1_from_b10:
  //SEG31 [14] phi (byte) main::ch#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@10->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG32 [14] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
  //SEG33 [14] phi (byte) main::ch#2 = (byte) main::ch#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
  //SEG34 main::@1
  b1:
  //SEG35 [15] *((const byte*) SCREEN#0 + (byte) main::ch#2) ← (byte) main::ch#2 [ main::ch#2 ] ( main:2 [ main::ch#2 ] ) -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta SCREEN,x
  //SEG36 [16] (byte) main::ch#1 ← ++ (byte) main::ch#2 [ main::ch#1 ] ( main:2 [ main::ch#1 ] ) -- vbuxx=_inc_vbuxx 
    inx
  //SEG37 [17] if((byte) main::ch#1!=(byte/word/signed word/dword/signed dword) 240) goto main::@1 [ main::ch#1 ] ( main:2 [ main::ch#1 ] ) -- vbuxx_neq_vbuc1_then_la1 
    cpx #$f0
    bne b1_from_b1
    jmp b3
  //SEG38 main::@3
  b3:
  //SEG39 [18] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) 999) ← ++ *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) 999) [ ] ( main:2 [ ] ) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN+$3e7
  //SEG40 kickasm {{ inc $d020  }}
    inc $d020 
    jmp b3
}
//SEG41 fill
fill: {
    .label end = 2
    .label addr = 4
    .label size = 2
  //SEG42 [21] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) fill::size#2 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::fill:11 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::fill:13 [ fill::addr#0 fill::val#3 fill::end#0 ] ) -- pbuz1=pbuz2_plus_vwuz1 
    lda end
    clc
    adc addr
    sta end
    lda end+1
    adc addr+1
    sta end+1
  //SEG43 [22] phi from fill fill::@1 to fill::@1 [phi:fill/fill::@1->fill::@1]
  b1_from_fill:
  b1_from_b1:
  //SEG44 [22] phi (byte*) fill::addr#2 = (byte*) fill::addr#0 [phi:fill/fill::@1->fill::@1#0] -- register_copy 
    jmp b1
  //SEG45 fill::@1
  b1:
  //SEG46 [23] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#2 ] ) -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (addr),y
  //SEG47 [24] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] ) -- pbuz1=_inc_pbuz1 
    inc addr
    bne !+
    inc addr+1
  !:
  //SEG48 [25] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] ) -- pbuz1_neq_pbuz2_then_la1 
    lda addr+1
    cmp end+1
    bne b1_from_b1
    lda addr
    cmp end
    bne b1_from_b1
    jmp breturn
  //SEG49 fill::@return
  breturn:
  //SEG50 [26] return  [ ] ( main:2::fill:11 [ ] main:2::fill:13 [ ] )
    rts
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b5
Removing instruction jmp bend
Removing instruction jmp toD0181
Removing instruction jmp b9
Removing instruction jmp b10
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda BGCOL2
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b1_from_b1 with b1
Replacing label b1_from_b1 with b1
Replacing label b1_from_b1 with b1
Removing instruction bbegin:
Removing instruction bend_from_b5:
Removing instruction toD0181_from_main:
Removing instruction toD0181:
Removing instruction b10_from_b9:
Removing instruction fill_from_b10:
Removing instruction b1_from_b1:
Removing instruction b1_from_fill:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b5:
Removing instruction bend:
Removing instruction b9:
Removing instruction fill_from_b9:
Removing instruction b10:
Removing instruction b1_from_b10:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
(label) @5
(label) @begin
(label) @end
(byte*) BGCOL
(const byte*) BGCOL#0 BGCOL = ((byte*))(word/dword/signed dword) 53281
(byte*) BGCOL2
(const byte*) BGCOL2#0 BGCOL2 = ((byte*))(word/dword/signed dword) 53282
(byte*) BGCOL3
(const byte*) BGCOL3#0 BGCOL3 = ((byte*))(word/dword/signed dword) 53283
(byte) BLACK
(const byte) BLACK#0 BLACK = (byte/signed byte/word/signed word/dword/signed dword) 0
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = ((byte*))(word/dword/signed dword) 53280
(byte*) COLS
(const byte*) COLS#0 COLS = ((byte*))(word/dword/signed dword) 55296
(byte*) D016
(const byte*) D016#0 D016 = ((byte*))(word/dword/signed dword) 53270
(byte*) D018
(const byte*) D018#0 D018 = ((byte*))(word/dword/signed dword) 53272
(byte) DARK_GREY
(const byte) DARK_GREY#0 DARK_GREY = (byte/signed byte/word/signed word/dword/signed dword) 11
(byte*) LOGO
(const byte*) LOGO#0 LOGO = ((byte*))(word/signed word/dword/signed dword) 8192
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = ((byte*))(word/signed word/dword/signed dword) 1024
(byte) VIC_CSEL
(const byte) VIC_CSEL#0 VIC_CSEL = (byte/signed byte/word/signed word/dword/signed dword) 8
(byte) VIC_MCM
(const byte) VIC_MCM#0 VIC_MCM = (byte/signed byte/word/signed word/dword/signed dword) 16
(byte) WHITE
(const byte) WHITE#0 WHITE = (byte/signed byte/word/signed word/dword/signed dword) 1
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(label) fill::@1
(label) fill::@return
(byte*) fill::addr
(byte*) fill::addr#0 addr zp ZP_WORD:4 2.0
(byte*) fill::addr#1 addr zp ZP_WORD:4 16.5
(byte*) fill::addr#2 addr zp ZP_WORD:4 17.5
(byte*) fill::end
(byte*) fill::end#0 end zp ZP_WORD:2 2.6
(word) fill::size
(word) fill::size#2 size zp ZP_WORD:2 2.0
(byte*) fill::start
(byte) fill::val
(byte) fill::val#3 reg byte x 1.8333333333333333
(void()) main()
(label) main::@1
(label) main::@10
(label) main::@3
(label) main::@9
(byte) main::ch
(byte) main::ch#1 reg byte x 16.5
(byte) main::ch#2 reg byte x 22.0
(label) main::toD0181
(word~) main::toD0181_$0
(word~) main::toD0181_$1
(word~) main::toD0181_$2
(byte~) main::toD0181_$3
(word~) main::toD0181_$4
(byte~) main::toD0181_$5
(byte~) main::toD0181_$6
(byte~) main::toD0181_$7
(byte~) main::toD0181_$8
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(const byte) main::toD0181_return#0 toD0181_return = >((word))(const byte*) SCREEN#0&(word/signed word/dword/signed dword) 16383<<(byte/signed byte/word/signed word/dword/signed dword) 2|>((word))(const byte*) LOGO#0>>(byte/signed byte/word/signed word/dword/signed dword) 2&(byte/signed byte/word/signed word/dword/signed dword) 15
(byte*) main::toD0181_screen

reg byte x [ main::ch#2 main::ch#1 ]
zp ZP_WORD:2 [ fill::size#2 fill::end#0 ]
reg byte x [ fill::val#3 ]
zp ZP_WORD:4 [ fill::addr#2 fill::addr#0 fill::addr#1 ]


FINAL ASSEMBLER
Score: 3578

//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label BORDERCOL = $d020
  .label BGCOL = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label D016 = $d016
  .const VIC_MCM = $10
  .const VIC_CSEL = 8
  .label D018 = $d018
  .label COLS = $d800
  .const BLACK = 0
  .const WHITE = 1
  .const DARK_GREY = $b
  .label SCREEN = $400
  .label LOGO = $2000
//SEG2 @begin
//SEG3 @5
//SEG4 kickasm {{ .label pc_restore = *     .pc = $2000     logo:     .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))     .for (var y=0; y<6	; y++)         .for (var x=0;x<40; x++)             .for(var cp=0; cp<8; cp++)                 .byte logoPic.getMulticolorByte(x,cp+y*8)     .pc = pc_restore  }}
  .label pc_restore = *
    .pc = $2000
    logo:
    .var logoPic = LoadPicture("logo.png", List().add($444444, $808080, $000000, $ffffff))
    .for (var y=0; y<6	; y++)
        .for (var x=0;x<40; x++)
            .for(var cp=0; cp<8; cp++)
                .byte logoPic.getMulticolorByte(x,cp+y*8)
    .pc = pc_restore

//SEG5 [2] call main  [ ] ( )
  jsr main
//SEG6 [3] phi from @5 to @end [phi:@5->@end]
//SEG7 @end
//SEG8 main
main: {
    .const toD0181_return = (>(SCREEN&$3fff)<<2)|(>LOGO)>>2&$f
  //SEG9 [4] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
  //SEG10 [5] *((const byte*) BGCOL2#0) ← (const byte) DARK_GREY#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #DARK_GREY
    sta BGCOL2
  //SEG11 [6] *((const byte*) BGCOL#0) ← *((const byte*) BGCOL2#0) [ ] ( main:2 [ ] ) -- _deref_pbuc1=_deref_pbuc2 
    sta BGCOL
  //SEG12 [7] *((const byte*) BGCOL3#0) ← (const byte) BLACK#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BGCOL3
  //SEG13 [8] phi from main to main::toD0181 [phi:main->main::toD0181]
  //SEG14 main::toD0181
  //SEG15 main::@9
  //SEG16 [9] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG17 [10] *((const byte*) D016#0) ← (const byte) VIC_MCM#0|(const byte) VIC_CSEL#0 [ ] ( main:2 [ ] ) -- _deref_pbuc1=vbuc2 
    lda #VIC_MCM|VIC_CSEL
    sta D016
  //SEG18 [11] call fill  [ ] ( main:2 [ ] )
  //SEG19 [20] phi from main::@9 to fill [phi:main::@9->fill]
  //SEG20 [20] phi (byte) fill::val#3 = (const byte) BLACK#0 [phi:main::@9->fill#0] -- vbuxx=vbuc1 
    ldx #BLACK
  //SEG21 [20] phi (word) fill::size#2 = (byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25 [phi:main::@9->fill#1] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta fill.size
    lda #>$28*$19
    sta fill.size+1
  //SEG22 [20] phi (byte*) fill::addr#0 = (const byte*) SCREEN#0 [phi:main::@9->fill#2] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta fill.addr
    lda #>SCREEN
    sta fill.addr+1
    jsr fill
  //SEG23 [12] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  //SEG24 main::@10
  //SEG25 [13] call fill  [ ] ( main:2 [ ] )
  //SEG26 [20] phi from main::@10 to fill [phi:main::@10->fill]
  //SEG27 [20] phi (byte) fill::val#3 = (const byte) WHITE#0|(byte/signed byte/word/signed word/dword/signed dword) 8 [phi:main::@10->fill#0] -- vbuxx=vbuc1 
    ldx #WHITE|8
  //SEG28 [20] phi (word) fill::size#2 = (byte/signed byte/word/signed word/dword/signed dword) 40*(byte/signed byte/word/signed word/dword/signed dword) 25 [phi:main::@10->fill#1] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta fill.size
    lda #>$28*$19
    sta fill.size+1
  //SEG29 [20] phi (byte*) fill::addr#0 = (const byte*) COLS#0 [phi:main::@10->fill#2] -- pbuz1=pbuc1 
    lda #<COLS
    sta fill.addr
    lda #>COLS
    sta fill.addr+1
    jsr fill
  //SEG30 [14] phi from main::@10 to main::@1 [phi:main::@10->main::@1]
  //SEG31 [14] phi (byte) main::ch#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@10->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG32 [14] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  //SEG33 [14] phi (byte) main::ch#2 = (byte) main::ch#1 [phi:main::@1->main::@1#0] -- register_copy 
  //SEG34 main::@1
  b1:
  //SEG35 [15] *((const byte*) SCREEN#0 + (byte) main::ch#2) ← (byte) main::ch#2 [ main::ch#2 ] ( main:2 [ main::ch#2 ] ) -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta SCREEN,x
  //SEG36 [16] (byte) main::ch#1 ← ++ (byte) main::ch#2 [ main::ch#1 ] ( main:2 [ main::ch#1 ] ) -- vbuxx=_inc_vbuxx 
    inx
  //SEG37 [17] if((byte) main::ch#1!=(byte/word/signed word/dword/signed dword) 240) goto main::@1 [ main::ch#1 ] ( main:2 [ main::ch#1 ] ) -- vbuxx_neq_vbuc1_then_la1 
    cpx #$f0
    bne b1
  //SEG38 main::@3
  b3:
  //SEG39 [18] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) 999) ← ++ *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) 999) [ ] ( main:2 [ ] ) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN+$3e7
  //SEG40 kickasm {{ inc $d020  }}
    inc $d020 
    jmp b3
}
//SEG41 fill
fill: {
    .label end = 2
    .label addr = 4
    .label size = 2
  //SEG42 [21] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) fill::size#2 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::fill:11 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::fill:13 [ fill::addr#0 fill::val#3 fill::end#0 ] ) -- pbuz1=pbuz2_plus_vwuz1 
    lda end
    clc
    adc addr
    sta end
    lda end+1
    adc addr+1
    sta end+1
  //SEG43 [22] phi from fill fill::@1 to fill::@1 [phi:fill/fill::@1->fill::@1]
  //SEG44 [22] phi (byte*) fill::addr#2 = (byte*) fill::addr#0 [phi:fill/fill::@1->fill::@1#0] -- register_copy 
  //SEG45 fill::@1
  b1:
  //SEG46 [23] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#2 ] ) -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (addr),y
  //SEG47 [24] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] ) -- pbuz1=_inc_pbuz1 
    inc addr
    bne !+
    inc addr+1
  !:
  //SEG48 [25] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::fill:11 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::fill:13 [ fill::val#3 fill::end#0 fill::addr#1 ] ) -- pbuz1_neq_pbuz2_then_la1 
    lda addr+1
    cmp end+1
    bne b1
    lda addr
    cmp end
    bne b1
  //SEG49 fill::@return
  //SEG50 [26] return  [ ] ( main:2::fill:11 [ ] main:2::fill:13 [ ] )
    rts
}

