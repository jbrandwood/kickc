Inlined call call __init 

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  i#31 = phi( __start::@1/i#32 )
  out::c#0 = main::reg_zp_flex
  call out 
  to:main::@1
main::@1: scope:[main]  from main
  i#16 = phi( main/i#12 )
  i#0 = i#16
  out::c#1 = main::reg_zp_abs
  call out 
  to:main::@2
main::@2: scope:[main]  from main::@1
  i#17 = phi( main::@1/i#12 )
  i#1 = i#17
  out::c#2 = main::reg_mem_flex
  call out 
  to:main::@3
main::@3: scope:[main]  from main::@2
  i#18 = phi( main::@2/i#12 )
  i#2 = i#18
  out::c#3 = main::reg_mem_abs
  call out 
  to:main::@4
main::@4: scope:[main]  from main::@3
  i#19 = phi( main::@3/i#12 )
  i#3 = i#19
  out::c#4 = main::default_default
  call out 
  to:main::@5
main::@5: scope:[main]  from main::@4
  i#20 = phi( main::@4/i#12 )
  i#4 = i#20
  out::c#5 = main::reg_default
  call out 
  to:main::@6
main::@6: scope:[main]  from main::@5
  i#21 = phi( main::@5/i#12 )
  i#5 = i#21
  out::c#6 = main::default_zp_flex
  call out 
  to:main::@7
main::@7: scope:[main]  from main::@6
  i#22 = phi( main::@6/i#12 )
  i#6 = i#22
  out::c#7 = main::default_zp_abs
  call out 
  to:main::@8
main::@8: scope:[main]  from main::@7
  i#23 = phi( main::@7/i#12 )
  i#7 = i#23
  out::c#8 = main::default_mem_flex
  call out 
  to:main::@9
main::@9: scope:[main]  from main::@8
  i#24 = phi( main::@8/i#12 )
  i#8 = i#24
  out::c#9 = main::default_mem_abs
  call out 
  to:main::@10
main::@10: scope:[main]  from main::@9
  i#25 = phi( main::@9/i#12 )
  i#9 = i#25
  to:main::@return
main::@return: scope:[main]  from main::@10
  i#26 = phi( main::@10/i#9 )
  i#10 = i#26
  return 
  to:@return

void out(byte out::c)
out: scope:[out]  from main main::@1 main::@2 main::@3 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  i#27 = phi( main/i#31, main::@1/i#0, main::@2/i#1, main::@3/i#2, main::@4/i#3, main::@5/i#4, main::@6/i#5, main::@7/i#6, main::@8/i#7, main::@9/i#8 )
  out::c#10 = phi( main/out::c#0, main::@1/out::c#1, main::@2/out::c#2, main::@3/out::c#3, main::@4/out::c#4, main::@5/out::c#5, main::@6/out::c#6, main::@7/out::c#7, main::@8/out::c#8, main::@9/out::c#9 )
  SCREEN[i#27] = out::c#10
  i#11 = ++ i#27
  to:out::@return
out::@return: scope:[out]  from out
  i#28 = phi( out/i#11 )
  i#12 = i#28
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  i#13 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  i#32 = phi( __start::__init1/i#13 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  i#29 = phi( __start::@1/i#10 )
  i#14 = i#29
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  i#30 = phi( __start::@2/i#14 )
  i#15 = i#30
  return 
  to:@return

SYMBOL TABLE SSA
const nomodify byte* SCREEN = (byte*)$400
void __start()
byte i
byte i#0
byte i#1
byte i#10
byte i#11
byte i#12
byte i#13
byte i#14
byte i#15
byte i#16
byte i#17
byte i#18
byte i#19
byte i#2
byte i#20
byte i#21
byte i#22
byte i#23
byte i#24
byte i#25
byte i#26
byte i#27
byte i#28
byte i#29
byte i#3
byte i#30
byte i#31
byte i#32
byte i#4
byte i#5
byte i#6
byte i#7
byte i#8
byte i#9
void main()
const byte main::default_default = '.'
const byte main::default_mem_abs !mem[-1]:4096 = '.'
const byte main::default_mem_flex = '.'
const byte main::default_zp_abs !zp[-1]:16 = '.'
const byte main::default_zp_flex = '.'
const byte main::reg_default = '.'
const byte main::reg_mem_abs !mem[-1]:4096 = '.'
const byte main::reg_mem_flex = '.'
const byte main::reg_zp_abs !zp[-1]:16 = '.'
const byte main::reg_zp_flex = '.'
void out(byte out::c)
byte out::c
byte out::c#0
byte out::c#1
byte out::c#10
byte out::c#2
byte out::c#3
byte out::c#4
byte out::c#5
byte out::c#6
byte out::c#7
byte out::c#8
byte out::c#9

Simplifying constant pointer cast (byte*) 1024
Successful SSA optimization PassNCastSimplification
Alias i#0 = i#16 
Alias i#1 = i#17 
Alias i#18 = i#2 
Alias i#19 = i#3 
Alias i#20 = i#4 
Alias i#21 = i#5 
Alias i#22 = i#6 
Alias i#23 = i#7 
Alias i#24 = i#8 
Alias i#10 = i#9 i#25 i#26 
Alias i#11 = i#28 i#12 
Alias i#13 = i#32 
Alias i#14 = i#29 i#30 i#15 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values i#31 i#13
Identical Phi Values i#0 i#11
Identical Phi Values i#1 i#11
Identical Phi Values i#18 i#11
Identical Phi Values i#19 i#11
Identical Phi Values i#20 i#11
Identical Phi Values i#21 i#11
Identical Phi Values i#22 i#11
Identical Phi Values i#23 i#11
Identical Phi Values i#24 i#11
Identical Phi Values i#10 i#11
Identical Phi Values i#14 i#10
Successful SSA optimization Pass2IdenticalPhiElimination
Constant out::c#0 = main::reg_zp_flex
Constant out::c#1 = main::reg_zp_abs
Constant out::c#2 = main::reg_mem_flex
Constant out::c#3 = main::reg_mem_abs
Constant out::c#4 = main::default_default
Constant out::c#5 = main::reg_default
Constant out::c#6 = main::default_zp_flex
Constant out::c#7 = main::default_zp_abs
Constant out::c#8 = main::default_mem_flex
Constant out::c#9 = main::default_mem_abs
Constant i#13 = 0
Successful SSA optimization Pass2ConstantIdentification
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings out::c#0
Inlining constant with var siblings out::c#1
Inlining constant with var siblings out::c#2
Inlining constant with var siblings out::c#3
Inlining constant with var siblings out::c#4
Inlining constant with var siblings out::c#5
Inlining constant with var siblings out::c#6
Inlining constant with var siblings out::c#7
Inlining constant with var siblings out::c#8
Inlining constant with var siblings out::c#9
Inlining constant with var siblings i#13
Constant inlined out::c#8 = main::default_mem_flex
Constant inlined out::c#9 = main::default_mem_abs
Constant inlined out::c#6 = main::default_zp_flex
Constant inlined out::c#7 = main::default_zp_abs
Constant inlined out::c#0 = main::reg_zp_flex
Constant inlined out::c#1 = main::reg_zp_abs
Constant inlined out::c#4 = main::default_default
Constant inlined i#13 = 0
Constant inlined out::c#5 = main::reg_default
Constant inlined out::c#2 = main::reg_mem_flex
Constant inlined out::c#3 = main::reg_mem_abs
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@10
CALL GRAPH
Calls in [main] to out:1 out:3 out:5 out:7 out:9 out:11 out:13 out:15 out:17 out:19 

Created 2 initial phi equivalence classes
Coalesced [2] i#33 = i#11
Coalesced (already) [4] i#34 = i#11
Coalesced (already) [6] i#35 = i#11
Coalesced (already) [8] i#36 = i#11
Coalesced (already) [10] i#37 = i#11
Coalesced (already) [12] i#38 = i#11
Coalesced (already) [14] i#39 = i#11
Coalesced (already) [16] i#40 = i#11
Coalesced (already) [18] i#41 = i#11
Coalesced down to 2 phi equivalence classes
Culled Empty Block label main::@10
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@9

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call out 
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call out 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] phi()
  [5] call out 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [6] phi()
  [7] call out 
  to:main::@4
main::@4: scope:[main]  from main::@3
  [8] phi()
  [9] call out 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [10] phi()
  [11] call out 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [12] phi()
  [13] call out 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [14] phi()
  [15] call out 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [16] phi()
  [17] call out 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [18] phi()
  [19] call out 
  to:main::@return
main::@return: scope:[main]  from main::@9
  [20] return 
  to:@return

void out(byte out::c)
out: scope:[out]  from main main::@1 main::@2 main::@3 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  [21] i#27 = phi( main/0, main::@1/i#11, main::@2/i#11, main::@3/i#11, main::@4/i#11, main::@5/i#11, main::@6/i#11, main::@7/i#11, main::@8/i#11, main::@9/i#11 )
  [21] out::c#10 = phi( main/main::reg_zp_flex, main::@1/main::reg_zp_abs, main::@2/main::reg_mem_flex, main::@3/main::reg_mem_abs, main::@4/main::default_default, main::@5/main::reg_default, main::@6/main::default_zp_flex, main::@7/main::default_zp_abs, main::@8/main::default_mem_flex, main::@9/main::default_mem_abs )
  [22] SCREEN[i#27] = out::c#10
  [23] i#11 = ++ i#27
  to:out::@return
out::@return: scope:[out]  from out
  [24] return 
  to:@return


VARIABLE REGISTER WEIGHTS
byte i
byte i#11 1.45
byte i#27 20.0
void main()
void out(byte out::c)
byte out::c
byte out::c#10 11.0

Initial phi equivalence classes
[ out::c#10 ]
[ i#27 i#11 ]
Complete equivalence classes
[ out::c#10 ]
[ i#27 i#11 ]
Allocated zp[1]:2 [ out::c#10 ]
Allocated zp[1]:3 [ i#27 i#11 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp[1]:2 [ out::c#10 ] : zp[1]:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ i#27 i#11 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 21.45: zp[1]:3 [ i#27 i#11 ] 
Uplift Scope [out] 11: zp[1]:2 [ out::c#10 ] 
Uplift Scope [main] 

Uplifting [] best 167 combination reg byte x [ i#27 i#11 ] 
Uplifting [out] best 134 combination reg byte a [ out::c#10 ] 
Uplifting [main] best 134 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test declaring a variable as "memory", meaning it will be stored in memory and accessed through an implicit pointer (using load/store)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // main
main: {
    .const reg_zp_flex = '.'
    .const reg_zp_abs = '.'
    .const reg_mem_flex = '.'
    .const reg_mem_abs = '.'
    .const default_default = '.'
    .const reg_default = '.'
    .const default_zp_flex = '.'
    .const default_zp_abs = '.'
    .const default_mem_flex = '.'
    .const default_mem_abs = '.'
    // [1] call out 
    // [21] phi from main to out [phi:main->out]
  out_from_main:
    // [21] phi i#27 = 0 [phi:main->out#0] -- vbuxx=vbuc1 
    ldx #0
    // [21] phi out::c#10 = main::reg_zp_flex [phi:main->out#1] -- vbuaa=vbuc1 
    lda #reg_zp_flex
    jsr out
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call out 
    // [21] phi from main::@1 to out [phi:main::@1->out]
  out_from___b1:
    // [21] phi i#27 = i#11 [phi:main::@1->out#0] -- register_copy 
    // [21] phi out::c#10 = main::reg_zp_abs [phi:main::@1->out#1] -- vbuaa=vbuc1 
    lda #reg_zp_abs
    jsr out
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [5] call out 
    // [21] phi from main::@2 to out [phi:main::@2->out]
  out_from___b2:
    // [21] phi i#27 = i#11 [phi:main::@2->out#0] -- register_copy 
    // [21] phi out::c#10 = main::reg_mem_flex [phi:main::@2->out#1] -- vbuaa=vbuc1 
    lda #reg_mem_flex
    jsr out
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [7] call out 
    // [21] phi from main::@3 to out [phi:main::@3->out]
  out_from___b3:
    // [21] phi i#27 = i#11 [phi:main::@3->out#0] -- register_copy 
    // [21] phi out::c#10 = main::reg_mem_abs [phi:main::@3->out#1] -- vbuaa=vbuc1 
    lda #reg_mem_abs
    jsr out
    // [8] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  __b4_from___b3:
    jmp __b4
    // main::@4
  __b4:
    // [9] call out 
    // [21] phi from main::@4 to out [phi:main::@4->out]
  out_from___b4:
    // [21] phi i#27 = i#11 [phi:main::@4->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_default [phi:main::@4->out#1] -- vbuaa=vbuc1 
    lda #default_default
    jsr out
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    jmp __b5
    // main::@5
  __b5:
    // [11] call out 
    // [21] phi from main::@5 to out [phi:main::@5->out]
  out_from___b5:
    // [21] phi i#27 = i#11 [phi:main::@5->out#0] -- register_copy 
    // [21] phi out::c#10 = main::reg_default [phi:main::@5->out#1] -- vbuaa=vbuc1 
    lda #reg_default
    jsr out
    // [12] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    jmp __b6
    // main::@6
  __b6:
    // [13] call out 
    // [21] phi from main::@6 to out [phi:main::@6->out]
  out_from___b6:
    // [21] phi i#27 = i#11 [phi:main::@6->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_zp_flex [phi:main::@6->out#1] -- vbuaa=vbuc1 
    lda #default_zp_flex
    jsr out
    // [14] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  __b7_from___b6:
    jmp __b7
    // main::@7
  __b7:
    // [15] call out 
    // [21] phi from main::@7 to out [phi:main::@7->out]
  out_from___b7:
    // [21] phi i#27 = i#11 [phi:main::@7->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_zp_abs [phi:main::@7->out#1] -- vbuaa=vbuc1 
    lda #default_zp_abs
    jsr out
    // [16] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  __b8_from___b7:
    jmp __b8
    // main::@8
  __b8:
    // [17] call out 
    // [21] phi from main::@8 to out [phi:main::@8->out]
  out_from___b8:
    // [21] phi i#27 = i#11 [phi:main::@8->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_mem_flex [phi:main::@8->out#1] -- vbuaa=vbuc1 
    lda #default_mem_flex
    jsr out
    // [18] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
  __b9_from___b8:
    jmp __b9
    // main::@9
  __b9:
    // [19] call out 
    // [21] phi from main::@9 to out [phi:main::@9->out]
  out_from___b9:
    // [21] phi i#27 = i#11 [phi:main::@9->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_mem_abs [phi:main::@9->out#1] -- vbuaa=vbuc1 
    lda #default_mem_abs
    jsr out
    jmp __breturn
    // main::@return
  __breturn:
    // [20] return 
    rts
}
  // out
// out(byte register(A) c)
out: {
    // [22] SCREEN[i#27] = out::c#10 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    // [23] i#11 = ++ i#27 -- vbuxx=_inc_vbuxx 
    inx
    jmp __breturn
    // out::@return
  __breturn:
    // [24] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b1_from_main:
Removing instruction out_from___b1:
Removing instruction __b2_from___b1:
Removing instruction out_from___b2:
Removing instruction __b3_from___b2:
Removing instruction out_from___b3:
Removing instruction __b4_from___b3:
Removing instruction out_from___b4:
Removing instruction __b5_from___b4:
Removing instruction out_from___b5:
Removing instruction __b6_from___b5:
Removing instruction out_from___b6:
Removing instruction __b7_from___b6:
Removing instruction out_from___b7:
Removing instruction __b8_from___b7:
Removing instruction out_from___b8:
Removing instruction __b9_from___b8:
Removing instruction out_from___b9:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction out_from_main:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
const nomodify byte* SCREEN = (byte*) 1024
byte i
byte i#11 reg byte x 1.45
byte i#27 reg byte x 20.0
void main()
const byte main::default_default = '.'
const byte main::default_mem_abs !mem[-1]:4096 = '.'
const byte main::default_mem_flex = '.'
const byte main::default_zp_abs !zp[-1]:16 = '.'
const byte main::default_zp_flex = '.'
const byte main::reg_default = '.'
const byte main::reg_mem_abs !mem[-1]:4096 = '.'
const byte main::reg_mem_flex = '.'
const byte main::reg_zp_abs !zp[-1]:16 = '.'
const byte main::reg_zp_flex = '.'
void out(byte out::c)
byte out::c
byte out::c#10 reg byte a 11.0

reg byte a [ out::c#10 ]
reg byte x [ i#27 i#11 ]


FINAL ASSEMBLER
Score: 101

  // File Comments
// Test declaring a variable as "memory", meaning it will be stored in memory and accessed through an implicit pointer (using load/store)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // main
main: {
    .const reg_zp_flex = '.'
    .const reg_zp_abs = '.'
    .const reg_mem_flex = '.'
    .const reg_mem_abs = '.'
    .const default_default = '.'
    .const reg_default = '.'
    .const default_zp_flex = '.'
    .const default_zp_abs = '.'
    .const default_mem_flex = '.'
    .const default_mem_abs = '.'
    // out(reg_zp_flex)
    // [1] call out 
    // [21] phi from main to out [phi:main->out]
    // [21] phi i#27 = 0 [phi:main->out#0] -- vbuxx=vbuc1 
    ldx #0
    // [21] phi out::c#10 = main::reg_zp_flex [phi:main->out#1] -- vbuaa=vbuc1 
    lda #reg_zp_flex
    jsr out
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // out(reg_zp_abs)
    // [3] call out 
    // [21] phi from main::@1 to out [phi:main::@1->out]
    // [21] phi i#27 = i#11 [phi:main::@1->out#0] -- register_copy 
    // [21] phi out::c#10 = main::reg_zp_abs [phi:main::@1->out#1] -- vbuaa=vbuc1 
    lda #reg_zp_abs
    jsr out
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // out(reg_mem_flex)
    // [5] call out 
    // [21] phi from main::@2 to out [phi:main::@2->out]
    // [21] phi i#27 = i#11 [phi:main::@2->out#0] -- register_copy 
    // [21] phi out::c#10 = main::reg_mem_flex [phi:main::@2->out#1] -- vbuaa=vbuc1 
    lda #reg_mem_flex
    jsr out
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // main::@3
    // out(reg_mem_abs)
    // [7] call out 
    // [21] phi from main::@3 to out [phi:main::@3->out]
    // [21] phi i#27 = i#11 [phi:main::@3->out#0] -- register_copy 
    // [21] phi out::c#10 = main::reg_mem_abs [phi:main::@3->out#1] -- vbuaa=vbuc1 
    lda #reg_mem_abs
    jsr out
    // [8] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
    // main::@4
    // out(default_default)
    // [9] call out 
    // [21] phi from main::@4 to out [phi:main::@4->out]
    // [21] phi i#27 = i#11 [phi:main::@4->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_default [phi:main::@4->out#1] -- vbuaa=vbuc1 
    lda #default_default
    jsr out
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
    // main::@5
    // out(reg_default)
    // [11] call out 
    // [21] phi from main::@5 to out [phi:main::@5->out]
    // [21] phi i#27 = i#11 [phi:main::@5->out#0] -- register_copy 
    // [21] phi out::c#10 = main::reg_default [phi:main::@5->out#1] -- vbuaa=vbuc1 
    lda #reg_default
    jsr out
    // [12] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // main::@6
    // out(default_zp_flex)
    // [13] call out 
    // [21] phi from main::@6 to out [phi:main::@6->out]
    // [21] phi i#27 = i#11 [phi:main::@6->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_zp_flex [phi:main::@6->out#1] -- vbuaa=vbuc1 
    lda #default_zp_flex
    jsr out
    // [14] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
    // main::@7
    // out(default_zp_abs)
    // [15] call out 
    // [21] phi from main::@7 to out [phi:main::@7->out]
    // [21] phi i#27 = i#11 [phi:main::@7->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_zp_abs [phi:main::@7->out#1] -- vbuaa=vbuc1 
    lda #default_zp_abs
    jsr out
    // [16] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
    // main::@8
    // out(default_mem_flex)
    // [17] call out 
    // [21] phi from main::@8 to out [phi:main::@8->out]
    // [21] phi i#27 = i#11 [phi:main::@8->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_mem_flex [phi:main::@8->out#1] -- vbuaa=vbuc1 
    lda #default_mem_flex
    jsr out
    // [18] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
    // main::@9
    // out(default_mem_abs)
    // [19] call out 
    // [21] phi from main::@9 to out [phi:main::@9->out]
    // [21] phi i#27 = i#11 [phi:main::@9->out#0] -- register_copy 
    // [21] phi out::c#10 = main::default_mem_abs [phi:main::@9->out#1] -- vbuaa=vbuc1 
    lda #default_mem_abs
    jsr out
    // main::@return
    // }
    // [20] return 
    rts
}
  // out
// out(byte register(A) c)
out: {
    // SCREEN[i++] = c
    // [22] SCREEN[i#27] = out::c#10 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    // SCREEN[i++] = c;
    // [23] i#11 = ++ i#27 -- vbuxx=_inc_vbuxx 
    inx
    // out::@return
    // }
    // [24] return 
    rts
}
  // File Data

