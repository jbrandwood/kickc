Resolved forward reference min to byte min(byte min::a , byte min::b)
Resolved forward reference max to byte max(byte max::a , byte max::b)
Resolved forward reference xor to byte xor(byte xor::a , byte xor::b)
Setting inferred __stackcall on procedure affected by address-of __stackcall byte sum(byte sum::a , byte sum::b) caused by statement main::$1 = call exec &sum 
Setting inferred __stackcall on procedure affected by address-of __stackcall byte min(byte min::a , byte min::b) caused by statement main::$3 = call exec &min 
Setting inferred __stackcall on procedure affected by address-of __stackcall byte max(byte max::a , byte max::b) caused by statement main::$5 = call exec &max 
Setting inferred __stackcall on procedure affected by address-of __stackcall byte xor(byte xor::a , byte xor::b) caused by statement main::$7 = call exec &xor 
Adding parameter assignment in __stackcall procedure sum::b = param(sum::b)
Adding parameter assignment in __stackcall procedure sum::a = param(sum::a)
Adding parameter assignment in __stackcall procedure max::b = param(max::b)
Adding parameter assignment in __stackcall procedure max::a = param(max::a)
Adding parameter assignment in __stackcall procedure min::b = param(min::b)
Adding parameter assignment in __stackcall procedure min::a = param(min::a)
Adding parameter assignment in __stackcall procedure xor::b = param(xor::b)
Adding parameter assignment in __stackcall procedure xor::a = param(xor::a)
Inlined call call __init 
Calling convention STACK_CALL adding prepare/execute/finalize for exec::$5 = call *exec::collect exec::out INPUT[exec::i] 
Calling convention STACK_CALL replacing param(sum::a) with stackidx(byte,sum::OFFSET_STACK_A)
Calling convention STACK_CALL replacing param(sum::b) with stackidx(byte,sum::OFFSET_STACK_B)
Calling convention STACK_CALL replacing param(max::a) with stackidx(byte,max::OFFSET_STACK_A)
Calling convention STACK_CALL replacing param(max::b) with stackidx(byte,max::OFFSET_STACK_B)
Calling convention STACK_CALL replacing param(min::a) with stackidx(byte,min::OFFSET_STACK_A)
Calling convention STACK_CALL replacing param(min::b) with stackidx(byte,min::OFFSET_STACK_B)
Calling convention STACK_CALL replacing param(xor::a) with stackidx(byte,xor::OFFSET_STACK_A)
Calling convention STACK_CALL replacing param(xor::b) with stackidx(byte,xor::OFFSET_STACK_B)
Calling convention STACK_CALL adding stack return stackidx(byte,sum::OFFSET_STACK_RETURN_1) = sum::return
Calling convention STACK_CALL adding stack return stackidx(byte,max::OFFSET_STACK_RETURN_1) = max::return
Calling convention STACK_CALL adding stack return stackidx(byte,min::OFFSET_STACK_RETURN_1) = min::return
Calling convention STACK_CALL adding stack return stackidx(byte,xor::OFFSET_STACK_RETURN_1) = xor::return
Calling convention STACK_CALL adding stack pull exec::$5 = stackpull(byte)
Calling convention STACK_CALL adding stack push stackpush(byte) = exec::out
Calling convention STACK_CALL adding stack push stackpush(byte) = INPUT[exec::i]

CONTROL FLOW GRAPH SSA

__stackcall byte sum(byte sum::a , byte sum::b)
sum: scope:[sum]  from
  sum::a#0 = stackidx(byte,sum::OFFSET_STACK_A)
  sum::b#0 = stackidx(byte,sum::OFFSET_STACK_B)
  sum::$0 = sum::a#0 + sum::b#0
  sum::return#0 = sum::$0
  to:sum::@return
sum::@return: scope:[sum]  from sum
  sum::return#2 = phi( sum/sum::return#0 )
  sum::return#1 = sum::return#2
  stackidx(byte,sum::OFFSET_STACK_RETURN_1) = sum::return#1
  return 
  to:@return

void cout(byte cout::c)
cout: scope:[cout]  from exec exec::@4 exec::@5 exec::@7 main::@4 print print::@1
  idx#27 = phi( exec/idx#52, exec::@4/idx#18, exec::@5/idx#19, exec::@7/idx#21, main::@4/idx#7, print/idx#53, print::@1/idx#4 )
  cout::c#7 = phi( exec/cout::c#3, exec::@4/cout::c#4, exec::@5/cout::c#5, exec::@7/cout::c#6, main::@4/cout::c#2, print/cout::c#0, print::@1/cout::c#1 )
  line[idx#27] = cout::c#7
  idx#0 = ++ idx#27
  to:cout::@return
cout::@return: scope:[cout]  from cout
  idx#28 = phi( cout/idx#0 )
  idx#1 = idx#28
  return 
  to:@return

void ln()
ln: scope:[ln]  from main::@11 main::@3 main::@7 main::@9
  line = line + $28
  idx#2 = 0
  to:ln::@return
ln::@return: scope:[ln]  from ln
  idx#29 = phi( ln/idx#2 )
  idx#3 = idx#29
  return 
  to:@return

void print(byte print::i)
print: scope:[print]  from exec::@3 main::@2
  idx#53 = phi( exec::@3/idx#56, main::@2/idx#54 )
  print::i#2 = phi( exec::@3/print::i#1, main::@2/print::i#0 )
  print::$0 = print::i#2 >> 4
  cout::c#0 = HEX[print::$0]
  call cout 
  to:print::@1
print::@1: scope:[print]  from print
  print::i#3 = phi( print/print::i#2 )
  idx#30 = phi( print/idx#1 )
  idx#4 = idx#30
  print::$2 = print::i#3 & $f
  cout::c#1 = HEX[print::$2]
  call cout 
  to:print::@2
print::@2: scope:[print]  from print::@1
  idx#31 = phi( print::@1/idx#1 )
  idx#5 = idx#31
  to:print::@return
print::@return: scope:[print]  from print::@2
  idx#32 = phi( print::@2/idx#5 )
  idx#6 = idx#32
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  idx#61 = phi( __start::@1/idx#58 )
  main::i#0 = 0
  to:main::@1
main::@1: scope:[main]  from main main::@5
  idx#59 = phi( main/idx#61, main::@5/idx#8 )
  main::i#2 = phi( main/main::i#0, main::@5/main::i#1 )
  main::$8 = sizeof  INPUT
  main::$9 = main::i#2 < main::$8
  if(main::$9) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  idx#54 = phi( main::@1/idx#59 )
  main::i#3 = phi( main::@1/main::i#2 )
  print::i#0 = INPUT[main::i#3]
  call print 
  to:main::@4
main::@4: scope:[main]  from main::@2
  main::i#5 = phi( main::@2/main::i#3 )
  idx#33 = phi( main::@2/idx#6 )
  idx#7 = idx#33
  cout::c#2 = ' '
  call cout 
  to:main::@5
main::@5: scope:[main]  from main::@4
  main::i#4 = phi( main::@4/main::i#5 )
  idx#34 = phi( main::@4/idx#1 )
  idx#8 = idx#34
  main::i#1 = ++ main::i#4
  to:main::@1
main::@3: scope:[main]  from main::@1
  idx#55 = phi( main::@1/idx#59 )
  call ln 
  to:main::@6
main::@6: scope:[main]  from main::@3
  idx#35 = phi( main::@3/idx#3 )
  idx#9 = idx#35
  exec::collect#0 = &sum
  call exec 
  to:main::@7
main::@7: scope:[main]  from main::@6
  idx#36 = phi( main::@6/idx#23 )
  idx#10 = idx#36
  call ln 
  to:main::@8
main::@8: scope:[main]  from main::@7
  idx#37 = phi( main::@7/idx#3 )
  idx#11 = idx#37
  exec::collect#1 = &min
  call exec 
  to:main::@9
main::@9: scope:[main]  from main::@8
  idx#38 = phi( main::@8/idx#23 )
  idx#12 = idx#38
  call ln 
  to:main::@10
main::@10: scope:[main]  from main::@9
  idx#39 = phi( main::@9/idx#3 )
  idx#13 = idx#39
  exec::collect#2 = &max
  call exec 
  to:main::@11
main::@11: scope:[main]  from main::@10
  idx#40 = phi( main::@10/idx#23 )
  idx#14 = idx#40
  call ln 
  to:main::@12
main::@12: scope:[main]  from main::@11
  idx#41 = phi( main::@11/idx#3 )
  idx#15 = idx#41
  exec::collect#3 = &xor
  call exec 
  to:main::@13
main::@13: scope:[main]  from main::@12
  idx#42 = phi( main::@12/idx#23 )
  idx#16 = idx#42
  to:main::@return
main::@return: scope:[main]  from main::@13
  idx#43 = phi( main::@13/idx#16 )
  idx#17 = idx#43
  return 
  to:@return

void exec(byte(byte,byte)* exec::collect)
exec: scope:[exec]  from main::@10 main::@12 main::@6 main::@8
  exec::collect#12 = phi( main::@10/exec::collect#2, main::@12/exec::collect#3, main::@6/exec::collect#0, main::@8/exec::collect#1 )
  idx#52 = phi( main::@10/idx#13, main::@12/idx#15, main::@6/idx#9, main::@8/idx#11 )
  cout::c#3 = ' '
  call cout 
  to:exec::@4
exec::@4: scope:[exec]  from exec
  exec::collect#10 = phi( exec/exec::collect#12 )
  idx#44 = phi( exec/idx#1 )
  idx#18 = idx#44
  cout::c#4 = ' '
  call cout 
  to:exec::@5
exec::@5: scope:[exec]  from exec::@4
  exec::collect#8 = phi( exec::@4/exec::collect#10 )
  idx#45 = phi( exec::@4/idx#1 )
  idx#19 = idx#45
  cout::c#5 = ' '
  call cout 
  to:exec::@6
exec::@6: scope:[exec]  from exec::@5
  exec::collect#6 = phi( exec::@5/exec::collect#8 )
  idx#46 = phi( exec::@5/idx#1 )
  idx#20 = idx#46
  exec::out#0 = INPUT[0]
  exec::i#0 = 1
  to:exec::@1
exec::@1: scope:[exec]  from exec::@6 exec::@8
  idx#57 = phi( exec::@6/idx#20, exec::@8/idx#22 )
  exec::collect#5 = phi( exec::@6/exec::collect#6, exec::@8/exec::collect#7 )
  exec::out#3 = phi( exec::@6/exec::out#0, exec::@8/exec::out#4 )
  exec::i#2 = phi( exec::@6/exec::i#0, exec::@8/exec::i#1 )
  exec::$3 = sizeof  INPUT
  exec::$4 = exec::i#2 < exec::$3
  if(exec::$4) goto exec::@2
  to:exec::@return
exec::@2: scope:[exec]  from exec::@1
  idx#60 = phi( exec::@1/idx#57 )
  exec::collect#4 = phi( exec::@1/exec::collect#5 )
  exec::i#3 = phi( exec::@1/exec::i#2 )
  exec::out#2 = phi( exec::@1/exec::out#3 )
  stackpush(byte) = exec::out#2
  stackpush(byte) = INPUT[exec::i#3]
  callexecute *exec::collect#4 
  sideeffect stackpullbytes(1)
  exec::$5 = stackpull(byte)
  to:exec::@3
exec::@3: scope:[exec]  from exec::@2
  exec::collect#11 = phi( exec::@2/exec::collect#4 )
  exec::i#6 = phi( exec::@2/exec::i#3 )
  idx#56 = phi( exec::@2/idx#60 )
  exec::out#1 = exec::$5
  print::i#1 = exec::out#1
  call print 
  to:exec::@7
exec::@7: scope:[exec]  from exec::@3
  exec::collect#9 = phi( exec::@3/exec::collect#11 )
  exec::out#5 = phi( exec::@3/exec::out#1 )
  exec::i#5 = phi( exec::@3/exec::i#6 )
  idx#47 = phi( exec::@3/idx#6 )
  idx#21 = idx#47
  cout::c#6 = ' '
  call cout 
  to:exec::@8
exec::@8: scope:[exec]  from exec::@7
  exec::collect#7 = phi( exec::@7/exec::collect#9 )
  exec::out#4 = phi( exec::@7/exec::out#5 )
  exec::i#4 = phi( exec::@7/exec::i#5 )
  idx#48 = phi( exec::@7/idx#1 )
  idx#22 = idx#48
  exec::i#1 = ++ exec::i#4
  to:exec::@1
exec::@return: scope:[exec]  from exec::@1
  idx#49 = phi( exec::@1/idx#57 )
  idx#23 = idx#49
  return 
  to:@return

__stackcall byte max(byte max::a , byte max::b)
max: scope:[max]  from
  max::a#0 = stackidx(byte,max::OFFSET_STACK_A)
  max::b#0 = stackidx(byte,max::OFFSET_STACK_B)
  max::$0 = max::a#0 > max::b#0
  if(max::$0) goto max::@1
  to:max::@2
max::@1: scope:[max]  from max
  max::a#1 = phi( max/max::a#0 )
  max::return#0 = max::a#1
  to:max::@return
max::@2: scope:[max]  from max
  max::b#1 = phi( max/max::b#0 )
  max::return#1 = max::b#1
  to:max::@return
max::@return: scope:[max]  from max::@1 max::@2
  max::return#3 = phi( max::@1/max::return#0, max::@2/max::return#1 )
  max::return#2 = max::return#3
  stackidx(byte,max::OFFSET_STACK_RETURN_1) = max::return#2
  return 
  to:@return

__stackcall byte min(byte min::a , byte min::b)
min: scope:[min]  from
  min::a#0 = stackidx(byte,min::OFFSET_STACK_A)
  min::b#0 = stackidx(byte,min::OFFSET_STACK_B)
  min::$0 = min::a#0 < min::b#0
  if(min::$0) goto min::@1
  to:min::@2
min::@1: scope:[min]  from min
  min::a#1 = phi( min/min::a#0 )
  min::return#0 = min::a#1
  to:min::@return
min::@2: scope:[min]  from min
  min::b#1 = phi( min/min::b#0 )
  min::return#1 = min::b#1
  to:min::@return
min::@return: scope:[min]  from min::@1 min::@2
  min::return#3 = phi( min::@1/min::return#0, min::@2/min::return#1 )
  min::return#2 = min::return#3
  stackidx(byte,min::OFFSET_STACK_RETURN_1) = min::return#2
  return 
  to:@return

__stackcall byte xor(byte xor::a , byte xor::b)
xor: scope:[xor]  from
  xor::a#0 = stackidx(byte,xor::OFFSET_STACK_A)
  xor::b#0 = stackidx(byte,xor::OFFSET_STACK_B)
  xor::$0 = xor::a#0 ^ xor::b#0
  xor::return#0 = xor::$0
  to:xor::@return
xor::@return: scope:[xor]  from xor
  xor::return#2 = phi( xor/xor::return#0 )
  xor::return#1 = xor::return#2
  stackidx(byte,xor::OFFSET_STACK_RETURN_1) = xor::return#1
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  line = (byte*)$400
  idx#24 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  idx#58 = phi( __start::__init1/idx#24 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  idx#50 = phi( __start::@1/idx#17 )
  idx#25 = idx#50
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  idx#51 = phi( __start::@2/idx#25 )
  idx#26 = idx#51
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* HEX[]  = "0123456789abcdef"
constant byte* INPUT[]  = { 2, 1, 3, 4, 6, 5 }
constant word STACK_BASE = $103
void __start()
void cout(byte cout::c)
byte cout::c
byte cout::c#0
byte cout::c#1
byte cout::c#2
byte cout::c#3
byte cout::c#4
byte cout::c#5
byte cout::c#6
byte cout::c#7
void exec(byte(byte,byte)* exec::collect)
word~ exec::$3
bool~ exec::$4
byte~ exec::$5
byte(byte,byte)* exec::collect
byte(byte,byte)* exec::collect#0
byte(byte,byte)* exec::collect#1
byte(byte,byte)* exec::collect#10
byte(byte,byte)* exec::collect#11
byte(byte,byte)* exec::collect#12
byte(byte,byte)* exec::collect#2
byte(byte,byte)* exec::collect#3
byte(byte,byte)* exec::collect#4
byte(byte,byte)* exec::collect#5
byte(byte,byte)* exec::collect#6
byte(byte,byte)* exec::collect#7
byte(byte,byte)* exec::collect#8
byte(byte,byte)* exec::collect#9
byte exec::i
byte exec::i#0
byte exec::i#1
byte exec::i#2
byte exec::i#3
byte exec::i#4
byte exec::i#5
byte exec::i#6
byte exec::out
byte exec::out#0
byte exec::out#1
byte exec::out#2
byte exec::out#3
byte exec::out#4
byte exec::out#5
byte idx
byte idx#0
byte idx#1
byte idx#10
byte idx#11
byte idx#12
byte idx#13
byte idx#14
byte idx#15
byte idx#16
byte idx#17
byte idx#18
byte idx#19
byte idx#2
byte idx#20
byte idx#21
byte idx#22
byte idx#23
byte idx#24
byte idx#25
byte idx#26
byte idx#27
byte idx#28
byte idx#29
byte idx#3
byte idx#30
byte idx#31
byte idx#32
byte idx#33
byte idx#34
byte idx#35
byte idx#36
byte idx#37
byte idx#38
byte idx#39
byte idx#4
byte idx#40
byte idx#41
byte idx#42
byte idx#43
byte idx#44
byte idx#45
byte idx#46
byte idx#47
byte idx#48
byte idx#49
byte idx#5
byte idx#50
byte idx#51
byte idx#52
byte idx#53
byte idx#54
byte idx#55
byte idx#56
byte idx#57
byte idx#58
byte idx#59
byte idx#6
byte idx#60
byte idx#61
byte idx#7
byte idx#8
byte idx#9
byte* line loadstore
void ln()
void main()
word~ main::$8
bool~ main::$9
byte main::i
byte main::i#0
byte main::i#1
byte main::i#2
byte main::i#3
byte main::i#4
byte main::i#5
__stackcall byte max(byte max::a , byte max::b)
bool~ max::$0
constant byte max::OFFSET_STACK_A = 1
constant byte max::OFFSET_STACK_B = 0
constant byte max::OFFSET_STACK_RETURN_1 = 1
byte max::a
byte max::a#0
byte max::a#1
byte max::b
byte max::b#0
byte max::b#1
byte max::return
byte max::return#0
byte max::return#1
byte max::return#2
byte max::return#3
__stackcall byte min(byte min::a , byte min::b)
bool~ min::$0
constant byte min::OFFSET_STACK_A = 1
constant byte min::OFFSET_STACK_B = 0
constant byte min::OFFSET_STACK_RETURN_1 = 1
byte min::a
byte min::a#0
byte min::a#1
byte min::b
byte min::b#0
byte min::b#1
byte min::return
byte min::return#0
byte min::return#1
byte min::return#2
byte min::return#3
void print(byte print::i)
byte~ print::$0
number~ print::$2
byte print::i
byte print::i#0
byte print::i#1
byte print::i#2
byte print::i#3
__stackcall byte sum(byte sum::a , byte sum::b)
byte~ sum::$0
constant byte sum::OFFSET_STACK_A = 1
constant byte sum::OFFSET_STACK_B = 0
constant byte sum::OFFSET_STACK_RETURN_1 = 1
byte sum::a
byte sum::a#0
byte sum::b
byte sum::b#0
byte sum::return
byte sum::return#0
byte sum::return#1
byte sum::return#2
__stackcall byte xor(byte xor::a , byte xor::b)
byte~ xor::$0
constant byte xor::OFFSET_STACK_A = 1
constant byte xor::OFFSET_STACK_B = 0
constant byte xor::OFFSET_STACK_RETURN_1 = 1
byte xor::a
byte xor::a#0
byte xor::b
byte xor::b#0
byte xor::return
byte xor::return#0
byte xor::return#1
byte xor::return#2

Adding number conversion cast (unumber) $28 in line = line + $28
Adding number conversion cast (unumber) 0 in idx#2 = 0
Adding number conversion cast (unumber) 4 in print::$0 = print::i#2 >> 4
Adding number conversion cast (unumber) $f in print::$2 = print::i#3 & $f
Adding number conversion cast (unumber) print::$2 in print::$2 = print::i#3 & (unumber)$f
Adding number conversion cast (unumber) 0 in exec::out#0 = INPUT[0]
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast idx#2 = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 1024
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in print::$2 = print::i#3 & $f
Alias sum::return#0 = sum::$0 sum::return#2 sum::return#1 
Alias idx#0 = idx#28 idx#1 
Alias idx#2 = idx#29 idx#3 
Alias print::i#2 = print::i#3 
Alias idx#30 = idx#4 
Alias idx#31 = idx#5 idx#32 idx#6 
Alias main::i#2 = main::i#3 main::i#5 main::i#4 
Alias idx#54 = idx#59 idx#55 
Alias idx#33 = idx#7 
Alias idx#34 = idx#8 
Alias idx#35 = idx#9 
Alias idx#10 = idx#36 
Alias idx#11 = idx#37 
Alias idx#12 = idx#38 
Alias idx#13 = idx#39 
Alias idx#14 = idx#40 
Alias idx#15 = idx#41 
Alias idx#16 = idx#42 idx#43 idx#17 
Alias exec::collect#10 = exec::collect#12 exec::collect#8 exec::collect#6 
Alias idx#18 = idx#44 
Alias idx#19 = idx#45 
Alias idx#20 = idx#46 
Alias exec::out#2 = exec::out#3 
Alias exec::i#2 = exec::i#3 exec::i#6 exec::i#5 exec::i#4 
Alias exec::collect#11 = exec::collect#4 exec::collect#5 exec::collect#9 exec::collect#7 
Alias idx#23 = idx#60 idx#57 idx#56 idx#49 
Alias exec::out#1 = exec::$5 exec::out#5 exec::out#4 
Alias idx#21 = idx#47 
Alias idx#22 = idx#48 
Alias max::a#0 = max::a#1 max::return#0 
Alias max::b#0 = max::b#1 max::return#1 
Alias max::return#2 = max::return#3 
Alias min::a#0 = min::a#1 min::return#0 
Alias min::b#0 = min::b#1 min::return#1 
Alias min::return#2 = min::return#3 
Alias xor::return#0 = xor::$0 xor::return#2 xor::return#1 
Alias idx#24 = idx#58 
Alias idx#25 = idx#50 idx#51 idx#26 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values idx#30 idx#0
Identical Phi Values idx#31 idx#0
Identical Phi Values idx#61 idx#24
Identical Phi Values idx#33 idx#31
Identical Phi Values idx#34 idx#0
Identical Phi Values idx#35 idx#2
Identical Phi Values idx#10 idx#23
Identical Phi Values idx#11 idx#2
Identical Phi Values idx#12 idx#23
Identical Phi Values idx#13 idx#2
Identical Phi Values idx#14 idx#23
Identical Phi Values idx#15 idx#2
Identical Phi Values idx#16 idx#23
Identical Phi Values idx#18 idx#0
Identical Phi Values idx#19 idx#0
Identical Phi Values idx#20 idx#0
Identical Phi Values exec::collect#11 exec::collect#10
Identical Phi Values idx#21 idx#31
Identical Phi Values idx#22 idx#0
Identical Phi Values idx#25 idx#16
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values idx#52 idx#2
Identical Phi Values idx#23 idx#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$9 [27] if(main::i#2<main::$8) goto main::@2
Simple Condition exec::$4 [71] if(exec::i#2<exec::$3) goto exec::@2
Simple Condition max::$0 [88] if(max::a#0>max::b#0) goto max::@1
Simple Condition min::$0 [95] if(min::a#0<min::b#0) goto min::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [25] main::$8 = sizeof  INPUT
Constant right-side identified [69] exec::$3 = sizeof  INPUT
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant idx#2 = 0
Constant main::i#0 = 0
Constant main::$8 = sizeof INPUT
Constant cout::c#2 = ' '
Constant exec::collect#0 = &sum
Constant exec::collect#1 = &min
Constant exec::collect#2 = &max
Constant exec::collect#3 = &xor
Constant cout::c#3 = ' '
Constant cout::c#4 = ' '
Constant cout::c#5 = ' '
Constant exec::i#0 = 1
Constant exec::$3 = sizeof INPUT
Constant cout::c#6 = ' '
Constant idx#24 = 0
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero INPUT in [66] exec::out#0 = INPUT[0]
Successful SSA optimization PassNSimplifyExpressionWithZero
Resolving array sizeof() sizeof INPUT
Resolving array sizeof() sizeof INPUT
Successful SSA optimization PassNSizeOfSimplification
Adding number conversion cast (unumber) 6 in 
Adding number conversion cast (unumber) 6 in 
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 6
Simplifying constant integer cast 6
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) 6
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings cout::c#2
Inlining constant with var siblings cout::c#3
Inlining constant with var siblings cout::c#4
Inlining constant with var siblings cout::c#5
Inlining constant with var siblings cout::c#6
Inlining constant with var siblings main::i#0
Inlining constant with var siblings exec::collect#0
Inlining constant with var siblings exec::collect#1
Inlining constant with var siblings exec::collect#2
Inlining constant with var siblings exec::collect#3
Inlining constant with var siblings exec::i#0
Inlining constant with var siblings idx#2
Inlining constant with var siblings idx#24
Constant inlined exec::collect#1 = &min
Constant inlined exec::collect#0 = &sum
Constant inlined exec::$3 = 6*SIZEOF_BYTE
Constant inlined exec::collect#3 = &xor
Constant inlined exec::collect#2 = &max
Constant inlined idx#24 = 0
Constant inlined cout::c#2 = ' '
Constant inlined cout::c#4 = ' '
Constant inlined main::i#0 = 0
Constant inlined cout::c#3 = ' '
Constant inlined cout::c#6 = ' '
Constant inlined exec::i#0 = 1
Constant inlined idx#2 = 0
Constant inlined cout::c#5 = ' '
Constant inlined main::$8 = 6*SIZEOF_BYTE
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of __start::@2
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@9
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@12
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of print::@2
CALL GRAPH
Calls in [__start] to main:3 
Calls in [main] to ln:36 exec:38 ln:40 exec:42 ln:44 exec:46 ln:48 exec:50 print:56 cout:58 
Calls in [exec] to cout:65 cout:67 cout:69 null:77 print:83 cout:85 
Calls in [print] to cout:94 cout:99 

Created 11 initial phi equivalence classes
Coalesced [14] min::return#5 = min::b#0
Not coalescing [18] min::return#4 = min::a#0
Coalesced [22] max::return#5 = max::b#0
Not coalescing [26] max::return#4 = max::a#0
Coalesced [54] print::i#5 = print::i#0
Coalesced [55] idx#69 = idx#54
Coalesced [57] idx#65 = idx#0
Coalesced [60] main::i#6 = main::i#1
Coalesced [61] idx#70 = idx#0
Coalesced (already) [66] idx#62 = idx#0
Coalesced (already) [68] idx#63 = idx#0
Coalesced [71] exec::out#6 = exec::out#0
Coalesced [81] print::i#4 = print::i#1
Coalesced (already) [82] idx#68 = idx#0
Coalesced (already) [84] idx#64 = idx#0
Coalesced [87] exec::i#7 = exec::i#1
Coalesced [88] exec::out#7 = exec::out#1
Coalesced [92] cout::c#8 = cout::c#0
Coalesced (already) [93] idx#66 = idx#53
Coalesced [97] cout::c#9 = cout::c#1
Coalesced (already) [98] idx#67 = idx#0
Coalesced down to 11 phi equivalence classes
Culled Empty Block label __start::@2
Culled Empty Block label min::@2
Culled Empty Block label max::@2
Culled Empty Block label main::@13
Culled Empty Block label print::@2
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@9
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@12
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of exec::@4
Adding NOP phi() at start of exec::@5
Adding NOP phi() at start of exec::@7

FINAL CONTROL FLOW GRAPH

void __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] line = (byte*) 1024
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [2] phi()
  [3] call main 
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [4] return 
  to:@return

__stackcall byte xor(byte xor::a , byte xor::b)
xor: scope:[xor]  from
  [5] xor::a#0 = stackidx(byte,xor::OFFSET_STACK_A)
  [6] xor::b#0 = stackidx(byte,xor::OFFSET_STACK_B)
  [7] xor::return#0 = xor::a#0 ^ xor::b#0
  to:xor::@return
xor::@return: scope:[xor]  from xor
  [8] stackidx(byte,xor::OFFSET_STACK_RETURN_1) = xor::return#0
  [9] return 
  to:@return

__stackcall byte min(byte min::a , byte min::b)
min: scope:[min]  from
  [10] min::a#0 = stackidx(byte,min::OFFSET_STACK_A)
  [11] min::b#0 = stackidx(byte,min::OFFSET_STACK_B)
  [12] if(min::a#0<min::b#0) goto min::@1
  to:min::@return
min::@1: scope:[min]  from min
  [13] min::return#4 = min::a#0
  to:min::@return
min::@return: scope:[min]  from min min::@1
  [14] min::return#2 = phi( min::@1/min::return#4, min/min::b#0 )
  [15] stackidx(byte,min::OFFSET_STACK_RETURN_1) = min::return#2
  [16] return 
  to:@return

__stackcall byte max(byte max::a , byte max::b)
max: scope:[max]  from
  [17] max::a#0 = stackidx(byte,max::OFFSET_STACK_A)
  [18] max::b#0 = stackidx(byte,max::OFFSET_STACK_B)
  [19] if(max::a#0>max::b#0) goto max::@1
  to:max::@return
max::@1: scope:[max]  from max
  [20] max::return#4 = max::a#0
  to:max::@return
max::@return: scope:[max]  from max max::@1
  [21] max::return#2 = phi( max::@1/max::return#4, max/max::b#0 )
  [22] stackidx(byte,max::OFFSET_STACK_RETURN_1) = max::return#2
  [23] return 
  to:@return

__stackcall byte sum(byte sum::a , byte sum::b)
sum: scope:[sum]  from
  [24] sum::a#0 = stackidx(byte,sum::OFFSET_STACK_A)
  [25] sum::b#0 = stackidx(byte,sum::OFFSET_STACK_B)
  [26] sum::return#0 = sum::a#0 + sum::b#0
  to:sum::@return
sum::@return: scope:[sum]  from sum
  [27] stackidx(byte,sum::OFFSET_STACK_RETURN_1) = sum::return#0
  [28] return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  [29] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [30] idx#54 = phi( main/0, main::@5/idx#0 )
  [30] main::i#2 = phi( main/0, main::@5/main::i#1 )
  [31] if(main::i#2<6*SIZEOF_BYTE) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [32] phi()
  [33] call ln 
  to:main::@6
main::@6: scope:[main]  from main::@3
  [34] phi()
  [35] call exec 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [36] phi()
  [37] call ln 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [38] phi()
  [39] call exec 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [40] phi()
  [41] call ln 
  to:main::@10
main::@10: scope:[main]  from main::@9
  [42] phi()
  [43] call exec 
  to:main::@11
main::@11: scope:[main]  from main::@10
  [44] phi()
  [45] call ln 
  to:main::@12
main::@12: scope:[main]  from main::@11
  [46] phi()
  [47] call exec 
  to:main::@return
main::@return: scope:[main]  from main::@12
  [48] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [49] print::i#0 = INPUT[main::i#2]
  [50] call print 
  to:main::@4
main::@4: scope:[main]  from main::@2
  [51] phi()
  [52] call cout 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [53] main::i#1 = ++ main::i#2
  to:main::@1

void ln()
ln: scope:[ln]  from main::@11 main::@3 main::@7 main::@9
  [54] line = line + $28
  to:ln::@return
ln::@return: scope:[ln]  from ln
  [55] return 
  to:@return

void exec(byte(byte,byte)* exec::collect)
exec: scope:[exec]  from main::@10 main::@12 main::@6 main::@8
  [56] exec::collect#10 = phi( main::@10/&max, main::@12/&xor, main::@6/&sum, main::@8/&min )
  [57] call cout 
  to:exec::@4
exec::@4: scope:[exec]  from exec
  [58] phi()
  [59] call cout 
  to:exec::@5
exec::@5: scope:[exec]  from exec::@4
  [60] phi()
  [61] call cout 
  to:exec::@6
exec::@6: scope:[exec]  from exec::@5
  [62] exec::out#0 = *INPUT
  to:exec::@1
exec::@1: scope:[exec]  from exec::@6 exec::@8
  [63] exec::out#2 = phi( exec::@6/exec::out#0, exec::@8/exec::out#1 )
  [63] exec::i#2 = phi( exec::@6/1, exec::@8/exec::i#1 )
  [64] if(exec::i#2<6*SIZEOF_BYTE) goto exec::@2
  to:exec::@return
exec::@return: scope:[exec]  from exec::@1
  [65] return 
  to:@return
exec::@2: scope:[exec]  from exec::@1
  [66] stackpush(byte) = exec::out#2
  [67] stackpush(byte) = INPUT[exec::i#2]
  [68] callexecute *exec::collect#10 
  sideeffect stackpullbytes(1)
  [70] exec::out#1 = stackpull(byte)
  to:exec::@3
exec::@3: scope:[exec]  from exec::@2
  [71] print::i#1 = exec::out#1
  [72] call print 
  to:exec::@7
exec::@7: scope:[exec]  from exec::@3
  [73] phi()
  [74] call cout 
  to:exec::@8
exec::@8: scope:[exec]  from exec::@7
  [75] exec::i#1 = ++ exec::i#2
  to:exec::@1

void print(byte print::i)
print: scope:[print]  from exec::@3 main::@2
  [76] idx#53 = phi( exec::@3/idx#0, main::@2/idx#54 )
  [76] print::i#2 = phi( exec::@3/print::i#1, main::@2/print::i#0 )
  [77] print::$0 = print::i#2 >> 4
  [78] cout::c#0 = HEX[print::$0]
  [79] call cout 
  to:print::@1
print::@1: scope:[print]  from print
  [80] print::$2 = print::i#2 & $f
  [81] cout::c#1 = HEX[print::$2]
  [82] call cout 
  to:print::@return
print::@return: scope:[print]  from print::@1
  [83] return 
  to:@return

void cout(byte cout::c)
cout: scope:[cout]  from exec exec::@4 exec::@5 exec::@7 main::@4 print print::@1
  [84] idx#27 = phi( exec/0, exec::@4/idx#0, exec::@5/idx#0, exec::@7/idx#0, main::@4/idx#0, print/idx#53, print::@1/idx#0 )
  [84] cout::c#7 = phi( exec/' ', exec::@4/' ', exec::@5/' ', exec::@7/' ', main::@4/' ', print/cout::c#0, print::@1/cout::c#1 )
  [85] line[idx#27] = cout::c#7
  [86] idx#0 = ++ idx#27
  to:cout::@return
cout::@return: scope:[cout]  from cout
  [87] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void __start()
void cout(byte cout::c)
byte cout::c
byte cout::c#0 20002.0
byte cout::c#1 20002.0
byte cout::c#7 120003.0
void exec(byte(byte,byte)* exec::collect)
byte(byte,byte)* exec::collect
byte(byte,byte)* exec::collect#10
byte exec::i
byte exec::i#1 2002.0
byte exec::i#2 400.4
byte exec::out
byte exec::out#0 202.0
byte exec::out#1 500.5
byte exec::out#2 1051.5
byte idx
byte idx#0 5352.761904761905
byte idx#27 110654.0
byte idx#53 3701.0
byte idx#54 67.33333333333333
byte* line loadstore 1757.982456140351
void ln()
void main()
byte main::i
byte main::i#1 202.0
byte main::i#2 67.33333333333333
__stackcall byte max(byte max::a , byte max::b)
byte max::a
byte max::a#0 2.0
byte max::b
byte max::b#0 3.0
byte max::return
byte max::return#2 6.0
byte max::return#4 4.0
__stackcall byte min(byte min::a , byte min::b)
byte min::a
byte min::a#0 2.0
byte min::b
byte min::b#0 3.0
byte min::return
byte min::return#2 6.0
byte min::return#4 4.0
void print(byte print::i)
byte~ print::$0 20002.0
byte~ print::$2 20002.0
byte print::i
byte print::i#0 202.0
byte print::i#1 2002.0
byte print::i#2 5276.0
__stackcall byte sum(byte sum::a , byte sum::b)
byte sum::a
byte sum::a#0 2.0
byte sum::b
byte sum::b#0 4.0
byte sum::return
byte sum::return#0 4.0
__stackcall byte xor(byte xor::a , byte xor::b)
byte xor::a
byte xor::a#0 2.0
byte xor::b
byte xor::b#0 4.0
byte xor::return
byte xor::return#0 4.0

Initial phi equivalence classes
[ min::return#2 min::return#4 min::b#0 ]
[ max::return#2 max::return#4 max::b#0 ]
[ main::i#2 main::i#1 ]
[ exec::collect#10 ]
[ exec::i#2 exec::i#1 ]
[ exec::out#2 exec::out#0 exec::out#1 ]
[ print::i#2 print::i#1 print::i#0 ]
[ cout::c#7 cout::c#0 cout::c#1 ]
[ idx#27 idx#53 idx#54 idx#0 ]
Added variable line to live range equivalence class [ line ]
Added variable xor::a#0 to live range equivalence class [ xor::a#0 ]
Added variable xor::b#0 to live range equivalence class [ xor::b#0 ]
Added variable xor::return#0 to live range equivalence class [ xor::return#0 ]
Added variable min::a#0 to live range equivalence class [ min::a#0 ]
Added variable max::a#0 to live range equivalence class [ max::a#0 ]
Added variable sum::a#0 to live range equivalence class [ sum::a#0 ]
Added variable sum::b#0 to live range equivalence class [ sum::b#0 ]
Added variable sum::return#0 to live range equivalence class [ sum::return#0 ]
Added variable print::$0 to live range equivalence class [ print::$0 ]
Added variable print::$2 to live range equivalence class [ print::$2 ]
Complete equivalence classes
[ min::return#2 min::return#4 min::b#0 ]
[ max::return#2 max::return#4 max::b#0 ]
[ main::i#2 main::i#1 ]
[ exec::collect#10 ]
[ exec::i#2 exec::i#1 ]
[ exec::out#2 exec::out#0 exec::out#1 ]
[ print::i#2 print::i#1 print::i#0 ]
[ cout::c#7 cout::c#0 cout::c#1 ]
[ idx#27 idx#53 idx#54 idx#0 ]
[ line ]
[ xor::a#0 ]
[ xor::b#0 ]
[ xor::return#0 ]
[ min::a#0 ]
[ max::a#0 ]
[ sum::a#0 ]
[ sum::b#0 ]
[ sum::return#0 ]
[ print::$0 ]
[ print::$2 ]
Allocated zp[1]:2 [ min::return#2 min::return#4 min::b#0 ]
Allocated zp[1]:3 [ max::return#2 max::return#4 max::b#0 ]
Allocated zp[1]:4 [ main::i#2 main::i#1 ]
Allocated zp[2]:5 [ exec::collect#10 ]
Allocated zp[1]:7 [ exec::i#2 exec::i#1 ]
Allocated zp[1]:8 [ exec::out#2 exec::out#0 exec::out#1 ]
Allocated zp[1]:9 [ print::i#2 print::i#1 print::i#0 ]
Allocated zp[1]:10 [ cout::c#7 cout::c#0 cout::c#1 ]
Allocated zp[1]:11 [ idx#27 idx#53 idx#54 idx#0 ]
Allocated zp[2]:12 [ line ]
Allocated zp[1]:14 [ xor::a#0 ]
Allocated zp[1]:15 [ xor::b#0 ]
Allocated zp[1]:16 [ xor::return#0 ]
Allocated zp[1]:17 [ min::a#0 ]
Allocated zp[1]:18 [ max::a#0 ]
Allocated zp[1]:19 [ sum::a#0 ]
Allocated zp[1]:20 [ sum::b#0 ]
Allocated zp[1]:21 [ sum::return#0 ]
Allocated zp[1]:22 [ print::$0 ]
Allocated zp[1]:23 [ print::$2 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] line = (byte*) 1024 [ line ] (  [ line ] { }  ) always clobbers reg byte a 
Statement [5] xor::a#0 = stackidx(byte,xor::OFFSET_STACK_A) [ xor::a#0 ] (  [ xor::a#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [6] xor::b#0 = stackidx(byte,xor::OFFSET_STACK_B) [ xor::a#0 xor::b#0 ] (  [ xor::a#0 xor::b#0 ] { }  ) always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte a as potential for zp[1]:14 [ xor::a#0 ]
Removing always clobbered register reg byte x as potential for zp[1]:14 [ xor::a#0 ]
Statement [7] xor::return#0 = xor::a#0 ^ xor::b#0 [ xor::return#0 ] (  [ xor::return#0 ] { }  ) always clobbers reg byte a 
Statement [8] stackidx(byte,xor::OFFSET_STACK_RETURN_1) = xor::return#0 [ ] (  [ ] { }  ) always clobbers reg byte x 
Statement [10] min::a#0 = stackidx(byte,min::OFFSET_STACK_A) [ min::a#0 ] (  [ min::a#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [11] min::b#0 = stackidx(byte,min::OFFSET_STACK_B) [ min::a#0 min::b#0 ] (  [ min::a#0 min::b#0 ] { }  ) always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte a as potential for zp[1]:17 [ min::a#0 ]
Removing always clobbered register reg byte x as potential for zp[1]:17 [ min::a#0 ]
Statement [15] stackidx(byte,min::OFFSET_STACK_RETURN_1) = min::return#2 [ ] (  [ ] { }  ) always clobbers reg byte x 
Statement [17] max::a#0 = stackidx(byte,max::OFFSET_STACK_A) [ max::a#0 ] (  [ max::a#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [18] max::b#0 = stackidx(byte,max::OFFSET_STACK_B) [ max::a#0 max::b#0 ] (  [ max::a#0 max::b#0 ] { }  ) always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte a as potential for zp[1]:18 [ max::a#0 ]
Removing always clobbered register reg byte x as potential for zp[1]:18 [ max::a#0 ]
Statement [22] stackidx(byte,max::OFFSET_STACK_RETURN_1) = max::return#2 [ ] (  [ ] { }  ) always clobbers reg byte x 
Statement [24] sum::a#0 = stackidx(byte,sum::OFFSET_STACK_A) [ sum::a#0 ] (  [ sum::a#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [25] sum::b#0 = stackidx(byte,sum::OFFSET_STACK_B) [ sum::a#0 sum::b#0 ] (  [ sum::a#0 sum::b#0 ] { }  ) always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte a as potential for zp[1]:19 [ sum::a#0 ]
Removing always clobbered register reg byte x as potential for zp[1]:19 [ sum::a#0 ]
Statement [26] sum::return#0 = sum::a#0 + sum::b#0 [ sum::return#0 ] (  [ sum::return#0 ] { }  ) always clobbers reg byte a 
Statement [27] stackidx(byte,sum::OFFSET_STACK_RETURN_1) = sum::return#0 [ ] (  [ ] { }  ) always clobbers reg byte x 
Statement [54] line = line + $28 [ line ] ( main:3::ln:33 [ line ] { }  main:3::ln:37 [ line ] { }  main:3::ln:41 [ line ] { }  main:3::ln:45 [ line ] { }  ) always clobbers reg byte a 
Statement [67] stackpush(byte) = INPUT[exec::i#2] [ ] ( main:3::exec:35 [ ] { }  main:3::exec:39 [ ] { }  main:3::exec:43 [ ] { }  main:3::exec:47 [ ] { }  ) always clobbers reg byte a 
Statement [68] callexecute *exec::collect#10  [ line idx#0 exec::i#2 ] ( main:3::exec:35 [ line idx#0 exec::i#2 ] { }  main:3::exec:39 [ line idx#0 exec::i#2 ] { }  main:3::exec:43 [ line idx#0 exec::i#2 ] { }  main:3::exec:47 [ line idx#0 exec::i#2 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:11 [ idx#27 idx#53 idx#54 idx#0 ]
Removing always clobbered register reg byte x as potential for zp[1]:11 [ idx#27 idx#53 idx#54 idx#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:11 [ idx#27 idx#53 idx#54 idx#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ exec::i#2 exec::i#1 ]
Removing always clobbered register reg byte x as potential for zp[1]:7 [ exec::i#2 exec::i#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:7 [ exec::i#2 exec::i#1 ]
Statement sideeffect stackpullbytes(1) always clobbers reg byte a 
Statement [70] exec::out#1 = stackpull(byte) [ line idx#0 exec::i#2 exec::out#1 ] ( main:3::exec:35 [ line idx#0 exec::i#2 exec::out#1 ] { }  main:3::exec:39 [ line idx#0 exec::i#2 exec::out#1 ] { }  main:3::exec:43 [ line idx#0 exec::i#2 exec::out#1 ] { }  main:3::exec:47 [ line idx#0 exec::i#2 exec::out#1 ] { }  ) always clobbers reg byte a 
Statement [77] print::$0 = print::i#2 >> 4 [ line print::i#2 idx#53 print::$0 ] ( main:3::print:50 [ main::i#2 line print::i#2 idx#53 print::$0 ] { { print::i#0 = print::i#2 } { idx#27 = idx#53 idx#54 } { cout::c#0 = cout::c#7 } }  main:3::exec:35::print:72 [ exec::i#2 exec::out#1 line print::i#2 idx#53 print::$0 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:39::print:72 [ exec::i#2 exec::out#1 line print::i#2 idx#53 print::$0 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:43::print:72 [ exec::i#2 exec::out#1 line print::i#2 idx#53 print::$0 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:47::print:72 [ exec::i#2 exec::out#1 line print::i#2 idx#53 print::$0 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ main::i#2 main::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:9 [ print::i#2 print::i#1 print::i#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:8 [ exec::out#2 exec::out#0 exec::out#1 ]
Statement [80] print::$2 = print::i#2 & $f [ line idx#0 print::$2 ] ( main:3::print:50 [ main::i#2 line idx#0 print::$2 ] { { print::i#0 = print::i#2 } { idx#53 = idx#54 } { cout::c#1 = cout::c#7 } { idx#0 = idx#27 } }  main:3::exec:35::print:72 [ exec::i#2 exec::out#1 line idx#0 print::$2 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:39::print:72 [ exec::i#2 exec::out#1 line idx#0 print::$2 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:43::print:72 [ exec::i#2 exec::out#1 line idx#0 print::$2 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:47::print:72 [ exec::i#2 exec::out#1 line idx#0 print::$2 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  ) always clobbers reg byte a 
Statement [85] line[idx#27] = cout::c#7 [ line idx#27 ] ( main:3::cout:52 [ main::i#2 line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:35::cout:57 [ line idx#27 ] { }  main:3::exec:39::cout:57 [ line idx#27 ] { }  main:3::exec:43::cout:57 [ line idx#27 ] { }  main:3::exec:47::cout:57 [ line idx#27 ] { }  main:3::exec:35::cout:59 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:39::cout:59 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:43::cout:59 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:47::cout:59 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:35::cout:61 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:39::cout:61 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:43::cout:61 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:47::cout:61 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:35::cout:74 [ exec::i#2 exec::out#1 line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:39::cout:74 [ exec::i#2 exec::out#1 line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:43::cout:74 [ exec::i#2 exec::out#1 line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:47::cout:74 [ exec::i#2 exec::out#1 line idx#27 ] { { idx#0 = idx#27 } }  main:3::print:50::cout:79 [ main::i#2 print::i#2 line idx#27 ] { { print::i#0 = print::i#2 } { idx#27 = idx#53 idx#54 } { cout::c#0 = cout::c#7 } }  main:3::exec:35::print:72::cout:79 [ exec::i#2 exec::out#1 print::i#2 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:39::print:72::cout:79 [ exec::i#2 exec::out#1 print::i#2 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:43::print:72::cout:79 [ exec::i#2 exec::out#1 print::i#2 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:47::print:72::cout:79 [ exec::i#2 exec::out#1 print::i#2 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::print:50::cout:82 [ main::i#2 line idx#27 ] { { print::i#0 = print::i#2 } { idx#53 = idx#54 } { cout::c#1 = cout::c#7 } { idx#0 = idx#27 } }  main:3::exec:35::print:72::cout:82 [ exec::i#2 exec::out#1 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:39::print:72::cout:82 [ exec::i#2 exec::out#1 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:43::print:72::cout:82 [ exec::i#2 exec::out#1 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:47::print:72::cout:82 [ exec::i#2 exec::out#1 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:4 [ main::i#2 main::i#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:8 [ exec::out#2 exec::out#0 exec::out#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:9 [ print::i#2 print::i#1 print::i#0 ]
Statement [1] line = (byte*) 1024 [ line ] (  [ line ] { }  ) always clobbers reg byte a 
Statement [5] xor::a#0 = stackidx(byte,xor::OFFSET_STACK_A) [ xor::a#0 ] (  [ xor::a#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [6] xor::b#0 = stackidx(byte,xor::OFFSET_STACK_B) [ xor::a#0 xor::b#0 ] (  [ xor::a#0 xor::b#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [7] xor::return#0 = xor::a#0 ^ xor::b#0 [ xor::return#0 ] (  [ xor::return#0 ] { }  ) always clobbers reg byte a 
Statement [8] stackidx(byte,xor::OFFSET_STACK_RETURN_1) = xor::return#0 [ ] (  [ ] { }  ) always clobbers reg byte x 
Statement [10] min::a#0 = stackidx(byte,min::OFFSET_STACK_A) [ min::a#0 ] (  [ min::a#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [11] min::b#0 = stackidx(byte,min::OFFSET_STACK_B) [ min::a#0 min::b#0 ] (  [ min::a#0 min::b#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [15] stackidx(byte,min::OFFSET_STACK_RETURN_1) = min::return#2 [ ] (  [ ] { }  ) always clobbers reg byte x 
Statement [17] max::a#0 = stackidx(byte,max::OFFSET_STACK_A) [ max::a#0 ] (  [ max::a#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [18] max::b#0 = stackidx(byte,max::OFFSET_STACK_B) [ max::a#0 max::b#0 ] (  [ max::a#0 max::b#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [22] stackidx(byte,max::OFFSET_STACK_RETURN_1) = max::return#2 [ ] (  [ ] { }  ) always clobbers reg byte x 
Statement [24] sum::a#0 = stackidx(byte,sum::OFFSET_STACK_A) [ sum::a#0 ] (  [ sum::a#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [25] sum::b#0 = stackidx(byte,sum::OFFSET_STACK_B) [ sum::a#0 sum::b#0 ] (  [ sum::a#0 sum::b#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [26] sum::return#0 = sum::a#0 + sum::b#0 [ sum::return#0 ] (  [ sum::return#0 ] { }  ) always clobbers reg byte a 
Statement [27] stackidx(byte,sum::OFFSET_STACK_RETURN_1) = sum::return#0 [ ] (  [ ] { }  ) always clobbers reg byte x 
Statement [54] line = line + $28 [ line ] ( main:3::ln:33 [ line ] { }  main:3::ln:37 [ line ] { }  main:3::ln:41 [ line ] { }  main:3::ln:45 [ line ] { }  ) always clobbers reg byte a 
Statement [64] if(exec::i#2<6*SIZEOF_BYTE) goto exec::@2 [ line exec::i#2 exec::out#2 ] ( main:3::exec:35 [ line exec::i#2 exec::out#2 ] { }  main:3::exec:39 [ line exec::i#2 exec::out#2 ] { }  main:3::exec:43 [ line exec::i#2 exec::out#2 ] { }  main:3::exec:47 [ line exec::i#2 exec::out#2 ] { }  ) always clobbers reg byte a 
Statement [66] stackpush(byte) = exec::out#2 [ exec::i#2 ] ( main:3::exec:35 [ exec::i#2 ] { }  main:3::exec:39 [ exec::i#2 ] { }  main:3::exec:43 [ exec::i#2 ] { }  main:3::exec:47 [ exec::i#2 ] { }  ) always clobbers reg byte a 
Statement [67] stackpush(byte) = INPUT[exec::i#2] [ ] ( main:3::exec:35 [ ] { }  main:3::exec:39 [ ] { }  main:3::exec:43 [ ] { }  main:3::exec:47 [ ] { }  ) always clobbers reg byte a reg byte y 
Statement [68] callexecute *exec::collect#10  [ line idx#0 exec::i#2 ] ( main:3::exec:35 [ line idx#0 exec::i#2 ] { }  main:3::exec:39 [ line idx#0 exec::i#2 ] { }  main:3::exec:43 [ line idx#0 exec::i#2 ] { }  main:3::exec:47 [ line idx#0 exec::i#2 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement sideeffect stackpullbytes(1) always clobbers reg byte a 
Statement [70] exec::out#1 = stackpull(byte) [ line idx#0 exec::i#2 exec::out#1 ] ( main:3::exec:35 [ line idx#0 exec::i#2 exec::out#1 ] { }  main:3::exec:39 [ line idx#0 exec::i#2 exec::out#1 ] { }  main:3::exec:43 [ line idx#0 exec::i#2 exec::out#1 ] { }  main:3::exec:47 [ line idx#0 exec::i#2 exec::out#1 ] { }  ) always clobbers reg byte a 
Statement [77] print::$0 = print::i#2 >> 4 [ line print::i#2 idx#53 print::$0 ] ( main:3::print:50 [ main::i#2 line print::i#2 idx#53 print::$0 ] { { print::i#0 = print::i#2 } { idx#27 = idx#53 idx#54 } { cout::c#0 = cout::c#7 } }  main:3::exec:35::print:72 [ exec::i#2 exec::out#1 line print::i#2 idx#53 print::$0 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:39::print:72 [ exec::i#2 exec::out#1 line print::i#2 idx#53 print::$0 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:43::print:72 [ exec::i#2 exec::out#1 line print::i#2 idx#53 print::$0 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:47::print:72 [ exec::i#2 exec::out#1 line print::i#2 idx#53 print::$0 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  ) always clobbers reg byte a 
Statement [80] print::$2 = print::i#2 & $f [ line idx#0 print::$2 ] ( main:3::print:50 [ main::i#2 line idx#0 print::$2 ] { { print::i#0 = print::i#2 } { idx#53 = idx#54 } { cout::c#1 = cout::c#7 } { idx#0 = idx#27 } }  main:3::exec:35::print:72 [ exec::i#2 exec::out#1 line idx#0 print::$2 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:39::print:72 [ exec::i#2 exec::out#1 line idx#0 print::$2 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:43::print:72 [ exec::i#2 exec::out#1 line idx#0 print::$2 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:47::print:72 [ exec::i#2 exec::out#1 line idx#0 print::$2 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  ) always clobbers reg byte a 
Statement [85] line[idx#27] = cout::c#7 [ line idx#27 ] ( main:3::cout:52 [ main::i#2 line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:35::cout:57 [ line idx#27 ] { }  main:3::exec:39::cout:57 [ line idx#27 ] { }  main:3::exec:43::cout:57 [ line idx#27 ] { }  main:3::exec:47::cout:57 [ line idx#27 ] { }  main:3::exec:35::cout:59 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:39::cout:59 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:43::cout:59 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:47::cout:59 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:35::cout:61 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:39::cout:61 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:43::cout:61 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:47::cout:61 [ line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:35::cout:74 [ exec::i#2 exec::out#1 line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:39::cout:74 [ exec::i#2 exec::out#1 line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:43::cout:74 [ exec::i#2 exec::out#1 line idx#27 ] { { idx#0 = idx#27 } }  main:3::exec:47::cout:74 [ exec::i#2 exec::out#1 line idx#27 ] { { idx#0 = idx#27 } }  main:3::print:50::cout:79 [ main::i#2 print::i#2 line idx#27 ] { { print::i#0 = print::i#2 } { idx#27 = idx#53 idx#54 } { cout::c#0 = cout::c#7 } }  main:3::exec:35::print:72::cout:79 [ exec::i#2 exec::out#1 print::i#2 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:39::print:72::cout:79 [ exec::i#2 exec::out#1 print::i#2 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:43::print:72::cout:79 [ exec::i#2 exec::out#1 print::i#2 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::exec:47::print:72::cout:79 [ exec::i#2 exec::out#1 print::i#2 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#0 = cout::c#7 } }  main:3::print:50::cout:82 [ main::i#2 line idx#27 ] { { print::i#0 = print::i#2 } { idx#53 = idx#54 } { cout::c#1 = cout::c#7 } { idx#0 = idx#27 } }  main:3::exec:35::print:72::cout:82 [ exec::i#2 exec::out#1 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:39::print:72::cout:82 [ exec::i#2 exec::out#1 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:43::print:72::cout:82 [ exec::i#2 exec::out#1 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  main:3::exec:47::print:72::cout:82 [ exec::i#2 exec::out#1 line idx#27 ] { { print::i#1 = print::i#2 exec::out#1 } { idx#0 = idx#53 idx#27 } { cout::c#1 = cout::c#7 } }  ) always clobbers reg byte y 
Potential registers zp[1]:2 [ min::return#2 min::return#4 min::b#0 ] : zp[1]:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ max::return#2 max::return#4 max::b#0 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ main::i#2 main::i#1 ] : zp[1]:4 , reg byte x , 
Potential registers zp[2]:5 [ exec::collect#10 ] : zp[2]:5 , 
Potential registers zp[1]:7 [ exec::i#2 exec::i#1 ] : zp[1]:7 , 
Potential registers zp[1]:8 [ exec::out#2 exec::out#0 exec::out#1 ] : zp[1]:8 , reg byte x , 
Potential registers zp[1]:9 [ print::i#2 print::i#1 print::i#0 ] : zp[1]:9 , reg byte x , 
Potential registers zp[1]:10 [ cout::c#7 cout::c#0 cout::c#1 ] : zp[1]:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ idx#27 idx#53 idx#54 idx#0 ] : zp[1]:11 , 
Potential registers zp[2]:12 [ line ] : zp[2]:12 , 
Potential registers zp[1]:14 [ xor::a#0 ] : zp[1]:14 , reg byte y , 
Potential registers zp[1]:15 [ xor::b#0 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ xor::return#0 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ min::a#0 ] : zp[1]:17 , reg byte y , 
Potential registers zp[1]:18 [ max::a#0 ] : zp[1]:18 , reg byte y , 
Potential registers zp[1]:19 [ sum::a#0 ] : zp[1]:19 , reg byte y , 
Potential registers zp[1]:20 [ sum::b#0 ] : zp[1]:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:21 [ sum::return#0 ] : zp[1]:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:22 [ print::$0 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:23 [ print::$2 ] : zp[1]:23 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [cout] 160,007: zp[1]:10 [ cout::c#7 cout::c#0 cout::c#1 ] 
Uplift Scope [] 119,775.1: zp[1]:11 [ idx#27 idx#53 idx#54 idx#0 ] 1,757.98: zp[2]:12 [ line ] 
Uplift Scope [print] 20,002: zp[1]:22 [ print::$0 ] 20,002: zp[1]:23 [ print::$2 ] 7,480: zp[1]:9 [ print::i#2 print::i#1 print::i#0 ] 
Uplift Scope [exec] 2,402.4: zp[1]:7 [ exec::i#2 exec::i#1 ] 1,754: zp[1]:8 [ exec::out#2 exec::out#0 exec::out#1 ] 0: zp[2]:5 [ exec::collect#10 ] 
Uplift Scope [main] 269.33: zp[1]:4 [ main::i#2 main::i#1 ] 
Uplift Scope [max] 13: zp[1]:3 [ max::return#2 max::return#4 max::b#0 ] 2: zp[1]:18 [ max::a#0 ] 
Uplift Scope [min] 13: zp[1]:2 [ min::return#2 min::return#4 min::b#0 ] 2: zp[1]:17 [ min::a#0 ] 
Uplift Scope [sum] 4: zp[1]:20 [ sum::b#0 ] 4: zp[1]:21 [ sum::return#0 ] 2: zp[1]:19 [ sum::a#0 ] 
Uplift Scope [xor] 4: zp[1]:15 [ xor::b#0 ] 4: zp[1]:16 [ xor::return#0 ] 2: zp[1]:14 [ xor::a#0 ] 
Uplift Scope [ln] 
Uplift Scope [__start] 

Uplifting [cout] best 1767 combination reg byte x [ cout::c#7 cout::c#0 cout::c#1 ] 
Uplifting [] best 1767 combination zp[1]:11 [ idx#27 idx#53 idx#54 idx#0 ] zp[2]:12 [ line ] 
Uplifting [print] best 1759 combination reg byte a [ print::$0 ] reg byte a [ print::$2 ] zp[1]:9 [ print::i#2 print::i#1 print::i#0 ] 
Uplifting [exec] best 1759 combination zp[1]:7 [ exec::i#2 exec::i#1 ] zp[1]:8 [ exec::out#2 exec::out#0 exec::out#1 ] zp[2]:5 [ exec::collect#10 ] 
Uplifting [main] best 1759 combination zp[1]:4 [ main::i#2 main::i#1 ] 
Uplifting [max] best 1747 combination reg byte a [ max::return#2 max::return#4 max::b#0 ] zp[1]:18 [ max::a#0 ] 
Uplifting [min] best 1736 combination reg byte a [ min::return#2 min::return#4 min::b#0 ] reg byte y [ min::a#0 ] 
Uplifting [sum] best 1724 combination reg byte a [ sum::b#0 ] reg byte a [ sum::return#0 ] zp[1]:19 [ sum::a#0 ] 
Uplifting [xor] best 1712 combination reg byte a [ xor::b#0 ] reg byte a [ xor::return#0 ] zp[1]:14 [ xor::a#0 ] 
Uplifting [ln] best 1712 combination 
Uplifting [__start] best 1712 combination 
Attempting to uplift remaining variables inzp[1]:11 [ idx#27 idx#53 idx#54 idx#0 ]
Uplifting [] best 1712 combination zp[1]:11 [ idx#27 idx#53 idx#54 idx#0 ] 
Attempting to uplift remaining variables inzp[1]:9 [ print::i#2 print::i#1 print::i#0 ]
Uplifting [print] best 1712 combination zp[1]:9 [ print::i#2 print::i#1 print::i#0 ] 
Attempting to uplift remaining variables inzp[1]:7 [ exec::i#2 exec::i#1 ]
Uplifting [exec] best 1712 combination zp[1]:7 [ exec::i#2 exec::i#1 ] 
Attempting to uplift remaining variables inzp[1]:8 [ exec::out#2 exec::out#0 exec::out#1 ]
Uplifting [exec] best 1712 combination zp[1]:8 [ exec::out#2 exec::out#0 exec::out#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ main::i#2 main::i#1 ]
Uplifting [main] best 1712 combination zp[1]:4 [ main::i#2 main::i#1 ] 
Attempting to uplift remaining variables inzp[1]:14 [ xor::a#0 ]
Uplifting [xor] best 1712 combination zp[1]:14 [ xor::a#0 ] 
Attempting to uplift remaining variables inzp[1]:18 [ max::a#0 ]
Uplifting [max] best 1712 combination zp[1]:18 [ max::a#0 ] 
Attempting to uplift remaining variables inzp[1]:19 [ sum::a#0 ]
Uplifting [sum] best 1712 combination zp[1]:19 [ sum::a#0 ] 
Coalescing zero page register [ zp[1]:8 [ exec::out#2 exec::out#0 exec::out#1 ] ] with [ zp[1]:9 [ print::i#2 print::i#1 print::i#0 ] ] - score: 1
Allocated (was zp[1]:4) zp[1]:2 [ main::i#2 main::i#1 ]
Allocated (was zp[2]:5) zp[2]:3 [ exec::collect#10 ]
Allocated (was zp[1]:7) zp[1]:5 [ exec::i#2 exec::i#1 ]
Allocated (was zp[1]:8) zp[1]:6 [ exec::out#2 exec::out#0 exec::out#1 print::i#2 print::i#1 print::i#0 ]
Allocated (was zp[1]:11) zp[1]:7 [ idx#27 idx#53 idx#54 idx#0 ]
Allocated (was zp[2]:12) zp[2]:8 [ line ]
Allocated (was zp[1]:14) zp[1]:10 [ xor::a#0 ]
Allocated (was zp[1]:18) zp[1]:11 [ max::a#0 ]
Allocated (was zp[1]:19) zp[1]:12 [ sum::a#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests calling advanced functions pointers (with multiple parameters and a return value)
  // Upstart
  // Commodore 64 PRG executable file
.file [name="function-pointer-advanced-1.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
  // Global Constants & labels
  .const STACK_BASE = $103
  .const SIZEOF_BYTE = 1
  .label line = 8
  .label idx = 7
.segment Code
  // __start
__start: {
    jmp __init1
    // __start::__init1
  __init1:
    // [1] line = (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z line
    lda #>$400
    sta.z line+1
    // [2] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
  __b1_from___init1:
    jmp __b1
    // __start::@1
  __b1:
    // [3] call main 
    // [29] phi from __start::@1 to main [phi:__start::@1->main]
  main_from___b1:
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [4] return 
    rts
}
  // xor
// xor(byte zp($a) a, byte register(A) b)
xor: {
    .const OFFSET_STACK_A = 1
    .const OFFSET_STACK_B = 0
    .const OFFSET_STACK_RETURN_1 = 1
    .label a = $a
    // [5] xor::a#0 = stackidx(byte,xor::OFFSET_STACK_A) -- vbuz1=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_A,x
    sta.z a
    // [6] xor::b#0 = stackidx(byte,xor::OFFSET_STACK_B) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_B,x
    // [7] xor::return#0 = xor::a#0 ^ xor::b#0 -- vbuaa=vbuz1_bxor_vbuaa 
    eor.z a
    jmp __breturn
    // xor::@return
  __breturn:
    // [8] stackidx(byte,xor::OFFSET_STACK_RETURN_1) = xor::return#0 -- _stackidxbyte_vbuc1=vbuaa 
    tsx
    sta STACK_BASE+OFFSET_STACK_RETURN_1,x
    // [9] return 
    rts
}
  // min
// min(byte register(Y) a, byte register(A) b)
min: {
    .const OFFSET_STACK_A = 1
    .const OFFSET_STACK_B = 0
    .const OFFSET_STACK_RETURN_1 = 1
    // [10] min::a#0 = stackidx(byte,min::OFFSET_STACK_A) -- vbuyy=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_A,x
    tay
    // [11] min::b#0 = stackidx(byte,min::OFFSET_STACK_B) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_B,x
    // [12] if(min::a#0<min::b#0) goto min::@1 -- vbuyy_lt_vbuaa_then_la1 
    sta.z $ff
    cpy.z $ff
    bcc __b1
    // [14] phi from min min::@1 to min::@return [phi:min/min::@1->min::@return]
  __breturn_from_min:
  __breturn_from___b1:
    // [14] phi min::return#2 = min::b#0 [phi:min/min::@1->min::@return#0] -- register_copy 
    jmp __breturn
    // min::@1
  __b1:
    // [13] min::return#4 = min::a#0 -- vbuaa=vbuyy 
    tya
    jmp __breturn_from___b1
    // min::@return
  __breturn:
    // [15] stackidx(byte,min::OFFSET_STACK_RETURN_1) = min::return#2 -- _stackidxbyte_vbuc1=vbuaa 
    tsx
    sta STACK_BASE+OFFSET_STACK_RETURN_1,x
    // [16] return 
    rts
}
  // max
// max(byte zp($b) a, byte register(A) b)
max: {
    .const OFFSET_STACK_A = 1
    .const OFFSET_STACK_B = 0
    .const OFFSET_STACK_RETURN_1 = 1
    .label a = $b
    // [17] max::a#0 = stackidx(byte,max::OFFSET_STACK_A) -- vbuz1=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_A,x
    sta.z a
    // [18] max::b#0 = stackidx(byte,max::OFFSET_STACK_B) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_B,x
    // [19] if(max::a#0>max::b#0) goto max::@1 -- vbuz1_gt_vbuaa_then_la1 
    cmp.z a
    bcc __b1
    // [21] phi from max max::@1 to max::@return [phi:max/max::@1->max::@return]
  __breturn_from_max:
  __breturn_from___b1:
    // [21] phi max::return#2 = max::b#0 [phi:max/max::@1->max::@return#0] -- register_copy 
    jmp __breturn
    // max::@1
  __b1:
    // [20] max::return#4 = max::a#0 -- vbuaa=vbuz1 
    lda.z a
    jmp __breturn_from___b1
    // max::@return
  __breturn:
    // [22] stackidx(byte,max::OFFSET_STACK_RETURN_1) = max::return#2 -- _stackidxbyte_vbuc1=vbuaa 
    tsx
    sta STACK_BASE+OFFSET_STACK_RETURN_1,x
    // [23] return 
    rts
}
  // sum
// sum(byte zp($c) a, byte register(A) b)
sum: {
    .const OFFSET_STACK_A = 1
    .const OFFSET_STACK_B = 0
    .const OFFSET_STACK_RETURN_1 = 1
    .label a = $c
    // [24] sum::a#0 = stackidx(byte,sum::OFFSET_STACK_A) -- vbuz1=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_A,x
    sta.z a
    // [25] sum::b#0 = stackidx(byte,sum::OFFSET_STACK_B) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_B,x
    // [26] sum::return#0 = sum::a#0 + sum::b#0 -- vbuaa=vbuz1_plus_vbuaa 
    clc
    adc.z a
    jmp __breturn
    // sum::@return
  __breturn:
    // [27] stackidx(byte,sum::OFFSET_STACK_RETURN_1) = sum::return#0 -- _stackidxbyte_vbuc1=vbuaa 
    tsx
    sta STACK_BASE+OFFSET_STACK_RETURN_1,x
    // [28] return 
    rts
}
  // main
main: {
    .label i = 2
    // [30] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [30] phi idx#54 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [30] phi main::i#2 = 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // main::@1
  __b1:
    // [31] if(main::i#2<6*SIZEOF_BYTE) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #6*SIZEOF_BYTE
    bcc __b2
    // [32] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [33] call ln 
    jsr ln
    // [34] phi from main::@3 to main::@6 [phi:main::@3->main::@6]
  __b6_from___b3:
    jmp __b6
    // main::@6
  __b6:
    // [35] call exec 
    // [56] phi from main::@6 to exec [phi:main::@6->exec]
  exec_from___b6:
    // [56] phi exec::collect#10 = &sum [phi:main::@6->exec#0] -- pprz1=pprc1 
    lda #<sum
    sta.z exec.collect
    lda #>sum
    sta.z exec.collect+1
    jsr exec
    // [36] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  __b7_from___b6:
    jmp __b7
    // main::@7
  __b7:
    // [37] call ln 
    jsr ln
    // [38] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  __b8_from___b7:
    jmp __b8
    // main::@8
  __b8:
    // [39] call exec 
    // [56] phi from main::@8 to exec [phi:main::@8->exec]
  exec_from___b8:
    // [56] phi exec::collect#10 = &min [phi:main::@8->exec#0] -- pprz1=pprc1 
    lda #<min
    sta.z exec.collect
    lda #>min
    sta.z exec.collect+1
    jsr exec
    // [40] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
  __b9_from___b8:
    jmp __b9
    // main::@9
  __b9:
    // [41] call ln 
    jsr ln
    // [42] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  __b10_from___b9:
    jmp __b10
    // main::@10
  __b10:
    // [43] call exec 
    // [56] phi from main::@10 to exec [phi:main::@10->exec]
  exec_from___b10:
    // [56] phi exec::collect#10 = &max [phi:main::@10->exec#0] -- pprz1=pprc1 
    lda #<max
    sta.z exec.collect
    lda #>max
    sta.z exec.collect+1
    jsr exec
    // [44] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  __b11_from___b10:
    jmp __b11
    // main::@11
  __b11:
    // [45] call ln 
    jsr ln
    // [46] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  __b12_from___b11:
    jmp __b12
    // main::@12
  __b12:
    // [47] call exec 
    // [56] phi from main::@12 to exec [phi:main::@12->exec]
  exec_from___b12:
    // [56] phi exec::collect#10 = &xor [phi:main::@12->exec#0] -- pprz1=pprc1 
    lda #<xor
    sta.z exec.collect
    lda #>xor
    sta.z exec.collect+1
    jsr exec
    jmp __breturn
    // main::@return
  __breturn:
    // [48] return 
    rts
    // main::@2
  __b2:
    // [49] print::i#0 = INPUT[main::i#2] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z i
    lda INPUT,y
    sta.z print.i
    // [50] call print 
    // [76] phi from main::@2 to print [phi:main::@2->print]
  print_from___b2:
    // [76] phi idx#53 = idx#54 [phi:main::@2->print#0] -- register_copy 
    // [76] phi print::i#2 = print::i#0 [phi:main::@2->print#1] -- register_copy 
    jsr print
    // [51] phi from main::@2 to main::@4 [phi:main::@2->main::@4]
  __b4_from___b2:
    jmp __b4
    // main::@4
  __b4:
    // [52] call cout 
    // [84] phi from main::@4 to cout [phi:main::@4->cout]
  cout_from___b4:
    // [84] phi idx#27 = idx#0 [phi:main::@4->cout#0] -- register_copy 
    // [84] phi cout::c#7 = ' ' [phi:main::@4->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    jmp __b5
    // main::@5
  __b5:
    // [53] main::i#1 = ++ main::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [30] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  __b1_from___b5:
    // [30] phi idx#54 = idx#0 [phi:main::@5->main::@1#0] -- register_copy 
    // [30] phi main::i#2 = main::i#1 [phi:main::@5->main::@1#1] -- register_copy 
    jmp __b1
}
  // ln
ln: {
    // [54] line = line + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z line
    sta.z line
    bcc !+
    inc.z line+1
  !:
    jmp __breturn
    // ln::@return
  __breturn:
    // [55] return 
    rts
}
  // exec
// exec(byte(byte,byte)* zp(3) collect)
exec: {
    .label out = 6
    .label i = 5
    .label collect = 3
    // [57] call cout 
    // [84] phi from exec to cout [phi:exec->cout]
  cout_from_exec:
    // [84] phi idx#27 = 0 [phi:exec->cout#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [84] phi cout::c#7 = ' ' [phi:exec->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    // [58] phi from exec to exec::@4 [phi:exec->exec::@4]
  __b4_from_exec:
    jmp __b4
    // exec::@4
  __b4:
    // [59] call cout 
    // [84] phi from exec::@4 to cout [phi:exec::@4->cout]
  cout_from___b4:
    // [84] phi idx#27 = idx#0 [phi:exec::@4->cout#0] -- register_copy 
    // [84] phi cout::c#7 = ' ' [phi:exec::@4->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    // [60] phi from exec::@4 to exec::@5 [phi:exec::@4->exec::@5]
  __b5_from___b4:
    jmp __b5
    // exec::@5
  __b5:
    // [61] call cout 
    // [84] phi from exec::@5 to cout [phi:exec::@5->cout]
  cout_from___b5:
    // [84] phi idx#27 = idx#0 [phi:exec::@5->cout#0] -- register_copy 
    // [84] phi cout::c#7 = ' ' [phi:exec::@5->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    jmp __b6
    // exec::@6
  __b6:
    // [62] exec::out#0 = *INPUT -- vbuz1=_deref_pbuc1 
    lda INPUT
    sta.z out
    // [63] phi from exec::@6 to exec::@1 [phi:exec::@6->exec::@1]
  __b1_from___b6:
    // [63] phi exec::out#2 = exec::out#0 [phi:exec::@6->exec::@1#0] -- register_copy 
    // [63] phi exec::i#2 = 1 [phi:exec::@6->exec::@1#1] -- vbuz1=vbuc1 
    lda #1
    sta.z i
    jmp __b1
    // exec::@1
  __b1:
    // [64] if(exec::i#2<6*SIZEOF_BYTE) goto exec::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #6*SIZEOF_BYTE
    bcc __b2
    jmp __breturn
    // exec::@return
  __breturn:
    // [65] return 
    rts
    // exec::@2
  __b2:
    // [66] stackpush(byte) = exec::out#2 -- _stackpushbyte_=vbuz1 
    lda.z out
    pha
    // [67] stackpush(byte) = INPUT[exec::i#2] -- _stackpushbyte_=pbuc1_derefidx_vbuz1 
    ldy.z i
    lda INPUT,y
    pha
    // [68] callexecute *exec::collect#10 
    jsr bi_collect
    // sideeffect stackpullbytes(1) -- _stackpullbyte_1 
    pla
    // [70] exec::out#1 = stackpull(byte) -- vbuz1=_stackpullbyte_ 
    pla
    sta.z out
    jmp __b3
    // exec::@3
  __b3:
    // [71] print::i#1 = exec::out#1
    // [72] call print 
    // [76] phi from exec::@3 to print [phi:exec::@3->print]
  print_from___b3:
    // [76] phi idx#53 = idx#0 [phi:exec::@3->print#0] -- register_copy 
    // [76] phi print::i#2 = print::i#1 [phi:exec::@3->print#1] -- register_copy 
    jsr print
    // [73] phi from exec::@3 to exec::@7 [phi:exec::@3->exec::@7]
  __b7_from___b3:
    jmp __b7
    // exec::@7
  __b7:
    // [74] call cout 
    // [84] phi from exec::@7 to cout [phi:exec::@7->cout]
  cout_from___b7:
    // [84] phi idx#27 = idx#0 [phi:exec::@7->cout#0] -- register_copy 
    // [84] phi cout::c#7 = ' ' [phi:exec::@7->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    jmp __b8
    // exec::@8
  __b8:
    // [75] exec::i#1 = ++ exec::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [63] phi from exec::@8 to exec::@1 [phi:exec::@8->exec::@1]
  __b1_from___b8:
    // [63] phi exec::out#2 = exec::out#1 [phi:exec::@8->exec::@1#0] -- register_copy 
    // [63] phi exec::i#2 = exec::i#1 [phi:exec::@8->exec::@1#1] -- register_copy 
    jmp __b1
  bi_collect:
    jmp (collect)
}
  // print
// print(byte zp(6) i)
print: {
    .label i = 6
    // [77] print::$0 = print::i#2 >> 4 -- vbuaa=vbuz1_ror_4 
    lda.z i
    lsr
    lsr
    lsr
    lsr
    // [78] cout::c#0 = HEX[print::$0] -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx HEX,y
    // [79] call cout 
    // [84] phi from print to cout [phi:print->cout]
  cout_from_print:
    // [84] phi idx#27 = idx#53 [phi:print->cout#0] -- register_copy 
    // [84] phi cout::c#7 = cout::c#0 [phi:print->cout#1] -- register_copy 
    jsr cout
    jmp __b1
    // print::@1
  __b1:
    // [80] print::$2 = print::i#2 & $f -- vbuaa=vbuz1_band_vbuc1 
    lda #$f
    and.z i
    // [81] cout::c#1 = HEX[print::$2] -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx HEX,y
    // [82] call cout 
    // [84] phi from print::@1 to cout [phi:print::@1->cout]
  cout_from___b1:
    // [84] phi idx#27 = idx#0 [phi:print::@1->cout#0] -- register_copy 
    // [84] phi cout::c#7 = cout::c#1 [phi:print::@1->cout#1] -- register_copy 
    jsr cout
    jmp __breturn
    // print::@return
  __breturn:
    // [83] return 
    rts
}
  // cout
// cout(byte register(X) c)
cout: {
    // [85] line[idx#27] = cout::c#7 -- pbuz1_derefidx_vbuz2=vbuxx 
    ldy.z idx
    txa
    sta (line),y
    // [86] idx#0 = ++ idx#27 -- vbuz1=_inc_vbuz1 
    inc.z idx
    jmp __breturn
    // cout::@return
  __breturn:
    // [87] return 
    rts
}
  // File Data
.segment Data
  INPUT: .byte 2, 1, 3, 4, 6, 5
  HEX: .text "0123456789abcdef"
  .byte 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __init1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __breturn
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __breturn_from___b1 with __breturn_from_min
Replacing label __breturn_from___b1 with __breturn_from_max
Removing instruction __b1_from___init1:
Removing instruction main_from___b1:
Removing instruction __breturn_from___b1:
Removing instruction __breturn_from___b1:
Removing instruction __b3_from___b1:
Removing instruction __b6_from___b3:
Removing instruction exec_from___b6:
Removing instruction __b7_from___b6:
Removing instruction __b8_from___b7:
Removing instruction exec_from___b8:
Removing instruction __b9_from___b8:
Removing instruction __b10_from___b9:
Removing instruction exec_from___b10:
Removing instruction __b11_from___b10:
Removing instruction __b12_from___b11:
Removing instruction exec_from___b12:
Removing instruction __b4_from___b2:
Removing instruction cout_from___b4:
Removing instruction __b4_from_exec:
Removing instruction cout_from___b4:
Removing instruction __b5_from___b4:
Removing instruction cout_from___b5:
Removing instruction print_from___b3:
Removing instruction __b7_from___b3:
Removing instruction cout_from___b7:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __init1:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __breturn:
Removing instruction print_from___b2:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b1_from___b5:
Removing instruction __breturn:
Removing instruction cout_from_exec:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __b1_from___b6:
Removing instruction __breturn:
Removing instruction __b3:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b1_from___b8:
Removing instruction cout_from_print:
Removing instruction __b1:
Removing instruction cout_from___b1:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Skipping double jump to __breturn in jmp __breturn_from_min
Skipping double jump to __breturn in jmp __breturn_from_max
Succesful ASM optimization Pass5DoubleJumpElimination
Relabelling long label __breturn_from_min to __b2
Relabelling long label __breturn_from_max to __b2
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b2:
Removing instruction __b2:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
constant byte* HEX[]  = "0123456789abcdef"
constant byte* INPUT[]  = { 2, 1, 3, 4, 6, 5 }
constant byte SIZEOF_BYTE = 1
constant word STACK_BASE = $103
void __start()
void cout(byte cout::c)
byte cout::c
byte cout::c#0 reg byte x 20002.0
byte cout::c#1 reg byte x 20002.0
byte cout::c#7 reg byte x 120003.0
void exec(byte(byte,byte)* exec::collect)
byte(byte,byte)* exec::collect
byte(byte,byte)* exec::collect#10 collect zp[2]:3
byte exec::i
byte exec::i#1 i zp[1]:5 2002.0
byte exec::i#2 i zp[1]:5 400.4
byte exec::out
byte exec::out#0 out zp[1]:6 202.0
byte exec::out#1 out zp[1]:6 500.5
byte exec::out#2 out zp[1]:6 1051.5
byte idx
byte idx#0 idx zp[1]:7 5352.761904761905
byte idx#27 idx zp[1]:7 110654.0
byte idx#53 idx zp[1]:7 3701.0
byte idx#54 idx zp[1]:7 67.33333333333333
byte* line loadstore zp[2]:8 1757.982456140351
void ln()
void main()
byte main::i
byte main::i#1 i zp[1]:2 202.0
byte main::i#2 i zp[1]:2 67.33333333333333
__stackcall byte max(byte max::a , byte max::b)
constant byte max::OFFSET_STACK_A = 1
constant byte max::OFFSET_STACK_B = 0
constant byte max::OFFSET_STACK_RETURN_1 = 1
byte max::a
byte max::a#0 a zp[1]:11 2.0
byte max::b
byte max::b#0 reg byte a 3.0
byte max::return
byte max::return#2 reg byte a 6.0
byte max::return#4 reg byte a 4.0
__stackcall byte min(byte min::a , byte min::b)
constant byte min::OFFSET_STACK_A = 1
constant byte min::OFFSET_STACK_B = 0
constant byte min::OFFSET_STACK_RETURN_1 = 1
byte min::a
byte min::a#0 reg byte y 2.0
byte min::b
byte min::b#0 reg byte a 3.0
byte min::return
byte min::return#2 reg byte a 6.0
byte min::return#4 reg byte a 4.0
void print(byte print::i)
byte~ print::$0 reg byte a 20002.0
byte~ print::$2 reg byte a 20002.0
byte print::i
byte print::i#0 i zp[1]:6 202.0
byte print::i#1 i zp[1]:6 2002.0
byte print::i#2 i zp[1]:6 5276.0
__stackcall byte sum(byte sum::a , byte sum::b)
constant byte sum::OFFSET_STACK_A = 1
constant byte sum::OFFSET_STACK_B = 0
constant byte sum::OFFSET_STACK_RETURN_1 = 1
byte sum::a
byte sum::a#0 a zp[1]:12 2.0
byte sum::b
byte sum::b#0 reg byte a 4.0
byte sum::return
byte sum::return#0 reg byte a 4.0
__stackcall byte xor(byte xor::a , byte xor::b)
constant byte xor::OFFSET_STACK_A = 1
constant byte xor::OFFSET_STACK_B = 0
constant byte xor::OFFSET_STACK_RETURN_1 = 1
byte xor::a
byte xor::a#0 a zp[1]:10 2.0
byte xor::b
byte xor::b#0 reg byte a 4.0
byte xor::return
byte xor::return#0 reg byte a 4.0

reg byte a [ min::return#2 min::return#4 min::b#0 ]
reg byte a [ max::return#2 max::return#4 max::b#0 ]
zp[1]:2 [ main::i#2 main::i#1 ]
zp[2]:3 [ exec::collect#10 ]
zp[1]:5 [ exec::i#2 exec::i#1 ]
zp[1]:6 [ exec::out#2 exec::out#0 exec::out#1 print::i#2 print::i#1 print::i#0 ]
reg byte x [ cout::c#7 cout::c#0 cout::c#1 ]
zp[1]:7 [ idx#27 idx#53 idx#54 idx#0 ]
zp[2]:8 [ line ]
zp[1]:10 [ xor::a#0 ]
reg byte a [ xor::b#0 ]
reg byte a [ xor::return#0 ]
reg byte y [ min::a#0 ]
zp[1]:11 [ max::a#0 ]
zp[1]:12 [ sum::a#0 ]
reg byte a [ sum::b#0 ]
reg byte a [ sum::return#0 ]
reg byte a [ print::$0 ]
reg byte a [ print::$2 ]


FINAL ASSEMBLER
Score: 1350

  // File Comments
// Tests calling advanced functions pointers (with multiple parameters and a return value)
  // Upstart
  // Commodore 64 PRG executable file
.file [name="function-pointer-advanced-1.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
  // Global Constants & labels
  .const STACK_BASE = $103
  .const SIZEOF_BYTE = 1
  .label line = 8
  .label idx = 7
.segment Code
  // __start
__start: {
    // __start::__init1
    // __ma char* line = (char*)0x400
    // [1] line = (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z line
    lda #>$400
    sta.z line+1
    // [2] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
    // __start::@1
    // [3] call main 
    // [29] phi from __start::@1 to main [phi:__start::@1->main]
    jsr main
    // __start::@return
    // [4] return 
    rts
}
  // xor
// xor(byte zp($a) a, byte register(A) b)
xor: {
    .const OFFSET_STACK_A = 1
    .const OFFSET_STACK_B = 0
    .const OFFSET_STACK_RETURN_1 = 1
    .label a = $a
    // [5] xor::a#0 = stackidx(byte,xor::OFFSET_STACK_A) -- vbuz1=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_A,x
    sta.z a
    // [6] xor::b#0 = stackidx(byte,xor::OFFSET_STACK_B) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_B,x
    // a^b
    // [7] xor::return#0 = xor::a#0 ^ xor::b#0 -- vbuaa=vbuz1_bxor_vbuaa 
    eor.z a
    // xor::@return
    // }
    // [8] stackidx(byte,xor::OFFSET_STACK_RETURN_1) = xor::return#0 -- _stackidxbyte_vbuc1=vbuaa 
    tsx
    sta STACK_BASE+OFFSET_STACK_RETURN_1,x
    // [9] return 
    rts
}
  // min
// min(byte register(Y) a, byte register(A) b)
min: {
    .const OFFSET_STACK_A = 1
    .const OFFSET_STACK_B = 0
    .const OFFSET_STACK_RETURN_1 = 1
    // return a;
    // [10] min::a#0 = stackidx(byte,min::OFFSET_STACK_A) -- vbuyy=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_A,x
    tay
    // return b;
    // [11] min::b#0 = stackidx(byte,min::OFFSET_STACK_B) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_B,x
    // if(a<b)
    // [12] if(min::a#0<min::b#0) goto min::@1 -- vbuyy_lt_vbuaa_then_la1 
    sta.z $ff
    cpy.z $ff
    bcc __b1
    // [14] phi from min min::@1 to min::@return [phi:min/min::@1->min::@return]
    // [14] phi min::return#2 = min::b#0 [phi:min/min::@1->min::@return#0] -- register_copy 
    jmp __breturn
    // min::@1
  __b1:
    // [13] min::return#4 = min::a#0 -- vbuaa=vbuyy 
    tya
    // min::@return
  __breturn:
    // }
    // [15] stackidx(byte,min::OFFSET_STACK_RETURN_1) = min::return#2 -- _stackidxbyte_vbuc1=vbuaa 
    tsx
    sta STACK_BASE+OFFSET_STACK_RETURN_1,x
    // [16] return 
    rts
}
  // max
// max(byte zp($b) a, byte register(A) b)
max: {
    .const OFFSET_STACK_A = 1
    .const OFFSET_STACK_B = 0
    .const OFFSET_STACK_RETURN_1 = 1
    .label a = $b
    // return a;
    // [17] max::a#0 = stackidx(byte,max::OFFSET_STACK_A) -- vbuz1=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_A,x
    sta.z a
    // return b;
    // [18] max::b#0 = stackidx(byte,max::OFFSET_STACK_B) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_B,x
    // if(a>b)
    // [19] if(max::a#0>max::b#0) goto max::@1 -- vbuz1_gt_vbuaa_then_la1 
    cmp.z a
    bcc __b1
    // [21] phi from max max::@1 to max::@return [phi:max/max::@1->max::@return]
    // [21] phi max::return#2 = max::b#0 [phi:max/max::@1->max::@return#0] -- register_copy 
    jmp __breturn
    // max::@1
  __b1:
    // [20] max::return#4 = max::a#0 -- vbuaa=vbuz1 
    lda.z a
    // max::@return
  __breturn:
    // }
    // [22] stackidx(byte,max::OFFSET_STACK_RETURN_1) = max::return#2 -- _stackidxbyte_vbuc1=vbuaa 
    tsx
    sta STACK_BASE+OFFSET_STACK_RETURN_1,x
    // [23] return 
    rts
}
  // sum
// sum(byte zp($c) a, byte register(A) b)
sum: {
    .const OFFSET_STACK_A = 1
    .const OFFSET_STACK_B = 0
    .const OFFSET_STACK_RETURN_1 = 1
    .label a = $c
    // [24] sum::a#0 = stackidx(byte,sum::OFFSET_STACK_A) -- vbuz1=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_A,x
    sta.z a
    // [25] sum::b#0 = stackidx(byte,sum::OFFSET_STACK_B) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_B,x
    // a+b
    // [26] sum::return#0 = sum::a#0 + sum::b#0 -- vbuaa=vbuz1_plus_vbuaa 
    clc
    adc.z a
    // sum::@return
    // }
    // [27] stackidx(byte,sum::OFFSET_STACK_RETURN_1) = sum::return#0 -- _stackidxbyte_vbuc1=vbuaa 
    tsx
    sta STACK_BASE+OFFSET_STACK_RETURN_1,x
    // [28] return 
    rts
}
  // main
main: {
    .label i = 2
    // [30] phi from main to main::@1 [phi:main->main::@1]
    // [30] phi idx#54 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [30] phi main::i#2 = 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    sta.z i
    // main::@1
  __b1:
    // for(char i=0;i<sizeof(INPUT);i++)
    // [31] if(main::i#2<6*SIZEOF_BYTE) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #6*SIZEOF_BYTE
    bcc __b2
    // [32] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // main::@3
    // ln()
    // [33] call ln 
    jsr ln
    // [34] phi from main::@3 to main::@6 [phi:main::@3->main::@6]
    // main::@6
    // exec(&sum)
    // [35] call exec 
    // [56] phi from main::@6 to exec [phi:main::@6->exec]
    // [56] phi exec::collect#10 = &sum [phi:main::@6->exec#0] -- pprz1=pprc1 
    lda #<sum
    sta.z exec.collect
    lda #>sum
    sta.z exec.collect+1
    jsr exec
    // [36] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
    // main::@7
    // ln()
    // [37] call ln 
    jsr ln
    // [38] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
    // main::@8
    // exec(&min)
    // [39] call exec 
    // [56] phi from main::@8 to exec [phi:main::@8->exec]
    // [56] phi exec::collect#10 = &min [phi:main::@8->exec#0] -- pprz1=pprc1 
    lda #<min
    sta.z exec.collect
    lda #>min
    sta.z exec.collect+1
    jsr exec
    // [40] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
    // main::@9
    // ln()
    // [41] call ln 
    jsr ln
    // [42] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
    // main::@10
    // exec(&max)
    // [43] call exec 
    // [56] phi from main::@10 to exec [phi:main::@10->exec]
    // [56] phi exec::collect#10 = &max [phi:main::@10->exec#0] -- pprz1=pprc1 
    lda #<max
    sta.z exec.collect
    lda #>max
    sta.z exec.collect+1
    jsr exec
    // [44] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
    // main::@11
    // ln()
    // [45] call ln 
    jsr ln
    // [46] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
    // main::@12
    // exec(&xor)
    // [47] call exec 
    // [56] phi from main::@12 to exec [phi:main::@12->exec]
    // [56] phi exec::collect#10 = &xor [phi:main::@12->exec#0] -- pprz1=pprc1 
    lda #<xor
    sta.z exec.collect
    lda #>xor
    sta.z exec.collect+1
    jsr exec
    // main::@return
    // }
    // [48] return 
    rts
    // main::@2
  __b2:
    // print(INPUT[i])
    // [49] print::i#0 = INPUT[main::i#2] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z i
    lda INPUT,y
    sta.z print.i
    // [50] call print 
    // [76] phi from main::@2 to print [phi:main::@2->print]
    // [76] phi idx#53 = idx#54 [phi:main::@2->print#0] -- register_copy 
    // [76] phi print::i#2 = print::i#0 [phi:main::@2->print#1] -- register_copy 
    jsr print
    // [51] phi from main::@2 to main::@4 [phi:main::@2->main::@4]
    // main::@4
    // cout(' ')
    // [52] call cout 
    // [84] phi from main::@4 to cout [phi:main::@4->cout]
    // [84] phi idx#27 = idx#0 [phi:main::@4->cout#0] -- register_copy 
    // [84] phi cout::c#7 = ' ' [phi:main::@4->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    // main::@5
    // for(char i=0;i<sizeof(INPUT);i++)
    // [53] main::i#1 = ++ main::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [30] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
    // [30] phi idx#54 = idx#0 [phi:main::@5->main::@1#0] -- register_copy 
    // [30] phi main::i#2 = main::i#1 [phi:main::@5->main::@1#1] -- register_copy 
    jmp __b1
}
  // ln
ln: {
    // line += 40
    // [54] line = line + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z line
    sta.z line
    bcc !+
    inc.z line+1
  !:
    // ln::@return
    // }
    // [55] return 
    rts
}
  // exec
// exec(byte(byte,byte)* zp(3) collect)
exec: {
    .label out = 6
    .label i = 5
    .label collect = 3
    // cout(' ')
    // [57] call cout 
    // [84] phi from exec to cout [phi:exec->cout]
    // [84] phi idx#27 = 0 [phi:exec->cout#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [84] phi cout::c#7 = ' ' [phi:exec->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    // [58] phi from exec to exec::@4 [phi:exec->exec::@4]
    // exec::@4
    // cout(' ')
    // [59] call cout 
    // [84] phi from exec::@4 to cout [phi:exec::@4->cout]
    // [84] phi idx#27 = idx#0 [phi:exec::@4->cout#0] -- register_copy 
    // [84] phi cout::c#7 = ' ' [phi:exec::@4->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    // [60] phi from exec::@4 to exec::@5 [phi:exec::@4->exec::@5]
    // exec::@5
    // cout(' ')
    // [61] call cout 
    // [84] phi from exec::@5 to cout [phi:exec::@5->cout]
    // [84] phi idx#27 = idx#0 [phi:exec::@5->cout#0] -- register_copy 
    // [84] phi cout::c#7 = ' ' [phi:exec::@5->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    // exec::@6
    // char out = INPUT[0]
    // [62] exec::out#0 = *INPUT -- vbuz1=_deref_pbuc1 
    lda INPUT
    sta.z out
    // [63] phi from exec::@6 to exec::@1 [phi:exec::@6->exec::@1]
    // [63] phi exec::out#2 = exec::out#0 [phi:exec::@6->exec::@1#0] -- register_copy 
    // [63] phi exec::i#2 = 1 [phi:exec::@6->exec::@1#1] -- vbuz1=vbuc1 
    lda #1
    sta.z i
    // exec::@1
  __b1:
    // for(char i=1;i<sizeof(INPUT);i++)
    // [64] if(exec::i#2<6*SIZEOF_BYTE) goto exec::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #6*SIZEOF_BYTE
    bcc __b2
    // exec::@return
    // }
    // [65] return 
    rts
    // exec::@2
  __b2:
    // (*collect)(out,INPUT[i])
    // [66] stackpush(byte) = exec::out#2 -- _stackpushbyte_=vbuz1 
    lda.z out
    pha
    // [67] stackpush(byte) = INPUT[exec::i#2] -- _stackpushbyte_=pbuc1_derefidx_vbuz1 
    ldy.z i
    lda INPUT,y
    pha
    // [68] callexecute *exec::collect#10 
    jsr bi_collect
    // sideeffect stackpullbytes(1) -- _stackpullbyte_1 
    pla
    // out = (*collect)(out,INPUT[i])
    // [70] exec::out#1 = stackpull(byte) -- vbuz1=_stackpullbyte_ 
    pla
    sta.z out
    // exec::@3
    // print(out)
    // [71] print::i#1 = exec::out#1
    // [72] call print 
    // [76] phi from exec::@3 to print [phi:exec::@3->print]
    // [76] phi idx#53 = idx#0 [phi:exec::@3->print#0] -- register_copy 
    // [76] phi print::i#2 = print::i#1 [phi:exec::@3->print#1] -- register_copy 
    jsr print
    // [73] phi from exec::@3 to exec::@7 [phi:exec::@3->exec::@7]
    // exec::@7
    // cout(' ')
    // [74] call cout 
    // [84] phi from exec::@7 to cout [phi:exec::@7->cout]
    // [84] phi idx#27 = idx#0 [phi:exec::@7->cout#0] -- register_copy 
    // [84] phi cout::c#7 = ' ' [phi:exec::@7->cout#1] -- vbuxx=vbuc1 
    ldx #' '
    jsr cout
    // exec::@8
    // for(char i=1;i<sizeof(INPUT);i++)
    // [75] exec::i#1 = ++ exec::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [63] phi from exec::@8 to exec::@1 [phi:exec::@8->exec::@1]
    // [63] phi exec::out#2 = exec::out#1 [phi:exec::@8->exec::@1#0] -- register_copy 
    // [63] phi exec::i#2 = exec::i#1 [phi:exec::@8->exec::@1#1] -- register_copy 
    jmp __b1
  bi_collect:
    jmp (collect)
}
  // print
// print(byte zp(6) i)
print: {
    .label i = 6
    // i>>4
    // [77] print::$0 = print::i#2 >> 4 -- vbuaa=vbuz1_ror_4 
    lda.z i
    lsr
    lsr
    lsr
    lsr
    // cout(HEX[i>>4])
    // [78] cout::c#0 = HEX[print::$0] -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx HEX,y
    // [79] call cout 
    // [84] phi from print to cout [phi:print->cout]
    // [84] phi idx#27 = idx#53 [phi:print->cout#0] -- register_copy 
    // [84] phi cout::c#7 = cout::c#0 [phi:print->cout#1] -- register_copy 
    jsr cout
    // print::@1
    // i&0x0f
    // [80] print::$2 = print::i#2 & $f -- vbuaa=vbuz1_band_vbuc1 
    lda #$f
    and.z i
    // cout(HEX[i&0x0f])
    // [81] cout::c#1 = HEX[print::$2] -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx HEX,y
    // [82] call cout 
    // [84] phi from print::@1 to cout [phi:print::@1->cout]
    // [84] phi idx#27 = idx#0 [phi:print::@1->cout#0] -- register_copy 
    // [84] phi cout::c#7 = cout::c#1 [phi:print::@1->cout#1] -- register_copy 
    jsr cout
    // print::@return
    // }
    // [83] return 
    rts
}
  // cout
// cout(byte register(X) c)
cout: {
    // line[idx++] = c
    // [85] line[idx#27] = cout::c#7 -- pbuz1_derefidx_vbuz2=vbuxx 
    ldy.z idx
    txa
    sta (line),y
    // line[idx++] = c;
    // [86] idx#0 = ++ idx#27 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // cout::@return
    // }
    // [87] return 
    rts
}
  // File Data
.segment Data
  INPUT: .byte 2, 1, 3, 4, 6, 5
  HEX: .text "0123456789abcdef"
  .byte 0

