// Black Hole at the center of the BASIC screen sucking in letters

import "c64"
import "multiply"

// Address of the screen
const byte* SCREEN = 0x0400;
// Sprite data for the animating sprites
const byte* SPRITE_DATA = 0x2000;

// Copy of the screen used for finding chars to process
byte[1000] SCREEN_COPY;

// Max number of chars processed at once
const byte NUM_PROCESSING = 8;


// Struct holding char being processed
struct ProcessingChar {
    // x-position (0-39)
    byte x;
    // y-position (0-24)
    byte y;
    // squared distance to center (0-569)
    word dist;
};

// Distance value meaning not found
const word NOT_FOUND = 0xffff;

// Struct holding sprite being processed
struct ProcessingSprite {
    // sprite x-position. Fixed point [12.4]. Values (24-336)
    word x;
    // sprite y-position. Fixed point [12.4]. Values (30-228)
    word y;
    // sprite ID (0-7)
    byte id;
    // sprite pointer (0-255)
    byte ptr;
    // status of the processing (0: free, 1: new, 2: processing)
    byte status;
    // Pointer to screen char being processed (used for deletion)
    byte* screenPtr;
};

// Values for ProcessingSprite.status
const byte STATUS_FREE = 0;
const byte STATUS_NEW = 1;
const byte STATUS_PROCESSING = 2;

// Sprites currently being processed in the interrupt
struct ProcessingSprite[NUM_PROCESSING] PROCESSING;

void main() {
    // Init squares table
    initSquareTables();
    // Copy screen to screen copy
    for( byte* src=SCREEN, dst=SCREEN_COPY; src!=SCREEN+1000; src++, dst++) *dst = *src;
    // Init processing array
    for( byte i: 0..NUM_PROCESSING-1 ) PROCESSING[i] = { 0, 0, 0, 0, STATUS_FREE, 0};
    // Init sprites
    initSprites();
    // Set-up raster interrupts
    setupRasterIrq(RASTER_IRQ_TOP, &irqTop);
    // Main loop
    do {
        // Look for the non-space closest to the screen center
        struct ProcessingChar center = getCharToProcess();
        if(center.dist==NOT_FOUND)
            break;
        startProcessing(center);
    } while(true);
    do {
        (*(COLS+999))++;
    } while (true);
}

// Find the non-space char closest to the center of the screen
// If no non-space char is found the distance will be 0xffff
struct ProcessingChar getCharToProcess() {
    struct ProcessingChar closest = { 0, 0, NOT_FOUND };
    byte* screen_line = SCREEN_COPY;
    for( byte y: 0..24) {
        for( byte x: 0..39) {
            if(screen_line[x]!=' ') {
                word dist = SQUARES_X[x]+SQUARES_Y[y];
                if(dist<closest.dist) {
                    // Update closest char
                    closest = { x, y, dist };
                }
            }
        }
        screen_line += 40;
    }
    if(closest.dist != NOT_FOUND) {
        // clear the found char on the screen copy
        *(SCREEN_COPY+(word)closest.y*40+closest.x) = ' ';
    }
    return closest;
}

// Start processing a char - by inserting it into the PROCESSING array
void startProcessing(struct ProcessingChar center) {
    // Busy-wait while finding an empty slot in the PROCESSING array
    byte freeIdx = 0xff;
    do {
        for( byte i: 0..NUM_PROCESSING-1 ) {
            if(PROCESSING[i].status==STATUS_FREE) {
                freeIdx = i;
                break;
            }
        }
    } while (freeIdx==0xff);
    // Found a free sprite
    byte spriteIdx = freeIdx;
    // Copy char into sprite
    byte* screenPtr = SCREEN+(word)center.y*40+center.x;
    byte* spriteData = SPRITE_DATA+(word)spriteIdx*64;
    byte ch = (*screenPtr);
    byte* chargenData = CHARGEN+(word)ch*8;
    asm { sei }
    *PROCPORT = PROCPORT_RAM_CHARROM;
    for( byte i: 0..7) {
        *spriteData = *chargenData;
        spriteData += 3;
        chargenData++;
    }
    *PROCPORT = PROCPORT_RAM_IO;
    asm { cli }
    word spriteX = (BORDER_XPOS_LEFT + (word)center.x*8) << 4;
    word spriteY = (BORDER_YPOS_TOP + (word)center.y*8) << 4;
    byte spritePtr = (byte)(SPRITE_DATA/64)+spriteIdx;
    // Put the sprite into the PROCESSING array
    PROCESSING[spriteIdx] = { spriteX, spriteY, spriteIdx, spritePtr, STATUS_NEW, screenPtr };
}

const word XPOS_LEFTMOST = (word)(BORDER_XPOS_LEFT-8)<<4;
const word YPOS_UPMOST = (word)(BORDER_YPOS_TOP-8)<<4;

// Process any chars in the PROCESSING array
void processChars() {
    byte numActive = 0;
    for( byte i: 0..NUM_PROCESSING-1 ) {
        struct ProcessingSprite* processing = PROCESSING+i;
        byte bitmask = 1<<processing->id;
        if(processing->status!=STATUS_FREE) {
            if(processing->status==STATUS_NEW) {
                // Clear the char on the screen
                *(processing->screenPtr) = ' ';
                // Enable the sprite
                *SPRITES_ENABLE |= bitmask;
                // Set sprite pointer
                *(SCREEN+SPRITE_PTRS+processing->id) = processing->ptr;
                // Set status
                processing->status = STATUS_PROCESSING;
            }
            word xpos = processing->x >> 4;
            // Set sprite position
            if(>xpos) {
                *SPRITES_XMSB |= bitmask;
            } else {
                *SPRITES_XMSB &= 0xff ^ bitmask;
            }
            SPRITES_XPOS[i*2] = (byte)xpos;
            SPRITES_YPOS[i*2] = (byte)(processing->y>>4);

            // Move sprite
            if(processing->x < XPOS_LEFTMOST || processing->y < YPOS_UPMOST) {
                // Set status to FREE
                processing->status = STATUS_FREE;
                // Disable the sprite
                *SPRITES_ENABLE &= 0xff ^ bitmask;
            } else {
                processing->y = processing->y - 16;
                processing->x = processing->x - 16;
            }
            numActive++;
        }
    }
    *(SCREEN+999) = '0'+numActive;
}

// SQUARES_X[i] = (i-20)*(i-20)
word[40] SQUARES_X;
// SQUARES_Y[i] = (i-12)*(i-12)
word[25] SQUARES_Y;

// initialize SQUARES table
void initSquareTables() {
    for(byte x: 0..39) {
        byte x_dist = (x<20)?20-x:x-20;
        SQUARES_X[x] = mul8u(x_dist, x_dist);
    }
    for(byte y: 0..24) {
        byte y_dist = (y<12)?12-y:y-12;
        SQUARES_Y[y] = mul8u(y_dist, y_dist);
    }
}

// Initialize sprites
void initSprites() {
    // Clear sprite data
    for( byte* sp = SPRITE_DATA; sp<SPRITE_DATA+NUM_PROCESSING*64; sp++) *sp = 0;
    // Initialize sprite registers
    for( byte i: 0..7) {
        SPRITES_COLS[i] = LIGHT_BLUE;
    }
    *SPRITES_MC = 0;
    *SPRITES_EXPAND_X = 0;
    *SPRITES_EXPAND_Y = 0;
}

// Setup Raster IRQ
void setupRasterIrq(word raster, void()* irqRoutine) {
    asm { sei }
    // Disable kernal & basic
    *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK;
    *PROCPORT = PROCPORT_RAM_IO;
    // Disable CIA 1 Timer IRQ
    *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR;
    if(raster<0x100) {
        *VIC_CONTROL &=0x7f;
    } else {
        *VIC_CONTROL |=0x80;
    }
    *RASTER = <raster;
    // Enable Raster Interrupt
    *IRQ_ENABLE = IRQ_RASTER;
    // Set the IRQ routine
    *HARDWARE_IRQ = irqRoutine;
    asm { cli }
}

const byte RASTER_IRQ_TOP = 0x30;

// Raster Interrupt at the top of the screen
interrupt(hardware_all) void irqTop() {
    for( byte i: 0..4) {}
    *BORDERCOL = WHITE;
    *BGCOL = WHITE;
    for( byte i: 0..7) {}
    *BORDERCOL = LIGHT_BLUE;
    *BGCOL = BLUE;

    // Trigger IRQ at the middle of the screen
    *RASTER = RASTER_IRQ_MIDDLE;
    *HARDWARE_IRQ = &irqBottom;
    // Acknowledge the IRQ
    *IRQ_STATUS = IRQ_RASTER;
}

const byte RASTER_IRQ_MIDDLE = 0xff;

// Raster Interrupt at the middle of the screen
interrupt(hardware_all) void irqBottom() {
    for( byte i: 0..4) {}
    *BORDERCOL = WHITE;
    *BGCOL = WHITE;
    processChars();
    *BORDERCOL = LIGHT_BLUE;
    *BGCOL = BLUE;

    // Trigger IRQ at the top of the screen
    *RASTER = RASTER_IRQ_TOP;
    *HARDWARE_IRQ = &irqTop;
    // Acknowledge the IRQ
    *IRQ_STATUS = IRQ_RASTER;
}