Resolved forward reference plex_irq to __interrupt(rom_min_c64) void plex_irq()
Inlined call vicSelectGfxBank::$0 = call toDd00(vicSelectGfxBank::gfx)
Inlined call call plexSetScreen(plexInit::screen)
Inlined call call plexFreePrepare
Inlined call call plexFreeAdd(plexShowSprite::ypos)
Inlined call plex_irq::$2 = call plexFreeNextYpos
Inlined call call __init
Eliminating unused variable with no statement plexShowSprite::$0

CONTROL FLOW GRAPH SSA

void plexInit(char *screen)
plexInit: scope:[plexInit]  from init
  plexInit::screen#1 = phi( init/plexInit::screen#0 )
  plexInit::plexSetScreen1_screen#0 = plexInit::screen#1
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  plexInit::plexSetScreen1_screen#1 = phi( plexInit/plexInit::plexSetScreen1_screen#0 )
  plexInit::plexSetScreen1_$0 = plexInit::plexSetScreen1_screen#1 + $3f8
  PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0
  to:plexInit::@2
plexInit::@2: scope:[plexInit]  from plexInit::plexSetScreen1
  plexInit::i#0 = 0
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::@2
  plexInit::i#2 = phi( plexInit::@1/plexInit::i#1, plexInit::@2/plexInit::i#0 )
  PLEX_SORTED_IDX[plexInit::i#2] = plexInit::i#2
  plexInit::i#1 = plexInit::i#2 + rangenext(0,PLEX_COUNT-1)
  plexInit::$1 = plexInit::i#1 != rangelast(0,PLEX_COUNT-1)
  if(plexInit::$1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  return 
  to:@return

void plexSort()
plexSort: scope:[plexSort]  from loop::@5
  plexSort::m#0 = 0
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  plexSort::m#2 = phi( plexSort/plexSort::m#0, plexSort::@2/plexSort::m#1 )
  plexSort::$1 = plexSort::m#2 + 1
  plexSort::nxt_idx#0 = PLEX_SORTED_IDX[plexSort::$1]
  plexSort::nxt_y#0 = PLEX_YPOS[plexSort::nxt_idx#0]
  plexSort::$2 = plexSort::nxt_y#0 < PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]
  plexSort::$3 = ! plexSort::$2
  if(plexSort::$3) goto plexSort::@2
  to:plexSort::@5
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  plexSort::m#3 = phi( plexSort::@1/plexSort::m#2, plexSort::@4/plexSort::m#5 )
  plexSort::m#1 = plexSort::m#3 + rangenext(0,PLEX_COUNT-2)
  plexSort::$8 = plexSort::m#1 != rangelast(0,PLEX_COUNT-2)
  if(plexSort::$8) goto plexSort::@1
  to:plexSort::@6
plexSort::@5: scope:[plexSort]  from plexSort::@1
  plexSort::nxt_idx#3 = phi( plexSort::@1/plexSort::nxt_idx#0 )
  plexSort::nxt_y#2 = phi( plexSort::@1/plexSort::nxt_y#0 )
  plexSort::m#4 = phi( plexSort::@1/plexSort::m#2 )
  plexSort::s#0 = plexSort::m#4
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@3 plexSort::@5
  plexSort::m#6 = phi( plexSort::@3/plexSort::m#6, plexSort::@5/plexSort::m#4 )
  plexSort::nxt_idx#2 = phi( plexSort::@3/plexSort::nxt_idx#2, plexSort::@5/plexSort::nxt_idx#3 )
  plexSort::nxt_y#1 = phi( plexSort::@3/plexSort::nxt_y#1, plexSort::@5/plexSort::nxt_y#2 )
  plexSort::s#3 = phi( plexSort::@3/plexSort::s#1, plexSort::@5/plexSort::s#0 )
  plexSort::$4 = plexSort::s#3 + 1
  PLEX_SORTED_IDX[plexSort::$4] = PLEX_SORTED_IDX[plexSort::s#3]
  plexSort::s#1 = -- plexSort::s#3
  plexSort::$5 = plexSort::s#1 != $ff
  plexSort::$6 = plexSort::nxt_y#1 < PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]
  plexSort::$7 = plexSort::$5 && plexSort::$6
  if(plexSort::$7) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3
  plexSort::m#5 = phi( plexSort::@3/plexSort::m#6 )
  plexSort::nxt_idx#1 = phi( plexSort::@3/plexSort::nxt_idx#2 )
  plexSort::s#4 = phi( plexSort::@3/plexSort::s#1 )
  plexSort::s#2 = ++ plexSort::s#4
  PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#1
  to:plexSort::@2
plexSort::@6: scope:[plexSort]  from plexSort::@2
  plex_show_idx = 0
  plex_sprite_idx = 0
  plex_sprite_msb = 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  plexSort::plexFreePrepare1_s#0 = 0
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  plexSort::plexFreePrepare1_s#2 = phi( plexSort::plexFreePrepare1/plexSort::plexFreePrepare1_s#0, plexSort::plexFreePrepare1_@1/plexSort::plexFreePrepare1_s#1 )
  PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0
  plexSort::plexFreePrepare1_s#1 = plexSort::plexFreePrepare1_s#2 + rangenext(0,7)
  plexSort::plexFreePrepare1_$0 = plexSort::plexFreePrepare1_s#1 != rangelast(0,7)
  if(plexSort::plexFreePrepare1_$0) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  plex_free_next = 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  return 
  to:@return

void plexShowSprite()
plexShowSprite: scope:[plexShowSprite]  from plex_irq::@3
  plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx * 2
  plexShowSprite::ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]]
  SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::ypos#0
  plexShowSprite::plexFreeAdd1_ypos#0 = plexShowSprite::ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  plexShowSprite::plex_sprite_idx2#2 = phi( plexShowSprite/plexShowSprite::plex_sprite_idx2#0 )
  plexShowSprite::plexFreeAdd1_ypos#1 = phi( plexShowSprite/plexShowSprite::plexFreeAdd1_ypos#0 )
  plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#1 + $16
  PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0
  plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1
  plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7
  plex_free_next = plexShowSprite::plexFreeAdd1_$2
  to:plexShowSprite::@5
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  plexShowSprite::plex_sprite_idx2#1 = phi( plexShowSprite::plexFreeAdd1/plexShowSprite::plex_sprite_idx2#2 )
  PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]]
  plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx]
  plexShowSprite::$9 = plexShowSprite::xpos_idx#0 * SIZEOF_UNSIGNED_INT
  SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#1] = (char)PLEX_XPOS[plexShowSprite::$9]
  plexShowSprite::$10 = plexShowSprite::xpos_idx#0 * SIZEOF_UNSIGNED_INT
  plexShowSprite::$2 = byte1  PLEX_XPOS[plexShowSprite::$10]
  plexShowSprite::$3 = plexShowSprite::$2 != 0
  if(plexShowSprite::$3) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@5
  *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb
  to:plexShowSprite::@2
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@5
  plexShowSprite::$8 = $ff ^ plex_sprite_msb
  *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$8
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  plexShowSprite::$4 = plex_sprite_idx + 1
  plexShowSprite::$5 = plexShowSprite::$4 & 7
  plex_sprite_idx = plexShowSprite::$5
  plex_show_idx = ++ plex_show_idx
  plex_sprite_msb = plex_sprite_msb << 1
  plexShowSprite::$6 = plex_sprite_msb == 0
  plexShowSprite::$7 = ! plexShowSprite::$6
  if(plexShowSprite::$7) goto plexShowSprite::@return
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@2
  plex_sprite_msb = 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@4
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  asm { sei  }
  call init
  to:main::@1
main::@1: scope:[main]  from main
  call loop
  to:main::@2
main::@2: scope:[main]  from main::@1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return

void init()
init: scope:[init]  from main
  *D011 = VICII_DEN|VICII_RSEL|3
  plexInit::screen#0 = SCREEN
  call plexInit
  to:init::@5
init::@5: scope:[init]  from init
  init::xp#0 = $20
  init::sx#0 = 0
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@5
  init::xp#2 = phi( init::@1/init::xp#1, init::@5/init::xp#0 )
  init::sx#2 = phi( init::@1/init::sx#1, init::@5/init::sx#0 )
  PLEX_PTR[init::sx#2] = (char)SPRITE/$40
  init::$3 = init::sx#2 * SIZEOF_UNSIGNED_INT
  PLEX_XPOS[init::$3] = init::xp#2
  init::xp#1 = init::xp#2 + 9
  init::sx#1 = init::sx#2 + rangenext(0,PLEX_COUNT-1)
  init::$1 = init::sx#1 != rangelast(0,PLEX_COUNT-1)
  if(init::$1) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  *SPRITES_ENABLE = $ff
  init::ss#0 = 0
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  init::ss#2 = phi( init::@2/init::ss#0, init::@3/init::ss#1 )
  SPRITES_COLOR[init::ss#2] = GREEN
  init::ss#1 = init::ss#2 + rangenext(0,7)
  init::$2 = init::ss#1 != rangelast(0,7)
  if(init::$2) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  asm { sei  }
  *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR
  *IRQ_ENABLE = IRQ_RASTER
  *IRQ_STATUS = IRQ_RASTER
  *KERNEL_IRQ = &plex_irq
  *VICII_CONTROL1 = *VICII_CONTROL1 & $7f
  *RASTER = 0
  asm { cli  }
  to:init::@return
init::@return: scope:[init]  from init::@4
  return 
  to:@return

__interrupt(rom_min_c64) void plex_irq()
plex_irq: scope:[plex_irq]  from
  asm { sei  }
  *BORDER_COLOR = WHITE
  plex_irq::rasterY#0 = 0
  to:plex_irq::@3
plex_irq::@3: scope:[plex_irq]  from plex_irq plex_irq::@6
  call plexShowSprite
  to:plex_irq::@7
plex_irq::@7: scope:[plex_irq]  from plex_irq::@3
  to:plex_irq::plexFreeNextYpos1
plex_irq::plexFreeNextYpos1: scope:[plex_irq]  from plex_irq::@7
  plex_irq::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next]
  to:plex_irq::plexFreeNextYpos1_@return
plex_irq::plexFreeNextYpos1_@return: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1
  plex_irq::plexFreeNextYpos1_return#2 = phi( plex_irq::plexFreeNextYpos1/plex_irq::plexFreeNextYpos1_return#0 )
  plex_irq::plexFreeNextYpos1_return#1 = plex_irq::plexFreeNextYpos1_return#2
  to:plex_irq::@6
plex_irq::@6: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1_@return
  plex_irq::plexFreeNextYpos1_return#3 = phi( plex_irq::plexFreeNextYpos1_@return/plex_irq::plexFreeNextYpos1_return#1 )
  plex_irq::$2 = plex_irq::plexFreeNextYpos1_return#3
  plex_irq::rasterY#1 = plex_irq::$2
  plex_irq::$3 = plex_show_idx < PLEX_COUNT
  plex_irq::$4 = *RASTER + 2
  plex_irq::$5 = plex_irq::rasterY#1 < plex_irq::$4
  plex_irq::$6 = plex_irq::$3 && plex_irq::$5
  if(plex_irq::$6) goto plex_irq::@3
  to:plex_irq::@4
plex_irq::@4: scope:[plex_irq]  from plex_irq::@6
  plex_irq::rasterY#3 = phi( plex_irq::@6/plex_irq::rasterY#1 )
  *IRQ_STATUS = IRQ_RASTER
  plex_irq::$0 = plex_show_idx < PLEX_COUNT
  if(plex_irq::$0) goto plex_irq::@1
  to:plex_irq::@5
plex_irq::@1: scope:[plex_irq]  from plex_irq::@4
  plex_irq::rasterY#2 = phi( plex_irq::@4/plex_irq::rasterY#3 )
  *RASTER = plex_irq::rasterY#2
  to:plex_irq::@2
plex_irq::@5: scope:[plex_irq]  from plex_irq::@4
  *RASTER = 0
  framedone = true
  to:plex_irq::@2
plex_irq::@2: scope:[plex_irq]  from plex_irq::@1 plex_irq::@5
  *BORDER_COLOR = 0
  asm { cli  }
  to:plex_irq::@return
plex_irq::@return: scope:[plex_irq]  from plex_irq::@2
  return 
  to:@return

void loop()
loop: scope:[loop]  from main::@1
  loop::sin_idx#0 = 0
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@6
  loop::sin_idx#6 = phi( loop/loop::sin_idx#0, loop::@6/loop::sin_idx#7 )
  if(true) goto loop::@2
  to:loop::@return
loop::@2: scope:[loop]  from loop::@1 loop::@2
  loop::sin_idx#4 = phi( loop::@1/loop::sin_idx#6, loop::@2/loop::sin_idx#4 )
  loop::$0 = ! framedone
  if(loop::$0) goto loop::@2
  to:loop::@3
loop::@3: scope:[loop]  from loop::@2
  loop::sin_idx#2 = phi( loop::@2/loop::sin_idx#4 )
  *BORDER_COLOR = RED
  loop::y_idx#0 = loop::sin_idx#2
  loop::sy#0 = 0
  to:loop::@4
loop::@4: scope:[loop]  from loop::@3 loop::@4
  loop::sin_idx#5 = phi( loop::@3/loop::sin_idx#2, loop::@4/loop::sin_idx#5 )
  loop::sy#2 = phi( loop::@3/loop::sy#0, loop::@4/loop::sy#1 )
  loop::y_idx#2 = phi( loop::@3/loop::y_idx#0, loop::@4/loop::y_idx#1 )
  PLEX_YPOS[loop::sy#2] = YSIN[loop::y_idx#2]
  loop::y_idx#1 = loop::y_idx#2 + 8
  loop::sy#1 = loop::sy#2 + rangenext(0,PLEX_COUNT-1)
  loop::$1 = loop::sy#1 != rangelast(0,PLEX_COUNT-1)
  if(loop::$1) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  loop::sin_idx#3 = phi( loop::@4/loop::sin_idx#5 )
  loop::sin_idx#1 = loop::sin_idx#3 + 1
  *BORDER_COLOR = ++ *BORDER_COLOR
  call plexSort
  to:loop::@6
loop::@6: scope:[loop]  from loop::@5
  loop::sin_idx#7 = phi( loop::@5/loop::sin_idx#1 )
  *BORDER_COLOR = GREEN
  framedone = false
  to:loop::@1
loop::@return: scope:[loop]  from loop::@1
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  PLEX_SCREEN_PTR = (char *)$400+$3f8
  plex_show_idx = 0
  plex_sprite_idx = 0
  plex_sprite_msb = 1
  plex_free_next = 0
  framedone = true
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
__constant char * const BORDER_COLOR = (char *)$d020
__constant struct MOS6526_CIA * const CIA1 = (struct MOS6526_CIA *)$dc00
__constant const char CIA_INTERRUPT_CLEAR = $7f
__constant char * const D011 = (char *)$d011
__constant const char GREEN = 5
__constant char * const IRQ_ENABLE = (char *)$d01a
__constant const char IRQ_RASTER = 1
__constant char * const IRQ_STATUS = (char *)$d019
__constant void (** const KERNEL_IRQ)() = (void (**)())$314
__constant char OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
__constant const char PLEX_COUNT = $20
__constant char PLEX_FREE_YPOS[8] = { fill( 8, 0) }
__constant char PLEX_PTR[PLEX_COUNT] = { fill( PLEX_COUNT, 0) }
__loadstore char * volatile PLEX_SCREEN_PTR
__constant char PLEX_SORTED_IDX[PLEX_COUNT] = { fill( PLEX_COUNT, 0) }
__constant unsigned int PLEX_XPOS[PLEX_COUNT] = { fill( PLEX_COUNT, 0) }
__constant char PLEX_YPOS[PLEX_COUNT] = { fill( PLEX_COUNT, 0) }
__constant char * const RASTER = (char *)$d012
__constant const char RED = 2
__constant char *SCREEN = (char *)$400
__constant char SIZEOF_UNSIGNED_INT = 2
__constant char SPRITE[$40] = kickasm {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
__constant char * const SPRITES_COLOR = (char *)$d027
__constant char * const SPRITES_ENABLE = (char *)$d015
__constant char * const SPRITES_XMSB = (char *)$d010
__constant char * const SPRITES_XPOS = (char *)$d000
__constant char * const SPRITES_YPOS = (char *)$d001
__constant char * const VICII_CONTROL1 = (char *)$d011
__constant const char VICII_DEN = $10
__constant const char VICII_RSEL = 8
__constant const char WHITE = 1
__constant char YSIN[$100] = kickasm {{ .fill $100, round(139.5+89.5*sin(toRadians(360*i/256)))
 }}
void __start()
__loadstore volatile bool framedone
void init()
bool init::$1
bool init::$2
char init::$3
char init::ss
char init::ss#0
char init::ss#1
char init::ss#2
char init::sx
char init::sx#0
char init::sx#1
char init::sx#2
unsigned int init::xp
unsigned int init::xp#0
unsigned int init::xp#1
unsigned int init::xp#2
void loop()
bool loop::$0
bool loop::$1
char loop::sin_idx
char loop::sin_idx#0
char loop::sin_idx#1
char loop::sin_idx#2
char loop::sin_idx#3
char loop::sin_idx#4
char loop::sin_idx#5
char loop::sin_idx#6
char loop::sin_idx#7
char loop::sy
char loop::sy#0
char loop::sy#1
char loop::sy#2
char loop::y_idx
char loop::y_idx#0
char loop::y_idx#1
char loop::y_idx#2
void main()
void plexInit(char *screen)
bool plexInit::$1
char plexInit::i
char plexInit::i#0
char plexInit::i#1
char plexInit::i#2
char *plexInit::plexSetScreen1_$0
char *plexInit::plexSetScreen1_screen
char *plexInit::plexSetScreen1_screen#0
char *plexInit::plexSetScreen1_screen#1
char *plexInit::screen
char *plexInit::screen#0
char *plexInit::screen#1
void plexShowSprite()
char plexShowSprite::$10
char plexShowSprite::$2
bool plexShowSprite::$3
number plexShowSprite::$4
number plexShowSprite::$5
bool plexShowSprite::$6
bool plexShowSprite::$7
number plexShowSprite::$8
char plexShowSprite::$9
number plexShowSprite::plexFreeAdd1_$0
number plexShowSprite::plexFreeAdd1_$1
number plexShowSprite::plexFreeAdd1_$2
char plexShowSprite::plexFreeAdd1_ypos
char plexShowSprite::plexFreeAdd1_ypos#0
char plexShowSprite::plexFreeAdd1_ypos#1
char plexShowSprite::plex_sprite_idx2
char plexShowSprite::plex_sprite_idx2#0
char plexShowSprite::plex_sprite_idx2#1
char plexShowSprite::plex_sprite_idx2#2
char plexShowSprite::xpos_idx
char plexShowSprite::xpos_idx#0
char plexShowSprite::ypos
char plexShowSprite::ypos#0
void plexSort()
number plexSort::$1
bool plexSort::$2
bool plexSort::$3
number plexSort::$4
bool plexSort::$5
bool plexSort::$6
bool plexSort::$7
bool plexSort::$8
char plexSort::m
char plexSort::m#0
char plexSort::m#1
char plexSort::m#2
char plexSort::m#3
char plexSort::m#4
char plexSort::m#5
char plexSort::m#6
char plexSort::nxt_idx
char plexSort::nxt_idx#0
char plexSort::nxt_idx#1
char plexSort::nxt_idx#2
char plexSort::nxt_idx#3
char plexSort::nxt_y
char plexSort::nxt_y#0
char plexSort::nxt_y#1
char plexSort::nxt_y#2
bool plexSort::plexFreePrepare1_$0
char plexSort::plexFreePrepare1_s
char plexSort::plexFreePrepare1_s#0
char plexSort::plexFreePrepare1_s#1
char plexSort::plexFreePrepare1_s#2
char plexSort::s
char plexSort::s#0
char plexSort::s#1
char plexSort::s#2
char plexSort::s#3
char plexSort::s#4
__loadstore volatile char plex_free_next
__interrupt(rom_min_c64) void plex_irq()
bool plex_irq::$0
char plex_irq::$2
bool plex_irq::$3
number plex_irq::$4
bool plex_irq::$5
bool plex_irq::$6
char plex_irq::plexFreeNextYpos1_return
char plex_irq::plexFreeNextYpos1_return#0
char plex_irq::plexFreeNextYpos1_return#1
char plex_irq::plexFreeNextYpos1_return#2
char plex_irq::plexFreeNextYpos1_return#3
char plex_irq::rasterY
char plex_irq::rasterY#0
char plex_irq::rasterY#1
char plex_irq::rasterY#2
char plex_irq::rasterY#3
__loadstore volatile char plex_show_idx
__loadstore volatile char plex_sprite_idx
__loadstore volatile char plex_sprite_msb

Adding number conversion cast (unumber) $3f8 in plexInit::plexSetScreen1_$0 = plexInit::plexSetScreen1_screen#1 + $3f8
Adding number conversion cast (unumber) 1 in plexInit::i#1 = plexInit::i#2 + rangenext(0,PLEX_COUNT-1)
Adding number conversion cast (unumber) 1 in plexSort::$1 = plexSort::m#2 + 1
Adding number conversion cast (unumber) plexSort::$1 in plexSort::$1 = plexSort::m#2 + (unumber)1
Adding number conversion cast (unumber) 2 in plexSort::m#1 = plexSort::m#3 + rangenext(0,PLEX_COUNT-2)
Adding number conversion cast (unumber) 1 in plexSort::$4 = plexSort::s#3 + 1
Adding number conversion cast (unumber) plexSort::$4 in plexSort::$4 = plexSort::s#3 + (unumber)1
Adding number conversion cast (unumber) $ff in plexSort::$5 = plexSort::s#1 != $ff
Adding number conversion cast (unumber) 0 in plex_show_idx = 0
Adding number conversion cast (unumber) 0 in plex_sprite_idx = 0
Adding number conversion cast (unumber) 1 in plex_sprite_msb = 1
Adding number conversion cast (unumber) 0 in PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0
Adding number conversion cast (unumber) 0 in plex_free_next = 0
Adding number conversion cast (unumber) 2 in plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx * 2
Adding number conversion cast (unumber) $16 in plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#1 + $16
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$0 in plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#1 + (unumber)$16
Adding number conversion cast (unumber) 1 in plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$1 in plexShowSprite::plexFreeAdd1_$1 = plex_free_next + (unumber)1
Adding number conversion cast (unumber) 7 in plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$2 in plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & (unumber)7
Adding number conversion cast (unumber) 0 in plexShowSprite::$3 = plexShowSprite::$2 != 0
Adding number conversion cast (unumber) $ff in plexShowSprite::$8 = $ff ^ plex_sprite_msb
Adding number conversion cast (unumber) plexShowSprite::$8 in plexShowSprite::$8 = (unumber)$ff ^ plex_sprite_msb
Adding number conversion cast (unumber) 1 in plexShowSprite::$4 = plex_sprite_idx + 1
Adding number conversion cast (unumber) plexShowSprite::$4 in plexShowSprite::$4 = plex_sprite_idx + (unumber)1
Adding number conversion cast (unumber) 7 in plexShowSprite::$5 = plexShowSprite::$4 & 7
Adding number conversion cast (unumber) plexShowSprite::$5 in plexShowSprite::$5 = plexShowSprite::$4 & (unumber)7
Adding number conversion cast (unumber) 1 in plex_sprite_msb = plex_sprite_msb << 1
Adding number conversion cast (unumber) 0 in plexShowSprite::$6 = plex_sprite_msb == 0
Adding number conversion cast (unumber) 1 in plex_sprite_msb = 1
Adding number conversion cast (unumber) VICII_DEN|VICII_RSEL|3 in *D011 = VICII_DEN|VICII_RSEL|3
Adding number conversion cast (unumber) 3 in *D011 = ((unumber)) VICII_DEN|VICII_RSEL|3
Adding number conversion cast (unumber) $40 in PLEX_PTR[init::sx#2] = (char)SPRITE/$40
Adding number conversion cast (unumber) 9 in init::xp#1 = init::xp#2 + 9
Adding number conversion cast (unumber) 1 in init::sx#1 = init::sx#2 + rangenext(0,PLEX_COUNT-1)
Adding number conversion cast (unumber) $ff in *SPRITES_ENABLE = $ff
Adding number conversion cast (unumber) $7f in *VICII_CONTROL1 = *VICII_CONTROL1 & $7f
Adding number conversion cast (unumber) 0 in *RASTER = 0
Adding number conversion cast (unumber) 2 in plex_irq::$4 = *RASTER + 2
Adding number conversion cast (unumber) plex_irq::$4 in plex_irq::$4 = *RASTER + (unumber)2
Adding number conversion cast (unumber) 0 in *RASTER = 0
Adding number conversion cast (unumber) 0 in *BORDER_COLOR = 0
Adding number conversion cast (unumber) 8 in loop::y_idx#1 = loop::y_idx#2 + 8
Adding number conversion cast (unumber) 1 in loop::sy#1 = loop::sy#2 + rangenext(0,PLEX_COUNT-1)
Adding number conversion cast (unumber) 1 in loop::sin_idx#1 = loop::sin_idx#3 + 1
Adding number conversion cast (unumber) $3f8 in PLEX_SCREEN_PTR = (char *)$400+$3f8
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast plex_show_idx = (unumber)0
Inlining cast plex_sprite_idx = (unumber)0
Inlining cast plex_sprite_msb = (unumber)1
Inlining cast PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = (unumber)0
Inlining cast plex_free_next = (unumber)0
Inlining cast plex_sprite_msb = (unumber)1
Inlining cast *D011 = (unumber)VICII_DEN|VICII_RSEL|(unumber)3
Inlining cast *SPRITES_ENABLE = (unumber)$ff
Inlining cast *RASTER = (unumber)0
Inlining cast *RASTER = (unumber)0
Inlining cast *BORDER_COLOR = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (char *) 53248
Simplifying constant pointer cast (char *) 53249
Simplifying constant pointer cast (char *) 53264
Simplifying constant pointer cast (char *) 53287
Simplifying constant pointer cast (char *) 53269
Simplifying constant pointer cast (char *) 53266
Simplifying constant pointer cast (char *) 53280
Simplifying constant pointer cast (char *) 53265
Simplifying constant pointer cast (char *) 53265
Simplifying constant pointer cast (char *) 53273
Simplifying constant pointer cast (char *) 53274
Simplifying constant pointer cast (struct MOS6526_CIA *) 56320
Simplifying constant pointer cast (void (**)()) 788
Simplifying constant pointer cast (char *) 1024
Simplifying constant integer cast $3f8
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $16
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast VICII_DEN|VICII_RSEL|(unumber)3
Simplifying constant integer cast 3
Simplifying constant integer cast $40
Simplifying constant integer cast 9
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast $7f
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 8
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant pointer cast (char *) 1024
Simplifying constant integer cast $3f8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (unsigned int) $3f8
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) $ff
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) $16
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 7
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $ff
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 7
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 3
Finalized unsigned number type (char) $40
Finalized unsigned number type (char) 9
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) $ff
Finalized unsigned number type (char) $7f
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 1
Finalized unsigned number type (unsigned int) $3f8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to char in plexSort::$1 = plexSort::m#2 + 1
Inferred type updated to char in plexSort::$4 = plexSort::s#3 + 1
Inferred type updated to char in plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#1 + $16
Inferred type updated to char in plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1
Inferred type updated to char in plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7
Inferred type updated to char in plexShowSprite::$8 = $ff ^ plex_sprite_msb
Inferred type updated to char in plexShowSprite::$4 = plex_sprite_idx + 1
Inferred type updated to char in plexShowSprite::$5 = plexShowSprite::$4 & 7
Inferred type updated to char in plex_irq::$4 = *RASTER + 2
Inversing boolean not [18] plexSort::$3 = plexSort::nxt_y#0 >= PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]] from [17] plexSort::$2 = plexSort::nxt_y#0 < PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]
Inversing boolean not [76] plexShowSprite::$7 = plex_sprite_msb != 0 from [75] plexShowSprite::$6 = plex_sprite_msb == 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias candidate removed (volatile)PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Alias plexInit::plexSetScreen1_screen#0 = plexInit::screen#1 plexInit::plexSetScreen1_screen#1 
Alias plexSort::m#2 = plexSort::m#4 plexSort::s#0 
Alias plexSort::nxt_y#0 = plexSort::nxt_y#2 
Alias plexSort::nxt_idx#0 = plexSort::nxt_idx#3 
Alias plexSort::s#1 = plexSort::s#4 
Alias plexSort::nxt_idx#1 = plexSort::nxt_idx#2 
Alias plexSort::m#5 = plexSort::m#6 
Alias plexShowSprite::plexFreeAdd1_ypos#0 = plexShowSprite::ypos#0 plexShowSprite::plexFreeAdd1_ypos#1 
Alias plexShowSprite::plex_sprite_idx2#0 = plexShowSprite::plex_sprite_idx2#2 plexShowSprite::plex_sprite_idx2#1 
Alias plex_irq::plexFreeNextYpos1_return#0 = plex_irq::plexFreeNextYpos1_return#2 plex_irq::plexFreeNextYpos1_return#1 plex_irq::plexFreeNextYpos1_return#3 plex_irq::$2 plex_irq::rasterY#1 plex_irq::rasterY#3 plex_irq::rasterY#2 
Alias loop::sin_idx#2 = loop::sin_idx#4 loop::y_idx#0 
Alias loop::sin_idx#3 = loop::sin_idx#5 
Alias loop::sin_idx#1 = loop::sin_idx#7 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Identical Phi Values plexInit::plexSetScreen1_screen#0 plexInit::screen#0
Identical Phi Values plexSort::nxt_y#1 plexSort::nxt_y#0
Identical Phi Values plexSort::nxt_idx#1 plexSort::nxt_idx#0
Identical Phi Values plexSort::m#5 plexSort::m#2
Identical Phi Values loop::sin_idx#2 loop::sin_idx#6
Identical Phi Values loop::sin_idx#3 loop::sin_idx#2
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values plexSort::m#3 plexSort::m#2
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [63] plexShowSprite::$10 = plexShowSprite::xpos_idx#0 * SIZEOF_UNSIGNED_INT
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition plexInit::$1 [8] if(plexInit::i#1!=rangelast(0,PLEX_COUNT-1)) goto plexInit::@1
Simple Condition plexSort::$3 [16] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2
Simple Condition plexSort::$8 [20] if(plexSort::m#1!=rangelast(0,PLEX_COUNT-2)) goto plexSort::@1
Simple Condition plexSort::plexFreePrepare1_$0 [39] if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1
Simple Condition plexShowSprite::$3 [57] if(plexShowSprite::$2!=0) goto plexShowSprite::@1
Simple Condition plexShowSprite::$7 [67] if(plex_sprite_msb!=0) goto plexShowSprite::@return
Simple Condition init::$1 [86] if(init::sx#1!=rangelast(0,PLEX_COUNT-1)) goto init::@1
Simple Condition init::$2 [93] if(init::ss#1!=rangelast(0,7)) goto init::@3
Simple Condition plex_irq::$0 [115] if(plex_show_idx<PLEX_COUNT) goto plex_irq::@1
Simple Condition loop::$1 [135] if(loop::sy#1!=rangelast(0,PLEX_COUNT-1)) goto loop::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [27] plexSort::$7 = plexSort::$5 && plexSort::$6
Rewriting && if()-condition to two if()s [111] plex_irq::$6 = plex_irq::$3 && plex_irq::$5
Rewriting ! if()-condition to reversed if() [126] loop::$0 = ! framedone
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant plexInit::i#0 = 0
Constant plexSort::m#0 = 0
Constant plexSort::plexFreePrepare1_s#0 = 0
Constant plexInit::screen#0 = SCREEN
Constant init::xp#0 = $20
Constant init::sx#0 = 0
Constant init::ss#0 = 0
Constant plex_irq::rasterY#0 = 0
Constant loop::sin_idx#0 = 0
Constant loop::sy#0 = 0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [124] if(true) goto loop::@2
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [6] plexInit::i#1 = ++ plexInit::i#2 to ++
Resolved ranged comparison value [8] if(plexInit::i#1!=rangelast(0,PLEX_COUNT-1)) goto plexInit::@1 to PLEX_COUNT-1+1
Resolved ranged next value [18] plexSort::m#1 = ++ plexSort::m#2 to ++
Resolved ranged comparison value [20] if(plexSort::m#1!=rangelast(0,PLEX_COUNT-2)) goto plexSort::@1 to PLEX_COUNT-2+1
Resolved ranged next value [37] plexSort::plexFreePrepare1_s#1 = ++ plexSort::plexFreePrepare1_s#2 to ++
Resolved ranged comparison value [39] if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1 to 8
Resolved ranged next value [84] init::sx#1 = ++ init::sx#2 to ++
Resolved ranged comparison value [86] if(init::sx#1!=rangelast(0,PLEX_COUNT-1)) goto init::@1 to PLEX_COUNT-1+1
Resolved ranged next value [91] init::ss#1 = ++ init::ss#2 to ++
Resolved ranged comparison value [93] if(init::ss#1!=rangelast(0,7)) goto init::@3 to 8
Resolved ranged next value [133] loop::sy#1 = ++ loop::sy#2 to ++
Resolved ranged comparison value [135] if(loop::sy#1!=rangelast(0,PLEX_COUNT-1)) goto loop::@4 to PLEX_COUNT-1+1
Removing unused block loop::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused constant plex_irq::rasterY#0
Successful SSA optimization PassNEliminateUnusedVars
Adding number conversion cast (unumber) PLEX_COUNT-1+1 in if(plexInit::i#1!=PLEX_COUNT-1+1) goto plexInit::@1
Adding number conversion cast (unumber) 1 in if(plexInit::i#1!=(unumber)PLEX_COUNT-1+1) goto plexInit::@1
Adding number conversion cast (unumber) PLEX_COUNT-2+1 in if(plexSort::m#1!=PLEX_COUNT-2+1) goto plexSort::@1
Adding number conversion cast (unumber) 1 in if(plexSort::m#1!=(unumber)PLEX_COUNT-2+1) goto plexSort::@1
Adding number conversion cast (unumber) 8 in if(plexSort::plexFreePrepare1_s#1!=8) goto plexSort::plexFreePrepare1_@1
Adding number conversion cast (unumber) PLEX_COUNT-1+1 in if(init::sx#1!=PLEX_COUNT-1+1) goto init::@1
Adding number conversion cast (unumber) 1 in if(init::sx#1!=(unumber)PLEX_COUNT-1+1) goto init::@1
Adding number conversion cast (unumber) 8 in if(init::ss#1!=8) goto init::@3
Adding number conversion cast (unumber) PLEX_COUNT-1+1 in if(loop::sy#1!=PLEX_COUNT-1+1) goto loop::@4
Adding number conversion cast (unumber) 1 in if(loop::sy#1!=(unumber)PLEX_COUNT-1+1) goto loop::@4
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast PLEX_COUNT-1+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast PLEX_COUNT-2+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Simplifying constant integer cast PLEX_COUNT-1+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Simplifying constant integer cast PLEX_COUNT-1+(unumber)1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Alias plexShowSprite::$10 = plexShowSprite::$9 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Simple Condition plexSort::$5 [20] if(plexSort::s#1!=$ff) goto plexSort::@7
Simple Condition plexSort::$6 [32] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3
Simple Condition plex_irq::$3 [92] if(plex_show_idx<PLEX_COUNT) goto plex_irq::@8
Simple Condition plex_irq::$5 [101] if(plex_irq::plexFreeNextYpos1_return#0<plex_irq::$4) goto plex_irq::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [20] if(plexSort::s#1==$ff) goto plexSort::@4
Negating conditional jump and destination [92] if(plex_show_idx>=PLEX_COUNT) goto plex_irq::@4
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [0] plexInit::plexSetScreen1_$0 = plexInit::screen#0 + $3f8
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant plexInit::plexSetScreen1_$0 = plexInit::screen#0+$3f8
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Rewriting multiplication to use shift [30] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx * 2
Rewriting multiplication to use shift [40] plexShowSprite::$10 = plexShowSprite::xpos_idx#0 * SIZEOF_UNSIGNED_INT
Rewriting multiplication to use shift [63] init::$3 = init::sx#2 * SIZEOF_UNSIGNED_INT
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings plexInit::i#0
Inlining constant with var siblings plexSort::m#0
Inlining constant with var siblings plexSort::plexFreePrepare1_s#0
Inlining constant with var siblings init::xp#0
Inlining constant with var siblings init::sx#0
Inlining constant with var siblings init::ss#0
Inlining constant with var siblings loop::sin_idx#0
Inlining constant with var siblings loop::sy#0
Constant inlined plexInit::screen#0 = SCREEN
Constant inlined init::xp#0 = $20
Constant inlined plexInit::plexSetScreen1_$0 = SCREEN+$3f8
Constant inlined loop::sy#0 = 0
Constant inlined init::sx#0 = 0
Constant inlined plexSort::plexFreePrepare1_s#0 = 0
Constant inlined init::ss#0 = 0
Constant inlined plexInit::i#0 = 0
Constant inlined plexSort::m#0 = 0
Constant inlined loop::sin_idx#0 = 0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment (PLEX_SORTED_IDX+1)[plexSort::$1]
Consolidated array index constant in assignment (PLEX_SORTED_IDX+1)[plexSort::$4]
Successful SSA optimization Pass2ConstantAdditionElimination
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Alias plexSort::m#2 = plexSort::$1 
Alias plexSort::s#3 = plexSort::$4 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Eliminating unused constant SIZEOF_UNSIGNED_INT
Successful SSA optimization PassNEliminateUnusedVars
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) $40
Finalized unsigned number type (unsigned int) $100
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$5 
Added new block during phi lifting plexInit::@3(between plexInit::@1 and plexInit::@1)
Added new block during phi lifting plexSort::@8(between plexSort::@2 and plexSort::@1)
Added new block during phi lifting plexSort::@9(between plexSort::@7 and plexSort::@3)
Added new block during phi lifting plexSort::@10(between plexSort::plexFreePrepare1_@1 and plexSort::plexFreePrepare1_@1)
Added new block during phi lifting init::@6(between init::@1 and init::@1)
Added new block during phi lifting init::@7(between init::@3 and init::@3)
Added new block during phi lifting loop::@7(between loop::@4 and loop::@4)
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of __start::@2
Adding NOP phi() at start of plex_irq::@3
Adding NOP phi() at start of plex_irq::@7
Adding NOP phi() at start of plex_irq::plexFreeNextYpos1_@return
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of init::@5
Adding NOP phi() at start of loop
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::@2
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
CALL GRAPH
Calls in [__start] to main:8 
Calls in [plex_irq] to plexShowSprite:14 
Calls in [main] to init:30 loop:32 
Calls in [init] to plexInit:61 
Calls in [loop] to plexSort:99 

Created 10 initial phi equivalence classes
Coalesced [84] init::ss#3 = init::ss#1
Coalesced [85] init::sx#3 = init::sx#1
Coalesced [86] init::xp#3 = init::xp#1
Not coalescing [91] loop::y_idx#3 = loop::sin_idx#6
Coalesced [102] loop::sin_idx#8 = loop::sin_idx#1
Coalesced [103] loop::y_idx#4 = loop::y_idx#1
Coalesced [104] loop::sy#3 = loop::sy#1
Coalesced [113] plexInit::i#3 = plexInit::i#1
Not coalescing [119] plexSort::s#6 = plexSort::m#2
Coalesced [139] plexSort::plexFreePrepare1_s#3 = plexSort::plexFreePrepare1_s#1
Coalesced [140] plexSort::m#7 = plexSort::m#1
Coalesced [141] plexSort::s#5 = plexSort::s#1
Coalesced down to 10 phi equivalence classes
Culled Empty Block label __start::@2
Culled Empty Block label plex_irq::@7
Culled Empty Block label plex_irq::plexFreeNextYpos1_@return
Culled Empty Block label main::@2
Culled Empty Block label init::@5
Culled Empty Block label init::@7
Culled Empty Block label init::@6
Culled Empty Block label loop::@7
Culled Empty Block label plexInit::@2
Culled Empty Block label plexInit::@3
Culled Empty Block label plexSort::@10
Culled Empty Block label plexSort::@8
Culled Empty Block label plexSort::@9
Renumbering block plex_irq::@8 to plex_irq::@7
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of plex_irq::@3
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of loop
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1

FINAL CONTROL FLOW GRAPH

void __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] PLEX_SCREEN_PTR = (char *) 1024+$3f8
  [2] plex_show_idx = 0
  [3] plex_sprite_idx = 0
  [4] plex_sprite_msb = 1
  [5] plex_free_next = 0
  [6] framedone = true
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [7] phi()
  [8] call main
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [9] return 
  to:@return

__interrupt(rom_min_c64) void plex_irq()
plex_irq: scope:[plex_irq]  from
  asm { sei  }
  [11] *BORDER_COLOR = WHITE
  to:plex_irq::@3
plex_irq::@3: scope:[plex_irq]  from plex_irq plex_irq::@7
  [12] phi()
  [13] call plexShowSprite
  to:plex_irq::plexFreeNextYpos1
plex_irq::plexFreeNextYpos1: scope:[plex_irq]  from plex_irq::@3
  [14] plex_irq::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next]
  to:plex_irq::@6
plex_irq::@6: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1
  [15] plex_irq::$4 = *RASTER + 2
  [16] if(plex_show_idx>=PLEX_COUNT) goto plex_irq::@4
  to:plex_irq::@7
plex_irq::@7: scope:[plex_irq]  from plex_irq::@6
  [17] if(plex_irq::plexFreeNextYpos1_return#0<plex_irq::$4) goto plex_irq::@3
  to:plex_irq::@4
plex_irq::@4: scope:[plex_irq]  from plex_irq::@6 plex_irq::@7
  [18] *IRQ_STATUS = IRQ_RASTER
  [19] if(plex_show_idx<PLEX_COUNT) goto plex_irq::@1
  to:plex_irq::@5
plex_irq::@5: scope:[plex_irq]  from plex_irq::@4
  [20] *RASTER = 0
  [21] framedone = true
  to:plex_irq::@2
plex_irq::@2: scope:[plex_irq]  from plex_irq::@1 plex_irq::@5
  [22] *BORDER_COLOR = 0
  asm { cli  }
  to:plex_irq::@return
plex_irq::@return: scope:[plex_irq]  from plex_irq::@2
  [24] return 
  to:@return
plex_irq::@1: scope:[plex_irq]  from plex_irq::@4
  [25] *RASTER = plex_irq::plexFreeNextYpos1_return#0
  to:plex_irq::@2

void main()
main: scope:[main]  from __start::@1
  asm { sei  }
  [27] call init
  to:main::@1
main::@1: scope:[main]  from main
  [28] phi()
  [29] call loop
  to:main::@return
main::@return: scope:[main]  from main::@1
  [30] return 
  to:@return

void plexShowSprite()
plexShowSprite: scope:[plexShowSprite]  from plex_irq::@3
  [31] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1
  [32] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]]
  [33] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  [34] plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#0 + $16
  [35] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0
  [36] plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1
  [37] plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7
  [38] plex_free_next = plexShowSprite::plexFreeAdd1_$2
  to:plexShowSprite::@5
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  [39] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]]
  [40] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx]
  [41] plexShowSprite::$10 = plexShowSprite::xpos_idx#0 << 1
  [42] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = (char)PLEX_XPOS[plexShowSprite::$10]
  [43] plexShowSprite::$2 = byte1  PLEX_XPOS[plexShowSprite::$10]
  [44] if(plexShowSprite::$2!=0) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@5
  [45] plexShowSprite::$8 = $ff ^ plex_sprite_msb
  [46] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$8
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  [47] plexShowSprite::$4 = plex_sprite_idx + 1
  [48] plexShowSprite::$5 = plexShowSprite::$4 & 7
  [49] plex_sprite_idx = plexShowSprite::$5
  [50] plex_show_idx = ++ plex_show_idx
  [51] plex_sprite_msb = plex_sprite_msb << 1
  [52] if(plex_sprite_msb!=0) goto plexShowSprite::@return
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@2
  [53] plex_sprite_msb = 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@4
  [54] return 
  to:@return
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@5
  [55] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb
  to:plexShowSprite::@2

void init()
init: scope:[init]  from main
  [56] *D011 = VICII_DEN|VICII_RSEL|3
  [57] call plexInit
  to:init::@1
init::@1: scope:[init]  from init init::@1
  [58] init::xp#2 = phi( init::@1/init::xp#1, init/$20 )
  [58] init::sx#2 = phi( init::@1/init::sx#1, init/0 )
  [59] PLEX_PTR[init::sx#2] = (char)SPRITE/$40
  [60] init::$3 = init::sx#2 << 1
  [61] PLEX_XPOS[init::$3] = init::xp#2
  [62] init::xp#1 = init::xp#2 + 9
  [63] init::sx#1 = ++ init::sx#2
  [64] if(init::sx#1!=PLEX_COUNT-1+1) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  [65] *SPRITES_ENABLE = $ff
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  [66] init::ss#2 = phi( init::@2/0, init::@3/init::ss#1 )
  [67] SPRITES_COLOR[init::ss#2] = GREEN
  [68] init::ss#1 = ++ init::ss#2
  [69] if(init::ss#1!=8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  asm { sei  }
  [71] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR
  [72] *IRQ_ENABLE = IRQ_RASTER
  [73] *IRQ_STATUS = IRQ_RASTER
  [74] *KERNEL_IRQ = &plex_irq
  [75] *VICII_CONTROL1 = *VICII_CONTROL1 & $7f
  [76] *RASTER = 0
  asm { cli  }
  to:init::@return
init::@return: scope:[init]  from init::@4
  [78] return 
  to:@return

void loop()
loop: scope:[loop]  from main::@1
  [79] phi()
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@6
  [80] loop::sin_idx#6 = phi( loop/0, loop::@6/loop::sin_idx#1 )
  to:loop::@2
loop::@2: scope:[loop]  from loop::@1 loop::@2
  [81] if(framedone) goto loop::@3
  to:loop::@2
loop::@3: scope:[loop]  from loop::@2
  [82] *BORDER_COLOR = RED
  [83] loop::y_idx#3 = loop::sin_idx#6
  to:loop::@4
loop::@4: scope:[loop]  from loop::@3 loop::@4
  [84] loop::sy#2 = phi( loop::@3/0, loop::@4/loop::sy#1 )
  [84] loop::y_idx#2 = phi( loop::@3/loop::y_idx#3, loop::@4/loop::y_idx#1 )
  [85] PLEX_YPOS[loop::sy#2] = YSIN[loop::y_idx#2]
  [86] loop::y_idx#1 = loop::y_idx#2 + 8
  [87] loop::sy#1 = ++ loop::sy#2
  [88] if(loop::sy#1!=PLEX_COUNT-1+1) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  [89] loop::sin_idx#1 = loop::sin_idx#6 + 1
  [90] *BORDER_COLOR = ++ *BORDER_COLOR
  [91] call plexSort
  to:loop::@6
loop::@6: scope:[loop]  from loop::@5
  [92] *BORDER_COLOR = GREEN
  [93] framedone = false
  to:loop::@1

void plexInit(char *screen)
plexInit: scope:[plexInit]  from init
  [94] phi()
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  [95] PLEX_SCREEN_PTR = SCREEN+$3f8
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::plexSetScreen1
  [96] plexInit::i#2 = phi( plexInit::@1/plexInit::i#1, plexInit::plexSetScreen1/0 )
  [97] PLEX_SORTED_IDX[plexInit::i#2] = plexInit::i#2
  [98] plexInit::i#1 = ++ plexInit::i#2
  [99] if(plexInit::i#1!=PLEX_COUNT-1+1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  [100] return 
  to:@return

void plexSort()
plexSort: scope:[plexSort]  from loop::@5
  [101] phi()
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  [102] plexSort::m#2 = phi( plexSort/0, plexSort::@2/plexSort::m#1 )
  [103] plexSort::nxt_idx#0 = (PLEX_SORTED_IDX+1)[plexSort::m#2]
  [104] plexSort::nxt_y#0 = PLEX_YPOS[plexSort::nxt_idx#0]
  [105] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2
  to:plexSort::@5
plexSort::@5: scope:[plexSort]  from plexSort::@1
  [106] plexSort::s#6 = plexSort::m#2
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@5 plexSort::@7
  [107] plexSort::s#3 = phi( plexSort::@7/plexSort::s#1, plexSort::@5/plexSort::s#6 )
  [108] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3]
  [109] plexSort::s#1 = -- plexSort::s#3
  [110] if(plexSort::s#1==$ff) goto plexSort::@4
  to:plexSort::@7
plexSort::@7: scope:[plexSort]  from plexSort::@3
  [111] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3 plexSort::@7
  [112] plexSort::s#2 = ++ plexSort::s#1
  [113] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0
  to:plexSort::@2
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  [114] plexSort::m#1 = ++ plexSort::m#2
  [115] if(plexSort::m#1!=PLEX_COUNT-2+1) goto plexSort::@1
  to:plexSort::@6
plexSort::@6: scope:[plexSort]  from plexSort::@2
  [116] plex_show_idx = 0
  [117] plex_sprite_idx = 0
  [118] plex_sprite_msb = 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  [119] phi()
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  [120] plexSort::plexFreePrepare1_s#2 = phi( plexSort::plexFreePrepare1/0, plexSort::plexFreePrepare1_@1/plexSort::plexFreePrepare1_s#1 )
  [121] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0
  [122] plexSort::plexFreePrepare1_s#1 = ++ plexSort::plexFreePrepare1_s#2
  [123] if(plexSort::plexFreePrepare1_s#1!=8) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  [124] plex_free_next = 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  [125] return 
  to:@return


VARIABLE REGISTER WEIGHTS
__loadstore char * volatile PLEX_SCREEN_PTR // 33.45454545454545
void __start()
__loadstore volatile bool framedone // 1222.8888888888887
void init()
char init::$3 // 2002.0
char init::ss
char init::ss#1 // 1501.5
char init::ss#2 // 1501.5
char init::sx
char init::sx#1 // 1501.5
char init::sx#2 // 800.8
unsigned int init::xp
unsigned int init::xp#1 // 667.3333333333334
unsigned int init::xp#2 // 750.75
void loop()
char loop::sin_idx
char loop::sin_idx#1 // 400.4
char loop::sin_idx#6 // 333.6666666666667
char loop::sy
char loop::sy#1 // 15001.5
char loop::sy#2 // 10001.0
char loop::y_idx
char loop::y_idx#1 // 6667.333333333333
char loop::y_idx#2 // 15502.0
char loop::y_idx#3 // 2002.0
void main()
void plexInit(char *screen)
char plexInit::i
char plexInit::i#1 // 15001.5
char plexInit::i#2 // 20002.0
char *plexInit::plexSetScreen1_screen
char *plexInit::screen
void plexShowSprite()
char plexShowSprite::$10 // 101.0
char plexShowSprite::$2 // 202.0
char plexShowSprite::$4 // 202.0
char plexShowSprite::$5 // 202.0
char plexShowSprite::$8 // 202.0
char plexShowSprite::plexFreeAdd1_$0 // 202.0
char plexShowSprite::plexFreeAdd1_$1 // 202.0
char plexShowSprite::plexFreeAdd1_$2 // 202.0
char plexShowSprite::plexFreeAdd1_ypos
char plexShowSprite::plexFreeAdd1_ypos#0 // 151.5
char plexShowSprite::plex_sprite_idx2
char plexShowSprite::plex_sprite_idx2#0 // 27.545454545454547
char plexShowSprite::xpos_idx
char plexShowSprite::xpos_idx#0 // 202.0
char plexShowSprite::ypos
void plexSort()
char plexSort::m
char plexSort::m#1 // 1500001.5
char plexSort::m#2 // 416667.0833333334
char plexSort::nxt_idx
char plexSort::nxt_idx#0 // 300000.30000000005
char plexSort::nxt_y
char plexSort::nxt_y#0 // 1500000.375
char plexSort::plexFreePrepare1_s
char plexSort::plexFreePrepare1_s#1 // 1500001.5
char plexSort::plexFreePrepare1_s#2 // 1500001.5
char plexSort::s
char plexSort::s#1 // 1.3666668333333332E7
char plexSort::s#2 // 2000002.0
char plexSort::s#3 // 2.05000025E7
char plexSort::s#6 // 2000002.0
__loadstore volatile char plex_free_next // 332.80645161290323
__interrupt(rom_min_c64) void plex_irq()
char plex_irq::$4 // 11.0
char plex_irq::plexFreeNextYpos1_return
char plex_irq::plexFreeNextYpos1_return#0 // 4.0
char plex_irq::rasterY
__loadstore volatile char plex_show_idx // 309.44117647058823
__loadstore volatile char plex_sprite_idx // 335.7096774193549
__loadstore volatile char plex_sprite_msb // 321.4848484848485

Initial phi equivalence classes
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#3 loop::y_idx#1 ]
[ loop::sy#2 loop::sy#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Added variable PLEX_SCREEN_PTR to live range equivalence class [ PLEX_SCREEN_PTR ]
Added variable plex_show_idx to live range equivalence class [ plex_show_idx ]
Added variable plex_sprite_idx to live range equivalence class [ plex_sprite_idx ]
Added variable plex_sprite_msb to live range equivalence class [ plex_sprite_msb ]
Added variable plex_free_next to live range equivalence class [ plex_free_next ]
Added variable framedone to live range equivalence class [ framedone ]
Added variable plex_irq::plexFreeNextYpos1_return#0 to live range equivalence class [ plex_irq::plexFreeNextYpos1_return#0 ]
Added variable plex_irq::$4 to live range equivalence class [ plex_irq::$4 ]
Added variable plexShowSprite::plex_sprite_idx2#0 to live range equivalence class [ plexShowSprite::plex_sprite_idx2#0 ]
Added variable plexShowSprite::plexFreeAdd1_ypos#0 to live range equivalence class [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Added variable plexShowSprite::plexFreeAdd1_$0 to live range equivalence class [ plexShowSprite::plexFreeAdd1_$0 ]
Added variable plexShowSprite::plexFreeAdd1_$1 to live range equivalence class [ plexShowSprite::plexFreeAdd1_$1 ]
Added variable plexShowSprite::plexFreeAdd1_$2 to live range equivalence class [ plexShowSprite::plexFreeAdd1_$2 ]
Added variable plexShowSprite::xpos_idx#0 to live range equivalence class [ plexShowSprite::xpos_idx#0 ]
Added variable plexShowSprite::$10 to live range equivalence class [ plexShowSprite::$10 ]
Added variable plexShowSprite::$2 to live range equivalence class [ plexShowSprite::$2 ]
Added variable plexShowSprite::$8 to live range equivalence class [ plexShowSprite::$8 ]
Added variable plexShowSprite::$4 to live range equivalence class [ plexShowSprite::$4 ]
Added variable plexShowSprite::$5 to live range equivalence class [ plexShowSprite::$5 ]
Added variable init::$3 to live range equivalence class [ init::$3 ]
Added variable plexSort::nxt_idx#0 to live range equivalence class [ plexSort::nxt_idx#0 ]
Added variable plexSort::nxt_y#0 to live range equivalence class [ plexSort::nxt_y#0 ]
Added variable plexSort::s#2 to live range equivalence class [ plexSort::s#2 ]
Complete equivalence classes
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#3 loop::y_idx#1 ]
[ loop::sy#2 loop::sy#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ PLEX_SCREEN_PTR ]
[ plex_show_idx ]
[ plex_sprite_idx ]
[ plex_sprite_msb ]
[ plex_free_next ]
[ framedone ]
[ plex_irq::plexFreeNextYpos1_return#0 ]
[ plex_irq::$4 ]
[ plexShowSprite::plex_sprite_idx2#0 ]
[ plexShowSprite::plexFreeAdd1_ypos#0 ]
[ plexShowSprite::plexFreeAdd1_$0 ]
[ plexShowSprite::plexFreeAdd1_$1 ]
[ plexShowSprite::plexFreeAdd1_$2 ]
[ plexShowSprite::xpos_idx#0 ]
[ plexShowSprite::$10 ]
[ plexShowSprite::$2 ]
[ plexShowSprite::$8 ]
[ plexShowSprite::$4 ]
[ plexShowSprite::$5 ]
[ init::$3 ]
[ plexSort::nxt_idx#0 ]
[ plexSort::nxt_y#0 ]
[ plexSort::s#2 ]
Allocated zp[1]:2 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Allocated zp[1]:3 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Allocated zp[1]:4 [ plexSort::s#2 ]
Allocated zp[1]:5 [ plexSort::m#2 plexSort::m#1 ]
Allocated zp[1]:6 [ plexSort::nxt_y#0 ]
Allocated zp[1]:7 [ plexSort::nxt_idx#0 ]
Allocated zp[1]:8 [ plexInit::i#2 plexInit::i#1 ]
Allocated zp[1]:9 [ loop::sy#2 loop::sy#1 ]
Allocated zp[1]:10 [ loop::y_idx#2 loop::y_idx#3 loop::y_idx#1 ]
Allocated zp[1]:11 [ init::ss#2 init::ss#1 ]
Allocated zp[1]:12 [ init::sx#2 init::sx#1 ]
Allocated zp[1]:13 [ init::$3 ]
Allocated zp[2]:14 [ init::xp#2 init::xp#1 ]
Allocated zp[1]:16 [ framedone ]
Allocated zp[1]:17 [ loop::sin_idx#6 loop::sin_idx#1 ]
Allocated zp[1]:18 [ plex_sprite_idx ]
Allocated zp[1]:19 [ plex_free_next ]
Allocated zp[1]:20 [ plex_sprite_msb ]
Allocated zp[1]:21 [ plex_show_idx ]
Allocated zp[1]:22 [ plexShowSprite::plexFreeAdd1_$0 ]
Allocated zp[1]:23 [ plexShowSprite::plexFreeAdd1_$1 ]
Allocated zp[1]:24 [ plexShowSprite::plexFreeAdd1_$2 ]
Allocated zp[1]:25 [ plexShowSprite::xpos_idx#0 ]
Allocated zp[1]:26 [ plexShowSprite::$2 ]
Allocated zp[1]:27 [ plexShowSprite::$8 ]
Allocated zp[1]:28 [ plexShowSprite::$4 ]
Allocated zp[1]:29 [ plexShowSprite::$5 ]
Allocated zp[1]:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Allocated zp[1]:31 [ plexShowSprite::$10 ]
Allocated zp[2]:32 [ PLEX_SCREEN_PTR ]
Allocated zp[1]:34 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated zp[1]:35 [ plex_irq::$4 ]
Allocated zp[1]:36 [ plex_irq::plexFreeNextYpos1_return#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] PLEX_SCREEN_PTR = (char *) 1024+$3f8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] plex_show_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] plex_sprite_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] plex_sprite_msb = 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] plex_free_next = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] framedone = true [ framedone ] (  [ framedone ] { }  ) always clobbers reg byte a 
Statement [11] *BORDER_COLOR = WHITE [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] (  [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [14] plex_irq::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 ] (  [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte y 
Statement [16] if(plex_show_idx>=PLEX_COUNT) goto plex_irq::@4 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:36 [ plex_irq::plexFreeNextYpos1_return#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:35 [ plex_irq::$4 ]
Statement [18] *IRQ_STATUS = IRQ_RASTER [ plex_show_idx plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_show_idx plex_irq::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte a 
Statement [19] if(plex_show_idx<PLEX_COUNT) goto plex_irq::@1 [ plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_irq::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte a 
Statement [20] *RASTER = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [21] framedone = true [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [22] *BORDER_COLOR = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [31] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Statement [32] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte x reg byte y 
Removing always clobbered register reg byte x as potential for zp[1]:34 [ plexShowSprite::plex_sprite_idx2#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:34 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [35] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte y 
Statement [39] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:34 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [40] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] { }  ) always clobbers reg byte y 
Statement [41] plexShowSprite::$10 = plexShowSprite::xpos_idx#0 << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$10 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$10 ] { }  ) always clobbers reg byte a 
Statement [42] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = (char)PLEX_XPOS[plexShowSprite::$10] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$10 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$10 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:31 [ plexShowSprite::$10 ]
Statement [43] plexShowSprite::$2 = byte1  PLEX_XPOS[plexShowSprite::$10] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$2 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$2 ] { }  ) always clobbers reg byte a 
Statement [45] plexShowSprite::$8 = $ff ^ plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$8 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$8 ] { }  ) always clobbers reg byte a 
Statement [46] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$8 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [52] if(plex_sprite_msb!=0) goto plexShowSprite::@return [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [53] plex_sprite_msb = 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [55] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [56] *D011 = VICII_DEN|VICII_RSEL|3 [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [59] PLEX_PTR[init::sx#2] = (char)SPRITE/$40 [ init::sx#2 init::xp#2 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:12 [ init::sx#2 init::sx#1 ]
Statement [60] init::$3 = init::sx#2 << 1 [ init::sx#2 init::xp#2 init::$3 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#2 init::$3 ] { }  ) always clobbers reg byte a 
Statement [61] PLEX_XPOS[init::$3] = init::xp#2 [ init::sx#2 init::xp#2 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#2 ] { }  ) always clobbers reg byte a 
Statement [62] init::xp#1 = init::xp#2 + 9 [ init::sx#2 init::xp#1 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#1 ] { }  ) always clobbers reg byte a 
Statement [65] *SPRITES_ENABLE = $ff [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [67] SPRITES_COLOR[init::ss#2] = GREEN [ init::ss#2 ] ( main:8::init:27 [ framedone init::ss#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:11 [ init::ss#2 init::ss#1 ]
Statement [71] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [72] *IRQ_ENABLE = IRQ_RASTER [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [73] *IRQ_STATUS = IRQ_RASTER [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [74] *KERNEL_IRQ = &plex_irq [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [75] *VICII_CONTROL1 = *VICII_CONTROL1 & $7f [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [76] *RASTER = 0 [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [81] if(framedone) goto loop::@3 [ framedone loop::sin_idx#6 ] ( main:8::loop:29 [ framedone loop::sin_idx#6 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:17 [ loop::sin_idx#6 loop::sin_idx#1 ]
Statement [82] *BORDER_COLOR = RED [ loop::sin_idx#6 ] ( main:8::loop:29 [ loop::sin_idx#6 ] { }  ) always clobbers reg byte a 
Statement [85] PLEX_YPOS[loop::sy#2] = YSIN[loop::y_idx#2] [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:8::loop:29 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ loop::y_idx#2 loop::y_idx#3 loop::y_idx#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:9 [ loop::sy#2 loop::sy#1 ]
Statement [86] loop::y_idx#1 = loop::y_idx#2 + 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:8::loop:29 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] { }  ) always clobbers reg byte a 
Statement [92] *BORDER_COLOR = GREEN [ loop::sin_idx#1 ] ( main:8::loop:29 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [93] framedone = false [ framedone loop::sin_idx#1 ] ( main:8::loop:29 [ framedone loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [95] PLEX_SCREEN_PTR = SCREEN+$3f8 [ ] ( main:8::init:27::plexInit:57 [ framedone ] { }  ) always clobbers reg byte a 
Statement [108] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ plexSort::m#2 plexSort::m#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ plexSort::nxt_idx#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ plexSort::nxt_y#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:2 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Statement [111] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] { }  ) always clobbers reg byte a 
Statement [113] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 ] { }  ) always clobbers reg byte a 
Statement [116] plex_show_idx = 0 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [117] plex_sprite_idx = 0 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [118] plex_sprite_msb = 1 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [121] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:3 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Statement [124] plex_free_next = 0 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [1] PLEX_SCREEN_PTR = (char *) 1024+$3f8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] plex_show_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] plex_sprite_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] plex_sprite_msb = 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] plex_free_next = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] framedone = true [ framedone ] (  [ framedone ] { }  ) always clobbers reg byte a 
Statement [11] *BORDER_COLOR = WHITE [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] (  [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [14] plex_irq::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 ] (  [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte y 
Statement [16] if(plex_show_idx>=PLEX_COUNT) goto plex_irq::@4 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] { }  ) always clobbers reg byte a 
Statement [18] *IRQ_STATUS = IRQ_RASTER [ plex_show_idx plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_show_idx plex_irq::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte a 
Statement [19] if(plex_show_idx<PLEX_COUNT) goto plex_irq::@1 [ plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_irq::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte a 
Statement [20] *RASTER = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [21] framedone = true [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [22] *BORDER_COLOR = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [31] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Statement [32] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte x reg byte y 
Statement [33] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Statement [35] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte y 
Statement [39] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [40] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] { }  ) always clobbers reg byte y 
Statement [41] plexShowSprite::$10 = plexShowSprite::xpos_idx#0 << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$10 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$10 ] { }  ) always clobbers reg byte a 
Statement [42] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = (char)PLEX_XPOS[plexShowSprite::$10] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$10 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$10 ] { }  ) always clobbers reg byte a 
Statement [43] plexShowSprite::$2 = byte1  PLEX_XPOS[plexShowSprite::$10] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$2 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$2 ] { }  ) always clobbers reg byte a 
Statement [45] plexShowSprite::$8 = $ff ^ plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$8 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$8 ] { }  ) always clobbers reg byte a 
Statement [46] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$8 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [52] if(plex_sprite_msb!=0) goto plexShowSprite::@return [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [53] plex_sprite_msb = 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [55] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [56] *D011 = VICII_DEN|VICII_RSEL|3 [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [59] PLEX_PTR[init::sx#2] = (char)SPRITE/$40 [ init::sx#2 init::xp#2 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#2 ] { }  ) always clobbers reg byte a 
Statement [60] init::$3 = init::sx#2 << 1 [ init::sx#2 init::xp#2 init::$3 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#2 init::$3 ] { }  ) always clobbers reg byte a 
Statement [61] PLEX_XPOS[init::$3] = init::xp#2 [ init::sx#2 init::xp#2 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#2 ] { }  ) always clobbers reg byte a 
Statement [62] init::xp#1 = init::xp#2 + 9 [ init::sx#2 init::xp#1 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#1 ] { }  ) always clobbers reg byte a 
Statement [65] *SPRITES_ENABLE = $ff [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [67] SPRITES_COLOR[init::ss#2] = GREEN [ init::ss#2 ] ( main:8::init:27 [ framedone init::ss#2 ] { }  ) always clobbers reg byte a 
Statement [71] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [72] *IRQ_ENABLE = IRQ_RASTER [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [73] *IRQ_STATUS = IRQ_RASTER [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [74] *KERNEL_IRQ = &plex_irq [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [75] *VICII_CONTROL1 = *VICII_CONTROL1 & $7f [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [76] *RASTER = 0 [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [81] if(framedone) goto loop::@3 [ framedone loop::sin_idx#6 ] ( main:8::loop:29 [ framedone loop::sin_idx#6 ] { }  ) always clobbers reg byte a 
Statement [82] *BORDER_COLOR = RED [ loop::sin_idx#6 ] ( main:8::loop:29 [ loop::sin_idx#6 ] { }  ) always clobbers reg byte a 
Statement [85] PLEX_YPOS[loop::sy#2] = YSIN[loop::y_idx#2] [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:8::loop:29 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] { }  ) always clobbers reg byte a 
Statement [86] loop::y_idx#1 = loop::y_idx#2 + 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:8::loop:29 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] { }  ) always clobbers reg byte a 
Statement [92] *BORDER_COLOR = GREEN [ loop::sin_idx#1 ] ( main:8::loop:29 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [93] framedone = false [ framedone loop::sin_idx#1 ] ( main:8::loop:29 [ framedone loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [95] PLEX_SCREEN_PTR = SCREEN+$3f8 [ ] ( main:8::init:27::plexInit:57 [ framedone ] { }  ) always clobbers reg byte a 
Statement [105] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] { }  ) always clobbers reg byte a 
Statement [108] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] { }  ) always clobbers reg byte a 
Statement [111] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] { }  ) always clobbers reg byte a 
Statement [113] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 ] { }  ) always clobbers reg byte a 
Statement [116] plex_show_idx = 0 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [117] plex_sprite_idx = 0 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [118] plex_sprite_msb = 1 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [121] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] { }  ) always clobbers reg byte a 
Statement [124] plex_free_next = 0 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [1] PLEX_SCREEN_PTR = (char *) 1024+$3f8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] plex_show_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] plex_sprite_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] plex_sprite_msb = 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] plex_free_next = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] framedone = true [ framedone ] (  [ framedone ] { }  ) always clobbers reg byte a 
Statement [11] *BORDER_COLOR = WHITE [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] (  [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [14] plex_irq::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 ] (  [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte y 
Statement [16] if(plex_show_idx>=PLEX_COUNT) goto plex_irq::@4 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] { }  ) always clobbers reg byte a 
Statement [18] *IRQ_STATUS = IRQ_RASTER [ plex_show_idx plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_show_idx plex_irq::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte a 
Statement [19] if(plex_show_idx<PLEX_COUNT) goto plex_irq::@1 [ plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_irq::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte a 
Statement [20] *RASTER = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [21] framedone = true [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [22] *BORDER_COLOR = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [31] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Statement [32] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte x reg byte y 
Statement [33] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte y 
Statement [35] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte y 
Statement [39] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [40] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] { }  ) always clobbers reg byte y 
Statement [41] plexShowSprite::$10 = plexShowSprite::xpos_idx#0 << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$10 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$10 ] { }  ) always clobbers reg byte a 
Statement [42] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = (char)PLEX_XPOS[plexShowSprite::$10] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$10 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$10 ] { }  ) always clobbers reg byte a 
Statement [43] plexShowSprite::$2 = byte1  PLEX_XPOS[plexShowSprite::$10] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$2 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$2 ] { }  ) always clobbers reg byte a 
Statement [45] plexShowSprite::$8 = $ff ^ plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$8 ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$8 ] { }  ) always clobbers reg byte a 
Statement [46] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$8 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [52] if(plex_sprite_msb!=0) goto plexShowSprite::@return [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [53] plex_sprite_msb = 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [55] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( plexShowSprite:13 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [56] *D011 = VICII_DEN|VICII_RSEL|3 [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [59] PLEX_PTR[init::sx#2] = (char)SPRITE/$40 [ init::sx#2 init::xp#2 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#2 ] { }  ) always clobbers reg byte a 
Statement [60] init::$3 = init::sx#2 << 1 [ init::sx#2 init::xp#2 init::$3 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#2 init::$3 ] { }  ) always clobbers reg byte a 
Statement [61] PLEX_XPOS[init::$3] = init::xp#2 [ init::sx#2 init::xp#2 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#2 ] { }  ) always clobbers reg byte a 
Statement [62] init::xp#1 = init::xp#2 + 9 [ init::sx#2 init::xp#1 ] ( main:8::init:27 [ framedone init::sx#2 init::xp#1 ] { }  ) always clobbers reg byte a 
Statement [65] *SPRITES_ENABLE = $ff [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [67] SPRITES_COLOR[init::ss#2] = GREEN [ init::ss#2 ] ( main:8::init:27 [ framedone init::ss#2 ] { }  ) always clobbers reg byte a 
Statement [71] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [72] *IRQ_ENABLE = IRQ_RASTER [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [73] *IRQ_STATUS = IRQ_RASTER [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [74] *KERNEL_IRQ = &plex_irq [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [75] *VICII_CONTROL1 = *VICII_CONTROL1 & $7f [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [76] *RASTER = 0 [ ] ( main:8::init:27 [ framedone ] { }  ) always clobbers reg byte a 
Statement [81] if(framedone) goto loop::@3 [ framedone loop::sin_idx#6 ] ( main:8::loop:29 [ framedone loop::sin_idx#6 ] { }  ) always clobbers reg byte a 
Statement [82] *BORDER_COLOR = RED [ loop::sin_idx#6 ] ( main:8::loop:29 [ loop::sin_idx#6 ] { }  ) always clobbers reg byte a 
Statement [85] PLEX_YPOS[loop::sy#2] = YSIN[loop::y_idx#2] [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:8::loop:29 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] { }  ) always clobbers reg byte a 
Statement [86] loop::y_idx#1 = loop::y_idx#2 + 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:8::loop:29 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] { }  ) always clobbers reg byte a 
Statement [92] *BORDER_COLOR = GREEN [ loop::sin_idx#1 ] ( main:8::loop:29 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [93] framedone = false [ framedone loop::sin_idx#1 ] ( main:8::loop:29 [ framedone loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [95] PLEX_SCREEN_PTR = SCREEN+$3f8 [ ] ( main:8::init:27::plexInit:57 [ framedone ] { }  ) always clobbers reg byte a 
Statement [105] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] { }  ) always clobbers reg byte a 
Statement [108] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] { }  ) always clobbers reg byte a 
Statement [111] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] { }  ) always clobbers reg byte a 
Statement [113] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::m#2 ] { }  ) always clobbers reg byte a 
Statement [116] plex_show_idx = 0 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [117] plex_sprite_idx = 0 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [118] plex_sprite_msb = 1 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Statement [121] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] { }  ) always clobbers reg byte a 
Statement [124] plex_free_next = 0 [ ] ( main:8::loop:29::plexSort:91 [ loop::sin_idx#1 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:12 [ init::sx#2 init::sx#1 ] : zp[1]:12 , reg byte x , reg byte y , 
Potential registers zp[2]:14 [ init::xp#2 init::xp#1 ] : zp[2]:14 , 
Potential registers zp[1]:11 [ init::ss#2 init::ss#1 ] : zp[1]:11 , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ loop::sin_idx#6 loop::sin_idx#1 ] : zp[1]:17 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ loop::y_idx#2 loop::y_idx#3 loop::y_idx#1 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ loop::sy#2 loop::sy#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ plexInit::i#2 plexInit::i#1 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ plexSort::m#2 plexSort::m#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:2 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[2]:32 [ PLEX_SCREEN_PTR ] : zp[2]:32 , 
Potential registers zp[1]:21 [ plex_show_idx ] : zp[1]:21 , 
Potential registers zp[1]:18 [ plex_sprite_idx ] : zp[1]:18 , 
Potential registers zp[1]:20 [ plex_sprite_msb ] : zp[1]:20 , 
Potential registers zp[1]:19 [ plex_free_next ] : zp[1]:19 , 
Potential registers zp[1]:16 [ framedone ] : zp[1]:16 , 
Potential registers zp[1]:36 [ plex_irq::plexFreeNextYpos1_return#0 ] : zp[1]:36 , reg byte x , reg byte y , 
Potential registers zp[1]:35 [ plex_irq::$4 ] : zp[1]:35 , reg byte x , reg byte y , 
Potential registers zp[1]:34 [ plexShowSprite::plex_sprite_idx2#0 ] : zp[1]:34 , 
Potential registers zp[1]:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ] : zp[1]:30 , reg byte a , reg byte x , 
Potential registers zp[1]:22 [ plexShowSprite::plexFreeAdd1_$0 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:23 [ plexShowSprite::plexFreeAdd1_$1 ] : zp[1]:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:24 [ plexShowSprite::plexFreeAdd1_$2 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:25 [ plexShowSprite::xpos_idx#0 ] : zp[1]:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:31 [ plexShowSprite::$10 ] : zp[1]:31 , reg byte x , reg byte y , 
Potential registers zp[1]:26 [ plexShowSprite::$2 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:27 [ plexShowSprite::$8 ] : zp[1]:27 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:28 [ plexShowSprite::$4 ] : zp[1]:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:29 [ plexShowSprite::$5 ] : zp[1]:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ init::$3 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ plexSort::nxt_idx#0 ] : zp[1]:7 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ plexSort::nxt_y#0 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ plexSort::s#2 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [plexSort] 36,166,672.83: zp[1]:2 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] 3,000,003: zp[1]:3 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] 2,000,002: zp[1]:4 [ plexSort::s#2 ] 1,916,668.58: zp[1]:5 [ plexSort::m#2 plexSort::m#1 ] 1,500,000.38: zp[1]:6 [ plexSort::nxt_y#0 ] 300,000.3: zp[1]:7 [ plexSort::nxt_idx#0 ] 
Uplift Scope [loop] 25,002.5: zp[1]:9 [ loop::sy#2 loop::sy#1 ] 24,171.33: zp[1]:10 [ loop::y_idx#2 loop::y_idx#3 loop::y_idx#1 ] 734.07: zp[1]:17 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Uplift Scope [plexInit] 35,003.5: zp[1]:8 [ plexInit::i#2 plexInit::i#1 ] 
Uplift Scope [init] 3,003: zp[1]:11 [ init::ss#2 init::ss#1 ] 2,302.3: zp[1]:12 [ init::sx#2 init::sx#1 ] 2,002: zp[1]:13 [ init::$3 ] 1,418.08: zp[2]:14 [ init::xp#2 init::xp#1 ] 
Uplift Scope [] 1,222.89: zp[1]:16 [ framedone ] 335.71: zp[1]:18 [ plex_sprite_idx ] 332.81: zp[1]:19 [ plex_free_next ] 321.48: zp[1]:20 [ plex_sprite_msb ] 309.44: zp[1]:21 [ plex_show_idx ] 33.45: zp[2]:32 [ PLEX_SCREEN_PTR ] 
Uplift Scope [plexShowSprite] 202: zp[1]:22 [ plexShowSprite::plexFreeAdd1_$0 ] 202: zp[1]:23 [ plexShowSprite::plexFreeAdd1_$1 ] 202: zp[1]:24 [ plexShowSprite::plexFreeAdd1_$2 ] 202: zp[1]:25 [ plexShowSprite::xpos_idx#0 ] 202: zp[1]:26 [ plexShowSprite::$2 ] 202: zp[1]:27 [ plexShowSprite::$8 ] 202: zp[1]:28 [ plexShowSprite::$4 ] 202: zp[1]:29 [ plexShowSprite::$5 ] 151.5: zp[1]:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ] 101: zp[1]:31 [ plexShowSprite::$10 ] 27.55: zp[1]:34 [ plexShowSprite::plex_sprite_idx2#0 ] 
Uplift Scope [plex_irq] 11: zp[1]:35 [ plex_irq::$4 ] 4: zp[1]:36 [ plex_irq::plexFreeNextYpos1_return#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [main] 
Uplift Scope [__start] 

Uplifting [plexSort] best 60310 combination reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] zp[1]:4 [ plexSort::s#2 ] zp[1]:5 [ plexSort::m#2 plexSort::m#1 ] zp[1]:6 [ plexSort::nxt_y#0 ] zp[1]:7 [ plexSort::nxt_idx#0 ] 
Limited combination testing to 10 combinations of 972 possible.
Uplifting [loop] best 58380 combination reg byte y [ loop::sy#2 loop::sy#1 ] reg byte x [ loop::y_idx#2 loop::y_idx#3 loop::y_idx#1 ] zp[1]:17 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Limited combination testing to 10 combinations of 27 possible.
Uplifting [plexInit] best 58260 combination reg byte x [ plexInit::i#2 plexInit::i#1 ] 
Uplifting [init] best 58010 combination reg byte x [ init::ss#2 init::ss#1 ] reg byte x [ init::sx#2 init::sx#1 ] zp[1]:13 [ init::$3 ] zp[2]:14 [ init::xp#2 init::xp#1 ] 
Limited combination testing to 10 combinations of 36 possible.
Uplifting [] best 58010 combination zp[1]:16 [ framedone ] zp[1]:18 [ plex_sprite_idx ] zp[1]:19 [ plex_free_next ] zp[1]:20 [ plex_sprite_msb ] zp[1]:21 [ plex_show_idx ] zp[2]:32 [ PLEX_SCREEN_PTR ] 
Uplifting [plexShowSprite] best 58000 combination reg byte a [ plexShowSprite::plexFreeAdd1_$0 ] reg byte x [ plexShowSprite::plexFreeAdd1_$1 ] zp[1]:24 [ plexShowSprite::plexFreeAdd1_$2 ] zp[1]:25 [ plexShowSprite::xpos_idx#0 ] zp[1]:26 [ plexShowSprite::$2 ] zp[1]:27 [ plexShowSprite::$8 ] zp[1]:28 [ plexShowSprite::$4 ] zp[1]:29 [ plexShowSprite::$5 ] zp[1]:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ] zp[1]:31 [ plexShowSprite::$10 ] zp[1]:34 [ plexShowSprite::plex_sprite_idx2#0 ] 
Limited combination testing to 10 combinations of 589824 possible.
Uplifting [plex_irq] best 57937 combination zp[1]:35 [ plex_irq::$4 ] reg byte x [ plex_irq::plexFreeNextYpos1_return#0 ] 
Uplifting [MOS6526_CIA] best 57937 combination 
Uplifting [MOS6569_VICII] best 57937 combination 
Uplifting [MOS6581_SID] best 57937 combination 
Uplifting [main] best 57937 combination 
Uplifting [__start] best 57937 combination 
Attempting to uplift remaining variables inzp[1]:4 [ plexSort::s#2 ]
Uplifting [plexSort] best 57337 combination reg byte x [ plexSort::s#2 ] 
Attempting to uplift remaining variables inzp[1]:5 [ plexSort::m#2 plexSort::m#1 ]
Uplifting [plexSort] best 57337 combination zp[1]:5 [ plexSort::m#2 plexSort::m#1 ] 
Attempting to uplift remaining variables inzp[1]:6 [ plexSort::nxt_y#0 ]
Uplifting [plexSort] best 57337 combination zp[1]:6 [ plexSort::nxt_y#0 ] 
Attempting to uplift remaining variables inzp[1]:7 [ plexSort::nxt_idx#0 ]
Uplifting [plexSort] best 57337 combination zp[1]:7 [ plexSort::nxt_idx#0 ] 
Attempting to uplift remaining variables inzp[1]:13 [ init::$3 ]
Uplifting [init] best 57297 combination reg byte a [ init::$3 ] 
Attempting to uplift remaining variables inzp[1]:16 [ framedone ]
Uplifting [] best 57297 combination zp[1]:16 [ framedone ] 
Attempting to uplift remaining variables inzp[1]:17 [ loop::sin_idx#6 loop::sin_idx#1 ]
Uplifting [loop] best 57297 combination zp[1]:17 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Attempting to uplift remaining variables inzp[1]:18 [ plex_sprite_idx ]
Uplifting [] best 57297 combination zp[1]:18 [ plex_sprite_idx ] 
Attempting to uplift remaining variables inzp[1]:19 [ plex_free_next ]
Uplifting [] best 57297 combination zp[1]:19 [ plex_free_next ] 
Attempting to uplift remaining variables inzp[1]:20 [ plex_sprite_msb ]
Uplifting [] best 57297 combination zp[1]:20 [ plex_sprite_msb ] 
Attempting to uplift remaining variables inzp[1]:21 [ plex_show_idx ]
Uplifting [] best 57297 combination zp[1]:21 [ plex_show_idx ] 
Attempting to uplift remaining variables inzp[1]:24 [ plexShowSprite::plexFreeAdd1_$2 ]
Uplifting [plexShowSprite] best 57293 combination reg byte a [ plexShowSprite::plexFreeAdd1_$2 ] 
Attempting to uplift remaining variables inzp[1]:25 [ plexShowSprite::xpos_idx#0 ]
Uplifting [plexShowSprite] best 57287 combination reg byte a [ plexShowSprite::xpos_idx#0 ] 
Attempting to uplift remaining variables inzp[1]:26 [ plexShowSprite::$2 ]
Uplifting [plexShowSprite] best 57283 combination reg byte a [ plexShowSprite::$2 ] 
Attempting to uplift remaining variables inzp[1]:27 [ plexShowSprite::$8 ]
Uplifting [plexShowSprite] best 57277 combination reg byte a [ plexShowSprite::$8 ] 
Attempting to uplift remaining variables inzp[1]:28 [ plexShowSprite::$4 ]
Uplifting [plexShowSprite] best 57271 combination reg byte x [ plexShowSprite::$4 ] 
Attempting to uplift remaining variables inzp[1]:29 [ plexShowSprite::$5 ]
Uplifting [plexShowSprite] best 57267 combination reg byte a [ plexShowSprite::$5 ] 
Attempting to uplift remaining variables inzp[1]:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Uplifting [plexShowSprite] best 57258 combination reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ] 
Attempting to uplift remaining variables inzp[1]:31 [ plexShowSprite::$10 ]
Uplifting [plexShowSprite] best 57251 combination reg byte x [ plexShowSprite::$10 ] 
Attempting to uplift remaining variables inzp[1]:34 [ plexShowSprite::plex_sprite_idx2#0 ]
Uplifting [plexShowSprite] best 57251 combination zp[1]:34 [ plexShowSprite::plex_sprite_idx2#0 ] 
Attempting to uplift remaining variables inzp[1]:35 [ plex_irq::$4 ]
Uplifting [plex_irq] best 57251 combination zp[1]:35 [ plex_irq::$4 ] 
Allocated (was zp[1]:5) zp[1]:2 [ plexSort::m#2 plexSort::m#1 ]
Allocated (was zp[1]:6) zp[1]:3 [ plexSort::nxt_y#0 ]
Allocated (was zp[1]:7) zp[1]:4 [ plexSort::nxt_idx#0 ]
Allocated (was zp[2]:14) zp[2]:5 [ init::xp#2 init::xp#1 ]
Allocated (was zp[1]:16) zp[1]:7 [ framedone ]
Allocated (was zp[1]:17) zp[1]:8 [ loop::sin_idx#6 loop::sin_idx#1 ]
Allocated (was zp[1]:18) zp[1]:9 [ plex_sprite_idx ]
Allocated (was zp[1]:19) zp[1]:10 [ plex_free_next ]
Allocated (was zp[1]:20) zp[1]:11 [ plex_sprite_msb ]
Allocated (was zp[1]:21) zp[1]:12 [ plex_show_idx ]
Allocated (was zp[2]:32) zp[2]:13 [ PLEX_SCREEN_PTR ]
Allocated (was zp[1]:34) zp[1]:15 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated (was zp[1]:35) zp[1]:16 [ plex_irq::$4 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// A simple usage of the flexible sprite multiplexer routine
/// @file
/// Commodore 64 Registers and Constants
/// @file
/// The MOS 6526 Complex Interface Adapter (CIA)
///
/// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
  // Commodore 64 PRG executable file
.file [name="simple-multiplexer-irq.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
  // Global Constants & labels
  /// Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  /// $D011 Control Register #1  Bit#4: DEN Switch VIC-II output on/off
  .const VICII_DEN = $10
  /// $D011 Control Register #1  Bit#3: RSEL Switch betweem 25 or 24 visible rows
  ///          RSEL|  Display window height   | First line  | Last line
  ///          ----+--------------------------+-------------+----------
  ///            0 | 24 text lines/192 pixels |   55 ($37)  | 246 ($f6)
  ///            1 | 25 text lines/200 pixels |   51 ($33)  | 250 ($fa)
  .const VICII_RSEL = 8
  /// VICII IRQ Status/Enable Raster
  // @see #IRQ_ENABLE #IRQ_STATUS
  ///  0 | RST| Reaching a certain raster line. The line is specified by writing
  ///    |    | to register 0xd012 and bit 7 of $d011 and internally stored by
  ///    |    | the VIC for the raster compare. The test for reaching the
  ///    |    | interrupt raster line is done in cycle 0 of every line (for line
  ///    |    | 0, in cycle 1).
  .const IRQ_RASTER = 1
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  /// Sprite X position register for sprite #0
  .label SPRITES_XPOS = $d000
  /// Sprite Y position register for sprite #0
  .label SPRITES_YPOS = $d001
  /// Sprite X position MSB register
  .label SPRITES_XMSB = $d010
  /// Sprite colors register for sprite #0
  .label SPRITES_COLOR = $d027
  /// Sprite enable register
  .label SPRITES_ENABLE = $d015
  /// $D012 RASTER Raster counter
  .label RASTER = $d012
  /// $D020 Border Color
  .label BORDER_COLOR = $d020
  /// $D011 Control Register #1
  /// - Bit#0-#2: YSCROLL Screen Soft Scroll Vertical
  /// - Bit#3: RSEL Switch betweem 25 or 24 visible rows
  ///          RSEL|  Display window height   | First line  | Last line
  ///          ----+--------------------------+-------------+----------
  ///            0 | 24 text lines/192 pixels |   55 ($37)  | 246 ($f6)
  ///            1 | 25 text lines/200 pixels |   51 ($33)  | 250 ($fa)
  /// - Bit#4: DEN Switch VIC-II output on/off
  /// - Bit#5: BMM Turn Bitmap Mode on/off
  /// - Bit#6: ECM Turn Extended Color Mode on/off
  /// - Bit#7: RST8 9th Bit for $D012 Rasterline counter
  /// Initial Value: %10011011
  .label VICII_CONTROL1 = $d011
  /// $D011 Control Register #1
  /// @see #VICII_CONTROL1
  .label D011 = $d011
  /// VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  /// VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  /// The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  /// The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  // Location of screen & sprites
  .label SCREEN = $400
  // The address of the sprite pointers on the current screen (screen+0x3f8).
  .label PLEX_SCREEN_PTR = $d
  // The index in the PLEX tables of the next sprite to show
  .label plex_show_idx = $c
  // The index the next sprite to use for showing (sprites are used round-robin)
  .label plex_sprite_idx = 9
  // The MSB bit of the next sprite to use for showing
  .label plex_sprite_msb = $b
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  .label plex_free_next = $a
  .label framedone = 7
.segment Code
  // __start
__start: {
    jmp __init1
    // __start::__init1
  __init1:
    // [1] PLEX_SCREEN_PTR = (char *) 1024+$3f8 -- pbuz1=pbuc1 
    lda #<$400+$3f8
    sta.z PLEX_SCREEN_PTR
    lda #>$400+$3f8
    sta.z PLEX_SCREEN_PTR+1
    // [2] plex_show_idx = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // [3] plex_sprite_idx = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [4] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [5] plex_free_next = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    // [6] framedone = true -- vboz1=vboc1 
    lda #1
    sta.z framedone
    // [7] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
  __b1_from___init1:
    jmp __b1
    // __start::@1
  __b1:
    // [8] call main
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [9] return 
    rts
}
  // plex_irq
plex_irq: {
    .label __4 = $10
    // interrupt(isr_rom_min_c64_entry) -- isr_rom_min_c64_entry 
    // asm { sei  }
    sei
    // [11] *BORDER_COLOR = WHITE -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDER_COLOR
    // [12] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
  __b3_from_plex_irq:
  __b3_from___b7:
    jmp __b3
    // plex_irq::@3
  __b3:
    // [13] call plexShowSprite
    jsr plexShowSprite
    jmp plexFreeNextYpos1
    // plex_irq::plexFreeNextYpos1
  plexFreeNextYpos1:
    // [14] plex_irq::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z plex_free_next
    ldx PLEX_FREE_YPOS,y
    jmp __b6
    // plex_irq::@6
  __b6:
    // [15] plex_irq::$4 = *RASTER + 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta.z __4
    // [16] if(plex_show_idx>=PLEX_COUNT) goto plex_irq::@4 -- vbuz1_ge_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcs __b4
    jmp __b7
    // plex_irq::@7
  __b7:
    // [17] if(plex_irq::plexFreeNextYpos1_return#0<plex_irq::$4) goto plex_irq::@3 -- vbuxx_lt_vbuz1_then_la1 
    cpx.z __4
    bcc __b3_from___b7
    jmp __b4
    // plex_irq::@4
  __b4:
    // [18] *IRQ_STATUS = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // [19] if(plex_show_idx<PLEX_COUNT) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcc __b1
    jmp __b5
    // plex_irq::@5
  __b5:
    // [20] *RASTER = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
    // [21] framedone = true -- vboz1=vboc1 
    lda #1
    sta.z framedone
    jmp __b2
    // plex_irq::@2
  __b2:
    // [22] *BORDER_COLOR = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDER_COLOR
    // asm { cli  }
    cli
    jmp __breturn
    // plex_irq::@return
  __breturn:
    // [24] return 
    // interrupt(isr_rom_min_c64_exit) -- isr_rom_min_c64_exit 
    jmp $ea81
    // plex_irq::@1
  __b1:
    // [25] *RASTER = plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuxx 
    stx RASTER
    jmp __b2
}
  // main
main: {
    // asm { sei  }
    sei
    // [27] call init
    jsr init
    // [28] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [29] call loop
    // [79] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from___b1:
    jsr loop
    jmp __breturn
    // main::@return
  __breturn:
    // [30] return 
    rts
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = $f
    // [31] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // [32] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // [33] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
    // plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
    // [34] plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#0 + $16 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$16
    // [35] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // [36] plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_free_next
    inx
    // [37] plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #7
    // [38] plex_free_next = plexShowSprite::plexFreeAdd1_$2 -- vbuz1=vbuaa 
    sta.z plex_free_next
    jmp __b5
    // plexShowSprite::@5
  __b5:
    // [39] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] -- pbuz1_derefidx_vbuz2=pbuc1_derefidx_(pbuc2_derefidx_vbuz3) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldy.z plex_sprite_idx
    sta (PLEX_SCREEN_PTR),y
    // [40] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // [41] plexShowSprite::$10 = plexShowSprite::xpos_idx#0 << 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [42] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = (char)PLEX_XPOS[plexShowSprite::$10] -- pbuc1_derefidx_vbuz1=_byte_pwuc2_derefidx_vbuxx 
    ldy.z plex_sprite_idx2
    lda PLEX_XPOS,x
    sta SPRITES_XPOS,y
    // [43] plexShowSprite::$2 = byte1  PLEX_XPOS[plexShowSprite::$10] -- vbuaa=_byte1_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // [44] if(plexShowSprite::$2!=0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b1
    jmp __b3
    // plexShowSprite::@3
  __b3:
    // [45] plexShowSprite::$8 = $ff ^ plex_sprite_msb -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // [46] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$8 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    jmp __b2
    // plexShowSprite::@2
  __b2:
    // [47] plexShowSprite::$4 = plex_sprite_idx + 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // [48] plexShowSprite::$5 = plexShowSprite::$4 & 7 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #7
    // [49] plex_sprite_idx = plexShowSprite::$5 -- vbuz1=vbuaa 
    sta.z plex_sprite_idx
    // [50] plex_show_idx = ++ plex_show_idx -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // [51] plex_sprite_msb = plex_sprite_msb << 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // [52] if(plex_sprite_msb!=0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    bne __breturn
    jmp __b4
    // plexShowSprite::@4
  __b4:
    // [53] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    jmp __breturn
    // plexShowSprite::@return
  __breturn:
    // [54] return 
    rts
    // plexShowSprite::@1
  __b1:
    // [55] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // init
// Initialize the program
init: {
    // Set the x-positions & pointers
    .label xp = 5
    // [56] *D011 = VICII_DEN|VICII_RSEL|3 -- _deref_pbuc1=vbuc2 
    lda #VICII_DEN|VICII_RSEL|3
    sta D011
    // [57] call plexInit
  // Initialize the multiplexer
    // [94] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
    // [58] phi from init to init::@1 [phi:init->init::@1]
  __b1_from_init:
    // [58] phi init::xp#2 = $20 [phi:init->init::@1#0] -- vwuz1=vwuc1 
    lda #<$20
    sta.z xp
    lda #>$20
    sta.z xp+1
    // [58] phi init::sx#2 = 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [58] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  __b1_from___b1:
    // [58] phi init::xp#2 = init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
    // [58] phi init::sx#2 = init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp __b1
    // init::@1
  __b1:
    // [59] PLEX_PTR[init::sx#2] = (char)SPRITE/$40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #$ff&SPRITE/$40
    sta PLEX_PTR,x
    // [60] init::$3 = init::sx#2 << 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [61] PLEX_XPOS[init::$3] = init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda.z xp
    sta PLEX_XPOS,y
    lda.z xp+1
    sta PLEX_XPOS+1,y
    // [62] init::xp#1 = init::xp#2 + 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc.z xp
    sta.z xp
    bcc !+
    inc.z xp+1
  !:
    // [63] init::sx#1 = ++ init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
    // [64] if(init::sx#1!=PLEX_COUNT-1+1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1_from___b1
    jmp __b2
    // init::@2
  __b2:
    // [65] *SPRITES_ENABLE = $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [66] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  __b3_from___b2:
    // [66] phi init::ss#2 = 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b3
    // [66] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  __b3_from___b3:
    // [66] phi init::ss#2 = init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp __b3
    // init::@3
  __b3:
    // [67] SPRITES_COLOR[init::ss#2] = GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLOR,x
    // [68] init::ss#1 = ++ init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
    // [69] if(init::ss#1!=8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3_from___b3
    jmp __b4
    // init::@4
  __b4:
    // asm { sei  }
    // enable the interrupt
    sei
    // [71] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // [72] *IRQ_ENABLE = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // [73] *IRQ_STATUS = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // [74] *KERNEL_IRQ = &plex_irq -- _deref_qprc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
    // [75] *VICII_CONTROL1 = *VICII_CONTROL1 & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VICII_CONTROL1
    sta VICII_CONTROL1
    // [76] *RASTER = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
    // asm { cli  }
    cli
    jmp __breturn
    // init::@return
  __breturn:
    // [78] return 
    rts
}
  // loop
// The raster loop
loop: {
    // The current index into the y-sine
    .label sin_idx = 8
    // [80] phi from loop to loop::@1 [phi:loop->loop::@1]
  __b1_from_loop:
    // [80] phi loop::sin_idx#6 = 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    jmp __b1
    // loop::@1
  __b1:
    jmp __b2
    // loop::@2
  __b2:
    // [81] if(framedone) goto loop::@3 -- vboz1_then_la1 
    lda.z framedone
    cmp #0
    bne __b3
    jmp __b2
    // loop::@3
  __b3:
    // [82] *BORDER_COLOR = RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDER_COLOR
    // [83] loop::y_idx#3 = loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx.z sin_idx
    // [84] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  __b4_from___b3:
    // [84] phi loop::sy#2 = 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
    // [84] phi loop::y_idx#2 = loop::y_idx#3 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp __b4
    // [84] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  __b4_from___b4:
    // [84] phi loop::sy#2 = loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [84] phi loop::y_idx#2 = loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp __b4
    // loop::@4
  __b4:
    // [85] PLEX_YPOS[loop::sy#2] = YSIN[loop::y_idx#2] -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
    // [86] loop::y_idx#1 = loop::y_idx#2 + 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
    // [87] loop::sy#1 = ++ loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
    // [88] if(loop::sy#1!=PLEX_COUNT-1+1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne __b4_from___b4
    jmp __b5
    // loop::@5
  __b5:
    // [89] loop::sin_idx#1 = loop::sin_idx#6 + 1 -- vbuz1=vbuz1_plus_1 
    inc.z sin_idx
    // [90] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // [91] call plexSort
    // [101] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from___b5:
    jsr plexSort
    jmp __b6
    // loop::@6
  __b6:
    // [92] *BORDER_COLOR = GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDER_COLOR
    // [93] framedone = false -- vboz1=vboc1 
    lda #0
    sta.z framedone
    // [80] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
  __b1_from___b6:
    // [80] phi loop::sin_idx#6 = loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
    jmp __b1
}
  // plexInit
// Initialize the multiplexer data structures
// void plexInit(char *screen)
plexInit: {
    jmp plexSetScreen1
    // plexInit::plexSetScreen1
  plexSetScreen1:
    // [95] PLEX_SCREEN_PTR = SCREEN+$3f8 -- pbuz1=pbuc1 
    lda #<SCREEN+$3f8
    sta.z PLEX_SCREEN_PTR
    lda #>SCREEN+$3f8
    sta.z PLEX_SCREEN_PTR+1
    // [96] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  __b1_from_plexSetScreen1:
    // [96] phi plexInit::i#2 = 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [96] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  __b1_from___b1:
    // [96] phi plexInit::i#2 = plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp __b1
    // plexInit::@1
  __b1:
    // [97] PLEX_SORTED_IDX[plexInit::i#2] = plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // [98] plexInit::i#1 = ++ plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [99] if(plexInit::i#1!=PLEX_COUNT-1+1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1_from___b1
    jmp __breturn
    // plexInit::@return
  __breturn:
    // [100] return 
    rts
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = 4
    .label nxt_y = 3
    .label m = 2
    // [102] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  __b1_from_plexSort:
    // [102] phi plexSort::m#2 = 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    jmp __b1
    // [102] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  __b1_from___b2:
    // [102] phi plexSort::m#2 = plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp __b1
    // plexSort::@1
  __b1:
    // [103] plexSort::nxt_idx#0 = (PLEX_SORTED_IDX+1)[plexSort::m#2] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // [104] plexSort::nxt_y#0 = PLEX_YPOS[plexSort::nxt_idx#0] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z nxt_idx
    lda PLEX_YPOS,y
    sta.z nxt_y
    // [105] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    jmp __b5
    // plexSort::@5
  __b5:
    // [106] plexSort::s#6 = plexSort::m#2 -- vbuxx=vbuz1 
    ldx.z m
    // [107] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
  __b3_from___b5:
  __b3_from___b7:
    // [107] phi plexSort::s#3 = plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
    jmp __b3
    // plexSort::@3
  __b3:
    // [108] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // [109] plexSort::s#1 = -- plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // [110] if(plexSort::s#1==$ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq __b4
    jmp __b7
    // plexSort::@7
  __b7:
    // [111] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3_from___b7
    jmp __b4
    // plexSort::@4
  __b4:
    // [112] plexSort::s#2 = ++ plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // [113] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    jmp __b2
    // plexSort::@2
  __b2:
    // [114] plexSort::m#1 = ++ plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [115] if(plexSort::m#1!=PLEX_COUNT-2+1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1_from___b2
    jmp __b6
    // plexSort::@6
  __b6:
    // [116] plex_show_idx = 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta.z plex_show_idx
    // [117] plex_sprite_idx = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [118] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [119] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
  plexFreePrepare1_from___b6:
    jmp plexFreePrepare1
    // plexSort::plexFreePrepare1
  plexFreePrepare1:
    // [120] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1:
    // [120] phi plexSort::plexFreePrepare1_s#2 = 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp plexFreePrepare1___b1
    // [120] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1___b1:
    // [120] phi plexSort::plexFreePrepare1_s#2 = plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1___b1
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // [121] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // [122] plexSort::plexFreePrepare1_s#1 = ++ plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [123] if(plexSort::plexFreePrepare1_s#1!=8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1___b1_from_plexFreePrepare1___b1
    jmp plexFreePrepare1___b2
    // plexSort::plexFreePrepare1_@2
  plexFreePrepare1___b2:
    // [124] plex_free_next = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    jmp __breturn
    // plexSort::@return
  __breturn:
    // [125] return 
    rts
}
  // File Data
.segment Data
  // The x-positions of the multiplexer sprites (0x000-0x1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  .align $40
SPRITE:
.var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)

  .align $100
YSIN:
.fill $100, round(139.5+89.5*sin(toRadians(360*i/256)))


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __init1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp plexFreeNextYpos1
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp plexFreeAdd1
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp plexSetScreen1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b7
Removing instruction jmp __b4
Removing instruction jmp __b2
Removing instruction jmp __b6
Removing instruction jmp plexFreePrepare1
Removing instruction jmp plexFreePrepare1___b1
Removing instruction jmp plexFreePrepare1___b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #IRQ_RASTER
Replacing instruction ldy.z nxt_idx with TAY
Removing instruction lda.z nxt_y
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b3_from___b7 with __b3
Replacing label __b1_from___b1 with __b1
Replacing label __b3_from___b3 with __b3
Replacing label __b4_from___b4 with __b4
Replacing label __b1 with __b2
Replacing label __b1_from___b1 with __b1
Replacing label __b3_from___b7 with __b3
Replacing label __b1_from___b2 with __b1
Replacing label plexFreePrepare1___b1_from_plexFreePrepare1___b1 with plexFreePrepare1___b1
Removing instruction __b1_from___init1:
Removing instruction __b3_from_plex_irq:
Removing instruction __b3_from___b7:
Removing instruction __b1_from_main:
Removing instruction loop_from___b1:
Removing instruction __b1_from___b1:
Removing instruction __b3_from___b3:
Removing instruction __b1:
Removing instruction __b4_from___b4:
Removing instruction __b1_from___b1:
Removing instruction __b1_from___b2:
Removing instruction __b3_from___b5:
Removing instruction __b3_from___b7:
Removing instruction plexFreePrepare1_from___b6:
Removing instruction plexFreePrepare1___b1_from_plexFreePrepare1:
Removing instruction plexFreePrepare1___b1_from_plexFreePrepare1___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __init1:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction plexFreeNextYpos1:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b5:
Removing instruction __breturn:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction plexFreeAdd1:
Removing instruction __b5:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction plexInit_from_init:
Removing instruction __b1_from_init:
Removing instruction __b2:
Removing instruction __b3_from___b2:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __b1_from_loop:
Removing instruction __b4_from___b3:
Removing instruction __b5:
Removing instruction plexSort_from___b5:
Removing instruction __b6:
Removing instruction __b1_from___b6:
Removing instruction plexSetScreen1:
Removing instruction __b1_from_plexSetScreen1:
Removing instruction __breturn:
Removing instruction __b1_from_plexSort:
Removing instruction __b5:
Removing instruction __b7:
Removing instruction __b6:
Removing instruction plexFreePrepare1:
Removing instruction plexFreePrepare1___b2:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp plexFreePrepare1___b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldx.z m
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination

FINAL SYMBOL TABLE
__constant char * const BORDER_COLOR = (char *) 53280
__constant struct MOS6526_CIA * const CIA1 = (struct MOS6526_CIA *) 56320
__constant const char CIA_INTERRUPT_CLEAR = $7f
__constant char * const D011 = (char *) 53265
__constant const char GREEN = 5
__constant char * const IRQ_ENABLE = (char *) 53274
__constant const char IRQ_RASTER = 1
__constant char * const IRQ_STATUS = (char *) 53273
__constant void (** const KERNEL_IRQ)() = (void (**)()) 788
__constant char OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
__constant const char PLEX_COUNT = $20
__constant char PLEX_FREE_YPOS[8] = { fill( 8, 0) }
__constant char PLEX_PTR[PLEX_COUNT] = { fill( PLEX_COUNT, 0) }
__loadstore char * volatile PLEX_SCREEN_PTR // zp[2]:13 33.45454545454545
__constant char PLEX_SORTED_IDX[PLEX_COUNT] = { fill( PLEX_COUNT, 0) }
__constant unsigned int PLEX_XPOS[PLEX_COUNT] = { fill( PLEX_COUNT, 0) }
__constant char PLEX_YPOS[PLEX_COUNT] = { fill( PLEX_COUNT, 0) }
__constant char * const RASTER = (char *) 53266
__constant const char RED = 2
__constant char *SCREEN = (char *) 1024
__constant char SPRITE[$40] = kickasm {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
__constant char * const SPRITES_COLOR = (char *) 53287
__constant char * const SPRITES_ENABLE = (char *) 53269
__constant char * const SPRITES_XMSB = (char *) 53264
__constant char * const SPRITES_XPOS = (char *) 53248
__constant char * const SPRITES_YPOS = (char *) 53249
__constant char * const VICII_CONTROL1 = (char *) 53265
__constant const char VICII_DEN = $10
__constant const char VICII_RSEL = 8
__constant const char WHITE = 1
__constant char YSIN[$100] = kickasm {{ .fill $100, round(139.5+89.5*sin(toRadians(360*i/256)))
 }}
void __start()
__loadstore volatile bool framedone // zp[1]:7 1222.8888888888887
void init()
char init::$3 // reg byte a 2002.0
char init::ss
char init::ss#1 // reg byte x 1501.5
char init::ss#2 // reg byte x 1501.5
char init::sx
char init::sx#1 // reg byte x 1501.5
char init::sx#2 // reg byte x 800.8
unsigned int init::xp
unsigned int init::xp#1 // xp zp[2]:5 667.3333333333334
unsigned int init::xp#2 // xp zp[2]:5 750.75
void loop()
char loop::sin_idx
char loop::sin_idx#1 // sin_idx zp[1]:8 400.4
char loop::sin_idx#6 // sin_idx zp[1]:8 333.6666666666667
char loop::sy
char loop::sy#1 // reg byte y 15001.5
char loop::sy#2 // reg byte y 10001.0
char loop::y_idx
char loop::y_idx#1 // reg byte x 6667.333333333333
char loop::y_idx#2 // reg byte x 15502.0
char loop::y_idx#3 // reg byte x 2002.0
void main()
void plexInit(char *screen)
char plexInit::i
char plexInit::i#1 // reg byte x 15001.5
char plexInit::i#2 // reg byte x 20002.0
char *plexInit::plexSetScreen1_screen
char *plexInit::screen
void plexShowSprite()
char plexShowSprite::$10 // reg byte x 101.0
char plexShowSprite::$2 // reg byte a 202.0
char plexShowSprite::$4 // reg byte x 202.0
char plexShowSprite::$5 // reg byte a 202.0
char plexShowSprite::$8 // reg byte a 202.0
char plexShowSprite::plexFreeAdd1_$0 // reg byte a 202.0
char plexShowSprite::plexFreeAdd1_$1 // reg byte x 202.0
char plexShowSprite::plexFreeAdd1_$2 // reg byte a 202.0
char plexShowSprite::plexFreeAdd1_ypos
char plexShowSprite::plexFreeAdd1_ypos#0 // reg byte a 151.5
char plexShowSprite::plex_sprite_idx2
char plexShowSprite::plex_sprite_idx2#0 // plex_sprite_idx2 zp[1]:15 27.545454545454547
char plexShowSprite::xpos_idx
char plexShowSprite::xpos_idx#0 // reg byte a 202.0
char plexShowSprite::ypos
void plexSort()
char plexSort::m
char plexSort::m#1 // m zp[1]:2 1500001.5
char plexSort::m#2 // m zp[1]:2 416667.0833333334
char plexSort::nxt_idx
char plexSort::nxt_idx#0 // nxt_idx zp[1]:4 300000.30000000005
char plexSort::nxt_y
char plexSort::nxt_y#0 // nxt_y zp[1]:3 1500000.375
char plexSort::plexFreePrepare1_s
char plexSort::plexFreePrepare1_s#1 // reg byte x 1500001.5
char plexSort::plexFreePrepare1_s#2 // reg byte x 1500001.5
char plexSort::s
char plexSort::s#1 // reg byte x 1.3666668333333332E7
char plexSort::s#2 // reg byte x 2000002.0
char plexSort::s#3 // reg byte x 2.05000025E7
char plexSort::s#6 // reg byte x 2000002.0
__loadstore volatile char plex_free_next // zp[1]:10 332.80645161290323
__interrupt(rom_min_c64) void plex_irq()
char plex_irq::$4 // zp[1]:16 11.0
char plex_irq::plexFreeNextYpos1_return
char plex_irq::plexFreeNextYpos1_return#0 // reg byte x 4.0
char plex_irq::rasterY
__loadstore volatile char plex_show_idx // zp[1]:12 309.44117647058823
__loadstore volatile char plex_sprite_idx // zp[1]:9 335.7096774193549
__loadstore volatile char plex_sprite_msb // zp[1]:11 321.4848484848485

reg byte x [ init::sx#2 init::sx#1 ]
zp[2]:5 [ init::xp#2 init::xp#1 ]
reg byte x [ init::ss#2 init::ss#1 ]
zp[1]:8 [ loop::sin_idx#6 loop::sin_idx#1 ]
reg byte x [ loop::y_idx#2 loop::y_idx#3 loop::y_idx#1 ]
reg byte y [ loop::sy#2 loop::sy#1 ]
reg byte x [ plexInit::i#2 plexInit::i#1 ]
zp[1]:2 [ plexSort::m#2 plexSort::m#1 ]
reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
zp[2]:13 [ PLEX_SCREEN_PTR ]
zp[1]:12 [ plex_show_idx ]
zp[1]:9 [ plex_sprite_idx ]
zp[1]:11 [ plex_sprite_msb ]
zp[1]:10 [ plex_free_next ]
zp[1]:7 [ framedone ]
reg byte x [ plex_irq::plexFreeNextYpos1_return#0 ]
zp[1]:16 [ plex_irq::$4 ]
zp[1]:15 [ plexShowSprite::plex_sprite_idx2#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$0 ]
reg byte x [ plexShowSprite::plexFreeAdd1_$1 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$2 ]
reg byte a [ plexShowSprite::xpos_idx#0 ]
reg byte x [ plexShowSprite::$10 ]
reg byte a [ plexShowSprite::$2 ]
reg byte a [ plexShowSprite::$8 ]
reg byte x [ plexShowSprite::$4 ]
reg byte a [ plexShowSprite::$5 ]
reg byte a [ init::$3 ]
zp[1]:4 [ plexSort::nxt_idx#0 ]
zp[1]:3 [ plexSort::nxt_y#0 ]
reg byte x [ plexSort::s#2 ]


FINAL ASSEMBLER
Score: 43652

  // File Comments
// A simple usage of the flexible sprite multiplexer routine
/// @file
/// Commodore 64 Registers and Constants
/// @file
/// The MOS 6526 Complex Interface Adapter (CIA)
///
/// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
  // Commodore 64 PRG executable file
.file [name="simple-multiplexer-irq.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
  // Global Constants & labels
  /// Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  /// $D011 Control Register #1  Bit#4: DEN Switch VIC-II output on/off
  .const VICII_DEN = $10
  /// $D011 Control Register #1  Bit#3: RSEL Switch betweem 25 or 24 visible rows
  ///          RSEL|  Display window height   | First line  | Last line
  ///          ----+--------------------------+-------------+----------
  ///            0 | 24 text lines/192 pixels |   55 ($37)  | 246 ($f6)
  ///            1 | 25 text lines/200 pixels |   51 ($33)  | 250 ($fa)
  .const VICII_RSEL = 8
  /// VICII IRQ Status/Enable Raster
  // @see #IRQ_ENABLE #IRQ_STATUS
  ///  0 | RST| Reaching a certain raster line. The line is specified by writing
  ///    |    | to register 0xd012 and bit 7 of $d011 and internally stored by
  ///    |    | the VIC for the raster compare. The test for reaching the
  ///    |    | interrupt raster line is done in cycle 0 of every line (for line
  ///    |    | 0, in cycle 1).
  .const IRQ_RASTER = 1
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  /// Sprite X position register for sprite #0
  .label SPRITES_XPOS = $d000
  /// Sprite Y position register for sprite #0
  .label SPRITES_YPOS = $d001
  /// Sprite X position MSB register
  .label SPRITES_XMSB = $d010
  /// Sprite colors register for sprite #0
  .label SPRITES_COLOR = $d027
  /// Sprite enable register
  .label SPRITES_ENABLE = $d015
  /// $D012 RASTER Raster counter
  .label RASTER = $d012
  /// $D020 Border Color
  .label BORDER_COLOR = $d020
  /// $D011 Control Register #1
  /// - Bit#0-#2: YSCROLL Screen Soft Scroll Vertical
  /// - Bit#3: RSEL Switch betweem 25 or 24 visible rows
  ///          RSEL|  Display window height   | First line  | Last line
  ///          ----+--------------------------+-------------+----------
  ///            0 | 24 text lines/192 pixels |   55 ($37)  | 246 ($f6)
  ///            1 | 25 text lines/200 pixels |   51 ($33)  | 250 ($fa)
  /// - Bit#4: DEN Switch VIC-II output on/off
  /// - Bit#5: BMM Turn Bitmap Mode on/off
  /// - Bit#6: ECM Turn Extended Color Mode on/off
  /// - Bit#7: RST8 9th Bit for $D012 Rasterline counter
  /// Initial Value: %10011011
  .label VICII_CONTROL1 = $d011
  /// $D011 Control Register #1
  /// @see #VICII_CONTROL1
  .label D011 = $d011
  /// VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  /// VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  /// The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  /// The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  // Location of screen & sprites
  .label SCREEN = $400
  // The address of the sprite pointers on the current screen (screen+0x3f8).
  .label PLEX_SCREEN_PTR = $d
  // The index in the PLEX tables of the next sprite to show
  .label plex_show_idx = $c
  // The index the next sprite to use for showing (sprites are used round-robin)
  .label plex_sprite_idx = 9
  // The MSB bit of the next sprite to use for showing
  .label plex_sprite_msb = $b
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  .label plex_free_next = $a
  .label framedone = 7
.segment Code
  // __start
__start: {
    // __start::__init1
    // char* volatile PLEX_SCREEN_PTR = (char*)0x400+0x3f8
    // [1] PLEX_SCREEN_PTR = (char *) 1024+$3f8 -- pbuz1=pbuc1 
    lda #<$400+$3f8
    sta.z PLEX_SCREEN_PTR
    lda #>$400+$3f8
    sta.z PLEX_SCREEN_PTR+1
    // volatile char plex_show_idx=0
    // [2] plex_show_idx = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // volatile char plex_sprite_idx=0
    // [3] plex_sprite_idx = 0 -- vbuz1=vbuc1 
    sta.z plex_sprite_idx
    // volatile char plex_sprite_msb=1
    // [4] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // volatile char plex_free_next = 0
    // [5] plex_free_next = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    // volatile bool framedone = true
    // [6] framedone = true -- vboz1=vboc1 
    lda #1
    sta.z framedone
    // [7] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
    // __start::@1
    // [8] call main
    jsr main
    // __start::@return
    // [9] return 
    rts
}
  // plex_irq
plex_irq: {
    .label __4 = $10
    // interrupt(isr_rom_min_c64_entry) -- isr_rom_min_c64_entry 
    // asm
    // asm { sei  }
    sei
    // *BORDER_COLOR = WHITE
    // [11] *BORDER_COLOR = WHITE -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDER_COLOR
    // [12] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
    // plex_irq::@3
  __b3:
    // plexShowSprite()
    // [13] call plexShowSprite
    jsr plexShowSprite
    // plex_irq::plexFreeNextYpos1
    // return PLEX_FREE_YPOS[plex_free_next];
    // [14] plex_irq::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z plex_free_next
    ldx PLEX_FREE_YPOS,y
    // plex_irq::@6
    // *RASTER+2
    // [15] plex_irq::$4 = *RASTER + 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta.z __4
    // while (plex_show_idx < PLEX_COUNT && rasterY < *RASTER+2)
    // [16] if(plex_show_idx>=PLEX_COUNT) goto plex_irq::@4 -- vbuz1_ge_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcs __b4
    // plex_irq::@7
    // [17] if(plex_irq::plexFreeNextYpos1_return#0<plex_irq::$4) goto plex_irq::@3 -- vbuxx_lt_vbuz1_then_la1 
    cpx.z __4
    bcc __b3
    // plex_irq::@4
  __b4:
    // *IRQ_STATUS = IRQ_RASTER
    // [18] *IRQ_STATUS = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // if (plex_show_idx<PLEX_COUNT)
    // [19] if(plex_show_idx<PLEX_COUNT) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcc __b1
    // plex_irq::@5
    // *RASTER = 0x0
    // [20] *RASTER = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
    // framedone = true
    // [21] framedone = true -- vboz1=vboc1 
    lda #1
    sta.z framedone
    // plex_irq::@2
  __b2:
    // *BORDER_COLOR = 0
    // [22] *BORDER_COLOR = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDER_COLOR
    // asm
    // asm { cli  }
    cli
    // plex_irq::@return
    // }
    // [24] return 
    // interrupt(isr_rom_min_c64_exit) -- isr_rom_min_c64_exit 
    jmp $ea81
    // plex_irq::@1
  __b1:
    // *RASTER = rasterY
    // [25] *RASTER = plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuxx 
    stx RASTER
    jmp __b2
}
  // main
main: {
    // asm
    // asm { sei  }
    sei
    // init()
    // [27] call init
    jsr init
    // [28] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // loop()
    // [29] call loop
    // [79] phi from main::@1 to loop [phi:main::@1->loop]
    jsr loop
    // main::@return
    // }
    // [30] return 
    rts
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = $f
    // char plex_sprite_idx2 = plex_sprite_idx*2
    // [31] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // char ypos = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]]
    // [32] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // SPRITES_YPOS[plex_sprite_idx2] = ypos
    // [33] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    // plexShowSprite::plexFreeAdd1
    // ypos+22
    // [34] plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#0 + $16 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$16
    // PLEX_FREE_YPOS[plex_free_next] =  ypos+22
    // [35] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // plex_free_next+1
    // [36] plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_free_next
    inx
    // (plex_free_next+1)&7
    // [37] plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #7
    // plex_free_next = (plex_free_next+1)&7
    // [38] plex_free_next = plexShowSprite::plexFreeAdd1_$2 -- vbuz1=vbuaa 
    sta.z plex_free_next
    // plexShowSprite::@5
    // PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]]
    // [39] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] -- pbuz1_derefidx_vbuz2=pbuc1_derefidx_(pbuc2_derefidx_vbuz3) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldy.z plex_sprite_idx
    sta (PLEX_SCREEN_PTR),y
    // char xpos_idx = PLEX_SORTED_IDX[plex_show_idx]
    // [40] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // SPRITES_XPOS[plex_sprite_idx2] = (char)PLEX_XPOS[xpos_idx]
    // [41] plexShowSprite::$10 = plexShowSprite::xpos_idx#0 << 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [42] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = (char)PLEX_XPOS[plexShowSprite::$10] -- pbuc1_derefidx_vbuz1=_byte_pwuc2_derefidx_vbuxx 
    ldy.z plex_sprite_idx2
    lda PLEX_XPOS,x
    sta SPRITES_XPOS,y
    // BYTE1(PLEX_XPOS[xpos_idx])
    // [43] plexShowSprite::$2 = byte1  PLEX_XPOS[plexShowSprite::$10] -- vbuaa=_byte1_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // if(BYTE1(PLEX_XPOS[xpos_idx])!=0)
    // [44] if(plexShowSprite::$2!=0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b1
    // plexShowSprite::@3
    // 0xff^plex_sprite_msb
    // [45] plexShowSprite::$8 = $ff ^ plex_sprite_msb -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // *SPRITES_XMSB &= (0xff^plex_sprite_msb)
    // [46] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$8 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    // plexShowSprite::@2
  __b2:
    // plex_sprite_idx+1
    // [47] plexShowSprite::$4 = plex_sprite_idx + 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // (plex_sprite_idx+1)&7
    // [48] plexShowSprite::$5 = plexShowSprite::$4 & 7 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #7
    // plex_sprite_idx = (plex_sprite_idx+1)&7
    // [49] plex_sprite_idx = plexShowSprite::$5 -- vbuz1=vbuaa 
    sta.z plex_sprite_idx
    // plex_show_idx++;
    // [50] plex_show_idx = ++ plex_show_idx -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // plex_sprite_msb <<=1
    // [51] plex_sprite_msb = plex_sprite_msb << 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // if(plex_sprite_msb==0)
    // [52] if(plex_sprite_msb!=0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    bne __breturn
    // plexShowSprite::@4
    // plex_sprite_msb = 1
    // [53] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // plexShowSprite::@return
  __breturn:
    // }
    // [54] return 
    rts
    // plexShowSprite::@1
  __b1:
    // *SPRITES_XMSB |= plex_sprite_msb
    // [55] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // init
// Initialize the program
init: {
    // Set the x-positions & pointers
    .label xp = 5
    // *D011 = VICII_DEN | VICII_RSEL | 3
    // [56] *D011 = VICII_DEN|VICII_RSEL|3 -- _deref_pbuc1=vbuc2 
    lda #VICII_DEN|VICII_RSEL|3
    sta D011
    // plexInit(SCREEN)
    // [57] call plexInit
  // Initialize the multiplexer
    // [94] phi from init to plexInit [phi:init->plexInit]
    jsr plexInit
    // [58] phi from init to init::@1 [phi:init->init::@1]
    // [58] phi init::xp#2 = $20 [phi:init->init::@1#0] -- vwuz1=vwuc1 
    lda #<$20
    sta.z xp
    lda #>$20
    sta.z xp+1
    // [58] phi init::sx#2 = 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [58] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
    // [58] phi init::xp#2 = init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
    // [58] phi init::sx#2 = init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    // init::@1
  __b1:
    // PLEX_PTR[sx] = (char)(SPRITE/0x40)
    // [59] PLEX_PTR[init::sx#2] = (char)SPRITE/$40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #$ff&SPRITE/$40
    sta PLEX_PTR,x
    // PLEX_XPOS[sx] = xp
    // [60] init::$3 = init::sx#2 << 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [61] PLEX_XPOS[init::$3] = init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda.z xp
    sta PLEX_XPOS,y
    lda.z xp+1
    sta PLEX_XPOS+1,y
    // xp += 9
    // [62] init::xp#1 = init::xp#2 + 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc.z xp
    sta.z xp
    bcc !+
    inc.z xp+1
  !:
    // for(char sx: 0..PLEX_COUNT-1)
    // [63] init::sx#1 = ++ init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
    // [64] if(init::sx#1!=PLEX_COUNT-1+1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1
    // init::@2
    // *SPRITES_ENABLE = 0xff
    // [65] *SPRITES_ENABLE = $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [66] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
    // [66] phi init::ss#2 = 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    // [66] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
    // [66] phi init::ss#2 = init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    // init::@3
  __b3:
    // SPRITES_COLOR[ss] = GREEN
    // [67] SPRITES_COLOR[init::ss#2] = GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLOR,x
    // for(char ss: 0..7)
    // [68] init::ss#1 = ++ init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
    // [69] if(init::ss#1!=8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3
    // init::@4
    // asm
    // asm { sei  }
    // enable the interrupt
    sei
    // CIA1->INTERRUPT = CIA_INTERRUPT_CLEAR
    // [71] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // *IRQ_ENABLE = IRQ_RASTER
    // [72] *IRQ_ENABLE = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // *IRQ_STATUS = IRQ_RASTER
    // [73] *IRQ_STATUS = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    sta IRQ_STATUS
    // *KERNEL_IRQ = &plex_irq
    // [74] *KERNEL_IRQ = &plex_irq -- _deref_qprc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
    // *VICII_CONTROL1 &= 0x7f
    // [75] *VICII_CONTROL1 = *VICII_CONTROL1 & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VICII_CONTROL1
    sta VICII_CONTROL1
    // *RASTER = 0x0
    // [76] *RASTER = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
    // asm
    // asm { cli  }
    cli
    // init::@return
    // }
    // [78] return 
    rts
}
  // loop
// The raster loop
loop: {
    // The current index into the y-sine
    .label sin_idx = 8
    // [80] phi from loop to loop::@1 [phi:loop->loop::@1]
    // [80] phi loop::sin_idx#6 = 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    // loop::@1
    // loop::@2
  __b2:
    // while(!framedone)
    // [81] if(framedone) goto loop::@3 -- vboz1_then_la1 
    lda.z framedone
    cmp #0
    bne __b3
    jmp __b2
    // loop::@3
  __b3:
    // *BORDER_COLOR = RED
    // [82] *BORDER_COLOR = RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDER_COLOR
    // [83] loop::y_idx#3 = loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx.z sin_idx
    // [84] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
    // [84] phi loop::sy#2 = 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
    // [84] phi loop::y_idx#2 = loop::y_idx#3 [phi:loop::@3->loop::@4#1] -- register_copy 
    // [84] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
    // [84] phi loop::sy#2 = loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [84] phi loop::y_idx#2 = loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    // loop::@4
  __b4:
    // PLEX_YPOS[sy] = YSIN[y_idx]
    // [85] PLEX_YPOS[loop::sy#2] = YSIN[loop::y_idx#2] -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
    // y_idx += 8
    // [86] loop::y_idx#1 = loop::y_idx#2 + 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
    // for(char sy: 0..PLEX_COUNT-1)
    // [87] loop::sy#1 = ++ loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
    // [88] if(loop::sy#1!=PLEX_COUNT-1+1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne __b4
    // loop::@5
    // sin_idx +=1
    // [89] loop::sin_idx#1 = loop::sin_idx#6 + 1 -- vbuz1=vbuz1_plus_1 
    inc.z sin_idx
    // (*BORDER_COLOR)++;
    // [90] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // plexSort()
    // [91] call plexSort
    // [101] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
    jsr plexSort
    // loop::@6
    // *BORDER_COLOR = GREEN
    // [92] *BORDER_COLOR = GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDER_COLOR
    // framedone = false
    // [93] framedone = false -- vboz1=vboc1 
    lda #0
    sta.z framedone
    // [80] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
    // [80] phi loop::sin_idx#6 = loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
    jmp __b2
}
  // plexInit
// Initialize the multiplexer data structures
// void plexInit(char *screen)
plexInit: {
    // plexInit::plexSetScreen1
    // PLEX_SCREEN_PTR = screen+0x3f8
    // [95] PLEX_SCREEN_PTR = SCREEN+$3f8 -- pbuz1=pbuc1 
    lda #<SCREEN+$3f8
    sta.z PLEX_SCREEN_PTR
    lda #>SCREEN+$3f8
    sta.z PLEX_SCREEN_PTR+1
    // [96] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
    // [96] phi plexInit::i#2 = 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [96] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
    // [96] phi plexInit::i#2 = plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    // plexInit::@1
  __b1:
    // PLEX_SORTED_IDX[i] = i
    // [97] PLEX_SORTED_IDX[plexInit::i#2] = plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // for(char i: 0..PLEX_COUNT-1)
    // [98] plexInit::i#1 = ++ plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [99] if(plexInit::i#1!=PLEX_COUNT-1+1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1
    // plexInit::@return
    // }
    // [100] return 
    rts
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = 4
    .label nxt_y = 3
    .label m = 2
    // [102] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
    // [102] phi plexSort::m#2 = 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    // [102] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
    // [102] phi plexSort::m#2 = plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    // plexSort::@1
  __b1:
    // char nxt_idx = PLEX_SORTED_IDX[m+1]
    // [103] plexSort::nxt_idx#0 = (PLEX_SORTED_IDX+1)[plexSort::m#2] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // char nxt_y = PLEX_YPOS[nxt_idx]
    // [104] plexSort::nxt_y#0 = PLEX_YPOS[plexSort::nxt_idx#0] -- vbuz1=pbuc1_derefidx_vbuz2 
    tay
    lda PLEX_YPOS,y
    sta.z nxt_y
    // if(nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[m]])
    // [105] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    // plexSort::@5
    // [106] plexSort::s#6 = plexSort::m#2 -- vbuxx=vbuz1 
    // [107] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
    // [107] phi plexSort::s#3 = plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
    // plexSort::@3
  __b3:
    // PLEX_SORTED_IDX[s+1] = PLEX_SORTED_IDX[s]
    // [108] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // s--;
    // [109] plexSort::s#1 = -- plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // while((s!=0xff) && (nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[s]]))
    // [110] if(plexSort::s#1==$ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq __b4
    // plexSort::@7
    // [111] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3
    // plexSort::@4
  __b4:
    // s++;
    // [112] plexSort::s#2 = ++ plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // PLEX_SORTED_IDX[s] = nxt_idx
    // [113] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    // plexSort::@2
  __b2:
    // for(char m: 0..PLEX_COUNT-2)
    // [114] plexSort::m#1 = ++ plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [115] if(plexSort::m#1!=PLEX_COUNT-2+1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1
    // plexSort::@6
    // plex_show_idx = 0
    // [116] plex_show_idx = 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta.z plex_show_idx
    // plex_sprite_idx = 0
    // [117] plex_sprite_idx = 0 -- vbuz1=vbuc1 
    sta.z plex_sprite_idx
    // plex_sprite_msb = 1
    // [118] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [119] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
    // plexSort::plexFreePrepare1
    // [120] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
    // [120] phi plexSort::plexFreePrepare1_s#2 = 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [120] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
    // [120] phi plexSort::plexFreePrepare1_s#2 = plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // PLEX_FREE_YPOS[s] = 0
    // [121] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // for( char s: 0..7)
    // [122] plexSort::plexFreePrepare1_s#1 = ++ plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [123] if(plexSort::plexFreePrepare1_s#1!=8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1___b1
    // plexSort::plexFreePrepare1_@2
    // plex_free_next = 0
    // [124] plex_free_next = 0 -- vbuz1=vbuc1 
    sta.z plex_free_next
    // plexSort::@return
    // }
    // [125] return 
    rts
}
  // File Data
.segment Data
  // The x-positions of the multiplexer sprites (0x000-0x1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  .align $40
SPRITE:
.var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)

  .align $100
YSIN:
.fill $100, round(139.5+89.5*sin(toRadians(360*i/256)))


