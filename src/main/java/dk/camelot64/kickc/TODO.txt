Features
- Move the main code into a main() function, and disallow code outside functions. The main function per default has no parameters and exits with RTS.
- Add a for loop for(init;condition;increment) {stmt} -> { init; do { stmt; increment } while (condition) }
- Add for loop for(byte i: 1..100) { } and for(byte i : 100..0) {}  (plus maybe .+. and .-. to make the inc/dec unambiguous)
- Add signed bytes
- Add signed words
- Add Fixed Point number types fixed[8.8], fixed[16.8] - maybe even fixed[24.4]
- Add imports
- Add structs
- Add possibility of declaring in-program data - just like .byte/.fill in KickAss.
- Let { stmt } introduce a new anonymous scope. (But not when optimizing)
- Add preprocessing / find a way to allow some functions to run at compile time
- Implement inline compilation of functions (and a mechanism for choosing which methods / calls to inline)
- Add ability to call ASM code from KC.
- Add ability to call KC code from ASM. (Maybe declare some functions external to ensure their interface is well defined. Maybe generate ASM call stubs.)
- Add an export keyword ensuring that a function is generated even if it is never called. Maybe export can be handled by generating a call that can be used as stub.
- Add inline ASM (maybe?)
- Handle long branches
- Allow complex array expressions in lValues eg. (SCREEN+$100)[idx]
- Optimize loops by unrolling them somewhat
- Optimize loops with Strength reduction (https://en.wikipedia.org/wiki/Strength_reduction)
+ Create a proper main function for the compiler
+ Add ++/-- incrementing/decrementing operators.
+ Optimize if's without else if(expr) { stmt; } -> $1=!expr; if($1) goto @1; stmt; @1:

Assembler Improvements
- Make generated ASM human readable.
  + Use hex-numbers
  - add labels for constants and zp-variables.
+ Eliminate unnecessary labels in ASM
- Eliminate CPX from DEX, CPX #0, BNE la1
- Eliminate LDA from DEC $2, LDA $2, BNE la1
- Eliminate LDA from STA $11, LDA $11
- Optimize by allowing resequencing of ASM (statements and phi assignments) in a final phase.

Known Problems
+ Procedures that modify variables outside their scope does not work. Outer vars must be transfered in/out like parameters/return values to get it working.
+ Alive vars are propagated backward through procedures (correctly). However they are then propagated back through ALL calls to the procedure incorrectly. They should only be alive at calls where they are alive after the call. In summin.kc s1#0 is incirrectly backpropagated through the first call, where it is not alive.

Register Allocation
- Allow user to limit number of combinations tested
- Safe-Copy based SSA deconstruction
  - Reuse phi-transitions that are identical
  - Optimize phi transitions by ensuring that identical phi-transitions with regards to register allocation are collected into a single transition.
  - Optimize by finding optimal sequence for multiple phi assignments in entry-segments.
  - Avoid clobbering alive vars
- Maybe support several fragments for the same operation with different cost and clobbering profiles.
- Add memory registers (if we need to free some ZP)
+ Limit number of combinations tested
+ Equivalences not tested through combinaitons should be tested individually afterwards.
+ Matrix Phi operation (instead of separate statements)
+ Phi Lifting
+ PhiLifting & PhiMemCoalesce (http://compilers.cs.ucla.edu/fernando/projects/soc/reports/short_tech.pdf)
+ Interval Analysis (variable liveness intervals)
+ ComputeLoopNestDepth(b) - Assign loop nesting levels to blocks.
+ ComputeRegisterPreference(v), ComputeWeight(v)
+ CalculateClobbering(i)
+ Register types: A, X, Y, ZP, (memory).
+ Implement a register allocation (coloring) algorithm using by liveness intervals, preferences, weights & clobbering information.
  + Optimize register allocation by combining with knowledge of ASM program cost (bytes/cycles) and different ASM fragments with different clobbering.

Process/Code Structure Improvement
- Eliminate copy visitor
- Refactor Expression Operator Implementation & Evaluation into one class per operator
- Improve error messages to give better context
- Offer to compile resulting ASM with KickAssembler
+ Implemenent Assertions for the output of different phases (ensuring that the result of the phase is consistent)
+ Make each phase return a separate object graph (allowing for keeeping the history in memory & performing rollbacks)

Testing
- Test that the parse tree for specific KC syntax is as expected. Use a print function for the parse tree to generate output for comparison.
- Test the ICL result of a specific phase on a specific ICL input. Create an ICL syntax for parsing directly to ICL and a printer for the syntax.
- Emulate/Run the ASM for a specific KC program compiled. Compare the emulated ASM output to output calculated by executing directly on the KC tree.
- Add assert statements to the language. Create KC programs that test the compiler by compiling, running and testing assertions.
+ Test the ASM program output resulting from compiling specific KC program input.

Usages
- Implement library for memory allocation in main memory
- Implement library for output on the screen (using basic functions)

Real Usage
- Implement library for fast multiply (mul.asm)
- Implement spline library (spline.asm)
- Implement polygon filler for complex polygons.
- Implement a true type font renderer.