
CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start
  fill::screen#0 = (byte*)$400
  fill::ch#0 = 'a'
  call fill 
  to:main::@1
main::@1: scope:[main]  from main
  fill::screen#1 = (byte*)$2000
  fill::ch#1 = 'b'
  call fill 
  to:main::@2
main::@2: scope:[main]  from main::@1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return

void fill(byte* fill::screen , byte fill::ch)
fill: scope:[fill]  from main main::@1
  fill::ch#4 = phi( main/fill::ch#0, main::@1/fill::ch#1 )
  fill::screen#4 = phi( main/fill::screen#0, main::@1/fill::screen#1 )
  fill::i#0 = 0
  to:fill::@1
fill::@1: scope:[fill]  from fill fill::@3
  fill::i#4 = phi( fill/fill::i#0, fill::@3/fill::i#1 )
  fill::ch#3 = phi( fill/fill::ch#4, fill::@3/fill::ch#5 )
  fill::screen#3 = phi( fill/fill::screen#4, fill::@3/fill::screen#5 )
  fill::j#0 = 0
  to:fill::@2
fill::@2: scope:[fill]  from fill::@1 fill::@2
  fill::i#2 = phi( fill::@1/fill::i#4, fill::@2/fill::i#2 )
  fill::ch#2 = phi( fill::@1/fill::ch#3, fill::@2/fill::ch#2 )
  fill::screen#2 = phi( fill::@1/fill::screen#3, fill::@2/fill::screen#2 )
  fill::j#2 = phi( fill::@1/fill::j#0, fill::@2/fill::j#1 )
  fill::$0 = fill::j#2 * $28
  fill::$1 = fill::screen#2 + fill::$0
  fill::$1[fill::i#2] = fill::ch#2
  fill::j#1 = fill::j#2 + rangenext(0,2)
  fill::$2 = fill::j#1 != rangelast(0,2)
  unroll if(fill::$2) goto fill::@2
  to:fill::@3
fill::@3: scope:[fill]  from fill::@2
  fill::ch#5 = phi( fill::@2/fill::ch#2 )
  fill::screen#5 = phi( fill::@2/fill::screen#2 )
  fill::i#3 = phi( fill::@2/fill::i#2 )
  fill::i#1 = fill::i#3 + rangenext(0,$27)
  fill::$3 = fill::i#1 != rangelast(0,$27)
  if(fill::$3) goto fill::@1
  to:fill::@return
fill::@return: scope:[fill]  from fill::@3
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
void __start()
void fill(byte* fill::screen , byte fill::ch)
number~ fill::$0
byte*~ fill::$1
bool~ fill::$2
bool~ fill::$3
byte fill::ch
byte fill::ch#0
byte fill::ch#1
byte fill::ch#2
byte fill::ch#3
byte fill::ch#4
byte fill::ch#5
byte fill::i
byte fill::i#0
byte fill::i#1
byte fill::i#2
byte fill::i#3
byte fill::i#4
byte fill::j
byte fill::j#0
byte fill::j#1
byte fill::j#2
byte* fill::screen
byte* fill::screen#0
byte* fill::screen#1
byte* fill::screen#2
byte* fill::screen#3
byte* fill::screen#4
byte* fill::screen#5
void main()

Adding number conversion cast (unumber) $28 in fill::$0 = fill::j#2 * $28
Adding number conversion cast (unumber) fill::$0 in fill::$0 = fill::j#2 * (unumber)$28
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 8192
Simplifying constant integer cast $28
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in fill::$0 = fill::j#2 * $28
Alias fill::i#2 = fill::i#3 
Alias fill::screen#2 = fill::screen#5 
Alias fill::ch#2 = fill::ch#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values fill::screen#2 fill::screen#3
Identical Phi Values fill::ch#2 fill::ch#3
Identical Phi Values fill::i#2 fill::i#4
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values fill::screen#3 fill::screen#4
Identical Phi Values fill::ch#3 fill::ch#4
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition fill::$2 [17] unroll if(fill::j#1!=rangelast(0,2)) goto fill::@2
Simple Condition fill::$3 [20] if(fill::i#1!=rangelast(0,$27)) goto fill::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant fill::screen#0 = (byte*) 1024
Constant fill::ch#0 = 'a'
Constant fill::screen#1 = (byte*) 8192
Constant fill::ch#1 = 'b'
Constant fill::i#0 = 0
Constant fill::j#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [15] fill::j#1 = ++ fill::j#2 to ++
Resolved ranged comparison value [17] unroll if(fill::j#1!=rangelast(0,2)) goto fill::@2 to 3
Resolved ranged next value [18] fill::i#1 = ++ fill::i#4 to ++
Resolved ranged comparison value [20] if(fill::i#1!=rangelast(0,$27)) goto fill::@1 to $28
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) 3 in [10] unroll if(fill::j#1!=3) goto fill::@2
Adding number conversion cast (unumber) $28 in [12] if(fill::i#1!=$28) goto fill::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 3
Simplifying constant integer cast $28
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Unrolling loop Loop head: fill::@2 tails: fill::@2 blocks: fill::@2 
Successful SSA optimization Pass2LoopUnroll
Identical Phi Values fill::j#2 fill::j#0
Successful SSA optimization Pass2IdenticalPhiElimination
Negating conditional jump and destination [10] if(fill::j#1==3) goto fill::@3
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [6] fill::$0 = fill::j#0 * $28
Constant right-side identified [9] fill::j#1 = ++ fill::j#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant fill::$0 = fill::j#0*$28
Constant fill::j#1 = ++fill::j#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always false - eliminating [10] if(fill::j#1==3) goto fill::@3
Successful SSA optimization Pass2ConstantIfs
Simplifying constant evaluating to zero fill::j#0*$28 in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero fill::screen#4 in [7] fill::$1 = fill::screen#4 + fill::$0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant fill::$0
Successful SSA optimization PassNEliminateUnusedVars
Alias fill::screen#4 = fill::$1 
Successful SSA optimization Pass2AliasElimination
Unrolling loop Loop head: fill::@2_1 tails: fill::@2_1 blocks: fill::@2_1 
Successful SSA optimization Pass2LoopUnroll
Identical Phi Values fill::j#3 fill::j#1
Successful SSA optimization Pass2IdenticalPhiElimination
Negating conditional jump and destination [11] if(fill::j#4==3) goto fill::@3
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [7] fill::$4 = fill::j#1 * $28
Constant right-side identified [10] fill::j#4 = ++ fill::j#1
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant fill::$4 = fill::j#1*$28
Constant fill::j#4 = ++fill::j#1
Successful SSA optimization Pass2ConstantIdentification
if() condition always false - eliminating [11] if(fill::j#4==3) goto fill::@3
Successful SSA optimization Pass2ConstantIfs
Unrolling loop Loop head: fill::@2_2 tails: fill::@2_2 blocks: fill::@2_2 
Successful SSA optimization Pass2LoopUnroll
Identical Phi Values fill::j#5 fill::j#4
Successful SSA optimization Pass2IdenticalPhiElimination
Negating conditional jump and destination [13] if(fill::j#6==3) goto fill::@3
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [9] fill::$6 = fill::j#4 * $28
Constant right-side identified [12] fill::j#6 = ++ fill::j#4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant fill::$6 = fill::j#4*$28
Constant fill::j#6 = ++fill::j#4
Successful SSA optimization Pass2ConstantIdentification
Removing PHI-reference to removed block (fill::@2_2) in block fill::@2_3
if() condition always true - replacing block destination [13] if(fill::j#6==3) goto fill::@3
Successful SSA optimization Pass2ConstantIfs
Eliminating unused constant fill::j#6
Successful SSA optimization PassNEliminateUnusedVars
Eliminating variable fill::j#7 from unused block fill::@2_3
Eliminating variable fill::$8 from unused block fill::@2_3
Eliminating variable fill::$9 from unused block fill::@2_3
Eliminating variable fill::j#8 from unused block fill::@2_3
Removing unused block fill::@2_3
Successful SSA optimization Pass2EliminateUnusedBlocks
Inlining constant with var siblings fill::screen#0
Inlining constant with var siblings fill::ch#0
Inlining constant with var siblings fill::screen#1
Inlining constant with var siblings fill::ch#1
Inlining constant with var siblings fill::i#0
Inlining constant with different constant siblings fill::j#0
Inlining constant with different constant siblings fill::j#1
Inlining constant with different constant siblings fill::j#4
Constant inlined fill::j#4 = ++++0
Constant inlined fill::ch#0 = 'a'
Constant inlined fill::screen#1 = (byte*) 8192
Constant inlined fill::screen#0 = (byte*) 1024
Constant inlined fill::i#0 = 0
Constant inlined fill::$6 = ++++0*$28
Constant inlined fill::ch#1 = 'b'
Constant inlined fill::j#1 = ++0
Constant inlined fill::$4 = ++0*$28
Constant inlined fill::j#0 = 0
Successful SSA optimization Pass2ConstantInlining
Simplifying constant integer increment ++0
Simplifying constant integer increment ++0
Successful SSA optimization Pass2ConstantSimplification
Simplifying constant integer increment ++1
Successful SSA optimization Pass2ConstantSimplification
Added new block during phi lifting fill::@4(between fill::@3 and fill::@1)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
CALL GRAPH
Calls in [main] to fill:1 fill:3 

Created 3 initial phi equivalence classes
Coalesced [16] fill::i#5 = fill::i#1
Coalesced down to 3 phi equivalence classes
Culled Empty Block label main::@2
Culled Empty Block label fill::@4
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call fill 
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call fill 
  to:main::@return
main::@return: scope:[main]  from main::@1
  [4] return 
  to:@return

void fill(byte* fill::screen , byte fill::ch)
fill: scope:[fill]  from main main::@1
  [5] fill::ch#4 = phi( main/'a', main::@1/'b' )
  [5] fill::screen#4 = phi( main/(byte*) 1024, main::@1/(byte*) 8192 )
  to:fill::@1
fill::@1: scope:[fill]  from fill fill::@3
  [6] fill::i#4 = phi( fill/0, fill::@3/fill::i#1 )
  to:fill::@2
fill::@2: scope:[fill]  from fill::@1
  [7] fill::screen#4[fill::i#4] = fill::ch#4
  to:fill::@2_1
fill::@2_1: scope:[fill]  from fill::@2
  [8] fill::$5 = fill::screen#4 + 1*$28
  [9] fill::$5[fill::i#4] = fill::ch#4
  to:fill::@2_2
fill::@2_2: scope:[fill]  from fill::@2_1
  [10] fill::$7 = fill::screen#4 + 2*$28
  [11] fill::$7[fill::i#4] = fill::ch#4
  to:fill::@3
fill::@3: scope:[fill]  from fill::@2_2
  [12] fill::i#1 = ++ fill::i#4
  [13] if(fill::i#1!=$28) goto fill::@1
  to:fill::@return
fill::@return: scope:[fill]  from fill::@3
  [14] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void fill(byte* fill::screen , byte fill::ch)
byte*~ fill::$5 202.0
byte*~ fill::$7 202.0
byte fill::ch
byte fill::ch#4 33.666666666666664
byte fill::i
byte fill::i#1 151.5
byte fill::i#4 84.16666666666666
byte fill::j
byte* fill::screen
byte* fill::screen#4 33.666666666666664
void main()

Initial phi equivalence classes
[ fill::screen#4 ]
[ fill::ch#4 ]
[ fill::i#4 fill::i#1 ]
Added variable fill::$5 to live range equivalence class [ fill::$5 ]
Added variable fill::$7 to live range equivalence class [ fill::$7 ]
Complete equivalence classes
[ fill::screen#4 ]
[ fill::ch#4 ]
[ fill::i#4 fill::i#1 ]
[ fill::$5 ]
[ fill::$7 ]
Allocated zp[2]:2 [ fill::screen#4 ]
Allocated zp[1]:4 [ fill::ch#4 ]
Allocated zp[1]:5 [ fill::i#4 fill::i#1 ]
Allocated zp[2]:6 [ fill::$5 ]
Allocated zp[2]:8 [ fill::$7 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [8] fill::$5 = fill::screen#4 + 1*$28 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$5 ] ( fill:1 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$5 ] { }  fill:3 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$5 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ fill::ch#4 ]
Removing always clobbered register reg byte a as potential for zp[1]:5 [ fill::i#4 fill::i#1 ]
Statement [9] fill::$5[fill::i#4] = fill::ch#4 [ fill::screen#4 fill::ch#4 fill::i#4 ] ( fill:1 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  fill:3 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  ) always clobbers reg byte a 
Statement [10] fill::$7 = fill::screen#4 + 2*$28 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$7 ] ( fill:1 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$7 ] { }  fill:3 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$7 ] { }  ) always clobbers reg byte a 
Statement [11] fill::$7[fill::i#4] = fill::ch#4 [ fill::screen#4 fill::ch#4 fill::i#4 ] ( fill:1 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  fill:3 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  ) always clobbers reg byte a 
Statement [7] fill::screen#4[fill::i#4] = fill::ch#4 [ fill::screen#4 fill::ch#4 fill::i#4 ] ( fill:1 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  fill:3 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  ) always clobbers reg byte a 
Statement [8] fill::$5 = fill::screen#4 + 1*$28 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$5 ] ( fill:1 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$5 ] { }  fill:3 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$5 ] { }  ) always clobbers reg byte a 
Statement [9] fill::$5[fill::i#4] = fill::ch#4 [ fill::screen#4 fill::ch#4 fill::i#4 ] ( fill:1 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  fill:3 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  ) always clobbers reg byte a 
Statement [10] fill::$7 = fill::screen#4 + 2*$28 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$7 ] ( fill:1 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$7 ] { }  fill:3 [ fill::screen#4 fill::ch#4 fill::i#4 fill::$7 ] { }  ) always clobbers reg byte a 
Statement [11] fill::$7[fill::i#4] = fill::ch#4 [ fill::screen#4 fill::ch#4 fill::i#4 ] ( fill:1 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  fill:3 [ fill::screen#4 fill::ch#4 fill::i#4 ] { }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ fill::screen#4 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ fill::ch#4 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ fill::i#4 fill::i#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[2]:6 [ fill::$5 ] : zp[2]:6 , 
Potential registers zp[2]:8 [ fill::$7 ] : zp[2]:8 , 

REGISTER UPLIFT SCOPES
Uplift Scope [fill] 235.67: zp[1]:5 [ fill::i#4 fill::i#1 ] 202: zp[2]:6 [ fill::$5 ] 202: zp[2]:8 [ fill::$7 ] 33.67: zp[2]:2 [ fill::screen#4 ] 33.67: zp[1]:4 [ fill::ch#4 ] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [fill] best 949 combination reg byte y [ fill::i#4 fill::i#1 ] zp[2]:6 [ fill::$5 ] zp[2]:8 [ fill::$7 ] zp[2]:2 [ fill::screen#4 ] reg byte x [ fill::ch#4 ] 
Uplifting [main] best 949 combination 
Uplifting [] best 949 combination 
Allocated (was zp[2]:6) zp[2]:4 [ fill::$5 ]
Allocated (was zp[2]:8) zp[2]:6 [ fill::$7 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests elimination of plus 0
  // Upstart
  // Commodore 64 PRG executable file
.file [name="plus-0.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    // [1] call fill 
    // [5] phi from main to fill [phi:main->fill]
  fill_from_main:
    // [5] phi fill::ch#4 = 'a' [phi:main->fill#0] -- vbuxx=vbuc1 
    ldx #'a'
    // [5] phi fill::screen#4 = (byte*) 1024 [phi:main->fill#1] -- pbuz1=pbuc1 
    lda #<$400
    sta.z fill.screen
    lda #>$400
    sta.z fill.screen+1
    jsr fill
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call fill 
    // [5] phi from main::@1 to fill [phi:main::@1->fill]
  fill_from___b1:
    // [5] phi fill::ch#4 = 'b' [phi:main::@1->fill#0] -- vbuxx=vbuc1 
    ldx #'b'
    // [5] phi fill::screen#4 = (byte*) 8192 [phi:main::@1->fill#1] -- pbuz1=pbuc1 
    lda #<$2000
    sta.z fill.screen
    lda #>$2000
    sta.z fill.screen+1
    jsr fill
    jmp __breturn
    // main::@return
  __breturn:
    // [4] return 
    rts
}
  // fill
// fill(byte* zp(2) screen, byte register(X) ch)
fill: {
    .label screen = 2
    .label __5 = 4
    .label __7 = 6
    // [6] phi from fill to fill::@1 [phi:fill->fill::@1]
  __b1_from_fill:
    // [6] phi fill::i#4 = 0 [phi:fill->fill::@1#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b1
    // [6] phi from fill::@3 to fill::@1 [phi:fill::@3->fill::@1]
  __b1_from___b3:
    // [6] phi fill::i#4 = fill::i#1 [phi:fill::@3->fill::@1#0] -- register_copy 
    jmp __b1
    // fill::@1
  __b1:
    jmp __b2
    // fill::@2
  __b2:
    // [7] fill::screen#4[fill::i#4] = fill::ch#4 -- pbuz1_derefidx_vbuyy=vbuxx 
    txa
    sta (screen),y
    jmp __b2_1
    // fill::@2_1
  __b2_1:
    // [8] fill::$5 = fill::screen#4 + 1*$28 -- pbuz1=pbuz2_plus_vbuc1 
    lda #1*$28
    clc
    adc.z screen
    sta.z __5
    lda #0
    adc.z screen+1
    sta.z __5+1
    // [9] fill::$5[fill::i#4] = fill::ch#4 -- pbuz1_derefidx_vbuyy=vbuxx 
    txa
    sta (__5),y
    jmp __b2_2
    // fill::@2_2
  __b2_2:
    // [10] fill::$7 = fill::screen#4 + 2*$28 -- pbuz1=pbuz2_plus_vbuc1 
    lda #2*$28
    clc
    adc.z screen
    sta.z __7
    lda #0
    adc.z screen+1
    sta.z __7+1
    // [11] fill::$7[fill::i#4] = fill::ch#4 -- pbuz1_derefidx_vbuyy=vbuxx 
    txa
    sta (__7),y
    jmp __b3
    // fill::@3
  __b3:
    // [12] fill::i#1 = ++ fill::i#4 -- vbuyy=_inc_vbuyy 
    iny
    // [13] if(fill::i#1!=$28) goto fill::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$28
    bne __b1_from___b3
    jmp __breturn
    // fill::@return
  __breturn:
    // [14] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b2_1
Removing instruction jmp __b2_2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1 with __b2
Replacing label __b1_from___b3 with __b2
Removing instruction __b1_from_main:
Removing instruction fill_from___b1:
Removing instruction __b1_from___b3:
Removing instruction __b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction fill_from_main:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b1_from_fill:
Removing instruction __b2_1:
Removing instruction __b2_2:
Removing instruction __b3:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b2
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
void fill(byte* fill::screen , byte fill::ch)
byte*~ fill::$5 zp[2]:4 202.0
byte*~ fill::$7 zp[2]:6 202.0
byte fill::ch
byte fill::ch#4 reg byte x 33.666666666666664
byte fill::i
byte fill::i#1 reg byte y 151.5
byte fill::i#4 reg byte y 84.16666666666666
byte fill::j
byte* fill::screen
byte* fill::screen#4 screen zp[2]:2 33.666666666666664
void main()

zp[2]:2 [ fill::screen#4 ]
reg byte x [ fill::ch#4 ]
reg byte y [ fill::i#4 fill::i#1 ]
zp[2]:4 [ fill::$5 ]
zp[2]:6 [ fill::$7 ]


FINAL ASSEMBLER
Score: 733

  // File Comments
// Tests elimination of plus 0
  // Upstart
  // Commodore 64 PRG executable file
.file [name="plus-0.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    // fill((byte*)$400,'a')
    // [1] call fill 
    // [5] phi from main to fill [phi:main->fill]
    // [5] phi fill::ch#4 = 'a' [phi:main->fill#0] -- vbuxx=vbuc1 
    ldx #'a'
    // [5] phi fill::screen#4 = (byte*) 1024 [phi:main->fill#1] -- pbuz1=pbuc1 
    lda #<$400
    sta.z fill.screen
    lda #>$400
    sta.z fill.screen+1
    jsr fill
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // fill((byte*)$2000,'b')
    // [3] call fill 
    // [5] phi from main::@1 to fill [phi:main::@1->fill]
    // [5] phi fill::ch#4 = 'b' [phi:main::@1->fill#0] -- vbuxx=vbuc1 
    ldx #'b'
    // [5] phi fill::screen#4 = (byte*) 8192 [phi:main::@1->fill#1] -- pbuz1=pbuc1 
    lda #<$2000
    sta.z fill.screen
    lda #>$2000
    sta.z fill.screen+1
    jsr fill
    // main::@return
    // }
    // [4] return 
    rts
}
  // fill
// fill(byte* zp(2) screen, byte register(X) ch)
fill: {
    .label screen = 2
    .label __5 = 4
    .label __7 = 6
    // [6] phi from fill to fill::@1 [phi:fill->fill::@1]
    // [6] phi fill::i#4 = 0 [phi:fill->fill::@1#0] -- vbuyy=vbuc1 
    ldy #0
    // [6] phi from fill::@3 to fill::@1 [phi:fill::@3->fill::@1]
    // [6] phi fill::i#4 = fill::i#1 [phi:fill::@3->fill::@1#0] -- register_copy 
    // fill::@1
    // fill::@2
  __b2:
    // (screen+j*40)[i] = ch
    // [7] fill::screen#4[fill::i#4] = fill::ch#4 -- pbuz1_derefidx_vbuyy=vbuxx 
    txa
    sta (screen),y
    // fill::@2_1
    // screen+j*40
    // [8] fill::$5 = fill::screen#4 + 1*$28 -- pbuz1=pbuz2_plus_vbuc1 
    lda #1*$28
    clc
    adc.z screen
    sta.z __5
    lda #0
    adc.z screen+1
    sta.z __5+1
    // (screen+j*40)[i] = ch
    // [9] fill::$5[fill::i#4] = fill::ch#4 -- pbuz1_derefidx_vbuyy=vbuxx 
    txa
    sta (__5),y
    // fill::@2_2
    // screen+j*40
    // [10] fill::$7 = fill::screen#4 + 2*$28 -- pbuz1=pbuz2_plus_vbuc1 
    lda #2*$28
    clc
    adc.z screen
    sta.z __7
    lda #0
    adc.z screen+1
    sta.z __7+1
    // (screen+j*40)[i] = ch
    // [11] fill::$7[fill::i#4] = fill::ch#4 -- pbuz1_derefidx_vbuyy=vbuxx 
    txa
    sta (__7),y
    // fill::@3
    // for(byte i: 0..39)
    // [12] fill::i#1 = ++ fill::i#4 -- vbuyy=_inc_vbuyy 
    iny
    // [13] if(fill::i#1!=$28) goto fill::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$28
    bne __b2
    // fill::@return
    // }
    // [14] return 
    rts
}
  // File Data

