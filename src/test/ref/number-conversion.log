Resolved forward reference idx to (byte) idx
Resolved forward reference idx to (byte) idx
Resolved forward reference idx to (byte) idx
Inlined call call _init 

CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from _start::@1
  (byte) idx#0 ← (byte) 0
  (byte~) main::$0 ← typeid  (signed byte) $c+(number) $c
  (byte) assertType::t1#0 ← (byte~) main::$0
  (byte) assertType::t2#0 ← (const byte) TYPEID_SIGNED_BYTE
  call assertType 
  to:main::@1
main::@1: scope:[main]  from main
  (byte) idx#44 ← phi( main/(byte) idx#40 )
  (byte) idx#1 ← (byte) idx#44
  (byte~) main::$2 ← typeid  (signed byte) $c+(number) $82
  (byte) assertType::t1#1 ← (byte~) main::$2
  (byte) assertType::t2#1 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) idx#45 ← phi( main::@1/(byte) idx#40 )
  (byte) idx#2 ← (byte) idx#45
  (byte~) main::$4 ← typeid  (signed byte) $c+(number) $80e8
  (byte) assertType::t1#2 ← (byte~) main::$4
  (byte) assertType::t2#2 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte) idx#46 ← phi( main::@2/(byte) idx#40 )
  (byte) idx#3 ← (byte) idx#46
  (byte~) main::$6 ← typeid  (signed word) $c+(number) $c
  (byte) assertType::t1#3 ← (byte~) main::$6
  (byte) assertType::t2#3 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:main::@4
main::@4: scope:[main]  from main::@3
  (byte) idx#47 ← phi( main::@3/(byte) idx#40 )
  (byte) idx#4 ← (byte) idx#47
  (byte~) main::$8 ← typeid  (signed word) $c+(number) $82
  (byte) assertType::t1#4 ← (byte~) main::$8
  (byte) assertType::t2#4 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:main::@5
main::@5: scope:[main]  from main::@4
  (byte) idx#48 ← phi( main::@4/(byte) idx#40 )
  (byte) idx#5 ← (byte) idx#48
  (byte~) main::$10 ← typeid  (signed word) $c+(number) $186a0
  (byte) assertType::t1#5 ← (byte~) main::$10
  (byte) assertType::t2#5 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@6
main::@6: scope:[main]  from main::@5
  (byte) idx#49 ← phi( main::@5/(byte) idx#40 )
  (byte) idx#6 ← (byte) idx#49
  (byte~) main::$12 ← typeid  (signed dword) $c+(number) $c
  (byte) assertType::t1#6 ← (byte~) main::$12
  (byte) assertType::t2#6 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@7
main::@7: scope:[main]  from main::@6
  (byte) idx#50 ← phi( main::@6/(byte) idx#40 )
  (byte) idx#7 ← (byte) idx#50
  (byte~) main::$14 ← typeid  (signed dword) $c+(number) $82
  (byte) assertType::t1#7 ← (byte~) main::$14
  (byte) assertType::t2#7 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@8
main::@8: scope:[main]  from main::@7
  (byte) idx#51 ← phi( main::@7/(byte) idx#40 )
  (byte) idx#8 ← (byte) idx#51
  (byte~) main::$16 ← typeid  (signed dword) $c+(number) $186a0
  (byte) assertType::t1#8 ← (byte~) main::$16
  (byte) assertType::t2#8 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:main::@9
main::@9: scope:[main]  from main::@8
  (byte) idx#52 ← phi( main::@8/(byte) idx#40 )
  (byte) idx#9 ← (byte) idx#52
  (byte) idx#10 ← (byte) $28
  (byte~) main::$18 ← typeid  (byte) $c+(number) $c
  (byte) assertType::t1#9 ← (byte~) main::$18
  (byte) assertType::t2#9 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@10
main::@10: scope:[main]  from main::@9
  (byte) idx#53 ← phi( main::@9/(byte) idx#40 )
  (byte) idx#11 ← (byte) idx#53
  (byte~) main::$20 ← typeid  (byte) $c+(number) $fa
  (byte) assertType::t1#10 ← (byte~) main::$20
  (byte) assertType::t2#10 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@11
main::@11: scope:[main]  from main::@10
  (byte) idx#54 ← phi( main::@10/(byte) idx#40 )
  (byte) idx#12 ← (byte) idx#54
  (byte~) main::$22 ← typeid  (byte) $c+(number) $12c
  (byte) assertType::t1#11 ← (byte~) main::$22
  (byte) assertType::t2#11 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@12
main::@12: scope:[main]  from main::@11
  (byte) idx#55 ← phi( main::@11/(byte) idx#40 )
  (byte) idx#13 ← (byte) idx#55
  (byte~) main::$24 ← typeid  (byte) $c+(number) $fffe
  (byte) assertType::t1#12 ← (byte~) main::$24
  (byte) assertType::t2#12 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@13
main::@13: scope:[main]  from main::@12
  (byte) idx#56 ← phi( main::@12/(byte) idx#40 )
  (byte) idx#14 ← (byte) idx#56
  (byte~) main::$26 ← typeid  (byte) $c+(number) $101d0
  (byte) assertType::t1#13 ← (byte~) main::$26
  (byte) assertType::t2#13 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@14
main::@14: scope:[main]  from main::@13
  (byte) idx#57 ← phi( main::@13/(byte) idx#40 )
  (byte) idx#15 ← (byte) idx#57
  (byte~) main::$28 ← typeid  (word) $c+(number) $c
  (byte) assertType::t1#14 ← (byte~) main::$28
  (byte) assertType::t2#14 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@15
main::@15: scope:[main]  from main::@14
  (byte) idx#58 ← phi( main::@14/(byte) idx#40 )
  (byte) idx#16 ← (byte) idx#58
  (byte~) main::$30 ← typeid  (word) $c+(number) $82
  (byte) assertType::t1#15 ← (byte~) main::$30
  (byte) assertType::t2#15 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@16
main::@16: scope:[main]  from main::@15
  (byte) idx#59 ← phi( main::@15/(byte) idx#40 )
  (byte) idx#17 ← (byte) idx#59
  (byte~) main::$32 ← typeid  (word) $c+(number) $101d0
  (byte) assertType::t1#16 ← (byte~) main::$32
  (byte) assertType::t2#16 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@17
main::@17: scope:[main]  from main::@16
  (byte) idx#60 ← phi( main::@16/(byte) idx#40 )
  (byte) idx#18 ← (byte) idx#60
  (byte~) main::$34 ← typeid  (dword) $c+(number) $c
  (byte) assertType::t1#17 ← (byte~) main::$34
  (byte) assertType::t2#17 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@18
main::@18: scope:[main]  from main::@17
  (byte) idx#61 ← phi( main::@17/(byte) idx#40 )
  (byte) idx#19 ← (byte) idx#61
  (byte~) main::$36 ← typeid  (dword) $c+(number) $82
  (byte) assertType::t1#18 ← (byte~) main::$36
  (byte) assertType::t2#18 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@19
main::@19: scope:[main]  from main::@18
  (byte) idx#62 ← phi( main::@18/(byte) idx#40 )
  (byte) idx#20 ← (byte) idx#62
  (byte~) main::$38 ← typeid  (dword) $c+(number) $101d0
  (byte) assertType::t1#19 ← (byte~) main::$38
  (byte) assertType::t2#19 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@20
main::@20: scope:[main]  from main::@19
  (byte) idx#63 ← phi( main::@19/(byte) idx#40 )
  (byte) idx#21 ← (byte) idx#63
  (byte~) main::$40 ← typeid  (byte) $c+(number) $b2d05e00
  (byte) assertType::t1#20 ← (byte~) main::$40
  (byte) assertType::t2#20 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@21
main::@21: scope:[main]  from main::@20
  (byte) idx#64 ← phi( main::@20/(byte) idx#40 )
  (byte) idx#22 ← (byte) idx#64
  (byte) idx#23 ← (byte) $50
  (byte~) main::$42 ← typeid  (byte) $c+(number) -$c
  (byte) assertType::t1#21 ← (byte~) main::$42
  (byte) assertType::t2#21 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@22
main::@22: scope:[main]  from main::@21
  (byte) idx#65 ← phi( main::@21/(byte) idx#40 )
  (byte) idx#24 ← (byte) idx#65
  (byte~) main::$44 ← typeid  (byte) $c+(number) -$78
  (byte) assertType::t1#22 ← (byte~) main::$44
  (byte) assertType::t2#22 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@23
main::@23: scope:[main]  from main::@22
  (byte) idx#66 ← phi( main::@22/(byte) idx#40 )
  (byte) idx#25 ← (byte) idx#66
  (byte~) main::$46 ← typeid  (byte) $c+(number) -$fa
  (byte) assertType::t1#23 ← (byte~) main::$46
  (byte) assertType::t2#23 ← (const byte) TYPEID_BYTE
  call assertType 
  to:main::@24
main::@24: scope:[main]  from main::@23
  (byte) idx#67 ← phi( main::@23/(byte) idx#40 )
  (byte) idx#26 ← (byte) idx#67
  (byte~) main::$48 ← typeid  (byte) $c+(number) -$104
  (byte) assertType::t1#24 ← (byte~) main::$48
  (byte) assertType::t2#24 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@25
main::@25: scope:[main]  from main::@24
  (byte) idx#68 ← phi( main::@24/(byte) idx#40 )
  (byte) idx#27 ← (byte) idx#68
  (byte~) main::$50 ← typeid  (byte) $c+(number) -$fde8
  (byte) assertType::t1#25 ← (byte~) main::$50
  (byte) assertType::t2#25 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@26
main::@26: scope:[main]  from main::@25
  (byte) idx#69 ← phi( main::@25/(byte) idx#40 )
  (byte) idx#28 ← (byte) idx#69
  (byte~) main::$52 ← typeid  (byte) $c+(number) -$101d0
  (byte) assertType::t1#26 ← (byte~) main::$52
  (byte) assertType::t2#26 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@27
main::@27: scope:[main]  from main::@26
  (byte) idx#70 ← phi( main::@26/(byte) idx#40 )
  (byte) idx#29 ← (byte) idx#70
  (byte~) main::$54 ← typeid  (word) $c+(number) -$c
  (byte) assertType::t1#27 ← (byte~) main::$54
  (byte) assertType::t2#27 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@28
main::@28: scope:[main]  from main::@27
  (byte) idx#71 ← phi( main::@27/(byte) idx#40 )
  (byte) idx#30 ← (byte) idx#71
  (byte~) main::$56 ← typeid  (word) $c+(number) -$82
  (byte) assertType::t1#28 ← (byte~) main::$56
  (byte) assertType::t2#28 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@29
main::@29: scope:[main]  from main::@28
  (byte) idx#72 ← phi( main::@28/(byte) idx#40 )
  (byte) idx#31 ← (byte) idx#72
  (byte~) main::$58 ← typeid  (word) $c+(number) -$fde8
  (byte) assertType::t1#29 ← (byte~) main::$58
  (byte) assertType::t2#29 ← (const byte) TYPEID_WORD
  call assertType 
  to:main::@30
main::@30: scope:[main]  from main::@29
  (byte) idx#73 ← phi( main::@29/(byte) idx#40 )
  (byte) idx#32 ← (byte) idx#73
  (byte~) main::$60 ← typeid  (word) $c+(number) -$101d0
  (byte) assertType::t1#30 ← (byte~) main::$60
  (byte) assertType::t2#30 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@31
main::@31: scope:[main]  from main::@30
  (byte) idx#74 ← phi( main::@30/(byte) idx#40 )
  (byte) idx#33 ← (byte) idx#74
  (byte~) main::$62 ← typeid  (dword) $c+(number) -$c
  (byte) assertType::t1#31 ← (byte~) main::$62
  (byte) assertType::t2#31 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@32
main::@32: scope:[main]  from main::@31
  (byte) idx#75 ← phi( main::@31/(byte) idx#40 )
  (byte) idx#34 ← (byte) idx#75
  (byte~) main::$64 ← typeid  (dword) $c+(number) -$82
  (byte) assertType::t1#32 ← (byte~) main::$64
  (byte) assertType::t2#32 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@33
main::@33: scope:[main]  from main::@32
  (byte) idx#76 ← phi( main::@32/(byte) idx#40 )
  (byte) idx#35 ← (byte) idx#76
  (byte~) main::$66 ← typeid  (dword) $c+(number) -$101d0
  (byte) assertType::t1#33 ← (byte~) main::$66
  (byte) assertType::t2#33 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@34
main::@34: scope:[main]  from main::@33
  (byte) idx#77 ← phi( main::@33/(byte) idx#40 )
  (byte) idx#36 ← (byte) idx#77
  (byte~) main::$68 ← typeid  (signed byte) $c+(number) -$7d2b7500
  (byte) assertType::t1#34 ← (byte~) main::$68
  (byte) assertType::t2#34 ← (const byte) TYPEID_DWORD
  call assertType 
  to:main::@35
main::@35: scope:[main]  from main::@34
  (byte) idx#78 ← phi( main::@34/(byte) idx#40 )
  (byte) idx#37 ← (byte) idx#78
  to:main::@return
main::@return: scope:[main]  from main::@35
  (byte) idx#79 ← phi( main::@35/(byte) idx#37 )
  (byte) idx#38 ← (byte) idx#79
  return 
  to:@return

(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
assertType: scope:[assertType]  from main main::@1 main::@10 main::@11 main::@12 main::@13 main::@14 main::@15 main::@16 main::@17 main::@18 main::@19 main::@2 main::@20 main::@21 main::@22 main::@23 main::@24 main::@25 main::@26 main::@27 main::@28 main::@29 main::@3 main::@30 main::@31 main::@32 main::@33 main::@34 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  (byte) idx#86 ← phi( main/(byte) idx#0 main::@1/(byte) idx#1 main::@10/(byte) idx#11 main::@11/(byte) idx#12 main::@12/(byte) idx#13 main::@13/(byte) idx#14 main::@14/(byte) idx#15 main::@15/(byte) idx#16 main::@16/(byte) idx#17 main::@17/(byte) idx#18 main::@18/(byte) idx#19 main::@19/(byte) idx#20 main::@2/(byte) idx#2 main::@20/(byte) idx#21 main::@21/(byte) idx#23 main::@22/(byte) idx#24 main::@23/(byte) idx#25 main::@24/(byte) idx#26 main::@25/(byte) idx#27 main::@26/(byte) idx#28 main::@27/(byte) idx#29 main::@28/(byte) idx#30 main::@29/(byte) idx#31 main::@3/(byte) idx#3 main::@30/(byte) idx#32 main::@31/(byte) idx#33 main::@32/(byte) idx#34 main::@33/(byte) idx#35 main::@34/(byte) idx#36 main::@4/(byte) idx#4 main::@5/(byte) idx#5 main::@6/(byte) idx#6 main::@7/(byte) idx#7 main::@8/(byte) idx#8 main::@9/(byte) idx#10 )
  (byte) assertType::t2#35 ← phi( main/(byte) assertType::t2#0 main::@1/(byte) assertType::t2#1 main::@10/(byte) assertType::t2#10 main::@11/(byte) assertType::t2#11 main::@12/(byte) assertType::t2#12 main::@13/(byte) assertType::t2#13 main::@14/(byte) assertType::t2#14 main::@15/(byte) assertType::t2#15 main::@16/(byte) assertType::t2#16 main::@17/(byte) assertType::t2#17 main::@18/(byte) assertType::t2#18 main::@19/(byte) assertType::t2#19 main::@2/(byte) assertType::t2#2 main::@20/(byte) assertType::t2#20 main::@21/(byte) assertType::t2#21 main::@22/(byte) assertType::t2#22 main::@23/(byte) assertType::t2#23 main::@24/(byte) assertType::t2#24 main::@25/(byte) assertType::t2#25 main::@26/(byte) assertType::t2#26 main::@27/(byte) assertType::t2#27 main::@28/(byte) assertType::t2#28 main::@29/(byte) assertType::t2#29 main::@3/(byte) assertType::t2#3 main::@30/(byte) assertType::t2#30 main::@31/(byte) assertType::t2#31 main::@32/(byte) assertType::t2#32 main::@33/(byte) assertType::t2#33 main::@34/(byte) assertType::t2#34 main::@4/(byte) assertType::t2#4 main::@5/(byte) assertType::t2#5 main::@6/(byte) assertType::t2#6 main::@7/(byte) assertType::t2#7 main::@8/(byte) assertType::t2#8 main::@9/(byte) assertType::t2#9 )
  (byte) assertType::t1#35 ← phi( main/(byte) assertType::t1#0 main::@1/(byte) assertType::t1#1 main::@10/(byte) assertType::t1#10 main::@11/(byte) assertType::t1#11 main::@12/(byte) assertType::t1#12 main::@13/(byte) assertType::t1#13 main::@14/(byte) assertType::t1#14 main::@15/(byte) assertType::t1#15 main::@16/(byte) assertType::t1#16 main::@17/(byte) assertType::t1#17 main::@18/(byte) assertType::t1#18 main::@19/(byte) assertType::t1#19 main::@2/(byte) assertType::t1#2 main::@20/(byte) assertType::t1#20 main::@21/(byte) assertType::t1#21 main::@22/(byte) assertType::t1#22 main::@23/(byte) assertType::t1#23 main::@24/(byte) assertType::t1#24 main::@25/(byte) assertType::t1#25 main::@26/(byte) assertType::t1#26 main::@27/(byte) assertType::t1#27 main::@28/(byte) assertType::t1#28 main::@29/(byte) assertType::t1#29 main::@3/(byte) assertType::t1#3 main::@30/(byte) assertType::t1#30 main::@31/(byte) assertType::t1#31 main::@32/(byte) assertType::t1#32 main::@33/(byte) assertType::t1#33 main::@34/(byte) assertType::t1#34 main::@4/(byte) assertType::t1#4 main::@5/(byte) assertType::t1#5 main::@6/(byte) assertType::t1#6 main::@7/(byte) assertType::t1#7 main::@8/(byte) assertType::t1#8 main::@9/(byte) assertType::t1#9 )
  (bool~) assertType::$0 ← (byte) assertType::t1#35 == (byte) assertType::t2#35
  if((bool~) assertType::$0) goto assertType::@1
  to:assertType::@3
assertType::@1: scope:[assertType]  from assertType
  (byte) assertType::t1#37 ← phi( assertType/(byte) assertType::t1#35 )
  (byte) idx#80 ← phi( assertType/(byte) idx#86 )
  *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) GREEN
  to:assertType::@2
assertType::@3: scope:[assertType]  from assertType
  (byte) assertType::t1#38 ← phi( assertType/(byte) assertType::t1#35 )
  (byte) idx#81 ← phi( assertType/(byte) idx#86 )
  *((const nomodify byte*) COLS + (byte) idx#81) ← (const nomodify byte) RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  (byte) idx#82 ← phi( assertType::@1/(byte) idx#80 assertType::@3/(byte) idx#81 )
  (byte) assertType::t1#36 ← phi( assertType::@1/(byte) assertType::t1#37 assertType::@3/(byte) assertType::t1#38 )
  *((const nomodify byte*) SCREEN + (byte) idx#82) ← (byte) assertType::t1#36
  (byte) idx#39 ← ++ (byte) idx#82
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  (byte) idx#83 ← phi( assertType::@2/(byte) idx#39 )
  (byte) idx#40 ← (byte) idx#83
  return 
  to:@return

(void()) _start()
_start: scope:[_start]  from
  to:_start::_init1
_start::_init1: scope:[_start]  from _start
  (byte) idx#41 ← (byte) 0
  to:_start::@1
_start::@1: scope:[_start]  from _start::_init1
  (byte) idx#87 ← phi( _start::_init1/(byte) idx#41 )
  call main 
  to:_start::@2
_start::@2: scope:[_start]  from _start::@1
  (byte) idx#84 ← phi( _start::@1/(byte) idx#38 )
  (byte) idx#42 ← (byte) idx#84
  to:_start::@return
_start::@return: scope:[_start]  from _start::@2
  (byte) idx#85 ← phi( _start::@2/(byte) idx#42 )
  (byte) idx#43 ← (byte) idx#85
  return 
  to:@return

SYMBOL TABLE SSA
(const nomodify byte*) COLS = (byte*)(word) $d800
(const nomodify byte) GREEN = (byte) 5
(const nomodify byte) RED = (byte) 2
(const nomodify byte*) SCREEN = (byte*)(word) $400
(const byte) TYPEID_BYTE = (number) 1
(const byte) TYPEID_DWORD = (number) 5
(const byte) TYPEID_SIGNED_BYTE = (number) 2
(const byte) TYPEID_SIGNED_DWORD = (number) 6
(const byte) TYPEID_SIGNED_WORD = (number) 4
(const byte) TYPEID_WORD = (number) 3
(void()) _start()
(label) _start::@1
(label) _start::@2
(label) _start::@return
(label) _start::_init1
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(bool~) assertType::$0
(label) assertType::@1
(label) assertType::@2
(label) assertType::@3
(label) assertType::@return
(byte) assertType::t1
(byte) assertType::t1#0
(byte) assertType::t1#1
(byte) assertType::t1#10
(byte) assertType::t1#11
(byte) assertType::t1#12
(byte) assertType::t1#13
(byte) assertType::t1#14
(byte) assertType::t1#15
(byte) assertType::t1#16
(byte) assertType::t1#17
(byte) assertType::t1#18
(byte) assertType::t1#19
(byte) assertType::t1#2
(byte) assertType::t1#20
(byte) assertType::t1#21
(byte) assertType::t1#22
(byte) assertType::t1#23
(byte) assertType::t1#24
(byte) assertType::t1#25
(byte) assertType::t1#26
(byte) assertType::t1#27
(byte) assertType::t1#28
(byte) assertType::t1#29
(byte) assertType::t1#3
(byte) assertType::t1#30
(byte) assertType::t1#31
(byte) assertType::t1#32
(byte) assertType::t1#33
(byte) assertType::t1#34
(byte) assertType::t1#35
(byte) assertType::t1#36
(byte) assertType::t1#37
(byte) assertType::t1#38
(byte) assertType::t1#4
(byte) assertType::t1#5
(byte) assertType::t1#6
(byte) assertType::t1#7
(byte) assertType::t1#8
(byte) assertType::t1#9
(byte) assertType::t2
(byte) assertType::t2#0
(byte) assertType::t2#1
(byte) assertType::t2#10
(byte) assertType::t2#11
(byte) assertType::t2#12
(byte) assertType::t2#13
(byte) assertType::t2#14
(byte) assertType::t2#15
(byte) assertType::t2#16
(byte) assertType::t2#17
(byte) assertType::t2#18
(byte) assertType::t2#19
(byte) assertType::t2#2
(byte) assertType::t2#20
(byte) assertType::t2#21
(byte) assertType::t2#22
(byte) assertType::t2#23
(byte) assertType::t2#24
(byte) assertType::t2#25
(byte) assertType::t2#26
(byte) assertType::t2#27
(byte) assertType::t2#28
(byte) assertType::t2#29
(byte) assertType::t2#3
(byte) assertType::t2#30
(byte) assertType::t2#31
(byte) assertType::t2#32
(byte) assertType::t2#33
(byte) assertType::t2#34
(byte) assertType::t2#35
(byte) assertType::t2#4
(byte) assertType::t2#5
(byte) assertType::t2#6
(byte) assertType::t2#7
(byte) assertType::t2#8
(byte) assertType::t2#9
(byte) idx
(byte) idx#0
(byte) idx#1
(byte) idx#10
(byte) idx#11
(byte) idx#12
(byte) idx#13
(byte) idx#14
(byte) idx#15
(byte) idx#16
(byte) idx#17
(byte) idx#18
(byte) idx#19
(byte) idx#2
(byte) idx#20
(byte) idx#21
(byte) idx#22
(byte) idx#23
(byte) idx#24
(byte) idx#25
(byte) idx#26
(byte) idx#27
(byte) idx#28
(byte) idx#29
(byte) idx#3
(byte) idx#30
(byte) idx#31
(byte) idx#32
(byte) idx#33
(byte) idx#34
(byte) idx#35
(byte) idx#36
(byte) idx#37
(byte) idx#38
(byte) idx#39
(byte) idx#4
(byte) idx#40
(byte) idx#41
(byte) idx#42
(byte) idx#43
(byte) idx#44
(byte) idx#45
(byte) idx#46
(byte) idx#47
(byte) idx#48
(byte) idx#49
(byte) idx#5
(byte) idx#50
(byte) idx#51
(byte) idx#52
(byte) idx#53
(byte) idx#54
(byte) idx#55
(byte) idx#56
(byte) idx#57
(byte) idx#58
(byte) idx#59
(byte) idx#6
(byte) idx#60
(byte) idx#61
(byte) idx#62
(byte) idx#63
(byte) idx#64
(byte) idx#65
(byte) idx#66
(byte) idx#67
(byte) idx#68
(byte) idx#69
(byte) idx#7
(byte) idx#70
(byte) idx#71
(byte) idx#72
(byte) idx#73
(byte) idx#74
(byte) idx#75
(byte) idx#76
(byte) idx#77
(byte) idx#78
(byte) idx#79
(byte) idx#8
(byte) idx#80
(byte) idx#81
(byte) idx#82
(byte) idx#83
(byte) idx#84
(byte) idx#85
(byte) idx#86
(byte) idx#87
(byte) idx#9
(void()) main()
(byte~) main::$0
(byte~) main::$10
(byte~) main::$12
(byte~) main::$14
(byte~) main::$16
(byte~) main::$18
(byte~) main::$2
(byte~) main::$20
(byte~) main::$22
(byte~) main::$24
(byte~) main::$26
(byte~) main::$28
(byte~) main::$30
(byte~) main::$32
(byte~) main::$34
(byte~) main::$36
(byte~) main::$38
(byte~) main::$4
(byte~) main::$40
(byte~) main::$42
(byte~) main::$44
(byte~) main::$46
(byte~) main::$48
(byte~) main::$50
(byte~) main::$52
(byte~) main::$54
(byte~) main::$56
(byte~) main::$58
(byte~) main::$6
(byte~) main::$60
(byte~) main::$62
(byte~) main::$64
(byte~) main::$66
(byte~) main::$68
(byte~) main::$8
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@22
(label) main::@23
(label) main::@24
(label) main::@25
(label) main::@26
(label) main::@27
(label) main::@28
(label) main::@29
(label) main::@3
(label) main::@30
(label) main::@31
(label) main::@32
(label) main::@33
(label) main::@34
(label) main::@35
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return

Adding number conversion cast (snumber) $c in (byte~) main::$0 ← typeid  (signed byte) $c+(number) $c
Adding number conversion cast (snumber) $82 in (byte~) main::$2 ← typeid  (signed byte) $c+(number) $82
Adding number conversion cast (snumber) $80e8 in (byte~) main::$4 ← typeid  (signed byte) $c+(number) $80e8
Adding number conversion cast (snumber) $c in (byte~) main::$6 ← typeid  (signed word) $c+(number) $c
Adding number conversion cast (snumber) $82 in (byte~) main::$8 ← typeid  (signed word) $c+(number) $82
Adding number conversion cast (snumber) $186a0 in (byte~) main::$10 ← typeid  (signed word) $c+(number) $186a0
Adding number conversion cast (snumber) $c in (byte~) main::$12 ← typeid  (signed dword) $c+(number) $c
Adding number conversion cast (snumber) $82 in (byte~) main::$14 ← typeid  (signed dword) $c+(number) $82
Adding number conversion cast (snumber) $186a0 in (byte~) main::$16 ← typeid  (signed dword) $c+(number) $186a0
Adding number conversion cast (unumber) $c in (byte~) main::$18 ← typeid  (byte) $c+(number) $c
Adding number conversion cast (unumber) $fa in (byte~) main::$20 ← typeid  (byte) $c+(number) $fa
Adding number conversion cast (unumber) $12c in (byte~) main::$22 ← typeid  (byte) $c+(number) $12c
Adding number conversion cast (unumber) $fffe in (byte~) main::$24 ← typeid  (byte) $c+(number) $fffe
Adding number conversion cast (unumber) $101d0 in (byte~) main::$26 ← typeid  (byte) $c+(number) $101d0
Adding number conversion cast (unumber) $c in (byte~) main::$28 ← typeid  (word) $c+(number) $c
Adding number conversion cast (unumber) $82 in (byte~) main::$30 ← typeid  (word) $c+(number) $82
Adding number conversion cast (unumber) $101d0 in (byte~) main::$32 ← typeid  (word) $c+(number) $101d0
Adding number conversion cast (unumber) $c in (byte~) main::$34 ← typeid  (dword) $c+(number) $c
Adding number conversion cast (unumber) $82 in (byte~) main::$36 ← typeid  (dword) $c+(number) $82
Adding number conversion cast (unumber) $101d0 in (byte~) main::$38 ← typeid  (dword) $c+(number) $101d0
Adding number conversion cast (unumber) $b2d05e00 in (byte~) main::$40 ← typeid  (byte) $c+(number) $b2d05e00
Adding number conversion cast (unumber) -$c in (byte~) main::$42 ← typeid  (byte) $c+(number) -$c
Adding number conversion cast (unumber) -$78 in (byte~) main::$44 ← typeid  (byte) $c+(number) -$78
Adding number conversion cast (unumber) -$fa in (byte~) main::$46 ← typeid  (byte) $c+(number) -$fa
Adding number conversion cast (unumber) -$104 in (byte~) main::$48 ← typeid  (byte) $c+(number) -$104
Adding number conversion cast (unumber) -$fde8 in (byte~) main::$50 ← typeid  (byte) $c+(number) -$fde8
Adding number conversion cast (unumber) -$101d0 in (byte~) main::$52 ← typeid  (byte) $c+(number) -$101d0
Adding number conversion cast (unumber) -$c in (byte~) main::$54 ← typeid  (word) $c+(number) -$c
Adding number conversion cast (unumber) -$82 in (byte~) main::$56 ← typeid  (word) $c+(number) -$82
Adding number conversion cast (unumber) -$fde8 in (byte~) main::$58 ← typeid  (word) $c+(number) -$fde8
Adding number conversion cast (unumber) -$101d0 in (byte~) main::$60 ← typeid  (word) $c+(number) -$101d0
Adding number conversion cast (unumber) -$c in (byte~) main::$62 ← typeid  (dword) $c+(number) -$c
Adding number conversion cast (unumber) -$82 in (byte~) main::$64 ← typeid  (dword) $c+(number) -$82
Adding number conversion cast (unumber) -$101d0 in (byte~) main::$66 ← typeid  (dword) $c+(number) -$101d0
Adding number conversion cast (snumber) -$7d2b7500 in (byte~) main::$68 ← typeid  (signed byte) $c+(number) -$7d2b7500
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $80e8
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $186a0
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $186a0
Simplifying constant integer cast $c
Simplifying constant integer cast $fa
Simplifying constant integer cast $12c
Simplifying constant integer cast $fffe
Simplifying constant integer cast $101d0
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $101d0
Simplifying constant integer cast $c
Simplifying constant integer cast $82
Simplifying constant integer cast $101d0
Simplifying constant integer cast $b2d05e00
Simplifying constant integer cast -$c
Simplifying constant integer cast -$78
Simplifying constant integer cast -$fa
Simplifying constant integer cast -$104
Simplifying constant integer cast -$fde8
Simplifying constant integer cast -$101d0
Simplifying constant integer cast -$c
Simplifying constant integer cast -$82
Simplifying constant integer cast -$fde8
Simplifying constant integer cast -$101d0
Simplifying constant integer cast -$c
Simplifying constant integer cast -$82
Simplifying constant integer cast -$101d0
Simplifying constant integer cast -$7d2b7500
Successful SSA optimization PassNCastSimplification
Finalized signed number type (signed byte) $c
Finalized signed number type (signed word) $82
Finalized signed number type (signed dword) $80e8
Finalized signed number type (signed byte) $c
Finalized signed number type (signed word) $82
Finalized signed number type (signed dword) $186a0
Finalized signed number type (signed byte) $c
Finalized signed number type (signed word) $82
Finalized signed number type (signed dword) $186a0
Finalized unsigned number type (byte) $c
Finalized unsigned number type (byte) $fa
Finalized unsigned number type (word) $12c
Finalized unsigned number type (word) $fffe
Finalized unsigned number type (dword) $101d0
Finalized unsigned number type (byte) $c
Finalized unsigned number type (byte) $82
Finalized unsigned number type (dword) $101d0
Finalized unsigned number type (byte) $c
Finalized unsigned number type (byte) $82
Finalized unsigned number type (dword) $101d0
Finalized unsigned number type (dword) $b2d05e00
Finalized unsigned number type (byte) -$c
Finalized unsigned number type (byte) -$78
Finalized unsigned number type (byte) -$fa
Finalized unsigned number type (word) -$104
Finalized unsigned number type (word) -$fde8
Finalized unsigned number type (dword) -$101d0
Finalized unsigned number type (byte) -$c
Finalized unsigned number type (byte) -$82
Finalized unsigned number type (word) -$fde8
Finalized unsigned number type (dword) -$101d0
Finalized unsigned number type (byte) -$c
Finalized unsigned number type (byte) -$82
Finalized unsigned number type (dword) -$101d0
Finalized signed number type (signed dword) -$7d2b7500
Successful SSA optimization PassNFinalizeNumberTypeConversions
Resolving typeid() (byte~) main::$0 ← typeid  (signed byte) $c+(signed byte) $c
Resolving typeid() (byte~) main::$2 ← typeid  (signed byte) $c+(signed word) $82
Resolving typeid() (byte~) main::$4 ← typeid  (signed byte) $c+(signed dword) $80e8
Resolving typeid() (byte~) main::$6 ← typeid  (signed word) $c+(signed byte) $c
Resolving typeid() (byte~) main::$8 ← typeid  (signed word) $c+(signed word) $82
Resolving typeid() (byte~) main::$10 ← typeid  (signed word) $c+(signed dword) $186a0
Resolving typeid() (byte~) main::$12 ← typeid  (signed dword) $c+(signed byte) $c
Resolving typeid() (byte~) main::$14 ← typeid  (signed dword) $c+(signed word) $82
Resolving typeid() (byte~) main::$16 ← typeid  (signed dword) $c+(signed dword) $186a0
Resolving typeid() (byte~) main::$18 ← typeid  (byte) $c+(byte) $c
Resolving typeid() (byte~) main::$20 ← typeid  (byte) $c+(byte) $fa
Resolving typeid() (byte~) main::$22 ← typeid  (byte) $c+(word) $12c
Resolving typeid() (byte~) main::$24 ← typeid  (byte) $c+(word) $fffe
Resolving typeid() (byte~) main::$26 ← typeid  (byte) $c+(dword) $101d0
Resolving typeid() (byte~) main::$28 ← typeid  (word) $c+(byte) $c
Resolving typeid() (byte~) main::$30 ← typeid  (word) $c+(byte) $82
Resolving typeid() (byte~) main::$32 ← typeid  (word) $c+(dword) $101d0
Resolving typeid() (byte~) main::$34 ← typeid  (dword) $c+(byte) $c
Resolving typeid() (byte~) main::$36 ← typeid  (dword) $c+(byte) $82
Resolving typeid() (byte~) main::$38 ← typeid  (dword) $c+(dword) $101d0
Resolving typeid() (byte~) main::$40 ← typeid  (byte) $c+(dword) $b2d05e00
Resolving typeid() (byte~) main::$42 ← typeid  (byte) $c+(byte) -$c
Resolving typeid() (byte~) main::$44 ← typeid  (byte) $c+(byte) -$78
Resolving typeid() (byte~) main::$46 ← typeid  (byte) $c+(byte) -$fa
Resolving typeid() (byte~) main::$48 ← typeid  (byte) $c+(word) -$104
Resolving typeid() (byte~) main::$50 ← typeid  (byte) $c+(word) -$fde8
Resolving typeid() (byte~) main::$52 ← typeid  (byte) $c+(dword) -$101d0
Resolving typeid() (byte~) main::$54 ← typeid  (word) $c+(byte) -$c
Resolving typeid() (byte~) main::$56 ← typeid  (word) $c+(byte) -$82
Resolving typeid() (byte~) main::$58 ← typeid  (word) $c+(word) -$fde8
Resolving typeid() (byte~) main::$60 ← typeid  (word) $c+(dword) -$101d0
Resolving typeid() (byte~) main::$62 ← typeid  (dword) $c+(byte) -$c
Resolving typeid() (byte~) main::$64 ← typeid  (dword) $c+(byte) -$82
Resolving typeid() (byte~) main::$66 ← typeid  (dword) $c+(dword) -$101d0
Resolving typeid() (byte~) main::$68 ← typeid  (signed byte) $c+(signed dword) -$7d2b7500
Successful SSA optimization PassNTypeIdSimplification
Alias assertType::t1#0 = main::$0 
Alias idx#1 = idx#44 
Alias assertType::t1#1 = main::$2 
Alias idx#2 = idx#45 
Alias assertType::t1#2 = main::$4 
Alias idx#3 = idx#46 
Alias assertType::t1#3 = main::$6 
Alias idx#4 = idx#47 
Alias assertType::t1#4 = main::$8 
Alias idx#48 = idx#5 
Alias assertType::t1#5 = main::$10 
Alias idx#49 = idx#6 
Alias assertType::t1#6 = main::$12 
Alias idx#50 = idx#7 
Alias assertType::t1#7 = main::$14 
Alias idx#51 = idx#8 
Alias assertType::t1#8 = main::$16 
Alias idx#52 = idx#9 
Alias assertType::t1#9 = main::$18 
Alias idx#11 = idx#53 
Alias assertType::t1#10 = main::$20 
Alias idx#12 = idx#54 
Alias assertType::t1#11 = main::$22 
Alias idx#13 = idx#55 
Alias assertType::t1#12 = main::$24 
Alias idx#14 = idx#56 
Alias assertType::t1#13 = main::$26 
Alias idx#15 = idx#57 
Alias assertType::t1#14 = main::$28 
Alias idx#16 = idx#58 
Alias assertType::t1#15 = main::$30 
Alias idx#17 = idx#59 
Alias assertType::t1#16 = main::$32 
Alias idx#18 = idx#60 
Alias assertType::t1#17 = main::$34 
Alias idx#19 = idx#61 
Alias assertType::t1#18 = main::$36 
Alias idx#20 = idx#62 
Alias assertType::t1#19 = main::$38 
Alias idx#21 = idx#63 
Alias assertType::t1#20 = main::$40 
Alias idx#22 = idx#64 
Alias assertType::t1#21 = main::$42 
Alias idx#24 = idx#65 
Alias assertType::t1#22 = main::$44 
Alias idx#25 = idx#66 
Alias assertType::t1#23 = main::$46 
Alias idx#26 = idx#67 
Alias assertType::t1#24 = main::$48 
Alias idx#27 = idx#68 
Alias assertType::t1#25 = main::$50 
Alias idx#28 = idx#69 
Alias assertType::t1#26 = main::$52 
Alias idx#29 = idx#70 
Alias assertType::t1#27 = main::$54 
Alias idx#30 = idx#71 
Alias assertType::t1#28 = main::$56 
Alias idx#31 = idx#72 
Alias assertType::t1#29 = main::$58 
Alias idx#32 = idx#73 
Alias assertType::t1#30 = main::$60 
Alias idx#33 = idx#74 
Alias assertType::t1#31 = main::$62 
Alias idx#34 = idx#75 
Alias assertType::t1#32 = main::$64 
Alias idx#35 = idx#76 
Alias assertType::t1#33 = main::$66 
Alias idx#36 = idx#77 
Alias assertType::t1#34 = main::$68 
Alias idx#37 = idx#78 idx#79 idx#38 
Alias idx#80 = idx#86 idx#81 
Alias assertType::t1#35 = assertType::t1#37 assertType::t1#38 
Alias idx#39 = idx#83 idx#40 
Alias idx#41 = idx#87 
Alias idx#42 = idx#84 idx#85 idx#43 
Successful SSA optimization Pass2AliasElimination
Alias assertType::t1#35 = assertType::t1#36 
Alias idx#80 = idx#82 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) idx#1 (byte) idx#39
Identical Phi Values (byte) idx#2 (byte) idx#39
Identical Phi Values (byte) idx#3 (byte) idx#39
Identical Phi Values (byte) idx#4 (byte) idx#39
Identical Phi Values (byte) idx#48 (byte) idx#39
Identical Phi Values (byte) idx#49 (byte) idx#39
Identical Phi Values (byte) idx#50 (byte) idx#39
Identical Phi Values (byte) idx#51 (byte) idx#39
Identical Phi Values (byte) idx#52 (byte) idx#39
Identical Phi Values (byte) idx#11 (byte) idx#39
Identical Phi Values (byte) idx#12 (byte) idx#39
Identical Phi Values (byte) idx#13 (byte) idx#39
Identical Phi Values (byte) idx#14 (byte) idx#39
Identical Phi Values (byte) idx#15 (byte) idx#39
Identical Phi Values (byte) idx#16 (byte) idx#39
Identical Phi Values (byte) idx#17 (byte) idx#39
Identical Phi Values (byte) idx#18 (byte) idx#39
Identical Phi Values (byte) idx#19 (byte) idx#39
Identical Phi Values (byte) idx#20 (byte) idx#39
Identical Phi Values (byte) idx#21 (byte) idx#39
Identical Phi Values (byte) idx#22 (byte) idx#39
Identical Phi Values (byte) idx#24 (byte) idx#39
Identical Phi Values (byte) idx#25 (byte) idx#39
Identical Phi Values (byte) idx#26 (byte) idx#39
Identical Phi Values (byte) idx#27 (byte) idx#39
Identical Phi Values (byte) idx#28 (byte) idx#39
Identical Phi Values (byte) idx#29 (byte) idx#39
Identical Phi Values (byte) idx#30 (byte) idx#39
Identical Phi Values (byte) idx#31 (byte) idx#39
Identical Phi Values (byte) idx#32 (byte) idx#39
Identical Phi Values (byte) idx#33 (byte) idx#39
Identical Phi Values (byte) idx#34 (byte) idx#39
Identical Phi Values (byte) idx#35 (byte) idx#39
Identical Phi Values (byte) idx#36 (byte) idx#39
Identical Phi Values (byte) idx#37 (byte) idx#39
Identical Phi Values (byte) idx#42 (byte) idx#37
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) assertType::$0 [146] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte) idx#0 = 0
Constant (const byte) assertType::t1#0 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t2#0 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t1#1 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#1 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t1#2 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#2 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t1#3 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#3 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t1#4 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#4 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t1#5 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#5 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t1#6 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#6 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t1#7 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#7 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t1#8 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#8 = TYPEID_SIGNED_DWORD
Constant (const byte) idx#10 = $28
Constant (const byte) assertType::t1#9 = TYPEID_BYTE
Constant (const byte) assertType::t2#9 = TYPEID_BYTE
Constant (const byte) assertType::t1#10 = TYPEID_BYTE
Constant (const byte) assertType::t2#10 = TYPEID_BYTE
Constant (const byte) assertType::t1#11 = TYPEID_WORD
Constant (const byte) assertType::t2#11 = TYPEID_WORD
Constant (const byte) assertType::t1#12 = TYPEID_WORD
Constant (const byte) assertType::t2#12 = TYPEID_WORD
Constant (const byte) assertType::t1#13 = TYPEID_DWORD
Constant (const byte) assertType::t2#13 = TYPEID_DWORD
Constant (const byte) assertType::t1#14 = TYPEID_WORD
Constant (const byte) assertType::t2#14 = TYPEID_WORD
Constant (const byte) assertType::t1#15 = TYPEID_WORD
Constant (const byte) assertType::t2#15 = TYPEID_WORD
Constant (const byte) assertType::t1#16 = TYPEID_DWORD
Constant (const byte) assertType::t2#16 = TYPEID_DWORD
Constant (const byte) assertType::t1#17 = TYPEID_DWORD
Constant (const byte) assertType::t2#17 = TYPEID_DWORD
Constant (const byte) assertType::t1#18 = TYPEID_DWORD
Constant (const byte) assertType::t2#18 = TYPEID_DWORD
Constant (const byte) assertType::t1#19 = TYPEID_DWORD
Constant (const byte) assertType::t2#19 = TYPEID_DWORD
Constant (const byte) assertType::t1#20 = TYPEID_DWORD
Constant (const byte) assertType::t2#20 = TYPEID_DWORD
Constant (const byte) idx#23 = $50
Constant (const byte) assertType::t1#21 = TYPEID_BYTE
Constant (const byte) assertType::t2#21 = TYPEID_BYTE
Constant (const byte) assertType::t1#22 = TYPEID_BYTE
Constant (const byte) assertType::t2#22 = TYPEID_BYTE
Constant (const byte) assertType::t1#23 = TYPEID_BYTE
Constant (const byte) assertType::t2#23 = TYPEID_BYTE
Constant (const byte) assertType::t1#24 = TYPEID_WORD
Constant (const byte) assertType::t2#24 = TYPEID_WORD
Constant (const byte) assertType::t1#25 = TYPEID_WORD
Constant (const byte) assertType::t2#25 = TYPEID_WORD
Constant (const byte) assertType::t1#26 = TYPEID_DWORD
Constant (const byte) assertType::t2#26 = TYPEID_DWORD
Constant (const byte) assertType::t1#27 = TYPEID_WORD
Constant (const byte) assertType::t2#27 = TYPEID_WORD
Constant (const byte) assertType::t1#28 = TYPEID_WORD
Constant (const byte) assertType::t2#28 = TYPEID_WORD
Constant (const byte) assertType::t1#29 = TYPEID_WORD
Constant (const byte) assertType::t2#29 = TYPEID_WORD
Constant (const byte) assertType::t1#30 = TYPEID_DWORD
Constant (const byte) assertType::t2#30 = TYPEID_DWORD
Constant (const byte) assertType::t1#31 = TYPEID_DWORD
Constant (const byte) assertType::t2#31 = TYPEID_DWORD
Constant (const byte) assertType::t1#32 = TYPEID_DWORD
Constant (const byte) assertType::t2#32 = TYPEID_DWORD
Constant (const byte) assertType::t1#33 = TYPEID_DWORD
Constant (const byte) assertType::t2#33 = TYPEID_DWORD
Constant (const byte) assertType::t1#34 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#34 = TYPEID_DWORD
Constant (const byte) idx#41 = 0
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant (const byte) idx#41
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure _start
Removing unused procedure block _start
Removing unused procedure block _start::_init1
Removing unused procedure block _start::@1
Removing unused procedure block _start::@2
Removing unused procedure block _start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings (const byte) assertType::t1#0
Inlining constant with var siblings (const byte) assertType::t2#0
Inlining constant with var siblings (const byte) assertType::t1#1
Inlining constant with var siblings (const byte) assertType::t2#1
Inlining constant with var siblings (const byte) assertType::t1#2
Inlining constant with var siblings (const byte) assertType::t2#2
Inlining constant with var siblings (const byte) assertType::t1#3
Inlining constant with var siblings (const byte) assertType::t2#3
Inlining constant with var siblings (const byte) assertType::t1#4
Inlining constant with var siblings (const byte) assertType::t2#4
Inlining constant with var siblings (const byte) assertType::t1#5
Inlining constant with var siblings (const byte) assertType::t2#5
Inlining constant with var siblings (const byte) assertType::t1#6
Inlining constant with var siblings (const byte) assertType::t2#6
Inlining constant with var siblings (const byte) assertType::t1#7
Inlining constant with var siblings (const byte) assertType::t2#7
Inlining constant with var siblings (const byte) assertType::t1#8
Inlining constant with var siblings (const byte) assertType::t2#8
Inlining constant with var siblings (const byte) assertType::t1#9
Inlining constant with var siblings (const byte) assertType::t2#9
Inlining constant with var siblings (const byte) assertType::t1#10
Inlining constant with var siblings (const byte) assertType::t2#10
Inlining constant with var siblings (const byte) assertType::t1#11
Inlining constant with var siblings (const byte) assertType::t2#11
Inlining constant with var siblings (const byte) assertType::t1#12
Inlining constant with var siblings (const byte) assertType::t2#12
Inlining constant with var siblings (const byte) assertType::t1#13
Inlining constant with var siblings (const byte) assertType::t2#13
Inlining constant with var siblings (const byte) assertType::t1#14
Inlining constant with var siblings (const byte) assertType::t2#14
Inlining constant with var siblings (const byte) assertType::t1#15
Inlining constant with var siblings (const byte) assertType::t2#15
Inlining constant with var siblings (const byte) assertType::t1#16
Inlining constant with var siblings (const byte) assertType::t2#16
Inlining constant with var siblings (const byte) assertType::t1#17
Inlining constant with var siblings (const byte) assertType::t2#17
Inlining constant with var siblings (const byte) assertType::t1#18
Inlining constant with var siblings (const byte) assertType::t2#18
Inlining constant with var siblings (const byte) assertType::t1#19
Inlining constant with var siblings (const byte) assertType::t2#19
Inlining constant with var siblings (const byte) assertType::t1#20
Inlining constant with var siblings (const byte) assertType::t2#20
Inlining constant with var siblings (const byte) assertType::t1#21
Inlining constant with var siblings (const byte) assertType::t2#21
Inlining constant with var siblings (const byte) assertType::t1#22
Inlining constant with var siblings (const byte) assertType::t2#22
Inlining constant with var siblings (const byte) assertType::t1#23
Inlining constant with var siblings (const byte) assertType::t2#23
Inlining constant with var siblings (const byte) assertType::t1#24
Inlining constant with var siblings (const byte) assertType::t2#24
Inlining constant with var siblings (const byte) assertType::t1#25
Inlining constant with var siblings (const byte) assertType::t2#25
Inlining constant with var siblings (const byte) assertType::t1#26
Inlining constant with var siblings (const byte) assertType::t2#26
Inlining constant with var siblings (const byte) assertType::t1#27
Inlining constant with var siblings (const byte) assertType::t2#27
Inlining constant with var siblings (const byte) assertType::t1#28
Inlining constant with var siblings (const byte) assertType::t2#28
Inlining constant with var siblings (const byte) assertType::t1#29
Inlining constant with var siblings (const byte) assertType::t2#29
Inlining constant with var siblings (const byte) assertType::t1#30
Inlining constant with var siblings (const byte) assertType::t2#30
Inlining constant with var siblings (const byte) assertType::t1#31
Inlining constant with var siblings (const byte) assertType::t2#31
Inlining constant with var siblings (const byte) assertType::t1#32
Inlining constant with var siblings (const byte) assertType::t2#32
Inlining constant with var siblings (const byte) assertType::t1#33
Inlining constant with var siblings (const byte) assertType::t2#33
Inlining constant with var siblings (const byte) assertType::t1#34
Inlining constant with var siblings (const byte) assertType::t2#34
Inlining constant with var siblings (const byte) idx#0
Inlining constant with var siblings (const byte) idx#10
Inlining constant with var siblings (const byte) idx#23
Constant inlined assertType::t2#5 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#6 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#7 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#8 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#9 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#31 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#30 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#21 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#33 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#20 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#32 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#23 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#22 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#34 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#25 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#24 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#27 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#0 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t1#26 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#1 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t1#29 = (const byte) TYPEID_WORD
Constant inlined idx#0 = (byte) 0
Constant inlined assertType::t2#2 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#28 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#3 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#4 = (const byte) TYPEID_SIGNED_WORD
Constant inlined idx#23 = (byte) $50
Constant inlined assertType::t2#20 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#10 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#22 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#21 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#12 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#24 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#11 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#23 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#14 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#26 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#13 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#25 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#16 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#28 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#15 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#27 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#18 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#17 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#29 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#19 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#6 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined idx#10 = (byte) $28
Constant inlined assertType::t1#7 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#8 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#9 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#11 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#10 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#13 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#12 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#15 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#14 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#0 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t2#17 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#1 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#16 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#2 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#19 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#3 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#18 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#4 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t1#5 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#30 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#32 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#31 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#34 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#33 = (const byte) TYPEID_DWORD
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@9
Adding NOP phi() at start of main::@21
Adding NOP phi() at start of main::@35
CALL GRAPH
Calls in [main] to assertType:1 assertType:3 assertType:5 assertType:7 assertType:9 assertType:11 assertType:13 assertType:15 assertType:17 assertType:19 assertType:21 assertType:23 assertType:25 assertType:27 assertType:29 assertType:31 assertType:33 assertType:35 assertType:37 assertType:39 assertType:41 assertType:43 assertType:45 assertType:47 assertType:49 assertType:51 assertType:53 assertType:55 assertType:57 assertType:59 assertType:61 assertType:63 assertType:65 assertType:67 assertType:69 

Created 3 initial phi equivalence classes
Coalesced [2] idx#88 ← idx#39
Coalesced (already) [4] idx#99 ← idx#39
Coalesced (already) [6] idx#109 ← idx#39
Coalesced (already) [8] idx#115 ← idx#39
Coalesced (already) [10] idx#116 ← idx#39
Coalesced (already) [12] idx#117 ← idx#39
Coalesced (already) [14] idx#118 ← idx#39
Coalesced (already) [16] idx#119 ← idx#39
Coalesced (already) [20] idx#89 ← idx#39
Coalesced (already) [22] idx#90 ← idx#39
Coalesced (already) [24] idx#91 ← idx#39
Coalesced (already) [26] idx#92 ← idx#39
Coalesced (already) [28] idx#93 ← idx#39
Coalesced (already) [30] idx#94 ← idx#39
Coalesced (already) [32] idx#95 ← idx#39
Coalesced (already) [34] idx#96 ← idx#39
Coalesced (already) [36] idx#97 ← idx#39
Coalesced (already) [38] idx#98 ← idx#39
Coalesced (already) [40] idx#100 ← idx#39
Coalesced (already) [44] idx#101 ← idx#39
Coalesced (already) [46] idx#102 ← idx#39
Coalesced (already) [48] idx#103 ← idx#39
Coalesced (already) [50] idx#104 ← idx#39
Coalesced (already) [52] idx#105 ← idx#39
Coalesced (already) [54] idx#106 ← idx#39
Coalesced (already) [56] idx#107 ← idx#39
Coalesced (already) [58] idx#108 ← idx#39
Coalesced (already) [60] idx#110 ← idx#39
Coalesced (already) [62] idx#111 ← idx#39
Coalesced (already) [64] idx#112 ← idx#39
Coalesced (already) [66] idx#113 ← idx#39
Coalesced (already) [68] idx#114 ← idx#39
Coalesced down to 3 phi equivalence classes
Culled Empty Block (label) main::@35
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@9
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@12
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@16
Adding NOP phi() at start of main::@17
Adding NOP phi() at start of main::@18
Adding NOP phi() at start of main::@19
Adding NOP phi() at start of main::@20
Adding NOP phi() at start of main::@21
Adding NOP phi() at start of main::@22
Adding NOP phi() at start of main::@23
Adding NOP phi() at start of main::@24
Adding NOP phi() at start of main::@25
Adding NOP phi() at start of main::@26
Adding NOP phi() at start of main::@27
Adding NOP phi() at start of main::@28
Adding NOP phi() at start of main::@29
Adding NOP phi() at start of main::@30
Adding NOP phi() at start of main::@31
Adding NOP phi() at start of main::@32
Adding NOP phi() at start of main::@33
Adding NOP phi() at start of main::@34

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call assertType 
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call assertType 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] phi()
  [5] call assertType 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [6] phi()
  [7] call assertType 
  to:main::@4
main::@4: scope:[main]  from main::@3
  [8] phi()
  [9] call assertType 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [10] phi()
  [11] call assertType 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [12] phi()
  [13] call assertType 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [14] phi()
  [15] call assertType 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [16] phi()
  [17] call assertType 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [18] phi()
  [19] call assertType 
  to:main::@10
main::@10: scope:[main]  from main::@9
  [20] phi()
  [21] call assertType 
  to:main::@11
main::@11: scope:[main]  from main::@10
  [22] phi()
  [23] call assertType 
  to:main::@12
main::@12: scope:[main]  from main::@11
  [24] phi()
  [25] call assertType 
  to:main::@13
main::@13: scope:[main]  from main::@12
  [26] phi()
  [27] call assertType 
  to:main::@14
main::@14: scope:[main]  from main::@13
  [28] phi()
  [29] call assertType 
  to:main::@15
main::@15: scope:[main]  from main::@14
  [30] phi()
  [31] call assertType 
  to:main::@16
main::@16: scope:[main]  from main::@15
  [32] phi()
  [33] call assertType 
  to:main::@17
main::@17: scope:[main]  from main::@16
  [34] phi()
  [35] call assertType 
  to:main::@18
main::@18: scope:[main]  from main::@17
  [36] phi()
  [37] call assertType 
  to:main::@19
main::@19: scope:[main]  from main::@18
  [38] phi()
  [39] call assertType 
  to:main::@20
main::@20: scope:[main]  from main::@19
  [40] phi()
  [41] call assertType 
  to:main::@21
main::@21: scope:[main]  from main::@20
  [42] phi()
  [43] call assertType 
  to:main::@22
main::@22: scope:[main]  from main::@21
  [44] phi()
  [45] call assertType 
  to:main::@23
main::@23: scope:[main]  from main::@22
  [46] phi()
  [47] call assertType 
  to:main::@24
main::@24: scope:[main]  from main::@23
  [48] phi()
  [49] call assertType 
  to:main::@25
main::@25: scope:[main]  from main::@24
  [50] phi()
  [51] call assertType 
  to:main::@26
main::@26: scope:[main]  from main::@25
  [52] phi()
  [53] call assertType 
  to:main::@27
main::@27: scope:[main]  from main::@26
  [54] phi()
  [55] call assertType 
  to:main::@28
main::@28: scope:[main]  from main::@27
  [56] phi()
  [57] call assertType 
  to:main::@29
main::@29: scope:[main]  from main::@28
  [58] phi()
  [59] call assertType 
  to:main::@30
main::@30: scope:[main]  from main::@29
  [60] phi()
  [61] call assertType 
  to:main::@31
main::@31: scope:[main]  from main::@30
  [62] phi()
  [63] call assertType 
  to:main::@32
main::@32: scope:[main]  from main::@31
  [64] phi()
  [65] call assertType 
  to:main::@33
main::@33: scope:[main]  from main::@32
  [66] phi()
  [67] call assertType 
  to:main::@34
main::@34: scope:[main]  from main::@33
  [68] phi()
  [69] call assertType 
  to:main::@return
main::@return: scope:[main]  from main::@34
  [70] return 
  to:@return

(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
assertType: scope:[assertType]  from main main::@1 main::@10 main::@11 main::@12 main::@13 main::@14 main::@15 main::@16 main::@17 main::@18 main::@19 main::@2 main::@20 main::@21 main::@22 main::@23 main::@24 main::@25 main::@26 main::@27 main::@28 main::@29 main::@3 main::@30 main::@31 main::@32 main::@33 main::@34 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  [71] (byte) idx#80 ← phi( main/(byte) 0 main::@1/(byte) idx#39 main::@10/(byte) idx#39 main::@11/(byte) idx#39 main::@12/(byte) idx#39 main::@13/(byte) idx#39 main::@14/(byte) idx#39 main::@15/(byte) idx#39 main::@16/(byte) idx#39 main::@17/(byte) idx#39 main::@18/(byte) idx#39 main::@19/(byte) idx#39 main::@2/(byte) idx#39 main::@20/(byte) idx#39 main::@21/(byte) $50 main::@22/(byte) idx#39 main::@23/(byte) idx#39 main::@24/(byte) idx#39 main::@25/(byte) idx#39 main::@26/(byte) idx#39 main::@27/(byte) idx#39 main::@28/(byte) idx#39 main::@29/(byte) idx#39 main::@3/(byte) idx#39 main::@30/(byte) idx#39 main::@31/(byte) idx#39 main::@32/(byte) idx#39 main::@33/(byte) idx#39 main::@34/(byte) idx#39 main::@4/(byte) idx#39 main::@5/(byte) idx#39 main::@6/(byte) idx#39 main::@7/(byte) idx#39 main::@8/(byte) idx#39 main::@9/(byte) $28 )
  [71] (byte) assertType::t2#35 ← phi( main/(const byte) TYPEID_SIGNED_BYTE main::@1/(const byte) TYPEID_SIGNED_WORD main::@10/(const byte) TYPEID_BYTE main::@11/(const byte) TYPEID_WORD main::@12/(const byte) TYPEID_WORD main::@13/(const byte) TYPEID_DWORD main::@14/(const byte) TYPEID_WORD main::@15/(const byte) TYPEID_WORD main::@16/(const byte) TYPEID_DWORD main::@17/(const byte) TYPEID_DWORD main::@18/(const byte) TYPEID_DWORD main::@19/(const byte) TYPEID_DWORD main::@2/(const byte) TYPEID_SIGNED_DWORD main::@20/(const byte) TYPEID_DWORD main::@21/(const byte) TYPEID_BYTE main::@22/(const byte) TYPEID_BYTE main::@23/(const byte) TYPEID_BYTE main::@24/(const byte) TYPEID_WORD main::@25/(const byte) TYPEID_WORD main::@26/(const byte) TYPEID_DWORD main::@27/(const byte) TYPEID_WORD main::@28/(const byte) TYPEID_WORD main::@29/(const byte) TYPEID_WORD main::@3/(const byte) TYPEID_SIGNED_WORD main::@30/(const byte) TYPEID_DWORD main::@31/(const byte) TYPEID_DWORD main::@32/(const byte) TYPEID_DWORD main::@33/(const byte) TYPEID_DWORD main::@34/(const byte) TYPEID_DWORD main::@4/(const byte) TYPEID_SIGNED_WORD main::@5/(const byte) TYPEID_SIGNED_DWORD main::@6/(const byte) TYPEID_SIGNED_DWORD main::@7/(const byte) TYPEID_SIGNED_DWORD main::@8/(const byte) TYPEID_SIGNED_DWORD main::@9/(const byte) TYPEID_BYTE )
  [71] (byte) assertType::t1#35 ← phi( main/(const byte) TYPEID_SIGNED_BYTE main::@1/(const byte) TYPEID_SIGNED_WORD main::@10/(const byte) TYPEID_BYTE main::@11/(const byte) TYPEID_WORD main::@12/(const byte) TYPEID_WORD main::@13/(const byte) TYPEID_DWORD main::@14/(const byte) TYPEID_WORD main::@15/(const byte) TYPEID_WORD main::@16/(const byte) TYPEID_DWORD main::@17/(const byte) TYPEID_DWORD main::@18/(const byte) TYPEID_DWORD main::@19/(const byte) TYPEID_DWORD main::@2/(const byte) TYPEID_SIGNED_DWORD main::@20/(const byte) TYPEID_DWORD main::@21/(const byte) TYPEID_BYTE main::@22/(const byte) TYPEID_BYTE main::@23/(const byte) TYPEID_BYTE main::@24/(const byte) TYPEID_WORD main::@25/(const byte) TYPEID_WORD main::@26/(const byte) TYPEID_DWORD main::@27/(const byte) TYPEID_WORD main::@28/(const byte) TYPEID_WORD main::@29/(const byte) TYPEID_WORD main::@3/(const byte) TYPEID_SIGNED_WORD main::@30/(const byte) TYPEID_DWORD main::@31/(const byte) TYPEID_DWORD main::@32/(const byte) TYPEID_DWORD main::@33/(const byte) TYPEID_DWORD main::@34/(const byte) TYPEID_SIGNED_DWORD main::@4/(const byte) TYPEID_SIGNED_WORD main::@5/(const byte) TYPEID_SIGNED_DWORD main::@6/(const byte) TYPEID_SIGNED_DWORD main::@7/(const byte) TYPEID_SIGNED_DWORD main::@8/(const byte) TYPEID_SIGNED_DWORD main::@9/(const byte) TYPEID_BYTE )
  [72] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1
  to:assertType::@3
assertType::@3: scope:[assertType]  from assertType
  [73] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  [74] *((const nomodify byte*) SCREEN + (byte) idx#80) ← (byte) assertType::t1#35
  [75] (byte) idx#39 ← ++ (byte) idx#80
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  [76] return 
  to:@return
assertType::@1: scope:[assertType]  from assertType
  [77] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) GREEN
  to:assertType::@2


VARIABLE REGISTER WEIGHTS
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(byte) assertType::t1
(byte) assertType::t1#35 5.5
(byte) assertType::t2
(byte) assertType::t2#35 11.0
(byte) idx
(byte) idx#39 1.1363636363636358
(byte) idx#80 21.600000000000005
(void()) main()

Initial phi equivalence classes
[ assertType::t1#35 ]
[ assertType::t2#35 ]
[ idx#80 idx#39 ]
Complete equivalence classes
[ assertType::t1#35 ]
[ assertType::t2#35 ]
[ idx#80 idx#39 ]
Allocated zp[1]:2 [ assertType::t1#35 ]
Allocated zp[1]:3 [ assertType::t2#35 ]
Allocated zp[1]:4 [ idx#80 idx#39 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Tests conversion of numbers to correct int types
// See https://gitlab.com/camelot/kickc/issues/181
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_SIGNED_DWORD = 6
  .const TYPEID_BYTE = 1
  .const TYPEID_WORD = 3
  .const TYPEID_DWORD = 5
  .const RED = 2
  .const GREEN = 5
  .label SCREEN = $400
  .label COLS = $d800
  // Signed type and number
  // a) If one operand is a signed type and the other a number.
  //    The number becomes the smallest signed type that can hold its value (if one exists).
  //    The two operands are then converted normally (using 2a or 2b).
  // Unsigned type and positive number
  // b) If one operand is an unsigned type and the other a positive number.
  //    The number is converted to the smallest unsigned type that can hold the value.
  //    The two operands are then converted normally (using 2a or 2b).
  // Unsigned type and negative number
  // If one operand is an unsigned type and the other a negative number.
  // The number is first converted to the smallest signed type that can hold its value (if one exits).
  // If the signed type is smaller than the unsigned type it is converted up to the size of the unsigned type.
  // The signed type is finally converted to unsigned.
  // The two unsigned operands are then finally converted to the size of the largest type (using 2b).
  .label idx = 4
  // main
main: {
    // [1] call assertType 
    // [71] phi from main to assertType [phi:main->assertType]
  assertType_from_main:
    // [71] phi (byte) idx#80 = (byte) 0 [phi:main->assertType#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t1
    jsr assertType
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call assertType 
    // [71] phi from main::@1 to assertType [phi:main::@1->assertType]
  assertType_from___b1:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@1->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t1
    jsr assertType
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [5] call assertType 
    // [71] phi from main::@2 to assertType [phi:main::@2->assertType]
  assertType_from___b2:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@2->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t1
    jsr assertType
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [7] call assertType 
    // [71] phi from main::@3 to assertType [phi:main::@3->assertType]
  assertType_from___b3:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@3->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t1
    jsr assertType
    // [8] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  __b4_from___b3:
    jmp __b4
    // main::@4
  __b4:
    // [9] call assertType 
    // [71] phi from main::@4 to assertType [phi:main::@4->assertType]
  assertType_from___b4:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@4->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t1
    jsr assertType
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    jmp __b5
    // main::@5
  __b5:
    // [11] call assertType 
    // [71] phi from main::@5 to assertType [phi:main::@5->assertType]
  assertType_from___b5:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@5->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t1
    jsr assertType
    // [12] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    jmp __b6
    // main::@6
  __b6:
    // [13] call assertType 
    // [71] phi from main::@6 to assertType [phi:main::@6->assertType]
  assertType_from___b6:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@6->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t1
    jsr assertType
    // [14] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  __b7_from___b6:
    jmp __b7
    // main::@7
  __b7:
    // [15] call assertType 
    // [71] phi from main::@7 to assertType [phi:main::@7->assertType]
  assertType_from___b7:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@7->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t1
    jsr assertType
    // [16] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  __b8_from___b7:
    jmp __b8
    // main::@8
  __b8:
    // [17] call assertType 
    // [71] phi from main::@8 to assertType [phi:main::@8->assertType]
  assertType_from___b8:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@8->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t1
    jsr assertType
    // [18] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
  __b9_from___b8:
    jmp __b9
    // main::@9
  __b9:
    // [19] call assertType 
    // [71] phi from main::@9 to assertType [phi:main::@9->assertType]
  assertType_from___b9:
    // [71] phi (byte) idx#80 = (byte) $28 [phi:main::@9->assertType#0] -- vbuz1=vbuc1 
    lda #$28
    sta.z idx
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t1
    jsr assertType
    // [20] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  __b10_from___b9:
    jmp __b10
    // main::@10
  __b10:
    // [21] call assertType 
    // [71] phi from main::@10 to assertType [phi:main::@10->assertType]
  assertType_from___b10:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@10->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t1
    jsr assertType
    // [22] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  __b11_from___b10:
    jmp __b11
    // main::@11
  __b11:
    // [23] call assertType 
    // [71] phi from main::@11 to assertType [phi:main::@11->assertType]
  assertType_from___b11:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@11->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [24] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  __b12_from___b11:
    jmp __b12
    // main::@12
  __b12:
    // [25] call assertType 
    // [71] phi from main::@12 to assertType [phi:main::@12->assertType]
  assertType_from___b12:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@12->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [26] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
  __b13_from___b12:
    jmp __b13
    // main::@13
  __b13:
    // [27] call assertType 
    // [71] phi from main::@13 to assertType [phi:main::@13->assertType]
  assertType_from___b13:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@13->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [28] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
  __b14_from___b13:
    jmp __b14
    // main::@14
  __b14:
    // [29] call assertType 
    // [71] phi from main::@14 to assertType [phi:main::@14->assertType]
  assertType_from___b14:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@14->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [30] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  __b15_from___b14:
    jmp __b15
    // main::@15
  __b15:
    // [31] call assertType 
    // [71] phi from main::@15 to assertType [phi:main::@15->assertType]
  assertType_from___b15:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@15->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [32] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
  __b16_from___b15:
    jmp __b16
    // main::@16
  __b16:
    // [33] call assertType 
    // [71] phi from main::@16 to assertType [phi:main::@16->assertType]
  assertType_from___b16:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@16->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [34] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
  __b17_from___b16:
    jmp __b17
    // main::@17
  __b17:
    // [35] call assertType 
    // [71] phi from main::@17 to assertType [phi:main::@17->assertType]
  assertType_from___b17:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@17->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [36] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  __b18_from___b17:
    jmp __b18
    // main::@18
  __b18:
    // [37] call assertType 
    // [71] phi from main::@18 to assertType [phi:main::@18->assertType]
  assertType_from___b18:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@18->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [38] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  __b19_from___b18:
    jmp __b19
    // main::@19
  __b19:
    // [39] call assertType 
    // [71] phi from main::@19 to assertType [phi:main::@19->assertType]
  assertType_from___b19:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@19->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [40] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  __b20_from___b19:
    jmp __b20
    // main::@20
  __b20:
    // [41] call assertType 
    // [71] phi from main::@20 to assertType [phi:main::@20->assertType]
  assertType_from___b20:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@20->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [42] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
  __b21_from___b20:
    jmp __b21
    // main::@21
  __b21:
    // [43] call assertType 
    // [71] phi from main::@21 to assertType [phi:main::@21->assertType]
  assertType_from___b21:
    // [71] phi (byte) idx#80 = (byte) $50 [phi:main::@21->assertType#0] -- vbuz1=vbuc1 
    lda #$50
    sta.z idx
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t1
    jsr assertType
    // [44] phi from main::@21 to main::@22 [phi:main::@21->main::@22]
  __b22_from___b21:
    jmp __b22
    // main::@22
  __b22:
    // [45] call assertType 
    // [71] phi from main::@22 to assertType [phi:main::@22->assertType]
  assertType_from___b22:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@22->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t1
    jsr assertType
    // [46] phi from main::@22 to main::@23 [phi:main::@22->main::@23]
  __b23_from___b22:
    jmp __b23
    // main::@23
  __b23:
    // [47] call assertType 
    // [71] phi from main::@23 to assertType [phi:main::@23->assertType]
  assertType_from___b23:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@23->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t1
    jsr assertType
    // [48] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
  __b24_from___b23:
    jmp __b24
    // main::@24
  __b24:
    // [49] call assertType 
    // [71] phi from main::@24 to assertType [phi:main::@24->assertType]
  assertType_from___b24:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@24->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [50] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
  __b25_from___b24:
    jmp __b25
    // main::@25
  __b25:
    // [51] call assertType 
    // [71] phi from main::@25 to assertType [phi:main::@25->assertType]
  assertType_from___b25:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@25->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [52] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
  __b26_from___b25:
    jmp __b26
    // main::@26
  __b26:
    // [53] call assertType 
    // [71] phi from main::@26 to assertType [phi:main::@26->assertType]
  assertType_from___b26:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@26->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [54] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
  __b27_from___b26:
    jmp __b27
    // main::@27
  __b27:
    // [55] call assertType 
    // [71] phi from main::@27 to assertType [phi:main::@27->assertType]
  assertType_from___b27:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@27->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [56] phi from main::@27 to main::@28 [phi:main::@27->main::@28]
  __b28_from___b27:
    jmp __b28
    // main::@28
  __b28:
    // [57] call assertType 
    // [71] phi from main::@28 to assertType [phi:main::@28->assertType]
  assertType_from___b28:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@28->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [58] phi from main::@28 to main::@29 [phi:main::@28->main::@29]
  __b29_from___b28:
    jmp __b29
    // main::@29
  __b29:
    // [59] call assertType 
    // [71] phi from main::@29 to assertType [phi:main::@29->assertType]
  assertType_from___b29:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@29->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [60] phi from main::@29 to main::@30 [phi:main::@29->main::@30]
  __b30_from___b29:
    jmp __b30
    // main::@30
  __b30:
    // [61] call assertType 
    // [71] phi from main::@30 to assertType [phi:main::@30->assertType]
  assertType_from___b30:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@30->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [62] phi from main::@30 to main::@31 [phi:main::@30->main::@31]
  __b31_from___b30:
    jmp __b31
    // main::@31
  __b31:
    // [63] call assertType 
    // [71] phi from main::@31 to assertType [phi:main::@31->assertType]
  assertType_from___b31:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@31->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [64] phi from main::@31 to main::@32 [phi:main::@31->main::@32]
  __b32_from___b31:
    jmp __b32
    // main::@32
  __b32:
    // [65] call assertType 
    // [71] phi from main::@32 to assertType [phi:main::@32->assertType]
  assertType_from___b32:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@32->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [66] phi from main::@32 to main::@33 [phi:main::@32->main::@33]
  __b33_from___b32:
    jmp __b33
    // main::@33
  __b33:
    // [67] call assertType 
    // [71] phi from main::@33 to assertType [phi:main::@33->assertType]
  assertType_from___b33:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@33->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [68] phi from main::@33 to main::@34 [phi:main::@33->main::@34]
  __b34_from___b33:
    jmp __b34
    // main::@34
  __b34:
    // [69] call assertType 
    // [71] phi from main::@34 to assertType [phi:main::@34->assertType]
  assertType_from___b34:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@34->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@34->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@34->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t1
    jsr assertType
    jmp __breturn
    // main::@return
  __breturn:
    // [70] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte zp(2) t1, byte zp(3) t2)
assertType: {
    .label t1 = 2
    .label t2 = 3
    // [72] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1 -- vbuz1_eq_vbuz2_then_la1 
    lda.z t1
    cmp.z t2
    beq __b1
    jmp __b3
    // assertType::@3
  __b3:
    // [73] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) RED -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #RED
    ldy.z idx
    sta COLS,y
    jmp __b2
    // assertType::@2
  __b2:
    // [74] *((const nomodify byte*) SCREEN + (byte) idx#80) ← (byte) assertType::t1#35 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z t1
    ldy.z idx
    sta SCREEN,y
    // [75] (byte) idx#39 ← ++ (byte) idx#80 -- vbuz1=_inc_vbuz1 
    inc.z idx
    jmp __breturn
    // assertType::@return
  __breturn:
    // [76] return 
    rts
    // assertType::@1
  __b1:
    // [77] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) GREEN -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy.z idx
    sta COLS,y
    jmp __b2
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [73] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) RED [ assertType::t1#35 idx#80 ] ( assertType:1 [ assertType::t1#35 idx#80 ] { }  assertType:3 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ assertType::t1#35 idx#80 ] { }  assertType:21 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ assertType::t1#35 idx#80 ] { }  assertType:45 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ assertType::t1#35 ]
Removing always clobbered register reg byte a as potential for zp[1]:4 [ idx#80 idx#39 ]
Statement [74] *((const nomodify byte*) SCREEN + (byte) idx#80) ← (byte) assertType::t1#35 [ idx#80 ] ( assertType:1 [ idx#80 ] { }  assertType:3 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ idx#80 ] { }  assertType:21 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ idx#80 ] { }  assertType:45 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Statement [77] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) GREEN [ assertType::t1#35 idx#80 ] ( assertType:1 [ assertType::t1#35 idx#80 ] { }  assertType:3 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ assertType::t1#35 idx#80 ] { }  assertType:21 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ assertType::t1#35 idx#80 ] { }  assertType:45 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Statement [73] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) RED [ assertType::t1#35 idx#80 ] ( assertType:1 [ assertType::t1#35 idx#80 ] { }  assertType:3 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ assertType::t1#35 idx#80 ] { }  assertType:21 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ assertType::t1#35 idx#80 ] { }  assertType:45 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Statement [74] *((const nomodify byte*) SCREEN + (byte) idx#80) ← (byte) assertType::t1#35 [ idx#80 ] ( assertType:1 [ idx#80 ] { }  assertType:3 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ idx#80 ] { }  assertType:21 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ idx#80 ] { }  assertType:45 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Statement [77] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) GREEN [ assertType::t1#35 idx#80 ] ( assertType:1 [ assertType::t1#35 idx#80 ] { }  assertType:3 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:5 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:7 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:9 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:11 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:13 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:15 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:17 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:19 [ assertType::t1#35 idx#80 ] { }  assertType:21 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:23 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:25 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:27 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:29 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:31 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:33 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:35 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:37 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:39 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:41 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:43 [ assertType::t1#35 idx#80 ] { }  assertType:45 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:47 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:49 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:51 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:53 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:55 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:57 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:59 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:61 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:63 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:65 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:67 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  assertType:69 [ assertType::t1#35 idx#80 ] { { idx#39 = idx#80 } }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ assertType::t1#35 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ assertType::t2#35 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ idx#80 idx#39 ] : zp[1]:4 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 22.74: zp[1]:4 [ idx#80 idx#39 ] 
Uplift Scope [assertType] 11: zp[1]:3 [ assertType::t2#35 ] 5.5: zp[1]:2 [ assertType::t1#35 ] 
Uplift Scope [main] 

Uplifting [] best 727 combination reg byte x [ idx#80 idx#39 ] 
Uplifting [assertType] best 620 combination zp[1]:3 [ assertType::t2#35 ] reg byte y [ assertType::t1#35 ] 
Uplifting [main] best 620 combination 
Attempting to uplift remaining variables inzp[1]:3 [ assertType::t2#35 ]
Uplifting [assertType] best 620 combination zp[1]:3 [ assertType::t2#35 ] 
Allocated (was zp[1]:3) zp[1]:2 [ assertType::t2#35 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests conversion of numbers to correct int types
// See https://gitlab.com/camelot/kickc/issues/181
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_SIGNED_DWORD = 6
  .const TYPEID_BYTE = 1
  .const TYPEID_WORD = 3
  .const TYPEID_DWORD = 5
  .const RED = 2
  .const GREEN = 5
  .label SCREEN = $400
  .label COLS = $d800
  // main
main: {
    // [1] call assertType 
    // [71] phi from main to assertType [phi:main->assertType]
  assertType_from_main:
    // [71] phi (byte) idx#80 = (byte) 0 [phi:main->assertType#0] -- vbuxx=vbuc1 
    ldx #0
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    jsr assertType
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call assertType 
    // [71] phi from main::@1 to assertType [phi:main::@1->assertType]
  assertType_from___b1:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@1->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [5] call assertType 
    // [71] phi from main::@2 to assertType [phi:main::@2->assertType]
  assertType_from___b2:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@2->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [7] call assertType 
    // [71] phi from main::@3 to assertType [phi:main::@3->assertType]
  assertType_from___b3:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@3->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
    // [8] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  __b4_from___b3:
    jmp __b4
    // main::@4
  __b4:
    // [9] call assertType 
    // [71] phi from main::@4 to assertType [phi:main::@4->assertType]
  assertType_from___b4:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@4->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    jmp __b5
    // main::@5
  __b5:
    // [11] call assertType 
    // [71] phi from main::@5 to assertType [phi:main::@5->assertType]
  assertType_from___b5:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@5->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    // [12] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    jmp __b6
    // main::@6
  __b6:
    // [13] call assertType 
    // [71] phi from main::@6 to assertType [phi:main::@6->assertType]
  assertType_from___b6:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@6->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    // [14] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  __b7_from___b6:
    jmp __b7
    // main::@7
  __b7:
    // [15] call assertType 
    // [71] phi from main::@7 to assertType [phi:main::@7->assertType]
  assertType_from___b7:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@7->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    // [16] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  __b8_from___b7:
    jmp __b8
    // main::@8
  __b8:
    // [17] call assertType 
    // [71] phi from main::@8 to assertType [phi:main::@8->assertType]
  assertType_from___b8:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@8->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    // [18] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
  __b9_from___b8:
    jmp __b9
    // main::@9
  __b9:
    // [19] call assertType 
    // [71] phi from main::@9 to assertType [phi:main::@9->assertType]
  assertType_from___b9:
    // [71] phi (byte) idx#80 = (byte) $28 [phi:main::@9->assertType#0] -- vbuxx=vbuc1 
    ldx #$28
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
    // [20] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
  __b10_from___b9:
    jmp __b10
    // main::@10
  __b10:
    // [21] call assertType 
    // [71] phi from main::@10 to assertType [phi:main::@10->assertType]
  assertType_from___b10:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@10->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
    // [22] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  __b11_from___b10:
    jmp __b11
    // main::@11
  __b11:
    // [23] call assertType 
    // [71] phi from main::@11 to assertType [phi:main::@11->assertType]
  assertType_from___b11:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@11->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [24] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  __b12_from___b11:
    jmp __b12
    // main::@12
  __b12:
    // [25] call assertType 
    // [71] phi from main::@12 to assertType [phi:main::@12->assertType]
  assertType_from___b12:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@12->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [26] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
  __b13_from___b12:
    jmp __b13
    // main::@13
  __b13:
    // [27] call assertType 
    // [71] phi from main::@13 to assertType [phi:main::@13->assertType]
  assertType_from___b13:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@13->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [28] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
  __b14_from___b13:
    jmp __b14
    // main::@14
  __b14:
    // [29] call assertType 
    // [71] phi from main::@14 to assertType [phi:main::@14->assertType]
  assertType_from___b14:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@14->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [30] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  __b15_from___b14:
    jmp __b15
    // main::@15
  __b15:
    // [31] call assertType 
    // [71] phi from main::@15 to assertType [phi:main::@15->assertType]
  assertType_from___b15:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@15->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [32] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
  __b16_from___b15:
    jmp __b16
    // main::@16
  __b16:
    // [33] call assertType 
    // [71] phi from main::@16 to assertType [phi:main::@16->assertType]
  assertType_from___b16:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@16->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [34] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
  __b17_from___b16:
    jmp __b17
    // main::@17
  __b17:
    // [35] call assertType 
    // [71] phi from main::@17 to assertType [phi:main::@17->assertType]
  assertType_from___b17:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@17->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [36] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  __b18_from___b17:
    jmp __b18
    // main::@18
  __b18:
    // [37] call assertType 
    // [71] phi from main::@18 to assertType [phi:main::@18->assertType]
  assertType_from___b18:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@18->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [38] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  __b19_from___b18:
    jmp __b19
    // main::@19
  __b19:
    // [39] call assertType 
    // [71] phi from main::@19 to assertType [phi:main::@19->assertType]
  assertType_from___b19:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@19->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [40] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  __b20_from___b19:
    jmp __b20
    // main::@20
  __b20:
    // [41] call assertType 
    // [71] phi from main::@20 to assertType [phi:main::@20->assertType]
  assertType_from___b20:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@20->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [42] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
  __b21_from___b20:
    jmp __b21
    // main::@21
  __b21:
    // [43] call assertType 
    // [71] phi from main::@21 to assertType [phi:main::@21->assertType]
  assertType_from___b21:
    // [71] phi (byte) idx#80 = (byte) $50 [phi:main::@21->assertType#0] -- vbuxx=vbuc1 
    ldx #$50
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
    // [44] phi from main::@21 to main::@22 [phi:main::@21->main::@22]
  __b22_from___b21:
    jmp __b22
    // main::@22
  __b22:
    // [45] call assertType 
    // [71] phi from main::@22 to assertType [phi:main::@22->assertType]
  assertType_from___b22:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@22->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
    // [46] phi from main::@22 to main::@23 [phi:main::@22->main::@23]
  __b23_from___b22:
    jmp __b23
    // main::@23
  __b23:
    // [47] call assertType 
    // [71] phi from main::@23 to assertType [phi:main::@23->assertType]
  assertType_from___b23:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@23->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
    // [48] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
  __b24_from___b23:
    jmp __b24
    // main::@24
  __b24:
    // [49] call assertType 
    // [71] phi from main::@24 to assertType [phi:main::@24->assertType]
  assertType_from___b24:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@24->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [50] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
  __b25_from___b24:
    jmp __b25
    // main::@25
  __b25:
    // [51] call assertType 
    // [71] phi from main::@25 to assertType [phi:main::@25->assertType]
  assertType_from___b25:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@25->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [52] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
  __b26_from___b25:
    jmp __b26
    // main::@26
  __b26:
    // [53] call assertType 
    // [71] phi from main::@26 to assertType [phi:main::@26->assertType]
  assertType_from___b26:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@26->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [54] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
  __b27_from___b26:
    jmp __b27
    // main::@27
  __b27:
    // [55] call assertType 
    // [71] phi from main::@27 to assertType [phi:main::@27->assertType]
  assertType_from___b27:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@27->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [56] phi from main::@27 to main::@28 [phi:main::@27->main::@28]
  __b28_from___b27:
    jmp __b28
    // main::@28
  __b28:
    // [57] call assertType 
    // [71] phi from main::@28 to assertType [phi:main::@28->assertType]
  assertType_from___b28:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@28->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [58] phi from main::@28 to main::@29 [phi:main::@28->main::@29]
  __b29_from___b28:
    jmp __b29
    // main::@29
  __b29:
    // [59] call assertType 
    // [71] phi from main::@29 to assertType [phi:main::@29->assertType]
  assertType_from___b29:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@29->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [60] phi from main::@29 to main::@30 [phi:main::@29->main::@30]
  __b30_from___b29:
    jmp __b30
    // main::@30
  __b30:
    // [61] call assertType 
    // [71] phi from main::@30 to assertType [phi:main::@30->assertType]
  assertType_from___b30:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@30->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [62] phi from main::@30 to main::@31 [phi:main::@30->main::@31]
  __b31_from___b30:
    jmp __b31
    // main::@31
  __b31:
    // [63] call assertType 
    // [71] phi from main::@31 to assertType [phi:main::@31->assertType]
  assertType_from___b31:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@31->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [64] phi from main::@31 to main::@32 [phi:main::@31->main::@32]
  __b32_from___b31:
    jmp __b32
    // main::@32
  __b32:
    // [65] call assertType 
    // [71] phi from main::@32 to assertType [phi:main::@32->assertType]
  assertType_from___b32:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@32->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [66] phi from main::@32 to main::@33 [phi:main::@32->main::@33]
  __b33_from___b32:
    jmp __b33
    // main::@33
  __b33:
    // [67] call assertType 
    // [71] phi from main::@33 to assertType [phi:main::@33->assertType]
  assertType_from___b33:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@33->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [68] phi from main::@33 to main::@34 [phi:main::@33->main::@34]
  __b34_from___b33:
    jmp __b34
    // main::@34
  __b34:
    // [69] call assertType 
    // [71] phi from main::@34 to assertType [phi:main::@34->assertType]
  assertType_from___b34:
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@34->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@34->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@34->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    jmp __breturn
    // main::@return
  __breturn:
    // [70] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(Y) t1, byte zp(2) t2)
assertType: {
    .label t2 = 2
    // [72] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp.z t2
    beq __b1
    jmp __b3
    // assertType::@3
  __b3:
    // [73] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) RED -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta COLS,x
    jmp __b2
    // assertType::@2
  __b2:
    // [74] *((const nomodify byte*) SCREEN + (byte) idx#80) ← (byte) assertType::t1#35 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta SCREEN,x
    // [75] (byte) idx#39 ← ++ (byte) idx#80 -- vbuxx=_inc_vbuxx 
    inx
    jmp __breturn
    // assertType::@return
  __breturn:
    // [76] return 
    rts
    // assertType::@1
  __b1:
    // [77] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta COLS,x
    jmp __b2
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b13
Removing instruction jmp __b14
Removing instruction jmp __b15
Removing instruction jmp __b16
Removing instruction jmp __b17
Removing instruction jmp __b18
Removing instruction jmp __b19
Removing instruction jmp __b20
Removing instruction jmp __b21
Removing instruction jmp __b22
Removing instruction jmp __b23
Removing instruction jmp __b24
Removing instruction jmp __b25
Removing instruction jmp __b26
Removing instruction jmp __b27
Removing instruction jmp __b28
Removing instruction jmp __b29
Removing instruction jmp __b30
Removing instruction jmp __b31
Removing instruction jmp __b32
Removing instruction jmp __b33
Removing instruction jmp __b34
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing instruction ldy #TYPEID_SIGNED_BYTE with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Removing instruction __b1_from_main:
Removing instruction assertType_from___b1:
Removing instruction __b2_from___b1:
Removing instruction assertType_from___b2:
Removing instruction __b3_from___b2:
Removing instruction assertType_from___b3:
Removing instruction __b4_from___b3:
Removing instruction assertType_from___b4:
Removing instruction __b5_from___b4:
Removing instruction assertType_from___b5:
Removing instruction __b6_from___b5:
Removing instruction assertType_from___b6:
Removing instruction __b7_from___b6:
Removing instruction assertType_from___b7:
Removing instruction __b8_from___b7:
Removing instruction assertType_from___b8:
Removing instruction __b9_from___b8:
Removing instruction assertType_from___b9:
Removing instruction __b10_from___b9:
Removing instruction assertType_from___b10:
Removing instruction __b11_from___b10:
Removing instruction assertType_from___b11:
Removing instruction __b12_from___b11:
Removing instruction assertType_from___b12:
Removing instruction __b13_from___b12:
Removing instruction assertType_from___b13:
Removing instruction __b14_from___b13:
Removing instruction assertType_from___b14:
Removing instruction __b15_from___b14:
Removing instruction assertType_from___b15:
Removing instruction __b16_from___b15:
Removing instruction assertType_from___b16:
Removing instruction __b17_from___b16:
Removing instruction assertType_from___b17:
Removing instruction __b18_from___b17:
Removing instruction assertType_from___b18:
Removing instruction __b19_from___b18:
Removing instruction assertType_from___b19:
Removing instruction __b20_from___b19:
Removing instruction assertType_from___b20:
Removing instruction __b21_from___b20:
Removing instruction assertType_from___b21:
Removing instruction __b22_from___b21:
Removing instruction assertType_from___b22:
Removing instruction __b23_from___b22:
Removing instruction assertType_from___b23:
Removing instruction __b24_from___b23:
Removing instruction assertType_from___b24:
Removing instruction __b25_from___b24:
Removing instruction assertType_from___b25:
Removing instruction __b26_from___b25:
Removing instruction assertType_from___b26:
Removing instruction __b27_from___b26:
Removing instruction assertType_from___b27:
Removing instruction __b28_from___b27:
Removing instruction assertType_from___b28:
Removing instruction __b29_from___b28:
Removing instruction assertType_from___b29:
Removing instruction __b30_from___b29:
Removing instruction assertType_from___b30:
Removing instruction __b31_from___b30:
Removing instruction assertType_from___b31:
Removing instruction __b32_from___b31:
Removing instruction assertType_from___b32:
Removing instruction __b33_from___b32:
Removing instruction assertType_from___b33:
Removing instruction __b34_from___b33:
Removing instruction assertType_from___b34:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction assertType_from_main:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b13:
Removing instruction __b14:
Removing instruction __b15:
Removing instruction __b16:
Removing instruction __b17:
Removing instruction __b18:
Removing instruction __b19:
Removing instruction __b20:
Removing instruction __b21:
Removing instruction __b22:
Removing instruction __b23:
Removing instruction __b24:
Removing instruction __b25:
Removing instruction __b26:
Removing instruction __b27:
Removing instruction __b28:
Removing instruction __b29:
Removing instruction __b30:
Removing instruction __b31:
Removing instruction __b32:
Removing instruction __b33:
Removing instruction __b34:
Removing instruction __breturn:
Removing instruction __b3:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(const nomodify byte*) COLS = (byte*)(word) $d800
(const nomodify byte) GREEN = (byte) 5
(const nomodify byte) RED = (byte) 2
(const nomodify byte*) SCREEN = (byte*)(word) $400
(const byte) TYPEID_BYTE = (number) 1
(const byte) TYPEID_DWORD = (number) 5
(const byte) TYPEID_SIGNED_BYTE = (number) 2
(const byte) TYPEID_SIGNED_DWORD = (number) 6
(const byte) TYPEID_SIGNED_WORD = (number) 4
(const byte) TYPEID_WORD = (number) 3
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(label) assertType::@1
(label) assertType::@2
(label) assertType::@3
(label) assertType::@return
(byte) assertType::t1
(byte) assertType::t1#35 reg byte y 5.5
(byte) assertType::t2
(byte) assertType::t2#35 t2 zp[1]:2 11.0
(byte) idx
(byte) idx#39 reg byte x 1.1363636363636358
(byte) idx#80 reg byte x 21.600000000000005
(void()) main()
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@22
(label) main::@23
(label) main::@24
(label) main::@25
(label) main::@26
(label) main::@27
(label) main::@28
(label) main::@29
(label) main::@3
(label) main::@30
(label) main::@31
(label) main::@32
(label) main::@33
(label) main::@34
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return

reg byte y [ assertType::t1#35 ]
zp[1]:2 [ assertType::t2#35 ]
reg byte x [ idx#80 idx#39 ]


FINAL ASSEMBLER
Score: 506

  // File Comments
// Tests conversion of numbers to correct int types
// See https://gitlab.com/camelot/kickc/issues/181
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_SIGNED_DWORD = 6
  .const TYPEID_BYTE = 1
  .const TYPEID_WORD = 3
  .const TYPEID_DWORD = 5
  .const RED = 2
  .const GREEN = 5
  .label SCREEN = $400
  .label COLS = $d800
  // main
main: {
    // assertType(typeid(12sb+12), typeid(signed byte))
    // [1] call assertType 
    // [71] phi from main to assertType [phi:main->assertType]
    // [71] phi (byte) idx#80 = (byte) 0 [phi:main->assertType#0] -- vbuxx=vbuc1 
    ldx #0
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_BYTE [phi:main->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // assertType(typeid(12sb+130), typeid(signed word))
    // [3] call assertType 
    // [71] phi from main::@1 to assertType [phi:main::@1->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@1->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@1->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // assertType(typeid(12sb+33000), typeid(signed dword))
    // [5] call assertType 
    // [71] phi from main::@2 to assertType [phi:main::@2->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@2->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@2->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // main::@3
    // assertType(typeid(12sw+12), typeid(signed word))
    // [7] call assertType 
    // [71] phi from main::@3 to assertType [phi:main::@3->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@3->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@3->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [8] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
    // main::@4
    // assertType(typeid(12sw+130), typeid(signed word))
    // [9] call assertType 
    // [71] phi from main::@4 to assertType [phi:main::@4->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@4->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_WORD [phi:main::@4->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
    // main::@5
    // assertType(typeid(12sw+100000), typeid(signed dword))
    // [11] call assertType 
    // [71] phi from main::@5 to assertType [phi:main::@5->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@5->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@5->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [12] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // main::@6
    // assertType(typeid(12sd+12), typeid(signed dword))
    // [13] call assertType 
    // [71] phi from main::@6 to assertType [phi:main::@6->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@6->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@6->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [14] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
    // main::@7
    // assertType(typeid(12sd+130), typeid(signed dword))
    // [15] call assertType 
    // [71] phi from main::@7 to assertType [phi:main::@7->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@7->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@7->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [16] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
    // main::@8
    // assertType(typeid(12sd+100000), typeid(signed dword))
    // [17] call assertType 
    // [71] phi from main::@8 to assertType [phi:main::@8->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@8->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@8->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [18] phi from main::@8 to main::@9 [phi:main::@8->main::@9]
    // main::@9
    // assertType(typeid(12ub+12), typeid(unsigned byte))
    // [19] call assertType 
    // [71] phi from main::@9 to assertType [phi:main::@9->assertType]
    // [71] phi (byte) idx#80 = (byte) $28 [phi:main::@9->assertType#0] -- vbuxx=vbuc1 
    ldx #$28
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@9->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [20] phi from main::@9 to main::@10 [phi:main::@9->main::@10]
    // main::@10
    // assertType(typeid(12ub+250), typeid(unsigned byte))
    // [21] call assertType 
    // [71] phi from main::@10 to assertType [phi:main::@10->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@10->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@10->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [22] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
    // main::@11
    // assertType(typeid(12ub+300), typeid(unsigned word))
    // [23] call assertType 
    // [71] phi from main::@11 to assertType [phi:main::@11->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@11->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@11->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [24] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
    // main::@12
    // assertType(typeid(12ub+65534), typeid(unsigned word))
    // [25] call assertType 
    // [71] phi from main::@12 to assertType [phi:main::@12->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@12->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@12->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [26] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
    // main::@13
    // assertType(typeid(12ub+66000), typeid(unsigned dword))
    // [27] call assertType 
    // [71] phi from main::@13 to assertType [phi:main::@13->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@13->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@13->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [28] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
    // main::@14
    // assertType(typeid(12uw+12), typeid(unsigned word))
    // [29] call assertType 
    // [71] phi from main::@14 to assertType [phi:main::@14->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@14->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@14->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [30] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
    // main::@15
    // assertType(typeid(12uw+130), typeid(unsigned word))
    // [31] call assertType 
    // [71] phi from main::@15 to assertType [phi:main::@15->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@15->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@15->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [32] phi from main::@15 to main::@16 [phi:main::@15->main::@16]
    // main::@16
    // assertType(typeid(12uw+66000), typeid(unsigned dword))
    // [33] call assertType 
    // [71] phi from main::@16 to assertType [phi:main::@16->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@16->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@16->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [34] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
    // main::@17
    // assertType(typeid(12ud+12), typeid(unsigned dword))
    // [35] call assertType 
    // [71] phi from main::@17 to assertType [phi:main::@17->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@17->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@17->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [36] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
    // main::@18
    // assertType(typeid(12ud+130), typeid(unsigned dword))
    // [37] call assertType 
    // [71] phi from main::@18 to assertType [phi:main::@18->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@18->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@18->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [38] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
    // main::@19
    // assertType(typeid(12ud+66000), typeid(unsigned dword))
    // [39] call assertType 
    // [71] phi from main::@19 to assertType [phi:main::@19->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@19->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@19->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [40] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
    // main::@20
    // assertType(typeid(12ub+3000000000), typeid(unsigned dword))
    // [41] call assertType 
    // [71] phi from main::@20 to assertType [phi:main::@20->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@20->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@20->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [42] phi from main::@20 to main::@21 [phi:main::@20->main::@21]
    // main::@21
    // assertType(typeid(12ub+-12), typeid(unsigned byte))
    // [43] call assertType 
    // [71] phi from main::@21 to assertType [phi:main::@21->assertType]
    // [71] phi (byte) idx#80 = (byte) $50 [phi:main::@21->assertType#0] -- vbuxx=vbuc1 
    ldx #$50
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@21->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [44] phi from main::@21 to main::@22 [phi:main::@21->main::@22]
    // main::@22
    // assertType(typeid(12ub+-120), typeid(unsigned byte))
    // [45] call assertType 
    // [71] phi from main::@22 to assertType [phi:main::@22->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@22->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@22->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [46] phi from main::@22 to main::@23 [phi:main::@22->main::@23]
    // main::@23
    // assertType(typeid(12ub+-250), typeid(unsigned byte))
    // [47] call assertType 
    // [71] phi from main::@23 to assertType [phi:main::@23->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@23->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_BYTE [phi:main::@23->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [48] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
    // main::@24
    // assertType(typeid(12ub+-260), typeid(unsigned word))
    // [49] call assertType 
    // [71] phi from main::@24 to assertType [phi:main::@24->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@24->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@24->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [50] phi from main::@24 to main::@25 [phi:main::@24->main::@25]
    // main::@25
    // assertType(typeid(12ub+-65000), typeid(unsigned word))
    // [51] call assertType 
    // [71] phi from main::@25 to assertType [phi:main::@25->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@25->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@25->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [52] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
    // main::@26
    // assertType(typeid(12ub+-66000), typeid(unsigned dword))
    // [53] call assertType 
    // [71] phi from main::@26 to assertType [phi:main::@26->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@26->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@26->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [54] phi from main::@26 to main::@27 [phi:main::@26->main::@27]
    // main::@27
    // assertType(typeid(12uw+-12), typeid(unsigned word))
    // [55] call assertType 
    // [71] phi from main::@27 to assertType [phi:main::@27->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@27->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@27->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [56] phi from main::@27 to main::@28 [phi:main::@27->main::@28]
    // main::@28
    // assertType(typeid(12uw+-130), typeid(unsigned word))
    // [57] call assertType 
    // [71] phi from main::@28 to assertType [phi:main::@28->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@28->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@28->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [58] phi from main::@28 to main::@29 [phi:main::@28->main::@29]
    // main::@29
    // assertType(typeid(12uw+-65000), typeid(unsigned word))
    // [59] call assertType 
    // [71] phi from main::@29 to assertType [phi:main::@29->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@29->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_WORD [phi:main::@29->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [60] phi from main::@29 to main::@30 [phi:main::@29->main::@30]
    // main::@30
    // assertType(typeid(12uw+-66000), typeid(unsigned dword))
    // [61] call assertType 
    // [71] phi from main::@30 to assertType [phi:main::@30->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@30->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@30->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [62] phi from main::@30 to main::@31 [phi:main::@30->main::@31]
    // main::@31
    // assertType(typeid(12ud+-12), typeid(unsigned dword))
    // [63] call assertType 
    // [71] phi from main::@31 to assertType [phi:main::@31->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@31->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@31->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [64] phi from main::@31 to main::@32 [phi:main::@31->main::@32]
    // main::@32
    // assertType(typeid(12ud+-130), typeid(unsigned dword))
    // [65] call assertType 
    // [71] phi from main::@32 to assertType [phi:main::@32->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@32->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@32->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [66] phi from main::@32 to main::@33 [phi:main::@32->main::@33]
    // main::@33
    // assertType(typeid(12ud+-66000), typeid(unsigned dword))
    // [67] call assertType 
    // [71] phi from main::@33 to assertType [phi:main::@33->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@33->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_DWORD [phi:main::@33->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [68] phi from main::@33 to main::@34 [phi:main::@33->main::@34]
    // main::@34
    // assertType(typeid(12sb+-2100000000), typeid(unsigned dword))
    // [69] call assertType 
    // [71] phi from main::@34 to assertType [phi:main::@34->assertType]
    // [71] phi (byte) idx#80 = (byte) idx#39 [phi:main::@34->assertType#0] -- register_copy 
    // [71] phi (byte) assertType::t2#35 = (const byte) TYPEID_DWORD [phi:main::@34->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [71] phi (byte) assertType::t1#35 = (const byte) TYPEID_SIGNED_DWORD [phi:main::@34->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    // main::@return
    // }
    // [70] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(Y) t1, byte zp(2) t2)
assertType: {
    .label t2 = 2
    // if(t1==t2)
    // [72] if((byte) assertType::t1#35==(byte) assertType::t2#35) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp.z t2
    beq __b1
    // assertType::@3
    // COLS[idx] = RED
    // [73] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) RED -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta COLS,x
    // assertType::@2
  __b2:
    // SCREEN[idx++] = t1
    // [74] *((const nomodify byte*) SCREEN + (byte) idx#80) ← (byte) assertType::t1#35 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta SCREEN,x
    // SCREEN[idx++] = t1;
    // [75] (byte) idx#39 ← ++ (byte) idx#80 -- vbuxx=_inc_vbuxx 
    inx
    // assertType::@return
    // }
    // [76] return 
    rts
    // assertType::@1
  __b1:
    // COLS[idx] = GREEN
    // [77] *((const nomodify byte*) COLS + (byte) idx#80) ← (const nomodify byte) GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta COLS,x
    jmp __b2
}
  // File Data

