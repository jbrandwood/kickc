byte* SCREEN = $0400;

main();

void main() {
  byte i=100;
  do {
    nest();
  } while (--i>0)
}

void nest() {
  byte j=100;
  do {
    *SCREEN = j;
  } while (--j>0)
}

Adding pre/post-modifier (byte) main::i ← -- (byte) main::i
Adding pre/post-modifier (byte) nest::j ← -- (byte) nest::j
PROGRAM
  (byte*) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  proc (void()) main()
  (byte) main::i ← (byte) 100
main::@1:
  (void~) main::$0 ← call nest 
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$1 ← (byte) main::i > (byte) 0
  if((boolean~) main::$1) goto main::@1
main::@return:
  return 
  endproc // main()
  proc (void()) nest()
  (byte) nest::j ← (byte) 100
nest::@1:
  *((byte*) SCREEN) ← (byte) nest::j
  (byte) nest::j ← -- (byte) nest::j
  (boolean~) nest::$0 ← (byte) nest::j > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
nest::@return:
  return 
  endproc // nest()

SYMBOLS
(void~) $0
(byte*) SCREEN
(void()) main()
(void~) main::$0
(boolean~) main::$1
(label) main::@1
(label) main::@return
(byte) main::i
(void()) nest()
(boolean~) nest::$0
(label) nest::@1
(label) nest::@return
(byte) nest::j

INITIAL CONTROL FLOW GRAPH
@BEGIN: from
  (byte*) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@1
main: from
  (byte) main::i ← (byte) 100
  to:main::@1
main::@1: from main main::@1
  (void~) main::$0 ← call nest 
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$1 ← (byte) main::i > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@2
main::@2: from main::@1
  to:main::@return
main::@return: from main::@2
  return 
  to:@RETURN
@1: from @BEGIN
  to:@2
nest: from
  (byte) nest::j ← (byte) 100
  to:nest::@1
nest::@1: from nest nest::@1
  *((byte*) SCREEN) ← (byte) nest::j
  (byte) nest::j ← -- (byte) nest::j
  (boolean~) nest::$0 ← (byte) nest::j > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@2
nest::@2: from nest::@1
  to:nest::@return
nest::@return: from nest::@2
  return 
  to:@RETURN
@2: from @1
  to:@END
@END: from @2

Removing empty block main::@2
Removing empty block @1
Removing empty block nest::@2
Removing empty block @2
CONTROL FLOW GRAPH
@BEGIN: from
  (byte*) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@END
main: from
  (byte) main::i ← (byte) 100
  to:main::@1
main::@1: from main main::@1
  (void~) main::$0 ← call nest 
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$1 ← (byte) main::i > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@return
main::@return: from main::@1
  return 
  to:@RETURN
nest: from
  (byte) nest::j ← (byte) 100
  to:nest::@1
nest::@1: from nest nest::@1
  *((byte*) SCREEN) ← (byte) nest::j
  (byte) nest::j ← -- (byte) nest::j
  (boolean~) nest::$0 ← (byte) nest::j > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @BEGIN

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@BEGIN: from
  (byte*) SCREEN ← (word) 1024
  call main param-assignment
  to:@3
@3: from @BEGIN
  to:@END
main: from @BEGIN
  (byte) main::i ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$1 ← (byte) main::i > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  (byte) nest::j ← (byte) 100
  to:nest::@1
nest::@1: from nest nest::@1
  *((byte*) SCREEN) ← (byte) nest::j
  (byte) nest::j ← -- (byte) nest::j
  (boolean~) nest::$0 ← (byte) nest::j > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @3

Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@BEGIN: from
  (byte*) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: from @BEGIN
  to:@END
main: from @BEGIN
  (byte*) SCREEN#4 ← phi( @BEGIN/(byte*) SCREEN#0 )
  (byte) main::i#0 ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#3 ← phi( main/(byte*) SCREEN#4 main::@3/(byte*) SCREEN#5 )
  (byte) main::i#3 ← phi( main/(byte) main::i#0 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte*) SCREEN#5 ← phi( main::@1/(byte*) SCREEN#3 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#3 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$1 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  (byte*) SCREEN#2 ← phi( main::@1/(byte*) SCREEN#3 )
  (byte) nest::j#0 ← (byte) 100
  to:nest::@1
nest::@1: from nest nest::@1
  (byte*) SCREEN#1 ← phi( nest/(byte*) SCREEN#2 nest::@1/(byte*) SCREEN#1 )
  (byte) nest::j#2 ← phi( nest/(byte) nest::j#0 nest::@1/(byte) nest::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  (boolean~) nest::$0 ← (byte) nest::j#1 > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@BEGIN: from
  (byte*) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: from @BEGIN
  to:@END
main: from @BEGIN
  (byte*) SCREEN#4 ← phi( @BEGIN/(byte*) SCREEN#0 )
  (byte) main::i#0 ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#3 ← phi( main/(byte*) SCREEN#4 main::@3/(byte*) SCREEN#5 )
  (byte) main::i#3 ← phi( main/(byte) main::i#0 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte*) SCREEN#5 ← phi( main::@1/(byte*) SCREEN#3 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#3 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$1 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  (byte*) SCREEN#2 ← phi( main::@1/(byte*) SCREEN#3 )
  (byte) nest::j#0 ← (byte) 100
  to:nest::@1
nest::@1: from nest nest::@1
  (byte*) SCREEN#1 ← phi( nest/(byte*) SCREEN#2 nest::@1/(byte*) SCREEN#1 )
  (byte) nest::j#2 ← phi( nest/(byte) nest::j#0 nest::@1/(byte) nest::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  (boolean~) nest::$0 ← (byte) nest::j#1 > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @3

Culled Empty Block (label) @3
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@BEGIN: from
  (byte*) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@END
main: from @BEGIN
  (byte*) SCREEN#4 ← phi( @BEGIN/(byte*) SCREEN#0 )
  (byte) main::i#0 ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#3 ← phi( main/(byte*) SCREEN#4 main::@3/(byte*) SCREEN#5 )
  (byte) main::i#3 ← phi( main/(byte) main::i#0 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte*) SCREEN#5 ← phi( main::@1/(byte*) SCREEN#3 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#3 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$1 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  (byte*) SCREEN#2 ← phi( main::@1/(byte*) SCREEN#3 )
  (byte) nest::j#0 ← (byte) 100
  to:nest::@1
nest::@1: from nest nest::@1
  (byte*) SCREEN#1 ← phi( nest/(byte*) SCREEN#2 nest::@1/(byte*) SCREEN#1 )
  (byte) nest::j#2 ← phi( nest/(byte) nest::j#0 nest::@1/(byte) nest::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  (boolean~) nest::$0 ← (byte) nest::j#1 > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @BEGIN

Constant (byte*) SCREEN#0 (word) 1024
Constant (byte) main::i#0 (byte) 100
Constant (byte) nest::j#0 (byte) 100
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  (byte*) SCREEN#4 ← phi( @BEGIN/(word) 1024 )
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#3 ← phi( main/(byte*) SCREEN#4 main::@3/(byte*) SCREEN#5 )
  (byte) main::i#3 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte*) SCREEN#5 ← phi( main::@1/(byte*) SCREEN#3 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#3 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$1 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  (byte*) SCREEN#2 ← phi( main::@1/(byte*) SCREEN#3 )
  to:nest::@1
nest::@1: from nest nest::@1
  (byte*) SCREEN#1 ← phi( nest/(byte*) SCREEN#2 nest::@1/(byte*) SCREEN#1 )
  (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@1/(byte) nest::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  (boolean~) nest::$0 ← (byte) nest::j#1 > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @BEGIN

Alias (byte) main::i#2 = (byte) main::i#3 
Alias (byte*) SCREEN#2 = (byte*) SCREEN#5 (byte*) SCREEN#3 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  (byte*) SCREEN#4 ← phi( @BEGIN/(word) 1024 )
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#2 ← phi( main/(byte*) SCREEN#4 main::@3/(byte*) SCREEN#2 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$1 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  to:nest::@1
nest::@1: from nest nest::@1
  (byte*) SCREEN#1 ← phi( nest/(byte*) SCREEN#2 nest::@1/(byte*) SCREEN#1 )
  (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@1/(byte) nest::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  (boolean~) nest::$0 ← (byte) nest::j#1 > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @BEGIN

Redundant Phi (byte*) SCREEN#4 (word) 1024
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#2 ← phi( main/(word) 1024 main::@3/(byte*) SCREEN#2 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$1 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  to:nest::@1
nest::@1: from nest nest::@1
  (byte*) SCREEN#1 ← phi( nest/(byte*) SCREEN#2 nest::@1/(byte*) SCREEN#1 )
  (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@1/(byte) nest::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  (boolean~) nest::$0 ← (byte) nest::j#1 > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @BEGIN

Self Phi Eliminated (byte*) SCREEN#2
Self Phi Eliminated (byte*) SCREEN#1
Succesful SSA optimization Pass2SelfPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#2 ← phi( main/(word) 1024 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$1 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$1) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  to:nest::@1
nest::@1: from nest nest::@1
  (byte*) SCREEN#1 ← phi( nest/(byte*) SCREEN#2 )
  (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@1/(byte) nest::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  (boolean~) nest::$0 ← (byte) nest::j#1 > (byte) 0
  if((boolean~) nest::$0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @BEGIN

Simple Condition (boolean~) main::$1 if((byte) main::i#1>(byte) 0) goto main::@1
Simple Condition (boolean~) nest::$0 if((byte) nest::j#1>(byte) 0) goto nest::@1
Succesful SSA optimization Pass2ConditionalJumpSimplification
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#2 ← phi( main/(word) 1024 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  to:nest::@1
nest::@1: from nest nest::@1
  (byte*) SCREEN#1 ← phi( nest/(byte*) SCREEN#2 )
  (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@1/(byte) nest::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  if((byte) nest::j#1>(byte) 0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @BEGIN

Constant (byte*) SCREEN#2 (word) 1024
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  to:nest::@1
nest::@1: from nest nest::@1
  (byte*) SCREEN#1 ← phi( nest/(word) 1024 )
  (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@1/(byte) nest::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  if((byte) nest::j#1>(byte) 0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @BEGIN

Redundant Phi (byte*) SCREEN#1 (word) 1024
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest: from main::@1
  to:nest::@1
nest::@1: from nest nest::@1
  (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@1/(byte) nest::j#1 )
  *((word) 1024) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  if((byte) nest::j#1>(byte) 0) goto nest::@1
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
@END: from @BEGIN

Block Sequence Planned @BEGIN @END main main::@1 main::@3 main::@return nest nest::@1 nest::@return 
Added new block during phi lifting main::@4(between main::@3 and main::@1)
Added new block during phi lifting nest::@3(between nest::@1 and nest::@1)
Block Sequence Planned @BEGIN @END main main::@1 main::@3 main::@return main::@4 nest nest::@1 nest::@return nest::@3 
CONTROL FLOW GRAPH - PHI LIFTED
@BEGIN: from
  call main param-assignment
  to:@END
@END: from @BEGIN
main: from @BEGIN
  to:main::@1
main::@1: from main main::@4
  (byte) main::i#2 ← phi( main/(byte) 100 main::@4/(byte~) main::i#4 )
  call nest param-assignment
  to:main::@3
main::@3: from main::@1
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@4
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
main::@4: from main::@3
  (byte~) main::i#4 ← (byte) main::i#1
  to:main::@1
nest: from main::@1
  to:nest::@1
nest::@1: from nest nest::@3
  (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@3/(byte~) nest::j#3 )
  *((word) 1024) ← (byte) nest::j#2
  (byte) nest::j#1 ← -- (byte) nest::j#2
  if((byte) nest::j#1>(byte) 0) goto nest::@3
  to:nest::@return
nest::@return: from nest::@1
  return 
  to:@RETURN
nest::@3: from nest::@1
  (byte~) nest::j#3 ← (byte) nest::j#1
  to:nest::@1

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@BEGIN: from
  [0] call main param-assignment [ ]
  to:@END
@END: from @BEGIN
main: from @BEGIN
  to:main::@1
main::@1: from main main::@4
  [1] (byte) main::i#2 ← phi( main/(byte) 100 main::@4/(byte~) main::i#4 ) [ main::i#2 ]
  [2] call nest param-assignment [ main::i#2 ]
  to:main::@3
main::@3: from main::@1
  [3] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ]
  [4] if((byte) main::i#1>(byte) 0) goto main::@4 [ main::i#1 ]
  to:main::@return
main::@return: from main::@3
  [5] return  [ ]
  to:@RETURN
main::@4: from main::@3
  [6] (byte~) main::i#4 ← (byte) main::i#1 [ main::i#4 ]
  to:main::@1
nest: from main::@1
  to:nest::@1
nest::@1: from nest nest::@3
  [7] (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@3/(byte~) nest::j#3 ) [ main::i#2 nest::j#2 ]
  [8] *((word) 1024) ← (byte) nest::j#2 [ main::i#2 nest::j#2 ]
  [9] (byte) nest::j#1 ← -- (byte) nest::j#2 [ main::i#2 nest::j#1 ]
  [10] if((byte) nest::j#1>(byte) 0) goto nest::@3 [ main::i#2 nest::j#1 ]
  to:nest::@return
nest::@return: from nest::@1
  [11] return  [ main::i#2 ]
  to:@RETURN
nest::@3: from nest::@1
  [12] (byte~) nest::j#3 ← (byte) nest::j#1 [ main::i#2 nest::j#3 ]
  to:nest::@1

Created 2 initial phi equivalence classes
Coalesced [6] main::i#4 ← main::i#1
Coalesced [12] nest::j#3 ← nest::j#1
Coalesced down to 2 phi equivalence classes
Culled Empty Block (label) main::@4
Culled Empty Block (label) nest::@3
Block Sequence Planned @BEGIN @END main main::@1 main::@3 main::@return nest nest::@1 nest::@return 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@BEGIN: from
  [0] call main param-assignment [ ]
  to:@END
@END: from @BEGIN
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  [1] (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 ) [ main::i#2 ]
  [2] call nest param-assignment [ main::i#2 ]
  to:main::@3
main::@3: from main::@1
  [3] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ]
  [4] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ]
  to:main::@return
main::@return: from main::@3
  [5] return  [ ]
  to:@RETURN
nest: from main::@1
  to:nest::@1
nest::@1: from nest nest::@1
  [6] (byte) nest::j#2 ← phi( nest/(byte) 100 nest::@1/(byte) nest::j#1 ) [ main::i#2 nest::j#2 ]
  [7] *((word) 1024) ← (byte) nest::j#2 [ main::i#2 nest::j#2 ]
  [8] (byte) nest::j#1 ← -- (byte) nest::j#2 [ main::i#2 nest::j#1 ]
  [9] if((byte) nest::j#1>(byte) 0) goto nest::@1 [ main::i#2 nest::j#1 ]
  to:nest::@return
nest::@return: from nest::@1
  [10] return  [ main::i#2 ]
  to:@RETURN

CALL GRAPH
Calls in [] to 0:main 
Calls in [main] to 2:nest 

DOMINATORS
@BEGIN dominated by  @BEGIN 
@END dominated by  @BEGIN @END 
main dominated by  @BEGIN main 
main::@1 dominated by  @BEGIN main::@1 main 
main::@3 dominated by  @BEGIN main::@1 main::@3 main 
main::@return dominated by  @BEGIN main::@return main::@1 main::@3 main 
nest dominated by  @BEGIN nest main::@1 main 
nest::@1 dominated by  @BEGIN nest main::@1 nest::@1 main 
nest::@return dominated by  @BEGIN nest::@return nest main::@1 nest::@1 main 

Found back edge: Loop head: main::@1 tails: main::@3 blocks: null
Found back edge: Loop head: nest::@1 tails: nest::@1 blocks: null
Populated: Loop head: main::@1 tails: main::@3 blocks: main::@3 main::@1 
Populated: Loop head: nest::@1 tails: nest::@1 blocks: nest::@1 
NATURAL LOOPS
Loop head: main::@1 tails: main::@3 blocks: main::@3 main::@1 
Loop head: nest::@1 tails: nest::@1 blocks: nest::@1 

Found 0 loops in scope []
Found 1 loops in scope [main]
  Loop head: main::@1 tails: main::@3 blocks: main::@3 main::@1 
Found 1 loops in scope [nest]
  Loop head: nest::@1 tails: nest::@1 blocks: nest::@1 
NATURAL LOOPS WITH DEPTH
Loop head: main::@1 tails: main::@3 blocks: main::@3 main::@1  depth: 1
Loop head: nest::@1 tails: nest::@1 blocks: nest::@1  depth: 2

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ nest::j#2 nest::j#1 ]
Copy Coalesced equivalence classes
[ main::i#2 main::i#1 ]
[ nest::j#2 nest::j#1 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ nest::j#2 nest::j#1 ]
Allocated zp byte:2 to zp byte:2 [ main::i#2 main::i#1 ]
Allocated zp byte:3 to zp byte:3 [ nest::j#2 nest::j#1 ]

VARIABLE REGISTER WEIGHTS
(byte*) SCREEN
(void()) main()
(byte) main::i
(byte) main::i#1 16.5
(byte) main::i#2 3.142857142857143
(void()) nest()
(byte) nest::j
(byte) nest::j#1 151.5
(byte) nest::j#2 151.5

zp byte:2 [ main::i#2 main::i#1 ]
zp byte:3 [ nest::j#2 nest::j#1 ]

Re-allocated ZP register from zp byte:2 to zp byte:2
Re-allocated ZP register from zp byte:3 to zp byte:3
INITIAL ASM
BBEGIN:
  jsr main
  jmp BEND
BEND:
main:
main__B1_from_main:
  // (byte) main::i#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 2
  jmp main__B1
main__B1_from_B3:
  // (byte) main::i#2 = (byte) main::i#1  // register copy zp byte:2
  jmp main__B1
main__B1:
  jsr nest
  jmp main__B3
main__B3:
  // [3] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ]  //  zpby1=_dec_zpby1
  dec 2
  // [4] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ]  //  zpby1_gt_0_then_la1
  lda 2
  bne main__B1_from_B3
  jmp main__Breturn
main__Breturn:
  rts
nest:
nest__B1_from_nest:
  // (byte) nest::j#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 3
  jmp nest__B1
nest__B1_from_B1:
  // (byte) nest::j#2 = (byte) nest::j#1  // register copy zp byte:3
  jmp nest__B1
nest__B1:
  // [7] *((word) 1024) ← (byte) nest::j#2 [ main::i#2 nest::j#2 ]  //  coptr1=zpby1
  lda 3
  sta 1024
  // [8] (byte) nest::j#1 ← -- (byte) nest::j#2 [ main::i#2 nest::j#1 ]  //  zpby1=_dec_zpby1
  dec 3
  // [9] if((byte) nest::j#1>(byte) 0) goto nest::@1 [ main::i#2 nest::j#1 ]  //  zpby1_gt_0_then_la1
  lda 3
  bne nest__B1_from_B1
  jmp nest__Breturn
nest__Breturn:
  rts

Removing instruction jmp BEND
Removing instruction jmp main__B1
Removing instruction jmp main__B3
Removing instruction jmp main__Breturn
Removing instruction jmp nest__B1
Removing instruction jmp nest__Breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
BBEGIN:
  jsr main
BEND:
main:
main__B1_from_main:
  // (byte) main::i#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 2
  jmp main__B1
main__B1_from_B3:
  // (byte) main::i#2 = (byte) main::i#1  // register copy zp byte:2
main__B1:
  jsr nest
main__B3:
  // [3] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ]  //  zpby1=_dec_zpby1
  dec 2
  // [4] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ]  //  zpby1_gt_0_then_la1
  lda 2
  bne main__B1_from_B3
main__Breturn:
  rts
nest:
nest__B1_from_nest:
  // (byte) nest::j#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 3
  jmp nest__B1
nest__B1_from_B1:
  // (byte) nest::j#2 = (byte) nest::j#1  // register copy zp byte:3
nest__B1:
  // [7] *((word) 1024) ← (byte) nest::j#2 [ main::i#2 nest::j#2 ]  //  coptr1=zpby1
  lda 3
  sta 1024
  // [8] (byte) nest::j#1 ← -- (byte) nest::j#2 [ main::i#2 nest::j#1 ]  //  zpby1=_dec_zpby1
  dec 3
  // [9] if((byte) nest::j#1>(byte) 0) goto nest::@1 [ main::i#2 nest::j#1 ]  //  zpby1_gt_0_then_la1
  lda 3
  bne nest__B1_from_B1
nest__Breturn:
  rts

Removing instruction jmp main__B1
Removing instruction jmp nest__B1
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
BBEGIN:
  jsr main
BEND:
main:
main__B1_from_main:
  // (byte) main::i#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 2
main__B1_from_B3:
  // (byte) main::i#2 = (byte) main::i#1  // register copy zp byte:2
main__B1:
  jsr nest
main__B3:
  // [3] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ]  //  zpby1=_dec_zpby1
  dec 2
  // [4] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ]  //  zpby1_gt_0_then_la1
  lda 2
  bne main__B1_from_B3
main__Breturn:
  rts
nest:
nest__B1_from_nest:
  // (byte) nest::j#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 3
nest__B1_from_B1:
  // (byte) nest::j#2 = (byte) nest::j#1  // register copy zp byte:3
nest__B1:
  // [7] *((word) 1024) ← (byte) nest::j#2 [ main::i#2 nest::j#2 ]  //  coptr1=zpby1
  lda 3
  sta 1024
  // [8] (byte) nest::j#1 ← -- (byte) nest::j#2 [ main::i#2 nest::j#1 ]  //  zpby1=_dec_zpby1
  dec 3
  // [9] if((byte) nest::j#1>(byte) 0) goto nest::@1 [ main::i#2 nest::j#1 ]  //  zpby1_gt_0_then_la1
  lda 3
  bne nest__B1_from_B1
nest__Breturn:
  rts

FINAL SYMBOL TABLE
(label) @BEGIN
(label) @END
(byte*) SCREEN
(void()) main()
(label) main::@1
(label) main::@3
(label) main::@return
(byte) main::i
(byte) main::i#1 zp byte:2 16.5
(byte) main::i#2 zp byte:2 3.142857142857143
(void()) nest()
(label) nest::@1
(label) nest::@return
(byte) nest::j
(byte) nest::j#1 zp byte:3 151.5
(byte) nest::j#2 zp byte:3 151.5

zp byte:2 [ main::i#2 main::i#1 ]
zp byte:3 [ nest::j#2 nest::j#1 ]

FINAL CODE
BBEGIN:
  jsr main
BEND:
main:
main__B1_from_main:
  // (byte) main::i#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 2
main__B1_from_B3:
  // (byte) main::i#2 = (byte) main::i#1  // register copy zp byte:2
main__B1:
  jsr nest
main__B3:
  // [3] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ]  //  zpby1=_dec_zpby1
  dec 2
  // [4] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ]  //  zpby1_gt_0_then_la1
  lda 2
  bne main__B1_from_B3
main__Breturn:
  rts
nest:
nest__B1_from_nest:
  // (byte) nest::j#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 3
nest__B1_from_B1:
  // (byte) nest::j#2 = (byte) nest::j#1  // register copy zp byte:3
nest__B1:
  // [7] *((word) 1024) ← (byte) nest::j#2 [ main::i#2 nest::j#2 ]  //  coptr1=zpby1
  lda 3
  sta 1024
  // [8] (byte) nest::j#1 ← -- (byte) nest::j#2 [ main::i#2 nest::j#1 ]  //  zpby1=_dec_zpby1
  dec 3
  // [9] if((byte) nest::j#1>(byte) 0) goto nest::@1 [ main::i#2 nest::j#1 ]  //  zpby1_gt_0_then_la1
  lda 3
  bne nest__B1_from_B1
nest__Breturn:
  rts

