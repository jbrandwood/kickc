Resolved forward reference DMA_SCREEN_UP to DMA_SCREEN_UP
Resolved forward reference DMA_SCREEN_UP to DMA_SCREEN_UP
Fixing struct type size struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = >&DMA_SCREEN_UP
Setting struct to load/store in variable affected by address-of *DMA.ADDRLSBTRIG = <&DMA_SCREEN_UP
Inlined call vicSelectGfxBank::$0 = call toDd00 vicSelectGfxBank::gfx 

CONTROL FLOW GRAPH SSA

void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main
  memoryRemap::upperPageOffset#1 = phi( main/memoryRemap::upperPageOffset#0 )
  memoryRemap::remapBlocks#1 = phi( main/memoryRemap::remapBlocks#0 )
  memoryRemap::lowerPageOffset#1 = phi( main/memoryRemap::lowerPageOffset#0 )
  memoryRemap::$0 = < memoryRemap::lowerPageOffset#1
  *memoryRemap::aVal = memoryRemap::$0
  memoryRemap::$1 = memoryRemap::remapBlocks#1 << 4
  memoryRemap::$2 = > memoryRemap::lowerPageOffset#1
  memoryRemap::$3 = memoryRemap::$2 & $f
  memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
  *memoryRemap::xVal = memoryRemap::$4
  memoryRemap::$5 = < memoryRemap::upperPageOffset#1
  *memoryRemap::yVal = memoryRemap::$5
  memoryRemap::$6 = memoryRemap::remapBlocks#1 & $f0
  memoryRemap::$7 = > memoryRemap::upperPageOffset#1
  memoryRemap::$8 = memoryRemap::$7 & $f
  memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
  *memoryRemap::zVal = memoryRemap::$9
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  return 
  to:@return

void main()
main: scope:[main]  from __start
  memoryRemap::remapBlocks#0 = 0
  memoryRemap::lowerPageOffset#0 = 0
  memoryRemap::upperPageOffset#0 = 0
  call memoryRemap 
  to:main::@1
main::@1: scope:[main]  from main
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&DMA_SCREEN_UP
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) = <&DMA_SCREEN_UP
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 0
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
const nomodify byte* DEFAULT_SCREEN = (byte*)$800
const nomodify struct F018_DMAGIC* DMA = (struct F018_DMAGIC*)$d700
const nomodify byte DMA_COMMAND_COPY = 0
struct DMA_LIST_F018B DMA_SCREEN_UP loadstore = { command: DMA_COMMAND_COPY, count: (word)$18*$50, src: DEFAULT_SCREEN+$50, src_bank: 0, dest: DEFAULT_SCREEN, dest_bank: 0, sub_command: 0, modulo: 0 }
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG = 0
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
const byte OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
void __start()
void main()
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
byte~ memoryRemap::$0
byte~ memoryRemap::$1
byte~ memoryRemap::$2
number~ memoryRemap::$3
number~ memoryRemap::$4
byte~ memoryRemap::$5
number~ memoryRemap::$6
byte~ memoryRemap::$7
number~ memoryRemap::$8
number~ memoryRemap::$9
const byte* memoryRemap::aVal = (byte*)$fc
word memoryRemap::lowerPageOffset
word memoryRemap::lowerPageOffset#0
word memoryRemap::lowerPageOffset#1
byte memoryRemap::remapBlocks
byte memoryRemap::remapBlocks#0
byte memoryRemap::remapBlocks#1
word memoryRemap::upperPageOffset
word memoryRemap::upperPageOffset#0
word memoryRemap::upperPageOffset#1
const byte* memoryRemap::xVal = (byte*)$fd
const byte* memoryRemap::yVal = (byte*)$fe
const byte* memoryRemap::zVal = (byte*)$ff

Adding number conversion cast (unumber) $50 in 
Adding number conversion cast (unumber) 4 in memoryRemap::$1 = memoryRemap::remapBlocks#1 << 4
Adding number conversion cast (unumber) $f in memoryRemap::$3 = memoryRemap::$2 & $f
Adding number conversion cast (unumber) memoryRemap::$3 in memoryRemap::$3 = memoryRemap::$2 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap::$4 in memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Adding number conversion cast (unumber) $f0 in memoryRemap::$6 = memoryRemap::remapBlocks#1 & $f0
Adding number conversion cast (unumber) memoryRemap::$6 in memoryRemap::$6 = memoryRemap::remapBlocks#1 & (unumber)$f0
Adding number conversion cast (unumber) $f in memoryRemap::$8 = memoryRemap::$7 & $f
Adding number conversion cast (unumber) memoryRemap::$8 in memoryRemap::$8 = memoryRemap::$7 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap::$9 in memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Adding number conversion cast (unumber) 0 in memoryRemap::remapBlocks#0 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::lowerPageOffset#0 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::upperPageOffset#0 = 0
Adding number conversion cast (unumber) 1 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
Adding number conversion cast (unumber) 0 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
Adding number conversion cast (unumber) 0 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
Adding number conversion cast (unumber) 0 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast memoryRemap::remapBlocks#0 = (unumber)0
Inlining cast memoryRemap::lowerPageOffset#0 = (unumber)0
Inlining cast memoryRemap::upperPageOffset#0 = (unumber)0
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = (unumber)1
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = (unumber)0
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = (unumber)0
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 252
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant pointer cast (struct F018_DMAGIC*) 55040
Simplifying constant pointer cast (byte*) 2048
Simplifying constant integer cast $50
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $50
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $f0
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in memoryRemap::$3 = memoryRemap::$2 & $f
Inferred type updated to byte in memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Inferred type updated to byte in memoryRemap::$6 = memoryRemap::remapBlocks#1 & $f0
Inferred type updated to byte in memoryRemap::$8 = memoryRemap::$7 & $f
Inferred type updated to byte in memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Identical Phi Values memoryRemap::lowerPageOffset#1 memoryRemap::lowerPageOffset#0
Identical Phi Values memoryRemap::remapBlocks#1 memoryRemap::remapBlocks#0
Identical Phi Values memoryRemap::upperPageOffset#1 memoryRemap::upperPageOffset#0
Successful SSA optimization Pass2IdenticalPhiElimination
Constant memoryRemap::remapBlocks#0 = 0
Constant memoryRemap::lowerPageOffset#0 = 0
Constant memoryRemap::upperPageOffset#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero (byte*)DMA in [25] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) = <&DMA_SCREEN_UP
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Constant right-side identified [0] memoryRemap::$0 = < memoryRemap::lowerPageOffset#0
Constant right-side identified [2] memoryRemap::$1 = memoryRemap::remapBlocks#0 << 4
Constant right-side identified [3] memoryRemap::$2 = > memoryRemap::lowerPageOffset#0
Constant right-side identified [7] memoryRemap::$5 = < memoryRemap::upperPageOffset#0
Constant right-side identified [9] memoryRemap::$6 = memoryRemap::remapBlocks#0 & $f0
Constant right-side identified [10] memoryRemap::$7 = > memoryRemap::upperPageOffset#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap::$0 = <memoryRemap::lowerPageOffset#0
Constant memoryRemap::$1 = memoryRemap::remapBlocks#0<<4
Constant memoryRemap::$2 = >memoryRemap::lowerPageOffset#0
Constant memoryRemap::$5 = <memoryRemap::upperPageOffset#0
Constant memoryRemap::$6 = memoryRemap::remapBlocks#0&$f0
Constant memoryRemap::$7 = >memoryRemap::upperPageOffset#0
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero <memoryRemap::lowerPageOffset#0 in 
Simplifying constant evaluating to zero memoryRemap::remapBlocks#0<<4 in 
Simplifying constant evaluating to zero >memoryRemap::lowerPageOffset#0 in 
Simplifying constant evaluating to zero <memoryRemap::upperPageOffset#0 in 
Simplifying constant evaluating to zero memoryRemap::remapBlocks#0&$f0 in 
Simplifying constant evaluating to zero >memoryRemap::upperPageOffset#0 in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero memoryRemap::$3 in [5] memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Simplifying expression containing zero memoryRemap::$8 in [12] memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant memoryRemap::remapBlocks#0
Eliminating unused constant memoryRemap::lowerPageOffset#0
Eliminating unused constant memoryRemap::upperPageOffset#0
Eliminating unused constant memoryRemap::$1
Eliminating unused constant memoryRemap::$6
Successful SSA optimization PassNEliminateUnusedVars
Alias memoryRemap::$4 = memoryRemap::$3 
Alias memoryRemap::$9 = memoryRemap::$8 
Successful SSA optimization Pass2AliasElimination
Constant right-side identified [1] memoryRemap::$4 = memoryRemap::$2 & $f
Constant right-side identified [4] memoryRemap::$9 = memoryRemap::$7 & $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap::$4 = memoryRemap::$2&$f
Constant memoryRemap::$9 = memoryRemap::$7&$f
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero memoryRemap::$2&$f in 
Simplifying constant evaluating to zero memoryRemap::$7&$f in 
Successful SSA optimization PassNSimplifyConstantZero
Eliminating unused constant memoryRemap::$2
Eliminating unused constant memoryRemap::$7
Successful SSA optimization PassNEliminateUnusedVars
Constant inlined memoryRemap::$4 = 0
Constant inlined memoryRemap::$5 = 0
Constant inlined memoryRemap::$0 = 0
Constant inlined memoryRemap::$9 = 0
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) $50
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main
CALL GRAPH
Calls in [main] to memoryRemap:1 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call memoryRemap 
  to:main::@1
main::@1: scope:[main]  from main
  [2] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  [3] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  [4] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  [5] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&DMA_SCREEN_UP
  [6] *((byte*)DMA) = <&DMA_SCREEN_UP
  [7] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 0
  to:main::@return
main::@return: scope:[main]  from main::@1
  [8] return 
  to:@return

void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main
  [9] *memoryRemap::aVal = 0
  [10] *memoryRemap::xVal = 0
  [11] *memoryRemap::yVal = 0
  [12] *memoryRemap::zVal = 0
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  [14] return 
  to:@return


VARIABLE REGISTER WEIGHTS
struct DMA_LIST_F018B DMA_SCREEN_UP loadstore = { command: DMA_COMMAND_COPY, count: (word)$18*$50, src: DEFAULT_SCREEN+$50, src_bank: 0, dest: DEFAULT_SCREEN, dest_bank: 0, sub_command: 0, modulo: 0 }
void main()
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
word memoryRemap::lowerPageOffset
byte memoryRemap::remapBlocks
word memoryRemap::upperPageOffset

Initial phi equivalence classes
Added variable DMA_SCREEN_UP to live range equivalence class [ DMA_SCREEN_UP ]
Complete equivalence classes
[ DMA_SCREEN_UP ]
Allocated mem[12] [ DMA_SCREEN_UP ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ DMA_SCREEN_UP ] (  [ DMA_SCREEN_UP ] { }  ) always clobbers reg byte a 
Statement [3] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ DMA_SCREEN_UP ] (  [ DMA_SCREEN_UP ] { }  ) always clobbers reg byte a 
Statement [4] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ DMA_SCREEN_UP ] (  [ DMA_SCREEN_UP ] { }  ) always clobbers reg byte a 
Statement [5] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&DMA_SCREEN_UP [ DMA_SCREEN_UP ] (  [ DMA_SCREEN_UP ] { }  ) always clobbers reg byte a 
Statement [6] *((byte*)DMA) = <&DMA_SCREEN_UP [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [7] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] *memoryRemap::aVal = 0 [ ] ( memoryRemap:1 [ DMA_SCREEN_UP ] { }  ) always clobbers reg byte a 
Statement [10] *memoryRemap::xVal = 0 [ ] ( memoryRemap:1 [ DMA_SCREEN_UP ] { }  ) always clobbers reg byte a 
Statement [11] *memoryRemap::yVal = 0 [ ] ( memoryRemap:1 [ DMA_SCREEN_UP ] { }  ) always clobbers reg byte a 
Statement [12] *memoryRemap::zVal = 0 [ ] ( memoryRemap:1 [ DMA_SCREEN_UP ] { }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Potential registers mem[12] [ DMA_SCREEN_UP ] : mem[12] , 

REGISTER UPLIFT SCOPES
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [MOS4569_VICIII] 
Uplift Scope [MEGA65_VICIV] 
Uplift Scope [memoryRemap] 
Uplift Scope [F018_DMAGIC] 
Uplift Scope [DMA_LIST_F018A] 
Uplift Scope [DMA_LIST_F018B] 
Uplift Scope [main] 
Uplift Scope [] 0: mem[12] [ DMA_SCREEN_UP ] 

Uplifting [MOS6526_CIA] best 106 combination 
Uplifting [MOS6569_VICII] best 106 combination 
Uplifting [MOS6581_SID] best 106 combination 
Uplifting [MOS4569_VICIII] best 106 combination 
Uplifting [MEGA65_VICIV] best 106 combination 
Uplifting [memoryRemap] best 106 combination 
Uplifting [F018_DMAGIC] best 106 combination 
Uplifting [DMA_LIST_F018A] best 106 combination 
Uplifting [DMA_LIST_F018B] best 106 combination 
Uplifting [main] best 106 combination 
Uplifting [] best 106 combination mem[12] [ DMA_SCREEN_UP ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// MEGA65 DMA test using F018 directly
// Appendix J in https://mega.scryptos.com/sharefolder-link/MEGA/MEGA65+filehost/Docs/MEGA65-Book_draft.pdf
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="dma-test.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // DMA command copy
  .const DMA_COMMAND_COPY = 0
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  // DMAgic F018 Controller
  .label DMA = $d700
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
.segment Code
  // main
main: {
    // [1] call memoryRemap 
    // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    jsr memoryRemap
    jmp __b1
    // main::@1
  __b1:
    // [2] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Enable enable F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [3] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // [4] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // [5] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&DMA_SCREEN_UP -- _deref_pbuc1=vbuc2 
    lda #>DMA_SCREEN_UP
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // [6] *((byte*)DMA) = <&DMA_SCREEN_UP -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<DMA_SCREEN_UP
    sta DMA
    // [7] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 0 -- _deref_pbuc1=vbuc2 
    // Re-enable F018A mode
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    jmp __breturn
    // main::@return
  __breturn:
    // [8] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    // [9] *memoryRemap::aVal = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta aVal
    // [10] *memoryRemap::xVal = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta xVal
    // [11] *memoryRemap::yVal = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta yVal
    // [12] *memoryRemap::zVal = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [14] return 
    rts
}
  // File Data
.segment Data
  // DMA list entry that scrolls the default screen up
  DMA_SCREEN_UP: .byte DMA_COMMAND_COPY
  .word $18*$50, DEFAULT_SCREEN+$50
  .byte 0
  .word DEFAULT_SCREEN
  .byte 0, 0
  .word 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
const nomodify byte* DEFAULT_SCREEN = (byte*) 2048
const nomodify struct F018_DMAGIC* DMA = (struct F018_DMAGIC*) 55040
const nomodify byte DMA_COMMAND_COPY = 0
struct DMA_LIST_F018B DMA_SCREEN_UP loadstore mem[12] = { command: DMA_COMMAND_COPY, count: (word)$18*$50, src: DEFAULT_SCREEN+$50, src_bank: 0, dest: DEFAULT_SCREEN, dest_bank: 0, sub_command: 0, modulo: 0 }
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
const byte OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
void main()
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
const byte* memoryRemap::aVal = (byte*) 252
word memoryRemap::lowerPageOffset
byte memoryRemap::remapBlocks
word memoryRemap::upperPageOffset
const byte* memoryRemap::xVal = (byte*) 253
const byte* memoryRemap::yVal = (byte*) 254
const byte* memoryRemap::zVal = (byte*) 255

mem[12] [ DMA_SCREEN_UP ]


FINAL ASSEMBLER
Score: 89

  // File Comments
// MEGA65 DMA test using F018 directly
// Appendix J in https://mega.scryptos.com/sharefolder-link/MEGA/MEGA65+filehost/Docs/MEGA65-Book_draft.pdf
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="dma-test.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // DMA command copy
  .const DMA_COMMAND_COPY = 0
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  // DMAgic F018 Controller
  .label DMA = $d700
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
.segment Code
  // main
main: {
    // memoryRemap(0,0,0)
    // [1] call memoryRemap 
    // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    jsr memoryRemap
    // main::@1
    // DMA->EN018B = 1
    // [2] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Enable enable F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // DMA->ADDRMB = 0
    // [3] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // DMA->ADDRBANK = 0
    // [4] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // DMA-> ADDRMSB = >&DMA_SCREEN_UP
    // [5] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&DMA_SCREEN_UP -- _deref_pbuc1=vbuc2 
    lda #>DMA_SCREEN_UP
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // DMA-> ADDRLSBTRIG = <&DMA_SCREEN_UP
    // [6] *((byte*)DMA) = <&DMA_SCREEN_UP -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<DMA_SCREEN_UP
    sta DMA
    // DMA->EN018B = 0
    // [7] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 0 -- _deref_pbuc1=vbuc2 
    // Re-enable F018A mode
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // main::@return
    // }
    // [8] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    // *aVal = <lowerPageOffset
    // [9] *memoryRemap::aVal = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta aVal
    // *xVal = (remapBlocks << 4)   | (>lowerPageOffset & 0xf)
    // [10] *memoryRemap::xVal = 0 -- _deref_pbuc1=vbuc2 
    sta xVal
    // *yVal = <upperPageOffset
    // [11] *memoryRemap::yVal = 0 -- _deref_pbuc1=vbuc2 
    sta yVal
    // *zVal = (remapBlocks & 0xf0) | (>upperPageOffset & 0xf)
    // [12] *memoryRemap::zVal = 0 -- _deref_pbuc1=vbuc2 
    sta zVal
    // asm
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap::@return
    // }
    // [14] return 
    rts
}
  // File Data
.segment Data
  // DMA list entry that scrolls the default screen up
  DMA_SCREEN_UP: .byte DMA_COMMAND_COPY
  .word $18*$50, DEFAULT_SCREEN+$50
  .byte 0
  .word DEFAULT_SCREEN
  .byte 0, 0
  .word 0

