// 3D Rotation using a Rotation Matrix
// Based on: 
// - C= Hacking Magazine Issue 8. http://www.ffd2.com/fridge/chacking/c=hacking8.txt
// - Codebase64 Article http://codebase64.org/doku.php?id=base:3d_rotation  
import "c64"
import "print"

// The rotated point - updated by calling rotate_matrix()
signed byte* xr = $f0;
signed byte* yr = $f1;
signed byte* zr = $f2;

// The rotated point with perspective
signed byte* pp = $f3;
signed byte* xp = $f4;
signed byte* yp = $f5;

// Pointers used to multiply perspective (d/z0-z) onto x- & y-coordinates. Points into mulf_sqr1 / mulf_sqr2  
word* psp1 = $f6;
word* psp2 = $f8;

byte* SCREEN = $400;

void main() {
	asm { sei }
	sprites_init();
	//mulf_init();
	*psp1 = (word)mulf_sqr1;
	*psp2 = (word)mulf_sqr2;

	debug_print_init();

 	//calculate_matrix(1,1,1);

	anim();
}

// Positions to rotate
signed byte[8] xs = { -94,  94,  00,  00,  00,  00,  00,  63};
signed byte[8] ys = {  00,  00, -94,  94,  00,  00,  00,  00};
signed byte[8] zs = {  00,  00,  00,  00, -94,  94, -00,  00};
// Rotated positions
signed byte[8] xrs;
signed byte[8] yrs;
signed byte[8] zrs;
// Persepctive factors (from zrs)
signed byte[8] pps;
// Rotated positions with persepctive
signed byte[8] xps;
signed byte[8] yps;

signed byte sx = 0;
signed byte sy = 0;
signed byte sz = 0;

void anim() {
	//signed byte xmin = 0;
	//signed byte xmax = 0;
	while(true) {
		while(*RASTER!=$ff) {}
        (*BORDERCOL)++; 
    	calculate_matrix(sx,sy,sz);
    	store_matrix();
        for(byte i: 0..7) {
            (*BORDERCOL)++;
            rotate_matrix(xs[i], ys[i], zs[i]);
            //if(*xr<xmin) xmin = *xr;
            //if(*xr>xmax) xmax = *xr;
            xrs[i] = *xr;
            yrs[i] = *yr;
            zrs[i] = *zr;
            pps[i] = *pp;
            xps[i] = *xp;
            yps[i] = *yp;
            byte i2 = i<<1;
       	    SPRITES_XPOS[i2] = $80+(byte)((*xp));
       	    SPRITES_YPOS[i2] = $80+(byte)((*yp));
    	}
        *BORDERCOL = LIGHT_GREY;
        debug_print();
        *BORDERCOL = LIGHT_BLUE;
        // Increment angles        
    	sx -=1;
    	sy +=1;
    	sz -=1;
	}	
}

void debug_print_init() {
	print_cls();
	print_str_at("sx@", SCREEN+40*0+34);
	print_str_at("sy@", SCREEN+40*1+34);
	print_str_at("sz@", SCREEN+40*2+34);
	print_str_at("x@", SCREEN+40*16);
	print_str_at("y@", SCREEN+40*17);
	print_str_at("z@", SCREEN+40*18);
	print_str_at("xr@", SCREEN+40*19);
	print_str_at("yr@", SCREEN+40*20);
	print_str_at("zr@", SCREEN+40*21);
	print_str_at("pp@", SCREEN+40*22);
	print_str_at("xp@", SCREEN+40*23);
	print_str_at("yp@", SCREEN+40*24);

    byte* at_line = SCREEN+16*40;
 	byte c = 4;
 	byte* COLS = $d800;
 	byte* at_cols = COLS+16*40;
    for( byte i: 0..7) {
    	print_sbyte_at(xs[i], at_line+40*0+c);
    	print_sbyte_at(ys[i], at_line+40*1+c);
    	print_sbyte_at(zs[i], at_line+40*2+c);
    	for( byte j: 0..3) {
    		byte col = 8+i;
    		*(at_cols+40*0+c+j) = col;
    		*(at_cols+40*1+c+j) = col;
    		*(at_cols+40*2+c+j) = col;
    		*(at_cols+40*3+c+j) = col;
    		*(at_cols+40*4+c+j) = col;
    		*(at_cols+40*5+c+j) = col;
    		*(at_cols+40*6+c+j) = col;
    		*(at_cols+40*7+c+j) = col;
    		*(at_cols+40*8+c+j) = col;
    	}
    	c += 4;
    }


}

void debug_print() {
	// angles
    print_sbyte_at(sx, SCREEN+40*0+37);
    print_sbyte_at(sy, SCREEN+40*1+37);
    print_sbyte_at(sz, SCREEN+40*2+37);
    // rotation matrix
    print_sbyte_at(rotation_matrix[0], SCREEN+40*4+29);    	
    print_sbyte_at(rotation_matrix[1], SCREEN+40*4+33);    	
    print_sbyte_at(rotation_matrix[2], SCREEN+40*4+37);    	
    print_sbyte_at(rotation_matrix[3], SCREEN+40*5+29);    	
    print_sbyte_at(rotation_matrix[4], SCREEN+40*5+33);    	
    print_sbyte_at(rotation_matrix[5], SCREEN+40*5+37);    	
    print_sbyte_at(rotation_matrix[6], SCREEN+40*6+29);    	
    print_sbyte_at(rotation_matrix[7], SCREEN+40*6+33);    	
    print_sbyte_at(rotation_matrix[8], SCREEN+40*6+37);    	

    byte* at_line = SCREEN+19*40;
 	byte c = 4;
    for( byte i: 0..7) {
    	print_sbyte_at(xrs[i], at_line+40*0+c);
    	print_sbyte_at(yrs[i], at_line+40*1+c);
    	print_sbyte_at(zrs[i], at_line+40*2+c);
    	print_sbyte_at(pps[i], at_line+40*3+c);
    	print_sbyte_at(xps[i], at_line+40*4+c);
    	print_sbyte_at(yps[i], at_line+40*5+c);
    	c += 4;
    }
}

// Initialize sprites
void sprites_init() {
	byte* SCREEN = $400;
    *SPRITES_ENABLE = %11111111;
    byte* sprites_ptr = SCREEN+$3f8;
    for(byte i: 0..7) {
    	sprites_ptr[i] = (byte)(SPRITE/$40);
        SPRITES_COLS[i] = 8+i;
    }
}

// The rotation matrix
signed byte[9] rotation_matrix;

// Prepare the 3x3 rotation matrix into rotation_matrix[]
// Angles sx, sy, sz are based on 2*PI=$100 
// Method described in C= Hacking Magazine Issue 8. http://www.ffd2.com/fridge/chacking/c=hacking8.txt
void calculate_matrix(signed byte sx, signed byte sy, signed byte sz) {
	signed byte t1 = sy-sz;
	signed byte t2 = sy+sz;
	signed byte t3 = sx+sz;
	signed byte t4 = sx-sz;
	signed byte t5 = sx+t2; // = sx+sy+sz
	signed byte t6 = sx-t1; // = sx-sy+sz
	signed byte t7 = sx+t1; // = sx+sy-sz
	signed byte t8 = t2-sx; // = sy+sz-sx
	signed byte t9 = sy-sx;
	signed byte t10 = sy+sx;
	rotation_matrix[0] = COSH[t1]+COSH[t2];
	rotation_matrix[1] = SINH[t1]-SINH[t2];
	rotation_matrix[2] = SINH[sy]+SINH[sy];
	rotation_matrix[3] = SINH[t3]-SINH[t4] + COSQ[t6]-COSQ[t5]+COSQ[t8]-COSQ[t7];
	rotation_matrix[4] = COSH[t3]+COSH[t4] + SINQ[t5]-SINQ[t6]-SINQ[t7]-SINQ[t8];
	rotation_matrix[5] = SINH[t9]-SINH[t10];
	rotation_matrix[6] = COSH[t4]-COSH[t3] + SINQ[t6]-SINQ[t5]-SINQ[t8]-SINQ[t7];
	rotation_matrix[7] = SINH[t3]+SINH[t4] + COSQ[t6]-COSQ[t5]+COSQ[t7]-COSQ[t8];
	rotation_matrix[8] = COSH[t9]+COSH[t10];
}

// Store the rotation matrix into the rotation routine rotate()
// After this each call to rotate() will rotate a point with the matrix
// Implemented in assembler to utilize seriously fast multiplication 
void store_matrix() {
	asm {
		lda rotation_matrix+0
		sta rotate_matrix.A1+1
		eor #$ff
		sta rotate_matrix.A2+1
		lda rotation_matrix+1
		sta rotate_matrix.B1+1
		eor #$ff
		sta rotate_matrix.B2+1
		lda rotation_matrix+2
		sta rotate_matrix.C1+1
		eor #$ff
		sta rotate_matrix.C2+1
		lda rotation_matrix+3
		sta rotate_matrix.D1+1
		eor #$ff
		sta rotate_matrix.D2+1
		lda rotation_matrix+4
		sta rotate_matrix.E1+1
		eor #$ff
		sta rotate_matrix.E2+1
		lda rotation_matrix+5
		sta rotate_matrix.F1+1
		eor #$ff
		sta rotate_matrix.F2+1
		lda rotation_matrix+6
		sta rotate_matrix.G1+1
		eor #$ff
		sta rotate_matrix.G2+1
		lda rotation_matrix+7
		sta rotate_matrix.H1+1
		eor #$ff
		sta rotate_matrix.H2+1
		lda rotation_matrix+8
		sta rotate_matrix.I1+1
		eor #$ff
		sta rotate_matrix.I2+1
	}	
}

// Rotate a 3D point (x,y,z) using the rotation matrix
// The rotation matrix is prepared by calling prepare_matrix() 
// The passed points must be in the interval [-$3f;$3f].
// Implemented in assembler to utilize seriously fast multiplication 
void rotate_matrix(signed byte x, signed byte y, signed byte z) {
	*xr = x;
	*yr = y;
	*zr = z;
	asm {
			ldx zr //z
			// C*z 
		C1:	lda mulf_sqr1,x
			sec
		C2: sbc mulf_sqr2,x
			sta C3+1
			// F*z 
		F1:	lda mulf_sqr1,x
			sec
		F2: sbc mulf_sqr2,x
			sta F3+1
			// I*z 
		I1:	lda mulf_sqr1,x
			sec
		I2: sbc mulf_sqr2,x
			sta I3+1

			ldx xr //x
			ldy yr //y

		I3: lda #0 // I*z
			clc
		G1:	adc mulf_sqr1,x
			sec
		G2: sbc mulf_sqr2,x
			clc
		H1:	adc mulf_sqr1,y
			sec
		H2: sbc mulf_sqr2,y
			sta zr

			sta PP+1
		PP: lda PERSP_Z
			sta pp
			sta psp1
			eor #$ff
			sta psp2 			

		C3: lda #0 // C*z
			clc
		A1:	adc mulf_sqr1,x
			sec
		A2: sbc mulf_sqr2,x
			clc
		B1:	adc mulf_sqr1,y
			sec
		B2: sbc mulf_sqr2,y
			sta xr
			// divide x by 2 to get x below $3f for multiplication
			//cmp #$80
			//ror
			sta XX+1
			clc

		F3: lda #0 // F*z
			clc
		D1:	adc mulf_sqr1,x
			sec
		D2: sbc mulf_sqr2,x
			clc
		E1:	adc mulf_sqr1,y
			sec
		E2: sbc mulf_sqr2,y
			sta yr

			// Calculate perspective for Y-position
			// divide y by 2 to get x below $3f for multiplication
			//cmp #$80
			//ror
			tay
			lda (psp1),y
			sec
			sbc (psp2),y
			sta yp

			// Calculate perspective for X-position
		XX:	ldy #0
			lda (psp1),y
			sec
			sbc (psp2),y
			sta xp
	}
}

// mulf_sqr tables will contain f(x)=int(x*x) and g(x) = f(1-x).
// f(x) = >(( x * x ))
byte* mulf_sqr1 = $2400;
// g(x) =  >((( 1 - x ) * ( 1 - x )))
byte* mulf_sqr2 = $2600;

kickasm(pc mulf_sqr1) {{	
    .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }
}}

kickasm(pc mulf_sqr2) {{	
    .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }
}}

/*
// Multiplication tables for seriously fast multiplication. 
// This version is optimized for speed over accuracy
// - It can multiply signed numbers with no extra code - but only for numbers in [-$3f;$3f]  
// - It throws away the low part of the 32-bit result
// - It return >a*b*4 to maximize precision (when passed maximal input values $3f*$3f the result is $3e) 
// See the following for information about the method
// - http://codebase64.org/doku.php?id=base:seriously_fast_multiplication 
// - http://codebase64.org/doku.php?id=magazines:chacking16
// mulf_sqr tables will contain f(x)=int(x*x) and g(x) = f(1-x).
// f(x) = >(( x * x ))
byte[512] align($100) mulf_sqr1;
// g(x) =  >((( 1 - x ) * ( 1 - x )))
byte[512] align($100) mulf_sqr2;

// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x) and g(x) = f(1-x) 
void mulf_init() {
	signed word sqr = 0;	
	signed word add = 1;
	for( byte i:0..128) {
		byte val = >sqr;
		mulf_sqr1[i] = val;
		(mulf_sqr1+$100)[i] = val;
		mulf_sqr1[-i] = val;
		(mulf_sqr1+$100)[-i] = val;
		mulf_sqr2[i+1] = val;
		(mulf_sqr2+$100)[i+1] = val;
		mulf_sqr2[1-i] = val;
		(mulf_sqr2+$100)[1-i] = val;
		sqr += add;
		add +=2;
	}
}
*/

// A single sprite
byte* SPRITE = $3000;
kickasm(pc SPRITE, resource "balloon.png") {{
    .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
}}

// Perspective multiplication table containing (d/(z0-z)[z] for each z-value   
signed byte* PERSP_Z = $2800;

kickasm(pc PERSP_Z) {{
    {
    .var d = 256.0	
    .var z0 = 6.0	
    // These values of d/z0 result in table values from $20 to $40 (effectively max is $3f)
    .for(var z=0;z<$100;z++) {
    	.if(z>127) {
    		.byte round(d / (z0 - ((z - 256) / 64.0)));
    	} else {
    		.byte round(d / (z0 - (z / 64.0)));
    	}
    }
	}
}}

// Sine and Cosine Tables   
// Angles: $00=0, $80=PI,$100=2*PI
// Half Sine/Cosine: signed fixed [-$1f,$1f]
signed byte* SINH = $2000;
signed byte* COSH = SINH+$40; // sin(x) = cos(x+PI/2)
// Quarter Sine/Cosine: signed fixed [-$0f,$0f]
signed byte* SINQ = $2200;
signed byte* COSQ = SINQ+$40; // sin(x) = cos(x+PI/2)
kickasm(pc SINH) {{
    {
    .var min = -$2000
    .var max = $2000
    .var ampl = max-min;
    .for(var i=0;i<$140;i++) {
        .var rad = i*2*PI/256;
        .byte round((min+(ampl/2)+(ampl/2)*sin(rad))/256)
    }
    }
}}
kickasm(pc SINQ) {{
    {
    .var min = -$1000
    .var max = $1000
    .var ampl = max-min;
    .for(var i=0;i<$140;i++) {
        .var rad = i*2*PI/256;
        .byte round((min+(ampl/2)+(ampl/2)*sin(rad))/256)
    }
    }
}}

