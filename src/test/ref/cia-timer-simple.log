Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call __init 

CONTROL FLOW GRAPH SSA

(dword()) clock()
clock: scope:[clock]  from main::@2
  (number~) clock::$0 ← (number) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
  (dword) clock::return#0 ← (number~) clock::$0
  to:clock::@return
clock::@return: scope:[clock]  from clock
  (dword) clock::return#3 ← phi( clock/(dword) clock::return#0 )
  (dword) clock::return#1 ← (dword) clock::return#3
  return 
  to:@return

(void()) clock_start()
clock_start: scope:[clock_start]  from main
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  *((const nomodify dword*) CIA2_TIMER_AB) ← (number) $ffffffff
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  return 
  to:@return

(void()) print_uint_at((word) print_uint_at::w , (byte*) print_uint_at::at)
print_uint_at: scope:[print_uint_at]  from print_ulong_at print_ulong_at::@1
  (byte*) print_uint_at::at#2 ← phi( print_ulong_at/(byte*) print_uint_at::at#0 print_ulong_at::@1/(byte*) print_uint_at::at#1 )
  (word) print_uint_at::w#2 ← phi( print_ulong_at/(word) print_uint_at::w#0 print_ulong_at::@1/(word) print_uint_at::w#1 )
  (byte~) print_uint_at::$0 ← > (word) print_uint_at::w#2
  (byte) print_uchar_at::b#0 ← (byte~) print_uint_at::$0
  (byte*) print_uchar_at::at#0 ← (byte*) print_uint_at::at#2
  call print_uchar_at 
  to:print_uint_at::@1
print_uint_at::@1: scope:[print_uint_at]  from print_uint_at
  (byte*) print_uint_at::at#3 ← phi( print_uint_at/(byte*) print_uint_at::at#2 )
  (word) print_uint_at::w#3 ← phi( print_uint_at/(word) print_uint_at::w#2 )
  (byte~) print_uint_at::$2 ← < (word) print_uint_at::w#3
  (byte*~) print_uint_at::$3 ← (byte*) print_uint_at::at#3 + (number) 2
  (byte) print_uchar_at::b#1 ← (byte~) print_uint_at::$2
  (byte*) print_uchar_at::at#1 ← (byte*~) print_uint_at::$3
  call print_uchar_at 
  to:print_uint_at::@2
print_uint_at::@2: scope:[print_uint_at]  from print_uint_at::@1
  to:print_uint_at::@return
print_uint_at::@return: scope:[print_uint_at]  from print_uint_at::@2
  return 
  to:@return

(void()) print_ulong_at((dword) print_ulong_at::dw , (byte*) print_ulong_at::at)
print_ulong_at: scope:[print_ulong_at]  from main::@4
  (byte*) print_ulong_at::at#1 ← phi( main::@4/(byte*) print_ulong_at::at#0 )
  (dword) print_ulong_at::dw#1 ← phi( main::@4/(dword) print_ulong_at::dw#0 )
  (word~) print_ulong_at::$0 ← > (dword) print_ulong_at::dw#1
  (word) print_uint_at::w#0 ← (word~) print_ulong_at::$0
  (byte*) print_uint_at::at#0 ← (byte*) print_ulong_at::at#1
  call print_uint_at 
  to:print_ulong_at::@1
print_ulong_at::@1: scope:[print_ulong_at]  from print_ulong_at
  (byte*) print_ulong_at::at#2 ← phi( print_ulong_at/(byte*) print_ulong_at::at#1 )
  (dword) print_ulong_at::dw#2 ← phi( print_ulong_at/(dword) print_ulong_at::dw#1 )
  (word~) print_ulong_at::$2 ← < (dword) print_ulong_at::dw#2
  (byte*~) print_ulong_at::$3 ← (byte*) print_ulong_at::at#2 + (number) 4
  (word) print_uint_at::w#1 ← (word~) print_ulong_at::$2
  (byte*) print_uint_at::at#1 ← (byte*~) print_ulong_at::$3
  call print_uint_at 
  to:print_ulong_at::@2
print_ulong_at::@2: scope:[print_ulong_at]  from print_ulong_at::@1
  to:print_ulong_at::@return
print_ulong_at::@return: scope:[print_ulong_at]  from print_ulong_at::@2
  return 
  to:@return

(void()) print_uchar_at((byte) print_uchar_at::b , (byte*) print_uchar_at::at)
print_uchar_at: scope:[print_uchar_at]  from print_uint_at print_uint_at::@1
  (byte*) print_uchar_at::at#2 ← phi( print_uint_at/(byte*) print_uchar_at::at#0 print_uint_at::@1/(byte*) print_uchar_at::at#1 )
  (byte) print_uchar_at::b#2 ← phi( print_uint_at/(byte) print_uchar_at::b#0 print_uint_at::@1/(byte) print_uchar_at::b#1 )
  (byte~) print_uchar_at::$0 ← (byte) print_uchar_at::b#2 >> (number) 4
  (byte) print_char_at::ch#0 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$0)
  (byte*) print_char_at::at#0 ← (byte*) print_uchar_at::at#2
  call print_char_at 
  to:print_uchar_at::@1
print_uchar_at::@1: scope:[print_uchar_at]  from print_uchar_at
  (byte*) print_uchar_at::at#3 ← phi( print_uchar_at/(byte*) print_uchar_at::at#2 )
  (byte) print_uchar_at::b#3 ← phi( print_uchar_at/(byte) print_uchar_at::b#2 )
  (number~) print_uchar_at::$2 ← (byte) print_uchar_at::b#3 & (number) $f
  (byte*~) print_uchar_at::$3 ← (byte*) print_uchar_at::at#3 + (number) 1
  (byte) print_char_at::ch#1 ← *((const to_nomodify byte*) print_hextab + (number~) print_uchar_at::$2)
  (byte*) print_char_at::at#1 ← (byte*~) print_uchar_at::$3
  call print_char_at 
  to:print_uchar_at::@2
print_uchar_at::@2: scope:[print_uchar_at]  from print_uchar_at::@1
  to:print_uchar_at::@return
print_uchar_at::@return: scope:[print_uchar_at]  from print_uchar_at::@2
  return 
  to:@return

(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
print_char_at: scope:[print_char_at]  from print_uchar_at print_uchar_at::@1
  (byte*) print_char_at::at#2 ← phi( print_uchar_at/(byte*) print_char_at::at#0 print_uchar_at::@1/(byte*) print_char_at::at#1 )
  (byte) print_char_at::ch#2 ← phi( print_uchar_at/(byte) print_char_at::ch#0 print_uchar_at::@1/(byte) print_char_at::ch#1 )
  *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  return 
  to:@return

(void()) main()
main: scope:[main]  from __start::@1
  call clock_start 
  to:main::@3
main::@3: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@3 main::@5
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  call clock 
  (dword) clock::return#2 ← (dword) clock::return#1
  to:main::@4
main::@4: scope:[main]  from main::@2
  (dword) clock::return#4 ← phi( main::@2/(dword) clock::return#2 )
  (dword~) main::$1 ← (dword) clock::return#4
  (dword) print_ulong_at::dw#0 ← (dword~) main::$1
  (byte*) print_ulong_at::at#0 ← (const nomodify byte*) SCREEN
  call print_ulong_at 
  to:main::@5
main::@5: scope:[main]  from main::@4
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
(const nomodify struct MOS6526_CIA*) CIA2 = (struct MOS6526_CIA*)(number) $dd00
(const nomodify dword*) CIA2_TIMER_AB = (dword*)(number) $dd04
(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES = (byte) 0
(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = (byte) $40
(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS = (byte) 0
(const nomodify byte) CIA_TIMER_CONTROL_START = (byte) 1
(const nomodify byte) CIA_TIMER_CONTROL_STOP = (byte) 0
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = (byte) $e
(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = (byte) $f
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(const nomodify byte*) SCREEN = (byte*)(number) $400
(void()) __start()
(label) __start::@1
(label) __start::@2
(label) __start::@return
(label) __start::__init1
(dword()) clock()
(number~) clock::$0
(label) clock::@return
(dword) clock::return
(dword) clock::return#0
(dword) clock::return#1
(dword) clock::return#2
(dword) clock::return#3
(dword) clock::return#4
(void()) clock_start()
(label) clock_start::@return
(void()) main()
(dword~) main::$1
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@return
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(label) print_char_at::@return
(byte*) print_char_at::at
(byte*) print_char_at::at#0
(byte*) print_char_at::at#1
(byte*) print_char_at::at#2
(byte) print_char_at::ch
(byte) print_char_at::ch#0
(byte) print_char_at::ch#1
(byte) print_char_at::ch#2
(const to_nomodify byte*) print_hextab[]  = (byte*) "0123456789abcdef"z
(void()) print_uchar_at((byte) print_uchar_at::b , (byte*) print_uchar_at::at)
(byte~) print_uchar_at::$0
(number~) print_uchar_at::$2
(byte*~) print_uchar_at::$3
(label) print_uchar_at::@1
(label) print_uchar_at::@2
(label) print_uchar_at::@return
(byte*) print_uchar_at::at
(byte*) print_uchar_at::at#0
(byte*) print_uchar_at::at#1
(byte*) print_uchar_at::at#2
(byte*) print_uchar_at::at#3
(byte) print_uchar_at::b
(byte) print_uchar_at::b#0
(byte) print_uchar_at::b#1
(byte) print_uchar_at::b#2
(byte) print_uchar_at::b#3
(void()) print_uint_at((word) print_uint_at::w , (byte*) print_uint_at::at)
(byte~) print_uint_at::$0
(byte~) print_uint_at::$2
(byte*~) print_uint_at::$3
(label) print_uint_at::@1
(label) print_uint_at::@2
(label) print_uint_at::@return
(byte*) print_uint_at::at
(byte*) print_uint_at::at#0
(byte*) print_uint_at::at#1
(byte*) print_uint_at::at#2
(byte*) print_uint_at::at#3
(word) print_uint_at::w
(word) print_uint_at::w#0
(word) print_uint_at::w#1
(word) print_uint_at::w#2
(word) print_uint_at::w#3
(void()) print_ulong_at((dword) print_ulong_at::dw , (byte*) print_ulong_at::at)
(word~) print_ulong_at::$0
(word~) print_ulong_at::$2
(byte*~) print_ulong_at::$3
(label) print_ulong_at::@1
(label) print_ulong_at::@2
(label) print_ulong_at::@return
(byte*) print_ulong_at::at
(byte*) print_ulong_at::at#0
(byte*) print_ulong_at::at#1
(byte*) print_ulong_at::at#2
(dword) print_ulong_at::dw
(dword) print_ulong_at::dw#0
(dword) print_ulong_at::dw#1
(dword) print_ulong_at::dw#2

Adding number conversion cast (unumber) $ffffffff in (number~) clock::$0 ← (number) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
Adding number conversion cast (unumber) clock::$0 in (number~) clock::$0 ← (unumber)(number) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
Adding number conversion cast (unumber) $ffffffff in *((const nomodify dword*) CIA2_TIMER_AB) ← (number) $ffffffff
Adding number conversion cast (unumber) 2 in (byte*~) print_uint_at::$3 ← (byte*) print_uint_at::at#3 + (number) 2
Adding number conversion cast (unumber) 4 in (byte*~) print_ulong_at::$3 ← (byte*) print_ulong_at::at#2 + (number) 4
Adding number conversion cast (unumber) 4 in (byte~) print_uchar_at::$0 ← (byte) print_uchar_at::b#2 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) print_uchar_at::$2 ← (byte) print_uchar_at::b#3 & (number) $f
Adding number conversion cast (unumber) print_uchar_at::$2 in (number~) print_uchar_at::$2 ← (byte) print_uchar_at::b#3 & (unumber)(number) $f
Adding number conversion cast (unumber) 1 in (byte*~) print_uchar_at::$3 ← (byte*) print_uchar_at::at#3 + (number) 1
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((const nomodify dword*) CIA2_TIMER_AB) ← (unumber)(number) $ffffffff
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (struct MOS6526_CIA*) 56576
Simplifying constant pointer cast (dword*) 56580
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to dword in (unumber~) clock::$0 ← (dword) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
Inferred type updated to byte in (unumber~) print_uchar_at::$2 ← (byte) print_uchar_at::b#3 & (byte) $f
Alias clock::return#0 = clock::$0 clock::return#3 clock::return#1 
Alias print_uchar_at::b#0 = print_uint_at::$0 
Alias print_uint_at::w#2 = print_uint_at::w#3 
Alias print_uint_at::at#2 = print_uint_at::at#3 
Alias print_uchar_at::b#1 = print_uint_at::$2 
Alias print_uchar_at::at#1 = print_uint_at::$3 
Alias print_uint_at::w#0 = print_ulong_at::$0 
Alias print_ulong_at::dw#1 = print_ulong_at::dw#2 
Alias print_ulong_at::at#1 = print_ulong_at::at#2 
Alias print_uint_at::w#1 = print_ulong_at::$2 
Alias print_uint_at::at#1 = print_ulong_at::$3 
Alias print_uchar_at::b#2 = print_uchar_at::b#3 
Alias print_uchar_at::at#2 = print_uchar_at::at#3 
Alias print_char_at::at#1 = print_uchar_at::$3 
Alias clock::return#2 = clock::return#4 
Alias print_ulong_at::dw#0 = main::$1 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (dword) print_ulong_at::dw#1 (dword) print_ulong_at::dw#0
Identical Phi Values (byte*) print_ulong_at::at#1 (byte*) print_ulong_at::at#0
Successful SSA optimization Pass2IdenticalPhiElimination
Constant (const byte*) print_ulong_at::at#0 = SCREEN
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) print_uint_at::at#0 = print_ulong_at::at#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [38] if(true) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Simplifying constant evaluating to zero (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES in [2] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
Simplifying constant evaluating to zero (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS in [3] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A in [3] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (byte) 0|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Simplifying expression containing zero CIA_TIMER_CONTROL_START in [5] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Simplifying expression containing zero CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_CONTINUOUS in [6] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
Successful SSA optimization PassNSimplifyExpressionWithZero
Simplifying expression containing zero CIA_TIMER_CONTROL_START in [6] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const nomodify byte) CIA_TIMER_CONTROL_STOP
Eliminating unused constant (const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS
Eliminating unused constant (const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Constant right-side identified [19] (byte*) print_uint_at::at#1 ← (const byte*) print_ulong_at::at#0 + (byte) 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) print_uint_at::at#1 = print_ulong_at::at#0+4
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings (const byte*) print_uint_at::at#0
Inlining constant with var siblings (const byte*) print_uint_at::at#1
Constant inlined print_ulong_at::at#0 = (const nomodify byte*) SCREEN
Constant inlined print_uint_at::at#1 = (const nomodify byte*) SCREEN+(byte) 4
Constant inlined print_uint_at::at#0 = (const nomodify byte*) SCREEN
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of print_ulong_at::@2
Adding NOP phi() at start of print_uint_at::@2
Adding NOP phi() at start of print_uchar_at::@2
CALL GRAPH
Calls in [main] to clock_start:1 clock:5 print_ulong_at:8 
Calls in [print_ulong_at] to print_uint_at:20 print_uint_at:23 
Calls in [print_uint_at] to print_uchar_at:31 print_uchar_at:36 
Calls in [print_uchar_at] to print_char_at:45 print_char_at:51 

Created 6 initial phi equivalence classes
Coalesced [19] print_uint_at::w#4 ← print_uint_at::w#0
Coalesced [22] print_uint_at::w#5 ← print_uint_at::w#1
Coalesced [29] print_uchar_at::b#4 ← print_uchar_at::b#0
Coalesced [30] print_uchar_at::at#4 ← print_uchar_at::at#0
Coalesced [34] print_uchar_at::b#5 ← print_uchar_at::b#1
Coalesced [35] print_uchar_at::at#5 ← print_uchar_at::at#1
Coalesced [43] print_char_at::ch#3 ← print_char_at::ch#0
Coalesced [44] print_char_at::at#3 ← print_char_at::at#0
Coalesced [49] print_char_at::ch#4 ← print_char_at::ch#1
Coalesced [50] print_char_at::at#4 ← print_char_at::at#1
Coalesced down to 6 phi equivalence classes
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@1
Culled Empty Block (label) main::@5
Culled Empty Block (label) print_ulong_at::@2
Culled Empty Block (label) print_uint_at::@2
Culled Empty Block (label) print_uchar_at::@2
Renumbering block main::@2 to main::@1
Renumbering block main::@4 to main::@2
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call clock_start 
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [2] phi()
  [3] call clock 
  [4] (dword) clock::return#2 ← (dword) clock::return#0
  to:main::@2
main::@2: scope:[main]  from main::@1
  [5] (dword) print_ulong_at::dw#0 ← (dword) clock::return#2
  [6] call print_ulong_at 
  to:main::@1

(void()) clock_start()
clock_start: scope:[clock_start]  from main
  [7] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0
  [8] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  [9] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff
  [10] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  [11] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  [12] return 
  to:@return

(dword()) clock()
clock: scope:[clock]  from main::@1
  [13] (dword) clock::return#0 ← (dword) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
  to:clock::@return
clock::@return: scope:[clock]  from clock
  [14] return 
  to:@return

(void()) print_ulong_at((dword) print_ulong_at::dw , (byte*) print_ulong_at::at)
print_ulong_at: scope:[print_ulong_at]  from main::@2
  [15] (word) print_uint_at::w#0 ← > (dword) print_ulong_at::dw#0
  [16] call print_uint_at 
  to:print_ulong_at::@1
print_ulong_at::@1: scope:[print_ulong_at]  from print_ulong_at
  [17] (word) print_uint_at::w#1 ← < (dword) print_ulong_at::dw#0
  [18] call print_uint_at 
  to:print_ulong_at::@return
print_ulong_at::@return: scope:[print_ulong_at]  from print_ulong_at::@1
  [19] return 
  to:@return

(void()) print_uint_at((word) print_uint_at::w , (byte*) print_uint_at::at)
print_uint_at: scope:[print_uint_at]  from print_ulong_at print_ulong_at::@1
  [20] (byte*) print_uint_at::at#2 ← phi( print_ulong_at/(const nomodify byte*) SCREEN print_ulong_at::@1/(const nomodify byte*) SCREEN+(byte) 4 )
  [20] (word) print_uint_at::w#2 ← phi( print_ulong_at/(word) print_uint_at::w#0 print_ulong_at::@1/(word) print_uint_at::w#1 )
  [21] (byte) print_uchar_at::b#0 ← > (word) print_uint_at::w#2
  [22] (byte*) print_uchar_at::at#0 ← (byte*) print_uint_at::at#2
  [23] call print_uchar_at 
  to:print_uint_at::@1
print_uint_at::@1: scope:[print_uint_at]  from print_uint_at
  [24] (byte) print_uchar_at::b#1 ← < (word) print_uint_at::w#2
  [25] (byte*) print_uchar_at::at#1 ← (byte*) print_uint_at::at#2 + (byte) 2
  [26] call print_uchar_at 
  to:print_uint_at::@return
print_uint_at::@return: scope:[print_uint_at]  from print_uint_at::@1
  [27] return 
  to:@return

(void()) print_uchar_at((byte) print_uchar_at::b , (byte*) print_uchar_at::at)
print_uchar_at: scope:[print_uchar_at]  from print_uint_at print_uint_at::@1
  [28] (byte*) print_uchar_at::at#2 ← phi( print_uint_at/(byte*) print_uchar_at::at#0 print_uint_at::@1/(byte*) print_uchar_at::at#1 )
  [28] (byte) print_uchar_at::b#2 ← phi( print_uint_at/(byte) print_uchar_at::b#0 print_uint_at::@1/(byte) print_uchar_at::b#1 )
  [29] (byte~) print_uchar_at::$0 ← (byte) print_uchar_at::b#2 >> (byte) 4
  [30] (byte) print_char_at::ch#0 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$0)
  [31] (byte*) print_char_at::at#0 ← (byte*) print_uchar_at::at#2
  [32] call print_char_at 
  to:print_uchar_at::@1
print_uchar_at::@1: scope:[print_uchar_at]  from print_uchar_at
  [33] (byte~) print_uchar_at::$2 ← (byte) print_uchar_at::b#2 & (byte) $f
  [34] (byte*) print_char_at::at#1 ← (byte*) print_uchar_at::at#2 + (byte) 1
  [35] (byte) print_char_at::ch#1 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$2)
  [36] call print_char_at 
  to:print_uchar_at::@return
print_uchar_at::@return: scope:[print_uchar_at]  from print_uchar_at::@1
  [37] return 
  to:@return

(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
print_char_at: scope:[print_char_at]  from print_uchar_at print_uchar_at::@1
  [38] (byte*) print_char_at::at#2 ← phi( print_uchar_at/(byte*) print_char_at::at#0 print_uchar_at::@1/(byte*) print_char_at::at#1 )
  [38] (byte) print_char_at::ch#2 ← phi( print_uchar_at/(byte) print_char_at::ch#0 print_uchar_at::@1/(byte) print_char_at::ch#1 )
  [39] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  [40] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(dword()) clock()
(dword) clock::return
(dword) clock::return#0 37.33333333333333
(dword) clock::return#2 22.0
(void()) clock_start()
(void()) main()
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(byte*) print_char_at::at
(byte*) print_char_at::at#0 20002.0
(byte*) print_char_at::at#1 10001.0
(byte*) print_char_at::at#2 120003.0
(byte) print_char_at::ch
(byte) print_char_at::ch#0 10001.0
(byte) print_char_at::ch#1 20002.0
(byte) print_char_at::ch#2 120003.0
(void()) print_uchar_at((byte) print_uchar_at::b , (byte*) print_uchar_at::at)
(byte~) print_uchar_at::$0 20002.0
(byte~) print_uchar_at::$2 10001.0
(byte*) print_uchar_at::at
(byte*) print_uchar_at::at#0 2002.0
(byte*) print_uchar_at::at#1 2002.0
(byte*) print_uchar_at::at#2 3667.333333333333
(byte) print_uchar_at::b
(byte) print_uchar_at::b#0 1001.0
(byte) print_uchar_at::b#1 1001.0
(byte) print_uchar_at::b#2 4400.8
(void()) print_uint_at((word) print_uint_at::w , (byte*) print_uint_at::at)
(byte*) print_uint_at::at
(byte*) print_uint_at::at#2 400.4
(word) print_uint_at::w
(word) print_uint_at::w#0 202.0
(word) print_uint_at::w#1 202.0
(word) print_uint_at::w#2 551.0
(void()) print_ulong_at((dword) print_ulong_at::dw , (byte*) print_ulong_at::at)
(byte*) print_ulong_at::at
(dword) print_ulong_at::dw
(dword) print_ulong_at::dw#0 71.0

Initial phi equivalence classes
[ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ]
[ print_uint_at::at#2 ]
[ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
[ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ]
[ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
[ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
Added variable clock::return#2 to live range equivalence class [ clock::return#2 ]
Added variable print_ulong_at::dw#0 to live range equivalence class [ print_ulong_at::dw#0 ]
Added variable clock::return#0 to live range equivalence class [ clock::return#0 ]
Added variable print_uchar_at::$0 to live range equivalence class [ print_uchar_at::$0 ]
Added variable print_uchar_at::$2 to live range equivalence class [ print_uchar_at::$2 ]
Complete equivalence classes
[ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ]
[ print_uint_at::at#2 ]
[ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
[ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ]
[ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
[ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
[ clock::return#2 ]
[ print_ulong_at::dw#0 ]
[ clock::return#0 ]
[ print_uchar_at::$0 ]
[ print_uchar_at::$2 ]
Allocated zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ]
Allocated zp[2]:4 [ print_uint_at::at#2 ]
Allocated zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
Allocated zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ]
Allocated zp[1]:9 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
Allocated zp[2]:10 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
Allocated zp[4]:12 [ clock::return#2 ]
Allocated zp[4]:16 [ print_ulong_at::dw#0 ]
Allocated zp[4]:20 [ clock::return#0 ]
Allocated zp[1]:24 [ print_uchar_at::$0 ]
Allocated zp[1]:25 [ print_uchar_at::$2 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Setup and run a simple CIA-timer
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#2 timer A&B as one single 32-bit value
  .label CIA2_TIMER_AB = $dd04
  .label SCREEN = $400
  // main
main: {
    // [1] call clock_start 
    // Reset & start the CIA#2 timer A+B
    jsr clock_start
    // [2] phi from main main::@2 to main::@1 [phi:main/main::@2->main::@1]
  __b1_from_main:
  __b1_from___b2:
    jmp __b1
    // main::@1
  __b1:
    // [3] call clock 
    jsr clock
    // [4] (dword) clock::return#2 ← (dword) clock::return#0 -- vduz1=vduz2 
    lda.z clock.return
    sta.z clock.return_1
    lda.z clock.return+1
    sta.z clock.return_1+1
    lda.z clock.return+2
    sta.z clock.return_1+2
    lda.z clock.return+3
    sta.z clock.return_1+3
    jmp __b2
    // main::@2
  __b2:
    // [5] (dword) print_ulong_at::dw#0 ← (dword) clock::return#2 -- vduz1=vduz2 
    lda.z clock.return_1
    sta.z print_ulong_at.dw
    lda.z clock.return_1+1
    sta.z print_ulong_at.dw+1
    lda.z clock.return_1+2
    sta.z print_ulong_at.dw+2
    lda.z clock.return_1+3
    sta.z print_ulong_at.dw+3
    // [6] call print_ulong_at 
    jsr print_ulong_at
    jmp __b1_from___b2
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [7] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #0
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // [8] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [9] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [10] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [11] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    jmp __breturn
    // clock_start::@return
  __breturn:
    // [12] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = $14
    .label return_1 = $c
    // [13] (dword) clock::return#0 ← (dword) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta.z return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta.z return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta.z return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta.z return+3
    jmp __breturn
    // clock::@return
  __breturn:
    // [14] return 
    rts
}
  // print_ulong_at
// Print a unsigned long as HEX at a specific position
// print_ulong_at(dword zp($10) dw)
print_ulong_at: {
    .label dw = $10
    // [15] (word) print_uint_at::w#0 ← > (dword) print_ulong_at::dw#0 -- vwuz1=_hi_vduz2 
    lda.z dw+2
    sta.z print_uint_at.w
    lda.z dw+3
    sta.z print_uint_at.w+1
    // [16] call print_uint_at 
    // [20] phi from print_ulong_at to print_uint_at [phi:print_ulong_at->print_uint_at]
  print_uint_at_from_print_ulong_at:
    // [20] phi (byte*) print_uint_at::at#2 = (const nomodify byte*) SCREEN [phi:print_ulong_at->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z print_uint_at.at
    lda #>SCREEN
    sta.z print_uint_at.at+1
    // [20] phi (word) print_uint_at::w#2 = (word) print_uint_at::w#0 [phi:print_ulong_at->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    jmp __b1
    // print_ulong_at::@1
  __b1:
    // [17] (word) print_uint_at::w#1 ← < (dword) print_ulong_at::dw#0 -- vwuz1=_lo_vduz2 
    lda.z dw
    sta.z print_uint_at.w
    lda.z dw+1
    sta.z print_uint_at.w+1
    // [18] call print_uint_at 
    // [20] phi from print_ulong_at::@1 to print_uint_at [phi:print_ulong_at::@1->print_uint_at]
  print_uint_at_from___b1:
    // [20] phi (byte*) print_uint_at::at#2 = (const nomodify byte*) SCREEN+(byte) 4 [phi:print_ulong_at::@1->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN+4
    sta.z print_uint_at.at
    lda #>SCREEN+4
    sta.z print_uint_at.at+1
    // [20] phi (word) print_uint_at::w#2 = (word) print_uint_at::w#1 [phi:print_ulong_at::@1->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    jmp __breturn
    // print_ulong_at::@return
  __breturn:
    // [19] return 
    rts
}
  // print_uint_at
// Print a unsigned int as HEX at a specific position
// print_uint_at(word zp(2) w, byte* zp(4) at)
print_uint_at: {
    .label w = 2
    .label at = 4
    // [21] (byte) print_uchar_at::b#0 ← > (word) print_uint_at::w#2 -- vbuz1=_hi_vwuz2 
    lda.z w+1
    sta.z print_uchar_at.b
    // [22] (byte*) print_uchar_at::at#0 ← (byte*) print_uint_at::at#2 -- pbuz1=pbuz2 
    lda.z at
    sta.z print_uchar_at.at
    lda.z at+1
    sta.z print_uchar_at.at+1
    // [23] call print_uchar_at 
    // [28] phi from print_uint_at to print_uchar_at [phi:print_uint_at->print_uchar_at]
  print_uchar_at_from_print_uint_at:
    // [28] phi (byte*) print_uchar_at::at#2 = (byte*) print_uchar_at::at#0 [phi:print_uint_at->print_uchar_at#0] -- register_copy 
    // [28] phi (byte) print_uchar_at::b#2 = (byte) print_uchar_at::b#0 [phi:print_uint_at->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    jmp __b1
    // print_uint_at::@1
  __b1:
    // [24] (byte) print_uchar_at::b#1 ← < (word) print_uint_at::w#2 -- vbuz1=_lo_vwuz2 
    lda.z w
    sta.z print_uchar_at.b
    // [25] (byte*) print_uchar_at::at#1 ← (byte*) print_uint_at::at#2 + (byte) 2 -- pbuz1=pbuz2_plus_vbuc1 
    lda #2
    clc
    adc.z at
    sta.z print_uchar_at.at
    lda #0
    adc.z at+1
    sta.z print_uchar_at.at+1
    // [26] call print_uchar_at 
    // [28] phi from print_uint_at::@1 to print_uchar_at [phi:print_uint_at::@1->print_uchar_at]
  print_uchar_at_from___b1:
    // [28] phi (byte*) print_uchar_at::at#2 = (byte*) print_uchar_at::at#1 [phi:print_uint_at::@1->print_uchar_at#0] -- register_copy 
    // [28] phi (byte) print_uchar_at::b#2 = (byte) print_uchar_at::b#1 [phi:print_uint_at::@1->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    jmp __breturn
    // print_uint_at::@return
  __breturn:
    // [27] return 
    rts
}
  // print_uchar_at
// Print a char as HEX at a specific position
// print_uchar_at(byte zp(6) b, byte* zp(7) at)
print_uchar_at: {
    .label __0 = $18
    .label __2 = $19
    .label b = 6
    .label at = 7
    // [29] (byte~) print_uchar_at::$0 ← (byte) print_uchar_at::b#2 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda.z b
    lsr
    lsr
    lsr
    lsr
    sta.z __0
    // [30] (byte) print_char_at::ch#0 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z __0
    lda print_hextab,y
    sta.z print_char_at.ch
    // [31] (byte*) print_char_at::at#0 ← (byte*) print_uchar_at::at#2 -- pbuz1=pbuz2 
    lda.z at
    sta.z print_char_at.at
    lda.z at+1
    sta.z print_char_at.at+1
    // [32] call print_char_at 
  // Table of hexadecimal digits
    // [38] phi from print_uchar_at to print_char_at [phi:print_uchar_at->print_char_at]
  print_char_at_from_print_uchar_at:
    // [38] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#0 [phi:print_uchar_at->print_char_at#0] -- register_copy 
    // [38] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#0 [phi:print_uchar_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp __b1
    // print_uchar_at::@1
  __b1:
    // [33] (byte~) print_uchar_at::$2 ← (byte) print_uchar_at::b#2 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and.z b
    sta.z __2
    // [34] (byte*) print_char_at::at#1 ← (byte*) print_uchar_at::at#2 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda.z at
    clc
    adc #1
    sta.z print_char_at.at
    lda.z at+1
    adc #0
    sta.z print_char_at.at+1
    // [35] (byte) print_char_at::ch#1 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z __2
    lda print_hextab,y
    sta.z print_char_at.ch
    // [36] call print_char_at 
    // [38] phi from print_uchar_at::@1 to print_char_at [phi:print_uchar_at::@1->print_char_at]
  print_char_at_from___b1:
    // [38] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#1 [phi:print_uchar_at::@1->print_char_at#0] -- register_copy 
    // [38] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#1 [phi:print_uchar_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp __breturn
    // print_uchar_at::@return
  __breturn:
    // [37] return 
    rts
}
  // print_char_at
// Print a single char
// print_char_at(byte zp(9) ch, byte* zp($a) at)
print_char_at: {
    .label ch = 9
    .label at = $a
    // [39] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 -- _deref_pbuz1=vbuz2 
    lda.z ch
    ldy #0
    sta (at),y
    jmp __breturn
    // print_char_at::@return
  __breturn:
    // [40] return 
    rts
}
  // File Data
  print_hextab: .text "0123456789abcdef"

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [4] (dword) clock::return#2 ← (dword) clock::return#0 [ clock::return#2 ] (  [ clock::return#2 ] { { clock::return#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [5] (dword) print_ulong_at::dw#0 ← (dword) clock::return#2 [ print_ulong_at::dw#0 ] (  [ print_ulong_at::dw#0 ] { { print_ulong_at::dw#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [7] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [8] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [9] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [10] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [11] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [13] (dword) clock::return#0 ← (dword) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB) [ clock::return#0 ] ( clock:3 [ clock::return#0 ] { { clock::return#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [15] (word) print_uint_at::w#0 ← > (dword) print_ulong_at::dw#0 [ print_ulong_at::dw#0 print_uint_at::w#0 ] ( print_ulong_at:6 [ print_ulong_at::dw#0 print_uint_at::w#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } }  ) always clobbers reg byte a 
Statement [17] (word) print_uint_at::w#1 ← < (dword) print_ulong_at::dw#0 [ print_uint_at::w#1 ] ( print_ulong_at:6 [ print_uint_at::w#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } }  ) always clobbers reg byte a 
Statement [22] (byte*) print_uchar_at::at#0 ← (byte*) print_uint_at::at#2 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] ( print_ulong_at:6::print_uint_at:16 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:18 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
Statement [25] (byte*) print_uchar_at::at#1 ← (byte*) print_uint_at::at#2 + (byte) 2 [ print_uchar_at::b#1 print_uchar_at::at#1 ] ( print_ulong_at:6::print_uint_at:16 [ print_ulong_at::dw#0 print_uchar_at::b#1 print_uchar_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } }  print_ulong_at:6::print_uint_at:18 [ print_uchar_at::b#1 print_uchar_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } }  ) always clobbers reg byte a 
Statement [29] (byte~) print_uchar_at::$0 ← (byte) print_uchar_at::b#2 >> (byte) 4 [ print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26 [ print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  ) always clobbers reg byte a 
Statement [31] (byte*) print_char_at::at#0 ← (byte*) print_uchar_at::at#2 [ print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26 [ print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:9 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
Statement [33] (byte~) print_uchar_at::$2 ← (byte) print_uchar_at::b#2 & (byte) $f [ print_uchar_at::at#2 print_uchar_at::$2 ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26 [ print_ulong_at::dw#0 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26 [ print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a 
Statement [34] (byte*) print_char_at::at#1 ← (byte*) print_uchar_at::at#2 + (byte) 1 [ print_uchar_at::$2 print_char_at::at#1 ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26 [ print_ulong_at::dw#0 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26 [ print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:25 [ print_uchar_at::$2 ]
Statement [39] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 [ ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23::print_char_at:32 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23::print_char_at:32 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26::print_char_at:32 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26::print_char_at:32 [ print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:23::print_char_at:36 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23::print_char_at:36 [ print_uint_at::w#2 print_uint_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26::print_char_at:36 [ print_ulong_at::dw#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26::print_char_at:36 [ ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
Statement [4] (dword) clock::return#2 ← (dword) clock::return#0 [ clock::return#2 ] (  [ clock::return#2 ] { { clock::return#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [5] (dword) print_ulong_at::dw#0 ← (dword) clock::return#2 [ print_ulong_at::dw#0 ] (  [ print_ulong_at::dw#0 ] { { print_ulong_at::dw#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [7] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [8] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [9] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [10] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [11] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START [ ] ( clock_start:1 [ ] { }  ) always clobbers reg byte a 
Statement [13] (dword) clock::return#0 ← (dword) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB) [ clock::return#0 ] ( clock:3 [ clock::return#0 ] { { clock::return#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [15] (word) print_uint_at::w#0 ← > (dword) print_ulong_at::dw#0 [ print_ulong_at::dw#0 print_uint_at::w#0 ] ( print_ulong_at:6 [ print_ulong_at::dw#0 print_uint_at::w#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } }  ) always clobbers reg byte a 
Statement [17] (word) print_uint_at::w#1 ← < (dword) print_ulong_at::dw#0 [ print_uint_at::w#1 ] ( print_ulong_at:6 [ print_uint_at::w#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } }  ) always clobbers reg byte a 
Statement [22] (byte*) print_uchar_at::at#0 ← (byte*) print_uint_at::at#2 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] ( print_ulong_at:6::print_uint_at:16 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:18 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } }  ) always clobbers reg byte a 
Statement [25] (byte*) print_uchar_at::at#1 ← (byte*) print_uint_at::at#2 + (byte) 2 [ print_uchar_at::b#1 print_uchar_at::at#1 ] ( print_ulong_at:6::print_uint_at:16 [ print_ulong_at::dw#0 print_uchar_at::b#1 print_uchar_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } }  print_ulong_at:6::print_uint_at:18 [ print_uchar_at::b#1 print_uchar_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } }  ) always clobbers reg byte a 
Statement [29] (byte~) print_uchar_at::$0 ← (byte) print_uchar_at::b#2 >> (byte) 4 [ print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26 [ print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  ) always clobbers reg byte a 
Statement [31] (byte*) print_char_at::at#0 ← (byte*) print_uchar_at::at#2 [ print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26 [ print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  ) always clobbers reg byte a 
Statement [33] (byte~) print_uchar_at::$2 ← (byte) print_uchar_at::b#2 & (byte) $f [ print_uchar_at::at#2 print_uchar_at::$2 ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26 [ print_ulong_at::dw#0 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26 [ print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a 
Statement [34] (byte*) print_char_at::at#1 ← (byte*) print_uchar_at::at#2 + (byte) 1 [ print_uchar_at::$2 print_char_at::at#1 ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26 [ print_ulong_at::dw#0 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26 [ print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a 
Statement [39] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 [ ] ( print_ulong_at:6::print_uint_at:16::print_uchar_at:23::print_char_at:32 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23::print_char_at:32 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26::print_char_at:32 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26::print_char_at:32 [ print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:23::print_char_at:36 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:23::print_char_at:36 [ print_uint_at::w#2 print_uint_at::at#2 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:16::print_uchar_at:26::print_char_at:36 [ print_ulong_at::dw#0 ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:6::print_uint_at:18::print_uchar_at:26::print_char_at:36 [ ] { { print_ulong_at::dw#0 = clock::return#2 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a reg byte y 
Potential registers zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ] : zp[2]:2 , 
Potential registers zp[2]:4 [ print_uint_at::at#2 ] : zp[2]:4 , 
Potential registers zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ] : zp[1]:6 , reg byte x , 
Potential registers zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ] : zp[2]:7 , 
Potential registers zp[1]:9 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[2]:10 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] : zp[2]:10 , 
Potential registers zp[4]:12 [ clock::return#2 ] : zp[4]:12 , 
Potential registers zp[4]:16 [ print_ulong_at::dw#0 ] : zp[4]:16 , 
Potential registers zp[4]:20 [ clock::return#0 ] : zp[4]:20 , 
Potential registers zp[1]:24 [ print_uchar_at::$0 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:25 [ print_uchar_at::$2 ] : zp[1]:25 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [print_char_at] 150,006: zp[1]:9 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ] 150,006: zp[2]:10 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] 
Uplift Scope [print_uchar_at] 20,002: zp[1]:24 [ print_uchar_at::$0 ] 10,001: zp[1]:25 [ print_uchar_at::$2 ] 7,671.33: zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ] 6,402.8: zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ] 
Uplift Scope [print_uint_at] 955: zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ] 400.4: zp[2]:4 [ print_uint_at::at#2 ] 
Uplift Scope [print_ulong_at] 71: zp[4]:16 [ print_ulong_at::dw#0 ] 
Uplift Scope [clock] 37.33: zp[4]:20 [ clock::return#0 ] 22: zp[4]:12 [ clock::return#2 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [clock_start] 
Uplift Scope [RADIX] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [print_char_at] best 1043 combination reg byte x [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ] zp[2]:10 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] 
Uplifting [print_uchar_at] best 1035 combination reg byte a [ print_uchar_at::$0 ] reg byte y [ print_uchar_at::$2 ] zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ] zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ] 
Uplifting [print_uint_at] best 1035 combination zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ] zp[2]:4 [ print_uint_at::at#2 ] 
Uplifting [print_ulong_at] best 1035 combination zp[4]:16 [ print_ulong_at::dw#0 ] 
Uplifting [clock] best 1035 combination zp[4]:20 [ clock::return#0 ] zp[4]:12 [ clock::return#2 ] 
Uplifting [MOS6526_CIA] best 1035 combination 
Uplifting [MOS6569_VICII] best 1035 combination 
Uplifting [MOS6581_SID] best 1035 combination 
Uplifting [clock_start] best 1035 combination 
Uplifting [RADIX] best 1035 combination 
Uplifting [main] best 1035 combination 
Uplifting [] best 1035 combination 
Attempting to uplift remaining variables inzp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
Uplifting [print_uchar_at] best 1035 combination zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ] 
Coalescing zero page register [ zp[2]:4 [ print_uint_at::at#2 ] ] with [ zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ] ] - score: 2
Coalescing zero page register [ zp[4]:12 [ clock::return#2 ] ] with [ zp[4]:16 [ print_ulong_at::dw#0 ] ] - score: 1
Coalescing zero page register [ zp[4]:12 [ clock::return#2 print_ulong_at::dw#0 ] ] with [ zp[4]:20 [ clock::return#0 ] ] - score: 1
Allocated (was zp[2]:10) zp[2]:7 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
Allocated (was zp[4]:12) zp[4]:9 [ clock::return#2 print_ulong_at::dw#0 clock::return#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Setup and run a simple CIA-timer
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#2 timer A&B as one single 32-bit value
  .label CIA2_TIMER_AB = $dd04
  .label SCREEN = $400
  // main
main: {
    // [1] call clock_start 
    // Reset & start the CIA#2 timer A+B
    jsr clock_start
    // [2] phi from main main::@2 to main::@1 [phi:main/main::@2->main::@1]
  __b1_from_main:
  __b1_from___b2:
    jmp __b1
    // main::@1
  __b1:
    // [3] call clock 
    jsr clock
    // [4] (dword) clock::return#2 ← (dword) clock::return#0
    jmp __b2
    // main::@2
  __b2:
    // [5] (dword) print_ulong_at::dw#0 ← (dword) clock::return#2
    // [6] call print_ulong_at 
    jsr print_ulong_at
    jmp __b1_from___b2
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [7] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #0
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // [8] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [9] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [10] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [11] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    jmp __breturn
    // clock_start::@return
  __breturn:
    // [12] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = 9
    // [13] (dword) clock::return#0 ← (dword) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta.z return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta.z return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta.z return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta.z return+3
    jmp __breturn
    // clock::@return
  __breturn:
    // [14] return 
    rts
}
  // print_ulong_at
// Print a unsigned long as HEX at a specific position
// print_ulong_at(dword zp(9) dw)
print_ulong_at: {
    .label dw = 9
    // [15] (word) print_uint_at::w#0 ← > (dword) print_ulong_at::dw#0 -- vwuz1=_hi_vduz2 
    lda.z dw+2
    sta.z print_uint_at.w
    lda.z dw+3
    sta.z print_uint_at.w+1
    // [16] call print_uint_at 
    // [20] phi from print_ulong_at to print_uint_at [phi:print_ulong_at->print_uint_at]
  print_uint_at_from_print_ulong_at:
    // [20] phi (byte*) print_uint_at::at#2 = (const nomodify byte*) SCREEN [phi:print_ulong_at->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z print_uint_at.at
    lda #>SCREEN
    sta.z print_uint_at.at+1
    // [20] phi (word) print_uint_at::w#2 = (word) print_uint_at::w#0 [phi:print_ulong_at->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    jmp __b1
    // print_ulong_at::@1
  __b1:
    // [17] (word) print_uint_at::w#1 ← < (dword) print_ulong_at::dw#0 -- vwuz1=_lo_vduz2 
    lda.z dw
    sta.z print_uint_at.w
    lda.z dw+1
    sta.z print_uint_at.w+1
    // [18] call print_uint_at 
    // [20] phi from print_ulong_at::@1 to print_uint_at [phi:print_ulong_at::@1->print_uint_at]
  print_uint_at_from___b1:
    // [20] phi (byte*) print_uint_at::at#2 = (const nomodify byte*) SCREEN+(byte) 4 [phi:print_ulong_at::@1->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN+4
    sta.z print_uint_at.at
    lda #>SCREEN+4
    sta.z print_uint_at.at+1
    // [20] phi (word) print_uint_at::w#2 = (word) print_uint_at::w#1 [phi:print_ulong_at::@1->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    jmp __breturn
    // print_ulong_at::@return
  __breturn:
    // [19] return 
    rts
}
  // print_uint_at
// Print a unsigned int as HEX at a specific position
// print_uint_at(word zp(2) w, byte* zp(4) at)
print_uint_at: {
    .label w = 2
    .label at = 4
    // [21] (byte) print_uchar_at::b#0 ← > (word) print_uint_at::w#2 -- vbuz1=_hi_vwuz2 
    lda.z w+1
    sta.z print_uchar_at.b
    // [22] (byte*) print_uchar_at::at#0 ← (byte*) print_uint_at::at#2
    // [23] call print_uchar_at 
    // [28] phi from print_uint_at to print_uchar_at [phi:print_uint_at->print_uchar_at]
  print_uchar_at_from_print_uint_at:
    // [28] phi (byte*) print_uchar_at::at#2 = (byte*) print_uchar_at::at#0 [phi:print_uint_at->print_uchar_at#0] -- register_copy 
    // [28] phi (byte) print_uchar_at::b#2 = (byte) print_uchar_at::b#0 [phi:print_uint_at->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    jmp __b1
    // print_uint_at::@1
  __b1:
    // [24] (byte) print_uchar_at::b#1 ← < (word) print_uint_at::w#2 -- vbuz1=_lo_vwuz2 
    lda.z w
    sta.z print_uchar_at.b
    // [25] (byte*) print_uchar_at::at#1 ← (byte*) print_uint_at::at#2 + (byte) 2 -- pbuz1=pbuz1_plus_vbuc1 
    lda #2
    clc
    adc.z print_uchar_at.at
    sta.z print_uchar_at.at
    bcc !+
    inc.z print_uchar_at.at+1
  !:
    // [26] call print_uchar_at 
    // [28] phi from print_uint_at::@1 to print_uchar_at [phi:print_uint_at::@1->print_uchar_at]
  print_uchar_at_from___b1:
    // [28] phi (byte*) print_uchar_at::at#2 = (byte*) print_uchar_at::at#1 [phi:print_uint_at::@1->print_uchar_at#0] -- register_copy 
    // [28] phi (byte) print_uchar_at::b#2 = (byte) print_uchar_at::b#1 [phi:print_uint_at::@1->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    jmp __breturn
    // print_uint_at::@return
  __breturn:
    // [27] return 
    rts
}
  // print_uchar_at
// Print a char as HEX at a specific position
// print_uchar_at(byte zp(6) b, byte* zp(4) at)
print_uchar_at: {
    .label b = 6
    .label at = 4
    // [29] (byte~) print_uchar_at::$0 ← (byte) print_uchar_at::b#2 >> (byte) 4 -- vbuaa=vbuz1_ror_4 
    lda.z b
    lsr
    lsr
    lsr
    lsr
    // [30] (byte) print_char_at::ch#0 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$0) -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx print_hextab,y
    // [31] (byte*) print_char_at::at#0 ← (byte*) print_uchar_at::at#2 -- pbuz1=pbuz2 
    lda.z at
    sta.z print_char_at.at
    lda.z at+1
    sta.z print_char_at.at+1
    // [32] call print_char_at 
  // Table of hexadecimal digits
    // [38] phi from print_uchar_at to print_char_at [phi:print_uchar_at->print_char_at]
  print_char_at_from_print_uchar_at:
    // [38] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#0 [phi:print_uchar_at->print_char_at#0] -- register_copy 
    // [38] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#0 [phi:print_uchar_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp __b1
    // print_uchar_at::@1
  __b1:
    // [33] (byte~) print_uchar_at::$2 ← (byte) print_uchar_at::b#2 & (byte) $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and.z b
    tay
    // [34] (byte*) print_char_at::at#1 ← (byte*) print_uchar_at::at#2 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda.z at
    clc
    adc #1
    sta.z print_char_at.at
    lda.z at+1
    adc #0
    sta.z print_char_at.at+1
    // [35] (byte) print_char_at::ch#1 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$2) -- vbuxx=pbuc1_derefidx_vbuyy 
    ldx print_hextab,y
    // [36] call print_char_at 
    // [38] phi from print_uchar_at::@1 to print_char_at [phi:print_uchar_at::@1->print_char_at]
  print_char_at_from___b1:
    // [38] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#1 [phi:print_uchar_at::@1->print_char_at#0] -- register_copy 
    // [38] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#1 [phi:print_uchar_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp __breturn
    // print_uchar_at::@return
  __breturn:
    // [37] return 
    rts
}
  // print_char_at
// Print a single char
// print_char_at(byte register(X) ch, byte* zp(7) at)
print_char_at: {
    .label at = 7
    // [39] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (at),y
    jmp __breturn
    // print_char_at::@return
  __breturn:
    // [40] return 
    rts
}
  // File Data
  print_hextab: .text "0123456789abcdef"

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b2 with __b1
Removing instruction __b1_from_main:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b2:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction print_uint_at_from_print_ulong_at:
Removing instruction __b1:
Removing instruction print_uint_at_from___b1:
Removing instruction __breturn:
Removing instruction print_uchar_at_from_print_uint_at:
Removing instruction __b1:
Removing instruction print_uchar_at_from___b1:
Removing instruction __breturn:
Removing instruction print_char_at_from_print_uchar_at:
Removing instruction __b1:
Removing instruction print_char_at_from___b1:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(const nomodify struct MOS6526_CIA*) CIA2 = (struct MOS6526_CIA*) 56576
(const nomodify dword*) CIA2_TIMER_AB = (dword*) 56580
(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = (byte) $40
(const nomodify byte) CIA_TIMER_CONTROL_START = (byte) 1
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = (byte) $e
(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = (byte) $f
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(const nomodify byte*) SCREEN = (byte*) 1024
(dword()) clock()
(label) clock::@return
(dword) clock::return
(dword) clock::return#0 return zp[4]:9 37.33333333333333
(dword) clock::return#2 return zp[4]:9 22.0
(void()) clock_start()
(label) clock_start::@return
(void()) main()
(label) main::@1
(label) main::@2
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(label) print_char_at::@return
(byte*) print_char_at::at
(byte*) print_char_at::at#0 at zp[2]:7 20002.0
(byte*) print_char_at::at#1 at zp[2]:7 10001.0
(byte*) print_char_at::at#2 at zp[2]:7 120003.0
(byte) print_char_at::ch
(byte) print_char_at::ch#0 reg byte x 10001.0
(byte) print_char_at::ch#1 reg byte x 20002.0
(byte) print_char_at::ch#2 reg byte x 120003.0
(const to_nomodify byte*) print_hextab[]  = (byte*) "0123456789abcdef"z
(void()) print_uchar_at((byte) print_uchar_at::b , (byte*) print_uchar_at::at)
(byte~) print_uchar_at::$0 reg byte a 20002.0
(byte~) print_uchar_at::$2 reg byte y 10001.0
(label) print_uchar_at::@1
(label) print_uchar_at::@return
(byte*) print_uchar_at::at
(byte*) print_uchar_at::at#0 at zp[2]:4 2002.0
(byte*) print_uchar_at::at#1 at zp[2]:4 2002.0
(byte*) print_uchar_at::at#2 at zp[2]:4 3667.333333333333
(byte) print_uchar_at::b
(byte) print_uchar_at::b#0 b zp[1]:6 1001.0
(byte) print_uchar_at::b#1 b zp[1]:6 1001.0
(byte) print_uchar_at::b#2 b zp[1]:6 4400.8
(void()) print_uint_at((word) print_uint_at::w , (byte*) print_uint_at::at)
(label) print_uint_at::@1
(label) print_uint_at::@return
(byte*) print_uint_at::at
(byte*) print_uint_at::at#2 at zp[2]:4 400.4
(word) print_uint_at::w
(word) print_uint_at::w#0 w zp[2]:2 202.0
(word) print_uint_at::w#1 w zp[2]:2 202.0
(word) print_uint_at::w#2 w zp[2]:2 551.0
(void()) print_ulong_at((dword) print_ulong_at::dw , (byte*) print_ulong_at::at)
(label) print_ulong_at::@1
(label) print_ulong_at::@return
(byte*) print_ulong_at::at
(dword) print_ulong_at::dw
(dword) print_ulong_at::dw#0 dw zp[4]:9 71.0

zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ]
zp[2]:4 [ print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ]
zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
reg byte x [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
zp[2]:7 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
zp[4]:9 [ clock::return#2 print_ulong_at::dw#0 clock::return#0 ]
reg byte a [ print_uchar_at::$0 ]
reg byte y [ print_uchar_at::$2 ]


FINAL ASSEMBLER
Score: 455

  // File Comments
// Setup and run a simple CIA-timer
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#2 timer A&B as one single 32-bit value
  .label CIA2_TIMER_AB = $dd04
  .label SCREEN = $400
  // main
main: {
    // clock_start()
    // [1] call clock_start 
    // Reset & start the CIA#2 timer A+B
    jsr clock_start
    // [2] phi from main main::@2 to main::@1 [phi:main/main::@2->main::@1]
    // main::@1
  __b1:
    // clock()
    // [3] call clock 
    jsr clock
    // [4] (dword) clock::return#2 ← (dword) clock::return#0
    // main::@2
    // print_ulong_at(clock(), SCREEN)
    // [5] (dword) print_ulong_at::dw#0 ← (dword) clock::return#2
    // [6] call print_ulong_at 
    jsr print_ulong_at
    jmp __b1
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // CIA2->TIMER_A_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [7] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #0
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // CIA2->TIMER_B_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [8] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // *CIA2_TIMER_AB = 0xffffffff
    // [9] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // CIA2->TIMER_B_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [10] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // CIA2->TIMER_A_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [11] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // clock_start::@return
    // }
    // [12] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = 9
    // 0xffffffff - *CIA2_TIMER_AB
    // [13] (dword) clock::return#0 ← (dword) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta.z return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta.z return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta.z return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta.z return+3
    // clock::@return
    // }
    // [14] return 
    rts
}
  // print_ulong_at
// Print a unsigned long as HEX at a specific position
// print_ulong_at(dword zp(9) dw)
print_ulong_at: {
    .label dw = 9
    // print_uint_at(>dw, at)
    // [15] (word) print_uint_at::w#0 ← > (dword) print_ulong_at::dw#0 -- vwuz1=_hi_vduz2 
    lda.z dw+2
    sta.z print_uint_at.w
    lda.z dw+3
    sta.z print_uint_at.w+1
    // [16] call print_uint_at 
    // [20] phi from print_ulong_at to print_uint_at [phi:print_ulong_at->print_uint_at]
    // [20] phi (byte*) print_uint_at::at#2 = (const nomodify byte*) SCREEN [phi:print_ulong_at->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z print_uint_at.at
    lda #>SCREEN
    sta.z print_uint_at.at+1
    // [20] phi (word) print_uint_at::w#2 = (word) print_uint_at::w#0 [phi:print_ulong_at->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    // print_ulong_at::@1
    // print_uint_at(<dw, at+4)
    // [17] (word) print_uint_at::w#1 ← < (dword) print_ulong_at::dw#0 -- vwuz1=_lo_vduz2 
    lda.z dw
    sta.z print_uint_at.w
    lda.z dw+1
    sta.z print_uint_at.w+1
    // [18] call print_uint_at 
    // [20] phi from print_ulong_at::@1 to print_uint_at [phi:print_ulong_at::@1->print_uint_at]
    // [20] phi (byte*) print_uint_at::at#2 = (const nomodify byte*) SCREEN+(byte) 4 [phi:print_ulong_at::@1->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN+4
    sta.z print_uint_at.at
    lda #>SCREEN+4
    sta.z print_uint_at.at+1
    // [20] phi (word) print_uint_at::w#2 = (word) print_uint_at::w#1 [phi:print_ulong_at::@1->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    // print_ulong_at::@return
    // }
    // [19] return 
    rts
}
  // print_uint_at
// Print a unsigned int as HEX at a specific position
// print_uint_at(word zp(2) w, byte* zp(4) at)
print_uint_at: {
    .label w = 2
    .label at = 4
    // print_uchar_at(>w, at)
    // [21] (byte) print_uchar_at::b#0 ← > (word) print_uint_at::w#2 -- vbuz1=_hi_vwuz2 
    lda.z w+1
    sta.z print_uchar_at.b
    // [22] (byte*) print_uchar_at::at#0 ← (byte*) print_uint_at::at#2
    // [23] call print_uchar_at 
    // [28] phi from print_uint_at to print_uchar_at [phi:print_uint_at->print_uchar_at]
    // [28] phi (byte*) print_uchar_at::at#2 = (byte*) print_uchar_at::at#0 [phi:print_uint_at->print_uchar_at#0] -- register_copy 
    // [28] phi (byte) print_uchar_at::b#2 = (byte) print_uchar_at::b#0 [phi:print_uint_at->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    // print_uint_at::@1
    // print_uchar_at(<w, at+2)
    // [24] (byte) print_uchar_at::b#1 ← < (word) print_uint_at::w#2 -- vbuz1=_lo_vwuz2 
    lda.z w
    sta.z print_uchar_at.b
    // [25] (byte*) print_uchar_at::at#1 ← (byte*) print_uint_at::at#2 + (byte) 2 -- pbuz1=pbuz1_plus_vbuc1 
    lda #2
    clc
    adc.z print_uchar_at.at
    sta.z print_uchar_at.at
    bcc !+
    inc.z print_uchar_at.at+1
  !:
    // [26] call print_uchar_at 
    // [28] phi from print_uint_at::@1 to print_uchar_at [phi:print_uint_at::@1->print_uchar_at]
    // [28] phi (byte*) print_uchar_at::at#2 = (byte*) print_uchar_at::at#1 [phi:print_uint_at::@1->print_uchar_at#0] -- register_copy 
    // [28] phi (byte) print_uchar_at::b#2 = (byte) print_uchar_at::b#1 [phi:print_uint_at::@1->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    // print_uint_at::@return
    // }
    // [27] return 
    rts
}
  // print_uchar_at
// Print a char as HEX at a specific position
// print_uchar_at(byte zp(6) b, byte* zp(4) at)
print_uchar_at: {
    .label b = 6
    .label at = 4
    // b>>4
    // [29] (byte~) print_uchar_at::$0 ← (byte) print_uchar_at::b#2 >> (byte) 4 -- vbuaa=vbuz1_ror_4 
    lda.z b
    lsr
    lsr
    lsr
    lsr
    // print_char_at(print_hextab[b>>4], at)
    // [30] (byte) print_char_at::ch#0 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$0) -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx print_hextab,y
    // [31] (byte*) print_char_at::at#0 ← (byte*) print_uchar_at::at#2 -- pbuz1=pbuz2 
    lda.z at
    sta.z print_char_at.at
    lda.z at+1
    sta.z print_char_at.at+1
    // [32] call print_char_at 
  // Table of hexadecimal digits
    // [38] phi from print_uchar_at to print_char_at [phi:print_uchar_at->print_char_at]
    // [38] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#0 [phi:print_uchar_at->print_char_at#0] -- register_copy 
    // [38] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#0 [phi:print_uchar_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    // print_uchar_at::@1
    // b&$f
    // [33] (byte~) print_uchar_at::$2 ← (byte) print_uchar_at::b#2 & (byte) $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and.z b
    tay
    // print_char_at(print_hextab[b&$f], at+1)
    // [34] (byte*) print_char_at::at#1 ← (byte*) print_uchar_at::at#2 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda.z at
    clc
    adc #1
    sta.z print_char_at.at
    lda.z at+1
    adc #0
    sta.z print_char_at.at+1
    // [35] (byte) print_char_at::ch#1 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$2) -- vbuxx=pbuc1_derefidx_vbuyy 
    ldx print_hextab,y
    // [36] call print_char_at 
    // [38] phi from print_uchar_at::@1 to print_char_at [phi:print_uchar_at::@1->print_char_at]
    // [38] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#1 [phi:print_uchar_at::@1->print_char_at#0] -- register_copy 
    // [38] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#1 [phi:print_uchar_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    // print_uchar_at::@return
    // }
    // [37] return 
    rts
}
  // print_char_at
// Print a single char
// print_char_at(byte register(X) ch, byte* zp(7) at)
print_char_at: {
    .label at = 7
    // *(at) = ch
    // [39] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (at),y
    // print_char_at::@return
    // }
    // [40] return 
    rts
}
  // File Data
  print_hextab: .text "0123456789abcdef"

