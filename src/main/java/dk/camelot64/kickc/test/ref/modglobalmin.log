byte cnt = 0;
byte[256] SCREEN=$0400;

main();

void main() {
  inccnt();
  SCREEN[0]=cnt++;
  inccnt();
  SCREEN[1]=++cnt;
}

void inccnt() {
    ++cnt;
}




Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
PROGRAM
  (byte) cnt ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
proc (void()) main()
  (void~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  (void~) main::$1 ← call inccnt 
  (byte) cnt ← ++ (byte) cnt
  *((byte[256]) SCREEN + (byte) 1) ← (byte) cnt
main::@return:
  return 
endproc // main()
proc (void()) inccnt()
  (byte) cnt ← ++ (byte) cnt
inccnt::@return:
  return 
endproc // inccnt()

SYMBOLS
(void~) $0
(byte[256]) SCREEN
(byte) cnt
(void()) inccnt()
(label) inccnt::@return
(void()) main()
(void~) main::$0
(void~) main::$1
(label) main::@return

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) cnt ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@1
main: scope:[main]  from
  (void~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  (void~) main::$1 ← call inccnt 
  (byte) cnt ← ++ (byte) cnt
  *((byte[256]) SCREEN + (byte) 1) ← (byte) cnt
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
@1: scope:[]  from @begin
  to:@2
inccnt: scope:[inccnt]  from
  (byte) cnt ← ++ (byte) cnt
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

Removing empty block @1
Removing empty block @2
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) cnt ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@end
main: scope:[main]  from
  (void~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  (void~) main::$1 ← call inccnt 
  (byte) cnt ← ++ (byte) cnt
  *((byte[256]) SCREEN + (byte) 1) ← (byte) cnt
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
inccnt: scope:[inccnt]  from
  (byte) cnt ← ++ (byte) cnt
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @begin

PROCEDURE MODIFY VARIABLE ANALYSIS
main modifies cnt
inccnt modifies cnt

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  (byte) cnt ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt ← (byte) cnt
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) cnt ← (byte) cnt
  *((byte[256]) SCREEN + (byte) 0) ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  *((byte[256]) SCREEN + (byte) 1) ← (byte) cnt
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt ← (byte) cnt
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt ← ++ (byte) cnt
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt ← (byte) cnt
  return 
  to:@return
@end: scope:[]  from @3

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) cnt#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt#9 ← phi( @begin/(byte) cnt#0 )
  (byte) cnt#1 ← (byte) cnt#9
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(byte[256]) SCREEN#0 )
  (byte) cnt#15 ← phi( @begin/(byte) cnt#0 )
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt#10 ← phi( main/(byte) cnt#15 )
  (byte) cnt#2 ← (byte) cnt#10
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte) cnt#2
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt#11 ← phi( main::@1/(byte) cnt#3 )
  (byte) cnt#4 ← (byte) cnt#11
  (byte) cnt#5 ← ++ (byte) cnt#4
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte) cnt#5
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt#12 ← phi( main::@2/(byte) cnt#5 )
  (byte) cnt#6 ← (byte) cnt#12
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) cnt#15 main::@1/(byte) cnt#3 )
  (byte) cnt#7 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt#14 ← phi( inccnt/(byte) cnt#7 )
  (byte) cnt#8 ← (byte) cnt#14
  return 
  to:@return
@end: scope:[]  from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (byte) cnt#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt#9 ← phi( @begin/(byte) cnt#6 )
  (byte) cnt#1 ← (byte) cnt#9
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(byte[256]) SCREEN#0 )
  (byte) cnt#15 ← phi( @begin/(byte) cnt#0 )
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt#10 ← phi( main/(byte) cnt#8 )
  (byte) cnt#2 ← (byte) cnt#10
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte) cnt#2
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt#11 ← phi( main::@1/(byte) cnt#8 )
  (byte) cnt#4 ← (byte) cnt#11
  (byte) cnt#5 ← ++ (byte) cnt#4
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte) cnt#5
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt#12 ← phi( main::@2/(byte) cnt#5 )
  (byte) cnt#6 ← (byte) cnt#12
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) cnt#15 main::@1/(byte) cnt#3 )
  (byte) cnt#7 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt#14 ← phi( inccnt/(byte) cnt#7 )
  (byte) cnt#8 ← (byte) cnt#14
  return 
  to:@return
@end: scope:[]  from @3

INITIAL SSA SYMBOL TABLE
(label) @3
(label) @begin
(label) @end
(byte[256]) SCREEN
(byte[256]) SCREEN#0
(byte[256]) SCREEN#1
(byte[256]) SCREEN#2
(byte[256]) SCREEN#3
(byte) cnt
(byte) cnt#0
(byte) cnt#1
(byte) cnt#10
(byte) cnt#11
(byte) cnt#12
(byte) cnt#13
(byte) cnt#14
(byte) cnt#15
(byte) cnt#2
(byte) cnt#3
(byte) cnt#4
(byte) cnt#5
(byte) cnt#6
(byte) cnt#7
(byte) cnt#8
(byte) cnt#9
(void()) inccnt()
(label) inccnt::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return

Alias (byte) cnt#1 = (byte) cnt#9 (byte) cnt#6 (byte) cnt#12 (byte) cnt#5 
Alias (byte) cnt#0 = (byte) cnt#15 
Alias (byte[256]) SCREEN#0 = (byte[256]) SCREEN#3 (byte[256]) SCREEN#1 (byte[256]) SCREEN#2 
Alias (byte) cnt#10 = (byte) cnt#8 (byte) cnt#2 (byte) cnt#11 (byte) cnt#4 (byte) cnt#14 (byte) cnt#7 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) cnt#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((byte[256]) SCREEN#0 + (byte) 0) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((byte[256]) SCREEN#0 + (byte) 1) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) cnt#0 main::@1/(byte) cnt#3 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @3

Constant (const byte) cnt#0 = 0
Constant (const byte[256]) SCREEN#0 = 1024
Succesful SSA optimization Pass2ConstantIdentification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((const byte[256]) SCREEN#0 + (byte) 0) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((const byte[256]) SCREEN#0 + (byte) 1) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(const byte) cnt#0 main::@1/(byte) cnt#3 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @3

Consolidated assigned array index constant in assignment *(SCREEN#0+0)
Consolidated assigned array index constant in assignment *(SCREEN#0+1)
Succesful SSA optimization Pass2ConstantAdditionElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(const byte) cnt#0 main::@1/(byte) cnt#3 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @3

Culled Empty Block (label) @3
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(const byte) cnt#0 main::@1/(byte) cnt#3 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @begin

Inlining constant with var siblings (const byte) cnt#0
Inlining constant with var siblings (const byte) cnt#0
Inlining constant with var siblings (const byte) cnt#0
Inlining constant with var siblings (const byte) cnt#0
Constant inlined cnt#0 = (byte) 0
Succesful SSA optimization Pass2ConstantInlining
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @begin

FINAL SYMBOL TABLE
(label) @begin
(label) @end
(byte[256]) SCREEN
(const byte[256]) SCREEN#0 = (word) 1024
(byte) cnt
(byte) cnt#1
(byte) cnt#10
(byte) cnt#13
(byte) cnt#3
(void()) inccnt()
(label) inccnt::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return

Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  call main param-assignment
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  (byte~) cnt#16 ← (byte) cnt#3
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte~) cnt#16 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return

Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to 0:main 
Calls in [main] to 2:inccnt 6:inccnt 

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES FOUND
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  [1] phi() [ ]
  [2] call inccnt param-assignment [ cnt#10 ]
  to:main::@1
main::@1: scope:[main]  from main
  [3] *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10 [ cnt#10 ]
  [4] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ]
  [5] (byte~) cnt#16 ← (byte) cnt#3 [ cnt#16 ]
  [6] call inccnt param-assignment [ cnt#10 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [7] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ]
  [8] *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1 [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [9] return  [ ]
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  [10] (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte~) cnt#16 ) [ cnt#13 ]
  [11] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ]
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  [12] return  [ cnt#10 ]
  to:@return

Created 1 initial phi equivalence classes
Coalesced [5] cnt#16 ← cnt#3
Coalesced down to 1 phi equivalence classes
Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
Adding NOP phi() at start of main
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  [1] phi() [ ]
  [2] call inccnt param-assignment [ cnt#10 ]
  to:main::@1
main::@1: scope:[main]  from main
  [3] *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10 [ cnt#10 ]
  [4] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ]
  [5] call inccnt param-assignment [ cnt#10 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [6] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ]
  [7] *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1 [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [8] return  [ ]
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  [9] (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 ) [ cnt#13 ]
  [10] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ]
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  [11] return  [ cnt#10 ]
  to:@return

DOMINATORS
@begin dominated by  @begin 
@end dominated by  @end @begin 
main dominated by  @begin main 
main::@1 dominated by  @begin main::@1 main 
main::@2 dominated by  @begin main::@2 main::@1 main 
main::@return dominated by  main::@return @begin main::@2 main::@1 main 
inccnt dominated by  inccnt @begin main 
inccnt::@return dominated by  inccnt::@return inccnt @begin main 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [main]
Found 0 loops in scope [inccnt]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1 4.0
(byte) cnt#10 1.6
(byte) cnt#13 4.0
(byte) cnt#3 4.0
(void()) inccnt()
(void()) main()

Initial phi equivalence classes
[ cnt#13 cnt#3 ]
Added variable cnt#1 to zero page equivalence class [ cnt#1 ]
Added variable cnt#10 to zero page equivalence class [ cnt#10 ]
Complete equivalence classes
[ cnt#13 cnt#3 ]
[ cnt#1 ]
[ cnt#10 ]
Allocated zp ZP_BYTE:2 [ cnt#13 cnt#3 ]
Allocated zp ZP_BYTE:3 [ cnt#1 ]
Allocated zp ZP_BYTE:4 [ cnt#10 ]
INITIAL ASM
//SEG0 Global Constants & labels
  .const SCREEN = $400
  .label cnt = 3
  .label cnt_3 = 2
  .label cnt_10 = 4
  .label cnt_13 = 2
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main [phi:@begin->main]
main_from_bbegin:
  jsr main
  jmp bend
//SEG4 @end
bend:
//SEG5 main
main: {
  //SEG6 [2] call inccnt param-assignment [ cnt#10 ]
  //SEG7 [9] phi from main to inccnt [phi:main->inccnt]
  inccnt_from_main:
  //SEG8 [9] phi (byte) cnt#13 = (byte) 0 [phi:main->inccnt#0] -- zpby1=coby1 
    lda #0
    sta cnt_13
    jsr inccnt
    jmp b1
  //SEG9 main::@1
  b1:
  //SEG10 [3] *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10 [ cnt#10 ] -- _star_cowo1=zpby1 
    lda cnt_10
    sta SCREEN+0
  //SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ] -- zpby1=_inc_zpby2 
    lda cnt_10
    sta cnt_3
    inc cnt_3
  //SEG12 [5] call inccnt param-assignment [ cnt#10 ]
  //SEG13 [9] phi from main::@1 to inccnt [phi:main::@1->inccnt]
  inccnt_from_b1:
  //SEG14 [9] phi (byte) cnt#13 = (byte) cnt#3 [phi:main::@1->inccnt#0] -- register_copy 
    jsr inccnt
    jmp b2
  //SEG15 main::@2
  b2:
  //SEG16 [6] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ] -- zpby1=_inc_zpby2 
    lda cnt_10
    sta cnt
    inc cnt
  //SEG17 [7] *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1 [ ] -- _star_cowo1=zpby1 
    lda cnt
    sta SCREEN+1
    jmp breturn
  //SEG18 main::@return
  breturn:
  //SEG19 [8] return  [ ]
    rts
}
//SEG20 inccnt
inccnt: {
  //SEG21 [10] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ] -- zpby1=_inc_zpby2 
    lda cnt_13
    sta cnt_10
    inc cnt_10
    jmp breturn
  //SEG22 inccnt::@return
  breturn:
  //SEG23 [11] return  [ cnt#10 ]
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp ZP_BYTE:2 [ cnt#13 cnt#3 ] : zp ZP_BYTE:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ cnt#1 ] : zp ZP_BYTE:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ cnt#10 ] : zp ZP_BYTE:4 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 8: zp ZP_BYTE:2 [ cnt#13 cnt#3 ] 4: zp ZP_BYTE:3 [ cnt#1 ] 1.6: zp ZP_BYTE:4 [ cnt#10 ] 
Uplift Scope [main] 
Uplift Scope [inccnt] 

Uplifting [] best 61 combination reg byte x [ cnt#13 cnt#3 ] reg byte x [ cnt#1 ] reg byte x [ cnt#10 ] 
Uplifting [main] best 61 combination 
Uplifting [inccnt] best 61 combination 
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 Global Constants & labels
  .const SCREEN = $400
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main [phi:@begin->main]
main_from_bbegin:
  jsr main
//SEG4 @end
bend:
//SEG5 main
main: {
  //SEG6 [2] call inccnt param-assignment [ cnt#10 ]
  //SEG7 [9] phi from main to inccnt [phi:main->inccnt]
  inccnt_from_main:
  //SEG8 [9] phi (byte) cnt#13 = (byte) 0 [phi:main->inccnt#0] -- xby=coby1 
    ldx #0
    jsr inccnt
  //SEG9 main::@1
  b1:
  //SEG10 [3] *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10 [ cnt#10 ] -- _star_cowo1=xby 
    stx SCREEN+0
  //SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ] -- xby=_inc_xby 
    inx
  //SEG12 [5] call inccnt param-assignment [ cnt#10 ]
  //SEG13 [9] phi from main::@1 to inccnt [phi:main::@1->inccnt]
  inccnt_from_b1:
  //SEG14 [9] phi (byte) cnt#13 = (byte) cnt#3 [phi:main::@1->inccnt#0] -- register_copy 
    jsr inccnt
  //SEG15 main::@2
  b2:
  //SEG16 [6] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ] -- xby=_inc_xby 
    inx
  //SEG17 [7] *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1 [ ] -- _star_cowo1=xby 
    stx SCREEN+1
  //SEG18 main::@return
  breturn:
  //SEG19 [8] return  [ ]
    rts
}
//SEG20 inccnt
inccnt: {
  //SEG21 [10] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ] -- xby=_inc_xby 
    inx
  //SEG22 inccnt::@return
  breturn:
  //SEG23 [11] return  [ cnt#10 ]
    rts
}

Removing instruction main_from_bbegin:
Succesful ASM optimization Pass5RedundantLabelElimination
ASSEMBLER
//SEG0 Global Constants & labels
  .const SCREEN = $400
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main [phi:@begin->main]
  jsr main
//SEG4 @end
bend:
//SEG5 main
main: {
  //SEG6 [2] call inccnt param-assignment [ cnt#10 ]
  //SEG7 [9] phi from main to inccnt [phi:main->inccnt]
  inccnt_from_main:
  //SEG8 [9] phi (byte) cnt#13 = (byte) 0 [phi:main->inccnt#0] -- xby=coby1 
    ldx #0
    jsr inccnt
  //SEG9 main::@1
  b1:
  //SEG10 [3] *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10 [ cnt#10 ] -- _star_cowo1=xby 
    stx SCREEN+0
  //SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ] -- xby=_inc_xby 
    inx
  //SEG12 [5] call inccnt param-assignment [ cnt#10 ]
  //SEG13 [9] phi from main::@1 to inccnt [phi:main::@1->inccnt]
  inccnt_from_b1:
  //SEG14 [9] phi (byte) cnt#13 = (byte) cnt#3 [phi:main::@1->inccnt#0] -- register_copy 
    jsr inccnt
  //SEG15 main::@2
  b2:
  //SEG16 [6] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ] -- xby=_inc_xby 
    inx
  //SEG17 [7] *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1 [ ] -- _star_cowo1=xby 
    stx SCREEN+1
  //SEG18 main::@return
  breturn:
  //SEG19 [8] return  [ ]
    rts
}
//SEG20 inccnt
inccnt: {
  //SEG21 [10] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ] -- xby=_inc_xby 
    inx
  //SEG22 inccnt::@return
  breturn:
  //SEG23 [11] return  [ cnt#10 ]
    rts
}

Removing instruction bbegin:
Removing instruction bend:
Removing instruction inccnt_from_main:
Removing instruction b1:
Removing instruction inccnt_from_b1:
Removing instruction b2:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
ASSEMBLER
//SEG0 Global Constants & labels
  .const SCREEN = $400
//SEG1 @begin
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main [phi:@begin->main]
  jsr main
//SEG4 @end
//SEG5 main
main: {
  //SEG6 [2] call inccnt param-assignment [ cnt#10 ]
  //SEG7 [9] phi from main to inccnt [phi:main->inccnt]
  //SEG8 [9] phi (byte) cnt#13 = (byte) 0 [phi:main->inccnt#0] -- xby=coby1 
    ldx #0
    jsr inccnt
  //SEG9 main::@1
  //SEG10 [3] *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10 [ cnt#10 ] -- _star_cowo1=xby 
    stx SCREEN+0
  //SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ] -- xby=_inc_xby 
    inx
  //SEG12 [5] call inccnt param-assignment [ cnt#10 ]
  //SEG13 [9] phi from main::@1 to inccnt [phi:main::@1->inccnt]
  //SEG14 [9] phi (byte) cnt#13 = (byte) cnt#3 [phi:main::@1->inccnt#0] -- register_copy 
    jsr inccnt
  //SEG15 main::@2
  //SEG16 [6] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ] -- xby=_inc_xby 
    inx
  //SEG17 [7] *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1 [ ] -- _star_cowo1=xby 
    stx SCREEN+1
  //SEG18 main::@return
  //SEG19 [8] return  [ ]
    rts
}
//SEG20 inccnt
inccnt: {
  //SEG21 [10] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ] -- xby=_inc_xby 
    inx
  //SEG22 inccnt::@return
  //SEG23 [11] return  [ cnt#10 ]
    rts
}

FINAL SYMBOL TABLE
(label) @begin
(label) @end
(byte[256]) SCREEN
(const byte[256]) SCREEN#0 SCREEN = (word) 1024
(byte) cnt
(byte) cnt#1 reg byte x 4.0
(byte) cnt#10 reg byte x 1.6
(byte) cnt#13 reg byte x 4.0
(byte) cnt#3 reg byte x 4.0
(void()) inccnt()
(label) inccnt::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return

reg byte x [ cnt#13 cnt#3 ]
reg byte x [ cnt#1 ]
reg byte x [ cnt#10 ]

FINAL CODE
//SEG0 Global Constants & labels
  .const SCREEN = $400
//SEG1 @begin
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main [phi:@begin->main]
  jsr main
//SEG4 @end
//SEG5 main
main: {
  //SEG6 [2] call inccnt param-assignment [ cnt#10 ]
  //SEG7 [9] phi from main to inccnt [phi:main->inccnt]
  //SEG8 [9] phi (byte) cnt#13 = (byte) 0 [phi:main->inccnt#0] -- xby=coby1 
    ldx #0
    jsr inccnt
  //SEG9 main::@1
  //SEG10 [3] *((const byte[256]) SCREEN#0+(byte) 0) ← (byte) cnt#10 [ cnt#10 ] -- _star_cowo1=xby 
    stx SCREEN+0
  //SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ] -- xby=_inc_xby 
    inx
  //SEG12 [5] call inccnt param-assignment [ cnt#10 ]
  //SEG13 [9] phi from main::@1 to inccnt [phi:main::@1->inccnt]
  //SEG14 [9] phi (byte) cnt#13 = (byte) cnt#3 [phi:main::@1->inccnt#0] -- register_copy 
    jsr inccnt
  //SEG15 main::@2
  //SEG16 [6] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ] -- xby=_inc_xby 
    inx
  //SEG17 [7] *((const byte[256]) SCREEN#0+(byte) 1) ← (byte) cnt#1 [ ] -- _star_cowo1=xby 
    stx SCREEN+1
  //SEG18 main::@return
  //SEG19 [8] return  [ ]
    rts
}
//SEG20 inccnt
inccnt: {
  //SEG21 [10] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ] -- xby=_inc_xby 
    inx
  //SEG22 inccnt::@return
  //SEG23 [11] return  [ cnt#10 ]
    rts
}

