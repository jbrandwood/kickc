Identified constant variable (byte*) SCREEN
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @5
Culled Empty Block (label) keyboard_matrix_read::@1
Culled Empty Block (label) @6
Culled Empty Block (label) keyboard_key_pressed::@1
Culled Empty Block (label) @7
Culled Empty Block (label) @8
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@6
Culled Empty Block (label) @12
Culled Empty Block (label) menu::@7
Culled Empty Block (label) menu::@3
Culled Empty Block (label) menu::@8
Culled Empty Block (label) menu::@10
Culled Empty Block (label) menu::@12
Culled Empty Block (label) menu::@14
Culled Empty Block (label) menu::@15
Culled Empty Block (label) @13
Culled Empty Block (label) pressed::@5
Culled Empty Block (label) pressed::@3
Culled Empty Block (label) pressed::@6
Culled Empty Block (label) pressed::@4
Culled Empty Block (label) pressed::@7
Culled Empty Block (label) pressed::@8
Culled Empty Block (label) pressed::@9

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@4
@4: scope:[]  from @begin
  (byte[8]) keyboard_matrix_row_bitmask ← { (number) $fe, (number) $fd, (number) $fb, (number) $f7, (number) $ef, (number) $df, (number) $bf, (number) $7f }
  (byte[8]) keyboard_matrix_col_bitmask ← { (number) 1, (number) 2, (number) 4, (number) 8, (number) $10, (number) $20, (number) $40, (number) $80 }
  to:@14

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  (byte) keyboard_matrix_read::rowid#1 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::rowid#0 )
  *((const byte*) CIA1_PORT_A) ← *((byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#1)
  (byte~) keyboard_matrix_read::$0 ← ~ *((const byte*) CIA1_PORT_B)
  (byte) keyboard_matrix_read::row_pressed_bits#0 ← (byte~) keyboard_matrix_read::$0
  (byte) keyboard_matrix_read::return#0 ← (byte) keyboard_matrix_read::row_pressed_bits#0
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  (byte) keyboard_matrix_read::return#3 ← phi( keyboard_matrix_read/(byte) keyboard_matrix_read::return#0 )
  (byte) keyboard_matrix_read::return#1 ← (byte) keyboard_matrix_read::return#3
  return 
  to:@return

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from menu::@2 menu::@4 menu::@5 pressed::@2
  (byte) keyboard_key_pressed::key#4 ← phi( menu::@2/(byte) keyboard_key_pressed::key#0 menu::@4/(byte) keyboard_key_pressed::key#1 menu::@5/(byte) keyboard_key_pressed::key#2 pressed::@2/(byte) keyboard_key_pressed::key#3 )
  (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#4 & (number) 7
  (byte) keyboard_key_pressed::colidx#0 ← (number~) keyboard_key_pressed::$0
  (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#4 >> (number) 3
  (byte) keyboard_key_pressed::rowidx#0 ← (byte~) keyboard_key_pressed::$1
  (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  call keyboard_matrix_read 
  (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#1
  to:keyboard_key_pressed::@2
keyboard_key_pressed::@2: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  (byte) keyboard_key_pressed::colidx#1 ← phi( keyboard_key_pressed/(byte) keyboard_key_pressed::colidx#0 )
  (byte) keyboard_matrix_read::return#4 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::return#2 )
  (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#4
  (byte~) keyboard_key_pressed::$3 ← (byte~) keyboard_key_pressed::$2 & *((byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#1)
  (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$3
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@2
  (byte) keyboard_key_pressed::return#6 ← phi( keyboard_key_pressed::@2/(byte) keyboard_key_pressed::return#0 )
  (byte) keyboard_key_pressed::return#1 ← (byte) keyboard_key_pressed::return#6
  return 
  to:@return

(void()) main()
main: scope:[main]  from @14
  *((const byte*) BORDERCOL) ← (const byte) GREEN
  to:main::@1
main::@1: scope:[main]  from main main::@7
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  call menu 
  to:main::@7
main::@7: scope:[main]  from main::@2
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return

(void()) menu()
menu: scope:[menu]  from main::@2
  to:menu::@1
menu::@1: scope:[menu]  from menu menu::@6
  if(true) goto menu::@2
  to:menu::@return
menu::@2: scope:[menu]  from menu::@1
  (byte) keyboard_key_pressed::key#0 ← (const byte) KEY_C
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#1
  to:menu::@16
menu::@16: scope:[menu]  from menu::@2
  (byte) keyboard_key_pressed::return#7 ← phi( menu::@2/(byte) keyboard_key_pressed::return#2 )
  (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#7
  (bool~) menu::$1 ← (byte~) menu::$0 != (number) 0
  (bool~) menu::$2 ← ! (bool~) menu::$1
  if((bool~) menu::$2) goto menu::@4
  to:menu::@9
menu::@4: scope:[menu]  from menu::@16
  (byte) keyboard_key_pressed::key#1 ← (const byte) KEY_I
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#1
  to:menu::@17
menu::@17: scope:[menu]  from menu::@4
  (byte) keyboard_key_pressed::return#8 ← phi( menu::@4/(byte) keyboard_key_pressed::return#3 )
  (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#8
  (bool~) menu::$5 ← (byte~) menu::$4 != (number) 0
  (bool~) menu::$6 ← ! (bool~) menu::$5
  if((bool~) menu::$6) goto menu::@5
  to:menu::@11
menu::@9: scope:[menu]  from menu::@16
  call pressed 
  to:menu::@18
menu::@18: scope:[menu]  from menu::@9
  to:menu::@return
menu::@return: scope:[menu]  from menu::@1 menu::@11 menu::@13 menu::@18
  return 
  to:@return
menu::@5: scope:[menu]  from menu::@17
  (byte) keyboard_key_pressed::key#2 ← (const byte) KEY_E
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#1
  to:menu::@19
menu::@19: scope:[menu]  from menu::@5
  (byte) keyboard_key_pressed::return#9 ← phi( menu::@5/(byte) keyboard_key_pressed::return#4 )
  (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#9
  (bool~) menu::$8 ← (byte~) menu::$7 != (number) 0
  (bool~) menu::$9 ← ! (bool~) menu::$8
  if((bool~) menu::$9) goto menu::@6
  to:menu::@13
menu::@11: scope:[menu]  from menu::@17
  *((const byte*) BORDERCOL) ← (const byte) RED
  asm { sei  }
  to:menu::@return
menu::@6: scope:[menu]  from menu::@19
  *((const byte*) SCREEN) ← ++ *((const byte*) SCREEN)
  to:menu::@1
menu::@13: scope:[menu]  from menu::@19
  *((const byte*) BORDERCOL) ← (const byte) GREEN
  asm { cli  }
  to:menu::@return

(void()) pressed()
pressed: scope:[pressed]  from menu::@9
  *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL)
  to:pressed::@1
pressed::@1: scope:[pressed]  from pressed pressed::@10
  if(true) goto pressed::@2
  to:pressed::@return
pressed::@2: scope:[pressed]  from pressed::@1
  (byte) keyboard_key_pressed::key#3 ← (const byte) KEY_SPACE
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#5 ← (byte) keyboard_key_pressed::return#1
  to:pressed::@10
pressed::@10: scope:[pressed]  from pressed::@2
  (byte) keyboard_key_pressed::return#10 ← phi( pressed::@2/(byte) keyboard_key_pressed::return#5 )
  (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10
  (bool~) pressed::$2 ← (byte~) pressed::$1 != (number) 0
  (bool~) pressed::$3 ← ! (bool~) pressed::$2
  if((bool~) pressed::$3) goto pressed::@1
  to:pressed::@return
pressed::@return: scope:[pressed]  from pressed::@1 pressed::@10
  return 
  to:@return
@14: scope:[]  from @4
  call main 
  to:@15
@15: scope:[]  from @14
  to:@end
@end: scope:[]  from @15

SYMBOL TABLE SSA
(label) @14
(label) @15
(label) @4
(label) @begin
(label) @end
(const byte*) BGCOL = (byte*)(number) $d021
(const byte*) BORDERCOL = (byte*)(number) $d020
(const byte*) CIA1_PORT_A = (byte*)(number) $dc00
(const byte*) CIA1_PORT_B = (byte*)(number) $dc01
(const byte) GREEN = (number) 5
(const byte) KEY_C = (number) $14
(const byte) KEY_E = (number) $e
(const byte) KEY_I = (number) $21
(const byte) KEY_SPACE = (number) $3c
(const byte) RED = (number) 2
(const byte*) SCREEN = (byte*)(number) $400
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(number~) keyboard_key_pressed::$0
(byte~) keyboard_key_pressed::$1
(byte~) keyboard_key_pressed::$2
(byte~) keyboard_key_pressed::$3
(label) keyboard_key_pressed::@2
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0
(byte) keyboard_key_pressed::colidx#1
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0
(byte) keyboard_key_pressed::key#1
(byte) keyboard_key_pressed::key#2
(byte) keyboard_key_pressed::key#3
(byte) keyboard_key_pressed::key#4
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0
(byte) keyboard_key_pressed::return#1
(byte) keyboard_key_pressed::return#10
(byte) keyboard_key_pressed::return#2
(byte) keyboard_key_pressed::return#3
(byte) keyboard_key_pressed::return#4
(byte) keyboard_key_pressed::return#5
(byte) keyboard_key_pressed::return#6
(byte) keyboard_key_pressed::return#7
(byte) keyboard_key_pressed::return#8
(byte) keyboard_key_pressed::return#9
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0
(byte[8]) keyboard_matrix_col_bitmask
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte~) keyboard_matrix_read::$0
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0
(byte) keyboard_matrix_read::return#1
(byte) keyboard_matrix_read::return#2
(byte) keyboard_matrix_read::return#3
(byte) keyboard_matrix_read::return#4
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::row_pressed_bits#0
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0
(byte) keyboard_matrix_read::rowid#1
(byte[8]) keyboard_matrix_row_bitmask
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@7
(label) main::@return
(void()) menu()
(byte~) menu::$0
(bool~) menu::$1
(bool~) menu::$2
(byte~) menu::$4
(bool~) menu::$5
(bool~) menu::$6
(byte~) menu::$7
(bool~) menu::$8
(bool~) menu::$9
(label) menu::@1
(label) menu::@11
(label) menu::@13
(label) menu::@16
(label) menu::@17
(label) menu::@18
(label) menu::@19
(label) menu::@2
(label) menu::@4
(label) menu::@5
(label) menu::@6
(label) menu::@9
(label) menu::@return
(void()) pressed()
(byte~) pressed::$1
(bool~) pressed::$2
(bool~) pressed::$3
(label) pressed::@1
(label) pressed::@10
(label) pressed::@2
(label) pressed::@return

Adding number conversion cast (unumber) 7 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#4 & (number) 7
Adding number conversion cast (unumber) keyboard_key_pressed::$0 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#4 & (unumber)(number) 7
Adding number conversion cast (unumber) 3 in (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#4 >> (number) 3
Adding number conversion cast (unumber) 0 in (bool~) menu::$1 ← (byte~) menu::$0 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) menu::$5 ← (byte~) menu::$4 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) menu::$8 ← (byte~) menu::$7 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) pressed::$2 ← (byte~) pressed::$1 != (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Added casts to value list in (byte[8]) keyboard_matrix_row_bitmask ← (byte[8]){ (byte)(number) $fe, (byte)(number) $fd, (byte)(number) $fb, (byte)(number) $f7, (byte)(number) $ef, (byte)(number) $df, (byte)(number) $bf, (byte)(number) $7f }
Added casts to value list in (byte[8]) keyboard_matrix_col_bitmask ← (byte[8]){ (byte)(number) 1, (byte)(number) 2, (byte)(number) 4, (byte)(number) 8, (byte)(number) $10, (byte)(number) $20, (byte)(number) $40, (byte)(number) $80 }
Successful SSA optimization PassNAddInitializerValueListTypeCasts
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53281
Simplifying constant pointer cast (byte*) 56320
Simplifying constant pointer cast (byte*) 56321
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $fe
Simplifying constant integer cast $fd
Simplifying constant integer cast $fb
Simplifying constant integer cast $f7
Simplifying constant integer cast $ef
Simplifying constant integer cast $df
Simplifying constant integer cast $bf
Simplifying constant integer cast $7f
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 8
Simplifying constant integer cast $10
Simplifying constant integer cast $20
Simplifying constant integer cast $40
Simplifying constant integer cast $80
Simplifying constant integer cast 7
Simplifying constant integer cast 3
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7
Inversing boolean not [36] (bool~) menu::$2 ← (byte~) menu::$0 == (byte) 0 from [35] (bool~) menu::$1 ← (byte~) menu::$0 != (byte) 0
Inversing boolean not [44] (bool~) menu::$6 ← (byte~) menu::$4 == (byte) 0 from [43] (bool~) menu::$5 ← (byte~) menu::$4 != (byte) 0
Inversing boolean not [54] (bool~) menu::$9 ← (byte~) menu::$7 == (byte) 0 from [53] (bool~) menu::$8 ← (byte~) menu::$7 != (byte) 0
Inversing boolean not [69] (bool~) pressed::$3 ← (byte~) pressed::$1 == (byte) 0 from [68] (bool~) pressed::$2 ← (byte~) pressed::$1 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte) keyboard_matrix_read::return#0 = (byte) keyboard_matrix_read::row_pressed_bits#0 (byte~) keyboard_matrix_read::$0 (byte) keyboard_matrix_read::return#3 (byte) keyboard_matrix_read::return#1 
Alias (byte) keyboard_key_pressed::colidx#0 = (byte~) keyboard_key_pressed::$0 (byte) keyboard_key_pressed::colidx#1 
Alias (byte) keyboard_key_pressed::rowidx#0 = (byte~) keyboard_key_pressed::$1 
Alias (byte) keyboard_matrix_read::return#2 = (byte) keyboard_matrix_read::return#4 
Alias (byte) keyboard_key_pressed::return#0 = (byte~) keyboard_key_pressed::$3 (byte) keyboard_key_pressed::return#6 (byte) keyboard_key_pressed::return#1 
Alias (byte) keyboard_key_pressed::return#2 = (byte) keyboard_key_pressed::return#7 
Alias (byte) keyboard_key_pressed::return#3 = (byte) keyboard_key_pressed::return#8 
Alias (byte) keyboard_key_pressed::return#4 = (byte) keyboard_key_pressed::return#9 
Alias (byte) keyboard_key_pressed::return#10 = (byte) keyboard_key_pressed::return#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) keyboard_matrix_read::rowid#1 (byte) keyboard_matrix_read::rowid#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) menu::$2 [37] if((byte~) menu::$0==(byte) 0) goto menu::@4
Simple Condition (bool~) menu::$6 [45] if((byte~) menu::$4==(byte) 0) goto menu::@5
Simple Condition (bool~) menu::$9 [55] if((byte~) menu::$7==(byte) 0) goto menu::@6
Simple Condition (bool~) pressed::$3 [70] if((byte~) pressed::$1==(byte) 0) goto pressed::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [70] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Identified constant from value list (byte[8]) { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
Identified constant from value list (byte[8]) { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
Successful SSA optimization Pass2ConstantInitializerValueLists
Constant (const byte[8]) keyboard_matrix_row_bitmask = { $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f }
Constant (const byte[8]) keyboard_matrix_col_bitmask = { 1, 2, 4, 8, $10, $20, $40, $80 }
Constant (const byte) keyboard_key_pressed::key#0 = KEY_C
Constant (const byte) keyboard_key_pressed::key#1 = KEY_I
Constant (const byte) keyboard_key_pressed::key#2 = KEY_E
Constant (const byte) keyboard_key_pressed::key#3 = KEY_SPACE
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [26] if(true) goto main::@2
if() condition always true - replacing block destination [29] if(true) goto menu::@2
if() condition always true - replacing block destination [62] if(true) goto pressed::@2
Successful SSA optimization Pass2ConstantIfs
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#0
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#1
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#2
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#3
Constant inlined keyboard_key_pressed::key#0 = (const byte) KEY_C
Constant inlined keyboard_key_pressed::key#1 = (const byte) KEY_I
Constant inlined keyboard_key_pressed::key#2 = (const byte) KEY_E
Constant inlined keyboard_key_pressed::key#3 = (const byte) KEY_SPACE
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @14
Adding NOP phi() at start of @15
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of menu
Adding NOP phi() at start of menu::@1
Adding NOP phi() at start of menu::@2
Adding NOP phi() at start of menu::@9
Adding NOP phi() at start of menu::@18
Adding NOP phi() at start of menu::@4
Adding NOP phi() at start of menu::@5
Adding NOP phi() at start of pressed::@1
Adding NOP phi() at start of pressed::@2
CALL GRAPH
Calls in [] to main:3 
Calls in [main] to menu:9 
Calls in [menu] to keyboard_key_pressed:14 pressed:19 keyboard_key_pressed:23 keyboard_key_pressed:30 
Calls in [keyboard_key_pressed] to keyboard_matrix_read:41 
Calls in [pressed] to keyboard_key_pressed:52 

Created 1 initial phi equivalence classes
Coalesced down to 1 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @15
Culled Empty Block (label) main::@1
Culled Empty Block (label) main::@7
Culled Empty Block (label) menu::@1
Culled Empty Block (label) menu::@18
Culled Empty Block (label) pressed::@1
Renumbering block @14 to @1
Renumbering block keyboard_key_pressed::@2 to keyboard_key_pressed::@1
Renumbering block main::@2 to main::@1
Renumbering block menu::@2 to menu::@1
Renumbering block menu::@4 to menu::@2
Renumbering block menu::@5 to menu::@3
Renumbering block menu::@6 to menu::@4
Renumbering block menu::@9 to menu::@5
Renumbering block menu::@11 to menu::@6
Renumbering block menu::@13 to menu::@7
Renumbering block menu::@16 to menu::@8
Renumbering block menu::@17 to menu::@9
Renumbering block menu::@19 to menu::@10
Renumbering block pressed::@2 to pressed::@1
Renumbering block pressed::@10 to pressed::@2
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of menu
Adding NOP phi() at start of menu::@1
Adding NOP phi() at start of menu::@5
Adding NOP phi() at start of menu::@2
Adding NOP phi() at start of menu::@3
Adding NOP phi() at start of pressed::@1

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] *((const byte*) BORDERCOL) ← (const byte) GREEN
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [5] phi()
  [6] call menu 
  to:main::@1

(void()) menu()
menu: scope:[menu]  from main::@1
  [7] phi()
  to:menu::@1
menu::@1: scope:[menu]  from menu menu::@4
  [8] phi()
  [9] call keyboard_key_pressed 
  [10] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
  to:menu::@8
menu::@8: scope:[menu]  from menu::@1
  [11] (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#2
  [12] if((byte~) menu::$0==(byte) 0) goto menu::@2
  to:menu::@5
menu::@5: scope:[menu]  from menu::@8
  [13] phi()
  [14] call pressed 
  to:menu::@return
menu::@return: scope:[menu]  from menu::@5 menu::@6 menu::@7
  [15] return 
  to:@return
menu::@2: scope:[menu]  from menu::@8
  [16] phi()
  [17] call keyboard_key_pressed 
  [18] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0
  to:menu::@9
menu::@9: scope:[menu]  from menu::@2
  [19] (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#3
  [20] if((byte~) menu::$4==(byte) 0) goto menu::@3
  to:menu::@6
menu::@6: scope:[menu]  from menu::@9
  [21] *((const byte*) BORDERCOL) ← (const byte) RED
  asm { sei  }
  to:menu::@return
menu::@3: scope:[menu]  from menu::@9
  [23] phi()
  [24] call keyboard_key_pressed 
  [25] (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#0
  to:menu::@10
menu::@10: scope:[menu]  from menu::@3
  [26] (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#4
  [27] if((byte~) menu::$7==(byte) 0) goto menu::@4
  to:menu::@7
menu::@7: scope:[menu]  from menu::@10
  [28] *((const byte*) BORDERCOL) ← (const byte) GREEN
  asm { cli  }
  to:menu::@return
menu::@4: scope:[menu]  from menu::@10
  [30] *((const byte*) SCREEN) ← ++ *((const byte*) SCREEN)
  to:menu::@1

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from menu::@1 menu::@2 menu::@3 pressed::@1
  [31] (byte) keyboard_key_pressed::key#4 ← phi( menu::@1/(const byte) KEY_C menu::@2/(const byte) KEY_I menu::@3/(const byte) KEY_E pressed::@1/(const byte) KEY_SPACE )
  [32] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7
  [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3
  [34] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  [35] call keyboard_matrix_read 
  [36] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  [37] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
  [38] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0)
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  [39] return 
  to:@return

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  [40] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#0)
  [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B)
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  [42] return 
  to:@return

(void()) pressed()
pressed: scope:[pressed]  from menu::@5
  [43] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL)
  to:pressed::@1
pressed::@1: scope:[pressed]  from pressed pressed::@2
  [44] phi()
  [45] call keyboard_key_pressed 
  [46] (byte) keyboard_key_pressed::return#10 ← (byte) keyboard_key_pressed::return#0
  to:pressed::@2
pressed::@2: scope:[pressed]  from pressed::@1
  [47] (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10
  [48] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return
  to:pressed::@1
pressed::@return: scope:[pressed]  from pressed::@2
  [49] return 
  to:@return

null depth in calling loop Loop head: pressed::@1 tails: pressed::@2 blocks: pressed::@2 pressed::@1  in scope keyboard_key_pressed

VARIABLE REGISTER WEIGHTS
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 4.0
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0 0.6666666666666666
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#4 2.0
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 67.66666666666667
(byte) keyboard_key_pressed::return#10 202.0
(byte) keyboard_key_pressed::return#2 202.0
(byte) keyboard_key_pressed::return#3 202.0
(byte) keyboard_key_pressed::return#4 202.0
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0 4.0
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 1.3333333333333333
(byte) keyboard_matrix_read::return#2 4.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0 4.0
(void()) main()
(void()) menu()
(byte~) menu::$0 202.0
(byte~) menu::$4 202.0
(byte~) menu::$7 202.0
(void()) pressed()
(byte~) pressed::$1 202.0

Initial phi equivalence classes
[ keyboard_key_pressed::key#4 ]
Added variable keyboard_key_pressed::return#2 to zero page equivalence class [ keyboard_key_pressed::return#2 ]
Added variable menu::$0 to zero page equivalence class [ menu::$0 ]
Added variable keyboard_key_pressed::return#3 to zero page equivalence class [ keyboard_key_pressed::return#3 ]
Added variable menu::$4 to zero page equivalence class [ menu::$4 ]
Added variable keyboard_key_pressed::return#4 to zero page equivalence class [ keyboard_key_pressed::return#4 ]
Added variable menu::$7 to zero page equivalence class [ menu::$7 ]
Added variable keyboard_key_pressed::colidx#0 to zero page equivalence class [ keyboard_key_pressed::colidx#0 ]
Added variable keyboard_key_pressed::rowidx#0 to zero page equivalence class [ keyboard_key_pressed::rowidx#0 ]
Added variable keyboard_matrix_read::rowid#0 to zero page equivalence class [ keyboard_matrix_read::rowid#0 ]
Added variable keyboard_matrix_read::return#2 to zero page equivalence class [ keyboard_matrix_read::return#2 ]
Added variable keyboard_key_pressed::$2 to zero page equivalence class [ keyboard_key_pressed::$2 ]
Added variable keyboard_key_pressed::return#0 to zero page equivalence class [ keyboard_key_pressed::return#0 ]
Added variable keyboard_matrix_read::return#0 to zero page equivalence class [ keyboard_matrix_read::return#0 ]
Added variable keyboard_key_pressed::return#10 to zero page equivalence class [ keyboard_key_pressed::return#10 ]
Added variable pressed::$1 to zero page equivalence class [ pressed::$1 ]
Complete equivalence classes
[ keyboard_key_pressed::key#4 ]
[ keyboard_key_pressed::return#2 ]
[ menu::$0 ]
[ keyboard_key_pressed::return#3 ]
[ menu::$4 ]
[ keyboard_key_pressed::return#4 ]
[ menu::$7 ]
[ keyboard_key_pressed::colidx#0 ]
[ keyboard_key_pressed::rowidx#0 ]
[ keyboard_matrix_read::rowid#0 ]
[ keyboard_matrix_read::return#2 ]
[ keyboard_key_pressed::$2 ]
[ keyboard_key_pressed::return#0 ]
[ keyboard_matrix_read::return#0 ]
[ keyboard_key_pressed::return#10 ]
[ pressed::$1 ]
Allocated zp[1]:2 [ keyboard_key_pressed::key#4 ]
Allocated zp[1]:3 [ keyboard_key_pressed::return#2 ]
Allocated zp[1]:4 [ menu::$0 ]
Allocated zp[1]:5 [ keyboard_key_pressed::return#3 ]
Allocated zp[1]:6 [ menu::$4 ]
Allocated zp[1]:7 [ keyboard_key_pressed::return#4 ]
Allocated zp[1]:8 [ menu::$7 ]
Allocated zp[1]:9 [ keyboard_key_pressed::colidx#0 ]
Allocated zp[1]:10 [ keyboard_key_pressed::rowidx#0 ]
Allocated zp[1]:11 [ keyboard_matrix_read::rowid#0 ]
Allocated zp[1]:12 [ keyboard_matrix_read::return#2 ]
Allocated zp[1]:13 [ keyboard_key_pressed::$2 ]
Allocated zp[1]:14 [ keyboard_key_pressed::return#0 ]
Allocated zp[1]:15 [ keyboard_matrix_read::return#0 ]
Allocated zp[1]:16 [ keyboard_key_pressed::return#10 ]
Allocated zp[1]:17 [ pressed::$1 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Exploring keyboard glitch that finds "C" press when pressing space
// The glitch is caused by the "normal" C64 interrupt occuring just as the keyboard is read.
// Press "I" to disable interrupts (red border)
// Press "E" to enable interrupts (green border)
// Press "C" to enter pressed state (increaded bgcol) - and "SPACE" to leave presssed state again.
// Holding SPACE will sometimes trigger the pressed state when normal interrupts are enabled (green border)
// but never when they are disabled (red border)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label BORDERCOL = $d020
  .label BGCOL = $d021
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  .const RED = 2
  .const GREEN = 5
  .const KEY_E = $e
  .const KEY_C = $14
  .const KEY_I = $21
  .const KEY_SPACE = $3c
  .label SCREEN = $400
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // [4] *((const byte*) BORDERCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // [5] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
  __b1_from_main:
  __b1_from___b1:
    jmp __b1
    // main::@1
  __b1:
    // [6] call menu 
    // [7] phi from main::@1 to menu [phi:main::@1->menu]
  menu_from___b1:
    jsr menu
    jmp __b1_from___b1
}
  // menu
menu: {
    .label __0 = 4
    .label __4 = 6
    .label __7 = 8
    // [8] phi from menu menu::@4 to menu::@1 [phi:menu/menu::@4->menu::@1]
  __b1_from_menu:
  __b1_from___b4:
    jmp __b1
    // menu::@1
  __b1:
    // [9] call keyboard_key_pressed 
    // [31] phi from menu::@1 to keyboard_key_pressed [phi:menu::@1->keyboard_key_pressed]
  keyboard_key_pressed_from___b1:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_C [phi:menu::@1->keyboard_key_pressed#0] -- vbuz1=vbuc1 
    lda #KEY_C
    sta.z keyboard_key_pressed.key
    jsr keyboard_key_pressed
    // [10] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_1
    jmp __b8
    // menu::@8
  __b8:
    // [11] (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_1
    sta.z __0
    // [12] if((byte~) menu::$0==(byte) 0) goto menu::@2 -- vbuz1_eq_0_then_la1 
    lda.z __0
    cmp #0
    beq __b2_from___b8
    // [13] phi from menu::@8 to menu::@5 [phi:menu::@8->menu::@5]
  __b5_from___b8:
    jmp __b5
    // menu::@5
  __b5:
    // [14] call pressed 
    jsr pressed
    jmp __breturn
    // menu::@return
  __breturn:
    // [15] return 
    rts
    // [16] phi from menu::@8 to menu::@2 [phi:menu::@8->menu::@2]
  __b2_from___b8:
    jmp __b2
    // menu::@2
  __b2:
    // [17] call keyboard_key_pressed 
    // [31] phi from menu::@2 to keyboard_key_pressed [phi:menu::@2->keyboard_key_pressed]
  keyboard_key_pressed_from___b2:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_I [phi:menu::@2->keyboard_key_pressed#0] -- vbuz1=vbuc1 
    lda #KEY_I
    sta.z keyboard_key_pressed.key
    jsr keyboard_key_pressed
    // [18] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_2
    jmp __b9
    // menu::@9
  __b9:
    // [19] (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#3 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_2
    sta.z __4
    // [20] if((byte~) menu::$4==(byte) 0) goto menu::@3 -- vbuz1_eq_0_then_la1 
    lda.z __4
    cmp #0
    beq __b3_from___b9
    jmp __b6
    // menu::@6
  __b6:
    // [21] *((const byte*) BORDERCOL) ← (const byte) RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
    // asm { sei  }
    sei
    jmp __breturn
    // [23] phi from menu::@9 to menu::@3 [phi:menu::@9->menu::@3]
  __b3_from___b9:
    jmp __b3
    // menu::@3
  __b3:
    // [24] call keyboard_key_pressed 
    // [31] phi from menu::@3 to keyboard_key_pressed [phi:menu::@3->keyboard_key_pressed]
  keyboard_key_pressed_from___b3:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_E [phi:menu::@3->keyboard_key_pressed#0] -- vbuz1=vbuc1 
    lda #KEY_E
    sta.z keyboard_key_pressed.key
    jsr keyboard_key_pressed
    // [25] (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_3
    jmp __b10
    // menu::@10
  __b10:
    // [26] (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#4 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_3
    sta.z __7
    // [27] if((byte~) menu::$7==(byte) 0) goto menu::@4 -- vbuz1_eq_0_then_la1 
    lda.z __7
    cmp #0
    beq __b4
    jmp __b7
    // menu::@7
  __b7:
    // [28] *((const byte*) BORDERCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // asm { cli  }
    cli
    jmp __breturn
    // menu::@4
  __b4:
    // [30] *((const byte*) SCREEN) ← ++ *((const byte*) SCREEN) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN
    jmp __b1_from___b4
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte zeropage(2) key)
keyboard_key_pressed: {
    .label __2 = $d
    .label colidx = 9
    .label rowidx = $a
    .label return = $e
    .label return_1 = 3
    .label return_2 = 5
    .label return_3 = 7
    .label key = 2
    .label return_4 = $10
    // [32] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z key
    sta.z colidx
    // [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z key
    lsr
    lsr
    lsr
    sta.z rowidx
    // [34] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuz1=vbuz2 
    lda.z rowidx
    sta.z keyboard_matrix_read.rowid
    // [35] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [36] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return
    sta.z keyboard_matrix_read.return_1
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [37] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return_1
    sta.z __2
    // [38] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0) -- vbuz1=vbuz2_band_pbuc1_derefidx_vbuz3 
    lda.z __2
    ldy.z colidx
    and keyboard_matrix_col_bitmask,y
    sta.z return
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [39] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte zeropage($b) rowid)
keyboard_matrix_read: {
    .label return = $f
    .label rowid = $b
    .label return_1 = $c
    // [40] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#0) -- _deref_pbuc1=pbuc2_derefidx_vbuz1 
    ldy.z rowid
    lda keyboard_matrix_row_bitmask,y
    sta CIA1_PORT_A
    // [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuz1=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    sta.z return
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [42] return 
    rts
}
  // pressed
pressed: {
    .label __1 = $11
    // [43] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [44] phi from pressed pressed::@2 to pressed::@1 [phi:pressed/pressed::@2->pressed::@1]
  __b1_from_pressed:
  __b1_from___b2:
    jmp __b1
    // pressed::@1
  __b1:
    // [45] call keyboard_key_pressed 
    // [31] phi from pressed::@1 to keyboard_key_pressed [phi:pressed::@1->keyboard_key_pressed]
  keyboard_key_pressed_from___b1:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_SPACE [phi:pressed::@1->keyboard_key_pressed#0] -- vbuz1=vbuc1 
    lda #KEY_SPACE
    sta.z keyboard_key_pressed.key
    jsr keyboard_key_pressed
    // [46] (byte) keyboard_key_pressed::return#10 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_4
    jmp __b2
    // pressed::@2
  __b2:
    // [47] (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_4
    sta.z __1
    // [48] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return -- vbuz1_neq_0_then_la1 
    lda.z __1
    cmp #0
    bne __breturn
    jmp __b1_from___b2
    // pressed::@return
  __breturn:
    // [49] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [4] *((const byte*) BORDERCOL) ← (const byte) GREEN [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [21] *((const byte*) BORDERCOL) ← (const byte) RED [ ] ( main:2::menu:6 [ ] ) always clobbers reg byte a 
Statement [28] *((const byte*) BORDERCOL) ← (const byte) GREEN [ ] ( main:2::menu:6 [ ] ) always clobbers reg byte a 
Statement [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( main:2::menu:6::keyboard_key_pressed:9 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::keyboard_key_pressed:17 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::keyboard_key_pressed:24 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:9 [ keyboard_key_pressed::colidx#0 ]
Statement [40] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#0) [ ] ( main:2::menu:6::keyboard_key_pressed:9::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::keyboard_key_pressed:17::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::keyboard_key_pressed:24::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] ) always clobbers reg byte a 
Statement [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:2::menu:6::keyboard_key_pressed:9::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::keyboard_key_pressed:17::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::keyboard_key_pressed:24::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] ) always clobbers reg byte a 
Statement [4] *((const byte*) BORDERCOL) ← (const byte) GREEN [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [21] *((const byte*) BORDERCOL) ← (const byte) RED [ ] ( main:2::menu:6 [ ] ) always clobbers reg byte a 
Statement [28] *((const byte*) BORDERCOL) ← (const byte) GREEN [ ] ( main:2::menu:6 [ ] ) always clobbers reg byte a 
Statement [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( main:2::menu:6::keyboard_key_pressed:9 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::keyboard_key_pressed:17 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::keyboard_key_pressed:24 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ) always clobbers reg byte a 
Statement [40] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#0) [ ] ( main:2::menu:6::keyboard_key_pressed:9::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::keyboard_key_pressed:17::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::keyboard_key_pressed:24::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] ) always clobbers reg byte a 
Statement [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:2::menu:6::keyboard_key_pressed:9::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::keyboard_key_pressed:17::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::keyboard_key_pressed:24::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] ) always clobbers reg byte a 
Potential registers zp[1]:2 [ keyboard_key_pressed::key#4 ] : zp[1]:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ keyboard_key_pressed::return#2 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ menu::$0 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ keyboard_key_pressed::return#3 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ menu::$4 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ keyboard_key_pressed::return#4 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ menu::$7 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ keyboard_key_pressed::colidx#0 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ keyboard_key_pressed::rowidx#0 ] : zp[1]:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ keyboard_matrix_read::rowid#0 ] : zp[1]:11 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:12 [ keyboard_matrix_read::return#2 ] : zp[1]:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ keyboard_key_pressed::$2 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ keyboard_key_pressed::return#0 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ keyboard_matrix_read::return#0 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ keyboard_key_pressed::return#10 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ pressed::$1 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [keyboard_key_pressed] 202: zp[1]:3 [ keyboard_key_pressed::return#2 ] 202: zp[1]:5 [ keyboard_key_pressed::return#3 ] 202: zp[1]:7 [ keyboard_key_pressed::return#4 ] 202: zp[1]:16 [ keyboard_key_pressed::return#10 ] 67.67: zp[1]:14 [ keyboard_key_pressed::return#0 ] 4: zp[1]:10 [ keyboard_key_pressed::rowidx#0 ] 4: zp[1]:13 [ keyboard_key_pressed::$2 ] 2: zp[1]:2 [ keyboard_key_pressed::key#4 ] 0.67: zp[1]:9 [ keyboard_key_pressed::colidx#0 ] 
Uplift Scope [menu] 202: zp[1]:4 [ menu::$0 ] 202: zp[1]:6 [ menu::$4 ] 202: zp[1]:8 [ menu::$7 ] 
Uplift Scope [pressed] 202: zp[1]:17 [ pressed::$1 ] 
Uplift Scope [keyboard_matrix_read] 4: zp[1]:11 [ keyboard_matrix_read::rowid#0 ] 4: zp[1]:12 [ keyboard_matrix_read::return#2 ] 1.33: zp[1]:15 [ keyboard_matrix_read::return#0 ] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [keyboard_key_pressed] best 9851 combination reg byte a [ keyboard_key_pressed::return#2 ] reg byte a [ keyboard_key_pressed::return#3 ] reg byte a [ keyboard_key_pressed::return#4 ] reg byte a [ keyboard_key_pressed::return#10 ] zp[1]:14 [ keyboard_key_pressed::return#0 ] zp[1]:10 [ keyboard_key_pressed::rowidx#0 ] zp[1]:13 [ keyboard_key_pressed::$2 ] zp[1]:2 [ keyboard_key_pressed::key#4 ] zp[1]:9 [ keyboard_key_pressed::colidx#0 ] 
Limited combination testing to 100 combinations of 196608 possible.
Uplifting [menu] best 8051 combination reg byte a [ menu::$0 ] reg byte a [ menu::$4 ] reg byte a [ menu::$7 ] 
Uplifting [pressed] best 7451 combination reg byte a [ pressed::$1 ] 
Uplifting [keyboard_matrix_read] best 7433 combination reg byte x [ keyboard_matrix_read::rowid#0 ] reg byte a [ keyboard_matrix_read::return#2 ] reg byte a [ keyboard_matrix_read::return#0 ] 
Uplifting [main] best 7433 combination 
Uplifting [] best 7433 combination 
Attempting to uplift remaining variables inzp[1]:14 [ keyboard_key_pressed::return#0 ]
Uplifting [keyboard_key_pressed] best 6230 combination reg byte a [ keyboard_key_pressed::return#0 ] 
Attempting to uplift remaining variables inzp[1]:10 [ keyboard_key_pressed::rowidx#0 ]
Uplifting [keyboard_key_pressed] best 6226 combination reg byte a [ keyboard_key_pressed::rowidx#0 ] 
Attempting to uplift remaining variables inzp[1]:13 [ keyboard_key_pressed::$2 ]
Uplifting [keyboard_key_pressed] best 6220 combination reg byte a [ keyboard_key_pressed::$2 ] 
Attempting to uplift remaining variables inzp[1]:2 [ keyboard_key_pressed::key#4 ]
Uplifting [keyboard_key_pressed] best 6204 combination reg byte x [ keyboard_key_pressed::key#4 ] 
Attempting to uplift remaining variables inzp[1]:9 [ keyboard_key_pressed::colidx#0 ]
Uplifting [keyboard_key_pressed] best 6202 combination reg byte y [ keyboard_key_pressed::colidx#0 ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Exploring keyboard glitch that finds "C" press when pressing space
// The glitch is caused by the "normal" C64 interrupt occuring just as the keyboard is read.
// Press "I" to disable interrupts (red border)
// Press "E" to enable interrupts (green border)
// Press "C" to enter pressed state (increaded bgcol) - and "SPACE" to leave presssed state again.
// Holding SPACE will sometimes trigger the pressed state when normal interrupts are enabled (green border)
// but never when they are disabled (red border)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label BORDERCOL = $d020
  .label BGCOL = $d021
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  .const RED = 2
  .const GREEN = 5
  .const KEY_E = $e
  .const KEY_C = $14
  .const KEY_I = $21
  .const KEY_SPACE = $3c
  .label SCREEN = $400
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // [4] *((const byte*) BORDERCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // [5] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
  __b1_from_main:
  __b1_from___b1:
    jmp __b1
    // main::@1
  __b1:
    // [6] call menu 
    // [7] phi from main::@1 to menu [phi:main::@1->menu]
  menu_from___b1:
    jsr menu
    jmp __b1_from___b1
}
  // menu
menu: {
    // [8] phi from menu menu::@4 to menu::@1 [phi:menu/menu::@4->menu::@1]
  __b1_from_menu:
  __b1_from___b4:
    jmp __b1
    // menu::@1
  __b1:
    // [9] call keyboard_key_pressed 
    // [31] phi from menu::@1 to keyboard_key_pressed [phi:menu::@1->keyboard_key_pressed]
  keyboard_key_pressed_from___b1:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_C [phi:menu::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_C
    jsr keyboard_key_pressed
    // [10] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    jmp __b8
    // menu::@8
  __b8:
    // [11] (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#2
    // [12] if((byte~) menu::$0==(byte) 0) goto menu::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2_from___b8
    // [13] phi from menu::@8 to menu::@5 [phi:menu::@8->menu::@5]
  __b5_from___b8:
    jmp __b5
    // menu::@5
  __b5:
    // [14] call pressed 
    jsr pressed
    jmp __breturn
    // menu::@return
  __breturn:
    // [15] return 
    rts
    // [16] phi from menu::@8 to menu::@2 [phi:menu::@8->menu::@2]
  __b2_from___b8:
    jmp __b2
    // menu::@2
  __b2:
    // [17] call keyboard_key_pressed 
    // [31] phi from menu::@2 to keyboard_key_pressed [phi:menu::@2->keyboard_key_pressed]
  keyboard_key_pressed_from___b2:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_I [phi:menu::@2->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_I
    jsr keyboard_key_pressed
    // [18] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0
    jmp __b9
    // menu::@9
  __b9:
    // [19] (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#3
    // [20] if((byte~) menu::$4==(byte) 0) goto menu::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3_from___b9
    jmp __b6
    // menu::@6
  __b6:
    // [21] *((const byte*) BORDERCOL) ← (const byte) RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
    // asm { sei  }
    sei
    jmp __breturn
    // [23] phi from menu::@9 to menu::@3 [phi:menu::@9->menu::@3]
  __b3_from___b9:
    jmp __b3
    // menu::@3
  __b3:
    // [24] call keyboard_key_pressed 
    // [31] phi from menu::@3 to keyboard_key_pressed [phi:menu::@3->keyboard_key_pressed]
  keyboard_key_pressed_from___b3:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_E [phi:menu::@3->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_E
    jsr keyboard_key_pressed
    // [25] (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#0
    jmp __b10
    // menu::@10
  __b10:
    // [26] (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#4
    // [27] if((byte~) menu::$7==(byte) 0) goto menu::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    jmp __b7
    // menu::@7
  __b7:
    // [28] *((const byte*) BORDERCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // asm { cli  }
    cli
    jmp __breturn
    // menu::@4
  __b4:
    // [30] *((const byte*) SCREEN) ← ++ *((const byte*) SCREEN) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN
    jmp __b1_from___b4
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(X) key)
keyboard_key_pressed: {
    // [32] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7 -- vbuyy=vbuxx_band_vbuc1 
    txa
    and #7
    tay
    // [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 -- vbuaa=vbuxx_ror_3 
    txa
    lsr
    lsr
    lsr
    // [34] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuxx=vbuaa 
    tax
    // [35] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [36] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [37] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // [38] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuyy 
    and keyboard_matrix_col_bitmask,y
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [39] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(X) rowid)
keyboard_matrix_read: {
    // [40] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#0) -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda keyboard_matrix_row_bitmask,x
    sta CIA1_PORT_A
    // [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [42] return 
    rts
}
  // pressed
pressed: {
    // [43] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [44] phi from pressed pressed::@2 to pressed::@1 [phi:pressed/pressed::@2->pressed::@1]
  __b1_from_pressed:
  __b1_from___b2:
    jmp __b1
    // pressed::@1
  __b1:
    // [45] call keyboard_key_pressed 
    // [31] phi from pressed::@1 to keyboard_key_pressed [phi:pressed::@1->keyboard_key_pressed]
  keyboard_key_pressed_from___b1:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_SPACE [phi:pressed::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_SPACE
    jsr keyboard_key_pressed
    // [46] (byte) keyboard_key_pressed::return#10 ← (byte) keyboard_key_pressed::return#0
    jmp __b2
    // pressed::@2
  __b2:
    // [47] (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10
    // [48] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __breturn
    jmp __b1_from___b2
    // pressed::@return
  __breturn:
    // [49] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b8
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __b2
Removing instruction jmp __b9
Removing instruction jmp __b6
Removing instruction jmp __b3
Removing instruction jmp __b10
Removing instruction jmp __b7
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __bbegin with __b1
Replacing label __b1_from___b1 with __b1
Replacing label __b2_from___b8 with __b2
Replacing label __b3_from___b9 with __b3
Replacing label __b1_from___b4 with __b1
Replacing label __b1_from___b2 with __b1
Removing instruction __bbegin:
Removing instruction __b1_from___bbegin:
Removing instruction __bend_from___b1:
Removing instruction __b1_from_main:
Removing instruction __b1_from___b1:
Removing instruction menu_from___b1:
Removing instruction __b1_from_menu:
Removing instruction __b1_from___b4:
Removing instruction keyboard_key_pressed_from___b1:
Removing instruction __b5_from___b8:
Removing instruction __b2_from___b8:
Removing instruction keyboard_key_pressed_from___b2:
Removing instruction __b3_from___b9:
Removing instruction keyboard_key_pressed_from___b3:
Removing instruction __b1_from_pressed:
Removing instruction __b1_from___b2:
Removing instruction keyboard_key_pressed_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction __b8:
Removing instruction __b5:
Removing instruction __b9:
Removing instruction __b6:
Removing instruction __b10:
Removing instruction __b7:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Replacing jump to rts with rts in jmp __breturn
Replacing jump to rts with rts in jmp __breturn
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction __b1:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) BGCOL = (byte*) 53281
(const byte*) BORDERCOL = (byte*) 53280
(const byte*) CIA1_PORT_A = (byte*) 56320
(const byte*) CIA1_PORT_B = (byte*) 56321
(const byte) GREEN = (number) 5
(const byte) KEY_C = (number) $14
(const byte) KEY_E = (number) $e
(const byte) KEY_I = (number) $21
(const byte) KEY_SPACE = (number) $3c
(const byte) RED = (number) 2
(const byte*) SCREEN = (byte*) 1024
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 reg byte a 4.0
(label) keyboard_key_pressed::@1
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0 reg byte y 0.6666666666666666
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#4 reg byte x 2.0
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 reg byte a 67.66666666666667
(byte) keyboard_key_pressed::return#10 reg byte a 202.0
(byte) keyboard_key_pressed::return#2 reg byte a 202.0
(byte) keyboard_key_pressed::return#3 reg byte a 202.0
(byte) keyboard_key_pressed::return#4 reg byte a 202.0
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0 reg byte a 4.0
(const byte[8]) keyboard_matrix_col_bitmask = { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 reg byte a 1.3333333333333333
(byte) keyboard_matrix_read::return#2 reg byte a 4.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0 reg byte x 4.0
(const byte[8]) keyboard_matrix_row_bitmask = { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
(void()) main()
(label) main::@1
(void()) menu()
(byte~) menu::$0 reg byte a 202.0
(byte~) menu::$4 reg byte a 202.0
(byte~) menu::$7 reg byte a 202.0
(label) menu::@1
(label) menu::@10
(label) menu::@2
(label) menu::@3
(label) menu::@4
(label) menu::@5
(label) menu::@6
(label) menu::@7
(label) menu::@8
(label) menu::@9
(label) menu::@return
(void()) pressed()
(byte~) pressed::$1 reg byte a 202.0
(label) pressed::@1
(label) pressed::@2
(label) pressed::@return

reg byte x [ keyboard_key_pressed::key#4 ]
reg byte a [ keyboard_key_pressed::return#2 ]
reg byte a [ menu::$0 ]
reg byte a [ keyboard_key_pressed::return#3 ]
reg byte a [ menu::$4 ]
reg byte a [ keyboard_key_pressed::return#4 ]
reg byte a [ menu::$7 ]
reg byte y [ keyboard_key_pressed::colidx#0 ]
reg byte a [ keyboard_key_pressed::rowidx#0 ]
reg byte x [ keyboard_matrix_read::rowid#0 ]
reg byte a [ keyboard_matrix_read::return#2 ]
reg byte a [ keyboard_key_pressed::$2 ]
reg byte a [ keyboard_key_pressed::return#0 ]
reg byte a [ keyboard_matrix_read::return#0 ]
reg byte a [ keyboard_key_pressed::return#10 ]
reg byte a [ pressed::$1 ]


FINAL ASSEMBLER
Score: 3151

  // File Comments
// Exploring keyboard glitch that finds "C" press when pressing space
// The glitch is caused by the "normal" C64 interrupt occuring just as the keyboard is read.
// Press "I" to disable interrupts (red border)
// Press "E" to enable interrupts (green border)
// Press "C" to enter pressed state (increaded bgcol) - and "SPACE" to leave presssed state again.
// Holding SPACE will sometimes trigger the pressed state when normal interrupts are enabled (green border)
// but never when they are disabled (red border)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label BORDERCOL = $d020
  .label BGCOL = $d021
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  .const RED = 2
  .const GREEN = 5
  .const KEY_E = $e
  .const KEY_C = $14
  .const KEY_I = $21
  .const KEY_SPACE = $3c
  .label SCREEN = $400
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // *BORDERCOL = GREEN
    // [4] *((const byte*) BORDERCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // [5] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
    // main::@1
  __b1:
    // menu()
    // [6] call menu 
    // [7] phi from main::@1 to menu [phi:main::@1->menu]
    jsr menu
    jmp __b1
}
  // menu
menu: {
    // [8] phi from menu menu::@4 to menu::@1 [phi:menu/menu::@4->menu::@1]
    // menu::@1
  __b1:
    // keyboard_key_pressed(KEY_C)
    // [9] call keyboard_key_pressed 
    // [31] phi from menu::@1 to keyboard_key_pressed [phi:menu::@1->keyboard_key_pressed]
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_C [phi:menu::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_C
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_C)
    // [10] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    // menu::@8
    // [11] (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#2
    // if(keyboard_key_pressed(KEY_C)!=0)
    // [12] if((byte~) menu::$0==(byte) 0) goto menu::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // [13] phi from menu::@8 to menu::@5 [phi:menu::@8->menu::@5]
    // menu::@5
    // pressed()
    // [14] call pressed 
    jsr pressed
    // menu::@return
    // }
    // [15] return 
    rts
    // [16] phi from menu::@8 to menu::@2 [phi:menu::@8->menu::@2]
    // menu::@2
  __b2:
    // keyboard_key_pressed(KEY_I)
    // [17] call keyboard_key_pressed 
    // [31] phi from menu::@2 to keyboard_key_pressed [phi:menu::@2->keyboard_key_pressed]
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_I [phi:menu::@2->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_I
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_I)
    // [18] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0
    // menu::@9
    // [19] (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#3
    // if(keyboard_key_pressed(KEY_I)!=0)
    // [20] if((byte~) menu::$4==(byte) 0) goto menu::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3
    // menu::@6
    // *BORDERCOL = RED
    // [21] *((const byte*) BORDERCOL) ← (const byte) RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
    // asm
    // asm { sei  }
    sei
    rts
    // [23] phi from menu::@9 to menu::@3 [phi:menu::@9->menu::@3]
    // menu::@3
  __b3:
    // keyboard_key_pressed(KEY_E)
    // [24] call keyboard_key_pressed 
    // [31] phi from menu::@3 to keyboard_key_pressed [phi:menu::@3->keyboard_key_pressed]
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_E [phi:menu::@3->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_E
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_E)
    // [25] (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#0
    // menu::@10
    // [26] (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#4
    // if(keyboard_key_pressed(KEY_E)!=0)
    // [27] if((byte~) menu::$7==(byte) 0) goto menu::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    // menu::@7
    // *BORDERCOL = GREEN
    // [28] *((const byte*) BORDERCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // asm
    // asm { cli  }
    cli
    rts
    // menu::@4
  __b4:
    // (*SCREEN)++;
    // [30] *((const byte*) SCREEN) ← ++ *((const byte*) SCREEN) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(X) key)
keyboard_key_pressed: {
    // colidx = key&7
    // [32] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7 -- vbuyy=vbuxx_band_vbuc1 
    txa
    and #7
    tay
    // rowidx = key>>3
    // [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 -- vbuaa=vbuxx_ror_3 
    txa
    lsr
    lsr
    lsr
    // keyboard_matrix_read(rowidx)
    // [34] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuxx=vbuaa 
    tax
    // [35] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [36] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    // keyboard_key_pressed::@1
    // [37] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // keyboard_matrix_read(rowidx) & keyboard_matrix_col_bitmask[colidx]
    // [38] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuyy 
    and keyboard_matrix_col_bitmask,y
    // keyboard_key_pressed::@return
    // }
    // [39] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(X) rowid)
keyboard_matrix_read: {
    // *CIA1_PORT_A = keyboard_matrix_row_bitmask[rowid]
    // [40] *((const byte*) CIA1_PORT_A) ← *((const byte[8]) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#0) -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda keyboard_matrix_row_bitmask,x
    sta CIA1_PORT_A
    // ~*CIA1_PORT_B
    // [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    // keyboard_matrix_read::@return
    // }
    // [42] return 
    rts
}
  // pressed
pressed: {
    // (*BGCOL)++;
    // [43] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [44] phi from pressed pressed::@2 to pressed::@1 [phi:pressed/pressed::@2->pressed::@1]
    // pressed::@1
  __b1:
    // keyboard_key_pressed(KEY_SPACE)
    // [45] call keyboard_key_pressed 
    // [31] phi from pressed::@1 to keyboard_key_pressed [phi:pressed::@1->keyboard_key_pressed]
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_SPACE [phi:pressed::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_SPACE
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_SPACE)
    // [46] (byte) keyboard_key_pressed::return#10 ← (byte) keyboard_key_pressed::return#0
    // pressed::@2
    // [47] (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10
    // if(keyboard_key_pressed(KEY_SPACE)!=0)
    // [48] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __breturn
    jmp __b1
    // pressed::@return
  __breturn:
    // }
    // [49] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

