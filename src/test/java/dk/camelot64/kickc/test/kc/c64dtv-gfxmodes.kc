// Exploring C64DTV Screen Modes
import "c64dtv.kc"
import "print.kc"
import "keyboard.kc"

void main() {
    *DTV_FEATURE = DTV_FEATURE_ENABLE;
    while(true) {
        menu();
    }
}

const byte* MENU_SCREEN = $8000;
const byte* MENU_CHARSET = $9800; // Charset ROM
byte[] MENU_TEXT =
     "C64DTV Graphics Modes            EMBLHCC@" +
     "                                 CCMIIHO@" +
     "                                 MMMNCUL@" +
     "----------------------------------------@" +
     "1. Standard Char             (V) 0000000@" +
     "2. Extended Color Char       (V) 1000000@" +
     "3. Multicolor Char           (V) 0100000@" +
     "4. Standard Bitmap           (V) 0010000@" +
     "5. Multicolor Bitmap         (V) 0110000@" +
     "6. High Color Standard Char  (H) 0000100@" +
     "7. High Extended Color Char  (H) 1000100@" +
     "8. High Multicolor Char      (H) 0100100@" +
     "9. High Multicolor Bitmap    (H) 0110100@" +
     "a. Sixs Fred                 (D) 1111100@" +
     "b. Sixs Fred 2               (D) 1111000@" +
     "c. Two Plane Bitmap          (D) 1011100@" +
     "d. Two Plane Multicol Bitmap (D) 1111100@" +
     "e. 8bpp Pixel Cell           (D) 1101110@" +
     "f. Chunky 8bpp Bitmap        (D) 1101111@" +
     "----------------------------------------@" +
     "    (V) vicII (H) vicII+hicol (D) c64dtv@" +
     "@" ;

void menu() {
    // DTV Graphics Bank
    *DTV_GRAPHICS_VIC_BANK = (byte)((dword)MENU_CHARSET/$10000);
    // DTV Graphics Mode
    *DTV_CONTROL = 0;
    // VIC Graphics Bank
    *CIA2_PORT_A_DDR = %00000011; // Set VIC Bank bits to output - all others to input
    *CIA2_PORT_A = %00000011 ^ (byte)((word)MENU_CHARSET/$4000); // Set VIC Bank
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_CSEL;
    // VIC Memory Pointers
    *VIC_MEMORY =  (byte)((((word)MENU_SCREEN&$3fff)/$40)|(((word)MENU_CHARSET&$3fff)/$400));
    // Char Colors
    for(byte* c=COLS;c!=COLS+1000;c++) *c=LIGHT_GREEN;
    // Screen colors
    *BGCOL = 0;
    *BORDERCOL = 0;
    // Display menu Text
    print_set_screen(MENU_SCREEN);
    print_cls();
    print_str_lines(MENU_TEXT);
    // Wait for key press
    while(true) {
        if(keyboard_key_pressed(KEY_C)!=0) {
            mode_twoplanebitmap();
            return;
        }
        byte* last = MENU_SCREEN+999;
        (*last)++;
    }

}

const byte* TWOPLANE_PLANEA = $4000;
const byte* TWOPLANE_PLANEB = $6000;

// Test the Two Plane Bitmap - generated from the two DTV linear graphics plane counters
// Two Plane Bitmap Mode (CHUNK/COLDIS/MCM = 0, ECM/BMM/HICOL/LINEAR = 1)
void mode_twoplanebitmap() {
    // DTV Graphics Mode
    *DTV_CONTROL = DTV_CONTROL_HIGHCOLOR_ON | DTV_CONTROL_LINEAR_ADDRESSING_ON;
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_ECM|VIC_BMM|VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_CSEL;
    // Linear Graphics Plane A Counter
    *DTV_PLANEA_START_LO = <TWOPLANE_PLANEA;
    *DTV_PLANEA_START_MI = >TWOPLANE_PLANEA;
    *DTV_PLANEA_START_HI = 0;
    *DTV_PLANEA_STEP = 1;
    *DTV_PLANEA_MODULO_LO = 0;
    *DTV_PLANEA_MODULO_HI = 0;
    // Linear Graphics Plane B Counter
    *DTV_PLANEB_START_LO = <TWOPLANE_PLANEB;
    *DTV_PLANEB_START_MI = >TWOPLANE_PLANEB;
    *DTV_PLANEB_START_HI = 0;
    *DTV_PLANEB_STEP = 1;
    *DTV_PLANEB_MODULO_LO = 0;
    *DTV_PLANEB_MODULO_HI = 0;

    // Screen colors
    *BORDERCOL = 0;
    *BGCOL1 = GREEN; // Color for bits 00
    *BGCOL2 = BLUE; // Color for bits 11
    // Colors for bits 01 / 10
    for(byte* c=COLS;c!=COLS+1000;c++) *c= <c;
    // Graphics for Plane A - horizontal stripes
    byte* gfxa = TWOPLANE_PLANEA;
    for(byte ay : 0..199) {
        for (byte ax : 0..39) {
            if((ay&4)==0) {
                *gfxa++ = $00;
            } else {
                *gfxa++ = $ff;
            }
        }
    }
    // Graphics for Plane B - vertical stripes
    byte* gfxb = TWOPLANE_PLANEB;
    for(byte by : 0..199) {
        for ( byte bx : 0..39) {
            *gfxb++ = $0f;
        }
    }
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }

}

