Resolved forward reference MEMORYBLOCK_4000 to (const nomodify byte) MEMORYBLOCK_4000
Resolved forward reference MEMORYBLOCK_8000 to (const nomodify byte) MEMORYBLOCK_8000
Resolved forward reference MEMORYBLOCK_4000 to (const nomodify byte) MEMORYBLOCK_4000
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 

CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from __start
  (byte) memoryRemapBlock::blockPage#0 ← (number) $40
  (word) memoryRemapBlock::memoryPage#0 ← (number) $100
  call memoryRemapBlock 
  to:main::@1
main::@1: scope:[main]  from main
  *((const byte*) main::block1 + (number) 0) ← (number) $55
  *((const byte*) main::block1 + (number) 1) ← (number) $aa
  (byte) memoryRemapBlock::blockPage#1 ← (number) $80
  (word) memoryRemapBlock::memoryPage#1 ← (number) $100
  call memoryRemapBlock 
  to:main::@2
main::@2: scope:[main]  from main::@1
  *((const byte*) main::block2 + (number) 2) ← (number) $55
  *((const byte*) main::block2 + (number) 3) ← (number) $aa
  (byte~) main::$2 ← (const nomodify byte) MEMORYBLOCK_4000 | (const nomodify byte) MEMORYBLOCK_8000
  (byte) memoryRemap::remapBlocks#0 ← (byte~) main::$2
  (word) memoryRemap::lowerPageOffset#0 ← (number) $c0
  (word) memoryRemap::upperPageOffset#0 ← (number) $80
  call memoryRemap 
  to:main::@3
main::@3: scope:[main]  from main::@2
  *((const byte*) main::block2 + (number) 4) ← *((const byte*) main::block1 + (number) 2)
  *((const byte*) main::block1 + (number) 5) ← *((const byte*) main::block2 + (number) 1)
  (byte) memoryRemap256M::remapBlocks#0 ← (const nomodify byte) MEMORYBLOCK_4000
  (dword) memoryRemap256M::lowerPageOffset#0 ← (number) $ff800-(number) $40
  (dword) memoryRemap256M::upperPageOffset#0 ← (number) 0
  call memoryRemap256M 
  to:main::@4
main::@4: scope:[main]  from main::@3
  *((const byte*) main::block1 + (number) 0) ← (number) 0
  *((const byte*) main::block1 + (number) 1) ← (number) 1
  (byte) memoryRemap256M::remapBlocks#1 ← (number) 0
  (dword) memoryRemap256M::lowerPageOffset#1 ← (number) 0
  (dword) memoryRemap256M::upperPageOffset#1 ← (number) 0
  call memoryRemap256M 
  to:main::@5
main::@5: scope:[main]  from main::@4
  to:main::@return
main::@return: scope:[main]  from main::@5
  return 
  to:@return

(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main::@2 memoryRemapBlock
  (word) memoryRemap::upperPageOffset#2 ← phi( main::@2/(word) memoryRemap::upperPageOffset#0 memoryRemapBlock/(word) memoryRemap::upperPageOffset#1 )
  (byte) memoryRemap::remapBlocks#2 ← phi( main::@2/(byte) memoryRemap::remapBlocks#0 memoryRemapBlock/(byte) memoryRemap::remapBlocks#1 )
  (word) memoryRemap::lowerPageOffset#2 ← phi( main::@2/(word) memoryRemap::lowerPageOffset#0 memoryRemapBlock/(word) memoryRemap::lowerPageOffset#1 )
  (byte~) memoryRemap::$0 ← < (word) memoryRemap::lowerPageOffset#2
  *((const byte*) memoryRemap::aVal) ← (byte~) memoryRemap::$0
  (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#2 << (number) 4
  (byte~) memoryRemap::$2 ← > (word) memoryRemap::lowerPageOffset#2
  (number~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (number) $f
  (number~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (number~) memoryRemap::$3
  *((const byte*) memoryRemap::xVal) ← (number~) memoryRemap::$4
  (byte~) memoryRemap::$5 ← < (word) memoryRemap::upperPageOffset#2
  *((const byte*) memoryRemap::yVal) ← (byte~) memoryRemap::$5
  (number~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (number) $f0
  (byte~) memoryRemap::$7 ← > (word) memoryRemap::upperPageOffset#2
  (number~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (number) $f
  (number~) memoryRemap::$9 ← (number~) memoryRemap::$6 | (number~) memoryRemap::$8
  *((const byte*) memoryRemap::zVal) ← (number~) memoryRemap::$9
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  return 
  to:@return

(void()) memoryRemapBlock((byte) memoryRemapBlock::blockPage , (word) memoryRemapBlock::memoryPage)
memoryRemapBlock: scope:[memoryRemapBlock]  from main main::@1
  (byte) memoryRemapBlock::blockPage#2 ← phi( main/(byte) memoryRemapBlock::blockPage#0 main::@1/(byte) memoryRemapBlock::blockPage#1 )
  (word) memoryRemapBlock::memoryPage#2 ← phi( main/(word) memoryRemapBlock::memoryPage#0 main::@1/(word) memoryRemapBlock::memoryPage#1 )
  (word~) memoryRemapBlock::$0 ← (word) memoryRemapBlock::memoryPage#2 - (byte) memoryRemapBlock::blockPage#2
  (word) memoryRemapBlock::pageOffset#0 ← (word~) memoryRemapBlock::$0
  (number~) memoryRemapBlock::$1 ← (byte) memoryRemapBlock::blockPage#2 / (number) $20
  (byte) memoryRemapBlock::block#0 ← (number~) memoryRemapBlock::$1
  (number~) memoryRemapBlock::$2 ← (number) 1 << (byte) memoryRemapBlock::block#0
  (byte) memoryRemapBlock::blockBits#0 ← (number~) memoryRemapBlock::$2
  (byte) memoryRemap::remapBlocks#1 ← (byte) memoryRemapBlock::blockBits#0
  (word) memoryRemap::lowerPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0
  (word) memoryRemap::upperPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0
  call memoryRemap 
  to:memoryRemapBlock::@1
memoryRemapBlock::@1: scope:[memoryRemapBlock]  from memoryRemapBlock
  to:memoryRemapBlock::@return
memoryRemapBlock::@return: scope:[memoryRemapBlock]  from memoryRemapBlock::@1
  return 
  to:@return

(void()) memoryRemap256M((byte) memoryRemap256M::remapBlocks , (dword) memoryRemap256M::lowerPageOffset , (dword) memoryRemap256M::upperPageOffset)
memoryRemap256M: scope:[memoryRemap256M]  from main::@3 main::@4
  (byte) memoryRemap256M::remapBlocks#2 ← phi( main::@3/(byte) memoryRemap256M::remapBlocks#0 main::@4/(byte) memoryRemap256M::remapBlocks#1 )
  (dword) memoryRemap256M::upperPageOffset#2 ← phi( main::@3/(dword) memoryRemap256M::upperPageOffset#0 main::@4/(dword) memoryRemap256M::upperPageOffset#1 )
  (dword) memoryRemap256M::lowerPageOffset#2 ← phi( main::@3/(dword) memoryRemap256M::lowerPageOffset#0 main::@4/(dword) memoryRemap256M::lowerPageOffset#1 )
  (dword~) memoryRemap256M::$0 ← (dword) memoryRemap256M::lowerPageOffset#2 >> (number) 4
  (byte~) memoryRemap256M::$1 ← > (word)(dword~) memoryRemap256M::$0
  *((const byte*) memoryRemap256M::lMb) ← (byte~) memoryRemap256M::$1
  (dword~) memoryRemap256M::$2 ← (dword) memoryRemap256M::upperPageOffset#2 >> (number) 4
  (byte~) memoryRemap256M::$3 ← > (word)(dword~) memoryRemap256M::$2
  *((const byte*) memoryRemap256M::uMb) ← (byte~) memoryRemap256M::$3
  (word~) memoryRemap256M::$4 ← < (dword) memoryRemap256M::lowerPageOffset#2
  (byte~) memoryRemap256M::$5 ← < (word~) memoryRemap256M::$4
  *((const byte*) memoryRemap256M::aVal) ← (byte~) memoryRemap256M::$5
  (byte~) memoryRemap256M::$6 ← (byte) memoryRemap256M::remapBlocks#2 << (number) 4
  (word~) memoryRemap256M::$7 ← < (dword) memoryRemap256M::lowerPageOffset#2
  (byte~) memoryRemap256M::$8 ← > (word~) memoryRemap256M::$7
  (number~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (number) $f
  (number~) memoryRemap256M::$10 ← (byte~) memoryRemap256M::$6 | (number~) memoryRemap256M::$9
  *((const byte*) memoryRemap256M::xVal) ← (number~) memoryRemap256M::$10
  (word~) memoryRemap256M::$11 ← < (dword) memoryRemap256M::upperPageOffset#2
  (byte~) memoryRemap256M::$12 ← < (word~) memoryRemap256M::$11
  *((const byte*) memoryRemap256M::yVal) ← (byte~) memoryRemap256M::$12
  (number~) memoryRemap256M::$13 ← (byte) memoryRemap256M::remapBlocks#2 & (number) $f0
  (word~) memoryRemap256M::$14 ← < (dword) memoryRemap256M::upperPageOffset#2
  (byte~) memoryRemap256M::$15 ← > (word~) memoryRemap256M::$14
  (number~) memoryRemap256M::$16 ← (byte~) memoryRemap256M::$15 & (number) $f
  (number~) memoryRemap256M::$17 ← (number~) memoryRemap256M::$13 | (number~) memoryRemap256M::$16
  *((const byte*) memoryRemap256M::zVal) ← (number~) memoryRemap256M::$17
  asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap256M::@return
memoryRemap256M::@return: scope:[memoryRemap256M]  from memoryRemap256M
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
(byte) MEGA65_VICIV::ALPHADELAY
(byte) MEGA65_VICIV::B0PIX
(byte) MEGA65_VICIV::B0_ADDR
(byte) MEGA65_VICIV::B1PIX
(byte) MEGA65_VICIV::B1_ADDR
(byte) MEGA65_VICIV::B2PIX
(byte) MEGA65_VICIV::B2_ADDR
(byte) MEGA65_VICIV::B3PIX
(byte) MEGA65_VICIV::B3_ADDR
(byte) MEGA65_VICIV::B4PIX
(byte) MEGA65_VICIV::B4_ADDR
(byte) MEGA65_VICIV::B5PIX
(byte) MEGA65_VICIV::B5_ADDR
(byte) MEGA65_VICIV::B6PIX
(byte) MEGA65_VICIV::B6_ADDR
(byte) MEGA65_VICIV::B7PIX
(byte) MEGA65_VICIV::B7_ADDR
(byte) MEGA65_VICIV::BBDRPOS_HI
(byte) MEGA65_VICIV::BBDRPOS_LO
(byte) MEGA65_VICIV::BG_COLOR
(byte) MEGA65_VICIV::BG_COLOR1
(byte) MEGA65_VICIV::BG_COLOR2
(byte) MEGA65_VICIV::BG_COLOR3
(byte) MEGA65_VICIV::BORDER_COLOR
(byte) MEGA65_VICIV::BP16ENS
(byte) MEGA65_VICIV::BPCOMP
(byte) MEGA65_VICIV::BPX
(byte) MEGA65_VICIV::BPY
(byte) MEGA65_VICIV::CHARPTR_HILO
(byte) MEGA65_VICIV::CHARPTR_LOHI
(byte) MEGA65_VICIV::CHARPTR_LOLO
(byte) MEGA65_VICIV::CHARSTEP_HI
(byte) MEGA65_VICIV::CHARSTEP_LO
(byte) MEGA65_VICIV::CHRCOUNT
(byte) MEGA65_VICIV::CHRXSCL
(byte) MEGA65_VICIV::CHRYSCL
(byte) MEGA65_VICIV::COLPTR_HI
(byte) MEGA65_VICIV::COLPTR_LO
(byte) MEGA65_VICIV::CONTROL1
(byte) MEGA65_VICIV::CONTROL2
(byte) MEGA65_VICIV::CONTROLA
(byte) MEGA65_VICIV::CONTROLB
(byte) MEGA65_VICIV::CONTROLC
(byte) MEGA65_VICIV::DEBUG1
(byte) MEGA65_VICIV::DEBUGX
(byte) MEGA65_VICIV::DEBUGXY
(byte) MEGA65_VICIV::DEBUGY
(byte) MEGA65_VICIV::FNRASTER_HI
(byte) MEGA65_VICIV::FNRASTER_LO
(byte) MEGA65_VICIV::HPOS
(byte) MEGA65_VICIV::IRQ_ENABLE
(byte) MEGA65_VICIV::IRQ_STATUS
(byte) MEGA65_VICIV::KEY
(byte) MEGA65_VICIV::LIGHTPEN_X
(byte) MEGA65_VICIV::LIGHTPEN_Y
(byte) MEGA65_VICIV::MEMORY
(byte) MEGA65_VICIV::PALSEL
(byte) MEGA65_VICIV::RASLINE0
(byte) MEGA65_VICIV::RASTER
(byte) MEGA65_VICIV::ROWCOUNT
(byte) MEGA65_VICIV::RSTCMP
(byte) MEGA65_VICIV::RSTCOMP
(byte) MEGA65_VICIV::SBPDEBUG
(byte) MEGA65_VICIV::SCRNPTR_HIHI
(byte) MEGA65_VICIV::SCRNPTR_HILO
(byte) MEGA65_VICIV::SCRNPTR_LOHI
(byte) MEGA65_VICIV::SCRNPTR_LOLO
(byte) MEGA65_VICIV::SIDBDRWD_HI
(byte) MEGA65_VICIV::SIDBDRWD_LO
(byte) MEGA65_VICIV::SPR16EN
(byte) MEGA65_VICIV::SPRALPHAVAL
(byte) MEGA65_VICIV::SPRENALPHA
(byte) MEGA65_VICIV::SPRENV400
(byte) MEGA65_VICIV::SPRHGHT
(byte) MEGA65_VICIV::SPRHGTEN
(byte) MEGA65_VICIV::SPRITE0_COLOR
(byte) MEGA65_VICIV::SPRITE0_X
(byte) MEGA65_VICIV::SPRITE0_Y
(byte) MEGA65_VICIV::SPRITE1_COLOR
(byte) MEGA65_VICIV::SPRITE1_X
(byte) MEGA65_VICIV::SPRITE1_Y
(byte) MEGA65_VICIV::SPRITE2_COLOR
(byte) MEGA65_VICIV::SPRITE2_X
(byte) MEGA65_VICIV::SPRITE2_Y
(byte) MEGA65_VICIV::SPRITE3_COLOR
(byte) MEGA65_VICIV::SPRITE3_X
(byte) MEGA65_VICIV::SPRITE3_Y
(byte) MEGA65_VICIV::SPRITE4_COLOR
(byte) MEGA65_VICIV::SPRITE4_X
(byte) MEGA65_VICIV::SPRITE4_Y
(byte) MEGA65_VICIV::SPRITE5_COLOR
(byte) MEGA65_VICIV::SPRITE5_X
(byte) MEGA65_VICIV::SPRITE5_Y
(byte) MEGA65_VICIV::SPRITE6_COLOR
(byte) MEGA65_VICIV::SPRITE6_X
(byte) MEGA65_VICIV::SPRITE6_Y
(byte) MEGA65_VICIV::SPRITE7_COLOR
(byte) MEGA65_VICIV::SPRITE7_X
(byte) MEGA65_VICIV::SPRITE7_Y
(byte) MEGA65_VICIV::SPRITES_BG_COLLISION
(byte) MEGA65_VICIV::SPRITES_COLLISION
(byte) MEGA65_VICIV::SPRITES_ENABLE
(byte) MEGA65_VICIV::SPRITES_EXPAND_X
(byte) MEGA65_VICIV::SPRITES_EXPAND_Y
(byte) MEGA65_VICIV::SPRITES_MC
(byte) MEGA65_VICIV::SPRITES_MCOLOR1
(byte) MEGA65_VICIV::SPRITES_MCOLOR2
(byte) MEGA65_VICIV::SPRITES_PRIORITY
(byte) MEGA65_VICIV::SPRITES_XMSB
(byte) MEGA65_VICIV::SPRPTRADR_HILO
(byte) MEGA65_VICIV::SPRPTRADR_LOHI
(byte) MEGA65_VICIV::SPRPTRADR_LOLO
(byte) MEGA65_VICIV::SPRX64EN
(byte) MEGA65_VICIV::SPRXSMSBS
(byte) MEGA65_VICIV::SPRYSMSBSM
(byte) MEGA65_VICIV::SRPYMSBS
(byte) MEGA65_VICIV::SYNCPOL
(byte) MEGA65_VICIV::TBDRPOS_HI
(byte) MEGA65_VICIV::TBDRPOS_LO
(byte) MEGA65_VICIV::TEXTXPOS_HI
(byte) MEGA65_VICIV::TEXTXPOS_LO
(byte) MEGA65_VICIV::TEXTYPOS_HI
(byte) MEGA65_VICIV::TEXTYPOS_LO
(byte) MEGA65_VICIV::UNUSED
(byte) MEGA65_VICIV::VPOS
(byte) MEGA65_VICIV::VSYNDEL
(byte) MEGA65_VICIV::XPOS_HI
(byte) MEGA65_VICIV::XPOS_LO
(const nomodify byte) MEMORYBLOCK_4000 = (byte) 4
(const nomodify byte) MEMORYBLOCK_8000 = (byte) $10
(byte) MOS4569_VICIII::B0PIX
(byte) MOS4569_VICIII::B0_ADDR
(byte) MOS4569_VICIII::B1PIX
(byte) MOS4569_VICIII::B1_ADDR
(byte) MOS4569_VICIII::B2PIX
(byte) MOS4569_VICIII::B2_ADDR
(byte) MOS4569_VICIII::B3PIX
(byte) MOS4569_VICIII::B3_ADDR
(byte) MOS4569_VICIII::B4PIX
(byte) MOS4569_VICIII::B4_ADDR
(byte) MOS4569_VICIII::B5PIX
(byte) MOS4569_VICIII::B5_ADDR
(byte) MOS4569_VICIII::B6PIX
(byte) MOS4569_VICIII::B6_ADDR
(byte) MOS4569_VICIII::B7PIX
(byte) MOS4569_VICIII::B7_ADDR
(byte) MOS4569_VICIII::BG_COLOR
(byte) MOS4569_VICIII::BG_COLOR1
(byte) MOS4569_VICIII::BG_COLOR2
(byte) MOS4569_VICIII::BG_COLOR3
(byte) MOS4569_VICIII::BORDER_COLOR
(byte) MOS4569_VICIII::BPCOMP
(byte) MOS4569_VICIII::BPX
(byte) MOS4569_VICIII::BPY
(byte) MOS4569_VICIII::CONTROL1
(byte) MOS4569_VICIII::CONTROL2
(byte) MOS4569_VICIII::CONTROLA
(byte) MOS4569_VICIII::CONTROLB
(byte) MOS4569_VICIII::HPOS
(byte) MOS4569_VICIII::IRQ_ENABLE
(byte) MOS4569_VICIII::IRQ_STATUS
(byte) MOS4569_VICIII::KEY
(byte) MOS4569_VICIII::LIGHTPEN_X
(byte) MOS4569_VICIII::LIGHTPEN_Y
(byte) MOS4569_VICIII::MEMORY
(byte) MOS4569_VICIII::RASTER
(byte) MOS4569_VICIII::SPRITE0_COLOR
(byte) MOS4569_VICIII::SPRITE0_X
(byte) MOS4569_VICIII::SPRITE0_Y
(byte) MOS4569_VICIII::SPRITE1_COLOR
(byte) MOS4569_VICIII::SPRITE1_X
(byte) MOS4569_VICIII::SPRITE1_Y
(byte) MOS4569_VICIII::SPRITE2_COLOR
(byte) MOS4569_VICIII::SPRITE2_X
(byte) MOS4569_VICIII::SPRITE2_Y
(byte) MOS4569_VICIII::SPRITE3_COLOR
(byte) MOS4569_VICIII::SPRITE3_X
(byte) MOS4569_VICIII::SPRITE3_Y
(byte) MOS4569_VICIII::SPRITE4_COLOR
(byte) MOS4569_VICIII::SPRITE4_X
(byte) MOS4569_VICIII::SPRITE4_Y
(byte) MOS4569_VICIII::SPRITE5_COLOR
(byte) MOS4569_VICIII::SPRITE5_X
(byte) MOS4569_VICIII::SPRITE5_Y
(byte) MOS4569_VICIII::SPRITE6_COLOR
(byte) MOS4569_VICIII::SPRITE6_X
(byte) MOS4569_VICIII::SPRITE6_Y
(byte) MOS4569_VICIII::SPRITE7_COLOR
(byte) MOS4569_VICIII::SPRITE7_X
(byte) MOS4569_VICIII::SPRITE7_Y
(byte) MOS4569_VICIII::SPRITES_BG_COLLISION
(byte) MOS4569_VICIII::SPRITES_COLLISION
(byte) MOS4569_VICIII::SPRITES_ENABLE
(byte) MOS4569_VICIII::SPRITES_EXPAND_X
(byte) MOS4569_VICIII::SPRITES_EXPAND_Y
(byte) MOS4569_VICIII::SPRITES_MC
(byte) MOS4569_VICIII::SPRITES_MCOLOR1
(byte) MOS4569_VICIII::SPRITES_MCOLOR2
(byte) MOS4569_VICIII::SPRITES_PRIORITY
(byte) MOS4569_VICIII::SPRITES_XMSB
(byte) MOS4569_VICIII::UNUSED
(byte) MOS4569_VICIII::VPOS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(void()) __start()
(label) __start::@1
(label) __start::@return
(void()) main()
(byte~) main::$2
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@return
(const byte*) main::block1 = (byte*)(number) $4000
(const byte*) main::block2 = (byte*)(number) $8000
(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
(byte~) memoryRemap::$0
(byte~) memoryRemap::$1
(byte~) memoryRemap::$2
(number~) memoryRemap::$3
(number~) memoryRemap::$4
(byte~) memoryRemap::$5
(number~) memoryRemap::$6
(byte~) memoryRemap::$7
(number~) memoryRemap::$8
(number~) memoryRemap::$9
(label) memoryRemap::@return
(const byte*) memoryRemap::aVal = (byte*)(number) $fc
(word) memoryRemap::lowerPageOffset
(word) memoryRemap::lowerPageOffset#0
(word) memoryRemap::lowerPageOffset#1
(word) memoryRemap::lowerPageOffset#2
(byte) memoryRemap::remapBlocks
(byte) memoryRemap::remapBlocks#0
(byte) memoryRemap::remapBlocks#1
(byte) memoryRemap::remapBlocks#2
(word) memoryRemap::upperPageOffset
(word) memoryRemap::upperPageOffset#0
(word) memoryRemap::upperPageOffset#1
(word) memoryRemap::upperPageOffset#2
(const byte*) memoryRemap::xVal = (byte*)(number) $fd
(const byte*) memoryRemap::yVal = (byte*)(number) $fe
(const byte*) memoryRemap::zVal = (byte*)(number) $ff
(void()) memoryRemap256M((byte) memoryRemap256M::remapBlocks , (dword) memoryRemap256M::lowerPageOffset , (dword) memoryRemap256M::upperPageOffset)
(dword~) memoryRemap256M::$0
(byte~) memoryRemap256M::$1
(number~) memoryRemap256M::$10
(word~) memoryRemap256M::$11
(byte~) memoryRemap256M::$12
(number~) memoryRemap256M::$13
(word~) memoryRemap256M::$14
(byte~) memoryRemap256M::$15
(number~) memoryRemap256M::$16
(number~) memoryRemap256M::$17
(dword~) memoryRemap256M::$2
(byte~) memoryRemap256M::$3
(word~) memoryRemap256M::$4
(byte~) memoryRemap256M::$5
(byte~) memoryRemap256M::$6
(word~) memoryRemap256M::$7
(byte~) memoryRemap256M::$8
(number~) memoryRemap256M::$9
(label) memoryRemap256M::@return
(const byte*) memoryRemap256M::aVal = (byte*)(number) $fc
(const byte*) memoryRemap256M::lMb = (byte*)(number) $fa
(dword) memoryRemap256M::lowerPageOffset
(dword) memoryRemap256M::lowerPageOffset#0
(dword) memoryRemap256M::lowerPageOffset#1
(dword) memoryRemap256M::lowerPageOffset#2
(byte) memoryRemap256M::remapBlocks
(byte) memoryRemap256M::remapBlocks#0
(byte) memoryRemap256M::remapBlocks#1
(byte) memoryRemap256M::remapBlocks#2
(const byte*) memoryRemap256M::uMb = (byte*)(number) $fb
(dword) memoryRemap256M::upperPageOffset
(dword) memoryRemap256M::upperPageOffset#0
(dword) memoryRemap256M::upperPageOffset#1
(dword) memoryRemap256M::upperPageOffset#2
(const byte*) memoryRemap256M::xVal = (byte*)(number) $fd
(const byte*) memoryRemap256M::yVal = (byte*)(number) $fe
(const byte*) memoryRemap256M::zVal = (byte*)(number) $ff
(void()) memoryRemapBlock((byte) memoryRemapBlock::blockPage , (word) memoryRemapBlock::memoryPage)
(word~) memoryRemapBlock::$0
(number~) memoryRemapBlock::$1
(number~) memoryRemapBlock::$2
(label) memoryRemapBlock::@1
(label) memoryRemapBlock::@return
(byte) memoryRemapBlock::block
(byte) memoryRemapBlock::block#0
(byte) memoryRemapBlock::blockBits
(byte) memoryRemapBlock::blockBits#0
(byte) memoryRemapBlock::blockPage
(byte) memoryRemapBlock::blockPage#0
(byte) memoryRemapBlock::blockPage#1
(byte) memoryRemapBlock::blockPage#2
(word) memoryRemapBlock::memoryPage
(word) memoryRemapBlock::memoryPage#0
(word) memoryRemapBlock::memoryPage#1
(word) memoryRemapBlock::memoryPage#2
(word) memoryRemapBlock::pageOffset
(word) memoryRemapBlock::pageOffset#0

Adding number conversion cast (unumber) $40 in (byte) memoryRemapBlock::blockPage#0 ← (number) $40
Adding number conversion cast (unumber) $100 in (word) memoryRemapBlock::memoryPage#0 ← (number) $100
Adding number conversion cast (unumber) $55 in *((const byte*) main::block1 + (number) 0) ← (number) $55
Adding number conversion cast (unumber) 0 in *((const byte*) main::block1 + (number) 0) ← ((unumber)) (number) $55
Adding number conversion cast (unumber) $aa in *((const byte*) main::block1 + (number) 1) ← (number) $aa
Adding number conversion cast (unumber) 1 in *((const byte*) main::block1 + (number) 1) ← ((unumber)) (number) $aa
Adding number conversion cast (unumber) $80 in (byte) memoryRemapBlock::blockPage#1 ← (number) $80
Adding number conversion cast (unumber) $100 in (word) memoryRemapBlock::memoryPage#1 ← (number) $100
Adding number conversion cast (unumber) $55 in *((const byte*) main::block2 + (number) 2) ← (number) $55
Adding number conversion cast (unumber) 2 in *((const byte*) main::block2 + (number) 2) ← ((unumber)) (number) $55
Adding number conversion cast (unumber) $aa in *((const byte*) main::block2 + (number) 3) ← (number) $aa
Adding number conversion cast (unumber) 3 in *((const byte*) main::block2 + (number) 3) ← ((unumber)) (number) $aa
Adding number conversion cast (unumber) $c0 in (word) memoryRemap::lowerPageOffset#0 ← (number) $c0
Adding number conversion cast (unumber) $80 in (word) memoryRemap::upperPageOffset#0 ← (number) $80
Adding number conversion cast (unumber) 2 in *((const byte*) main::block2 + (number) 4) ← *((const byte*) main::block1 + (number) 2)
Adding number conversion cast (unumber) 4 in *((const byte*) main::block2 + (number) 4) ← *((const byte*) main::block1 + (unumber)(number) 2)
Adding number conversion cast (unumber) 1 in *((const byte*) main::block1 + (number) 5) ← *((const byte*) main::block2 + (number) 1)
Adding number conversion cast (unumber) 5 in *((const byte*) main::block1 + (number) 5) ← *((const byte*) main::block2 + (unumber)(number) 1)
Adding number conversion cast (unumber) $ff800-$40 in (dword) memoryRemap256M::lowerPageOffset#0 ← (number) $ff800-(number) $40
Adding number conversion cast (unumber) 0 in (dword) memoryRemap256M::upperPageOffset#0 ← (number) 0
Adding number conversion cast (unumber) 0 in *((const byte*) main::block1 + (number) 0) ← (number) 0
Adding number conversion cast (unumber) 0 in *((const byte*) main::block1 + (number) 0) ← ((unumber)) (number) 0
Adding number conversion cast (unumber) 1 in *((const byte*) main::block1 + (number) 1) ← (number) 1
Adding number conversion cast (unumber) 1 in *((const byte*) main::block1 + (number) 1) ← ((unumber)) (number) 1
Adding number conversion cast (unumber) 0 in (byte) memoryRemap256M::remapBlocks#1 ← (number) 0
Adding number conversion cast (unumber) 0 in (dword) memoryRemap256M::lowerPageOffset#1 ← (number) 0
Adding number conversion cast (unumber) 0 in (dword) memoryRemap256M::upperPageOffset#1 ← (number) 0
Adding number conversion cast (unumber) 4 in (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#2 << (number) 4
Adding number conversion cast (unumber) $f in (number~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (number) $f
Adding number conversion cast (unumber) memoryRemap::$3 in (number~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (unumber)(number) $f
Adding number conversion cast (unumber) memoryRemap::$4 in (number~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (unumber~) memoryRemap::$3
Adding number conversion cast (unumber) $f0 in (number~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (number) $f0
Adding number conversion cast (unumber) memoryRemap::$6 in (number~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (unumber)(number) $f0
Adding number conversion cast (unumber) $f in (number~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (number) $f
Adding number conversion cast (unumber) memoryRemap::$8 in (number~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (unumber)(number) $f
Adding number conversion cast (unumber) memoryRemap::$9 in (number~) memoryRemap::$9 ← (unumber~) memoryRemap::$6 | (unumber~) memoryRemap::$8
Adding number conversion cast (unumber) $20 in (number~) memoryRemapBlock::$1 ← (byte) memoryRemapBlock::blockPage#2 / (number) $20
Adding number conversion cast (unumber) memoryRemapBlock::$1 in (number~) memoryRemapBlock::$1 ← (byte) memoryRemapBlock::blockPage#2 / (unumber)(number) $20
Adding number conversion cast (unumber) 1 in (number~) memoryRemapBlock::$2 ← (number) 1 << (byte) memoryRemapBlock::block#0
Adding number conversion cast (unumber) memoryRemapBlock::$2 in (number~) memoryRemapBlock::$2 ← (unumber)(number) 1 << (byte) memoryRemapBlock::block#0
Adding number conversion cast (unumber) 4 in (dword~) memoryRemap256M::$0 ← (dword) memoryRemap256M::lowerPageOffset#2 >> (number) 4
Adding number conversion cast (unumber) 4 in (dword~) memoryRemap256M::$2 ← (dword) memoryRemap256M::upperPageOffset#2 >> (number) 4
Adding number conversion cast (unumber) 4 in (byte~) memoryRemap256M::$6 ← (byte) memoryRemap256M::remapBlocks#2 << (number) 4
Adding number conversion cast (unumber) $f in (number~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (number) $f
Adding number conversion cast (unumber) memoryRemap256M::$9 in (number~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (unumber)(number) $f
Adding number conversion cast (unumber) memoryRemap256M::$10 in (number~) memoryRemap256M::$10 ← (byte~) memoryRemap256M::$6 | (unumber~) memoryRemap256M::$9
Adding number conversion cast (unumber) $f0 in (number~) memoryRemap256M::$13 ← (byte) memoryRemap256M::remapBlocks#2 & (number) $f0
Adding number conversion cast (unumber) memoryRemap256M::$13 in (number~) memoryRemap256M::$13 ← (byte) memoryRemap256M::remapBlocks#2 & (unumber)(number) $f0
Adding number conversion cast (unumber) $f in (number~) memoryRemap256M::$16 ← (byte~) memoryRemap256M::$15 & (number) $f
Adding number conversion cast (unumber) memoryRemap256M::$16 in (number~) memoryRemap256M::$16 ← (byte~) memoryRemap256M::$15 & (unumber)(number) $f
Adding number conversion cast (unumber) memoryRemap256M::$17 in (number~) memoryRemap256M::$17 ← (unumber~) memoryRemap256M::$13 | (unumber~) memoryRemap256M::$16
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte) memoryRemapBlock::blockPage#0 ← (unumber)(number) $40
Inlining cast (word) memoryRemapBlock::memoryPage#0 ← (unumber)(number) $100
Inlining cast *((const byte*) main::block1 + (unumber)(number) 0) ← (unumber)(number) $55
Inlining cast *((const byte*) main::block1 + (unumber)(number) 1) ← (unumber)(number) $aa
Inlining cast (byte) memoryRemapBlock::blockPage#1 ← (unumber)(number) $80
Inlining cast (word) memoryRemapBlock::memoryPage#1 ← (unumber)(number) $100
Inlining cast *((const byte*) main::block2 + (unumber)(number) 2) ← (unumber)(number) $55
Inlining cast *((const byte*) main::block2 + (unumber)(number) 3) ← (unumber)(number) $aa
Inlining cast (word) memoryRemap::lowerPageOffset#0 ← (unumber)(number) $c0
Inlining cast (word) memoryRemap::upperPageOffset#0 ← (unumber)(number) $80
Inlining cast (dword) memoryRemap256M::lowerPageOffset#0 ← (unumber)(number) $ff800-(number) $40
Inlining cast (dword) memoryRemap256M::upperPageOffset#0 ← (unumber)(number) 0
Inlining cast *((const byte*) main::block1 + (unumber)(number) 0) ← (unumber)(number) 0
Inlining cast *((const byte*) main::block1 + (unumber)(number) 1) ← (unumber)(number) 1
Inlining cast (byte) memoryRemap256M::remapBlocks#1 ← (unumber)(number) 0
Inlining cast (dword) memoryRemap256M::lowerPageOffset#1 ← (unumber)(number) 0
Inlining cast (dword) memoryRemap256M::upperPageOffset#1 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 16384
Simplifying constant pointer cast (byte*) 32768
Simplifying constant pointer cast (byte*) 252
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant pointer cast (byte*) 250
Simplifying constant pointer cast (byte*) 251
Simplifying constant pointer cast (byte*) 252
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant integer cast $40
Simplifying constant integer cast $100
Simplifying constant integer cast $55
Simplifying constant integer cast 0
Simplifying constant integer cast $aa
Simplifying constant integer cast 1
Simplifying constant integer cast $80
Simplifying constant integer cast $100
Simplifying constant integer cast $55
Simplifying constant integer cast 2
Simplifying constant integer cast $aa
Simplifying constant integer cast 3
Simplifying constant integer cast $c0
Simplifying constant integer cast $80
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 1
Simplifying constant integer cast 5
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Simplifying constant integer cast $20
Simplifying constant integer cast 1
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $100
Finalized unsigned number type (byte) $55
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $aa
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $80
Finalized unsigned number type (word) $100
Finalized unsigned number type (byte) $55
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $aa
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $c0
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $f0
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $f0
Finalized unsigned number type (byte) $f
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (byte) $f
Inferred type updated to byte in (unumber~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (byte~) memoryRemap::$3
Inferred type updated to byte in (unumber~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (byte) $f0
Inferred type updated to byte in (unumber~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (byte) $f
Inferred type updated to byte in (unumber~) memoryRemap::$9 ← (byte~) memoryRemap::$6 | (byte~) memoryRemap::$8
Inferred type updated to byte in (unumber~) memoryRemapBlock::$1 ← (byte) memoryRemapBlock::blockPage#2 / (byte) $20
Inferred type updated to byte in (unumber~) memoryRemapBlock::$2 ← (byte) 1 << (byte) memoryRemapBlock::block#0
Inferred type updated to byte in (unumber~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (byte) $f
Inferred type updated to byte in (unumber~) memoryRemap256M::$10 ← (byte~) memoryRemap256M::$6 | (byte~) memoryRemap256M::$9
Inferred type updated to byte in (unumber~) memoryRemap256M::$13 ← (byte) memoryRemap256M::remapBlocks#2 & (byte) $f0
Inferred type updated to byte in (unumber~) memoryRemap256M::$16 ← (byte~) memoryRemap256M::$15 & (byte) $f
Inferred type updated to byte in (unumber~) memoryRemap256M::$17 ← (byte~) memoryRemap256M::$13 | (byte~) memoryRemap256M::$16
Alias memoryRemap::remapBlocks#0 = main::$2 
Alias memoryRemapBlock::pageOffset#0 = memoryRemapBlock::$0 
Alias memoryRemapBlock::block#0 = memoryRemapBlock::$1 
Alias memoryRemapBlock::blockBits#0 = memoryRemapBlock::$2 
Successful SSA optimization Pass2AliasElimination
Identified duplicate assignment right side [68] (word~) memoryRemap256M::$7 ← < (dword) memoryRemap256M::lowerPageOffset#2
Identified duplicate assignment right side [77] (word~) memoryRemap256M::$14 ← < (dword) memoryRemap256M::upperPageOffset#2
Successful SSA optimization Pass2DuplicateRValueIdentification
Constant right-side identified [10] (byte) memoryRemap::remapBlocks#0 ← (const nomodify byte) MEMORYBLOCK_4000 | (const nomodify byte) MEMORYBLOCK_8000
Constant right-side identified [17] (dword) memoryRemap256M::lowerPageOffset#0 ← (unumber)(number) $ff800-(number) $40
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) memoryRemapBlock::blockPage#0 = $40
Constant (const word) memoryRemapBlock::memoryPage#0 = $100
Constant (const byte) memoryRemapBlock::blockPage#1 = $80
Constant (const word) memoryRemapBlock::memoryPage#1 = $100
Constant (const byte) memoryRemap::remapBlocks#0 = MEMORYBLOCK_4000|MEMORYBLOCK_8000
Constant (const word) memoryRemap::lowerPageOffset#0 = $c0
Constant (const word) memoryRemap::upperPageOffset#0 = $80
Constant (const byte) memoryRemap256M::remapBlocks#0 = MEMORYBLOCK_4000
Constant (const dword) memoryRemap256M::lowerPageOffset#0 = (unumber)$ff800-$40
Constant (const dword) memoryRemap256M::upperPageOffset#0 = 0
Constant (const byte) memoryRemap256M::remapBlocks#1 = 0
Constant (const dword) memoryRemap256M::lowerPageOffset#1 = 0
Constant (const dword) memoryRemap256M::upperPageOffset#1 = 0
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero main::block1 in [3] *((const byte*) main::block1 + (byte) 0) ← (byte) $55
Simplifying expression containing zero main::block1 in [20] *((const byte*) main::block1 + (byte) 0) ← (byte) 0
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Alias memoryRemap256M::$7 = memoryRemap256M::$4 
Alias memoryRemap256M::$14 = memoryRemap256M::$11 
Successful SSA optimization Pass2AliasElimination
Rewriting division to use shift [33] (byte) memoryRemapBlock::block#0 ← (byte) memoryRemapBlock::blockPage#2 / (byte) $20
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) memoryRemap::remapBlocks#0
Inlining constant with var siblings (const word) memoryRemap::lowerPageOffset#0
Inlining constant with var siblings (const word) memoryRemap::upperPageOffset#0
Inlining constant with var siblings (const byte) memoryRemapBlock::blockPage#0
Inlining constant with var siblings (const word) memoryRemapBlock::memoryPage#0
Inlining constant with var siblings (const byte) memoryRemapBlock::blockPage#1
Inlining constant with var siblings (const word) memoryRemapBlock::memoryPage#1
Inlining constant with var siblings (const byte) memoryRemap256M::remapBlocks#0
Inlining constant with var siblings (const dword) memoryRemap256M::lowerPageOffset#0
Inlining constant with var siblings (const dword) memoryRemap256M::upperPageOffset#0
Inlining constant with var siblings (const byte) memoryRemap256M::remapBlocks#1
Inlining constant with var siblings (const dword) memoryRemap256M::lowerPageOffset#1
Inlining constant with var siblings (const dword) memoryRemap256M::upperPageOffset#1
Constant inlined memoryRemapBlock::blockPage#1 = (byte) $80
Constant inlined memoryRemap::remapBlocks#0 = (const nomodify byte) MEMORYBLOCK_4000|(const nomodify byte) MEMORYBLOCK_8000
Constant inlined memoryRemapBlock::blockPage#0 = (byte) $40
Constant inlined memoryRemapBlock::memoryPage#1 = (word) $100
Constant inlined memoryRemapBlock::memoryPage#0 = (word) $100
Constant inlined memoryRemap::upperPageOffset#0 = (byte) $80
Constant inlined memoryRemap256M::upperPageOffset#1 = (byte) 0
Constant inlined memoryRemap256M::upperPageOffset#0 = (byte) 0
Constant inlined memoryRemap::lowerPageOffset#0 = (byte) $c0
Constant inlined memoryRemap256M::lowerPageOffset#0 = (dword)(number) $ff800-(number) $40
Constant inlined memoryRemap256M::lowerPageOffset#1 = (byte) 0
Constant inlined memoryRemap256M::remapBlocks#1 = (byte) 0
Constant inlined memoryRemap256M::remapBlocks#0 = (const nomodify byte) MEMORYBLOCK_4000
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(main::block1+1)
Consolidated array index constant in *(main::block2+2)
Consolidated array index constant in *(main::block2+3)
Consolidated array index constant in *(main::block1+2)
Consolidated array index constant in *(main::block2+4)
Consolidated array index constant in *(main::block2+1)
Consolidated array index constant in *(main::block1+5)
Consolidated array index constant in *(main::block1+1)
Successful SSA optimization Pass2ConstantAdditionElimination
Identical Phi Values (word) memoryRemapBlock::memoryPage#2 (word) $100
Identical Phi Values (dword) memoryRemap256M::upperPageOffset#2 (byte) 0
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [44] (dword~) memoryRemap256M::$2 ← (byte) 0 >> (byte) 4
Constant right-side identified [55] (word~) memoryRemap256M::$14 ← < (byte) 0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const dword) memoryRemap256M::$2 = 0>>4
Constant (const word) memoryRemap256M::$14 = <0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)memoryRemap256M::$2 in [45] (byte~) memoryRemap256M::$3 ← > (word)(const dword) memoryRemap256M::$2
Successful SSA optimization Pass2ConstantValues
Simplifying constant evaluating to zero (byte) 0>>(byte) 4 in 
Simplifying constant evaluating to zero <(byte) 0 in 
Simplifying constant evaluating to zero (word)(const dword) memoryRemap256M::$2 in [45] (byte~) memoryRemap256M::$3 ← > (word)(const dword) memoryRemap256M::$2
Successful SSA optimization PassNSimplifyConstantZero
Eliminating unused constant (const dword) memoryRemap256M::$2
Successful SSA optimization PassNEliminateUnusedVars
Constant inlined memoryRemap256M::$14 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Constant right-side identified [44] (byte~) memoryRemap256M::$3 ← > (word) 0
Constant right-side identified [54] (byte~) memoryRemap256M::$12 ← < (byte) 0
Constant right-side identified [57] (byte~) memoryRemap256M::$15 ← > (byte) 0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) memoryRemap256M::$3 = >0
Constant (const byte) memoryRemap256M::$12 = <0
Constant (const byte) memoryRemap256M::$15 = >0
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero >(word) 0 in 
Simplifying constant evaluating to zero <(byte) 0 in 
Simplifying constant evaluating to zero >(byte) 0 in 
Successful SSA optimization PassNSimplifyConstantZero
Constant inlined memoryRemap256M::$15 = (byte) 0
Constant inlined memoryRemap256M::$12 = (byte) 0
Constant inlined memoryRemap256M::$3 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Constant right-side identified [55] (byte~) memoryRemap256M::$16 ← (byte) 0 & (byte) $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) memoryRemap256M::$16 = 0&$f
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero (byte) 0&(byte) $f in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero memoryRemap256M::$13 in [56] (byte~) memoryRemap256M::$17 ← (byte~) memoryRemap256M::$13 | (const byte) memoryRemap256M::$16
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) memoryRemap256M::$16
Successful SSA optimization PassNEliminateUnusedVars
Alias memoryRemap256M::$17 = memoryRemap256M::$13 
Successful SSA optimization Pass2AliasElimination
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of memoryRemapBlock::@1
CALL GRAPH
Calls in [main] to memoryRemapBlock:1 memoryRemapBlock:4 memoryRemap:7 memoryRemap256M:10 memoryRemap256M:13 
Calls in [memoryRemapBlock] to memoryRemap:26 

Created 6 initial phi equivalence classes
Coalesced [23] memoryRemap::lowerPageOffset#3 ← memoryRemap::lowerPageOffset#1
Coalesced [24] memoryRemap::remapBlocks#3 ← memoryRemap::remapBlocks#1
Coalesced [25] memoryRemap::upperPageOffset#3 ← memoryRemap::upperPageOffset#1
Coalesced down to 6 phi equivalence classes
Culled Empty Block (label) main::@5
Culled Empty Block (label) memoryRemapBlock::@1
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call memoryRemapBlock 
  to:main::@1
main::@1: scope:[main]  from main
  [2] *((const byte*) main::block1) ← (byte) $55
  [3] *((const byte*) main::block1+(byte) 1) ← (byte) $aa
  [4] call memoryRemapBlock 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [5] *((const byte*) main::block2+(byte) 2) ← (byte) $55
  [6] *((const byte*) main::block2+(byte) 3) ← (byte) $aa
  [7] call memoryRemap 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [8] *((const byte*) main::block2+(byte) 4) ← *((const byte*) main::block1+(byte) 2)
  [9] *((const byte*) main::block1+(byte) 5) ← *((const byte*) main::block2+(byte) 1)
  [10] call memoryRemap256M 
  to:main::@4
main::@4: scope:[main]  from main::@3
  [11] *((const byte*) main::block1) ← (byte) 0
  [12] *((const byte*) main::block1+(byte) 1) ← (byte) 1
  [13] call memoryRemap256M 
  to:main::@return
main::@return: scope:[main]  from main::@4
  [14] return 
  to:@return

(void()) memoryRemapBlock((byte) memoryRemapBlock::blockPage , (word) memoryRemapBlock::memoryPage)
memoryRemapBlock: scope:[memoryRemapBlock]  from main main::@1
  [15] (byte) memoryRemapBlock::blockPage#2 ← phi( main/(byte) $40 main::@1/(byte) $80 )
  [16] (word) memoryRemapBlock::pageOffset#0 ← (word) $100 - (byte) memoryRemapBlock::blockPage#2
  [17] (byte) memoryRemapBlock::block#0 ← (byte) memoryRemapBlock::blockPage#2 >> (byte) 5
  [18] (byte) memoryRemapBlock::blockBits#0 ← (byte) 1 << (byte) memoryRemapBlock::block#0
  [19] (byte) memoryRemap::remapBlocks#1 ← (byte) memoryRemapBlock::blockBits#0
  [20] (word) memoryRemap::lowerPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0
  [21] (word) memoryRemap::upperPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0
  [22] call memoryRemap 
  to:memoryRemapBlock::@return
memoryRemapBlock::@return: scope:[memoryRemapBlock]  from memoryRemapBlock
  [23] return 
  to:@return

(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main::@2 memoryRemapBlock
  [24] (word) memoryRemap::upperPageOffset#2 ← phi( main::@2/(byte) $80 memoryRemapBlock/(word) memoryRemap::upperPageOffset#1 )
  [24] (byte) memoryRemap::remapBlocks#2 ← phi( main::@2/(const nomodify byte) MEMORYBLOCK_4000|(const nomodify byte) MEMORYBLOCK_8000 memoryRemapBlock/(byte) memoryRemap::remapBlocks#1 )
  [24] (word) memoryRemap::lowerPageOffset#2 ← phi( main::@2/(byte) $c0 memoryRemapBlock/(word) memoryRemap::lowerPageOffset#1 )
  [25] (byte~) memoryRemap::$0 ← < (word) memoryRemap::lowerPageOffset#2
  [26] *((const byte*) memoryRemap::aVal) ← (byte~) memoryRemap::$0
  [27] (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#2 << (byte) 4
  [28] (byte~) memoryRemap::$2 ← > (word) memoryRemap::lowerPageOffset#2
  [29] (byte~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (byte) $f
  [30] (byte~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (byte~) memoryRemap::$3
  [31] *((const byte*) memoryRemap::xVal) ← (byte~) memoryRemap::$4
  [32] (byte~) memoryRemap::$5 ← < (word) memoryRemap::upperPageOffset#2
  [33] *((const byte*) memoryRemap::yVal) ← (byte~) memoryRemap::$5
  [34] (byte~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (byte) $f0
  [35] (byte~) memoryRemap::$7 ← > (word) memoryRemap::upperPageOffset#2
  [36] (byte~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (byte) $f
  [37] (byte~) memoryRemap::$9 ← (byte~) memoryRemap::$6 | (byte~) memoryRemap::$8
  [38] *((const byte*) memoryRemap::zVal) ← (byte~) memoryRemap::$9
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  [40] return 
  to:@return

(void()) memoryRemap256M((byte) memoryRemap256M::remapBlocks , (dword) memoryRemap256M::lowerPageOffset , (dword) memoryRemap256M::upperPageOffset)
memoryRemap256M: scope:[memoryRemap256M]  from main::@3 main::@4
  [41] (byte) memoryRemap256M::remapBlocks#2 ← phi( main::@3/(const nomodify byte) MEMORYBLOCK_4000 main::@4/(byte) 0 )
  [41] (dword) memoryRemap256M::lowerPageOffset#2 ← phi( main::@3/(dword)(number) $ff800-(number) $40 main::@4/(byte) 0 )
  [42] (dword~) memoryRemap256M::$0 ← (dword) memoryRemap256M::lowerPageOffset#2 >> (byte) 4
  [43] (byte~) memoryRemap256M::$1 ← > (word)(dword~) memoryRemap256M::$0
  [44] *((const byte*) memoryRemap256M::lMb) ← (byte~) memoryRemap256M::$1
  [45] *((const byte*) memoryRemap256M::uMb) ← (byte) 0
  [46] (word~) memoryRemap256M::$7 ← < (dword) memoryRemap256M::lowerPageOffset#2
  [47] (byte~) memoryRemap256M::$5 ← < (word~) memoryRemap256M::$7
  [48] *((const byte*) memoryRemap256M::aVal) ← (byte~) memoryRemap256M::$5
  [49] (byte~) memoryRemap256M::$6 ← (byte) memoryRemap256M::remapBlocks#2 << (byte) 4
  [50] (byte~) memoryRemap256M::$8 ← > (word~) memoryRemap256M::$7
  [51] (byte~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (byte) $f
  [52] (byte~) memoryRemap256M::$10 ← (byte~) memoryRemap256M::$6 | (byte~) memoryRemap256M::$9
  [53] *((const byte*) memoryRemap256M::xVal) ← (byte~) memoryRemap256M::$10
  [54] *((const byte*) memoryRemap256M::yVal) ← (byte) 0
  [55] (byte~) memoryRemap256M::$17 ← (byte) memoryRemap256M::remapBlocks#2 & (byte) $f0
  [56] *((const byte*) memoryRemap256M::zVal) ← (byte~) memoryRemap256M::$17
  asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap256M::@return
memoryRemap256M::@return: scope:[memoryRemap256M]  from memoryRemap256M
  [58] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) MEGA65_VICIV::ALPHADELAY
(byte) MEGA65_VICIV::B0PIX
(byte) MEGA65_VICIV::B0_ADDR
(byte) MEGA65_VICIV::B1PIX
(byte) MEGA65_VICIV::B1_ADDR
(byte) MEGA65_VICIV::B2PIX
(byte) MEGA65_VICIV::B2_ADDR
(byte) MEGA65_VICIV::B3PIX
(byte) MEGA65_VICIV::B3_ADDR
(byte) MEGA65_VICIV::B4PIX
(byte) MEGA65_VICIV::B4_ADDR
(byte) MEGA65_VICIV::B5PIX
(byte) MEGA65_VICIV::B5_ADDR
(byte) MEGA65_VICIV::B6PIX
(byte) MEGA65_VICIV::B6_ADDR
(byte) MEGA65_VICIV::B7PIX
(byte) MEGA65_VICIV::B7_ADDR
(byte) MEGA65_VICIV::BBDRPOS_HI
(byte) MEGA65_VICIV::BBDRPOS_LO
(byte) MEGA65_VICIV::BG_COLOR
(byte) MEGA65_VICIV::BG_COLOR1
(byte) MEGA65_VICIV::BG_COLOR2
(byte) MEGA65_VICIV::BG_COLOR3
(byte) MEGA65_VICIV::BORDER_COLOR
(byte) MEGA65_VICIV::BP16ENS
(byte) MEGA65_VICIV::BPCOMP
(byte) MEGA65_VICIV::BPX
(byte) MEGA65_VICIV::BPY
(byte) MEGA65_VICIV::CHARPTR_HILO
(byte) MEGA65_VICIV::CHARPTR_LOHI
(byte) MEGA65_VICIV::CHARPTR_LOLO
(byte) MEGA65_VICIV::CHARSTEP_HI
(byte) MEGA65_VICIV::CHARSTEP_LO
(byte) MEGA65_VICIV::CHRCOUNT
(byte) MEGA65_VICIV::CHRXSCL
(byte) MEGA65_VICIV::CHRYSCL
(byte) MEGA65_VICIV::COLPTR_HI
(byte) MEGA65_VICIV::COLPTR_LO
(byte) MEGA65_VICIV::CONTROL1
(byte) MEGA65_VICIV::CONTROL2
(byte) MEGA65_VICIV::CONTROLA
(byte) MEGA65_VICIV::CONTROLB
(byte) MEGA65_VICIV::CONTROLC
(byte) MEGA65_VICIV::DEBUG1
(byte) MEGA65_VICIV::DEBUGX
(byte) MEGA65_VICIV::DEBUGXY
(byte) MEGA65_VICIV::DEBUGY
(byte) MEGA65_VICIV::FNRASTER_HI
(byte) MEGA65_VICIV::FNRASTER_LO
(byte) MEGA65_VICIV::HPOS
(byte) MEGA65_VICIV::IRQ_ENABLE
(byte) MEGA65_VICIV::IRQ_STATUS
(byte) MEGA65_VICIV::KEY
(byte) MEGA65_VICIV::LIGHTPEN_X
(byte) MEGA65_VICIV::LIGHTPEN_Y
(byte) MEGA65_VICIV::MEMORY
(byte) MEGA65_VICIV::PALSEL
(byte) MEGA65_VICIV::RASLINE0
(byte) MEGA65_VICIV::RASTER
(byte) MEGA65_VICIV::ROWCOUNT
(byte) MEGA65_VICIV::RSTCMP
(byte) MEGA65_VICIV::RSTCOMP
(byte) MEGA65_VICIV::SBPDEBUG
(byte) MEGA65_VICIV::SCRNPTR_HIHI
(byte) MEGA65_VICIV::SCRNPTR_HILO
(byte) MEGA65_VICIV::SCRNPTR_LOHI
(byte) MEGA65_VICIV::SCRNPTR_LOLO
(byte) MEGA65_VICIV::SIDBDRWD_HI
(byte) MEGA65_VICIV::SIDBDRWD_LO
(byte) MEGA65_VICIV::SPR16EN
(byte) MEGA65_VICIV::SPRALPHAVAL
(byte) MEGA65_VICIV::SPRENALPHA
(byte) MEGA65_VICIV::SPRENV400
(byte) MEGA65_VICIV::SPRHGHT
(byte) MEGA65_VICIV::SPRHGTEN
(byte) MEGA65_VICIV::SPRITE0_COLOR
(byte) MEGA65_VICIV::SPRITE0_X
(byte) MEGA65_VICIV::SPRITE0_Y
(byte) MEGA65_VICIV::SPRITE1_COLOR
(byte) MEGA65_VICIV::SPRITE1_X
(byte) MEGA65_VICIV::SPRITE1_Y
(byte) MEGA65_VICIV::SPRITE2_COLOR
(byte) MEGA65_VICIV::SPRITE2_X
(byte) MEGA65_VICIV::SPRITE2_Y
(byte) MEGA65_VICIV::SPRITE3_COLOR
(byte) MEGA65_VICIV::SPRITE3_X
(byte) MEGA65_VICIV::SPRITE3_Y
(byte) MEGA65_VICIV::SPRITE4_COLOR
(byte) MEGA65_VICIV::SPRITE4_X
(byte) MEGA65_VICIV::SPRITE4_Y
(byte) MEGA65_VICIV::SPRITE5_COLOR
(byte) MEGA65_VICIV::SPRITE5_X
(byte) MEGA65_VICIV::SPRITE5_Y
(byte) MEGA65_VICIV::SPRITE6_COLOR
(byte) MEGA65_VICIV::SPRITE6_X
(byte) MEGA65_VICIV::SPRITE6_Y
(byte) MEGA65_VICIV::SPRITE7_COLOR
(byte) MEGA65_VICIV::SPRITE7_X
(byte) MEGA65_VICIV::SPRITE7_Y
(byte) MEGA65_VICIV::SPRITES_BG_COLLISION
(byte) MEGA65_VICIV::SPRITES_COLLISION
(byte) MEGA65_VICIV::SPRITES_ENABLE
(byte) MEGA65_VICIV::SPRITES_EXPAND_X
(byte) MEGA65_VICIV::SPRITES_EXPAND_Y
(byte) MEGA65_VICIV::SPRITES_MC
(byte) MEGA65_VICIV::SPRITES_MCOLOR1
(byte) MEGA65_VICIV::SPRITES_MCOLOR2
(byte) MEGA65_VICIV::SPRITES_PRIORITY
(byte) MEGA65_VICIV::SPRITES_XMSB
(byte) MEGA65_VICIV::SPRPTRADR_HILO
(byte) MEGA65_VICIV::SPRPTRADR_LOHI
(byte) MEGA65_VICIV::SPRPTRADR_LOLO
(byte) MEGA65_VICIV::SPRX64EN
(byte) MEGA65_VICIV::SPRXSMSBS
(byte) MEGA65_VICIV::SPRYSMSBSM
(byte) MEGA65_VICIV::SRPYMSBS
(byte) MEGA65_VICIV::SYNCPOL
(byte) MEGA65_VICIV::TBDRPOS_HI
(byte) MEGA65_VICIV::TBDRPOS_LO
(byte) MEGA65_VICIV::TEXTXPOS_HI
(byte) MEGA65_VICIV::TEXTXPOS_LO
(byte) MEGA65_VICIV::TEXTYPOS_HI
(byte) MEGA65_VICIV::TEXTYPOS_LO
(byte) MEGA65_VICIV::UNUSED
(byte) MEGA65_VICIV::VPOS
(byte) MEGA65_VICIV::VSYNDEL
(byte) MEGA65_VICIV::XPOS_HI
(byte) MEGA65_VICIV::XPOS_LO
(byte) MOS4569_VICIII::B0PIX
(byte) MOS4569_VICIII::B0_ADDR
(byte) MOS4569_VICIII::B1PIX
(byte) MOS4569_VICIII::B1_ADDR
(byte) MOS4569_VICIII::B2PIX
(byte) MOS4569_VICIII::B2_ADDR
(byte) MOS4569_VICIII::B3PIX
(byte) MOS4569_VICIII::B3_ADDR
(byte) MOS4569_VICIII::B4PIX
(byte) MOS4569_VICIII::B4_ADDR
(byte) MOS4569_VICIII::B5PIX
(byte) MOS4569_VICIII::B5_ADDR
(byte) MOS4569_VICIII::B6PIX
(byte) MOS4569_VICIII::B6_ADDR
(byte) MOS4569_VICIII::B7PIX
(byte) MOS4569_VICIII::B7_ADDR
(byte) MOS4569_VICIII::BG_COLOR
(byte) MOS4569_VICIII::BG_COLOR1
(byte) MOS4569_VICIII::BG_COLOR2
(byte) MOS4569_VICIII::BG_COLOR3
(byte) MOS4569_VICIII::BORDER_COLOR
(byte) MOS4569_VICIII::BPCOMP
(byte) MOS4569_VICIII::BPX
(byte) MOS4569_VICIII::BPY
(byte) MOS4569_VICIII::CONTROL1
(byte) MOS4569_VICIII::CONTROL2
(byte) MOS4569_VICIII::CONTROLA
(byte) MOS4569_VICIII::CONTROLB
(byte) MOS4569_VICIII::HPOS
(byte) MOS4569_VICIII::IRQ_ENABLE
(byte) MOS4569_VICIII::IRQ_STATUS
(byte) MOS4569_VICIII::KEY
(byte) MOS4569_VICIII::LIGHTPEN_X
(byte) MOS4569_VICIII::LIGHTPEN_Y
(byte) MOS4569_VICIII::MEMORY
(byte) MOS4569_VICIII::RASTER
(byte) MOS4569_VICIII::SPRITE0_COLOR
(byte) MOS4569_VICIII::SPRITE0_X
(byte) MOS4569_VICIII::SPRITE0_Y
(byte) MOS4569_VICIII::SPRITE1_COLOR
(byte) MOS4569_VICIII::SPRITE1_X
(byte) MOS4569_VICIII::SPRITE1_Y
(byte) MOS4569_VICIII::SPRITE2_COLOR
(byte) MOS4569_VICIII::SPRITE2_X
(byte) MOS4569_VICIII::SPRITE2_Y
(byte) MOS4569_VICIII::SPRITE3_COLOR
(byte) MOS4569_VICIII::SPRITE3_X
(byte) MOS4569_VICIII::SPRITE3_Y
(byte) MOS4569_VICIII::SPRITE4_COLOR
(byte) MOS4569_VICIII::SPRITE4_X
(byte) MOS4569_VICIII::SPRITE4_Y
(byte) MOS4569_VICIII::SPRITE5_COLOR
(byte) MOS4569_VICIII::SPRITE5_X
(byte) MOS4569_VICIII::SPRITE5_Y
(byte) MOS4569_VICIII::SPRITE6_COLOR
(byte) MOS4569_VICIII::SPRITE6_X
(byte) MOS4569_VICIII::SPRITE6_Y
(byte) MOS4569_VICIII::SPRITE7_COLOR
(byte) MOS4569_VICIII::SPRITE7_X
(byte) MOS4569_VICIII::SPRITE7_Y
(byte) MOS4569_VICIII::SPRITES_BG_COLLISION
(byte) MOS4569_VICIII::SPRITES_COLLISION
(byte) MOS4569_VICIII::SPRITES_ENABLE
(byte) MOS4569_VICIII::SPRITES_EXPAND_X
(byte) MOS4569_VICIII::SPRITES_EXPAND_Y
(byte) MOS4569_VICIII::SPRITES_MC
(byte) MOS4569_VICIII::SPRITES_MCOLOR1
(byte) MOS4569_VICIII::SPRITES_MCOLOR2
(byte) MOS4569_VICIII::SPRITES_PRIORITY
(byte) MOS4569_VICIII::SPRITES_XMSB
(byte) MOS4569_VICIII::UNUSED
(byte) MOS4569_VICIII::VPOS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(void()) main()
(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
(byte~) memoryRemap::$0 202.0
(byte~) memoryRemap::$1 67.33333333333333
(byte~) memoryRemap::$2 202.0
(byte~) memoryRemap::$3 202.0
(byte~) memoryRemap::$4 202.0
(byte~) memoryRemap::$5 202.0
(byte~) memoryRemap::$6 67.33333333333333
(byte~) memoryRemap::$7 202.0
(byte~) memoryRemap::$8 202.0
(byte~) memoryRemap::$9 202.0
(word) memoryRemap::lowerPageOffset
(word) memoryRemap::lowerPageOffset#1 11.0
(word) memoryRemap::lowerPageOffset#2 53.25
(byte) memoryRemap::remapBlocks
(byte) memoryRemap::remapBlocks#1 7.333333333333333
(byte) memoryRemap::remapBlocks#2 21.299999999999997
(word) memoryRemap::upperPageOffset
(word) memoryRemap::upperPageOffset#1 22.0
(word) memoryRemap::upperPageOffset#2 19.363636363636363
(void()) memoryRemap256M((byte) memoryRemap256M::remapBlocks , (dword) memoryRemap256M::lowerPageOffset , (dword) memoryRemap256M::upperPageOffset)
(dword~) memoryRemap256M::$0 11.0
(byte~) memoryRemap256M::$1 22.0
(byte~) memoryRemap256M::$10 22.0
(byte~) memoryRemap256M::$17 22.0
(byte~) memoryRemap256M::$5 22.0
(byte~) memoryRemap256M::$6 7.333333333333333
(word~) memoryRemap256M::$7 8.25
(byte~) memoryRemap256M::$8 22.0
(byte~) memoryRemap256M::$9 22.0
(dword) memoryRemap256M::lowerPageOffset
(dword) memoryRemap256M::lowerPageOffset#2 4.4
(byte) memoryRemap256M::remapBlocks
(byte) memoryRemap256M::remapBlocks#2 1.5714285714285714
(dword) memoryRemap256M::upperPageOffset
(void()) memoryRemapBlock((byte) memoryRemapBlock::blockPage , (word) memoryRemapBlock::memoryPage)
(byte) memoryRemapBlock::block
(byte) memoryRemapBlock::block#0 22.0
(byte) memoryRemapBlock::blockBits
(byte) memoryRemapBlock::blockBits#0 22.0
(byte) memoryRemapBlock::blockPage
(byte) memoryRemapBlock::blockPage#2 11.0
(word) memoryRemapBlock::memoryPage
(word) memoryRemapBlock::pageOffset
(word) memoryRemapBlock::pageOffset#0 6.6000000000000005

Initial phi equivalence classes
[ memoryRemapBlock::blockPage#2 ]
[ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 ]
[ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ]
[ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#1 ]
[ memoryRemap256M::lowerPageOffset#2 ]
[ memoryRemap256M::remapBlocks#2 ]
Added variable memoryRemapBlock::pageOffset#0 to live range equivalence class [ memoryRemapBlock::pageOffset#0 ]
Added variable memoryRemapBlock::block#0 to live range equivalence class [ memoryRemapBlock::block#0 ]
Added variable memoryRemapBlock::blockBits#0 to live range equivalence class [ memoryRemapBlock::blockBits#0 ]
Added variable memoryRemap::$0 to live range equivalence class [ memoryRemap::$0 ]
Added variable memoryRemap::$1 to live range equivalence class [ memoryRemap::$1 ]
Added variable memoryRemap::$2 to live range equivalence class [ memoryRemap::$2 ]
Added variable memoryRemap::$3 to live range equivalence class [ memoryRemap::$3 ]
Added variable memoryRemap::$4 to live range equivalence class [ memoryRemap::$4 ]
Added variable memoryRemap::$5 to live range equivalence class [ memoryRemap::$5 ]
Added variable memoryRemap::$6 to live range equivalence class [ memoryRemap::$6 ]
Added variable memoryRemap::$7 to live range equivalence class [ memoryRemap::$7 ]
Added variable memoryRemap::$8 to live range equivalence class [ memoryRemap::$8 ]
Added variable memoryRemap::$9 to live range equivalence class [ memoryRemap::$9 ]
Added variable memoryRemap256M::$0 to live range equivalence class [ memoryRemap256M::$0 ]
Added variable memoryRemap256M::$1 to live range equivalence class [ memoryRemap256M::$1 ]
Added variable memoryRemap256M::$7 to live range equivalence class [ memoryRemap256M::$7 ]
Added variable memoryRemap256M::$5 to live range equivalence class [ memoryRemap256M::$5 ]
Added variable memoryRemap256M::$6 to live range equivalence class [ memoryRemap256M::$6 ]
Added variable memoryRemap256M::$8 to live range equivalence class [ memoryRemap256M::$8 ]
Added variable memoryRemap256M::$9 to live range equivalence class [ memoryRemap256M::$9 ]
Added variable memoryRemap256M::$10 to live range equivalence class [ memoryRemap256M::$10 ]
Added variable memoryRemap256M::$17 to live range equivalence class [ memoryRemap256M::$17 ]
Complete equivalence classes
[ memoryRemapBlock::blockPage#2 ]
[ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 ]
[ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ]
[ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#1 ]
[ memoryRemap256M::lowerPageOffset#2 ]
[ memoryRemap256M::remapBlocks#2 ]
[ memoryRemapBlock::pageOffset#0 ]
[ memoryRemapBlock::block#0 ]
[ memoryRemapBlock::blockBits#0 ]
[ memoryRemap::$0 ]
[ memoryRemap::$1 ]
[ memoryRemap::$2 ]
[ memoryRemap::$3 ]
[ memoryRemap::$4 ]
[ memoryRemap::$5 ]
[ memoryRemap::$6 ]
[ memoryRemap::$7 ]
[ memoryRemap::$8 ]
[ memoryRemap::$9 ]
[ memoryRemap256M::$0 ]
[ memoryRemap256M::$1 ]
[ memoryRemap256M::$7 ]
[ memoryRemap256M::$5 ]
[ memoryRemap256M::$6 ]
[ memoryRemap256M::$8 ]
[ memoryRemap256M::$9 ]
[ memoryRemap256M::$10 ]
[ memoryRemap256M::$17 ]
Allocated zp[1]:2 [ memoryRemapBlock::blockPage#2 ]
Allocated zp[2]:3 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 ]
Allocated zp[1]:5 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ]
Allocated zp[2]:6 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#1 ]
Allocated zp[4]:8 [ memoryRemap256M::lowerPageOffset#2 ]
Allocated zp[1]:12 [ memoryRemap256M::remapBlocks#2 ]
Allocated zp[2]:13 [ memoryRemapBlock::pageOffset#0 ]
Allocated zp[1]:15 [ memoryRemapBlock::block#0 ]
Allocated zp[1]:16 [ memoryRemapBlock::blockBits#0 ]
Allocated zp[1]:17 [ memoryRemap::$0 ]
Allocated zp[1]:18 [ memoryRemap::$1 ]
Allocated zp[1]:19 [ memoryRemap::$2 ]
Allocated zp[1]:20 [ memoryRemap::$3 ]
Allocated zp[1]:21 [ memoryRemap::$4 ]
Allocated zp[1]:22 [ memoryRemap::$5 ]
Allocated zp[1]:23 [ memoryRemap::$6 ]
Allocated zp[1]:24 [ memoryRemap::$7 ]
Allocated zp[1]:25 [ memoryRemap::$8 ]
Allocated zp[1]:26 [ memoryRemap::$9 ]
Allocated zp[4]:27 [ memoryRemap256M::$0 ]
Allocated zp[1]:31 [ memoryRemap256M::$1 ]
Allocated zp[2]:32 [ memoryRemap256M::$7 ]
Allocated zp[1]:34 [ memoryRemap256M::$5 ]
Allocated zp[1]:35 [ memoryRemap256M::$6 ]
Allocated zp[1]:36 [ memoryRemap256M::$8 ]
Allocated zp[1]:37 [ memoryRemap256M::$9 ]
Allocated zp[1]:38 [ memoryRemap256M::$10 ]
Allocated zp[1]:39 [ memoryRemap256M::$17 ]

INITIAL ASM
Target platform is mega65 / MEGA45GS02
  // File Comments
// Test the MAP instruction for remapping memory
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in file:///Users/jespergravgaard/Downloads/MEGA65-Book_draft%20(5).pdf for a description of the CPU memory remapper of the MEGA65.
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="memorymap-test.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // Bit representing 8K block #2 of the 64K addressable memory ($4000-$5fff)
  .const MEMORYBLOCK_4000 = 4
  // Bit representing 8K block #4 of the 64K addressable memory ($8000-$9fff)
  .const MEMORYBLOCK_8000 = $10
.segment Code
  // main
main: {
    .label block1 = $4000
    .label block2 = $8000
    // [1] call memoryRemapBlock 
  // Remap [$4000-$5fff] to point to [$10000-$11fff]
    // [15] phi from main to memoryRemapBlock [phi:main->memoryRemapBlock]
  memoryRemapBlock_from_main:
    // [15] phi (byte) memoryRemapBlock::blockPage#2 = (byte) $40 [phi:main->memoryRemapBlock#0] -- vbuz1=vbuc1 
    lda #$40
    sta.z memoryRemapBlock.blockPage
    jsr memoryRemapBlock
    jmp __b1
    // main::@1
  __b1:
    // [2] *((const byte*) main::block1) ← (byte) $55 -- _deref_pbuc1=vbuc2 
    // Put 0x55, 0xaa into $10000
    lda #$55
    sta block1
    // [3] *((const byte*) main::block1+(byte) 1) ← (byte) $aa -- _deref_pbuc1=vbuc2 
    lda #$aa
    sta block1+1
    // [4] call memoryRemapBlock 
  // Remap [$8000-$9fff] to point to [$10000-$11fff]
    // [15] phi from main::@1 to memoryRemapBlock [phi:main::@1->memoryRemapBlock]
  memoryRemapBlock_from___b1:
    // [15] phi (byte) memoryRemapBlock::blockPage#2 = (byte) $80 [phi:main::@1->memoryRemapBlock#0] -- vbuz1=vbuc1 
    lda #$80
    sta.z memoryRemapBlock.blockPage
    jsr memoryRemapBlock
    jmp __b2
    // main::@2
  __b2:
    // [5] *((const byte*) main::block2+(byte) 2) ← (byte) $55 -- _deref_pbuc1=vbuc2 
    // Put 0x55, 0xaainto $10002
    lda #$55
    sta block2+2
    // [6] *((const byte*) main::block2+(byte) 3) ← (byte) $aa -- _deref_pbuc1=vbuc2 
    lda #$aa
    sta block2+3
    // [7] call memoryRemap 
  // Remap [$4000-$5fff] and [$8000-$9fff] to both point to [$10000-$11fff] (notice usage of page offsets)
    // [24] phi from main::@2 to memoryRemap [phi:main::@2->memoryRemap]
  memoryRemap_from___b2:
    // [24] phi (word) memoryRemap::upperPageOffset#2 = (byte) $80 [phi:main::@2->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<$80
    sta.z memoryRemap.upperPageOffset
    lda #>$80
    sta.z memoryRemap.upperPageOffset+1
    // [24] phi (byte) memoryRemap::remapBlocks#2 = (const nomodify byte) MEMORYBLOCK_4000|(const nomodify byte) MEMORYBLOCK_8000 [phi:main::@2->memoryRemap#1] -- vbuz1=vbuc1 
    lda #MEMORYBLOCK_4000|MEMORYBLOCK_8000
    sta.z memoryRemap.remapBlocks
    // [24] phi (word) memoryRemap::lowerPageOffset#2 = (byte) $c0 [phi:main::@2->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<$c0
    sta.z memoryRemap.lowerPageOffset
    lda #>$c0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __b3
    // main::@3
  __b3:
    // [8] *((const byte*) main::block2+(byte) 4) ← *((const byte*) main::block1+(byte) 2) -- _deref_pbuc1=_deref_pbuc2 
    // Put 0x55, 0xaa into $10004 in a convoluted way
    lda block1+2
    sta block2+4
    // [9] *((const byte*) main::block1+(byte) 5) ← *((const byte*) main::block2+(byte) 1) -- _deref_pbuc1=_deref_pbuc2 
    lda block2+1
    sta block1+5
    // [10] call memoryRemap256M 
  // Remap [$4000-$5fff] to both point to [$ff80000-$ff81fff] COLORAM! (notice usage of page offsets)
    // [41] phi from main::@3 to memoryRemap256M [phi:main::@3->memoryRemap256M]
  memoryRemap256M_from___b3:
    // [41] phi (byte) memoryRemap256M::remapBlocks#2 = (const nomodify byte) MEMORYBLOCK_4000 [phi:main::@3->memoryRemap256M#0] -- vbuz1=vbuc1 
    lda #MEMORYBLOCK_4000
    sta.z memoryRemap256M.remapBlocks
    // [41] phi (dword) memoryRemap256M::lowerPageOffset#2 = (dword)(number) $ff800-(number) $40 [phi:main::@3->memoryRemap256M#1] -- vduz1=vduc1 
    lda #<$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset
    lda #>$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset+1
    lda #<$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+2
    lda #>$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    jmp __b4
    // main::@4
  __b4:
    // [11] *((const byte*) main::block1) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Put colors in the upper left corner!
    lda #0
    sta block1
    // [12] *((const byte*) main::block1+(byte) 1) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta block1+1
    // [13] call memoryRemap256M 
  // Remap [$4000-$5fff] back to normal memory!
    // [41] phi from main::@4 to memoryRemap256M [phi:main::@4->memoryRemap256M]
  memoryRemap256M_from___b4:
    // [41] phi (byte) memoryRemap256M::remapBlocks#2 = (byte) 0 [phi:main::@4->memoryRemap256M#0] -- vbuz1=vbuc1 
    lda #0
    sta.z memoryRemap256M.remapBlocks
    // [41] phi (dword) memoryRemap256M::lowerPageOffset#2 = (byte) 0 [phi:main::@4->memoryRemap256M#1] -- vduz1=vbuc1 
    lda #0
    sta.z memoryRemap256M.lowerPageOffset
    lda #0
    sta.z memoryRemap256M.lowerPageOffset+1
    sta.z memoryRemap256M.lowerPageOffset+2
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    jmp __breturn
    // main::@return
  __breturn:
    // [14] return 
    rts
}
  // memoryRemapBlock
// Remap a single 8K memory block in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// All the other 8K memory blocks will not be mapped and will point to their own address in the lowest 64K of the MEGA65 memory.
// blockPage: Page address of the 8K memory block to remap (ie. the block that is remapped is $100 * the passed page address.) 
// memoryPage: Page address of the memory that the block should point to in the 1MB memory space of the MEGA65. 
// Ie. the memory that will be pointed to is $100 * the passed page address. Only the lower 12bits of the passed value is used.
// memoryRemapBlock(byte zp(2) blockPage)
memoryRemapBlock: {
    .label pageOffset = $d
    .label block = $f
    .label blockBits = $10
    .label blockPage = 2
    // [16] (word) memoryRemapBlock::pageOffset#0 ← (word) $100 - (byte) memoryRemapBlock::blockPage#2 -- vwuz1=vwuc1_minus_vbuz2 
    sec
    lda #<$100
    sbc.z blockPage
    sta.z pageOffset
    lda #>$100
    sbc #0
    sta.z pageOffset+1
    // [17] (byte) memoryRemapBlock::block#0 ← (byte) memoryRemapBlock::blockPage#2 >> (byte) 5 -- vbuz1=vbuz2_ror_5 
    lda.z blockPage
    lsr
    lsr
    lsr
    lsr
    lsr
    sta.z block
    // [18] (byte) memoryRemapBlock::blockBits#0 ← (byte) 1 << (byte) memoryRemapBlock::block#0 -- vbuz1=vbuc1_rol_vbuz2 
    lda #1
    ldy.z block
    cpy #0
    beq !e+
  !:
    asl
    dey
    bne !-
  !e:
    sta.z blockBits
    // [19] (byte) memoryRemap::remapBlocks#1 ← (byte) memoryRemapBlock::blockBits#0 -- vbuz1=vbuz2 
    lda.z blockBits
    sta.z memoryRemap.remapBlocks
    // [20] (word) memoryRemap::lowerPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0 -- vwuz1=vwuz2 
    lda.z pageOffset
    sta.z memoryRemap.lowerPageOffset
    lda.z pageOffset+1
    sta.z memoryRemap.lowerPageOffset+1
    // [21] (word) memoryRemap::upperPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0 -- vwuz1=vwuz2 
    lda.z pageOffset
    sta.z memoryRemap.upperPageOffset
    lda.z pageOffset+1
    sta.z memoryRemap.upperPageOffset+1
    // [22] call memoryRemap 
    // [24] phi from memoryRemapBlock to memoryRemap [phi:memoryRemapBlock->memoryRemap]
  memoryRemap_from_memoryRemapBlock:
    // [24] phi (word) memoryRemap::upperPageOffset#2 = (word) memoryRemap::upperPageOffset#1 [phi:memoryRemapBlock->memoryRemap#0] -- register_copy 
    // [24] phi (byte) memoryRemap::remapBlocks#2 = (byte) memoryRemap::remapBlocks#1 [phi:memoryRemapBlock->memoryRemap#1] -- register_copy 
    // [24] phi (word) memoryRemap::lowerPageOffset#2 = (word) memoryRemap::lowerPageOffset#1 [phi:memoryRemapBlock->memoryRemap#2] -- register_copy 
    jsr memoryRemap
    jmp __breturn
    // memoryRemapBlock::@return
  __breturn:
    // [23] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000. 
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000. 
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000. 
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000. 
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000. 
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000. 
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000. 
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000. 
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.  
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.  
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.  
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.  
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000  
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.  
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.  
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.  
// memoryRemap(byte zp(5) remapBlocks, word zp(3) lowerPageOffset, word zp(6) upperPageOffset)
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __0 = $11
    .label __1 = $12
    .label __2 = $13
    .label __3 = $14
    .label __4 = $15
    .label __5 = $16
    .label __6 = $17
    .label __7 = $18
    .label __8 = $19
    .label __9 = $1a
    .label remapBlocks = 5
    .label lowerPageOffset = 3
    .label upperPageOffset = 6
    // [25] (byte~) memoryRemap::$0 ← < (word) memoryRemap::lowerPageOffset#2 -- vbuz1=_lo_vwuz2 
    lda.z lowerPageOffset
    sta.z __0
    // [26] *((const byte*) memoryRemap::aVal) ← (byte~) memoryRemap::$0 -- _deref_pbuc1=vbuz1 
    lda.z __0
    sta aVal
    // [27] (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#2 << (byte) 4 -- vbuz1=vbuz2_rol_4 
    lda.z remapBlocks
    asl
    asl
    asl
    asl
    sta.z __1
    // [28] (byte~) memoryRemap::$2 ← > (word) memoryRemap::lowerPageOffset#2 -- vbuz1=_hi_vwuz2 
    lda.z lowerPageOffset+1
    sta.z __2
    // [29] (byte~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and.z __2
    sta.z __3
    // [30] (byte~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (byte~) memoryRemap::$3 -- vbuz1=vbuz2_bor_vbuz3 
    lda.z __1
    ora.z __3
    sta.z __4
    // [31] *((const byte*) memoryRemap::xVal) ← (byte~) memoryRemap::$4 -- _deref_pbuc1=vbuz1 
    lda.z __4
    sta xVal
    // [32] (byte~) memoryRemap::$5 ← < (word) memoryRemap::upperPageOffset#2 -- vbuz1=_lo_vwuz2 
    lda.z upperPageOffset
    sta.z __5
    // [33] *((const byte*) memoryRemap::yVal) ← (byte~) memoryRemap::$5 -- _deref_pbuc1=vbuz1 
    lda.z __5
    sta yVal
    // [34] (byte~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (byte) $f0 -- vbuz1=vbuz2_band_vbuc1 
    lda #$f0
    and.z remapBlocks
    sta.z __6
    // [35] (byte~) memoryRemap::$7 ← > (word) memoryRemap::upperPageOffset#2 -- vbuz1=_hi_vwuz2 
    lda.z upperPageOffset+1
    sta.z __7
    // [36] (byte~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and.z __7
    sta.z __8
    // [37] (byte~) memoryRemap::$9 ← (byte~) memoryRemap::$6 | (byte~) memoryRemap::$8 -- vbuz1=vbuz2_bor_vbuz3 
    lda.z __6
    ora.z __8
    sta.z __9
    // [38] *((const byte*) memoryRemap::zVal) ← (byte~) memoryRemap::$9 -- _deref_pbuc1=vbuz1 
    lda.z __9
    sta zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [40] return 
    rts
}
  // memoryRemap256M
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the entire 256MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in file:///Users/jespergravgaard/Downloads/MEGA65-Book_draft%20(5).pdf for a description of the CPU memory remapper of the MEGA65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000. 
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000. 
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000. 
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000. 
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000. 
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000. 
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000. 
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000. 
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.  
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.  
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.  
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.  
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000  
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.  
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.  
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.  
// memoryRemap256M(byte zp($c) remapBlocks, dword zp(8) lowerPageOffset)
memoryRemap256M: {
    .label lMb = $fa
    .label uMb = $fb
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __0 = $1b
    .label __1 = $1f
    .label __5 = $22
    .label __6 = $23
    .label __7 = $20
    .label __8 = $24
    .label __9 = $25
    .label __10 = $26
    .label __17 = $27
    .label lowerPageOffset = 8
    .label remapBlocks = $c
    // [42] (dword~) memoryRemap256M::$0 ← (dword) memoryRemap256M::lowerPageOffset#2 >> (byte) 4 -- vduz1=vduz2_ror_4 
    lda.z lowerPageOffset+3
    lsr
    sta.z __0+3
    lda.z lowerPageOffset+2
    ror
    sta.z __0+2
    lda.z lowerPageOffset+1
    ror
    sta.z __0+1
    lda.z lowerPageOffset
    ror
    sta.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    // [43] (byte~) memoryRemap256M::$1 ← > (word)(dword~) memoryRemap256M::$0 -- vbuz1=_hi__word_vduz2 
    lda.z __0+1
    sta.z __1
    // [44] *((const byte*) memoryRemap256M::lMb) ← (byte~) memoryRemap256M::$1 -- _deref_pbuc1=vbuz1 
    lda.z __1
    sta lMb
    // [45] *((const byte*) memoryRemap256M::uMb) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta uMb
    // [46] (word~) memoryRemap256M::$7 ← < (dword) memoryRemap256M::lowerPageOffset#2 -- vwuz1=_lo_vduz2 
    lda.z lowerPageOffset
    sta.z __7
    lda.z lowerPageOffset+1
    sta.z __7+1
    // [47] (byte~) memoryRemap256M::$5 ← < (word~) memoryRemap256M::$7 -- vbuz1=_lo_vwuz2 
    lda.z __7
    sta.z __5
    // [48] *((const byte*) memoryRemap256M::aVal) ← (byte~) memoryRemap256M::$5 -- _deref_pbuc1=vbuz1 
    lda.z __5
    sta aVal
    // [49] (byte~) memoryRemap256M::$6 ← (byte) memoryRemap256M::remapBlocks#2 << (byte) 4 -- vbuz1=vbuz2_rol_4 
    lda.z remapBlocks
    asl
    asl
    asl
    asl
    sta.z __6
    // [50] (byte~) memoryRemap256M::$8 ← > (word~) memoryRemap256M::$7 -- vbuz1=_hi_vwuz2 
    lda.z __7+1
    sta.z __8
    // [51] (byte~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and.z __8
    sta.z __9
    // [52] (byte~) memoryRemap256M::$10 ← (byte~) memoryRemap256M::$6 | (byte~) memoryRemap256M::$9 -- vbuz1=vbuz2_bor_vbuz3 
    lda.z __6
    ora.z __9
    sta.z __10
    // [53] *((const byte*) memoryRemap256M::xVal) ← (byte~) memoryRemap256M::$10 -- _deref_pbuc1=vbuz1 
    lda.z __10
    sta xVal
    // [54] *((const byte*) memoryRemap256M::yVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta yVal
    // [55] (byte~) memoryRemap256M::$17 ← (byte) memoryRemap256M::remapBlocks#2 & (byte) $f0 -- vbuz1=vbuz2_band_vbuc1 
    lda #$f0
    and.z remapBlocks
    sta.z __17
    // [56] *((const byte*) memoryRemap256M::zVal) ← (byte~) memoryRemap256M::$17 -- _deref_pbuc1=vbuz1 
    lda.z __17
    sta zVal
    // asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda lMb
    ldx #$f
    ldy uMb
    ldz #0
    map
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap256M::@return
  __breturn:
    // [58] return 
    rts
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] *((const byte*) main::block1) ← (byte) $55 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] *((const byte*) main::block1+(byte) 1) ← (byte) $aa [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *((const byte*) main::block2+(byte) 2) ← (byte) $55 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] *((const byte*) main::block2+(byte) 3) ← (byte) $aa [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] *((const byte*) main::block2+(byte) 4) ← *((const byte*) main::block1+(byte) 2) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] *((const byte*) main::block1+(byte) 5) ← *((const byte*) main::block2+(byte) 1) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [11] *((const byte*) main::block1) ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [12] *((const byte*) main::block1+(byte) 1) ← (byte) 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [16] (word) memoryRemapBlock::pageOffset#0 ← (word) $100 - (byte) memoryRemapBlock::blockPage#2 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ memoryRemapBlock::blockPage#2 ]
Statement [17] (byte) memoryRemapBlock::block#0 ← (byte) memoryRemapBlock::blockPage#2 >> (byte) 5 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [18] (byte) memoryRemapBlock::blockBits#0 ← (byte) 1 << (byte) memoryRemapBlock::block#0 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [20] (word) memoryRemap::lowerPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ]
Statement [21] (word) memoryRemap::upperPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0 [ memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 memoryRemap::upperPageOffset#1 ] ( memoryRemapBlock:1 [ memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 memoryRemap::upperPageOffset#1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 memoryRemap::upperPageOffset#1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [27] (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#2 << (byte) 4 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] ( memoryRemap:7 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { }  memoryRemapBlock:1::memoryRemap:22 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:22 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [29] (byte~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (byte) $f [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] ( memoryRemap:7 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:1::memoryRemap:22 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:22 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:18 [ memoryRemap::$1 ]
Statement [34] (byte~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (byte) $f0 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] ( memoryRemap:7 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { }  memoryRemapBlock:1::memoryRemap:22 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:22 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [36] (byte~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (byte) $f [ memoryRemap::$6 memoryRemap::$8 ] ( memoryRemap:7 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:1::memoryRemap:22 [ memoryRemap::$6 memoryRemap::$8 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:22 [ memoryRemap::$6 memoryRemap::$8 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:23 [ memoryRemap::$6 ]
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [42] (dword~) memoryRemap256M::$0 ← (dword) memoryRemap256M::lowerPageOffset#2 >> (byte) 4 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] ( memoryRemap256M:10 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] { }  memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:12 [ memoryRemap256M::remapBlocks#2 ]
Statement [45] *((const byte*) memoryRemap256M::uMb) ← (byte) 0 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] ( memoryRemap256M:10 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] { }  memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] { }  ) always clobbers reg byte a 
Statement [46] (word~) memoryRemap256M::$7 ← < (dword) memoryRemap256M::lowerPageOffset#2 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 ] ( memoryRemap256M:10 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 ] { }  memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 ] { }  ) always clobbers reg byte a 
Statement [49] (byte~) memoryRemap256M::$6 ← (byte) memoryRemap256M::remapBlocks#2 << (byte) 4 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 memoryRemap256M::$6 ] ( memoryRemap256M:10 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 memoryRemap256M::$6 ] { }  memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 memoryRemap256M::$6 ] { }  ) always clobbers reg byte a 
Statement [51] (byte~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (byte) $f [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] ( memoryRemap256M:10 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] { }  memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:35 [ memoryRemap256M::$6 ]
Statement [54] *((const byte*) memoryRemap256M::yVal) ← (byte) 0 [ memoryRemap256M::remapBlocks#2 ] ( memoryRemap256M:10 [ memoryRemap256M::remapBlocks#2 ] { }  memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 ] { }  ) always clobbers reg byte a 
Statement [55] (byte~) memoryRemap256M::$17 ← (byte) memoryRemap256M::remapBlocks#2 & (byte) $f0 [ memoryRemap256M::$17 ] ( memoryRemap256M:10 [ memoryRemap256M::$17 ] { }  memoryRemap256M:13 [ memoryRemap256M::$17 ] { }  ) always clobbers reg byte a 
Statement asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [2] *((const byte*) main::block1) ← (byte) $55 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] *((const byte*) main::block1+(byte) 1) ← (byte) $aa [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *((const byte*) main::block2+(byte) 2) ← (byte) $55 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] *((const byte*) main::block2+(byte) 3) ← (byte) $aa [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] *((const byte*) main::block2+(byte) 4) ← *((const byte*) main::block1+(byte) 2) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] *((const byte*) main::block1+(byte) 5) ← *((const byte*) main::block2+(byte) 1) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [11] *((const byte*) main::block1) ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [12] *((const byte*) main::block1+(byte) 1) ← (byte) 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [16] (word) memoryRemapBlock::pageOffset#0 ← (word) $100 - (byte) memoryRemapBlock::blockPage#2 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [17] (byte) memoryRemapBlock::block#0 ← (byte) memoryRemapBlock::blockPage#2 >> (byte) 5 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [18] (byte) memoryRemapBlock::blockBits#0 ← (byte) 1 << (byte) memoryRemapBlock::block#0 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [20] (word) memoryRemap::lowerPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [21] (word) memoryRemap::upperPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0 [ memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 memoryRemap::upperPageOffset#1 ] ( memoryRemapBlock:1 [ memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 memoryRemap::upperPageOffset#1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemap::remapBlocks#1 memoryRemap::lowerPageOffset#1 memoryRemap::upperPageOffset#1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [27] (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#2 << (byte) 4 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] ( memoryRemap:7 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { }  memoryRemapBlock:1::memoryRemap:22 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:22 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [29] (byte~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (byte) $f [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] ( memoryRemap:7 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:1::memoryRemap:22 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:22 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [34] (byte~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (byte) $f0 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] ( memoryRemap:7 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { }  memoryRemapBlock:1::memoryRemap:22 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:22 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [36] (byte~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (byte) $f [ memoryRemap::$6 memoryRemap::$8 ] ( memoryRemap:7 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:1::memoryRemap:22 [ memoryRemap::$6 memoryRemap::$8 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:22 [ memoryRemap::$6 memoryRemap::$8 ] { { memoryRemap::remapBlocks#1 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#1 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [42] (dword~) memoryRemap256M::$0 ← (dword) memoryRemap256M::lowerPageOffset#2 >> (byte) 4 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] ( memoryRemap256M:10 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] { }  memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] { }  ) always clobbers reg byte a 
Statement [45] *((const byte*) memoryRemap256M::uMb) ← (byte) 0 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] ( memoryRemap256M:10 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] { }  memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] { }  ) always clobbers reg byte a 
Statement [46] (word~) memoryRemap256M::$7 ← < (dword) memoryRemap256M::lowerPageOffset#2 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 ] ( memoryRemap256M:10 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 ] { }  memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 ] { }  ) always clobbers reg byte a 
Statement [49] (byte~) memoryRemap256M::$6 ← (byte) memoryRemap256M::remapBlocks#2 << (byte) 4 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 memoryRemap256M::$6 ] ( memoryRemap256M:10 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 memoryRemap256M::$6 ] { }  memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$7 memoryRemap256M::$6 ] { }  ) always clobbers reg byte a 
Statement [51] (byte~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (byte) $f [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] ( memoryRemap256M:10 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] { }  memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] { }  ) always clobbers reg byte a 
Statement [54] *((const byte*) memoryRemap256M::yVal) ← (byte) 0 [ memoryRemap256M::remapBlocks#2 ] ( memoryRemap256M:10 [ memoryRemap256M::remapBlocks#2 ] { }  memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 ] { }  ) always clobbers reg byte a 
Statement [55] (byte~) memoryRemap256M::$17 ← (byte) memoryRemap256M::remapBlocks#2 & (byte) $f0 [ memoryRemap256M::$17 ] ( memoryRemap256M:10 [ memoryRemap256M::$17 ] { }  memoryRemap256M:13 [ memoryRemap256M::$17 ] { }  ) always clobbers reg byte a 
Statement asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Potential registers zp[1]:2 [ memoryRemapBlock::blockPage#2 ] : zp[1]:2 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:3 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 ] : zp[2]:3 , 
Potential registers zp[1]:5 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ] : zp[1]:5 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:6 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#1 ] : zp[2]:6 , 
Potential registers zp[4]:8 [ memoryRemap256M::lowerPageOffset#2 ] : zp[4]:8 , 
Potential registers zp[1]:12 [ memoryRemap256M::remapBlocks#2 ] : zp[1]:12 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:13 [ memoryRemapBlock::pageOffset#0 ] : zp[2]:13 , 
Potential registers zp[1]:15 [ memoryRemapBlock::block#0 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:16 [ memoryRemapBlock::blockBits#0 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:17 [ memoryRemap::$0 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:18 [ memoryRemap::$1 ] : zp[1]:18 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:19 [ memoryRemap::$2 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:20 [ memoryRemap::$3 ] : zp[1]:20 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:21 [ memoryRemap::$4 ] : zp[1]:21 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:22 [ memoryRemap::$5 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:23 [ memoryRemap::$6 ] : zp[1]:23 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:24 [ memoryRemap::$7 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:25 [ memoryRemap::$8 ] : zp[1]:25 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:26 [ memoryRemap::$9 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[4]:27 [ memoryRemap256M::$0 ] : zp[4]:27 , 
Potential registers zp[1]:31 [ memoryRemap256M::$1 ] : zp[1]:31 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:32 [ memoryRemap256M::$7 ] : zp[2]:32 , 
Potential registers zp[1]:34 [ memoryRemap256M::$5 ] : zp[1]:34 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:35 [ memoryRemap256M::$6 ] : zp[1]:35 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:36 [ memoryRemap256M::$8 ] : zp[1]:36 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:37 [ memoryRemap256M::$9 ] : zp[1]:37 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:38 [ memoryRemap256M::$10 ] : zp[1]:38 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:39 [ memoryRemap256M::$17 ] : zp[1]:39 , reg byte a , reg byte x , reg byte y , reg byte z , 

REGISTER UPLIFT SCOPES
Uplift Scope [memoryRemap] 202: zp[1]:17 [ memoryRemap::$0 ] 202: zp[1]:19 [ memoryRemap::$2 ] 202: zp[1]:20 [ memoryRemap::$3 ] 202: zp[1]:21 [ memoryRemap::$4 ] 202: zp[1]:22 [ memoryRemap::$5 ] 202: zp[1]:24 [ memoryRemap::$7 ] 202: zp[1]:25 [ memoryRemap::$8 ] 202: zp[1]:26 [ memoryRemap::$9 ] 67.33: zp[1]:18 [ memoryRemap::$1 ] 67.33: zp[1]:23 [ memoryRemap::$6 ] 64.25: zp[2]:3 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 ] 41.36: zp[2]:6 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#1 ] 28.63: zp[1]:5 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ] 
Uplift Scope [memoryRemap256M] 22: zp[1]:31 [ memoryRemap256M::$1 ] 22: zp[1]:34 [ memoryRemap256M::$5 ] 22: zp[1]:36 [ memoryRemap256M::$8 ] 22: zp[1]:37 [ memoryRemap256M::$9 ] 22: zp[1]:38 [ memoryRemap256M::$10 ] 22: zp[1]:39 [ memoryRemap256M::$17 ] 11: zp[4]:27 [ memoryRemap256M::$0 ] 8.25: zp[2]:32 [ memoryRemap256M::$7 ] 7.33: zp[1]:35 [ memoryRemap256M::$6 ] 4.4: zp[4]:8 [ memoryRemap256M::lowerPageOffset#2 ] 1.57: zp[1]:12 [ memoryRemap256M::remapBlocks#2 ] 
Uplift Scope [memoryRemapBlock] 22: zp[1]:15 [ memoryRemapBlock::block#0 ] 22: zp[1]:16 [ memoryRemapBlock::blockBits#0 ] 11: zp[1]:2 [ memoryRemapBlock::blockPage#2 ] 6.6: zp[2]:13 [ memoryRemapBlock::pageOffset#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [MOS4569_VICIII] 
Uplift Scope [MEGA65_VICIV] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [memoryRemap] best 642 combination reg byte a [ memoryRemap::$0 ] reg byte a [ memoryRemap::$2 ] reg byte a [ memoryRemap::$3 ] zp[1]:21 [ memoryRemap::$4 ] zp[1]:22 [ memoryRemap::$5 ] zp[1]:24 [ memoryRemap::$7 ] zp[1]:25 [ memoryRemap::$8 ] zp[1]:26 [ memoryRemap::$9 ] zp[1]:18 [ memoryRemap::$1 ] zp[1]:23 [ memoryRemap::$6 ] zp[2]:3 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 ] zp[2]:6 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#1 ] zp[1]:5 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ] 
Limited combination testing to 100 combinations of 25000000 possible.
Uplifting [memoryRemap256M] best 624 combination reg byte a [ memoryRemap256M::$1 ] reg byte a [ memoryRemap256M::$5 ] reg byte a [ memoryRemap256M::$8 ] zp[1]:37 [ memoryRemap256M::$9 ] zp[1]:38 [ memoryRemap256M::$10 ] zp[1]:39 [ memoryRemap256M::$17 ] zp[4]:27 [ memoryRemap256M::$0 ] zp[2]:32 [ memoryRemap256M::$7 ] zp[1]:35 [ memoryRemap256M::$6 ] zp[4]:8 [ memoryRemap256M::lowerPageOffset#2 ] zp[1]:12 [ memoryRemap256M::remapBlocks#2 ] 
Limited combination testing to 100 combinations of 250000 possible.
Uplifting [memoryRemapBlock] best 610 combination reg byte a [ memoryRemapBlock::block#0 ] reg byte a [ memoryRemapBlock::blockBits#0 ] reg byte x [ memoryRemapBlock::blockPage#2 ] zp[2]:13 [ memoryRemapBlock::pageOffset#0 ] 
Uplifting [MOS6526_CIA] best 610 combination 
Uplifting [MOS6569_VICII] best 610 combination 
Uplifting [MOS6581_SID] best 610 combination 
Uplifting [MOS4569_VICIII] best 610 combination 
Uplifting [MEGA65_VICIV] best 610 combination 
Uplifting [main] best 610 combination 
Uplifting [] best 610 combination 
Attempting to uplift remaining variables inzp[1]:21 [ memoryRemap::$4 ]
Uplifting [memoryRemap] best 604 combination reg byte a [ memoryRemap::$4 ] 
Attempting to uplift remaining variables inzp[1]:22 [ memoryRemap::$5 ]
Uplifting [memoryRemap] best 598 combination reg byte a [ memoryRemap::$5 ] 
Attempting to uplift remaining variables inzp[1]:24 [ memoryRemap::$7 ]
Uplifting [memoryRemap] best 592 combination reg byte a [ memoryRemap::$7 ] 
Attempting to uplift remaining variables inzp[1]:25 [ memoryRemap::$8 ]
Uplifting [memoryRemap] best 586 combination reg byte a [ memoryRemap::$8 ] 
Attempting to uplift remaining variables inzp[1]:26 [ memoryRemap::$9 ]
Uplifting [memoryRemap] best 580 combination reg byte a [ memoryRemap::$9 ] 
Attempting to uplift remaining variables inzp[1]:18 [ memoryRemap::$1 ]
Uplifting [memoryRemap] best 580 combination zp[1]:18 [ memoryRemap::$1 ] 
Attempting to uplift remaining variables inzp[1]:23 [ memoryRemap::$6 ]
Uplifting [memoryRemap] best 580 combination zp[1]:23 [ memoryRemap::$6 ] 
Attempting to uplift remaining variables inzp[1]:5 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ]
Uplifting [memoryRemap] best 571 combination reg byte z [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ] 
Attempting to uplift remaining variables inzp[1]:37 [ memoryRemap256M::$9 ]
Uplifting [memoryRemap256M] best 565 combination reg byte a [ memoryRemap256M::$9 ] 
Attempting to uplift remaining variables inzp[1]:38 [ memoryRemap256M::$10 ]
Uplifting [memoryRemap256M] best 559 combination reg byte a [ memoryRemap256M::$10 ] 
Attempting to uplift remaining variables inzp[1]:39 [ memoryRemap256M::$17 ]
Uplifting [memoryRemap256M] best 553 combination reg byte a [ memoryRemap256M::$17 ] 
Attempting to uplift remaining variables inzp[1]:35 [ memoryRemap256M::$6 ]
Uplifting [memoryRemap256M] best 553 combination zp[1]:35 [ memoryRemap256M::$6 ] 
Attempting to uplift remaining variables inzp[1]:12 [ memoryRemap256M::remapBlocks#2 ]
Uplifting [memoryRemap256M] best 543 combination reg byte z [ memoryRemap256M::remapBlocks#2 ] 
Coalescing zero page register [ zp[2]:3 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 ] ] with [ zp[2]:13 [ memoryRemapBlock::pageOffset#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:32 [ memoryRemap256M::$7 ] ] with [ zp[2]:3 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 ] ]
Coalescing zero page register [ zp[1]:35 [ memoryRemap256M::$6 ] ] with [ zp[1]:18 [ memoryRemap::$1 ] ]
Allocated (was zp[2]:6) zp[2]:2 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#1 ]
Allocated (was zp[4]:8) zp[4]:4 [ memoryRemap256M::lowerPageOffset#2 ]
Allocated (was zp[1]:23) zp[1]:8 [ memoryRemap::$6 ]
Allocated (was zp[4]:27) zp[4]:9 [ memoryRemap256M::$0 ]
Allocated (was zp[2]:32) zp[2]:13 [ memoryRemap256M::$7 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 ]
Allocated (was zp[1]:35) zp[1]:15 [ memoryRemap256M::$6 memoryRemap::$1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test the MAP instruction for remapping memory
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in file:///Users/jespergravgaard/Downloads/MEGA65-Book_draft%20(5).pdf for a description of the CPU memory remapper of the MEGA65.
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="memorymap-test.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // Bit representing 8K block #2 of the 64K addressable memory ($4000-$5fff)
  .const MEMORYBLOCK_4000 = 4
  // Bit representing 8K block #4 of the 64K addressable memory ($8000-$9fff)
  .const MEMORYBLOCK_8000 = $10
.segment Code
  // main
main: {
    .label block1 = $4000
    .label block2 = $8000
    // [1] call memoryRemapBlock 
  // Remap [$4000-$5fff] to point to [$10000-$11fff]
    // [15] phi from main to memoryRemapBlock [phi:main->memoryRemapBlock]
  memoryRemapBlock_from_main:
    // [15] phi (byte) memoryRemapBlock::blockPage#2 = (byte) $40 [phi:main->memoryRemapBlock#0] -- vbuxx=vbuc1 
    ldx #$40
    jsr memoryRemapBlock
    jmp __b1
    // main::@1
  __b1:
    // [2] *((const byte*) main::block1) ← (byte) $55 -- _deref_pbuc1=vbuc2 
    // Put 0x55, 0xaa into $10000
    lda #$55
    sta block1
    // [3] *((const byte*) main::block1+(byte) 1) ← (byte) $aa -- _deref_pbuc1=vbuc2 
    lda #$aa
    sta block1+1
    // [4] call memoryRemapBlock 
  // Remap [$8000-$9fff] to point to [$10000-$11fff]
    // [15] phi from main::@1 to memoryRemapBlock [phi:main::@1->memoryRemapBlock]
  memoryRemapBlock_from___b1:
    // [15] phi (byte) memoryRemapBlock::blockPage#2 = (byte) $80 [phi:main::@1->memoryRemapBlock#0] -- vbuxx=vbuc1 
    ldx #$80
    jsr memoryRemapBlock
    jmp __b2
    // main::@2
  __b2:
    // [5] *((const byte*) main::block2+(byte) 2) ← (byte) $55 -- _deref_pbuc1=vbuc2 
    // Put 0x55, 0xaainto $10002
    lda #$55
    sta block2+2
    // [6] *((const byte*) main::block2+(byte) 3) ← (byte) $aa -- _deref_pbuc1=vbuc2 
    lda #$aa
    sta block2+3
    // [7] call memoryRemap 
  // Remap [$4000-$5fff] and [$8000-$9fff] to both point to [$10000-$11fff] (notice usage of page offsets)
    // [24] phi from main::@2 to memoryRemap [phi:main::@2->memoryRemap]
  memoryRemap_from___b2:
    // [24] phi (word) memoryRemap::upperPageOffset#2 = (byte) $80 [phi:main::@2->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<$80
    sta.z memoryRemap.upperPageOffset
    lda #>$80
    sta.z memoryRemap.upperPageOffset+1
    // [24] phi (byte) memoryRemap::remapBlocks#2 = (const nomodify byte) MEMORYBLOCK_4000|(const nomodify byte) MEMORYBLOCK_8000 [phi:main::@2->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #MEMORYBLOCK_4000|MEMORYBLOCK_8000
    // [24] phi (word) memoryRemap::lowerPageOffset#2 = (byte) $c0 [phi:main::@2->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<$c0
    sta.z memoryRemap.lowerPageOffset
    lda #>$c0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __b3
    // main::@3
  __b3:
    // [8] *((const byte*) main::block2+(byte) 4) ← *((const byte*) main::block1+(byte) 2) -- _deref_pbuc1=_deref_pbuc2 
    // Put 0x55, 0xaa into $10004 in a convoluted way
    lda block1+2
    sta block2+4
    // [9] *((const byte*) main::block1+(byte) 5) ← *((const byte*) main::block2+(byte) 1) -- _deref_pbuc1=_deref_pbuc2 
    lda block2+1
    sta block1+5
    // [10] call memoryRemap256M 
  // Remap [$4000-$5fff] to both point to [$ff80000-$ff81fff] COLORAM! (notice usage of page offsets)
    // [41] phi from main::@3 to memoryRemap256M [phi:main::@3->memoryRemap256M]
  memoryRemap256M_from___b3:
    // [41] phi (byte) memoryRemap256M::remapBlocks#2 = (const nomodify byte) MEMORYBLOCK_4000 [phi:main::@3->memoryRemap256M#0] -- vbuzz=vbuc1 
    ldz #MEMORYBLOCK_4000
    // [41] phi (dword) memoryRemap256M::lowerPageOffset#2 = (dword)(number) $ff800-(number) $40 [phi:main::@3->memoryRemap256M#1] -- vduz1=vduc1 
    lda #<$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset
    lda #>$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset+1
    lda #<$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+2
    lda #>$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    jmp __b4
    // main::@4
  __b4:
    // [11] *((const byte*) main::block1) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Put colors in the upper left corner!
    lda #0
    sta block1
    // [12] *((const byte*) main::block1+(byte) 1) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta block1+1
    // [13] call memoryRemap256M 
  // Remap [$4000-$5fff] back to normal memory!
    // [41] phi from main::@4 to memoryRemap256M [phi:main::@4->memoryRemap256M]
  memoryRemap256M_from___b4:
    // [41] phi (byte) memoryRemap256M::remapBlocks#2 = (byte) 0 [phi:main::@4->memoryRemap256M#0] -- vbuzz=vbuc1 
    ldz #0
    // [41] phi (dword) memoryRemap256M::lowerPageOffset#2 = (byte) 0 [phi:main::@4->memoryRemap256M#1] -- vduz1=vbuc1 
    lda #0
    sta.z memoryRemap256M.lowerPageOffset
    lda #0
    sta.z memoryRemap256M.lowerPageOffset+1
    sta.z memoryRemap256M.lowerPageOffset+2
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    jmp __breturn
    // main::@return
  __breturn:
    // [14] return 
    rts
}
  // memoryRemapBlock
// Remap a single 8K memory block in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// All the other 8K memory blocks will not be mapped and will point to their own address in the lowest 64K of the MEGA65 memory.
// blockPage: Page address of the 8K memory block to remap (ie. the block that is remapped is $100 * the passed page address.) 
// memoryPage: Page address of the memory that the block should point to in the 1MB memory space of the MEGA65. 
// Ie. the memory that will be pointed to is $100 * the passed page address. Only the lower 12bits of the passed value is used.
// memoryRemapBlock(byte register(X) blockPage)
memoryRemapBlock: {
    .label pageOffset = $d
    // [16] (word) memoryRemapBlock::pageOffset#0 ← (word) $100 - (byte) memoryRemapBlock::blockPage#2 -- vwuz1=vwuc1_minus_vbuxx 
    stx.z $ff
    lda #<$100
    sec
    sbc.z $ff
    sta.z pageOffset
    lda #>$100
    sbc #0
    sta.z pageOffset+1
    // [17] (byte) memoryRemapBlock::block#0 ← (byte) memoryRemapBlock::blockPage#2 >> (byte) 5 -- vbuaa=vbuxx_ror_5 
    txa
    lsr
    lsr
    lsr
    lsr
    lsr
    // [18] (byte) memoryRemapBlock::blockBits#0 ← (byte) 1 << (byte) memoryRemapBlock::block#0 -- vbuaa=vbuc1_rol_vbuaa 
    tay
    lda #1
    cpy #0
    beq !e+
  !:
    asl
    dey
    bne !-
  !e:
    // [19] (byte) memoryRemap::remapBlocks#1 ← (byte) memoryRemapBlock::blockBits#0 -- vbuzz=vbuaa 
    taz
    // [20] (word) memoryRemap::lowerPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0
    // [21] (word) memoryRemap::upperPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0 -- vwuz1=vwuz2 
    lda.z pageOffset
    sta.z memoryRemap.upperPageOffset
    lda.z pageOffset+1
    sta.z memoryRemap.upperPageOffset+1
    // [22] call memoryRemap 
    // [24] phi from memoryRemapBlock to memoryRemap [phi:memoryRemapBlock->memoryRemap]
  memoryRemap_from_memoryRemapBlock:
    // [24] phi (word) memoryRemap::upperPageOffset#2 = (word) memoryRemap::upperPageOffset#1 [phi:memoryRemapBlock->memoryRemap#0] -- register_copy 
    // [24] phi (byte) memoryRemap::remapBlocks#2 = (byte) memoryRemap::remapBlocks#1 [phi:memoryRemapBlock->memoryRemap#1] -- register_copy 
    // [24] phi (word) memoryRemap::lowerPageOffset#2 = (word) memoryRemap::lowerPageOffset#1 [phi:memoryRemapBlock->memoryRemap#2] -- register_copy 
    jsr memoryRemap
    jmp __breturn
    // memoryRemapBlock::@return
  __breturn:
    // [23] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000. 
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000. 
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000. 
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000. 
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000. 
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000. 
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000. 
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000. 
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.  
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.  
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.  
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.  
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000  
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.  
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.  
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.  
// memoryRemap(byte register(Z) remapBlocks, word zp($d) lowerPageOffset, word zp(2) upperPageOffset)
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __1 = $f
    .label __6 = 8
    .label lowerPageOffset = $d
    .label upperPageOffset = 2
    // [25] (byte~) memoryRemap::$0 ← < (word) memoryRemap::lowerPageOffset#2 -- vbuaa=_lo_vwuz1 
    lda.z lowerPageOffset
    // [26] *((const byte*) memoryRemap::aVal) ← (byte~) memoryRemap::$0 -- _deref_pbuc1=vbuaa 
    sta aVal
    // [27] (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#2 << (byte) 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __1
    // [28] (byte~) memoryRemap::$2 ← > (word) memoryRemap::lowerPageOffset#2 -- vbuaa=_hi_vwuz1 
    lda.z lowerPageOffset+1
    // [29] (byte~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [30] (byte~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (byte~) memoryRemap::$3 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // [31] *((const byte*) memoryRemap::xVal) ← (byte~) memoryRemap::$4 -- _deref_pbuc1=vbuaa 
    sta xVal
    // [32] (byte~) memoryRemap::$5 ← < (word) memoryRemap::upperPageOffset#2 -- vbuaa=_lo_vwuz1 
    lda.z upperPageOffset
    // [33] *((const byte*) memoryRemap::yVal) ← (byte~) memoryRemap::$5 -- _deref_pbuc1=vbuaa 
    sta yVal
    // [34] (byte~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (byte) $f0 -- vbuz1=vbuzz_band_vbuc1 
    tza
    and #$f0
    sta.z __6
    // [35] (byte~) memoryRemap::$7 ← > (word) memoryRemap::upperPageOffset#2 -- vbuaa=_hi_vwuz1 
    lda.z upperPageOffset+1
    // [36] (byte~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [37] (byte~) memoryRemap::$9 ← (byte~) memoryRemap::$6 | (byte~) memoryRemap::$8 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // [38] *((const byte*) memoryRemap::zVal) ← (byte~) memoryRemap::$9 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [40] return 
    rts
}
  // memoryRemap256M
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the entire 256MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in file:///Users/jespergravgaard/Downloads/MEGA65-Book_draft%20(5).pdf for a description of the CPU memory remapper of the MEGA65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000. 
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000. 
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000. 
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000. 
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000. 
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000. 
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000. 
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000. 
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.  
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.  
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.  
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.  
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000  
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.  
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.  
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.  
// memoryRemap256M(byte register(Z) remapBlocks, dword zp(4) lowerPageOffset)
memoryRemap256M: {
    .label lMb = $fa
    .label uMb = $fb
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __0 = 9
    .label __6 = $f
    .label __7 = $d
    .label lowerPageOffset = 4
    // [42] (dword~) memoryRemap256M::$0 ← (dword) memoryRemap256M::lowerPageOffset#2 >> (byte) 4 -- vduz1=vduz2_ror_4 
    lda.z lowerPageOffset+3
    lsr
    sta.z __0+3
    lda.z lowerPageOffset+2
    ror
    sta.z __0+2
    lda.z lowerPageOffset+1
    ror
    sta.z __0+1
    lda.z lowerPageOffset
    ror
    sta.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    // [43] (byte~) memoryRemap256M::$1 ← > (word)(dword~) memoryRemap256M::$0 -- vbuaa=_hi__word_vduz1 
    lda.z __0+1
    // [44] *((const byte*) memoryRemap256M::lMb) ← (byte~) memoryRemap256M::$1 -- _deref_pbuc1=vbuaa 
    sta lMb
    // [45] *((const byte*) memoryRemap256M::uMb) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta uMb
    // [46] (word~) memoryRemap256M::$7 ← < (dword) memoryRemap256M::lowerPageOffset#2 -- vwuz1=_lo_vduz2 
    lda.z lowerPageOffset
    sta.z __7
    lda.z lowerPageOffset+1
    sta.z __7+1
    // [47] (byte~) memoryRemap256M::$5 ← < (word~) memoryRemap256M::$7 -- vbuaa=_lo_vwuz1 
    lda.z __7
    // [48] *((const byte*) memoryRemap256M::aVal) ← (byte~) memoryRemap256M::$5 -- _deref_pbuc1=vbuaa 
    sta aVal
    // [49] (byte~) memoryRemap256M::$6 ← (byte) memoryRemap256M::remapBlocks#2 << (byte) 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __6
    // [50] (byte~) memoryRemap256M::$8 ← > (word~) memoryRemap256M::$7 -- vbuaa=_hi_vwuz1 
    lda.z __7+1
    // [51] (byte~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [52] (byte~) memoryRemap256M::$10 ← (byte~) memoryRemap256M::$6 | (byte~) memoryRemap256M::$9 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // [53] *((const byte*) memoryRemap256M::xVal) ← (byte~) memoryRemap256M::$10 -- _deref_pbuc1=vbuaa 
    sta xVal
    // [54] *((const byte*) memoryRemap256M::yVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta yVal
    // [55] (byte~) memoryRemap256M::$17 ← (byte) memoryRemap256M::remapBlocks#2 & (byte) $f0 -- vbuaa=vbuzz_band_vbuc1 
    tza
    and #$f0
    // [56] *((const byte*) memoryRemap256M::zVal) ← (byte~) memoryRemap256M::$17 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda lMb
    ldx #$f
    ldy uMb
    ldz #0
    map
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap256M::@return
  __breturn:
    // [58] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction memoryRemapBlock_from_main:
Removing instruction __b1:
Removing instruction memoryRemapBlock_from___b1:
Removing instruction __b2:
Removing instruction memoryRemap_from___b2:
Removing instruction __b3:
Removing instruction memoryRemap256M_from___b3:
Removing instruction __b4:
Removing instruction memoryRemap256M_from___b4:
Removing instruction __breturn:
Removing instruction memoryRemap_from_memoryRemapBlock:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(byte) MEGA65_VICIV::ALPHADELAY
(byte) MEGA65_VICIV::B0PIX
(byte) MEGA65_VICIV::B0_ADDR
(byte) MEGA65_VICIV::B1PIX
(byte) MEGA65_VICIV::B1_ADDR
(byte) MEGA65_VICIV::B2PIX
(byte) MEGA65_VICIV::B2_ADDR
(byte) MEGA65_VICIV::B3PIX
(byte) MEGA65_VICIV::B3_ADDR
(byte) MEGA65_VICIV::B4PIX
(byte) MEGA65_VICIV::B4_ADDR
(byte) MEGA65_VICIV::B5PIX
(byte) MEGA65_VICIV::B5_ADDR
(byte) MEGA65_VICIV::B6PIX
(byte) MEGA65_VICIV::B6_ADDR
(byte) MEGA65_VICIV::B7PIX
(byte) MEGA65_VICIV::B7_ADDR
(byte) MEGA65_VICIV::BBDRPOS_HI
(byte) MEGA65_VICIV::BBDRPOS_LO
(byte) MEGA65_VICIV::BG_COLOR
(byte) MEGA65_VICIV::BG_COLOR1
(byte) MEGA65_VICIV::BG_COLOR2
(byte) MEGA65_VICIV::BG_COLOR3
(byte) MEGA65_VICIV::BORDER_COLOR
(byte) MEGA65_VICIV::BP16ENS
(byte) MEGA65_VICIV::BPCOMP
(byte) MEGA65_VICIV::BPX
(byte) MEGA65_VICIV::BPY
(byte) MEGA65_VICIV::CHARPTR_HILO
(byte) MEGA65_VICIV::CHARPTR_LOHI
(byte) MEGA65_VICIV::CHARPTR_LOLO
(byte) MEGA65_VICIV::CHARSTEP_HI
(byte) MEGA65_VICIV::CHARSTEP_LO
(byte) MEGA65_VICIV::CHRCOUNT
(byte) MEGA65_VICIV::CHRXSCL
(byte) MEGA65_VICIV::CHRYSCL
(byte) MEGA65_VICIV::COLPTR_HI
(byte) MEGA65_VICIV::COLPTR_LO
(byte) MEGA65_VICIV::CONTROL1
(byte) MEGA65_VICIV::CONTROL2
(byte) MEGA65_VICIV::CONTROLA
(byte) MEGA65_VICIV::CONTROLB
(byte) MEGA65_VICIV::CONTROLC
(byte) MEGA65_VICIV::DEBUG1
(byte) MEGA65_VICIV::DEBUGX
(byte) MEGA65_VICIV::DEBUGXY
(byte) MEGA65_VICIV::DEBUGY
(byte) MEGA65_VICIV::FNRASTER_HI
(byte) MEGA65_VICIV::FNRASTER_LO
(byte) MEGA65_VICIV::HPOS
(byte) MEGA65_VICIV::IRQ_ENABLE
(byte) MEGA65_VICIV::IRQ_STATUS
(byte) MEGA65_VICIV::KEY
(byte) MEGA65_VICIV::LIGHTPEN_X
(byte) MEGA65_VICIV::LIGHTPEN_Y
(byte) MEGA65_VICIV::MEMORY
(byte) MEGA65_VICIV::PALSEL
(byte) MEGA65_VICIV::RASLINE0
(byte) MEGA65_VICIV::RASTER
(byte) MEGA65_VICIV::ROWCOUNT
(byte) MEGA65_VICIV::RSTCMP
(byte) MEGA65_VICIV::RSTCOMP
(byte) MEGA65_VICIV::SBPDEBUG
(byte) MEGA65_VICIV::SCRNPTR_HIHI
(byte) MEGA65_VICIV::SCRNPTR_HILO
(byte) MEGA65_VICIV::SCRNPTR_LOHI
(byte) MEGA65_VICIV::SCRNPTR_LOLO
(byte) MEGA65_VICIV::SIDBDRWD_HI
(byte) MEGA65_VICIV::SIDBDRWD_LO
(byte) MEGA65_VICIV::SPR16EN
(byte) MEGA65_VICIV::SPRALPHAVAL
(byte) MEGA65_VICIV::SPRENALPHA
(byte) MEGA65_VICIV::SPRENV400
(byte) MEGA65_VICIV::SPRHGHT
(byte) MEGA65_VICIV::SPRHGTEN
(byte) MEGA65_VICIV::SPRITE0_COLOR
(byte) MEGA65_VICIV::SPRITE0_X
(byte) MEGA65_VICIV::SPRITE0_Y
(byte) MEGA65_VICIV::SPRITE1_COLOR
(byte) MEGA65_VICIV::SPRITE1_X
(byte) MEGA65_VICIV::SPRITE1_Y
(byte) MEGA65_VICIV::SPRITE2_COLOR
(byte) MEGA65_VICIV::SPRITE2_X
(byte) MEGA65_VICIV::SPRITE2_Y
(byte) MEGA65_VICIV::SPRITE3_COLOR
(byte) MEGA65_VICIV::SPRITE3_X
(byte) MEGA65_VICIV::SPRITE3_Y
(byte) MEGA65_VICIV::SPRITE4_COLOR
(byte) MEGA65_VICIV::SPRITE4_X
(byte) MEGA65_VICIV::SPRITE4_Y
(byte) MEGA65_VICIV::SPRITE5_COLOR
(byte) MEGA65_VICIV::SPRITE5_X
(byte) MEGA65_VICIV::SPRITE5_Y
(byte) MEGA65_VICIV::SPRITE6_COLOR
(byte) MEGA65_VICIV::SPRITE6_X
(byte) MEGA65_VICIV::SPRITE6_Y
(byte) MEGA65_VICIV::SPRITE7_COLOR
(byte) MEGA65_VICIV::SPRITE7_X
(byte) MEGA65_VICIV::SPRITE7_Y
(byte) MEGA65_VICIV::SPRITES_BG_COLLISION
(byte) MEGA65_VICIV::SPRITES_COLLISION
(byte) MEGA65_VICIV::SPRITES_ENABLE
(byte) MEGA65_VICIV::SPRITES_EXPAND_X
(byte) MEGA65_VICIV::SPRITES_EXPAND_Y
(byte) MEGA65_VICIV::SPRITES_MC
(byte) MEGA65_VICIV::SPRITES_MCOLOR1
(byte) MEGA65_VICIV::SPRITES_MCOLOR2
(byte) MEGA65_VICIV::SPRITES_PRIORITY
(byte) MEGA65_VICIV::SPRITES_XMSB
(byte) MEGA65_VICIV::SPRPTRADR_HILO
(byte) MEGA65_VICIV::SPRPTRADR_LOHI
(byte) MEGA65_VICIV::SPRPTRADR_LOLO
(byte) MEGA65_VICIV::SPRX64EN
(byte) MEGA65_VICIV::SPRXSMSBS
(byte) MEGA65_VICIV::SPRYSMSBSM
(byte) MEGA65_VICIV::SRPYMSBS
(byte) MEGA65_VICIV::SYNCPOL
(byte) MEGA65_VICIV::TBDRPOS_HI
(byte) MEGA65_VICIV::TBDRPOS_LO
(byte) MEGA65_VICIV::TEXTXPOS_HI
(byte) MEGA65_VICIV::TEXTXPOS_LO
(byte) MEGA65_VICIV::TEXTYPOS_HI
(byte) MEGA65_VICIV::TEXTYPOS_LO
(byte) MEGA65_VICIV::UNUSED
(byte) MEGA65_VICIV::VPOS
(byte) MEGA65_VICIV::VSYNDEL
(byte) MEGA65_VICIV::XPOS_HI
(byte) MEGA65_VICIV::XPOS_LO
(const nomodify byte) MEMORYBLOCK_4000 = (byte) 4
(const nomodify byte) MEMORYBLOCK_8000 = (byte) $10
(byte) MOS4569_VICIII::B0PIX
(byte) MOS4569_VICIII::B0_ADDR
(byte) MOS4569_VICIII::B1PIX
(byte) MOS4569_VICIII::B1_ADDR
(byte) MOS4569_VICIII::B2PIX
(byte) MOS4569_VICIII::B2_ADDR
(byte) MOS4569_VICIII::B3PIX
(byte) MOS4569_VICIII::B3_ADDR
(byte) MOS4569_VICIII::B4PIX
(byte) MOS4569_VICIII::B4_ADDR
(byte) MOS4569_VICIII::B5PIX
(byte) MOS4569_VICIII::B5_ADDR
(byte) MOS4569_VICIII::B6PIX
(byte) MOS4569_VICIII::B6_ADDR
(byte) MOS4569_VICIII::B7PIX
(byte) MOS4569_VICIII::B7_ADDR
(byte) MOS4569_VICIII::BG_COLOR
(byte) MOS4569_VICIII::BG_COLOR1
(byte) MOS4569_VICIII::BG_COLOR2
(byte) MOS4569_VICIII::BG_COLOR3
(byte) MOS4569_VICIII::BORDER_COLOR
(byte) MOS4569_VICIII::BPCOMP
(byte) MOS4569_VICIII::BPX
(byte) MOS4569_VICIII::BPY
(byte) MOS4569_VICIII::CONTROL1
(byte) MOS4569_VICIII::CONTROL2
(byte) MOS4569_VICIII::CONTROLA
(byte) MOS4569_VICIII::CONTROLB
(byte) MOS4569_VICIII::HPOS
(byte) MOS4569_VICIII::IRQ_ENABLE
(byte) MOS4569_VICIII::IRQ_STATUS
(byte) MOS4569_VICIII::KEY
(byte) MOS4569_VICIII::LIGHTPEN_X
(byte) MOS4569_VICIII::LIGHTPEN_Y
(byte) MOS4569_VICIII::MEMORY
(byte) MOS4569_VICIII::RASTER
(byte) MOS4569_VICIII::SPRITE0_COLOR
(byte) MOS4569_VICIII::SPRITE0_X
(byte) MOS4569_VICIII::SPRITE0_Y
(byte) MOS4569_VICIII::SPRITE1_COLOR
(byte) MOS4569_VICIII::SPRITE1_X
(byte) MOS4569_VICIII::SPRITE1_Y
(byte) MOS4569_VICIII::SPRITE2_COLOR
(byte) MOS4569_VICIII::SPRITE2_X
(byte) MOS4569_VICIII::SPRITE2_Y
(byte) MOS4569_VICIII::SPRITE3_COLOR
(byte) MOS4569_VICIII::SPRITE3_X
(byte) MOS4569_VICIII::SPRITE3_Y
(byte) MOS4569_VICIII::SPRITE4_COLOR
(byte) MOS4569_VICIII::SPRITE4_X
(byte) MOS4569_VICIII::SPRITE4_Y
(byte) MOS4569_VICIII::SPRITE5_COLOR
(byte) MOS4569_VICIII::SPRITE5_X
(byte) MOS4569_VICIII::SPRITE5_Y
(byte) MOS4569_VICIII::SPRITE6_COLOR
(byte) MOS4569_VICIII::SPRITE6_X
(byte) MOS4569_VICIII::SPRITE6_Y
(byte) MOS4569_VICIII::SPRITE7_COLOR
(byte) MOS4569_VICIII::SPRITE7_X
(byte) MOS4569_VICIII::SPRITE7_Y
(byte) MOS4569_VICIII::SPRITES_BG_COLLISION
(byte) MOS4569_VICIII::SPRITES_COLLISION
(byte) MOS4569_VICIII::SPRITES_ENABLE
(byte) MOS4569_VICIII::SPRITES_EXPAND_X
(byte) MOS4569_VICIII::SPRITES_EXPAND_Y
(byte) MOS4569_VICIII::SPRITES_MC
(byte) MOS4569_VICIII::SPRITES_MCOLOR1
(byte) MOS4569_VICIII::SPRITES_MCOLOR2
(byte) MOS4569_VICIII::SPRITES_PRIORITY
(byte) MOS4569_VICIII::SPRITES_XMSB
(byte) MOS4569_VICIII::UNUSED
(byte) MOS4569_VICIII::VPOS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return
(const byte*) main::block1 = (byte*) 16384
(const byte*) main::block2 = (byte*) 32768
(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
(byte~) memoryRemap::$0 reg byte a 202.0
(byte~) memoryRemap::$1 zp[1]:15 67.33333333333333
(byte~) memoryRemap::$2 reg byte a 202.0
(byte~) memoryRemap::$3 reg byte a 202.0
(byte~) memoryRemap::$4 reg byte a 202.0
(byte~) memoryRemap::$5 reg byte a 202.0
(byte~) memoryRemap::$6 zp[1]:8 67.33333333333333
(byte~) memoryRemap::$7 reg byte a 202.0
(byte~) memoryRemap::$8 reg byte a 202.0
(byte~) memoryRemap::$9 reg byte a 202.0
(label) memoryRemap::@return
(const byte*) memoryRemap::aVal = (byte*) 252
(word) memoryRemap::lowerPageOffset
(word) memoryRemap::lowerPageOffset#1 lowerPageOffset zp[2]:13 11.0
(word) memoryRemap::lowerPageOffset#2 lowerPageOffset zp[2]:13 53.25
(byte) memoryRemap::remapBlocks
(byte) memoryRemap::remapBlocks#1 reg byte z 7.333333333333333
(byte) memoryRemap::remapBlocks#2 reg byte z 21.299999999999997
(word) memoryRemap::upperPageOffset
(word) memoryRemap::upperPageOffset#1 upperPageOffset zp[2]:2 22.0
(word) memoryRemap::upperPageOffset#2 upperPageOffset zp[2]:2 19.363636363636363
(const byte*) memoryRemap::xVal = (byte*) 253
(const byte*) memoryRemap::yVal = (byte*) 254
(const byte*) memoryRemap::zVal = (byte*) 255
(void()) memoryRemap256M((byte) memoryRemap256M::remapBlocks , (dword) memoryRemap256M::lowerPageOffset , (dword) memoryRemap256M::upperPageOffset)
(dword~) memoryRemap256M::$0 zp[4]:9 11.0
(byte~) memoryRemap256M::$1 reg byte a 22.0
(byte~) memoryRemap256M::$10 reg byte a 22.0
(byte~) memoryRemap256M::$17 reg byte a 22.0
(byte~) memoryRemap256M::$5 reg byte a 22.0
(byte~) memoryRemap256M::$6 zp[1]:15 7.333333333333333
(word~) memoryRemap256M::$7 zp[2]:13 8.25
(byte~) memoryRemap256M::$8 reg byte a 22.0
(byte~) memoryRemap256M::$9 reg byte a 22.0
(label) memoryRemap256M::@return
(const byte*) memoryRemap256M::aVal = (byte*) 252
(const byte*) memoryRemap256M::lMb = (byte*) 250
(dword) memoryRemap256M::lowerPageOffset
(dword) memoryRemap256M::lowerPageOffset#2 lowerPageOffset zp[4]:4 4.4
(byte) memoryRemap256M::remapBlocks
(byte) memoryRemap256M::remapBlocks#2 reg byte z 1.5714285714285714
(const byte*) memoryRemap256M::uMb = (byte*) 251
(dword) memoryRemap256M::upperPageOffset
(const byte*) memoryRemap256M::xVal = (byte*) 253
(const byte*) memoryRemap256M::yVal = (byte*) 254
(const byte*) memoryRemap256M::zVal = (byte*) 255
(void()) memoryRemapBlock((byte) memoryRemapBlock::blockPage , (word) memoryRemapBlock::memoryPage)
(label) memoryRemapBlock::@return
(byte) memoryRemapBlock::block
(byte) memoryRemapBlock::block#0 reg byte a 22.0
(byte) memoryRemapBlock::blockBits
(byte) memoryRemapBlock::blockBits#0 reg byte a 22.0
(byte) memoryRemapBlock::blockPage
(byte) memoryRemapBlock::blockPage#2 reg byte x 11.0
(word) memoryRemapBlock::memoryPage
(word) memoryRemapBlock::pageOffset
(word) memoryRemapBlock::pageOffset#0 pageOffset zp[2]:13 6.6000000000000005

reg byte x [ memoryRemapBlock::blockPage#2 ]
reg byte z [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#1 ]
zp[2]:2 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#1 ]
zp[4]:4 [ memoryRemap256M::lowerPageOffset#2 ]
reg byte z [ memoryRemap256M::remapBlocks#2 ]
reg byte a [ memoryRemapBlock::block#0 ]
reg byte a [ memoryRemapBlock::blockBits#0 ]
reg byte a [ memoryRemap::$0 ]
reg byte a [ memoryRemap::$2 ]
reg byte a [ memoryRemap::$3 ]
reg byte a [ memoryRemap::$4 ]
reg byte a [ memoryRemap::$5 ]
zp[1]:8 [ memoryRemap::$6 ]
reg byte a [ memoryRemap::$7 ]
reg byte a [ memoryRemap::$8 ]
reg byte a [ memoryRemap::$9 ]
zp[4]:9 [ memoryRemap256M::$0 ]
reg byte a [ memoryRemap256M::$1 ]
zp[2]:13 [ memoryRemap256M::$7 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#1 memoryRemapBlock::pageOffset#0 ]
reg byte a [ memoryRemap256M::$5 ]
zp[1]:15 [ memoryRemap256M::$6 memoryRemap::$1 ]
reg byte a [ memoryRemap256M::$8 ]
reg byte a [ memoryRemap256M::$9 ]
reg byte a [ memoryRemap256M::$10 ]
reg byte a [ memoryRemap256M::$17 ]


FINAL ASSEMBLER
Score: 505

  // File Comments
// Test the MAP instruction for remapping memory
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in file:///Users/jespergravgaard/Downloads/MEGA65-Book_draft%20(5).pdf for a description of the CPU memory remapper of the MEGA65.
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="memorymap-test.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // Bit representing 8K block #2 of the 64K addressable memory ($4000-$5fff)
  .const MEMORYBLOCK_4000 = 4
  // Bit representing 8K block #4 of the 64K addressable memory ($8000-$9fff)
  .const MEMORYBLOCK_8000 = $10
.segment Code
  // main
main: {
    .label block1 = $4000
    .label block2 = $8000
    // memoryRemapBlock(0x40, 0x100)
    // [1] call memoryRemapBlock 
  // Remap [$4000-$5fff] to point to [$10000-$11fff]
    // [15] phi from main to memoryRemapBlock [phi:main->memoryRemapBlock]
    // [15] phi (byte) memoryRemapBlock::blockPage#2 = (byte) $40 [phi:main->memoryRemapBlock#0] -- vbuxx=vbuc1 
    ldx #$40
    jsr memoryRemapBlock
    // main::@1
    // block1[0] = 0x55
    // [2] *((const byte*) main::block1) ← (byte) $55 -- _deref_pbuc1=vbuc2 
    // Put 0x55, 0xaa into $10000
    lda #$55
    sta block1
    // block1[1] = 0xaa
    // [3] *((const byte*) main::block1+(byte) 1) ← (byte) $aa -- _deref_pbuc1=vbuc2 
    lda #$aa
    sta block1+1
    // memoryRemapBlock(0x80, 0x100)
    // [4] call memoryRemapBlock 
  // Remap [$8000-$9fff] to point to [$10000-$11fff]
    // [15] phi from main::@1 to memoryRemapBlock [phi:main::@1->memoryRemapBlock]
    // [15] phi (byte) memoryRemapBlock::blockPage#2 = (byte) $80 [phi:main::@1->memoryRemapBlock#0] -- vbuxx=vbuc1 
    ldx #$80
    jsr memoryRemapBlock
    // main::@2
    // block2[2] = 0x55
    // [5] *((const byte*) main::block2+(byte) 2) ← (byte) $55 -- _deref_pbuc1=vbuc2 
    // Put 0x55, 0xaainto $10002
    lda #$55
    sta block2+2
    // block2[3] = 0xaa
    // [6] *((const byte*) main::block2+(byte) 3) ← (byte) $aa -- _deref_pbuc1=vbuc2 
    lda #$aa
    sta block2+3
    // memoryRemap(MEMORYBLOCK_4000|MEMORYBLOCK_8000, 0x0c0, 0x080)
    // [7] call memoryRemap 
  // Remap [$4000-$5fff] and [$8000-$9fff] to both point to [$10000-$11fff] (notice usage of page offsets)
    // [24] phi from main::@2 to memoryRemap [phi:main::@2->memoryRemap]
    // [24] phi (word) memoryRemap::upperPageOffset#2 = (byte) $80 [phi:main::@2->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<$80
    sta.z memoryRemap.upperPageOffset
    lda #>$80
    sta.z memoryRemap.upperPageOffset+1
    // [24] phi (byte) memoryRemap::remapBlocks#2 = (const nomodify byte) MEMORYBLOCK_4000|(const nomodify byte) MEMORYBLOCK_8000 [phi:main::@2->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #MEMORYBLOCK_4000|MEMORYBLOCK_8000
    // [24] phi (word) memoryRemap::lowerPageOffset#2 = (byte) $c0 [phi:main::@2->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<$c0
    sta.z memoryRemap.lowerPageOffset
    lda #>$c0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // main::@3
    // block2[4] = block1[2]
    // [8] *((const byte*) main::block2+(byte) 4) ← *((const byte*) main::block1+(byte) 2) -- _deref_pbuc1=_deref_pbuc2 
    // Put 0x55, 0xaa into $10004 in a convoluted way
    lda block1+2
    sta block2+4
    // block1[5] = block2[1]
    // [9] *((const byte*) main::block1+(byte) 5) ← *((const byte*) main::block2+(byte) 1) -- _deref_pbuc1=_deref_pbuc2 
    lda block2+1
    sta block1+5
    // memoryRemap256M(MEMORYBLOCK_4000, 0xff800-0x00040, 0)
    // [10] call memoryRemap256M 
  // Remap [$4000-$5fff] to both point to [$ff80000-$ff81fff] COLORAM! (notice usage of page offsets)
    // [41] phi from main::@3 to memoryRemap256M [phi:main::@3->memoryRemap256M]
    // [41] phi (byte) memoryRemap256M::remapBlocks#2 = (const nomodify byte) MEMORYBLOCK_4000 [phi:main::@3->memoryRemap256M#0] -- vbuzz=vbuc1 
    ldz #MEMORYBLOCK_4000
    // [41] phi (dword) memoryRemap256M::lowerPageOffset#2 = (dword)(number) $ff800-(number) $40 [phi:main::@3->memoryRemap256M#1] -- vduz1=vduc1 
    lda #<$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset
    lda #>$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset+1
    lda #<$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+2
    lda #>$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    // main::@4
    // block1[0] = 0
    // [11] *((const byte*) main::block1) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Put colors in the upper left corner!
    lda #0
    sta block1
    // block1[1] = 1
    // [12] *((const byte*) main::block1+(byte) 1) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta block1+1
    // memoryRemap256M(0, 0, 0)
    // [13] call memoryRemap256M 
  // Remap [$4000-$5fff] back to normal memory!
    // [41] phi from main::@4 to memoryRemap256M [phi:main::@4->memoryRemap256M]
    // [41] phi (byte) memoryRemap256M::remapBlocks#2 = (byte) 0 [phi:main::@4->memoryRemap256M#0] -- vbuzz=vbuc1 
    ldz #0
    // [41] phi (dword) memoryRemap256M::lowerPageOffset#2 = (byte) 0 [phi:main::@4->memoryRemap256M#1] -- vduz1=vbuc1 
    lda #0
    sta.z memoryRemap256M.lowerPageOffset
    sta.z memoryRemap256M.lowerPageOffset+1
    sta.z memoryRemap256M.lowerPageOffset+2
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    // main::@return
    // }
    // [14] return 
    rts
}
  // memoryRemapBlock
// Remap a single 8K memory block in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// All the other 8K memory blocks will not be mapped and will point to their own address in the lowest 64K of the MEGA65 memory.
// blockPage: Page address of the 8K memory block to remap (ie. the block that is remapped is $100 * the passed page address.) 
// memoryPage: Page address of the memory that the block should point to in the 1MB memory space of the MEGA65. 
// Ie. the memory that will be pointed to is $100 * the passed page address. Only the lower 12bits of the passed value is used.
// memoryRemapBlock(byte register(X) blockPage)
memoryRemapBlock: {
    .label pageOffset = $d
    // pageOffset = memoryPage-blockPage
    // [16] (word) memoryRemapBlock::pageOffset#0 ← (word) $100 - (byte) memoryRemapBlock::blockPage#2 -- vwuz1=vwuc1_minus_vbuxx 
    stx.z $ff
    lda #<$100
    sec
    sbc.z $ff
    sta.z pageOffset
    lda #>$100
    sbc #0
    sta.z pageOffset+1
    // block = blockPage / $20
    // [17] (byte) memoryRemapBlock::block#0 ← (byte) memoryRemapBlock::blockPage#2 >> (byte) 5 -- vbuaa=vbuxx_ror_5 
    txa
    lsr
    lsr
    lsr
    lsr
    lsr
    // blockBits = 1<<block
    // [18] (byte) memoryRemapBlock::blockBits#0 ← (byte) 1 << (byte) memoryRemapBlock::block#0 -- vbuaa=vbuc1_rol_vbuaa 
    tay
    lda #1
    cpy #0
    beq !e+
  !:
    asl
    dey
    bne !-
  !e:
    // memoryRemap(blockBits, pageOffset, pageOffset)
    // [19] (byte) memoryRemap::remapBlocks#1 ← (byte) memoryRemapBlock::blockBits#0 -- vbuzz=vbuaa 
    taz
    // [20] (word) memoryRemap::lowerPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0
    // [21] (word) memoryRemap::upperPageOffset#1 ← (word) memoryRemapBlock::pageOffset#0 -- vwuz1=vwuz2 
    lda.z pageOffset
    sta.z memoryRemap.upperPageOffset
    lda.z pageOffset+1
    sta.z memoryRemap.upperPageOffset+1
    // [22] call memoryRemap 
    // [24] phi from memoryRemapBlock to memoryRemap [phi:memoryRemapBlock->memoryRemap]
    // [24] phi (word) memoryRemap::upperPageOffset#2 = (word) memoryRemap::upperPageOffset#1 [phi:memoryRemapBlock->memoryRemap#0] -- register_copy 
    // [24] phi (byte) memoryRemap::remapBlocks#2 = (byte) memoryRemap::remapBlocks#1 [phi:memoryRemapBlock->memoryRemap#1] -- register_copy 
    // [24] phi (word) memoryRemap::lowerPageOffset#2 = (word) memoryRemap::lowerPageOffset#1 [phi:memoryRemapBlock->memoryRemap#2] -- register_copy 
    jsr memoryRemap
    // memoryRemapBlock::@return
    // }
    // [23] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000. 
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000. 
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000. 
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000. 
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000. 
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000. 
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000. 
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000. 
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.  
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.  
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.  
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.  
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000  
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.  
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.  
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.  
// memoryRemap(byte register(Z) remapBlocks, word zp($d) lowerPageOffset, word zp(2) upperPageOffset)
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __1 = $f
    .label __6 = 8
    .label lowerPageOffset = $d
    .label upperPageOffset = 2
    // <lowerPageOffset
    // [25] (byte~) memoryRemap::$0 ← < (word) memoryRemap::lowerPageOffset#2 -- vbuaa=_lo_vwuz1 
    lda.z lowerPageOffset
    // *aVal = <lowerPageOffset
    // [26] *((const byte*) memoryRemap::aVal) ← (byte~) memoryRemap::$0 -- _deref_pbuc1=vbuaa 
    sta aVal
    // remapBlocks << 4
    // [27] (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#2 << (byte) 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __1
    // >lowerPageOffset
    // [28] (byte~) memoryRemap::$2 ← > (word) memoryRemap::lowerPageOffset#2 -- vbuaa=_hi_vwuz1 
    lda.z lowerPageOffset+1
    // >lowerPageOffset & 0xf
    // [29] (byte~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // (remapBlocks << 4)   | (>lowerPageOffset & 0xf)
    // [30] (byte~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (byte~) memoryRemap::$3 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // *xVal = (remapBlocks << 4)   | (>lowerPageOffset & 0xf)
    // [31] *((const byte*) memoryRemap::xVal) ← (byte~) memoryRemap::$4 -- _deref_pbuc1=vbuaa 
    sta xVal
    // <upperPageOffset
    // [32] (byte~) memoryRemap::$5 ← < (word) memoryRemap::upperPageOffset#2 -- vbuaa=_lo_vwuz1 
    lda.z upperPageOffset
    // *yVal = <upperPageOffset
    // [33] *((const byte*) memoryRemap::yVal) ← (byte~) memoryRemap::$5 -- _deref_pbuc1=vbuaa 
    sta yVal
    // remapBlocks & 0xf0
    // [34] (byte~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#2 & (byte) $f0 -- vbuz1=vbuzz_band_vbuc1 
    tza
    and #$f0
    sta.z __6
    // >upperPageOffset
    // [35] (byte~) memoryRemap::$7 ← > (word) memoryRemap::upperPageOffset#2 -- vbuaa=_hi_vwuz1 
    lda.z upperPageOffset+1
    // >upperPageOffset & 0xf
    // [36] (byte~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // (remapBlocks & 0xf0) | (>upperPageOffset & 0xf)
    // [37] (byte~) memoryRemap::$9 ← (byte~) memoryRemap::$6 | (byte~) memoryRemap::$8 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // *zVal = (remapBlocks & 0xf0) | (>upperPageOffset & 0xf)
    // [38] *((const byte*) memoryRemap::zVal) ← (byte~) memoryRemap::$9 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap::@return
    // }
    // [40] return 
    rts
}
  // memoryRemap256M
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the entire 256MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in file:///Users/jespergravgaard/Downloads/MEGA65-Book_draft%20(5).pdf for a description of the CPU memory remapper of the MEGA65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000. 
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000. 
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000. 
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000. 
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000. 
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000. 
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000. 
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000. 
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.  
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.  
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.  
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.  
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7). 
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000  
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.  
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.  
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.  
// memoryRemap256M(byte register(Z) remapBlocks, dword zp(4) lowerPageOffset)
memoryRemap256M: {
    .label lMb = $fa
    .label uMb = $fb
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __0 = 9
    .label __6 = $f
    .label __7 = $d
    .label lowerPageOffset = 4
    // lowerPageOffset>>4
    // [42] (dword~) memoryRemap256M::$0 ← (dword) memoryRemap256M::lowerPageOffset#2 >> (byte) 4 -- vduz1=vduz2_ror_4 
    lda.z lowerPageOffset+3
    lsr
    sta.z __0+3
    lda.z lowerPageOffset+2
    ror
    sta.z __0+2
    lda.z lowerPageOffset+1
    ror
    sta.z __0+1
    lda.z lowerPageOffset
    ror
    sta.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    // >((unsigned int)(lowerPageOffset>>4))
    // [43] (byte~) memoryRemap256M::$1 ← > (word)(dword~) memoryRemap256M::$0 -- vbuaa=_hi__word_vduz1 
    lda.z __0+1
    // *lMb = >((unsigned int)(lowerPageOffset>>4))
    // [44] *((const byte*) memoryRemap256M::lMb) ← (byte~) memoryRemap256M::$1 -- _deref_pbuc1=vbuaa 
    sta lMb
    // *uMb = >((unsigned int)(upperPageOffset>>4))
    // [45] *((const byte*) memoryRemap256M::uMb) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta uMb
    // <lowerPageOffset
    // [46] (word~) memoryRemap256M::$7 ← < (dword) memoryRemap256M::lowerPageOffset#2 -- vwuz1=_lo_vduz2 
    lda.z lowerPageOffset
    sta.z __7
    lda.z lowerPageOffset+1
    sta.z __7+1
    // < <lowerPageOffset
    // [47] (byte~) memoryRemap256M::$5 ← < (word~) memoryRemap256M::$7 -- vbuaa=_lo_vwuz1 
    lda.z __7
    // *aVal = < <lowerPageOffset
    // [48] *((const byte*) memoryRemap256M::aVal) ← (byte~) memoryRemap256M::$5 -- _deref_pbuc1=vbuaa 
    sta aVal
    // remapBlocks << 4
    // [49] (byte~) memoryRemap256M::$6 ← (byte) memoryRemap256M::remapBlocks#2 << (byte) 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __6
    // > <lowerPageOffset
    // [50] (byte~) memoryRemap256M::$8 ← > (word~) memoryRemap256M::$7 -- vbuaa=_hi_vwuz1 
    lda.z __7+1
    // > <lowerPageOffset & 0xf
    // [51] (byte~) memoryRemap256M::$9 ← (byte~) memoryRemap256M::$8 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // (remapBlocks << 4)   | (> <lowerPageOffset & 0xf)
    // [52] (byte~) memoryRemap256M::$10 ← (byte~) memoryRemap256M::$6 | (byte~) memoryRemap256M::$9 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // *xVal = (remapBlocks << 4)   | (> <lowerPageOffset & 0xf)
    // [53] *((const byte*) memoryRemap256M::xVal) ← (byte~) memoryRemap256M::$10 -- _deref_pbuc1=vbuaa 
    sta xVal
    // *yVal = < <upperPageOffset
    // [54] *((const byte*) memoryRemap256M::yVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta yVal
    // (remapBlocks & 0xf0) | (> <upperPageOffset & 0xf)
    // [55] (byte~) memoryRemap256M::$17 ← (byte) memoryRemap256M::remapBlocks#2 & (byte) $f0 -- vbuaa=vbuzz_band_vbuc1 
    tza
    and #$f0
    // *zVal = (remapBlocks & 0xf0) | (> <upperPageOffset & 0xf)
    // [56] *((const byte*) memoryRemap256M::zVal) ← (byte~) memoryRemap256M::$17 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm
    // asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda lMb
    ldx #$f
    ldy uMb
    ldz #0
    map
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap256M::@return
    // }
    // [58] return 
    rts
}
  // File Data

