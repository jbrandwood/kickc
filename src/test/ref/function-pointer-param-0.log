Resolved forward reference fn1 to void fn1(byte fn1::c)
Resolved forward reference fn2 to void fn2(byte fn2::d)
Setting inferred __stackcall on procedure affected by address-of __stackcall void fn1(byte fn1::c) caused by statement main::f = &fn1
Setting inferred __stackcall on procedure affected by address-of __stackcall void fn2(byte fn2::d) caused by statement main::f = &fn2
Adding parameter assignment in __stackcall procedure fn1::c = param(fn1::c)
Adding parameter assignment in __stackcall procedure fn2::d = param(fn2::d)
Adding parameter assignment in __stackcall procedure fn3::e = param(fn3::e)
Calling convention __stackcall adding prepare/execute/finalize for call fn3 main::i 
Calling convention STACK_CALL adding prepare/execute/finalize for call *main::f main::i 
Calling convention STACK_CALL replacing param(fn1::c) with stackidx(byte,fn1::OFFSET_STACK_C)
Calling convention STACK_CALL replacing param(fn2::d) with stackidx(byte,fn2::OFFSET_STACK_D)
Calling convention STACK_CALL replacing param(fn3::e) with stackidx(byte,fn3::OFFSET_STACK_E)
Calling convention STACK_CALL adding stack push stackpush(byte) = main::i
Calling convention STACK_CALL adding stack push stackpush(byte) = main::i

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start
  main::f#0 = (void(byte)*) 0
  main::i#0 = 0
  to:main::@1
main::@1: scope:[main]  from main main::@4
  main::i#2 = phi( main/main::i#0, main::@4/main::i#1 )
  main::$0 = main::i#2 < $a0
  if(main::$0) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  main::i#3 = phi( main::@1/main::i#2 )
  main::$1 = main::i#3 & 1
  main::$2 = main::$1 == 0
  main::$3 = ! main::$2
  if(main::$3) goto main::@3
  to:main::@7
main::@3: scope:[main]  from main::@2
  main::i#4 = phi( main::@2/main::i#3 )
  main::$5 = main::i#4 & 3
  main::$6 = main::$5 == 1
  if(main::$6) goto main::@5
  to:main::@8
main::@7: scope:[main]  from main::@2
  main::i#5 = phi( main::@2/main::i#3 )
  stackpush(byte) = main::i#5
  callexecute fn3 
  sideeffect stackpullbytes(1)
  to:main::@4
main::@4: scope:[main]  from main::@6 main::@7
  main::i#6 = phi( main::@6/main::i#7, main::@7/main::i#5 )
  main::i#1 = ++ main::i#6
  to:main::@1
main::@5: scope:[main]  from main::@3
  main::i#8 = phi( main::@3/main::i#4 )
  main::f#1 = &fn1
  to:main::@6
main::@8: scope:[main]  from main::@3
  main::i#9 = phi( main::@3/main::i#4 )
  main::f#2 = &fn2
  to:main::@6
main::@6: scope:[main]  from main::@5 main::@8
  main::f#3 = phi( main::@5/main::f#1, main::@8/main::f#2 )
  main::i#7 = phi( main::@5/main::i#8, main::@8/main::i#9 )
  stackpush(byte) = main::i#7
  callexecute *main::f#3 
  sideeffect stackpullbytes(1)
  to:main::@4
main::@return: scope:[main]  from main::@1
  return 
  to:@return

__stackcall void fn1(byte fn1::c)
fn1: scope:[fn1]  from
  fn1::c#0 = stackidx(byte,fn1::OFFSET_STACK_C)
  SCREEN[fn1::c#0] = 'a'
  to:fn1::@return
fn1::@return: scope:[fn1]  from fn1
  return 
  to:@return

__stackcall void fn2(byte fn2::d)
fn2: scope:[fn2]  from
  fn2::d#0 = stackidx(byte,fn2::OFFSET_STACK_D)
  SCREEN[fn2::d#0] = 'b'
  to:fn2::@return
fn2::@return: scope:[fn2]  from fn2
  return 
  to:@return

__stackcall void fn3(byte fn3::e)
fn3: scope:[fn3]  from
  fn3::e#0 = stackidx(byte,fn3::OFFSET_STACK_E)
  SCREEN[fn3::e#0] = 'c'
  to:fn3::@return
fn3::@return: scope:[fn3]  from fn3
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* const SCREEN = (byte*)$400
constant word STACK_BASE = $103
void __start()
__stackcall void fn1(byte fn1::c)
constant byte fn1::OFFSET_STACK_C = 0
byte fn1::c
byte fn1::c#0
__stackcall void fn2(byte fn2::d)
constant byte fn2::OFFSET_STACK_D = 0
byte fn2::d
byte fn2::d#0
__stackcall void fn3(byte fn3::e)
constant byte fn3::OFFSET_STACK_E = 0
byte fn3::e
byte fn3::e#0
void main()
bool~ main::$0
number~ main::$1
bool~ main::$2
bool~ main::$3
number~ main::$5
bool~ main::$6
void(byte)* main::f
void(byte)* main::f#0
void(byte)* main::f#1
void(byte)* main::f#2
void(byte)* main::f#3
byte main::i
byte main::i#0
byte main::i#1
byte main::i#2
byte main::i#3
byte main::i#4
byte main::i#5
byte main::i#6
byte main::i#7
byte main::i#8
byte main::i#9

Adding number conversion cast (unumber) $a0 in main::$0 = main::i#2 < $a0
Adding number conversion cast (unumber) 1 in main::$1 = main::i#3 & 1
Adding number conversion cast (unumber) main::$1 in main::$1 = main::i#3 & (unumber)1
Adding number conversion cast (unumber) 0 in main::$2 = main::$1 == 0
Adding number conversion cast (unumber) 3 in main::$5 = main::i#4 & 3
Adding number conversion cast (unumber) main::$5 in main::$5 = main::i#4 & (unumber)3
Adding number conversion cast (unumber) 1 in main::$6 = main::$5 == 1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $a0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 3
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $a0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in main::$1 = main::i#3 & 1
Inferred type updated to byte in main::$5 = main::i#4 & 3
Inversing boolean not [8] main::$3 = main::$1 != 0 from [7] main::$2 = main::$1 == 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias main::i#2 = main::i#3 main::i#4 main::i#5 main::i#8 main::i#9 
Successful SSA optimization Pass2AliasElimination
Alias main::i#2 = main::i#7 
Successful SSA optimization Pass2AliasElimination
Alias main::i#2 = main::i#6 
Successful SSA optimization Pass2AliasElimination
Simple Condition main::$0 [4] if(main::i#2<$a0) goto main::@2
Simple Condition main::$3 [7] if(main::$1!=0) goto main::@3
Simple Condition main::$6 [10] if(main::$5==1) goto main::@5
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant main::f#0 = (void(byte)*) 0
Constant main::i#0 = 0
Constant main::f#1 = &fn1
Constant main::f#2 = &fn2
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant main::f#0
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings main::i#0
Inlining constant with var siblings main::f#1
Inlining constant with var siblings main::f#2
Constant inlined main::i#0 = 0
Constant inlined main::f#2 = &fn2
Constant inlined main::f#1 = &fn1
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@5
CALL GRAPH
Calls in [main] to fn3:16 null:25 

Created 2 initial phi equivalence classes
Coalesced [19] main::i#10 = main::i#1
Coalesced down to 2 phi equivalence classes
Culled Empty Block label main::@8
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@5

FINAL CONTROL FLOW GRAPH

__stackcall void fn3(byte fn3::e)
fn3: scope:[fn3]  from
  [0] fn3::e#0 = stackidx(byte,fn3::OFFSET_STACK_E)
  [1] SCREEN[fn3::e#0] = 'c'
  to:fn3::@return
fn3::@return: scope:[fn3]  from fn3
  [2] return 
  to:@return

__stackcall void fn2(byte fn2::d)
fn2: scope:[fn2]  from
  [3] fn2::d#0 = stackidx(byte,fn2::OFFSET_STACK_D)
  [4] SCREEN[fn2::d#0] = 'b'
  to:fn2::@return
fn2::@return: scope:[fn2]  from fn2
  [5] return 
  to:@return

__stackcall void fn1(byte fn1::c)
fn1: scope:[fn1]  from
  [6] fn1::c#0 = stackidx(byte,fn1::OFFSET_STACK_C)
  [7] SCREEN[fn1::c#0] = 'a'
  to:fn1::@return
fn1::@return: scope:[fn1]  from fn1
  [8] return 
  to:@return

void main()
main: scope:[main]  from
  [9] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@4
  [10] main::i#2 = phi( main/0, main::@4/main::i#1 )
  [11] if(main::i#2<$a0) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@1
  [12] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [13] main::$1 = main::i#2 & 1
  [14] if(main::$1!=0) goto main::@3
  to:main::@7
main::@7: scope:[main]  from main::@2
  [15] stackpush(byte) = main::i#2
  [16] callexecute fn3 
  sideeffect stackpullbytes(1)
  to:main::@4
main::@4: scope:[main]  from main::@6 main::@7
  [18] main::i#1 = ++ main::i#2
  to:main::@1
main::@3: scope:[main]  from main::@2
  [19] main::$5 = main::i#2 & 3
  [20] if(main::$5==1) goto main::@5
  to:main::@6
main::@5: scope:[main]  from main::@3
  [21] phi()
  to:main::@6
main::@6: scope:[main]  from main::@3 main::@5
  [22] main::f#3 = phi( main::@5/&fn1, main::@3/&fn2 )
  [23] stackpush(byte) = main::i#2
  [24] callexecute *main::f#3 
  sideeffect stackpullbytes(1)
  to:main::@4

null depth in calling loop Loop head: main::@1 tails: main::@4 blocks: main::@4 main::@6 main::@7 main::@3 main::@5 main::@2 main::@1  in scope fn3

VARIABLE REGISTER WEIGHTS
__stackcall void fn1(byte fn1::c)
byte fn1::c
byte fn1::c#0 4.0
__stackcall void fn2(byte fn2::d)
byte fn2::d
byte fn2::d#0 4.0
__stackcall void fn3(byte fn3::e)
byte fn3::e
byte fn3::e#0 202.0
void main()
byte~ main::$1 22.0
byte~ main::$5 22.0
void(byte)* main::f
void(byte)* main::f#3
byte main::i
byte main::i#1 22.0
byte main::i#2 5.9230769230769225

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ main::f#3 ]
Added variable fn3::e#0 to live range equivalence class [ fn3::e#0 ]
Added variable fn2::d#0 to live range equivalence class [ fn2::d#0 ]
Added variable fn1::c#0 to live range equivalence class [ fn1::c#0 ]
Added variable main::$1 to live range equivalence class [ main::$1 ]
Added variable main::$5 to live range equivalence class [ main::$5 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ main::f#3 ]
[ fn3::e#0 ]
[ fn2::d#0 ]
[ fn1::c#0 ]
[ main::$1 ]
[ main::$5 ]
Allocated zp[1]:2 [ main::i#2 main::i#1 ]
Allocated zp[2]:3 [ main::f#3 ]
Allocated zp[1]:5 [ fn3::e#0 ]
Allocated zp[1]:6 [ fn2::d#0 ]
Allocated zp[1]:7 [ fn1::c#0 ]
Allocated zp[1]:8 [ main::$1 ]
Allocated zp[1]:9 [ main::$5 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] fn3::e#0 = stackidx(byte,fn3::OFFSET_STACK_E) [ fn3::e#0 ] ( fn3:16 [ main::i#2 fn3::e#0 ] { }  ) always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::i#2 main::i#1 ]
Removing always clobbered register reg byte x as potential for zp[1]:2 [ main::i#2 main::i#1 ]
Statement [1] SCREEN[fn3::e#0] = 'c' [ ] ( fn3:16 [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [3] fn2::d#0 = stackidx(byte,fn2::OFFSET_STACK_D) [ fn2::d#0 ] (  [ fn2::d#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [4] SCREEN[fn2::d#0] = 'b' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] fn1::c#0 = stackidx(byte,fn1::OFFSET_STACK_C) [ fn1::c#0 ] (  [ fn1::c#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [7] SCREEN[fn1::c#0] = 'a' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [13] main::$1 = main::i#2 & 1 [ main::i#2 main::$1 ] (  [ main::i#2 main::$1 ] { }  ) always clobbers reg byte a 
Statement [15] stackpush(byte) = main::i#2 [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement sideeffect stackpullbytes(1) always clobbers reg byte a 
Statement [19] main::$5 = main::i#2 & 3 [ main::i#2 main::$5 ] (  [ main::i#2 main::$5 ] { }  ) always clobbers reg byte a 
Statement [23] stackpush(byte) = main::i#2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [24] callexecute *main::f#3  [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:2 [ main::i#2 main::i#1 ]
Statement sideeffect stackpullbytes(1) always clobbers reg byte a 
Statement [0] fn3::e#0 = stackidx(byte,fn3::OFFSET_STACK_E) [ fn3::e#0 ] ( fn3:16 [ main::i#2 fn3::e#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [1] SCREEN[fn3::e#0] = 'c' [ ] ( fn3:16 [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [3] fn2::d#0 = stackidx(byte,fn2::OFFSET_STACK_D) [ fn2::d#0 ] (  [ fn2::d#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [4] SCREEN[fn2::d#0] = 'b' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] fn1::c#0 = stackidx(byte,fn1::OFFSET_STACK_C) [ fn1::c#0 ] (  [ fn1::c#0 ] { }  ) always clobbers reg byte a reg byte x 
Statement [7] SCREEN[fn1::c#0] = 'a' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [11] if(main::i#2<$a0) goto main::@2 [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [13] main::$1 = main::i#2 & 1 [ main::i#2 main::$1 ] (  [ main::i#2 main::$1 ] { }  ) always clobbers reg byte a 
Statement [15] stackpush(byte) = main::i#2 [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement sideeffect stackpullbytes(1) always clobbers reg byte a 
Statement [19] main::$5 = main::i#2 & 3 [ main::i#2 main::$5 ] (  [ main::i#2 main::$5 ] { }  ) always clobbers reg byte a 
Statement [23] stackpush(byte) = main::i#2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [24] callexecute *main::f#3  [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement sideeffect stackpullbytes(1) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::i#2 main::i#1 ] : zp[1]:2 , 
Potential registers zp[2]:3 [ main::f#3 ] : zp[2]:3 , 
Potential registers zp[1]:5 [ fn3::e#0 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ fn2::d#0 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ fn1::c#0 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ main::$1 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ main::$5 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [fn3] 202: zp[1]:5 [ fn3::e#0 ] 
Uplift Scope [main] 27.92: zp[1]:2 [ main::i#2 main::i#1 ] 22: zp[1]:8 [ main::$1 ] 22: zp[1]:9 [ main::$5 ] 0: zp[2]:3 [ main::f#3 ] 
Uplift Scope [fn1] 4: zp[1]:7 [ fn1::c#0 ] 
Uplift Scope [fn2] 4: zp[1]:6 [ fn2::d#0 ] 
Uplift Scope [] 

Uplifting [fn3] best 1391 combination reg byte a [ fn3::e#0 ] 
Uplifting [main] best 1291 combination zp[1]:2 [ main::i#2 main::i#1 ] reg byte a [ main::$1 ] reg byte a [ main::$5 ] zp[2]:3 [ main::f#3 ] 
Uplifting [fn1] best 1287 combination reg byte a [ fn1::c#0 ] 
Uplifting [fn2] best 1283 combination reg byte a [ fn2::d#0 ] 
Uplifting [] best 1283 combination 
Attempting to uplift remaining variables inzp[1]:2 [ main::i#2 main::i#1 ]
Uplifting [main] best 1283 combination zp[1]:2 [ main::i#2 main::i#1 ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test function pointers with parameters
// Currently the parameter is not transferred properly
  // Upstart
  // Commodore 64 PRG executable file
.file [name="function-pointer-param-0.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const STACK_BASE = $103
  .label SCREEN = $400
.segment Code
  // fn3
// fn3(byte register(A) e)
fn3: {
    .const OFFSET_STACK_E = 0
    // [0] fn3::e#0 = stackidx(byte,fn3::OFFSET_STACK_E) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_E,x
    // [1] SCREEN[fn3::e#0] = 'c' -- pbuc1_derefidx_vbuaa=vbuc2 
    tay
    lda #'c'
    sta SCREEN,y
    jmp __breturn
    // fn3::@return
  __breturn:
    // [2] return 
    rts
}
  // fn2
// fn2(byte register(A) d)
fn2: {
    .const OFFSET_STACK_D = 0
    // [3] fn2::d#0 = stackidx(byte,fn2::OFFSET_STACK_D) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_D,x
    // [4] SCREEN[fn2::d#0] = 'b' -- pbuc1_derefidx_vbuaa=vbuc2 
    tay
    lda #'b'
    sta SCREEN,y
    jmp __breturn
    // fn2::@return
  __breturn:
    // [5] return 
    rts
}
  // fn1
// fn1(byte register(A) c)
fn1: {
    .const OFFSET_STACK_C = 0
    // [6] fn1::c#0 = stackidx(byte,fn1::OFFSET_STACK_C) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_C,x
    // [7] SCREEN[fn1::c#0] = 'a' -- pbuc1_derefidx_vbuaa=vbuc2 
    tay
    lda #'a'
    sta SCREEN,y
    jmp __breturn
    // fn1::@return
  __breturn:
    // [8] return 
    rts
}
  // main
main: {
    .label i = 2
    // A pointer to a function taking a single char param
    .label f = 3
    // [10] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [10] phi main::i#2 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // main::@1
  __b1:
    // [11] if(main::i#2<$a0) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #$a0
    bcc __b2
    jmp __breturn
    // main::@return
  __breturn:
    // [12] return 
    rts
    // main::@2
  __b2:
    // [13] main::$1 = main::i#2 & 1 -- vbuaa=vbuz1_band_vbuc1 
    lda #1
    and.z i
    // [14] if(main::$1!=0) goto main::@3 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b3
    jmp __b7
    // main::@7
  __b7:
    // [15] stackpush(byte) = main::i#2 -- _stackpushbyte_=vbuz1 
    lda.z i
    pha
    // [16] callexecute fn3  -- jsr 
    jsr fn3
    // sideeffect stackpullbytes(1) -- _stackpullbyte_1 
    pla
    jmp __b4
    // main::@4
  __b4:
    // [18] main::i#1 = ++ main::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [10] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  __b1_from___b4:
    // [10] phi main::i#2 = main::i#1 [phi:main::@4->main::@1#0] -- register_copy 
    jmp __b1
    // main::@3
  __b3:
    // [19] main::$5 = main::i#2 & 3 -- vbuaa=vbuz1_band_vbuc1 
    lda #3
    and.z i
    // [20] if(main::$5==1) goto main::@5 -- vbuaa_eq_vbuc1_then_la1 
    cmp #1
    beq __b5_from___b3
    // [22] phi from main::@3 to main::@6 [phi:main::@3->main::@6]
  __b6_from___b3:
    // [22] phi main::f#3 = &fn2 [phi:main::@3->main::@6#0] -- pprz1=pprc1 
    lda #<fn2
    sta.z f
    lda #>fn2
    sta.z f+1
    jmp __b6
    // [21] phi from main::@3 to main::@5 [phi:main::@3->main::@5]
  __b5_from___b3:
    jmp __b5
    // main::@5
  __b5:
    // [22] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    // [22] phi main::f#3 = &fn1 [phi:main::@5->main::@6#0] -- pprz1=pprc1 
    lda #<fn1
    sta.z f
    lda #>fn1
    sta.z f+1
    jmp __b6
    // main::@6
  __b6:
    // [23] stackpush(byte) = main::i#2 -- _stackpushbyte_=vbuz1 
    lda.z i
    pha
    // [24] callexecute *main::f#3 
    jsr bi_f
    // sideeffect stackpullbytes(1) -- _stackpullbyte_1 
    pla
    jmp __b4
  bi_f:
    jmp (f)
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b7
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b5_from___b3 with __b5
Removing instruction __b5_from___b3:
Removing instruction __b6_from___b5:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b1_from_main:
Removing instruction __breturn:
Removing instruction __b7:
Removing instruction __b1_from___b4:
Removing instruction __b6_from___b3:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
constant byte* const SCREEN = (byte*) 1024
constant word STACK_BASE = $103
__stackcall void fn1(byte fn1::c)
constant byte fn1::OFFSET_STACK_C = 0
byte fn1::c
byte fn1::c#0 reg byte a 4.0
__stackcall void fn2(byte fn2::d)
constant byte fn2::OFFSET_STACK_D = 0
byte fn2::d
byte fn2::d#0 reg byte a 4.0
__stackcall void fn3(byte fn3::e)
constant byte fn3::OFFSET_STACK_E = 0
byte fn3::e
byte fn3::e#0 reg byte a 202.0
void main()
byte~ main::$1 reg byte a 22.0
byte~ main::$5 reg byte a 22.0
void(byte)* main::f
void(byte)* main::f#3 f zp[2]:3
byte main::i
byte main::i#1 i zp[1]:2 22.0
byte main::i#2 i zp[1]:2 5.9230769230769225

zp[1]:2 [ main::i#2 main::i#1 ]
zp[2]:3 [ main::f#3 ]
reg byte a [ fn3::e#0 ]
reg byte a [ fn2::d#0 ]
reg byte a [ fn1::c#0 ]
reg byte a [ main::$1 ]
reg byte a [ main::$5 ]


FINAL ASSEMBLER
Score: 1094

  // File Comments
// Test function pointers with parameters
// Currently the parameter is not transferred properly
  // Upstart
  // Commodore 64 PRG executable file
.file [name="function-pointer-param-0.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const STACK_BASE = $103
  .label SCREEN = $400
.segment Code
  // fn3
// fn3(byte register(A) e)
fn3: {
    .const OFFSET_STACK_E = 0
    // [0] fn3::e#0 = stackidx(byte,fn3::OFFSET_STACK_E) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_E,x
    // SCREEN[e] = 'c'
    // [1] SCREEN[fn3::e#0] = 'c' -- pbuc1_derefidx_vbuaa=vbuc2 
    tay
    lda #'c'
    sta SCREEN,y
    // fn3::@return
    // }
    // [2] return 
    rts
}
  // fn2
// fn2(byte register(A) d)
fn2: {
    .const OFFSET_STACK_D = 0
    // [3] fn2::d#0 = stackidx(byte,fn2::OFFSET_STACK_D) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_D,x
    // SCREEN[d] = 'b'
    // [4] SCREEN[fn2::d#0] = 'b' -- pbuc1_derefidx_vbuaa=vbuc2 
    tay
    lda #'b'
    sta SCREEN,y
    // fn2::@return
    // }
    // [5] return 
    rts
}
  // fn1
// fn1(byte register(A) c)
fn1: {
    .const OFFSET_STACK_C = 0
    // [6] fn1::c#0 = stackidx(byte,fn1::OFFSET_STACK_C) -- vbuaa=_stackidxbyte_vbuc1 
    tsx
    lda STACK_BASE+OFFSET_STACK_C,x
    // SCREEN[c] = 'a'
    // [7] SCREEN[fn1::c#0] = 'a' -- pbuc1_derefidx_vbuaa=vbuc2 
    tay
    lda #'a'
    sta SCREEN,y
    // fn1::@return
    // }
    // [8] return 
    rts
}
  // main
main: {
    .label i = 2
    // A pointer to a function taking a single char param
    .label f = 3
    // [10] phi from main to main::@1 [phi:main->main::@1]
    // [10] phi main::i#2 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // main::@1
  __b1:
    // for(char i=0;i<160;i++)
    // [11] if(main::i#2<$a0) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #$a0
    bcc __b2
    // main::@return
    // }
    // [12] return 
    rts
    // main::@2
  __b2:
    // i&1
    // [13] main::$1 = main::i#2 & 1 -- vbuaa=vbuz1_band_vbuc1 
    lda #1
    and.z i
    // if((i&1)==0)
    // [14] if(main::$1!=0) goto main::@3 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b3
    // main::@7
    // fn3(i)
    // [15] stackpush(byte) = main::i#2 -- _stackpushbyte_=vbuz1 
    lda.z i
    pha
    // [16] callexecute fn3  -- jsr 
    jsr fn3
    // sideeffect stackpullbytes(1) -- _stackpullbyte_1 
    pla
    // main::@4
  __b4:
    // for(char i=0;i<160;i++)
    // [18] main::i#1 = ++ main::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [10] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
    // [10] phi main::i#2 = main::i#1 [phi:main::@4->main::@1#0] -- register_copy 
    jmp __b1
    // main::@3
  __b3:
    // i&3
    // [19] main::$5 = main::i#2 & 3 -- vbuaa=vbuz1_band_vbuc1 
    lda #3
    and.z i
    // if((i&3)==1)
    // [20] if(main::$5==1) goto main::@5 -- vbuaa_eq_vbuc1_then_la1 
    cmp #1
    beq __b5
    // [22] phi from main::@3 to main::@6 [phi:main::@3->main::@6]
    // [22] phi main::f#3 = &fn2 [phi:main::@3->main::@6#0] -- pprz1=pprc1 
    lda #<fn2
    sta.z f
    lda #>fn2
    sta.z f+1
    jmp __b6
    // [21] phi from main::@3 to main::@5 [phi:main::@3->main::@5]
    // main::@5
  __b5:
    // [22] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // [22] phi main::f#3 = &fn1 [phi:main::@5->main::@6#0] -- pprz1=pprc1 
    lda #<fn1
    sta.z f
    lda #>fn1
    sta.z f+1
    // main::@6
  __b6:
    // (*f)(i)
    // [23] stackpush(byte) = main::i#2 -- _stackpushbyte_=vbuz1 
    lda.z i
    pha
    // [24] callexecute *main::f#3 
    jsr bi_f
    // sideeffect stackpullbytes(1) -- _stackpullbyte_1 
    pla
    jmp __b4
  bi_f:
    jmp (f)
}
  // File Data

