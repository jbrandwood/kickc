Identified constant variable (byte*) SCREEN
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @5
Culled Empty Block (label) keyboard_matrix_read::@1
Culled Empty Block (label) @6
Culled Empty Block (label) keyboard_key_pressed::@1
Culled Empty Block (label) @7
Culled Empty Block (label) @8
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@6
Culled Empty Block (label) menu::@7
Culled Empty Block (label) menu::@3
Culled Empty Block (label) menu::@8
Culled Empty Block (label) menu::@10
Culled Empty Block (label) menu::@12
Culled Empty Block (label) menu::@14
Culled Empty Block (label) menu::@15
Culled Empty Block (label) @13
Culled Empty Block (label) pressed::@5
Culled Empty Block (label) pressed::@3
Culled Empty Block (label) pressed::@6
Culled Empty Block (label) pressed::@4
Culled Empty Block (label) pressed::@7
Culled Empty Block (label) pressed::@8
Culled Empty Block (label) pressed::@9

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) BORDERCOL#0 ← ((byte*)) (number) $d020
  (byte*) BGCOL#0 ← ((byte*)) (number) $d021
  (byte*) CIA1_PORT_A#0 ← ((byte*)) (number) $dc00
  (byte*) CIA1_PORT_B#0 ← ((byte*)) (number) $dc01
  (byte) RED#0 ← (number) 2
  (byte) GREEN#0 ← (number) 5
  to:@4
@4: scope:[]  from @begin
  (byte) KEY_E#0 ← (number) $e
  (byte) KEY_C#0 ← (number) $14
  (byte) KEY_I#0 ← (number) $21
  (byte) KEY_SPACE#0 ← (number) $3c
  (byte[8]) keyboard_matrix_row_bitmask#0 ← { (number) $fe, (number) $fd, (number) $fb, (number) $f7, (number) $ef, (number) $df, (number) $bf, (number) $7f }
  (byte[8]) keyboard_matrix_col_bitmask#0 ← { (number) 1, (number) 2, (number) 4, (number) 8, (number) $10, (number) $20, (number) $40, (number) $80 }
  to:@12
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  (byte) keyboard_matrix_read::rowid#1 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::rowid#0 )
  *((byte*) CIA1_PORT_A#0) ← *((byte[8]) keyboard_matrix_row_bitmask#0 + (byte) keyboard_matrix_read::rowid#1)
  (byte~) keyboard_matrix_read::$0 ← ~ *((byte*) CIA1_PORT_B#0)
  (byte) keyboard_matrix_read::row_pressed_bits#0 ← (byte~) keyboard_matrix_read::$0
  (byte) keyboard_matrix_read::return#0 ← (byte) keyboard_matrix_read::row_pressed_bits#0
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  (byte) keyboard_matrix_read::return#3 ← phi( keyboard_matrix_read/(byte) keyboard_matrix_read::return#0 )
  (byte) keyboard_matrix_read::return#1 ← (byte) keyboard_matrix_read::return#3
  return 
  to:@return
keyboard_key_pressed: scope:[keyboard_key_pressed]  from menu::@2 menu::@4 menu::@5 pressed::@2
  (byte) keyboard_key_pressed::key#4 ← phi( menu::@2/(byte) keyboard_key_pressed::key#0 menu::@4/(byte) keyboard_key_pressed::key#1 menu::@5/(byte) keyboard_key_pressed::key#2 pressed::@2/(byte) keyboard_key_pressed::key#3 )
  (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#4 & (number) 7
  (byte) keyboard_key_pressed::colidx#0 ← (number~) keyboard_key_pressed::$0
  (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#4 >> (number) 3
  (byte) keyboard_key_pressed::rowidx#0 ← (byte~) keyboard_key_pressed::$1
  (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  call keyboard_matrix_read 
  (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#1
  to:keyboard_key_pressed::@2
keyboard_key_pressed::@2: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  (byte) keyboard_key_pressed::colidx#1 ← phi( keyboard_key_pressed/(byte) keyboard_key_pressed::colidx#0 )
  (byte) keyboard_matrix_read::return#4 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::return#2 )
  (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#4
  (byte~) keyboard_key_pressed::$3 ← (byte~) keyboard_key_pressed::$2 & *((byte[8]) keyboard_matrix_col_bitmask#0 + (byte) keyboard_key_pressed::colidx#1)
  (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$3
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@2
  (byte) keyboard_key_pressed::return#6 ← phi( keyboard_key_pressed::@2/(byte) keyboard_key_pressed::return#0 )
  (byte) keyboard_key_pressed::return#1 ← (byte) keyboard_key_pressed::return#6
  return 
  to:@return
main: scope:[main]  from @14
  *((byte*) BORDERCOL#0) ← (byte) GREEN#0
  to:main::@1
main::@1: scope:[main]  from main main::@7
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  call menu 
  to:main::@7
main::@7: scope:[main]  from main::@2
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return
@12: scope:[]  from @4
  (byte*) SCREEN#0 ← ((byte*)) (number) $400
  to:@14
menu: scope:[menu]  from main::@2
  to:menu::@1
menu::@1: scope:[menu]  from menu menu::@6
  if(true) goto menu::@2
  to:menu::@return
menu::@2: scope:[menu]  from menu::@1
  (byte) keyboard_key_pressed::key#0 ← (byte) KEY_C#0
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#1
  to:menu::@16
menu::@16: scope:[menu]  from menu::@2
  (byte) keyboard_key_pressed::return#7 ← phi( menu::@2/(byte) keyboard_key_pressed::return#2 )
  (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#7
  (bool~) menu::$1 ← (byte~) menu::$0 != (number) 0
  (bool~) menu::$2 ← ! (bool~) menu::$1
  if((bool~) menu::$2) goto menu::@4
  to:menu::@9
menu::@4: scope:[menu]  from menu::@16
  (byte) keyboard_key_pressed::key#1 ← (byte) KEY_I#0
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#1
  to:menu::@17
menu::@17: scope:[menu]  from menu::@4
  (byte) keyboard_key_pressed::return#8 ← phi( menu::@4/(byte) keyboard_key_pressed::return#3 )
  (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#8
  (bool~) menu::$5 ← (byte~) menu::$4 != (number) 0
  (bool~) menu::$6 ← ! (bool~) menu::$5
  if((bool~) menu::$6) goto menu::@5
  to:menu::@11
menu::@9: scope:[menu]  from menu::@16
  call pressed 
  to:menu::@18
menu::@18: scope:[menu]  from menu::@9
  to:menu::@return
menu::@return: scope:[menu]  from menu::@1 menu::@11 menu::@13 menu::@18
  return 
  to:@return
menu::@5: scope:[menu]  from menu::@17
  (byte) keyboard_key_pressed::key#2 ← (byte) KEY_E#0
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#1
  to:menu::@19
menu::@19: scope:[menu]  from menu::@5
  (byte) keyboard_key_pressed::return#9 ← phi( menu::@5/(byte) keyboard_key_pressed::return#4 )
  (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#9
  (bool~) menu::$8 ← (byte~) menu::$7 != (number) 0
  (bool~) menu::$9 ← ! (bool~) menu::$8
  if((bool~) menu::$9) goto menu::@6
  to:menu::@13
menu::@11: scope:[menu]  from menu::@17
  *((byte*) BORDERCOL#0) ← (byte) RED#0
  asm { sei  }
  to:menu::@return
menu::@6: scope:[menu]  from menu::@19
  *((byte*) SCREEN#0) ← ++ *((byte*) SCREEN#0)
  to:menu::@1
menu::@13: scope:[menu]  from menu::@19
  *((byte*) BORDERCOL#0) ← (byte) GREEN#0
  asm { cli  }
  to:menu::@return
pressed: scope:[pressed]  from menu::@9
  *((byte*) BGCOL#0) ← ++ *((byte*) BGCOL#0)
  to:pressed::@1
pressed::@1: scope:[pressed]  from pressed pressed::@10
  if(true) goto pressed::@2
  to:pressed::@return
pressed::@2: scope:[pressed]  from pressed::@1
  (byte) keyboard_key_pressed::key#3 ← (byte) KEY_SPACE#0
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#5 ← (byte) keyboard_key_pressed::return#1
  to:pressed::@10
pressed::@10: scope:[pressed]  from pressed::@2
  (byte) keyboard_key_pressed::return#10 ← phi( pressed::@2/(byte) keyboard_key_pressed::return#5 )
  (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10
  (bool~) pressed::$2 ← (byte~) pressed::$1 != (number) 0
  (bool~) pressed::$3 ← ! (bool~) pressed::$2
  if((bool~) pressed::$3) goto pressed::@1
  to:pressed::@return
pressed::@return: scope:[pressed]  from pressed::@1 pressed::@10
  return 
  to:@return
@14: scope:[]  from @12
  call main 
  to:@15
@15: scope:[]  from @14
  to:@end
@end: scope:[]  from @15

SYMBOL TABLE SSA
(label) @12
(label) @14
(label) @15
(label) @4
(label) @begin
(label) @end
(byte*) BGCOL
(byte*) BGCOL#0
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte*) CIA1_PORT_A
(byte*) CIA1_PORT_A#0
(byte*) CIA1_PORT_B
(byte*) CIA1_PORT_B#0
(byte) GREEN
(byte) GREEN#0
(byte) KEY_C
(byte) KEY_C#0
(byte) KEY_E
(byte) KEY_E#0
(byte) KEY_I
(byte) KEY_I#0
(byte) KEY_SPACE
(byte) KEY_SPACE#0
(byte) RED
(byte) RED#0
(byte*) SCREEN
(byte*) SCREEN#0
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(number~) keyboard_key_pressed::$0
(byte~) keyboard_key_pressed::$1
(byte~) keyboard_key_pressed::$2
(byte~) keyboard_key_pressed::$3
(label) keyboard_key_pressed::@2
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0
(byte) keyboard_key_pressed::colidx#1
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0
(byte) keyboard_key_pressed::key#1
(byte) keyboard_key_pressed::key#2
(byte) keyboard_key_pressed::key#3
(byte) keyboard_key_pressed::key#4
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0
(byte) keyboard_key_pressed::return#1
(byte) keyboard_key_pressed::return#10
(byte) keyboard_key_pressed::return#2
(byte) keyboard_key_pressed::return#3
(byte) keyboard_key_pressed::return#4
(byte) keyboard_key_pressed::return#5
(byte) keyboard_key_pressed::return#6
(byte) keyboard_key_pressed::return#7
(byte) keyboard_key_pressed::return#8
(byte) keyboard_key_pressed::return#9
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0
(byte[8]) keyboard_matrix_col_bitmask
(byte[8]) keyboard_matrix_col_bitmask#0
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte~) keyboard_matrix_read::$0
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0
(byte) keyboard_matrix_read::return#1
(byte) keyboard_matrix_read::return#2
(byte) keyboard_matrix_read::return#3
(byte) keyboard_matrix_read::return#4
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::row_pressed_bits#0
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0
(byte) keyboard_matrix_read::rowid#1
(byte[8]) keyboard_matrix_row_bitmask
(byte[8]) keyboard_matrix_row_bitmask#0
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@7
(label) main::@return
(void()) menu()
(byte~) menu::$0
(bool~) menu::$1
(bool~) menu::$2
(byte~) menu::$4
(bool~) menu::$5
(bool~) menu::$6
(byte~) menu::$7
(bool~) menu::$8
(bool~) menu::$9
(label) menu::@1
(label) menu::@11
(label) menu::@13
(label) menu::@16
(label) menu::@17
(label) menu::@18
(label) menu::@19
(label) menu::@2
(label) menu::@4
(label) menu::@5
(label) menu::@6
(label) menu::@9
(label) menu::@return
(void()) pressed()
(byte~) pressed::$1
(bool~) pressed::$2
(bool~) pressed::$3
(label) pressed::@1
(label) pressed::@10
(label) pressed::@2
(label) pressed::@return

Adding number conversion cast (unumber) 2 in (byte) RED#0 ← (number) 2
Adding number conversion cast (unumber) 5 in (byte) GREEN#0 ← (number) 5
Adding number conversion cast (unumber) $e in (byte) KEY_E#0 ← (number) $e
Adding number conversion cast (unumber) $14 in (byte) KEY_C#0 ← (number) $14
Adding number conversion cast (unumber) $21 in (byte) KEY_I#0 ← (number) $21
Adding number conversion cast (unumber) $3c in (byte) KEY_SPACE#0 ← (number) $3c
Adding number conversion cast (unumber) 7 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#4 & (number) 7
Adding number conversion cast (unumber) keyboard_key_pressed::$0 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#4 & (unumber)(number) 7
Adding number conversion cast (unumber) 3 in (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#4 >> (number) 3
Adding number conversion cast (unumber) 0 in (bool~) menu::$1 ← (byte~) menu::$0 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) menu::$5 ← (byte~) menu::$4 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) menu::$8 ← (byte~) menu::$7 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) pressed::$2 ← (byte~) pressed::$1 != (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Added casts to value list in (byte[8]) keyboard_matrix_row_bitmask#0 ← (byte[8]){ (byte)(number) $fe, (byte)(number) $fd, (byte)(number) $fb, (byte)(number) $f7, (byte)(number) $ef, (byte)(number) $df, (byte)(number) $bf, (byte)(number) $7f }
Added casts to value list in (byte[8]) keyboard_matrix_col_bitmask#0 ← (byte[8]){ (byte)(number) 1, (byte)(number) 2, (byte)(number) 4, (byte)(number) 8, (byte)(number) $10, (byte)(number) $20, (byte)(number) $40, (byte)(number) $80 }
Successful SSA optimization PassNAddInitializerValueListTypeCasts
Inlining cast (byte*) BORDERCOL#0 ← (byte*)(number) $d020
Inlining cast (byte*) BGCOL#0 ← (byte*)(number) $d021
Inlining cast (byte*) CIA1_PORT_A#0 ← (byte*)(number) $dc00
Inlining cast (byte*) CIA1_PORT_B#0 ← (byte*)(number) $dc01
Inlining cast (byte) RED#0 ← (unumber)(number) 2
Inlining cast (byte) GREEN#0 ← (unumber)(number) 5
Inlining cast (byte) KEY_E#0 ← (unumber)(number) $e
Inlining cast (byte) KEY_C#0 ← (unumber)(number) $14
Inlining cast (byte) KEY_I#0 ← (unumber)(number) $21
Inlining cast (byte) KEY_SPACE#0 ← (unumber)(number) $3c
Inlining cast (byte*) SCREEN#0 ← (byte*)(number) $400
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53281
Simplifying constant pointer cast (byte*) 56320
Simplifying constant pointer cast (byte*) 56321
Simplifying constant integer cast 2
Simplifying constant integer cast 5
Simplifying constant integer cast $e
Simplifying constant integer cast $14
Simplifying constant integer cast $21
Simplifying constant integer cast $3c
Simplifying constant integer cast $fe
Simplifying constant integer cast $fd
Simplifying constant integer cast $fb
Simplifying constant integer cast $f7
Simplifying constant integer cast $ef
Simplifying constant integer cast $df
Simplifying constant integer cast $bf
Simplifying constant integer cast $7f
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 8
Simplifying constant integer cast $10
Simplifying constant integer cast $20
Simplifying constant integer cast $40
Simplifying constant integer cast $80
Simplifying constant integer cast 7
Simplifying constant integer cast 3
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $e
Finalized unsigned number type (byte) $14
Finalized unsigned number type (byte) $21
Finalized unsigned number type (byte) $3c
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7
Inversing boolean not [47] (bool~) menu::$2 ← (byte~) menu::$0 == (byte) 0 from [46] (bool~) menu::$1 ← (byte~) menu::$0 != (byte) 0
Inversing boolean not [55] (bool~) menu::$6 ← (byte~) menu::$4 == (byte) 0 from [54] (bool~) menu::$5 ← (byte~) menu::$4 != (byte) 0
Inversing boolean not [65] (bool~) menu::$9 ← (byte~) menu::$7 == (byte) 0 from [64] (bool~) menu::$8 ← (byte~) menu::$7 != (byte) 0
Inversing boolean not [80] (bool~) pressed::$3 ← (byte~) pressed::$1 == (byte) 0 from [79] (bool~) pressed::$2 ← (byte~) pressed::$1 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte) keyboard_matrix_read::return#0 = (byte) keyboard_matrix_read::row_pressed_bits#0 (byte~) keyboard_matrix_read::$0 (byte) keyboard_matrix_read::return#3 (byte) keyboard_matrix_read::return#1 
Alias (byte) keyboard_key_pressed::colidx#0 = (byte~) keyboard_key_pressed::$0 (byte) keyboard_key_pressed::colidx#1 
Alias (byte) keyboard_key_pressed::rowidx#0 = (byte~) keyboard_key_pressed::$1 
Alias (byte) keyboard_matrix_read::return#2 = (byte) keyboard_matrix_read::return#4 
Alias (byte) keyboard_key_pressed::return#0 = (byte~) keyboard_key_pressed::$3 (byte) keyboard_key_pressed::return#6 (byte) keyboard_key_pressed::return#1 
Alias (byte) keyboard_key_pressed::return#2 = (byte) keyboard_key_pressed::return#7 
Alias (byte) keyboard_key_pressed::return#3 = (byte) keyboard_key_pressed::return#8 
Alias (byte) keyboard_key_pressed::return#4 = (byte) keyboard_key_pressed::return#9 
Alias (byte) keyboard_key_pressed::return#10 = (byte) keyboard_key_pressed::return#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) keyboard_matrix_read::rowid#1 (byte) keyboard_matrix_read::rowid#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) menu::$2 [48] if((byte~) menu::$0==(byte) 0) goto menu::@4
Simple Condition (bool~) menu::$6 [56] if((byte~) menu::$4==(byte) 0) goto menu::@5
Simple Condition (bool~) menu::$9 [66] if((byte~) menu::$7==(byte) 0) goto menu::@6
Simple Condition (bool~) pressed::$3 [81] if((byte~) pressed::$1==(byte) 0) goto pressed::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [81] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Identified constant from value list (byte[8]) { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
Identified constant from value list (byte[8]) { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
Successful SSA optimization Pass2ConstantInitializerValueLists
Constant (const byte*) BORDERCOL#0 = (byte*) 53280
Constant (const byte*) BGCOL#0 = (byte*) 53281
Constant (const byte*) CIA1_PORT_A#0 = (byte*) 56320
Constant (const byte*) CIA1_PORT_B#0 = (byte*) 56321
Constant (const byte) RED#0 = 2
Constant (const byte) GREEN#0 = 5
Constant (const byte) KEY_E#0 = $e
Constant (const byte) KEY_C#0 = $14
Constant (const byte) KEY_I#0 = $21
Constant (const byte) KEY_SPACE#0 = $3c
Constant (const byte[8]) keyboard_matrix_row_bitmask#0 = { $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f }
Constant (const byte[8]) keyboard_matrix_col_bitmask#0 = { 1, 2, 4, 8, $10, $20, $40, $80 }
Constant (const byte*) SCREEN#0 = (byte*) 1024
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) keyboard_key_pressed::key#0 = KEY_C#0
Constant (const byte) keyboard_key_pressed::key#1 = KEY_I#0
Constant (const byte) keyboard_key_pressed::key#2 = KEY_E#0
Constant (const byte) keyboard_key_pressed::key#3 = KEY_SPACE#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [36] if(true) goto main::@2
if() condition always true - replacing block destination [40] if(true) goto menu::@2
if() condition always true - replacing block destination [73] if(true) goto pressed::@2
Successful SSA optimization Pass2ConstantIfs
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#0
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#1
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#2
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#3
Constant inlined keyboard_key_pressed::key#0 = (const byte) KEY_C#0
Constant inlined keyboard_key_pressed::key#1 = (const byte) KEY_I#0
Constant inlined keyboard_key_pressed::key#2 = (const byte) KEY_E#0
Constant inlined keyboard_key_pressed::key#3 = (const byte) KEY_SPACE#0
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @12
Adding NOP phi() at start of @14
Adding NOP phi() at start of @15
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of menu
Adding NOP phi() at start of menu::@1
Adding NOP phi() at start of menu::@2
Adding NOP phi() at start of menu::@9
Adding NOP phi() at start of menu::@18
Adding NOP phi() at start of menu::@4
Adding NOP phi() at start of menu::@5
Adding NOP phi() at start of pressed::@1
Adding NOP phi() at start of pressed::@2
CALL GRAPH
Calls in [] to main:4 
Calls in [main] to menu:10 
Calls in [menu] to keyboard_key_pressed:15 pressed:20 keyboard_key_pressed:24 keyboard_key_pressed:31 
Calls in [keyboard_key_pressed] to keyboard_matrix_read:42 
Calls in [pressed] to keyboard_key_pressed:53 

Created 1 initial phi equivalence classes
Coalesced down to 1 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @12
Culled Empty Block (label) @15
Culled Empty Block (label) main::@1
Culled Empty Block (label) main::@7
Culled Empty Block (label) menu::@1
Culled Empty Block (label) menu::@18
Culled Empty Block (label) pressed::@1
Renumbering block @14 to @1
Renumbering block keyboard_key_pressed::@2 to keyboard_key_pressed::@1
Renumbering block main::@2 to main::@1
Renumbering block menu::@2 to menu::@1
Renumbering block menu::@4 to menu::@2
Renumbering block menu::@5 to menu::@3
Renumbering block menu::@6 to menu::@4
Renumbering block menu::@9 to menu::@5
Renumbering block menu::@11 to menu::@6
Renumbering block menu::@13 to menu::@7
Renumbering block menu::@16 to menu::@8
Renumbering block menu::@17 to menu::@9
Renumbering block menu::@19 to menu::@10
Renumbering block pressed::@2 to pressed::@1
Renumbering block pressed::@10 to pressed::@2
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of menu
Adding NOP phi() at start of menu::@1
Adding NOP phi() at start of menu::@5
Adding NOP phi() at start of menu::@2
Adding NOP phi() at start of menu::@3
Adding NOP phi() at start of pressed::@1

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [5] phi()
  [6] call menu 
  to:main::@1
menu: scope:[menu]  from main::@1
  [7] phi()
  to:menu::@1
menu::@1: scope:[menu]  from menu menu::@4
  [8] phi()
  [9] call keyboard_key_pressed 
  [10] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
  to:menu::@8
menu::@8: scope:[menu]  from menu::@1
  [11] (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#2
  [12] if((byte~) menu::$0==(byte) 0) goto menu::@2
  to:menu::@5
menu::@5: scope:[menu]  from menu::@8
  [13] phi()
  [14] call pressed 
  to:menu::@return
menu::@return: scope:[menu]  from menu::@5 menu::@6 menu::@7
  [15] return 
  to:@return
menu::@2: scope:[menu]  from menu::@8
  [16] phi()
  [17] call keyboard_key_pressed 
  [18] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0
  to:menu::@9
menu::@9: scope:[menu]  from menu::@2
  [19] (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#3
  [20] if((byte~) menu::$4==(byte) 0) goto menu::@3
  to:menu::@6
menu::@6: scope:[menu]  from menu::@9
  [21] *((const byte*) BORDERCOL#0) ← (const byte) RED#0
  asm { sei  }
  to:menu::@return
menu::@3: scope:[menu]  from menu::@9
  [23] phi()
  [24] call keyboard_key_pressed 
  [25] (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#0
  to:menu::@10
menu::@10: scope:[menu]  from menu::@3
  [26] (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#4
  [27] if((byte~) menu::$7==(byte) 0) goto menu::@4
  to:menu::@7
menu::@7: scope:[menu]  from menu::@10
  [28] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0
  asm { cli  }
  to:menu::@return
menu::@4: scope:[menu]  from menu::@10
  [30] *((const byte*) SCREEN#0) ← ++ *((const byte*) SCREEN#0)
  to:menu::@1
keyboard_key_pressed: scope:[keyboard_key_pressed]  from menu::@1 menu::@2 menu::@3 pressed::@1
  [31] (byte) keyboard_key_pressed::key#4 ← phi( menu::@1/(const byte) KEY_C#0 menu::@2/(const byte) KEY_I#0 menu::@3/(const byte) KEY_E#0 pressed::@1/(const byte) KEY_SPACE#0 )
  [32] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7
  [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3
  [34] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  [35] call keyboard_matrix_read 
  [36] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  [37] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
  [38] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask#0 + (byte) keyboard_key_pressed::colidx#0)
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  [39] return 
  to:@return
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  [40] *((const byte*) CIA1_PORT_A#0) ← *((const byte[8]) keyboard_matrix_row_bitmask#0 + (byte) keyboard_matrix_read::rowid#0)
  [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B#0)
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  [42] return 
  to:@return
pressed: scope:[pressed]  from menu::@5
  [43] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0)
  to:pressed::@1
pressed::@1: scope:[pressed]  from pressed pressed::@2
  [44] phi()
  [45] call keyboard_key_pressed 
  [46] (byte) keyboard_key_pressed::return#10 ← (byte) keyboard_key_pressed::return#0
  to:pressed::@2
pressed::@2: scope:[pressed]  from pressed::@1
  [47] (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10
  [48] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return
  to:pressed::@1
pressed::@return: scope:[pressed]  from pressed::@2
  [49] return 
  to:@return

null depth in calling loop Loop head: pressed::@1 tails: pressed::@2 blocks: pressed::@2 pressed::@1  in scope keyboard_key_pressed

VARIABLE REGISTER WEIGHTS
(byte*) BGCOL
(byte*) BORDERCOL
(byte*) CIA1_PORT_A
(byte*) CIA1_PORT_B
(byte) GREEN
(byte) KEY_C
(byte) KEY_E
(byte) KEY_I
(byte) KEY_SPACE
(byte) RED
(byte*) SCREEN
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 4.0
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0 0.6666666666666666
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#4 2.0
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 67.66666666666667
(byte) keyboard_key_pressed::return#10 202.0
(byte) keyboard_key_pressed::return#2 202.0
(byte) keyboard_key_pressed::return#3 202.0
(byte) keyboard_key_pressed::return#4 202.0
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0 4.0
(byte[8]) keyboard_matrix_col_bitmask
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 1.3333333333333333
(byte) keyboard_matrix_read::return#2 4.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0 4.0
(byte[8]) keyboard_matrix_row_bitmask
(void()) main()
(void()) menu()
(byte~) menu::$0 202.0
(byte~) menu::$4 202.0
(byte~) menu::$7 202.0
(void()) pressed()
(byte~) pressed::$1 202.0

Initial phi equivalence classes
[ keyboard_key_pressed::key#4 ]
Added variable keyboard_key_pressed::return#2 to zero page equivalence class [ keyboard_key_pressed::return#2 ]
Added variable menu::$0 to zero page equivalence class [ menu::$0 ]
Added variable keyboard_key_pressed::return#3 to zero page equivalence class [ keyboard_key_pressed::return#3 ]
Added variable menu::$4 to zero page equivalence class [ menu::$4 ]
Added variable keyboard_key_pressed::return#4 to zero page equivalence class [ keyboard_key_pressed::return#4 ]
Added variable menu::$7 to zero page equivalence class [ menu::$7 ]
Added variable keyboard_key_pressed::colidx#0 to zero page equivalence class [ keyboard_key_pressed::colidx#0 ]
Added variable keyboard_key_pressed::rowidx#0 to zero page equivalence class [ keyboard_key_pressed::rowidx#0 ]
Added variable keyboard_matrix_read::rowid#0 to zero page equivalence class [ keyboard_matrix_read::rowid#0 ]
Added variable keyboard_matrix_read::return#2 to zero page equivalence class [ keyboard_matrix_read::return#2 ]
Added variable keyboard_key_pressed::$2 to zero page equivalence class [ keyboard_key_pressed::$2 ]
Added variable keyboard_key_pressed::return#0 to zero page equivalence class [ keyboard_key_pressed::return#0 ]
Added variable keyboard_matrix_read::return#0 to zero page equivalence class [ keyboard_matrix_read::return#0 ]
Added variable keyboard_key_pressed::return#10 to zero page equivalence class [ keyboard_key_pressed::return#10 ]
Added variable pressed::$1 to zero page equivalence class [ pressed::$1 ]
Complete equivalence classes
[ keyboard_key_pressed::key#4 ]
[ keyboard_key_pressed::return#2 ]
[ menu::$0 ]
[ keyboard_key_pressed::return#3 ]
[ menu::$4 ]
[ keyboard_key_pressed::return#4 ]
[ menu::$7 ]
[ keyboard_key_pressed::colidx#0 ]
[ keyboard_key_pressed::rowidx#0 ]
[ keyboard_matrix_read::rowid#0 ]
[ keyboard_matrix_read::return#2 ]
[ keyboard_key_pressed::$2 ]
[ keyboard_key_pressed::return#0 ]
[ keyboard_matrix_read::return#0 ]
[ keyboard_key_pressed::return#10 ]
[ pressed::$1 ]
Allocated zp ZP_BYTE:2 [ keyboard_key_pressed::key#4 ]
Allocated zp ZP_BYTE:3 [ keyboard_key_pressed::return#2 ]
Allocated zp ZP_BYTE:4 [ menu::$0 ]
Allocated zp ZP_BYTE:5 [ keyboard_key_pressed::return#3 ]
Allocated zp ZP_BYTE:6 [ menu::$4 ]
Allocated zp ZP_BYTE:7 [ keyboard_key_pressed::return#4 ]
Allocated zp ZP_BYTE:8 [ menu::$7 ]
Allocated zp ZP_BYTE:9 [ keyboard_key_pressed::colidx#0 ]
Allocated zp ZP_BYTE:10 [ keyboard_key_pressed::rowidx#0 ]
Allocated zp ZP_BYTE:11 [ keyboard_matrix_read::rowid#0 ]
Allocated zp ZP_BYTE:12 [ keyboard_matrix_read::return#2 ]
Allocated zp ZP_BYTE:13 [ keyboard_key_pressed::$2 ]
Allocated zp ZP_BYTE:14 [ keyboard_key_pressed::return#0 ]
Allocated zp ZP_BYTE:15 [ keyboard_matrix_read::return#0 ]
Allocated zp ZP_BYTE:16 [ keyboard_key_pressed::return#10 ]
Allocated zp ZP_BYTE:17 [ pressed::$1 ]

INITIAL ASM
Target platform is c64basic / 6502X
  // File Comments
// Exploring keyboard glitch that finds "C" press when pressing space
// The glitch is caused by the "normal" C64 interrupt occuring just as the keyboard is read.
// Press "I" to disable interrupts (red border)
// Press "E" to enable interrupts (green border)
// Press "C" to enter pressed state (increaded bgcol) - and "SPACE" to leave presssed state again.
// Holding SPACE will sometimes trigger the pressed state when normal interrupts are enabled (green border)
// but never when they are disabled (red border)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label BORDERCOL = $d020
  .label BGCOL = $d021
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  .const RED = 2
  .const GREEN = 5
  .const KEY_E = $e
  .const KEY_C = $14
  .const KEY_I = $21
  .const KEY_SPACE = $3c
  .label SCREEN = $400
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    // [4] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // [5] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
  b1_from_main:
  b1_from_b1:
    jmp b1
    // main::@1
  b1:
    // [6] call menu 
    // [7] phi from main::@1 to menu [phi:main::@1->menu]
  menu_from_b1:
    jsr menu
    jmp b1_from_b1
}
  // menu
menu: {
    .label _0 = 4
    .label _4 = 6
    .label _7 = 8
    // [8] phi from menu menu::@4 to menu::@1 [phi:menu/menu::@4->menu::@1]
  b1_from_menu:
  b1_from_b4:
    jmp b1
    // menu::@1
  b1:
    // [9] call keyboard_key_pressed 
    // [31] phi from menu::@1 to keyboard_key_pressed [phi:menu::@1->keyboard_key_pressed]
  keyboard_key_pressed_from_b1:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_C#0 [phi:menu::@1->keyboard_key_pressed#0] -- vbuz1=vbuc1 
    lda #KEY_C
    sta.z keyboard_key_pressed.key
    jsr keyboard_key_pressed
    // [10] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_2
    jmp b8
    // menu::@8
  b8:
    // [11] (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_2
    sta.z _0
    // [12] if((byte~) menu::$0==(byte) 0) goto menu::@2 -- vbuz1_eq_0_then_la1 
    lda.z _0
    cmp #0
    beq b2_from_b8
    // [13] phi from menu::@8 to menu::@5 [phi:menu::@8->menu::@5]
  b5_from_b8:
    jmp b5
    // menu::@5
  b5:
    // [14] call pressed 
    jsr pressed
    jmp breturn
    // menu::@return
  breturn:
    // [15] return 
    rts
    // [16] phi from menu::@8 to menu::@2 [phi:menu::@8->menu::@2]
  b2_from_b8:
    jmp b2
    // menu::@2
  b2:
    // [17] call keyboard_key_pressed 
    // [31] phi from menu::@2 to keyboard_key_pressed [phi:menu::@2->keyboard_key_pressed]
  keyboard_key_pressed_from_b2:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_I#0 [phi:menu::@2->keyboard_key_pressed#0] -- vbuz1=vbuc1 
    lda #KEY_I
    sta.z keyboard_key_pressed.key
    jsr keyboard_key_pressed
    // [18] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_3
    jmp b9
    // menu::@9
  b9:
    // [19] (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#3 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_3
    sta.z _4
    // [20] if((byte~) menu::$4==(byte) 0) goto menu::@3 -- vbuz1_eq_0_then_la1 
    lda.z _4
    cmp #0
    beq b3_from_b9
    jmp b6
    // menu::@6
  b6:
    // [21] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
    // asm { sei  }
    sei
    jmp breturn
    // [23] phi from menu::@9 to menu::@3 [phi:menu::@9->menu::@3]
  b3_from_b9:
    jmp b3
    // menu::@3
  b3:
    // [24] call keyboard_key_pressed 
    // [31] phi from menu::@3 to keyboard_key_pressed [phi:menu::@3->keyboard_key_pressed]
  keyboard_key_pressed_from_b3:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_E#0 [phi:menu::@3->keyboard_key_pressed#0] -- vbuz1=vbuc1 
    lda #KEY_E
    sta.z keyboard_key_pressed.key
    jsr keyboard_key_pressed
    // [25] (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_4
    jmp b10
    // menu::@10
  b10:
    // [26] (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#4 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_4
    sta.z _7
    // [27] if((byte~) menu::$7==(byte) 0) goto menu::@4 -- vbuz1_eq_0_then_la1 
    lda.z _7
    cmp #0
    beq b4
    jmp b7
    // menu::@7
  b7:
    // [28] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // asm { cli  }
    cli
    jmp breturn
    // menu::@4
  b4:
    // [30] *((const byte*) SCREEN#0) ← ++ *((const byte*) SCREEN#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN
    jmp b1_from_b4
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte zeropage(2) key)
keyboard_key_pressed: {
    .label _2 = $d
    .label colidx = 9
    .label rowidx = $a
    .label return = $e
    .label return_2 = 3
    .label return_3 = 5
    .label return_4 = 7
    .label key = 2
    .label return_10 = $10
    // [32] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z key
    sta.z colidx
    // [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z key
    lsr
    lsr
    lsr
    sta.z rowidx
    // [34] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuz1=vbuz2 
    lda.z rowidx
    sta.z keyboard_matrix_read.rowid
    // [35] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [36] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return
    sta.z keyboard_matrix_read.return_2
    jmp b1
    // keyboard_key_pressed::@1
  b1:
    // [37] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return_2
    sta.z _2
    // [38] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask#0 + (byte) keyboard_key_pressed::colidx#0) -- vbuz1=vbuz2_band_pbuc1_derefidx_vbuz3 
    lda.z _2
    ldy.z colidx
    and keyboard_matrix_col_bitmask,y
    sta.z return
    jmp breturn
    // keyboard_key_pressed::@return
  breturn:
    // [39] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte zeropage($b) rowid)
keyboard_matrix_read: {
    .label return = $f
    .label rowid = $b
    .label return_2 = $c
    // [40] *((const byte*) CIA1_PORT_A#0) ← *((const byte[8]) keyboard_matrix_row_bitmask#0 + (byte) keyboard_matrix_read::rowid#0) -- _deref_pbuc1=pbuc2_derefidx_vbuz1 
    ldy.z rowid
    lda keyboard_matrix_row_bitmask,y
    sta CIA1_PORT_A
    // [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B#0) -- vbuz1=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    sta.z return
    jmp breturn
    // keyboard_matrix_read::@return
  breturn:
    // [42] return 
    rts
}
  // pressed
pressed: {
    .label _1 = $11
    // [43] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [44] phi from pressed pressed::@2 to pressed::@1 [phi:pressed/pressed::@2->pressed::@1]
  b1_from_pressed:
  b1_from_b2:
    jmp b1
    // pressed::@1
  b1:
    // [45] call keyboard_key_pressed 
    // [31] phi from pressed::@1 to keyboard_key_pressed [phi:pressed::@1->keyboard_key_pressed]
  keyboard_key_pressed_from_b1:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_SPACE#0 [phi:pressed::@1->keyboard_key_pressed#0] -- vbuz1=vbuc1 
    lda #KEY_SPACE
    sta.z keyboard_key_pressed.key
    jsr keyboard_key_pressed
    // [46] (byte) keyboard_key_pressed::return#10 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_10
    jmp b2
    // pressed::@2
  b2:
    // [47] (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_10
    sta.z _1
    // [48] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return -- vbuz1_neq_0_then_la1 
    lda.z _1
    cmp #0
    bne breturn
    jmp b1_from_b2
    // pressed::@return
  breturn:
    // [49] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [4] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [21] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 [ ] ( main:2::menu:6 [ ] ) always clobbers reg byte a 
Statement [28] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ ] ( main:2::menu:6 [ ] ) always clobbers reg byte a 
Statement [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( main:2::menu:6::keyboard_key_pressed:9 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::keyboard_key_pressed:17 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::keyboard_key_pressed:24 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ keyboard_key_pressed::colidx#0 ]
Statement [40] *((const byte*) CIA1_PORT_A#0) ← *((const byte[8]) keyboard_matrix_row_bitmask#0 + (byte) keyboard_matrix_read::rowid#0) [ ] ( main:2::menu:6::keyboard_key_pressed:9::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::keyboard_key_pressed:17::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::keyboard_key_pressed:24::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] ) always clobbers reg byte a 
Statement [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B#0) [ keyboard_matrix_read::return#0 ] ( main:2::menu:6::keyboard_key_pressed:9::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::keyboard_key_pressed:17::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::keyboard_key_pressed:24::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] ) always clobbers reg byte a 
Statement [4] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [21] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 [ ] ( main:2::menu:6 [ ] ) always clobbers reg byte a 
Statement [28] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ ] ( main:2::menu:6 [ ] ) always clobbers reg byte a 
Statement [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( main:2::menu:6::keyboard_key_pressed:9 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::keyboard_key_pressed:17 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::keyboard_key_pressed:24 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ) always clobbers reg byte a 
Statement [40] *((const byte*) CIA1_PORT_A#0) ← *((const byte[8]) keyboard_matrix_row_bitmask#0 + (byte) keyboard_matrix_read::rowid#0) [ ] ( main:2::menu:6::keyboard_key_pressed:9::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::keyboard_key_pressed:17::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::keyboard_key_pressed:24::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 ] ) always clobbers reg byte a 
Statement [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B#0) [ keyboard_matrix_read::return#0 ] ( main:2::menu:6::keyboard_key_pressed:9::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::keyboard_key_pressed:17::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::keyboard_key_pressed:24::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] main:2::menu:6::pressed:14::keyboard_key_pressed:45::keyboard_matrix_read:35 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ keyboard_key_pressed::key#4 ] : zp ZP_BYTE:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ keyboard_key_pressed::return#2 ] : zp ZP_BYTE:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ menu::$0 ] : zp ZP_BYTE:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ keyboard_key_pressed::return#3 ] : zp ZP_BYTE:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ menu::$4 ] : zp ZP_BYTE:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ keyboard_key_pressed::return#4 ] : zp ZP_BYTE:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ menu::$7 ] : zp ZP_BYTE:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:9 [ keyboard_key_pressed::colidx#0 ] : zp ZP_BYTE:9 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:10 [ keyboard_key_pressed::rowidx#0 ] : zp ZP_BYTE:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:11 [ keyboard_matrix_read::rowid#0 ] : zp ZP_BYTE:11 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:12 [ keyboard_matrix_read::return#2 ] : zp ZP_BYTE:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ keyboard_key_pressed::$2 ] : zp ZP_BYTE:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:14 [ keyboard_key_pressed::return#0 ] : zp ZP_BYTE:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:15 [ keyboard_matrix_read::return#0 ] : zp ZP_BYTE:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:16 [ keyboard_key_pressed::return#10 ] : zp ZP_BYTE:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:17 [ pressed::$1 ] : zp ZP_BYTE:17 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [keyboard_key_pressed] 202: zp ZP_BYTE:3 [ keyboard_key_pressed::return#2 ] 202: zp ZP_BYTE:5 [ keyboard_key_pressed::return#3 ] 202: zp ZP_BYTE:7 [ keyboard_key_pressed::return#4 ] 202: zp ZP_BYTE:16 [ keyboard_key_pressed::return#10 ] 67.67: zp ZP_BYTE:14 [ keyboard_key_pressed::return#0 ] 4: zp ZP_BYTE:10 [ keyboard_key_pressed::rowidx#0 ] 4: zp ZP_BYTE:13 [ keyboard_key_pressed::$2 ] 2: zp ZP_BYTE:2 [ keyboard_key_pressed::key#4 ] 0.67: zp ZP_BYTE:9 [ keyboard_key_pressed::colidx#0 ] 
Uplift Scope [menu] 202: zp ZP_BYTE:4 [ menu::$0 ] 202: zp ZP_BYTE:6 [ menu::$4 ] 202: zp ZP_BYTE:8 [ menu::$7 ] 
Uplift Scope [pressed] 202: zp ZP_BYTE:17 [ pressed::$1 ] 
Uplift Scope [keyboard_matrix_read] 4: zp ZP_BYTE:11 [ keyboard_matrix_read::rowid#0 ] 4: zp ZP_BYTE:12 [ keyboard_matrix_read::return#2 ] 1.33: zp ZP_BYTE:15 [ keyboard_matrix_read::return#0 ] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [keyboard_key_pressed] best 9851 combination reg byte a [ keyboard_key_pressed::return#2 ] reg byte a [ keyboard_key_pressed::return#3 ] reg byte a [ keyboard_key_pressed::return#4 ] reg byte a [ keyboard_key_pressed::return#10 ] zp ZP_BYTE:14 [ keyboard_key_pressed::return#0 ] zp ZP_BYTE:10 [ keyboard_key_pressed::rowidx#0 ] zp ZP_BYTE:13 [ keyboard_key_pressed::$2 ] zp ZP_BYTE:2 [ keyboard_key_pressed::key#4 ] zp ZP_BYTE:9 [ keyboard_key_pressed::colidx#0 ] 
Limited combination testing to 100 combinations of 196608 possible.
Uplifting [menu] best 8051 combination reg byte a [ menu::$0 ] reg byte a [ menu::$4 ] reg byte a [ menu::$7 ] 
Uplifting [pressed] best 7451 combination reg byte a [ pressed::$1 ] 
Uplifting [keyboard_matrix_read] best 7433 combination reg byte x [ keyboard_matrix_read::rowid#0 ] reg byte a [ keyboard_matrix_read::return#2 ] reg byte a [ keyboard_matrix_read::return#0 ] 
Uplifting [main] best 7433 combination 
Uplifting [] best 7433 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:14 [ keyboard_key_pressed::return#0 ]
Uplifting [keyboard_key_pressed] best 6230 combination reg byte a [ keyboard_key_pressed::return#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:10 [ keyboard_key_pressed::rowidx#0 ]
Uplifting [keyboard_key_pressed] best 6226 combination reg byte a [ keyboard_key_pressed::rowidx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:13 [ keyboard_key_pressed::$2 ]
Uplifting [keyboard_key_pressed] best 6220 combination reg byte a [ keyboard_key_pressed::$2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ keyboard_key_pressed::key#4 ]
Uplifting [keyboard_key_pressed] best 6204 combination reg byte x [ keyboard_key_pressed::key#4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:9 [ keyboard_key_pressed::colidx#0 ]
Uplifting [keyboard_key_pressed] best 6202 combination reg byte y [ keyboard_key_pressed::colidx#0 ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Exploring keyboard glitch that finds "C" press when pressing space
// The glitch is caused by the "normal" C64 interrupt occuring just as the keyboard is read.
// Press "I" to disable interrupts (red border)
// Press "E" to enable interrupts (green border)
// Press "C" to enter pressed state (increaded bgcol) - and "SPACE" to leave presssed state again.
// Holding SPACE will sometimes trigger the pressed state when normal interrupts are enabled (green border)
// but never when they are disabled (red border)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label BORDERCOL = $d020
  .label BGCOL = $d021
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  .const RED = 2
  .const GREEN = 5
  .const KEY_E = $e
  .const KEY_C = $14
  .const KEY_I = $21
  .const KEY_SPACE = $3c
  .label SCREEN = $400
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    // [4] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // [5] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
  b1_from_main:
  b1_from_b1:
    jmp b1
    // main::@1
  b1:
    // [6] call menu 
    // [7] phi from main::@1 to menu [phi:main::@1->menu]
  menu_from_b1:
    jsr menu
    jmp b1_from_b1
}
  // menu
menu: {
    // [8] phi from menu menu::@4 to menu::@1 [phi:menu/menu::@4->menu::@1]
  b1_from_menu:
  b1_from_b4:
    jmp b1
    // menu::@1
  b1:
    // [9] call keyboard_key_pressed 
    // [31] phi from menu::@1 to keyboard_key_pressed [phi:menu::@1->keyboard_key_pressed]
  keyboard_key_pressed_from_b1:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_C#0 [phi:menu::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_C
    jsr keyboard_key_pressed
    // [10] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    jmp b8
    // menu::@8
  b8:
    // [11] (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#2
    // [12] if((byte~) menu::$0==(byte) 0) goto menu::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b2_from_b8
    // [13] phi from menu::@8 to menu::@5 [phi:menu::@8->menu::@5]
  b5_from_b8:
    jmp b5
    // menu::@5
  b5:
    // [14] call pressed 
    jsr pressed
    jmp breturn
    // menu::@return
  breturn:
    // [15] return 
    rts
    // [16] phi from menu::@8 to menu::@2 [phi:menu::@8->menu::@2]
  b2_from_b8:
    jmp b2
    // menu::@2
  b2:
    // [17] call keyboard_key_pressed 
    // [31] phi from menu::@2 to keyboard_key_pressed [phi:menu::@2->keyboard_key_pressed]
  keyboard_key_pressed_from_b2:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_I#0 [phi:menu::@2->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_I
    jsr keyboard_key_pressed
    // [18] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0
    jmp b9
    // menu::@9
  b9:
    // [19] (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#3
    // [20] if((byte~) menu::$4==(byte) 0) goto menu::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b3_from_b9
    jmp b6
    // menu::@6
  b6:
    // [21] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
    // asm { sei  }
    sei
    jmp breturn
    // [23] phi from menu::@9 to menu::@3 [phi:menu::@9->menu::@3]
  b3_from_b9:
    jmp b3
    // menu::@3
  b3:
    // [24] call keyboard_key_pressed 
    // [31] phi from menu::@3 to keyboard_key_pressed [phi:menu::@3->keyboard_key_pressed]
  keyboard_key_pressed_from_b3:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_E#0 [phi:menu::@3->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_E
    jsr keyboard_key_pressed
    // [25] (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#0
    jmp b10
    // menu::@10
  b10:
    // [26] (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#4
    // [27] if((byte~) menu::$7==(byte) 0) goto menu::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b4
    jmp b7
    // menu::@7
  b7:
    // [28] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // asm { cli  }
    cli
    jmp breturn
    // menu::@4
  b4:
    // [30] *((const byte*) SCREEN#0) ← ++ *((const byte*) SCREEN#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN
    jmp b1_from_b4
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(X) key)
keyboard_key_pressed: {
    // [32] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7 -- vbuyy=vbuxx_band_vbuc1 
    txa
    and #7
    tay
    // [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 -- vbuaa=vbuxx_ror_3 
    txa
    lsr
    lsr
    lsr
    // [34] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuxx=vbuaa 
    tax
    // [35] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [36] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    jmp b1
    // keyboard_key_pressed::@1
  b1:
    // [37] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // [38] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask#0 + (byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuyy 
    and keyboard_matrix_col_bitmask,y
    jmp breturn
    // keyboard_key_pressed::@return
  breturn:
    // [39] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(X) rowid)
keyboard_matrix_read: {
    // [40] *((const byte*) CIA1_PORT_A#0) ← *((const byte[8]) keyboard_matrix_row_bitmask#0 + (byte) keyboard_matrix_read::rowid#0) -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda keyboard_matrix_row_bitmask,x
    sta CIA1_PORT_A
    // [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B#0) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    jmp breturn
    // keyboard_matrix_read::@return
  breturn:
    // [42] return 
    rts
}
  // pressed
pressed: {
    // [43] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [44] phi from pressed pressed::@2 to pressed::@1 [phi:pressed/pressed::@2->pressed::@1]
  b1_from_pressed:
  b1_from_b2:
    jmp b1
    // pressed::@1
  b1:
    // [45] call keyboard_key_pressed 
    // [31] phi from pressed::@1 to keyboard_key_pressed [phi:pressed::@1->keyboard_key_pressed]
  keyboard_key_pressed_from_b1:
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_SPACE#0 [phi:pressed::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_SPACE
    jsr keyboard_key_pressed
    // [46] (byte) keyboard_key_pressed::return#10 ← (byte) keyboard_key_pressed::return#0
    jmp b2
    // pressed::@2
  b2:
    // [47] (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10
    // [48] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return -- vbuaa_neq_0_then_la1 
    cmp #0
    bne breturn
    jmp b1_from_b2
    // pressed::@return
  breturn:
    // [49] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b1
Removing instruction jmp b8
Removing instruction jmp b5
Removing instruction jmp breturn
Removing instruction jmp b2
Removing instruction jmp b9
Removing instruction jmp b6
Removing instruction jmp b3
Removing instruction jmp b10
Removing instruction jmp b7
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Succesful ASM optimization Pass5NextJumpElimination
Replacing label b1_from_b1 with b1
Replacing label b2_from_b8 with b2
Replacing label b3_from_b9 with b3
Replacing label b1_from_b4 with b1
Replacing label b1_from_b2 with b1
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_main:
Removing instruction b1_from_b1:
Removing instruction menu_from_b1:
Removing instruction b1_from_menu:
Removing instruction b1_from_b4:
Removing instruction keyboard_key_pressed_from_b1:
Removing instruction b5_from_b8:
Removing instruction b2_from_b8:
Removing instruction keyboard_key_pressed_from_b2:
Removing instruction b3_from_b9:
Removing instruction keyboard_key_pressed_from_b3:
Removing instruction b1_from_pressed:
Removing instruction b1_from_b2:
Removing instruction keyboard_key_pressed_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b8:
Removing instruction b5:
Removing instruction b9:
Removing instruction b6:
Removing instruction b10:
Removing instruction b7:
Removing instruction b1:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Replacing jump to rts with rts in jmp breturn
Replacing jump to rts with rts in jmp breturn
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction bbegin:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) BGCOL
(const byte*) BGCOL#0 BGCOL = (byte*) 53281
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = (byte*) 53280
(byte*) CIA1_PORT_A
(const byte*) CIA1_PORT_A#0 CIA1_PORT_A = (byte*) 56320
(byte*) CIA1_PORT_B
(const byte*) CIA1_PORT_B#0 CIA1_PORT_B = (byte*) 56321
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte) 5
(byte) KEY_C
(const byte) KEY_C#0 KEY_C = (byte) $14
(byte) KEY_E
(const byte) KEY_E#0 KEY_E = (byte) $e
(byte) KEY_I
(const byte) KEY_I#0 KEY_I = (byte) $21
(byte) KEY_SPACE
(const byte) KEY_SPACE#0 KEY_SPACE = (byte) $3c
(byte) RED
(const byte) RED#0 RED = (byte) 2
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = (byte*) 1024
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 reg byte a 4.0
(label) keyboard_key_pressed::@1
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0 reg byte y 0.6666666666666666
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#4 reg byte x 2.0
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 reg byte a 67.66666666666667
(byte) keyboard_key_pressed::return#10 reg byte a 202.0
(byte) keyboard_key_pressed::return#2 reg byte a 202.0
(byte) keyboard_key_pressed::return#3 reg byte a 202.0
(byte) keyboard_key_pressed::return#4 reg byte a 202.0
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0 reg byte a 4.0
(byte[8]) keyboard_matrix_col_bitmask
(const byte[8]) keyboard_matrix_col_bitmask#0 keyboard_matrix_col_bitmask = { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 reg byte a 1.3333333333333333
(byte) keyboard_matrix_read::return#2 reg byte a 4.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0 reg byte x 4.0
(byte[8]) keyboard_matrix_row_bitmask
(const byte[8]) keyboard_matrix_row_bitmask#0 keyboard_matrix_row_bitmask = { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
(void()) main()
(label) main::@1
(void()) menu()
(byte~) menu::$0 reg byte a 202.0
(byte~) menu::$4 reg byte a 202.0
(byte~) menu::$7 reg byte a 202.0
(label) menu::@1
(label) menu::@10
(label) menu::@2
(label) menu::@3
(label) menu::@4
(label) menu::@5
(label) menu::@6
(label) menu::@7
(label) menu::@8
(label) menu::@9
(label) menu::@return
(void()) pressed()
(byte~) pressed::$1 reg byte a 202.0
(label) pressed::@1
(label) pressed::@2
(label) pressed::@return

reg byte x [ keyboard_key_pressed::key#4 ]
reg byte a [ keyboard_key_pressed::return#2 ]
reg byte a [ menu::$0 ]
reg byte a [ keyboard_key_pressed::return#3 ]
reg byte a [ menu::$4 ]
reg byte a [ keyboard_key_pressed::return#4 ]
reg byte a [ menu::$7 ]
reg byte y [ keyboard_key_pressed::colidx#0 ]
reg byte a [ keyboard_key_pressed::rowidx#0 ]
reg byte x [ keyboard_matrix_read::rowid#0 ]
reg byte a [ keyboard_matrix_read::return#2 ]
reg byte a [ keyboard_key_pressed::$2 ]
reg byte a [ keyboard_key_pressed::return#0 ]
reg byte a [ keyboard_matrix_read::return#0 ]
reg byte a [ keyboard_key_pressed::return#10 ]
reg byte a [ pressed::$1 ]


FINAL ASSEMBLER
Score: 3151

  // File Comments
// Exploring keyboard glitch that finds "C" press when pressing space
// The glitch is caused by the "normal" C64 interrupt occuring just as the keyboard is read.
// Press "I" to disable interrupts (red border)
// Press "E" to enable interrupts (green border)
// Press "C" to enter pressed state (increaded bgcol) - and "SPACE" to leave presssed state again.
// Holding SPACE will sometimes trigger the pressed state when normal interrupts are enabled (green border)
// but never when they are disabled (red border)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label BORDERCOL = $d020
  .label BGCOL = $d021
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  .const RED = 2
  .const GREEN = 5
  .const KEY_E = $e
  .const KEY_C = $14
  .const KEY_I = $21
  .const KEY_SPACE = $3c
  .label SCREEN = $400
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // *BORDERCOL = GREEN
    // [4] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // [5] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
    // main::@1
  b1:
    // menu()
    // [6] call menu 
    // [7] phi from main::@1 to menu [phi:main::@1->menu]
    jsr menu
    jmp b1
}
  // menu
menu: {
    // [8] phi from menu menu::@4 to menu::@1 [phi:menu/menu::@4->menu::@1]
    // menu::@1
  b1:
    // keyboard_key_pressed(KEY_C)
    // [9] call keyboard_key_pressed 
    // [31] phi from menu::@1 to keyboard_key_pressed [phi:menu::@1->keyboard_key_pressed]
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_C#0 [phi:menu::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_C
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_C)
    // [10] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    // menu::@8
    // [11] (byte~) menu::$0 ← (byte) keyboard_key_pressed::return#2
    // if(keyboard_key_pressed(KEY_C)!=0)
    // [12] if((byte~) menu::$0==(byte) 0) goto menu::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b2
    // [13] phi from menu::@8 to menu::@5 [phi:menu::@8->menu::@5]
    // menu::@5
    // pressed()
    // [14] call pressed 
    jsr pressed
    // menu::@return
    // }
    // [15] return 
    rts
    // [16] phi from menu::@8 to menu::@2 [phi:menu::@8->menu::@2]
    // menu::@2
  b2:
    // keyboard_key_pressed(KEY_I)
    // [17] call keyboard_key_pressed 
    // [31] phi from menu::@2 to keyboard_key_pressed [phi:menu::@2->keyboard_key_pressed]
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_I#0 [phi:menu::@2->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_I
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_I)
    // [18] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0
    // menu::@9
    // [19] (byte~) menu::$4 ← (byte) keyboard_key_pressed::return#3
    // if(keyboard_key_pressed(KEY_I)!=0)
    // [20] if((byte~) menu::$4==(byte) 0) goto menu::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b3
    // menu::@6
    // *BORDERCOL = RED
    // [21] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
    // asm
    // asm { sei  }
    sei
    rts
    // [23] phi from menu::@9 to menu::@3 [phi:menu::@9->menu::@3]
    // menu::@3
  b3:
    // keyboard_key_pressed(KEY_E)
    // [24] call keyboard_key_pressed 
    // [31] phi from menu::@3 to keyboard_key_pressed [phi:menu::@3->keyboard_key_pressed]
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_E#0 [phi:menu::@3->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_E
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_E)
    // [25] (byte) keyboard_key_pressed::return#4 ← (byte) keyboard_key_pressed::return#0
    // menu::@10
    // [26] (byte~) menu::$7 ← (byte) keyboard_key_pressed::return#4
    // if(keyboard_key_pressed(KEY_E)!=0)
    // [27] if((byte~) menu::$7==(byte) 0) goto menu::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b4
    // menu::@7
    // *BORDERCOL = GREEN
    // [28] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // asm
    // asm { cli  }
    cli
    rts
    // menu::@4
  b4:
    // (*SCREEN)++;
    // [30] *((const byte*) SCREEN#0) ← ++ *((const byte*) SCREEN#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN
    jmp b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(X) key)
keyboard_key_pressed: {
    // colidx = key&7
    // [32] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#4 & (byte) 7 -- vbuyy=vbuxx_band_vbuc1 
    txa
    and #7
    tay
    // rowidx = key>>3
    // [33] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#4 >> (byte) 3 -- vbuaa=vbuxx_ror_3 
    txa
    lsr
    lsr
    lsr
    // keyboard_matrix_read(rowidx)
    // [34] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuxx=vbuaa 
    tax
    // [35] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [36] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    // keyboard_key_pressed::@1
    // [37] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // keyboard_matrix_read(rowidx) & keyboard_matrix_col_bitmask[colidx]
    // [38] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte[8]) keyboard_matrix_col_bitmask#0 + (byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuyy 
    and keyboard_matrix_col_bitmask,y
    // keyboard_key_pressed::@return
    // }
    // [39] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(X) rowid)
keyboard_matrix_read: {
    // *CIA1_PORT_A = keyboard_matrix_row_bitmask[rowid]
    // [40] *((const byte*) CIA1_PORT_A#0) ← *((const byte[8]) keyboard_matrix_row_bitmask#0 + (byte) keyboard_matrix_read::rowid#0) -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda keyboard_matrix_row_bitmask,x
    sta CIA1_PORT_A
    // ~*CIA1_PORT_B
    // [41] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B#0) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    // keyboard_matrix_read::@return
    // }
    // [42] return 
    rts
}
  // pressed
pressed: {
    // (*BGCOL)++;
    // [43] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [44] phi from pressed pressed::@2 to pressed::@1 [phi:pressed/pressed::@2->pressed::@1]
    // pressed::@1
  b1:
    // keyboard_key_pressed(KEY_SPACE)
    // [45] call keyboard_key_pressed 
    // [31] phi from pressed::@1 to keyboard_key_pressed [phi:pressed::@1->keyboard_key_pressed]
    // [31] phi (byte) keyboard_key_pressed::key#4 = (const byte) KEY_SPACE#0 [phi:pressed::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_SPACE
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_SPACE)
    // [46] (byte) keyboard_key_pressed::return#10 ← (byte) keyboard_key_pressed::return#0
    // pressed::@2
    // [47] (byte~) pressed::$1 ← (byte) keyboard_key_pressed::return#10
    // if(keyboard_key_pressed(KEY_SPACE)!=0)
    // [48] if((byte~) pressed::$1!=(byte) 0) goto pressed::@return -- vbuaa_neq_0_then_la1 
    cmp #0
    bne breturn
    jmp b1
    // pressed::@return
  breturn:
    // }
    // [49] return 
    rts
}
  // File Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

