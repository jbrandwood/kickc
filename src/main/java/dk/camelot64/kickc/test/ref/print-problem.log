
byte line = $40;
byte char = line;

void main() {
    ln();
    char++;
    ln();
    char++;
    ln();
}

void ln() {
    line = line + $2;
    char = line;
}






Adding pre/post-modifier (byte) char ← ++ (byte) char
Adding pre/post-modifier (byte) char ← ++ (byte) char
PROGRAM
  (byte) line ← (byte/signed byte/word/signed word) 64
  (byte) char ← (byte) line
proc (void()) main()
  (void~) main::$0 ← call ln 
  (byte) char ← ++ (byte) char
  (void~) main::$1 ← call ln 
  (byte) char ← ++ (byte) char
  (void~) main::$2 ← call ln 
main::@return:
  return 
endproc // main()
proc (void()) ln()
  (byte~) ln::$0 ← (byte) line + (byte/signed byte/word/signed word) 2
  (byte) line ← (byte~) ln::$0
  (byte) char ← (byte) line
ln::@return:
  return 
endproc // ln()
  call main 

SYMBOLS
(byte) char
(byte) line
(void()) ln()
(byte~) ln::$0
(label) ln::@return
(void()) main()
(void~) main::$0
(void~) main::$1
(void~) main::$2
(label) main::@return

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) line ← (byte/signed byte/word/signed word) 64
  (byte) char ← (byte) line
  to:@1
main: scope:[main]  from
  (void~) main::$0 ← call ln 
  (byte) char ← ++ (byte) char
  (void~) main::$1 ← call ln 
  (byte) char ← ++ (byte) char
  (void~) main::$2 ← call ln 
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
@1: scope:[]  from @begin
  to:@2
ln: scope:[ln]  from
  (byte~) ln::$0 ← (byte) line + (byte/signed byte/word/signed word) 2
  (byte) line ← (byte~) ln::$0
  (byte) char ← (byte) line
  to:ln::@return
ln::@return: scope:[ln]  from ln
  return 
  to:@return
@2: scope:[]  from @1
  call main 
  to:@end
@end: scope:[]  from @2

Eliminating unused variable - keeping the call (void~) main::$0
Eliminating unused variable - keeping the call (void~) main::$1
Eliminating unused variable - keeping the call (void~) main::$2
Removing empty block @1
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) line ← (byte/signed byte/word/signed word) 64
  (byte) char ← (byte) line
  to:@2
main: scope:[main]  from
  call ln 
  (byte) char ← ++ (byte) char
  call ln 
  (byte) char ← ++ (byte) char
  call ln 
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
ln: scope:[ln]  from
  (byte~) ln::$0 ← (byte) line + (byte/signed byte/word/signed word) 2
  (byte) line ← (byte~) ln::$0
  (byte) char ← (byte) line
  to:ln::@return
ln::@return: scope:[ln]  from ln
  return 
  to:@return
@2: scope:[]  from @begin
  call main 
  to:@end
@end: scope:[]  from @2

PROCEDURE MODIFY VARIABLE ANALYSIS
main modifies line
main modifies char
ln modifies line
ln modifies char

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  (byte) line ← (byte/signed byte/word/signed word) 64
  (byte) char ← (byte) line
  to:@2
main: scope:[main]  from @2
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) line ← (byte) line
  (byte) char ← (byte) char
  (byte) char ← ++ (byte) char
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) line ← (byte) line
  (byte) char ← (byte) char
  (byte) char ← ++ (byte) char
  call ln param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte) line ← (byte) line
  (byte) char ← (byte) char
  to:main::@return
main::@return: scope:[main]  from main::@3
  (byte) line ← (byte) line
  (byte) char ← (byte) char
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte~) ln::$0 ← (byte) line + (byte/signed byte/word/signed word) 2
  (byte) line ← (byte~) ln::$0
  (byte) char ← (byte) line
  to:ln::@return
ln::@return: scope:[ln]  from ln
  (byte) line ← (byte) line
  (byte) char ← (byte) char
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) line ← (byte) line
  (byte) char ← (byte) char
  to:@end
@end: scope:[]  from @3

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) line#0 ← (byte/signed byte/word/signed word) 64
  (byte) char#0 ← (byte) line#0
  to:@2
main: scope:[main]  from @2
  (byte) char#16 ← phi( @2/(byte) char#17 )
  (byte) line#15 ← phi( @2/(byte) line#16 )
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) char#10 ← phi( main/(byte) char#16 )
  (byte) line#8 ← phi( main/(byte) line#15 )
  (byte) line#1 ← (byte) line#8
  (byte) char#1 ← (byte) char#10
  (byte) char#2 ← ++ (byte) char#1
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) char#11 ← phi( main::@1/(byte) char#2 )
  (byte) line#9 ← phi( main::@1/(byte) line#1 )
  (byte) line#2 ← (byte) line#9
  (byte) char#3 ← (byte) char#11
  (byte) char#4 ← ++ (byte) char#3
  call ln param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte) char#12 ← phi( main::@2/(byte) char#4 )
  (byte) line#10 ← phi( main::@2/(byte) line#2 )
  (byte) line#3 ← (byte) line#10
  (byte) char#5 ← (byte) char#12
  to:main::@return
main::@return: scope:[main]  from main::@3
  (byte) char#13 ← phi( main::@3/(byte) char#5 )
  (byte) line#11 ← phi( main::@3/(byte) line#3 )
  (byte) line#4 ← (byte) line#11
  (byte) char#6 ← (byte) char#13
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte) line#12 ← phi( main/(byte) line#15 main::@1/(byte) line#1 main::@2/(byte) line#2 )
  (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2
  (byte) line#5 ← (byte~) ln::$0
  (byte) char#7 ← (byte) line#5
  to:ln::@return
ln::@return: scope:[ln]  from ln
  (byte) char#14 ← phi( ln/(byte) char#7 )
  (byte) line#13 ← phi( ln/(byte) line#5 )
  (byte) line#6 ← (byte) line#13
  (byte) char#8 ← (byte) char#14
  return 
  to:@return
@2: scope:[]  from @begin
  (byte) char#17 ← phi( @begin/(byte) char#0 )
  (byte) line#16 ← phi( @begin/(byte) line#0 )
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) char#15 ← phi( @2/(byte) char#17 )
  (byte) line#14 ← phi( @2/(byte) line#16 )
  (byte) line#7 ← (byte) line#14
  (byte) char#9 ← (byte) char#15
  to:@end
@end: scope:[]  from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (byte) line#0 ← (byte/signed byte/word/signed word) 64
  (byte) char#0 ← (byte) line#0
  to:@2
main: scope:[main]  from @2
  (byte) char#16 ← phi( @2/(byte) char#17 )
  (byte) line#15 ← phi( @2/(byte) line#16 )
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) char#10 ← phi( main/(byte) char#8 )
  (byte) line#8 ← phi( main/(byte) line#6 )
  (byte) line#1 ← (byte) line#8
  (byte) char#1 ← (byte) char#10
  (byte) char#2 ← ++ (byte) char#1
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) char#11 ← phi( main::@1/(byte) char#8 )
  (byte) line#9 ← phi( main::@1/(byte) line#6 )
  (byte) line#2 ← (byte) line#9
  (byte) char#3 ← (byte) char#11
  (byte) char#4 ← ++ (byte) char#3
  call ln param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte) char#12 ← phi( main::@2/(byte) char#8 )
  (byte) line#10 ← phi( main::@2/(byte) line#6 )
  (byte) line#3 ← (byte) line#10
  (byte) char#5 ← (byte) char#12
  to:main::@return
main::@return: scope:[main]  from main::@3
  (byte) char#13 ← phi( main::@3/(byte) char#5 )
  (byte) line#11 ← phi( main::@3/(byte) line#3 )
  (byte) line#4 ← (byte) line#11
  (byte) char#6 ← (byte) char#13
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte) line#12 ← phi( main/(byte) line#15 main::@1/(byte) line#1 main::@2/(byte) line#2 )
  (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2
  (byte) line#5 ← (byte~) ln::$0
  (byte) char#7 ← (byte) line#5
  to:ln::@return
ln::@return: scope:[ln]  from ln
  (byte) char#14 ← phi( ln/(byte) char#7 )
  (byte) line#13 ← phi( ln/(byte) line#5 )
  (byte) line#6 ← (byte) line#13
  (byte) char#8 ← (byte) char#14
  return 
  to:@return
@2: scope:[]  from @begin
  (byte) char#17 ← phi( @begin/(byte) char#0 )
  (byte) line#16 ← phi( @begin/(byte) line#0 )
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) char#15 ← phi( @2/(byte) char#6 )
  (byte) line#14 ← phi( @2/(byte) line#4 )
  (byte) line#7 ← (byte) line#14
  (byte) char#9 ← (byte) char#15
  to:@end
@end: scope:[]  from @3

INITIAL SSA SYMBOL TABLE
(label) @2
(label) @3
(label) @begin
(label) @end
(byte) char
(byte) char#0
(byte) char#1
(byte) char#10
(byte) char#11
(byte) char#12
(byte) char#13
(byte) char#14
(byte) char#15
(byte) char#16
(byte) char#17
(byte) char#2
(byte) char#3
(byte) char#4
(byte) char#5
(byte) char#6
(byte) char#7
(byte) char#8
(byte) char#9
(byte) line
(byte) line#0
(byte) line#1
(byte) line#10
(byte) line#11
(byte) line#12
(byte) line#13
(byte) line#14
(byte) line#15
(byte) line#16
(byte) line#2
(byte) line#3
(byte) line#4
(byte) line#5
(byte) line#6
(byte) line#7
(byte) line#8
(byte) line#9
(void()) ln()
(byte~) ln::$0
(label) ln::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return

Not aliassing across scopes: line#15 line#16
Not aliassing across scopes: char#16 char#17
Not aliassing across scopes: line#8 line#6
Not aliassing across scopes: char#10 char#8
Not aliassing across scopes: line#9 line#6
Not aliassing across scopes: char#11 char#8
Not aliassing across scopes: line#10 line#6
Not aliassing across scopes: char#12 char#8
Not aliassing across scopes: line#12 line#15
Not aliassing across scopes: line#5 ln::$0
Not aliassing across scopes: line#14 line#4
Not aliassing across scopes: char#15 char#6
Alias candidate removed (byte) char#0
Alias candidate removed (byte) char#7
Alias (byte) char#17 = (byte) line#0 (byte) line#16 
Alias (byte) line#1 = (byte) line#8 
Alias (byte) char#1 = (byte) char#10 
Alias (byte) line#2 = (byte) line#9 
Alias (byte) char#11 = (byte) char#3 
Alias (byte) line#10 = (byte) line#3 (byte) line#11 (byte) line#4 
Alias (byte) char#12 = (byte) char#5 (byte) char#13 (byte) char#6 
Alias (byte) char#14 = (byte) line#5 (byte) line#13 (byte) line#6 (byte) char#8 
Alias (byte) line#14 = (byte) line#7 
Alias (byte) char#15 = (byte) char#9 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) char#17 ← (byte/signed byte/word/signed word) 64
  (byte) char#0 ← (byte) char#17
  to:@2
main: scope:[main]  from @2
  (byte) char#16 ← phi( @2/(byte) char#17 )
  (byte) line#15 ← phi( @2/(byte) char#17 )
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) char#1 ← phi( main/(byte) char#14 )
  (byte) line#1 ← phi( main/(byte) char#14 )
  (byte) char#2 ← ++ (byte) char#1
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) char#11 ← phi( main::@1/(byte) char#14 )
  (byte) line#2 ← phi( main::@1/(byte) char#14 )
  (byte) char#4 ← ++ (byte) char#11
  call ln param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte) char#12 ← phi( main::@2/(byte) char#14 )
  (byte) line#10 ← phi( main::@2/(byte) char#14 )
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte) line#12 ← phi( main/(byte) line#15 main::@1/(byte) line#1 main::@2/(byte) line#2 )
  (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2
  (byte) char#14 ← (byte~) ln::$0
  (byte) char#7 ← (byte) char#14
  to:ln::@return
ln::@return: scope:[ln]  from ln
  (byte) char#14 ← phi( ln/(byte) char#7 )
  return 
  to:@return
@2: scope:[]  from @begin
  (byte) char#17 ← phi( @begin/(byte) char#0 )
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) char#15 ← phi( @2/(byte) char#12 )
  (byte) line#14 ← phi( @2/(byte) line#10 )
  to:@end
@end: scope:[]  from @3

Not aliassing across scopes: line#15 char#17
Not aliassing across scopes: char#16 char#17
Not aliassing across scopes: line#1 char#14
Not aliassing across scopes: char#1 char#14
Not aliassing across scopes: line#2 char#14
Not aliassing across scopes: char#11 char#14
Not aliassing across scopes: line#10 char#14
Not aliassing across scopes: char#12 char#14
Not aliassing across scopes: line#12 line#15
Not aliassing across scopes: char#14 ln::$0
Not aliassing across scopes: line#14 line#10
Not aliassing across scopes: char#15 char#12
Alias (byte) char#0 = (byte) char#17 
Alias (byte) char#14 = (byte) char#7 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) char#0 ← (byte/signed byte/word/signed word) 64
  to:@2
main: scope:[main]  from @2
  (byte) char#16 ← phi( @2/(byte) char#0 )
  (byte) line#15 ← phi( @2/(byte) char#0 )
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) char#1 ← phi( main/(byte) char#14 )
  (byte) line#1 ← phi( main/(byte) char#14 )
  (byte) char#2 ← ++ (byte) char#1
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) char#11 ← phi( main::@1/(byte) char#14 )
  (byte) line#2 ← phi( main::@1/(byte) char#14 )
  (byte) char#4 ← ++ (byte) char#11
  call ln param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte) char#12 ← phi( main::@2/(byte) char#14 )
  (byte) line#10 ← phi( main::@2/(byte) char#14 )
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte) line#12 ← phi( main/(byte) line#15 main::@1/(byte) line#1 main::@2/(byte) line#2 )
  (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2
  (byte) char#14 ← (byte~) ln::$0
  to:ln::@return
ln::@return: scope:[ln]  from ln
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) char#15 ← phi( @2/(byte) char#12 )
  (byte) line#14 ← phi( @2/(byte) line#10 )
  to:@end
@end: scope:[]  from @3

Not aliassing across scopes: line#15 char#0
Not aliassing across scopes: char#16 char#0
Not aliassing across scopes: line#1 char#14
Not aliassing across scopes: char#1 char#14
Not aliassing across scopes: line#2 char#14
Not aliassing across scopes: char#11 char#14
Not aliassing across scopes: line#10 char#14
Not aliassing across scopes: char#12 char#14
Not aliassing across scopes: line#12 line#15
Not aliassing across scopes: char#14 ln::$0
Not aliassing across scopes: line#14 line#10
Not aliassing across scopes: char#15 char#12
Redundant Phi (byte) line#15 (byte) char#0
Redundant Phi (byte) char#16 (byte) char#0
Redundant Phi (byte) line#1 (byte) char#14
Redundant Phi (byte) char#1 (byte) char#14
Redundant Phi (byte) line#2 (byte) char#14
Redundant Phi (byte) char#11 (byte) char#14
Redundant Phi (byte) line#10 (byte) char#14
Redundant Phi (byte) char#12 (byte) char#14
Redundant Phi (byte) line#14 (byte) line#10
Redundant Phi (byte) char#15 (byte) char#12
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) char#0 ← (byte/signed byte/word/signed word) 64
  to:@2
main: scope:[main]  from @2
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) char#2 ← ++ (byte) char#14
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) char#4 ← ++ (byte) char#14
  call ln param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte) line#12 ← phi( main/(byte) char#0 main::@1/(byte) char#14 main::@2/(byte) char#14 )
  (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2
  (byte) char#14 ← (byte~) ln::$0
  to:ln::@return
ln::@return: scope:[ln]  from ln
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Constant (const byte) char#0 = 64
Succesful SSA optimization Pass2ConstantIdentification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) char#2 ← ++ (byte) char#14
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) char#4 ← ++ (byte) char#14
  call ln param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte) line#12 ← phi( main/(const byte) char#0 main::@1/(byte) char#14 main::@2/(byte) char#14 )
  (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2
  (byte) char#14 ← (byte~) ln::$0
  to:ln::@return
ln::@return: scope:[ln]  from ln
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Culled Empty Block (label) main::@3
Culled Empty Block (label) @3
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) char#2 ← ++ (byte) char#14
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) char#4 ← ++ (byte) char#14
  call ln param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte) line#12 ← phi( main/(const byte) char#0 main::@1/(byte) char#14 main::@2/(byte) char#14 )
  (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2
  (byte) char#14 ← (byte~) ln::$0
  to:ln::@return
ln::@return: scope:[ln]  from ln
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @2

Not aliassing across scopes: char#14 ln::$0
Not aliassing across scopes: char#14 ln::$0
Inlining constant with var siblings (const byte) char#0
Inlining constant with var siblings (const byte) char#0
Inlining constant with var siblings (const byte) char#0
Constant inlined char#0 = (byte/signed byte/word/signed word) 64
Succesful SSA optimization Pass2ConstantInlining
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) char#2 ← ++ (byte) char#14
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) char#4 ← ++ (byte) char#14
  call ln param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte) line#12 ← phi( main/(byte/signed byte/word/signed word) 64 main::@1/(byte) char#14 main::@2/(byte) char#14 )
  (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2
  (byte) char#14 ← (byte~) ln::$0
  to:ln::@return
ln::@return: scope:[ln]  from ln
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @2

FINAL SYMBOL TABLE
(label) @2
(label) @begin
(label) @end
(byte) char
(byte) char#14
(byte) char#2
(byte) char#4
(byte) line
(byte) line#12
(void()) ln()
(byte~) ln::$0
(label) ln::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return

Block Sequence Planned @begin @2 @end main main::@1 main::@2 main::@return ln ln::@return 
Block Sequence Planned @begin @2 @end main main::@1 main::@2 main::@return ln ln::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  to:@2
@2: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @2
main: scope:[main]  from @2
  call ln param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) char#2 ← ++ (byte) char#14
  (byte~) char#18 ← (byte) char#14
  call ln param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) char#4 ← ++ (byte) char#14
  (byte~) char#19 ← (byte) char#14
  call ln param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  (byte) line#12 ← phi( main/(byte/signed byte/word/signed word) 64 main::@1/(byte~) char#18 main::@2/(byte~) char#19 )
  (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2
  (byte) char#14 ← (byte~) ln::$0
  to:ln::@return
ln::@return: scope:[ln]  from ln
  return 
  to:@return

Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to ln:5 ln:8 ln:11 

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES FOUND
@begin: scope:[]  from
  [0] phi() [ ]
  to:@2
@2: scope:[]  from @begin
  [1] phi() [ ]
  [2] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @2
  [3] phi() [ ]
main: scope:[main]  from @2
  [4] phi() [ ]
  [5] call ln param-assignment [ char#14 ]
  to:main::@1
main::@1: scope:[main]  from main
  [6] (byte) char#2 ← ++ (byte) char#14 [ char#14 ]
  [7] (byte~) char#18 ← (byte) char#14 [ char#18 ]
  [8] call ln param-assignment [ char#14 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [9] (byte) char#4 ← ++ (byte) char#14 [ char#14 ]
  [10] (byte~) char#19 ← (byte) char#14 [ char#19 ]
  [11] call ln param-assignment [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [12] return  [ ]
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  [13] (byte) line#12 ← phi( main/(byte/signed byte/word/signed word) 64 main::@1/(byte~) char#18 main::@2/(byte~) char#19 ) [ line#12 ]
  [14] (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2 [ ln::$0 ]
  [15] (byte) char#14 ← (byte~) ln::$0 [ char#14 ]
  to:ln::@return
ln::@return: scope:[ln]  from ln
  [16] return  [ char#14 ]
  to:@return

Created 1 initial phi equivalence classes
Coalesced [7] char#18 ← char#14
Coalesced (already) [10] char#19 ← char#14
Coalesced [15] char#14 ← ln::$0
Coalesced down to 1 phi equivalence classes
Block Sequence Planned @begin @2 @end main main::@1 main::@2 main::@return ln ln::@return 
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - BEFORE EFFECTIVE LIVE RANGES
@begin: scope:[]  from
  [0] phi() [ ]
  to:@2
@2: scope:[]  from @begin
  [1] phi() [ ]
  [2] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @2
  [3] phi() [ ]
main: scope:[main]  from @2
  [4] phi() [ ]
  [5] call ln param-assignment [ ln::$0 ]
  to:main::@1
main::@1: scope:[main]  from main
  [6] (byte) char#2 ← ++ (byte~) ln::$0 [ ln::$0 ]
  [7] call ln param-assignment [ ln::$0 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] (byte) char#4 ← ++ (byte~) ln::$0 [ ln::$0 ]
  [9] call ln param-assignment [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [10] return  [ ]
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  [11] (byte) line#12 ← phi( main/(byte/signed byte/word/signed word) 64 main::@1/(byte~) ln::$0 main::@2/(byte~) ln::$0 ) [ line#12 ]
  [12] (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2 [ ln::$0 ]
  to:ln::@return
ln::@return: scope:[ln]  from ln
  [13] return  [ ln::$0 ]
  to:@return

CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  [0] phi() [ ] ( )
  to:@2
@2: scope:[]  from @begin
  [1] phi() [ ] ( )
  [2] call main param-assignment [ ] ( )
  to:@end
@end: scope:[]  from @2
  [3] phi() [ ] ( )
main: scope:[main]  from @2
  [4] phi() [ ] ( main:2 [ ] )
  [5] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  to:main::@1
main::@1: scope:[main]  from main
  [6] (byte) char#2 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] )
  [7] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] (byte) char#4 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] )
  [9] call ln param-assignment [ ] ( main:2 [ ] )
  to:main::@return
main::@return: scope:[main]  from main::@2
  [10] return  [ ] ( main:2 [ ] )
  to:@return
ln: scope:[ln]  from main main::@1 main::@2
  [11] (byte) line#12 ← phi( main/(byte/signed byte/word/signed word) 64 main::@1/(byte~) ln::$0 main::@2/(byte~) ln::$0 ) [ line#12 ] ( main:2::ln:5 [ line#12 ] main:2::ln:7 [ line#12 ] main:2::ln:9 [ line#12 ] )
  [12] (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2 [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] )
  to:ln::@return
ln::@return: scope:[ln]  from ln
  [13] return  [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] )
  to:@return

DOMINATORS
@begin dominated by  @begin 
@2 dominated by  @2 @begin 
@end dominated by  @2 @begin @end 
main dominated by  @2 @begin main 
main::@1 dominated by  @2 @begin main::@1 main 
main::@2 dominated by  @2 @begin main::@1 main::@2 main 
main::@return dominated by  main::@return @2 @begin main::@1 main::@2 main 
ln dominated by  @2 ln @begin main 
ln::@return dominated by  @2 ln ln::@return @begin main 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [main]
Found 0 loops in scope [ln]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(byte) char
(byte) char#2 20.0
(byte) char#4 20.0
(byte) line
(byte) line#12 6.0
(void()) ln()
(byte~) ln::$0 1.6666666666666665
(void()) main()

Initial phi equivalence classes
[ line#12 ln::$0 ]
Added variable char#2 to zero page equivalence class [ char#2 ]
Added variable char#4 to zero page equivalence class [ char#4 ]
Complete equivalence classes
[ line#12 ln::$0 ]
[ char#2 ]
[ char#4 ]
Allocated zp ZP_BYTE:2 [ line#12 ln::$0 ]
Allocated zp ZP_BYTE:3 [ char#2 ]
Allocated zp ZP_BYTE:4 [ char#4 ]
INITIAL ASM
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label char = 3
  .label char_4 = 4
  .label line = 2
//SEG2 @begin
bbegin:
//SEG3 [1] phi from @begin to @2 [phi:@begin->@2]
b2_from_bbegin:
  jmp b2
//SEG4 @2
b2:
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @2 to main [phi:@2->main]
main_from_b2:
  jsr main
//SEG7 [3] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
  //SEG10 [5] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG11 [11] phi from main to ln [phi:main->ln]
  ln_from_main:
  //SEG12 [11] phi (byte) line#12 = (byte/signed byte/word/signed word) 64 [phi:main->ln#0] -- zpby1=coby1 
    lda #$40
    sta line
    jsr ln
    jmp b1
  //SEG13 main::@1
  b1:
  //SEG14 [6] (byte) char#2 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_zpby2 
    lda ln._0
    sta char
    inc char
  //SEG15 [7] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG16 [11] phi from main::@1 to ln [phi:main::@1->ln]
  ln_from_b1:
  //SEG17 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@1->ln#0] -- register_copy 
    jsr ln
    jmp b2
  //SEG18 main::@2
  b2:
  //SEG19 [8] (byte) char#4 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_zpby2 
    lda ln._0
    sta char_4
    inc char_4
  //SEG20 [9] call ln param-assignment [ ] ( main:2 [ ] )
  //SEG21 [11] phi from main::@2 to ln [phi:main::@2->ln]
  ln_from_b2:
  //SEG22 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@2->ln#0] -- register_copy 
    jsr ln
    jmp breturn
  //SEG23 main::@return
  breturn:
  //SEG24 [10] return  [ ] ( main:2 [ ] )
    rts
}
//SEG25 ln
ln: {
    .label _0 = 2
  //SEG26 [12] (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2 [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] ) -- zpby1=zpby1_plus_coby1 
    lda _0
    clc
    adc #2
    sta _0
    jmp breturn
  //SEG27 ln::@return
  breturn:
  //SEG28 [13] return  [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] )
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [12] (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2 [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ line#12 ln::$0 ] : zp ZP_BYTE:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ char#2 ] : zp ZP_BYTE:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ char#4 ] : zp ZP_BYTE:4 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 20: zp ZP_BYTE:3 [ char#2 ] 20: zp ZP_BYTE:4 [ char#4 ] 7.67: zp ZP_BYTE:2 [ line#12 ln::$0 ] 
Uplift Scope [main] 
Uplift Scope [ln] 

Uplifting [] best 76 combination zp ZP_BYTE:3 [ char#2 ] zp ZP_BYTE:4 [ char#4 ] reg byte a [ line#12 ln::$0 ] 
Uplifting [main] best 76 combination 
Uplifting [ln] best 76 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ char#2 ]
Uplifting [] best 76 combination zp ZP_BYTE:3 [ char#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:4 [ char#4 ]
Uplifting [] best 76 combination zp ZP_BYTE:4 [ char#4 ] 
Coalescing zero page register [ zp ZP_BYTE:3 [ char#2 ] ] with [ zp ZP_BYTE:4 [ char#4 ] ]
Allocated (was zp ZP_BYTE:3) zp ZP_BYTE:2 [ char#2 char#4 ]
Removing instruction jmp b2
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label char = 2
//SEG2 @begin
bbegin:
//SEG3 [1] phi from @begin to @2 [phi:@begin->@2]
b2_from_bbegin:
//SEG4 @2
b2:
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @2 to main [phi:@2->main]
main_from_b2:
  jsr main
//SEG7 [3] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
//SEG8 @end
bend:
//SEG9 main
main: {
  //SEG10 [5] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG11 [11] phi from main to ln [phi:main->ln]
  ln_from_main:
  //SEG12 [11] phi (byte) line#12 = (byte/signed byte/word/signed word) 64 [phi:main->ln#0] -- aby=coby1 
    lda #$40
    jsr ln
  //SEG13 main::@1
  b1:
  //SEG14 [6] (byte) char#2 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_aby 
    sta char
    inc char
  //SEG15 [7] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG16 [11] phi from main::@1 to ln [phi:main::@1->ln]
  ln_from_b1:
  //SEG17 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@1->ln#0] -- register_copy 
    jsr ln
  //SEG18 main::@2
  b2:
  //SEG19 [8] (byte) char#4 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_aby 
    sta char
    inc char
  //SEG20 [9] call ln param-assignment [ ] ( main:2 [ ] )
  //SEG21 [11] phi from main::@2 to ln [phi:main::@2->ln]
  ln_from_b2:
  //SEG22 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@2->ln#0] -- register_copy 
    jsr ln
  //SEG23 main::@return
  breturn:
  //SEG24 [10] return  [ ] ( main:2 [ ] )
    rts
}
//SEG25 ln
ln: {
  //SEG26 [12] (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2 [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] ) -- aby=aby_plus_coby1 
    clc
    adc #2
  //SEG27 ln::@return
  breturn:
  //SEG28 [13] return  [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] )
    rts
}

Removing instruction bbegin:
Removing instruction b2_from_bbegin:
Removing instruction main_from_b2:
Removing instruction bend_from_b2:
Succesful ASM optimization Pass5RedundantLabelElimination
ASSEMBLER
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label char = 2
//SEG2 @begin
//SEG3 [1] phi from @begin to @2 [phi:@begin->@2]
//SEG4 @2
b2:
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @2 to main [phi:@2->main]
  jsr main
//SEG7 [3] phi from @2 to @end [phi:@2->@end]
//SEG8 @end
bend:
//SEG9 main
main: {
  //SEG10 [5] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG11 [11] phi from main to ln [phi:main->ln]
  ln_from_main:
  //SEG12 [11] phi (byte) line#12 = (byte/signed byte/word/signed word) 64 [phi:main->ln#0] -- aby=coby1 
    lda #$40
    jsr ln
  //SEG13 main::@1
  b1:
  //SEG14 [6] (byte) char#2 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_aby 
    sta char
    inc char
  //SEG15 [7] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG16 [11] phi from main::@1 to ln [phi:main::@1->ln]
  ln_from_b1:
  //SEG17 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@1->ln#0] -- register_copy 
    jsr ln
  //SEG18 main::@2
  b2:
  //SEG19 [8] (byte) char#4 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_aby 
    sta char
    inc char
  //SEG20 [9] call ln param-assignment [ ] ( main:2 [ ] )
  //SEG21 [11] phi from main::@2 to ln [phi:main::@2->ln]
  ln_from_b2:
  //SEG22 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@2->ln#0] -- register_copy 
    jsr ln
  //SEG23 main::@return
  breturn:
  //SEG24 [10] return  [ ] ( main:2 [ ] )
    rts
}
//SEG25 ln
ln: {
  //SEG26 [12] (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2 [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] ) -- aby=aby_plus_coby1 
    clc
    adc #2
  //SEG27 ln::@return
  breturn:
  //SEG28 [13] return  [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] )
    rts
}

Removing instruction b2:
Removing instruction bend:
Removing instruction ln_from_main:
Removing instruction b1:
Removing instruction ln_from_b1:
Removing instruction b2:
Removing instruction ln_from_b2:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
ASSEMBLER
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label char = 2
//SEG2 @begin
//SEG3 [1] phi from @begin to @2 [phi:@begin->@2]
//SEG4 @2
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @2 to main [phi:@2->main]
  jsr main
//SEG7 [3] phi from @2 to @end [phi:@2->@end]
//SEG8 @end
//SEG9 main
main: {
  //SEG10 [5] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG11 [11] phi from main to ln [phi:main->ln]
  //SEG12 [11] phi (byte) line#12 = (byte/signed byte/word/signed word) 64 [phi:main->ln#0] -- aby=coby1 
    lda #$40
    jsr ln
  //SEG13 main::@1
  //SEG14 [6] (byte) char#2 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_aby 
    sta char
    inc char
  //SEG15 [7] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG16 [11] phi from main::@1 to ln [phi:main::@1->ln]
  //SEG17 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@1->ln#0] -- register_copy 
    jsr ln
  //SEG18 main::@2
  //SEG19 [8] (byte) char#4 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_aby 
    sta char
    inc char
  //SEG20 [9] call ln param-assignment [ ] ( main:2 [ ] )
  //SEG21 [11] phi from main::@2 to ln [phi:main::@2->ln]
  //SEG22 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@2->ln#0] -- register_copy 
    jsr ln
  //SEG23 main::@return
  //SEG24 [10] return  [ ] ( main:2 [ ] )
    rts
}
//SEG25 ln
ln: {
  //SEG26 [12] (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2 [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] ) -- aby=aby_plus_coby1 
    clc
    adc #2
  //SEG27 ln::@return
  //SEG28 [13] return  [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] )
    rts
}

FINAL SYMBOL TABLE
(label) @2
(label) @begin
(label) @end
(byte) char
(byte) char#2 char zp ZP_BYTE:2 20.0
(byte) char#4 char zp ZP_BYTE:2 20.0
(byte) line
(byte) line#12 reg byte a 6.0
(void()) ln()
(byte~) ln::$0 reg byte a 1.6666666666666665
(label) ln::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return

reg byte a [ line#12 ln::$0 ]
zp ZP_BYTE:2 [ char#2 char#4 ]

FINAL CODE
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label char = 2
//SEG2 @begin
//SEG3 [1] phi from @begin to @2 [phi:@begin->@2]
//SEG4 @2
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @2 to main [phi:@2->main]
  jsr main
//SEG7 [3] phi from @2 to @end [phi:@2->@end]
//SEG8 @end
//SEG9 main
main: {
  //SEG10 [5] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG11 [11] phi from main to ln [phi:main->ln]
  //SEG12 [11] phi (byte) line#12 = (byte/signed byte/word/signed word) 64 [phi:main->ln#0] -- aby=coby1 
    lda #$40
    jsr ln
  //SEG13 main::@1
  //SEG14 [6] (byte) char#2 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_aby 
    sta char
    inc char
  //SEG15 [7] call ln param-assignment [ ln::$0 ] ( main:2 [ ln::$0 ] )
  //SEG16 [11] phi from main::@1 to ln [phi:main::@1->ln]
  //SEG17 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@1->ln#0] -- register_copy 
    jsr ln
  //SEG18 main::@2
  //SEG19 [8] (byte) char#4 ← ++ (byte~) ln::$0 [ ln::$0 ] ( main:2 [ ln::$0 ] ) -- zpby1=_inc_aby 
    sta char
    inc char
  //SEG20 [9] call ln param-assignment [ ] ( main:2 [ ] )
  //SEG21 [11] phi from main::@2 to ln [phi:main::@2->ln]
  //SEG22 [11] phi (byte) line#12 = (byte~) ln::$0 [phi:main::@2->ln#0] -- register_copy 
    jsr ln
  //SEG23 main::@return
  //SEG24 [10] return  [ ] ( main:2 [ ] )
    rts
}
//SEG25 ln
ln: {
  //SEG26 [12] (byte~) ln::$0 ← (byte) line#12 + (byte/signed byte/word/signed word) 2 [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] ) -- aby=aby_plus_coby1 
    clc
    adc #2
  //SEG27 ln::@return
  //SEG28 [13] return  [ ln::$0 ] ( main:2::ln:5 [ ln::$0 ] main:2::ln:7 [ ln::$0 ] main:2::ln:9 [ ln::$0 ] )
    rts
}

