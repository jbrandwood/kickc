Inlined call call __init

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  idx#37 = phi( __start::@1/idx#36 )
  main::sw#0 = -$14
  to:main::@1
main::@1: scope:[main]  from main main::@4
  idx#31 = phi( main/idx#37, main::@4/idx#0 )
  main::sw#2 = phi( main/main::sw#0, main::@4/main::sw#1 )
  outsw::sw#0 = main::sw#2
  call outsw
  to:main::@4
main::@4: scope:[main]  from main::@1
  main::sw#3 = phi( main::@1/main::sw#2 )
  idx#16 = phi( main::@1/idx#5 )
  idx#0 = idx#16
  main::sw#1 = main::sw#3 + rangenext(-$14,$13)
  main::$1 = main::sw#1 != rangelast(-$14,$13)
  if(main::$1) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@4
  idx#38 = phi( main::@4/idx#0 )
  main::w#0 = 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@5
  idx#32 = phi( main::@2/idx#38, main::@5/idx#1 )
  main::w#2 = phi( main::@2/main::w#0, main::@5/main::w#1 )
  outw::w#0 = main::w#2
  call outw
  to:main::@5
main::@5: scope:[main]  from main::@3
  main::w#3 = phi( main::@3/main::w#2 )
  idx#17 = phi( main::@3/idx#10 )
  idx#1 = idx#17
  main::w#1 = main::w#3 + rangenext(0,$27)
  main::$3 = main::w#1 != rangelast(0,$27)
  if(main::$3) goto main::@3
  to:main::@return
main::@return: scope:[main]  from main::@5
  idx#18 = phi( main::@5/idx#1 )
  idx#2 = idx#18
  return 
  to:@return

void outsw(int sw)
outsw: scope:[outsw]  from main::@1
  idx#39 = phi( main::@1/idx#31 )
  outsw::sw#2 = phi( main::@1/outsw::sw#0 )
  outsw::$0 = outsw::sw#2 < 0
  outsw::$1 = ! outsw::$0
  if(outsw::$1) goto outsw::@1
  to:outsw::@2
outsw::@1: scope:[outsw]  from outsw outsw::@4
  idx#33 = phi( outsw/idx#39, outsw::@4/idx#4 )
  outsw::sw#3 = phi( outsw/outsw::sw#2, outsw::@4/outsw::sw#1 )
  outw::w#1 = (unsigned int)outsw::sw#3
  call outw
  to:outsw::@3
outsw::@3: scope:[outsw]  from outsw::@1
  idx#19 = phi( outsw::@1/idx#10 )
  idx#3 = idx#19
  to:outsw::@return
outsw::@2: scope:[outsw]  from outsw
  outsw::sw#5 = phi( outsw/outsw::sw#2 )
  idx#34 = phi( outsw/idx#39 )
  out::c#0 = '-'
  call out
  to:outsw::@4
outsw::@4: scope:[outsw]  from outsw::@2
  outsw::sw#4 = phi( outsw::@2/outsw::sw#5 )
  idx#20 = phi( outsw::@2/idx#12 )
  idx#4 = idx#20
  outsw::$4 = - outsw::sw#4
  outsw::sw#1 = outsw::$4
  to:outsw::@1
outsw::@return: scope:[outsw]  from outsw::@3
  idx#21 = phi( outsw::@3/idx#3 )
  idx#5 = idx#21
  return 
  to:@return

void outw(unsigned int w)
outw: scope:[outw]  from main::@3 outsw::@1
  idx#35 = phi( main::@3/idx#32, outsw::@1/idx#33 )
  outw::w#2 = phi( main::@3/outw::w#0, outsw::@1/outw::w#1 )
  outw::$0 = byte1  outw::w#2
  outw::$1 = outw::$0 << 4
  out::c#1 = HEXTAB[outw::$1]
  call out
  to:outw::@1
outw::@1: scope:[outw]  from outw
  outw::w#3 = phi( outw/outw::w#2 )
  idx#22 = phi( outw/idx#12 )
  idx#6 = idx#22
  outw::$3 = byte1  outw::w#3
  outw::$4 = outw::$3 & $f
  out::c#2 = HEXTAB[outw::$4]
  call out
  to:outw::@2
outw::@2: scope:[outw]  from outw::@1
  outw::w#4 = phi( outw::@1/outw::w#3 )
  idx#23 = phi( outw::@1/idx#12 )
  idx#7 = idx#23
  outw::$6 = byte0  outw::w#4
  outw::$7 = outw::$6 << 4
  out::c#3 = HEXTAB[outw::$7]
  call out
  to:outw::@3
outw::@3: scope:[outw]  from outw::@2
  outw::w#5 = phi( outw::@2/outw::w#4 )
  idx#24 = phi( outw::@2/idx#12 )
  idx#8 = idx#24
  outw::$9 = byte0  outw::w#5
  outw::$10 = outw::$9 & $f
  out::c#4 = HEXTAB[outw::$10]
  call out
  to:outw::@4
outw::@4: scope:[outw]  from outw::@3
  idx#25 = phi( outw::@3/idx#12 )
  idx#9 = idx#25
  to:outw::@return
outw::@return: scope:[outw]  from outw::@4
  idx#26 = phi( outw::@4/idx#9 )
  idx#10 = idx#26
  return 
  to:@return

void out(char c)
out: scope:[out]  from outsw::@2 outw outw::@1 outw::@2 outw::@3
  out::c#5 = phi( outsw::@2/out::c#0, outw/out::c#1, outw::@1/out::c#2, outw::@2/out::c#3, outw::@3/out::c#4 )
  idx#27 = phi( outsw::@2/idx#34, outw/idx#35, outw::@1/idx#6, outw::@2/idx#7, outw::@3/idx#8 )
  idx#11 = ++ idx#27
  SCREEN[idx#11] = out::c#5
  to:out::@return
out::@return: scope:[out]  from out
  idx#28 = phi( out/idx#11 )
  idx#12 = idx#28
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  idx#13 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  idx#36 = phi( __start::__init1/idx#13 )
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  idx#29 = phi( __start::@1/idx#2 )
  idx#14 = idx#29
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  idx#30 = phi( __start::@2/idx#14 )
  idx#15 = idx#30
  return 
  to:@return

SYMBOL TABLE SSA
__constant char HEXTAB[] = "0123456789abcdef"
__constant char * const SCREEN = (char *)$400
void __start()
char idx
char idx#0
char idx#1
char idx#10
char idx#11
char idx#12
char idx#13
char idx#14
char idx#15
char idx#16
char idx#17
char idx#18
char idx#19
char idx#2
char idx#20
char idx#21
char idx#22
char idx#23
char idx#24
char idx#25
char idx#26
char idx#27
char idx#28
char idx#29
char idx#3
char idx#30
char idx#31
char idx#32
char idx#33
char idx#34
char idx#35
char idx#36
char idx#37
char idx#38
char idx#39
char idx#4
char idx#5
char idx#6
char idx#7
char idx#8
char idx#9
void main()
bool main::$1
bool main::$3
int main::sw
int main::sw#0
int main::sw#1
int main::sw#2
int main::sw#3
unsigned int main::w
unsigned int main::w#0
unsigned int main::w#1
unsigned int main::w#2
unsigned int main::w#3
void out(char c)
char out::c
char out::c#0
char out::c#1
char out::c#2
char out::c#3
char out::c#4
char out::c#5
void outsw(int sw)
bool outsw::$0
bool outsw::$1
int outsw::$4
int outsw::sw
int outsw::sw#0
int outsw::sw#1
int outsw::sw#2
int outsw::sw#3
int outsw::sw#4
int outsw::sw#5
void outw(unsigned int w)
char outw::$0
char outw::$1
number outw::$10
char outw::$3
number outw::$4
char outw::$6
char outw::$7
char outw::$9
unsigned int outw::w
unsigned int outw::w#0
unsigned int outw::w#1
unsigned int outw::w#2
unsigned int outw::w#3
unsigned int outw::w#4
unsigned int outw::w#5

Adding number conversion cast (snumber) 0 in outsw::$0 = outsw::sw#2 < 0
Adding number conversion cast (unumber) 4 in outw::$1 = outw::$0 << 4
Adding number conversion cast (unumber) $f in outw::$4 = outw::$3 & $f
Adding number conversion cast (unumber) outw::$4 in outw::$4 = outw::$3 & (unumber)$f
Adding number conversion cast (unumber) 4 in outw::$7 = outw::$6 << 4
Adding number conversion cast (unumber) $f in outw::$10 = outw::$9 & $f
Adding number conversion cast (unumber) outw::$10 in outw::$10 = outw::$9 & (unumber)$f
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (char *) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Successful SSA optimization PassNCastSimplification
Finalized signed number type (signed char) 0
Finalized unsigned number type (char) 4
Finalized unsigned number type (char) $f
Finalized unsigned number type (char) 4
Finalized unsigned number type (char) $f
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to char in outw::$4 = outw::$3 & $f
Inferred type updated to char in outw::$10 = outw::$9 & $f
Inversing boolean not [25] outsw::$1 = outsw::sw#2 >= 0 from [24] outsw::$0 = outsw::sw#2 < 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias main::sw#2 = main::sw#3 
Alias idx#0 = idx#16 idx#38 
Alias main::w#2 = main::w#3 
Alias idx#1 = idx#17 idx#18 idx#2 
Alias idx#19 = idx#3 idx#21 idx#5 
Alias idx#34 = idx#39 
Alias outsw::sw#2 = outsw::sw#5 outsw::sw#4 
Alias idx#20 = idx#4 
Alias outsw::sw#1 = outsw::$4 
Alias outw::w#2 = outw::w#3 outw::w#4 outw::w#5 
Alias idx#22 = idx#6 
Alias idx#23 = idx#7 
Alias idx#24 = idx#8 
Alias idx#10 = idx#9 idx#25 idx#26 
Alias idx#11 = idx#28 idx#12 
Alias idx#13 = idx#36 
Alias idx#14 = idx#29 idx#30 idx#15 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values idx#37 idx#13
Identical Phi Values idx#0 idx#19
Identical Phi Values idx#1 idx#10
Identical Phi Values outsw::sw#2 outsw::sw#0
Identical Phi Values idx#34 idx#31
Identical Phi Values idx#19 idx#10
Identical Phi Values idx#20 idx#11
Identical Phi Values idx#22 idx#11
Identical Phi Values idx#23 idx#11
Identical Phi Values idx#24 idx#11
Identical Phi Values idx#10 idx#11
Identical Phi Values idx#14 idx#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values idx#32 idx#11
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$1 [8] if(main::sw#1!=rangelast(-$14,$13)) goto main::@1
Simple Condition main::$3 [16] if(main::w#1!=rangelast(0,$27)) goto main::@3
Simple Condition outsw::$1 [20] if(outsw::sw#0>=0) goto outsw::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant main::sw#0 = -$14
Constant main::w#0 = 0
Constant out::c#0 = '-'
Constant idx#13 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [6] main::sw#1 = ++ main::sw#2 to ++
Resolved ranged comparison value [8] if(main::sw#1!=rangelast(-$14,$13)) goto main::@1 to $14
Resolved ranged next value [14] main::w#1 = ++ main::w#2 to ++
Resolved ranged comparison value [16] if(main::w#1!=rangelast(0,$27)) goto main::@3 to $28
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (snumber) $14 in [4] if(main::sw#1!=$14) goto main::@1
Adding number conversion cast (unumber) $28 in [9] if(main::w#1!=$28) goto main::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $14
Simplifying constant integer cast $28
Successful SSA optimization PassNCastSimplification
Finalized signed number type (signed char) $14
Finalized unsigned number type (char) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings main::sw#0
Inlining constant with var siblings main::w#0
Inlining constant with var siblings out::c#0
Inlining constant with var siblings idx#13
Constant inlined out::c#0 = '-'
Constant inlined main::w#0 = 0
Constant inlined idx#13 = 0
Constant inlined main::sw#0 = -$14
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@6(between main::@4 and main::@1)
Added new block during phi lifting main::@7(between main::@5 and main::@3)
Added new block during phi lifting outsw::@5(between outsw and outsw::@1)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of outsw::@3
Adding NOP phi() at start of outw::@4
CALL GRAPH
Calls in [main] to outsw:3 outw:11 
Calls in [outsw] to out:20 outw:28 
Calls in [outw] to out:39 out:45 out:51 out:57 

Created 9 initial phi equivalence classes
Coalesced [9] outw::w#6 = outw::w#0
Coalesced [10] idx#43 = idx#11
Coalesced [15] main::w#4 = main::w#1
Coalesced [16] main::sw#4 = main::sw#1
Coalesced [17] idx#40 = idx#11
Coalesced [19] idx#45 = idx#31
Coalesced [22] outsw::sw#7 = outsw::sw#1
Coalesced [23] idx#42 = idx#11
Coalesced [26] outw::w#7 = outw::w#1
Coalesced (already) [27] idx#44 = idx#33
Coalesced [31] outsw::sw#6 = outsw::sw#0
Coalesced (already) [32] idx#41 = idx#31
Coalesced (already) [37] idx#46 = idx#35
Coalesced [38] out::c#6 = out::c#1
Coalesced (already) [43] idx#47 = idx#11
Coalesced [44] out::c#7 = out::c#2
Coalesced (already) [49] idx#48 = idx#11
Coalesced [50] out::c#8 = out::c#3
Coalesced (already) [55] idx#49 = idx#11
Coalesced [56] out::c#9 = out::c#4
Coalesced down to 6 phi equivalence classes
Culled Empty Block label main::@2
Culled Empty Block label main::@7
Culled Empty Block label main::@6
Culled Empty Block label outsw::@3
Culled Empty Block label outsw::@5
Culled Empty Block label outw::@4
Renumbering block main::@3 to main::@2
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block outsw::@4 to outsw::@3
Adding NOP phi() at start of main
Adding NOP phi() at start of outsw::@2

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@3
  [1] idx#31 = phi( main/0, main::@3/idx#11 )
  [1] main::sw#2 = phi( main/-$14, main::@3/main::sw#1 )
  [2] outsw::sw#0 = main::sw#2
  [3] call outsw
  to:main::@3
main::@3: scope:[main]  from main::@1
  [4] main::sw#1 = ++ main::sw#2
  [5] if(main::sw#1!=$14) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@3 main::@4
  [6] main::w#2 = phi( main::@3/0, main::@4/main::w#1 )
  [7] outw::w#0 = main::w#2
  [8] call outw
  to:main::@4
main::@4: scope:[main]  from main::@2
  [9] main::w#1 = ++ main::w#2
  [10] if(main::w#1!=$28) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@4
  [11] return 
  to:@return

void outsw(int sw)
outsw: scope:[outsw]  from main::@1
  [12] if(outsw::sw#0>=0) goto outsw::@1
  to:outsw::@2
outsw::@2: scope:[outsw]  from outsw
  [13] phi()
  [14] call out
  to:outsw::@3
outsw::@3: scope:[outsw]  from outsw::@2
  [15] outsw::sw#1 = - outsw::sw#0
  to:outsw::@1
outsw::@1: scope:[outsw]  from outsw outsw::@3
  [16] idx#33 = phi( outsw/idx#31, outsw::@3/idx#11 )
  [16] outsw::sw#3 = phi( outsw/outsw::sw#0, outsw::@3/outsw::sw#1 )
  [17] outw::w#1 = (unsigned int)outsw::sw#3
  [18] call outw
  to:outsw::@return
outsw::@return: scope:[outsw]  from outsw::@1
  [19] return 
  to:@return

void outw(unsigned int w)
outw: scope:[outw]  from main::@2 outsw::@1
  [20] idx#35 = phi( main::@2/idx#11, outsw::@1/idx#33 )
  [20] outw::w#2 = phi( main::@2/outw::w#0, outsw::@1/outw::w#1 )
  [21] outw::$0 = byte1  outw::w#2
  [22] outw::$1 = outw::$0 << 4
  [23] out::c#1 = HEXTAB[outw::$1]
  [24] call out
  to:outw::@1
outw::@1: scope:[outw]  from outw
  [25] outw::$3 = byte1  outw::w#2
  [26] outw::$4 = outw::$3 & $f
  [27] out::c#2 = HEXTAB[outw::$4]
  [28] call out
  to:outw::@2
outw::@2: scope:[outw]  from outw::@1
  [29] outw::$6 = byte0  outw::w#2
  [30] outw::$7 = outw::$6 << 4
  [31] out::c#3 = HEXTAB[outw::$7]
  [32] call out
  to:outw::@3
outw::@3: scope:[outw]  from outw::@2
  [33] outw::$9 = byte0  outw::w#2
  [34] outw::$10 = outw::$9 & $f
  [35] out::c#4 = HEXTAB[outw::$10]
  [36] call out
  to:outw::@return
outw::@return: scope:[outw]  from outw::@3
  [37] return 
  to:@return

void out(char c)
out: scope:[out]  from outsw::@2 outw outw::@1 outw::@2 outw::@3
  [38] out::c#5 = phi( outsw::@2/'-', outw/out::c#1, outw::@1/out::c#2, outw::@2/out::c#3, outw::@3/out::c#4 )
  [38] idx#27 = phi( outsw::@2/idx#31, outw/idx#35, outw::@1/idx#11, outw::@2/idx#11, outw::@3/idx#11 )
  [39] idx#11 = ++ idx#27
  [40] SCREEN[idx#11] = out::c#5
  to:out::@return
out::@return: scope:[out]  from out
  [41] return 
  to:@return


VARIABLE REGISTER WEIGHTS
char idx
char idx#11 // 797.5172413793105
char idx#27 // 14106.0
char idx#31 // 53.25
char idx#33 // 151.5
char idx#35 // 278.25
void main()
int main::sw
int main::sw#1 // 16.5
int main::sw#2 // 11.0
unsigned int main::w
unsigned int main::w#1 // 16.5
unsigned int main::w#2 // 11.0
void out(char c)
char out::c
char out::c#1 // 2002.0
char out::c#2 // 2002.0
char out::c#3 // 2002.0
char out::c#4 // 2002.0
char out::c#5 // 7002.5
void outsw(int sw)
int outsw::sw
int outsw::sw#0 // 78.5
int outsw::sw#1 // 202.0
int outsw::sw#3 // 202.0
void outw(unsigned int w)
char outw::$0 // 2002.0
char outw::$1 // 2002.0
char outw::$10 // 2002.0
char outw::$3 // 2002.0
char outw::$4 // 2002.0
char outw::$6 // 2002.0
char outw::$7 // 2002.0
char outw::$9 // 2002.0
unsigned int outw::w
unsigned int outw::w#0 // 22.0
unsigned int outw::w#1 // 202.0
unsigned int outw::w#2 // 316.61538461538464

Initial phi equivalence classes
[ main::sw#2 main::sw#1 ]
[ main::w#2 main::w#1 ]
[ outsw::sw#3 outsw::sw#0 outsw::sw#1 ]
[ outw::w#2 outw::w#0 outw::w#1 ]
[ idx#27 idx#35 idx#33 idx#31 idx#11 ]
[ out::c#5 out::c#1 out::c#2 out::c#3 out::c#4 ]
Added variable outw::$0 to live range equivalence class [ outw::$0 ]
Added variable outw::$1 to live range equivalence class [ outw::$1 ]
Added variable outw::$3 to live range equivalence class [ outw::$3 ]
Added variable outw::$4 to live range equivalence class [ outw::$4 ]
Added variable outw::$6 to live range equivalence class [ outw::$6 ]
Added variable outw::$7 to live range equivalence class [ outw::$7 ]
Added variable outw::$9 to live range equivalence class [ outw::$9 ]
Added variable outw::$10 to live range equivalence class [ outw::$10 ]
Complete equivalence classes
[ main::sw#2 main::sw#1 ]
[ main::w#2 main::w#1 ]
[ outsw::sw#3 outsw::sw#0 outsw::sw#1 ]
[ outw::w#2 outw::w#0 outw::w#1 ]
[ idx#27 idx#35 idx#33 idx#31 idx#11 ]
[ out::c#5 out::c#1 out::c#2 out::c#3 out::c#4 ]
[ outw::$0 ]
[ outw::$1 ]
[ outw::$3 ]
[ outw::$4 ]
[ outw::$6 ]
[ outw::$7 ]
[ outw::$9 ]
[ outw::$10 ]
Allocated zp[1]:2 [ idx#27 idx#35 idx#33 idx#31 idx#11 ]
Allocated zp[1]:3 [ out::c#5 out::c#1 out::c#2 out::c#3 out::c#4 ]
Allocated zp[1]:4 [ outw::$0 ]
Allocated zp[1]:5 [ outw::$1 ]
Allocated zp[1]:6 [ outw::$3 ]
Allocated zp[1]:7 [ outw::$4 ]
Allocated zp[1]:8 [ outw::$6 ]
Allocated zp[1]:9 [ outw::$7 ]
Allocated zp[1]:10 [ outw::$9 ]
Allocated zp[1]:11 [ outw::$10 ]
Allocated zp[2]:12 [ outw::w#2 outw::w#0 outw::w#1 ]
Allocated zp[2]:14 [ outsw::sw#3 outsw::sw#0 outsw::sw#1 ]
Allocated zp[2]:16 [ main::sw#2 main::sw#1 ]
Allocated zp[2]:18 [ main::w#2 main::w#1 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] outsw::sw#0 = main::sw#2 [ main::sw#2 idx#31 outsw::sw#0 ] (  [ main::sw#2 idx#31 outsw::sw#0 ] { { outsw::sw#0 = main::sw#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ idx#27 idx#35 idx#33 idx#31 idx#11 ]
Statement [5] if(main::sw#1!=$14) goto main::@1 [ main::sw#1 idx#11 ] (  [ main::sw#1 idx#11 ] { }  ) always clobbers reg byte a 
Statement [7] outw::w#0 = main::w#2 [ idx#11 main::w#2 outw::w#0 ] (  [ idx#11 main::w#2 outw::w#0 ] { { outw::w#0 = outw::w#2 main::w#2 } { idx#11 = idx#35 } }  ) always clobbers reg byte a 
Statement [10] if(main::w#1!=$28) goto main::@2 [ idx#11 main::w#1 ] (  [ idx#11 main::w#1 ] { }  ) always clobbers reg byte a 
Statement [12] if(outsw::sw#0>=0) goto outsw::@1 [ idx#31 outsw::sw#0 ] ( outsw:3 [ main::sw#2 idx#31 outsw::sw#0 ] { { outsw::sw#0 = main::sw#2 } }  ) always clobbers reg byte a 
Statement [15] outsw::sw#1 = - outsw::sw#0 [ idx#11 outsw::sw#1 ] ( outsw:3 [ main::sw#2 idx#11 outsw::sw#1 ] { { outsw::sw#0 = main::sw#2 } }  ) always clobbers reg byte a 
Statement [17] outw::w#1 = (unsigned int)outsw::sw#3 [ idx#33 outw::w#1 ] ( outsw:3 [ main::sw#2 idx#33 outw::w#1 ] { { outsw::sw#0 = main::sw#2 } { outw::w#1 = outw::w#2 } { idx#33 = idx#35 } }  ) always clobbers reg byte a 
Statement [22] outw::$1 = outw::$0 << 4 [ outw::w#2 idx#35 outw::$1 ] ( outw:8 [ main::w#2 outw::w#2 idx#35 outw::$1 ] { { outw::w#0 = outw::w#2 main::w#2 } { idx#11 = idx#35 idx#27 } { out::c#1 = out::c#5 } }  outsw:3::outw:18 [ main::sw#2 outw::w#2 idx#35 outw::$1 ] { { outsw::sw#0 = main::sw#2 } { outw::w#1 = outw::w#2 } { idx#27 = idx#35 idx#33 } { out::c#1 = out::c#5 } }  ) always clobbers reg byte a 
Statement [30] outw::$7 = outw::$6 << 4 [ idx#11 outw::w#2 outw::$7 ] ( outw:8 [ main::w#2 idx#11 outw::w#2 outw::$7 ] { { outw::w#0 = outw::w#2 main::w#2 } { idx#11 = idx#35 idx#27 } { out::c#3 = out::c#5 } }  outsw:3::outw:18 [ main::sw#2 idx#11 outw::w#2 outw::$7 ] { { outsw::sw#0 = main::sw#2 } { outw::w#1 = outw::w#2 } { idx#33 = idx#35 } { idx#11 = idx#27 } { out::c#3 = out::c#5 } }  ) always clobbers reg byte a 
Statement [2] outsw::sw#0 = main::sw#2 [ main::sw#2 idx#31 outsw::sw#0 ] (  [ main::sw#2 idx#31 outsw::sw#0 ] { { outsw::sw#0 = main::sw#2 } }  ) always clobbers reg byte a 
Statement [5] if(main::sw#1!=$14) goto main::@1 [ main::sw#1 idx#11 ] (  [ main::sw#1 idx#11 ] { }  ) always clobbers reg byte a 
Statement [7] outw::w#0 = main::w#2 [ idx#11 main::w#2 outw::w#0 ] (  [ idx#11 main::w#2 outw::w#0 ] { { outw::w#0 = outw::w#2 main::w#2 } { idx#11 = idx#35 } }  ) always clobbers reg byte a 
Statement [10] if(main::w#1!=$28) goto main::@2 [ idx#11 main::w#1 ] (  [ idx#11 main::w#1 ] { }  ) always clobbers reg byte a 
Statement [12] if(outsw::sw#0>=0) goto outsw::@1 [ idx#31 outsw::sw#0 ] ( outsw:3 [ main::sw#2 idx#31 outsw::sw#0 ] { { outsw::sw#0 = main::sw#2 } }  ) always clobbers reg byte a 
Statement [15] outsw::sw#1 = - outsw::sw#0 [ idx#11 outsw::sw#1 ] ( outsw:3 [ main::sw#2 idx#11 outsw::sw#1 ] { { outsw::sw#0 = main::sw#2 } }  ) always clobbers reg byte a 
Statement [17] outw::w#1 = (unsigned int)outsw::sw#3 [ idx#33 outw::w#1 ] ( outsw:3 [ main::sw#2 idx#33 outw::w#1 ] { { outsw::sw#0 = main::sw#2 } { outw::w#1 = outw::w#2 } { idx#33 = idx#35 } }  ) always clobbers reg byte a 
Statement [22] outw::$1 = outw::$0 << 4 [ outw::w#2 idx#35 outw::$1 ] ( outw:8 [ main::w#2 outw::w#2 idx#35 outw::$1 ] { { outw::w#0 = outw::w#2 main::w#2 } { idx#11 = idx#35 idx#27 } { out::c#1 = out::c#5 } }  outsw:3::outw:18 [ main::sw#2 outw::w#2 idx#35 outw::$1 ] { { outsw::sw#0 = main::sw#2 } { outw::w#1 = outw::w#2 } { idx#27 = idx#35 idx#33 } { out::c#1 = out::c#5 } }  ) always clobbers reg byte a 
Statement [30] outw::$7 = outw::$6 << 4 [ idx#11 outw::w#2 outw::$7 ] ( outw:8 [ main::w#2 idx#11 outw::w#2 outw::$7 ] { { outw::w#0 = outw::w#2 main::w#2 } { idx#11 = idx#35 idx#27 } { out::c#3 = out::c#5 } }  outsw:3::outw:18 [ main::sw#2 idx#11 outw::w#2 outw::$7 ] { { outsw::sw#0 = main::sw#2 } { outw::w#1 = outw::w#2 } { idx#33 = idx#35 } { idx#11 = idx#27 } { out::c#3 = out::c#5 } }  ) always clobbers reg byte a 
Potential registers zp[2]:16 [ main::sw#2 main::sw#1 ] : zp[2]:16 , 
Potential registers zp[2]:18 [ main::w#2 main::w#1 ] : zp[2]:18 , 
Potential registers zp[2]:14 [ outsw::sw#3 outsw::sw#0 outsw::sw#1 ] : zp[2]:14 , 
Potential registers zp[2]:12 [ outw::w#2 outw::w#0 outw::w#1 ] : zp[2]:12 , 
Potential registers zp[1]:2 [ idx#27 idx#35 idx#33 idx#31 idx#11 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ out::c#5 out::c#1 out::c#2 out::c#3 out::c#4 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ outw::$0 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ outw::$1 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ outw::$3 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ outw::$4 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ outw::$6 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ outw::$7 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ outw::$9 ] : zp[1]:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ outw::$10 ] : zp[1]:11 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [outw] 2,002: zp[1]:4 [ outw::$0 ] 2,002: zp[1]:5 [ outw::$1 ] 2,002: zp[1]:6 [ outw::$3 ] 2,002: zp[1]:7 [ outw::$4 ] 2,002: zp[1]:8 [ outw::$6 ] 2,002: zp[1]:9 [ outw::$7 ] 2,002: zp[1]:10 [ outw::$9 ] 2,002: zp[1]:11 [ outw::$10 ] 540.62: zp[2]:12 [ outw::w#2 outw::w#0 outw::w#1 ] 
Uplift Scope [] 15,386.52: zp[1]:2 [ idx#27 idx#35 idx#33 idx#31 idx#11 ] 
Uplift Scope [out] 15,010.5: zp[1]:3 [ out::c#5 out::c#1 out::c#2 out::c#3 out::c#4 ] 
Uplift Scope [outsw] 482.5: zp[2]:14 [ outsw::sw#3 outsw::sw#0 outsw::sw#1 ] 
Uplift Scope [main] 27.5: zp[2]:16 [ main::sw#2 main::sw#1 ] 27.5: zp[2]:18 [ main::w#2 main::w#1 ] 

Uplifting [outw] best 1500 combination reg byte a [ outw::$0 ] reg byte a [ outw::$1 ] reg byte a [ outw::$3 ] reg byte a [ outw::$4 ] zp[1]:8 [ outw::$6 ] zp[1]:9 [ outw::$7 ] zp[1]:10 [ outw::$9 ] zp[1]:11 [ outw::$10 ] zp[2]:12 [ outw::w#2 outw::w#0 outw::w#1 ] 
Limited combination testing to 100 combinations of 65536 possible.
Uplifting [] best 1464 combination reg byte x [ idx#27 idx#35 idx#33 idx#31 idx#11 ] 
Uplifting [out] best 1446 combination reg byte a [ out::c#5 out::c#1 out::c#2 out::c#3 out::c#4 ] 
Uplifting [outsw] best 1446 combination zp[2]:14 [ outsw::sw#3 outsw::sw#0 outsw::sw#1 ] 
Uplifting [main] best 1446 combination zp[2]:16 [ main::sw#2 main::sw#1 ] zp[2]:18 [ main::w#2 main::w#1 ] 
Attempting to uplift remaining variables inzp[1]:8 [ outw::$6 ]
Uplifting [outw] best 1440 combination reg byte a [ outw::$6 ] 
Attempting to uplift remaining variables inzp[1]:9 [ outw::$7 ]
Uplifting [outw] best 1436 combination reg byte a [ outw::$7 ] 
Attempting to uplift remaining variables inzp[1]:10 [ outw::$9 ]
Uplifting [outw] best 1430 combination reg byte a [ outw::$9 ] 
Attempting to uplift remaining variables inzp[1]:11 [ outw::$10 ]
Uplifting [outw] best 1426 combination reg byte a [ outw::$10 ] 
Coalescing zero page register [ zp[2]:18 [ main::w#2 main::w#1 ] ] with [ zp[2]:12 [ outw::w#2 outw::w#0 outw::w#1 ] ] - score: 1
Coalescing zero page register [ zp[2]:18 [ main::w#2 main::w#1 outw::w#2 outw::w#0 outw::w#1 ] ] with [ zp[2]:14 [ outsw::sw#3 outsw::sw#0 outsw::sw#1 ] ] - score: 1
Allocated (was zp[2]:18) zp[2]:2 [ main::w#2 main::w#1 outw::w#2 outw::w#0 outw::w#1 outsw::sw#3 outsw::sw#0 outsw::sw#1 ]
Allocated (was zp[2]:16) zp[2]:4 [ main::sw#2 main::sw#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test effective live range and register allocation
// Here outsw::sw and outw::w should have the same allocation
  // Upstart
  // Commodore 64 PRG executable file
.file [name="liverange-10.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label SCREEN = $400
.segment Code
  // main
main: {
    .label sw = 4
    .label w = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi idx#31 = 0 [phi:main->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [1] phi main::sw#2 = -$14 [phi:main->main::@1#1] -- vwsz1=vwsc1 
    lda #<-$14
    sta.z sw
    lda #>-$14
    sta.z sw+1
    jmp __b1
    // [1] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  __b1_from___b3:
    // [1] phi idx#31 = idx#11 [phi:main::@3->main::@1#0] -- register_copy 
    // [1] phi main::sw#2 = main::sw#1 [phi:main::@3->main::@1#1] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [2] outsw::sw#0 = main::sw#2 -- vwsz1=vwsz2 
    lda.z sw
    sta.z outsw.sw
    lda.z sw+1
    sta.z outsw.sw+1
    // [3] call outsw -- call_phi_near 
    jsr outsw
    jmp __b3
    // main::@3
  __b3:
    // [4] main::sw#1 = ++ main::sw#2 -- vwsz1=_inc_vwsz1 
    inc.z sw
    bne !+
    inc.z sw+1
  !:
    // [5] if(main::sw#1!=$14) goto main::@1 -- vwsz1_neq_vwuc1_then_la1 
    lda.z sw+1
    cmp #>$14
    bne __b1_from___b3
    lda.z sw
    cmp #<$14
    bne __b1_from___b3
    // [6] phi from main::@3 to main::@2 [phi:main::@3->main::@2]
  __b2_from___b3:
    // [6] phi main::w#2 = 0 [phi:main::@3->main::@2#0] -- vwuz1=vwuc1 
    lda #<0
    sta.z w
    lda #>0
    sta.z w+1
    jmp __b2
    // [6] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  __b2_from___b4:
    // [6] phi main::w#2 = main::w#1 [phi:main::@4->main::@2#0] -- register_copy 
    jmp __b2
    // main::@2
  __b2:
    // [7] outw::w#0 = main::w#2
    // [8] call outw
    // [20] phi from main::@2 to outw [phi:main::@2->outw]
  outw_from___b2:
    // [20] phi idx#35 = idx#11 [phi:main::@2->outw#0] -- register_copy 
    // [20] phi outw::w#2 = outw::w#0 [phi:main::@2->outw#1] -- call_phi_near 
    jsr outw
    jmp __b4
    // main::@4
  __b4:
    // [9] main::w#1 = ++ main::w#2 -- vwuz1=_inc_vwuz1 
    inc.z w
    bne !+
    inc.z w+1
  !:
    // [10] if(main::w#1!=$28) goto main::@2 -- vwuz1_neq_vbuc1_then_la1 
    lda.z w+1
    bne __b2_from___b4
    lda.z w
    cmp #$28
    bne __b2_from___b4
    jmp __breturn
    // main::@return
  __breturn:
    // [11] return 
    rts
}
  // outsw
// void outsw(__zp(2) int sw)
outsw: {
    .label sw = 2
    // [12] if(outsw::sw#0>=0) goto outsw::@1 -- vwsz1_ge_0_then_la1 
    lda.z sw+1
    bpl __b1_from_outsw
    // [13] phi from outsw to outsw::@2 [phi:outsw->outsw::@2]
  __b2_from_outsw:
    jmp __b2
    // outsw::@2
  __b2:
    // [14] call out
    // [38] phi from outsw::@2 to out [phi:outsw::@2->out]
  out_from___b2:
    // [38] phi out::c#5 = '-' [phi:outsw::@2->out#0] -- vbuaa=vbuc1 
    lda #'-'
    // [38] phi idx#27 = idx#31 [phi:outsw::@2->out#1] -- call_phi_near 
    jsr out
    jmp __b3
    // outsw::@3
  __b3:
    // [15] outsw::sw#1 = - outsw::sw#0 -- vwsz1=_neg_vwsz1 
    lda #0
    sec
    sbc.z sw
    sta.z sw
    lda #0
    sbc.z sw+1
    sta.z sw+1
    // [16] phi from outsw outsw::@3 to outsw::@1 [phi:outsw/outsw::@3->outsw::@1]
  __b1_from_outsw:
  __b1_from___b3:
    // [16] phi idx#33 = idx#31 [phi:outsw/outsw::@3->outsw::@1#0] -- register_copy 
    // [16] phi outsw::sw#3 = outsw::sw#0 [phi:outsw/outsw::@3->outsw::@1#1] -- register_copy 
    jmp __b1
    // outsw::@1
  __b1:
    // [17] outw::w#1 = (unsigned int)outsw::sw#3
    // [18] call outw
    // [20] phi from outsw::@1 to outw [phi:outsw::@1->outw]
  outw_from___b1:
    // [20] phi idx#35 = idx#33 [phi:outsw::@1->outw#0] -- register_copy 
    // [20] phi outw::w#2 = outw::w#1 [phi:outsw::@1->outw#1] -- call_phi_near 
    jsr outw
    jmp __breturn
    // outsw::@return
  __breturn:
    // [19] return 
    rts
}
  // outw
// void outw(__zp(2) unsigned int w)
outw: {
    .label w = 2
    // [21] outw::$0 = byte1  outw::w#2 -- vbuaa=_byte1_vwuz1 
    lda.z w+1
    // [22] outw::$1 = outw::$0 << 4 -- vbuaa=vbuaa_rol_4 
    asl
    asl
    asl
    asl
    // [23] out::c#1 = HEXTAB[outw::$1] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda HEXTAB,y
    // [24] call out
    // [38] phi from outw to out [phi:outw->out]
  out_from_outw:
    // [38] phi out::c#5 = out::c#1 [phi:outw->out#0] -- register_copy 
    // [38] phi idx#27 = idx#35 [phi:outw->out#1] -- call_phi_near 
    jsr out
    jmp __b1
    // outw::@1
  __b1:
    // [25] outw::$3 = byte1  outw::w#2 -- vbuaa=_byte1_vwuz1 
    lda.z w+1
    // [26] outw::$4 = outw::$3 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [27] out::c#2 = HEXTAB[outw::$4] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda HEXTAB,y
    // [28] call out
    // [38] phi from outw::@1 to out [phi:outw::@1->out]
  out_from___b1:
    // [38] phi out::c#5 = out::c#2 [phi:outw::@1->out#0] -- register_copy 
    // [38] phi idx#27 = idx#11 [phi:outw::@1->out#1] -- call_phi_near 
    jsr out
    jmp __b2
    // outw::@2
  __b2:
    // [29] outw::$6 = byte0  outw::w#2 -- vbuaa=_byte0_vwuz1 
    lda.z w
    // [30] outw::$7 = outw::$6 << 4 -- vbuaa=vbuaa_rol_4 
    asl
    asl
    asl
    asl
    // [31] out::c#3 = HEXTAB[outw::$7] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda HEXTAB,y
    // [32] call out
    // [38] phi from outw::@2 to out [phi:outw::@2->out]
  out_from___b2:
    // [38] phi out::c#5 = out::c#3 [phi:outw::@2->out#0] -- register_copy 
    // [38] phi idx#27 = idx#11 [phi:outw::@2->out#1] -- call_phi_near 
    jsr out
    jmp __b3
    // outw::@3
  __b3:
    // [33] outw::$9 = byte0  outw::w#2 -- vbuaa=_byte0_vwuz1 
    lda.z w
    // [34] outw::$10 = outw::$9 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [35] out::c#4 = HEXTAB[outw::$10] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda HEXTAB,y
    // [36] call out
    // [38] phi from outw::@3 to out [phi:outw::@3->out]
  out_from___b3:
    // [38] phi out::c#5 = out::c#4 [phi:outw::@3->out#0] -- register_copy 
    // [38] phi idx#27 = idx#11 [phi:outw::@3->out#1] -- call_phi_near 
    jsr out
    jmp __breturn
    // outw::@return
  __breturn:
    // [37] return 
    rts
}
  // out
// void out(__register(A) char c)
out: {
    // [39] idx#11 = ++ idx#27 -- vbuxx=_inc_vbuxx 
    inx
    // [40] SCREEN[idx#11] = out::c#5 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    jmp __breturn
    // out::@return
  __breturn:
    // [41] return 
    rts
}
  // File Data
.segment Data
  HEXTAB: .text "0123456789abcdef"
  .byte 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #>0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Replacing label __b2_from___b4 with __b2
Replacing label __b2_from___b4 with __b2
Replacing label __b1_from_outsw with __b1
Removing instruction __b1_from___b3:
Removing instruction __b2_from___b4:
Removing instruction outw_from___b2:
Removing instruction __b2_from_outsw:
Removing instruction out_from___b2:
Removing instruction __b1_from_outsw:
Removing instruction __b1_from___b3:
Removing instruction outw_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __b2_from___b3:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction out_from_outw:
Removing instruction __b1:
Removing instruction out_from___b1:
Removing instruction __b2:
Removing instruction out_from___b2:
Removing instruction __b3:
Removing instruction out_from___b3:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b2
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
__constant char HEXTAB[] = "0123456789abcdef"
__constant char * const SCREEN = (char *) 1024
char idx
char idx#11 // reg byte x 797.5172413793105
char idx#27 // reg byte x 14106.0
char idx#31 // reg byte x 53.25
char idx#33 // reg byte x 151.5
char idx#35 // reg byte x 278.25
void main()
int main::sw
int main::sw#1 // sw zp[2]:4 16.5
int main::sw#2 // sw zp[2]:4 11.0
unsigned int main::w
unsigned int main::w#1 // w zp[2]:2 16.5
unsigned int main::w#2 // w zp[2]:2 11.0
void out(char c)
char out::c
char out::c#1 // reg byte a 2002.0
char out::c#2 // reg byte a 2002.0
char out::c#3 // reg byte a 2002.0
char out::c#4 // reg byte a 2002.0
char out::c#5 // reg byte a 7002.5
void outsw(int sw)
int outsw::sw
int outsw::sw#0 // sw zp[2]:2 78.5
int outsw::sw#1 // sw zp[2]:2 202.0
int outsw::sw#3 // sw zp[2]:2 202.0
void outw(unsigned int w)
char outw::$0 // reg byte a 2002.0
char outw::$1 // reg byte a 2002.0
char outw::$10 // reg byte a 2002.0
char outw::$3 // reg byte a 2002.0
char outw::$4 // reg byte a 2002.0
char outw::$6 // reg byte a 2002.0
char outw::$7 // reg byte a 2002.0
char outw::$9 // reg byte a 2002.0
unsigned int outw::w
unsigned int outw::w#0 // w zp[2]:2 22.0
unsigned int outw::w#1 // w zp[2]:2 202.0
unsigned int outw::w#2 // w zp[2]:2 316.61538461538464

zp[2]:4 [ main::sw#2 main::sw#1 ]
zp[2]:2 [ main::w#2 main::w#1 outw::w#2 outw::w#0 outw::w#1 outsw::sw#3 outsw::sw#0 outsw::sw#1 ]
reg byte x [ idx#27 idx#35 idx#33 idx#31 idx#11 ]
reg byte a [ out::c#5 out::c#1 out::c#2 out::c#3 out::c#4 ]
reg byte a [ outw::$0 ]
reg byte a [ outw::$1 ]
reg byte a [ outw::$3 ]
reg byte a [ outw::$4 ]
reg byte a [ outw::$6 ]
reg byte a [ outw::$7 ]
reg byte a [ outw::$9 ]
reg byte a [ outw::$10 ]


FINAL ASSEMBLER
Score: 1064

  // File Comments
// Test effective live range and register allocation
// Here outsw::sw and outw::w should have the same allocation
  // Upstart
  // Commodore 64 PRG executable file
.file [name="liverange-10.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label SCREEN = $400
.segment Code
  // main
main: {
    .label sw = 4
    .label w = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi idx#31 = 0 [phi:main->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [1] phi main::sw#2 = -$14 [phi:main->main::@1#1] -- vwsz1=vwsc1 
    lda #<-$14
    sta.z sw
    lda #>-$14
    sta.z sw+1
    // [1] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
    // [1] phi idx#31 = idx#11 [phi:main::@3->main::@1#0] -- register_copy 
    // [1] phi main::sw#2 = main::sw#1 [phi:main::@3->main::@1#1] -- register_copy 
    // main::@1
  __b1:
    // outsw(sw)
    // [2] outsw::sw#0 = main::sw#2 -- vwsz1=vwsz2 
    lda.z sw
    sta.z outsw.sw
    lda.z sw+1
    sta.z outsw.sw+1
    // [3] call outsw -- call_phi_near 
    jsr outsw
    // main::@3
    // for(signed int sw: -20..19 )
    // [4] main::sw#1 = ++ main::sw#2 -- vwsz1=_inc_vwsz1 
    inc.z sw
    bne !+
    inc.z sw+1
  !:
    // [5] if(main::sw#1!=$14) goto main::@1 -- vwsz1_neq_vwuc1_then_la1 
    lda.z sw+1
    cmp #>$14
    bne __b1
    lda.z sw
    cmp #<$14
    bne __b1
    // [6] phi from main::@3 to main::@2 [phi:main::@3->main::@2]
    // [6] phi main::w#2 = 0 [phi:main::@3->main::@2#0] -- vwuz1=vwuc1 
    lda #<0
    sta.z w
    sta.z w+1
    // [6] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
    // [6] phi main::w#2 = main::w#1 [phi:main::@4->main::@2#0] -- register_copy 
    // main::@2
  __b2:
    // outw(w)
    // [7] outw::w#0 = main::w#2
    // [8] call outw
    // [20] phi from main::@2 to outw [phi:main::@2->outw]
    // [20] phi idx#35 = idx#11 [phi:main::@2->outw#0] -- register_copy 
    // [20] phi outw::w#2 = outw::w#0 [phi:main::@2->outw#1] -- call_phi_near 
    jsr outw
    // main::@4
    // for(unsigned int w: 0..39 )
    // [9] main::w#1 = ++ main::w#2 -- vwuz1=_inc_vwuz1 
    inc.z w
    bne !+
    inc.z w+1
  !:
    // [10] if(main::w#1!=$28) goto main::@2 -- vwuz1_neq_vbuc1_then_la1 
    lda.z w+1
    bne __b2
    lda.z w
    cmp #$28
    bne __b2
    // main::@return
    // }
    // [11] return 
    rts
}
  // outsw
// void outsw(__zp(2) int sw)
outsw: {
    .label sw = 2
    // if(sw<0)
    // [12] if(outsw::sw#0>=0) goto outsw::@1 -- vwsz1_ge_0_then_la1 
    lda.z sw+1
    bpl __b1
    // [13] phi from outsw to outsw::@2 [phi:outsw->outsw::@2]
    // outsw::@2
    // out('-')
    // [14] call out
    // [38] phi from outsw::@2 to out [phi:outsw::@2->out]
    // [38] phi out::c#5 = '-' [phi:outsw::@2->out#0] -- vbuaa=vbuc1 
    lda #'-'
    // [38] phi idx#27 = idx#31 [phi:outsw::@2->out#1] -- call_phi_near 
    jsr out
    // outsw::@3
    // sw = -sw
    // [15] outsw::sw#1 = - outsw::sw#0 -- vwsz1=_neg_vwsz1 
    lda #0
    sec
    sbc.z sw
    sta.z sw
    lda #0
    sbc.z sw+1
    sta.z sw+1
    // [16] phi from outsw outsw::@3 to outsw::@1 [phi:outsw/outsw::@3->outsw::@1]
    // [16] phi idx#33 = idx#31 [phi:outsw/outsw::@3->outsw::@1#0] -- register_copy 
    // [16] phi outsw::sw#3 = outsw::sw#0 [phi:outsw/outsw::@3->outsw::@1#1] -- register_copy 
    // outsw::@1
  __b1:
    // outw((unsigned int)sw)
    // [17] outw::w#1 = (unsigned int)outsw::sw#3
    // [18] call outw
    // [20] phi from outsw::@1 to outw [phi:outsw::@1->outw]
    // [20] phi idx#35 = idx#33 [phi:outsw::@1->outw#0] -- register_copy 
    // [20] phi outw::w#2 = outw::w#1 [phi:outsw::@1->outw#1] -- call_phi_near 
    jsr outw
    // outsw::@return
    // }
    // [19] return 
    rts
}
  // outw
// void outw(__zp(2) unsigned int w)
outw: {
    .label w = 2
    // BYTE1(w)
    // [21] outw::$0 = byte1  outw::w#2 -- vbuaa=_byte1_vwuz1 
    lda.z w+1
    // BYTE1(w)<<4
    // [22] outw::$1 = outw::$0 << 4 -- vbuaa=vbuaa_rol_4 
    asl
    asl
    asl
    asl
    // out(HEXTAB[BYTE1(w)<<4])
    // [23] out::c#1 = HEXTAB[outw::$1] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda HEXTAB,y
    // [24] call out
    // [38] phi from outw to out [phi:outw->out]
    // [38] phi out::c#5 = out::c#1 [phi:outw->out#0] -- register_copy 
    // [38] phi idx#27 = idx#35 [phi:outw->out#1] -- call_phi_near 
    jsr out
    // outw::@1
    // BYTE1(w)
    // [25] outw::$3 = byte1  outw::w#2 -- vbuaa=_byte1_vwuz1 
    lda.z w+1
    // BYTE1(w)&0x0f
    // [26] outw::$4 = outw::$3 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // out(HEXTAB[BYTE1(w)&0x0f])
    // [27] out::c#2 = HEXTAB[outw::$4] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda HEXTAB,y
    // [28] call out
    // [38] phi from outw::@1 to out [phi:outw::@1->out]
    // [38] phi out::c#5 = out::c#2 [phi:outw::@1->out#0] -- register_copy 
    // [38] phi idx#27 = idx#11 [phi:outw::@1->out#1] -- call_phi_near 
    jsr out
    // outw::@2
    // BYTE0(w)
    // [29] outw::$6 = byte0  outw::w#2 -- vbuaa=_byte0_vwuz1 
    lda.z w
    // BYTE0(w)<<4
    // [30] outw::$7 = outw::$6 << 4 -- vbuaa=vbuaa_rol_4 
    asl
    asl
    asl
    asl
    // out(HEXTAB[BYTE0(w)<<4])
    // [31] out::c#3 = HEXTAB[outw::$7] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda HEXTAB,y
    // [32] call out
    // [38] phi from outw::@2 to out [phi:outw::@2->out]
    // [38] phi out::c#5 = out::c#3 [phi:outw::@2->out#0] -- register_copy 
    // [38] phi idx#27 = idx#11 [phi:outw::@2->out#1] -- call_phi_near 
    jsr out
    // outw::@3
    // BYTE0(w)
    // [33] outw::$9 = byte0  outw::w#2 -- vbuaa=_byte0_vwuz1 
    lda.z w
    // BYTE0(w)&0x0f
    // [34] outw::$10 = outw::$9 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // out(HEXTAB[BYTE0(w)&0x0f])
    // [35] out::c#4 = HEXTAB[outw::$10] -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda HEXTAB,y
    // [36] call out
    // [38] phi from outw::@3 to out [phi:outw::@3->out]
    // [38] phi out::c#5 = out::c#4 [phi:outw::@3->out#0] -- register_copy 
    // [38] phi idx#27 = idx#11 [phi:outw::@3->out#1] -- call_phi_near 
    jsr out
    // outw::@return
    // }
    // [37] return 
    rts
}
  // out
// void out(__register(A) char c)
out: {
    // idx++;
    // [39] idx#11 = ++ idx#27 -- vbuxx=_inc_vbuxx 
    inx
    // SCREEN[idx] = c
    // [40] SCREEN[idx#11] = out::c#5 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    // out::@return
    // }
    // [41] return 
    rts
}
  // File Data
.segment Data
  HEXTAB: .text "0123456789abcdef"
  .byte 0

