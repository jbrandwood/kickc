Inlined call vicSelectGfxBank::$0 = call toDd00 vicSelectGfxBank::gfx 
Inlined call call __init 

CONTROL FLOW GRAPH SSA

byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  keyboard_matrix_read::rowid#1 = phi( keyboard_key_pressed/keyboard_matrix_read::rowid#0 )
  *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_A) = keyboard_matrix_row_bitmask[keyboard_matrix_read::rowid#1]
  keyboard_matrix_read::$0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B)
  keyboard_matrix_read::row_pressed_bits#0 = keyboard_matrix_read::$0
  keyboard_matrix_read::return#0 = keyboard_matrix_read::row_pressed_bits#0
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  keyboard_matrix_read::return#3 = phi( keyboard_matrix_read/keyboard_matrix_read::return#0 )
  keyboard_matrix_read::return#1 = keyboard_matrix_read::return#3
  return 
  to:@return

byte keyboard_key_pressed(byte keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from menu::@2 menu::@3 menu::@4 pressed::@2
  keyboard_key_pressed::key#4 = phi( menu::@2/keyboard_key_pressed::key#0, menu::@3/keyboard_key_pressed::key#1, menu::@4/keyboard_key_pressed::key#2, pressed::@2/keyboard_key_pressed::key#3 )
  keyboard_key_pressed::$0 = keyboard_key_pressed::key#4 & 7
  keyboard_key_pressed::colidx#0 = keyboard_key_pressed::$0
  keyboard_key_pressed::$1 = keyboard_key_pressed::key#4 >> 3
  keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::$1
  keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0
  call keyboard_matrix_read 
  keyboard_matrix_read::return#2 = keyboard_matrix_read::return#1
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  keyboard_key_pressed::colidx#1 = phi( keyboard_key_pressed/keyboard_key_pressed::colidx#0 )
  keyboard_matrix_read::return#4 = phi( keyboard_key_pressed/keyboard_matrix_read::return#2 )
  keyboard_key_pressed::$2 = keyboard_matrix_read::return#4
  keyboard_key_pressed::$3 = keyboard_key_pressed::$2 & keyboard_matrix_col_bitmask[keyboard_key_pressed::colidx#1]
  keyboard_key_pressed::return#0 = keyboard_key_pressed::$3
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  keyboard_key_pressed::return#6 = phi( keyboard_key_pressed::@1/keyboard_key_pressed::return#0 )
  keyboard_key_pressed::return#1 = keyboard_key_pressed::return#6
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  *BORDER_COLOR = GREEN
  to:main::@1
main::@1: scope:[main]  from main main::@3
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  call menu 
  to:main::@3
main::@3: scope:[main]  from main::@2
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return

void menu()
menu: scope:[menu]  from main::@2
  to:menu::@1
menu::@1: scope:[menu]  from menu menu::@5
  if(true) goto menu::@2
  to:menu::@return
menu::@2: scope:[menu]  from menu::@1
  keyboard_key_pressed::key#0 = KEY_C
  call keyboard_key_pressed 
  keyboard_key_pressed::return#2 = keyboard_key_pressed::return#1
  to:menu::@9
menu::@9: scope:[menu]  from menu::@2
  keyboard_key_pressed::return#7 = phi( menu::@2/keyboard_key_pressed::return#2 )
  menu::$0 = keyboard_key_pressed::return#7
  menu::$1 = menu::$0 != 0
  menu::$2 = ! menu::$1
  if(menu::$2) goto menu::@3
  to:menu::@6
menu::@3: scope:[menu]  from menu::@9
  keyboard_key_pressed::key#1 = KEY_I
  call keyboard_key_pressed 
  keyboard_key_pressed::return#3 = keyboard_key_pressed::return#1
  to:menu::@10
menu::@10: scope:[menu]  from menu::@3
  keyboard_key_pressed::return#8 = phi( menu::@3/keyboard_key_pressed::return#3 )
  menu::$4 = keyboard_key_pressed::return#8
  menu::$5 = menu::$4 != 0
  menu::$6 = ! menu::$5
  if(menu::$6) goto menu::@4
  to:menu::@7
menu::@6: scope:[menu]  from menu::@9
  call pressed 
  to:menu::@11
menu::@11: scope:[menu]  from menu::@6
  to:menu::@return
menu::@return: scope:[menu]  from menu::@1 menu::@11 menu::@7 menu::@8
  return 
  to:@return
menu::@4: scope:[menu]  from menu::@10
  keyboard_key_pressed::key#2 = KEY_E
  call keyboard_key_pressed 
  keyboard_key_pressed::return#4 = keyboard_key_pressed::return#1
  to:menu::@12
menu::@12: scope:[menu]  from menu::@4
  keyboard_key_pressed::return#9 = phi( menu::@4/keyboard_key_pressed::return#4 )
  menu::$7 = keyboard_key_pressed::return#9
  menu::$8 = menu::$7 != 0
  menu::$9 = ! menu::$8
  if(menu::$9) goto menu::@5
  to:menu::@8
menu::@7: scope:[menu]  from menu::@10
  *BORDER_COLOR = RED
  asm { sei  }
  to:menu::@return
menu::@5: scope:[menu]  from menu::@12
  *SCREEN = ++ *SCREEN
  to:menu::@1
menu::@8: scope:[menu]  from menu::@12
  *BORDER_COLOR = GREEN
  asm { cli  }
  to:menu::@return

void pressed()
pressed: scope:[pressed]  from menu::@6
  *BG_COLOR = ++ *BG_COLOR
  to:pressed::@1
pressed::@1: scope:[pressed]  from pressed pressed::@3
  if(true) goto pressed::@2
  to:pressed::@return
pressed::@2: scope:[pressed]  from pressed::@1
  keyboard_key_pressed::key#3 = KEY_SPACE
  call keyboard_key_pressed 
  keyboard_key_pressed::return#5 = keyboard_key_pressed::return#1
  to:pressed::@3
pressed::@3: scope:[pressed]  from pressed::@2
  keyboard_key_pressed::return#10 = phi( pressed::@2/keyboard_key_pressed::return#5 )
  pressed::$1 = keyboard_key_pressed::return#10
  pressed::$2 = pressed::$1 != 0
  pressed::$3 = ! pressed::$2
  if(pressed::$3) goto pressed::@1
  to:pressed::@return
pressed::@return: scope:[pressed]  from pressed::@1 pressed::@3
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* const BG_COLOR = (byte*)$d021
constant byte* const BORDER_COLOR = (byte*)$d020
constant struct MOS6526_CIA* const CIA1 = (struct MOS6526_CIA*)$dc00
constant const byte GREEN = 5
constant const byte KEY_C = $14
constant const byte KEY_E = $e
constant const byte KEY_I = $21
constant const byte KEY_SPACE = $3c
constant byte OFFSET_STRUCT_MOS6526_CIA_PORT_A = 0
constant byte OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
constant const byte RED = 2
constant byte* SCREEN = (byte*)$400
void __start()
byte keyboard_key_pressed(byte keyboard_key_pressed::key)
number~ keyboard_key_pressed::$0
byte~ keyboard_key_pressed::$1
byte~ keyboard_key_pressed::$2
byte~ keyboard_key_pressed::$3
byte keyboard_key_pressed::colidx
byte keyboard_key_pressed::colidx#0
byte keyboard_key_pressed::colidx#1
byte keyboard_key_pressed::key
byte keyboard_key_pressed::key#0
byte keyboard_key_pressed::key#1
byte keyboard_key_pressed::key#2
byte keyboard_key_pressed::key#3
byte keyboard_key_pressed::key#4
byte keyboard_key_pressed::return
byte keyboard_key_pressed::return#0
byte keyboard_key_pressed::return#1
byte keyboard_key_pressed::return#10
byte keyboard_key_pressed::return#2
byte keyboard_key_pressed::return#3
byte keyboard_key_pressed::return#4
byte keyboard_key_pressed::return#5
byte keyboard_key_pressed::return#6
byte keyboard_key_pressed::return#7
byte keyboard_key_pressed::return#8
byte keyboard_key_pressed::return#9
byte keyboard_key_pressed::rowidx
byte keyboard_key_pressed::rowidx#0
constant byte* keyboard_matrix_col_bitmask[8]  = { 1, 2, 4, 8, $10, $20, $40, $80 }
byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
byte~ keyboard_matrix_read::$0
byte keyboard_matrix_read::return
byte keyboard_matrix_read::return#0
byte keyboard_matrix_read::return#1
byte keyboard_matrix_read::return#2
byte keyboard_matrix_read::return#3
byte keyboard_matrix_read::return#4
byte keyboard_matrix_read::row_pressed_bits
byte keyboard_matrix_read::row_pressed_bits#0
byte keyboard_matrix_read::rowid
byte keyboard_matrix_read::rowid#0
byte keyboard_matrix_read::rowid#1
constant byte* keyboard_matrix_row_bitmask[8]  = { $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f }
void main()
void menu()
byte~ menu::$0
bool~ menu::$1
bool~ menu::$2
byte~ menu::$4
bool~ menu::$5
bool~ menu::$6
byte~ menu::$7
bool~ menu::$8
bool~ menu::$9
void pressed()
byte~ pressed::$1
bool~ pressed::$2
bool~ pressed::$3

Adding number conversion cast (unumber) 7 in keyboard_key_pressed::$0 = keyboard_key_pressed::key#4 & 7
Adding number conversion cast (unumber) keyboard_key_pressed::$0 in keyboard_key_pressed::$0 = keyboard_key_pressed::key#4 & (unumber)7
Adding number conversion cast (unumber) 3 in keyboard_key_pressed::$1 = keyboard_key_pressed::key#4 >> 3
Adding number conversion cast (unumber) 0 in menu::$1 = menu::$0 != 0
Adding number conversion cast (unumber) 0 in menu::$5 = menu::$4 != 0
Adding number conversion cast (unumber) 0 in menu::$8 = menu::$7 != 0
Adding number conversion cast (unumber) 0 in pressed::$2 = pressed::$1 != 0
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53281
Simplifying constant pointer cast (struct MOS6526_CIA*) 56320
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 7
Simplifying constant integer cast 3
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in keyboard_key_pressed::$0 = keyboard_key_pressed::key#4 & 7
Inversing boolean not [34] menu::$2 = menu::$0 == 0 from [33] menu::$1 = menu::$0 != 0
Inversing boolean not [42] menu::$6 = menu::$4 == 0 from [41] menu::$5 = menu::$4 != 0
Inversing boolean not [52] menu::$9 = menu::$7 == 0 from [51] menu::$8 = menu::$7 != 0
Inversing boolean not [67] pressed::$3 = pressed::$1 == 0 from [66] pressed::$2 = pressed::$1 != 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias keyboard_matrix_read::return#0 = keyboard_matrix_read::row_pressed_bits#0 keyboard_matrix_read::$0 keyboard_matrix_read::return#3 keyboard_matrix_read::return#1 
Alias keyboard_key_pressed::colidx#0 = keyboard_key_pressed::$0 keyboard_key_pressed::colidx#1 
Alias keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::$1 
Alias keyboard_matrix_read::return#2 = keyboard_matrix_read::return#4 
Alias keyboard_key_pressed::return#0 = keyboard_key_pressed::$3 keyboard_key_pressed::return#6 keyboard_key_pressed::return#1 
Alias keyboard_key_pressed::return#2 = keyboard_key_pressed::return#7 
Alias keyboard_key_pressed::return#3 = keyboard_key_pressed::return#8 
Alias keyboard_key_pressed::return#4 = keyboard_key_pressed::return#9 
Alias keyboard_key_pressed::return#10 = keyboard_key_pressed::return#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values keyboard_matrix_read::rowid#1 keyboard_matrix_read::rowid#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition menu::$2 [23] if(menu::$0==0) goto menu::@3
Simple Condition menu::$6 [29] if(menu::$4==0) goto menu::@4
Simple Condition menu::$9 [37] if(menu::$7==0) goto menu::@5
Simple Condition pressed::$3 [50] if(pressed::$1==0) goto pressed::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [50] if(pressed::$1!=0) goto pressed::@return
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant keyboard_key_pressed::key#0 = KEY_C
Constant keyboard_key_pressed::key#1 = KEY_I
Constant keyboard_key_pressed::key#2 = KEY_E
Constant keyboard_key_pressed::key#3 = KEY_SPACE
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [14] if(true) goto main::@2
if() condition always true - replacing block destination [17] if(true) goto menu::@2
if() condition always true - replacing block destination [44] if(true) goto pressed::@2
Successful SSA optimization Pass2ConstantIfs
Simplifying expression containing zero (byte*)CIA1 in [1] *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_A) = keyboard_matrix_row_bitmask[keyboard_matrix_read::rowid#0]
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused constant OFFSET_STRUCT_MOS6526_CIA_PORT_A
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings keyboard_key_pressed::key#0
Inlining constant with var siblings keyboard_key_pressed::key#1
Inlining constant with var siblings keyboard_key_pressed::key#2
Inlining constant with var siblings keyboard_key_pressed::key#3
Constant inlined keyboard_key_pressed::key#0 = KEY_C
Constant inlined keyboard_key_pressed::key#1 = KEY_I
Constant inlined keyboard_key_pressed::key#2 = KEY_E
Constant inlined keyboard_key_pressed::key#3 = KEY_SPACE
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of menu
Adding NOP phi() at start of menu::@1
Adding NOP phi() at start of menu::@2
Adding NOP phi() at start of menu::@6
Adding NOP phi() at start of menu::@11
Adding NOP phi() at start of menu::@3
Adding NOP phi() at start of menu::@4
Adding NOP phi() at start of pressed::@1
Adding NOP phi() at start of pressed::@2
CALL GRAPH
Calls in [main] to menu:3 
Calls in [menu] to keyboard_key_pressed:8 pressed:13 keyboard_key_pressed:17 keyboard_key_pressed:24 
Calls in [keyboard_key_pressed] to keyboard_matrix_read:35 
Calls in [pressed] to keyboard_key_pressed:43 

Created 1 initial phi equivalence classes
Coalesced down to 1 phi equivalence classes
Culled Empty Block label main::@1
Culled Empty Block label main::@3
Culled Empty Block label menu::@1
Culled Empty Block label menu::@11
Culled Empty Block label pressed::@1
Renumbering block main::@2 to main::@1
Renumbering block menu::@2 to menu::@1
Renumbering block menu::@3 to menu::@2
Renumbering block menu::@4 to menu::@3
Renumbering block menu::@5 to menu::@4
Renumbering block menu::@6 to menu::@5
Renumbering block menu::@7 to menu::@6
Renumbering block menu::@8 to menu::@7
Renumbering block menu::@9 to menu::@8
Renumbering block menu::@10 to menu::@9
Renumbering block menu::@12 to menu::@10
Renumbering block pressed::@2 to pressed::@1
Renumbering block pressed::@3 to pressed::@2
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of menu
Adding NOP phi() at start of menu::@1
Adding NOP phi() at start of menu::@5
Adding NOP phi() at start of menu::@2
Adding NOP phi() at start of menu::@3
Adding NOP phi() at start of pressed::@1

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] *BORDER_COLOR = GREEN
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [1] phi()
  [2] call menu 
  to:main::@1

void menu()
menu: scope:[menu]  from main::@1
  [3] phi()
  to:menu::@1
menu::@1: scope:[menu]  from menu menu::@4
  [4] phi()
  [5] call keyboard_key_pressed 
  [6] keyboard_key_pressed::return#2 = keyboard_key_pressed::return#0
  to:menu::@8
menu::@8: scope:[menu]  from menu::@1
  [7] menu::$0 = keyboard_key_pressed::return#2
  [8] if(menu::$0==0) goto menu::@2
  to:menu::@5
menu::@5: scope:[menu]  from menu::@8
  [9] phi()
  [10] call pressed 
  to:menu::@return
menu::@return: scope:[menu]  from menu::@5 menu::@6 menu::@7
  [11] return 
  to:@return
menu::@2: scope:[menu]  from menu::@8
  [12] phi()
  [13] call keyboard_key_pressed 
  [14] keyboard_key_pressed::return#3 = keyboard_key_pressed::return#0
  to:menu::@9
menu::@9: scope:[menu]  from menu::@2
  [15] menu::$4 = keyboard_key_pressed::return#3
  [16] if(menu::$4==0) goto menu::@3
  to:menu::@6
menu::@6: scope:[menu]  from menu::@9
  [17] *BORDER_COLOR = RED
  asm { sei  }
  to:menu::@return
menu::@3: scope:[menu]  from menu::@9
  [19] phi()
  [20] call keyboard_key_pressed 
  [21] keyboard_key_pressed::return#4 = keyboard_key_pressed::return#0
  to:menu::@10
menu::@10: scope:[menu]  from menu::@3
  [22] menu::$7 = keyboard_key_pressed::return#4
  [23] if(menu::$7==0) goto menu::@4
  to:menu::@7
menu::@7: scope:[menu]  from menu::@10
  [24] *BORDER_COLOR = GREEN
  asm { cli  }
  to:menu::@return
menu::@4: scope:[menu]  from menu::@10
  [26] *SCREEN = ++ *SCREEN
  to:menu::@1

byte keyboard_key_pressed(byte keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from menu::@1 menu::@2 menu::@3 pressed::@1
  [27] keyboard_key_pressed::key#4 = phi( menu::@1/KEY_C, menu::@2/KEY_I, menu::@3/KEY_E, pressed::@1/KEY_SPACE )
  [28] keyboard_key_pressed::colidx#0 = keyboard_key_pressed::key#4 & 7
  [29] keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::key#4 >> 3
  [30] keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0
  [31] call keyboard_matrix_read 
  [32] keyboard_matrix_read::return#2 = keyboard_matrix_read::return#0
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  [33] keyboard_key_pressed::$2 = keyboard_matrix_read::return#2
  [34] keyboard_key_pressed::return#0 = keyboard_key_pressed::$2 & keyboard_matrix_col_bitmask[keyboard_key_pressed::colidx#0]
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  [35] return 
  to:@return

void pressed()
pressed: scope:[pressed]  from menu::@5
  [36] *BG_COLOR = ++ *BG_COLOR
  to:pressed::@1
pressed::@1: scope:[pressed]  from pressed pressed::@2
  [37] phi()
  [38] call keyboard_key_pressed 
  [39] keyboard_key_pressed::return#10 = keyboard_key_pressed::return#0
  to:pressed::@2
pressed::@2: scope:[pressed]  from pressed::@1
  [40] pressed::$1 = keyboard_key_pressed::return#10
  [41] if(pressed::$1!=0) goto pressed::@return
  to:pressed::@1
pressed::@return: scope:[pressed]  from pressed::@2
  [42] return 
  to:@return

byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  [43] *((byte*)CIA1) = keyboard_matrix_row_bitmask[keyboard_matrix_read::rowid#0]
  [44] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B)
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  [45] return 
  to:@return

null depth in calling loop Loop head: pressed::@1 tails: pressed::@2 blocks: pressed::@2 pressed::@1  in scope keyboard_key_pressed

VARIABLE REGISTER WEIGHTS
byte keyboard_key_pressed(byte keyboard_key_pressed::key)
byte~ keyboard_key_pressed::$2 2000002.0
byte keyboard_key_pressed::colidx
byte keyboard_key_pressed::colidx#0 333333.6666666667
byte keyboard_key_pressed::key
byte keyboard_key_pressed::key#4 1000001.0
byte keyboard_key_pressed::return
byte keyboard_key_pressed::return#0 188334.1666666667
byte keyboard_key_pressed::return#10 200002.0
byte keyboard_key_pressed::return#2 20002.0
byte keyboard_key_pressed::return#3 20002.0
byte keyboard_key_pressed::return#4 20002.0
byte keyboard_key_pressed::rowidx
byte keyboard_key_pressed::rowidx#0 2000002.0
byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
byte keyboard_matrix_read::return
byte keyboard_matrix_read::return#0 3666667.333333333
byte keyboard_matrix_read::return#2 2000002.0
byte keyboard_matrix_read::row_pressed_bits
byte keyboard_matrix_read::rowid
byte keyboard_matrix_read::rowid#0 1.1000002E7
void main()
void menu()
byte~ menu::$0 20002.0
byte~ menu::$4 20002.0
byte~ menu::$7 20002.0
void pressed()
byte~ pressed::$1 200002.0

Initial phi equivalence classes
[ keyboard_key_pressed::key#4 ]
Added variable keyboard_key_pressed::return#2 to live range equivalence class [ keyboard_key_pressed::return#2 ]
Added variable menu::$0 to live range equivalence class [ menu::$0 ]
Added variable keyboard_key_pressed::return#3 to live range equivalence class [ keyboard_key_pressed::return#3 ]
Added variable menu::$4 to live range equivalence class [ menu::$4 ]
Added variable keyboard_key_pressed::return#4 to live range equivalence class [ keyboard_key_pressed::return#4 ]
Added variable menu::$7 to live range equivalence class [ menu::$7 ]
Added variable keyboard_key_pressed::colidx#0 to live range equivalence class [ keyboard_key_pressed::colidx#0 ]
Added variable keyboard_key_pressed::rowidx#0 to live range equivalence class [ keyboard_key_pressed::rowidx#0 ]
Added variable keyboard_matrix_read::rowid#0 to live range equivalence class [ keyboard_matrix_read::rowid#0 ]
Added variable keyboard_matrix_read::return#2 to live range equivalence class [ keyboard_matrix_read::return#2 ]
Added variable keyboard_key_pressed::$2 to live range equivalence class [ keyboard_key_pressed::$2 ]
Added variable keyboard_key_pressed::return#0 to live range equivalence class [ keyboard_key_pressed::return#0 ]
Added variable keyboard_key_pressed::return#10 to live range equivalence class [ keyboard_key_pressed::return#10 ]
Added variable pressed::$1 to live range equivalence class [ pressed::$1 ]
Added variable keyboard_matrix_read::return#0 to live range equivalence class [ keyboard_matrix_read::return#0 ]
Complete equivalence classes
[ keyboard_key_pressed::key#4 ]
[ keyboard_key_pressed::return#2 ]
[ menu::$0 ]
[ keyboard_key_pressed::return#3 ]
[ menu::$4 ]
[ keyboard_key_pressed::return#4 ]
[ menu::$7 ]
[ keyboard_key_pressed::colidx#0 ]
[ keyboard_key_pressed::rowidx#0 ]
[ keyboard_matrix_read::rowid#0 ]
[ keyboard_matrix_read::return#2 ]
[ keyboard_key_pressed::$2 ]
[ keyboard_key_pressed::return#0 ]
[ keyboard_key_pressed::return#10 ]
[ pressed::$1 ]
[ keyboard_matrix_read::return#0 ]
Allocated zp[1]:2 [ keyboard_key_pressed::key#4 ]
Allocated zp[1]:3 [ keyboard_key_pressed::return#2 ]
Allocated zp[1]:4 [ menu::$0 ]
Allocated zp[1]:5 [ keyboard_key_pressed::return#3 ]
Allocated zp[1]:6 [ menu::$4 ]
Allocated zp[1]:7 [ keyboard_key_pressed::return#4 ]
Allocated zp[1]:8 [ menu::$7 ]
Allocated zp[1]:9 [ keyboard_key_pressed::colidx#0 ]
Allocated zp[1]:10 [ keyboard_key_pressed::rowidx#0 ]
Allocated zp[1]:11 [ keyboard_matrix_read::rowid#0 ]
Allocated zp[1]:12 [ keyboard_matrix_read::return#2 ]
Allocated zp[1]:13 [ keyboard_key_pressed::$2 ]
Allocated zp[1]:14 [ keyboard_key_pressed::return#0 ]
Allocated zp[1]:15 [ keyboard_key_pressed::return#10 ]
Allocated zp[1]:16 [ pressed::$1 ]
Allocated zp[1]:17 [ keyboard_matrix_read::return#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] *BORDER_COLOR = GREEN [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [17] *BORDER_COLOR = RED [ ] ( menu:2 [ ] { }  ) always clobbers reg byte a 
Statement [24] *BORDER_COLOR = GREEN [ ] ( menu:2 [ ] { }  ) always clobbers reg byte a 
Statement [29] keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::key#4 >> 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( menu:2::keyboard_key_pressed:5 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:13 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:20 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#4 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::pressed:10::keyboard_key_pressed:38 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#10 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:9 [ keyboard_key_pressed::colidx#0 ]
Statement [43] *((byte*)CIA1) = keyboard_matrix_row_bitmask[keyboard_matrix_read::rowid#0] [ ] ( menu:2::keyboard_key_pressed:5::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:13::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:20::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#4 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::pressed:10::keyboard_key_pressed:38::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#10 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [44] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B) [ keyboard_matrix_read::return#0 ] ( menu:2::keyboard_key_pressed:5::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:13::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:20::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#4 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::pressed:10::keyboard_key_pressed:38::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#10 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [0] *BORDER_COLOR = GREEN [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [17] *BORDER_COLOR = RED [ ] ( menu:2 [ ] { }  ) always clobbers reg byte a 
Statement [24] *BORDER_COLOR = GREEN [ ] ( menu:2 [ ] { }  ) always clobbers reg byte a 
Statement [29] keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::key#4 >> 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( menu:2::keyboard_key_pressed:5 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:13 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:20 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#4 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::pressed:10::keyboard_key_pressed:38 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#10 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [43] *((byte*)CIA1) = keyboard_matrix_row_bitmask[keyboard_matrix_read::rowid#0] [ ] ( menu:2::keyboard_key_pressed:5::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:13::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:20::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#4 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::pressed:10::keyboard_key_pressed:38::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#10 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [44] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B) [ keyboard_matrix_read::return#0 ] ( menu:2::keyboard_key_pressed:5::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:13::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::keyboard_key_pressed:20::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#4 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  menu:2::pressed:10::keyboard_key_pressed:38::keyboard_matrix_read:31 [ keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#10 } { keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ keyboard_key_pressed::key#4 ] : zp[1]:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ keyboard_key_pressed::return#2 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ menu::$0 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ keyboard_key_pressed::return#3 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ menu::$4 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ keyboard_key_pressed::return#4 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ menu::$7 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ keyboard_key_pressed::colidx#0 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ keyboard_key_pressed::rowidx#0 ] : zp[1]:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ keyboard_matrix_read::rowid#0 ] : zp[1]:11 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:12 [ keyboard_matrix_read::return#2 ] : zp[1]:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ keyboard_key_pressed::$2 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ keyboard_key_pressed::return#0 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ keyboard_key_pressed::return#10 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ pressed::$1 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ keyboard_matrix_read::return#0 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [keyboard_matrix_read] 11,000,002: zp[1]:11 [ keyboard_matrix_read::rowid#0 ] 3,666,667.33: zp[1]:17 [ keyboard_matrix_read::return#0 ] 2,000,002: zp[1]:12 [ keyboard_matrix_read::return#2 ] 
Uplift Scope [keyboard_key_pressed] 2,000,002: zp[1]:10 [ keyboard_key_pressed::rowidx#0 ] 2,000,002: zp[1]:13 [ keyboard_key_pressed::$2 ] 1,000,001: zp[1]:2 [ keyboard_key_pressed::key#4 ] 333,333.67: zp[1]:9 [ keyboard_key_pressed::colidx#0 ] 200,002: zp[1]:15 [ keyboard_key_pressed::return#10 ] 188,334.17: zp[1]:14 [ keyboard_key_pressed::return#0 ] 20,002: zp[1]:3 [ keyboard_key_pressed::return#2 ] 20,002: zp[1]:5 [ keyboard_key_pressed::return#3 ] 20,002: zp[1]:7 [ keyboard_key_pressed::return#4 ] 
Uplift Scope [pressed] 200,002: zp[1]:16 [ pressed::$1 ] 
Uplift Scope [menu] 20,002: zp[1]:4 [ menu::$0 ] 20,002: zp[1]:6 [ menu::$4 ] 20,002: zp[1]:8 [ menu::$7 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [keyboard_matrix_read] best 11421 combination reg byte x [ keyboard_matrix_read::rowid#0 ] reg byte a [ keyboard_matrix_read::return#0 ] reg byte a [ keyboard_matrix_read::return#2 ] 
Uplifting [keyboard_key_pressed] best 11395 combination reg byte a [ keyboard_key_pressed::rowidx#0 ] reg byte a [ keyboard_key_pressed::$2 ] reg byte x [ keyboard_key_pressed::key#4 ] zp[1]:9 [ keyboard_key_pressed::colidx#0 ] zp[1]:15 [ keyboard_key_pressed::return#10 ] zp[1]:14 [ keyboard_key_pressed::return#0 ] zp[1]:3 [ keyboard_key_pressed::return#2 ] zp[1]:5 [ keyboard_key_pressed::return#3 ] zp[1]:7 [ keyboard_key_pressed::return#4 ] 
Limited combination testing to 100 combinations of 196608 possible.
Uplifting [pressed] best 10995 combination reg byte a [ pressed::$1 ] 
Uplifting [menu] best 9795 combination reg byte a [ menu::$0 ] reg byte a [ menu::$4 ] reg byte a [ menu::$7 ] 
Uplifting [MOS6526_CIA] best 9795 combination 
Uplifting [MOS6569_VICII] best 9795 combination 
Uplifting [MOS6581_SID] best 9795 combination 
Uplifting [main] best 9795 combination 
Uplifting [] best 9795 combination 
Attempting to uplift remaining variables inzp[1]:9 [ keyboard_key_pressed::colidx#0 ]
Uplifting [keyboard_key_pressed] best 9793 combination reg byte y [ keyboard_key_pressed::colidx#0 ] 
Attempting to uplift remaining variables inzp[1]:15 [ keyboard_key_pressed::return#10 ]
Uplifting [keyboard_key_pressed] best 9193 combination reg byte a [ keyboard_key_pressed::return#10 ] 
Attempting to uplift remaining variables inzp[1]:14 [ keyboard_key_pressed::return#0 ]
Uplifting [keyboard_key_pressed] best 7990 combination reg byte a [ keyboard_key_pressed::return#0 ] 
Attempting to uplift remaining variables inzp[1]:3 [ keyboard_key_pressed::return#2 ]
Uplifting [keyboard_key_pressed] best 7390 combination reg byte a [ keyboard_key_pressed::return#2 ] 
Attempting to uplift remaining variables inzp[1]:5 [ keyboard_key_pressed::return#3 ]
Uplifting [keyboard_key_pressed] best 6790 combination reg byte a [ keyboard_key_pressed::return#3 ] 
Attempting to uplift remaining variables inzp[1]:7 [ keyboard_key_pressed::return#4 ]
Uplifting [keyboard_key_pressed] best 6190 combination reg byte a [ keyboard_key_pressed::return#4 ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Exploring keyboard glitch that finds "C" press when pressing space
// The glitch is caused by the "normal" C64 interrupt occuring just as the keyboard is read.
// Press "I" to disable interrupts (red border)
// Press "E" to enable interrupts (green border)
// Press "C" to enter pressed state (increaded BG_COLOR) - and "SPACE" to leave presssed state again.
// Holding SPACE will sometimes trigger the pressed state when normal interrupts are enabled (green border)
// but never when they are disabled (red border)
/// @file
/// Simple Keyboard Input Library
///
/// C64 Keyboard Matrix Reference - from http://codebase64.org/doku.php?id=base:reading_the_keyboard
/// Keyboard Codes are %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
/// +----+----------------------+-------------------------------------------------------------------------------------------------------+
/// |    | Write                |                                Read $dc01 (C64 screen code in parenthesis):                              |
/// |row:| $dc00: row bits      +------------+------------+------------+------------+------------+------------+------------+------------+
/// |    |                      |   BIT 7    |   BIT 6    |   BIT 5    |   BIT 4    |   BIT 3    |   BIT 2    |   BIT 1    |   BIT 0    |
/// +----+----------------------+------------+------------+------------+------------+------------+------------+------------+------------+
/// |0.  | #%11111110 (254/$fe) | DOWN  ($  )|   F5  ($  )|   F3  ($  )|   F1  ($  )|   F7  ($  )| RIGHT ($  )| RETURN($  )|DELETE ($  )|
/// |1.  | #%11111101 (253/$fd) |LEFT-SH($  )|   e   ($05)|   s   ($13)|   z   ($1a)|   4   ($34)|   a   ($01)|   w   ($17)|   3   ($33)|
/// |2.  | #%11111011 (251/$fb) |   x   ($18)|   t   ($14)|   f   ($06)|   c   ($03)|   6   ($36)|   d   ($04)|   r   ($12)|   5   ($35)|
/// |3.  | #%11110111 (247/$f7) |   v   ($16)|   u   ($15)|   h   ($08)|   b   ($02)|   8   ($38)|   g   ($07)|   y   ($19)|   7   ($37)|
/// |4.  | #%11101111 (239/$ef) |   n   ($0e)|   o   ($0f)|   k   ($0b)|   m   ($0d)|   0   ($30)|   j   ($0a)|   i   ($09)|   9   ($39)|
/// |5.  | #%11011111 (223/$df) |   ,   ($2c)|   @   ($00)|   :   ($3a)|   .   ($2e)|   -   ($2d)|   l   ($0c)|   p   ($10)|   +   ($2b)|
/// |6.  | #%10111111 (191/$bf) |   /   ($2f)|   ^   ($1e)|   =   ($3d)|RGHT-SH($  )|  HOME ($  )|   ;   ($3b)|   *   ($2a)|   Â£   ($1c)|
/// |7.  | #%01111111 (127/$7f) | STOP  ($  )|   q   ($11)|COMMODR($  )| SPACE ($20)|   2   ($32)|CONTROL($  )|  <-   ($1f)|   1   ($31)|
/// +----+----------------------+------------+------------+------------+------------+------------+------------+------------+------------+
  // Upstart
  // Commodore 64 PRG executable file
.file [name="keyboard-glitch.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const KEY_E = $e
  .const KEY_C = $14
  .const KEY_I = $21
  .const KEY_SPACE = $3c
  .const RED = 2
  .const GREEN = 5
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
  .label BORDER_COLOR = $d020
  .label BG_COLOR = $d021
  /// The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  .label SCREEN = $400
.segment Code
  // main
main: {
    // [0] *BORDER_COLOR = GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDER_COLOR
    // [1] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
  __b1_from_main:
  __b1_from___b1:
    jmp __b1
    // main::@1
  __b1:
    // [2] call menu 
    // [3] phi from main::@1 to menu [phi:main::@1->menu]
  menu_from___b1:
    jsr menu
    jmp __b1_from___b1
}
  // menu
menu: {
    // [4] phi from menu menu::@4 to menu::@1 [phi:menu/menu::@4->menu::@1]
  __b1_from_menu:
  __b1_from___b4:
    jmp __b1
    // menu::@1
  __b1:
    // [5] call keyboard_key_pressed 
    // [27] phi from menu::@1 to keyboard_key_pressed [phi:menu::@1->keyboard_key_pressed]
  keyboard_key_pressed_from___b1:
    // [27] phi keyboard_key_pressed::key#4 = KEY_C [phi:menu::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_C
    jsr keyboard_key_pressed
    // [6] keyboard_key_pressed::return#2 = keyboard_key_pressed::return#0
    jmp __b8
    // menu::@8
  __b8:
    // [7] menu::$0 = keyboard_key_pressed::return#2
    // [8] if(menu::$0==0) goto menu::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2_from___b8
    // [9] phi from menu::@8 to menu::@5 [phi:menu::@8->menu::@5]
  __b5_from___b8:
    jmp __b5
    // menu::@5
  __b5:
    // [10] call pressed 
    jsr pressed
    jmp __breturn
    // menu::@return
  __breturn:
    // [11] return 
    rts
    // [12] phi from menu::@8 to menu::@2 [phi:menu::@8->menu::@2]
  __b2_from___b8:
    jmp __b2
    // menu::@2
  __b2:
    // [13] call keyboard_key_pressed 
    // [27] phi from menu::@2 to keyboard_key_pressed [phi:menu::@2->keyboard_key_pressed]
  keyboard_key_pressed_from___b2:
    // [27] phi keyboard_key_pressed::key#4 = KEY_I [phi:menu::@2->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_I
    jsr keyboard_key_pressed
    // [14] keyboard_key_pressed::return#3 = keyboard_key_pressed::return#0
    jmp __b9
    // menu::@9
  __b9:
    // [15] menu::$4 = keyboard_key_pressed::return#3
    // [16] if(menu::$4==0) goto menu::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3_from___b9
    jmp __b6
    // menu::@6
  __b6:
    // [17] *BORDER_COLOR = RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDER_COLOR
    // asm { sei  }
    sei
    jmp __breturn
    // [19] phi from menu::@9 to menu::@3 [phi:menu::@9->menu::@3]
  __b3_from___b9:
    jmp __b3
    // menu::@3
  __b3:
    // [20] call keyboard_key_pressed 
    // [27] phi from menu::@3 to keyboard_key_pressed [phi:menu::@3->keyboard_key_pressed]
  keyboard_key_pressed_from___b3:
    // [27] phi keyboard_key_pressed::key#4 = KEY_E [phi:menu::@3->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_E
    jsr keyboard_key_pressed
    // [21] keyboard_key_pressed::return#4 = keyboard_key_pressed::return#0
    jmp __b10
    // menu::@10
  __b10:
    // [22] menu::$7 = keyboard_key_pressed::return#4
    // [23] if(menu::$7==0) goto menu::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    jmp __b7
    // menu::@7
  __b7:
    // [24] *BORDER_COLOR = GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDER_COLOR
    // asm { cli  }
    cli
    jmp __breturn
    // menu::@4
  __b4:
    // [26] *SCREEN = ++ *SCREEN -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN
    jmp __b1_from___b4
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(X) key)
keyboard_key_pressed: {
    // [28] keyboard_key_pressed::colidx#0 = keyboard_key_pressed::key#4 & 7 -- vbuyy=vbuxx_band_vbuc1 
    txa
    and #7
    tay
    // [29] keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::key#4 >> 3 -- vbuaa=vbuxx_ror_3 
    txa
    lsr
    lsr
    lsr
    // [30] keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 -- vbuxx=vbuaa 
    tax
    // [31] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [32] keyboard_matrix_read::return#2 = keyboard_matrix_read::return#0
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [33] keyboard_key_pressed::$2 = keyboard_matrix_read::return#2
    // [34] keyboard_key_pressed::return#0 = keyboard_key_pressed::$2 & keyboard_matrix_col_bitmask[keyboard_key_pressed::colidx#0] -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuyy 
    and keyboard_matrix_col_bitmask,y
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [35] return 
    rts
}
  // pressed
pressed: {
    // [36] *BG_COLOR = ++ *BG_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BG_COLOR
    // [37] phi from pressed pressed::@2 to pressed::@1 [phi:pressed/pressed::@2->pressed::@1]
  __b1_from_pressed:
  __b1_from___b2:
    jmp __b1
    // pressed::@1
  __b1:
    // [38] call keyboard_key_pressed 
    // [27] phi from pressed::@1 to keyboard_key_pressed [phi:pressed::@1->keyboard_key_pressed]
  keyboard_key_pressed_from___b1:
    // [27] phi keyboard_key_pressed::key#4 = KEY_SPACE [phi:pressed::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_SPACE
    jsr keyboard_key_pressed
    // [39] keyboard_key_pressed::return#10 = keyboard_key_pressed::return#0
    jmp __b2
    // pressed::@2
  __b2:
    // [40] pressed::$1 = keyboard_key_pressed::return#10
    // [41] if(pressed::$1!=0) goto pressed::@return -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __breturn
    jmp __b1_from___b2
    // pressed::@return
  __breturn:
    // [42] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(X) rowid)
keyboard_matrix_read: {
    // [43] *((byte*)CIA1) = keyboard_matrix_row_bitmask[keyboard_matrix_read::rowid#0] -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda keyboard_matrix_row_bitmask,x
    sta CIA1
    // [44] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B
    eor #$ff
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [45] return 
    rts
}
  // File Data
.segment Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b8
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __b2
Removing instruction jmp __b9
Removing instruction jmp __b6
Removing instruction jmp __b3
Removing instruction jmp __b10
Removing instruction jmp __b7
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b1 with __b1
Replacing label __b2_from___b8 with __b2
Replacing label __b3_from___b9 with __b3
Replacing label __b1_from___b4 with __b1
Replacing label __b1_from___b2 with __b1
Removing instruction __b1_from_main:
Removing instruction __b1_from___b1:
Removing instruction menu_from___b1:
Removing instruction __b1_from_menu:
Removing instruction __b1_from___b4:
Removing instruction keyboard_key_pressed_from___b1:
Removing instruction __b5_from___b8:
Removing instruction __b2_from___b8:
Removing instruction keyboard_key_pressed_from___b2:
Removing instruction __b3_from___b9:
Removing instruction keyboard_key_pressed_from___b3:
Removing instruction __b1_from_pressed:
Removing instruction __b1_from___b2:
Removing instruction keyboard_key_pressed_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b8:
Removing instruction __b5:
Removing instruction __b9:
Removing instruction __b6:
Removing instruction __b10:
Removing instruction __b7:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b2:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Replacing jump to rts with rts in jmp __breturn
Replacing jump to rts with rts in jmp __breturn
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
constant byte* const BG_COLOR = (byte*) 53281
constant byte* const BORDER_COLOR = (byte*) 53280
constant struct MOS6526_CIA* const CIA1 = (struct MOS6526_CIA*) 56320
constant const byte GREEN = 5
constant const byte KEY_C = $14
constant const byte KEY_E = $e
constant const byte KEY_I = $21
constant const byte KEY_SPACE = $3c
constant byte OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
constant const byte RED = 2
constant byte* SCREEN = (byte*) 1024
byte keyboard_key_pressed(byte keyboard_key_pressed::key)
byte~ keyboard_key_pressed::$2 reg byte a 2000002.0
byte keyboard_key_pressed::colidx
byte keyboard_key_pressed::colidx#0 reg byte y 333333.6666666667
byte keyboard_key_pressed::key
byte keyboard_key_pressed::key#4 reg byte x 1000001.0
byte keyboard_key_pressed::return
byte keyboard_key_pressed::return#0 reg byte a 188334.1666666667
byte keyboard_key_pressed::return#10 reg byte a 200002.0
byte keyboard_key_pressed::return#2 reg byte a 20002.0
byte keyboard_key_pressed::return#3 reg byte a 20002.0
byte keyboard_key_pressed::return#4 reg byte a 20002.0
byte keyboard_key_pressed::rowidx
byte keyboard_key_pressed::rowidx#0 reg byte a 2000002.0
constant byte* keyboard_matrix_col_bitmask[8]  = { 1, 2, 4, 8, $10, $20, $40, $80 }
byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
byte keyboard_matrix_read::return
byte keyboard_matrix_read::return#0 reg byte a 3666667.333333333
byte keyboard_matrix_read::return#2 reg byte a 2000002.0
byte keyboard_matrix_read::row_pressed_bits
byte keyboard_matrix_read::rowid
byte keyboard_matrix_read::rowid#0 reg byte x 1.1000002E7
constant byte* keyboard_matrix_row_bitmask[8]  = { $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f }
void main()
void menu()
byte~ menu::$0 reg byte a 20002.0
byte~ menu::$4 reg byte a 20002.0
byte~ menu::$7 reg byte a 20002.0
void pressed()
byte~ pressed::$1 reg byte a 200002.0

reg byte x [ keyboard_key_pressed::key#4 ]
reg byte a [ keyboard_key_pressed::return#2 ]
reg byte a [ menu::$0 ]
reg byte a [ keyboard_key_pressed::return#3 ]
reg byte a [ menu::$4 ]
reg byte a [ keyboard_key_pressed::return#4 ]
reg byte a [ menu::$7 ]
reg byte y [ keyboard_key_pressed::colidx#0 ]
reg byte a [ keyboard_key_pressed::rowidx#0 ]
reg byte x [ keyboard_matrix_read::rowid#0 ]
reg byte a [ keyboard_matrix_read::return#2 ]
reg byte a [ keyboard_key_pressed::$2 ]
reg byte a [ keyboard_key_pressed::return#0 ]
reg byte a [ keyboard_key_pressed::return#10 ]
reg byte a [ pressed::$1 ]
reg byte a [ keyboard_matrix_read::return#0 ]


FINAL ASSEMBLER
Score: 3151

  // File Comments
// Exploring keyboard glitch that finds "C" press when pressing space
// The glitch is caused by the "normal" C64 interrupt occuring just as the keyboard is read.
// Press "I" to disable interrupts (red border)
// Press "E" to enable interrupts (green border)
// Press "C" to enter pressed state (increaded BG_COLOR) - and "SPACE" to leave presssed state again.
// Holding SPACE will sometimes trigger the pressed state when normal interrupts are enabled (green border)
// but never when they are disabled (red border)
/// @file
/// Simple Keyboard Input Library
///
/// C64 Keyboard Matrix Reference - from http://codebase64.org/doku.php?id=base:reading_the_keyboard
/// Keyboard Codes are %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
/// +----+----------------------+-------------------------------------------------------------------------------------------------------+
/// |    | Write                |                                Read $dc01 (C64 screen code in parenthesis):                              |
/// |row:| $dc00: row bits      +------------+------------+------------+------------+------------+------------+------------+------------+
/// |    |                      |   BIT 7    |   BIT 6    |   BIT 5    |   BIT 4    |   BIT 3    |   BIT 2    |   BIT 1    |   BIT 0    |
/// +----+----------------------+------------+------------+------------+------------+------------+------------+------------+------------+
/// |0.  | #%11111110 (254/$fe) | DOWN  ($  )|   F5  ($  )|   F3  ($  )|   F1  ($  )|   F7  ($  )| RIGHT ($  )| RETURN($  )|DELETE ($  )|
/// |1.  | #%11111101 (253/$fd) |LEFT-SH($  )|   e   ($05)|   s   ($13)|   z   ($1a)|   4   ($34)|   a   ($01)|   w   ($17)|   3   ($33)|
/// |2.  | #%11111011 (251/$fb) |   x   ($18)|   t   ($14)|   f   ($06)|   c   ($03)|   6   ($36)|   d   ($04)|   r   ($12)|   5   ($35)|
/// |3.  | #%11110111 (247/$f7) |   v   ($16)|   u   ($15)|   h   ($08)|   b   ($02)|   8   ($38)|   g   ($07)|   y   ($19)|   7   ($37)|
/// |4.  | #%11101111 (239/$ef) |   n   ($0e)|   o   ($0f)|   k   ($0b)|   m   ($0d)|   0   ($30)|   j   ($0a)|   i   ($09)|   9   ($39)|
/// |5.  | #%11011111 (223/$df) |   ,   ($2c)|   @   ($00)|   :   ($3a)|   .   ($2e)|   -   ($2d)|   l   ($0c)|   p   ($10)|   +   ($2b)|
/// |6.  | #%10111111 (191/$bf) |   /   ($2f)|   ^   ($1e)|   =   ($3d)|RGHT-SH($  )|  HOME ($  )|   ;   ($3b)|   *   ($2a)|   Â£   ($1c)|
/// |7.  | #%01111111 (127/$7f) | STOP  ($  )|   q   ($11)|COMMODR($  )| SPACE ($20)|   2   ($32)|CONTROL($  )|  <-   ($1f)|   1   ($31)|
/// +----+----------------------+------------+------------+------------+------------+------------+------------+------------+------------+
  // Upstart
  // Commodore 64 PRG executable file
.file [name="keyboard-glitch.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const KEY_E = $e
  .const KEY_C = $14
  .const KEY_I = $21
  .const KEY_SPACE = $3c
  .const RED = 2
  .const GREEN = 5
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
  .label BORDER_COLOR = $d020
  .label BG_COLOR = $d021
  /// The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  .label SCREEN = $400
.segment Code
  // main
main: {
    // *BORDER_COLOR = GREEN
    // [0] *BORDER_COLOR = GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDER_COLOR
    // [1] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
    // main::@1
  __b1:
    // menu()
    // [2] call menu 
    // [3] phi from main::@1 to menu [phi:main::@1->menu]
    jsr menu
    jmp __b1
}
  // menu
menu: {
    // [4] phi from menu menu::@4 to menu::@1 [phi:menu/menu::@4->menu::@1]
    // menu::@1
  __b1:
    // keyboard_key_pressed(KEY_C)
    // [5] call keyboard_key_pressed 
    // [27] phi from menu::@1 to keyboard_key_pressed [phi:menu::@1->keyboard_key_pressed]
    // [27] phi keyboard_key_pressed::key#4 = KEY_C [phi:menu::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_C
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_C)
    // [6] keyboard_key_pressed::return#2 = keyboard_key_pressed::return#0
    // menu::@8
    // [7] menu::$0 = keyboard_key_pressed::return#2
    // if(keyboard_key_pressed(KEY_C)!=0)
    // [8] if(menu::$0==0) goto menu::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // [9] phi from menu::@8 to menu::@5 [phi:menu::@8->menu::@5]
    // menu::@5
    // pressed()
    // [10] call pressed 
    jsr pressed
    // menu::@return
    // }
    // [11] return 
    rts
    // [12] phi from menu::@8 to menu::@2 [phi:menu::@8->menu::@2]
    // menu::@2
  __b2:
    // keyboard_key_pressed(KEY_I)
    // [13] call keyboard_key_pressed 
    // [27] phi from menu::@2 to keyboard_key_pressed [phi:menu::@2->keyboard_key_pressed]
    // [27] phi keyboard_key_pressed::key#4 = KEY_I [phi:menu::@2->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_I
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_I)
    // [14] keyboard_key_pressed::return#3 = keyboard_key_pressed::return#0
    // menu::@9
    // [15] menu::$4 = keyboard_key_pressed::return#3
    // if(keyboard_key_pressed(KEY_I)!=0)
    // [16] if(menu::$4==0) goto menu::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3
    // menu::@6
    // *BORDER_COLOR = RED
    // [17] *BORDER_COLOR = RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDER_COLOR
    // asm
    // asm { sei  }
    sei
    rts
    // [19] phi from menu::@9 to menu::@3 [phi:menu::@9->menu::@3]
    // menu::@3
  __b3:
    // keyboard_key_pressed(KEY_E)
    // [20] call keyboard_key_pressed 
    // [27] phi from menu::@3 to keyboard_key_pressed [phi:menu::@3->keyboard_key_pressed]
    // [27] phi keyboard_key_pressed::key#4 = KEY_E [phi:menu::@3->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_E
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_E)
    // [21] keyboard_key_pressed::return#4 = keyboard_key_pressed::return#0
    // menu::@10
    // [22] menu::$7 = keyboard_key_pressed::return#4
    // if(keyboard_key_pressed(KEY_E)!=0)
    // [23] if(menu::$7==0) goto menu::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    // menu::@7
    // *BORDER_COLOR = GREEN
    // [24] *BORDER_COLOR = GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDER_COLOR
    // asm
    // asm { cli  }
    cli
    rts
    // menu::@4
  __b4:
    // (*SCREEN)++;
    // [26] *SCREEN = ++ *SCREEN -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(X) key)
keyboard_key_pressed: {
    // char colidx = key&7
    // [28] keyboard_key_pressed::colidx#0 = keyboard_key_pressed::key#4 & 7 -- vbuyy=vbuxx_band_vbuc1 
    txa
    and #7
    tay
    // char rowidx = key>>3
    // [29] keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::key#4 >> 3 -- vbuaa=vbuxx_ror_3 
    txa
    lsr
    lsr
    lsr
    // keyboard_matrix_read(rowidx)
    // [30] keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0 -- vbuxx=vbuaa 
    tax
    // [31] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [32] keyboard_matrix_read::return#2 = keyboard_matrix_read::return#0
    // keyboard_key_pressed::@1
    // [33] keyboard_key_pressed::$2 = keyboard_matrix_read::return#2
    // keyboard_matrix_read(rowidx) & keyboard_matrix_col_bitmask[colidx]
    // [34] keyboard_key_pressed::return#0 = keyboard_key_pressed::$2 & keyboard_matrix_col_bitmask[keyboard_key_pressed::colidx#0] -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuyy 
    and keyboard_matrix_col_bitmask,y
    // keyboard_key_pressed::@return
    // }
    // [35] return 
    rts
}
  // pressed
pressed: {
    // (*BG_COLOR)++;
    // [36] *BG_COLOR = ++ *BG_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BG_COLOR
    // [37] phi from pressed pressed::@2 to pressed::@1 [phi:pressed/pressed::@2->pressed::@1]
    // pressed::@1
  __b1:
    // keyboard_key_pressed(KEY_SPACE)
    // [38] call keyboard_key_pressed 
    // [27] phi from pressed::@1 to keyboard_key_pressed [phi:pressed::@1->keyboard_key_pressed]
    // [27] phi keyboard_key_pressed::key#4 = KEY_SPACE [phi:pressed::@1->keyboard_key_pressed#0] -- vbuxx=vbuc1 
    ldx #KEY_SPACE
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_SPACE)
    // [39] keyboard_key_pressed::return#10 = keyboard_key_pressed::return#0
    // pressed::@2
    // [40] pressed::$1 = keyboard_key_pressed::return#10
    // if(keyboard_key_pressed(KEY_SPACE)!=0)
    // [41] if(pressed::$1!=0) goto pressed::@return -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __breturn
    jmp __b1
    // pressed::@return
  __breturn:
    // }
    // [42] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(X) rowid)
keyboard_matrix_read: {
    // CIA1->PORT_A = keyboard_matrix_row_bitmask[rowid]
    // [43] *((byte*)CIA1) = keyboard_matrix_row_bitmask[keyboard_matrix_read::rowid#0] -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda keyboard_matrix_row_bitmask,x
    sta CIA1
    // ~CIA1->PORT_B
    // [44] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B
    eor #$ff
    // keyboard_matrix_read::@return
    // }
    // [45] return 
    rts
}
  // File Data
.segment Data
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

