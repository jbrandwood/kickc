Features
- Move the main code into a main() function, and disallow code outside functions. The main function per default has no parameters and exits with RTS.
- Add a for loop for(init;condition;increment) {stmt} -> { init; do { stmt; increment } while (condition) }
- Add Fixed Point number types
- Add imports
- Add structs
- Let { stmt } introduce a new anonymous scope.
- Add preprocessing / find a way to allow some functions to run at compile time
- Implement inline compilation of functions (and a mechanism for choosing which methods / calls to inline)
- Add ability to call ASM code from KC.
- Add ability to call KC code from ASM. (Maybe declare some functions external to ensure their interface is well defined. Maybe generate ASM call stubs.)
- Add an export keyword ensuring that a function is generated even if it is never called. Maybe export can be handled by generating a call that can be used as stub.
- Add inline ASM (maybe?)
- Handle long branches
- Allow complex array expressions in lValues eg. (SCREEN+$100)[idx]
+ Create a proper main function for the compiler
+ Add ++/-- incrementing/decrementing operators.

Register Allocation
- Matrix Phi operation (instead of separate statements)
- Safe-Copy based SSA deconstruction
  - Optimize phi transitions by ensuring that identical phi-transitions with regards to register allocation are collected into a single transition.
  - Optimize by finding optimal sequence for multiple phi assignments in entry-segments.
- Phi Lifting
- Interval Analysis (variable liveness intervals)
- PhiLifting & PhiMemCoalesce (http://compilers.cs.ucla.edu/fernando/projects/soc/reports/short_tech.pdf)
- ComputeLoopNestDepth(b) - Assign loop nesting levels to blocks.
- ComputeRegisterPreference(v), ComputeWeight(v)
- CalculateClobbering(i)
  - Maybe support several fragements for the same operation with different cost and clobbering profiles.
- Register types: A, X, Y, ZP, (memory).
  - Maybe register preference should also incorporate the types of operations that can be effectively performed with the register? (Maybe based on fragment cost?)
- Implement a register allocation (coloring) algorithm using by liveness intervals, preferences, weights & clobbering information.
  - Optimize register allocation by combining with knowledge of ASM program cost (bytes/cycles) and different ASM fragments with different clobbering.

Process/Code Structure Improvement
- Make each phase return a separate object graph (allowing for keeeping the history in memory & performing rollbacks)
- Refactor Expression Operator Implementation & Evaluation into one class per operator
- Improve error messages to give better context
- Offer to compile resulting ASM with KickAssembler
+ Implemenent Assertions for the output of different phases (ensuring that the result of the phase is consistent)

Testing
- Test that the parse tree for specific KC syntax is as expected. Use a print function for the parse tree to generate output for comparison.
- Test the ICL result of a specific phase on a specific ICL input. Create an ICL syntax for parsing directly to ICL and a printer for the syntax.
- Emulate/Run the ASM for a specific KC program compiled. Compare the emulated ASM output to output calculated by executing directly on the KC tree.
- Add assert statements to the language. Create KC programs that test the compiler by compiling, running and testing assertions.
+ Test the ASM program output resulting from compiling specific KC program input.

Optimizations
- Optimize by allowing resequencing of statements and phi assignemtns in a final phase. Perhaps by converting phi statements to "normal" statements and using some optimization step.
- This phase could also help simplify LDA xx, CMP#0, BNE by expressing these in a language where CMP can be eliminated before.

Usages
- Implement library for memory allocation in main memory
- Implement library for output on the screen (using basic functions)

Real Usage
- Implement library for fast multiply (mul.asm)
- Implement spline library (spline.asm)
- Implement polygon filler for complex polygons.
- Implement a true type font renderer.