Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@6

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) x#0 ← (number) $c
  to:@1
main: scope:[main]  from @1
  (byte) x#8 ← phi( @1/(byte) x#9 )
  to:main::@1
main::@1: scope:[main]  from main main::@1
  (byte) x#5 ← phi( main/(byte) x#8 main::@1/(byte) x#1 )
  (byte) x#1 ← ++ (byte) x#5
  (bool~) main::$0 ← (byte) x#1 < (number) $32
  if((bool~) main::$0) goto main::@1
  to:main::@3
main::@3: scope:[main]  from main::@1
  (byte) x#2 ← (number) 0
  to:main::@return
main::@return: scope:[main]  from main::@3
  (byte) x#6 ← phi( main::@3/(byte) x#2 )
  (byte) x#3 ← (byte) x#6
  return 
  to:@return
@1: scope:[]  from @begin
  (byte) x#9 ← phi( @begin/(byte) x#0 )
  call main 
  to:@2
@2: scope:[]  from @1
  (byte) x#7 ← phi( @1/(byte) x#3 )
  (byte) x#4 ← (byte) x#7
  to:@end
@end: scope:[]  from @2

SYMBOL TABLE SSA
(label) @1
(label) @2
(label) @begin
(label) @end
(void()) main()
(bool~) main::$0
(label) main::@1
(label) main::@3
(label) main::@return
(byte) x
(byte) x#0
(byte) x#1
(byte) x#2
(byte) x#3
(byte) x#4
(byte) x#5
(byte) x#6
(byte) x#7
(byte) x#8
(byte) x#9

Adding number conversion cast (unumber) $c in (byte) x#0 ← (number) $c
Adding number conversion cast (unumber) $32 in (bool~) main::$0 ← (byte) x#1 < (number) $32
Adding number conversion cast (unumber) 0 in (byte) x#2 ← (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte) x#0 ← (unumber)(number) $c
Inlining cast (byte) x#2 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast $c
Simplifying constant integer cast $32
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $c
Finalized unsigned number type (byte) $32
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias (byte) x#2 = (byte) x#6 (byte) x#3 
Alias (byte) x#0 = (byte) x#9 
Alias (byte) x#4 = (byte) x#7 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) x#8 (byte) x#0
Identical Phi Values (byte) x#4 (byte) x#2
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$0 [5] if((byte) x#1<(byte) $32) goto main::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Added new block during phi lifting main::@7(between main::@1 and main::@1)
Adding NOP phi() at start of @1
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
CALL GRAPH
Calls in [] to main:2 

Created 1 initial phi equivalence classes
Coalesced [5] x#10 ← x#0
Coalesced [11] x#11 ← x#1
Coalesced down to 1 phi equivalence classes
Culled Empty Block (label) @2
Culled Empty Block (label) main::@7
Renumbering block main::@3 to main::@2
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] (byte) x#0 ← (byte) $c
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [5] (byte) x#5 ← phi( main/(byte) x#0 main::@1/(byte) x#1 )
  [6] (byte) x#1 ← ++ (byte) x#5
  [7] if((byte) x#1<(byte) $32) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] (byte) x#2 ← (byte) 0
  to:main::@return
main::@return: scope:[main]  from main::@2
  [9] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) main()
(byte) x
(byte) x#0 1.3333333333333333
(byte) x#1 16.5
(byte) x#2 20.0
(byte) x#5 24.0

Initial phi equivalence classes
[ x#5 x#0 x#1 ]
Coalescing volatile variable equivalence classes [ x#5 x#0 x#1 ] and [ x#2 ]
Complete equivalence classes
[ x#5 x#0 x#1 x#2 ]
Allocated zp ZP_BYTE:2 [ x#5 x#0 x#1 x#2 ]

INITIAL ASM
// File Comments
// Illustrates a problem where volatiles with initializers are initialized outside the main()-routine
// Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
// Global Constants & labels
  .label x = 2
// @begin
bbegin:
// [0] (byte) x#0 ← (byte) $c -- vbuz1=vbuc1 
  lda #$c
  sta x
// [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
// @1
b1:
// [2] call main 
// [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
// [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
// @end
bend:
// main
main: {
  // [5] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
  b1_from_main:
  b1_from_b1:
  // [5] phi (byte) x#5 = (byte) x#0 [phi:main/main::@1->main::@1#0] -- register_copy 
    jmp b1
  // main::@1
  b1:
  // [6] (byte) x#1 ← ++ (byte) x#5 -- vbuz1=_inc_vbuz1 
    inc x
  // [7] if((byte) x#1<(byte) $32) goto main::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda x
    cmp #$32
    bcc b1_from_b1
    jmp b2
  // main::@2
  b2:
  // [8] (byte) x#2 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta x
    jmp breturn
  // main::@return
  breturn:
  // [9] return 
    rts
}
// File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] (byte) x#0 ← (byte) $c [ x#0 ] (  [ x#0 ] ) always clobbers reg byte a 
Statement [7] if((byte) x#1<(byte) $32) goto main::@1 [ x#1 ] ( main:2 [ x#1 ] ) always clobbers reg byte a 
Statement [8] (byte) x#2 ← (byte) 0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ x#5 x#0 x#1 x#2 ] : zp ZP_BYTE:2 , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 61.83: zp ZP_BYTE:2 [ x#5 x#0 x#1 x#2 ] 
Uplift Scope [main] 

Uplifting [] best 216 combination zp ZP_BYTE:2 [ x#5 x#0 x#1 x#2 ] 
Uplifting [main] best 216 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ x#5 x#0 x#1 x#2 ]
Uplifting [] best 216 combination zp ZP_BYTE:2 [ x#5 x#0 x#1 x#2 ] 

ASSEMBLER BEFORE OPTIMIZATION
// File Comments
// Illustrates a problem where volatiles with initializers are initialized outside the main()-routine
// Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
// Global Constants & labels
  .label x = 2
// @begin
bbegin:
// [0] (byte) x#0 ← (byte) $c -- vbuz1=vbuc1 
  lda #$c
  sta x
// [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
// @1
b1:
// [2] call main 
// [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
// [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
// @end
bend:
// main
main: {
  // [5] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
  b1_from_main:
  b1_from_b1:
  // [5] phi (byte) x#5 = (byte) x#0 [phi:main/main::@1->main::@1#0] -- register_copy 
    jmp b1
  // main::@1
  b1:
  // [6] (byte) x#1 ← ++ (byte) x#5 -- vbuz1=_inc_vbuz1 
    inc x
  // [7] if((byte) x#1<(byte) $32) goto main::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda x
    cmp #$32
    bcc b1_from_b1
    jmp b2
  // main::@2
  b2:
  // [8] (byte) x#2 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta x
    jmp breturn
  // main::@return
  breturn:
  // [9] return 
    rts
}
// File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label b1_from_b1 with b1
Removing instruction b1_from_bbegin:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_main:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b1:
Removing instruction bend:
Removing instruction b2:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(byte) x
(byte) x#0 x zp ZP_BYTE:2 1.3333333333333333
(byte) x#1 x zp ZP_BYTE:2 16.5
(byte) x#2 x zp ZP_BYTE:2 20.0
(byte) x#5 x zp ZP_BYTE:2 24.0

zp ZP_BYTE:2 [ x#5 x#0 x#1 x#2 ]


FINAL ASSEMBLER
Score: 153

// File Comments
// Illustrates a problem where volatiles with initializers are initialized outside the main()-routine
// Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
// Global Constants & labels
  .label x = 2
// @begin
bbegin:
// [0] (byte) x#0 ← (byte) $c -- vbuz1=vbuc1 
  lda #$c
  sta x
// [1] phi from @begin to @1 [phi:@begin->@1]
// @1
// [2] call main 
// [4] phi from @1 to main [phi:@1->main]
  jsr main
  rts
// [3] phi from @1 to @end [phi:@1->@end]
// @end
// main
main: {
  // [5] phi from main main::@1 to main::@1 [phi:main/main::@1->main::@1]
  // [5] phi (byte) x#5 = (byte) x#0 [phi:main/main::@1->main::@1#0] -- register_copy 
  // main::@1
  b1:
  // [6] (byte) x#1 ← ++ (byte) x#5 -- vbuz1=_inc_vbuz1 
    inc x
  // [7] if((byte) x#1<(byte) $32) goto main::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda x
    cmp #$32
    bcc b1
  // main::@2
  // [8] (byte) x#2 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta x
  // main::@return
  // [9] return 
    rts
}
// File Data

