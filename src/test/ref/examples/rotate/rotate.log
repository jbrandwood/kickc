Resolved forward reference SPRITE to (byte*) SPRITE
Fixing pointer addition (word*~) bsearch16u::$7 ← (word*) bsearch16u::items + (byte~) bsearch16u::$6
Fixing pointer addition (word*~) bsearch16u::$15 ← (word*) bsearch16u::pivot + (number) 1
Fixing pointer addition (word*~) bsearch16u::$1 ← (word*) bsearch16u::items - (number) 1
Fixing pointer array-indexing *((word*) utoa::digit_values + (byte) utoa::digit)
Fixing pointer array-indexing *((dword*) ultoa::digit_values + (byte) ultoa::digit)
Warning! Adding boolean cast to non-boolean condition *((byte*) strcpy::src)
Identified constant variable (byte*) HEAP_TOP
Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) SPRITE
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call mulf8s_prepare (signed byte) mulf8s::a 
Inlined call call mulf8s_prepare (signed byte) anim::cos_a 
Inlined call call mulf8s_prepare (signed byte) anim::sin_a 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) mulf8u_prepared::@1
Culled Empty Block (label) @7
Culled Empty Block (label) @8
Culled Empty Block (label) @9
Culled Empty Block (label) mulf8s_prepared::@5
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) @12
Culled Empty Block (label) clock::@1
Culled Empty Block (label) @14
Culled Empty Block (label) @15
Culled Empty Block (label) @16
Culled Empty Block (label) @17
Culled Empty Block (label) @18
Culled Empty Block (label) @19
Culled Empty Block (label) @20
Culled Empty Block (label) @21
Culled Empty Block (label) @22
Culled Empty Block (label) @23
Culled Empty Block (label) @24
Culled Empty Block (label) @25
Culled Empty Block (label) @26
Culled Empty Block (label) @27
Culled Empty Block (label) @28
Culled Empty Block (label) @29
Culled Empty Block (label) @30
Culled Empty Block (label) @31
Culled Empty Block (label) @32
Culled Empty Block (label) @33
Culled Empty Block (label) @34
Culled Empty Block (label) @35
Culled Empty Block (label) @36
Culled Empty Block (label) @37
Culled Empty Block (label) @38
Culled Empty Block (label) @39
Culled Empty Block (label) @40
Culled Empty Block (label) @41
Culled Empty Block (label) @42
Culled Empty Block (label) @43
Culled Empty Block (label) @45
Culled Empty Block (label) @46
Culled Empty Block (label) @47
Culled Empty Block (label) @48
Culled Empty Block (label) @49
Culled Empty Block (label) @50
Culled Empty Block (label) @52
Culled Empty Block (label) init::@2
Culled Empty Block (label) anim::@2
Culled Empty Block (label) anim::@15
Culled Empty Block (label) anim::@3
Culled Empty Block (label) anim::@16
Culled Empty Block (label) anim::@5
Culled Empty Block (label) anim::@7
Culled Empty Block (label) anim::@8
Culled Empty Block (label) anim::@9
Culled Empty Block (label) anim::mulf8s_prepare1_@return
Culled Empty Block (label) anim::mulf8s_prepare2_@return
Culled Empty Block (label) anim::@14

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) SPRITES_XPOS#0 ← ((byte*)) (number) $d000
  (byte*) SPRITES_YPOS#0 ← ((byte*)) (number) $d001
  (byte*) SPRITES_XMSB#0 ← ((byte*)) (number) $d010
  (byte*) RASTER#0 ← ((byte*)) (number) $d012
  (byte*) SPRITES_ENABLE#0 ← ((byte*)) (number) $d015
  (byte*) BORDERCOL#0 ← ((byte*)) (number) $d020
  (byte*) SPRITES_COLS#0 ← ((byte*)) (number) $d027
  (dword*) CIA2_TIMER_AB#0 ← ((dword*)) (number) $dd04
  (byte*) CIA2_TIMER_A_CONTROL#0 ← ((byte*)) (number) $dd0e
  (byte*) CIA2_TIMER_B_CONTROL#0 ← ((byte*)) (number) $dd0f
  (byte) CIA_TIMER_CONTROL_STOP#0 ← (number) 0
  (byte) CIA_TIMER_CONTROL_START#0 ← (number) 1
  (byte) CIA_TIMER_CONTROL_CONTINUOUS#0 ← (number) 0
  (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0 ← (number) 0
  (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 ← (number) $40
  (byte) GREEN#0 ← (number) 5
  (byte) LIGHT_BLUE#0 ← (number) $e
  to:@4
@4: scope:[]  from @begin
  (byte[$200]) mulf_sqr1_lo#0 ← { fill( $200, 0) }
  (byte[$200]) mulf_sqr1_hi#0 ← { fill( $200, 0) }
  (byte[$200]) mulf_sqr2_lo#0 ← { fill( $200, 0) }
  (byte[$200]) mulf_sqr2_hi#0 ← { fill( $200, 0) }
  to:@13
mulf_init: scope:[mulf_init]  from init
  (word) mulf_init::sqr#0 ← (number) 0
  (byte) mulf_init::x_2#0 ← (number) 0
  (byte) mulf_init::c#0 ← (number) 0
  (byte*~) mulf_init::$0 ← (byte[$200]) mulf_sqr1_hi#0 + (number) 1
  (byte*) mulf_init::sqr1_hi#0 ← (byte*~) mulf_init::$0
  (byte*~) mulf_init::$6 ← (byte[$200]) mulf_sqr1_lo#0 + (number) 1
  (byte*) mulf_init::sqr1_lo#0 ← (byte*~) mulf_init::$6
  to:mulf_init::@1
mulf_init::@1: scope:[mulf_init]  from mulf_init mulf_init::@2
  (byte) mulf_init::x_2#4 ← phi( mulf_init/(byte) mulf_init::x_2#0 mulf_init::@2/(byte) mulf_init::x_2#2 )
  (byte*) mulf_init::sqr1_hi#3 ← phi( mulf_init/(byte*) mulf_init::sqr1_hi#0 mulf_init::@2/(byte*) mulf_init::sqr1_hi#1 )
  (byte*) mulf_init::sqr1_lo#3 ← phi( mulf_init/(byte*) mulf_init::sqr1_lo#0 mulf_init::@2/(byte*) mulf_init::sqr1_lo#1 )
  (word) mulf_init::sqr#5 ← phi( mulf_init/(word) mulf_init::sqr#0 mulf_init::@2/(word) mulf_init::sqr#1 )
  (byte) mulf_init::c#2 ← phi( mulf_init/(byte) mulf_init::c#0 mulf_init::@2/(byte) mulf_init::c#3 )
  (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2
  (number~) mulf_init::$7 ← (byte) mulf_init::c#1 & (number) 1
  (bool~) mulf_init::$8 ← (number~) mulf_init::$7 == (number) 0
  (bool~) mulf_init::$9 ← ! (bool~) mulf_init::$8
  if((bool~) mulf_init::$9) goto mulf_init::@2
  to:mulf_init::@3
mulf_init::@2: scope:[mulf_init]  from mulf_init::@1 mulf_init::@3
  (byte) mulf_init::c#3 ← phi( mulf_init::@1/(byte) mulf_init::c#1 mulf_init::@3/(byte) mulf_init::c#4 )
  (byte) mulf_init::x_2#2 ← phi( mulf_init::@1/(byte) mulf_init::x_2#4 mulf_init::@3/(byte) mulf_init::x_2#1 )
  (byte*) mulf_init::sqr1_hi#2 ← phi( mulf_init::@1/(byte*) mulf_init::sqr1_hi#3 mulf_init::@3/(byte*) mulf_init::sqr1_hi#4 )
  (byte*) mulf_init::sqr1_lo#2 ← phi( mulf_init::@1/(byte*) mulf_init::sqr1_lo#3 mulf_init::@3/(byte*) mulf_init::sqr1_lo#4 )
  (word) mulf_init::sqr#3 ← phi( mulf_init::@1/(word) mulf_init::sqr#5 mulf_init::@3/(word) mulf_init::sqr#2 )
  (byte~) mulf_init::$10 ← < (word) mulf_init::sqr#3
  *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$10
  (byte~) mulf_init::$11 ← > (word) mulf_init::sqr#3
  *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$11
  (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2
  (word~) mulf_init::$12 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2
  (word) mulf_init::sqr#1 ← (word~) mulf_init::$12
  (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#2
  (byte*~) mulf_init::$13 ← (byte[$200]) mulf_sqr1_lo#0 + (number) $200
  (bool~) mulf_init::$14 ← (byte*) mulf_init::sqr1_lo#1 != (byte*~) mulf_init::$13
  if((bool~) mulf_init::$14) goto mulf_init::@1
  to:mulf_init::@4
mulf_init::@3: scope:[mulf_init]  from mulf_init::@1
  (byte) mulf_init::c#4 ← phi( mulf_init::@1/(byte) mulf_init::c#1 )
  (byte*) mulf_init::sqr1_hi#4 ← phi( mulf_init::@1/(byte*) mulf_init::sqr1_hi#3 )
  (byte*) mulf_init::sqr1_lo#4 ← phi( mulf_init::@1/(byte*) mulf_init::sqr1_lo#3 )
  (word) mulf_init::sqr#4 ← phi( mulf_init::@1/(word) mulf_init::sqr#5 )
  (byte) mulf_init::x_2#3 ← phi( mulf_init::@1/(byte) mulf_init::x_2#4 )
  (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3
  (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4
  to:mulf_init::@2
mulf_init::@4: scope:[mulf_init]  from mulf_init::@2
  (byte~) mulf_init::$1 ← ((byte)) (number) -1
  (byte) mulf_init::x_255#0 ← (byte~) mulf_init::$1
  (byte) mulf_init::dir#0 ← (number) $ff
  (byte*) mulf_init::sqr2_hi#0 ← (byte[$200]) mulf_sqr2_hi#0
  (byte*) mulf_init::sqr2_lo#0 ← (byte[$200]) mulf_sqr2_lo#0
  to:mulf_init::@5
mulf_init::@5: scope:[mulf_init]  from mulf_init::@4 mulf_init::@6
  (byte) mulf_init::dir#2 ← phi( mulf_init::@4/(byte) mulf_init::dir#0 mulf_init::@6/(byte) mulf_init::dir#3 )
  (byte*) mulf_init::sqr2_hi#2 ← phi( mulf_init::@4/(byte*) mulf_init::sqr2_hi#0 mulf_init::@6/(byte*) mulf_init::sqr2_hi#3 )
  (byte*) mulf_init::sqr2_lo#2 ← phi( mulf_init::@4/(byte*) mulf_init::sqr2_lo#0 mulf_init::@6/(byte*) mulf_init::sqr2_lo#1 )
  (byte) mulf_init::x_255#2 ← phi( mulf_init::@4/(byte) mulf_init::x_255#0 mulf_init::@6/(byte) mulf_init::x_255#3 )
  *((byte*) mulf_init::sqr2_lo#2) ← *((byte[$200]) mulf_sqr1_lo#0 + (byte) mulf_init::x_255#2)
  *((byte*) mulf_init::sqr2_hi#2) ← *((byte[$200]) mulf_sqr1_hi#0 + (byte) mulf_init::x_255#2)
  (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2
  (byte~) mulf_init::$15 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2
  (byte) mulf_init::x_255#1 ← (byte~) mulf_init::$15
  (bool~) mulf_init::$16 ← (byte) mulf_init::x_255#1 == (number) 0
  (bool~) mulf_init::$17 ← ! (bool~) mulf_init::$16
  if((bool~) mulf_init::$17) goto mulf_init::@6
  to:mulf_init::@7
mulf_init::@6: scope:[mulf_init]  from mulf_init::@5 mulf_init::@7
  (byte) mulf_init::dir#3 ← phi( mulf_init::@5/(byte) mulf_init::dir#2 mulf_init::@7/(byte) mulf_init::dir#1 )
  (byte*) mulf_init::sqr2_hi#3 ← phi( mulf_init::@5/(byte*) mulf_init::sqr2_hi#1 mulf_init::@7/(byte*) mulf_init::sqr2_hi#4 )
  (byte) mulf_init::x_255#3 ← phi( mulf_init::@5/(byte) mulf_init::x_255#1 mulf_init::@7/(byte) mulf_init::x_255#4 )
  (byte*) mulf_init::sqr2_lo#3 ← phi( mulf_init::@5/(byte*) mulf_init::sqr2_lo#2 mulf_init::@7/(byte*) mulf_init::sqr2_lo#4 )
  (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#3
  (byte*~) mulf_init::$18 ← (byte[$200]) mulf_sqr2_lo#0 + (number) $1ff
  (bool~) mulf_init::$19 ← (byte*) mulf_init::sqr2_lo#1 != (byte*~) mulf_init::$18
  if((bool~) mulf_init::$19) goto mulf_init::@5
  to:mulf_init::@8
mulf_init::@7: scope:[mulf_init]  from mulf_init::@5
  (byte*) mulf_init::sqr2_hi#4 ← phi( mulf_init::@5/(byte*) mulf_init::sqr2_hi#1 )
  (byte) mulf_init::x_255#4 ← phi( mulf_init::@5/(byte) mulf_init::x_255#1 )
  (byte*) mulf_init::sqr2_lo#4 ← phi( mulf_init::@5/(byte*) mulf_init::sqr2_lo#2 )
  (byte) mulf_init::dir#1 ← (number) 1
  to:mulf_init::@6
mulf_init::@8: scope:[mulf_init]  from mulf_init::@6
  (byte*~) mulf_init::$2 ← (byte[$200]) mulf_sqr2_lo#0 + (number) $1ff
  (byte*~) mulf_init::$3 ← (byte[$200]) mulf_sqr1_lo#0 + (number) $100
  *((byte*~) mulf_init::$2) ← *((byte*~) mulf_init::$3)
  (byte*~) mulf_init::$4 ← (byte[$200]) mulf_sqr2_hi#0 + (number) $1ff
  (byte*~) mulf_init::$5 ← (byte[$200]) mulf_sqr1_hi#0 + (number) $100
  *((byte*~) mulf_init::$4) ← *((byte*~) mulf_init::$5)
  to:mulf_init::@return
mulf_init::@return: scope:[mulf_init]  from mulf_init::@8
  return 
  to:@return
mulf8u_prepare: scope:[mulf8u_prepare]  from anim::mulf8s_prepare1 anim::mulf8s_prepare2
  (byte) mulf8u_prepare::a#2 ← phi( anim::mulf8s_prepare1/(byte) mulf8u_prepare::a#0 anim::mulf8s_prepare2/(byte) mulf8u_prepare::a#1 )
  (byte*) mulf8u_prepare::memA#0 ← ((byte*)) (number) $fd
  *((byte*) mulf8u_prepare::memA#0) ← (byte) mulf8u_prepare::a#2
  asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
  to:mulf8u_prepare::@return
mulf8u_prepare::@return: scope:[mulf8u_prepare]  from mulf8u_prepare
  return 
  to:@return
mulf8u_prepared: scope:[mulf8u_prepared]  from mulf8s_prepared
  (byte) mulf8u_prepared::b#1 ← phi( mulf8s_prepared/(byte) mulf8u_prepared::b#0 )
  (byte*) mulf8u_prepared::resL#0 ← ((byte*)) (number) $fe
  (byte*) mulf8u_prepared::memB#0 ← ((byte*)) (number) $ff
  *((byte*) mulf8u_prepared::memB#0) ← (byte) mulf8u_prepared::b#1
  asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
  (word) mulf8u_prepared::return#0 ← ((word)) { *((byte*) mulf8u_prepared::memB#0), *((byte*) mulf8u_prepared::resL#0) }
  to:mulf8u_prepared::@return
mulf8u_prepared::@return: scope:[mulf8u_prepared]  from mulf8u_prepared
  (word) mulf8u_prepared::return#3 ← phi( mulf8u_prepared/(word) mulf8u_prepared::return#0 )
  (word) mulf8u_prepared::return#1 ← (word) mulf8u_prepared::return#3
  return 
  to:@return
mulf8s_prepared: scope:[mulf8s_prepared]  from anim::@17 anim::@18 anim::@21 anim::@24
  (signed byte) mulf8s_prepared::b#4 ← phi( anim::@17/(signed byte) mulf8s_prepared::b#0 anim::@18/(signed byte) mulf8s_prepared::b#2 anim::@21/(signed byte) mulf8s_prepared::b#1 anim::@24/(signed byte) mulf8s_prepared::b#3 )
  (signed byte*) mulf8s_prepared::memA#0 ← ((signed byte*)) (number) $fd
  (byte~) mulf8s_prepared::$0 ← ((byte)) (signed byte) mulf8s_prepared::b#4
  (byte) mulf8u_prepared::b#0 ← (byte~) mulf8s_prepared::$0
  call mulf8u_prepared 
  (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#1
  to:mulf8s_prepared::@6
mulf8s_prepared::@6: scope:[mulf8s_prepared]  from mulf8s_prepared
  (signed byte) mulf8s_prepared::b#7 ← phi( mulf8s_prepared/(signed byte) mulf8s_prepared::b#4 )
  (word) mulf8u_prepared::return#4 ← phi( mulf8s_prepared/(word) mulf8u_prepared::return#2 )
  (word~) mulf8s_prepared::$1 ← (word) mulf8u_prepared::return#4
  (word) mulf8s_prepared::m#0 ← (word~) mulf8s_prepared::$1
  (bool~) mulf8s_prepared::$2 ← *((signed byte*) mulf8s_prepared::memA#0) < (number) 0
  (bool~) mulf8s_prepared::$3 ← ! (bool~) mulf8s_prepared::$2
  if((bool~) mulf8s_prepared::$3) goto mulf8s_prepared::@1
  to:mulf8s_prepared::@3
mulf8s_prepared::@1: scope:[mulf8s_prepared]  from mulf8s_prepared::@3 mulf8s_prepared::@6
  (word) mulf8s_prepared::m#6 ← phi( mulf8s_prepared::@3/(word) mulf8s_prepared::m#1 mulf8s_prepared::@6/(word) mulf8s_prepared::m#0 )
  (signed byte) mulf8s_prepared::b#5 ← phi( mulf8s_prepared::@3/(signed byte) mulf8s_prepared::b#6 mulf8s_prepared::@6/(signed byte) mulf8s_prepared::b#7 )
  (bool~) mulf8s_prepared::$4 ← (signed byte) mulf8s_prepared::b#5 < (number) 0
  (bool~) mulf8s_prepared::$5 ← ! (bool~) mulf8s_prepared::$4
  if((bool~) mulf8s_prepared::$5) goto mulf8s_prepared::@2
  to:mulf8s_prepared::@4
mulf8s_prepared::@3: scope:[mulf8s_prepared]  from mulf8s_prepared::@6
  (signed byte) mulf8s_prepared::b#6 ← phi( mulf8s_prepared::@6/(signed byte) mulf8s_prepared::b#7 )
  (word) mulf8s_prepared::m#3 ← phi( mulf8s_prepared::@6/(word) mulf8s_prepared::m#0 )
  (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#3
  (byte~) mulf8s_prepared::$9 ← ((byte)) (signed byte) mulf8s_prepared::b#6
  (byte~) mulf8s_prepared::$10 ← (byte~) mulf8s_prepared::$8 - (byte~) mulf8s_prepared::$9
  (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$10
  (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#3 hi= (byte~) mulf8s_prepared::$15
  to:mulf8s_prepared::@1
mulf8s_prepared::@2: scope:[mulf8s_prepared]  from mulf8s_prepared::@1 mulf8s_prepared::@4
  (word) mulf8s_prepared::m#4 ← phi( mulf8s_prepared::@1/(word) mulf8s_prepared::m#6 mulf8s_prepared::@4/(word) mulf8s_prepared::m#2 )
  (signed word~) mulf8s_prepared::$6 ← ((signed word)) (word) mulf8s_prepared::m#4
  (signed word) mulf8s_prepared::return#0 ← (signed word~) mulf8s_prepared::$6
  to:mulf8s_prepared::@return
mulf8s_prepared::@4: scope:[mulf8s_prepared]  from mulf8s_prepared::@1
  (word) mulf8s_prepared::m#5 ← phi( mulf8s_prepared::@1/(word) mulf8s_prepared::m#6 )
  (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5
  (byte~) mulf8s_prepared::$13 ← ((byte)) *((signed byte*) mulf8s_prepared::memA#0)
  (byte~) mulf8s_prepared::$14 ← (byte~) mulf8s_prepared::$12 - (byte~) mulf8s_prepared::$13
  (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$14
  (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16
  to:mulf8s_prepared::@2
mulf8s_prepared::@return: scope:[mulf8s_prepared]  from mulf8s_prepared::@2
  (signed word) mulf8s_prepared::return#6 ← phi( mulf8s_prepared::@2/(signed word) mulf8s_prepared::return#0 )
  (signed word) mulf8s_prepared::return#1 ← (signed word) mulf8s_prepared::return#6
  return 
  to:@return
@13: scope:[]  from @4
  (dword) CLOCKS_PER_INIT#0 ← (number) $12
  to:@44
clock: scope:[clock]  from anim::@13
  (number~) clock::$0 ← (number) $ffffffff - *((dword*) CIA2_TIMER_AB#0)
  (dword) clock::return#0 ← (number~) clock::$0
  to:clock::@return
clock::@return: scope:[clock]  from clock
  (dword) clock::return#3 ← phi( clock/(dword) clock::return#0 )
  (dword) clock::return#1 ← (dword) clock::return#3
  return 
  to:@return
clock_start: scope:[clock_start]  from anim::@6
  (byte~) clock_start::$0 ← (byte) CIA_TIMER_CONTROL_STOP#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  (byte~) clock_start::$1 ← (byte~) clock_start::$0 | (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
  *((byte*) CIA2_TIMER_A_CONTROL#0) ← (byte~) clock_start::$1
  (byte~) clock_start::$2 ← (byte) CIA_TIMER_CONTROL_STOP#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  (byte~) clock_start::$3 ← (byte~) clock_start::$2 | (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
  *((byte*) CIA2_TIMER_B_CONTROL#0) ← (byte~) clock_start::$3
  *((dword*) CIA2_TIMER_AB#0) ← (number) $ffffffff
  (byte~) clock_start::$4 ← (byte) CIA_TIMER_CONTROL_START#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  (byte~) clock_start::$5 ← (byte~) clock_start::$4 | (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
  *((byte*) CIA2_TIMER_B_CONTROL#0) ← (byte~) clock_start::$5
  (byte~) clock_start::$6 ← (byte) CIA_TIMER_CONTROL_START#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  (byte~) clock_start::$7 ← (byte~) clock_start::$6 | (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
  *((byte*) CIA2_TIMER_A_CONTROL#0) ← (byte~) clock_start::$7
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  return 
  to:@return
print_word_at: scope:[print_word_at]  from print_dword_at print_dword_at::@1
  (byte*) print_word_at::at#2 ← phi( print_dword_at/(byte*) print_word_at::at#0 print_dword_at::@1/(byte*) print_word_at::at#1 )
  (word) print_word_at::w#2 ← phi( print_dword_at/(word) print_word_at::w#0 print_dword_at::@1/(word) print_word_at::w#1 )
  (byte~) print_word_at::$0 ← > (word) print_word_at::w#2
  (byte) print_byte_at::b#0 ← (byte~) print_word_at::$0
  (byte*) print_byte_at::at#0 ← (byte*) print_word_at::at#2
  call print_byte_at 
  to:print_word_at::@1
print_word_at::@1: scope:[print_word_at]  from print_word_at
  (byte*) print_word_at::at#3 ← phi( print_word_at/(byte*) print_word_at::at#2 )
  (word) print_word_at::w#3 ← phi( print_word_at/(word) print_word_at::w#2 )
  (byte~) print_word_at::$2 ← < (word) print_word_at::w#3
  (byte*~) print_word_at::$3 ← (byte*) print_word_at::at#3 + (number) 2
  (byte) print_byte_at::b#1 ← (byte~) print_word_at::$2
  (byte*) print_byte_at::at#1 ← (byte*~) print_word_at::$3
  call print_byte_at 
  to:print_word_at::@2
print_word_at::@2: scope:[print_word_at]  from print_word_at::@1
  to:print_word_at::@return
print_word_at::@return: scope:[print_word_at]  from print_word_at::@2
  return 
  to:@return
print_dword_at: scope:[print_dword_at]  from anim::@26
  (byte*) print_dword_at::at#1 ← phi( anim::@26/(byte*) print_dword_at::at#0 )
  (dword) print_dword_at::dw#1 ← phi( anim::@26/(dword) print_dword_at::dw#0 )
  (word~) print_dword_at::$0 ← > (dword) print_dword_at::dw#1
  (word) print_word_at::w#0 ← (word~) print_dword_at::$0
  (byte*) print_word_at::at#0 ← (byte*) print_dword_at::at#1
  call print_word_at 
  to:print_dword_at::@1
print_dword_at::@1: scope:[print_dword_at]  from print_dword_at
  (byte*) print_dword_at::at#2 ← phi( print_dword_at/(byte*) print_dword_at::at#1 )
  (dword) print_dword_at::dw#2 ← phi( print_dword_at/(dword) print_dword_at::dw#1 )
  (word~) print_dword_at::$2 ← < (dword) print_dword_at::dw#2
  (byte*~) print_dword_at::$3 ← (byte*) print_dword_at::at#2 + (number) 4
  (word) print_word_at::w#1 ← (word~) print_dword_at::$2
  (byte*) print_word_at::at#1 ← (byte*~) print_dword_at::$3
  call print_word_at 
  to:print_dword_at::@2
print_dword_at::@2: scope:[print_dword_at]  from print_dword_at::@1
  to:print_dword_at::@return
print_dword_at::@return: scope:[print_dword_at]  from print_dword_at::@2
  return 
  to:@return
@44: scope:[]  from @13
  (byte[]) print_hextab#0 ← (const string) $2
  to:@51
print_byte_at: scope:[print_byte_at]  from print_word_at print_word_at::@1
  (byte*) print_byte_at::at#2 ← phi( print_word_at/(byte*) print_byte_at::at#0 print_word_at::@1/(byte*) print_byte_at::at#1 )
  (byte) print_byte_at::b#2 ← phi( print_word_at/(byte) print_byte_at::b#0 print_word_at::@1/(byte) print_byte_at::b#1 )
  (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#2 >> (number) 4
  (byte) print_char_at::ch#0 ← *((byte[]) print_hextab#0 + (byte~) print_byte_at::$0)
  (byte*) print_char_at::at#0 ← (byte*) print_byte_at::at#2
  call print_char_at 
  to:print_byte_at::@1
print_byte_at::@1: scope:[print_byte_at]  from print_byte_at
  (byte*) print_byte_at::at#3 ← phi( print_byte_at/(byte*) print_byte_at::at#2 )
  (byte) print_byte_at::b#3 ← phi( print_byte_at/(byte) print_byte_at::b#2 )
  (number~) print_byte_at::$2 ← (byte) print_byte_at::b#3 & (number) $f
  (byte*~) print_byte_at::$3 ← (byte*) print_byte_at::at#3 + (number) 1
  (byte) print_char_at::ch#1 ← *((byte[]) print_hextab#0 + (number~) print_byte_at::$2)
  (byte*) print_char_at::at#1 ← (byte*~) print_byte_at::$3
  call print_char_at 
  to:print_byte_at::@2
print_byte_at::@2: scope:[print_byte_at]  from print_byte_at::@1
  to:print_byte_at::@return
print_byte_at::@return: scope:[print_byte_at]  from print_byte_at::@2
  return 
  to:@return
print_char_at: scope:[print_char_at]  from print_byte_at print_byte_at::@1
  (byte*) print_char_at::at#2 ← phi( print_byte_at/(byte*) print_char_at::at#0 print_byte_at::@1/(byte*) print_char_at::at#1 )
  (byte) print_char_at::ch#2 ← phi( print_byte_at/(byte) print_char_at::ch#0 print_byte_at::@1/(byte) print_char_at::ch#1 )
  *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  return 
  to:@return
@51: scope:[]  from @44
  (byte*) SCREEN#0 ← ((byte*)) (number) $400
  (byte[$140]) SIN#0 ← kickasm {{ .for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))
 }}
  (byte*~) $1 ← (byte[$140]) SIN#0 + (number) $40
  (byte*) COS#0 ← (byte*~) $1
  to:@53
main: scope:[main]  from @54
  (byte*) COS#9 ← phi( @54/(byte*) COS#11 )
  asm { sei  }
  call init 
  to:main::@1
main::@1: scope:[main]  from main
  (byte*) COS#7 ← phi( main/(byte*) COS#9 )
  call anim 
  to:main::@2
main::@2: scope:[main]  from main::@1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
init: scope:[init]  from main
  call mulf_init 
  to:init::@3
init::@3: scope:[init]  from init
  *((byte*) SPRITES_ENABLE#0) ← (number) $ff
  (byte*~) init::$1 ← (byte*) SCREEN#0 + (number) $3f8
  (byte*) init::sprites_ptr#0 ← (byte*~) init::$1
  (byte) init::i#0 ← (byte) 0
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@3
  (byte) init::i#2 ← phi( init::@1/(byte) init::i#1 init::@3/(byte) init::i#0 )
  (byte*) init::sprites_ptr#1 ← phi( init::@1/(byte*) init::sprites_ptr#1 init::@3/(byte*) init::sprites_ptr#0 )
  (byte*~) init::$2 ← (byte*) SPRITE#0 / (number) $40
  (byte~) init::$3 ← ((byte)) (byte*~) init::$2
  *((byte*) init::sprites_ptr#1 + (byte) init::i#2) ← (byte~) init::$3
  *((byte*) SPRITES_COLS#0 + (byte) init::i#2) ← (byte) GREEN#0
  (byte) init::i#1 ← (byte) init::i#2 + rangenext(0,7)
  (bool~) init::$4 ← (byte) init::i#1 != rangelast(0,7)
  if((bool~) init::$4) goto init::@1
  to:init::@return
init::@return: scope:[init]  from init::@1
  return 
  to:@return
@53: scope:[]  from @51
  (byte*) COS#15 ← phi( @51/(byte*) COS#0 )
  (signed byte[8]) xs#0 ← { (number) -$46, (number) -$46, (number) -$46, (number) 0, (number) 0, (number) $46, (number) $46, (number) $46 }
  (signed byte[8]) ys#0 ← { (number) -$46, (number) 0, (number) $46, (number) -$46, (number) $46, (number) -$46, (number) 0, (number) $46 }
  to:@54
anim: scope:[anim]  from main::@1
  (byte*) COS#5 ← phi( main::@1/(byte*) COS#7 )
  (byte) anim::angle#0 ← (number) 0
  to:anim::@1
anim::@1: scope:[anim]  from anim anim::@27
  (byte) anim::angle#9 ← phi( anim/(byte) anim::angle#0 anim::@27/(byte) anim::angle#11 )
  (byte*) COS#4 ← phi( anim/(byte*) COS#5 anim::@27/(byte*) COS#6 )
  if(true) goto anim::@4
  to:anim::@return
anim::@4: scope:[anim]  from anim::@1 anim::@4
  (byte) anim::angle#6 ← phi( anim::@1/(byte) anim::angle#9 anim::@4/(byte) anim::angle#6 )
  (byte*) COS#3 ← phi( anim::@1/(byte*) COS#4 anim::@4/(byte*) COS#3 )
  (bool~) anim::$0 ← *((byte*) RASTER#0) != (number) $ff
  if((bool~) anim::$0) goto anim::@4
  to:anim::@6
anim::@6: scope:[anim]  from anim::@4
  (byte) anim::angle#4 ← phi( anim::@4/(byte) anim::angle#6 )
  (byte*) COS#2 ← phi( anim::@4/(byte*) COS#3 )
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  call clock_start 
  to:anim::@19
anim::@19: scope:[anim]  from anim::@6
  (byte) anim::angle#2 ← phi( anim::@6/(byte) anim::angle#4 )
  (byte*) COS#1 ← phi( anim::@6/(byte*) COS#2 )
  (signed byte~) anim::$2 ← ((signed byte)) *((byte*) COS#1 + (byte) anim::angle#2)
  (signed byte) anim::cos_a#0 ← (signed byte~) anim::$2
  (signed byte~) anim::$3 ← ((signed byte)) *((byte[$140]) SIN#0 + (byte) anim::angle#2)
  (signed byte) anim::sin_a#0 ← (signed byte~) anim::$3
  (byte) anim::sprite_msb#0 ← (number) 0
  (byte) anim::i#0 ← (byte) 0
  to:anim::@10
anim::@10: scope:[anim]  from anim::@11 anim::@19
  (byte*) COS#25 ← phi( anim::@11/(byte*) COS#12 anim::@19/(byte*) COS#1 )
  (byte) anim::angle#21 ← phi( anim::@11/(byte) anim::angle#5 anim::@19/(byte) anim::angle#2 )
  (byte) anim::sprite_msb#16 ← phi( anim::@11/(byte) anim::sprite_msb#7 anim::@19/(byte) anim::sprite_msb#0 )
  (signed byte) anim::sin_a#6 ← phi( anim::@11/(signed byte) anim::sin_a#7 anim::@19/(signed byte) anim::sin_a#0 )
  (signed byte) anim::cos_a#1 ← phi( anim::@11/(signed byte) anim::cos_a#2 anim::@19/(signed byte) anim::cos_a#0 )
  (byte) anim::i#2 ← phi( anim::@11/(byte) anim::i#1 anim::@19/(byte) anim::i#0 )
  (signed byte) anim::x#0 ← *((signed byte[8]) xs#0 + (byte) anim::i#2)
  (signed byte) anim::y#0 ← *((signed byte[8]) ys#0 + (byte) anim::i#2)
  (signed byte) anim::mulf8s_prepare1_a#0 ← (signed byte) anim::cos_a#1
  to:anim::mulf8s_prepare1
anim::mulf8s_prepare1: scope:[anim]  from anim::@10
  (byte*) COS#24 ← phi( anim::@10/(byte*) COS#25 )
  (byte) anim::angle#20 ← phi( anim::@10/(byte) anim::angle#21 )
  (signed byte) anim::cos_a#13 ← phi( anim::@10/(signed byte) anim::cos_a#1 )
  (byte) anim::i#14 ← phi( anim::@10/(byte) anim::i#2 )
  (byte) anim::sprite_msb#15 ← phi( anim::@10/(byte) anim::sprite_msb#16 )
  (signed byte) anim::sin_a#5 ← phi( anim::@10/(signed byte) anim::sin_a#6 )
  (signed byte) anim::y#7 ← phi( anim::@10/(signed byte) anim::y#0 )
  (signed byte) anim::x#5 ← phi( anim::@10/(signed byte) anim::x#0 )
  (signed byte) anim::mulf8s_prepare1_a#1 ← phi( anim::@10/(signed byte) anim::mulf8s_prepare1_a#0 )
  (byte~) anim::mulf8s_prepare1_$0#0 ← ((byte)) (signed byte) anim::mulf8s_prepare1_a#1
  (byte) mulf8u_prepare::a#0 ← (byte~) anim::mulf8s_prepare1_$0#0
  call mulf8u_prepare 
  to:anim::@20
anim::@20: scope:[anim]  from anim::mulf8s_prepare1
  (byte*) COS#23 ← phi( anim::mulf8s_prepare1/(byte*) COS#24 )
  (byte) anim::angle#19 ← phi( anim::mulf8s_prepare1/(byte) anim::angle#20 )
  (signed byte) anim::cos_a#12 ← phi( anim::mulf8s_prepare1/(signed byte) anim::cos_a#13 )
  (byte) anim::i#13 ← phi( anim::mulf8s_prepare1/(byte) anim::i#14 )
  (byte) anim::sprite_msb#14 ← phi( anim::mulf8s_prepare1/(byte) anim::sprite_msb#15 )
  (signed byte) anim::sin_a#4 ← phi( anim::mulf8s_prepare1/(signed byte) anim::sin_a#5 )
  (signed byte) anim::y#5 ← phi( anim::mulf8s_prepare1/(signed byte) anim::y#7 )
  (signed byte) anim::x#3 ← phi( anim::mulf8s_prepare1/(signed byte) anim::x#5 )
  to:anim::@17
anim::@17: scope:[anim]  from anim::@20
  (byte*) COS#22 ← phi( anim::@20/(byte*) COS#23 )
  (byte) anim::angle#18 ← phi( anim::@20/(byte) anim::angle#19 )
  (signed byte) anim::cos_a#11 ← phi( anim::@20/(signed byte) anim::cos_a#12 )
  (byte) anim::i#12 ← phi( anim::@20/(byte) anim::i#13 )
  (byte) anim::sprite_msb#13 ← phi( anim::@20/(byte) anim::sprite_msb#14 )
  (signed byte) anim::sin_a#3 ← phi( anim::@20/(signed byte) anim::sin_a#4 )
  (signed byte) anim::y#3 ← phi( anim::@20/(signed byte) anim::y#5 )
  (signed byte) anim::x#1 ← phi( anim::@20/(signed byte) anim::x#3 )
  (signed byte) mulf8s_prepared::b#0 ← (signed byte) anim::x#1
  call mulf8s_prepared 
  (signed word) mulf8s_prepared::return#2 ← (signed word) mulf8s_prepared::return#1
  to:anim::@21
anim::@21: scope:[anim]  from anim::@17
  (byte*) COS#21 ← phi( anim::@17/(byte*) COS#22 )
  (byte) anim::angle#17 ← phi( anim::@17/(byte) anim::angle#18 )
  (signed byte) anim::cos_a#10 ← phi( anim::@17/(signed byte) anim::cos_a#11 )
  (byte) anim::i#11 ← phi( anim::@17/(byte) anim::i#12 )
  (byte) anim::sprite_msb#12 ← phi( anim::@17/(byte) anim::sprite_msb#13 )
  (signed byte) anim::x#9 ← phi( anim::@17/(signed byte) anim::x#1 )
  (signed byte) anim::sin_a#2 ← phi( anim::@17/(signed byte) anim::sin_a#3 )
  (signed byte) anim::y#1 ← phi( anim::@17/(signed byte) anim::y#3 )
  (signed word) mulf8s_prepared::return#7 ← phi( anim::@17/(signed word) mulf8s_prepared::return#2 )
  (signed word~) anim::$5 ← (signed word) mulf8s_prepared::return#7
  (number~) anim::$6 ← (signed word~) anim::$5 * (number) 2
  (signed word) anim::xr#0 ← (number~) anim::$6
  (signed byte) mulf8s_prepared::b#1 ← (signed byte) anim::y#1
  call mulf8s_prepared 
  (signed word) mulf8s_prepared::return#3 ← (signed word) mulf8s_prepared::return#1
  to:anim::@22
anim::@22: scope:[anim]  from anim::@21
  (byte*) COS#20 ← phi( anim::@21/(byte*) COS#21 )
  (byte) anim::angle#16 ← phi( anim::@21/(byte) anim::angle#17 )
  (signed byte) anim::cos_a#9 ← phi( anim::@21/(signed byte) anim::cos_a#10 )
  (byte) anim::i#10 ← phi( anim::@21/(byte) anim::i#11 )
  (byte) anim::sprite_msb#11 ← phi( anim::@21/(byte) anim::sprite_msb#12 )
  (signed byte) anim::x#8 ← phi( anim::@21/(signed byte) anim::x#9 )
  (signed word) anim::xr#7 ← phi( anim::@21/(signed word) anim::xr#0 )
  (signed byte) anim::y#8 ← phi( anim::@21/(signed byte) anim::y#1 )
  (signed byte) anim::sin_a#1 ← phi( anim::@21/(signed byte) anim::sin_a#2 )
  (signed word) mulf8s_prepared::return#8 ← phi( anim::@21/(signed word) mulf8s_prepared::return#3 )
  (signed word~) anim::$7 ← (signed word) mulf8s_prepared::return#8
  (number~) anim::$8 ← (signed word~) anim::$7 * (number) 2
  (signed word) anim::yr#0 ← (number~) anim::$8
  (signed byte) anim::mulf8s_prepare2_a#0 ← (signed byte) anim::sin_a#1
  to:anim::mulf8s_prepare2
anim::mulf8s_prepare2: scope:[anim]  from anim::@22
  (byte*) COS#19 ← phi( anim::@22/(byte*) COS#20 )
  (signed byte) anim::sin_a#13 ← phi( anim::@22/(signed byte) anim::sin_a#1 )
  (byte) anim::angle#15 ← phi( anim::@22/(byte) anim::angle#16 )
  (signed byte) anim::cos_a#8 ← phi( anim::@22/(signed byte) anim::cos_a#9 )
  (byte) anim::i#9 ← phi( anim::@22/(byte) anim::i#10 )
  (byte) anim::sprite_msb#10 ← phi( anim::@22/(byte) anim::sprite_msb#11 )
  (signed word) anim::yr#8 ← phi( anim::@22/(signed word) anim::yr#0 )
  (signed byte) anim::x#7 ← phi( anim::@22/(signed byte) anim::x#8 )
  (signed word) anim::xr#6 ← phi( anim::@22/(signed word) anim::xr#7 )
  (signed byte) anim::y#6 ← phi( anim::@22/(signed byte) anim::y#8 )
  (signed byte) anim::mulf8s_prepare2_a#1 ← phi( anim::@22/(signed byte) anim::mulf8s_prepare2_a#0 )
  (byte~) anim::mulf8s_prepare2_$0#0 ← ((byte)) (signed byte) anim::mulf8s_prepare2_a#1
  (byte) mulf8u_prepare::a#1 ← (byte~) anim::mulf8s_prepare2_$0#0
  call mulf8u_prepare 
  to:anim::@23
anim::@23: scope:[anim]  from anim::mulf8s_prepare2
  (byte*) COS#18 ← phi( anim::mulf8s_prepare2/(byte*) COS#19 )
  (signed byte) anim::sin_a#12 ← phi( anim::mulf8s_prepare2/(signed byte) anim::sin_a#13 )
  (byte) anim::angle#13 ← phi( anim::mulf8s_prepare2/(byte) anim::angle#15 )
  (signed byte) anim::cos_a#7 ← phi( anim::mulf8s_prepare2/(signed byte) anim::cos_a#8 )
  (byte) anim::i#8 ← phi( anim::mulf8s_prepare2/(byte) anim::i#9 )
  (byte) anim::sprite_msb#9 ← phi( anim::mulf8s_prepare2/(byte) anim::sprite_msb#10 )
  (signed word) anim::yr#7 ← phi( anim::mulf8s_prepare2/(signed word) anim::yr#8 )
  (signed byte) anim::x#6 ← phi( anim::mulf8s_prepare2/(signed byte) anim::x#7 )
  (signed word) anim::xr#5 ← phi( anim::mulf8s_prepare2/(signed word) anim::xr#6 )
  (signed byte) anim::y#4 ← phi( anim::mulf8s_prepare2/(signed byte) anim::y#6 )
  to:anim::@18
anim::@18: scope:[anim]  from anim::@23
  (byte*) COS#17 ← phi( anim::@23/(byte*) COS#18 )
  (signed byte) anim::sin_a#11 ← phi( anim::@23/(signed byte) anim::sin_a#12 )
  (byte) anim::angle#12 ← phi( anim::@23/(byte) anim::angle#13 )
  (signed byte) anim::cos_a#6 ← phi( anim::@23/(signed byte) anim::cos_a#7 )
  (byte) anim::i#7 ← phi( anim::@23/(byte) anim::i#8 )
  (byte) anim::sprite_msb#8 ← phi( anim::@23/(byte) anim::sprite_msb#9 )
  (signed word) anim::yr#6 ← phi( anim::@23/(signed word) anim::yr#7 )
  (signed byte) anim::x#4 ← phi( anim::@23/(signed byte) anim::x#6 )
  (signed word) anim::xr#4 ← phi( anim::@23/(signed word) anim::xr#5 )
  (signed byte) anim::y#2 ← phi( anim::@23/(signed byte) anim::y#4 )
  (signed byte) mulf8s_prepared::b#2 ← (signed byte) anim::y#2
  call mulf8s_prepared 
  (signed word) mulf8s_prepared::return#4 ← (signed word) mulf8s_prepared::return#1
  to:anim::@24
anim::@24: scope:[anim]  from anim::@18
  (byte*) COS#16 ← phi( anim::@18/(byte*) COS#17 )
  (signed byte) anim::sin_a#10 ← phi( anim::@18/(signed byte) anim::sin_a#11 )
  (byte) anim::angle#10 ← phi( anim::@18/(byte) anim::angle#12 )
  (signed byte) anim::cos_a#5 ← phi( anim::@18/(signed byte) anim::cos_a#6 )
  (byte) anim::i#6 ← phi( anim::@18/(byte) anim::i#7 )
  (byte) anim::sprite_msb#6 ← phi( anim::@18/(byte) anim::sprite_msb#8 )
  (signed word) anim::yr#4 ← phi( anim::@18/(signed word) anim::yr#6 )
  (signed byte) anim::x#2 ← phi( anim::@18/(signed byte) anim::x#4 )
  (signed word) anim::xr#2 ← phi( anim::@18/(signed word) anim::xr#4 )
  (signed word) mulf8s_prepared::return#9 ← phi( anim::@18/(signed word) mulf8s_prepared::return#4 )
  (signed word~) anim::$10 ← (signed word) mulf8s_prepared::return#9
  (number~) anim::$11 ← (signed word~) anim::$10 * (number) 2
  (signed word) anim::xr#1 ← (signed word) anim::xr#2 - (number~) anim::$11
  (signed byte) mulf8s_prepared::b#3 ← (signed byte) anim::x#2
  call mulf8s_prepared 
  (signed word) mulf8s_prepared::return#5 ← (signed word) mulf8s_prepared::return#1
  to:anim::@25
anim::@25: scope:[anim]  from anim::@24
  (byte*) COS#14 ← phi( anim::@24/(byte*) COS#16 )
  (signed byte) anim::sin_a#9 ← phi( anim::@24/(signed byte) anim::sin_a#10 )
  (byte) anim::angle#8 ← phi( anim::@24/(byte) anim::angle#10 )
  (signed byte) anim::cos_a#4 ← phi( anim::@24/(signed byte) anim::cos_a#5 )
  (byte) anim::i#5 ← phi( anim::@24/(byte) anim::i#6 )
  (byte) anim::sprite_msb#3 ← phi( anim::@24/(byte) anim::sprite_msb#6 )
  (signed word) anim::xr#3 ← phi( anim::@24/(signed word) anim::xr#1 )
  (signed word) anim::yr#2 ← phi( anim::@24/(signed word) anim::yr#4 )
  (signed word) mulf8s_prepared::return#10 ← phi( anim::@24/(signed word) mulf8s_prepared::return#5 )
  (signed word~) anim::$12 ← (signed word) mulf8s_prepared::return#10
  (number~) anim::$13 ← (signed word~) anim::$12 * (number) 2
  (signed word) anim::yr#1 ← (signed word) anim::yr#2 + (number~) anim::$13
  (byte~) anim::$14 ← > (signed word) anim::xr#3
  (signed byte~) anim::$15 ← ((signed byte)) (byte~) anim::$14
  (number~) anim::$16 ← (signed byte~) anim::$15 + (number) $18
  (number~) anim::$17 ← (number~) anim::$16 + (number) $95
  (signed word) anim::xpos#0 ← (number~) anim::$17
  (number~) anim::$18 ← (byte) anim::sprite_msb#3 / (number) 2
  (byte) anim::sprite_msb#1 ← (number~) anim::$18
  (byte~) anim::$19 ← > (signed word) anim::xpos#0
  (bool~) anim::$20 ← (byte~) anim::$19 != (number) 0
  (bool~) anim::$21 ← ! (bool~) anim::$20
  if((bool~) anim::$21) goto anim::@11
  to:anim::@12
anim::@11: scope:[anim]  from anim::@12 anim::@25
  (byte*) COS#12 ← phi( anim::@12/(byte*) COS#13 anim::@25/(byte*) COS#14 )
  (signed byte) anim::sin_a#7 ← phi( anim::@12/(signed byte) anim::sin_a#8 anim::@25/(signed byte) anim::sin_a#9 )
  (byte) anim::angle#5 ← phi( anim::@12/(byte) anim::angle#7 anim::@25/(byte) anim::angle#8 )
  (byte) anim::sprite_msb#7 ← phi( anim::@12/(byte) anim::sprite_msb#2 anim::@25/(byte) anim::sprite_msb#1 )
  (signed byte) anim::cos_a#2 ← phi( anim::@12/(signed byte) anim::cos_a#3 anim::@25/(signed byte) anim::cos_a#4 )
  (signed word) anim::xpos#1 ← phi( anim::@12/(signed word) anim::xpos#2 anim::@25/(signed word) anim::xpos#0 )
  (byte) anim::i#3 ← phi( anim::@12/(byte) anim::i#4 anim::@25/(byte) anim::i#5 )
  (signed word) anim::yr#3 ← phi( anim::@12/(signed word) anim::yr#5 anim::@25/(signed word) anim::yr#1 )
  (byte~) anim::$22 ← > (signed word) anim::yr#3
  (number~) anim::$23 ← (byte~) anim::$22 + (number) $59
  (number~) anim::$24 ← (number~) anim::$23 + (number) $33
  (byte) anim::ypos#0 ← (number~) anim::$24
  (number~) anim::$25 ← (byte) anim::i#3 * (number) 2
  (byte) anim::i2#0 ← (number~) anim::$25
  (byte~) anim::$26 ← < (signed word) anim::xpos#1
  *((byte*) SPRITES_XPOS#0 + (byte) anim::i2#0) ← (byte~) anim::$26
  *((byte*) SPRITES_YPOS#0 + (byte) anim::i2#0) ← (byte) anim::ypos#0
  (byte) anim::i#1 ← (byte) anim::i#3 + rangenext(0,7)
  (bool~) anim::$27 ← (byte) anim::i#1 != rangelast(0,7)
  if((bool~) anim::$27) goto anim::@10
  to:anim::@13
anim::@12: scope:[anim]  from anim::@25
  (byte*) COS#13 ← phi( anim::@25/(byte*) COS#14 )
  (signed byte) anim::sin_a#8 ← phi( anim::@25/(signed byte) anim::sin_a#9 )
  (byte) anim::angle#7 ← phi( anim::@25/(byte) anim::angle#8 )
  (signed byte) anim::cos_a#3 ← phi( anim::@25/(signed byte) anim::cos_a#4 )
  (signed word) anim::xpos#2 ← phi( anim::@25/(signed word) anim::xpos#0 )
  (byte) anim::i#4 ← phi( anim::@25/(byte) anim::i#5 )
  (signed word) anim::yr#5 ← phi( anim::@25/(signed word) anim::yr#1 )
  (byte) anim::sprite_msb#4 ← phi( anim::@25/(byte) anim::sprite_msb#1 )
  (byte) anim::sprite_msb#2 ← (byte) anim::sprite_msb#4 | (number) $80
  to:anim::@11
anim::@13: scope:[anim]  from anim::@11
  (byte*) COS#10 ← phi( anim::@11/(byte*) COS#12 )
  (byte) anim::angle#3 ← phi( anim::@11/(byte) anim::angle#5 )
  (byte) anim::sprite_msb#5 ← phi( anim::@11/(byte) anim::sprite_msb#7 )
  *((byte*) SPRITES_XMSB#0) ← (byte) anim::sprite_msb#5
  (byte) anim::angle#1 ← ++ (byte) anim::angle#3
  call clock 
  (dword) clock::return#2 ← (dword) clock::return#1
  to:anim::@26
anim::@26: scope:[anim]  from anim::@13
  (byte) anim::angle#14 ← phi( anim::@13/(byte) anim::angle#1 )
  (byte*) COS#8 ← phi( anim::@13/(byte*) COS#10 )
  (dword) clock::return#4 ← phi( anim::@13/(dword) clock::return#2 )
  (dword~) anim::$28 ← (dword) clock::return#4
  (dword~) anim::$29 ← (dword~) anim::$28 - (dword) CLOCKS_PER_INIT#0
  (dword) anim::cyclecount#0 ← (dword~) anim::$29
  (dword) print_dword_at::dw#0 ← (dword) anim::cyclecount#0
  (byte*) print_dword_at::at#0 ← (byte*) SCREEN#0
  call print_dword_at 
  to:anim::@27
anim::@27: scope:[anim]  from anim::@26
  (byte) anim::angle#11 ← phi( anim::@26/(byte) anim::angle#14 )
  (byte*) COS#6 ← phi( anim::@26/(byte*) COS#8 )
  *((byte*) BORDERCOL#0) ← (byte) LIGHT_BLUE#0
  to:anim::@1
anim::@return: scope:[anim]  from anim::@1
  return 
  to:@return
@54: scope:[]  from @53
  (byte*) COS#11 ← phi( @53/(byte*) COS#15 )
  (byte*) SPRITE#0 ← ((byte*)) (number) $3000
  kickasm(location (byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  call main 
  to:@55
@55: scope:[]  from @54
  to:@end
@end: scope:[]  from @55

SYMBOL TABLE SSA
(byte*~) $1
(const string) $2 = (string) "0123456789abcdef"
(label) @13
(label) @4
(label) @44
(label) @51
(label) @53
(label) @54
(label) @55
(label) @begin
(label) @end
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(dword*) CIA2_TIMER_AB
(dword*) CIA2_TIMER_AB#0
(byte*) CIA2_TIMER_A_CONTROL
(byte*) CIA2_TIMER_A_CONTROL#0
(byte*) CIA2_TIMER_B_CONTROL
(byte*) CIA2_TIMER_B_CONTROL#0
(byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
(byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
(byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
(byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
(byte) CIA_TIMER_CONTROL_CONTINUOUS
(byte) CIA_TIMER_CONTROL_CONTINUOUS#0
(byte) CIA_TIMER_CONTROL_START
(byte) CIA_TIMER_CONTROL_START#0
(byte) CIA_TIMER_CONTROL_STOP
(byte) CIA_TIMER_CONTROL_STOP#0
(dword) CLOCKS_PER_INIT
(dword) CLOCKS_PER_INIT#0
(byte*) COS
(byte*) COS#0
(byte*) COS#1
(byte*) COS#10
(byte*) COS#11
(byte*) COS#12
(byte*) COS#13
(byte*) COS#14
(byte*) COS#15
(byte*) COS#16
(byte*) COS#17
(byte*) COS#18
(byte*) COS#19
(byte*) COS#2
(byte*) COS#20
(byte*) COS#21
(byte*) COS#22
(byte*) COS#23
(byte*) COS#24
(byte*) COS#25
(byte*) COS#3
(byte*) COS#4
(byte*) COS#5
(byte*) COS#6
(byte*) COS#7
(byte*) COS#8
(byte*) COS#9
(byte) GREEN
(byte) GREEN#0
(byte) LIGHT_BLUE
(byte) LIGHT_BLUE#0
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(byte*) RASTER
(byte*) RASTER#0
(byte*) SCREEN
(byte*) SCREEN#0
(byte[$140]) SIN
(byte[$140]) SIN#0
(byte*) SPRITE
(byte*) SPRITE#0
(byte*) SPRITES_COLS
(byte*) SPRITES_COLS#0
(byte*) SPRITES_ENABLE
(byte*) SPRITES_ENABLE#0
(byte*) SPRITES_XMSB
(byte*) SPRITES_XMSB#0
(byte*) SPRITES_XPOS
(byte*) SPRITES_XPOS#0
(byte*) SPRITES_YPOS
(byte*) SPRITES_YPOS#0
(void()) anim()
(bool~) anim::$0
(signed word~) anim::$10
(number~) anim::$11
(signed word~) anim::$12
(number~) anim::$13
(byte~) anim::$14
(signed byte~) anim::$15
(number~) anim::$16
(number~) anim::$17
(number~) anim::$18
(byte~) anim::$19
(signed byte~) anim::$2
(bool~) anim::$20
(bool~) anim::$21
(byte~) anim::$22
(number~) anim::$23
(number~) anim::$24
(number~) anim::$25
(byte~) anim::$26
(bool~) anim::$27
(dword~) anim::$28
(dword~) anim::$29
(signed byte~) anim::$3
(signed word~) anim::$5
(number~) anim::$6
(signed word~) anim::$7
(number~) anim::$8
(label) anim::@1
(label) anim::@10
(label) anim::@11
(label) anim::@12
(label) anim::@13
(label) anim::@17
(label) anim::@18
(label) anim::@19
(label) anim::@20
(label) anim::@21
(label) anim::@22
(label) anim::@23
(label) anim::@24
(label) anim::@25
(label) anim::@26
(label) anim::@27
(label) anim::@4
(label) anim::@6
(label) anim::@return
(byte) anim::angle
(byte) anim::angle#0
(byte) anim::angle#1
(byte) anim::angle#10
(byte) anim::angle#11
(byte) anim::angle#12
(byte) anim::angle#13
(byte) anim::angle#14
(byte) anim::angle#15
(byte) anim::angle#16
(byte) anim::angle#17
(byte) anim::angle#18
(byte) anim::angle#19
(byte) anim::angle#2
(byte) anim::angle#20
(byte) anim::angle#21
(byte) anim::angle#3
(byte) anim::angle#4
(byte) anim::angle#5
(byte) anim::angle#6
(byte) anim::angle#7
(byte) anim::angle#8
(byte) anim::angle#9
(signed byte) anim::cos_a
(signed byte) anim::cos_a#0
(signed byte) anim::cos_a#1
(signed byte) anim::cos_a#10
(signed byte) anim::cos_a#11
(signed byte) anim::cos_a#12
(signed byte) anim::cos_a#13
(signed byte) anim::cos_a#2
(signed byte) anim::cos_a#3
(signed byte) anim::cos_a#4
(signed byte) anim::cos_a#5
(signed byte) anim::cos_a#6
(signed byte) anim::cos_a#7
(signed byte) anim::cos_a#8
(signed byte) anim::cos_a#9
(dword) anim::cyclecount
(dword) anim::cyclecount#0
(byte) anim::i
(byte) anim::i#0
(byte) anim::i#1
(byte) anim::i#10
(byte) anim::i#11
(byte) anim::i#12
(byte) anim::i#13
(byte) anim::i#14
(byte) anim::i#2
(byte) anim::i#3
(byte) anim::i#4
(byte) anim::i#5
(byte) anim::i#6
(byte) anim::i#7
(byte) anim::i#8
(byte) anim::i#9
(byte) anim::i2
(byte) anim::i2#0
(label) anim::mulf8s_prepare1
(byte~) anim::mulf8s_prepare1_$0
(byte~) anim::mulf8s_prepare1_$0#0
(signed byte) anim::mulf8s_prepare1_a
(signed byte) anim::mulf8s_prepare1_a#0
(signed byte) anim::mulf8s_prepare1_a#1
(label) anim::mulf8s_prepare2
(byte~) anim::mulf8s_prepare2_$0
(byte~) anim::mulf8s_prepare2_$0#0
(signed byte) anim::mulf8s_prepare2_a
(signed byte) anim::mulf8s_prepare2_a#0
(signed byte) anim::mulf8s_prepare2_a#1
(signed byte) anim::sin_a
(signed byte) anim::sin_a#0
(signed byte) anim::sin_a#1
(signed byte) anim::sin_a#10
(signed byte) anim::sin_a#11
(signed byte) anim::sin_a#12
(signed byte) anim::sin_a#13
(signed byte) anim::sin_a#2
(signed byte) anim::sin_a#3
(signed byte) anim::sin_a#4
(signed byte) anim::sin_a#5
(signed byte) anim::sin_a#6
(signed byte) anim::sin_a#7
(signed byte) anim::sin_a#8
(signed byte) anim::sin_a#9
(byte) anim::sprite_msb
(byte) anim::sprite_msb#0
(byte) anim::sprite_msb#1
(byte) anim::sprite_msb#10
(byte) anim::sprite_msb#11
(byte) anim::sprite_msb#12
(byte) anim::sprite_msb#13
(byte) anim::sprite_msb#14
(byte) anim::sprite_msb#15
(byte) anim::sprite_msb#16
(byte) anim::sprite_msb#2
(byte) anim::sprite_msb#3
(byte) anim::sprite_msb#4
(byte) anim::sprite_msb#5
(byte) anim::sprite_msb#6
(byte) anim::sprite_msb#7
(byte) anim::sprite_msb#8
(byte) anim::sprite_msb#9
(signed byte) anim::x
(signed byte) anim::x#0
(signed byte) anim::x#1
(signed byte) anim::x#2
(signed byte) anim::x#3
(signed byte) anim::x#4
(signed byte) anim::x#5
(signed byte) anim::x#6
(signed byte) anim::x#7
(signed byte) anim::x#8
(signed byte) anim::x#9
(signed word) anim::xpos
(signed word) anim::xpos#0
(signed word) anim::xpos#1
(signed word) anim::xpos#2
(signed word) anim::xr
(signed word) anim::xr#0
(signed word) anim::xr#1
(signed word) anim::xr#2
(signed word) anim::xr#3
(signed word) anim::xr#4
(signed word) anim::xr#5
(signed word) anim::xr#6
(signed word) anim::xr#7
(signed byte) anim::y
(signed byte) anim::y#0
(signed byte) anim::y#1
(signed byte) anim::y#2
(signed byte) anim::y#3
(signed byte) anim::y#4
(signed byte) anim::y#5
(signed byte) anim::y#6
(signed byte) anim::y#7
(signed byte) anim::y#8
(byte) anim::ypos
(byte) anim::ypos#0
(signed word) anim::yr
(signed word) anim::yr#0
(signed word) anim::yr#1
(signed word) anim::yr#2
(signed word) anim::yr#3
(signed word) anim::yr#4
(signed word) anim::yr#5
(signed word) anim::yr#6
(signed word) anim::yr#7
(signed word) anim::yr#8
(dword()) clock()
(number~) clock::$0
(label) clock::@return
(dword) clock::return
(dword) clock::return#0
(dword) clock::return#1
(dword) clock::return#2
(dword) clock::return#3
(dword) clock::return#4
(void()) clock_start()
(byte~) clock_start::$0
(byte~) clock_start::$1
(byte~) clock_start::$2
(byte~) clock_start::$3
(byte~) clock_start::$4
(byte~) clock_start::$5
(byte~) clock_start::$6
(byte~) clock_start::$7
(label) clock_start::@return
(void()) init()
(byte*~) init::$1
(byte*~) init::$2
(byte~) init::$3
(bool~) init::$4
(label) init::@1
(label) init::@3
(label) init::@return
(byte) init::i
(byte) init::i#0
(byte) init::i#1
(byte) init::i#2
(byte*) init::sprites_ptr
(byte*) init::sprites_ptr#0
(byte*) init::sprites_ptr#1
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(signed word()) mulf8s_prepared((signed byte) mulf8s_prepared::b)
(byte~) mulf8s_prepared::$0
(word~) mulf8s_prepared::$1
(byte~) mulf8s_prepared::$10
(byte~) mulf8s_prepared::$12
(byte~) mulf8s_prepared::$13
(byte~) mulf8s_prepared::$14
(byte~) mulf8s_prepared::$15
(byte~) mulf8s_prepared::$16
(bool~) mulf8s_prepared::$2
(bool~) mulf8s_prepared::$3
(bool~) mulf8s_prepared::$4
(bool~) mulf8s_prepared::$5
(signed word~) mulf8s_prepared::$6
(byte~) mulf8s_prepared::$8
(byte~) mulf8s_prepared::$9
(label) mulf8s_prepared::@1
(label) mulf8s_prepared::@2
(label) mulf8s_prepared::@3
(label) mulf8s_prepared::@4
(label) mulf8s_prepared::@6
(label) mulf8s_prepared::@return
(signed byte) mulf8s_prepared::b
(signed byte) mulf8s_prepared::b#0
(signed byte) mulf8s_prepared::b#1
(signed byte) mulf8s_prepared::b#2
(signed byte) mulf8s_prepared::b#3
(signed byte) mulf8s_prepared::b#4
(signed byte) mulf8s_prepared::b#5
(signed byte) mulf8s_prepared::b#6
(signed byte) mulf8s_prepared::b#7
(word) mulf8s_prepared::m
(word) mulf8s_prepared::m#0
(word) mulf8s_prepared::m#1
(word) mulf8s_prepared::m#2
(word) mulf8s_prepared::m#3
(word) mulf8s_prepared::m#4
(word) mulf8s_prepared::m#5
(word) mulf8s_prepared::m#6
(signed byte*) mulf8s_prepared::memA
(signed byte*) mulf8s_prepared::memA#0
(signed word) mulf8s_prepared::return
(signed word) mulf8s_prepared::return#0
(signed word) mulf8s_prepared::return#1
(signed word) mulf8s_prepared::return#10
(signed word) mulf8s_prepared::return#2
(signed word) mulf8s_prepared::return#3
(signed word) mulf8s_prepared::return#4
(signed word) mulf8s_prepared::return#5
(signed word) mulf8s_prepared::return#6
(signed word) mulf8s_prepared::return#7
(signed word) mulf8s_prepared::return#8
(signed word) mulf8s_prepared::return#9
(void()) mulf8u_prepare((byte) mulf8u_prepare::a)
(label) mulf8u_prepare::@return
(byte) mulf8u_prepare::a
(byte) mulf8u_prepare::a#0
(byte) mulf8u_prepare::a#1
(byte) mulf8u_prepare::a#2
(byte*) mulf8u_prepare::memA
(byte*) mulf8u_prepare::memA#0
(word()) mulf8u_prepared((byte) mulf8u_prepared::b)
(label) mulf8u_prepared::@return
(byte) mulf8u_prepared::b
(byte) mulf8u_prepared::b#0
(byte) mulf8u_prepared::b#1
(byte*) mulf8u_prepared::memB
(byte*) mulf8u_prepared::memB#0
(byte*) mulf8u_prepared::resL
(byte*) mulf8u_prepared::resL#0
(word) mulf8u_prepared::return
(word) mulf8u_prepared::return#0
(word) mulf8u_prepared::return#1
(word) mulf8u_prepared::return#2
(word) mulf8u_prepared::return#3
(word) mulf8u_prepared::return#4
(void()) mulf_init()
(byte*~) mulf_init::$0
(byte~) mulf_init::$1
(byte~) mulf_init::$10
(byte~) mulf_init::$11
(word~) mulf_init::$12
(byte*~) mulf_init::$13
(bool~) mulf_init::$14
(byte~) mulf_init::$15
(bool~) mulf_init::$16
(bool~) mulf_init::$17
(byte*~) mulf_init::$18
(bool~) mulf_init::$19
(byte*~) mulf_init::$2
(byte*~) mulf_init::$3
(byte*~) mulf_init::$4
(byte*~) mulf_init::$5
(byte*~) mulf_init::$6
(number~) mulf_init::$7
(bool~) mulf_init::$8
(bool~) mulf_init::$9
(label) mulf_init::@1
(label) mulf_init::@2
(label) mulf_init::@3
(label) mulf_init::@4
(label) mulf_init::@5
(label) mulf_init::@6
(label) mulf_init::@7
(label) mulf_init::@8
(label) mulf_init::@return
(byte) mulf_init::c
(byte) mulf_init::c#0
(byte) mulf_init::c#1
(byte) mulf_init::c#2
(byte) mulf_init::c#3
(byte) mulf_init::c#4
(byte) mulf_init::dir
(byte) mulf_init::dir#0
(byte) mulf_init::dir#1
(byte) mulf_init::dir#2
(byte) mulf_init::dir#3
(word) mulf_init::sqr
(word) mulf_init::sqr#0
(word) mulf_init::sqr#1
(word) mulf_init::sqr#2
(word) mulf_init::sqr#3
(word) mulf_init::sqr#4
(word) mulf_init::sqr#5
(byte*) mulf_init::sqr1_hi
(byte*) mulf_init::sqr1_hi#0
(byte*) mulf_init::sqr1_hi#1
(byte*) mulf_init::sqr1_hi#2
(byte*) mulf_init::sqr1_hi#3
(byte*) mulf_init::sqr1_hi#4
(byte*) mulf_init::sqr1_lo
(byte*) mulf_init::sqr1_lo#0
(byte*) mulf_init::sqr1_lo#1
(byte*) mulf_init::sqr1_lo#2
(byte*) mulf_init::sqr1_lo#3
(byte*) mulf_init::sqr1_lo#4
(byte*) mulf_init::sqr2_hi
(byte*) mulf_init::sqr2_hi#0
(byte*) mulf_init::sqr2_hi#1
(byte*) mulf_init::sqr2_hi#2
(byte*) mulf_init::sqr2_hi#3
(byte*) mulf_init::sqr2_hi#4
(byte*) mulf_init::sqr2_lo
(byte*) mulf_init::sqr2_lo#0
(byte*) mulf_init::sqr2_lo#1
(byte*) mulf_init::sqr2_lo#2
(byte*) mulf_init::sqr2_lo#3
(byte*) mulf_init::sqr2_lo#4
(byte) mulf_init::x_2
(byte) mulf_init::x_2#0
(byte) mulf_init::x_2#1
(byte) mulf_init::x_2#2
(byte) mulf_init::x_2#3
(byte) mulf_init::x_2#4
(byte) mulf_init::x_255
(byte) mulf_init::x_255#0
(byte) mulf_init::x_255#1
(byte) mulf_init::x_255#2
(byte) mulf_init::x_255#3
(byte) mulf_init::x_255#4
(byte[$200]) mulf_sqr1_hi
(byte[$200]) mulf_sqr1_hi#0
(byte[$200]) mulf_sqr1_lo
(byte[$200]) mulf_sqr1_lo#0
(byte[$200]) mulf_sqr2_hi
(byte[$200]) mulf_sqr2_hi#0
(byte[$200]) mulf_sqr2_lo
(byte[$200]) mulf_sqr2_lo#0
(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
(byte~) print_byte_at::$0
(number~) print_byte_at::$2
(byte*~) print_byte_at::$3
(label) print_byte_at::@1
(label) print_byte_at::@2
(label) print_byte_at::@return
(byte*) print_byte_at::at
(byte*) print_byte_at::at#0
(byte*) print_byte_at::at#1
(byte*) print_byte_at::at#2
(byte*) print_byte_at::at#3
(byte) print_byte_at::b
(byte) print_byte_at::b#0
(byte) print_byte_at::b#1
(byte) print_byte_at::b#2
(byte) print_byte_at::b#3
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(label) print_char_at::@return
(byte*) print_char_at::at
(byte*) print_char_at::at#0
(byte*) print_char_at::at#1
(byte*) print_char_at::at#2
(byte) print_char_at::ch
(byte) print_char_at::ch#0
(byte) print_char_at::ch#1
(byte) print_char_at::ch#2
(void()) print_dword_at((dword) print_dword_at::dw , (byte*) print_dword_at::at)
(word~) print_dword_at::$0
(word~) print_dword_at::$2
(byte*~) print_dword_at::$3
(label) print_dword_at::@1
(label) print_dword_at::@2
(label) print_dword_at::@return
(byte*) print_dword_at::at
(byte*) print_dword_at::at#0
(byte*) print_dword_at::at#1
(byte*) print_dword_at::at#2
(dword) print_dword_at::dw
(dword) print_dword_at::dw#0
(dword) print_dword_at::dw#1
(dword) print_dword_at::dw#2
(byte[]) print_hextab
(byte[]) print_hextab#0
(void()) print_word_at((word) print_word_at::w , (byte*) print_word_at::at)
(byte~) print_word_at::$0
(byte~) print_word_at::$2
(byte*~) print_word_at::$3
(label) print_word_at::@1
(label) print_word_at::@2
(label) print_word_at::@return
(byte*) print_word_at::at
(byte*) print_word_at::at#0
(byte*) print_word_at::at#1
(byte*) print_word_at::at#2
(byte*) print_word_at::at#3
(word) print_word_at::w
(word) print_word_at::w#0
(word) print_word_at::w#1
(word) print_word_at::w#2
(word) print_word_at::w#3
(signed byte[8]) xs
(signed byte[8]) xs#0
(signed byte[8]) ys
(signed byte[8]) ys#0

Fixing inline constructor with mulf8u_prepared::$0 ← (byte)*(mulf8u_prepared::memB#0) w= (byte)*(mulf8u_prepared::resL#0)
Successful SSA optimization Pass2FixInlineConstructors
Adding number conversion cast (unumber) 0 in (byte) CIA_TIMER_CONTROL_STOP#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) CIA_TIMER_CONTROL_START#0 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) CIA_TIMER_CONTROL_CONTINUOUS#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0 ← (number) 0
Adding number conversion cast (unumber) $40 in (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 ← (number) $40
Adding number conversion cast (unumber) 5 in (byte) GREEN#0 ← (number) 5
Adding number conversion cast (unumber) $e in (byte) LIGHT_BLUE#0 ← (number) $e
Adding number conversion cast (unumber) 0 in (word) mulf_init::sqr#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) mulf_init::x_2#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) mulf_init::c#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte*~) mulf_init::$0 ← (byte[$200]) mulf_sqr1_hi#0 + (number) 1
Adding number conversion cast (unumber) 1 in (byte*~) mulf_init::$6 ← (byte[$200]) mulf_sqr1_lo#0 + (number) 1
Adding number conversion cast (unumber) 1 in (number~) mulf_init::$7 ← (byte) mulf_init::c#1 & (number) 1
Adding number conversion cast (unumber) mulf_init::$7 in (number~) mulf_init::$7 ← (byte) mulf_init::c#1 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) mulf_init::$8 ← (unumber~) mulf_init::$7 == (number) 0
Adding number conversion cast (unumber) $200 in (byte*~) mulf_init::$13 ← (byte[$200]) mulf_sqr1_lo#0 + (number) $200
Adding number conversion cast (unumber) $ff in (byte) mulf_init::dir#0 ← (number) $ff
Adding number conversion cast (unumber) 0 in (bool~) mulf_init::$16 ← (byte) mulf_init::x_255#1 == (number) 0
Adding number conversion cast (unumber) $1ff in (byte*~) mulf_init::$18 ← (byte[$200]) mulf_sqr2_lo#0 + (number) $1ff
Adding number conversion cast (unumber) 1 in (byte) mulf_init::dir#1 ← (number) 1
Adding number conversion cast (unumber) $1ff in (byte*~) mulf_init::$2 ← (byte[$200]) mulf_sqr2_lo#0 + (number) $1ff
Adding number conversion cast (unumber) $100 in (byte*~) mulf_init::$3 ← (byte[$200]) mulf_sqr1_lo#0 + (number) $100
Adding number conversion cast (unumber) $1ff in (byte*~) mulf_init::$4 ← (byte[$200]) mulf_sqr2_hi#0 + (number) $1ff
Adding number conversion cast (unumber) $100 in (byte*~) mulf_init::$5 ← (byte[$200]) mulf_sqr1_hi#0 + (number) $100
Adding number conversion cast (snumber) 0 in (bool~) mulf8s_prepared::$2 ← *((signed byte*) mulf8s_prepared::memA#0) < (number) 0
Adding number conversion cast (snumber) 0 in (bool~) mulf8s_prepared::$4 ← (signed byte) mulf8s_prepared::b#5 < (number) 0
Adding number conversion cast (unumber) $12 in (dword) CLOCKS_PER_INIT#0 ← (number) $12
Adding number conversion cast (unumber) $ffffffff in (number~) clock::$0 ← (number) $ffffffff - *((dword*) CIA2_TIMER_AB#0)
Adding number conversion cast (unumber) clock::$0 in (number~) clock::$0 ← (unumber)(number) $ffffffff - *((dword*) CIA2_TIMER_AB#0)
Adding number conversion cast (unumber) $ffffffff in *((dword*) CIA2_TIMER_AB#0) ← (number) $ffffffff
Adding number conversion cast (unumber) 2 in (byte*~) print_word_at::$3 ← (byte*) print_word_at::at#3 + (number) 2
Adding number conversion cast (unumber) 4 in (byte*~) print_dword_at::$3 ← (byte*) print_dword_at::at#2 + (number) 4
Adding number conversion cast (unumber) 4 in (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#2 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) print_byte_at::$2 ← (byte) print_byte_at::b#3 & (number) $f
Adding number conversion cast (unumber) print_byte_at::$2 in (number~) print_byte_at::$2 ← (byte) print_byte_at::b#3 & (unumber)(number) $f
Adding number conversion cast (unumber) 1 in (byte*~) print_byte_at::$3 ← (byte*) print_byte_at::at#3 + (number) 1
Adding number conversion cast (unumber) $40 in (byte*~) $1 ← (byte[$140]) SIN#0 + (number) $40
Adding number conversion cast (unumber) $ff in *((byte*) SPRITES_ENABLE#0) ← (number) $ff
Adding number conversion cast (unumber) $3f8 in (byte*~) init::$1 ← (byte*) SCREEN#0 + (number) $3f8
Adding number conversion cast (unumber) $40 in (byte*~) init::$2 ← (byte*) SPRITE#0 / (number) $40
Adding number conversion cast (unumber) 0 in (byte) anim::angle#0 ← (number) 0
Adding number conversion cast (unumber) $ff in (bool~) anim::$0 ← *((byte*) RASTER#0) != (number) $ff
Adding number conversion cast (unumber) 0 in (byte) anim::sprite_msb#0 ← (number) 0
Adding number conversion cast (snumber) 2 in (number~) anim::$6 ← (signed word~) anim::$5 * (number) 2
Adding number conversion cast (snumber) anim::$6 in (number~) anim::$6 ← (signed word~) anim::$5 * (snumber)(number) 2
Adding number conversion cast (snumber) 2 in (number~) anim::$8 ← (signed word~) anim::$7 * (number) 2
Adding number conversion cast (snumber) anim::$8 in (number~) anim::$8 ← (signed word~) anim::$7 * (snumber)(number) 2
Adding number conversion cast (snumber) 2 in (number~) anim::$11 ← (signed word~) anim::$10 * (number) 2
Adding number conversion cast (snumber) anim::$11 in (number~) anim::$11 ← (signed word~) anim::$10 * (snumber)(number) 2
Adding number conversion cast (snumber) 2 in (number~) anim::$13 ← (signed word~) anim::$12 * (number) 2
Adding number conversion cast (snumber) anim::$13 in (number~) anim::$13 ← (signed word~) anim::$12 * (snumber)(number) 2
Adding number conversion cast (snumber) $18 in (number~) anim::$16 ← (signed byte~) anim::$15 + (number) $18
Adding number conversion cast (snumber) anim::$16 in (number~) anim::$16 ← (signed byte~) anim::$15 + (snumber)(number) $18
Adding number conversion cast (snumber) $95 in (number~) anim::$17 ← (snumber~) anim::$16 + (number) $95
Adding number conversion cast (snumber) anim::$17 in (number~) anim::$17 ← (snumber~) anim::$16 + (snumber)(number) $95
Adding number conversion cast (unumber) 2 in (number~) anim::$18 ← (byte) anim::sprite_msb#3 / (number) 2
Adding number conversion cast (unumber) anim::$18 in (number~) anim::$18 ← (byte) anim::sprite_msb#3 / (unumber)(number) 2
Adding number conversion cast (unumber) 0 in (bool~) anim::$20 ← (byte~) anim::$19 != (number) 0
Adding number conversion cast (unumber) $59 in (number~) anim::$23 ← (byte~) anim::$22 + (number) $59
Adding number conversion cast (unumber) anim::$23 in (number~) anim::$23 ← (byte~) anim::$22 + (unumber)(number) $59
Adding number conversion cast (unumber) $33 in (number~) anim::$24 ← (unumber~) anim::$23 + (number) $33
Adding number conversion cast (unumber) anim::$24 in (number~) anim::$24 ← (unumber~) anim::$23 + (unumber)(number) $33
Adding number conversion cast (unumber) 2 in (number~) anim::$25 ← (byte) anim::i#3 * (number) 2
Adding number conversion cast (unumber) anim::$25 in (number~) anim::$25 ← (byte) anim::i#3 * (unumber)(number) 2
Adding number conversion cast (unumber) $80 in (byte) anim::sprite_msb#2 ← (byte) anim::sprite_msb#4 | (number) $80
Successful SSA optimization PassNAddNumberTypeConversions
Added casts to value list in (signed byte[8]) xs#0 ← (signed byte[8]){ (signed byte)(number) -$46, (signed byte)(number) -$46, (signed byte)(number) -$46, (signed byte)(number) 0, (signed byte)(number) 0, (signed byte)(number) $46, (signed byte)(number) $46, (signed byte)(number) $46 }
Added casts to value list in (signed byte[8]) ys#0 ← (signed byte[8]){ (signed byte)(number) -$46, (signed byte)(number) 0, (signed byte)(number) $46, (signed byte)(number) -$46, (signed byte)(number) $46, (signed byte)(number) -$46, (signed byte)(number) 0, (signed byte)(number) $46 }
Successful SSA optimization PassNAddInitializerValueListTypeCasts
Inlining cast (byte*) SPRITES_XPOS#0 ← (byte*)(number) $d000
Inlining cast (byte*) SPRITES_YPOS#0 ← (byte*)(number) $d001
Inlining cast (byte*) SPRITES_XMSB#0 ← (byte*)(number) $d010
Inlining cast (byte*) RASTER#0 ← (byte*)(number) $d012
Inlining cast (byte*) SPRITES_ENABLE#0 ← (byte*)(number) $d015
Inlining cast (byte*) BORDERCOL#0 ← (byte*)(number) $d020
Inlining cast (byte*) SPRITES_COLS#0 ← (byte*)(number) $d027
Inlining cast (dword*) CIA2_TIMER_AB#0 ← (dword*)(number) $dd04
Inlining cast (byte*) CIA2_TIMER_A_CONTROL#0 ← (byte*)(number) $dd0e
Inlining cast (byte*) CIA2_TIMER_B_CONTROL#0 ← (byte*)(number) $dd0f
Inlining cast (byte) CIA_TIMER_CONTROL_STOP#0 ← (unumber)(number) 0
Inlining cast (byte) CIA_TIMER_CONTROL_START#0 ← (unumber)(number) 1
Inlining cast (byte) CIA_TIMER_CONTROL_CONTINUOUS#0 ← (unumber)(number) 0
Inlining cast (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0 ← (unumber)(number) 0
Inlining cast (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 ← (unumber)(number) $40
Inlining cast (byte) GREEN#0 ← (unumber)(number) 5
Inlining cast (byte) LIGHT_BLUE#0 ← (unumber)(number) $e
Inlining cast (word) mulf_init::sqr#0 ← (unumber)(number) 0
Inlining cast (byte) mulf_init::x_2#0 ← (unumber)(number) 0
Inlining cast (byte) mulf_init::c#0 ← (unumber)(number) 0
Inlining cast (byte~) mulf_init::$1 ← (byte)(number) -1
Inlining cast (byte) mulf_init::dir#0 ← (unumber)(number) $ff
Inlining cast (byte) mulf_init::dir#1 ← (unumber)(number) 1
Inlining cast (byte*) mulf8u_prepare::memA#0 ← (byte*)(number) $fd
Inlining cast (byte*) mulf8u_prepared::resL#0 ← (byte*)(number) $fe
Inlining cast (byte*) mulf8u_prepared::memB#0 ← (byte*)(number) $ff
Inlining cast (signed byte*) mulf8s_prepared::memA#0 ← (signed byte*)(number) $fd
Inlining cast (byte~) mulf8s_prepared::$0 ← (byte)(signed byte) mulf8s_prepared::b#4
Inlining cast (byte~) mulf8s_prepared::$9 ← (byte)(signed byte) mulf8s_prepared::b#6
Inlining cast (signed word~) mulf8s_prepared::$6 ← (signed word)(word) mulf8s_prepared::m#4
Inlining cast (byte~) mulf8s_prepared::$13 ← (byte)*((signed byte*) mulf8s_prepared::memA#0)
Inlining cast (dword) CLOCKS_PER_INIT#0 ← (unumber)(number) $12
Inlining cast *((dword*) CIA2_TIMER_AB#0) ← (unumber)(number) $ffffffff
Inlining cast (byte*) SCREEN#0 ← (byte*)(number) $400
Inlining cast *((byte*) SPRITES_ENABLE#0) ← (unumber)(number) $ff
Inlining cast (byte~) init::$3 ← (byte)(byte*~) init::$2
Inlining cast (byte) anim::angle#0 ← (unumber)(number) 0
Inlining cast (signed byte~) anim::$2 ← (signed byte)*((byte*) COS#1 + (byte) anim::angle#2)
Inlining cast (signed byte~) anim::$3 ← (signed byte)*((byte[$140]) SIN#0 + (byte) anim::angle#2)
Inlining cast (byte) anim::sprite_msb#0 ← (unumber)(number) 0
Inlining cast (byte~) anim::mulf8s_prepare1_$0#0 ← (byte)(signed byte) anim::mulf8s_prepare1_a#1
Inlining cast (byte~) anim::mulf8s_prepare2_$0#0 ← (byte)(signed byte) anim::mulf8s_prepare2_a#1
Inlining cast (signed byte~) anim::$15 ← (signed byte)(byte~) anim::$14
Inlining cast (byte*) SPRITE#0 ← (byte*)(number) $3000
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 53249
Simplifying constant pointer cast (byte*) 53264
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (dword*) 56580
Simplifying constant pointer cast (byte*) 56590
Simplifying constant pointer cast (byte*) 56591
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast 5
Simplifying constant integer cast $e
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $200
Simplifying constant integer cast -1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $1ff
Simplifying constant integer cast 1
Simplifying constant integer cast $1ff
Simplifying constant integer cast $100
Simplifying constant integer cast $1ff
Simplifying constant integer cast $100
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant integer cast *((byte*) mulf8u_prepared::memB#0)
Simplifying constant integer cast *((byte*) mulf8u_prepared::resL#0)
Simplifying constant pointer cast (signed byte*) 253
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $12
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $40
Simplifying constant integer cast $ff
Simplifying constant integer cast $3f8
Simplifying constant integer cast $40
Simplifying constant integer cast -$46
Simplifying constant integer cast -$46
Simplifying constant integer cast -$46
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $46
Simplifying constant integer cast $46
Simplifying constant integer cast $46
Simplifying constant integer cast -$46
Simplifying constant integer cast 0
Simplifying constant integer cast $46
Simplifying constant integer cast -$46
Simplifying constant integer cast $46
Simplifying constant integer cast -$46
Simplifying constant integer cast 0
Simplifying constant integer cast $46
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast $18
Simplifying constant integer cast $95
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast $59
Simplifying constant integer cast $33
Simplifying constant integer cast 2
Simplifying constant integer cast $80
Simplifying constant pointer cast (byte*) 12288
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $e
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $200
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $1ff
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $1ff
Finalized unsigned number type (word) $100
Finalized unsigned number type (word) $1ff
Finalized unsigned number type (word) $100
Finalized signed number type (signed byte) 0
Finalized signed number type (signed byte) 0
Finalized unsigned number type (byte) $12
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (word) $3f8
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized signed number type (signed byte) 2
Finalized signed number type (signed byte) 2
Finalized signed number type (signed byte) 2
Finalized signed number type (signed byte) 2
Finalized signed number type (signed byte) $18
Finalized signed number type (signed word) $95
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $59
Finalized unsigned number type (byte) $33
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $80
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) mulf_init::$7 ← (byte) mulf_init::c#1 & (byte) 1
Inferred type updated to dword in (unumber~) clock::$0 ← (dword) $ffffffff - *((dword*) CIA2_TIMER_AB#0)
Inferred type updated to byte in (unumber~) print_byte_at::$2 ← (byte) print_byte_at::b#3 & (byte) $f
Inferred type updated to signed word in (snumber~) anim::$6 ← (signed word~) anim::$5 * (signed byte) 2
Inferred type updated to signed word in (snumber~) anim::$8 ← (signed word~) anim::$7 * (signed byte) 2
Inferred type updated to signed word in (snumber~) anim::$11 ← (signed word~) anim::$10 * (signed byte) 2
Inferred type updated to signed word in (snumber~) anim::$13 ← (signed word~) anim::$12 * (signed byte) 2
Inferred type updated to signed byte in (snumber~) anim::$16 ← (signed byte~) anim::$15 + (signed byte) $18
Inferred type updated to signed word in (snumber~) anim::$17 ← (signed byte~) anim::$16 + (signed word) $95
Inferred type updated to byte in (unumber~) anim::$18 ← (byte) anim::sprite_msb#3 / (byte) 2
Inferred type updated to byte in (unumber~) anim::$23 ← (byte~) anim::$22 + (byte) $59
Inferred type updated to byte in (unumber~) anim::$24 ← (byte~) anim::$23 + (byte) $33
Inferred type updated to byte in (unumber~) anim::$25 ← (byte) anim::i#3 * (byte) 2
Inversing boolean not [32] (bool~) mulf_init::$9 ← (byte~) mulf_init::$7 != (byte) 0 from [31] (bool~) mulf_init::$8 ← (byte~) mulf_init::$7 == (byte) 0
Inversing boolean not [61] (bool~) mulf_init::$17 ← (byte) mulf_init::x_255#1 != (byte) 0 from [60] (bool~) mulf_init::$16 ← (byte) mulf_init::x_255#1 == (byte) 0
Inversing boolean not [102] (bool~) mulf8s_prepared::$3 ← *((signed byte*) mulf8s_prepared::memA#0) >= (signed byte) 0 from [101] (bool~) mulf8s_prepared::$2 ← *((signed byte*) mulf8s_prepared::memA#0) < (signed byte) 0
Inversing boolean not [106] (bool~) mulf8s_prepared::$5 ← (signed byte) mulf8s_prepared::b#5 >= (signed byte) 0 from [105] (bool~) mulf8s_prepared::$4 ← (signed byte) mulf8s_prepared::b#5 < (signed byte) 0
Inversing boolean not [284] (bool~) anim::$21 ← (byte~) anim::$19 == (byte) 0 from [283] (bool~) anim::$20 ← (byte~) anim::$19 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte*) mulf_init::sqr1_hi#0 = (byte*~) mulf_init::$0 
Alias (byte*) mulf_init::sqr1_lo#0 = (byte*~) mulf_init::$6 
Alias (word) mulf_init::sqr#1 = (word~) mulf_init::$12 
Alias (byte) mulf_init::x_2#3 = (byte) mulf_init::x_2#4 
Alias (word) mulf_init::sqr#4 = (word) mulf_init::sqr#5 
Alias (byte*) mulf_init::sqr1_lo#3 = (byte*) mulf_init::sqr1_lo#4 
Alias (byte*) mulf_init::sqr1_hi#3 = (byte*) mulf_init::sqr1_hi#4 
Alias (byte) mulf_init::c#1 = (byte) mulf_init::c#4 
Alias (byte) mulf_init::x_255#0 = (byte~) mulf_init::$1 
Alias (byte) mulf_init::x_255#1 = (byte~) mulf_init::$15 (byte) mulf_init::x_255#4 
Alias (byte*) mulf_init::sqr2_lo#2 = (byte*) mulf_init::sqr2_lo#4 
Alias (byte*) mulf_init::sqr2_hi#1 = (byte*) mulf_init::sqr2_hi#4 
Alias (word) mulf8u_prepared::return#0 = (word~) mulf8u_prepared::$0 (word) mulf8u_prepared::return#3 (word) mulf8u_prepared::return#1 
Alias (byte) mulf8u_prepared::b#0 = (byte~) mulf8s_prepared::$0 
Alias (word) mulf8u_prepared::return#2 = (word) mulf8u_prepared::return#4 
Alias (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#7 (signed byte) mulf8s_prepared::b#6 
Alias (word) mulf8s_prepared::m#0 = (word~) mulf8s_prepared::$1 (word) mulf8s_prepared::m#3 
Alias (byte~) mulf8s_prepared::$15 = (byte~) mulf8s_prepared::$10 
Alias (signed word) mulf8s_prepared::return#0 = (signed word~) mulf8s_prepared::$6 (signed word) mulf8s_prepared::return#6 (signed word) mulf8s_prepared::return#1 
Alias (word) mulf8s_prepared::m#5 = (word) mulf8s_prepared::m#6 
Alias (byte~) mulf8s_prepared::$16 = (byte~) mulf8s_prepared::$14 
Alias (dword) clock::return#0 = (dword~) clock::$0 (dword) clock::return#3 (dword) clock::return#1 
Alias (byte) print_byte_at::b#0 = (byte~) print_word_at::$0 
Alias (word) print_word_at::w#2 = (word) print_word_at::w#3 
Alias (byte*) print_word_at::at#2 = (byte*) print_word_at::at#3 
Alias (byte) print_byte_at::b#1 = (byte~) print_word_at::$2 
Alias (byte*) print_byte_at::at#1 = (byte*~) print_word_at::$3 
Alias (word) print_word_at::w#0 = (word~) print_dword_at::$0 
Alias (dword) print_dword_at::dw#1 = (dword) print_dword_at::dw#2 
Alias (byte*) print_dword_at::at#1 = (byte*) print_dword_at::at#2 
Alias (word) print_word_at::w#1 = (word~) print_dword_at::$2 
Alias (byte*) print_word_at::at#1 = (byte*~) print_dword_at::$3 
Alias (byte) print_byte_at::b#2 = (byte) print_byte_at::b#3 
Alias (byte*) print_byte_at::at#2 = (byte*) print_byte_at::at#3 
Alias (byte*) print_char_at::at#1 = (byte*~) print_byte_at::$3 
Alias (byte*) COS#0 = (byte*~) $1 (byte*) COS#15 (byte*) COS#11 
Alias (byte*) COS#7 = (byte*) COS#9 
Alias (byte*) init::sprites_ptr#0 = (byte*~) init::$1 
Alias (byte*) COS#1 = (byte*) COS#2 (byte*) COS#3 
Alias (byte) anim::angle#2 = (byte) anim::angle#4 (byte) anim::angle#6 
Alias (signed byte) anim::cos_a#0 = (signed byte~) anim::$2 
Alias (signed byte) anim::sin_a#0 = (signed byte~) anim::$3 
Alias (signed byte) anim::cos_a#1 = (signed byte) anim::mulf8s_prepare1_a#0 (signed byte) anim::mulf8s_prepare1_a#1 (signed byte) anim::cos_a#13 (signed byte) anim::cos_a#12 (signed byte) anim::cos_a#11 (signed byte) anim::cos_a#10 (signed byte) anim::cos_a#9 (signed byte) anim::cos_a#8 (signed byte) anim::cos_a#7 (signed byte) anim::cos_a#6 (signed byte) anim::cos_a#5 (signed byte) anim::cos_a#4 (signed byte) anim::cos_a#3 
Alias (signed byte) anim::x#0 = (signed byte) anim::x#5 (signed byte) anim::x#3 (signed byte) anim::x#1 (signed byte) anim::x#9 (signed byte) anim::x#8 (signed byte) anim::x#7 (signed byte) anim::x#6 (signed byte) anim::x#4 (signed byte) anim::x#2 
Alias (signed byte) anim::y#0 = (signed byte) anim::y#7 (signed byte) anim::y#5 (signed byte) anim::y#3 (signed byte) anim::y#1 (signed byte) anim::y#8 (signed byte) anim::y#6 (signed byte) anim::y#4 (signed byte) anim::y#2 
Alias (signed byte) anim::sin_a#1 = (signed byte) anim::sin_a#5 (signed byte) anim::sin_a#6 (signed byte) anim::sin_a#4 (signed byte) anim::sin_a#3 (signed byte) anim::sin_a#2 (signed byte) anim::mulf8s_prepare2_a#0 (signed byte) anim::mulf8s_prepare2_a#1 (signed byte) anim::sin_a#13 (signed byte) anim::sin_a#12 (signed byte) anim::sin_a#11 (signed byte) anim::sin_a#10 (signed byte) anim::sin_a#9 (signed byte) anim::sin_a#8 
Alias (byte) anim::sprite_msb#10 = (byte) anim::sprite_msb#15 (byte) anim::sprite_msb#16 (byte) anim::sprite_msb#14 (byte) anim::sprite_msb#13 (byte) anim::sprite_msb#12 (byte) anim::sprite_msb#11 (byte) anim::sprite_msb#9 (byte) anim::sprite_msb#8 (byte) anim::sprite_msb#6 (byte) anim::sprite_msb#3 
Alias (byte) anim::i#10 = (byte) anim::i#14 (byte) anim::i#2 (byte) anim::i#13 (byte) anim::i#12 (byte) anim::i#11 (byte) anim::i#9 (byte) anim::i#8 (byte) anim::i#7 (byte) anim::i#6 (byte) anim::i#5 (byte) anim::i#4 
Alias (byte) anim::angle#10 = (byte) anim::angle#20 (byte) anim::angle#21 (byte) anim::angle#19 (byte) anim::angle#18 (byte) anim::angle#17 (byte) anim::angle#16 (byte) anim::angle#15 (byte) anim::angle#13 (byte) anim::angle#12 (byte) anim::angle#8 (byte) anim::angle#7 
Alias (byte*) COS#13 = (byte*) COS#24 (byte*) COS#25 (byte*) COS#23 (byte*) COS#22 (byte*) COS#21 (byte*) COS#20 (byte*) COS#19 (byte*) COS#18 (byte*) COS#17 (byte*) COS#16 (byte*) COS#14 
Alias (byte) mulf8u_prepare::a#0 = (byte~) anim::mulf8s_prepare1_$0#0 
Alias (signed word) mulf8s_prepared::return#2 = (signed word) mulf8s_prepared::return#7 
Alias (signed word) anim::xr#0 = (signed word~) anim::$6 (signed word) anim::xr#7 (signed word) anim::xr#6 (signed word) anim::xr#5 (signed word) anim::xr#4 (signed word) anim::xr#2 
Alias (signed word) mulf8s_prepared::return#3 = (signed word) mulf8s_prepared::return#8 
Alias (signed word) anim::yr#0 = (signed word~) anim::$8 (signed word) anim::yr#8 (signed word) anim::yr#7 (signed word) anim::yr#6 (signed word) anim::yr#4 (signed word) anim::yr#2 
Alias (byte) mulf8u_prepare::a#1 = (byte~) anim::mulf8s_prepare2_$0#0 
Alias (signed word) mulf8s_prepared::return#4 = (signed word) mulf8s_prepared::return#9 
Alias (signed word) mulf8s_prepared::return#10 = (signed word) mulf8s_prepared::return#5 
Alias (signed word) anim::xr#1 = (signed word) anim::xr#3 
Alias (signed word) anim::xpos#0 = (signed word~) anim::$17 (signed word) anim::xpos#2 
Alias (byte) anim::sprite_msb#1 = (byte~) anim::$18 (byte) anim::sprite_msb#4 
Alias (byte) anim::ypos#0 = (byte~) anim::$24 
Alias (byte) anim::i2#0 = (byte~) anim::$25 
Alias (signed word) anim::yr#1 = (signed word) anim::yr#5 
Alias (byte) anim::sprite_msb#5 = (byte) anim::sprite_msb#7 
Alias (byte) anim::angle#3 = (byte) anim::angle#5 
Alias (byte*) COS#10 = (byte*) COS#12 (byte*) COS#8 (byte*) COS#6 
Alias (dword) clock::return#2 = (dword) clock::return#4 
Alias (byte) anim::angle#1 = (byte) anim::angle#14 (byte) anim::angle#11 
Alias (dword) anim::cyclecount#0 = (dword~) anim::$29 
Successful SSA optimization Pass2AliasElimination
Alias (byte*) mulf_init::sqr1_lo#2 = (byte*) mulf_init::sqr1_lo#3 
Alias (byte*) mulf_init::sqr1_hi#2 = (byte*) mulf_init::sqr1_hi#3 
Alias (byte) mulf_init::c#1 = (byte) mulf_init::c#3 
Alias (byte*) mulf_init::sqr2_lo#2 = (byte*) mulf_init::sqr2_lo#3 
Alias (byte) mulf_init::x_255#1 = (byte) mulf_init::x_255#3 
Alias (byte*) mulf_init::sqr2_hi#1 = (byte*) mulf_init::sqr2_hi#3 
Alias (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#5 
Alias (signed word) anim::yr#1 = (signed word) anim::yr#3 
Alias (byte) anim::i#10 = (byte) anim::i#3 
Alias (signed word) anim::xpos#0 = (signed word) anim::xpos#1 
Alias (signed byte) anim::cos_a#1 = (signed byte) anim::cos_a#2 
Alias (byte) anim::angle#10 = (byte) anim::angle#3 
Alias (signed byte) anim::sin_a#1 = (signed byte) anim::sin_a#7 
Alias (byte*) COS#10 = (byte*) COS#13 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) mulf8u_prepared::b#1 (byte) mulf8u_prepared::b#0
Identical Phi Values (dword) print_dword_at::dw#1 (dword) print_dword_at::dw#0
Identical Phi Values (byte*) print_dword_at::at#1 (byte*) print_dword_at::at#0
Identical Phi Values (byte*) COS#7 (byte*) COS#0
Identical Phi Values (byte*) init::sprites_ptr#1 (byte*) init::sprites_ptr#0
Identical Phi Values (byte*) COS#5 (byte*) COS#7
Identical Phi Values (byte*) COS#1 (byte*) COS#4
Identical Phi Values (byte) anim::angle#2 (byte) anim::angle#9
Identical Phi Values (signed byte) anim::cos_a#1 (signed byte) anim::cos_a#0
Identical Phi Values (signed byte) anim::sin_a#1 (signed byte) anim::sin_a#0
Identical Phi Values (byte) anim::angle#10 (byte) anim::angle#2
Identical Phi Values (byte*) COS#10 (byte*) COS#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte*) COS#4 (byte*) COS#0
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [135] (byte~) clock_start::$2 ← (byte) CIA_TIMER_CONTROL_STOP#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Identified duplicate assignment right side [142] (byte~) clock_start::$6 ← (byte) CIA_TIMER_CONTROL_START#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) mulf_init::$9 [33] if((byte~) mulf_init::$7!=(byte) 0) goto mulf_init::@2
Simple Condition (bool~) mulf_init::$14 [45] if((byte*) mulf_init::sqr1_lo#1!=(byte*~) mulf_init::$13) goto mulf_init::@1
Simple Condition (bool~) mulf_init::$17 [62] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@6
Simple Condition (bool~) mulf_init::$19 [67] if((byte*) mulf_init::sqr2_lo#1!=(byte*~) mulf_init::$18) goto mulf_init::@5
Simple Condition (bool~) mulf8s_prepared::$3 [103] if(*((signed byte*) mulf8s_prepared::memA#0)>=(signed byte) 0) goto mulf8s_prepared::@1
Simple Condition (bool~) mulf8s_prepared::$5 [107] if((signed byte) mulf8s_prepared::b#4>=(signed byte) 0) goto mulf8s_prepared::@2
Simple Condition (bool~) init::$4 [208] if((byte) init::i#1!=rangelast(0,7)) goto init::@1
Simple Condition (bool~) anim::$0 [219] if(*((byte*) RASTER#0)!=(byte) $ff) goto anim::@4
Simple Condition (bool~) anim::$21 [285] if((byte~) anim::$19==(byte) 0) goto anim::@11
Simple Condition (bool~) anim::$27 [298] if((byte) anim::i#1!=rangelast(0,7)) goto anim::@10
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [17] (byte[$200]) mulf_sqr1_lo#0 ← { fill( $200, 0) }
Constant right-side identified [18] (byte[$200]) mulf_sqr1_hi#0 ← { fill( $200, 0) }
Constant right-side identified [19] (byte[$200]) mulf_sqr2_lo#0 ← { fill( $200, 0) }
Constant right-side identified [20] (byte[$200]) mulf_sqr2_hi#0 ← { fill( $200, 0) }
Successful SSA optimization Pass2ConstantRValueConsolidation
Identified constant from value list (signed byte[8]) { (signed byte) -$46, (signed byte) -$46, (signed byte) -$46, (signed byte) 0, (signed byte) 0, (signed byte) $46, (signed byte) $46, (signed byte) $46 }
Identified constant from value list (signed byte[8]) { (signed byte) -$46, (signed byte) 0, (signed byte) $46, (signed byte) -$46, (signed byte) $46, (signed byte) -$46, (signed byte) 0, (signed byte) $46 }
Successful SSA optimization Pass2ConstantInitializerValueLists
Constant (const byte*) SPRITES_XPOS#0 = (byte*) 53248
Constant (const byte*) SPRITES_YPOS#0 = (byte*) 53249
Constant (const byte*) SPRITES_XMSB#0 = (byte*) 53264
Constant (const byte*) RASTER#0 = (byte*) 53266
Constant (const byte*) SPRITES_ENABLE#0 = (byte*) 53269
Constant (const byte*) BORDERCOL#0 = (byte*) 53280
Constant (const byte*) SPRITES_COLS#0 = (byte*) 53287
Constant (const dword*) CIA2_TIMER_AB#0 = (dword*) 56580
Constant (const byte*) CIA2_TIMER_A_CONTROL#0 = (byte*) 56590
Constant (const byte*) CIA2_TIMER_B_CONTROL#0 = (byte*) 56591
Constant (const byte) CIA_TIMER_CONTROL_STOP#0 = 0
Constant (const byte) CIA_TIMER_CONTROL_START#0 = 1
Constant (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 = 0
Constant (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0 = 0
Constant (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 = $40
Constant (const byte) GREEN#0 = 5
Constant (const byte) LIGHT_BLUE#0 = $e
Constant (const byte[$200]) mulf_sqr1_lo#0 = { fill( $200, 0) }
Constant (const byte[$200]) mulf_sqr1_hi#0 = { fill( $200, 0) }
Constant (const byte[$200]) mulf_sqr2_lo#0 = { fill( $200, 0) }
Constant (const byte[$200]) mulf_sqr2_hi#0 = { fill( $200, 0) }
Constant (const word) mulf_init::sqr#0 = 0
Constant (const byte) mulf_init::x_2#0 = 0
Constant (const byte) mulf_init::c#0 = 0
Constant (const byte) mulf_init::x_255#0 = -1
Constant (const byte) mulf_init::dir#0 = $ff
Constant (const byte) mulf_init::dir#1 = 1
Constant (const byte*) mulf8u_prepare::memA#0 = (byte*) 253
Constant (const byte*) mulf8u_prepared::resL#0 = (byte*) 254
Constant (const byte*) mulf8u_prepared::memB#0 = (byte*) 255
Constant (const signed byte*) mulf8s_prepared::memA#0 = (signed byte*) 253
Constant (const dword) CLOCKS_PER_INIT#0 = $12
Constant (const byte[]) print_hextab#0 = $2
Constant (const byte*) SCREEN#0 = (byte*) 1024
Constant (const byte[$140]) SIN#0 = kickasm {{ .for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))
 }}
Constant (const byte) init::i#0 = 0
Constant (const signed byte[8]) xs#0 = { -$46, -$46, -$46, 0, 0, $46, $46, $46 }
Constant (const signed byte[8]) ys#0 = { -$46, 0, $46, -$46, $46, -$46, 0, $46 }
Constant (const byte) anim::angle#0 = 0
Constant (const byte) anim::sprite_msb#0 = 0
Constant (const byte) anim::i#0 = 0
Constant (const byte*) SPRITE#0 = (byte*) 12288
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) mulf_init::sqr2_hi#0 = mulf_sqr2_hi#0
Constant (const byte*) mulf_init::sqr2_lo#0 = mulf_sqr2_lo#0
Constant (const byte*) print_dword_at::at#0 = SCREEN#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) print_word_at::at#0 = print_dword_at::at#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [216] if(true) goto anim::@4
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [206] init::i#1 ← ++ init::i#2 to ++
Resolved ranged comparison value [208] if(init::i#1!=rangelast(0,7)) goto init::@1 to (number) 8
Resolved ranged next value [296] anim::i#1 ← ++ anim::i#10 to ++
Resolved ranged comparison value [298] if(anim::i#1!=rangelast(0,7)) goto anim::@10 to (number) 8
Simplifying expression containing zero CIA_TIMER_CONTROL_CONTINUOUS#0 in [132] (byte~) clock_start::$0 ← (const byte) CIA_TIMER_CONTROL_STOP#0 | (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Simplifying expression containing zero clock_start::$0 in [133] (byte~) clock_start::$1 ← (byte~) clock_start::$0 | (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
Simplifying expression containing zero CIA_TIMER_CONTROL_START#0 in [139] (byte~) clock_start::$4 ← (const byte) CIA_TIMER_CONTROL_START#0 | (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Simplifying expression containing zero clock_start::$6 in [143] (byte~) clock_start::$7 ← (byte~) clock_start::$6 | (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) CIA_TIMER_CONTROL_STOP#0
Eliminating unused constant (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block anim::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 8 in if((byte) init::i#1!=(number) 8) goto init::@1
Adding number conversion cast (unumber) 8 in if((byte) anim::i#1!=(number) 8) goto anim::@10
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias (byte~) clock_start::$1 = (byte~) clock_start::$0 (byte~) clock_start::$2 
Alias (byte~) clock_start::$6 = (byte~) clock_start::$4 (byte~) clock_start::$7 
Successful SSA optimization Pass2AliasElimination
Constant right-side identified [0] (byte*) mulf_init::sqr1_hi#0 ← (const byte[$200]) mulf_sqr1_hi#0 + (byte) 1
Constant right-side identified [1] (byte*) mulf_init::sqr1_lo#0 ← (const byte[$200]) mulf_sqr1_lo#0 + (byte) 1
Constant right-side identified [14] (byte*~) mulf_init::$13 ← (const byte[$200]) mulf_sqr1_lo#0 + (word) $200
Constant right-side identified [26] (byte*~) mulf_init::$18 ← (const byte[$200]) mulf_sqr2_lo#0 + (word) $1ff
Constant right-side identified [28] (byte*~) mulf_init::$2 ← (const byte[$200]) mulf_sqr2_lo#0 + (word) $1ff
Constant right-side identified [29] (byte*~) mulf_init::$3 ← (const byte[$200]) mulf_sqr1_lo#0 + (word) $100
Constant right-side identified [31] (byte*~) mulf_init::$4 ← (const byte[$200]) mulf_sqr2_hi#0 + (word) $1ff
Constant right-side identified [32] (byte*~) mulf_init::$5 ← (const byte[$200]) mulf_sqr1_hi#0 + (word) $100
Constant right-side identified [89] (byte*) print_word_at::at#1 ← (const byte*) print_dword_at::at#0 + (byte) 4
Constant right-side identified [105] (byte*) COS#0 ← (const byte[$140]) SIN#0 + (byte) $40
Constant right-side identified [112] (byte*) init::sprites_ptr#0 ← (const byte*) SCREEN#0 + (word) $3f8
Constant right-side identified [114] (byte*~) init::$2 ← (const byte*) SPRITE#0 / (byte) $40
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) mulf_init::sqr1_hi#0 = mulf_sqr1_hi#0+1
Constant (const byte*) mulf_init::sqr1_lo#0 = mulf_sqr1_lo#0+1
Constant (const byte*) mulf_init::$13 = mulf_sqr1_lo#0+$200
Constant (const byte*) mulf_init::$18 = mulf_sqr2_lo#0+$1ff
Constant (const byte*) mulf_init::$2 = mulf_sqr2_lo#0+$1ff
Constant (const byte*) mulf_init::$3 = mulf_sqr1_lo#0+$100
Constant (const byte*) mulf_init::$4 = mulf_sqr2_hi#0+$1ff
Constant (const byte*) mulf_init::$5 = mulf_sqr1_hi#0+$100
Constant (const byte) clock_start::$1 = CIA_TIMER_CONTROL_CONTINUOUS#0
Constant (const byte) clock_start::$6 = CIA_TIMER_CONTROL_START#0
Constant (const byte*) print_word_at::at#1 = print_dword_at::at#0+4
Constant (const byte*) COS#0 = SIN#0+$40
Constant (const byte*) init::sprites_ptr#0 = SCREEN#0+$3f8
Constant (const byte*) init::$2 = SPRITE#0/$40
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)init::$2 in [115] (byte~) init::$3 ← (byte)(const byte*) init::$2
Successful SSA optimization Pass2ConstantValues
Simplifying expression containing zero CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 in [68] (byte~) clock_start::$3 ← (const byte) clock_start::$1 | (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Successful SSA optimization PassNSimplifyExpressionWithZero
Constant right-side identified [60] (byte~) clock_start::$5 ← (const byte) clock_start::$6 | (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) clock_start::$3 = CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Constant (const byte) clock_start::$5 = clock_start::$6|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Constant (const byte) init::$3 = (byte)init::$2
Successful SSA optimization Pass2ConstantIdentification
Inlining Noop Cast [44] (byte~) mulf8s_prepared::$9 ← (byte)(signed byte) mulf8s_prepared::b#4 keeping mulf8s_prepared::b#4
Inlining Noop Cast [48] (signed word) mulf8s_prepared::return#0 ← (signed word)(word) mulf8s_prepared::m#4 keeping mulf8s_prepared::m#4
Inlining Noop Cast [50] (byte~) mulf8s_prepared::$13 ← (byte)*((const signed byte*) mulf8s_prepared::memA#0) keeping *(mulf8s_prepared::memA#0)
Inlining Noop Cast [104] (signed byte) anim::cos_a#0 ← (signed byte)*((const byte*) COS#0 + (byte) anim::angle#9) keeping *(COS#0 + anim::angle#9)
Inlining Noop Cast [105] (signed byte) anim::sin_a#0 ← (signed byte)*((const byte[$140]) SIN#0 + (byte) anim::angle#9) keeping *(SIN#0 + anim::angle#9)
Successful SSA optimization Pass2NopCastInlining
Inlining Noop Cast [109] (byte) mulf8u_prepare::a#0 ← (byte)(signed byte)*((const byte*) COS#0 + (byte) anim::angle#9) keeping (signed byte)*(COS#0 + anim::angle#9)
Inlining Noop Cast [113] (signed word) mulf8s_prepared::return#2 ← (signed word)(word) mulf8s_prepared::m#4 keeping mulf8s_prepared::m#4
Inlining Noop Cast [118] (signed word) mulf8s_prepared::return#3 ← (signed word)(word) mulf8s_prepared::m#4 keeping mulf8s_prepared::m#4
Inlining Noop Cast [121] (byte) mulf8u_prepare::a#1 ← (byte)(signed byte)*((const byte[$140]) SIN#0 + (byte) anim::angle#9) keeping (signed byte)*(SIN#0 + anim::angle#9)
Inlining Noop Cast [125] (signed word) mulf8s_prepared::return#4 ← (signed word)(word) mulf8s_prepared::m#4 keeping mulf8s_prepared::m#4
Inlining Noop Cast [131] (signed word) mulf8s_prepared::return#10 ← (signed word)(word) mulf8s_prepared::m#4 keeping mulf8s_prepared::m#4
Successful SSA optimization Pass2NopCastInlining
Inlining Noop Cast [136] (signed byte~) anim::$15 ← (signed byte)(byte~) anim::$14 keeping anim::$15
Successful SSA optimization Pass2NopCastInlining
Rewriting multiplication to use shift [115] (signed word) anim::xr#0 ← (signed word~) anim::$5 * (signed byte) 2
Rewriting multiplication to use shift [120] (signed word) anim::yr#0 ← (signed word~) anim::$7 * (signed byte) 2
Rewriting multiplication to use shift [127] (signed word~) anim::$11 ← (signed word~) anim::$10 * (signed byte) 2
Rewriting multiplication to use shift [133] (signed word~) anim::$13 ← (signed word~) anim::$12 * (signed byte) 2
Rewriting division to use shift [139] (byte) anim::sprite_msb#1 ← (byte) anim::sprite_msb#10 / (byte) 2
Rewriting multiplication to use shift [146] (byte) anim::i2#0 ← (byte) anim::i#10 * (byte) 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const word) mulf_init::sqr#0
Inlining constant with var siblings (const byte) mulf_init::x_2#0
Inlining constant with var siblings (const byte) mulf_init::c#0
Inlining constant with var siblings (const byte) mulf_init::x_255#0
Inlining constant with var siblings (const byte) mulf_init::dir#0
Inlining constant with var siblings (const byte) mulf_init::dir#1
Inlining constant with var siblings (const byte*) mulf_init::sqr2_hi#0
Inlining constant with var siblings (const byte*) mulf_init::sqr2_lo#0
Inlining constant with var siblings (const byte*) mulf_init::sqr1_hi#0
Inlining constant with var siblings (const byte*) mulf_init::sqr1_lo#0
Inlining constant with var siblings (const byte*) print_word_at::at#0
Inlining constant with var siblings (const byte*) print_word_at::at#1
Inlining constant with var siblings (const byte) init::i#0
Inlining constant with var siblings (const byte) anim::angle#0
Inlining constant with var siblings (const byte) anim::sprite_msb#0
Inlining constant with var siblings (const byte) anim::i#0
Constant inlined mulf_init::c#0 = (byte) 0
Constant inlined mulf_init::sqr2_lo#0 = (const byte[$200]) mulf_sqr2_lo#0
Constant inlined anim::sprite_msb#0 = (byte) 0
Constant inlined init::i#0 = (byte) 0
Constant inlined mulf_init::sqr2_hi#0 = (const byte[$200]) mulf_sqr2_hi#0
Constant inlined mulf_init::$2 = (const byte[$200]) mulf_sqr2_lo#0+(word) $1ff
Constant inlined mulf_init::$4 = (const byte[$200]) mulf_sqr2_hi#0+(word) $1ff
Constant inlined clock_start::$5 = (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Constant inlined clock_start::$6 = (const byte) CIA_TIMER_CONTROL_START#0
Constant inlined mulf_init::$3 = (const byte[$200]) mulf_sqr1_lo#0+(word) $100
Constant inlined clock_start::$3 = (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Constant inlined $2 = (const byte[]) print_hextab#0
Constant inlined anim::i#0 = (byte) 0
Constant inlined mulf_init::$5 = (const byte[$200]) mulf_sqr1_hi#0+(word) $100
Constant inlined mulf_init::dir#1 = (byte) 1
Constant inlined mulf_init::dir#0 = (byte) $ff
Constant inlined print_dword_at::at#0 = (const byte*) SCREEN#0
Constant inlined mulf_init::x_255#0 = (byte) -1
Constant inlined mulf_init::x_2#0 = (byte) 0
Constant inlined mulf_init::sqr#0 = (byte) 0
Constant inlined init::$3 = (byte)(const byte*) SPRITE#0/(byte) $40
Constant inlined init::$2 = (const byte*) SPRITE#0/(byte) $40
Constant inlined anim::angle#0 = (byte) 0
Constant inlined clock_start::$1 = (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Constant inlined mulf_init::sqr1_hi#0 = (const byte[$200]) mulf_sqr1_hi#0+(byte) 1
Constant inlined mulf_init::sqr1_lo#0 = (const byte[$200]) mulf_sqr1_lo#0+(byte) 1
Constant inlined print_word_at::at#1 = (const byte*) SCREEN#0+(byte) 4
Constant inlined print_word_at::at#0 = (const byte*) SCREEN#0
Constant inlined mulf_init::$13 = (const byte[$200]) mulf_sqr1_lo#0+(word) $200
Constant inlined mulf_init::$18 = (const byte[$200]) mulf_sqr2_lo#0+(word) $1ff
Successful SSA optimization Pass2ConstantInlining
Consolidated constant in assignment anim::xpos#0
Consolidated constant in assignment anim::ypos#0
Successful SSA optimization Pass2ConstantAdditionElimination
Alias (byte~) anim::$23 = (byte~) anim::$22 
Successful SSA optimization Pass2AliasElimination
Inlining Noop Cast [125] (signed byte~) anim::$16 ← (signed byte)(byte~) anim::$15 keeping anim::$16
Successful SSA optimization Pass2NopCastInlining
Added new block during phi lifting mulf_init::@9(between mulf_init::@2 and mulf_init::@1)
Added new block during phi lifting mulf_init::@10(between mulf_init::@1 and mulf_init::@2)
Added new block during phi lifting mulf_init::@11(between mulf_init::@6 and mulf_init::@5)
Added new block during phi lifting mulf_init::@12(between mulf_init::@5 and mulf_init::@6)
Added new block during phi lifting mulf8s_prepared::@7(between mulf8s_prepared::@6 and mulf8s_prepared::@1)
Added new block during phi lifting mulf8s_prepared::@8(between mulf8s_prepared::@1 and mulf8s_prepared::@2)
Added new block during phi lifting init::@4(between init::@1 and init::@1)
Added new block during phi lifting anim::@28(between anim::@11 and anim::@10)
Added new block during phi lifting anim::@29(between anim::@25 and anim::@11)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @13
Adding NOP phi() at start of @44
Adding NOP phi() at start of @51
Adding NOP phi() at start of @53
Adding NOP phi() at start of @55
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of anim
Adding NOP phi() at start of anim::@19
Adding NOP phi() at start of anim::@20
Adding NOP phi() at start of anim::@23
Adding NOP phi() at start of print_dword_at::@2
Adding NOP phi() at start of print_word_at::@2
Adding NOP phi() at start of print_byte_at::@2
Adding NOP phi() at start of init
Adding NOP phi() at start of mulf_init
Adding NOP phi() at start of mulf_init::@4
Adding NOP phi() at start of mulf_init::@7
CALL GRAPH
Calls in [] to main:7 
Calls in [main] to init:11 anim:13 
Calls in [anim] to clock_start:20 mulf8u_prepare:26 mulf8s_prepared:30 mulf8s_prepared:35 mulf8u_prepare:39 mulf8s_prepared:43 mulf8s_prepared:49 clock:71 print_dword_at:76 
Calls in [print_dword_at] to print_word_at:84 print_word_at:87 
Calls in [print_word_at] to print_byte_at:95 print_byte_at:100 
Calls in [print_byte_at] to print_char_at:109 print_char_at:115 
Calls in [mulf8s_prepared] to mulf8u_prepared:125 
Calls in [init] to mulf_init:158 

Created 27 initial phi equivalence classes
Coalesced [29] mulf8s_prepared::b#8 ← mulf8s_prepared::b#0
Coalesced [34] mulf8s_prepared::b#10 ← mulf8s_prepared::b#1
Coalesced [42] mulf8s_prepared::b#9 ← mulf8s_prepared::b#2
Coalesced [48] mulf8s_prepared::b#11 ← mulf8s_prepared::b#3
Coalesced [59] anim::sprite_msb#18 ← anim::sprite_msb#2
Coalesced [78] anim::angle#22 ← anim::angle#1
Coalesced [79] anim::i#15 ← anim::i#1
Coalesced [80] anim::sprite_msb#17 ← anim::sprite_msb#5
Coalesced [81] anim::sprite_msb#19 ← anim::sprite_msb#1
Coalesced [83] print_word_at::w#4 ← print_word_at::w#0
Coalesced [86] print_word_at::w#5 ← print_word_at::w#1
Coalesced [93] print_byte_at::b#4 ← print_byte_at::b#0
Coalesced [94] print_byte_at::at#4 ← print_byte_at::at#0
Coalesced [98] print_byte_at::b#5 ← print_byte_at::b#1
Coalesced [99] print_byte_at::at#5 ← print_byte_at::at#1
Coalesced [107] print_char_at::ch#3 ← print_char_at::ch#0
Coalesced [108] print_char_at::at#3 ← print_char_at::at#0
Coalesced [113] print_char_at::ch#4 ← print_char_at::ch#1
Coalesced [114] print_char_at::at#4 ← print_char_at::at#1
Coalesced [132] mulf8s_prepared::m#7 ← mulf8s_prepared::m#1
Coalesced [138] mulf8s_prepared::m#10 ← mulf8s_prepared::m#2
Coalesced [141] mulf8s_prepared::m#9 ← mulf8s_prepared::m#5
Coalesced [142] mulf8s_prepared::m#8 ← mulf8s_prepared::m#0
Coalesced [166] init::i#3 ← init::i#1
Coalesced [174] mulf_init::sqr#8 ← mulf_init::sqr#2
Coalesced [175] mulf_init::x_2#7 ← mulf_init::x_2#1
Coalesced [199] mulf_init::x_255#5 ← mulf_init::x_255#1
Coalesced [200] mulf_init::sqr2_lo#5 ← mulf_init::sqr2_lo#1
Coalesced [201] mulf_init::sqr2_hi#5 ← mulf_init::sqr2_hi#1
Coalesced [202] mulf_init::dir#4 ← mulf_init::dir#3
Coalesced (already) [203] mulf_init::dir#5 ← mulf_init::dir#2
Coalesced [204] mulf_init::c#5 ← mulf_init::c#1
Coalesced [205] mulf_init::sqr#6 ← mulf_init::sqr#1
Coalesced [206] mulf_init::sqr1_lo#5 ← mulf_init::sqr1_lo#1
Coalesced [207] mulf_init::sqr1_hi#5 ← mulf_init::sqr1_hi#1
Coalesced [208] mulf_init::x_2#5 ← mulf_init::x_2#2
Coalesced [209] mulf_init::sqr#7 ← mulf_init::sqr#4
Coalesced (already) [210] mulf_init::x_2#6 ← mulf_init::x_2#3
Coalesced down to 22 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @13
Culled Empty Block (label) @44
Culled Empty Block (label) @51
Culled Empty Block (label) @53
Culled Empty Block (label) @55
Culled Empty Block (label) main::@2
Culled Empty Block (label) anim::@19
Culled Empty Block (label) anim::@20
Culled Empty Block (label) anim::@23
Culled Empty Block (label) anim::@28
Culled Empty Block (label) anim::@29
Culled Empty Block (label) print_dword_at::@2
Culled Empty Block (label) print_word_at::@2
Culled Empty Block (label) print_byte_at::@2
Culled Empty Block (label) mulf8s_prepared::@8
Culled Empty Block (label) mulf8s_prepared::@7
Culled Empty Block (label) init::@4
Culled Empty Block (label) mulf_init::@4
Culled Empty Block (label) mulf_init::@7
Culled Empty Block (label) mulf_init::@11
Culled Empty Block (label) mulf_init::@9
Culled Empty Block (label) mulf_init::@10
Renumbering block @54 to @1
Renumbering block mulf_init::@5 to mulf_init::@4
Renumbering block mulf_init::@6 to mulf_init::@5
Renumbering block mulf_init::@8 to mulf_init::@6
Renumbering block mulf_init::@12 to mulf_init::@7
Renumbering block mulf8s_prepared::@6 to mulf8s_prepared::@5
Renumbering block init::@3 to init::@2
Renumbering block anim::@4 to anim::@2
Renumbering block anim::@6 to anim::@3
Renumbering block anim::@10 to anim::@4
Renumbering block anim::@11 to anim::@5
Renumbering block anim::@12 to anim::@6
Renumbering block anim::@13 to anim::@7
Renumbering block anim::@17 to anim::@8
Renumbering block anim::@18 to anim::@9
Renumbering block anim::@21 to anim::@10
Renumbering block anim::@22 to anim::@11
Renumbering block anim::@24 to anim::@12
Renumbering block anim::@25 to anim::@13
Renumbering block anim::@26 to anim::@14
Renumbering block anim::@27 to anim::@15
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of anim
Adding NOP phi() at start of init
Adding NOP phi() at start of mulf_init
Adding NOP phi() at start of mulf_init::@7

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  asm { sei  }
  [5] call init 
  to:main::@1
main::@1: scope:[main]  from main
  [6] phi()
  [7] call anim 
  to:main::@return
main::@return: scope:[main]  from main::@1
  [8] return 
  to:@return
anim: scope:[anim]  from main::@1
  [9] phi()
  to:anim::@1
anim::@1: scope:[anim]  from anim anim::@15
  [10] (byte) anim::angle#9 ← phi( anim/(byte) 0 anim::@15/(byte) anim::angle#1 )
  to:anim::@2
anim::@2: scope:[anim]  from anim::@1 anim::@2
  [11] if(*((const byte*) RASTER#0)!=(byte) $ff) goto anim::@2
  to:anim::@3
anim::@3: scope:[anim]  from anim::@2
  [12] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  [13] call clock_start 
  to:anim::@4
anim::@4: scope:[anim]  from anim::@3 anim::@5
  [14] (byte) anim::sprite_msb#10 ← phi( anim::@5/(byte) anim::sprite_msb#5 anim::@3/(byte) 0 )
  [14] (byte) anim::i#10 ← phi( anim::@5/(byte) anim::i#1 anim::@3/(byte) 0 )
  [15] (signed byte) anim::x#0 ← *((const signed byte[8]) xs#0 + (byte) anim::i#10)
  [16] (signed byte) anim::y#0 ← *((const signed byte[8]) ys#0 + (byte) anim::i#10)
  to:anim::mulf8s_prepare1
anim::mulf8s_prepare1: scope:[anim]  from anim::@4
  [17] (byte~) mulf8u_prepare::a#3 ← (byte)(signed byte)*((const byte*) COS#0 + (byte) anim::angle#9)
  [18] call mulf8u_prepare 
  to:anim::@8
anim::@8: scope:[anim]  from anim::mulf8s_prepare1
  [19] (signed byte) mulf8s_prepared::b#0 ← (signed byte) anim::x#0
  [20] call mulf8s_prepared 
  to:anim::@10
anim::@10: scope:[anim]  from anim::@8
  [21] (signed word~) anim::$5 ← (signed word)(word) mulf8s_prepared::m#4
  [22] (signed word) anim::xr#0 ← (signed word~) anim::$5 << (byte) 1
  [23] (signed byte) mulf8s_prepared::b#1 ← (signed byte) anim::y#0
  [24] call mulf8s_prepared 
  to:anim::@11
anim::@11: scope:[anim]  from anim::@10
  [25] (signed word~) anim::$7 ← (signed word)(word) mulf8s_prepared::m#4
  [26] (signed word) anim::yr#0 ← (signed word~) anim::$7 << (byte) 1
  to:anim::mulf8s_prepare2
anim::mulf8s_prepare2: scope:[anim]  from anim::@11
  [27] (byte~) mulf8u_prepare::a#4 ← (byte)(signed byte)*((const byte[$140]) SIN#0 + (byte) anim::angle#9)
  [28] call mulf8u_prepare 
  to:anim::@9
anim::@9: scope:[anim]  from anim::mulf8s_prepare2
  [29] (signed byte) mulf8s_prepared::b#2 ← (signed byte) anim::y#0
  [30] call mulf8s_prepared 
  to:anim::@12
anim::@12: scope:[anim]  from anim::@9
  [31] (signed word~) anim::$10 ← (signed word)(word) mulf8s_prepared::m#4
  [32] (signed word~) anim::$11 ← (signed word~) anim::$10 << (byte) 1
  [33] (signed word) anim::xr#1 ← (signed word) anim::xr#0 - (signed word~) anim::$11
  [34] (signed byte) mulf8s_prepared::b#3 ← (signed byte) anim::x#0
  [35] call mulf8s_prepared 
  to:anim::@13
anim::@13: scope:[anim]  from anim::@12
  [36] (signed word~) anim::$12 ← (signed word)(word) mulf8s_prepared::m#4
  [37] (signed word~) anim::$13 ← (signed word~) anim::$12 << (byte) 1
  [38] (signed word) anim::yr#1 ← (signed word) anim::yr#0 + (signed word~) anim::$13
  [39] (byte~) anim::$16 ← > (signed word) anim::xr#1
  [40] (signed word) anim::xpos#0 ← (signed byte)(byte~) anim::$16 + (signed byte) $18+(signed word) $95
  [41] (byte) anim::sprite_msb#1 ← (byte) anim::sprite_msb#10 >> (byte) 1
  [42] (byte~) anim::$19 ← > (signed word) anim::xpos#0
  [43] if((byte~) anim::$19==(byte) 0) goto anim::@5
  to:anim::@6
anim::@6: scope:[anim]  from anim::@13
  [44] (byte) anim::sprite_msb#2 ← (byte) anim::sprite_msb#1 | (byte) $80
  to:anim::@5
anim::@5: scope:[anim]  from anim::@13 anim::@6
  [45] (byte) anim::sprite_msb#5 ← phi( anim::@6/(byte) anim::sprite_msb#2 anim::@13/(byte) anim::sprite_msb#1 )
  [46] (byte~) anim::$23 ← > (signed word) anim::yr#1
  [47] (byte) anim::ypos#0 ← (byte~) anim::$23 + (byte) $59+(byte) $33
  [48] (byte) anim::i2#0 ← (byte) anim::i#10 << (byte) 1
  [49] (byte~) anim::$26 ← < (signed word) anim::xpos#0
  [50] *((const byte*) SPRITES_XPOS#0 + (byte) anim::i2#0) ← (byte~) anim::$26
  [51] *((const byte*) SPRITES_YPOS#0 + (byte) anim::i2#0) ← (byte) anim::ypos#0
  [52] (byte) anim::i#1 ← ++ (byte) anim::i#10
  [53] if((byte) anim::i#1!=(byte) 8) goto anim::@4
  to:anim::@7
anim::@7: scope:[anim]  from anim::@5
  [54] *((const byte*) SPRITES_XMSB#0) ← (byte) anim::sprite_msb#5
  [55] (byte) anim::angle#1 ← ++ (byte) anim::angle#9
  [56] call clock 
  [57] (dword) clock::return#2 ← (dword) clock::return#0
  to:anim::@14
anim::@14: scope:[anim]  from anim::@7
  [58] (dword~) anim::$28 ← (dword) clock::return#2
  [59] (dword) anim::cyclecount#0 ← (dword~) anim::$28 - (const dword) CLOCKS_PER_INIT#0
  [60] (dword) print_dword_at::dw#0 ← (dword) anim::cyclecount#0
  [61] call print_dword_at 
  to:anim::@15
anim::@15: scope:[anim]  from anim::@14
  [62] *((const byte*) BORDERCOL#0) ← (const byte) LIGHT_BLUE#0
  to:anim::@1
print_dword_at: scope:[print_dword_at]  from anim::@14
  [63] (word) print_word_at::w#0 ← > (dword) print_dword_at::dw#0
  [64] call print_word_at 
  to:print_dword_at::@1
print_dword_at::@1: scope:[print_dword_at]  from print_dword_at
  [65] (word) print_word_at::w#1 ← < (dword) print_dword_at::dw#0
  [66] call print_word_at 
  to:print_dword_at::@return
print_dword_at::@return: scope:[print_dword_at]  from print_dword_at::@1
  [67] return 
  to:@return
print_word_at: scope:[print_word_at]  from print_dword_at print_dword_at::@1
  [68] (byte*) print_word_at::at#2 ← phi( print_dword_at/(const byte*) SCREEN#0 print_dword_at::@1/(const byte*) SCREEN#0+(byte) 4 )
  [68] (word) print_word_at::w#2 ← phi( print_dword_at/(word) print_word_at::w#0 print_dword_at::@1/(word) print_word_at::w#1 )
  [69] (byte) print_byte_at::b#0 ← > (word) print_word_at::w#2
  [70] (byte*) print_byte_at::at#0 ← (byte*) print_word_at::at#2
  [71] call print_byte_at 
  to:print_word_at::@1
print_word_at::@1: scope:[print_word_at]  from print_word_at
  [72] (byte) print_byte_at::b#1 ← < (word) print_word_at::w#2
  [73] (byte*) print_byte_at::at#1 ← (byte*) print_word_at::at#2 + (byte) 2
  [74] call print_byte_at 
  to:print_word_at::@return
print_word_at::@return: scope:[print_word_at]  from print_word_at::@1
  [75] return 
  to:@return
print_byte_at: scope:[print_byte_at]  from print_word_at print_word_at::@1
  [76] (byte*) print_byte_at::at#2 ← phi( print_word_at/(byte*) print_byte_at::at#0 print_word_at::@1/(byte*) print_byte_at::at#1 )
  [76] (byte) print_byte_at::b#2 ← phi( print_word_at/(byte) print_byte_at::b#0 print_word_at::@1/(byte) print_byte_at::b#1 )
  [77] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#2 >> (byte) 4
  [78] (byte) print_char_at::ch#0 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0)
  [79] (byte*) print_char_at::at#0 ← (byte*) print_byte_at::at#2
  [80] call print_char_at 
  to:print_byte_at::@1
print_byte_at::@1: scope:[print_byte_at]  from print_byte_at
  [81] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (byte) $f
  [82] (byte*) print_char_at::at#1 ← (byte*) print_byte_at::at#2 + (byte) 1
  [83] (byte) print_char_at::ch#1 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2)
  [84] call print_char_at 
  to:print_byte_at::@return
print_byte_at::@return: scope:[print_byte_at]  from print_byte_at::@1
  [85] return 
  to:@return
print_char_at: scope:[print_char_at]  from print_byte_at print_byte_at::@1
  [86] (byte*) print_char_at::at#2 ← phi( print_byte_at/(byte*) print_char_at::at#0 print_byte_at::@1/(byte*) print_char_at::at#1 )
  [86] (byte) print_char_at::ch#2 ← phi( print_byte_at/(byte) print_char_at::ch#0 print_byte_at::@1/(byte) print_char_at::ch#1 )
  [87] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  [88] return 
  to:@return
clock: scope:[clock]  from anim::@7
  [89] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0)
  to:clock::@return
clock::@return: scope:[clock]  from clock
  [90] return 
  to:@return
mulf8s_prepared: scope:[mulf8s_prepared]  from anim::@10 anim::@12 anim::@8 anim::@9
  [91] (signed byte) mulf8s_prepared::b#4 ← phi( anim::@8/(signed byte) mulf8s_prepared::b#0 anim::@9/(signed byte) mulf8s_prepared::b#2 anim::@10/(signed byte) mulf8s_prepared::b#1 anim::@12/(signed byte) mulf8s_prepared::b#3 )
  [92] (byte) mulf8u_prepared::b#0 ← (byte)(signed byte) mulf8s_prepared::b#4
  [93] call mulf8u_prepared 
  [94] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0
  to:mulf8s_prepared::@5
mulf8s_prepared::@5: scope:[mulf8s_prepared]  from mulf8s_prepared
  [95] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2
  [96] if(*((const signed byte*) mulf8s_prepared::memA#0)>=(signed byte) 0) goto mulf8s_prepared::@1
  to:mulf8s_prepared::@3
mulf8s_prepared::@3: scope:[mulf8s_prepared]  from mulf8s_prepared::@5
  [97] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0
  [98] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#4
  [99] (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#0 hi= (byte~) mulf8s_prepared::$15
  to:mulf8s_prepared::@1
mulf8s_prepared::@1: scope:[mulf8s_prepared]  from mulf8s_prepared::@3 mulf8s_prepared::@5
  [100] (word) mulf8s_prepared::m#5 ← phi( mulf8s_prepared::@3/(word) mulf8s_prepared::m#1 mulf8s_prepared::@5/(word) mulf8s_prepared::m#0 )
  [101] if((signed byte) mulf8s_prepared::b#4>=(signed byte) 0) goto mulf8s_prepared::@2
  to:mulf8s_prepared::@4
mulf8s_prepared::@4: scope:[mulf8s_prepared]  from mulf8s_prepared::@1
  [102] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5
  [103] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA#0)
  [104] (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16
  to:mulf8s_prepared::@2
mulf8s_prepared::@2: scope:[mulf8s_prepared]  from mulf8s_prepared::@1 mulf8s_prepared::@4
  [105] (word) mulf8s_prepared::m#4 ← phi( mulf8s_prepared::@1/(word) mulf8s_prepared::m#5 mulf8s_prepared::@4/(word) mulf8s_prepared::m#2 )
  to:mulf8s_prepared::@return
mulf8s_prepared::@return: scope:[mulf8s_prepared]  from mulf8s_prepared::@2
  [106] return 
  to:@return
mulf8u_prepared: scope:[mulf8u_prepared]  from mulf8s_prepared
  [107] *((const byte*) mulf8u_prepared::memB#0) ← (byte) mulf8u_prepared::b#0
  asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
  [109] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB#0) w= *((const byte*) mulf8u_prepared::resL#0)
  to:mulf8u_prepared::@return
mulf8u_prepared::@return: scope:[mulf8u_prepared]  from mulf8u_prepared
  [110] return 
  to:@return
mulf8u_prepare: scope:[mulf8u_prepare]  from anim::mulf8s_prepare1 anim::mulf8s_prepare2
  [111] (byte) mulf8u_prepare::a#2 ← phi( anim::mulf8s_prepare1/(byte~) mulf8u_prepare::a#3 anim::mulf8s_prepare2/(byte~) mulf8u_prepare::a#4 )
  [112] *((const byte*) mulf8u_prepare::memA#0) ← (byte) mulf8u_prepare::a#2
  asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
  to:mulf8u_prepare::@return
mulf8u_prepare::@return: scope:[mulf8u_prepare]  from mulf8u_prepare
  [114] return 
  to:@return
clock_start: scope:[clock_start]  from anim::@3
  [115] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  [116] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
  [117] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff
  [118] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
  [119] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  [120] return 
  to:@return
init: scope:[init]  from main
  [121] phi()
  [122] call mulf_init 
  to:init::@2
init::@2: scope:[init]  from init
  [123] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@2
  [124] (byte) init::i#2 ← phi( init::@1/(byte) init::i#1 init::@2/(byte) 0 )
  [125] *((const byte*) init::sprites_ptr#0 + (byte) init::i#2) ← (byte)(const byte*) SPRITE#0/(byte) $40
  [126] *((const byte*) SPRITES_COLS#0 + (byte) init::i#2) ← (const byte) GREEN#0
  [127] (byte) init::i#1 ← ++ (byte) init::i#2
  [128] if((byte) init::i#1!=(byte) 8) goto init::@1
  to:init::@return
init::@return: scope:[init]  from init::@1
  [129] return 
  to:@return
mulf_init: scope:[mulf_init]  from init
  [130] phi()
  to:mulf_init::@1
mulf_init::@1: scope:[mulf_init]  from mulf_init mulf_init::@2
  [131] (byte) mulf_init::x_2#3 ← phi( mulf_init/(byte) 0 mulf_init::@2/(byte) mulf_init::x_2#2 )
  [131] (byte*) mulf_init::sqr1_hi#2 ← phi( mulf_init/(const byte[$200]) mulf_sqr1_hi#0+(byte) 1 mulf_init::@2/(byte*) mulf_init::sqr1_hi#1 )
  [131] (byte*) mulf_init::sqr1_lo#2 ← phi( mulf_init/(const byte[$200]) mulf_sqr1_lo#0+(byte) 1 mulf_init::@2/(byte*) mulf_init::sqr1_lo#1 )
  [131] (word) mulf_init::sqr#4 ← phi( mulf_init/(byte) 0 mulf_init::@2/(word) mulf_init::sqr#1 )
  [131] (byte) mulf_init::c#2 ← phi( mulf_init/(byte) 0 mulf_init::@2/(byte) mulf_init::c#1 )
  [132] (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2
  [133] (byte~) mulf_init::$7 ← (byte) mulf_init::c#1 & (byte) 1
  [134] if((byte~) mulf_init::$7!=(byte) 0) goto mulf_init::@2
  to:mulf_init::@3
mulf_init::@3: scope:[mulf_init]  from mulf_init::@1
  [135] (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3
  [136] (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4
  to:mulf_init::@2
mulf_init::@2: scope:[mulf_init]  from mulf_init::@1 mulf_init::@3
  [137] (byte) mulf_init::x_2#2 ← phi( mulf_init::@1/(byte) mulf_init::x_2#3 mulf_init::@3/(byte) mulf_init::x_2#1 )
  [137] (word) mulf_init::sqr#3 ← phi( mulf_init::@1/(word) mulf_init::sqr#4 mulf_init::@3/(word) mulf_init::sqr#2 )
  [138] (byte~) mulf_init::$10 ← < (word) mulf_init::sqr#3
  [139] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$10
  [140] (byte~) mulf_init::$11 ← > (word) mulf_init::sqr#3
  [141] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$11
  [142] (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2
  [143] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2
  [144] (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#2
  [145] if((byte*) mulf_init::sqr1_lo#1!=(const byte[$200]) mulf_sqr1_lo#0+(word) $200) goto mulf_init::@1
  to:mulf_init::@4
mulf_init::@4: scope:[mulf_init]  from mulf_init::@2 mulf_init::@5
  [146] (byte) mulf_init::dir#2 ← phi( mulf_init::@2/(byte) $ff mulf_init::@5/(byte) mulf_init::dir#3 )
  [146] (byte*) mulf_init::sqr2_hi#2 ← phi( mulf_init::@2/(const byte[$200]) mulf_sqr2_hi#0 mulf_init::@5/(byte*) mulf_init::sqr2_hi#1 )
  [146] (byte*) mulf_init::sqr2_lo#2 ← phi( mulf_init::@2/(const byte[$200]) mulf_sqr2_lo#0 mulf_init::@5/(byte*) mulf_init::sqr2_lo#1 )
  [146] (byte) mulf_init::x_255#2 ← phi( mulf_init::@2/(byte) -1 mulf_init::@5/(byte) mulf_init::x_255#1 )
  [147] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte[$200]) mulf_sqr1_lo#0 + (byte) mulf_init::x_255#2)
  [148] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte[$200]) mulf_sqr1_hi#0 + (byte) mulf_init::x_255#2)
  [149] (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2
  [150] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2
  [151] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@7
  to:mulf_init::@5
mulf_init::@7: scope:[mulf_init]  from mulf_init::@4
  [152] phi()
  to:mulf_init::@5
mulf_init::@5: scope:[mulf_init]  from mulf_init::@4 mulf_init::@7
  [153] (byte) mulf_init::dir#3 ← phi( mulf_init::@7/(byte) mulf_init::dir#2 mulf_init::@4/(byte) 1 )
  [154] (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#2
  [155] if((byte*) mulf_init::sqr2_lo#1!=(const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) goto mulf_init::@4
  to:mulf_init::@6
mulf_init::@6: scope:[mulf_init]  from mulf_init::@5
  [156] *((const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_lo#0+(word) $100)
  [157] *((const byte[$200]) mulf_sqr2_hi#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_hi#0+(word) $100)
  to:mulf_init::@return
mulf_init::@return: scope:[mulf_init]  from mulf_init::@6
  [158] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte*) BORDERCOL
(dword*) CIA2_TIMER_AB
(byte*) CIA2_TIMER_A_CONTROL
(byte*) CIA2_TIMER_B_CONTROL
(byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
(byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
(byte) CIA_TIMER_CONTROL_CONTINUOUS
(byte) CIA_TIMER_CONTROL_START
(byte) CIA_TIMER_CONTROL_STOP
(dword) CLOCKS_PER_INIT
(byte*) COS
(byte) GREEN
(byte) LIGHT_BLUE
(byte*) RASTER
(byte*) SCREEN
(byte[$140]) SIN
(byte*) SPRITE
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_XMSB
(byte*) SPRITES_XPOS
(byte*) SPRITES_YPOS
(void()) anim()
(signed word~) anim::$10 202.0
(signed word~) anim::$11 202.0
(signed word~) anim::$12 202.0
(signed word~) anim::$13 202.0
(byte~) anim::$16 101.0
(byte~) anim::$19 202.0
(byte~) anim::$23 202.0
(byte~) anim::$26 202.0
(dword~) anim::$28 22.0
(signed word~) anim::$5 202.0
(signed word~) anim::$7 202.0
(byte) anim::angle
(byte) anim::angle#1 2.75
(byte) anim::angle#9 0.4888888888888889
(signed byte) anim::cos_a
(dword) anim::cyclecount
(dword) anim::cyclecount#0 22.0
(byte) anim::i
(byte) anim::i#1 151.5
(byte) anim::i#10 13.289473684210527
(byte) anim::i2
(byte) anim::i2#0 101.0
(byte~) anim::mulf8s_prepare1_$0
(signed byte) anim::mulf8s_prepare1_a
(byte~) anim::mulf8s_prepare2_$0
(signed byte) anim::mulf8s_prepare2_a
(signed byte) anim::sin_a
(byte) anim::sprite_msb
(byte) anim::sprite_msb#1 101.0
(byte) anim::sprite_msb#10 7.481481481481482
(byte) anim::sprite_msb#2 202.0
(byte) anim::sprite_msb#5 34.888888888888886
(signed byte) anim::x
(signed byte) anim::x#0 15.947368421052632
(signed word) anim::xpos
(signed word) anim::xpos#0 33.666666666666664
(signed word) anim::xr
(signed word) anim::xr#0 18.363636363636363
(signed word) anim::xr#1 33.666666666666664
(signed byte) anim::y
(signed byte) anim::y#0 23.307692307692307
(byte) anim::ypos
(byte) anim::ypos#0 50.5
(signed word) anim::yr
(signed word) anim::yr#0 16.833333333333332
(signed word) anim::yr#1 25.25
(dword()) clock()
(dword) clock::return
(dword) clock::return#0 4.333333333333333
(dword) clock::return#2 22.0
(void()) clock_start()
(void()) init()
(byte) init::i
(byte) init::i#1 16.5
(byte) init::i#2 14.666666666666666
(byte*) init::sprites_ptr
(void()) main()
(signed word()) mulf8s_prepared((signed byte) mulf8s_prepared::b)
(byte~) mulf8s_prepared::$12 4.0
(byte~) mulf8s_prepared::$15 4.0
(byte~) mulf8s_prepared::$16 4.0
(byte~) mulf8s_prepared::$8 4.0
(signed byte) mulf8s_prepared::b
(signed byte) mulf8s_prepared::b#0 202.0
(signed byte) mulf8s_prepared::b#1 202.0
(signed byte) mulf8s_prepared::b#2 202.0
(signed byte) mulf8s_prepared::b#3 202.0
(signed byte) mulf8s_prepared::b#4 40.6
(word) mulf8s_prepared::m
(word) mulf8s_prepared::m#0 2.0
(word) mulf8s_prepared::m#1 4.0
(word) mulf8s_prepared::m#2 4.0
(word) mulf8s_prepared::m#4 0.6666666666666666
(word) mulf8s_prepared::m#5 2.5
(signed byte*) mulf8s_prepared::memA
(signed word) mulf8s_prepared::return
(void()) mulf8u_prepare((byte) mulf8u_prepare::a)
(byte) mulf8u_prepare::a
(byte) mulf8u_prepare::a#2 204.0
(byte~) mulf8u_prepare::a#3 202.0
(byte~) mulf8u_prepare::a#4 202.0
(byte*) mulf8u_prepare::memA
(word()) mulf8u_prepared((byte) mulf8u_prepared::b)
(byte) mulf8u_prepared::b
(byte) mulf8u_prepared::b#0 4.0
(byte*) mulf8u_prepared::memB
(byte*) mulf8u_prepared::resL
(word) mulf8u_prepared::return
(word) mulf8u_prepared::return#0 1.3333333333333333
(word) mulf8u_prepared::return#2 4.0
(void()) mulf_init()
(byte~) mulf_init::$10 22.0
(byte~) mulf_init::$11 22.0
(byte~) mulf_init::$7 22.0
(byte) mulf_init::c
(byte) mulf_init::c#1 2.357142857142857
(byte) mulf_init::c#2 22.0
(byte) mulf_init::dir
(byte) mulf_init::dir#2 4.714285714285714
(byte) mulf_init::dir#3 7.333333333333333
(word) mulf_init::sqr
(word) mulf_init::sqr#1 7.333333333333333
(word) mulf_init::sqr#2 22.0
(word) mulf_init::sqr#3 9.166666666666666
(word) mulf_init::sqr#4 6.6000000000000005
(byte*) mulf_init::sqr1_hi
(byte*) mulf_init::sqr1_hi#1 5.5
(byte*) mulf_init::sqr1_hi#2 3.0
(byte*) mulf_init::sqr1_lo
(byte*) mulf_init::sqr1_lo#1 16.5
(byte*) mulf_init::sqr1_lo#2 2.5384615384615383
(byte*) mulf_init::sqr2_hi
(byte*) mulf_init::sqr2_hi#1 3.142857142857143
(byte*) mulf_init::sqr2_hi#2 11.0
(byte*) mulf_init::sqr2_lo
(byte*) mulf_init::sqr2_lo#1 16.5
(byte*) mulf_init::sqr2_lo#2 4.125
(byte) mulf_init::x_2
(byte) mulf_init::x_2#1 11.0
(byte) mulf_init::x_2#2 4.888888888888889
(byte) mulf_init::x_2#3 8.25
(byte) mulf_init::x_255
(byte) mulf_init::x_255#1 5.5
(byte) mulf_init::x_255#2 11.0
(byte[$200]) mulf_sqr1_hi
(byte[$200]) mulf_sqr1_lo
(byte[$200]) mulf_sqr2_hi
(byte[$200]) mulf_sqr2_lo
(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
(byte~) print_byte_at::$0 4.0
(byte~) print_byte_at::$2 2.0
(byte*) print_byte_at::at
(byte*) print_byte_at::at#0 4.0
(byte*) print_byte_at::at#1 4.0
(byte*) print_byte_at::at#2 1.3333333333333333
(byte) print_byte_at::b
(byte) print_byte_at::b#0 2.0
(byte) print_byte_at::b#1 2.0
(byte) print_byte_at::b#2 1.6
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(byte*) print_char_at::at
(byte*) print_char_at::at#0 4.0
(byte*) print_char_at::at#1 2.0
(byte*) print_char_at::at#2 6.0
(byte) print_char_at::ch
(byte) print_char_at::ch#0 2.0
(byte) print_char_at::ch#1 4.0
(byte) print_char_at::ch#2 6.0
(void()) print_dword_at((dword) print_dword_at::dw , (byte*) print_dword_at::at)
(byte*) print_dword_at::at
(dword) print_dword_at::dw
(dword) print_dword_at::dw#0 5.0
(byte[]) print_hextab
(void()) print_word_at((word) print_word_at::w , (byte*) print_word_at::at)
(byte*) print_word_at::at
(byte*) print_word_at::at#2 0.8
(word) print_word_at::w
(word) print_word_at::w#0 4.0
(word) print_word_at::w#1 4.0
(word) print_word_at::w#2 2.0
(signed byte[8]) xs
(signed byte[8]) ys

Initial phi equivalence classes
[ anim::angle#9 anim::angle#1 ]
[ anim::i#10 anim::i#1 ]
[ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ]
[ print_word_at::w#2 print_word_at::w#0 print_word_at::w#1 ]
[ print_word_at::at#2 ]
[ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ]
[ print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ]
[ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
[ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
[ mulf8s_prepared::b#4 mulf8s_prepared::b#0 mulf8s_prepared::b#2 mulf8s_prepared::b#1 mulf8s_prepared::b#3 ]
[ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ]
[ mulf8u_prepare::a#2 mulf8u_prepare::a#3 mulf8u_prepare::a#4 ]
[ init::i#2 init::i#1 ]
[ mulf_init::c#2 mulf_init::c#1 ]
[ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
[ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
[ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
[ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
[ mulf_init::x_255#2 mulf_init::x_255#1 ]
[ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
[ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
[ mulf_init::dir#2 mulf_init::dir#3 ]
Added variable anim::x#0 to zero page equivalence class [ anim::x#0 ]
Added variable anim::y#0 to zero page equivalence class [ anim::y#0 ]
Added variable anim::$5 to zero page equivalence class [ anim::$5 ]
Added variable anim::xr#0 to zero page equivalence class [ anim::xr#0 ]
Added variable anim::$7 to zero page equivalence class [ anim::$7 ]
Added variable anim::yr#0 to zero page equivalence class [ anim::yr#0 ]
Added variable anim::$10 to zero page equivalence class [ anim::$10 ]
Added variable anim::$11 to zero page equivalence class [ anim::$11 ]
Added variable anim::xr#1 to zero page equivalence class [ anim::xr#1 ]
Added variable anim::$12 to zero page equivalence class [ anim::$12 ]
Added variable anim::$13 to zero page equivalence class [ anim::$13 ]
Added variable anim::yr#1 to zero page equivalence class [ anim::yr#1 ]
Added variable anim::$16 to zero page equivalence class [ anim::$16 ]
Added variable anim::xpos#0 to zero page equivalence class [ anim::xpos#0 ]
Added variable anim::$19 to zero page equivalence class [ anim::$19 ]
Added variable anim::$23 to zero page equivalence class [ anim::$23 ]
Added variable anim::ypos#0 to zero page equivalence class [ anim::ypos#0 ]
Added variable anim::i2#0 to zero page equivalence class [ anim::i2#0 ]
Added variable anim::$26 to zero page equivalence class [ anim::$26 ]
Added variable clock::return#2 to zero page equivalence class [ clock::return#2 ]
Added variable anim::$28 to zero page equivalence class [ anim::$28 ]
Added variable anim::cyclecount#0 to zero page equivalence class [ anim::cyclecount#0 ]
Added variable print_dword_at::dw#0 to zero page equivalence class [ print_dword_at::dw#0 ]
Added variable print_byte_at::$0 to zero page equivalence class [ print_byte_at::$0 ]
Added variable print_byte_at::$2 to zero page equivalence class [ print_byte_at::$2 ]
Added variable clock::return#0 to zero page equivalence class [ clock::return#0 ]
Added variable mulf8u_prepared::b#0 to zero page equivalence class [ mulf8u_prepared::b#0 ]
Added variable mulf8u_prepared::return#2 to zero page equivalence class [ mulf8u_prepared::return#2 ]
Added variable mulf8s_prepared::$8 to zero page equivalence class [ mulf8s_prepared::$8 ]
Added variable mulf8s_prepared::$15 to zero page equivalence class [ mulf8s_prepared::$15 ]
Added variable mulf8s_prepared::$12 to zero page equivalence class [ mulf8s_prepared::$12 ]
Added variable mulf8s_prepared::$16 to zero page equivalence class [ mulf8s_prepared::$16 ]
Added variable mulf8u_prepared::return#0 to zero page equivalence class [ mulf8u_prepared::return#0 ]
Added variable mulf_init::$7 to zero page equivalence class [ mulf_init::$7 ]
Added variable mulf_init::$10 to zero page equivalence class [ mulf_init::$10 ]
Added variable mulf_init::$11 to zero page equivalence class [ mulf_init::$11 ]
Complete equivalence classes
[ anim::angle#9 anim::angle#1 ]
[ anim::i#10 anim::i#1 ]
[ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ]
[ print_word_at::w#2 print_word_at::w#0 print_word_at::w#1 ]
[ print_word_at::at#2 ]
[ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ]
[ print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ]
[ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
[ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
[ mulf8s_prepared::b#4 mulf8s_prepared::b#0 mulf8s_prepared::b#2 mulf8s_prepared::b#1 mulf8s_prepared::b#3 ]
[ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ]
[ mulf8u_prepare::a#2 mulf8u_prepare::a#3 mulf8u_prepare::a#4 ]
[ init::i#2 init::i#1 ]
[ mulf_init::c#2 mulf_init::c#1 ]
[ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
[ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
[ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
[ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
[ mulf_init::x_255#2 mulf_init::x_255#1 ]
[ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
[ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
[ mulf_init::dir#2 mulf_init::dir#3 ]
[ anim::x#0 ]
[ anim::y#0 ]
[ anim::$5 ]
[ anim::xr#0 ]
[ anim::$7 ]
[ anim::yr#0 ]
[ anim::$10 ]
[ anim::$11 ]
[ anim::xr#1 ]
[ anim::$12 ]
[ anim::$13 ]
[ anim::yr#1 ]
[ anim::$16 ]
[ anim::xpos#0 ]
[ anim::$19 ]
[ anim::$23 ]
[ anim::ypos#0 ]
[ anim::i2#0 ]
[ anim::$26 ]
[ clock::return#2 ]
[ anim::$28 ]
[ anim::cyclecount#0 ]
[ print_dword_at::dw#0 ]
[ print_byte_at::$0 ]
[ print_byte_at::$2 ]
[ clock::return#0 ]
[ mulf8u_prepared::b#0 ]
[ mulf8u_prepared::return#2 ]
[ mulf8s_prepared::$8 ]
[ mulf8s_prepared::$15 ]
[ mulf8s_prepared::$12 ]
[ mulf8s_prepared::$16 ]
[ mulf8u_prepared::return#0 ]
[ mulf_init::$7 ]
[ mulf_init::$10 ]
[ mulf_init::$11 ]
Allocated zp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ]
Allocated zp ZP_BYTE:3 [ anim::i#10 anim::i#1 ]
Allocated zp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ]
Allocated zp ZP_WORD:5 [ print_word_at::w#2 print_word_at::w#0 print_word_at::w#1 ]
Allocated zp ZP_WORD:7 [ print_word_at::at#2 ]
Allocated zp ZP_BYTE:9 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ]
Allocated zp ZP_WORD:10 [ print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ]
Allocated zp ZP_BYTE:12 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
Allocated zp ZP_WORD:13 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
Allocated zp ZP_BYTE:15 [ mulf8s_prepared::b#4 mulf8s_prepared::b#0 mulf8s_prepared::b#2 mulf8s_prepared::b#1 mulf8s_prepared::b#3 ]
Allocated zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ]
Allocated zp ZP_BYTE:18 [ mulf8u_prepare::a#2 mulf8u_prepare::a#3 mulf8u_prepare::a#4 ]
Allocated zp ZP_BYTE:19 [ init::i#2 init::i#1 ]
Allocated zp ZP_BYTE:20 [ mulf_init::c#2 mulf_init::c#1 ]
Allocated zp ZP_WORD:21 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
Allocated zp ZP_WORD:23 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
Allocated zp ZP_BYTE:25 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Allocated zp ZP_WORD:26 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
Allocated zp ZP_BYTE:28 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Allocated zp ZP_WORD:29 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
Allocated zp ZP_WORD:31 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
Allocated zp ZP_BYTE:33 [ mulf_init::dir#2 mulf_init::dir#3 ]
Allocated zp ZP_BYTE:34 [ anim::x#0 ]
Allocated zp ZP_BYTE:35 [ anim::y#0 ]
Allocated zp ZP_WORD:36 [ anim::$5 ]
Allocated zp ZP_WORD:38 [ anim::xr#0 ]
Allocated zp ZP_WORD:40 [ anim::$7 ]
Allocated zp ZP_WORD:42 [ anim::yr#0 ]
Allocated zp ZP_WORD:44 [ anim::$10 ]
Allocated zp ZP_WORD:46 [ anim::$11 ]
Allocated zp ZP_WORD:48 [ anim::xr#1 ]
Allocated zp ZP_WORD:50 [ anim::$12 ]
Allocated zp ZP_WORD:52 [ anim::$13 ]
Allocated zp ZP_WORD:54 [ anim::yr#1 ]
Allocated zp ZP_BYTE:56 [ anim::$16 ]
Allocated zp ZP_WORD:57 [ anim::xpos#0 ]
Allocated zp ZP_BYTE:59 [ anim::$19 ]
Allocated zp ZP_BYTE:60 [ anim::$23 ]
Allocated zp ZP_BYTE:61 [ anim::ypos#0 ]
Allocated zp ZP_BYTE:62 [ anim::i2#0 ]
Allocated zp ZP_BYTE:63 [ anim::$26 ]
Allocated zp ZP_DWORD:64 [ clock::return#2 ]
Allocated zp ZP_DWORD:68 [ anim::$28 ]
Allocated zp ZP_DWORD:72 [ anim::cyclecount#0 ]
Allocated zp ZP_DWORD:76 [ print_dword_at::dw#0 ]
Allocated zp ZP_BYTE:80 [ print_byte_at::$0 ]
Allocated zp ZP_BYTE:81 [ print_byte_at::$2 ]
Allocated zp ZP_DWORD:82 [ clock::return#0 ]
Allocated zp ZP_BYTE:86 [ mulf8u_prepared::b#0 ]
Allocated zp ZP_WORD:87 [ mulf8u_prepared::return#2 ]
Allocated zp ZP_BYTE:89 [ mulf8s_prepared::$8 ]
Allocated zp ZP_BYTE:90 [ mulf8s_prepared::$15 ]
Allocated zp ZP_BYTE:91 [ mulf8s_prepared::$12 ]
Allocated zp ZP_BYTE:92 [ mulf8s_prepared::$16 ]
Allocated zp ZP_WORD:93 [ mulf8u_prepared::return#0 ]
Allocated zp ZP_BYTE:95 [ mulf_init::$7 ]
Allocated zp ZP_BYTE:96 [ mulf_init::$10 ]
Allocated zp ZP_BYTE:97 [ mulf_init::$11 ]

INITIAL ASM
Target platform is c64basic
  // File Comments
// 2D rotattion of 8 sprites 
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  // CIA #2 Timer A+B Value (32-bit)
  .label CIA2_TIMER_AB = $dd04
  // CIA #2 Timer A Control Register
  .label CIA2_TIMER_A_CONTROL = $dd0e
  // CIA #2 Timer B Control Register
  .label CIA2_TIMER_B_CONTROL = $dd0f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer Control - Time CONTINUOUS/ONE-SHOT (0:CONTINUOUS, 1: ONE-SHOT)
  .const CIA_TIMER_CONTROL_CONTINUOUS = 0
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  .const GREEN = 5
  .const LIGHT_BLUE = $e
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .label SCREEN = $400
  // A single sprite
  .label SPRITE = $3000
  .label COS = SIN+$40
  // @begin
bbegin:
  jmp b1
  // @1
b1:
  // kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
// sin(x) = cos(x+PI/2)
main: {
    // asm { sei  }
    sei
    // [5] call init 
    // [121] phi from main to init [phi:main->init]
  init_from_main:
    jsr init
    // [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
    // main::@1
  b1:
    // [7] call anim 
    // [9] phi from main::@1 to anim [phi:main::@1->anim]
  anim_from_b1:
    jsr anim
    jmp breturn
    // main::@return
  breturn:
    // [8] return 
    rts
}
  // anim
anim: {
    .label _5 = $24
    .label _7 = $28
    .label _10 = $2c
    .label _11 = $2e
    .label _12 = $32
    .label _13 = $34
    .label _16 = $38
    .label _19 = $3b
    .label _23 = $3c
    .label _26 = $3f
    .label _28 = $44
    .label x = $22
    .label y = $23
    .label xr = $26
    .label yr = $2a
    .label xr_1 = $30
    .label yr_1 = $36
    .label xpos = $39
    .label sprite_msb = 4
    .label ypos = $3d
    .label i2 = $3e
    .label i = 3
    .label angle = 2
    .label cyclecount = $48
    // [10] phi from anim to anim::@1 [phi:anim->anim::@1]
  b1_from_anim:
    // [10] phi (byte) anim::angle#9 = (byte) 0 [phi:anim->anim::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta angle
    jmp b1
    // anim::@1
  b1:
    jmp b2
    // anim::@2
  b2:
    // [11] if(*((const byte*) RASTER#0)!=(byte) $ff) goto anim::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    jmp b3
    // anim::@3
  b3:
    // [12] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [13] call clock_start 
    jsr clock_start
    // [14] phi from anim::@3 to anim::@4 [phi:anim::@3->anim::@4]
  b4_from_b3:
    // [14] phi (byte) anim::sprite_msb#10 = (byte) 0 [phi:anim::@3->anim::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta sprite_msb
    // [14] phi (byte) anim::i#10 = (byte) 0 [phi:anim::@3->anim::@4#1] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b4
    // [14] phi from anim::@5 to anim::@4 [phi:anim::@5->anim::@4]
  b4_from_b5:
    // [14] phi (byte) anim::sprite_msb#10 = (byte) anim::sprite_msb#5 [phi:anim::@5->anim::@4#0] -- register_copy 
    // [14] phi (byte) anim::i#10 = (byte) anim::i#1 [phi:anim::@5->anim::@4#1] -- register_copy 
    jmp b4
    // anim::@4
  b4:
    // [15] (signed byte) anim::x#0 ← *((const signed byte[8]) xs#0 + (byte) anim::i#10) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda xs,y
    sta x
    // [16] (signed byte) anim::y#0 ← *((const signed byte[8]) ys#0 + (byte) anim::i#10) -- vbsz1=pbsc1_derefidx_vbuz2 
    // signed fixed[7.0]
    ldy i
    lda ys,y
    sta y
    jmp mulf8s_prepare1
    // anim::mulf8s_prepare1
  mulf8s_prepare1:
    // [17] (byte~) mulf8u_prepare::a#3 ← (byte)(signed byte)*((const byte*) COS#0 + (byte) anim::angle#9) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy angle
    lda COS,y
    sta mulf8u_prepare.a
    // [18] call mulf8u_prepare 
    // [111] phi from anim::mulf8s_prepare1 to mulf8u_prepare [phi:anim::mulf8s_prepare1->mulf8u_prepare]
  mulf8u_prepare_from_mulf8s_prepare1:
    // [111] phi (byte) mulf8u_prepare::a#2 = (byte~) mulf8u_prepare::a#3 [phi:anim::mulf8s_prepare1->mulf8u_prepare#0] -- register_copy 
    jsr mulf8u_prepare
    jmp b8
    // anim::@8
  b8:
    // [19] (signed byte) mulf8s_prepared::b#0 ← (signed byte) anim::x#0 -- vbsz1=vbsz2 
    lda x
    sta mulf8s_prepared.b
    // [20] call mulf8s_prepared 
    // [91] phi from anim::@8 to mulf8s_prepared [phi:anim::@8->mulf8s_prepared]
  mulf8s_prepared_from_b8:
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#0 [phi:anim::@8->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    jmp b10
    // anim::@10
  b10:
    // [21] (signed word~) anim::$5 ← (signed word)(word) mulf8s_prepared::m#4 -- vwsz1=vwsz2 
    lda mulf8s_prepared.m
    sta _5
    lda mulf8s_prepared.m+1
    sta _5+1
    // [22] (signed word) anim::xr#0 ← (signed word~) anim::$5 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda _5
    asl
    sta xr
    lda _5+1
    rol
    sta xr+1
    // [23] (signed byte) mulf8s_prepared::b#1 ← (signed byte) anim::y#0 -- vbsz1=vbsz2 
    lda y
    sta mulf8s_prepared.b
    // [24] call mulf8s_prepared 
    // [91] phi from anim::@10 to mulf8s_prepared [phi:anim::@10->mulf8s_prepared]
  mulf8s_prepared_from_b10:
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#1 [phi:anim::@10->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    jmp b11
    // anim::@11
  b11:
    // [25] (signed word~) anim::$7 ← (signed word)(word) mulf8s_prepared::m#4 -- vwsz1=vwsz2 
    lda mulf8s_prepared.m
    sta _7
    lda mulf8s_prepared.m+1
    sta _7+1
    // [26] (signed word) anim::yr#0 ← (signed word~) anim::$7 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda _7
    asl
    sta yr
    lda _7+1
    rol
    sta yr+1
    jmp mulf8s_prepare2
    // anim::mulf8s_prepare2
  mulf8s_prepare2:
    // [27] (byte~) mulf8u_prepare::a#4 ← (byte)(signed byte)*((const byte[$140]) SIN#0 + (byte) anim::angle#9) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy angle
    lda SIN,y
    sta mulf8u_prepare.a
    // [28] call mulf8u_prepare 
    // [111] phi from anim::mulf8s_prepare2 to mulf8u_prepare [phi:anim::mulf8s_prepare2->mulf8u_prepare]
  mulf8u_prepare_from_mulf8s_prepare2:
    // [111] phi (byte) mulf8u_prepare::a#2 = (byte~) mulf8u_prepare::a#4 [phi:anim::mulf8s_prepare2->mulf8u_prepare#0] -- register_copy 
    jsr mulf8u_prepare
    jmp b9
    // anim::@9
  b9:
    // [29] (signed byte) mulf8s_prepared::b#2 ← (signed byte) anim::y#0 -- vbsz1=vbsz2 
    lda y
    sta mulf8s_prepared.b
    // [30] call mulf8s_prepared 
    // [91] phi from anim::@9 to mulf8s_prepared [phi:anim::@9->mulf8s_prepared]
  mulf8s_prepared_from_b9:
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#2 [phi:anim::@9->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    jmp b12
    // anim::@12
  b12:
    // [31] (signed word~) anim::$10 ← (signed word)(word) mulf8s_prepared::m#4 -- vwsz1=vwsz2 
    lda mulf8s_prepared.m
    sta _10
    lda mulf8s_prepared.m+1
    sta _10+1
    // [32] (signed word~) anim::$11 ← (signed word~) anim::$10 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda _10
    asl
    sta _11
    lda _10+1
    rol
    sta _11+1
    // [33] (signed word) anim::xr#1 ← (signed word) anim::xr#0 - (signed word~) anim::$11 -- vwsz1=vwsz2_minus_vwsz3 
    lda xr
    sec
    sbc _11
    sta xr_1
    lda xr+1
    sbc _11+1
    sta xr_1+1
    // [34] (signed byte) mulf8s_prepared::b#3 ← (signed byte) anim::x#0 -- vbsz1=vbsz2 
    lda x
    sta mulf8s_prepared.b
    // [35] call mulf8s_prepared 
    // [91] phi from anim::@12 to mulf8s_prepared [phi:anim::@12->mulf8s_prepared]
  mulf8s_prepared_from_b12:
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#3 [phi:anim::@12->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    jmp b13
    // anim::@13
  b13:
    // [36] (signed word~) anim::$12 ← (signed word)(word) mulf8s_prepared::m#4 -- vwsz1=vwsz2 
    lda mulf8s_prepared.m
    sta _12
    lda mulf8s_prepared.m+1
    sta _12+1
    // [37] (signed word~) anim::$13 ← (signed word~) anim::$12 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda _12
    asl
    sta _13
    lda _12+1
    rol
    sta _13+1
    // [38] (signed word) anim::yr#1 ← (signed word) anim::yr#0 + (signed word~) anim::$13 -- vwsz1=vwsz2_plus_vwsz3 
    // signed fixed[8.8]
    lda yr
    clc
    adc _13
    sta yr_1
    lda yr+1
    adc _13+1
    sta yr_1+1
    // [39] (byte~) anim::$16 ← > (signed word) anim::xr#1 -- vbuz1=_hi_vwsz2 
    lda xr_1+1
    sta _16
    // [40] (signed word) anim::xpos#0 ← (signed byte)(byte~) anim::$16 + (signed byte) $18+(signed word) $95 -- vwsz1=vbsz2_plus_vwsc1 
    lda _16
    tax
    clc
    adc #<$18+$95
    sta xpos
    txa
    ora #$7f
    bmi !+
    lda #0
  !:
    adc #>$18+$95
    sta xpos+1
    // [41] (byte) anim::sprite_msb#1 ← (byte) anim::sprite_msb#10 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr sprite_msb
    // [42] (byte~) anim::$19 ← > (signed word) anim::xpos#0 -- vbuz1=_hi_vwsz2 
    lda xpos+1
    sta _19
    // [43] if((byte~) anim::$19==(byte) 0) goto anim::@5 -- vbuz1_eq_0_then_la1 
    lda _19
    cmp #0
    beq b5_from_b13
    jmp b6
    // anim::@6
  b6:
    // [44] (byte) anim::sprite_msb#2 ← (byte) anim::sprite_msb#1 | (byte) $80 -- vbuz1=vbuz1_bor_vbuc1 
    lda #$80
    ora sprite_msb
    sta sprite_msb
    // [45] phi from anim::@13 anim::@6 to anim::@5 [phi:anim::@13/anim::@6->anim::@5]
  b5_from_b13:
  b5_from_b6:
    // [45] phi (byte) anim::sprite_msb#5 = (byte) anim::sprite_msb#1 [phi:anim::@13/anim::@6->anim::@5#0] -- register_copy 
    jmp b5
    // anim::@5
  b5:
    // [46] (byte~) anim::$23 ← > (signed word) anim::yr#1 -- vbuz1=_hi_vwsz2 
    lda yr_1+1
    sta _23
    // [47] (byte) anim::ypos#0 ← (byte~) anim::$23 + (byte) $59+(byte) $33 -- vbuz1=vbuz2_plus_vbuc1 
    lax _23
    axs #-[$59+$33]
    stx ypos
    // [48] (byte) anim::i2#0 ← (byte) anim::i#10 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda i
    asl
    sta i2
    // [49] (byte~) anim::$26 ← < (signed word) anim::xpos#0 -- vbuz1=_lo_vwsz2 
    lda xpos
    sta _26
    // [50] *((const byte*) SPRITES_XPOS#0 + (byte) anim::i2#0) ← (byte~) anim::$26 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _26
    ldy i2
    sta SPRITES_XPOS,y
    // [51] *((const byte*) SPRITES_YPOS#0 + (byte) anim::i2#0) ← (byte) anim::ypos#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda ypos
    ldy i2
    sta SPRITES_YPOS,y
    // [52] (byte) anim::i#1 ← ++ (byte) anim::i#10 -- vbuz1=_inc_vbuz1 
    inc i
    // [53] if((byte) anim::i#1!=(byte) 8) goto anim::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp i
    bne b4_from_b5
    jmp b7
    // anim::@7
  b7:
    // [54] *((const byte*) SPRITES_XMSB#0) ← (byte) anim::sprite_msb#5 -- _deref_pbuc1=vbuz1 
    lda sprite_msb
    sta SPRITES_XMSB
    // [55] (byte) anim::angle#1 ← ++ (byte) anim::angle#9 -- vbuz1=_inc_vbuz1 
    inc angle
    // [56] call clock 
    jsr clock
    // [57] (dword) clock::return#2 ← (dword) clock::return#0 -- vduz1=vduz2 
    lda clock.return
    sta clock.return_2
    lda clock.return+1
    sta clock.return_2+1
    lda clock.return+2
    sta clock.return_2+2
    lda clock.return+3
    sta clock.return_2+3
    jmp b14
    // anim::@14
  b14:
    // [58] (dword~) anim::$28 ← (dword) clock::return#2 -- vduz1=vduz2 
    lda clock.return_2
    sta _28
    lda clock.return_2+1
    sta _28+1
    lda clock.return_2+2
    sta _28+2
    lda clock.return_2+3
    sta _28+3
    // [59] (dword) anim::cyclecount#0 ← (dword~) anim::$28 - (const dword) CLOCKS_PER_INIT#0 -- vduz1=vduz2_minus_vduc1 
    lda _28
    sec
    sbc #<CLOCKS_PER_INIT
    sta cyclecount
    lda _28+1
    sbc #>CLOCKS_PER_INIT
    sta cyclecount+1
    lda _28+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta cyclecount+2
    lda _28+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta cyclecount+3
    // [60] (dword) print_dword_at::dw#0 ← (dword) anim::cyclecount#0 -- vduz1=vduz2 
    lda cyclecount
    sta print_dword_at.dw
    lda cyclecount+1
    sta print_dword_at.dw+1
    lda cyclecount+2
    sta print_dword_at.dw+2
    lda cyclecount+3
    sta print_dword_at.dw+3
    // [61] call print_dword_at 
    jsr print_dword_at
    jmp b15
    // anim::@15
  b15:
    // [62] *((const byte*) BORDERCOL#0) ← (const byte) LIGHT_BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #LIGHT_BLUE
    sta BORDERCOL
    // [10] phi from anim::@15 to anim::@1 [phi:anim::@15->anim::@1]
  b1_from_b15:
    // [10] phi (byte) anim::angle#9 = (byte) anim::angle#1 [phi:anim::@15->anim::@1#0] -- register_copy 
    jmp b1
}
  // print_dword_at
// Print a dword as HEX at a specific position
// print_dword_at(dword zeropage($4c) dw)
print_dword_at: {
    .label dw = $4c
    // [63] (word) print_word_at::w#0 ← > (dword) print_dword_at::dw#0 -- vwuz1=_hi_vduz2 
    lda dw+2
    sta print_word_at.w
    lda dw+3
    sta print_word_at.w+1
    // [64] call print_word_at 
    // [68] phi from print_dword_at to print_word_at [phi:print_dword_at->print_word_at]
  print_word_at_from_print_dword_at:
    // [68] phi (byte*) print_word_at::at#2 = (const byte*) SCREEN#0 [phi:print_dword_at->print_word_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta print_word_at.at
    lda #>SCREEN
    sta print_word_at.at+1
    // [68] phi (word) print_word_at::w#2 = (word) print_word_at::w#0 [phi:print_dword_at->print_word_at#1] -- register_copy 
    jsr print_word_at
    jmp b1
    // print_dword_at::@1
  b1:
    // [65] (word) print_word_at::w#1 ← < (dword) print_dword_at::dw#0 -- vwuz1=_lo_vduz2 
    lda dw
    sta print_word_at.w
    lda dw+1
    sta print_word_at.w+1
    // [66] call print_word_at 
    // [68] phi from print_dword_at::@1 to print_word_at [phi:print_dword_at::@1->print_word_at]
  print_word_at_from_b1:
    // [68] phi (byte*) print_word_at::at#2 = (const byte*) SCREEN#0+(byte) 4 [phi:print_dword_at::@1->print_word_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN+4
    sta print_word_at.at
    lda #>SCREEN+4
    sta print_word_at.at+1
    // [68] phi (word) print_word_at::w#2 = (word) print_word_at::w#1 [phi:print_dword_at::@1->print_word_at#1] -- register_copy 
    jsr print_word_at
    jmp breturn
    // print_dword_at::@return
  breturn:
    // [67] return 
    rts
}
  // print_word_at
// Print a word as HEX at a specific position
// print_word_at(word zeropage(5) w, byte* zeropage(7) at)
print_word_at: {
    .label w = 5
    .label at = 7
    // [69] (byte) print_byte_at::b#0 ← > (word) print_word_at::w#2 -- vbuz1=_hi_vwuz2 
    lda w+1
    sta print_byte_at.b
    // [70] (byte*) print_byte_at::at#0 ← (byte*) print_word_at::at#2 -- pbuz1=pbuz2 
    lda at
    sta print_byte_at.at
    lda at+1
    sta print_byte_at.at+1
    // [71] call print_byte_at 
    // [76] phi from print_word_at to print_byte_at [phi:print_word_at->print_byte_at]
  print_byte_at_from_print_word_at:
    // [76] phi (byte*) print_byte_at::at#2 = (byte*) print_byte_at::at#0 [phi:print_word_at->print_byte_at#0] -- register_copy 
    // [76] phi (byte) print_byte_at::b#2 = (byte) print_byte_at::b#0 [phi:print_word_at->print_byte_at#1] -- register_copy 
    jsr print_byte_at
    jmp b1
    // print_word_at::@1
  b1:
    // [72] (byte) print_byte_at::b#1 ← < (word) print_word_at::w#2 -- vbuz1=_lo_vwuz2 
    lda w
    sta print_byte_at.b
    // [73] (byte*) print_byte_at::at#1 ← (byte*) print_word_at::at#2 + (byte) 2 -- pbuz1=pbuz2_plus_2 
    lda at
    clc
    adc #2
    sta print_byte_at.at
    lda at+1
    adc #0
    sta print_byte_at.at+1
    // [74] call print_byte_at 
    // [76] phi from print_word_at::@1 to print_byte_at [phi:print_word_at::@1->print_byte_at]
  print_byte_at_from_b1:
    // [76] phi (byte*) print_byte_at::at#2 = (byte*) print_byte_at::at#1 [phi:print_word_at::@1->print_byte_at#0] -- register_copy 
    // [76] phi (byte) print_byte_at::b#2 = (byte) print_byte_at::b#1 [phi:print_word_at::@1->print_byte_at#1] -- register_copy 
    jsr print_byte_at
    jmp breturn
    // print_word_at::@return
  breturn:
    // [75] return 
    rts
}
  // print_byte_at
// Print a byte as HEX at a specific position
// print_byte_at(byte zeropage(9) b, byte* zeropage($a) at)
print_byte_at: {
    .label _0 = $50
    .label _2 = $51
    .label b = 9
    .label at = $a
    // [77] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#2 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda b
    lsr
    lsr
    lsr
    lsr
    sta _0
    // [78] (byte) print_char_at::ch#0 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy _0
    lda print_hextab,y
    sta print_char_at.ch
    // [79] (byte*) print_char_at::at#0 ← (byte*) print_byte_at::at#2 -- pbuz1=pbuz2 
    lda at
    sta print_char_at.at
    lda at+1
    sta print_char_at.at+1
    // [80] call print_char_at 
    // [86] phi from print_byte_at to print_char_at [phi:print_byte_at->print_char_at]
  print_char_at_from_print_byte_at:
    // [86] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#0 [phi:print_byte_at->print_char_at#0] -- register_copy 
    // [86] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#0 [phi:print_byte_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp b1
    // print_byte_at::@1
  b1:
    // [81] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and b
    sta _2
    // [82] (byte*) print_char_at::at#1 ← (byte*) print_byte_at::at#2 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda at
    clc
    adc #1
    sta print_char_at.at
    lda at+1
    adc #0
    sta print_char_at.at+1
    // [83] (byte) print_char_at::ch#1 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy _2
    lda print_hextab,y
    sta print_char_at.ch
    // [84] call print_char_at 
    // [86] phi from print_byte_at::@1 to print_char_at [phi:print_byte_at::@1->print_char_at]
  print_char_at_from_b1:
    // [86] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#1 [phi:print_byte_at::@1->print_char_at#0] -- register_copy 
    // [86] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#1 [phi:print_byte_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp breturn
    // print_byte_at::@return
  breturn:
    // [85] return 
    rts
}
  // print_char_at
// Print a single char
// print_char_at(byte zeropage($c) ch, byte* zeropage($d) at)
print_char_at: {
    .label ch = $c
    .label at = $d
    // [87] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 -- _deref_pbuz1=vbuz2 
    lda ch
    ldy #0
    sta (at),y
    jmp breturn
    // print_char_at::@return
  breturn:
    // [88] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = $52
    .label return_2 = $40
    // [89] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta return+3
    jmp breturn
    // clock::@return
  breturn:
    // [90] return 
    rts
}
  // mulf8s_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8s_prepare(byte a)
// mulf8s_prepared(signed byte zeropage($f) b)
mulf8s_prepared: {
    .label memA = $fd
    .label _8 = $59
    .label _12 = $5b
    .label _15 = $5a
    .label _16 = $5c
    .label m = $10
    .label b = $f
    // [92] (byte) mulf8u_prepared::b#0 ← (byte)(signed byte) mulf8s_prepared::b#4 -- vbuz1=vbuz2 
    lda b
    sta mulf8u_prepared.b
    // [93] call mulf8u_prepared 
    jsr mulf8u_prepared
    // [94] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0 -- vwuz1=vwuz2 
    lda mulf8u_prepared.return
    sta mulf8u_prepared.return_2
    lda mulf8u_prepared.return+1
    sta mulf8u_prepared.return_2+1
    jmp b5
    // mulf8s_prepared::@5
  b5:
    // [95] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2 -- vwuz1=vwuz2 
    lda mulf8u_prepared.return_2
    sta m
    lda mulf8u_prepared.return_2+1
    sta m+1
    // [96] if(*((const signed byte*) mulf8s_prepared::memA#0)>=(signed byte) 0) goto mulf8s_prepared::@1 -- _deref_pbsc1_ge_0_then_la1 
    lda memA
    cmp #0
    bpl b1_from_b5
    jmp b3
    // mulf8s_prepared::@3
  b3:
    // [97] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0 -- vbuz1=_hi_vwuz2 
    lda m+1
    sta _8
    // [98] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#4 -- vbuz1=vbuz2_minus_vbuz3 
    lda _8
    sec
    sbc b
    sta _15
    // [99] (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#0 hi= (byte~) mulf8s_prepared::$15 -- vwuz1=vwuz1_sethi_vbuz2 
    lda _15
    sta m+1
    // [100] phi from mulf8s_prepared::@3 mulf8s_prepared::@5 to mulf8s_prepared::@1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1]
  b1_from_b3:
  b1_from_b5:
    // [100] phi (word) mulf8s_prepared::m#5 = (word) mulf8s_prepared::m#1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1#0] -- register_copy 
    jmp b1
    // mulf8s_prepared::@1
  b1:
    // [101] if((signed byte) mulf8s_prepared::b#4>=(signed byte) 0) goto mulf8s_prepared::@2 -- vbsz1_ge_0_then_la1 
    lda b
    cmp #0
    bpl b2_from_b1
    jmp b4
    // mulf8s_prepared::@4
  b4:
    // [102] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5 -- vbuz1=_hi_vwuz2 
    lda m+1
    sta _12
    // [103] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA#0) -- vbuz1=vbuz2_minus__deref_pbuc1 
    lda _12
    sec
    sbc memA
    sta _16
    // [104] (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16 -- vwuz1=vwuz1_sethi_vbuz2 
    lda _16
    sta m+1
    // [105] phi from mulf8s_prepared::@1 mulf8s_prepared::@4 to mulf8s_prepared::@2 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2]
  b2_from_b1:
  b2_from_b4:
    // [105] phi (word) mulf8s_prepared::m#4 = (word) mulf8s_prepared::m#5 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2#0] -- register_copy 
    jmp b2
    // mulf8s_prepared::@2
  b2:
    jmp breturn
    // mulf8s_prepared::@return
  breturn:
    // [106] return 
    rts
}
  // mulf8u_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8u_prepare(byte a)
// mulf8u_prepared(byte zeropage($56) b)
mulf8u_prepared: {
    .label resL = $fe
    .label memB = $ff
    .label return = $5d
    .label b = $56
    .label return_2 = $57
    // [107] *((const byte*) mulf8u_prepared::memB#0) ← (byte) mulf8u_prepared::b#0 -- _deref_pbuc1=vbuz1 
    lda b
    sta memB
    // asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
    ldx memB
    sec
  sm1:
    lda mulf_sqr1_lo,x
  sm2:
    sbc mulf_sqr2_lo,x
    sta resL
  sm3:
    lda mulf_sqr1_hi,x
  sm4:
    sbc mulf_sqr2_hi,x
    sta memB
    // [109] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB#0) w= *((const byte*) mulf8u_prepared::resL#0) -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda resL
    sta return
    lda memB
    sta return+1
    jmp breturn
    // mulf8u_prepared::@return
  breturn:
    // [110] return 
    rts
}
  // mulf8u_prepare
// Prepare for fast multiply with an unsigned byte to a word result
// mulf8u_prepare(byte zeropage($12) a)
mulf8u_prepare: {
    .label memA = $fd
    .label a = $12
    // [112] *((const byte*) mulf8u_prepare::memA#0) ← (byte) mulf8u_prepare::a#2 -- _deref_pbuc1=vbuz1 
    lda a
    sta memA
    // asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
    lda memA
    sta mulf8u_prepared.sm1+1
    sta mulf8u_prepared.sm3+1
    eor #$ff
    sta mulf8u_prepared.sm2+1
    sta mulf8u_prepared.sm4+1
    jmp breturn
    // mulf8u_prepare::@return
  breturn:
    // [114] return 
    rts
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [115] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #CIA_TIMER_CONTROL_CONTINUOUS
    sta CIA2_TIMER_A_CONTROL
    // [116] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [117] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [118] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [119] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2_TIMER_A_CONTROL
    jmp breturn
    // clock_start::@return
  breturn:
    // [120] return 
    rts
}
  // init
init: {
    .label sprites_ptr = SCREEN+$3f8
    .label i = $13
    // [122] call mulf_init 
    // [130] phi from init to mulf_init [phi:init->mulf_init]
  mulf_init_from_init:
    jsr mulf_init
    jmp b2
    // init::@2
  b2:
    // [123] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    lda #$ff
    sta SPRITES_ENABLE
    // [124] phi from init::@2 to init::@1 [phi:init::@2->init::@1]
  b1_from_b2:
    // [124] phi (byte) init::i#2 = (byte) 0 [phi:init::@2->init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b1
    // [124] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
    // [124] phi (byte) init::i#2 = (byte) init::i#1 [phi:init::@1->init::@1#0] -- register_copy 
    jmp b1
    // init::@1
  b1:
    // [125] *((const byte*) init::sprites_ptr#0 + (byte) init::i#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #SPRITE/$40
    ldy i
    sta sprites_ptr,y
    // [126] *((const byte*) SPRITES_COLS#0 + (byte) init::i#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy i
    sta SPRITES_COLS,y
    // [127] (byte) init::i#1 ← ++ (byte) init::i#2 -- vbuz1=_inc_vbuz1 
    inc i
    // [128] if((byte) init::i#1!=(byte) 8) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp i
    bne b1_from_b1
    jmp breturn
    // init::@return
  breturn:
    // [129] return 
    rts
}
  // mulf_init
// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/4)
mulf_init: {
    .label _7 = $5f
    .label _10 = $60
    .label _11 = $61
    .label c = $14
    .label sqr1_hi = $17
    .label sqr = $1a
    .label sqr1_lo = $15
    .label x_2 = $19
    .label sqr2_hi = $1f
    .label x_255 = $1c
    .label sqr2_lo = $1d
    .label dir = $21
    // [131] phi from mulf_init to mulf_init::@1 [phi:mulf_init->mulf_init::@1]
  b1_from_mulf_init:
    // [131] phi (byte) mulf_init::x_2#3 = (byte) 0 [phi:mulf_init->mulf_init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x_2
    // [131] phi (byte*) mulf_init::sqr1_hi#2 = (const byte[$200]) mulf_sqr1_hi#0+(byte) 1 [phi:mulf_init->mulf_init::@1#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_hi+1
    sta sqr1_hi
    lda #>mulf_sqr1_hi+1
    sta sqr1_hi+1
    // [131] phi (byte*) mulf_init::sqr1_lo#2 = (const byte[$200]) mulf_sqr1_lo#0+(byte) 1 [phi:mulf_init->mulf_init::@1#2] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_lo+1
    sta sqr1_lo
    lda #>mulf_sqr1_lo+1
    sta sqr1_lo+1
    // [131] phi (word) mulf_init::sqr#4 = (byte) 0 [phi:mulf_init->mulf_init::@1#3] -- vwuz1=vbuc1 
    lda #<0
    sta sqr
    lda #>0
    sta sqr+1
    // [131] phi (byte) mulf_init::c#2 = (byte) 0 [phi:mulf_init->mulf_init::@1#4] -- vbuz1=vbuc1 
    lda #0
    sta c
    jmp b1
    // [131] phi from mulf_init::@2 to mulf_init::@1 [phi:mulf_init::@2->mulf_init::@1]
  b1_from_b2:
    // [131] phi (byte) mulf_init::x_2#3 = (byte) mulf_init::x_2#2 [phi:mulf_init::@2->mulf_init::@1#0] -- register_copy 
    // [131] phi (byte*) mulf_init::sqr1_hi#2 = (byte*) mulf_init::sqr1_hi#1 [phi:mulf_init::@2->mulf_init::@1#1] -- register_copy 
    // [131] phi (byte*) mulf_init::sqr1_lo#2 = (byte*) mulf_init::sqr1_lo#1 [phi:mulf_init::@2->mulf_init::@1#2] -- register_copy 
    // [131] phi (word) mulf_init::sqr#4 = (word) mulf_init::sqr#1 [phi:mulf_init::@2->mulf_init::@1#3] -- register_copy 
    // [131] phi (byte) mulf_init::c#2 = (byte) mulf_init::c#1 [phi:mulf_init::@2->mulf_init::@1#4] -- register_copy 
    jmp b1
    // mulf_init::@1
  b1:
    // [132] (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2 -- vbuz1=_inc_vbuz1 
    inc c
    // [133] (byte~) mulf_init::$7 ← (byte) mulf_init::c#1 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and c
    sta _7
    // [134] if((byte~) mulf_init::$7!=(byte) 0) goto mulf_init::@2 -- vbuz1_neq_0_then_la1 
    lda _7
    cmp #0
    bne b2_from_b1
    jmp b3
    // mulf_init::@3
  b3:
    // [135] (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3 -- vbuz1=_inc_vbuz1 
    inc x_2
    // [136] (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4 -- vwuz1=_inc_vwuz1 
    inc sqr
    bne !+
    inc sqr+1
  !:
    // [137] phi from mulf_init::@1 mulf_init::@3 to mulf_init::@2 [phi:mulf_init::@1/mulf_init::@3->mulf_init::@2]
  b2_from_b1:
  b2_from_b3:
    // [137] phi (byte) mulf_init::x_2#2 = (byte) mulf_init::x_2#3 [phi:mulf_init::@1/mulf_init::@3->mulf_init::@2#0] -- register_copy 
    // [137] phi (word) mulf_init::sqr#3 = (word) mulf_init::sqr#4 [phi:mulf_init::@1/mulf_init::@3->mulf_init::@2#1] -- register_copy 
    jmp b2
    // mulf_init::@2
  b2:
    // [138] (byte~) mulf_init::$10 ← < (word) mulf_init::sqr#3 -- vbuz1=_lo_vwuz2 
    lda sqr
    sta _10
    // [139] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$10 -- _deref_pbuz1=vbuz2 
    lda _10
    ldy #0
    sta (sqr1_lo),y
    // [140] (byte~) mulf_init::$11 ← > (word) mulf_init::sqr#3 -- vbuz1=_hi_vwuz2 
    lda sqr+1
    sta _11
    // [141] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$11 -- _deref_pbuz1=vbuz2 
    lda _11
    ldy #0
    sta (sqr1_hi),y
    // [142] (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2 -- pbuz1=_inc_pbuz1 
    inc sqr1_hi
    bne !+
    inc sqr1_hi+1
  !:
    // [143] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 -- vwuz1=vwuz1_plus_vbuz2 
    lda x_2
    clc
    adc sqr
    sta sqr
    bcc !+
    inc sqr+1
  !:
    // [144] (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#2 -- pbuz1=_inc_pbuz1 
    inc sqr1_lo
    bne !+
    inc sqr1_lo+1
  !:
    // [145] if((byte*) mulf_init::sqr1_lo#1!=(const byte[$200]) mulf_sqr1_lo#0+(word) $200) goto mulf_init::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda sqr1_lo+1
    cmp #>mulf_sqr1_lo+$200
    bne b1_from_b2
    lda sqr1_lo
    cmp #<mulf_sqr1_lo+$200
    bne b1_from_b2
    // [146] phi from mulf_init::@2 to mulf_init::@4 [phi:mulf_init::@2->mulf_init::@4]
  b4_from_b2:
    // [146] phi (byte) mulf_init::dir#2 = (byte) $ff [phi:mulf_init::@2->mulf_init::@4#0] -- vbuz1=vbuc1 
    lda #$ff
    sta dir
    // [146] phi (byte*) mulf_init::sqr2_hi#2 = (const byte[$200]) mulf_sqr2_hi#0 [phi:mulf_init::@2->mulf_init::@4#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_hi
    sta sqr2_hi
    lda #>mulf_sqr2_hi
    sta sqr2_hi+1
    // [146] phi (byte*) mulf_init::sqr2_lo#2 = (const byte[$200]) mulf_sqr2_lo#0 [phi:mulf_init::@2->mulf_init::@4#2] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_lo
    sta sqr2_lo
    lda #>mulf_sqr2_lo
    sta sqr2_lo+1
    // [146] phi (byte) mulf_init::x_255#2 = (byte) -1 [phi:mulf_init::@2->mulf_init::@4#3] -- vbuz1=vbuc1 
    lda #-1
    sta x_255
    jmp b4
    // [146] phi from mulf_init::@5 to mulf_init::@4 [phi:mulf_init::@5->mulf_init::@4]
  b4_from_b5:
    // [146] phi (byte) mulf_init::dir#2 = (byte) mulf_init::dir#3 [phi:mulf_init::@5->mulf_init::@4#0] -- register_copy 
    // [146] phi (byte*) mulf_init::sqr2_hi#2 = (byte*) mulf_init::sqr2_hi#1 [phi:mulf_init::@5->mulf_init::@4#1] -- register_copy 
    // [146] phi (byte*) mulf_init::sqr2_lo#2 = (byte*) mulf_init::sqr2_lo#1 [phi:mulf_init::@5->mulf_init::@4#2] -- register_copy 
    // [146] phi (byte) mulf_init::x_255#2 = (byte) mulf_init::x_255#1 [phi:mulf_init::@5->mulf_init::@4#3] -- register_copy 
    jmp b4
    // mulf_init::@4
  b4:
    // [147] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte[$200]) mulf_sqr1_lo#0 + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy x_255
    lda mulf_sqr1_lo,y
    ldy #0
    sta (sqr2_lo),y
    // [148] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte[$200]) mulf_sqr1_hi#0 + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy x_255
    lda mulf_sqr1_hi,y
    ldy #0
    sta (sqr2_hi),y
    // [149] (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2 -- pbuz1=_inc_pbuz1 
    inc sqr2_hi
    bne !+
    inc sqr2_hi+1
  !:
    // [150] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 -- vbuz1=vbuz1_plus_vbuz2 
    lda x_255
    clc
    adc dir
    sta x_255
    // [151] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@7 -- vbuz1_neq_0_then_la1 
    lda x_255
    cmp #0
    bne b7_from_b4
    // [153] phi from mulf_init::@4 to mulf_init::@5 [phi:mulf_init::@4->mulf_init::@5]
  b5_from_b4:
    // [153] phi (byte) mulf_init::dir#3 = (byte) 1 [phi:mulf_init::@4->mulf_init::@5#0] -- vbuz1=vbuc1 
    lda #1
    sta dir
    jmp b5
    // [152] phi from mulf_init::@4 to mulf_init::@7 [phi:mulf_init::@4->mulf_init::@7]
  b7_from_b4:
    jmp b7
    // mulf_init::@7
  b7:
    // [153] phi from mulf_init::@7 to mulf_init::@5 [phi:mulf_init::@7->mulf_init::@5]
  b5_from_b7:
    // [153] phi (byte) mulf_init::dir#3 = (byte) mulf_init::dir#2 [phi:mulf_init::@7->mulf_init::@5#0] -- register_copy 
    jmp b5
    // mulf_init::@5
  b5:
    // [154] (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#2 -- pbuz1=_inc_pbuz1 
    inc sqr2_lo
    bne !+
    inc sqr2_lo+1
  !:
    // [155] if((byte*) mulf_init::sqr2_lo#1!=(const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) goto mulf_init::@4 -- pbuz1_neq_pbuc1_then_la1 
    lda sqr2_lo+1
    cmp #>mulf_sqr2_lo+$1ff
    bne b4_from_b5
    lda sqr2_lo
    cmp #<mulf_sqr2_lo+$1ff
    bne b4_from_b5
    jmp b6
    // mulf_init::@6
  b6:
    // [156] *((const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_lo#0+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    // Set the very last value g(511) = f(256)
    lda mulf_sqr1_lo+$100
    sta mulf_sqr2_lo+$1ff
    // [157] *((const byte[$200]) mulf_sqr2_hi#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_hi#0+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    lda mulf_sqr1_hi+$100
    sta mulf_sqr2_hi+$1ff
    jmp breturn
    // mulf_init::@return
  breturn:
    // [158] return 
    rts
}
  // File Data
  // mulf_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
  // <f(x) = <(( x * x )/4)
  .align $100
  mulf_sqr1_lo: .fill $200, 0
  // >f(x) = >(( x * x )/4)
  .align $100
  mulf_sqr1_hi: .fill $200, 0
  // <g(x) =  <((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_lo: .fill $200, 0
  // >g(x) = >((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_hi: .fill $200, 0
  print_hextab: .text "0123456789abcdef"
  // Sine and Cosine tables  
  // Angles: $00=0, $80=PI,$100=2*PI
  // Sine/Cosine: signed fixed [-$7f,$7f]
  .align $40
SIN:
.for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))

  // Positions to rotate
  xs: .byte -$46, -$46, -$46, 0, 0, $46, $46, $46
  ys: .byte -$46, 0, $46, -$46, $46, -$46, 0, $46
.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


REGISTER UPLIFT POTENTIAL REGISTERS
Equivalence Class zp ZP_BYTE:60 [ anim::$23 ] has ALU potential.
Statement [11] if(*((const byte*) RASTER#0)!=(byte) $ff) goto anim::@2 [ anim::angle#9 ] ( main:2::anim:7 [ anim::angle#9 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ]
Statement [21] (signed word~) anim::$5 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::$5 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::$5 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ anim::i#10 anim::i#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:34 [ anim::x#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:35 [ anim::y#0 ]
Statement [22] (signed word) anim::xr#0 ← (signed word~) anim::$5 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 ] ) always clobbers reg byte a 
Statement [25] (signed word~) anim::$7 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::$7 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::$7 ] ) always clobbers reg byte a 
Statement [26] (signed word) anim::yr#0 ← (signed word~) anim::$7 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 ] ) always clobbers reg byte a 
Statement [31] (signed word~) anim::$10 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$10 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$10 ] ) always clobbers reg byte a 
Statement [32] (signed word~) anim::$11 ← (signed word~) anim::$10 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$11 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$11 ] ) always clobbers reg byte a 
Statement [33] (signed word) anim::xr#1 ← (signed word) anim::xr#0 - (signed word~) anim::$11 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::yr#0 anim::xr#1 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::yr#0 anim::xr#1 ] ) always clobbers reg byte a 
Statement [36] (signed word~) anim::$12 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$12 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$12 ] ) always clobbers reg byte a 
Statement [37] (signed word~) anim::$13 ← (signed word~) anim::$12 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$13 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$13 ] ) always clobbers reg byte a 
Statement [38] (signed word) anim::yr#1 ← (signed word) anim::yr#0 + (signed word~) anim::$13 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::xr#1 anim::yr#1 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::xr#1 anim::yr#1 ] ) always clobbers reg byte a 
Statement [39] (byte~) anim::$16 ← > (signed word) anim::xr#1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::$16 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::$16 ] ) always clobbers reg byte a 
Statement [40] (signed word) anim::xpos#0 ← (signed byte)(byte~) anim::$16 + (signed byte) $18+(signed word) $95 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::xpos#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::xpos#0 ] ) always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ]
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:3 [ anim::i#10 anim::i#1 ]
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ]
Statement [42] (byte~) anim::$19 ← > (signed word) anim::xpos#0 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#1 anim::$19 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#1 anim::$19 ] ) always clobbers reg byte a 
Statement [44] (byte) anim::sprite_msb#2 ← (byte) anim::sprite_msb#1 | (byte) $80 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#2 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#2 ] ) always clobbers reg byte a 
Statement [48] (byte) anim::i2#0 ← (byte) anim::i#10 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::xpos#0 anim::ypos#0 anim::i2#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::xpos#0 anim::ypos#0 anim::i2#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:61 [ anim::ypos#0 ]
Statement [49] (byte~) anim::$26 ← < (signed word) anim::xpos#0 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::ypos#0 anim::i2#0 anim::$26 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::ypos#0 anim::i2#0 anim::$26 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:62 [ anim::i2#0 ]
Statement [51] *((const byte*) SPRITES_YPOS#0 + (byte) anim::i2#0) ← (byte) anim::ypos#0 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 ] ) always clobbers reg byte a 
Statement [57] (dword) clock::return#2 ← (dword) clock::return#0 [ anim::angle#1 clock::return#2 ] ( main:2::anim:7 [ anim::angle#1 clock::return#2 ] ) always clobbers reg byte a 
Statement [58] (dword~) anim::$28 ← (dword) clock::return#2 [ anim::angle#1 anim::$28 ] ( main:2::anim:7 [ anim::angle#1 anim::$28 ] ) always clobbers reg byte a 
Statement [59] (dword) anim::cyclecount#0 ← (dword~) anim::$28 - (const dword) CLOCKS_PER_INIT#0 [ anim::angle#1 anim::cyclecount#0 ] ( main:2::anim:7 [ anim::angle#1 anim::cyclecount#0 ] ) always clobbers reg byte a 
Statement [60] (dword) print_dword_at::dw#0 ← (dword) anim::cyclecount#0 [ anim::angle#1 print_dword_at::dw#0 ] ( main:2::anim:7 [ anim::angle#1 print_dword_at::dw#0 ] ) always clobbers reg byte a 
Statement [62] *((const byte*) BORDERCOL#0) ← (const byte) LIGHT_BLUE#0 [ anim::angle#1 ] ( main:2::anim:7 [ anim::angle#1 ] ) always clobbers reg byte a 
Statement [63] (word) print_word_at::w#0 ← > (dword) print_dword_at::dw#0 [ print_dword_at::dw#0 print_word_at::w#0 ] ( main:2::anim:7::print_dword_at:61 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#0 ] ) always clobbers reg byte a 
Statement [65] (word) print_word_at::w#1 ← < (dword) print_dword_at::dw#0 [ print_word_at::w#1 ] ( main:2::anim:7::print_dword_at:61 [ anim::angle#1 print_word_at::w#1 ] ) always clobbers reg byte a 
Statement [69] (byte) print_byte_at::b#0 ← > (word) print_word_at::w#2 [ print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 ] ) always clobbers reg byte a 
Statement [70] (byte*) print_byte_at::at#0 ← (byte*) print_word_at::at#2 [ print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 print_byte_at::at#0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 print_byte_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 print_byte_at::at#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ]
Statement [72] (byte) print_byte_at::b#1 ← < (word) print_word_at::w#2 [ print_word_at::at#2 print_byte_at::b#1 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_word_at::at#2 print_byte_at::b#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_word_at::at#2 print_byte_at::b#1 ] ) always clobbers reg byte a 
Statement [73] (byte*) print_byte_at::at#1 ← (byte*) print_word_at::at#2 + (byte) 2 [ print_byte_at::b#1 print_byte_at::at#1 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#1 print_byte_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_byte_at::b#1 print_byte_at::at#1 ] ) always clobbers reg byte a 
Statement [77] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#2 >> (byte) 4 [ print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] ) always clobbers reg byte a 
Statement [79] (byte*) print_char_at::at#0 ← (byte*) print_byte_at::at#2 [ print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:12 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
Statement [81] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (byte) $f [ print_byte_at::at#2 print_byte_at::$2 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::at#2 print_byte_at::$2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::at#2 print_byte_at::$2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::at#2 print_byte_at::$2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::at#2 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement [82] (byte*) print_char_at::at#1 ← (byte*) print_byte_at::at#2 + (byte) 1 [ print_byte_at::$2 print_char_at::at#1 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::$2 print_char_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::$2 print_char_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::$2 print_char_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::$2 print_char_at::at#1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:81 [ print_byte_at::$2 ]
Statement [87] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 [ ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71::print_char_at:80 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71::print_char_at:80 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74::print_char_at:80 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74::print_char_at:80 [ anim::angle#1 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71::print_char_at:84 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71::print_char_at:84 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74::print_char_at:84 [ anim::angle#1 print_dword_at::dw#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74::print_char_at:84 [ anim::angle#1 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:9 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ]
Statement [89] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) [ clock::return#0 ] ( main:2::anim:7::clock:56 [ anim::angle#1 clock::return#0 ] ) always clobbers reg byte a 
Statement [94] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0 [ mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:15 [ mulf8s_prepared::b#4 mulf8s_prepared::b#0 mulf8s_prepared::b#2 mulf8s_prepared::b#1 mulf8s_prepared::b#3 ]
Statement [95] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ) always clobbers reg byte a 
Statement [96] if(*((const signed byte*) mulf8s_prepared::memA#0)>=(signed byte) 0) goto mulf8s_prepared::@1 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ) always clobbers reg byte a 
Statement [97] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] ) always clobbers reg byte a 
Statement [98] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#4 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] ) always clobbers reg byte a 
Statement [102] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5 [ mulf8s_prepared::m#5 mulf8s_prepared::$12 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] ) always clobbers reg byte a 
Statement [103] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA#0) [ mulf8s_prepared::m#5 mulf8s_prepared::$16 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] ) always clobbers reg byte a 
Statement asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  } always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:34 [ anim::x#0 ]
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:35 [ anim::y#0 ]
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:15 [ mulf8s_prepared::b#4 mulf8s_prepared::b#0 mulf8s_prepared::b#2 mulf8s_prepared::b#1 mulf8s_prepared::b#3 ]
Statement [109] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB#0) w= *((const byte*) mulf8u_prepared::resL#0) [ mulf8u_prepared::return#0 ] ( main:2::anim:7::mulf8s_prepared:20::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] main:2::anim:7::mulf8s_prepared:24::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] main:2::anim:7::mulf8s_prepared:30::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] main:2::anim:7::mulf8s_prepared:35::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] ) always clobbers reg byte a 
Statement asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  } always clobbers reg byte a 
Statement [115] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [116] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [117] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [118] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [119] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [123] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [125] *((const byte*) init::sprites_ptr#0 + (byte) init::i#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:19 [ init::i#2 init::i#1 ]
Statement [126] *((const byte*) SPRITES_COLS#0 + (byte) init::i#2) ← (const byte) GREEN#0 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] ) always clobbers reg byte a 
Statement [138] (byte~) mulf_init::$10 ← < (word) mulf_init::sqr#3 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$10 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$10 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:20 [ mulf_init::c#2 mulf_init::c#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:25 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Statement [139] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$10 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:20 [ mulf_init::c#2 mulf_init::c#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:25 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Statement [140] (byte~) mulf_init::$11 ← > (word) mulf_init::sqr#3 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$11 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$11 ] ) always clobbers reg byte a 
Statement [141] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$11 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ) always clobbers reg byte y 
Statement [143] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ) always clobbers reg byte a 
Statement [145] if((byte*) mulf_init::sqr1_lo#1!=(const byte[$200]) mulf_sqr1_lo#0+(word) $200) goto mulf_init::@1 [ mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_lo#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_lo#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ) always clobbers reg byte a 
Statement [147] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte[$200]) mulf_sqr1_lo#0 + (byte) mulf_init::x_255#2) [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:28 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:28 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:33 [ mulf_init::dir#2 mulf_init::dir#3 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:33 [ mulf_init::dir#2 mulf_init::dir#3 ]
Statement [148] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte[$200]) mulf_sqr1_hi#0 + (byte) mulf_init::x_255#2) [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ) always clobbers reg byte a reg byte y 
Statement [150] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ) always clobbers reg byte a 
Statement [155] if((byte*) mulf_init::sqr2_lo#1!=(const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) goto mulf_init::@4 [ mulf_init::x_255#1 mulf_init::sqr2_lo#1 mulf_init::sqr2_hi#1 mulf_init::dir#3 ] ( main:2::init:5::mulf_init:122 [ mulf_init::x_255#1 mulf_init::sqr2_lo#1 mulf_init::sqr2_hi#1 mulf_init::dir#3 ] ) always clobbers reg byte a 
Statement [156] *((const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_lo#0+(word) $100) [ ] ( main:2::init:5::mulf_init:122 [ ] ) always clobbers reg byte a 
Statement [157] *((const byte[$200]) mulf_sqr2_hi#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_hi#0+(word) $100) [ ] ( main:2::init:5::mulf_init:122 [ ] ) always clobbers reg byte a 
Statement [11] if(*((const byte*) RASTER#0)!=(byte) $ff) goto anim::@2 [ anim::angle#9 ] ( main:2::anim:7 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [17] (byte~) mulf8u_prepare::a#3 ← (byte)(signed byte)*((const byte*) COS#0 + (byte) anim::angle#9) [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8u_prepare::a#3 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8u_prepare::a#3 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:3 [ anim::i#10 anim::i#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:34 [ anim::x#0 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:35 [ anim::y#0 ]
Statement [21] (signed word~) anim::$5 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::$5 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::$5 ] ) always clobbers reg byte a 
Statement [22] (signed word) anim::xr#0 ← (signed word~) anim::$5 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 ] ) always clobbers reg byte a 
Statement [25] (signed word~) anim::$7 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::$7 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::$7 ] ) always clobbers reg byte a 
Statement [26] (signed word) anim::yr#0 ← (signed word~) anim::$7 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 ] ) always clobbers reg byte a 
Statement [27] (byte~) mulf8u_prepare::a#4 ← (byte)(signed byte)*((const byte[$140]) SIN#0 + (byte) anim::angle#9) [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 mulf8u_prepare::a#4 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 mulf8u_prepare::a#4 ] ) always clobbers reg byte y 
Statement [31] (signed word~) anim::$10 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$10 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$10 ] ) always clobbers reg byte a 
Statement [32] (signed word~) anim::$11 ← (signed word~) anim::$10 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$11 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$11 ] ) always clobbers reg byte a 
Statement [33] (signed word) anim::xr#1 ← (signed word) anim::xr#0 - (signed word~) anim::$11 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::yr#0 anim::xr#1 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::yr#0 anim::xr#1 ] ) always clobbers reg byte a 
Statement [36] (signed word~) anim::$12 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$12 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$12 ] ) always clobbers reg byte a 
Statement [37] (signed word~) anim::$13 ← (signed word~) anim::$12 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$13 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$13 ] ) always clobbers reg byte a 
Statement [38] (signed word) anim::yr#1 ← (signed word) anim::yr#0 + (signed word~) anim::$13 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::xr#1 anim::yr#1 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::xr#1 anim::yr#1 ] ) always clobbers reg byte a 
Statement [39] (byte~) anim::$16 ← > (signed word) anim::xr#1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::$16 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::$16 ] ) always clobbers reg byte a 
Statement [40] (signed word) anim::xpos#0 ← (signed byte)(byte~) anim::$16 + (signed byte) $18+(signed word) $95 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::xpos#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::xpos#0 ] ) always clobbers reg byte a reg byte x 
Statement [42] (byte~) anim::$19 ← > (signed word) anim::xpos#0 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#1 anim::$19 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#1 anim::$19 ] ) always clobbers reg byte a 
Statement [44] (byte) anim::sprite_msb#2 ← (byte) anim::sprite_msb#1 | (byte) $80 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#2 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#2 ] ) always clobbers reg byte a 
Statement [48] (byte) anim::i2#0 ← (byte) anim::i#10 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::xpos#0 anim::ypos#0 anim::i2#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::xpos#0 anim::ypos#0 anim::i2#0 ] ) always clobbers reg byte a 
Statement [49] (byte~) anim::$26 ← < (signed word) anim::xpos#0 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::ypos#0 anim::i2#0 anim::$26 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::ypos#0 anim::i2#0 anim::$26 ] ) always clobbers reg byte a 
Statement [51] *((const byte*) SPRITES_YPOS#0 + (byte) anim::i2#0) ← (byte) anim::ypos#0 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 ] ) always clobbers reg byte a 
Statement [53] if((byte) anim::i#1!=(byte) 8) goto anim::@4 [ anim::angle#9 anim::i#1 anim::sprite_msb#5 ] ( main:2::anim:7 [ anim::angle#9 anim::i#1 anim::sprite_msb#5 ] ) always clobbers reg byte a 
Statement [54] *((const byte*) SPRITES_XMSB#0) ← (byte) anim::sprite_msb#5 [ anim::angle#9 ] ( main:2::anim:7 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [57] (dword) clock::return#2 ← (dword) clock::return#0 [ anim::angle#1 clock::return#2 ] ( main:2::anim:7 [ anim::angle#1 clock::return#2 ] ) always clobbers reg byte a 
Statement [58] (dword~) anim::$28 ← (dword) clock::return#2 [ anim::angle#1 anim::$28 ] ( main:2::anim:7 [ anim::angle#1 anim::$28 ] ) always clobbers reg byte a 
Statement [59] (dword) anim::cyclecount#0 ← (dword~) anim::$28 - (const dword) CLOCKS_PER_INIT#0 [ anim::angle#1 anim::cyclecount#0 ] ( main:2::anim:7 [ anim::angle#1 anim::cyclecount#0 ] ) always clobbers reg byte a 
Statement [60] (dword) print_dword_at::dw#0 ← (dword) anim::cyclecount#0 [ anim::angle#1 print_dword_at::dw#0 ] ( main:2::anim:7 [ anim::angle#1 print_dword_at::dw#0 ] ) always clobbers reg byte a 
Statement [62] *((const byte*) BORDERCOL#0) ← (const byte) LIGHT_BLUE#0 [ anim::angle#1 ] ( main:2::anim:7 [ anim::angle#1 ] ) always clobbers reg byte a 
Statement [63] (word) print_word_at::w#0 ← > (dword) print_dword_at::dw#0 [ print_dword_at::dw#0 print_word_at::w#0 ] ( main:2::anim:7::print_dword_at:61 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#0 ] ) always clobbers reg byte a 
Statement [65] (word) print_word_at::w#1 ← < (dword) print_dword_at::dw#0 [ print_word_at::w#1 ] ( main:2::anim:7::print_dword_at:61 [ anim::angle#1 print_word_at::w#1 ] ) always clobbers reg byte a 
Statement [69] (byte) print_byte_at::b#0 ← > (word) print_word_at::w#2 [ print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 ] ) always clobbers reg byte a 
Statement [70] (byte*) print_byte_at::at#0 ← (byte*) print_word_at::at#2 [ print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 print_byte_at::at#0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 print_byte_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 print_byte_at::at#0 ] ) always clobbers reg byte a 
Statement [72] (byte) print_byte_at::b#1 ← < (word) print_word_at::w#2 [ print_word_at::at#2 print_byte_at::b#1 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_word_at::at#2 print_byte_at::b#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_word_at::at#2 print_byte_at::b#1 ] ) always clobbers reg byte a 
Statement [73] (byte*) print_byte_at::at#1 ← (byte*) print_word_at::at#2 + (byte) 2 [ print_byte_at::b#1 print_byte_at::at#1 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#1 print_byte_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_byte_at::b#1 print_byte_at::at#1 ] ) always clobbers reg byte a 
Statement [77] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#2 >> (byte) 4 [ print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] ) always clobbers reg byte a 
Statement [79] (byte*) print_char_at::at#0 ← (byte*) print_byte_at::at#2 [ print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ) always clobbers reg byte a 
Statement [81] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (byte) $f [ print_byte_at::at#2 print_byte_at::$2 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::at#2 print_byte_at::$2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::at#2 print_byte_at::$2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::at#2 print_byte_at::$2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::at#2 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement [82] (byte*) print_char_at::at#1 ← (byte*) print_byte_at::at#2 + (byte) 1 [ print_byte_at::$2 print_char_at::at#1 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::$2 print_char_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::$2 print_char_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::$2 print_char_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::$2 print_char_at::at#1 ] ) always clobbers reg byte a 
Statement [87] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 [ ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71::print_char_at:80 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71::print_char_at:80 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74::print_char_at:80 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74::print_char_at:80 [ anim::angle#1 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71::print_char_at:84 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71::print_char_at:84 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74::print_char_at:84 [ anim::angle#1 print_dword_at::dw#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74::print_char_at:84 [ anim::angle#1 ] ) always clobbers reg byte a reg byte y 
Statement [89] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) [ clock::return#0 ] ( main:2::anim:7::clock:56 [ anim::angle#1 clock::return#0 ] ) always clobbers reg byte a 
Statement [94] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0 [ mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] ) always clobbers reg byte a 
Statement [95] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ) always clobbers reg byte a 
Statement [96] if(*((const signed byte*) mulf8s_prepared::memA#0)>=(signed byte) 0) goto mulf8s_prepared::@1 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ) always clobbers reg byte a 
Statement [97] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] ) always clobbers reg byte a 
Statement [98] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#4 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] ) always clobbers reg byte a 
Statement [102] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5 [ mulf8s_prepared::m#5 mulf8s_prepared::$12 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] ) always clobbers reg byte a 
Statement [103] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA#0) [ mulf8s_prepared::m#5 mulf8s_prepared::$16 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] ) always clobbers reg byte a 
Statement asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  } always clobbers reg byte a reg byte x 
Statement [109] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB#0) w= *((const byte*) mulf8u_prepared::resL#0) [ mulf8u_prepared::return#0 ] ( main:2::anim:7::mulf8s_prepared:20::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] main:2::anim:7::mulf8s_prepared:24::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] main:2::anim:7::mulf8s_prepared:30::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] main:2::anim:7::mulf8s_prepared:35::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] ) always clobbers reg byte a 
Statement asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  } always clobbers reg byte a 
Statement [115] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [116] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [117] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [118] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [119] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [123] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [125] *((const byte*) init::sprites_ptr#0 + (byte) init::i#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] ) always clobbers reg byte a 
Statement [126] *((const byte*) SPRITES_COLS#0 + (byte) init::i#2) ← (const byte) GREEN#0 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] ) always clobbers reg byte a 
Statement [133] (byte~) mulf_init::$7 ← (byte) mulf_init::c#1 & (byte) 1 [ mulf_init::sqr#4 mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$7 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr#4 mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$7 ] ) always clobbers reg byte a 
Statement [138] (byte~) mulf_init::$10 ← < (word) mulf_init::sqr#3 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$10 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$10 ] ) always clobbers reg byte a 
Statement [139] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$10 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ) always clobbers reg byte y 
Statement [140] (byte~) mulf_init::$11 ← > (word) mulf_init::sqr#3 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$11 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$11 ] ) always clobbers reg byte a 
Statement [141] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$11 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ) always clobbers reg byte y 
Statement [143] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ) always clobbers reg byte a 
Statement [145] if((byte*) mulf_init::sqr1_lo#1!=(const byte[$200]) mulf_sqr1_lo#0+(word) $200) goto mulf_init::@1 [ mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_lo#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_lo#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ) always clobbers reg byte a 
Statement [147] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte[$200]) mulf_sqr1_lo#0 + (byte) mulf_init::x_255#2) [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ) always clobbers reg byte a reg byte y 
Statement [148] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte[$200]) mulf_sqr1_hi#0 + (byte) mulf_init::x_255#2) [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ) always clobbers reg byte a reg byte y 
Statement [150] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ) always clobbers reg byte a 
Statement [155] if((byte*) mulf_init::sqr2_lo#1!=(const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) goto mulf_init::@4 [ mulf_init::x_255#1 mulf_init::sqr2_lo#1 mulf_init::sqr2_hi#1 mulf_init::dir#3 ] ( main:2::init:5::mulf_init:122 [ mulf_init::x_255#1 mulf_init::sqr2_lo#1 mulf_init::sqr2_hi#1 mulf_init::dir#3 ] ) always clobbers reg byte a 
Statement [156] *((const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_lo#0+(word) $100) [ ] ( main:2::init:5::mulf_init:122 [ ] ) always clobbers reg byte a 
Statement [157] *((const byte[$200]) mulf_sqr2_hi#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_hi#0+(word) $100) [ ] ( main:2::init:5::mulf_init:122 [ ] ) always clobbers reg byte a 
Statement [11] if(*((const byte*) RASTER#0)!=(byte) $ff) goto anim::@2 [ anim::angle#9 ] ( main:2::anim:7 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [15] (signed byte) anim::x#0 ← *((const signed byte[8]) xs#0 + (byte) anim::i#10) [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 ] ) always clobbers reg byte a reg byte y 
Statement [16] (signed byte) anim::y#0 ← *((const signed byte[8]) ys#0 + (byte) anim::i#10) [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 ] ) always clobbers reg byte a reg byte y 
Statement [17] (byte~) mulf8u_prepare::a#3 ← (byte)(signed byte)*((const byte*) COS#0 + (byte) anim::angle#9) [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8u_prepare::a#3 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8u_prepare::a#3 ] ) always clobbers reg byte y 
Statement [21] (signed word~) anim::$5 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::$5 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::$5 ] ) always clobbers reg byte a 
Statement [22] (signed word) anim::xr#0 ← (signed word~) anim::$5 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 ] ) always clobbers reg byte a 
Statement [25] (signed word~) anim::$7 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::$7 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::$7 ] ) always clobbers reg byte a 
Statement [26] (signed word) anim::yr#0 ← (signed word~) anim::$7 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 ] ) always clobbers reg byte a 
Statement [27] (byte~) mulf8u_prepare::a#4 ← (byte)(signed byte)*((const byte[$140]) SIN#0 + (byte) anim::angle#9) [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 mulf8u_prepare::a#4 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 anim::yr#0 mulf8u_prepare::a#4 ] ) always clobbers reg byte y 
Statement [31] (signed word~) anim::$10 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$10 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$10 ] ) always clobbers reg byte a 
Statement [32] (signed word~) anim::$11 ← (signed word~) anim::$10 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$11 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 anim::$11 ] ) always clobbers reg byte a 
Statement [33] (signed word) anim::xr#1 ← (signed word) anim::xr#0 - (signed word~) anim::$11 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::yr#0 anim::xr#1 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::yr#0 anim::xr#1 ] ) always clobbers reg byte a 
Statement [36] (signed word~) anim::$12 ← (signed word)(word) mulf8s_prepared::m#4 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$12 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$12 ] ) always clobbers reg byte a 
Statement [37] (signed word~) anim::$13 ← (signed word~) anim::$12 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$13 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 anim::$13 ] ) always clobbers reg byte a 
Statement [38] (signed word) anim::yr#1 ← (signed word) anim::yr#0 + (signed word~) anim::$13 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::xr#1 anim::yr#1 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::xr#1 anim::yr#1 ] ) always clobbers reg byte a 
Statement [39] (byte~) anim::$16 ← > (signed word) anim::xr#1 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::$16 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::$16 ] ) always clobbers reg byte a 
Statement [40] (signed word) anim::xpos#0 ← (signed byte)(byte~) anim::$16 + (signed byte) $18+(signed word) $95 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::xpos#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#1 anim::xpos#0 ] ) always clobbers reg byte a reg byte x 
Statement [42] (byte~) anim::$19 ← > (signed word) anim::xpos#0 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#1 anim::$19 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#1 anim::$19 ] ) always clobbers reg byte a 
Statement [44] (byte) anim::sprite_msb#2 ← (byte) anim::sprite_msb#1 | (byte) $80 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#2 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::yr#1 anim::xpos#0 anim::sprite_msb#2 ] ) always clobbers reg byte a 
Statement [48] (byte) anim::i2#0 ← (byte) anim::i#10 << (byte) 1 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::xpos#0 anim::ypos#0 anim::i2#0 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::xpos#0 anim::ypos#0 anim::i2#0 ] ) always clobbers reg byte a 
Statement [49] (byte~) anim::$26 ← < (signed word) anim::xpos#0 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::ypos#0 anim::i2#0 anim::$26 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 anim::ypos#0 anim::i2#0 anim::$26 ] ) always clobbers reg byte a 
Statement [51] *((const byte*) SPRITES_YPOS#0 + (byte) anim::i2#0) ← (byte) anim::ypos#0 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 ] ( main:2::anim:7 [ anim::angle#9 anim::i#10 anim::sprite_msb#5 ] ) always clobbers reg byte a 
Statement [53] if((byte) anim::i#1!=(byte) 8) goto anim::@4 [ anim::angle#9 anim::i#1 anim::sprite_msb#5 ] ( main:2::anim:7 [ anim::angle#9 anim::i#1 anim::sprite_msb#5 ] ) always clobbers reg byte a 
Statement [54] *((const byte*) SPRITES_XMSB#0) ← (byte) anim::sprite_msb#5 [ anim::angle#9 ] ( main:2::anim:7 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [57] (dword) clock::return#2 ← (dword) clock::return#0 [ anim::angle#1 clock::return#2 ] ( main:2::anim:7 [ anim::angle#1 clock::return#2 ] ) always clobbers reg byte a 
Statement [58] (dword~) anim::$28 ← (dword) clock::return#2 [ anim::angle#1 anim::$28 ] ( main:2::anim:7 [ anim::angle#1 anim::$28 ] ) always clobbers reg byte a 
Statement [59] (dword) anim::cyclecount#0 ← (dword~) anim::$28 - (const dword) CLOCKS_PER_INIT#0 [ anim::angle#1 anim::cyclecount#0 ] ( main:2::anim:7 [ anim::angle#1 anim::cyclecount#0 ] ) always clobbers reg byte a 
Statement [60] (dword) print_dword_at::dw#0 ← (dword) anim::cyclecount#0 [ anim::angle#1 print_dword_at::dw#0 ] ( main:2::anim:7 [ anim::angle#1 print_dword_at::dw#0 ] ) always clobbers reg byte a 
Statement [62] *((const byte*) BORDERCOL#0) ← (const byte) LIGHT_BLUE#0 [ anim::angle#1 ] ( main:2::anim:7 [ anim::angle#1 ] ) always clobbers reg byte a 
Statement [63] (word) print_word_at::w#0 ← > (dword) print_dword_at::dw#0 [ print_dword_at::dw#0 print_word_at::w#0 ] ( main:2::anim:7::print_dword_at:61 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#0 ] ) always clobbers reg byte a 
Statement [65] (word) print_word_at::w#1 ← < (dword) print_dword_at::dw#0 [ print_word_at::w#1 ] ( main:2::anim:7::print_dword_at:61 [ anim::angle#1 print_word_at::w#1 ] ) always clobbers reg byte a 
Statement [69] (byte) print_byte_at::b#0 ← > (word) print_word_at::w#2 [ print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 ] ) always clobbers reg byte a 
Statement [70] (byte*) print_byte_at::at#0 ← (byte*) print_word_at::at#2 [ print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 print_byte_at::at#0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 print_byte_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#0 print_byte_at::at#0 ] ) always clobbers reg byte a 
Statement [72] (byte) print_byte_at::b#1 ← < (word) print_word_at::w#2 [ print_word_at::at#2 print_byte_at::b#1 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_word_at::at#2 print_byte_at::b#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_word_at::at#2 print_byte_at::b#1 ] ) always clobbers reg byte a 
Statement [73] (byte*) print_byte_at::at#1 ← (byte*) print_word_at::at#2 + (byte) 2 [ print_byte_at::b#1 print_byte_at::at#1 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#1 print_byte_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66 [ anim::angle#1 print_byte_at::b#1 print_byte_at::at#1 ] ) always clobbers reg byte a 
Statement [77] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#2 >> (byte) 4 [ print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::b#2 print_byte_at::at#2 print_byte_at::$0 ] ) always clobbers reg byte a 
Statement [79] (byte*) print_char_at::at#0 ← (byte*) print_byte_at::at#2 [ print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::b#2 print_byte_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ) always clobbers reg byte a 
Statement [81] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (byte) $f [ print_byte_at::at#2 print_byte_at::$2 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::at#2 print_byte_at::$2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::at#2 print_byte_at::$2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::at#2 print_byte_at::$2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::at#2 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement [82] (byte*) print_char_at::at#1 ← (byte*) print_byte_at::at#2 + (byte) 1 [ print_byte_at::$2 print_char_at::at#1 ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::$2 print_char_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::$2 print_char_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::$2 print_char_at::at#1 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74 [ anim::angle#1 print_byte_at::$2 print_char_at::at#1 ] ) always clobbers reg byte a 
Statement [87] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 [ ] ( main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71::print_char_at:80 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71::print_char_at:80 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74::print_char_at:80 [ anim::angle#1 print_dword_at::dw#0 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74::print_char_at:80 [ anim::angle#1 print_byte_at::b#2 print_byte_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:71::print_char_at:84 [ anim::angle#1 print_dword_at::dw#0 print_word_at::w#2 print_word_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:71::print_char_at:84 [ anim::angle#1 print_word_at::w#2 print_word_at::at#2 ] main:2::anim:7::print_dword_at:61::print_word_at:64::print_byte_at:74::print_char_at:84 [ anim::angle#1 print_dword_at::dw#0 ] main:2::anim:7::print_dword_at:61::print_word_at:66::print_byte_at:74::print_char_at:84 [ anim::angle#1 ] ) always clobbers reg byte a reg byte y 
Statement [89] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) [ clock::return#0 ] ( main:2::anim:7::clock:56 [ anim::angle#1 clock::return#0 ] ) always clobbers reg byte a 
Statement [94] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0 [ mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8u_prepared::return#2 ] ) always clobbers reg byte a 
Statement [95] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ) always clobbers reg byte a 
Statement [96] if(*((const signed byte*) mulf8s_prepared::memA#0)>=(signed byte) 0) goto mulf8s_prepared::@1 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 ] ) always clobbers reg byte a 
Statement [97] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$8 ] ) always clobbers reg byte a 
Statement [98] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#4 [ mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] ) always clobbers reg byte a 
Statement [102] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5 [ mulf8s_prepared::m#5 mulf8s_prepared::$12 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] ) always clobbers reg byte a 
Statement [103] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA#0) [ mulf8s_prepared::m#5 mulf8s_prepared::$16 ] ( main:2::anim:7::mulf8s_prepared:20 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] main:2::anim:7::mulf8s_prepared:24 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] main:2::anim:7::mulf8s_prepared:30 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] main:2::anim:7::mulf8s_prepared:35 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] ) always clobbers reg byte a 
Statement asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  } always clobbers reg byte a reg byte x 
Statement [109] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB#0) w= *((const byte*) mulf8u_prepared::resL#0) [ mulf8u_prepared::return#0 ] ( main:2::anim:7::mulf8s_prepared:20::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] main:2::anim:7::mulf8s_prepared:24::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::y#0 anim::xr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] main:2::anim:7::mulf8s_prepared:30::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::x#0 anim::xr#0 anim::yr#0 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] main:2::anim:7::mulf8s_prepared:35::mulf8u_prepared:93 [ anim::angle#9 anim::i#10 anim::sprite_msb#10 anim::yr#0 anim::xr#1 mulf8s_prepared::b#4 mulf8u_prepared::return#0 ] ) always clobbers reg byte a 
Statement asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  } always clobbers reg byte a 
Statement [115] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [116] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [117] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [118] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [119] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 [ ] ( main:2::anim:7::clock_start:13 [ anim::angle#9 ] ) always clobbers reg byte a 
Statement [123] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [125] *((const byte*) init::sprites_ptr#0 + (byte) init::i#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] ) always clobbers reg byte a 
Statement [126] *((const byte*) SPRITES_COLS#0 + (byte) init::i#2) ← (const byte) GREEN#0 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] ) always clobbers reg byte a 
Statement [133] (byte~) mulf_init::$7 ← (byte) mulf_init::c#1 & (byte) 1 [ mulf_init::sqr#4 mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$7 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr#4 mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$7 ] ) always clobbers reg byte a 
Statement [138] (byte~) mulf_init::$10 ← < (word) mulf_init::sqr#3 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$10 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$10 ] ) always clobbers reg byte a 
Statement [139] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$10 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ) always clobbers reg byte y 
Statement [140] (byte~) mulf_init::$11 ← > (word) mulf_init::sqr#3 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$11 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 mulf_init::$11 ] ) always clobbers reg byte a 
Statement [141] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$11 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ) always clobbers reg byte y 
Statement [143] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ) always clobbers reg byte a 
Statement [145] if((byte*) mulf_init::sqr1_lo#1!=(const byte[$200]) mulf_sqr1_lo#0+(word) $200) goto mulf_init::@1 [ mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_lo#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_lo#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ) always clobbers reg byte a 
Statement [147] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte[$200]) mulf_sqr1_lo#0 + (byte) mulf_init::x_255#2) [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ) always clobbers reg byte a reg byte y 
Statement [148] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte[$200]) mulf_sqr1_hi#0 + (byte) mulf_init::x_255#2) [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:122 [ mulf_init::x_255#2 mulf_init::sqr2_lo#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ) always clobbers reg byte a reg byte y 
Statement [150] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ( main:2::init:5::mulf_init:122 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ) always clobbers reg byte a 
Statement [155] if((byte*) mulf_init::sqr2_lo#1!=(const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) goto mulf_init::@4 [ mulf_init::x_255#1 mulf_init::sqr2_lo#1 mulf_init::sqr2_hi#1 mulf_init::dir#3 ] ( main:2::init:5::mulf_init:122 [ mulf_init::x_255#1 mulf_init::sqr2_lo#1 mulf_init::sqr2_hi#1 mulf_init::dir#3 ] ) always clobbers reg byte a 
Statement [156] *((const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_lo#0+(word) $100) [ ] ( main:2::init:5::mulf_init:122 [ ] ) always clobbers reg byte a 
Statement [157] *((const byte[$200]) mulf_sqr2_hi#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_hi#0+(word) $100) [ ] ( main:2::init:5::mulf_init:122 [ ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ] : zp ZP_BYTE:2 , 
Potential registers zp ZP_BYTE:3 [ anim::i#10 anim::i#1 ] : zp ZP_BYTE:3 , 
Potential registers zp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ] : zp ZP_BYTE:4 , 
Potential registers zp ZP_WORD:5 [ print_word_at::w#2 print_word_at::w#0 print_word_at::w#1 ] : zp ZP_WORD:5 , 
Potential registers zp ZP_WORD:7 [ print_word_at::at#2 ] : zp ZP_WORD:7 , 
Potential registers zp ZP_BYTE:9 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ] : zp ZP_BYTE:9 , reg byte x , 
Potential registers zp ZP_WORD:10 [ print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ] : zp ZP_WORD:10 , 
Potential registers zp ZP_BYTE:12 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ] : zp ZP_BYTE:12 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:13 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] : zp ZP_WORD:13 , 
Potential registers zp ZP_BYTE:15 [ mulf8s_prepared::b#4 mulf8s_prepared::b#0 mulf8s_prepared::b#2 mulf8s_prepared::b#1 mulf8s_prepared::b#3 ] : zp ZP_BYTE:15 , reg byte y , 
Potential registers zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] : zp ZP_WORD:16 , 
Potential registers zp ZP_BYTE:18 [ mulf8u_prepare::a#2 mulf8u_prepare::a#3 mulf8u_prepare::a#4 ] : zp ZP_BYTE:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:19 [ init::i#2 init::i#1 ] : zp ZP_BYTE:19 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:20 [ mulf_init::c#2 mulf_init::c#1 ] : zp ZP_BYTE:20 , reg byte x , 
Potential registers zp ZP_WORD:21 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] : zp ZP_WORD:21 , 
Potential registers zp ZP_WORD:23 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] : zp ZP_WORD:23 , 
Potential registers zp ZP_BYTE:25 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] : zp ZP_BYTE:25 , reg byte x , 
Potential registers zp ZP_WORD:26 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] : zp ZP_WORD:26 , 
Potential registers zp ZP_BYTE:28 [ mulf_init::x_255#2 mulf_init::x_255#1 ] : zp ZP_BYTE:28 , reg byte x , 
Potential registers zp ZP_WORD:29 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] : zp ZP_WORD:29 , 
Potential registers zp ZP_WORD:31 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] : zp ZP_WORD:31 , 
Potential registers zp ZP_BYTE:33 [ mulf_init::dir#2 mulf_init::dir#3 ] : zp ZP_BYTE:33 , reg byte x , 
Potential registers zp ZP_BYTE:34 [ anim::x#0 ] : zp ZP_BYTE:34 , 
Potential registers zp ZP_BYTE:35 [ anim::y#0 ] : zp ZP_BYTE:35 , 
Potential registers zp ZP_WORD:36 [ anim::$5 ] : zp ZP_WORD:36 , 
Potential registers zp ZP_WORD:38 [ anim::xr#0 ] : zp ZP_WORD:38 , 
Potential registers zp ZP_WORD:40 [ anim::$7 ] : zp ZP_WORD:40 , 
Potential registers zp ZP_WORD:42 [ anim::yr#0 ] : zp ZP_WORD:42 , 
Potential registers zp ZP_WORD:44 [ anim::$10 ] : zp ZP_WORD:44 , 
Potential registers zp ZP_WORD:46 [ anim::$11 ] : zp ZP_WORD:46 , 
Potential registers zp ZP_WORD:48 [ anim::xr#1 ] : zp ZP_WORD:48 , 
Potential registers zp ZP_WORD:50 [ anim::$12 ] : zp ZP_WORD:50 , 
Potential registers zp ZP_WORD:52 [ anim::$13 ] : zp ZP_WORD:52 , 
Potential registers zp ZP_WORD:54 [ anim::yr#1 ] : zp ZP_WORD:54 , 
Potential registers zp ZP_BYTE:56 [ anim::$16 ] : zp ZP_BYTE:56 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:57 [ anim::xpos#0 ] : zp ZP_WORD:57 , 
Potential registers zp ZP_BYTE:59 [ anim::$19 ] : zp ZP_BYTE:59 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:60 [ anim::$23 ] : zp ZP_BYTE:60 , reg byte a , reg byte x , reg byte y , reg byte alu , 
Potential registers zp ZP_BYTE:61 [ anim::ypos#0 ] : zp ZP_BYTE:61 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:62 [ anim::i2#0 ] : zp ZP_BYTE:62 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:63 [ anim::$26 ] : zp ZP_BYTE:63 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_DWORD:64 [ clock::return#2 ] : zp ZP_DWORD:64 , 
Potential registers zp ZP_DWORD:68 [ anim::$28 ] : zp ZP_DWORD:68 , 
Potential registers zp ZP_DWORD:72 [ anim::cyclecount#0 ] : zp ZP_DWORD:72 , 
Potential registers zp ZP_DWORD:76 [ print_dword_at::dw#0 ] : zp ZP_DWORD:76 , 
Potential registers zp ZP_BYTE:80 [ print_byte_at::$0 ] : zp ZP_BYTE:80 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:81 [ print_byte_at::$2 ] : zp ZP_BYTE:81 , reg byte x , reg byte y , 
Potential registers zp ZP_DWORD:82 [ clock::return#0 ] : zp ZP_DWORD:82 , 
Potential registers zp ZP_BYTE:86 [ mulf8u_prepared::b#0 ] : zp ZP_BYTE:86 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:87 [ mulf8u_prepared::return#2 ] : zp ZP_WORD:87 , 
Potential registers zp ZP_BYTE:89 [ mulf8s_prepared::$8 ] : zp ZP_BYTE:89 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:90 [ mulf8s_prepared::$15 ] : zp ZP_BYTE:90 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:91 [ mulf8s_prepared::$12 ] : zp ZP_BYTE:91 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:92 [ mulf8s_prepared::$16 ] : zp ZP_BYTE:92 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:93 [ mulf8u_prepared::return#0 ] : zp ZP_WORD:93 , 
Potential registers zp ZP_BYTE:95 [ mulf_init::$7 ] : zp ZP_BYTE:95 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:96 [ mulf_init::$10 ] : zp ZP_BYTE:96 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:97 [ mulf_init::$11 ] : zp ZP_BYTE:97 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [anim] 345.37: zp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ] 202: zp ZP_WORD:36 [ anim::$5 ] 202: zp ZP_WORD:40 [ anim::$7 ] 202: zp ZP_WORD:44 [ anim::$10 ] 202: zp ZP_WORD:46 [ anim::$11 ] 202: zp ZP_WORD:50 [ anim::$12 ] 202: zp ZP_WORD:52 [ anim::$13 ] 202: zp ZP_BYTE:59 [ anim::$19 ] 202: zp ZP_BYTE:60 [ anim::$23 ] 202: zp ZP_BYTE:63 [ anim::$26 ] 164.79: zp ZP_BYTE:3 [ anim::i#10 anim::i#1 ] 101: zp ZP_BYTE:56 [ anim::$16 ] 101: zp ZP_BYTE:62 [ anim::i2#0 ] 50.5: zp ZP_BYTE:61 [ anim::ypos#0 ] 33.67: zp ZP_WORD:48 [ anim::xr#1 ] 33.67: zp ZP_WORD:57 [ anim::xpos#0 ] 25.25: zp ZP_WORD:54 [ anim::yr#1 ] 23.31: zp ZP_BYTE:35 [ anim::y#0 ] 22: zp ZP_DWORD:68 [ anim::$28 ] 22: zp ZP_DWORD:72 [ anim::cyclecount#0 ] 18.36: zp ZP_WORD:38 [ anim::xr#0 ] 16.83: zp ZP_WORD:42 [ anim::yr#0 ] 15.95: zp ZP_BYTE:34 [ anim::x#0 ] 3.24: zp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ] 
Uplift Scope [mulf8s_prepared] 848.6: zp ZP_BYTE:15 [ mulf8s_prepared::b#4 mulf8s_prepared::b#0 mulf8s_prepared::b#2 mulf8s_prepared::b#1 mulf8s_prepared::b#3 ] 13.17: zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] 4: zp ZP_BYTE:89 [ mulf8s_prepared::$8 ] 4: zp ZP_BYTE:90 [ mulf8s_prepared::$15 ] 4: zp ZP_BYTE:91 [ mulf8s_prepared::$12 ] 4: zp ZP_BYTE:92 [ mulf8s_prepared::$16 ] 
Uplift Scope [mulf8u_prepare] 608: zp ZP_BYTE:18 [ mulf8u_prepare::a#2 mulf8u_prepare::a#3 mulf8u_prepare::a#4 ] 
Uplift Scope [mulf_init] 45.1: zp ZP_WORD:26 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] 24.36: zp ZP_BYTE:20 [ mulf_init::c#2 mulf_init::c#1 ] 24.14: zp ZP_BYTE:25 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] 22: zp ZP_BYTE:95 [ mulf_init::$7 ] 22: zp ZP_BYTE:96 [ mulf_init::$10 ] 22: zp ZP_BYTE:97 [ mulf_init::$11 ] 20.62: zp ZP_WORD:29 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] 19.04: zp ZP_WORD:21 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] 16.5: zp ZP_BYTE:28 [ mulf_init::x_255#2 mulf_init::x_255#1 ] 14.14: zp ZP_WORD:31 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] 12.05: zp ZP_BYTE:33 [ mulf_init::dir#2 mulf_init::dir#3 ] 8.5: zp ZP_WORD:23 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] 
Uplift Scope [init] 31.17: zp ZP_BYTE:19 [ init::i#2 init::i#1 ] 
Uplift Scope [clock] 22: zp ZP_DWORD:64 [ clock::return#2 ] 4.33: zp ZP_DWORD:82 [ clock::return#0 ] 
Uplift Scope [print_char_at] 12: zp ZP_BYTE:12 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ] 12: zp ZP_WORD:13 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] 
Uplift Scope [print_byte_at] 9.33: zp ZP_WORD:10 [ print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ] 5.6: zp ZP_BYTE:9 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ] 4: zp ZP_BYTE:80 [ print_byte_at::$0 ] 2: zp ZP_BYTE:81 [ print_byte_at::$2 ] 
Uplift Scope [print_word_at] 10: zp ZP_WORD:5 [ print_word_at::w#2 print_word_at::w#0 print_word_at::w#1 ] 0.8: zp ZP_WORD:7 [ print_word_at::at#2 ] 
Uplift Scope [mulf8u_prepared] 4: zp ZP_BYTE:86 [ mulf8u_prepared::b#0 ] 4: zp ZP_WORD:87 [ mulf8u_prepared::return#2 ] 1.33: zp ZP_WORD:93 [ mulf8u_prepared::return#0 ] 
Uplift Scope [print_dword_at] 5: zp ZP_DWORD:76 [ print_dword_at::dw#0 ] 
Uplift Scope [clock_start] 
Uplift Scope [RADIX] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [anim] best 45223 combination zp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ] zp ZP_WORD:36 [ anim::$5 ] zp ZP_WORD:40 [ anim::$7 ] zp ZP_WORD:44 [ anim::$10 ] zp ZP_WORD:46 [ anim::$11 ] zp ZP_WORD:50 [ anim::$12 ] zp ZP_WORD:52 [ anim::$13 ] reg byte a [ anim::$19 ] reg byte a [ anim::$23 ] reg byte a [ anim::$26 ] zp ZP_BYTE:3 [ anim::i#10 anim::i#1 ] zp ZP_BYTE:56 [ anim::$16 ] zp ZP_BYTE:62 [ anim::i2#0 ] zp ZP_BYTE:61 [ anim::ypos#0 ] zp ZP_WORD:48 [ anim::xr#1 ] zp ZP_WORD:57 [ anim::xpos#0 ] zp ZP_WORD:54 [ anim::yr#1 ] zp ZP_BYTE:35 [ anim::y#0 ] zp ZP_DWORD:68 [ anim::$28 ] zp ZP_DWORD:72 [ anim::cyclecount#0 ] zp ZP_WORD:38 [ anim::xr#0 ] zp ZP_WORD:42 [ anim::yr#0 ] zp ZP_BYTE:34 [ anim::x#0 ] zp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ] 
Limited combination testing to 100 combinations of 2880 possible.
Uplifting [mulf8s_prepared] best 44002 combination reg byte y [ mulf8s_prepared::b#4 mulf8s_prepared::b#0 mulf8s_prepared::b#2 mulf8s_prepared::b#1 mulf8s_prepared::b#3 ] zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] reg byte a [ mulf8s_prepared::$8 ] reg byte a [ mulf8s_prepared::$15 ] reg byte a [ mulf8s_prepared::$12 ] zp ZP_BYTE:92 [ mulf8s_prepared::$16 ] 
Limited combination testing to 100 combinations of 512 possible.
Uplifting [mulf8u_prepare] best 43399 combination reg byte a [ mulf8u_prepare::a#2 mulf8u_prepare::a#3 mulf8u_prepare::a#4 ] 
Uplifting [mulf_init] best 43149 combination zp ZP_WORD:26 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] reg byte x [ mulf_init::c#2 mulf_init::c#1 ] zp ZP_BYTE:25 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] reg byte a [ mulf_init::$7 ] reg byte a [ mulf_init::$10 ] reg byte a [ mulf_init::$11 ] zp ZP_WORD:29 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] zp ZP_WORD:21 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] zp ZP_BYTE:28 [ mulf_init::x_255#2 mulf_init::x_255#1 ] zp ZP_WORD:31 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] zp ZP_BYTE:33 [ mulf_init::dir#2 mulf_init::dir#3 ] zp ZP_WORD:23 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] 
Limited combination testing to 100 combinations of 1024 possible.
Uplifting [init] best 42999 combination reg byte x [ init::i#2 init::i#1 ] 
Uplifting [clock] best 42999 combination zp ZP_DWORD:64 [ clock::return#2 ] zp ZP_DWORD:82 [ clock::return#0 ] 
Uplifting [print_char_at] best 42992 combination reg byte x [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ] zp ZP_WORD:13 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] 
Uplifting [print_byte_at] best 42984 combination zp ZP_WORD:10 [ print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ] zp ZP_BYTE:9 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ] reg byte a [ print_byte_at::$0 ] reg byte y [ print_byte_at::$2 ] 
Uplifting [print_word_at] best 42984 combination zp ZP_WORD:5 [ print_word_at::w#2 print_word_at::w#0 print_word_at::w#1 ] zp ZP_WORD:7 [ print_word_at::at#2 ] 
Uplifting [mulf8u_prepared] best 42980 combination reg byte a [ mulf8u_prepared::b#0 ] zp ZP_WORD:87 [ mulf8u_prepared::return#2 ] zp ZP_WORD:93 [ mulf8u_prepared::return#0 ] 
Uplifting [print_dword_at] best 42980 combination zp ZP_DWORD:76 [ print_dword_at::dw#0 ] 
Uplifting [clock_start] best 42980 combination 
Uplifting [RADIX] best 42980 combination 
Uplifting [main] best 42980 combination 
Uplifting [] best 42980 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ]
Uplifting [anim] best 42980 combination zp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ anim::i#10 anim::i#1 ]
Uplifting [anim] best 42980 combination zp ZP_BYTE:3 [ anim::i#10 anim::i#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:56 [ anim::$16 ]
Uplifting [anim] best 42380 combination reg byte a [ anim::$16 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:62 [ anim::i2#0 ]
Uplifting [anim] best 41680 combination reg byte x [ anim::i2#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:61 [ anim::ypos#0 ]
Uplifting [anim] best 41480 combination reg byte y [ anim::ypos#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:25 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Uplifting [mulf_init] best 41480 combination zp ZP_BYTE:25 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:35 [ anim::y#0 ]
Uplifting [anim] best 41480 combination zp ZP_BYTE:35 [ anim::y#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:28 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Uplifting [mulf_init] best 41340 combination reg byte x [ mulf_init::x_255#2 mulf_init::x_255#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:34 [ anim::x#0 ]
Uplifting [anim] best 41340 combination zp ZP_BYTE:34 [ anim::x#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:33 [ mulf_init::dir#2 mulf_init::dir#3 ]
Uplifting [mulf_init] best 41340 combination zp ZP_BYTE:33 [ mulf_init::dir#2 mulf_init::dir#3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:9 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ]
Uplifting [print_byte_at] best 41340 combination zp ZP_BYTE:9 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:92 [ mulf8s_prepared::$16 ]
Uplifting [mulf8s_prepared] best 41334 combination reg byte a [ mulf8s_prepared::$16 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ]
Uplifting [anim] best 41334 combination zp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ] 
Coalescing zero page register [ zp ZP_WORD:7 [ print_word_at::at#2 ] ] with [ zp ZP_WORD:10 [ print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ] ] - score: 2
Coalescing zero page register [ zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] ] with [ zp ZP_WORD:36 [ anim::$5 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 ] ] with [ zp ZP_WORD:40 [ anim::$7 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 anim::$7 ] ] with [ zp ZP_WORD:44 [ anim::$10 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 anim::$7 anim::$10 ] ] with [ zp ZP_WORD:50 [ anim::$12 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 anim::$7 anim::$10 anim::$12 ] ] with [ zp ZP_WORD:87 [ mulf8u_prepared::return#2 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:38 [ anim::xr#0 ] ] with [ zp ZP_WORD:48 [ anim::xr#1 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:42 [ anim::yr#0 ] ] with [ zp ZP_WORD:54 [ anim::yr#1 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:64 [ clock::return#2 ] ] with [ zp ZP_DWORD:68 [ anim::$28 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:64 [ clock::return#2 anim::$28 ] ] with [ zp ZP_DWORD:82 [ clock::return#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:72 [ anim::cyclecount#0 ] ] with [ zp ZP_DWORD:76 [ print_dword_at::dw#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 anim::$7 anim::$10 anim::$12 mulf8u_prepared::return#2 ] ] with [ zp ZP_WORD:46 [ anim::$11 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 anim::$7 anim::$10 anim::$12 mulf8u_prepared::return#2 anim::$11 ] ] with [ zp ZP_WORD:52 [ anim::$13 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 anim::$7 anim::$10 anim::$12 mulf8u_prepared::return#2 anim::$11 anim::$13 ] ] with [ zp ZP_WORD:93 [ mulf8u_prepared::return#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_DWORD:64 [ clock::return#2 anim::$28 clock::return#0 ] ] with [ zp ZP_DWORD:72 [ anim::cyclecount#0 print_dword_at::dw#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_BYTE:9 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 ] ] with [ zp ZP_BYTE:3 [ anim::i#10 anim::i#1 ] ]
Coalescing zero page register [ zp ZP_WORD:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 anim::$7 anim::$10 anim::$12 mulf8u_prepared::return#2 anim::$11 anim::$13 mulf8u_prepared::return#0 ] ] with [ zp ZP_WORD:5 [ print_word_at::w#2 print_word_at::w#0 print_word_at::w#1 ] ]
Coalescing zero page register [ zp ZP_WORD:21 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] ] with [ zp ZP_WORD:7 [ print_word_at::at#2 print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ] ]
Coalescing zero page register [ zp ZP_WORD:23 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] ] with [ zp ZP_WORD:13 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] ]
Coalescing zero page register [ zp ZP_BYTE:25 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] ] with [ zp ZP_BYTE:2 [ anim::angle#9 anim::angle#1 ] ]
Coalescing zero page register [ zp ZP_BYTE:33 [ mulf_init::dir#2 mulf_init::dir#3 ] ] with [ zp ZP_BYTE:4 [ anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ] ]
Coalescing zero page register [ zp ZP_WORD:38 [ anim::xr#0 anim::xr#1 ] ] with [ zp ZP_WORD:26 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] ]
Coalescing zero page register [ zp ZP_WORD:42 [ anim::yr#0 anim::yr#1 ] ] with [ zp ZP_WORD:29 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] ]
Coalescing zero page register [ zp ZP_WORD:57 [ anim::xpos#0 ] ] with [ zp ZP_WORD:31 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] ]
Allocated (was zp ZP_BYTE:9) zp ZP_BYTE:2 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 anim::i#10 anim::i#1 ]
Allocated (was zp ZP_WORD:16) zp ZP_WORD:3 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 anim::$7 anim::$10 anim::$12 mulf8u_prepared::return#2 anim::$11 anim::$13 mulf8u_prepared::return#0 print_word_at::w#2 print_word_at::w#0 print_word_at::w#1 ]
Allocated (was zp ZP_WORD:21) zp ZP_WORD:5 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 print_word_at::at#2 print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ]
Allocated (was zp ZP_WORD:23) zp ZP_WORD:7 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
Allocated (was zp ZP_BYTE:25) zp ZP_BYTE:9 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 anim::angle#9 anim::angle#1 ]
Allocated (was zp ZP_BYTE:33) zp ZP_BYTE:10 [ mulf_init::dir#2 mulf_init::dir#3 anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ]
Allocated (was zp ZP_BYTE:34) zp ZP_BYTE:11 [ anim::x#0 ]
Allocated (was zp ZP_BYTE:35) zp ZP_BYTE:12 [ anim::y#0 ]
Allocated (was zp ZP_WORD:38) zp ZP_WORD:13 [ anim::xr#0 anim::xr#1 mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
Allocated (was zp ZP_WORD:42) zp ZP_WORD:15 [ anim::yr#0 anim::yr#1 mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
Allocated (was zp ZP_WORD:57) zp ZP_WORD:17 [ anim::xpos#0 mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
Allocated (was zp ZP_DWORD:64) zp ZP_DWORD:19 [ clock::return#2 anim::$28 clock::return#0 anim::cyclecount#0 print_dword_at::dw#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// 2D rotattion of 8 sprites 
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  // CIA #2 Timer A+B Value (32-bit)
  .label CIA2_TIMER_AB = $dd04
  // CIA #2 Timer A Control Register
  .label CIA2_TIMER_A_CONTROL = $dd0e
  // CIA #2 Timer B Control Register
  .label CIA2_TIMER_B_CONTROL = $dd0f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer Control - Time CONTINUOUS/ONE-SHOT (0:CONTINUOUS, 1: ONE-SHOT)
  .const CIA_TIMER_CONTROL_CONTINUOUS = 0
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  .const GREEN = 5
  .const LIGHT_BLUE = $e
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .label SCREEN = $400
  // A single sprite
  .label SPRITE = $3000
  .label COS = SIN+$40
  // @begin
bbegin:
  jmp b1
  // @1
b1:
  // kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
// sin(x) = cos(x+PI/2)
main: {
    // asm { sei  }
    sei
    // [5] call init 
    // [121] phi from main to init [phi:main->init]
  init_from_main:
    jsr init
    // [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
    // main::@1
  b1:
    // [7] call anim 
    // [9] phi from main::@1 to anim [phi:main::@1->anim]
  anim_from_b1:
    jsr anim
    jmp breturn
    // main::@return
  breturn:
    // [8] return 
    rts
}
  // anim
anim: {
    .label _5 = 3
    .label _7 = 3
    .label _10 = 3
    .label _11 = 3
    .label _12 = 3
    .label _13 = 3
    .label _28 = $13
    .label x = $b
    .label y = $c
    .label xr = $d
    .label yr = $f
    .label xpos = $11
    .label sprite_msb = $a
    .label i = 2
    .label angle = 9
    .label cyclecount = $13
    // [10] phi from anim to anim::@1 [phi:anim->anim::@1]
  b1_from_anim:
    // [10] phi (byte) anim::angle#9 = (byte) 0 [phi:anim->anim::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta angle
    jmp b1
    // anim::@1
  b1:
    jmp b2
    // anim::@2
  b2:
    // [11] if(*((const byte*) RASTER#0)!=(byte) $ff) goto anim::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    jmp b3
    // anim::@3
  b3:
    // [12] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [13] call clock_start 
    jsr clock_start
    // [14] phi from anim::@3 to anim::@4 [phi:anim::@3->anim::@4]
  b4_from_b3:
    // [14] phi (byte) anim::sprite_msb#10 = (byte) 0 [phi:anim::@3->anim::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta sprite_msb
    // [14] phi (byte) anim::i#10 = (byte) 0 [phi:anim::@3->anim::@4#1] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b4
    // [14] phi from anim::@5 to anim::@4 [phi:anim::@5->anim::@4]
  b4_from_b5:
    // [14] phi (byte) anim::sprite_msb#10 = (byte) anim::sprite_msb#5 [phi:anim::@5->anim::@4#0] -- register_copy 
    // [14] phi (byte) anim::i#10 = (byte) anim::i#1 [phi:anim::@5->anim::@4#1] -- register_copy 
    jmp b4
    // anim::@4
  b4:
    // [15] (signed byte) anim::x#0 ← *((const signed byte[8]) xs#0 + (byte) anim::i#10) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda xs,y
    sta x
    // [16] (signed byte) anim::y#0 ← *((const signed byte[8]) ys#0 + (byte) anim::i#10) -- vbsz1=pbsc1_derefidx_vbuz2 
    // signed fixed[7.0]
    ldy i
    lda ys,y
    sta y
    jmp mulf8s_prepare1
    // anim::mulf8s_prepare1
  mulf8s_prepare1:
    // [17] (byte~) mulf8u_prepare::a#3 ← (byte)(signed byte)*((const byte*) COS#0 + (byte) anim::angle#9) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy angle
    lda COS,y
    // [18] call mulf8u_prepare 
    // [111] phi from anim::mulf8s_prepare1 to mulf8u_prepare [phi:anim::mulf8s_prepare1->mulf8u_prepare]
  mulf8u_prepare_from_mulf8s_prepare1:
    // [111] phi (byte) mulf8u_prepare::a#2 = (byte~) mulf8u_prepare::a#3 [phi:anim::mulf8s_prepare1->mulf8u_prepare#0] -- register_copy 
    jsr mulf8u_prepare
    jmp b8
    // anim::@8
  b8:
    // [19] (signed byte) mulf8s_prepared::b#0 ← (signed byte) anim::x#0 -- vbsyy=vbsz1 
    ldy x
    // [20] call mulf8s_prepared 
    // [91] phi from anim::@8 to mulf8s_prepared [phi:anim::@8->mulf8s_prepared]
  mulf8s_prepared_from_b8:
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#0 [phi:anim::@8->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    jmp b10
    // anim::@10
  b10:
    // [21] (signed word~) anim::$5 ← (signed word)(word) mulf8s_prepared::m#4
    // [22] (signed word) anim::xr#0 ← (signed word~) anim::$5 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda _5
    asl
    sta xr
    lda _5+1
    rol
    sta xr+1
    // [23] (signed byte) mulf8s_prepared::b#1 ← (signed byte) anim::y#0 -- vbsyy=vbsz1 
    ldy y
    // [24] call mulf8s_prepared 
    // [91] phi from anim::@10 to mulf8s_prepared [phi:anim::@10->mulf8s_prepared]
  mulf8s_prepared_from_b10:
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#1 [phi:anim::@10->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    jmp b11
    // anim::@11
  b11:
    // [25] (signed word~) anim::$7 ← (signed word)(word) mulf8s_prepared::m#4
    // [26] (signed word) anim::yr#0 ← (signed word~) anim::$7 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda _7
    asl
    sta yr
    lda _7+1
    rol
    sta yr+1
    jmp mulf8s_prepare2
    // anim::mulf8s_prepare2
  mulf8s_prepare2:
    // [27] (byte~) mulf8u_prepare::a#4 ← (byte)(signed byte)*((const byte[$140]) SIN#0 + (byte) anim::angle#9) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy angle
    lda SIN,y
    // [28] call mulf8u_prepare 
    // [111] phi from anim::mulf8s_prepare2 to mulf8u_prepare [phi:anim::mulf8s_prepare2->mulf8u_prepare]
  mulf8u_prepare_from_mulf8s_prepare2:
    // [111] phi (byte) mulf8u_prepare::a#2 = (byte~) mulf8u_prepare::a#4 [phi:anim::mulf8s_prepare2->mulf8u_prepare#0] -- register_copy 
    jsr mulf8u_prepare
    jmp b9
    // anim::@9
  b9:
    // [29] (signed byte) mulf8s_prepared::b#2 ← (signed byte) anim::y#0 -- vbsyy=vbsz1 
    ldy y
    // [30] call mulf8s_prepared 
    // [91] phi from anim::@9 to mulf8s_prepared [phi:anim::@9->mulf8s_prepared]
  mulf8s_prepared_from_b9:
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#2 [phi:anim::@9->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    jmp b12
    // anim::@12
  b12:
    // [31] (signed word~) anim::$10 ← (signed word)(word) mulf8s_prepared::m#4
    // [32] (signed word~) anim::$11 ← (signed word~) anim::$10 << (byte) 1 -- vwsz1=vwsz1_rol_1 
    asl _11
    rol _11+1
    // [33] (signed word) anim::xr#1 ← (signed word) anim::xr#0 - (signed word~) anim::$11 -- vwsz1=vwsz1_minus_vwsz2 
    lda xr
    sec
    sbc _11
    sta xr
    lda xr+1
    sbc _11+1
    sta xr+1
    // [34] (signed byte) mulf8s_prepared::b#3 ← (signed byte) anim::x#0 -- vbsyy=vbsz1 
    ldy x
    // [35] call mulf8s_prepared 
    // [91] phi from anim::@12 to mulf8s_prepared [phi:anim::@12->mulf8s_prepared]
  mulf8s_prepared_from_b12:
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#3 [phi:anim::@12->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    jmp b13
    // anim::@13
  b13:
    // [36] (signed word~) anim::$12 ← (signed word)(word) mulf8s_prepared::m#4
    // [37] (signed word~) anim::$13 ← (signed word~) anim::$12 << (byte) 1 -- vwsz1=vwsz1_rol_1 
    asl _13
    rol _13+1
    // [38] (signed word) anim::yr#1 ← (signed word) anim::yr#0 + (signed word~) anim::$13 -- vwsz1=vwsz1_plus_vwsz2 
    // signed fixed[8.8]
    lda yr
    clc
    adc _13
    sta yr
    lda yr+1
    adc _13+1
    sta yr+1
    // [39] (byte~) anim::$16 ← > (signed word) anim::xr#1 -- vbuaa=_hi_vwsz1 
    lda xr+1
    // [40] (signed word) anim::xpos#0 ← (signed byte)(byte~) anim::$16 + (signed byte) $18+(signed word) $95 -- vwsz1=vbsaa_plus_vwsc1 
    tax
    clc
    adc #<$18+$95
    sta xpos
    txa
    ora #$7f
    bmi !+
    lda #0
  !:
    adc #>$18+$95
    sta xpos+1
    // [41] (byte) anim::sprite_msb#1 ← (byte) anim::sprite_msb#10 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr sprite_msb
    // [42] (byte~) anim::$19 ← > (signed word) anim::xpos#0 -- vbuaa=_hi_vwsz1 
    lda xpos+1
    // [43] if((byte~) anim::$19==(byte) 0) goto anim::@5 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b5_from_b13
    jmp b6
    // anim::@6
  b6:
    // [44] (byte) anim::sprite_msb#2 ← (byte) anim::sprite_msb#1 | (byte) $80 -- vbuz1=vbuz1_bor_vbuc1 
    lda #$80
    ora sprite_msb
    sta sprite_msb
    // [45] phi from anim::@13 anim::@6 to anim::@5 [phi:anim::@13/anim::@6->anim::@5]
  b5_from_b13:
  b5_from_b6:
    // [45] phi (byte) anim::sprite_msb#5 = (byte) anim::sprite_msb#1 [phi:anim::@13/anim::@6->anim::@5#0] -- register_copy 
    jmp b5
    // anim::@5
  b5:
    // [46] (byte~) anim::$23 ← > (signed word) anim::yr#1 -- vbuaa=_hi_vwsz1 
    lda yr+1
    // [47] (byte) anim::ypos#0 ← (byte~) anim::$23 + (byte) $59+(byte) $33 -- vbuyy=vbuaa_plus_vbuc1 
    clc
    adc #$59+$33
    tay
    // [48] (byte) anim::i2#0 ← (byte) anim::i#10 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda i
    asl
    tax
    // [49] (byte~) anim::$26 ← < (signed word) anim::xpos#0 -- vbuaa=_lo_vwsz1 
    lda xpos
    // [50] *((const byte*) SPRITES_XPOS#0 + (byte) anim::i2#0) ← (byte~) anim::$26 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SPRITES_XPOS,x
    // [51] *((const byte*) SPRITES_YPOS#0 + (byte) anim::i2#0) ← (byte) anim::ypos#0 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta SPRITES_YPOS,x
    // [52] (byte) anim::i#1 ← ++ (byte) anim::i#10 -- vbuz1=_inc_vbuz1 
    inc i
    // [53] if((byte) anim::i#1!=(byte) 8) goto anim::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp i
    bne b4_from_b5
    jmp b7
    // anim::@7
  b7:
    // [54] *((const byte*) SPRITES_XMSB#0) ← (byte) anim::sprite_msb#5 -- _deref_pbuc1=vbuz1 
    lda sprite_msb
    sta SPRITES_XMSB
    // [55] (byte) anim::angle#1 ← ++ (byte) anim::angle#9 -- vbuz1=_inc_vbuz1 
    inc angle
    // [56] call clock 
    jsr clock
    // [57] (dword) clock::return#2 ← (dword) clock::return#0
    jmp b14
    // anim::@14
  b14:
    // [58] (dword~) anim::$28 ← (dword) clock::return#2
    // [59] (dword) anim::cyclecount#0 ← (dword~) anim::$28 - (const dword) CLOCKS_PER_INIT#0 -- vduz1=vduz1_minus_vduc1 
    lda cyclecount
    sec
    sbc #<CLOCKS_PER_INIT
    sta cyclecount
    lda cyclecount+1
    sbc #>CLOCKS_PER_INIT
    sta cyclecount+1
    lda cyclecount+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta cyclecount+2
    lda cyclecount+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta cyclecount+3
    // [60] (dword) print_dword_at::dw#0 ← (dword) anim::cyclecount#0
    // [61] call print_dword_at 
    jsr print_dword_at
    jmp b15
    // anim::@15
  b15:
    // [62] *((const byte*) BORDERCOL#0) ← (const byte) LIGHT_BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #LIGHT_BLUE
    sta BORDERCOL
    // [10] phi from anim::@15 to anim::@1 [phi:anim::@15->anim::@1]
  b1_from_b15:
    // [10] phi (byte) anim::angle#9 = (byte) anim::angle#1 [phi:anim::@15->anim::@1#0] -- register_copy 
    jmp b1
}
  // print_dword_at
// Print a dword as HEX at a specific position
// print_dword_at(dword zeropage($13) dw)
print_dword_at: {
    .label dw = $13
    // [63] (word) print_word_at::w#0 ← > (dword) print_dword_at::dw#0 -- vwuz1=_hi_vduz2 
    lda dw+2
    sta print_word_at.w
    lda dw+3
    sta print_word_at.w+1
    // [64] call print_word_at 
    // [68] phi from print_dword_at to print_word_at [phi:print_dword_at->print_word_at]
  print_word_at_from_print_dword_at:
    // [68] phi (byte*) print_word_at::at#2 = (const byte*) SCREEN#0 [phi:print_dword_at->print_word_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta print_word_at.at
    lda #>SCREEN
    sta print_word_at.at+1
    // [68] phi (word) print_word_at::w#2 = (word) print_word_at::w#0 [phi:print_dword_at->print_word_at#1] -- register_copy 
    jsr print_word_at
    jmp b1
    // print_dword_at::@1
  b1:
    // [65] (word) print_word_at::w#1 ← < (dword) print_dword_at::dw#0 -- vwuz1=_lo_vduz2 
    lda dw
    sta print_word_at.w
    lda dw+1
    sta print_word_at.w+1
    // [66] call print_word_at 
    // [68] phi from print_dword_at::@1 to print_word_at [phi:print_dword_at::@1->print_word_at]
  print_word_at_from_b1:
    // [68] phi (byte*) print_word_at::at#2 = (const byte*) SCREEN#0+(byte) 4 [phi:print_dword_at::@1->print_word_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN+4
    sta print_word_at.at
    lda #>SCREEN+4
    sta print_word_at.at+1
    // [68] phi (word) print_word_at::w#2 = (word) print_word_at::w#1 [phi:print_dword_at::@1->print_word_at#1] -- register_copy 
    jsr print_word_at
    jmp breturn
    // print_dword_at::@return
  breturn:
    // [67] return 
    rts
}
  // print_word_at
// Print a word as HEX at a specific position
// print_word_at(word zeropage(3) w, byte* zeropage(5) at)
print_word_at: {
    .label w = 3
    .label at = 5
    // [69] (byte) print_byte_at::b#0 ← > (word) print_word_at::w#2 -- vbuz1=_hi_vwuz2 
    lda w+1
    sta print_byte_at.b
    // [70] (byte*) print_byte_at::at#0 ← (byte*) print_word_at::at#2
    // [71] call print_byte_at 
    // [76] phi from print_word_at to print_byte_at [phi:print_word_at->print_byte_at]
  print_byte_at_from_print_word_at:
    // [76] phi (byte*) print_byte_at::at#2 = (byte*) print_byte_at::at#0 [phi:print_word_at->print_byte_at#0] -- register_copy 
    // [76] phi (byte) print_byte_at::b#2 = (byte) print_byte_at::b#0 [phi:print_word_at->print_byte_at#1] -- register_copy 
    jsr print_byte_at
    jmp b1
    // print_word_at::@1
  b1:
    // [72] (byte) print_byte_at::b#1 ← < (word) print_word_at::w#2 -- vbuz1=_lo_vwuz2 
    lda w
    sta print_byte_at.b
    // [73] (byte*) print_byte_at::at#1 ← (byte*) print_word_at::at#2 + (byte) 2 -- pbuz1=pbuz1_plus_2 
    lda print_byte_at.at
    clc
    adc #2
    sta print_byte_at.at
    bcc !+
    inc print_byte_at.at+1
  !:
    // [74] call print_byte_at 
    // [76] phi from print_word_at::@1 to print_byte_at [phi:print_word_at::@1->print_byte_at]
  print_byte_at_from_b1:
    // [76] phi (byte*) print_byte_at::at#2 = (byte*) print_byte_at::at#1 [phi:print_word_at::@1->print_byte_at#0] -- register_copy 
    // [76] phi (byte) print_byte_at::b#2 = (byte) print_byte_at::b#1 [phi:print_word_at::@1->print_byte_at#1] -- register_copy 
    jsr print_byte_at
    jmp breturn
    // print_word_at::@return
  breturn:
    // [75] return 
    rts
}
  // print_byte_at
// Print a byte as HEX at a specific position
// print_byte_at(byte zeropage(2) b, byte* zeropage(5) at)
print_byte_at: {
    .label b = 2
    .label at = 5
    // [77] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#2 >> (byte) 4 -- vbuaa=vbuz1_ror_4 
    lda b
    lsr
    lsr
    lsr
    lsr
    // [78] (byte) print_char_at::ch#0 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0) -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx print_hextab,y
    // [79] (byte*) print_char_at::at#0 ← (byte*) print_byte_at::at#2 -- pbuz1=pbuz2 
    lda at
    sta print_char_at.at
    lda at+1
    sta print_char_at.at+1
    // [80] call print_char_at 
    // [86] phi from print_byte_at to print_char_at [phi:print_byte_at->print_char_at]
  print_char_at_from_print_byte_at:
    // [86] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#0 [phi:print_byte_at->print_char_at#0] -- register_copy 
    // [86] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#0 [phi:print_byte_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp b1
    // print_byte_at::@1
  b1:
    // [81] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (byte) $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and b
    tay
    // [82] (byte*) print_char_at::at#1 ← (byte*) print_byte_at::at#2 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda at
    clc
    adc #1
    sta print_char_at.at
    lda at+1
    adc #0
    sta print_char_at.at+1
    // [83] (byte) print_char_at::ch#1 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2) -- vbuxx=pbuc1_derefidx_vbuyy 
    ldx print_hextab,y
    // [84] call print_char_at 
    // [86] phi from print_byte_at::@1 to print_char_at [phi:print_byte_at::@1->print_char_at]
  print_char_at_from_b1:
    // [86] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#1 [phi:print_byte_at::@1->print_char_at#0] -- register_copy 
    // [86] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#1 [phi:print_byte_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp breturn
    // print_byte_at::@return
  breturn:
    // [85] return 
    rts
}
  // print_char_at
// Print a single char
// print_char_at(byte register(X) ch, byte* zeropage(7) at)
print_char_at: {
    .label at = 7
    // [87] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (at),y
    jmp breturn
    // print_char_at::@return
  breturn:
    // [88] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = $13
    // [89] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta return+3
    jmp breturn
    // clock::@return
  breturn:
    // [90] return 
    rts
}
  // mulf8s_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8s_prepare(byte a)
// mulf8s_prepared(signed byte register(Y) b)
mulf8s_prepared: {
    .label memA = $fd
    .label m = 3
    // [92] (byte) mulf8u_prepared::b#0 ← (byte)(signed byte) mulf8s_prepared::b#4 -- vbuaa=vbuyy 
    tya
    // [93] call mulf8u_prepared 
    jsr mulf8u_prepared
    // [94] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0
    jmp b5
    // mulf8s_prepared::@5
  b5:
    // [95] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2
    // [96] if(*((const signed byte*) mulf8s_prepared::memA#0)>=(signed byte) 0) goto mulf8s_prepared::@1 -- _deref_pbsc1_ge_0_then_la1 
    lda memA
    cmp #0
    bpl b1_from_b5
    jmp b3
    // mulf8s_prepared::@3
  b3:
    // [97] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0 -- vbuaa=_hi_vwuz1 
    lda m+1
    // [98] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#4 -- vbuaa=vbuaa_minus_vbuyy 
    sty $ff
    sec
    sbc $ff
    // [99] (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#0 hi= (byte~) mulf8s_prepared::$15 -- vwuz1=vwuz1_sethi_vbuaa 
    sta m+1
    // [100] phi from mulf8s_prepared::@3 mulf8s_prepared::@5 to mulf8s_prepared::@1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1]
  b1_from_b3:
  b1_from_b5:
    // [100] phi (word) mulf8s_prepared::m#5 = (word) mulf8s_prepared::m#1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1#0] -- register_copy 
    jmp b1
    // mulf8s_prepared::@1
  b1:
    // [101] if((signed byte) mulf8s_prepared::b#4>=(signed byte) 0) goto mulf8s_prepared::@2 -- vbsyy_ge_0_then_la1 
    cpy #0
    bpl b2_from_b1
    jmp b4
    // mulf8s_prepared::@4
  b4:
    // [102] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5 -- vbuaa=_hi_vwuz1 
    lda m+1
    // [103] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA#0) -- vbuaa=vbuaa_minus__deref_pbuc1 
    sec
    sbc memA
    // [104] (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16 -- vwuz1=vwuz1_sethi_vbuaa 
    sta m+1
    // [105] phi from mulf8s_prepared::@1 mulf8s_prepared::@4 to mulf8s_prepared::@2 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2]
  b2_from_b1:
  b2_from_b4:
    // [105] phi (word) mulf8s_prepared::m#4 = (word) mulf8s_prepared::m#5 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2#0] -- register_copy 
    jmp b2
    // mulf8s_prepared::@2
  b2:
    jmp breturn
    // mulf8s_prepared::@return
  breturn:
    // [106] return 
    rts
}
  // mulf8u_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8u_prepare(byte a)
// mulf8u_prepared(byte register(A) b)
mulf8u_prepared: {
    .label resL = $fe
    .label memB = $ff
    .label return = 3
    // [107] *((const byte*) mulf8u_prepared::memB#0) ← (byte) mulf8u_prepared::b#0 -- _deref_pbuc1=vbuaa 
    sta memB
    // asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
    ldx memB
    sec
  sm1:
    lda mulf_sqr1_lo,x
  sm2:
    sbc mulf_sqr2_lo,x
    sta resL
  sm3:
    lda mulf_sqr1_hi,x
  sm4:
    sbc mulf_sqr2_hi,x
    sta memB
    // [109] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB#0) w= *((const byte*) mulf8u_prepared::resL#0) -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda resL
    sta return
    lda memB
    sta return+1
    jmp breturn
    // mulf8u_prepared::@return
  breturn:
    // [110] return 
    rts
}
  // mulf8u_prepare
// Prepare for fast multiply with an unsigned byte to a word result
// mulf8u_prepare(byte register(A) a)
mulf8u_prepare: {
    .label memA = $fd
    // [112] *((const byte*) mulf8u_prepare::memA#0) ← (byte) mulf8u_prepare::a#2 -- _deref_pbuc1=vbuaa 
    sta memA
    // asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
    lda memA
    sta mulf8u_prepared.sm1+1
    sta mulf8u_prepared.sm3+1
    eor #$ff
    sta mulf8u_prepared.sm2+1
    sta mulf8u_prepared.sm4+1
    jmp breturn
    // mulf8u_prepare::@return
  breturn:
    // [114] return 
    rts
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [115] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #CIA_TIMER_CONTROL_CONTINUOUS
    sta CIA2_TIMER_A_CONTROL
    // [116] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [117] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [118] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [119] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2_TIMER_A_CONTROL
    jmp breturn
    // clock_start::@return
  breturn:
    // [120] return 
    rts
}
  // init
init: {
    .label sprites_ptr = SCREEN+$3f8
    // [122] call mulf_init 
    // [130] phi from init to mulf_init [phi:init->mulf_init]
  mulf_init_from_init:
    jsr mulf_init
    jmp b2
    // init::@2
  b2:
    // [123] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    lda #$ff
    sta SPRITES_ENABLE
    // [124] phi from init::@2 to init::@1 [phi:init::@2->init::@1]
  b1_from_b2:
    // [124] phi (byte) init::i#2 = (byte) 0 [phi:init::@2->init::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
    // [124] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
    // [124] phi (byte) init::i#2 = (byte) init::i#1 [phi:init::@1->init::@1#0] -- register_copy 
    jmp b1
    // init::@1
  b1:
    // [125] *((const byte*) init::sprites_ptr#0 + (byte) init::i#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta sprites_ptr,x
    // [126] *((const byte*) SPRITES_COLS#0 + (byte) init::i#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
    // [127] (byte) init::i#1 ← ++ (byte) init::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [128] if((byte) init::i#1!=(byte) 8) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b1_from_b1
    jmp breturn
    // init::@return
  breturn:
    // [129] return 
    rts
}
  // mulf_init
// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/4)
mulf_init: {
    .label sqr1_hi = 7
    .label sqr = $d
    .label sqr1_lo = 5
    .label x_2 = 9
    .label sqr2_hi = $11
    .label sqr2_lo = $f
    .label dir = $a
    // [131] phi from mulf_init to mulf_init::@1 [phi:mulf_init->mulf_init::@1]
  b1_from_mulf_init:
    // [131] phi (byte) mulf_init::x_2#3 = (byte) 0 [phi:mulf_init->mulf_init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x_2
    // [131] phi (byte*) mulf_init::sqr1_hi#2 = (const byte[$200]) mulf_sqr1_hi#0+(byte) 1 [phi:mulf_init->mulf_init::@1#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_hi+1
    sta sqr1_hi
    lda #>mulf_sqr1_hi+1
    sta sqr1_hi+1
    // [131] phi (byte*) mulf_init::sqr1_lo#2 = (const byte[$200]) mulf_sqr1_lo#0+(byte) 1 [phi:mulf_init->mulf_init::@1#2] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_lo+1
    sta sqr1_lo
    lda #>mulf_sqr1_lo+1
    sta sqr1_lo+1
    // [131] phi (word) mulf_init::sqr#4 = (byte) 0 [phi:mulf_init->mulf_init::@1#3] -- vwuz1=vbuc1 
    lda #<0
    sta sqr
    lda #>0
    sta sqr+1
    // [131] phi (byte) mulf_init::c#2 = (byte) 0 [phi:mulf_init->mulf_init::@1#4] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
    // [131] phi from mulf_init::@2 to mulf_init::@1 [phi:mulf_init::@2->mulf_init::@1]
  b1_from_b2:
    // [131] phi (byte) mulf_init::x_2#3 = (byte) mulf_init::x_2#2 [phi:mulf_init::@2->mulf_init::@1#0] -- register_copy 
    // [131] phi (byte*) mulf_init::sqr1_hi#2 = (byte*) mulf_init::sqr1_hi#1 [phi:mulf_init::@2->mulf_init::@1#1] -- register_copy 
    // [131] phi (byte*) mulf_init::sqr1_lo#2 = (byte*) mulf_init::sqr1_lo#1 [phi:mulf_init::@2->mulf_init::@1#2] -- register_copy 
    // [131] phi (word) mulf_init::sqr#4 = (word) mulf_init::sqr#1 [phi:mulf_init::@2->mulf_init::@1#3] -- register_copy 
    // [131] phi (byte) mulf_init::c#2 = (byte) mulf_init::c#1 [phi:mulf_init::@2->mulf_init::@1#4] -- register_copy 
    jmp b1
    // mulf_init::@1
  b1:
    // [132] (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // [133] (byte~) mulf_init::$7 ← (byte) mulf_init::c#1 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [134] if((byte~) mulf_init::$7!=(byte) 0) goto mulf_init::@2 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b2_from_b1
    jmp b3
    // mulf_init::@3
  b3:
    // [135] (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3 -- vbuz1=_inc_vbuz1 
    inc x_2
    // [136] (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4 -- vwuz1=_inc_vwuz1 
    inc sqr
    bne !+
    inc sqr+1
  !:
    // [137] phi from mulf_init::@1 mulf_init::@3 to mulf_init::@2 [phi:mulf_init::@1/mulf_init::@3->mulf_init::@2]
  b2_from_b1:
  b2_from_b3:
    // [137] phi (byte) mulf_init::x_2#2 = (byte) mulf_init::x_2#3 [phi:mulf_init::@1/mulf_init::@3->mulf_init::@2#0] -- register_copy 
    // [137] phi (word) mulf_init::sqr#3 = (word) mulf_init::sqr#4 [phi:mulf_init::@1/mulf_init::@3->mulf_init::@2#1] -- register_copy 
    jmp b2
    // mulf_init::@2
  b2:
    // [138] (byte~) mulf_init::$10 ← < (word) mulf_init::sqr#3 -- vbuaa=_lo_vwuz1 
    lda sqr
    // [139] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$10 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sqr1_lo),y
    // [140] (byte~) mulf_init::$11 ← > (word) mulf_init::sqr#3 -- vbuaa=_hi_vwuz1 
    lda sqr+1
    // [141] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$11 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sqr1_hi),y
    // [142] (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2 -- pbuz1=_inc_pbuz1 
    inc sqr1_hi
    bne !+
    inc sqr1_hi+1
  !:
    // [143] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 -- vwuz1=vwuz1_plus_vbuz2 
    lda x_2
    clc
    adc sqr
    sta sqr
    bcc !+
    inc sqr+1
  !:
    // [144] (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#2 -- pbuz1=_inc_pbuz1 
    inc sqr1_lo
    bne !+
    inc sqr1_lo+1
  !:
    // [145] if((byte*) mulf_init::sqr1_lo#1!=(const byte[$200]) mulf_sqr1_lo#0+(word) $200) goto mulf_init::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda sqr1_lo+1
    cmp #>mulf_sqr1_lo+$200
    bne b1_from_b2
    lda sqr1_lo
    cmp #<mulf_sqr1_lo+$200
    bne b1_from_b2
    // [146] phi from mulf_init::@2 to mulf_init::@4 [phi:mulf_init::@2->mulf_init::@4]
  b4_from_b2:
    // [146] phi (byte) mulf_init::dir#2 = (byte) $ff [phi:mulf_init::@2->mulf_init::@4#0] -- vbuz1=vbuc1 
    lda #$ff
    sta dir
    // [146] phi (byte*) mulf_init::sqr2_hi#2 = (const byte[$200]) mulf_sqr2_hi#0 [phi:mulf_init::@2->mulf_init::@4#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_hi
    sta sqr2_hi
    lda #>mulf_sqr2_hi
    sta sqr2_hi+1
    // [146] phi (byte*) mulf_init::sqr2_lo#2 = (const byte[$200]) mulf_sqr2_lo#0 [phi:mulf_init::@2->mulf_init::@4#2] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_lo
    sta sqr2_lo
    lda #>mulf_sqr2_lo
    sta sqr2_lo+1
    // [146] phi (byte) mulf_init::x_255#2 = (byte) -1 [phi:mulf_init::@2->mulf_init::@4#3] -- vbuxx=vbuc1 
    ldx #-1
    jmp b4
    // [146] phi from mulf_init::@5 to mulf_init::@4 [phi:mulf_init::@5->mulf_init::@4]
  b4_from_b5:
    // [146] phi (byte) mulf_init::dir#2 = (byte) mulf_init::dir#3 [phi:mulf_init::@5->mulf_init::@4#0] -- register_copy 
    // [146] phi (byte*) mulf_init::sqr2_hi#2 = (byte*) mulf_init::sqr2_hi#1 [phi:mulf_init::@5->mulf_init::@4#1] -- register_copy 
    // [146] phi (byte*) mulf_init::sqr2_lo#2 = (byte*) mulf_init::sqr2_lo#1 [phi:mulf_init::@5->mulf_init::@4#2] -- register_copy 
    // [146] phi (byte) mulf_init::x_255#2 = (byte) mulf_init::x_255#1 [phi:mulf_init::@5->mulf_init::@4#3] -- register_copy 
    jmp b4
    // mulf_init::@4
  b4:
    // [147] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte[$200]) mulf_sqr1_lo#0 + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_lo,x
    ldy #0
    sta (sqr2_lo),y
    // [148] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte[$200]) mulf_sqr1_hi#0 + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_hi,x
    ldy #0
    sta (sqr2_hi),y
    // [149] (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2 -- pbuz1=_inc_pbuz1 
    inc sqr2_hi
    bne !+
    inc sqr2_hi+1
  !:
    // [150] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc dir
    tax
    // [151] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@7 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b7_from_b4
    // [153] phi from mulf_init::@4 to mulf_init::@5 [phi:mulf_init::@4->mulf_init::@5]
  b5_from_b4:
    // [153] phi (byte) mulf_init::dir#3 = (byte) 1 [phi:mulf_init::@4->mulf_init::@5#0] -- vbuz1=vbuc1 
    lda #1
    sta dir
    jmp b5
    // [152] phi from mulf_init::@4 to mulf_init::@7 [phi:mulf_init::@4->mulf_init::@7]
  b7_from_b4:
    jmp b7
    // mulf_init::@7
  b7:
    // [153] phi from mulf_init::@7 to mulf_init::@5 [phi:mulf_init::@7->mulf_init::@5]
  b5_from_b7:
    // [153] phi (byte) mulf_init::dir#3 = (byte) mulf_init::dir#2 [phi:mulf_init::@7->mulf_init::@5#0] -- register_copy 
    jmp b5
    // mulf_init::@5
  b5:
    // [154] (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#2 -- pbuz1=_inc_pbuz1 
    inc sqr2_lo
    bne !+
    inc sqr2_lo+1
  !:
    // [155] if((byte*) mulf_init::sqr2_lo#1!=(const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) goto mulf_init::@4 -- pbuz1_neq_pbuc1_then_la1 
    lda sqr2_lo+1
    cmp #>mulf_sqr2_lo+$1ff
    bne b4_from_b5
    lda sqr2_lo
    cmp #<mulf_sqr2_lo+$1ff
    bne b4_from_b5
    jmp b6
    // mulf_init::@6
  b6:
    // [156] *((const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_lo#0+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    // Set the very last value g(511) = f(256)
    lda mulf_sqr1_lo+$100
    sta mulf_sqr2_lo+$1ff
    // [157] *((const byte[$200]) mulf_sqr2_hi#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_hi#0+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    lda mulf_sqr1_hi+$100
    sta mulf_sqr2_hi+$1ff
    jmp breturn
    // mulf_init::@return
  breturn:
    // [158] return 
    rts
}
  // File Data
  // mulf_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
  // <f(x) = <(( x * x )/4)
  .align $100
  mulf_sqr1_lo: .fill $200, 0
  // >f(x) = >(( x * x )/4)
  .align $100
  mulf_sqr1_hi: .fill $200, 0
  // <g(x) =  <((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_lo: .fill $200, 0
  // >g(x) = >((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_hi: .fill $200, 0
  print_hextab: .text "0123456789abcdef"
  // Sine and Cosine tables  
  // Angles: $00=0, $80=PI,$100=2*PI
  // Sine/Cosine: signed fixed [-$7f,$7f]
  .align $40
SIN:
.for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))

  // Positions to rotate
  xs: .byte -$46, -$46, -$46, 0, 0, $46, $46, $46
  ys: .byte -$46, 0, $46, -$46, $46, -$46, 0, $46
.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp mulf8s_prepare1
Removing instruction jmp b8
Removing instruction jmp b10
Removing instruction jmp b11
Removing instruction jmp mulf8s_prepare2
Removing instruction jmp b9
Removing instruction jmp b12
Removing instruction jmp b13
Removing instruction jmp b6
Removing instruction jmp b5
Removing instruction jmp b7
Removing instruction jmp b14
Removing instruction jmp b15
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b1
Removing instruction jmp b4
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp b2
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp b7
Removing instruction jmp b5
Removing instruction jmp b6
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction ldy i
Removing instruction lda xpos+1
Replacing instruction ldx memB with TAX
Removing instruction lda memA
Removing instruction lda #>0
Replacing instruction ldx #0 with TAX
Removing instruction ldy #0
Removing instruction ldy #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b5_from_b13 with b5
Replacing label b4_from_b5 with b4
Replacing label b1 with b2
Replacing label b1_from_b5 with b1
Replacing label b2_from_b1 with b2
Replacing label b1_from_b1 with b1
Replacing label b2_from_b1 with b2
Replacing label b1_from_b2 with b1
Replacing label b1_from_b2 with b1
Replacing label b7_from_b4 with b5
Replacing label b4_from_b5 with b4
Replacing label b4_from_b5 with b4
Removing instruction b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_main:
Removing instruction anim_from_b1:
Removing instruction b1:
Removing instruction b4_from_b5:
Removing instruction b5_from_b13:
Removing instruction b5_from_b6:
Removing instruction b1_from_b3:
Removing instruction b1_from_b5:
Removing instruction b2_from_b1:
Removing instruction b2_from_b4:
Removing instruction breturn:
Removing instruction b1_from_b1:
Removing instruction b1_from_b2:
Removing instruction b2_from_b1:
Removing instruction b2_from_b3:
Removing instruction b4_from_b5:
Removing instruction b7_from_b4:
Removing instruction b7:
Removing instruction b5_from_b7:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction init_from_main:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_anim:
Removing instruction b3:
Removing instruction b4_from_b3:
Removing instruction mulf8s_prepare1:
Removing instruction mulf8u_prepare_from_mulf8s_prepare1:
Removing instruction b8:
Removing instruction mulf8s_prepared_from_b8:
Removing instruction b10:
Removing instruction mulf8s_prepared_from_b10:
Removing instruction b11:
Removing instruction mulf8s_prepare2:
Removing instruction mulf8u_prepare_from_mulf8s_prepare2:
Removing instruction b9:
Removing instruction mulf8s_prepared_from_b9:
Removing instruction b12:
Removing instruction mulf8s_prepared_from_b12:
Removing instruction b13:
Removing instruction b6:
Removing instruction b7:
Removing instruction b14:
Removing instruction b15:
Removing instruction b1_from_b15:
Removing instruction print_word_at_from_print_dword_at:
Removing instruction b1:
Removing instruction print_word_at_from_b1:
Removing instruction breturn:
Removing instruction print_byte_at_from_print_word_at:
Removing instruction b1:
Removing instruction print_byte_at_from_b1:
Removing instruction breturn:
Removing instruction print_char_at_from_print_byte_at:
Removing instruction b1:
Removing instruction print_char_at_from_b1:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction b5:
Removing instruction b3:
Removing instruction b4:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction mulf_init_from_init:
Removing instruction b2:
Removing instruction b1_from_b2:
Removing instruction breturn:
Removing instruction b1_from_mulf_init:
Removing instruction b3:
Removing instruction b4_from_b2:
Removing instruction b5_from_b4:
Removing instruction b6:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b4
Removing instruction jmp b1
Removing instruction jmp b1
Removing instruction jmp b4
Removing instruction jmp b5
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination
Fixing long branch [152] bne b4 to beq

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = (byte*) 53280
(dword*) CIA2_TIMER_AB
(const dword*) CIA2_TIMER_AB#0 CIA2_TIMER_AB = (dword*) 56580
(byte*) CIA2_TIMER_A_CONTROL
(const byte*) CIA2_TIMER_A_CONTROL#0 CIA2_TIMER_A_CONTROL = (byte*) 56590
(byte*) CIA2_TIMER_B_CONTROL
(const byte*) CIA2_TIMER_B_CONTROL#0 CIA2_TIMER_B_CONTROL = (byte*) 56591
(byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
(byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = (byte) $40
(byte) CIA_TIMER_CONTROL_CONTINUOUS
(const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 CIA_TIMER_CONTROL_CONTINUOUS = (byte) 0
(byte) CIA_TIMER_CONTROL_START
(const byte) CIA_TIMER_CONTROL_START#0 CIA_TIMER_CONTROL_START = (byte) 1
(byte) CIA_TIMER_CONTROL_STOP
(dword) CLOCKS_PER_INIT
(const dword) CLOCKS_PER_INIT#0 CLOCKS_PER_INIT = (byte) $12
(byte*) COS
(const byte*) COS#0 COS = (const byte[$140]) SIN#0+(byte) $40
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte) 5
(byte) LIGHT_BLUE
(const byte) LIGHT_BLUE#0 LIGHT_BLUE = (byte) $e
(const byte) RADIX::BINARY BINARY = (number) 2
(const byte) RADIX::DECIMAL DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL OCTAL = (number) 8
(byte*) RASTER
(const byte*) RASTER#0 RASTER = (byte*) 53266
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = (byte*) 1024
(byte[$140]) SIN
(const byte[$140]) SIN#0 SIN = kickasm {{ .for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))
 }}
(byte*) SPRITE
(const byte*) SPRITE#0 SPRITE = (byte*) 12288
(byte*) SPRITES_COLS
(const byte*) SPRITES_COLS#0 SPRITES_COLS = (byte*) 53287
(byte*) SPRITES_ENABLE
(const byte*) SPRITES_ENABLE#0 SPRITES_ENABLE = (byte*) 53269
(byte*) SPRITES_XMSB
(const byte*) SPRITES_XMSB#0 SPRITES_XMSB = (byte*) 53264
(byte*) SPRITES_XPOS
(const byte*) SPRITES_XPOS#0 SPRITES_XPOS = (byte*) 53248
(byte*) SPRITES_YPOS
(const byte*) SPRITES_YPOS#0 SPRITES_YPOS = (byte*) 53249
(void()) anim()
(signed word~) anim::$10 $10 zp ZP_WORD:3 202.0
(signed word~) anim::$11 $11 zp ZP_WORD:3 202.0
(signed word~) anim::$12 $12 zp ZP_WORD:3 202.0
(signed word~) anim::$13 $13 zp ZP_WORD:3 202.0
(byte~) anim::$16 reg byte a 101.0
(byte~) anim::$19 reg byte a 202.0
(byte~) anim::$23 reg byte a 202.0
(byte~) anim::$26 reg byte a 202.0
(dword~) anim::$28 $28 zp ZP_DWORD:19 22.0
(signed word~) anim::$5 $5 zp ZP_WORD:3 202.0
(signed word~) anim::$7 $7 zp ZP_WORD:3 202.0
(label) anim::@1
(label) anim::@10
(label) anim::@11
(label) anim::@12
(label) anim::@13
(label) anim::@14
(label) anim::@15
(label) anim::@2
(label) anim::@3
(label) anim::@4
(label) anim::@5
(label) anim::@6
(label) anim::@7
(label) anim::@8
(label) anim::@9
(byte) anim::angle
(byte) anim::angle#1 angle zp ZP_BYTE:9 2.75
(byte) anim::angle#9 angle zp ZP_BYTE:9 0.4888888888888889
(signed byte) anim::cos_a
(dword) anim::cyclecount
(dword) anim::cyclecount#0 cyclecount zp ZP_DWORD:19 22.0
(byte) anim::i
(byte) anim::i#1 i zp ZP_BYTE:2 151.5
(byte) anim::i#10 i zp ZP_BYTE:2 13.289473684210527
(byte) anim::i2
(byte) anim::i2#0 reg byte x 101.0
(label) anim::mulf8s_prepare1
(byte~) anim::mulf8s_prepare1_$0
(signed byte) anim::mulf8s_prepare1_a
(label) anim::mulf8s_prepare2
(byte~) anim::mulf8s_prepare2_$0
(signed byte) anim::mulf8s_prepare2_a
(signed byte) anim::sin_a
(byte) anim::sprite_msb
(byte) anim::sprite_msb#1 sprite_msb zp ZP_BYTE:10 101.0
(byte) anim::sprite_msb#10 sprite_msb zp ZP_BYTE:10 7.481481481481482
(byte) anim::sprite_msb#2 sprite_msb zp ZP_BYTE:10 202.0
(byte) anim::sprite_msb#5 sprite_msb zp ZP_BYTE:10 34.888888888888886
(signed byte) anim::x
(signed byte) anim::x#0 x zp ZP_BYTE:11 15.947368421052632
(signed word) anim::xpos
(signed word) anim::xpos#0 xpos zp ZP_WORD:17 33.666666666666664
(signed word) anim::xr
(signed word) anim::xr#0 xr zp ZP_WORD:13 18.363636363636363
(signed word) anim::xr#1 xr zp ZP_WORD:13 33.666666666666664
(signed byte) anim::y
(signed byte) anim::y#0 y zp ZP_BYTE:12 23.307692307692307
(byte) anim::ypos
(byte) anim::ypos#0 reg byte y 50.5
(signed word) anim::yr
(signed word) anim::yr#0 yr zp ZP_WORD:15 16.833333333333332
(signed word) anim::yr#1 yr zp ZP_WORD:15 25.25
(dword()) clock()
(label) clock::@return
(dword) clock::return
(dword) clock::return#0 return zp ZP_DWORD:19 4.333333333333333
(dword) clock::return#2 return zp ZP_DWORD:19 22.0
(void()) clock_start()
(label) clock_start::@return
(void()) init()
(label) init::@1
(label) init::@2
(label) init::@return
(byte) init::i
(byte) init::i#1 reg byte x 16.5
(byte) init::i#2 reg byte x 14.666666666666666
(byte*) init::sprites_ptr
(const byte*) init::sprites_ptr#0 sprites_ptr = (const byte*) SCREEN#0+(word) $3f8
(void()) main()
(label) main::@1
(label) main::@return
(signed word()) mulf8s_prepared((signed byte) mulf8s_prepared::b)
(byte~) mulf8s_prepared::$12 reg byte a 4.0
(byte~) mulf8s_prepared::$15 reg byte a 4.0
(byte~) mulf8s_prepared::$16 reg byte a 4.0
(byte~) mulf8s_prepared::$8 reg byte a 4.0
(label) mulf8s_prepared::@1
(label) mulf8s_prepared::@2
(label) mulf8s_prepared::@3
(label) mulf8s_prepared::@4
(label) mulf8s_prepared::@5
(label) mulf8s_prepared::@return
(signed byte) mulf8s_prepared::b
(signed byte) mulf8s_prepared::b#0 reg byte y 202.0
(signed byte) mulf8s_prepared::b#1 reg byte y 202.0
(signed byte) mulf8s_prepared::b#2 reg byte y 202.0
(signed byte) mulf8s_prepared::b#3 reg byte y 202.0
(signed byte) mulf8s_prepared::b#4 reg byte y 40.6
(word) mulf8s_prepared::m
(word) mulf8s_prepared::m#0 m zp ZP_WORD:3 2.0
(word) mulf8s_prepared::m#1 m zp ZP_WORD:3 4.0
(word) mulf8s_prepared::m#2 m zp ZP_WORD:3 4.0
(word) mulf8s_prepared::m#4 m zp ZP_WORD:3 0.6666666666666666
(word) mulf8s_prepared::m#5 m zp ZP_WORD:3 2.5
(signed byte*) mulf8s_prepared::memA
(const signed byte*) mulf8s_prepared::memA#0 memA = (signed byte*) 253
(signed word) mulf8s_prepared::return
(void()) mulf8u_prepare((byte) mulf8u_prepare::a)
(label) mulf8u_prepare::@return
(byte) mulf8u_prepare::a
(byte) mulf8u_prepare::a#2 reg byte a 204.0
(byte~) mulf8u_prepare::a#3 reg byte a 202.0
(byte~) mulf8u_prepare::a#4 reg byte a 202.0
(byte*) mulf8u_prepare::memA
(const byte*) mulf8u_prepare::memA#0 memA = (byte*) 253
(word()) mulf8u_prepared((byte) mulf8u_prepared::b)
(label) mulf8u_prepared::@return
(byte) mulf8u_prepared::b
(byte) mulf8u_prepared::b#0 reg byte a 4.0
(byte*) mulf8u_prepared::memB
(const byte*) mulf8u_prepared::memB#0 memB = (byte*) 255
(byte*) mulf8u_prepared::resL
(const byte*) mulf8u_prepared::resL#0 resL = (byte*) 254
(word) mulf8u_prepared::return
(word) mulf8u_prepared::return#0 return zp ZP_WORD:3 1.3333333333333333
(word) mulf8u_prepared::return#2 return zp ZP_WORD:3 4.0
(void()) mulf_init()
(byte~) mulf_init::$10 reg byte a 22.0
(byte~) mulf_init::$11 reg byte a 22.0
(byte~) mulf_init::$7 reg byte a 22.0
(label) mulf_init::@1
(label) mulf_init::@2
(label) mulf_init::@3
(label) mulf_init::@4
(label) mulf_init::@5
(label) mulf_init::@6
(label) mulf_init::@7
(label) mulf_init::@return
(byte) mulf_init::c
(byte) mulf_init::c#1 reg byte x 2.357142857142857
(byte) mulf_init::c#2 reg byte x 22.0
(byte) mulf_init::dir
(byte) mulf_init::dir#2 dir zp ZP_BYTE:10 4.714285714285714
(byte) mulf_init::dir#3 dir zp ZP_BYTE:10 7.333333333333333
(word) mulf_init::sqr
(word) mulf_init::sqr#1 sqr zp ZP_WORD:13 7.333333333333333
(word) mulf_init::sqr#2 sqr zp ZP_WORD:13 22.0
(word) mulf_init::sqr#3 sqr zp ZP_WORD:13 9.166666666666666
(word) mulf_init::sqr#4 sqr zp ZP_WORD:13 6.6000000000000005
(byte*) mulf_init::sqr1_hi
(byte*) mulf_init::sqr1_hi#1 sqr1_hi zp ZP_WORD:7 5.5
(byte*) mulf_init::sqr1_hi#2 sqr1_hi zp ZP_WORD:7 3.0
(byte*) mulf_init::sqr1_lo
(byte*) mulf_init::sqr1_lo#1 sqr1_lo zp ZP_WORD:5 16.5
(byte*) mulf_init::sqr1_lo#2 sqr1_lo zp ZP_WORD:5 2.5384615384615383
(byte*) mulf_init::sqr2_hi
(byte*) mulf_init::sqr2_hi#1 sqr2_hi zp ZP_WORD:17 3.142857142857143
(byte*) mulf_init::sqr2_hi#2 sqr2_hi zp ZP_WORD:17 11.0
(byte*) mulf_init::sqr2_lo
(byte*) mulf_init::sqr2_lo#1 sqr2_lo zp ZP_WORD:15 16.5
(byte*) mulf_init::sqr2_lo#2 sqr2_lo zp ZP_WORD:15 4.125
(byte) mulf_init::x_2
(byte) mulf_init::x_2#1 x_2 zp ZP_BYTE:9 11.0
(byte) mulf_init::x_2#2 x_2 zp ZP_BYTE:9 4.888888888888889
(byte) mulf_init::x_2#3 x_2 zp ZP_BYTE:9 8.25
(byte) mulf_init::x_255
(byte) mulf_init::x_255#1 reg byte x 5.5
(byte) mulf_init::x_255#2 reg byte x 11.0
(byte[$200]) mulf_sqr1_hi
(const byte[$200]) mulf_sqr1_hi#0 mulf_sqr1_hi = { fill( $200, 0) }
(byte[$200]) mulf_sqr1_lo
(const byte[$200]) mulf_sqr1_lo#0 mulf_sqr1_lo = { fill( $200, 0) }
(byte[$200]) mulf_sqr2_hi
(const byte[$200]) mulf_sqr2_hi#0 mulf_sqr2_hi = { fill( $200, 0) }
(byte[$200]) mulf_sqr2_lo
(const byte[$200]) mulf_sqr2_lo#0 mulf_sqr2_lo = { fill( $200, 0) }
(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
(byte~) print_byte_at::$0 reg byte a 4.0
(byte~) print_byte_at::$2 reg byte y 2.0
(label) print_byte_at::@1
(label) print_byte_at::@return
(byte*) print_byte_at::at
(byte*) print_byte_at::at#0 at zp ZP_WORD:5 4.0
(byte*) print_byte_at::at#1 at zp ZP_WORD:5 4.0
(byte*) print_byte_at::at#2 at zp ZP_WORD:5 1.3333333333333333
(byte) print_byte_at::b
(byte) print_byte_at::b#0 b zp ZP_BYTE:2 2.0
(byte) print_byte_at::b#1 b zp ZP_BYTE:2 2.0
(byte) print_byte_at::b#2 b zp ZP_BYTE:2 1.6
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(label) print_char_at::@return
(byte*) print_char_at::at
(byte*) print_char_at::at#0 at zp ZP_WORD:7 4.0
(byte*) print_char_at::at#1 at zp ZP_WORD:7 2.0
(byte*) print_char_at::at#2 at zp ZP_WORD:7 6.0
(byte) print_char_at::ch
(byte) print_char_at::ch#0 reg byte x 2.0
(byte) print_char_at::ch#1 reg byte x 4.0
(byte) print_char_at::ch#2 reg byte x 6.0
(void()) print_dword_at((dword) print_dword_at::dw , (byte*) print_dword_at::at)
(label) print_dword_at::@1
(label) print_dword_at::@return
(byte*) print_dword_at::at
(dword) print_dword_at::dw
(dword) print_dword_at::dw#0 dw zp ZP_DWORD:19 5.0
(byte[]) print_hextab
(const byte[]) print_hextab#0 print_hextab = (string) "0123456789abcdef"
(void()) print_word_at((word) print_word_at::w , (byte*) print_word_at::at)
(label) print_word_at::@1
(label) print_word_at::@return
(byte*) print_word_at::at
(byte*) print_word_at::at#2 at zp ZP_WORD:5 0.8
(word) print_word_at::w
(word) print_word_at::w#0 w zp ZP_WORD:3 4.0
(word) print_word_at::w#1 w zp ZP_WORD:3 4.0
(word) print_word_at::w#2 w zp ZP_WORD:3 2.0
(signed byte[8]) xs
(const signed byte[8]) xs#0 xs = { (signed byte) -$46, (signed byte) -$46, (signed byte) -$46, (signed byte) 0, (signed byte) 0, (signed byte) $46, (signed byte) $46, (signed byte) $46 }
(signed byte[8]) ys
(const signed byte[8]) ys#0 ys = { (signed byte) -$46, (signed byte) 0, (signed byte) $46, (signed byte) -$46, (signed byte) $46, (signed byte) -$46, (signed byte) 0, (signed byte) $46 }

zp ZP_BYTE:2 [ print_byte_at::b#2 print_byte_at::b#0 print_byte_at::b#1 anim::i#10 anim::i#1 ]
reg byte x [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
reg byte y [ mulf8s_prepared::b#4 mulf8s_prepared::b#0 mulf8s_prepared::b#2 mulf8s_prepared::b#1 mulf8s_prepared::b#3 ]
zp ZP_WORD:3 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 anim::$5 anim::$7 anim::$10 anim::$12 mulf8u_prepared::return#2 anim::$11 anim::$13 mulf8u_prepared::return#0 print_word_at::w#2 print_word_at::w#0 print_word_at::w#1 ]
reg byte a [ mulf8u_prepare::a#2 mulf8u_prepare::a#3 mulf8u_prepare::a#4 ]
reg byte x [ init::i#2 init::i#1 ]
reg byte x [ mulf_init::c#2 mulf_init::c#1 ]
zp ZP_WORD:5 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 print_word_at::at#2 print_byte_at::at#2 print_byte_at::at#0 print_byte_at::at#1 ]
zp ZP_WORD:7 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
zp ZP_BYTE:9 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 anim::angle#9 anim::angle#1 ]
reg byte x [ mulf_init::x_255#2 mulf_init::x_255#1 ]
zp ZP_BYTE:10 [ mulf_init::dir#2 mulf_init::dir#3 anim::sprite_msb#10 anim::sprite_msb#5 anim::sprite_msb#2 anim::sprite_msb#1 ]
zp ZP_BYTE:11 [ anim::x#0 ]
zp ZP_BYTE:12 [ anim::y#0 ]
zp ZP_WORD:13 [ anim::xr#0 anim::xr#1 mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
zp ZP_WORD:15 [ anim::yr#0 anim::yr#1 mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
reg byte a [ anim::$16 ]
zp ZP_WORD:17 [ anim::xpos#0 mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
reg byte a [ anim::$19 ]
reg byte a [ anim::$23 ]
reg byte y [ anim::ypos#0 ]
reg byte x [ anim::i2#0 ]
reg byte a [ anim::$26 ]
zp ZP_DWORD:19 [ clock::return#2 anim::$28 clock::return#0 anim::cyclecount#0 print_dword_at::dw#0 ]
reg byte a [ print_byte_at::$0 ]
reg byte y [ print_byte_at::$2 ]
reg byte a [ mulf8u_prepared::b#0 ]
reg byte a [ mulf8s_prepared::$8 ]
reg byte a [ mulf8s_prepared::$15 ]
reg byte a [ mulf8s_prepared::$12 ]
reg byte a [ mulf8s_prepared::$16 ]
reg byte a [ mulf_init::$7 ]
reg byte a [ mulf_init::$10 ]
reg byte a [ mulf_init::$11 ]


FINAL ASSEMBLER
Score: 30954

  // File Comments
// 2D rotattion of 8 sprites 
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  // CIA #2 Timer A+B Value (32-bit)
  .label CIA2_TIMER_AB = $dd04
  // CIA #2 Timer A Control Register
  .label CIA2_TIMER_A_CONTROL = $dd0e
  // CIA #2 Timer B Control Register
  .label CIA2_TIMER_B_CONTROL = $dd0f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer Control - Time CONTINUOUS/ONE-SHOT (0:CONTINUOUS, 1: ONE-SHOT)
  .const CIA_TIMER_CONTROL_CONTINUOUS = 0
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  .const GREEN = 5
  .const LIGHT_BLUE = $e
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .label SCREEN = $400
  // A single sprite
  .label SPRITE = $3000
  .label COS = SIN+$40
  // @begin
  // @1
  // kickasm
  // kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
// sin(x) = cos(x+PI/2)
main: {
    // asm
    // asm { sei  }
    sei
    // init()
    // [5] call init 
    // [121] phi from main to init [phi:main->init]
    jsr init
    // [6] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // anim()
    // [7] call anim 
    // [9] phi from main::@1 to anim [phi:main::@1->anim]
    jsr anim
    // main::@return
    // }
    // [8] return 
    rts
}
  // anim
anim: {
    .label _5 = 3
    .label _7 = 3
    .label _10 = 3
    .label _11 = 3
    .label _12 = 3
    .label _13 = 3
    .label _28 = $13
    .label x = $b
    .label y = $c
    .label xr = $d
    .label yr = $f
    .label xpos = $11
    .label sprite_msb = $a
    .label i = 2
    .label angle = 9
    .label cyclecount = $13
    // [10] phi from anim to anim::@1 [phi:anim->anim::@1]
    // [10] phi (byte) anim::angle#9 = (byte) 0 [phi:anim->anim::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta angle
    // anim::@1
    // anim::@2
  b2:
    // while(*RASTER!=$ff)
    // [11] if(*((const byte*) RASTER#0)!=(byte) $ff) goto anim::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    // anim::@3
    // (*BORDERCOL)++;
    // [12] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // clock_start()
    // [13] call clock_start 
    jsr clock_start
    // [14] phi from anim::@3 to anim::@4 [phi:anim::@3->anim::@4]
    // [14] phi (byte) anim::sprite_msb#10 = (byte) 0 [phi:anim::@3->anim::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta sprite_msb
    // [14] phi (byte) anim::i#10 = (byte) 0 [phi:anim::@3->anim::@4#1] -- vbuz1=vbuc1 
    sta i
    // [14] phi from anim::@5 to anim::@4 [phi:anim::@5->anim::@4]
    // [14] phi (byte) anim::sprite_msb#10 = (byte) anim::sprite_msb#5 [phi:anim::@5->anim::@4#0] -- register_copy 
    // [14] phi (byte) anim::i#10 = (byte) anim::i#1 [phi:anim::@5->anim::@4#1] -- register_copy 
    // anim::@4
  b4:
    // x = xs[i]
    // [15] (signed byte) anim::x#0 ← *((const signed byte[8]) xs#0 + (byte) anim::i#10) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda xs,y
    sta x
    // y = ys[i]
    // [16] (signed byte) anim::y#0 ← *((const signed byte[8]) ys#0 + (byte) anim::i#10) -- vbsz1=pbsc1_derefidx_vbuz2 
    // signed fixed[7.0]
    lda ys,y
    sta y
    // anim::mulf8s_prepare1
    // [17] (byte~) mulf8u_prepare::a#3 ← (byte)(signed byte)*((const byte*) COS#0 + (byte) anim::angle#9) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy angle
    lda COS,y
    // mulf8u_prepare((byte)a)
    // [18] call mulf8u_prepare 
    // [111] phi from anim::mulf8s_prepare1 to mulf8u_prepare [phi:anim::mulf8s_prepare1->mulf8u_prepare]
    // [111] phi (byte) mulf8u_prepare::a#2 = (byte~) mulf8u_prepare::a#3 [phi:anim::mulf8s_prepare1->mulf8u_prepare#0] -- register_copy 
    jsr mulf8u_prepare
    // anim::@8
    // mulf8s_prepared(x)
    // [19] (signed byte) mulf8s_prepared::b#0 ← (signed byte) anim::x#0 -- vbsyy=vbsz1 
    ldy x
    // [20] call mulf8s_prepared 
    // [91] phi from anim::@8 to mulf8s_prepared [phi:anim::@8->mulf8s_prepared]
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#0 [phi:anim::@8->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    // anim::@10
    // mulf8s_prepared(x)
    // [21] (signed word~) anim::$5 ← (signed word)(word) mulf8s_prepared::m#4
    // xr = mulf8s_prepared(x)*2
    // [22] (signed word) anim::xr#0 ← (signed word~) anim::$5 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda _5
    asl
    sta xr
    lda _5+1
    rol
    sta xr+1
    // mulf8s_prepared(y)
    // [23] (signed byte) mulf8s_prepared::b#1 ← (signed byte) anim::y#0 -- vbsyy=vbsz1 
    ldy y
    // [24] call mulf8s_prepared 
    // [91] phi from anim::@10 to mulf8s_prepared [phi:anim::@10->mulf8s_prepared]
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#1 [phi:anim::@10->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    // anim::@11
    // mulf8s_prepared(y)
    // [25] (signed word~) anim::$7 ← (signed word)(word) mulf8s_prepared::m#4
    // yr = mulf8s_prepared(y)*2
    // [26] (signed word) anim::yr#0 ← (signed word~) anim::$7 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda _7
    asl
    sta yr
    lda _7+1
    rol
    sta yr+1
    // anim::mulf8s_prepare2
    // [27] (byte~) mulf8u_prepare::a#4 ← (byte)(signed byte)*((const byte[$140]) SIN#0 + (byte) anim::angle#9) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy angle
    lda SIN,y
    // mulf8u_prepare((byte)a)
    // [28] call mulf8u_prepare 
    // [111] phi from anim::mulf8s_prepare2 to mulf8u_prepare [phi:anim::mulf8s_prepare2->mulf8u_prepare]
    // [111] phi (byte) mulf8u_prepare::a#2 = (byte~) mulf8u_prepare::a#4 [phi:anim::mulf8s_prepare2->mulf8u_prepare#0] -- register_copy 
    jsr mulf8u_prepare
    // anim::@9
    // mulf8s_prepared(y)
    // [29] (signed byte) mulf8s_prepared::b#2 ← (signed byte) anim::y#0 -- vbsyy=vbsz1 
    ldy y
    // [30] call mulf8s_prepared 
    // [91] phi from anim::@9 to mulf8s_prepared [phi:anim::@9->mulf8s_prepared]
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#2 [phi:anim::@9->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    // anim::@12
    // mulf8s_prepared(y)
    // [31] (signed word~) anim::$10 ← (signed word)(word) mulf8s_prepared::m#4
    // mulf8s_prepared(y)*2
    // [32] (signed word~) anim::$11 ← (signed word~) anim::$10 << (byte) 1 -- vwsz1=vwsz1_rol_1 
    asl _11
    rol _11+1
    // xr -= mulf8s_prepared(y)*2
    // [33] (signed word) anim::xr#1 ← (signed word) anim::xr#0 - (signed word~) anim::$11 -- vwsz1=vwsz1_minus_vwsz2 
    lda xr
    sec
    sbc _11
    sta xr
    lda xr+1
    sbc _11+1
    sta xr+1
    // mulf8s_prepared(x)
    // [34] (signed byte) mulf8s_prepared::b#3 ← (signed byte) anim::x#0 -- vbsyy=vbsz1 
    ldy x
    // [35] call mulf8s_prepared 
    // [91] phi from anim::@12 to mulf8s_prepared [phi:anim::@12->mulf8s_prepared]
    // [91] phi (signed byte) mulf8s_prepared::b#4 = (signed byte) mulf8s_prepared::b#3 [phi:anim::@12->mulf8s_prepared#0] -- register_copy 
    jsr mulf8s_prepared
    // anim::@13
    // mulf8s_prepared(x)
    // [36] (signed word~) anim::$12 ← (signed word)(word) mulf8s_prepared::m#4
    // mulf8s_prepared(x)*2
    // [37] (signed word~) anim::$13 ← (signed word~) anim::$12 << (byte) 1 -- vwsz1=vwsz1_rol_1 
    asl _13
    rol _13+1
    // yr += mulf8s_prepared(x)*2
    // [38] (signed word) anim::yr#1 ← (signed word) anim::yr#0 + (signed word~) anim::$13 -- vwsz1=vwsz1_plus_vwsz2 
    // signed fixed[8.8]
    lda yr
    clc
    adc _13
    sta yr
    lda yr+1
    adc _13+1
    sta yr+1
    // >xr
    // [39] (byte~) anim::$16 ← > (signed word) anim::xr#1 -- vbuaa=_hi_vwsz1 
    lda xr+1
    // xpos = ((signed byte) >xr) + 24 /*border*/ + 149
    // [40] (signed word) anim::xpos#0 ← (signed byte)(byte~) anim::$16 + (signed byte) $18+(signed word) $95 -- vwsz1=vbsaa_plus_vwsc1 
    tax
    clc
    adc #<$18+$95
    sta xpos
    txa
    ora #$7f
    bmi !+
    lda #0
  !:
    adc #>$18+$95
    sta xpos+1
    // sprite_msb = sprite_msb/2
    // [41] (byte) anim::sprite_msb#1 ← (byte) anim::sprite_msb#10 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr sprite_msb
    // >xpos
    // [42] (byte~) anim::$19 ← > (signed word) anim::xpos#0 -- vbuaa=_hi_vwsz1 
    // if(>xpos!=0)
    // [43] if((byte~) anim::$19==(byte) 0) goto anim::@5 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b5
    // anim::@6
    // sprite_msb |= $80
    // [44] (byte) anim::sprite_msb#2 ← (byte) anim::sprite_msb#1 | (byte) $80 -- vbuz1=vbuz1_bor_vbuc1 
    lda #$80
    ora sprite_msb
    sta sprite_msb
    // [45] phi from anim::@13 anim::@6 to anim::@5 [phi:anim::@13/anim::@6->anim::@5]
    // [45] phi (byte) anim::sprite_msb#5 = (byte) anim::sprite_msb#1 [phi:anim::@13/anim::@6->anim::@5#0] -- register_copy 
    // anim::@5
  b5:
    // (>yr) + 89
    // [46] (byte~) anim::$23 ← > (signed word) anim::yr#1 -- vbuaa=_hi_vwsz1 
    lda yr+1
    // ypos = (>yr) + 89 /*center*/+ 51
    // [47] (byte) anim::ypos#0 ← (byte~) anim::$23 + (byte) $59+(byte) $33 -- vbuyy=vbuaa_plus_vbuc1 
    clc
    adc #$59+$33
    tay
    // i2 = i*2
    // [48] (byte) anim::i2#0 ← (byte) anim::i#10 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda i
    asl
    tax
    // <xpos
    // [49] (byte~) anim::$26 ← < (signed word) anim::xpos#0 -- vbuaa=_lo_vwsz1 
    lda xpos
    // SPRITES_XPOS[i2] = <xpos
    // [50] *((const byte*) SPRITES_XPOS#0 + (byte) anim::i2#0) ← (byte~) anim::$26 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SPRITES_XPOS,x
    // SPRITES_YPOS[i2] = ypos
    // [51] *((const byte*) SPRITES_YPOS#0 + (byte) anim::i2#0) ← (byte) anim::ypos#0 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta SPRITES_YPOS,x
    // for(byte i: 0..7)
    // [52] (byte) anim::i#1 ← ++ (byte) anim::i#10 -- vbuz1=_inc_vbuz1 
    inc i
    // [53] if((byte) anim::i#1!=(byte) 8) goto anim::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp i
    beq !b4+
    jmp b4
  !b4:
    // anim::@7
    // *SPRITES_XMSB = sprite_msb
    // [54] *((const byte*) SPRITES_XMSB#0) ← (byte) anim::sprite_msb#5 -- _deref_pbuc1=vbuz1 
    lda sprite_msb
    sta SPRITES_XMSB
    // angle++;
    // [55] (byte) anim::angle#1 ← ++ (byte) anim::angle#9 -- vbuz1=_inc_vbuz1 
    inc angle
    // clock()
    // [56] call clock 
    jsr clock
    // [57] (dword) clock::return#2 ← (dword) clock::return#0
    // anim::@14
    // [58] (dword~) anim::$28 ← (dword) clock::return#2
    // cyclecount = clock()-CLOCKS_PER_INIT
    // [59] (dword) anim::cyclecount#0 ← (dword~) anim::$28 - (const dword) CLOCKS_PER_INIT#0 -- vduz1=vduz1_minus_vduc1 
    lda cyclecount
    sec
    sbc #<CLOCKS_PER_INIT
    sta cyclecount
    lda cyclecount+1
    sbc #>CLOCKS_PER_INIT
    sta cyclecount+1
    lda cyclecount+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta cyclecount+2
    lda cyclecount+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta cyclecount+3
    // print_dword_at(cyclecount, SCREEN)
    // [60] (dword) print_dword_at::dw#0 ← (dword) anim::cyclecount#0
    // [61] call print_dword_at 
    jsr print_dword_at
    // anim::@15
    // *BORDERCOL = LIGHT_BLUE
    // [62] *((const byte*) BORDERCOL#0) ← (const byte) LIGHT_BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #LIGHT_BLUE
    sta BORDERCOL
    // [10] phi from anim::@15 to anim::@1 [phi:anim::@15->anim::@1]
    // [10] phi (byte) anim::angle#9 = (byte) anim::angle#1 [phi:anim::@15->anim::@1#0] -- register_copy 
    jmp b2
}
  // print_dword_at
// Print a dword as HEX at a specific position
// print_dword_at(dword zeropage($13) dw)
print_dword_at: {
    .label dw = $13
    // print_word_at(>dw, at)
    // [63] (word) print_word_at::w#0 ← > (dword) print_dword_at::dw#0 -- vwuz1=_hi_vduz2 
    lda dw+2
    sta print_word_at.w
    lda dw+3
    sta print_word_at.w+1
    // [64] call print_word_at 
    // [68] phi from print_dword_at to print_word_at [phi:print_dword_at->print_word_at]
    // [68] phi (byte*) print_word_at::at#2 = (const byte*) SCREEN#0 [phi:print_dword_at->print_word_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta print_word_at.at
    lda #>SCREEN
    sta print_word_at.at+1
    // [68] phi (word) print_word_at::w#2 = (word) print_word_at::w#0 [phi:print_dword_at->print_word_at#1] -- register_copy 
    jsr print_word_at
    // print_dword_at::@1
    // print_word_at(<dw, at+4)
    // [65] (word) print_word_at::w#1 ← < (dword) print_dword_at::dw#0 -- vwuz1=_lo_vduz2 
    lda dw
    sta print_word_at.w
    lda dw+1
    sta print_word_at.w+1
    // [66] call print_word_at 
    // [68] phi from print_dword_at::@1 to print_word_at [phi:print_dword_at::@1->print_word_at]
    // [68] phi (byte*) print_word_at::at#2 = (const byte*) SCREEN#0+(byte) 4 [phi:print_dword_at::@1->print_word_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN+4
    sta print_word_at.at
    lda #>SCREEN+4
    sta print_word_at.at+1
    // [68] phi (word) print_word_at::w#2 = (word) print_word_at::w#1 [phi:print_dword_at::@1->print_word_at#1] -- register_copy 
    jsr print_word_at
    // print_dword_at::@return
    // }
    // [67] return 
    rts
}
  // print_word_at
// Print a word as HEX at a specific position
// print_word_at(word zeropage(3) w, byte* zeropage(5) at)
print_word_at: {
    .label w = 3
    .label at = 5
    // print_byte_at(>w, at)
    // [69] (byte) print_byte_at::b#0 ← > (word) print_word_at::w#2 -- vbuz1=_hi_vwuz2 
    lda w+1
    sta print_byte_at.b
    // [70] (byte*) print_byte_at::at#0 ← (byte*) print_word_at::at#2
    // [71] call print_byte_at 
    // [76] phi from print_word_at to print_byte_at [phi:print_word_at->print_byte_at]
    // [76] phi (byte*) print_byte_at::at#2 = (byte*) print_byte_at::at#0 [phi:print_word_at->print_byte_at#0] -- register_copy 
    // [76] phi (byte) print_byte_at::b#2 = (byte) print_byte_at::b#0 [phi:print_word_at->print_byte_at#1] -- register_copy 
    jsr print_byte_at
    // print_word_at::@1
    // print_byte_at(<w, at+2)
    // [72] (byte) print_byte_at::b#1 ← < (word) print_word_at::w#2 -- vbuz1=_lo_vwuz2 
    lda w
    sta print_byte_at.b
    // [73] (byte*) print_byte_at::at#1 ← (byte*) print_word_at::at#2 + (byte) 2 -- pbuz1=pbuz1_plus_2 
    lda print_byte_at.at
    clc
    adc #2
    sta print_byte_at.at
    bcc !+
    inc print_byte_at.at+1
  !:
    // [74] call print_byte_at 
    // [76] phi from print_word_at::@1 to print_byte_at [phi:print_word_at::@1->print_byte_at]
    // [76] phi (byte*) print_byte_at::at#2 = (byte*) print_byte_at::at#1 [phi:print_word_at::@1->print_byte_at#0] -- register_copy 
    // [76] phi (byte) print_byte_at::b#2 = (byte) print_byte_at::b#1 [phi:print_word_at::@1->print_byte_at#1] -- register_copy 
    jsr print_byte_at
    // print_word_at::@return
    // }
    // [75] return 
    rts
}
  // print_byte_at
// Print a byte as HEX at a specific position
// print_byte_at(byte zeropage(2) b, byte* zeropage(5) at)
print_byte_at: {
    .label b = 2
    .label at = 5
    // b>>4
    // [77] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#2 >> (byte) 4 -- vbuaa=vbuz1_ror_4 
    lda b
    lsr
    lsr
    lsr
    lsr
    // print_char_at(print_hextab[b>>4], at)
    // [78] (byte) print_char_at::ch#0 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0) -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx print_hextab,y
    // [79] (byte*) print_char_at::at#0 ← (byte*) print_byte_at::at#2 -- pbuz1=pbuz2 
    lda at
    sta print_char_at.at
    lda at+1
    sta print_char_at.at+1
    // [80] call print_char_at 
    // [86] phi from print_byte_at to print_char_at [phi:print_byte_at->print_char_at]
    // [86] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#0 [phi:print_byte_at->print_char_at#0] -- register_copy 
    // [86] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#0 [phi:print_byte_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    // print_byte_at::@1
    // b&$f
    // [81] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (byte) $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and b
    tay
    // print_char_at(print_hextab[b&$f], at+1)
    // [82] (byte*) print_char_at::at#1 ← (byte*) print_byte_at::at#2 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda at
    clc
    adc #1
    sta print_char_at.at
    lda at+1
    adc #0
    sta print_char_at.at+1
    // [83] (byte) print_char_at::ch#1 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2) -- vbuxx=pbuc1_derefidx_vbuyy 
    ldx print_hextab,y
    // [84] call print_char_at 
    // [86] phi from print_byte_at::@1 to print_char_at [phi:print_byte_at::@1->print_char_at]
    // [86] phi (byte*) print_char_at::at#2 = (byte*) print_char_at::at#1 [phi:print_byte_at::@1->print_char_at#0] -- register_copy 
    // [86] phi (byte) print_char_at::ch#2 = (byte) print_char_at::ch#1 [phi:print_byte_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    // print_byte_at::@return
    // }
    // [85] return 
    rts
}
  // print_char_at
// Print a single char
// print_char_at(byte register(X) ch, byte* zeropage(7) at)
print_char_at: {
    .label at = 7
    // *(at) = ch
    // [87] *((byte*) print_char_at::at#2) ← (byte) print_char_at::ch#2 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (at),y
    // print_char_at::@return
    // }
    // [88] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = $13
    // 0xffffffff - *CIA2_TIMER_AB
    // [89] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta return+3
    // clock::@return
    // }
    // [90] return 
    rts
}
  // mulf8s_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8s_prepare(byte a)
// mulf8s_prepared(signed byte register(Y) b)
mulf8s_prepared: {
    .label memA = $fd
    .label m = 3
    // mulf8u_prepared((byte) b)
    // [92] (byte) mulf8u_prepared::b#0 ← (byte)(signed byte) mulf8s_prepared::b#4 -- vbuaa=vbuyy 
    tya
    // [93] call mulf8u_prepared 
    jsr mulf8u_prepared
    // [94] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0
    // mulf8s_prepared::@5
    // m = mulf8u_prepared((byte) b)
    // [95] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2
    // if(*memA<0)
    // [96] if(*((const signed byte*) mulf8s_prepared::memA#0)>=(signed byte) 0) goto mulf8s_prepared::@1 -- _deref_pbsc1_ge_0_then_la1 
    lda memA
    cmp #0
    bpl b1
    // mulf8s_prepared::@3
    // >m
    // [97] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0 -- vbuaa=_hi_vwuz1 
    lda m+1
    // >m = (>m)-(byte)b
    // [98] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#4 -- vbuaa=vbuaa_minus_vbuyy 
    sty $ff
    sec
    sbc $ff
    // [99] (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#0 hi= (byte~) mulf8s_prepared::$15 -- vwuz1=vwuz1_sethi_vbuaa 
    sta m+1
    // [100] phi from mulf8s_prepared::@3 mulf8s_prepared::@5 to mulf8s_prepared::@1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1]
    // [100] phi (word) mulf8s_prepared::m#5 = (word) mulf8s_prepared::m#1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1#0] -- register_copy 
    // mulf8s_prepared::@1
  b1:
    // if(b<0)
    // [101] if((signed byte) mulf8s_prepared::b#4>=(signed byte) 0) goto mulf8s_prepared::@2 -- vbsyy_ge_0_then_la1 
    cpy #0
    bpl b2
    // mulf8s_prepared::@4
    // >m
    // [102] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5 -- vbuaa=_hi_vwuz1 
    lda m+1
    // >m = (>m)-(byte)*memA
    // [103] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA#0) -- vbuaa=vbuaa_minus__deref_pbuc1 
    sec
    sbc memA
    // [104] (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16 -- vwuz1=vwuz1_sethi_vbuaa 
    sta m+1
    // [105] phi from mulf8s_prepared::@1 mulf8s_prepared::@4 to mulf8s_prepared::@2 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2]
    // [105] phi (word) mulf8s_prepared::m#4 = (word) mulf8s_prepared::m#5 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2#0] -- register_copy 
    // mulf8s_prepared::@2
  b2:
    // mulf8s_prepared::@return
    // }
    // [106] return 
    rts
}
  // mulf8u_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8u_prepare(byte a)
// mulf8u_prepared(byte register(A) b)
mulf8u_prepared: {
    .label resL = $fe
    .label memB = $ff
    .label return = 3
    // *memB = b
    // [107] *((const byte*) mulf8u_prepared::memB#0) ← (byte) mulf8u_prepared::b#0 -- _deref_pbuc1=vbuaa 
    sta memB
    // asm
    // asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
    tax
    sec
  sm1:
    lda mulf_sqr1_lo,x
  sm2:
    sbc mulf_sqr2_lo,x
    sta resL
  sm3:
    lda mulf_sqr1_hi,x
  sm4:
    sbc mulf_sqr2_hi,x
    sta memB
    // return { *memB, *resL };
    // [109] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB#0) w= *((const byte*) mulf8u_prepared::resL#0) -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda resL
    sta return
    lda memB
    sta return+1
    // mulf8u_prepared::@return
    // }
    // [110] return 
    rts
}
  // mulf8u_prepare
// Prepare for fast multiply with an unsigned byte to a word result
// mulf8u_prepare(byte register(A) a)
mulf8u_prepare: {
    .label memA = $fd
    // *memA = a
    // [112] *((const byte*) mulf8u_prepare::memA#0) ← (byte) mulf8u_prepare::a#2 -- _deref_pbuc1=vbuaa 
    sta memA
    // asm
    // asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
    sta mulf8u_prepared.sm1+1
    sta mulf8u_prepared.sm3+1
    eor #$ff
    sta mulf8u_prepared.sm2+1
    sta mulf8u_prepared.sm4+1
    // mulf8u_prepare::@return
    // }
    // [114] return 
    rts
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // *CIA2_TIMER_A_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [115] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #CIA_TIMER_CONTROL_CONTINUOUS
    sta CIA2_TIMER_A_CONTROL
    // *CIA2_TIMER_B_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [116] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // *CIA2_TIMER_AB = 0xffffffff
    // [117] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // *CIA2_TIMER_B_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [118] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // *CIA2_TIMER_A_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [119] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2_TIMER_A_CONTROL
    // clock_start::@return
    // }
    // [120] return 
    rts
}
  // init
init: {
    .label sprites_ptr = SCREEN+$3f8
    // mulf_init()
    // [122] call mulf_init 
    // [130] phi from init to mulf_init [phi:init->mulf_init]
    jsr mulf_init
    // init::@2
    // *SPRITES_ENABLE = %11111111
    // [123] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    lda #$ff
    sta SPRITES_ENABLE
    // [124] phi from init::@2 to init::@1 [phi:init::@2->init::@1]
    // [124] phi (byte) init::i#2 = (byte) 0 [phi:init::@2->init::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [124] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
    // [124] phi (byte) init::i#2 = (byte) init::i#1 [phi:init::@1->init::@1#0] -- register_copy 
    // init::@1
  b1:
    // sprites_ptr[i] = (byte)(SPRITE/$40)
    // [125] *((const byte*) init::sprites_ptr#0 + (byte) init::i#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta sprites_ptr,x
    // SPRITES_COLS[i] = GREEN
    // [126] *((const byte*) SPRITES_COLS#0 + (byte) init::i#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
    // for(byte i: 0..7)
    // [127] (byte) init::i#1 ← ++ (byte) init::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [128] if((byte) init::i#1!=(byte) 8) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b1
    // init::@return
    // }
    // [129] return 
    rts
}
  // mulf_init
// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/4)
mulf_init: {
    .label sqr1_hi = 7
    .label sqr = $d
    .label sqr1_lo = 5
    .label x_2 = 9
    .label sqr2_hi = $11
    .label sqr2_lo = $f
    .label dir = $a
    // [131] phi from mulf_init to mulf_init::@1 [phi:mulf_init->mulf_init::@1]
    // [131] phi (byte) mulf_init::x_2#3 = (byte) 0 [phi:mulf_init->mulf_init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x_2
    // [131] phi (byte*) mulf_init::sqr1_hi#2 = (const byte[$200]) mulf_sqr1_hi#0+(byte) 1 [phi:mulf_init->mulf_init::@1#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_hi+1
    sta sqr1_hi
    lda #>mulf_sqr1_hi+1
    sta sqr1_hi+1
    // [131] phi (byte*) mulf_init::sqr1_lo#2 = (const byte[$200]) mulf_sqr1_lo#0+(byte) 1 [phi:mulf_init->mulf_init::@1#2] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_lo+1
    sta sqr1_lo
    lda #>mulf_sqr1_lo+1
    sta sqr1_lo+1
    // [131] phi (word) mulf_init::sqr#4 = (byte) 0 [phi:mulf_init->mulf_init::@1#3] -- vwuz1=vbuc1 
    lda #<0
    sta sqr
    sta sqr+1
    // [131] phi (byte) mulf_init::c#2 = (byte) 0 [phi:mulf_init->mulf_init::@1#4] -- vbuxx=vbuc1 
    tax
    // [131] phi from mulf_init::@2 to mulf_init::@1 [phi:mulf_init::@2->mulf_init::@1]
    // [131] phi (byte) mulf_init::x_2#3 = (byte) mulf_init::x_2#2 [phi:mulf_init::@2->mulf_init::@1#0] -- register_copy 
    // [131] phi (byte*) mulf_init::sqr1_hi#2 = (byte*) mulf_init::sqr1_hi#1 [phi:mulf_init::@2->mulf_init::@1#1] -- register_copy 
    // [131] phi (byte*) mulf_init::sqr1_lo#2 = (byte*) mulf_init::sqr1_lo#1 [phi:mulf_init::@2->mulf_init::@1#2] -- register_copy 
    // [131] phi (word) mulf_init::sqr#4 = (word) mulf_init::sqr#1 [phi:mulf_init::@2->mulf_init::@1#3] -- register_copy 
    // [131] phi (byte) mulf_init::c#2 = (byte) mulf_init::c#1 [phi:mulf_init::@2->mulf_init::@1#4] -- register_copy 
    // mulf_init::@1
  b1:
    // if((++c&1)==0)
    // [132] (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // ++c&1
    // [133] (byte~) mulf_init::$7 ← (byte) mulf_init::c#1 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if((++c&1)==0)
    // [134] if((byte~) mulf_init::$7!=(byte) 0) goto mulf_init::@2 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b2
    // mulf_init::@3
    // x_2++;
    // [135] (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3 -- vbuz1=_inc_vbuz1 
    inc x_2
    // sqr++;
    // [136] (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4 -- vwuz1=_inc_vwuz1 
    inc sqr
    bne !+
    inc sqr+1
  !:
    // [137] phi from mulf_init::@1 mulf_init::@3 to mulf_init::@2 [phi:mulf_init::@1/mulf_init::@3->mulf_init::@2]
    // [137] phi (byte) mulf_init::x_2#2 = (byte) mulf_init::x_2#3 [phi:mulf_init::@1/mulf_init::@3->mulf_init::@2#0] -- register_copy 
    // [137] phi (word) mulf_init::sqr#3 = (word) mulf_init::sqr#4 [phi:mulf_init::@1/mulf_init::@3->mulf_init::@2#1] -- register_copy 
    // mulf_init::@2
  b2:
    // <sqr
    // [138] (byte~) mulf_init::$10 ← < (word) mulf_init::sqr#3 -- vbuaa=_lo_vwuz1 
    lda sqr
    // *sqr1_lo = <sqr
    // [139] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$10 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sqr1_lo),y
    // >sqr
    // [140] (byte~) mulf_init::$11 ← > (word) mulf_init::sqr#3 -- vbuaa=_hi_vwuz1 
    lda sqr+1
    // *sqr1_hi++ = >sqr
    // [141] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$11 -- _deref_pbuz1=vbuaa 
    sta (sqr1_hi),y
    // *sqr1_hi++ = >sqr;
    // [142] (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2 -- pbuz1=_inc_pbuz1 
    inc sqr1_hi
    bne !+
    inc sqr1_hi+1
  !:
    // sqr = sqr + x_2
    // [143] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 -- vwuz1=vwuz1_plus_vbuz2 
    lda x_2
    clc
    adc sqr
    sta sqr
    bcc !+
    inc sqr+1
  !:
    // for(byte* sqr1_lo = mulf_sqr1_lo+1; sqr1_lo!=mulf_sqr1_lo+512; sqr1_lo++)
    // [144] (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#2 -- pbuz1=_inc_pbuz1 
    inc sqr1_lo
    bne !+
    inc sqr1_lo+1
  !:
    // [145] if((byte*) mulf_init::sqr1_lo#1!=(const byte[$200]) mulf_sqr1_lo#0+(word) $200) goto mulf_init::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda sqr1_lo+1
    cmp #>mulf_sqr1_lo+$200
    bne b1
    lda sqr1_lo
    cmp #<mulf_sqr1_lo+$200
    bne b1
    // [146] phi from mulf_init::@2 to mulf_init::@4 [phi:mulf_init::@2->mulf_init::@4]
    // [146] phi (byte) mulf_init::dir#2 = (byte) $ff [phi:mulf_init::@2->mulf_init::@4#0] -- vbuz1=vbuc1 
    lda #$ff
    sta dir
    // [146] phi (byte*) mulf_init::sqr2_hi#2 = (const byte[$200]) mulf_sqr2_hi#0 [phi:mulf_init::@2->mulf_init::@4#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_hi
    sta sqr2_hi
    lda #>mulf_sqr2_hi
    sta sqr2_hi+1
    // [146] phi (byte*) mulf_init::sqr2_lo#2 = (const byte[$200]) mulf_sqr2_lo#0 [phi:mulf_init::@2->mulf_init::@4#2] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_lo
    sta sqr2_lo
    lda #>mulf_sqr2_lo
    sta sqr2_lo+1
    // [146] phi (byte) mulf_init::x_255#2 = (byte) -1 [phi:mulf_init::@2->mulf_init::@4#3] -- vbuxx=vbuc1 
    ldx #-1
    // [146] phi from mulf_init::@5 to mulf_init::@4 [phi:mulf_init::@5->mulf_init::@4]
    // [146] phi (byte) mulf_init::dir#2 = (byte) mulf_init::dir#3 [phi:mulf_init::@5->mulf_init::@4#0] -- register_copy 
    // [146] phi (byte*) mulf_init::sqr2_hi#2 = (byte*) mulf_init::sqr2_hi#1 [phi:mulf_init::@5->mulf_init::@4#1] -- register_copy 
    // [146] phi (byte*) mulf_init::sqr2_lo#2 = (byte*) mulf_init::sqr2_lo#1 [phi:mulf_init::@5->mulf_init::@4#2] -- register_copy 
    // [146] phi (byte) mulf_init::x_255#2 = (byte) mulf_init::x_255#1 [phi:mulf_init::@5->mulf_init::@4#3] -- register_copy 
    // mulf_init::@4
  b4:
    // *sqr2_lo = mulf_sqr1_lo[x_255]
    // [147] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte[$200]) mulf_sqr1_lo#0 + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_lo,x
    ldy #0
    sta (sqr2_lo),y
    // *sqr2_hi++ = mulf_sqr1_hi[x_255]
    // [148] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte[$200]) mulf_sqr1_hi#0 + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_hi,x
    sta (sqr2_hi),y
    // *sqr2_hi++ = mulf_sqr1_hi[x_255];
    // [149] (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2 -- pbuz1=_inc_pbuz1 
    inc sqr2_hi
    bne !+
    inc sqr2_hi+1
  !:
    // x_255 = x_255 + dir
    // [150] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc dir
    tax
    // if(x_255==0)
    // [151] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@7 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b5
    // [153] phi from mulf_init::@4 to mulf_init::@5 [phi:mulf_init::@4->mulf_init::@5]
    // [153] phi (byte) mulf_init::dir#3 = (byte) 1 [phi:mulf_init::@4->mulf_init::@5#0] -- vbuz1=vbuc1 
    lda #1
    sta dir
    // [152] phi from mulf_init::@4 to mulf_init::@7 [phi:mulf_init::@4->mulf_init::@7]
    // mulf_init::@7
    // [153] phi from mulf_init::@7 to mulf_init::@5 [phi:mulf_init::@7->mulf_init::@5]
    // [153] phi (byte) mulf_init::dir#3 = (byte) mulf_init::dir#2 [phi:mulf_init::@7->mulf_init::@5#0] -- register_copy 
    // mulf_init::@5
  b5:
    // for(byte* sqr2_lo = mulf_sqr2_lo; sqr2_lo!=mulf_sqr2_lo+511; sqr2_lo++)
    // [154] (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#2 -- pbuz1=_inc_pbuz1 
    inc sqr2_lo
    bne !+
    inc sqr2_lo+1
  !:
    // [155] if((byte*) mulf_init::sqr2_lo#1!=(const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) goto mulf_init::@4 -- pbuz1_neq_pbuc1_then_la1 
    lda sqr2_lo+1
    cmp #>mulf_sqr2_lo+$1ff
    bne b4
    lda sqr2_lo
    cmp #<mulf_sqr2_lo+$1ff
    bne b4
    // mulf_init::@6
    // *(mulf_sqr2_lo+511) = *(mulf_sqr1_lo+256)
    // [156] *((const byte[$200]) mulf_sqr2_lo#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_lo#0+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    // Set the very last value g(511) = f(256)
    lda mulf_sqr1_lo+$100
    sta mulf_sqr2_lo+$1ff
    // *(mulf_sqr2_hi+511) = *(mulf_sqr1_hi+256)
    // [157] *((const byte[$200]) mulf_sqr2_hi#0+(word) $1ff) ← *((const byte[$200]) mulf_sqr1_hi#0+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    lda mulf_sqr1_hi+$100
    sta mulf_sqr2_hi+$1ff
    // mulf_init::@return
    // }
    // [158] return 
    rts
}
  // File Data
  // mulf_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
  // <f(x) = <(( x * x )/4)
  .align $100
  mulf_sqr1_lo: .fill $200, 0
  // >f(x) = >(( x * x )/4)
  .align $100
  mulf_sqr1_hi: .fill $200, 0
  // <g(x) =  <((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_lo: .fill $200, 0
  // >g(x) = >((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_hi: .fill $200, 0
  print_hextab: .text "0123456789abcdef"
  // Sine and Cosine tables  
  // Angles: $00=0, $80=PI,$100=2*PI
  // Sine/Cosine: signed fixed [-$7f,$7f]
  .align $40
SIN:
.for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))

  // Positions to rotate
  xs: .byte -$46, -$46, -$46, 0, 0, $46, $46, $46
  ys: .byte -$46, 0, $46, -$46, $46, -$46, 0, $46
.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


