Inlined call call _init 

CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from _start::@1
  (byte) y#13 ← phi( _start::@1/(byte) y#12 )
  (byte) idx#12 ← phi( _start::@1/(byte) idx#11 )
  (byte) row#13 ← phi( _start::@1/(byte) row#12 )
  (byte) x#14 ← phi( _start::@1/(byte) x#13 )
  (byte) line#0 ← (number) 0
  to:main::@1
main::@1: scope:[main]  from main main::@5
  (byte) y#11 ← phi( main/(byte) y#13 main::@5/(byte) y#0 )
  (byte) idx#10 ← phi( main/(byte) idx#12 main::@5/(byte) idx#13 )
  (byte) row#11 ← phi( main/(byte) row#13 main::@5/(byte) row#14 )
  (byte) x#11 ← phi( main/(byte) x#14 main::@5/(byte) x#15 )
  (byte) line#6 ← phi( main/(byte) line#0 main::@5/(byte) line#1 )
  (bool~) main::$0 ← (byte) line#6 < (number) 8
  if((bool~) main::$0) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  (byte) line#13 ← phi( main::@1/(byte) line#6 )
  (byte) y#14 ← phi( main::@1/(byte) y#11 )
  (byte) idx#14 ← phi( main::@1/(byte) idx#10 )
  (byte) x#6 ← phi( main::@1/(byte) x#11 )
  (byte) x#0 ← ++ (byte) x#6
  (byte) row#0 ← (number) 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  (byte) line#11 ← phi( main::@2/(byte) line#13 main::@4/(byte) line#14 )
  (byte) x#12 ← phi( main::@2/(byte) x#0 main::@4/(byte) x#1 )
  (byte) y#10 ← phi( main::@2/(byte) y#14 main::@4/(byte) y#5 )
  (byte) idx#9 ← phi( main::@2/(byte) idx#14 main::@4/(byte) idx#0 )
  (byte) row#6 ← phi( main::@2/(byte) row#0 main::@4/(byte) row#1 )
  (bool~) main::$1 ← (byte) row#6 < (number) 8
  if((bool~) main::$1) goto main::@4
  to:main::@5
main::@4: scope:[main]  from main::@3
  (byte) line#14 ← phi( main::@3/(byte) line#11 )
  (byte) row#7 ← phi( main::@3/(byte) row#6 )
  (byte) x#7 ← phi( main::@3/(byte) x#12 )
  (byte) y#5 ← phi( main::@3/(byte) y#10 )
  (byte) idx#5 ← phi( main::@3/(byte) idx#9 )
  (byte~) main::$2 ← (byte) idx#5 * (const byte) SIZEOF_STRUCT_POS
  *((byte*)(const struct pos*) p+(const byte) OFFSET_STRUCT_POS_Y + (byte~) main::$2) ← (byte) y#5
  (byte~) main::$3 ← (byte) idx#5 * (const byte) SIZEOF_STRUCT_POS
  *((byte*)(const struct pos*) p+(const byte) OFFSET_STRUCT_POS_X + (byte~) main::$3) ← (byte) x#7
  (byte) idx#0 ← ++ (byte) idx#5
  (byte) x#1 ← (byte) x#7 + (const byte) XSPACE
  (byte) row#1 ← ++ (byte) row#7
  to:main::@3
main::@5: scope:[main]  from main::@3
  (byte) idx#13 ← phi( main::@3/(byte) idx#9 )
  (byte) row#14 ← phi( main::@3/(byte) row#6 )
  (byte) x#15 ← phi( main::@3/(byte) x#12 )
  (byte) line#7 ← phi( main::@3/(byte) line#11 )
  (byte) y#6 ← phi( main::@3/(byte) y#10 )
  (byte) y#0 ← (byte) y#6 + (const byte) YSPACE
  (byte) line#1 ← ++ (byte) line#7
  to:main::@1
main::@return: scope:[main]  from main::@1
  (byte) y#7 ← phi( main::@1/(byte) y#11 )
  (byte) idx#6 ← phi( main::@1/(byte) idx#10 )
  (byte) row#8 ← phi( main::@1/(byte) row#11 )
  (byte) x#8 ← phi( main::@1/(byte) x#11 )
  (byte) line#8 ← phi( main::@1/(byte) line#6 )
  (byte) line#2 ← (byte) line#8
  (byte) x#2 ← (byte) x#8
  (byte) row#2 ← (byte) row#8
  (byte) idx#1 ← (byte) idx#6
  (byte) y#1 ← (byte) y#7
  return 
  to:@return

(void()) _start()
_start: scope:[_start]  from
  to:_start::_init1
_start::_init1: scope:[_start]  from _start
  (byte) idx#2 ← (byte) 0
  (byte) line#3 ← (byte) 0
  (byte) row#3 ← (byte) 0
  (byte) x#3 ← (byte) 0
  (byte) y#2 ← (byte) 0
  to:_start::@1
_start::@1: scope:[_start]  from _start::_init1
  (byte) y#12 ← phi( _start::_init1/(byte) y#2 )
  (byte) idx#11 ← phi( _start::_init1/(byte) idx#2 )
  (byte) row#12 ← phi( _start::_init1/(byte) row#3 )
  (byte) x#13 ← phi( _start::_init1/(byte) x#3 )
  (byte) line#12 ← phi( _start::_init1/(byte) line#3 )
  call main 
  to:_start::@2
_start::@2: scope:[_start]  from _start::@1
  (byte) y#8 ← phi( _start::@1/(byte) y#1 )
  (byte) idx#7 ← phi( _start::@1/(byte) idx#1 )
  (byte) row#9 ← phi( _start::@1/(byte) row#2 )
  (byte) x#9 ← phi( _start::@1/(byte) x#2 )
  (byte) line#9 ← phi( _start::@1/(byte) line#2 )
  (byte) line#4 ← (byte) line#9
  (byte) x#4 ← (byte) x#9
  (byte) row#4 ← (byte) row#9
  (byte) idx#3 ← (byte) idx#7
  (byte) y#3 ← (byte) y#8
  to:_start::@return
_start::@return: scope:[_start]  from _start::@2
  (byte) y#9 ← phi( _start::@2/(byte) y#3 )
  (byte) x#10 ← phi( _start::@2/(byte) x#4 )
  (byte) row#10 ← phi( _start::@2/(byte) row#4 )
  (byte) line#10 ← phi( _start::@2/(byte) line#4 )
  (byte) idx#8 ← phi( _start::@2/(byte) idx#3 )
  (byte) idx#4 ← (byte) idx#8
  (byte) line#5 ← (byte) line#10
  (byte) row#5 ← (byte) row#10
  (byte) x#5 ← (byte) x#10
  (byte) y#4 ← (byte) y#9
  return 
  to:@return

SYMBOL TABLE SSA
(const byte) OFFSET_STRUCT_POS_X = (byte) 0
(const byte) OFFSET_STRUCT_POS_Y = (byte) 1
(const byte) SIZEOF_STRUCT_POS = (byte) 2
(const byte) XSPACE = (byte) $14
(const byte) YSPACE = (byte) $14
(void()) _start()
(label) _start::@1
(label) _start::@2
(label) _start::@return
(label) _start::_init1
(byte) idx
(byte) idx#0
(byte) idx#1
(byte) idx#10
(byte) idx#11
(byte) idx#12
(byte) idx#13
(byte) idx#14
(byte) idx#2
(byte) idx#3
(byte) idx#4
(byte) idx#5
(byte) idx#6
(byte) idx#7
(byte) idx#8
(byte) idx#9
(byte) line
(byte) line#0
(byte) line#1
(byte) line#10
(byte) line#11
(byte) line#12
(byte) line#13
(byte) line#14
(byte) line#2
(byte) line#3
(byte) line#4
(byte) line#5
(byte) line#6
(byte) line#7
(byte) line#8
(byte) line#9
(void()) main()
(bool~) main::$0
(bool~) main::$1
(byte~) main::$2
(byte~) main::$3
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@return
(const struct pos*) p[(number) $40]  = { fill( $40, 0) }
(byte) pos::x
(byte) pos::y
(byte) row
(byte) row#0
(byte) row#1
(byte) row#10
(byte) row#11
(byte) row#12
(byte) row#13
(byte) row#14
(byte) row#2
(byte) row#3
(byte) row#4
(byte) row#5
(byte) row#6
(byte) row#7
(byte) row#8
(byte) row#9
(byte) x
(byte) x#0
(byte) x#1
(byte) x#10
(byte) x#11
(byte) x#12
(byte) x#13
(byte) x#14
(byte) x#15
(byte) x#2
(byte) x#3
(byte) x#4
(byte) x#5
(byte) x#6
(byte) x#7
(byte) x#8
(byte) x#9
(byte) y
(byte) y#0
(byte) y#1
(byte) y#10
(byte) y#11
(byte) y#12
(byte) y#13
(byte) y#14
(byte) y#2
(byte) y#3
(byte) y#4
(byte) y#5
(byte) y#6
(byte) y#7
(byte) y#8
(byte) y#9

Adding number conversion cast (unumber) 0 in (byte) line#0 ← (number) 0
Adding number conversion cast (unumber) 8 in (bool~) main::$0 ← (byte) line#6 < (number) 8
Adding number conversion cast (unumber) 0 in (byte) row#0 ← (number) 0
Adding number conversion cast (unumber) 8 in (bool~) main::$1 ← (byte) row#6 < (number) 8
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte) line#0 ← (unumber)(number) 0
Inlining cast (byte) row#0 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast 0
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias x#11 = x#6 x#8 x#2 
Alias idx#1 = idx#14 idx#10 idx#6 
Alias y#1 = y#14 y#11 y#7 
Alias line#13 = line#6 line#8 line#2 
Alias idx#13 = idx#5 idx#9 
Alias y#10 = y#5 y#6 
Alias x#12 = x#7 x#15 
Alias row#14 = row#7 row#6 
Alias line#11 = line#14 line#7 
Alias row#11 = row#8 row#2 
Alias line#12 = line#3 
Alias x#13 = x#3 
Alias row#12 = row#3 
Alias idx#11 = idx#2 
Alias y#12 = y#2 
Alias line#10 = line#4 line#9 line#5 
Alias x#10 = x#4 x#9 x#5 
Alias row#10 = row#4 row#9 row#5 
Alias idx#3 = idx#7 idx#8 idx#4 
Alias y#3 = y#8 y#9 y#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) x#14 (byte) x#13
Identical Phi Values (byte) row#13 (byte) row#12
Identical Phi Values (byte) idx#12 (byte) idx#11
Identical Phi Values (byte) y#13 (byte) y#12
Identical Phi Values (byte) y#10 (byte) y#1
Identical Phi Values (byte) line#11 (byte) line#13
Identical Phi Values (byte) line#10 (byte) line#13
Identical Phi Values (byte) x#10 (byte) x#11
Identical Phi Values (byte) row#10 (byte) row#11
Identical Phi Values (byte) idx#3 (byte) idx#1
Identical Phi Values (byte) y#3 (byte) y#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [14] (byte~) main::$3 ← (byte) idx#13 * (const byte) SIZEOF_STRUCT_POS
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) main::$0 [4] if((byte) line#13<(byte) 8) goto main::@2
Simple Condition (bool~) main::$1 [9] if((byte) row#14<(byte) 8) goto main::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte) line#0 = 0
Constant (const byte) row#0 = 0
Constant (const byte) idx#11 = 0
Constant (const byte) line#12 = 0
Constant (const byte) row#12 = 0
Constant (const byte) x#13 = 0
Constant (const byte) y#12 = 0
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero (byte*)p in [13] *((byte*)(const struct pos*) p+(const byte) OFFSET_STRUCT_POS_X + (byte~) main::$3) ← (byte) x#12
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable - keeping the phi block (byte) row#11
Eliminating unused constant (const byte) OFFSET_STRUCT_POS_X
Eliminating unused constant (const byte) line#12
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte) row#12
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure _start
Removing unused procedure block _start
Removing unused procedure block _start::_init1
Removing unused procedure block _start::@1
Removing unused procedure block _start::@2
Removing unused procedure block _start::@return
Successful SSA optimization PassNEliminateEmptyStart
Alias main::$3 = main::$2 
Successful SSA optimization Pass2AliasElimination
Rewriting multiplication to use shift [5] (byte~) main::$3 ← (byte) idx#13 * (const byte) SIZEOF_STRUCT_POS
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) line#0
Inlining constant with var siblings (const byte) row#0
Inlining constant with var siblings (const byte) idx#11
Inlining constant with var siblings (const byte) x#13
Inlining constant with var siblings (const byte) y#12
Constant inlined x#13 = (byte) 0
Constant inlined idx#11 = (byte) 0
Constant inlined y#12 = (byte) 0
Constant inlined row#0 = (byte) 0
Constant inlined line#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Eliminating unused constant (const byte) SIZEOF_STRUCT_POS
Successful SSA optimization PassNEliminateUnusedVars
Adding NOP phi() at start of main
CALL GRAPH

Created 7 initial phi equivalence classes
Coalesced [5] idx#16 ← idx#1
Coalesced [6] x#17 ← x#0
Coalesced [11] line#15 ← line#1
Coalesced [12] x#16 ← x#12
Coalesced (already) [13] idx#15 ← idx#13
Coalesced [14] y#15 ← y#0
Coalesced [21] row#15 ← row#1
Coalesced [22] idx#17 ← idx#0
Coalesced [23] x#18 ← x#1
Coalesced down to 5 phi equivalence classes
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [1] (byte) y#1 ← phi( main/(byte) 0 main::@5/(byte) y#0 )
  [1] (byte) idx#1 ← phi( main/(byte) 0 main::@5/(byte) idx#13 )
  [1] (byte) x#11 ← phi( main/(byte) 0 main::@5/(byte) x#12 )
  [1] (byte) line#13 ← phi( main/(byte) 0 main::@5/(byte) line#1 )
  [2] if((byte) line#13<(byte) 8) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@1
  [3] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [4] (byte) x#0 ← ++ (byte) x#11
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  [5] (byte) x#12 ← phi( main::@2/(byte) x#0 main::@4/(byte) x#1 )
  [5] (byte) idx#13 ← phi( main::@2/(byte) idx#1 main::@4/(byte) idx#0 )
  [5] (byte) row#14 ← phi( main::@2/(byte) 0 main::@4/(byte) row#1 )
  [6] if((byte) row#14<(byte) 8) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@3
  [7] (byte) y#0 ← (byte) y#1 + (const byte) YSPACE
  [8] (byte) line#1 ← ++ (byte) line#13
  to:main::@1
main::@4: scope:[main]  from main::@3
  [9] (byte~) main::$3 ← (byte) idx#13 << (byte) 1
  [10] *((byte*)(const struct pos*) p+(const byte) OFFSET_STRUCT_POS_Y + (byte~) main::$3) ← (byte) y#1
  [11] *((byte*)(const struct pos*) p + (byte~) main::$3) ← (byte) x#12
  [12] (byte) idx#0 ← ++ (byte) idx#13
  [13] (byte) x#1 ← (byte) x#12 + (const byte) XSPACE
  [14] (byte) row#1 ← ++ (byte) row#14
  to:main::@3


VARIABLE REGISTER WEIGHTS
(byte) idx
(byte) idx#0 67.33333333333333
(byte) idx#1 7.333333333333333
(byte) idx#13 46.42857142857143
(byte) line
(byte) line#1 22.0
(byte) line#13 2.75
(void()) main()
(byte~) main::$3 151.5
(byte) pos::x
(byte) pos::y
(byte) row
(byte) row#1 202.0
(byte) row#14 43.285714285714285
(byte) x
(byte) x#0 22.0
(byte) x#1 101.0
(byte) x#11 11.0
(byte) x#12 40.625
(byte) y
(byte) y#0 11.0
(byte) y#1 11.181818181818182

Initial phi equivalence classes
[ line#13 line#1 ]
[ x#11 x#12 x#0 x#1 ]
[ idx#1 idx#13 idx#0 ]
[ y#1 y#0 ]
[ row#14 row#1 ]
Added variable main::$3 to live range equivalence class [ main::$3 ]
Complete equivalence classes
[ line#13 line#1 ]
[ x#11 x#12 x#0 x#1 ]
[ idx#1 idx#13 idx#0 ]
[ y#1 y#0 ]
[ row#14 row#1 ]
[ main::$3 ]
Allocated zp[1]:2 [ line#13 line#1 ]
Allocated zp[1]:3 [ x#11 x#12 x#0 x#1 ]
Allocated zp[1]:4 [ idx#1 idx#13 idx#0 ]
Allocated zp[1]:5 [ y#1 y#0 ]
Allocated zp[1]:6 [ row#14 row#1 ]
Allocated zp[1]:7 [ main::$3 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Example of structs that can be optimized by going planar
// https://cc65.github.io/mailarchive/2010-09/8593.html?fbclid=IwAR1IF_cTdyWcFeKU93VfL2Un1EuLjkGh7O7dQ4EVj4kpJzJAj01dbmEFQt8
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const OFFSET_STRUCT_POS_Y = 1
  .const XSPACE = $14
  .const YSPACE = $14
  .label x = 3
  .label idx = 4
  .label row = 6
  .label y = 5
  .label line = 2
  // main
main: {
    .label __3 = 7
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi (byte) y#1 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [1] phi (byte) idx#1 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [1] phi (byte) x#11 = (byte) 0 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    // [1] phi (byte) line#13 = (byte) 0 [phi:main->main::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z line
    jmp __b1
    // main::@1
  __b1:
    // [2] if((byte) line#13<(byte) 8) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z line
    cmp #8
    bcc __b2
    jmp __breturn
    // main::@return
  __breturn:
    // [3] return 
    rts
    // main::@2
  __b2:
    // [4] (byte) x#0 ← ++ (byte) x#11 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [5] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [5] phi (byte) x#12 = (byte) x#0 [phi:main::@2->main::@3#0] -- register_copy 
    // [5] phi (byte) idx#13 = (byte) idx#1 [phi:main::@2->main::@3#1] -- register_copy 
    // [5] phi (byte) row#14 = (byte) 0 [phi:main::@2->main::@3#2] -- vbuz1=vbuc1 
    lda #0
    sta.z row
    jmp __b3
    // main::@3
  __b3:
    // [6] if((byte) row#14<(byte) 8) goto main::@4 -- vbuz1_lt_vbuc1_then_la1 
    lda.z row
    cmp #8
    bcc __b4
    jmp __b5
    // main::@5
  __b5:
    // [7] (byte) y#0 ← (byte) y#1 + (const byte) YSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z y
    axs #-[YSPACE]
    stx.z y
    // [8] (byte) line#1 ← ++ (byte) line#13 -- vbuz1=_inc_vbuz1 
    inc.z line
    // [1] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  __b1_from___b5:
    // [1] phi (byte) y#1 = (byte) y#0 [phi:main::@5->main::@1#0] -- register_copy 
    // [1] phi (byte) idx#1 = (byte) idx#13 [phi:main::@5->main::@1#1] -- register_copy 
    // [1] phi (byte) x#11 = (byte) x#12 [phi:main::@5->main::@1#2] -- register_copy 
    // [1] phi (byte) line#13 = (byte) line#1 [phi:main::@5->main::@1#3] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // [9] (byte~) main::$3 ← (byte) idx#13 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z idx
    asl
    sta.z __3
    // [10] *((byte*)(const struct pos*) p+(const byte) OFFSET_STRUCT_POS_Y + (byte~) main::$3) ← (byte) y#1 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z y
    ldy.z __3
    sta p+OFFSET_STRUCT_POS_Y,y
    // [11] *((byte*)(const struct pos*) p + (byte~) main::$3) ← (byte) x#12 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z x
    ldy.z __3
    sta p,y
    // [12] (byte) idx#0 ← ++ (byte) idx#13 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // [13] (byte) x#1 ← (byte) x#12 + (const byte) XSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z x
    axs #-[XSPACE]
    stx.z x
    // [14] (byte) row#1 ← ++ (byte) row#14 -- vbuz1=_inc_vbuz1 
    inc.z row
    // [5] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [5] phi (byte) x#12 = (byte) x#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [5] phi (byte) idx#13 = (byte) idx#0 [phi:main::@4->main::@3#1] -- register_copy 
    // [5] phi (byte) row#14 = (byte) row#1 [phi:main::@4->main::@3#2] -- register_copy 
    jmp __b3
}
  // File Data
  p: .fill 2*$40, 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [7] (byte) y#0 ← (byte) y#1 + (const byte) YSPACE [ line#13 x#12 idx#13 y#0 ] (  [ line#13 x#12 idx#13 y#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ line#13 line#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ x#11 x#12 x#0 x#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:4 [ idx#1 idx#13 idx#0 ]
Statement [9] (byte~) main::$3 ← (byte) idx#13 << (byte) 1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ y#1 y#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ row#14 row#1 ]
Statement [10] *((byte*)(const struct pos*) p+(const byte) OFFSET_STRUCT_POS_Y + (byte~) main::$3) ← (byte) y#1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:7 [ main::$3 ]
Statement [11] *((byte*)(const struct pos*) p + (byte~) main::$3) ← (byte) x#12 [ line#13 y#1 x#12 idx#13 row#14 ] (  [ line#13 y#1 x#12 idx#13 row#14 ] { }  ) always clobbers reg byte a 
Statement [13] (byte) x#1 ← (byte) x#12 + (const byte) XSPACE [ line#13 y#1 row#14 idx#0 x#1 ] (  [ line#13 y#1 row#14 idx#0 x#1 ] { }  ) always clobbers reg byte a 
Statement [7] (byte) y#0 ← (byte) y#1 + (const byte) YSPACE [ line#13 x#12 idx#13 y#0 ] (  [ line#13 x#12 idx#13 y#0 ] { }  ) always clobbers reg byte a 
Statement [9] (byte~) main::$3 ← (byte) idx#13 << (byte) 1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Statement [10] *((byte*)(const struct pos*) p+(const byte) OFFSET_STRUCT_POS_Y + (byte~) main::$3) ← (byte) y#1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Statement [11] *((byte*)(const struct pos*) p + (byte~) main::$3) ← (byte) x#12 [ line#13 y#1 x#12 idx#13 row#14 ] (  [ line#13 y#1 x#12 idx#13 row#14 ] { }  ) always clobbers reg byte a 
Statement [13] (byte) x#1 ← (byte) x#12 + (const byte) XSPACE [ line#13 y#1 row#14 idx#0 x#1 ] (  [ line#13 y#1 row#14 idx#0 x#1 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ line#13 line#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ x#11 x#12 x#0 x#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ idx#1 idx#13 idx#0 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ y#1 y#0 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ row#14 row#1 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ main::$3 ] : zp[1]:7 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 245.29: zp[1]:6 [ row#14 row#1 ] 174.62: zp[1]:3 [ x#11 x#12 x#0 x#1 ] 121.1: zp[1]:4 [ idx#1 idx#13 idx#0 ] 24.75: zp[1]:2 [ line#13 line#1 ] 22.18: zp[1]:5 [ y#1 y#0 ] 
Uplift Scope [main] 151.5: zp[1]:7 [ main::$3 ] 
Uplift Scope [pos] 

Uplifting [] best 7501 combination zp[1]:6 [ row#14 row#1 ] zp[1]:3 [ x#11 x#12 x#0 x#1 ] zp[1]:4 [ idx#1 idx#13 idx#0 ] zp[1]:2 [ line#13 line#1 ] zp[1]:5 [ y#1 y#0 ] 
Limited combination testing to 100 combinations of 243 possible.
Uplifting [main] best 6801 combination reg byte x [ main::$3 ] 
Uplifting [pos] best 6801 combination 
Attempting to uplift remaining variables inzp[1]:6 [ row#14 row#1 ]
Uplifting [] best 5901 combination reg byte y [ row#14 row#1 ] 
Attempting to uplift remaining variables inzp[1]:3 [ x#11 x#12 x#0 x#1 ]
Uplifting [] best 5901 combination zp[1]:3 [ x#11 x#12 x#0 x#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ idx#1 idx#13 idx#0 ]
Uplifting [] best 5901 combination zp[1]:4 [ idx#1 idx#13 idx#0 ] 
Attempting to uplift remaining variables inzp[1]:2 [ line#13 line#1 ]
Uplifting [] best 5901 combination zp[1]:2 [ line#13 line#1 ] 
Attempting to uplift remaining variables inzp[1]:5 [ y#1 y#0 ]
Uplifting [] best 5901 combination zp[1]:5 [ y#1 y#0 ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Example of structs that can be optimized by going planar
// https://cc65.github.io/mailarchive/2010-09/8593.html?fbclid=IwAR1IF_cTdyWcFeKU93VfL2Un1EuLjkGh7O7dQ4EVj4kpJzJAj01dbmEFQt8
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const OFFSET_STRUCT_POS_Y = 1
  .const XSPACE = $14
  .const YSPACE = $14
  .label x = 3
  .label idx = 4
  .label y = 5
  .label line = 2
  // main
main: {
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi (byte) y#1 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [1] phi (byte) idx#1 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [1] phi (byte) x#11 = (byte) 0 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    // [1] phi (byte) line#13 = (byte) 0 [phi:main->main::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z line
    jmp __b1
    // main::@1
  __b1:
    // [2] if((byte) line#13<(byte) 8) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z line
    cmp #8
    bcc __b2
    jmp __breturn
    // main::@return
  __breturn:
    // [3] return 
    rts
    // main::@2
  __b2:
    // [4] (byte) x#0 ← ++ (byte) x#11 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [5] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [5] phi (byte) x#12 = (byte) x#0 [phi:main::@2->main::@3#0] -- register_copy 
    // [5] phi (byte) idx#13 = (byte) idx#1 [phi:main::@2->main::@3#1] -- register_copy 
    // [5] phi (byte) row#14 = (byte) 0 [phi:main::@2->main::@3#2] -- vbuyy=vbuc1 
    ldy #0
    jmp __b3
    // main::@3
  __b3:
    // [6] if((byte) row#14<(byte) 8) goto main::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #8
    bcc __b4
    jmp __b5
    // main::@5
  __b5:
    // [7] (byte) y#0 ← (byte) y#1 + (const byte) YSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z y
    axs #-[YSPACE]
    stx.z y
    // [8] (byte) line#1 ← ++ (byte) line#13 -- vbuz1=_inc_vbuz1 
    inc.z line
    // [1] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  __b1_from___b5:
    // [1] phi (byte) y#1 = (byte) y#0 [phi:main::@5->main::@1#0] -- register_copy 
    // [1] phi (byte) idx#1 = (byte) idx#13 [phi:main::@5->main::@1#1] -- register_copy 
    // [1] phi (byte) x#11 = (byte) x#12 [phi:main::@5->main::@1#2] -- register_copy 
    // [1] phi (byte) line#13 = (byte) line#1 [phi:main::@5->main::@1#3] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // [9] (byte~) main::$3 ← (byte) idx#13 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda.z idx
    asl
    tax
    // [10] *((byte*)(const struct pos*) p+(const byte) OFFSET_STRUCT_POS_Y + (byte~) main::$3) ← (byte) y#1 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z y
    sta p+OFFSET_STRUCT_POS_Y,x
    // [11] *((byte*)(const struct pos*) p + (byte~) main::$3) ← (byte) x#12 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z x
    sta p,x
    // [12] (byte) idx#0 ← ++ (byte) idx#13 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // [13] (byte) x#1 ← (byte) x#12 + (const byte) XSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z x
    axs #-[XSPACE]
    stx.z x
    // [14] (byte) row#1 ← ++ (byte) row#14 -- vbuyy=_inc_vbuyy 
    iny
    // [5] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [5] phi (byte) x#12 = (byte) x#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [5] phi (byte) idx#13 = (byte) idx#0 [phi:main::@4->main::@3#1] -- register_copy 
    // [5] phi (byte) row#14 = (byte) row#1 [phi:main::@4->main::@3#2] -- register_copy 
    jmp __b3
}
  // File Data
  p: .fill 2*$40, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b5
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b1_from_main:
Removing instruction __breturn:
Removing instruction __b3_from___b2:
Removing instruction __b5:
Removing instruction __b1_from___b5:
Removing instruction __b3_from___b4:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(const byte) OFFSET_STRUCT_POS_Y = (byte) 1
(const byte) XSPACE = (byte) $14
(const byte) YSPACE = (byte) $14
(byte) idx
(byte) idx#0 idx zp[1]:4 67.33333333333333
(byte) idx#1 idx zp[1]:4 7.333333333333333
(byte) idx#13 idx zp[1]:4 46.42857142857143
(byte) line
(byte) line#1 line zp[1]:2 22.0
(byte) line#13 line zp[1]:2 2.75
(void()) main()
(byte~) main::$3 reg byte x 151.5
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@return
(const struct pos*) p[(number) $40]  = { fill( $40, 0) }
(byte) pos::x
(byte) pos::y
(byte) row
(byte) row#1 reg byte y 202.0
(byte) row#14 reg byte y 43.285714285714285
(byte) x
(byte) x#0 x zp[1]:3 22.0
(byte) x#1 x zp[1]:3 101.0
(byte) x#11 x zp[1]:3 11.0
(byte) x#12 x zp[1]:3 40.625
(byte) y
(byte) y#0 y zp[1]:5 11.0
(byte) y#1 y zp[1]:5 11.181818181818182

zp[1]:2 [ line#13 line#1 ]
zp[1]:3 [ x#11 x#12 x#0 x#1 ]
zp[1]:4 [ idx#1 idx#13 idx#0 ]
zp[1]:5 [ y#1 y#0 ]
reg byte y [ row#14 row#1 ]
reg byte x [ main::$3 ]


FINAL ASSEMBLER
Score: 5181

  // File Comments
// Example of structs that can be optimized by going planar
// https://cc65.github.io/mailarchive/2010-09/8593.html?fbclid=IwAR1IF_cTdyWcFeKU93VfL2Un1EuLjkGh7O7dQ4EVj4kpJzJAj01dbmEFQt8
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const OFFSET_STRUCT_POS_Y = 1
  .const XSPACE = $14
  .const YSPACE = $14
  .label x = 3
  .label idx = 4
  .label y = 5
  .label line = 2
  // main
main: {
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi (byte) y#1 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [1] phi (byte) idx#1 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    sta.z idx
    // [1] phi (byte) x#11 = (byte) 0 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    sta.z x
    // [1] phi (byte) line#13 = (byte) 0 [phi:main->main::@1#3] -- vbuz1=vbuc1 
    sta.z line
    // main::@1
  __b1:
    // for (line=0;line<8;++line)
    // [2] if((byte) line#13<(byte) 8) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z line
    cmp #8
    bcc __b2
    // main::@return
    // }
    // [3] return 
    rts
    // main::@2
  __b2:
    // ++x;
    // [4] (byte) x#0 ← ++ (byte) x#11 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [5] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // [5] phi (byte) x#12 = (byte) x#0 [phi:main::@2->main::@3#0] -- register_copy 
    // [5] phi (byte) idx#13 = (byte) idx#1 [phi:main::@2->main::@3#1] -- register_copy 
    // [5] phi (byte) row#14 = (byte) 0 [phi:main::@2->main::@3#2] -- vbuyy=vbuc1 
    ldy #0
    // main::@3
  __b3:
    // for (row=0;row<8;++row)
    // [6] if((byte) row#14<(byte) 8) goto main::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #8
    bcc __b4
    // main::@5
    // y+=YSPACE
    // [7] (byte) y#0 ← (byte) y#1 + (const byte) YSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z y
    axs #-[YSPACE]
    stx.z y
    // for (line=0;line<8;++line)
    // [8] (byte) line#1 ← ++ (byte) line#13 -- vbuz1=_inc_vbuz1 
    inc.z line
    // [1] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
    // [1] phi (byte) y#1 = (byte) y#0 [phi:main::@5->main::@1#0] -- register_copy 
    // [1] phi (byte) idx#1 = (byte) idx#13 [phi:main::@5->main::@1#1] -- register_copy 
    // [1] phi (byte) x#11 = (byte) x#12 [phi:main::@5->main::@1#2] -- register_copy 
    // [1] phi (byte) line#13 = (byte) line#1 [phi:main::@5->main::@1#3] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // p[idx].y=y
    // [9] (byte~) main::$3 ← (byte) idx#13 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda.z idx
    asl
    tax
    // [10] *((byte*)(const struct pos*) p+(const byte) OFFSET_STRUCT_POS_Y + (byte~) main::$3) ← (byte) y#1 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z y
    sta p+OFFSET_STRUCT_POS_Y,x
    // p[idx].x=x
    // [11] *((byte*)(const struct pos*) p + (byte~) main::$3) ← (byte) x#12 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z x
    sta p,x
    // ++idx;
    // [12] (byte) idx#0 ← ++ (byte) idx#13 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // x+=XSPACE
    // [13] (byte) x#1 ← (byte) x#12 + (const byte) XSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z x
    axs #-[XSPACE]
    stx.z x
    // for (row=0;row<8;++row)
    // [14] (byte) row#1 ← ++ (byte) row#14 -- vbuyy=_inc_vbuyy 
    iny
    // [5] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
    // [5] phi (byte) x#12 = (byte) x#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [5] phi (byte) idx#13 = (byte) idx#0 [phi:main::@4->main::@3#1] -- register_copy 
    // [5] phi (byte) row#14 = (byte) row#1 [phi:main::@4->main::@3#2] -- register_copy 
    jmp __b3
}
  // File Data
  p: .fill 2*$40, 0

