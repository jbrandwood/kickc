
CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from __start
  call bool_and 
  to:main::@1
main::@1: scope:[main]  from main
  call bool_or 
  to:main::@2
main::@2: scope:[main]  from main::@1
  call bool_not 
  to:main::@3
main::@3: scope:[main]  from main::@2
  call bool_complex 
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return

(void()) bool_and()
bool_and: scope:[bool_and]  from main
  (byte) bool_and::i#0 ← (byte) 0
  to:bool_and::@1
bool_and::@1: scope:[bool_and]  from bool_and bool_and::@3
  (byte) bool_and::i#2 ← phi( bool_and/(byte) bool_and::i#0 bool_and::@3/(byte) bool_and::i#1 )
  (bool~) bool_and::$0 ← (byte) bool_and::i#2 < (number) $a
  (number~) bool_and::$1 ← (byte) bool_and::i#2 & (number) 1
  (bool~) bool_and::$2 ← (number~) bool_and::$1 == (number) 0
  (bool~) bool_and::$3 ← (bool~) bool_and::$0 && (bool~) bool_and::$2
  if((bool~) bool_and::$3) goto bool_and::@2
  to:bool_and::@4
bool_and::@2: scope:[bool_and]  from bool_and::@1
  (byte) bool_and::i#3 ← phi( bool_and::@1/(byte) bool_and::i#2 )
  *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#3) ← (byte) '*'
  to:bool_and::@3
bool_and::@4: scope:[bool_and]  from bool_and::@1
  (byte) bool_and::i#4 ← phi( bool_and::@1/(byte) bool_and::i#2 )
  *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#4) ← (byte) ' '
  to:bool_and::@3
bool_and::@3: scope:[bool_and]  from bool_and::@2 bool_and::@4
  (byte) bool_and::i#5 ← phi( bool_and::@2/(byte) bool_and::i#3 bool_and::@4/(byte) bool_and::i#4 )
  (byte) bool_and::i#1 ← (byte) bool_and::i#5 + rangenext(0,$14)
  (bool~) bool_and::$4 ← (byte) bool_and::i#1 != rangelast(0,$14)
  if((bool~) bool_and::$4) goto bool_and::@1
  to:bool_and::@return
bool_and::@return: scope:[bool_and]  from bool_and::@3
  return 
  to:@return

(void()) bool_or()
bool_or: scope:[bool_or]  from main::@1
  (byte) bool_or::i#0 ← (byte) 0
  to:bool_or::@1
bool_or::@1: scope:[bool_or]  from bool_or bool_or::@3
  (byte) bool_or::i#2 ← phi( bool_or/(byte) bool_or::i#0 bool_or::@3/(byte) bool_or::i#1 )
  (bool~) bool_or::$0 ← (byte) bool_or::i#2 < (number) $a
  (number~) bool_or::$1 ← (byte) bool_or::i#2 & (number) 1
  (bool~) bool_or::$2 ← (number~) bool_or::$1 == (number) 0
  (bool~) bool_or::$3 ← (bool~) bool_or::$0 || (bool~) bool_or::$2
  if((bool~) bool_or::$3) goto bool_or::@2
  to:bool_or::@4
bool_or::@2: scope:[bool_or]  from bool_or::@1
  (byte) bool_or::i#3 ← phi( bool_or::@1/(byte) bool_or::i#2 )
  *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#3) ← (byte) '*'
  to:bool_or::@3
bool_or::@4: scope:[bool_or]  from bool_or::@1
  (byte) bool_or::i#4 ← phi( bool_or::@1/(byte) bool_or::i#2 )
  *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#4) ← (byte) ' '
  to:bool_or::@3
bool_or::@3: scope:[bool_or]  from bool_or::@2 bool_or::@4
  (byte) bool_or::i#5 ← phi( bool_or::@2/(byte) bool_or::i#3 bool_or::@4/(byte) bool_or::i#4 )
  (byte) bool_or::i#1 ← (byte) bool_or::i#5 + rangenext(0,$14)
  (bool~) bool_or::$4 ← (byte) bool_or::i#1 != rangelast(0,$14)
  if((bool~) bool_or::$4) goto bool_or::@1
  to:bool_or::@return
bool_or::@return: scope:[bool_or]  from bool_or::@3
  return 
  to:@return

(void()) bool_not()
bool_not: scope:[bool_not]  from main::@2
  (byte) bool_not::i#0 ← (byte) 0
  to:bool_not::@1
bool_not::@1: scope:[bool_not]  from bool_not bool_not::@3
  (byte) bool_not::i#2 ← phi( bool_not/(byte) bool_not::i#0 bool_not::@3/(byte) bool_not::i#1 )
  (bool~) bool_not::$0 ← (byte) bool_not::i#2 < (number) $a
  (number~) bool_not::$1 ← (byte) bool_not::i#2 & (number) 1
  (bool~) bool_not::$2 ← (number~) bool_not::$1 == (number) 0
  (bool~) bool_not::$3 ← (bool~) bool_not::$0 || (bool~) bool_not::$2
  (bool~) bool_not::$4 ← ! (bool~) bool_not::$3
  if((bool~) bool_not::$4) goto bool_not::@2
  to:bool_not::@4
bool_not::@2: scope:[bool_not]  from bool_not::@1
  (byte) bool_not::i#3 ← phi( bool_not::@1/(byte) bool_not::i#2 )
  *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#3) ← (byte) '*'
  to:bool_not::@3
bool_not::@4: scope:[bool_not]  from bool_not::@1
  (byte) bool_not::i#4 ← phi( bool_not::@1/(byte) bool_not::i#2 )
  *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#4) ← (byte) ' '
  to:bool_not::@3
bool_not::@3: scope:[bool_not]  from bool_not::@2 bool_not::@4
  (byte) bool_not::i#5 ← phi( bool_not::@2/(byte) bool_not::i#3 bool_not::@4/(byte) bool_not::i#4 )
  (byte) bool_not::i#1 ← (byte) bool_not::i#5 + rangenext(0,$14)
  (bool~) bool_not::$5 ← (byte) bool_not::i#1 != rangelast(0,$14)
  if((bool~) bool_not::$5) goto bool_not::@1
  to:bool_not::@return
bool_not::@return: scope:[bool_not]  from bool_not::@3
  return 
  to:@return

(void()) bool_complex()
bool_complex: scope:[bool_complex]  from main::@3
  (byte) bool_complex::i#0 ← (byte) 0
  to:bool_complex::@1
bool_complex::@1: scope:[bool_complex]  from bool_complex bool_complex::@3
  (byte) bool_complex::i#2 ← phi( bool_complex/(byte) bool_complex::i#0 bool_complex::@3/(byte) bool_complex::i#1 )
  (bool~) bool_complex::$0 ← (byte) bool_complex::i#2 < (number) $a
  (number~) bool_complex::$1 ← (byte) bool_complex::i#2 & (number) 1
  (bool~) bool_complex::$2 ← (number~) bool_complex::$1 == (number) 0
  (bool~) bool_complex::$3 ← (bool~) bool_complex::$0 && (bool~) bool_complex::$2
  (bool~) bool_complex::$4 ← (byte) bool_complex::i#2 < (number) $a
  (number~) bool_complex::$5 ← (byte) bool_complex::i#2 & (number) 1
  (bool~) bool_complex::$6 ← (number~) bool_complex::$5 == (number) 0
  (bool~) bool_complex::$7 ← (bool~) bool_complex::$4 || (bool~) bool_complex::$6
  (bool~) bool_complex::$8 ← ! (bool~) bool_complex::$7
  (bool~) bool_complex::$9 ← (bool~) bool_complex::$3 || (bool~) bool_complex::$8
  if((bool~) bool_complex::$9) goto bool_complex::@2
  to:bool_complex::@4
bool_complex::@2: scope:[bool_complex]  from bool_complex::@1
  (byte) bool_complex::i#3 ← phi( bool_complex::@1/(byte) bool_complex::i#2 )
  *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#3) ← (byte) '*'
  to:bool_complex::@3
bool_complex::@4: scope:[bool_complex]  from bool_complex::@1
  (byte) bool_complex::i#4 ← phi( bool_complex::@1/(byte) bool_complex::i#2 )
  *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#4) ← (byte) ' '
  to:bool_complex::@3
bool_complex::@3: scope:[bool_complex]  from bool_complex::@2 bool_complex::@4
  (byte) bool_complex::i#5 ← phi( bool_complex::@2/(byte) bool_complex::i#3 bool_complex::@4/(byte) bool_complex::i#4 )
  (byte) bool_complex::i#1 ← (byte) bool_complex::i#5 + rangenext(0,$14)
  (bool~) bool_complex::$10 ← (byte) bool_complex::i#1 != rangelast(0,$14)
  if((bool~) bool_complex::$10) goto bool_complex::@1
  to:bool_complex::@return
bool_complex::@return: scope:[bool_complex]  from bool_complex::@3
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
(void()) __start()
(label) __start::@1
(label) __start::@return
(void()) bool_and()
(bool~) bool_and::$0
(number~) bool_and::$1
(bool~) bool_and::$2
(bool~) bool_and::$3
(bool~) bool_and::$4
(label) bool_and::@1
(label) bool_and::@2
(label) bool_and::@3
(label) bool_and::@4
(label) bool_and::@return
(byte) bool_and::i
(byte) bool_and::i#0
(byte) bool_and::i#1
(byte) bool_and::i#2
(byte) bool_and::i#3
(byte) bool_and::i#4
(byte) bool_and::i#5
(const nomodify byte*) bool_and::screen = (byte*)(number) $400
(void()) bool_complex()
(bool~) bool_complex::$0
(number~) bool_complex::$1
(bool~) bool_complex::$10
(bool~) bool_complex::$2
(bool~) bool_complex::$3
(bool~) bool_complex::$4
(number~) bool_complex::$5
(bool~) bool_complex::$6
(bool~) bool_complex::$7
(bool~) bool_complex::$8
(bool~) bool_complex::$9
(label) bool_complex::@1
(label) bool_complex::@2
(label) bool_complex::@3
(label) bool_complex::@4
(label) bool_complex::@return
(byte) bool_complex::i
(byte) bool_complex::i#0
(byte) bool_complex::i#1
(byte) bool_complex::i#2
(byte) bool_complex::i#3
(byte) bool_complex::i#4
(byte) bool_complex::i#5
(const nomodify byte*) bool_complex::screen = (byte*)(number) $478
(void()) bool_not()
(bool~) bool_not::$0
(number~) bool_not::$1
(bool~) bool_not::$2
(bool~) bool_not::$3
(bool~) bool_not::$4
(bool~) bool_not::$5
(label) bool_not::@1
(label) bool_not::@2
(label) bool_not::@3
(label) bool_not::@4
(label) bool_not::@return
(byte) bool_not::i
(byte) bool_not::i#0
(byte) bool_not::i#1
(byte) bool_not::i#2
(byte) bool_not::i#3
(byte) bool_not::i#4
(byte) bool_not::i#5
(const nomodify byte*) bool_not::screen = (byte*)(number) $450
(void()) bool_or()
(bool~) bool_or::$0
(number~) bool_or::$1
(bool~) bool_or::$2
(bool~) bool_or::$3
(bool~) bool_or::$4
(label) bool_or::@1
(label) bool_or::@2
(label) bool_or::@3
(label) bool_or::@4
(label) bool_or::@return
(byte) bool_or::i
(byte) bool_or::i#0
(byte) bool_or::i#1
(byte) bool_or::i#2
(byte) bool_or::i#3
(byte) bool_or::i#4
(byte) bool_or::i#5
(const nomodify byte*) bool_or::screen = (byte*)(number) $428
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return

Adding number conversion cast (unumber) $a in (bool~) bool_and::$0 ← (byte) bool_and::i#2 < (number) $a
Adding number conversion cast (unumber) 1 in (number~) bool_and::$1 ← (byte) bool_and::i#2 & (number) 1
Adding number conversion cast (unumber) bool_and::$1 in (number~) bool_and::$1 ← (byte) bool_and::i#2 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) bool_and::$2 ← (unumber~) bool_and::$1 == (number) 0
Adding number conversion cast (unumber) $a in (bool~) bool_or::$0 ← (byte) bool_or::i#2 < (number) $a
Adding number conversion cast (unumber) 1 in (number~) bool_or::$1 ← (byte) bool_or::i#2 & (number) 1
Adding number conversion cast (unumber) bool_or::$1 in (number~) bool_or::$1 ← (byte) bool_or::i#2 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) bool_or::$2 ← (unumber~) bool_or::$1 == (number) 0
Adding number conversion cast (unumber) $a in (bool~) bool_not::$0 ← (byte) bool_not::i#2 < (number) $a
Adding number conversion cast (unumber) 1 in (number~) bool_not::$1 ← (byte) bool_not::i#2 & (number) 1
Adding number conversion cast (unumber) bool_not::$1 in (number~) bool_not::$1 ← (byte) bool_not::i#2 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) bool_not::$2 ← (unumber~) bool_not::$1 == (number) 0
Adding number conversion cast (unumber) $a in (bool~) bool_complex::$0 ← (byte) bool_complex::i#2 < (number) $a
Adding number conversion cast (unumber) 1 in (number~) bool_complex::$1 ← (byte) bool_complex::i#2 & (number) 1
Adding number conversion cast (unumber) bool_complex::$1 in (number~) bool_complex::$1 ← (byte) bool_complex::i#2 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) bool_complex::$2 ← (unumber~) bool_complex::$1 == (number) 0
Adding number conversion cast (unumber) $a in (bool~) bool_complex::$4 ← (byte) bool_complex::i#2 < (number) $a
Adding number conversion cast (unumber) 1 in (number~) bool_complex::$5 ← (byte) bool_complex::i#2 & (number) 1
Adding number conversion cast (unumber) bool_complex::$5 in (number~) bool_complex::$5 ← (byte) bool_complex::i#2 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) bool_complex::$6 ← (unumber~) bool_complex::$5 == (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 1064
Simplifying constant pointer cast (byte*) 1104
Simplifying constant pointer cast (byte*) 1144
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) bool_and::$1 ← (byte) bool_and::i#2 & (byte) 1
Inferred type updated to byte in (unumber~) bool_or::$1 ← (byte) bool_or::i#2 & (byte) 1
Inferred type updated to byte in (unumber~) bool_not::$1 ← (byte) bool_not::i#2 & (byte) 1
Inferred type updated to byte in (unumber~) bool_complex::$1 ← (byte) bool_complex::i#2 & (byte) 1
Inferred type updated to byte in (unumber~) bool_complex::$5 ← (byte) bool_complex::i#2 & (byte) 1
Alias bool_and::i#2 = bool_and::i#3 bool_and::i#4 
Alias bool_or::i#2 = bool_or::i#3 bool_or::i#4 
Alias bool_not::i#2 = bool_not::i#3 bool_not::i#4 
Alias bool_complex::i#2 = bool_complex::i#3 bool_complex::i#4 
Successful SSA optimization Pass2AliasElimination
Alias bool_and::i#2 = bool_and::i#5 
Alias bool_or::i#2 = bool_or::i#5 
Alias bool_not::i#2 = bool_not::i#5 
Alias bool_complex::i#2 = bool_complex::i#5 
Successful SSA optimization Pass2AliasElimination
Identified duplicate assignment right side [61] (byte~) bool_complex::$5 ← (byte) bool_complex::i#2 & (byte) 1
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) bool_and::$4 [16] if((byte) bool_and::i#1!=rangelast(0,$14)) goto bool_and::@1
Simple Condition (bool~) bool_or::$4 [29] if((byte) bool_or::i#1!=rangelast(0,$14)) goto bool_or::@1
Simple Condition (bool~) bool_not::$5 [43] if((byte) bool_not::i#1!=rangelast(0,$14)) goto bool_not::@1
Simple Condition (bool~) bool_complex::$10 [62] if((byte) bool_complex::i#1!=rangelast(0,$14)) goto bool_complex::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [10] (bool~) bool_and::$3 ← (bool~) bool_and::$0 && (bool~) bool_and::$2
Rewriting || if()-condition to two if()s [23] (bool~) bool_or::$3 ← (bool~) bool_or::$0 || (bool~) bool_or::$2
Rewriting ! if()-condition to reversed if() [37] (bool~) bool_not::$4 ← ! (bool~) bool_not::$3
Rewriting || if()-condition to two if()s [36] (bool~) bool_not::$3 ← (bool~) bool_not::$0 || (bool~) bool_not::$2
Rewriting || if()-condition to two if()s [56] (bool~) bool_complex::$9 ← (bool~) bool_complex::$3 || (bool~) bool_complex::$8
Rewriting && if()-condition to two if()s [50] (bool~) bool_complex::$3 ← (bool~) bool_complex::$0 && (bool~) bool_complex::$2
Rewriting ! if()-condition to reversed if() [55] (bool~) bool_complex::$8 ← ! (bool~) bool_complex::$7
Rewriting || if()-condition to two if()s [54] (bool~) bool_complex::$7 ← (bool~) bool_complex::$4 || (bool~) bool_complex::$6
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant (const byte) bool_and::i#0 = 0
Constant (const byte) bool_or::i#0 = 0
Constant (const byte) bool_not::i#0 = 0
Constant (const byte) bool_complex::i#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [14] bool_and::i#1 ← ++ bool_and::i#2 to ++
Resolved ranged comparison value [16] if(bool_and::i#1!=rangelast(0,$14)) goto bool_and::@1 to (number) $15
Resolved ranged next value [27] bool_or::i#1 ← ++ bool_or::i#2 to ++
Resolved ranged comparison value [29] if(bool_or::i#1!=rangelast(0,$14)) goto bool_or::@1 to (number) $15
Resolved ranged next value [41] bool_not::i#1 ← ++ bool_not::i#2 to ++
Resolved ranged comparison value [43] if(bool_not::i#1!=rangelast(0,$14)) goto bool_not::@1 to (number) $15
Resolved ranged next value [60] bool_complex::i#1 ← ++ bool_complex::i#2 to ++
Resolved ranged comparison value [62] if(bool_complex::i#1!=rangelast(0,$14)) goto bool_complex::@1 to (number) $15
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) $15 in [13] if((byte) bool_and::i#1!=(number) $15) goto bool_and::@1
Adding number conversion cast (unumber) $15 in [23] if((byte) bool_or::i#1!=(number) $15) goto bool_or::@1
Adding number conversion cast (unumber) $15 in [33] if((byte) bool_not::i#1!=(number) $15) goto bool_not::@1
Adding number conversion cast (unumber) $15 in [46] if((byte) bool_complex::i#1!=(number) $15) goto bool_complex::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $15
Simplifying constant integer cast $15
Simplifying constant integer cast $15
Simplifying constant integer cast $15
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) $15
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias bool_complex::$5 = bool_complex::$1 
Successful SSA optimization Pass2AliasElimination
Simple Condition (bool~) bool_and::$0 [9] if((byte) bool_and::i#2<(byte) $a) goto bool_and::@5
Simple Condition (bool~) bool_or::$0 [19] if((byte) bool_or::i#2<(byte) $a) goto bool_or::@2
Simple Condition (bool~) bool_not::$0 [29] if((byte) bool_not::i#2<(byte) $a) goto bool_not::@4
Simple Condition (bool~) bool_complex::$0 [41] if((byte) bool_complex::i#2<(byte) $a) goto bool_complex::@6
Simple Condition (bool~) bool_and::$2 [47] if((byte~) bool_and::$1==(byte) 0) goto bool_and::@2
Simple Condition (bool~) bool_or::$2 [48] if((byte~) bool_or::$1==(byte) 0) goto bool_or::@2
Simple Condition (bool~) bool_not::$2 [49] if((byte~) bool_not::$1==(byte) 0) goto bool_not::@4
Simple Condition (bool~) bool_complex::$4 [50] if((byte) bool_complex::i#2<(byte) $a) goto bool_complex::@4
Simple Condition (bool~) bool_complex::$2 [51] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@2
Simple Condition (bool~) bool_complex::$6 [52] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [9] if((byte) bool_and::i#2>=(byte) $a) goto bool_and::@4
Negating conditional jump and destination [41] if((byte) bool_complex::i#2>=(byte) $a) goto bool_complex::@5
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Inlining constant with var siblings (const byte) bool_and::i#0
Inlining constant with var siblings (const byte) bool_or::i#0
Inlining constant with var siblings (const byte) bool_not::i#0
Inlining constant with var siblings (const byte) bool_complex::i#0
Constant inlined bool_complex::i#0 = (byte) 0
Constant inlined bool_or::i#0 = (byte) 0
Constant inlined bool_not::i#0 = (byte) 0
Constant inlined bool_and::i#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting bool_and::@6(between bool_and::@3 and bool_and::@1)
Added new block during phi lifting bool_or::@6(between bool_or::@3 and bool_or::@1)
Added new block during phi lifting bool_not::@6(between bool_not::@3 and bool_not::@1)
Added new block during phi lifting bool_complex::@8(between bool_complex::@3 and bool_complex::@1)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of bool_and
Adding NOP phi() at start of bool_or
Adding NOP phi() at start of bool_not
Adding NOP phi() at start of bool_complex
CALL GRAPH
Calls in [main] to bool_and:1 bool_or:3 bool_not:5 bool_complex:7 

Created 4 initial phi equivalence classes
Coalesced [19] bool_and::i#6 ← bool_and::i#1
Coalesced [30] bool_or::i#6 ← bool_or::i#1
Coalesced [41] bool_not::i#6 ← bool_not::i#1
Coalesced [54] bool_complex::i#6 ← bool_complex::i#1
Coalesced down to 4 phi equivalence classes
Culled Empty Block (label) main::@4
Culled Empty Block (label) bool_and::@6
Culled Empty Block (label) bool_or::@6
Culled Empty Block (label) bool_not::@6
Culled Empty Block (label) bool_complex::@8
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of bool_and
Adding NOP phi() at start of bool_or
Adding NOP phi() at start of bool_not
Adding NOP phi() at start of bool_complex

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call bool_and 
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call bool_or 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] phi()
  [5] call bool_not 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [6] phi()
  [7] call bool_complex 
  to:main::@return
main::@return: scope:[main]  from main::@3
  [8] return 
  to:@return

(void()) bool_and()
bool_and: scope:[bool_and]  from main
  [9] phi()
  to:bool_and::@1
bool_and::@1: scope:[bool_and]  from bool_and bool_and::@3
  [10] (byte) bool_and::i#2 ← phi( bool_and/(byte) 0 bool_and::@3/(byte) bool_and::i#1 )
  [11] (byte~) bool_and::$1 ← (byte) bool_and::i#2 & (byte) 1
  [12] if((byte) bool_and::i#2>=(byte) $a) goto bool_and::@4
  to:bool_and::@5
bool_and::@5: scope:[bool_and]  from bool_and::@1
  [13] if((byte~) bool_and::$1==(byte) 0) goto bool_and::@2
  to:bool_and::@4
bool_and::@4: scope:[bool_and]  from bool_and::@1 bool_and::@5
  [14] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) ' '
  to:bool_and::@3
bool_and::@3: scope:[bool_and]  from bool_and::@2 bool_and::@4
  [15] (byte) bool_and::i#1 ← ++ (byte) bool_and::i#2
  [16] if((byte) bool_and::i#1!=(byte) $15) goto bool_and::@1
  to:bool_and::@return
bool_and::@return: scope:[bool_and]  from bool_and::@3
  [17] return 
  to:@return
bool_and::@2: scope:[bool_and]  from bool_and::@5
  [18] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) '*'
  to:bool_and::@3

(void()) bool_or()
bool_or: scope:[bool_or]  from main::@1
  [19] phi()
  to:bool_or::@1
bool_or::@1: scope:[bool_or]  from bool_or bool_or::@3
  [20] (byte) bool_or::i#2 ← phi( bool_or/(byte) 0 bool_or::@3/(byte) bool_or::i#1 )
  [21] (byte~) bool_or::$1 ← (byte) bool_or::i#2 & (byte) 1
  [22] if((byte) bool_or::i#2<(byte) $a) goto bool_or::@2
  to:bool_or::@5
bool_or::@5: scope:[bool_or]  from bool_or::@1
  [23] if((byte~) bool_or::$1==(byte) 0) goto bool_or::@2
  to:bool_or::@4
bool_or::@4: scope:[bool_or]  from bool_or::@5
  [24] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) ' '
  to:bool_or::@3
bool_or::@3: scope:[bool_or]  from bool_or::@2 bool_or::@4
  [25] (byte) bool_or::i#1 ← ++ (byte) bool_or::i#2
  [26] if((byte) bool_or::i#1!=(byte) $15) goto bool_or::@1
  to:bool_or::@return
bool_or::@return: scope:[bool_or]  from bool_or::@3
  [27] return 
  to:@return
bool_or::@2: scope:[bool_or]  from bool_or::@1 bool_or::@5
  [28] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) '*'
  to:bool_or::@3

(void()) bool_not()
bool_not: scope:[bool_not]  from main::@2
  [29] phi()
  to:bool_not::@1
bool_not::@1: scope:[bool_not]  from bool_not bool_not::@3
  [30] (byte) bool_not::i#2 ← phi( bool_not/(byte) 0 bool_not::@3/(byte) bool_not::i#1 )
  [31] (byte~) bool_not::$1 ← (byte) bool_not::i#2 & (byte) 1
  [32] if((byte) bool_not::i#2<(byte) $a) goto bool_not::@4
  to:bool_not::@5
bool_not::@5: scope:[bool_not]  from bool_not::@1
  [33] if((byte~) bool_not::$1==(byte) 0) goto bool_not::@4
  to:bool_not::@2
bool_not::@2: scope:[bool_not]  from bool_not::@5
  [34] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) '*'
  to:bool_not::@3
bool_not::@3: scope:[bool_not]  from bool_not::@2 bool_not::@4
  [35] (byte) bool_not::i#1 ← ++ (byte) bool_not::i#2
  [36] if((byte) bool_not::i#1!=(byte) $15) goto bool_not::@1
  to:bool_not::@return
bool_not::@return: scope:[bool_not]  from bool_not::@3
  [37] return 
  to:@return
bool_not::@4: scope:[bool_not]  from bool_not::@1 bool_not::@5
  [38] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) ' '
  to:bool_not::@3

(void()) bool_complex()
bool_complex: scope:[bool_complex]  from main::@3
  [39] phi()
  to:bool_complex::@1
bool_complex::@1: scope:[bool_complex]  from bool_complex bool_complex::@3
  [40] (byte) bool_complex::i#2 ← phi( bool_complex/(byte) 0 bool_complex::@3/(byte) bool_complex::i#1 )
  [41] (byte~) bool_complex::$5 ← (byte) bool_complex::i#2 & (byte) 1
  [42] if((byte) bool_complex::i#2>=(byte) $a) goto bool_complex::@5
  to:bool_complex::@6
bool_complex::@6: scope:[bool_complex]  from bool_complex::@1
  [43] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@2
  to:bool_complex::@5
bool_complex::@5: scope:[bool_complex]  from bool_complex::@1 bool_complex::@6
  [44] if((byte) bool_complex::i#2<(byte) $a) goto bool_complex::@4
  to:bool_complex::@7
bool_complex::@7: scope:[bool_complex]  from bool_complex::@5
  [45] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@4
  to:bool_complex::@2
bool_complex::@2: scope:[bool_complex]  from bool_complex::@6 bool_complex::@7
  [46] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) '*'
  to:bool_complex::@3
bool_complex::@3: scope:[bool_complex]  from bool_complex::@2 bool_complex::@4
  [47] (byte) bool_complex::i#1 ← ++ (byte) bool_complex::i#2
  [48] if((byte) bool_complex::i#1!=(byte) $15) goto bool_complex::@1
  to:bool_complex::@return
bool_complex::@return: scope:[bool_complex]  from bool_complex::@3
  [49] return 
  to:@return
bool_complex::@4: scope:[bool_complex]  from bool_complex::@5 bool_complex::@7
  [50] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) ' '
  to:bool_complex::@3


VARIABLE REGISTER WEIGHTS
(void()) bool_and()
(byte~) bool_and::$1 101.0
(byte) bool_and::i
(byte) bool_and::i#1 151.5
(byte) bool_and::i#2 100.99999999999999
(void()) bool_complex()
(byte~) bool_complex::$5 75.75
(byte) bool_complex::i
(byte) bool_complex::i#1 151.5
(byte) bool_complex::i#2 88.375
(void()) bool_not()
(byte~) bool_not::$1 101.0
(byte) bool_not::i
(byte) bool_not::i#1 151.5
(byte) bool_not::i#2 100.99999999999999
(void()) bool_or()
(byte~) bool_or::$1 101.0
(byte) bool_or::i
(byte) bool_or::i#1 151.5
(byte) bool_or::i#2 100.99999999999999
(void()) main()

Initial phi equivalence classes
[ bool_and::i#2 bool_and::i#1 ]
[ bool_or::i#2 bool_or::i#1 ]
[ bool_not::i#2 bool_not::i#1 ]
[ bool_complex::i#2 bool_complex::i#1 ]
Added variable bool_and::$1 to live range equivalence class [ bool_and::$1 ]
Added variable bool_or::$1 to live range equivalence class [ bool_or::$1 ]
Added variable bool_not::$1 to live range equivalence class [ bool_not::$1 ]
Added variable bool_complex::$5 to live range equivalence class [ bool_complex::$5 ]
Complete equivalence classes
[ bool_and::i#2 bool_and::i#1 ]
[ bool_or::i#2 bool_or::i#1 ]
[ bool_not::i#2 bool_not::i#1 ]
[ bool_complex::i#2 bool_complex::i#1 ]
[ bool_and::$1 ]
[ bool_or::$1 ]
[ bool_not::$1 ]
[ bool_complex::$5 ]
Allocated zp[1]:2 [ bool_and::i#2 bool_and::i#1 ]
Allocated zp[1]:3 [ bool_or::i#2 bool_or::i#1 ]
Allocated zp[1]:4 [ bool_not::i#2 bool_not::i#1 ]
Allocated zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ]
Allocated zp[1]:6 [ bool_and::$1 ]
Allocated zp[1]:7 [ bool_or::$1 ]
Allocated zp[1]:8 [ bool_not::$1 ]
Allocated zp[1]:9 [ bool_complex::$5 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// A test of boolean conditions using && || and !
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // main
main: {
    // [1] call bool_and 
    // [9] phi from main to bool_and [phi:main->bool_and]
  bool_and_from_main:
    jsr bool_and
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call bool_or 
    // [19] phi from main::@1 to bool_or [phi:main::@1->bool_or]
  bool_or_from___b1:
    jsr bool_or
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [5] call bool_not 
    // [29] phi from main::@2 to bool_not [phi:main::@2->bool_not]
  bool_not_from___b2:
    jsr bool_not
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [7] call bool_complex 
    // [39] phi from main::@3 to bool_complex [phi:main::@3->bool_complex]
  bool_complex_from___b3:
    jsr bool_complex
    jmp __breturn
    // main::@return
  __breturn:
    // [8] return 
    rts
}
  // bool_and
bool_and: {
    .label screen = $400
    .label __1 = 6
    .label i = 2
    // [10] phi from bool_and to bool_and::@1 [phi:bool_and->bool_and::@1]
  __b1_from_bool_and:
    // [10] phi (byte) bool_and::i#2 = (byte) 0 [phi:bool_and->bool_and::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [10] phi from bool_and::@3 to bool_and::@1 [phi:bool_and::@3->bool_and::@1]
  __b1_from___b3:
    // [10] phi (byte) bool_and::i#2 = (byte) bool_and::i#1 [phi:bool_and::@3->bool_and::@1#0] -- register_copy 
    jmp __b1
    // bool_and::@1
  __b1:
    // [11] (byte~) bool_and::$1 ← (byte) bool_and::i#2 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and.z i
    sta.z __1
    // [12] if((byte) bool_and::i#2>=(byte) $a) goto bool_and::@4 -- vbuz1_ge_vbuc1_then_la1 
    lda.z i
    cmp #$a
    bcs __b4
    jmp __b5
    // bool_and::@5
  __b5:
    // [13] if((byte~) bool_and::$1==(byte) 0) goto bool_and::@2 -- vbuz1_eq_0_then_la1 
    lda.z __1
    cmp #0
    beq __b2
    jmp __b4
    // bool_and::@4
  __b4:
    // [14] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #' '
    ldy.z i
    sta screen,y
    jmp __b3
    // bool_and::@3
  __b3:
    // [15] (byte) bool_and::i#1 ← ++ (byte) bool_and::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [16] if((byte) bool_and::i#1!=(byte) $15) goto bool_and::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$15
    cmp.z i
    bne __b1_from___b3
    jmp __breturn
    // bool_and::@return
  __breturn:
    // [17] return 
    rts
    // bool_and::@2
  __b2:
    // [18] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #'*'
    ldy.z i
    sta screen,y
    jmp __b3
}
  // bool_or
bool_or: {
    .label screen = $428
    .label __1 = 7
    .label i = 3
    // [20] phi from bool_or to bool_or::@1 [phi:bool_or->bool_or::@1]
  __b1_from_bool_or:
    // [20] phi (byte) bool_or::i#2 = (byte) 0 [phi:bool_or->bool_or::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [20] phi from bool_or::@3 to bool_or::@1 [phi:bool_or::@3->bool_or::@1]
  __b1_from___b3:
    // [20] phi (byte) bool_or::i#2 = (byte) bool_or::i#1 [phi:bool_or::@3->bool_or::@1#0] -- register_copy 
    jmp __b1
    // bool_or::@1
  __b1:
    // [21] (byte~) bool_or::$1 ← (byte) bool_or::i#2 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and.z i
    sta.z __1
    // [22] if((byte) bool_or::i#2<(byte) $a) goto bool_or::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #$a
    bcc __b2
    jmp __b5
    // bool_or::@5
  __b5:
    // [23] if((byte~) bool_or::$1==(byte) 0) goto bool_or::@2 -- vbuz1_eq_0_then_la1 
    lda.z __1
    cmp #0
    beq __b2
    jmp __b4
    // bool_or::@4
  __b4:
    // [24] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #' '
    ldy.z i
    sta screen,y
    jmp __b3
    // bool_or::@3
  __b3:
    // [25] (byte) bool_or::i#1 ← ++ (byte) bool_or::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [26] if((byte) bool_or::i#1!=(byte) $15) goto bool_or::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$15
    cmp.z i
    bne __b1_from___b3
    jmp __breturn
    // bool_or::@return
  __breturn:
    // [27] return 
    rts
    // bool_or::@2
  __b2:
    // [28] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #'*'
    ldy.z i
    sta screen,y
    jmp __b3
}
  // bool_not
bool_not: {
    .label screen = $450
    .label __1 = 8
    .label i = 4
    // [30] phi from bool_not to bool_not::@1 [phi:bool_not->bool_not::@1]
  __b1_from_bool_not:
    // [30] phi (byte) bool_not::i#2 = (byte) 0 [phi:bool_not->bool_not::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [30] phi from bool_not::@3 to bool_not::@1 [phi:bool_not::@3->bool_not::@1]
  __b1_from___b3:
    // [30] phi (byte) bool_not::i#2 = (byte) bool_not::i#1 [phi:bool_not::@3->bool_not::@1#0] -- register_copy 
    jmp __b1
    // bool_not::@1
  __b1:
    // [31] (byte~) bool_not::$1 ← (byte) bool_not::i#2 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and.z i
    sta.z __1
    // [32] if((byte) bool_not::i#2<(byte) $a) goto bool_not::@4 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #$a
    bcc __b4
    jmp __b5
    // bool_not::@5
  __b5:
    // [33] if((byte~) bool_not::$1==(byte) 0) goto bool_not::@4 -- vbuz1_eq_0_then_la1 
    lda.z __1
    cmp #0
    beq __b4
    jmp __b2
    // bool_not::@2
  __b2:
    // [34] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #'*'
    ldy.z i
    sta screen,y
    jmp __b3
    // bool_not::@3
  __b3:
    // [35] (byte) bool_not::i#1 ← ++ (byte) bool_not::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [36] if((byte) bool_not::i#1!=(byte) $15) goto bool_not::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$15
    cmp.z i
    bne __b1_from___b3
    jmp __breturn
    // bool_not::@return
  __breturn:
    // [37] return 
    rts
    // bool_not::@4
  __b4:
    // [38] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #' '
    ldy.z i
    sta screen,y
    jmp __b3
}
  // bool_complex
bool_complex: {
    .label screen = $478
    .label __5 = 9
    .label i = 5
    // [40] phi from bool_complex to bool_complex::@1 [phi:bool_complex->bool_complex::@1]
  __b1_from_bool_complex:
    // [40] phi (byte) bool_complex::i#2 = (byte) 0 [phi:bool_complex->bool_complex::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [40] phi from bool_complex::@3 to bool_complex::@1 [phi:bool_complex::@3->bool_complex::@1]
  __b1_from___b3:
    // [40] phi (byte) bool_complex::i#2 = (byte) bool_complex::i#1 [phi:bool_complex::@3->bool_complex::@1#0] -- register_copy 
    jmp __b1
    // bool_complex::@1
  __b1:
    // [41] (byte~) bool_complex::$5 ← (byte) bool_complex::i#2 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and.z i
    sta.z __5
    // [42] if((byte) bool_complex::i#2>=(byte) $a) goto bool_complex::@5 -- vbuz1_ge_vbuc1_then_la1 
    lda.z i
    cmp #$a
    bcs __b5
    jmp __b6
    // bool_complex::@6
  __b6:
    // [43] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@2 -- vbuz1_eq_0_then_la1 
    lda.z __5
    cmp #0
    beq __b2
    jmp __b5
    // bool_complex::@5
  __b5:
    // [44] if((byte) bool_complex::i#2<(byte) $a) goto bool_complex::@4 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #$a
    bcc __b4
    jmp __b7
    // bool_complex::@7
  __b7:
    // [45] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@4 -- vbuz1_eq_0_then_la1 
    lda.z __5
    cmp #0
    beq __b4
    jmp __b2
    // bool_complex::@2
  __b2:
    // [46] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #'*'
    ldy.z i
    sta screen,y
    jmp __b3
    // bool_complex::@3
  __b3:
    // [47] (byte) bool_complex::i#1 ← ++ (byte) bool_complex::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [48] if((byte) bool_complex::i#1!=(byte) $15) goto bool_complex::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$15
    cmp.z i
    bne __b1_from___b3
    jmp __breturn
    // bool_complex::@return
  __breturn:
    // [49] return 
    rts
    // bool_complex::@4
  __b4:
    // [50] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #' '
    ldy.z i
    sta screen,y
    jmp __b3
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [14] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) ' ' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ bool_and::i#2 bool_and::i#1 ]
Statement [18] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) '*' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Statement [24] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) ' ' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:3 [ bool_or::i#2 bool_or::i#1 ]
Statement [28] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) '*' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Statement [34] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) '*' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ bool_not::i#2 bool_not::i#1 ]
Statement [38] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) ' ' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Statement [46] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) '*' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ]
Statement [50] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) ' ' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Statement [11] (byte~) bool_and::$1 ← (byte) bool_and::i#2 & (byte) 1 [ bool_and::i#2 bool_and::$1 ] ( bool_and:1 [ bool_and::i#2 bool_and::$1 ] { }  ) always clobbers reg byte a 
Statement [14] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) ' ' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Statement [18] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) '*' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Statement [21] (byte~) bool_or::$1 ← (byte) bool_or::i#2 & (byte) 1 [ bool_or::i#2 bool_or::$1 ] ( bool_or:3 [ bool_or::i#2 bool_or::$1 ] { }  ) always clobbers reg byte a 
Statement [24] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) ' ' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Statement [28] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) '*' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Statement [31] (byte~) bool_not::$1 ← (byte) bool_not::i#2 & (byte) 1 [ bool_not::i#2 bool_not::$1 ] ( bool_not:5 [ bool_not::i#2 bool_not::$1 ] { }  ) always clobbers reg byte a 
Statement [34] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) '*' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Statement [38] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) ' ' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Statement [41] (byte~) bool_complex::$5 ← (byte) bool_complex::i#2 & (byte) 1 [ bool_complex::i#2 bool_complex::$5 ] ( bool_complex:7 [ bool_complex::i#2 bool_complex::$5 ] { }  ) always clobbers reg byte a 
Statement [46] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) '*' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Statement [50] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) ' ' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ bool_and::i#2 bool_and::i#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ bool_or::i#2 bool_or::i#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ bool_not::i#2 bool_not::i#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ bool_and::$1 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ bool_or::$1 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ bool_not::$1 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ bool_complex::$5 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [bool_and] 252.5: zp[1]:2 [ bool_and::i#2 bool_and::i#1 ] 101: zp[1]:6 [ bool_and::$1 ] 
Uplift Scope [bool_or] 252.5: zp[1]:3 [ bool_or::i#2 bool_or::i#1 ] 101: zp[1]:7 [ bool_or::$1 ] 
Uplift Scope [bool_not] 252.5: zp[1]:4 [ bool_not::i#2 bool_not::i#1 ] 101: zp[1]:8 [ bool_not::$1 ] 
Uplift Scope [bool_complex] 239.88: zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ] 75.75: zp[1]:9 [ bool_complex::$5 ] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [bool_and] best 3286 combination reg byte x [ bool_and::i#2 bool_and::i#1 ] reg byte a [ bool_and::$1 ] 
Uplifting [bool_or] best 3036 combination reg byte x [ bool_or::i#2 bool_or::i#1 ] reg byte a [ bool_or::$1 ] 
Uplifting [bool_not] best 2786 combination reg byte x [ bool_not::i#2 bool_not::i#1 ] reg byte a [ bool_not::$1 ] 
Uplifting [bool_complex] best 2476 combination reg byte x [ bool_complex::i#2 bool_complex::i#1 ] reg byte a [ bool_complex::$5 ] 
Uplifting [main] best 2476 combination 
Uplifting [] best 2476 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// A test of boolean conditions using && || and !
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // main
main: {
    // [1] call bool_and 
    // [9] phi from main to bool_and [phi:main->bool_and]
  bool_and_from_main:
    jsr bool_and
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call bool_or 
    // [19] phi from main::@1 to bool_or [phi:main::@1->bool_or]
  bool_or_from___b1:
    jsr bool_or
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [5] call bool_not 
    // [29] phi from main::@2 to bool_not [phi:main::@2->bool_not]
  bool_not_from___b2:
    jsr bool_not
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [7] call bool_complex 
    // [39] phi from main::@3 to bool_complex [phi:main::@3->bool_complex]
  bool_complex_from___b3:
    jsr bool_complex
    jmp __breturn
    // main::@return
  __breturn:
    // [8] return 
    rts
}
  // bool_and
bool_and: {
    .label screen = $400
    // [10] phi from bool_and to bool_and::@1 [phi:bool_and->bool_and::@1]
  __b1_from_bool_and:
    // [10] phi (byte) bool_and::i#2 = (byte) 0 [phi:bool_and->bool_and::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [10] phi from bool_and::@3 to bool_and::@1 [phi:bool_and::@3->bool_and::@1]
  __b1_from___b3:
    // [10] phi (byte) bool_and::i#2 = (byte) bool_and::i#1 [phi:bool_and::@3->bool_and::@1#0] -- register_copy 
    jmp __b1
    // bool_and::@1
  __b1:
    // [11] (byte~) bool_and::$1 ← (byte) bool_and::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [12] if((byte) bool_and::i#2>=(byte) $a) goto bool_and::@4 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b4
    jmp __b5
    // bool_and::@5
  __b5:
    // [13] if((byte~) bool_and::$1==(byte) 0) goto bool_and::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    jmp __b4
    // bool_and::@4
  __b4:
    // [14] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
    // bool_and::@3
  __b3:
    // [15] (byte) bool_and::i#1 ← ++ (byte) bool_and::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [16] if((byte) bool_and::i#1!=(byte) $15) goto bool_and::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_and::@return
  __breturn:
    // [17] return 
    rts
    // bool_and::@2
  __b2:
    // [18] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_or
bool_or: {
    .label screen = $428
    // [20] phi from bool_or to bool_or::@1 [phi:bool_or->bool_or::@1]
  __b1_from_bool_or:
    // [20] phi (byte) bool_or::i#2 = (byte) 0 [phi:bool_or->bool_or::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [20] phi from bool_or::@3 to bool_or::@1 [phi:bool_or::@3->bool_or::@1]
  __b1_from___b3:
    // [20] phi (byte) bool_or::i#2 = (byte) bool_or::i#1 [phi:bool_or::@3->bool_or::@1#0] -- register_copy 
    jmp __b1
    // bool_or::@1
  __b1:
    // [21] (byte~) bool_or::$1 ← (byte) bool_or::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [22] if((byte) bool_or::i#2<(byte) $a) goto bool_or::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b2
    jmp __b5
    // bool_or::@5
  __b5:
    // [23] if((byte~) bool_or::$1==(byte) 0) goto bool_or::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    jmp __b4
    // bool_or::@4
  __b4:
    // [24] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
    // bool_or::@3
  __b3:
    // [25] (byte) bool_or::i#1 ← ++ (byte) bool_or::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [26] if((byte) bool_or::i#1!=(byte) $15) goto bool_or::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_or::@return
  __breturn:
    // [27] return 
    rts
    // bool_or::@2
  __b2:
    // [28] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_not
bool_not: {
    .label screen = $450
    // [30] phi from bool_not to bool_not::@1 [phi:bool_not->bool_not::@1]
  __b1_from_bool_not:
    // [30] phi (byte) bool_not::i#2 = (byte) 0 [phi:bool_not->bool_not::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [30] phi from bool_not::@3 to bool_not::@1 [phi:bool_not::@3->bool_not::@1]
  __b1_from___b3:
    // [30] phi (byte) bool_not::i#2 = (byte) bool_not::i#1 [phi:bool_not::@3->bool_not::@1#0] -- register_copy 
    jmp __b1
    // bool_not::@1
  __b1:
    // [31] (byte~) bool_not::$1 ← (byte) bool_not::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [32] if((byte) bool_not::i#2<(byte) $a) goto bool_not::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    jmp __b5
    // bool_not::@5
  __b5:
    // [33] if((byte~) bool_not::$1==(byte) 0) goto bool_not::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    jmp __b2
    // bool_not::@2
  __b2:
    // [34] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
    // bool_not::@3
  __b3:
    // [35] (byte) bool_not::i#1 ← ++ (byte) bool_not::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] if((byte) bool_not::i#1!=(byte) $15) goto bool_not::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_not::@return
  __breturn:
    // [37] return 
    rts
    // bool_not::@4
  __b4:
    // [38] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // bool_complex
bool_complex: {
    .label screen = $478
    // [40] phi from bool_complex to bool_complex::@1 [phi:bool_complex->bool_complex::@1]
  __b1_from_bool_complex:
    // [40] phi (byte) bool_complex::i#2 = (byte) 0 [phi:bool_complex->bool_complex::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [40] phi from bool_complex::@3 to bool_complex::@1 [phi:bool_complex::@3->bool_complex::@1]
  __b1_from___b3:
    // [40] phi (byte) bool_complex::i#2 = (byte) bool_complex::i#1 [phi:bool_complex::@3->bool_complex::@1#0] -- register_copy 
    jmp __b1
    // bool_complex::@1
  __b1:
    // [41] (byte~) bool_complex::$5 ← (byte) bool_complex::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [42] if((byte) bool_complex::i#2>=(byte) $a) goto bool_complex::@5 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b5
    jmp __b6
    // bool_complex::@6
  __b6:
    // [43] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    jmp __b5
    // bool_complex::@5
  __b5:
    // [44] if((byte) bool_complex::i#2<(byte) $a) goto bool_complex::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    jmp __b7
    // bool_complex::@7
  __b7:
    // [45] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    jmp __b2
    // bool_complex::@2
  __b2:
    // [46] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
    // bool_complex::@3
  __b3:
    // [47] (byte) bool_complex::i#1 ← ++ (byte) bool_complex::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [48] if((byte) bool_complex::i#1!=(byte) $15) goto bool_complex::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_complex::@return
  __breturn:
    // [49] return 
    rts
    // bool_complex::@4
  __b4:
    // [50] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b6
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Removing instruction __b1_from_main:
Removing instruction bool_or_from___b1:
Removing instruction __b2_from___b1:
Removing instruction bool_not_from___b2:
Removing instruction __b3_from___b2:
Removing instruction bool_complex_from___b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bool_and_from_main:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from_bool_and:
Removing instruction __b5:
Removing instruction __breturn:
Removing instruction __b1_from_bool_or:
Removing instruction __b5:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __b1_from_bool_not:
Removing instruction __b5:
Removing instruction __b2:
Removing instruction __breturn:
Removing instruction __b1_from_bool_complex:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
(void()) bool_and()
(byte~) bool_and::$1 reg byte a 101.0
(label) bool_and::@1
(label) bool_and::@2
(label) bool_and::@3
(label) bool_and::@4
(label) bool_and::@5
(label) bool_and::@return
(byte) bool_and::i
(byte) bool_and::i#1 reg byte x 151.5
(byte) bool_and::i#2 reg byte x 100.99999999999999
(const nomodify byte*) bool_and::screen = (byte*) 1024
(void()) bool_complex()
(byte~) bool_complex::$5 reg byte a 75.75
(label) bool_complex::@1
(label) bool_complex::@2
(label) bool_complex::@3
(label) bool_complex::@4
(label) bool_complex::@5
(label) bool_complex::@6
(label) bool_complex::@7
(label) bool_complex::@return
(byte) bool_complex::i
(byte) bool_complex::i#1 reg byte x 151.5
(byte) bool_complex::i#2 reg byte x 88.375
(const nomodify byte*) bool_complex::screen = (byte*) 1144
(void()) bool_not()
(byte~) bool_not::$1 reg byte a 101.0
(label) bool_not::@1
(label) bool_not::@2
(label) bool_not::@3
(label) bool_not::@4
(label) bool_not::@5
(label) bool_not::@return
(byte) bool_not::i
(byte) bool_not::i#1 reg byte x 151.5
(byte) bool_not::i#2 reg byte x 100.99999999999999
(const nomodify byte*) bool_not::screen = (byte*) 1104
(void()) bool_or()
(byte~) bool_or::$1 reg byte a 101.0
(label) bool_or::@1
(label) bool_or::@2
(label) bool_or::@3
(label) bool_or::@4
(label) bool_or::@5
(label) bool_or::@return
(byte) bool_or::i
(byte) bool_or::i#1 reg byte x 151.5
(byte) bool_or::i#2 reg byte x 100.99999999999999
(const nomodify byte*) bool_or::screen = (byte*) 1064
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return

reg byte x [ bool_and::i#2 bool_and::i#1 ]
reg byte x [ bool_or::i#2 bool_or::i#1 ]
reg byte x [ bool_not::i#2 bool_not::i#1 ]
reg byte x [ bool_complex::i#2 bool_complex::i#1 ]
reg byte a [ bool_and::$1 ]
reg byte a [ bool_or::$1 ]
reg byte a [ bool_not::$1 ]
reg byte a [ bool_complex::$5 ]


FINAL ASSEMBLER
Score: 1684

  // File Comments
// A test of boolean conditions using && || and !
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // main
main: {
    // bool_and()
    // [1] call bool_and 
    // [9] phi from main to bool_and [phi:main->bool_and]
    jsr bool_and
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // bool_or()
    // [3] call bool_or 
    // [19] phi from main::@1 to bool_or [phi:main::@1->bool_or]
    jsr bool_or
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // bool_not()
    // [5] call bool_not 
    // [29] phi from main::@2 to bool_not [phi:main::@2->bool_not]
    jsr bool_not
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // main::@3
    // bool_complex()
    // [7] call bool_complex 
    // [39] phi from main::@3 to bool_complex [phi:main::@3->bool_complex]
    jsr bool_complex
    // main::@return
    // }
    // [8] return 
    rts
}
  // bool_and
bool_and: {
    .label screen = $400
    // [10] phi from bool_and to bool_and::@1 [phi:bool_and->bool_and::@1]
    // [10] phi (byte) bool_and::i#2 = (byte) 0 [phi:bool_and->bool_and::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [10] phi from bool_and::@3 to bool_and::@1 [phi:bool_and::@3->bool_and::@1]
    // [10] phi (byte) bool_and::i#2 = (byte) bool_and::i#1 [phi:bool_and::@3->bool_and::@1#0] -- register_copy 
    // bool_and::@1
  __b1:
    // i&1
    // [11] (byte~) bool_and::$1 ← (byte) bool_and::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if( (i<10) && ((i&1)==0) )
    // [12] if((byte) bool_and::i#2>=(byte) $a) goto bool_and::@4 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b4
    // bool_and::@5
    // [13] if((byte~) bool_and::$1==(byte) 0) goto bool_and::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // bool_and::@4
  __b4:
    // screen[i] = ' '
    // [14] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    // bool_and::@3
  __b3:
    // for( byte i : 0..20)
    // [15] (byte) bool_and::i#1 ← ++ (byte) bool_and::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [16] if((byte) bool_and::i#1!=(byte) $15) goto bool_and::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_and::@return
    // }
    // [17] return 
    rts
    // bool_and::@2
  __b2:
    // screen[i] = '*'
    // [18] *((const nomodify byte*) bool_and::screen + (byte) bool_and::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_or
bool_or: {
    .label screen = $428
    // [20] phi from bool_or to bool_or::@1 [phi:bool_or->bool_or::@1]
    // [20] phi (byte) bool_or::i#2 = (byte) 0 [phi:bool_or->bool_or::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [20] phi from bool_or::@3 to bool_or::@1 [phi:bool_or::@3->bool_or::@1]
    // [20] phi (byte) bool_or::i#2 = (byte) bool_or::i#1 [phi:bool_or::@3->bool_or::@1#0] -- register_copy 
    // bool_or::@1
  __b1:
    // i&1
    // [21] (byte~) bool_or::$1 ← (byte) bool_or::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if( (i<10) || ((i&1)==0) )
    // [22] if((byte) bool_or::i#2<(byte) $a) goto bool_or::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b2
    // bool_or::@5
    // [23] if((byte~) bool_or::$1==(byte) 0) goto bool_or::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // bool_or::@4
    // screen[i] = ' '
    // [24] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    // bool_or::@3
  __b3:
    // for( byte i : 0..20)
    // [25] (byte) bool_or::i#1 ← ++ (byte) bool_or::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [26] if((byte) bool_or::i#1!=(byte) $15) goto bool_or::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_or::@return
    // }
    // [27] return 
    rts
    // bool_or::@2
  __b2:
    // screen[i] = '*'
    // [28] *((const nomodify byte*) bool_or::screen + (byte) bool_or::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_not
bool_not: {
    .label screen = $450
    // [30] phi from bool_not to bool_not::@1 [phi:bool_not->bool_not::@1]
    // [30] phi (byte) bool_not::i#2 = (byte) 0 [phi:bool_not->bool_not::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [30] phi from bool_not::@3 to bool_not::@1 [phi:bool_not::@3->bool_not::@1]
    // [30] phi (byte) bool_not::i#2 = (byte) bool_not::i#1 [phi:bool_not::@3->bool_not::@1#0] -- register_copy 
    // bool_not::@1
  __b1:
    // i&1
    // [31] (byte~) bool_not::$1 ← (byte) bool_not::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if( !((i<10) || (i&1)==0))
    // [32] if((byte) bool_not::i#2<(byte) $a) goto bool_not::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    // bool_not::@5
    // [33] if((byte~) bool_not::$1==(byte) 0) goto bool_not::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    // bool_not::@2
    // screen[i] = '*'
    // [34] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    // bool_not::@3
  __b3:
    // for( byte i : 0..20)
    // [35] (byte) bool_not::i#1 ← ++ (byte) bool_not::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] if((byte) bool_not::i#1!=(byte) $15) goto bool_not::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_not::@return
    // }
    // [37] return 
    rts
    // bool_not::@4
  __b4:
    // screen[i] = ' '
    // [38] *((const nomodify byte*) bool_not::screen + (byte) bool_not::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // bool_complex
bool_complex: {
    .label screen = $478
    // [40] phi from bool_complex to bool_complex::@1 [phi:bool_complex->bool_complex::@1]
    // [40] phi (byte) bool_complex::i#2 = (byte) 0 [phi:bool_complex->bool_complex::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [40] phi from bool_complex::@3 to bool_complex::@1 [phi:bool_complex::@3->bool_complex::@1]
    // [40] phi (byte) bool_complex::i#2 = (byte) bool_complex::i#1 [phi:bool_complex::@3->bool_complex::@1#0] -- register_copy 
    // bool_complex::@1
  __b1:
    // i&1
    // [41] (byte~) bool_complex::$5 ← (byte) bool_complex::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if( ((i<10) && (i&1)==0) || !((i<10) || (i&1)==0) )
    // [42] if((byte) bool_complex::i#2>=(byte) $a) goto bool_complex::@5 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b5
    // bool_complex::@6
    // [43] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // bool_complex::@5
  __b5:
    // [44] if((byte) bool_complex::i#2<(byte) $a) goto bool_complex::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    // bool_complex::@7
    // [45] if((byte~) bool_complex::$5==(byte) 0) goto bool_complex::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    // bool_complex::@2
  __b2:
    // screen[i] = '*'
    // [46] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    // bool_complex::@3
  __b3:
    // for( byte i : 0..20)
    // [47] (byte) bool_complex::i#1 ← ++ (byte) bool_complex::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [48] if((byte) bool_complex::i#1!=(byte) $15) goto bool_complex::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_complex::@return
    // }
    // [49] return 
    rts
    // bool_complex::@4
  __b4:
    // screen[i] = ' '
    // [50] *((const nomodify byte*) bool_complex::screen + (byte) bool_complex::i#2) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // File Data

