Resolved forward reference irq to interrupt(KERNEL_MIN)(void()) irq()

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (void()**) KERNEL_IRQ#0 ← ((void()**)) (word/signed word/dword/signed dword) $314
  (byte*) IRQ_STATUS#0 ← ((byte*)) (word/dword/signed dword) $d019
  (byte*) CIA1_INTERRUPT#0 ← ((byte*)) (word/dword/signed dword) $dc0d
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word/dword/signed dword) $400
  (byte) col1#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:@2
main: scope:[main]  from @2
  (void()*~) main::$0 ← & interrupt(KERNEL_MIN)(void()) irq()
  *((void()**) KERNEL_IRQ#0) ← (void()*~) main::$0
  to:main::@1
main::@1: scope:[main]  from main main::@10
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  (byte) main::x#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:main::@4
main::@4: scope:[main]  from main::@10 main::@2
  (byte) main::x#6 ← phi( main::@10/(byte) main::x#1 main::@2/(byte) main::x#0 )
  (byte) main::y#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:main::@5
main::@5: scope:[main]  from main::@4 main::@9
  (byte) main::x#4 ← phi( main::@4/(byte) main::x#6 main::@9/(byte) main::x#5 )
  (byte) main::y#4 ← phi( main::@4/(byte) main::y#0 main::@9/(byte) main::y#1 )
  (byte) main::a#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:main::@6
main::@6: scope:[main]  from main::@5 main::@6
  (byte) main::x#2 ← phi( main::@5/(byte) main::x#4 main::@6/(byte) main::x#2 )
  (byte) main::y#2 ← phi( main::@5/(byte) main::y#4 main::@6/(byte) main::y#2 )
  (byte) main::a#2 ← phi( main::@5/(byte) main::a#0 main::@6/(byte) main::a#1 )
  (byte~) main::$1 ← (byte) main::a#2 + (byte) main::y#2
  *((byte*) SCREEN#0 + (byte) main::x#2) ← (byte~) main::$1
  (byte) main::a#1 ← (byte) main::a#2 + rangenext(0,$a)
  (bool~) main::$2 ← (byte) main::a#1 != rangelast(0,$a)
  if((bool~) main::$2) goto main::@6
  to:main::@9
main::@9: scope:[main]  from main::@6
  (byte) main::x#5 ← phi( main::@6/(byte) main::x#2 )
  (byte) main::y#3 ← phi( main::@6/(byte) main::y#2 )
  (byte) main::y#1 ← (byte) main::y#3 + rangenext(0,$a)
  (bool~) main::$3 ← (byte) main::y#1 != rangelast(0,$a)
  if((bool~) main::$3) goto main::@5
  to:main::@10
main::@10: scope:[main]  from main::@9
  (byte) main::x#3 ← phi( main::@9/(byte) main::x#5 )
  (byte) main::x#1 ← (byte) main::x#3 + rangenext(0,$a)
  (bool~) main::$4 ← (byte) main::x#1 != rangelast(0,$a)
  if((bool~) main::$4) goto main::@4
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return
irq: scope:[irq]  from
  (byte) col1#3 ← phi( @2/(byte) col1#5 )
  *((byte*) IRQ_STATUS#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1
  asm { lda$dc0d  }
  *((byte*) SCREEN#0 + (byte/signed byte/word/signed word/dword/signed dword) $28) ← (byte) col1#3
  (byte) col1#1 ← ++ (byte) col1#3
  to:irq::@return
irq::@return: scope:[irq]  from irq
  (byte) col1#4 ← phi( irq/(byte) col1#1 )
  (byte) col1#2 ← (byte) col1#4
  return 
  to:@return
@2: scope:[]  from @begin
  (byte) col1#5 ← phi( @begin/(byte) col1#0 )
  call main 
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(label) @2
(label) @3
(label) @begin
(label) @end
(byte*) CIA1_INTERRUPT
(byte*) CIA1_INTERRUPT#0
(byte*) IRQ_STATUS
(byte*) IRQ_STATUS#0
(void()**) KERNEL_IRQ
(void()**) KERNEL_IRQ#0
(byte*) SCREEN
(byte*) SCREEN#0
(byte) col1
(byte) col1#0
(byte) col1#1
(byte) col1#2
(byte) col1#3
(byte) col1#4
(byte) col1#5
interrupt(KERNEL_MIN)(void()) irq()
(label) irq::@return
(void()) main()
(void()*~) main::$0
(byte~) main::$1
(bool~) main::$2
(bool~) main::$3
(bool~) main::$4
(label) main::@1
(label) main::@10
(label) main::@2
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@9
(label) main::@return
(byte) main::a
(byte) main::a#0
(byte) main::a#1
(byte) main::a#2
(byte) main::x
(byte) main::x#0
(byte) main::x#1
(byte) main::x#2
(byte) main::x#3
(byte) main::x#4
(byte) main::x#5
(byte) main::x#6
(byte) main::y
(byte) main::y#0
(byte) main::y#1
(byte) main::y#2
(byte) main::y#3
(byte) main::y#4

Culled Empty Block (label) @3
Successful SSA optimization Pass2CullEmptyBlocks
Alias (byte) main::y#2 = (byte) main::y#3 
Alias (byte) main::x#2 = (byte) main::x#5 (byte) main::x#3 
Alias (byte) col1#1 = (byte) col1#4 (byte) col1#2 
Alias (byte) col1#0 = (byte) col1#5 
Successful SSA optimization Pass2AliasElimination
Self Phi Eliminated (byte) main::y#2
Self Phi Eliminated (byte) main::x#2
Successful SSA optimization Pass2SelfPhiElimination
Redundant Phi (byte) main::y#2 (byte) main::y#4
Redundant Phi (byte) main::x#2 (byte) main::x#4
Redundant Phi (byte) col1#3 (byte) col1#0
Successful SSA optimization Pass2RedundantPhiElimination
Simple Condition (bool~) main::$2 [18] if((byte) main::a#1!=rangelast(0,$a)) goto main::@6
Simple Condition (bool~) main::$3 [22] if((byte) main::y#1!=rangelast(0,$a)) goto main::@5
Simple Condition (bool~) main::$4 [26] if((byte) main::x#1!=rangelast(0,$a)) goto main::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const void()**) KERNEL_IRQ#0 = ((void()**))$314
Constant (const byte*) IRQ_STATUS#0 = ((byte*))$d019
Constant (const byte*) CIA1_INTERRUPT#0 = ((byte*))$dc0d
Constant (const byte*) SCREEN#0 = ((byte*))$400
Constant (const void()*) main::$0 = &irq
Constant (const byte) main::x#0 = 0
Constant (const byte) main::y#0 = 0
Constant (const byte) main::a#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Consolidated array index constant in *(SCREEN#0+$28)
Successful SSA optimization Pass2ConstantAdditionElimination
if() condition always true - replacing block destination [2] if(true) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Resolved ranged next value main::a#1 ← ++ main::a#2 to ++
Resolved ranged comparison value if(main::a#1!=rangelast(0,$a)) goto main::@6 to (byte/signed byte/word/signed word/dword/signed dword) $b
Resolved ranged next value main::y#1 ← ++ main::y#4 to ++
Resolved ranged comparison value if(main::y#1!=rangelast(0,$a)) goto main::@5 to (byte/signed byte/word/signed word/dword/signed dword) $b
Resolved ranged next value main::x#1 ← ++ main::x#4 to ++
Resolved ranged comparison value if(main::x#1!=rangelast(0,$a)) goto main::@4 to (byte/signed byte/word/signed word/dword/signed dword) $b
Culled Empty Block (label) main::@1
Successful SSA optimization Pass2CullEmptyBlocks
Self Phi Eliminated (byte) main::x#4
Successful SSA optimization Pass2SelfPhiElimination
Redundant Phi (byte) main::x#4 (byte) main::x#6
Successful SSA optimization Pass2RedundantPhiElimination
Inlining constant with var siblings (const byte) main::x#0
Inlining constant with var siblings (const byte) main::y#0
Inlining constant with var siblings (const byte) main::a#0
Constant inlined main::a#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined main::x#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined main::y#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined main::$0 = &interrupt(KERNEL_MIN)(void()) irq()
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@13(between main::@10 and main::@4)
Added new block during phi lifting main::@14(between main::@9 and main::@5)
Added new block during phi lifting main::@15(between main::@6 and main::@6)
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@2
CALL GRAPH
Calls in [] to main:2 

Created 3 initial phi equivalence classes
Coalesced [17] main::x#7 ← main::x#1
Coalesced [18] main::y#5 ← main::y#1
Coalesced [19] main::a#3 ← main::a#1
Coalesced down to 3 phi equivalence classes
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@14
Culled Empty Block (label) main::@15
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@13

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] (byte) col1#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:@2
@2: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @2
  [3] phi()
main: scope:[main]  from @2
  [4] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) irq()
  to:main::@4
main::@4: scope:[main]  from main main::@10 main::@13
  [5] (byte) main::x#6 ← phi( main::@13/(byte) main::x#1 main/(byte/signed byte/word/signed word/dword/signed dword) 0 main::@10/(byte/signed byte/word/signed word/dword/signed dword) 0 )
  to:main::@5
main::@5: scope:[main]  from main::@4 main::@9
  [6] (byte) main::y#4 ← phi( main::@4/(byte/signed byte/word/signed word/dword/signed dword) 0 main::@9/(byte) main::y#1 )
  to:main::@6
main::@6: scope:[main]  from main::@5 main::@6
  [7] (byte) main::a#2 ← phi( main::@5/(byte/signed byte/word/signed word/dword/signed dword) 0 main::@6/(byte) main::a#1 )
  [8] (byte~) main::$1 ← (byte) main::a#2 + (byte) main::y#4
  [9] *((const byte*) SCREEN#0 + (byte) main::x#6) ← (byte~) main::$1
  [10] (byte) main::a#1 ← ++ (byte) main::a#2
  [11] if((byte) main::a#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@6
  to:main::@9
main::@9: scope:[main]  from main::@6
  [12] (byte) main::y#1 ← ++ (byte) main::y#4
  [13] if((byte) main::y#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@5
  to:main::@10
main::@10: scope:[main]  from main::@9
  [14] (byte) main::x#1 ← ++ (byte) main::x#6
  [15] if((byte) main::x#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@13
  to:main::@4
main::@13: scope:[main]  from main::@10
  [16] phi()
  to:main::@4
irq: scope:[irq]  from
  [17] *((const byte*) IRQ_STATUS#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1
  asm { lda$dc0d  }
  [19] *((const byte*) SCREEN#0+(byte/signed byte/word/signed word/dword/signed dword) $28) ← (byte) col1#0
  [20] (byte) col1#1 ← ++ (byte) col1#0
  to:irq::@return
irq::@return: scope:[irq]  from irq
  [21] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte*) CIA1_INTERRUPT
(byte*) IRQ_STATUS
(void()**) KERNEL_IRQ
(byte*) SCREEN
(byte) col1
(byte) col1#0 2.0
(byte) col1#1 20.0
interrupt(KERNEL_MIN)(void()) irq()
(void()) main()
(byte~) main::$1 20002.0
(byte) main::a
(byte) main::a#1 15001.5
(byte) main::a#2 10001.0
(byte) main::x
(byte) main::x#1 71.0
(byte) main::x#6 1123.6666666666665
(byte) main::y
(byte) main::y#1 1501.5
(byte) main::y#4 2000.4999999999998

Initial phi equivalence classes
[ main::x#6 main::x#1 ]
[ main::y#4 main::y#1 ]
[ main::a#2 main::a#1 ]
Added variable col1#0 to zero page equivalence class [ col1#0 ]
Added variable main::$1 to zero page equivalence class [ main::$1 ]
Added variable col1#1 to zero page equivalence class [ col1#1 ]
Complete equivalence classes
[ main::x#6 main::x#1 ]
[ main::y#4 main::y#1 ]
[ main::a#2 main::a#1 ]
[ col1#0 ]
[ main::$1 ]
[ col1#1 ]
Allocated zp ZP_BYTE:2 [ main::x#6 main::x#1 ]
Allocated zp ZP_BYTE:3 [ main::y#4 main::y#1 ]
Allocated zp ZP_BYTE:4 [ main::a#2 main::a#1 ]
Allocated zp ZP_BYTE:5 [ col1#0 ]
Allocated zp ZP_BYTE:6 [ main::$1 ]
Allocated zp ZP_BYTE:7 [ col1#1 ]

INITIAL ASM
//SEG0 File Comments
// Illustrates problem where volatiles reuse ZP addresses of other variables
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label KERNEL_IRQ = $314
  .label IRQ_STATUS = $d019
  .label SCREEN = $400
  .label col1 = 5
  .label col1_1 = 7
//SEG3 @begin
bbegin:
//SEG4 [0] (byte) col1#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  lda #0
  sta col1
//SEG5 [1] phi from @begin to @2 [phi:@begin->@2]
b2_from_bbegin:
  jmp b2
//SEG6 @2
b2:
//SEG7 [2] call main 
  jsr main
//SEG8 [3] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
    .label _1 = 6
    .label a = 4
    .label y = 3
    .label x = 2
  //SEG11 [4] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) irq() -- _deref_pptc1=pprc2 
    lda #<irq
    sta KERNEL_IRQ
    lda #>irq
    sta KERNEL_IRQ+1
  //SEG12 [5] phi from main main::@10 to main::@4 [phi:main/main::@10->main::@4]
  b4_from_main:
  b4_from_b10:
  //SEG13 [5] phi (byte) main::x#6 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main/main::@10->main::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta x
    jmp b4
  //SEG14 main::@4
  b4:
  //SEG15 [6] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  b5_from_b4:
  //SEG16 [6] phi (byte) main::y#4 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@4->main::@5#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    jmp b5
  //SEG17 [6] phi from main::@9 to main::@5 [phi:main::@9->main::@5]
  b5_from_b9:
  //SEG18 [6] phi (byte) main::y#4 = (byte) main::y#1 [phi:main::@9->main::@5#0] -- register_copy 
    jmp b5
  //SEG19 main::@5
  b5:
  //SEG20 [7] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  b6_from_b5:
  //SEG21 [7] phi (byte) main::a#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@5->main::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta a
    jmp b6
  //SEG22 [7] phi from main::@6 to main::@6 [phi:main::@6->main::@6]
  b6_from_b6:
  //SEG23 [7] phi (byte) main::a#2 = (byte) main::a#1 [phi:main::@6->main::@6#0] -- register_copy 
    jmp b6
  //SEG24 main::@6
  b6:
  //SEG25 [8] (byte~) main::$1 ← (byte) main::a#2 + (byte) main::y#4 -- vbuz1=vbuz2_plus_vbuz3 
    lda a
    clc
    adc y
    sta _1
  //SEG26 [9] *((const byte*) SCREEN#0 + (byte) main::x#6) ← (byte~) main::$1 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _1
    ldy x
    sta SCREEN,y
  //SEG27 [10] (byte) main::a#1 ← ++ (byte) main::a#2 -- vbuz1=_inc_vbuz1 
    inc a
  //SEG28 [11] if((byte) main::a#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@6 -- vbuz1_neq_vbuc1_then_la1 
    lda a
    cmp #$b
    bne b6_from_b6
    jmp b9
  //SEG29 main::@9
  b9:
  //SEG30 [12] (byte) main::y#1 ← ++ (byte) main::y#4 -- vbuz1=_inc_vbuz1 
    inc y
  //SEG31 [13] if((byte) main::y#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@5 -- vbuz1_neq_vbuc1_then_la1 
    lda y
    cmp #$b
    bne b5_from_b9
    jmp b10
  //SEG32 main::@10
  b10:
  //SEG33 [14] (byte) main::x#1 ← ++ (byte) main::x#6 -- vbuz1=_inc_vbuz1 
    inc x
  //SEG34 [15] if((byte) main::x#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@13 -- vbuz1_neq_vbuc1_then_la1 
    lda x
    cmp #$b
    bne b13_from_b10
    jmp b4_from_b10
  //SEG35 [16] phi from main::@10 to main::@13 [phi:main::@10->main::@13]
  b13_from_b10:
    jmp b13
  //SEG36 main::@13
  b13:
  //SEG37 [5] phi from main::@13 to main::@4 [phi:main::@13->main::@4]
  b4_from_b13:
  //SEG38 [5] phi (byte) main::x#6 = (byte) main::x#1 [phi:main::@13->main::@4#0] -- register_copy 
    jmp b4
}
//SEG39 irq
irq: {
  //SEG40 entry interrupt(KERNEL_MIN)
  //SEG41 [17] *((const byte*) IRQ_STATUS#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #1
    sta IRQ_STATUS
  //SEG42 asm { lda$dc0d  }
    lda $dc0d
  //SEG43 [19] *((const byte*) SCREEN#0+(byte/signed byte/word/signed word/dword/signed dword) $28) ← (byte) col1#0 -- _deref_pbuc1=vbuz1 
    lda col1
    sta SCREEN+$28
  //SEG44 [20] (byte) col1#1 ← ++ (byte) col1#0 -- vbuz1=_inc_vbuz2 
    ldy col1
    iny
    sty col1_1
    jmp breturn
  //SEG45 irq::@return
  breturn:
  //SEG46 [21] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] (byte) col1#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [4] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) irq() [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [8] (byte~) main::$1 ← (byte) main::a#2 + (byte) main::y#4 [ main::x#6 main::y#4 main::a#2 main::$1 ] ( main:2 [ main::x#6 main::y#4 main::a#2 main::$1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::x#6 main::x#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ main::y#4 main::y#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ main::a#2 main::a#1 ]
Statement [17] *((const byte*) IRQ_STATUS#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ col1#0 ] (  [ col1#0 ] ) always clobbers reg byte a 
Statement asm { lda$dc0d  } always clobbers reg byte a 
Statement [19] *((const byte*) SCREEN#0+(byte/signed byte/word/signed word/dword/signed dword) $28) ← (byte) col1#0 [ col1#0 ] (  [ col1#0 ] ) always clobbers reg byte a 
Statement [20] (byte) col1#1 ← ++ (byte) col1#0 [ ] (  [ ] ) always clobbers reg byte y 
Statement [0] (byte) col1#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [4] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) irq() [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [8] (byte~) main::$1 ← (byte) main::a#2 + (byte) main::y#4 [ main::x#6 main::y#4 main::a#2 main::$1 ] ( main:2 [ main::x#6 main::y#4 main::a#2 main::$1 ] ) always clobbers reg byte a 
Statement [17] *((const byte*) IRQ_STATUS#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ col1#0 ] (  [ col1#0 ] ) always clobbers reg byte a 
Statement asm { lda$dc0d  } always clobbers reg byte a 
Statement [19] *((const byte*) SCREEN#0+(byte/signed byte/word/signed word/dword/signed dword) $28) ← (byte) col1#0 [ col1#0 ] (  [ col1#0 ] ) always clobbers reg byte a 
Statement [20] (byte) col1#1 ← ++ (byte) col1#0 [ ] (  [ ] ) always clobbers reg byte y 
Potential registers zp ZP_BYTE:2 [ main::x#6 main::x#1 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ main::y#4 main::y#1 ] : zp ZP_BYTE:3 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ main::a#2 main::a#1 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ col1#0 ] : zp ZP_BYTE:5 , 
Potential registers zp ZP_BYTE:6 [ main::$1 ] : zp ZP_BYTE:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ col1#1 ] : zp ZP_BYTE:7 , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 25,002.5: zp ZP_BYTE:4 [ main::a#2 main::a#1 ] 20,002: zp ZP_BYTE:6 [ main::$1 ] 3,502: zp ZP_BYTE:3 [ main::y#4 main::y#1 ] 1,194.67: zp ZP_BYTE:2 [ main::x#6 main::x#1 ] 
Uplift Scope [] 20: zp ZP_BYTE:7 [ col1#1 ] 2: zp ZP_BYTE:5 [ col1#0 ] 
Uplift Scope [irq] 

Uplifting [main] best 323340 combination reg byte y [ main::a#2 main::a#1 ] reg byte a [ main::$1 ] zp ZP_BYTE:3 [ main::y#4 main::y#1 ] reg byte x [ main::x#6 main::x#1 ] 
Limited combination testing to 100 combinations of 108 possible.
Uplifting [] best 323340 combination zp ZP_BYTE:7 [ col1#1 ] zp ZP_BYTE:5 [ col1#0 ] 
Uplifting [irq] best 323340 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ main::y#4 main::y#1 ]
Uplifting [main] best 323340 combination zp ZP_BYTE:3 [ main::y#4 main::y#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:7 [ col1#1 ]
Uplifting [] best 323340 combination zp ZP_BYTE:7 [ col1#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:5 [ col1#0 ]
Uplifting [] best 323340 combination zp ZP_BYTE:5 [ col1#0 ] 
Coalescing zero page register with common assignment [ zp ZP_BYTE:5 [ col1#0 ] ] with [ zp ZP_BYTE:7 [ col1#1 ] ] - score: 1
Allocated (was zp ZP_BYTE:3) zp ZP_BYTE:2 [ main::y#4 main::y#1 ]
Allocated (was zp ZP_BYTE:5) zp ZP_BYTE:3 [ col1#0 col1#1 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Illustrates problem where volatiles reuse ZP addresses of other variables
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label KERNEL_IRQ = $314
  .label IRQ_STATUS = $d019
  .label SCREEN = $400
  .label col1 = 3
//SEG3 @begin
bbegin:
//SEG4 [0] (byte) col1#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  lda #0
  sta col1
//SEG5 [1] phi from @begin to @2 [phi:@begin->@2]
b2_from_bbegin:
  jmp b2
//SEG6 @2
b2:
//SEG7 [2] call main 
  jsr main
//SEG8 [3] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
    .label y = 2
  //SEG11 [4] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) irq() -- _deref_pptc1=pprc2 
    lda #<irq
    sta KERNEL_IRQ
    lda #>irq
    sta KERNEL_IRQ+1
  //SEG12 [5] phi from main main::@10 to main::@4 [phi:main/main::@10->main::@4]
  b4_from_main:
  b4_from_b10:
  //SEG13 [5] phi (byte) main::x#6 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main/main::@10->main::@4#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b4
  //SEG14 main::@4
  b4:
  //SEG15 [6] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  b5_from_b4:
  //SEG16 [6] phi (byte) main::y#4 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@4->main::@5#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    jmp b5
  //SEG17 [6] phi from main::@9 to main::@5 [phi:main::@9->main::@5]
  b5_from_b9:
  //SEG18 [6] phi (byte) main::y#4 = (byte) main::y#1 [phi:main::@9->main::@5#0] -- register_copy 
    jmp b5
  //SEG19 main::@5
  b5:
  //SEG20 [7] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  b6_from_b5:
  //SEG21 [7] phi (byte) main::a#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@5->main::@6#0] -- vbuyy=vbuc1 
    ldy #0
    jmp b6
  //SEG22 [7] phi from main::@6 to main::@6 [phi:main::@6->main::@6]
  b6_from_b6:
  //SEG23 [7] phi (byte) main::a#2 = (byte) main::a#1 [phi:main::@6->main::@6#0] -- register_copy 
    jmp b6
  //SEG24 main::@6
  b6:
  //SEG25 [8] (byte~) main::$1 ← (byte) main::a#2 + (byte) main::y#4 -- vbuaa=vbuyy_plus_vbuz1 
    tya
    clc
    adc y
  //SEG26 [9] *((const byte*) SCREEN#0 + (byte) main::x#6) ← (byte~) main::$1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
  //SEG27 [10] (byte) main::a#1 ← ++ (byte) main::a#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG28 [11] if((byte) main::a#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@6 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne b6_from_b6
    jmp b9
  //SEG29 main::@9
  b9:
  //SEG30 [12] (byte) main::y#1 ← ++ (byte) main::y#4 -- vbuz1=_inc_vbuz1 
    inc y
  //SEG31 [13] if((byte) main::y#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@5 -- vbuz1_neq_vbuc1_then_la1 
    lda y
    cmp #$b
    bne b5_from_b9
    jmp b10
  //SEG32 main::@10
  b10:
  //SEG33 [14] (byte) main::x#1 ← ++ (byte) main::x#6 -- vbuxx=_inc_vbuxx 
    inx
  //SEG34 [15] if((byte) main::x#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@13 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne b13_from_b10
    jmp b4_from_b10
  //SEG35 [16] phi from main::@10 to main::@13 [phi:main::@10->main::@13]
  b13_from_b10:
    jmp b13
  //SEG36 main::@13
  b13:
  //SEG37 [5] phi from main::@13 to main::@4 [phi:main::@13->main::@4]
  b4_from_b13:
  //SEG38 [5] phi (byte) main::x#6 = (byte) main::x#1 [phi:main::@13->main::@4#0] -- register_copy 
    jmp b4
}
//SEG39 irq
irq: {
  //SEG40 entry interrupt(KERNEL_MIN)
  //SEG41 [17] *((const byte*) IRQ_STATUS#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #1
    sta IRQ_STATUS
  //SEG42 asm { lda$dc0d  }
    lda $dc0d
  //SEG43 [19] *((const byte*) SCREEN#0+(byte/signed byte/word/signed word/dword/signed dword) $28) ← (byte) col1#0 -- _deref_pbuc1=vbuz1 
    lda col1
    sta SCREEN+$28
  //SEG44 [20] (byte) col1#1 ← ++ (byte) col1#0 -- vbuz1=_inc_vbuz1 
    inc col1
    jmp breturn
  //SEG45 irq::@return
  breturn:
  //SEG46 [21] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b2
Removing instruction jmp bend
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b6
Removing instruction jmp b9
Removing instruction jmp b10
Removing instruction jmp b13
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label b6_from_b6 with b6
Replacing label b5_from_b9 with b5
Replacing label b13_from_b10 with b13
Removing instruction b2_from_bbegin:
Removing instruction bend_from_b2:
Removing instruction b4_from_main:
Removing instruction b5_from_b4:
Removing instruction b5_from_b9:
Removing instruction b6_from_b5:
Removing instruction b6_from_b6:
Removing instruction b13_from_b10:
Removing instruction b4_from_b13:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b2:
Removing instruction bend:
Removing instruction b9:
Removing instruction b10:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Skipping double jump to b4 in bne b13
Succesful ASM optimization Pass5DoubleJumpElimination
Relabelling long label b4_from_b10 to b1
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp b5
Removing instruction jmp b6
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction b13:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing unreachable instruction jmp b4
Succesful ASM optimization Pass5UnreachableCodeElimination

FINAL SYMBOL TABLE
(label) @2
(label) @begin
(label) @end
(byte*) CIA1_INTERRUPT
(byte*) IRQ_STATUS
(const byte*) IRQ_STATUS#0 IRQ_STATUS = ((byte*))(word/dword/signed dword) $d019
(void()**) KERNEL_IRQ
(const void()**) KERNEL_IRQ#0 KERNEL_IRQ = ((void()**))(word/signed word/dword/signed dword) $314
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = ((byte*))(word/signed word/dword/signed dword) $400
(byte) col1
(byte) col1#0 col1 zp ZP_BYTE:3 2.0
(byte) col1#1 col1 zp ZP_BYTE:3 20.0
interrupt(KERNEL_MIN)(void()) irq()
(label) irq::@return
(void()) main()
(byte~) main::$1 reg byte a 20002.0
(label) main::@10
(label) main::@13
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@9
(byte) main::a
(byte) main::a#1 reg byte y 15001.5
(byte) main::a#2 reg byte y 10001.0
(byte) main::x
(byte) main::x#1 reg byte x 71.0
(byte) main::x#6 reg byte x 1123.6666666666665
(byte) main::y
(byte) main::y#1 y zp ZP_BYTE:2 1501.5
(byte) main::y#4 y zp ZP_BYTE:2 2000.4999999999998

reg byte x [ main::x#6 main::x#1 ]
zp ZP_BYTE:2 [ main::y#4 main::y#1 ]
reg byte y [ main::a#2 main::a#1 ]
zp ZP_BYTE:3 [ col1#0 col1#1 ]
reg byte a [ main::$1 ]


FINAL ASSEMBLER
Score: 223698

//SEG0 File Comments
// Illustrates problem where volatiles reuse ZP addresses of other variables
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label KERNEL_IRQ = $314
  .label IRQ_STATUS = $d019
  .label SCREEN = $400
  .label col1 = 3
//SEG3 @begin
bbegin:
//SEG4 [0] (byte) col1#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  lda #0
  sta col1
//SEG5 [1] phi from @begin to @2 [phi:@begin->@2]
//SEG6 @2
//SEG7 [2] call main 
  jsr main
//SEG8 [3] phi from @2 to @end [phi:@2->@end]
//SEG9 @end
//SEG10 main
main: {
    .label y = 2
  //SEG11 [4] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) irq() -- _deref_pptc1=pprc2 
    lda #<irq
    sta KERNEL_IRQ
    lda #>irq
    sta KERNEL_IRQ+1
  //SEG12 [5] phi from main main::@10 to main::@4 [phi:main/main::@10->main::@4]
  b1:
  //SEG13 [5] phi (byte) main::x#6 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main/main::@10->main::@4#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG14 main::@4
  b4:
  //SEG15 [6] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  //SEG16 [6] phi (byte) main::y#4 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@4->main::@5#0] -- vbuz1=vbuc1 
    lda #0
    sta y
  //SEG17 [6] phi from main::@9 to main::@5 [phi:main::@9->main::@5]
  //SEG18 [6] phi (byte) main::y#4 = (byte) main::y#1 [phi:main::@9->main::@5#0] -- register_copy 
  //SEG19 main::@5
  b5:
  //SEG20 [7] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  //SEG21 [7] phi (byte) main::a#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@5->main::@6#0] -- vbuyy=vbuc1 
    ldy #0
  //SEG22 [7] phi from main::@6 to main::@6 [phi:main::@6->main::@6]
  //SEG23 [7] phi (byte) main::a#2 = (byte) main::a#1 [phi:main::@6->main::@6#0] -- register_copy 
  //SEG24 main::@6
  b6:
  //SEG25 [8] (byte~) main::$1 ← (byte) main::a#2 + (byte) main::y#4 -- vbuaa=vbuyy_plus_vbuz1 
    tya
    clc
    adc y
  //SEG26 [9] *((const byte*) SCREEN#0 + (byte) main::x#6) ← (byte~) main::$1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
  //SEG27 [10] (byte) main::a#1 ← ++ (byte) main::a#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG28 [11] if((byte) main::a#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@6 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$b
    bne b6
  //SEG29 main::@9
  //SEG30 [12] (byte) main::y#1 ← ++ (byte) main::y#4 -- vbuz1=_inc_vbuz1 
    inc y
  //SEG31 [13] if((byte) main::y#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@5 -- vbuz1_neq_vbuc1_then_la1 
    lda y
    cmp #$b
    bne b5
  //SEG32 main::@10
  //SEG33 [14] (byte) main::x#1 ← ++ (byte) main::x#6 -- vbuxx=_inc_vbuxx 
    inx
  //SEG34 [15] if((byte) main::x#1!=(byte/signed byte/word/signed word/dword/signed dword) $b) goto main::@13 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$b
    bne b4
    jmp b1
  //SEG35 [16] phi from main::@10 to main::@13 [phi:main::@10->main::@13]
  //SEG36 main::@13
  //SEG37 [5] phi from main::@13 to main::@4 [phi:main::@13->main::@4]
  //SEG38 [5] phi (byte) main::x#6 = (byte) main::x#1 [phi:main::@13->main::@4#0] -- register_copy 
}
//SEG39 irq
irq: {
  //SEG40 entry interrupt(KERNEL_MIN)
  //SEG41 [17] *((const byte*) IRQ_STATUS#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #1
    sta IRQ_STATUS
  //SEG42 asm { lda$dc0d  }
    lda $dc0d
  //SEG43 [19] *((const byte*) SCREEN#0+(byte/signed byte/word/signed word/dword/signed dword) $28) ← (byte) col1#0 -- _deref_pbuc1=vbuz1 
    lda col1
    sta SCREEN+$28
  //SEG44 [20] (byte) col1#1 ← ++ (byte) col1#0 -- vbuz1=_inc_vbuz1 
    inc col1
  //SEG45 irq::@return
  //SEG46 [21] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
}

