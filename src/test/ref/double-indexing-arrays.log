Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) COLS

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte[$3e8]) MAPDATA#0 ← { fill( $3e8, 0) }
  (byte[$100]) COLORMAP1#0 ← { fill( $100, 0) }
  (byte[$100]) COLORMAP2#0 ← { fill( $100, 0) }
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word/dword/signed dword) $400
  (byte*) COLS#0 ← ((byte*)) (word/dword/signed dword) $d800
  to:@1
main: scope:[main]  from @1
  (byte) main::x#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@1/(byte) main::x#1 )
  *((byte*) SCREEN#0 + (byte) main::x#2) ← *((byte[$3e8]) MAPDATA#0 + (byte) main::x#2)
  *((byte*) COLS#0 + (byte) main::x#2) ← *((byte[$100]) COLORMAP1#0 + *((byte[$3e8]) MAPDATA#0 + (byte) main::x#2))
  (byte/word/signed word/dword/signed dword~) main::$0 ← (byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2
  (byte/word/signed word/dword/signed dword~) main::$1 ← (byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2
  *((byte*) SCREEN#0 + (byte/word/signed word/dword/signed dword~) main::$0) ← *((byte[$3e8]) MAPDATA#0 + (byte/word/signed word/dword/signed dword~) main::$1)
  (byte/word/signed word/dword/signed dword~) main::$2 ← (byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2
  (byte/word/signed word/dword/signed dword~) main::$3 ← (byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2
  *((byte*) COLS#0 + (byte/word/signed word/dword/signed dword~) main::$2) ← *((byte[$100]) COLORMAP1#0 + *((byte[$3e8]) MAPDATA#0 + (byte/word/signed word/dword/signed dword~) main::$3))
  (word/signed word/dword/signed dword~) main::$4 ← (word/signed word/dword/signed dword) $190 + (byte) main::x#2
  (word/signed word/dword/signed dword~) main::$5 ← (word/signed word/dword/signed dword) $190 + (byte) main::x#2
  *((byte*) SCREEN#0 + (word/signed word/dword/signed dword~) main::$4) ← *((byte[$3e8]) MAPDATA#0 + (word/signed word/dword/signed dword~) main::$5)
  (word/signed word/dword/signed dword~) main::$6 ← (word/signed word/dword/signed dword) $190 + (byte) main::x#2
  (word/signed word/dword/signed dword~) main::$7 ← (word/signed word/dword/signed dword) $190 + (byte) main::x#2
  *((byte*) COLS#0 + (word/signed word/dword/signed dword~) main::$6) ← *((byte[$100]) COLORMAP1#0 + *((byte[$3e8]) MAPDATA#0 + (word/signed word/dword/signed dword~) main::$7))
  (word/signed word/dword/signed dword~) main::$8 ← (word/signed word/dword/signed dword) $258 + (byte) main::x#2
  (word/signed word/dword/signed dword~) main::$9 ← (word/signed word/dword/signed dword) $258 + (byte) main::x#2
  *((byte*) SCREEN#0 + (word/signed word/dword/signed dword~) main::$8) ← *((byte[$3e8]) MAPDATA#0 + (word/signed word/dword/signed dword~) main::$9)
  (word/signed word/dword/signed dword~) main::$10 ← (word/signed word/dword/signed dword) $258 + (byte) main::x#2
  (word/signed word/dword/signed dword~) main::$11 ← (word/signed word/dword/signed dword) $258 + (byte) main::x#2
  *((byte*) COLS#0 + (word/signed word/dword/signed dword~) main::$10) ← *((byte[$100]) COLORMAP2#0 + *((byte[$3e8]) MAPDATA#0 + (word/signed word/dword/signed dword~) main::$11))
  (word/signed word/dword/signed dword~) main::$12 ← (word/signed word/dword/signed dword) $320 + (byte) main::x#2
  (word/signed word/dword/signed dword~) main::$13 ← (word/signed word/dword/signed dword) $320 + (byte) main::x#2
  *((byte*) SCREEN#0 + (word/signed word/dword/signed dword~) main::$12) ← *((byte[$3e8]) MAPDATA#0 + (word/signed word/dword/signed dword~) main::$13)
  (word/signed word/dword/signed dword~) main::$14 ← (word/signed word/dword/signed dword) $320 + (byte) main::x#2
  (word/signed word/dword/signed dword~) main::$15 ← (word/signed word/dword/signed dword) $320 + (byte) main::x#2
  *((byte*) COLS#0 + (word/signed word/dword/signed dword~) main::$14) ← *((byte[$100]) COLORMAP2#0 + *((byte[$3e8]) MAPDATA#0 + (word/signed word/dword/signed dword~) main::$15))
  (byte) main::x#1 ← (byte) main::x#2 + rangenext(0,$c8)
  (bool~) main::$16 ← (byte) main::x#1 != rangelast(0,$c8)
  if((bool~) main::$16) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
@1: scope:[]  from @begin
  call main 
  to:@2
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

SYMBOL TABLE SSA
(label) @1
(label) @2
(label) @begin
(label) @end
(byte[$100]) COLORMAP1
(byte[$100]) COLORMAP1#0
(byte[$100]) COLORMAP2
(byte[$100]) COLORMAP2#0
(byte*) COLS
(byte*) COLS#0
(byte[$3e8]) MAPDATA
(byte[$3e8]) MAPDATA#0
(byte*) SCREEN
(byte*) SCREEN#0
(void()) main()
(byte/word/signed word/dword/signed dword~) main::$0
(byte/word/signed word/dword/signed dword~) main::$1
(word/signed word/dword/signed dword~) main::$10
(word/signed word/dword/signed dword~) main::$11
(word/signed word/dword/signed dword~) main::$12
(word/signed word/dword/signed dword~) main::$13
(word/signed word/dword/signed dword~) main::$14
(word/signed word/dword/signed dword~) main::$15
(bool~) main::$16
(byte/word/signed word/dword/signed dword~) main::$2
(byte/word/signed word/dword/signed dword~) main::$3
(word/signed word/dword/signed dword~) main::$4
(word/signed word/dword/signed dword~) main::$5
(word/signed word/dword/signed dword~) main::$6
(word/signed word/dword/signed dword~) main::$7
(word/signed word/dword/signed dword~) main::$8
(word/signed word/dword/signed dword~) main::$9
(label) main::@1
(label) main::@return
(byte) main::x !reg byte y
(byte) main::x#0 !reg byte y
(byte) main::x#1 !reg byte y
(byte) main::x#2 !reg byte y

Culled Empty Block (label) @2
Successful SSA optimization Pass2CullEmptyBlocks
Simple Condition (bool~) main::$16 [35] if((byte) main::x#1!=rangelast(0,$c8)) goto main::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte[$3e8]) MAPDATA#0 = { fill( $3e8, 0) }
Constant (const byte[$100]) COLORMAP1#0 = { fill( $100, 0) }
Constant (const byte[$100]) COLORMAP2#0 = { fill( $100, 0) }
Constant (const byte*) SCREEN#0 = ((byte*))$400
Constant (const byte*) COLS#0 = ((byte*))$d800
Constant (const byte) main::x#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Consolidated array index constant in assignment *(MAPDATA#0+$c8 + main::$1)
Consolidated array index constant in assignment *(SCREEN#0+$c8 + main::$0)
Consolidated array index constant in assignment *(MAPDATA#0+$c8 + main::$3)
Consolidated array index constant in assignment *(COLS#0+$c8 + main::$2)
Consolidated array index constant in assignment *(MAPDATA#0+$190 + main::$5)
Consolidated array index constant in assignment *(SCREEN#0+$190 + main::$4)
Consolidated array index constant in assignment *(MAPDATA#0+$190 + main::$7)
Consolidated array index constant in assignment *(COLS#0+$190 + main::$6)
Consolidated array index constant in assignment *(MAPDATA#0+$258 + main::$9)
Consolidated array index constant in assignment *(SCREEN#0+$258 + main::$8)
Consolidated array index constant in assignment *(MAPDATA#0+$258 + main::$11)
Consolidated array index constant in assignment *(COLS#0+$258 + main::$10)
Consolidated array index constant in assignment *(MAPDATA#0+$320 + main::$13)
Consolidated array index constant in assignment *(SCREEN#0+$320 + main::$12)
Consolidated array index constant in assignment *(MAPDATA#0+$320 + main::$15)
Consolidated array index constant in assignment *(COLS#0+$320 + main::$14)
Successful SSA optimization Pass2ConstantAdditionElimination
Inferred type updated to byte in [3] (byte/word/signed word/dword/signed dword~) main::$0 ← (byte) main::x#2
Inferred type updated to byte in [4] (byte/word/signed word/dword/signed dword~) main::$1 ← (byte) main::x#2
Inferred type updated to byte in [6] (byte/word/signed word/dword/signed dword~) main::$2 ← (byte) main::x#2
Inferred type updated to byte in [7] (byte/word/signed word/dword/signed dword~) main::$3 ← (byte) main::x#2
Inferred type updated to byte in [9] (word/signed word/dword/signed dword~) main::$4 ← (byte) main::x#2
Inferred type updated to byte in [10] (word/signed word/dword/signed dword~) main::$5 ← (byte) main::x#2
Inferred type updated to byte in [12] (word/signed word/dword/signed dword~) main::$6 ← (byte) main::x#2
Inferred type updated to byte in [13] (word/signed word/dword/signed dword~) main::$7 ← (byte) main::x#2
Inferred type updated to byte in [15] (word/signed word/dword/signed dword~) main::$8 ← (byte) main::x#2
Inferred type updated to byte in [16] (word/signed word/dword/signed dword~) main::$9 ← (byte) main::x#2
Inferred type updated to byte in [18] (word/signed word/dword/signed dword~) main::$10 ← (byte) main::x#2
Inferred type updated to byte in [19] (word/signed word/dword/signed dword~) main::$11 ← (byte) main::x#2
Inferred type updated to byte in [21] (word/signed word/dword/signed dword~) main::$12 ← (byte) main::x#2
Inferred type updated to byte in [22] (word/signed word/dword/signed dword~) main::$13 ← (byte) main::x#2
Inferred type updated to byte in [24] (word/signed word/dword/signed dword~) main::$14 ← (byte) main::x#2
Inferred type updated to byte in [25] (word/signed word/dword/signed dword~) main::$15 ← (byte) main::x#2
Resolved ranged next value main::x#1 ← ++ main::x#2 to ++
Resolved ranged comparison value if(main::x#1!=rangelast(0,$c8)) goto main::@1 to (byte/word/signed word/dword/signed dword) $c9
Alias (byte) main::x#2 = (byte~) main::$0 (byte~) main::$1 (byte~) main::$2 (byte~) main::$3 (byte~) main::$4 (byte~) main::$5 (byte~) main::$6 (byte~) main::$7 (byte~) main::$8 (byte~) main::$9 (byte~) main::$10 (byte~) main::$11 (byte~) main::$12 (byte~) main::$13 (byte~) main::$14 (byte~) main::$15 
Successful SSA optimization Pass2AliasElimination
Inlining constant with var siblings (const byte) main::x#0
Constant inlined main::x#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@3(between main::@1 and main::@1)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to main:2 

Created 1 initial phi equivalence classes
Coalesced [19] main::x#3 ← main::x#1
Coalesced down to 1 phi equivalence classes
Culled Empty Block (label) main::@3
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [5] (byte) main::x#2 ← phi( main/(byte/signed byte/word/signed word/dword/signed dword) 0 main::@1/(byte) main::x#1 )
  [6] *((const byte*) SCREEN#0 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2)
  [7] *((const byte*) COLS#0 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2))
  [8] *((const byte*) SCREEN#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2)
  [9] *((const byte*) COLS#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2))
  [10] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2)
  [11] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2))
  [12] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2)
  [13] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2))
  [14] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2)
  [15] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2))
  [16] (byte) main::x#1 ← ++ (byte) main::x#2
  [17] if((byte) main::x#1!=(byte/word/signed word/dword/signed dword) $c9) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  [18] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte[$100]) COLORMAP1
(byte[$100]) COLORMAP2
(byte*) COLS
(byte[$3e8]) MAPDATA
(byte*) SCREEN
(void()) main()
(byte) main::x !reg byte y
(byte) main::x#1 !reg byte y 16.5
(byte) main::x#2 !reg byte y 22.0

Initial phi equivalence classes
[ main::x#2 main::x#1 ]
Complete equivalence classes
[ main::x#2 main::x#1 ]

INITIAL ASM
//SEG0 File Comments
// Tests that constant offset indexing into arrays is handled correctly
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SCREEN = $400
  .label COLS = $d800
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
  //SEG11 [5] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG12 [5] phi (byte) main::x#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main->main::@1#0] -- vbuyy=vbuc1 
    ldy #0
    jmp b1
  //SEG13 [5] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
  //SEG14 [5] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
  //SEG15 main::@1
  b1:
  //SEG16 [6] *((const byte*) SCREEN#0 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA,y
    sta SCREEN,y
  //SEG17 [7] *((const byte*) COLS#0 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA,y
    lda COLORMAP1,x
    sta COLS,y
  //SEG18 [8] *((const byte*) SCREEN#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$c8,y
    sta SCREEN+$c8,y
  //SEG19 [9] *((const byte*) COLS#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$c8,y
    lda COLORMAP1,x
    sta COLS+$c8,y
  //SEG20 [10] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$190,y
    sta SCREEN+$190,y
  //SEG21 [11] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$190,y
    lda COLORMAP1,x
    sta COLS+$190,y
  //SEG22 [12] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$258,y
    sta SCREEN+$258,y
  //SEG23 [13] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$258,y
    lda COLORMAP2,x
    sta COLS+$258,y
  //SEG24 [14] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$320,y
    sta SCREEN+$320,y
  //SEG25 [15] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$320,y
    lda COLORMAP2,x
    sta COLS+$320,y
  //SEG26 [16] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG27 [17] if((byte) main::x#1!=(byte/word/signed word/dword/signed dword) $c9) goto main::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$c9
    bne b1_from_b1
    jmp breturn
  //SEG28 main::@return
  breturn:
  //SEG29 [18] return 
    rts
}
  MAPDATA: .fill $3e8, 0
  COLORMAP1: .fill $100, 0
  COLORMAP2: .fill $100, 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] *((const byte*) SCREEN#0 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [7] *((const byte*) COLS#0 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [8] *((const byte*) SCREEN#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [9] *((const byte*) COLS#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [10] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [11] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [12] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [13] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [14] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [15] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [16] (byte) main::x#1 ← ++ (byte) main::x#2 [ main::x#1 ] ( main:2 [ main::x#1 ] ) always clobbers reg byte y 
Potential registers reg byte y [ main::x#2 main::x#1 ] : reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 38.5: reg byte y [ main::x#2 main::x#1 ] 
Uplift Scope [] 

Uplifting [main] best 1368 combination reg byte y [ main::x#2 main::x#1 ] 
Uplifting [] best 1368 combination 

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Tests that constant offset indexing into arrays is handled correctly
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SCREEN = $400
  .label COLS = $d800
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
  //SEG11 [5] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG12 [5] phi (byte) main::x#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main->main::@1#0] -- vbuyy=vbuc1 
    ldy #0
    jmp b1
  //SEG13 [5] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
  //SEG14 [5] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
  //SEG15 main::@1
  b1:
  //SEG16 [6] *((const byte*) SCREEN#0 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA,y
    sta SCREEN,y
  //SEG17 [7] *((const byte*) COLS#0 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA,y
    lda COLORMAP1,x
    sta COLS,y
  //SEG18 [8] *((const byte*) SCREEN#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$c8,y
    sta SCREEN+$c8,y
  //SEG19 [9] *((const byte*) COLS#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$c8,y
    lda COLORMAP1,x
    sta COLS+$c8,y
  //SEG20 [10] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$190,y
    sta SCREEN+$190,y
  //SEG21 [11] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$190,y
    lda COLORMAP1,x
    sta COLS+$190,y
  //SEG22 [12] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$258,y
    sta SCREEN+$258,y
  //SEG23 [13] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$258,y
    lda COLORMAP2,x
    sta COLS+$258,y
  //SEG24 [14] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$320,y
    sta SCREEN+$320,y
  //SEG25 [15] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$320,y
    lda COLORMAP2,x
    sta COLS+$320,y
  //SEG26 [16] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG27 [17] if((byte) main::x#1!=(byte/word/signed word/dword/signed dword) $c9) goto main::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$c9
    bne b1_from_b1
    jmp breturn
  //SEG28 main::@return
  breturn:
  //SEG29 [18] return 
    rts
}
  MAPDATA: .fill $3e8, 0
  COLORMAP1: .fill $100, 0
  COLORMAP2: .fill $100, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label b1_from_b1 with b1
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b1_from_main:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte[$100]) COLORMAP1
(const byte[$100]) COLORMAP1#0 COLORMAP1 = { fill( $100, 0) }
(byte[$100]) COLORMAP2
(const byte[$100]) COLORMAP2#0 COLORMAP2 = { fill( $100, 0) }
(byte*) COLS
(const byte*) COLS#0 COLS = ((byte*))(word/dword/signed dword) $d800
(byte[$3e8]) MAPDATA
(const byte[$3e8]) MAPDATA#0 MAPDATA = { fill( $3e8, 0) }
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = ((byte*))(word/signed word/dword/signed dword) $400
(void()) main()
(label) main::@1
(label) main::@return
(byte) main::x !reg byte y
(byte) main::x#1 !reg byte y 16.5
(byte) main::x#2 !reg byte y 22.0

reg byte y [ main::x#2 main::x#1 ]


FINAL ASSEMBLER
Score: 1266

//SEG0 File Comments
// Tests that constant offset indexing into arrays is handled correctly
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SCREEN = $400
  .label COLS = $d800
//SEG3 @begin
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
//SEG5 @1
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
//SEG9 @end
//SEG10 main
main: {
  //SEG11 [5] phi from main to main::@1 [phi:main->main::@1]
  //SEG12 [5] phi (byte) main::x#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main->main::@1#0] -- vbuyy=vbuc1 
    ldy #0
  //SEG13 [5] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  //SEG14 [5] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@1->main::@1#0] -- register_copy 
  //SEG15 main::@1
  b1:
  //SEG16 [6] *((const byte*) SCREEN#0 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA,y
    sta SCREEN,y
  //SEG17 [7] *((const byte*) COLS#0 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA,y
    lda COLORMAP1,x
    sta COLS,y
  //SEG18 [8] *((const byte*) SCREEN#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$c8,y
    sta SCREEN+$c8,y
  //SEG19 [9] *((const byte*) COLS#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(byte/word/signed word/dword/signed dword) $c8 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$c8,y
    lda COLORMAP1,x
    sta COLS+$c8,y
  //SEG20 [10] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$190,y
    sta SCREEN+$190,y
  //SEG21 [11] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $190 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$190,y
    lda COLORMAP1,x
    sta COLS+$190,y
  //SEG22 [12] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$258,y
    sta SCREEN+$258,y
  //SEG23 [13] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $258 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$258,y
    lda COLORMAP2,x
    sta COLS+$258,y
  //SEG24 [14] *((const byte*) SCREEN#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$320,y
    sta SCREEN+$320,y
  //SEG25 [15] *((const byte*) COLS#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2#0 + *((const byte[$3e8]) MAPDATA#0+(word/signed word/dword/signed dword) $320 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_pbuc3_derefidx_vbuyy 
    ldx MAPDATA+$320,y
    lda COLORMAP2,x
    sta COLS+$320,y
  //SEG26 [16] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG27 [17] if((byte) main::x#1!=(byte/word/signed word/dword/signed dword) $c9) goto main::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$c9
    bne b1
  //SEG28 main::@return
  //SEG29 [18] return 
    rts
}
  MAPDATA: .fill $3e8, 0
  COLORMAP1: .fill $100, 0
  COLORMAP2: .fill $100, 0

