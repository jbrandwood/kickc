
(void()) __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] (volatile byte) sinpos ← (byte) 0
  [2] (volatile byte) zoomx ← (byte) 0
  [3] (volatile byte) xpos ← (byte) 7
  [4] (volatile byte) greetnm ← (byte) 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [5] phi()
  [6] call main 
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [7] return 
  to:@return

interrupt(HARDWARE_STACK)(void()) irq1()
irq1: scope:[irq1]  from
  [8] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) | (byte) $80
  [9] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  [10] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) 0
  [11] (volatile byte) sinpos ← ++ (volatile byte) sinpos
  [12] (byte) irq1::wobblepos#0 ← (volatile byte) sinpos
  to:irq1::@1
irq1::@1: scope:[irq1]  from irq1 irq1::@9
  [13] (byte) irq1::wobblepos#10 ← phi( irq1/(byte) irq1::wobblepos#0 irq1::@9/(byte) irq1::wobblepos#7 )
  [13] (byte) irq1::line#10 ← phi( irq1/(byte) 0 irq1::@9/(byte) irq1::line#1 )
  [14] if((byte) irq1::line#10!=(byte) $e0) goto irq1::@2
  to:irq1::@3
irq1::@3: scope:[irq1]  from irq1::@1
  [15] call *((const void()*) songPlay) 
  to:irq1::@return
irq1::@return: scope:[irq1]  from irq1::@3
  [16] return 
  to:@return
irq1::@2: scope:[irq1]  from irq1::@1
  [17] (byte) irq1::col#0 ← *((const byte*) rasters + (byte) irq1::line#10)
  [18] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR) ← (byte) irq1::col#0
  [19] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR) ← (byte) irq1::col#0
  [20] if((byte) irq1::line#10<(const nomodify byte) irq1::scrollypos) goto irq1::@4
  to:irq1::@10
irq1::@10: scope:[irq1]  from irq1::@2
  [21] if((byte) irq1::line#10==(const nomodify byte) irq1::scrollypos) goto irq1::@5
  to:irq1::@11
irq1::@11: scope:[irq1]  from irq1::@10
  [22] if((byte) irq1::line#10==(const nomodify byte) irq1::scrollypos+(const nomodify byte) irq1::blackbar) goto irq1::@6
  to:irq1::@12
irq1::@12: scope:[irq1]  from irq1::@11
  [23] if((byte) irq1::line#10!=(const nomodify byte) irq1::scrollypos+(const nomodify byte) irq1::blackbar+(byte) 1) goto irq1::@7
  to:irq1::@13
irq1::@13: scope:[irq1]  from irq1::@12
  [24] (byte) irq1::zoomval#0 ← *((const byte*) SINUS + (volatile byte) zoomx)
  [25] (volatile byte) zoomx ← ++ (volatile byte) zoomx
  [26] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) irq1::zoomval#0
  [27] (byte~) irq1::$7 ← (byte) irq1::zoomval#0 + (byte) 1
  [28] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte~) irq1::$7
  [29] if((volatile byte) zoomx!=(byte) 0) goto irq1::@7
  to:irq1::@14
irq1::@14: scope:[irq1]  from irq1::@13
  [30] (volatile byte) greetnm ← ++ (volatile byte) greetnm
  [31] if((volatile byte) greetnm!=(const nomodify byte) GREETCOUNT) goto irq1::@7
  to:irq1::@15
irq1::@15: scope:[irq1]  from irq1::@14
  [32] (volatile byte) greetnm ← (byte) 0
  to:irq1::@7
irq1::@7: scope:[irq1]  from irq1::@12 irq1::@13 irq1::@14 irq1::@15 irq1::@4 irq1::@5 irq1::@6
  [33] (byte) irq1::wobblepos#7 ← phi( irq1::@12/(byte) irq1::wobblepos#10 irq1::@13/(byte) irq1::wobblepos#10 irq1::@14/(byte) irq1::wobblepos#10 irq1::@15/(byte) irq1::wobblepos#10 irq1::@4/(byte) irq1::wobblepos#1 irq1::@5/(byte) irq1::wobblepos#10 irq1::@6/(byte) irq1::wobblepos#10 )
  [34] (byte) irq1::raster#0 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)
  to:irq1::@8
irq1::@8: scope:[irq1]  from irq1::@7 irq1::@8
  [35] if((byte) irq1::raster#0==*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)) goto irq1::@8
  to:irq1::@9
irq1::@9: scope:[irq1]  from irq1::@8
  [36] (byte) irq1::line#1 ← ++ (byte) irq1::line#10
  to:irq1::@1
irq1::@6: scope:[irq1]  from irq1::@11
  [37] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50
  to:irq1::@7
irq1::@5: scope:[irq1]  from irq1::@10
  [38] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50
  [39] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (volatile byte) xpos
  to:irq1::@7
irq1::@4: scope:[irq1]  from irq1::@2
  [40] (byte~) irq1::$12 ← (byte) $28 + *((const byte*) SINUS + (byte) irq1::wobblepos#10)
  [41] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte~) irq1::$12
  [42] (byte) irq1::wobblepos#1 ← ++ (byte) irq1::wobblepos#10
  [43] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) $66
  to:irq1::@7

(void()) main()
main: scope:[main]  from __start::@1
  [44] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $47
  [45] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $53
  [46] call memset 
  to:main::@6
main::@6: scope:[main]  from main
  asm { lda#0  }
  [48] call *((const void()*) songInit) 
  to:main::@1
main::@1: scope:[main]  from main::@2 main::@6
  [49] (byte) main::i1#2 ← phi( main::@2/(byte) main::i1#1 main::@6/(byte) 0 )
  [50] if((byte) main::i1#2<(byte) $bc*(const byte) SIZEOF_BYTE) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1 main::@3
  [51] (byte) main::i#2 ← phi( main::@1/(byte) 0 main::@3/(byte) main::i#1 )
  [52] *((const nomodify byte*) PALETTE_RED + (byte) main::i#2) ← *((const byte*) PAL_RED + (byte) main::i#2)
  [53] *((const nomodify byte*) PALETTE_GREEN + (byte) main::i#2) ← *((const byte*) PAL_GREEN + (byte) main::i#2)
  [54] *((const nomodify byte*) PALETTE_BLUE + (byte) main::i#2) ← *((const byte*) PAL_BLUE + (byte) main::i#2)
  [55] (byte) main::i#1 ← ++ (byte) main::i#2
  [56] if((byte) main::i#1!=(byte) 0) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@3
  asm { sei  }
  [58] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR
  [59] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (byte) $16
  [60] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f
  [61] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER
  [62] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_STACK)(void()) irq1()
  [63] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK
  [64] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO
  [65] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (byte) 1
  asm { cli  }
  to:main::@5
main::@5: scope:[main]  from main::@4 main::@5
  [67] phi()
  to:main::@5
main::@2: scope:[main]  from main::@1
  [68] *((const nomodify byte*) SCREEN+(byte)(number) 3*(number) $28 + (byte) main::i1#2) ← *((const byte*) MEGA_LOGO + (byte) main::i1#2)
  [69] (byte) main::i1#1 ← ++ (byte) main::i1#2
  to:main::@1

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from main
  [70] phi()
  to:memset::@1
memset::@1: scope:[memset]  from memset memset::@2
  [71] (byte*) memset::dst#2 ← phi( memset/(byte*)(const void*) memset::str#0 memset::@2/(byte*) memset::dst#1 )
  [72] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset::@1
  [73] return 
  to:@return
memset::@2: scope:[memset]  from memset::@1
  [74] *((byte*) memset::dst#2) ← (const byte) memset::c#0
  [75] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  to:memset::@1
