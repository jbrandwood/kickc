byte* SCREEN = $0400;

main();

void main() {
    byte i=100;
    do {
        byte j=100;
        do {
            nest1();
        } while (--j>0)
    } while (--i>0)
}

void nest1() {
    byte i=100;
    do {
        byte j=100;
        do {
            nest2();
        } while (--j>0)
    } while (--i>0)
}

void nest2() {
    byte i=100;
    do {
        byte j=100;
        do {
            *SCREEN = j;
        } while (--j>0)
    } while (--i>0)
}

Adding pre/post-modifier (byte) main::j ← -- (byte) main::j
Adding pre/post-modifier (byte) main::i ← -- (byte) main::i
Adding pre/post-modifier (byte) nest1::j ← -- (byte) nest1::j
Adding pre/post-modifier (byte) nest1::i ← -- (byte) nest1::i
Adding pre/post-modifier (byte) nest2::j ← -- (byte) nest2::j
Adding pre/post-modifier (byte) nest2::i ← -- (byte) nest2::i
PROGRAM
  (byte*) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  proc (void()) main()
  (byte) main::i ← (byte) 100
main::@1:
  (byte) main::j ← (byte) 100
main::@2:
  (void~) main::$0 ← call nest1 
  (byte) main::j ← -- (byte) main::j
  (boolean~) main::$1 ← (byte) main::j > (byte) 0
  if((boolean~) main::$1) goto main::@2
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$2 ← (byte) main::i > (byte) 0
  if((boolean~) main::$2) goto main::@1
main::@return:
  return 
  endproc // main()
  proc (void()) nest1()
  (byte) nest1::i ← (byte) 100
nest1::@1:
  (byte) nest1::j ← (byte) 100
nest1::@2:
  (void~) nest1::$0 ← call nest2 
  (byte) nest1::j ← -- (byte) nest1::j
  (boolean~) nest1::$1 ← (byte) nest1::j > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  (byte) nest1::i ← -- (byte) nest1::i
  (boolean~) nest1::$2 ← (byte) nest1::i > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
nest1::@return:
  return 
  endproc // nest1()
  proc (void()) nest2()
  (byte) nest2::i ← (byte) 100
nest2::@1:
  (byte) nest2::j ← (byte) 100
nest2::@2:
  *((byte*) SCREEN) ← (byte) nest2::j
  (byte) nest2::j ← -- (byte) nest2::j
  (boolean~) nest2::$0 ← (byte) nest2::j > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  (byte) nest2::i ← -- (byte) nest2::i
  (boolean~) nest2::$1 ← (byte) nest2::i > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
nest2::@return:
  return 
  endproc // nest2()

SYMBOLS
(void~) $0
(byte*) SCREEN
(void()) main()
(void~) main::$0
(boolean~) main::$1
(boolean~) main::$2
(label) main::@1
(label) main::@2
(label) main::@return
(byte) main::i
(byte) main::j
(void()) nest1()
(void~) nest1::$0
(boolean~) nest1::$1
(boolean~) nest1::$2
(label) nest1::@1
(label) nest1::@2
(label) nest1::@return
(byte) nest1::i
(byte) nest1::j
(void()) nest2()
(boolean~) nest2::$0
(boolean~) nest2::$1
(label) nest2::@1
(label) nest2::@2
(label) nest2::@return
(byte) nest2::i
(byte) nest2::j

INITIAL CONTROL FLOW GRAPH
@BEGIN: from
  (byte*) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@1
main: from
  (byte) main::i ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  (byte) main::j ← (byte) 100
  to:main::@2
main::@2: from main::@1 main::@2
  (void~) main::$0 ← call nest1 
  (byte) main::j ← -- (byte) main::j
  (boolean~) main::$1 ← (byte) main::j > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@2
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$2 ← (byte) main::i > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@4
main::@4: from main::@3
  to:main::@return
main::@return: from main::@4
  return 
  to:@RETURN
@1: from @BEGIN
  to:@2
nest1: from
  (byte) nest1::i ← (byte) 100
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte) nest1::j ← (byte) 100
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@2
  (void~) nest1::$0 ← call nest2 
  (byte) nest1::j ← -- (byte) nest1::j
  (boolean~) nest1::$1 ← (byte) nest1::j > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@2
  (byte) nest1::i ← -- (byte) nest1::i
  (boolean~) nest1::$2 ← (byte) nest1::i > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@4
nest1::@4: from nest1::@3
  to:nest1::@return
nest1::@return: from nest1::@4
  return 
  to:@RETURN
@2: from @1
  to:@3
nest2: from
  (byte) nest2::i ← (byte) 100
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::j ← (byte) 100
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  *((byte*) SCREEN) ← (byte) nest2::j
  (byte) nest2::j ← -- (byte) nest2::j
  (boolean~) nest2::$0 ← (byte) nest2::j > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i ← -- (byte) nest2::i
  (boolean~) nest2::$1 ← (byte) nest2::i > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@4
nest2::@4: from nest2::@3
  to:nest2::@return
nest2::@return: from nest2::@4
  return 
  to:@RETURN
@3: from @2
  to:@END
@END: from @3

Removing empty block main::@4
Removing empty block @1
Removing empty block nest1::@4
Removing empty block @2
Removing empty block nest2::@4
Removing empty block @3
CONTROL FLOW GRAPH
@BEGIN: from
  (byte*) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@END
main: from
  (byte) main::i ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  (byte) main::j ← (byte) 100
  to:main::@2
main::@2: from main::@1 main::@2
  (void~) main::$0 ← call nest1 
  (byte) main::j ← -- (byte) main::j
  (boolean~) main::$1 ← (byte) main::j > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@2
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$2 ← (byte) main::i > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from
  (byte) nest1::i ← (byte) 100
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte) nest1::j ← (byte) 100
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@2
  (void~) nest1::$0 ← call nest2 
  (byte) nest1::j ← -- (byte) nest1::j
  (boolean~) nest1::$1 ← (byte) nest1::j > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@2
  (byte) nest1::i ← -- (byte) nest1::i
  (boolean~) nest1::$2 ← (byte) nest1::i > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from
  (byte) nest2::i ← (byte) 100
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::j ← (byte) 100
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  *((byte*) SCREEN) ← (byte) nest2::j
  (byte) nest2::j ← -- (byte) nest2::j
  (boolean~) nest2::$0 ← (byte) nest2::j > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i ← -- (byte) nest2::i
  (boolean~) nest2::$1 ← (byte) nest2::i > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@BEGIN: from
  (byte*) SCREEN ← (word) 1024
  call main param-assignment
  to:@4
@4: from @BEGIN
  to:@END
main: from @BEGIN
  (byte) main::i ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  (byte) main::j ← (byte) 100
  to:main::@2
main::@2: from main::@1 main::@5
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j ← -- (byte) main::j
  (boolean~) main::$1 ← (byte) main::j > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$2 ← (byte) main::i > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  (byte) nest1::i ← (byte) 100
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte) nest1::j ← (byte) 100
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j ← -- (byte) nest1::j
  (boolean~) nest1::$1 ← (byte) nest1::j > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i ← -- (byte) nest1::i
  (boolean~) nest1::$2 ← (byte) nest1::i > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  (byte) nest2::i ← (byte) 100
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::j ← (byte) 100
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  *((byte*) SCREEN) ← (byte) nest2::j
  (byte) nest2::j ← -- (byte) nest2::j
  (boolean~) nest2::$0 ← (byte) nest2::j > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i ← -- (byte) nest2::i
  (boolean~) nest2::$1 ← (byte) nest2::i > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @4

Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@BEGIN: from
  (byte*) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@4
@4: from @BEGIN
  to:@END
main: from @BEGIN
  (byte*) SCREEN#13 ← phi( @BEGIN/(byte*) SCREEN#0 )
  (byte) main::i#0 ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#11 ← phi( main/(byte*) SCREEN#13 main::@3/(byte*) SCREEN#14 )
  (byte) main::i#5 ← phi( main/(byte) main::i#0 main::@3/(byte) main::i#1 )
  (byte) main::j#0 ← (byte) 100
  to:main::@2
main::@2: from main::@1 main::@5
  (byte*) SCREEN#10 ← phi( main::@1/(byte*) SCREEN#11 main::@5/(byte*) SCREEN#12 )
  (byte) main::i#4 ← phi( main::@1/(byte) main::i#5 main::@5/(byte) main::i#3 )
  (byte) main::j#3 ← phi( main::@1/(byte) main::j#0 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte*) SCREEN#12 ← phi( main::@2/(byte*) SCREEN#10 )
  (byte) main::i#3 ← phi( main::@2/(byte) main::i#4 )
  (byte) main::j#2 ← phi( main::@2/(byte) main::j#3 )
  (byte) main::j#1 ← -- (byte) main::j#2
  (boolean~) main::$1 ← (byte) main::j#1 > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte*) SCREEN#14 ← phi( main::@5/(byte*) SCREEN#12 )
  (byte) main::i#2 ← phi( main::@5/(byte) main::i#3 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$2 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  (byte*) SCREEN#8 ← phi( main::@2/(byte*) SCREEN#10 )
  (byte) nest1::i#0 ← (byte) 100
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#6 ← phi( nest1/(byte*) SCREEN#8 nest1::@3/(byte*) SCREEN#9 )
  (byte) nest1::i#5 ← phi( nest1/(byte) nest1::i#0 nest1::@3/(byte) nest1::i#1 )
  (byte) nest1::j#0 ← (byte) 100
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte*) SCREEN#5 ← phi( nest1::@1/(byte*) SCREEN#6 nest1::@5/(byte*) SCREEN#7 )
  (byte) nest1::i#4 ← phi( nest1::@1/(byte) nest1::i#5 nest1::@5/(byte) nest1::i#3 )
  (byte) nest1::j#3 ← phi( nest1::@1/(byte) nest1::j#0 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte*) SCREEN#7 ← phi( nest1::@2/(byte*) SCREEN#5 )
  (byte) nest1::i#3 ← phi( nest1::@2/(byte) nest1::i#4 )
  (byte) nest1::j#2 ← phi( nest1::@2/(byte) nest1::j#3 )
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  (boolean~) nest1::$1 ← (byte) nest1::j#1 > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte*) SCREEN#9 ← phi( nest1::@5/(byte*) SCREEN#7 )
  (byte) nest1::i#2 ← phi( nest1::@5/(byte) nest1::i#3 )
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  (boolean~) nest1::$2 ← (byte) nest1::i#1 > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  (byte*) SCREEN#3 ← phi( nest1::@2/(byte*) SCREEN#5 )
  (byte) nest2::i#0 ← (byte) 100
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#4 ← phi( nest2/(byte) nest2::i#0 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#2 ← phi( nest2/(byte*) SCREEN#3 nest2::@3/(byte*) SCREEN#4 )
  (byte) nest2::j#0 ← (byte) 100
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::i#3 ← phi( nest2::@1/(byte) nest2::i#4 nest2::@2/(byte) nest2::i#3 )
  (byte*) SCREEN#1 ← phi( nest2::@1/(byte*) SCREEN#2 nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) nest2::j#0 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  (boolean~) nest2::$0 ← (byte) nest2::j#1 > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte*) SCREEN#4 ← phi( nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::i#2 ← phi( nest2::@2/(byte) nest2::i#3 )
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  (boolean~) nest2::$1 ← (byte) nest2::i#1 > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @4

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@BEGIN: from
  (byte*) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@4
@4: from @BEGIN
  to:@END
main: from @BEGIN
  (byte*) SCREEN#13 ← phi( @BEGIN/(byte*) SCREEN#0 )
  (byte) main::i#0 ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#11 ← phi( main/(byte*) SCREEN#13 main::@3/(byte*) SCREEN#14 )
  (byte) main::i#5 ← phi( main/(byte) main::i#0 main::@3/(byte) main::i#1 )
  (byte) main::j#0 ← (byte) 100
  to:main::@2
main::@2: from main::@1 main::@5
  (byte*) SCREEN#10 ← phi( main::@1/(byte*) SCREEN#11 main::@5/(byte*) SCREEN#12 )
  (byte) main::i#4 ← phi( main::@1/(byte) main::i#5 main::@5/(byte) main::i#3 )
  (byte) main::j#3 ← phi( main::@1/(byte) main::j#0 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte*) SCREEN#12 ← phi( main::@2/(byte*) SCREEN#10 )
  (byte) main::i#3 ← phi( main::@2/(byte) main::i#4 )
  (byte) main::j#2 ← phi( main::@2/(byte) main::j#3 )
  (byte) main::j#1 ← -- (byte) main::j#2
  (boolean~) main::$1 ← (byte) main::j#1 > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte*) SCREEN#14 ← phi( main::@5/(byte*) SCREEN#12 )
  (byte) main::i#2 ← phi( main::@5/(byte) main::i#3 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$2 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  (byte*) SCREEN#8 ← phi( main::@2/(byte*) SCREEN#10 )
  (byte) nest1::i#0 ← (byte) 100
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#6 ← phi( nest1/(byte*) SCREEN#8 nest1::@3/(byte*) SCREEN#9 )
  (byte) nest1::i#5 ← phi( nest1/(byte) nest1::i#0 nest1::@3/(byte) nest1::i#1 )
  (byte) nest1::j#0 ← (byte) 100
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte*) SCREEN#5 ← phi( nest1::@1/(byte*) SCREEN#6 nest1::@5/(byte*) SCREEN#7 )
  (byte) nest1::i#4 ← phi( nest1::@1/(byte) nest1::i#5 nest1::@5/(byte) nest1::i#3 )
  (byte) nest1::j#3 ← phi( nest1::@1/(byte) nest1::j#0 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte*) SCREEN#7 ← phi( nest1::@2/(byte*) SCREEN#5 )
  (byte) nest1::i#3 ← phi( nest1::@2/(byte) nest1::i#4 )
  (byte) nest1::j#2 ← phi( nest1::@2/(byte) nest1::j#3 )
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  (boolean~) nest1::$1 ← (byte) nest1::j#1 > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte*) SCREEN#9 ← phi( nest1::@5/(byte*) SCREEN#7 )
  (byte) nest1::i#2 ← phi( nest1::@5/(byte) nest1::i#3 )
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  (boolean~) nest1::$2 ← (byte) nest1::i#1 > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  (byte*) SCREEN#3 ← phi( nest1::@2/(byte*) SCREEN#5 )
  (byte) nest2::i#0 ← (byte) 100
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#4 ← phi( nest2/(byte) nest2::i#0 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#2 ← phi( nest2/(byte*) SCREEN#3 nest2::@3/(byte*) SCREEN#4 )
  (byte) nest2::j#0 ← (byte) 100
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::i#3 ← phi( nest2::@1/(byte) nest2::i#4 nest2::@2/(byte) nest2::i#3 )
  (byte*) SCREEN#1 ← phi( nest2::@1/(byte*) SCREEN#2 nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) nest2::j#0 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  (boolean~) nest2::$0 ← (byte) nest2::j#1 > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte*) SCREEN#4 ← phi( nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::i#2 ← phi( nest2::@2/(byte) nest2::i#3 )
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  (boolean~) nest2::$1 ← (byte) nest2::i#1 > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @4

Culled Empty Block (label) @4
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@BEGIN: from
  (byte*) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@END
main: from @BEGIN
  (byte*) SCREEN#13 ← phi( @BEGIN/(byte*) SCREEN#0 )
  (byte) main::i#0 ← (byte) 100
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#11 ← phi( main/(byte*) SCREEN#13 main::@3/(byte*) SCREEN#14 )
  (byte) main::i#5 ← phi( main/(byte) main::i#0 main::@3/(byte) main::i#1 )
  (byte) main::j#0 ← (byte) 100
  to:main::@2
main::@2: from main::@1 main::@5
  (byte*) SCREEN#10 ← phi( main::@1/(byte*) SCREEN#11 main::@5/(byte*) SCREEN#12 )
  (byte) main::i#4 ← phi( main::@1/(byte) main::i#5 main::@5/(byte) main::i#3 )
  (byte) main::j#3 ← phi( main::@1/(byte) main::j#0 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte*) SCREEN#12 ← phi( main::@2/(byte*) SCREEN#10 )
  (byte) main::i#3 ← phi( main::@2/(byte) main::i#4 )
  (byte) main::j#2 ← phi( main::@2/(byte) main::j#3 )
  (byte) main::j#1 ← -- (byte) main::j#2
  (boolean~) main::$1 ← (byte) main::j#1 > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte*) SCREEN#14 ← phi( main::@5/(byte*) SCREEN#12 )
  (byte) main::i#2 ← phi( main::@5/(byte) main::i#3 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$2 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  (byte*) SCREEN#8 ← phi( main::@2/(byte*) SCREEN#10 )
  (byte) nest1::i#0 ← (byte) 100
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#6 ← phi( nest1/(byte*) SCREEN#8 nest1::@3/(byte*) SCREEN#9 )
  (byte) nest1::i#5 ← phi( nest1/(byte) nest1::i#0 nest1::@3/(byte) nest1::i#1 )
  (byte) nest1::j#0 ← (byte) 100
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte*) SCREEN#5 ← phi( nest1::@1/(byte*) SCREEN#6 nest1::@5/(byte*) SCREEN#7 )
  (byte) nest1::i#4 ← phi( nest1::@1/(byte) nest1::i#5 nest1::@5/(byte) nest1::i#3 )
  (byte) nest1::j#3 ← phi( nest1::@1/(byte) nest1::j#0 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte*) SCREEN#7 ← phi( nest1::@2/(byte*) SCREEN#5 )
  (byte) nest1::i#3 ← phi( nest1::@2/(byte) nest1::i#4 )
  (byte) nest1::j#2 ← phi( nest1::@2/(byte) nest1::j#3 )
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  (boolean~) nest1::$1 ← (byte) nest1::j#1 > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte*) SCREEN#9 ← phi( nest1::@5/(byte*) SCREEN#7 )
  (byte) nest1::i#2 ← phi( nest1::@5/(byte) nest1::i#3 )
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  (boolean~) nest1::$2 ← (byte) nest1::i#1 > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  (byte*) SCREEN#3 ← phi( nest1::@2/(byte*) SCREEN#5 )
  (byte) nest2::i#0 ← (byte) 100
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#4 ← phi( nest2/(byte) nest2::i#0 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#2 ← phi( nest2/(byte*) SCREEN#3 nest2::@3/(byte*) SCREEN#4 )
  (byte) nest2::j#0 ← (byte) 100
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::i#3 ← phi( nest2::@1/(byte) nest2::i#4 nest2::@2/(byte) nest2::i#3 )
  (byte*) SCREEN#1 ← phi( nest2::@1/(byte*) SCREEN#2 nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) nest2::j#0 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  (boolean~) nest2::$0 ← (byte) nest2::j#1 > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte*) SCREEN#4 ← phi( nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::i#2 ← phi( nest2::@2/(byte) nest2::i#3 )
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  (boolean~) nest2::$1 ← (byte) nest2::i#1 > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Constant (byte*) SCREEN#0 (word) 1024
Constant (byte) main::i#0 (byte) 100
Constant (byte) main::j#0 (byte) 100
Constant (byte) nest1::i#0 (byte) 100
Constant (byte) nest1::j#0 (byte) 100
Constant (byte) nest2::i#0 (byte) 100
Constant (byte) nest2::j#0 (byte) 100
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  (byte*) SCREEN#13 ← phi( @BEGIN/(word) 1024 )
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#11 ← phi( main/(byte*) SCREEN#13 main::@3/(byte*) SCREEN#14 )
  (byte) main::i#5 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte*) SCREEN#10 ← phi( main::@1/(byte*) SCREEN#11 main::@5/(byte*) SCREEN#12 )
  (byte) main::i#4 ← phi( main::@1/(byte) main::i#5 main::@5/(byte) main::i#3 )
  (byte) main::j#3 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte*) SCREEN#12 ← phi( main::@2/(byte*) SCREEN#10 )
  (byte) main::i#3 ← phi( main::@2/(byte) main::i#4 )
  (byte) main::j#2 ← phi( main::@2/(byte) main::j#3 )
  (byte) main::j#1 ← -- (byte) main::j#2
  (boolean~) main::$1 ← (byte) main::j#1 > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte*) SCREEN#14 ← phi( main::@5/(byte*) SCREEN#12 )
  (byte) main::i#2 ← phi( main::@5/(byte) main::i#3 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$2 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  (byte*) SCREEN#8 ← phi( main::@2/(byte*) SCREEN#10 )
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#6 ← phi( nest1/(byte*) SCREEN#8 nest1::@3/(byte*) SCREEN#9 )
  (byte) nest1::i#5 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte*) SCREEN#5 ← phi( nest1::@1/(byte*) SCREEN#6 nest1::@5/(byte*) SCREEN#7 )
  (byte) nest1::i#4 ← phi( nest1::@1/(byte) nest1::i#5 nest1::@5/(byte) nest1::i#3 )
  (byte) nest1::j#3 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte*) SCREEN#7 ← phi( nest1::@2/(byte*) SCREEN#5 )
  (byte) nest1::i#3 ← phi( nest1::@2/(byte) nest1::i#4 )
  (byte) nest1::j#2 ← phi( nest1::@2/(byte) nest1::j#3 )
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  (boolean~) nest1::$1 ← (byte) nest1::j#1 > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte*) SCREEN#9 ← phi( nest1::@5/(byte*) SCREEN#7 )
  (byte) nest1::i#2 ← phi( nest1::@5/(byte) nest1::i#3 )
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  (boolean~) nest1::$2 ← (byte) nest1::i#1 > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  (byte*) SCREEN#3 ← phi( nest1::@2/(byte*) SCREEN#5 )
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#4 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#2 ← phi( nest2/(byte*) SCREEN#3 nest2::@3/(byte*) SCREEN#4 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::i#3 ← phi( nest2::@1/(byte) nest2::i#4 nest2::@2/(byte) nest2::i#3 )
  (byte*) SCREEN#1 ← phi( nest2::@1/(byte*) SCREEN#2 nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  (boolean~) nest2::$0 ← (byte) nest2::j#1 > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte*) SCREEN#4 ← phi( nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::i#2 ← phi( nest2::@2/(byte) nest2::i#3 )
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  (boolean~) nest2::$1 ← (byte) nest2::i#1 > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Alias (byte) main::j#2 = (byte) main::j#3 
Alias (byte) main::i#2 = (byte) main::i#3 (byte) main::i#4 
Alias (byte*) SCREEN#10 = (byte*) SCREEN#12 (byte*) SCREEN#14 (byte*) SCREEN#8 
Alias (byte) nest1::j#2 = (byte) nest1::j#3 
Alias (byte) nest1::i#2 = (byte) nest1::i#3 (byte) nest1::i#4 
Alias (byte*) SCREEN#3 = (byte*) SCREEN#7 (byte*) SCREEN#5 (byte*) SCREEN#9 
Alias (byte) nest2::i#2 = (byte) nest2::i#3 
Alias (byte*) SCREEN#1 = (byte*) SCREEN#4 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  (byte*) SCREEN#13 ← phi( @BEGIN/(word) 1024 )
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#11 ← phi( main/(byte*) SCREEN#13 main::@3/(byte*) SCREEN#10 )
  (byte) main::i#5 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte*) SCREEN#10 ← phi( main::@1/(byte*) SCREEN#11 main::@5/(byte*) SCREEN#10 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#5 main::@5/(byte) main::i#2 )
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  (boolean~) main::$1 ← (byte) main::j#1 > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$2 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#6 ← phi( nest1/(byte*) SCREEN#10 nest1::@3/(byte*) SCREEN#3 )
  (byte) nest1::i#5 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte*) SCREEN#3 ← phi( nest1::@1/(byte*) SCREEN#6 nest1::@5/(byte*) SCREEN#3 )
  (byte) nest1::i#2 ← phi( nest1::@1/(byte) nest1::i#5 nest1::@5/(byte) nest1::i#2 )
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  (boolean~) nest1::$1 ← (byte) nest1::j#1 > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  (boolean~) nest1::$2 ← (byte) nest1::i#1 > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#4 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#2 ← phi( nest2/(byte*) SCREEN#3 nest2::@3/(byte*) SCREEN#1 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::i#2 ← phi( nest2::@1/(byte) nest2::i#4 nest2::@2/(byte) nest2::i#2 )
  (byte*) SCREEN#1 ← phi( nest2::@1/(byte*) SCREEN#2 nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  (boolean~) nest2::$0 ← (byte) nest2::j#1 > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  (boolean~) nest2::$1 ← (byte) nest2::i#1 > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Redundant Phi (byte*) SCREEN#13 (word) 1024
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#11 ← phi( main/(word) 1024 main::@3/(byte*) SCREEN#10 )
  (byte) main::i#5 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte*) SCREEN#10 ← phi( main::@1/(byte*) SCREEN#11 main::@5/(byte*) SCREEN#10 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#5 main::@5/(byte) main::i#2 )
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  (boolean~) main::$1 ← (byte) main::j#1 > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$2 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#6 ← phi( nest1/(byte*) SCREEN#10 nest1::@3/(byte*) SCREEN#3 )
  (byte) nest1::i#5 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte*) SCREEN#3 ← phi( nest1::@1/(byte*) SCREEN#6 nest1::@5/(byte*) SCREEN#3 )
  (byte) nest1::i#2 ← phi( nest1::@1/(byte) nest1::i#5 nest1::@5/(byte) nest1::i#2 )
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  (boolean~) nest1::$1 ← (byte) nest1::j#1 > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  (boolean~) nest1::$2 ← (byte) nest1::i#1 > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#4 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#2 ← phi( nest2/(byte*) SCREEN#3 nest2::@3/(byte*) SCREEN#1 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::i#2 ← phi( nest2::@1/(byte) nest2::i#4 nest2::@2/(byte) nest2::i#2 )
  (byte*) SCREEN#1 ← phi( nest2::@1/(byte*) SCREEN#2 nest2::@2/(byte*) SCREEN#1 )
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  (boolean~) nest2::$0 ← (byte) nest2::j#1 > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  (boolean~) nest2::$1 ← (byte) nest2::i#1 > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Self Phi Eliminated (byte) main::i#2
Self Phi Eliminated (byte*) SCREEN#10
Self Phi Eliminated (byte) nest1::i#2
Self Phi Eliminated (byte*) SCREEN#3
Self Phi Eliminated (byte*) SCREEN#1
Self Phi Eliminated (byte) nest2::i#2
Succesful SSA optimization Pass2SelfPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#11 ← phi( main/(word) 1024 main::@3/(byte*) SCREEN#10 )
  (byte) main::i#5 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte*) SCREEN#10 ← phi( main::@1/(byte*) SCREEN#11 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#5 )
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  (boolean~) main::$1 ← (byte) main::j#1 > (byte) 0
  if((boolean~) main::$1) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$2 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$2) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#6 ← phi( nest1/(byte*) SCREEN#10 nest1::@3/(byte*) SCREEN#3 )
  (byte) nest1::i#5 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte*) SCREEN#3 ← phi( nest1::@1/(byte*) SCREEN#6 )
  (byte) nest1::i#2 ← phi( nest1::@1/(byte) nest1::i#5 )
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  (boolean~) nest1::$1 ← (byte) nest1::j#1 > (byte) 0
  if((boolean~) nest1::$1) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  (boolean~) nest1::$2 ← (byte) nest1::i#1 > (byte) 0
  if((boolean~) nest1::$2) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#4 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#2 ← phi( nest2/(byte*) SCREEN#3 nest2::@3/(byte*) SCREEN#1 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::i#2 ← phi( nest2::@1/(byte) nest2::i#4 )
  (byte*) SCREEN#1 ← phi( nest2::@1/(byte*) SCREEN#2 )
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  (boolean~) nest2::$0 ← (byte) nest2::j#1 > (byte) 0
  if((boolean~) nest2::$0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  (boolean~) nest2::$1 ← (byte) nest2::i#1 > (byte) 0
  if((boolean~) nest2::$1) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Simple Condition (boolean~) main::$1 if((byte) main::j#1>(byte) 0) goto main::@2
Simple Condition (boolean~) main::$2 if((byte) main::i#1>(byte) 0) goto main::@1
Simple Condition (boolean~) nest1::$1 if((byte) nest1::j#1>(byte) 0) goto nest1::@2
Simple Condition (boolean~) nest1::$2 if((byte) nest1::i#1>(byte) 0) goto nest1::@1
Simple Condition (boolean~) nest2::$0 if((byte) nest2::j#1>(byte) 0) goto nest2::@2
Simple Condition (boolean~) nest2::$1 if((byte) nest2::i#1>(byte) 0) goto nest2::@1
Succesful SSA optimization Pass2ConditionalJumpSimplification
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#11 ← phi( main/(word) 1024 main::@3/(byte*) SCREEN#10 )
  (byte) main::i#5 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte*) SCREEN#10 ← phi( main::@1/(byte*) SCREEN#11 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#5 )
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  if((byte) main::j#1>(byte) 0) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#6 ← phi( nest1/(byte*) SCREEN#10 nest1::@3/(byte*) SCREEN#3 )
  (byte) nest1::i#5 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte*) SCREEN#3 ← phi( nest1::@1/(byte*) SCREEN#6 )
  (byte) nest1::i#2 ← phi( nest1::@1/(byte) nest1::i#5 )
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  if((byte) nest1::j#1>(byte) 0) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  if((byte) nest1::i#1>(byte) 0) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#4 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#2 ← phi( nest2/(byte*) SCREEN#3 nest2::@3/(byte*) SCREEN#1 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::i#2 ← phi( nest2::@1/(byte) nest2::i#4 )
  (byte*) SCREEN#1 ← phi( nest2::@1/(byte*) SCREEN#2 )
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  if((byte) nest2::j#1>(byte) 0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  if((byte) nest2::i#1>(byte) 0) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Alias (byte) main::i#2 = (byte) main::i#5 
Alias (byte*) SCREEN#10 = (byte*) SCREEN#11 
Alias (byte) nest1::i#2 = (byte) nest1::i#5 
Alias (byte*) SCREEN#3 = (byte*) SCREEN#6 
Alias (byte*) SCREEN#1 = (byte*) SCREEN#2 
Alias (byte) nest2::i#2 = (byte) nest2::i#4 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#10 ← phi( main/(word) 1024 main::@3/(byte*) SCREEN#10 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  if((byte) main::j#1>(byte) 0) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#3 ← phi( nest1/(byte*) SCREEN#10 nest1::@3/(byte*) SCREEN#3 )
  (byte) nest1::i#2 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  if((byte) nest1::j#1>(byte) 0) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  if((byte) nest1::i#1>(byte) 0) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#2 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#1 ← phi( nest2/(byte*) SCREEN#3 nest2::@3/(byte*) SCREEN#1 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  if((byte) nest2::j#1>(byte) 0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  if((byte) nest2::i#1>(byte) 0) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Self Phi Eliminated (byte*) SCREEN#10
Self Phi Eliminated (byte*) SCREEN#3
Self Phi Eliminated (byte*) SCREEN#1
Succesful SSA optimization Pass2SelfPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte*) SCREEN#10 ← phi( main/(word) 1024 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  if((byte) main::j#1>(byte) 0) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#3 ← phi( nest1/(byte*) SCREEN#10 )
  (byte) nest1::i#2 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  if((byte) nest1::j#1>(byte) 0) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  if((byte) nest1::i#1>(byte) 0) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#2 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#1 ← phi( nest2/(byte*) SCREEN#3 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  if((byte) nest2::j#1>(byte) 0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  if((byte) nest2::i#1>(byte) 0) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Constant (byte*) SCREEN#10 (word) 1024
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  if((byte) main::j#1>(byte) 0) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#3 ← phi( nest1/(word) 1024 )
  (byte) nest1::i#2 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  if((byte) nest1::j#1>(byte) 0) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  if((byte) nest1::i#1>(byte) 0) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#2 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  (byte*) SCREEN#1 ← phi( nest2/(byte*) SCREEN#3 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  if((byte) nest2::j#1>(byte) 0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  if((byte) nest2::i#1>(byte) 0) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Alias (byte*) SCREEN#1 = (byte*) SCREEN#3 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  if((byte) main::j#1>(byte) 0) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte*) SCREEN#1 ← phi( nest1/(word) 1024 )
  (byte) nest1::i#2 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  if((byte) nest1::j#1>(byte) 0) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  if((byte) nest1::i#1>(byte) 0) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#2 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((byte*) SCREEN#1) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  if((byte) nest2::j#1>(byte) 0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  if((byte) nest2::i#1>(byte) 0) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Redundant Phi (byte*) SCREEN#1 (word) 1024
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 )
  to:main::@2
main::@2: from main::@1 main::@5
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  if((byte) main::j#1>(byte) 0) goto main::@2
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@1
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  (byte) nest1::i#2 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  if((byte) nest1::j#1>(byte) 0) goto nest1::@2
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  if((byte) nest1::i#1>(byte) 0) goto nest1::@1
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  (byte) nest2::i#2 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 )
  *((word) 1024) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  if((byte) nest2::j#1>(byte) 0) goto nest2::@2
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  if((byte) nest2::i#1>(byte) 0) goto nest2::@1
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
@END: from @BEGIN

Block Sequence Planned @BEGIN @END main main::@1 main::@2 main::@5 main::@3 main::@return nest1 nest1::@1 nest1::@2 nest1::@5 nest1::@3 nest1::@return nest2 nest2::@1 nest2::@2 nest2::@3 nest2::@return 
Added new block during phi lifting main::@6(between main::@3 and main::@1)
Added new block during phi lifting main::@7(between main::@5 and main::@2)
Added new block during phi lifting nest1::@6(between nest1::@3 and nest1::@1)
Added new block during phi lifting nest1::@7(between nest1::@5 and nest1::@2)
Added new block during phi lifting nest2::@5(between nest2::@3 and nest2::@1)
Added new block during phi lifting nest2::@6(between nest2::@2 and nest2::@2)
Block Sequence Planned @BEGIN @END main main::@1 main::@2 main::@5 main::@3 main::@return main::@6 main::@7 nest1 nest1::@1 nest1::@2 nest1::@5 nest1::@3 nest1::@return nest1::@6 nest1::@7 nest2 nest2::@1 nest2::@2 nest2::@3 nest2::@return nest2::@5 nest2::@6 
CONTROL FLOW GRAPH - PHI LIFTED
@BEGIN: from
  call main param-assignment
  to:@END
@END: from @BEGIN
main: from @BEGIN
  to:main::@1
main::@1: from main main::@6
  (byte) main::i#2 ← phi( main/(byte) 100 main::@6/(byte~) main::i#6 )
  to:main::@2
main::@2: from main::@1 main::@7
  (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@7/(byte~) main::j#4 )
  call nest1 param-assignment
  to:main::@5
main::@5: from main::@2
  (byte) main::j#1 ← -- (byte) main::j#2
  if((byte) main::j#1>(byte) 0) goto main::@7
  to:main::@3
main::@3: from main::@5
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@6
  to:main::@return
main::@return: from main::@3
  return 
  to:@RETURN
main::@6: from main::@3
  (byte~) main::i#6 ← (byte) main::i#1
  to:main::@1
main::@7: from main::@5
  (byte~) main::j#4 ← (byte) main::j#1
  to:main::@2
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@6
  (byte) nest1::i#2 ← phi( nest1/(byte) 100 nest1::@6/(byte~) nest1::i#6 )
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@7
  (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@7/(byte~) nest1::j#4 )
  call nest2 param-assignment
  to:nest1::@5
nest1::@5: from nest1::@2
  (byte) nest1::j#1 ← -- (byte) nest1::j#2
  if((byte) nest1::j#1>(byte) 0) goto nest1::@7
  to:nest1::@3
nest1::@3: from nest1::@5
  (byte) nest1::i#1 ← -- (byte) nest1::i#2
  if((byte) nest1::i#1>(byte) 0) goto nest1::@6
  to:nest1::@return
nest1::@return: from nest1::@3
  return 
  to:@RETURN
nest1::@6: from nest1::@3
  (byte~) nest1::i#6 ← (byte) nest1::i#1
  to:nest1::@1
nest1::@7: from nest1::@5
  (byte~) nest1::j#4 ← (byte) nest1::j#1
  to:nest1::@2
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@5
  (byte) nest2::i#2 ← phi( nest2/(byte) 100 nest2::@5/(byte~) nest2::i#5 )
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@6
  (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@6/(byte~) nest2::j#3 )
  *((word) 1024) ← (byte) nest2::j#2
  (byte) nest2::j#1 ← -- (byte) nest2::j#2
  if((byte) nest2::j#1>(byte) 0) goto nest2::@6
  to:nest2::@3
nest2::@3: from nest2::@2
  (byte) nest2::i#1 ← -- (byte) nest2::i#2
  if((byte) nest2::i#1>(byte) 0) goto nest2::@5
  to:nest2::@return
nest2::@return: from nest2::@3
  return 
  to:@RETURN
nest2::@5: from nest2::@3
  (byte~) nest2::i#5 ← (byte) nest2::i#1
  to:nest2::@1
nest2::@6: from nest2::@2
  (byte~) nest2::j#3 ← (byte) nest2::j#1
  to:nest2::@2

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@BEGIN: from
  [0] call main param-assignment [ ]
  to:@END
@END: from @BEGIN
main: from @BEGIN
  to:main::@1
main::@1: from main main::@6
  [1] (byte) main::i#2 ← phi( main/(byte) 100 main::@6/(byte~) main::i#6 ) [ main::i#2 ]
  to:main::@2
main::@2: from main::@1 main::@7
  [2] (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@7/(byte~) main::j#4 ) [ main::j#2 main::i#2 ]
  [3] call nest1 param-assignment [ main::j#2 main::i#2 ]
  to:main::@5
main::@5: from main::@2
  [4] (byte) main::j#1 ← -- (byte) main::j#2 [ main::j#1 main::i#2 ]
  [5] if((byte) main::j#1>(byte) 0) goto main::@7 [ main::j#1 main::i#2 ]
  to:main::@3
main::@3: from main::@5
  [6] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ]
  [7] if((byte) main::i#1>(byte) 0) goto main::@6 [ main::i#1 ]
  to:main::@return
main::@return: from main::@3
  [8] return  [ ]
  to:@RETURN
main::@6: from main::@3
  [9] (byte~) main::i#6 ← (byte) main::i#1 [ main::i#6 ]
  to:main::@1
main::@7: from main::@5
  [10] (byte~) main::j#4 ← (byte) main::j#1 [ main::j#4 main::i#2 ]
  to:main::@2
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@6
  [11] (byte) nest1::i#2 ← phi( nest1/(byte) 100 nest1::@6/(byte~) nest1::i#6 ) [ main::j#2 main::i#2 nest1::i#2 ]
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@7
  [12] (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@7/(byte~) nest1::j#4 ) [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  [13] call nest2 param-assignment [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  to:nest1::@5
nest1::@5: from nest1::@2
  [14] (byte) nest1::j#1 ← -- (byte) nest1::j#2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ]
  [15] if((byte) nest1::j#1>(byte) 0) goto nest1::@7 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ]
  to:nest1::@3
nest1::@3: from nest1::@5
  [16] (byte) nest1::i#1 ← -- (byte) nest1::i#2 [ main::j#2 main::i#2 nest1::i#1 ]
  [17] if((byte) nest1::i#1>(byte) 0) goto nest1::@6 [ main::j#2 main::i#2 nest1::i#1 ]
  to:nest1::@return
nest1::@return: from nest1::@3
  [18] return  [ main::j#2 main::i#2 ]
  to:@RETURN
nest1::@6: from nest1::@3
  [19] (byte~) nest1::i#6 ← (byte) nest1::i#1 [ main::j#2 main::i#2 nest1::i#6 ]
  to:nest1::@1
nest1::@7: from nest1::@5
  [20] (byte~) nest1::j#4 ← (byte) nest1::j#1 [ main::j#2 main::i#2 nest1::j#4 nest1::i#2 ]
  to:nest1::@2
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@5
  [21] (byte) nest2::i#2 ← phi( nest2/(byte) 100 nest2::@5/(byte~) nest2::i#5 ) [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#2 ]
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@6
  [22] (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@6/(byte~) nest2::j#3 ) [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#2 nest2::i#2 ]
  [23] *((word) 1024) ← (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#2 nest2::i#2 ]
  [24] (byte) nest2::j#1 ← -- (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ]
  [25] if((byte) nest2::j#1>(byte) 0) goto nest2::@6 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ]
  to:nest2::@3
nest2::@3: from nest2::@2
  [26] (byte) nest2::i#1 ← -- (byte) nest2::i#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ]
  [27] if((byte) nest2::i#1>(byte) 0) goto nest2::@5 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ]
  to:nest2::@return
nest2::@return: from nest2::@3
  [28] return  [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  to:@RETURN
nest2::@5: from nest2::@3
  [29] (byte~) nest2::i#5 ← (byte) nest2::i#1 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#5 ]
  to:nest2::@1
nest2::@6: from nest2::@2
  [30] (byte~) nest2::j#3 ← (byte) nest2::j#1 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#3 nest2::i#2 ]
  to:nest2::@2

Created 6 initial phi equivalence classes
Coalesced [9] main::i#6 ← main::i#1
Coalesced [10] main::j#4 ← main::j#1
Coalesced [19] nest1::i#6 ← nest1::i#1
Coalesced [20] nest1::j#4 ← nest1::j#1
Coalesced [29] nest2::i#5 ← nest2::i#1
Coalesced [30] nest2::j#3 ← nest2::j#1
Coalesced down to 6 phi equivalence classes
Culled Empty Block (label) main::@6
Culled Empty Block (label) main::@7
Culled Empty Block (label) nest1::@6
Culled Empty Block (label) nest1::@7
Culled Empty Block (label) nest2::@5
Culled Empty Block (label) nest2::@6
Block Sequence Planned @BEGIN @END main main::@1 main::@2 main::@5 main::@3 main::@return nest1 nest1::@1 nest1::@2 nest1::@5 nest1::@3 nest1::@return nest2 nest2::@1 nest2::@2 nest2::@3 nest2::@return 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@BEGIN: from
  [0] call main param-assignment [ ]
  to:@END
@END: from @BEGIN
main: from @BEGIN
  to:main::@1
main::@1: from main main::@3
  [1] (byte) main::i#2 ← phi( main/(byte) 100 main::@3/(byte) main::i#1 ) [ main::i#2 ]
  to:main::@2
main::@2: from main::@1 main::@5
  [2] (byte) main::j#2 ← phi( main::@1/(byte) 100 main::@5/(byte) main::j#1 ) [ main::j#2 main::i#2 ]
  [3] call nest1 param-assignment [ main::j#2 main::i#2 ]
  to:main::@5
main::@5: from main::@2
  [4] (byte) main::j#1 ← -- (byte) main::j#2 [ main::j#1 main::i#2 ]
  [5] if((byte) main::j#1>(byte) 0) goto main::@2 [ main::j#1 main::i#2 ]
  to:main::@3
main::@3: from main::@5
  [6] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ]
  [7] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ]
  to:main::@return
main::@return: from main::@3
  [8] return  [ ]
  to:@RETURN
nest1: from main::@2
  to:nest1::@1
nest1::@1: from nest1 nest1::@3
  [9] (byte) nest1::i#2 ← phi( nest1/(byte) 100 nest1::@3/(byte) nest1::i#1 ) [ main::j#2 main::i#2 nest1::i#2 ]
  to:nest1::@2
nest1::@2: from nest1::@1 nest1::@5
  [10] (byte) nest1::j#2 ← phi( nest1::@1/(byte) 100 nest1::@5/(byte) nest1::j#1 ) [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  [11] call nest2 param-assignment [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  to:nest1::@5
nest1::@5: from nest1::@2
  [12] (byte) nest1::j#1 ← -- (byte) nest1::j#2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ]
  [13] if((byte) nest1::j#1>(byte) 0) goto nest1::@2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ]
  to:nest1::@3
nest1::@3: from nest1::@5
  [14] (byte) nest1::i#1 ← -- (byte) nest1::i#2 [ main::j#2 main::i#2 nest1::i#1 ]
  [15] if((byte) nest1::i#1>(byte) 0) goto nest1::@1 [ main::j#2 main::i#2 nest1::i#1 ]
  to:nest1::@return
nest1::@return: from nest1::@3
  [16] return  [ main::j#2 main::i#2 ]
  to:@RETURN
nest2: from nest1::@2
  to:nest2::@1
nest2::@1: from nest2 nest2::@3
  [17] (byte) nest2::i#2 ← phi( nest2/(byte) 100 nest2::@3/(byte) nest2::i#1 ) [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#2 ]
  to:nest2::@2
nest2::@2: from nest2::@1 nest2::@2
  [18] (byte) nest2::j#2 ← phi( nest2::@1/(byte) 100 nest2::@2/(byte) nest2::j#1 ) [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#2 nest2::i#2 ]
  [19] *((word) 1024) ← (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#2 nest2::i#2 ]
  [20] (byte) nest2::j#1 ← -- (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ]
  [21] if((byte) nest2::j#1>(byte) 0) goto nest2::@2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ]
  to:nest2::@3
nest2::@3: from nest2::@2
  [22] (byte) nest2::i#1 ← -- (byte) nest2::i#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ]
  [23] if((byte) nest2::i#1>(byte) 0) goto nest2::@1 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ]
  to:nest2::@return
nest2::@return: from nest2::@3
  [24] return  [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  to:@RETURN

CALL GRAPH
Calls in [] to 0:main 
Calls in [main] to 3:nest1 
Calls in [nest1] to 11:nest2 

DOMINATORS
@BEGIN dominated by  @BEGIN 
@END dominated by  @BEGIN @END 
main dominated by  @BEGIN main 
main::@1 dominated by  @BEGIN main::@1 main 
main::@2 dominated by  @BEGIN main::@2 main::@1 main 
main::@5 dominated by  @BEGIN main::@2 main::@1 main::@5 main 
main::@3 dominated by  @BEGIN main::@2 main::@1 main::@3 main main::@5 
main::@return dominated by  @BEGIN main::@2 main::@1 main::@3 main main::@5 main::@return 
nest1 dominated by  @BEGIN main::@2 main::@1 main nest1 
nest1::@1 dominated by  nest1::@1 @BEGIN main::@2 main::@1 main nest1 
nest1::@2 dominated by  nest1::@1 nest1::@2 @BEGIN main::@2 main::@1 main nest1 
nest1::@5 dominated by  nest1::@1 @BEGIN nest1::@2 nest1::@5 main::@2 main::@1 main nest1 
nest1::@3 dominated by  nest1::@1 @BEGIN nest1::@2 nest1::@5 nest1::@3 main::@2 main::@1 main nest1 
nest1::@return dominated by  nest1::@1 @BEGIN nest1::@2 nest1::@5 nest1::@3 nest1::@return main::@2 main::@1 main nest1 
nest2 dominated by  nest1::@1 @BEGIN nest1::@2 main::@2 main::@1 main nest2 nest1 
nest2::@1 dominated by  nest1::@1 @BEGIN nest1::@2 main::@2 main::@1 main nest2 nest2::@1 nest1 
nest2::@2 dominated by  nest1::@1 @BEGIN nest1::@2 main::@2 main::@1 main nest2::@2 nest2 nest2::@1 nest1 
nest2::@3 dominated by  nest1::@1 @BEGIN nest1::@2 main::@2 main::@1 main nest2::@3 nest2::@2 nest2 nest2::@1 nest1 
nest2::@return dominated by  nest1::@1 @BEGIN nest1::@2 nest2::@return main::@2 main::@1 main nest2::@3 nest2::@2 nest2 nest2::@1 nest1 

Found back edge: Loop head: main::@2 tails: main::@5 blocks: null
Found back edge: Loop head: main::@1 tails: main::@3 blocks: null
Found back edge: Loop head: nest1::@2 tails: nest1::@5 blocks: null
Found back edge: Loop head: nest1::@1 tails: nest1::@3 blocks: null
Found back edge: Loop head: nest2::@2 tails: nest2::@2 blocks: null
Found back edge: Loop head: nest2::@1 tails: nest2::@3 blocks: null
Populated: Loop head: main::@2 tails: main::@5 blocks: main::@5 main::@2 
Populated: Loop head: main::@1 tails: main::@3 blocks: main::@3 main::@5 main::@2 main::@1 
Populated: Loop head: nest1::@2 tails: nest1::@5 blocks: nest1::@5 nest1::@2 
Populated: Loop head: nest1::@1 tails: nest1::@3 blocks: nest1::@3 nest1::@5 nest1::@2 nest1::@1 
Populated: Loop head: nest2::@2 tails: nest2::@2 blocks: nest2::@2 
Populated: Loop head: nest2::@1 tails: nest2::@3 blocks: nest2::@3 nest2::@2 nest2::@1 
NATURAL LOOPS
Loop head: main::@2 tails: main::@5 blocks: main::@5 main::@2 
Loop head: main::@1 tails: main::@3 blocks: main::@3 main::@5 main::@2 main::@1 
Loop head: nest1::@2 tails: nest1::@5 blocks: nest1::@5 nest1::@2 
Loop head: nest1::@1 tails: nest1::@3 blocks: nest1::@3 nest1::@5 nest1::@2 nest1::@1 
Loop head: nest2::@2 tails: nest2::@2 blocks: nest2::@2 
Loop head: nest2::@1 tails: nest2::@3 blocks: nest2::@3 nest2::@2 nest2::@1 

Found 0 loops in scope []
Found 2 loops in scope [main]
  Loop head: main::@2 tails: main::@5 blocks: main::@5 main::@2 
  Loop head: main::@1 tails: main::@3 blocks: main::@3 main::@5 main::@2 main::@1 
Found 2 loops in scope [nest1]
  Loop head: nest1::@2 tails: nest1::@5 blocks: nest1::@5 nest1::@2 
  Loop head: nest1::@1 tails: nest1::@3 blocks: nest1::@3 nest1::@5 nest1::@2 nest1::@1 
Found 2 loops in scope [nest2]
  Loop head: nest2::@2 tails: nest2::@2 blocks: nest2::@2 
  Loop head: nest2::@1 tails: nest2::@3 blocks: nest2::@3 nest2::@2 nest2::@1 
NATURAL LOOPS WITH DEPTH
Loop head: main::@2 tails: main::@5 blocks: main::@5 main::@2  depth: 2
Loop head: main::@1 tails: main::@3 blocks: main::@3 main::@5 main::@2 main::@1  depth: 1
Loop head: nest1::@2 tails: nest1::@5 blocks: nest1::@5 nest1::@2  depth: 4
Loop head: nest1::@1 tails: nest1::@3 blocks: nest1::@3 nest1::@5 nest1::@2 nest1::@1  depth: 3
Loop head: nest2::@2 tails: nest2::@2 blocks: nest2::@2  depth: 6
Loop head: nest2::@1 tails: nest2::@3 blocks: nest2::@3 nest2::@2 nest2::@1  depth: 5


VARIABLE REGISTER WEIGHTS
(byte*) SCREEN
(void()) main()
(byte) main::i
(byte) main::i#1 16.5
(byte) main::i#2 1.0476190476190477
(byte) main::j
(byte) main::j#1 151.5
(byte) main::j#2 11.222222222222221
(void()) nest1()
(byte) nest1::i
(byte) nest1::i#1 1501.5
(byte) nest1::i#2 154.0
(byte) nest1::j
(byte) nest1::j#1 15001.5
(byte) nest1::j#2 2000.2
(void()) nest2()
(byte) nest2::i
(byte) nest2::i#1 150001.5
(byte) nest2::i#2 40000.4
(byte) nest2::j
(byte) nest2::j#1 1500001.5
(byte) nest2::j#2 1500001.5

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ main::j#2 main::j#1 ]
[ nest1::i#2 nest1::i#1 ]
[ nest1::j#2 nest1::j#1 ]
[ nest2::i#2 nest2::i#1 ]
[ nest2::j#2 nest2::j#1 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ main::j#2 main::j#1 ]
[ nest1::i#2 nest1::i#1 ]
[ nest1::j#2 nest1::j#1 ]
[ nest2::i#2 nest2::i#1 ]
[ nest2::j#2 nest2::j#1 ]
Allocated zp byte:2 to zp byte:2 [ main::i#2 main::i#1 ]
Allocated zp byte:3 to zp byte:3 [ main::j#2 main::j#1 ]
Allocated zp byte:4 to zp byte:4 [ nest1::i#2 nest1::i#1 ]
Allocated zp byte:5 to zp byte:5 [ nest1::j#2 nest1::j#1 ]
Allocated zp byte:6 to zp byte:6 [ nest2::i#2 nest2::i#1 ]
Allocated zp byte:7 to zp byte:7 [ nest2::j#2 nest2::j#1 ]
INITIAL ASM
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
  jmp BEND
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] phi from main to main::@1
main__B1_from_main:
//SEG5 [1] phi (byte) main::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 2
  jmp main__B1
//SEG6 [1] phi from main::@3 to main::@1
main__B1_from_B3:
//SEG7 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
  jmp main__B1
//SEG8 main::@1
main__B1:
//SEG9 [2] phi from main::@1 to main::@2
main__B2_from_B1:
//SEG10 [2] phi (byte) main::j#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 3
  jmp main__B2
//SEG11 [2] phi from main::@5 to main::@2
main__B2_from_B5:
//SEG12 [2] phi (byte) main::j#2 = (byte) main::j#1 -- register_copy 
  jmp main__B2
//SEG13 main::@2
main__B2:
//SEG14 [3] call nest1 param-assignment [ main::j#2 main::i#2 ]
  jsr nest1
  jmp main__B5
//SEG15 main::@5
main__B5:
//SEG16 [4] (byte) main::j#1 ← -- (byte) main::j#2 [ main::j#1 main::i#2 ] -- zpby1=_dec_zpby1 
  dec 3
//SEG17 [5] if((byte) main::j#1>(byte) 0) goto main::@2 [ main::j#1 main::i#2 ] -- zpby1_gt_0_then_la1 
  lda 3
  bne main__B2_from_B5
  jmp main__B3
//SEG18 main::@3
main__B3:
//SEG19 [6] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ] -- zpby1=_dec_zpby1 
  dec 2
//SEG20 [7] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ] -- zpby1_gt_0_then_la1 
  lda 2
  bne main__B1_from_B3
  jmp main__Breturn
//SEG21 main::@return
main__Breturn:
//SEG22 [8] return  [ ]
  rts
//SEG23 nest1
nest1:
//SEG24 [9] phi from nest1 to nest1::@1
nest1__B1_from_nest1:
//SEG25 [9] phi (byte) nest1::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 4
  jmp nest1__B1
//SEG26 [9] phi from nest1::@3 to nest1::@1
nest1__B1_from_B3:
//SEG27 [9] phi (byte) nest1::i#2 = (byte) nest1::i#1 -- register_copy 
  jmp nest1__B1
//SEG28 nest1::@1
nest1__B1:
//SEG29 [10] phi from nest1::@1 to nest1::@2
nest1__B2_from_B1:
//SEG30 [10] phi (byte) nest1::j#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 5
  jmp nest1__B2
//SEG31 [10] phi from nest1::@5 to nest1::@2
nest1__B2_from_B5:
//SEG32 [10] phi (byte) nest1::j#2 = (byte) nest1::j#1 -- register_copy 
  jmp nest1__B2
//SEG33 nest1::@2
nest1__B2:
//SEG34 [11] call nest2 param-assignment [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  jsr nest2
  jmp nest1__B5
//SEG35 nest1::@5
nest1__B5:
//SEG36 [12] (byte) nest1::j#1 ← -- (byte) nest1::j#2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ] -- zpby1=_dec_zpby1 
  dec 5
//SEG37 [13] if((byte) nest1::j#1>(byte) 0) goto nest1::@2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ] -- zpby1_gt_0_then_la1 
  lda 5
  bne nest1__B2_from_B5
  jmp nest1__B3
//SEG38 nest1::@3
nest1__B3:
//SEG39 [14] (byte) nest1::i#1 ← -- (byte) nest1::i#2 [ main::j#2 main::i#2 nest1::i#1 ] -- zpby1=_dec_zpby1 
  dec 4
//SEG40 [15] if((byte) nest1::i#1>(byte) 0) goto nest1::@1 [ main::j#2 main::i#2 nest1::i#1 ] -- zpby1_gt_0_then_la1 
  lda 4
  bne nest1__B1_from_B3
  jmp nest1__Breturn
//SEG41 nest1::@return
nest1__Breturn:
//SEG42 [16] return  [ main::j#2 main::i#2 ]
  rts
//SEG43 nest2
nest2:
//SEG44 [17] phi from nest2 to nest2::@1
nest2__B1_from_nest2:
//SEG45 [17] phi (byte) nest2::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 6
  jmp nest2__B1
//SEG46 [17] phi from nest2::@3 to nest2::@1
nest2__B1_from_B3:
//SEG47 [17] phi (byte) nest2::i#2 = (byte) nest2::i#1 -- register_copy 
  jmp nest2__B1
//SEG48 nest2::@1
nest2__B1:
//SEG49 [18] phi from nest2::@1 to nest2::@2
nest2__B2_from_B1:
//SEG50 [18] phi (byte) nest2::j#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 7
  jmp nest2__B2
//SEG51 [18] phi from nest2::@2 to nest2::@2
nest2__B2_from_B2:
//SEG52 [18] phi (byte) nest2::j#2 = (byte) nest2::j#1 -- register_copy 
  jmp nest2__B2
//SEG53 nest2::@2
nest2__B2:
//SEG54 [19] *((word) 1024) ← (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#2 nest2::i#2 ] -- _star_cowo1=zpby1 
  lda 7
  sta 1024
//SEG55 [20] (byte) nest2::j#1 ← -- (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ] -- zpby1=_dec_zpby1 
  dec 7
//SEG56 [21] if((byte) nest2::j#1>(byte) 0) goto nest2::@2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ] -- zpby1_gt_0_then_la1 
  lda 7
  bne nest2__B2_from_B2
  jmp nest2__B3
//SEG57 nest2::@3
nest2__B3:
//SEG58 [22] (byte) nest2::i#1 ← -- (byte) nest2::i#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ] -- zpby1=_dec_zpby1 
  dec 6
//SEG59 [23] if((byte) nest2::i#1>(byte) 0) goto nest2::@1 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ] -- zpby1_gt_0_then_la1 
  lda 6
  bne nest2__B1_from_B3
  jmp nest2__Breturn
//SEG60 nest2::@return
nest2__Breturn:
//SEG61 [24] return  [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  rts

REGISTER UPLIFT SCOPES
Uplift Scope [main] 162.72: zp byte:3 [ main::j#2 main::j#1 ] 17.55: zp byte:2 [ main::i#2 main::i#1 ] 
Uplift Scope [nest1] 17,001.7: zp byte:5 [ nest1::j#2 nest1::j#1 ] 1,655.5: zp byte:4 [ nest1::i#2 nest1::i#1 ] 
Uplift Scope [nest2] 3,000,003: zp byte:7 [ nest2::j#2 nest2::j#1 ] 190,001.9: zp byte:6 [ nest2::i#2 nest2::i#1 ] 
Uplift Scope [] 

Uplift attempt [main] 140 allocation: zp byte:3 [ main::j#2 main::j#1 ] zp byte:2 [ main::i#2 main::i#1 ] 
Uplift attempt [main] clobber allocation: reg byte a [ main::j#2 main::j#1 ] zp byte:2 [ main::i#2 main::i#1 ] 
Uplift attempt [main] 137 allocation: reg byte x [ main::j#2 main::j#1 ] zp byte:2 [ main::i#2 main::i#1 ] 
Uplift attempt [main] 137 allocation: reg byte y [ main::j#2 main::j#1 ] zp byte:2 [ main::i#2 main::i#1 ] 
Uplift attempt [main] clobber allocation: zp byte:3 [ main::j#2 main::j#1 ] reg byte a [ main::i#2 main::i#1 ] 
Uplift attempt [main] clobber allocation: reg byte a [ main::j#2 main::j#1 ] reg byte a [ main::i#2 main::i#1 ] 
Uplift attempt [main] clobber allocation: reg byte x [ main::j#2 main::j#1 ] reg byte a [ main::i#2 main::i#1 ] 
Uplift attempt [main] clobber allocation: reg byte y [ main::j#2 main::j#1 ] reg byte a [ main::i#2 main::i#1 ] 
Uplift attempt [main] 137 allocation: zp byte:3 [ main::j#2 main::j#1 ] reg byte x [ main::i#2 main::i#1 ] 
Uplift attempt [main] clobber allocation: reg byte a [ main::j#2 main::j#1 ] reg byte x [ main::i#2 main::i#1 ] 
Uplift attempt [main] clobber allocation: reg byte x [ main::j#2 main::j#1 ] reg byte x [ main::i#2 main::i#1 ] 
Uplift attempt [main] 134 allocation: reg byte y [ main::j#2 main::j#1 ] reg byte x [ main::i#2 main::i#1 ] 
Uplift attempt [main] 137 allocation: zp byte:3 [ main::j#2 main::j#1 ] reg byte y [ main::i#2 main::i#1 ] 
Uplift attempt [main] clobber allocation: reg byte a [ main::j#2 main::j#1 ] reg byte y [ main::i#2 main::i#1 ] 
Uplift attempt [main] 134 allocation: reg byte x [ main::j#2 main::j#1 ] reg byte y [ main::i#2 main::i#1 ] 
Uplift attempt [main] clobber allocation: reg byte y [ main::j#2 main::j#1 ] reg byte y [ main::i#2 main::i#1 ] 
Uplifting [main] best 134 combination reg byte y [ main::j#2 main::j#1 ] reg byte x [ main::i#2 main::i#1 ] 
Uplift attempt [nest1] 134 allocation: zp byte:5 [ nest1::j#2 nest1::j#1 ] zp byte:4 [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte a [ nest1::j#2 nest1::j#1 ] zp byte:4 [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte x [ nest1::j#2 nest1::j#1 ] zp byte:4 [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte y [ nest1::j#2 nest1::j#1 ] zp byte:4 [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: zp byte:5 [ nest1::j#2 nest1::j#1 ] reg byte a [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte a [ nest1::j#2 nest1::j#1 ] reg byte a [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte x [ nest1::j#2 nest1::j#1 ] reg byte a [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte y [ nest1::j#2 nest1::j#1 ] reg byte a [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: zp byte:5 [ nest1::j#2 nest1::j#1 ] reg byte x [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte a [ nest1::j#2 nest1::j#1 ] reg byte x [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte x [ nest1::j#2 nest1::j#1 ] reg byte x [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte y [ nest1::j#2 nest1::j#1 ] reg byte x [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: zp byte:5 [ nest1::j#2 nest1::j#1 ] reg byte y [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte a [ nest1::j#2 nest1::j#1 ] reg byte y [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte x [ nest1::j#2 nest1::j#1 ] reg byte y [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest1] clobber allocation: reg byte y [ nest1::j#2 nest1::j#1 ] reg byte y [ nest1::i#2 nest1::i#1 ] 
Uplifting [nest1] best 134 combination zp byte:5 [ nest1::j#2 nest1::j#1 ] zp byte:4 [ nest1::i#2 nest1::i#1 ] 
Uplift attempt [nest2] 134 allocation: zp byte:7 [ nest2::j#2 nest2::j#1 ] zp byte:6 [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] 131 allocation: reg byte a [ nest2::j#2 nest2::j#1 ] zp byte:6 [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte x [ nest2::j#2 nest2::j#1 ] zp byte:6 [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte y [ nest2::j#2 nest2::j#1 ] zp byte:6 [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: zp byte:7 [ nest2::j#2 nest2::j#1 ] reg byte a [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte a [ nest2::j#2 nest2::j#1 ] reg byte a [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte x [ nest2::j#2 nest2::j#1 ] reg byte a [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte y [ nest2::j#2 nest2::j#1 ] reg byte a [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: zp byte:7 [ nest2::j#2 nest2::j#1 ] reg byte x [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte a [ nest2::j#2 nest2::j#1 ] reg byte x [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte x [ nest2::j#2 nest2::j#1 ] reg byte x [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte y [ nest2::j#2 nest2::j#1 ] reg byte x [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: zp byte:7 [ nest2::j#2 nest2::j#1 ] reg byte y [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte a [ nest2::j#2 nest2::j#1 ] reg byte y [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte x [ nest2::j#2 nest2::j#1 ] reg byte y [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [nest2] clobber allocation: reg byte y [ nest2::j#2 nest2::j#1 ] reg byte y [ nest2::i#2 nest2::i#1 ] 
Uplifting [nest2] best 131 combination reg byte a [ nest2::j#2 nest2::j#1 ] zp byte:6 [ nest2::i#2 nest2::i#1 ] 
Uplift attempt [] 131 allocation: 
Uplifting [] best 131 combination 
Re-allocated ZP register from zp byte:4 to zp byte:2
Re-allocated ZP register from zp byte:5 to zp byte:3
Re-allocated ZP register from zp byte:6 to zp byte:4
Removing instruction jmp BEND
Removing instruction jmp main__B1
Removing instruction jmp main__B2
Removing instruction jmp main__B5
Removing instruction jmp main__B3
Removing instruction jmp main__Breturn
Removing instruction jmp nest1__B1
Removing instruction jmp nest1__B2
Removing instruction jmp nest1__B5
Removing instruction jmp nest1__B3
Removing instruction jmp nest1__Breturn
Removing instruction jmp nest2__B1
Removing instruction jmp nest2__B2
Removing instruction jmp nest2__B3
Removing instruction jmp nest2__Breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] phi from main to main::@1
main__B1_from_main:
//SEG5 [1] phi (byte) main::i#2 = (byte) 100 -- xby=coby1 
  ldx #100
  jmp main__B1
//SEG6 [1] phi from main::@3 to main::@1
main__B1_from_B3:
//SEG7 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
//SEG8 main::@1
main__B1:
//SEG9 [2] phi from main::@1 to main::@2
main__B2_from_B1:
//SEG10 [2] phi (byte) main::j#2 = (byte) 100 -- yby=coby1 
  ldy #100
  jmp main__B2
//SEG11 [2] phi from main::@5 to main::@2
main__B2_from_B5:
//SEG12 [2] phi (byte) main::j#2 = (byte) main::j#1 -- register_copy 
//SEG13 main::@2
main__B2:
//SEG14 [3] call nest1 param-assignment [ main::j#2 main::i#2 ]
  jsr nest1
//SEG15 main::@5
main__B5:
//SEG16 [4] (byte) main::j#1 ← -- (byte) main::j#2 [ main::j#1 main::i#2 ] -- yby=_dec_yby 
  dey
//SEG17 [5] if((byte) main::j#1>(byte) 0) goto main::@2 [ main::j#1 main::i#2 ] -- yby_gt_0_then_la1 
  cpy #0
  bne main__B2_from_B5
//SEG18 main::@3
main__B3:
//SEG19 [6] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ] -- xby=_dec_xby 
  dex
//SEG20 [7] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ] -- xby_gt_0_then_la1 
  cpx #0
  bne main__B1_from_B3
//SEG21 main::@return
main__Breturn:
//SEG22 [8] return  [ ]
  rts
//SEG23 nest1
nest1:
//SEG24 [9] phi from nest1 to nest1::@1
nest1__B1_from_nest1:
//SEG25 [9] phi (byte) nest1::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 2
  jmp nest1__B1
//SEG26 [9] phi from nest1::@3 to nest1::@1
nest1__B1_from_B3:
//SEG27 [9] phi (byte) nest1::i#2 = (byte) nest1::i#1 -- register_copy 
//SEG28 nest1::@1
nest1__B1:
//SEG29 [10] phi from nest1::@1 to nest1::@2
nest1__B2_from_B1:
//SEG30 [10] phi (byte) nest1::j#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 3
  jmp nest1__B2
//SEG31 [10] phi from nest1::@5 to nest1::@2
nest1__B2_from_B5:
//SEG32 [10] phi (byte) nest1::j#2 = (byte) nest1::j#1 -- register_copy 
//SEG33 nest1::@2
nest1__B2:
//SEG34 [11] call nest2 param-assignment [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  jsr nest2
//SEG35 nest1::@5
nest1__B5:
//SEG36 [12] (byte) nest1::j#1 ← -- (byte) nest1::j#2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ] -- zpby1=_dec_zpby1 
  dec 3
//SEG37 [13] if((byte) nest1::j#1>(byte) 0) goto nest1::@2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ] -- zpby1_gt_0_then_la1 
  lda 3
  bne nest1__B2_from_B5
//SEG38 nest1::@3
nest1__B3:
//SEG39 [14] (byte) nest1::i#1 ← -- (byte) nest1::i#2 [ main::j#2 main::i#2 nest1::i#1 ] -- zpby1=_dec_zpby1 
  dec 2
//SEG40 [15] if((byte) nest1::i#1>(byte) 0) goto nest1::@1 [ main::j#2 main::i#2 nest1::i#1 ] -- zpby1_gt_0_then_la1 
  lda 2
  bne nest1__B1_from_B3
//SEG41 nest1::@return
nest1__Breturn:
//SEG42 [16] return  [ main::j#2 main::i#2 ]
  rts
//SEG43 nest2
nest2:
//SEG44 [17] phi from nest2 to nest2::@1
nest2__B1_from_nest2:
//SEG45 [17] phi (byte) nest2::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 4
  jmp nest2__B1
//SEG46 [17] phi from nest2::@3 to nest2::@1
nest2__B1_from_B3:
//SEG47 [17] phi (byte) nest2::i#2 = (byte) nest2::i#1 -- register_copy 
//SEG48 nest2::@1
nest2__B1:
//SEG49 [18] phi from nest2::@1 to nest2::@2
nest2__B2_from_B1:
//SEG50 [18] phi (byte) nest2::j#2 = (byte) 100 -- aby=coby1 
  lda #100
  jmp nest2__B2
//SEG51 [18] phi from nest2::@2 to nest2::@2
nest2__B2_from_B2:
//SEG52 [18] phi (byte) nest2::j#2 = (byte) nest2::j#1 -- register_copy 
//SEG53 nest2::@2
nest2__B2:
//SEG54 [19] *((word) 1024) ← (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#2 nest2::i#2 ] -- _star_cowo1=aby 
  sta 1024
//SEG55 [20] (byte) nest2::j#1 ← -- (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ] -- aby=_dec_aby 
  sec
  sbc #1
//SEG56 [21] if((byte) nest2::j#1>(byte) 0) goto nest2::@2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ] -- aby_gt_0_then_la1 
  cmp #0
  bne nest2__B2_from_B2
//SEG57 nest2::@3
nest2__B3:
//SEG58 [22] (byte) nest2::i#1 ← -- (byte) nest2::i#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ] -- zpby1=_dec_zpby1 
  dec 4
//SEG59 [23] if((byte) nest2::i#1>(byte) 0) goto nest2::@1 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ] -- zpby1_gt_0_then_la1 
  lda 4
  bne nest2__B1_from_B3
//SEG60 nest2::@return
nest2__Breturn:
//SEG61 [24] return  [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  rts

Removing instruction jmp main__B1
Removing instruction jmp main__B2
Removing instruction jmp nest1__B1
Removing instruction jmp nest1__B2
Removing instruction jmp nest2__B1
Removing instruction jmp nest2__B2
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] phi from main to main::@1
main__B1_from_main:
//SEG5 [1] phi (byte) main::i#2 = (byte) 100 -- xby=coby1 
  ldx #100
//SEG6 [1] phi from main::@3 to main::@1
main__B1_from_B3:
//SEG7 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
//SEG8 main::@1
main__B1:
//SEG9 [2] phi from main::@1 to main::@2
main__B2_from_B1:
//SEG10 [2] phi (byte) main::j#2 = (byte) 100 -- yby=coby1 
  ldy #100
//SEG11 [2] phi from main::@5 to main::@2
main__B2_from_B5:
//SEG12 [2] phi (byte) main::j#2 = (byte) main::j#1 -- register_copy 
//SEG13 main::@2
main__B2:
//SEG14 [3] call nest1 param-assignment [ main::j#2 main::i#2 ]
  jsr nest1
//SEG15 main::@5
main__B5:
//SEG16 [4] (byte) main::j#1 ← -- (byte) main::j#2 [ main::j#1 main::i#2 ] -- yby=_dec_yby 
  dey
//SEG17 [5] if((byte) main::j#1>(byte) 0) goto main::@2 [ main::j#1 main::i#2 ] -- yby_gt_0_then_la1 
  cpy #0
  bne main__B2_from_B5
//SEG18 main::@3
main__B3:
//SEG19 [6] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ] -- xby=_dec_xby 
  dex
//SEG20 [7] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ] -- xby_gt_0_then_la1 
  cpx #0
  bne main__B1_from_B3
//SEG21 main::@return
main__Breturn:
//SEG22 [8] return  [ ]
  rts
//SEG23 nest1
nest1:
//SEG24 [9] phi from nest1 to nest1::@1
nest1__B1_from_nest1:
//SEG25 [9] phi (byte) nest1::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 2
//SEG26 [9] phi from nest1::@3 to nest1::@1
nest1__B1_from_B3:
//SEG27 [9] phi (byte) nest1::i#2 = (byte) nest1::i#1 -- register_copy 
//SEG28 nest1::@1
nest1__B1:
//SEG29 [10] phi from nest1::@1 to nest1::@2
nest1__B2_from_B1:
//SEG30 [10] phi (byte) nest1::j#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 3
//SEG31 [10] phi from nest1::@5 to nest1::@2
nest1__B2_from_B5:
//SEG32 [10] phi (byte) nest1::j#2 = (byte) nest1::j#1 -- register_copy 
//SEG33 nest1::@2
nest1__B2:
//SEG34 [11] call nest2 param-assignment [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  jsr nest2
//SEG35 nest1::@5
nest1__B5:
//SEG36 [12] (byte) nest1::j#1 ← -- (byte) nest1::j#2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ] -- zpby1=_dec_zpby1 
  dec 3
//SEG37 [13] if((byte) nest1::j#1>(byte) 0) goto nest1::@2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ] -- zpby1_gt_0_then_la1 
  lda 3
  bne nest1__B2_from_B5
//SEG38 nest1::@3
nest1__B3:
//SEG39 [14] (byte) nest1::i#1 ← -- (byte) nest1::i#2 [ main::j#2 main::i#2 nest1::i#1 ] -- zpby1=_dec_zpby1 
  dec 2
//SEG40 [15] if((byte) nest1::i#1>(byte) 0) goto nest1::@1 [ main::j#2 main::i#2 nest1::i#1 ] -- zpby1_gt_0_then_la1 
  lda 2
  bne nest1__B1_from_B3
//SEG41 nest1::@return
nest1__Breturn:
//SEG42 [16] return  [ main::j#2 main::i#2 ]
  rts
//SEG43 nest2
nest2:
//SEG44 [17] phi from nest2 to nest2::@1
nest2__B1_from_nest2:
//SEG45 [17] phi (byte) nest2::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 4
//SEG46 [17] phi from nest2::@3 to nest2::@1
nest2__B1_from_B3:
//SEG47 [17] phi (byte) nest2::i#2 = (byte) nest2::i#1 -- register_copy 
//SEG48 nest2::@1
nest2__B1:
//SEG49 [18] phi from nest2::@1 to nest2::@2
nest2__B2_from_B1:
//SEG50 [18] phi (byte) nest2::j#2 = (byte) 100 -- aby=coby1 
  lda #100
//SEG51 [18] phi from nest2::@2 to nest2::@2
nest2__B2_from_B2:
//SEG52 [18] phi (byte) nest2::j#2 = (byte) nest2::j#1 -- register_copy 
//SEG53 nest2::@2
nest2__B2:
//SEG54 [19] *((word) 1024) ← (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#2 nest2::i#2 ] -- _star_cowo1=aby 
  sta 1024
//SEG55 [20] (byte) nest2::j#1 ← -- (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ] -- aby=_dec_aby 
  sec
  sbc #1
//SEG56 [21] if((byte) nest2::j#1>(byte) 0) goto nest2::@2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ] -- aby_gt_0_then_la1 
  cmp #0
  bne nest2__B2_from_B2
//SEG57 nest2::@3
nest2__B3:
//SEG58 [22] (byte) nest2::i#1 ← -- (byte) nest2::i#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ] -- zpby1=_dec_zpby1 
  dec 4
//SEG59 [23] if((byte) nest2::i#1>(byte) 0) goto nest2::@1 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ] -- zpby1_gt_0_then_la1 
  lda 4
  bne nest2__B1_from_B3
//SEG60 nest2::@return
nest2__Breturn:
//SEG61 [24] return  [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  rts

FINAL SYMBOL TABLE
(label) @BEGIN
(label) @END
(byte*) SCREEN
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@5
(label) main::@return
(byte) main::i
(byte) main::i#1 reg byte x 16.5
(byte) main::i#2 reg byte x 1.0476190476190477
(byte) main::j
(byte) main::j#1 reg byte y 151.5
(byte) main::j#2 reg byte y 11.222222222222221
(void()) nest1()
(label) nest1::@1
(label) nest1::@2
(label) nest1::@3
(label) nest1::@5
(label) nest1::@return
(byte) nest1::i
(byte) nest1::i#1 zp byte:2 1501.5
(byte) nest1::i#2 zp byte:2 154.0
(byte) nest1::j
(byte) nest1::j#1 zp byte:3 15001.5
(byte) nest1::j#2 zp byte:3 2000.2
(void()) nest2()
(label) nest2::@1
(label) nest2::@2
(label) nest2::@3
(label) nest2::@return
(byte) nest2::i
(byte) nest2::i#1 zp byte:4 150001.5
(byte) nest2::i#2 zp byte:4 40000.4
(byte) nest2::j
(byte) nest2::j#1 reg byte a 1500001.5
(byte) nest2::j#2 reg byte a 1500001.5

reg byte x [ main::i#2 main::i#1 ]
reg byte y [ main::j#2 main::j#1 ]
zp byte:2 [ nest1::i#2 nest1::i#1 ]
zp byte:3 [ nest1::j#2 nest1::j#1 ]
zp byte:4 [ nest2::i#2 nest2::i#1 ]
reg byte a [ nest2::j#2 nest2::j#1 ]

FINAL CODE
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] phi from main to main::@1
main__B1_from_main:
//SEG5 [1] phi (byte) main::i#2 = (byte) 100 -- xby=coby1 
  ldx #100
//SEG6 [1] phi from main::@3 to main::@1
main__B1_from_B3:
//SEG7 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
//SEG8 main::@1
main__B1:
//SEG9 [2] phi from main::@1 to main::@2
main__B2_from_B1:
//SEG10 [2] phi (byte) main::j#2 = (byte) 100 -- yby=coby1 
  ldy #100
//SEG11 [2] phi from main::@5 to main::@2
main__B2_from_B5:
//SEG12 [2] phi (byte) main::j#2 = (byte) main::j#1 -- register_copy 
//SEG13 main::@2
main__B2:
//SEG14 [3] call nest1 param-assignment [ main::j#2 main::i#2 ]
  jsr nest1
//SEG15 main::@5
main__B5:
//SEG16 [4] (byte) main::j#1 ← -- (byte) main::j#2 [ main::j#1 main::i#2 ] -- yby=_dec_yby 
  dey
//SEG17 [5] if((byte) main::j#1>(byte) 0) goto main::@2 [ main::j#1 main::i#2 ] -- yby_gt_0_then_la1 
  cpy #0
  bne main__B2_from_B5
//SEG18 main::@3
main__B3:
//SEG19 [6] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 ] -- xby=_dec_xby 
  dex
//SEG20 [7] if((byte) main::i#1>(byte) 0) goto main::@1 [ main::i#1 ] -- xby_gt_0_then_la1 
  cpx #0
  bne main__B1_from_B3
//SEG21 main::@return
main__Breturn:
//SEG22 [8] return  [ ]
  rts
//SEG23 nest1
nest1:
//SEG24 [9] phi from nest1 to nest1::@1
nest1__B1_from_nest1:
//SEG25 [9] phi (byte) nest1::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 2
//SEG26 [9] phi from nest1::@3 to nest1::@1
nest1__B1_from_B3:
//SEG27 [9] phi (byte) nest1::i#2 = (byte) nest1::i#1 -- register_copy 
//SEG28 nest1::@1
nest1__B1:
//SEG29 [10] phi from nest1::@1 to nest1::@2
nest1__B2_from_B1:
//SEG30 [10] phi (byte) nest1::j#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 3
//SEG31 [10] phi from nest1::@5 to nest1::@2
nest1__B2_from_B5:
//SEG32 [10] phi (byte) nest1::j#2 = (byte) nest1::j#1 -- register_copy 
//SEG33 nest1::@2
nest1__B2:
//SEG34 [11] call nest2 param-assignment [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  jsr nest2
//SEG35 nest1::@5
nest1__B5:
//SEG36 [12] (byte) nest1::j#1 ← -- (byte) nest1::j#2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ] -- zpby1=_dec_zpby1 
  dec 3
//SEG37 [13] if((byte) nest1::j#1>(byte) 0) goto nest1::@2 [ main::j#2 main::i#2 nest1::j#1 nest1::i#2 ] -- zpby1_gt_0_then_la1 
  lda 3
  bne nest1__B2_from_B5
//SEG38 nest1::@3
nest1__B3:
//SEG39 [14] (byte) nest1::i#1 ← -- (byte) nest1::i#2 [ main::j#2 main::i#2 nest1::i#1 ] -- zpby1=_dec_zpby1 
  dec 2
//SEG40 [15] if((byte) nest1::i#1>(byte) 0) goto nest1::@1 [ main::j#2 main::i#2 nest1::i#1 ] -- zpby1_gt_0_then_la1 
  lda 2
  bne nest1__B1_from_B3
//SEG41 nest1::@return
nest1__Breturn:
//SEG42 [16] return  [ main::j#2 main::i#2 ]
  rts
//SEG43 nest2
nest2:
//SEG44 [17] phi from nest2 to nest2::@1
nest2__B1_from_nest2:
//SEG45 [17] phi (byte) nest2::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 4
//SEG46 [17] phi from nest2::@3 to nest2::@1
nest2__B1_from_B3:
//SEG47 [17] phi (byte) nest2::i#2 = (byte) nest2::i#1 -- register_copy 
//SEG48 nest2::@1
nest2__B1:
//SEG49 [18] phi from nest2::@1 to nest2::@2
nest2__B2_from_B1:
//SEG50 [18] phi (byte) nest2::j#2 = (byte) 100 -- aby=coby1 
  lda #100
//SEG51 [18] phi from nest2::@2 to nest2::@2
nest2__B2_from_B2:
//SEG52 [18] phi (byte) nest2::j#2 = (byte) nest2::j#1 -- register_copy 
//SEG53 nest2::@2
nest2__B2:
//SEG54 [19] *((word) 1024) ← (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#2 nest2::i#2 ] -- _star_cowo1=aby 
  sta 1024
//SEG55 [20] (byte) nest2::j#1 ← -- (byte) nest2::j#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ] -- aby=_dec_aby 
  sec
  sbc #1
//SEG56 [21] if((byte) nest2::j#1>(byte) 0) goto nest2::@2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::j#1 nest2::i#2 ] -- aby_gt_0_then_la1 
  cmp #0
  bne nest2__B2_from_B2
//SEG57 nest2::@3
nest2__B3:
//SEG58 [22] (byte) nest2::i#1 ← -- (byte) nest2::i#2 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ] -- zpby1=_dec_zpby1 
  dec 4
//SEG59 [23] if((byte) nest2::i#1>(byte) 0) goto nest2::@1 [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 nest2::i#1 ] -- zpby1_gt_0_then_la1 
  lda 4
  bne nest2__B1_from_B3
//SEG60 nest2::@return
nest2__Breturn:
//SEG61 [24] return  [ main::j#2 main::i#2 nest1::j#2 nest1::i#2 ]
  rts

