Resolved forward reference sprites_irq to interrupt(HARDWARE_CLOBBER)(void()) sprites_irq()
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call (byte~) __init::$0 ← call toSpritePtr (const byte*) PLAYFIELD_SPRITES 
Inlined call (byte~) sprites_irq::$5 ← call toSpritePtr (const byte*) PLAYFIELD_SPRITES 
Inlined call call vicSelectGfxBank (const nomodify byte*) PLAYFIELD_SCREEN_1 
Inlined call (byte~) main::$1 ← call toD018 (const nomodify byte*) PLAYFIELD_SCREEN_1 (const byte*) PLAYFIELD_CHARSET 
Inlined call (byte~) main::$7 ← call toSpritePtr (const byte*) SIN_SPRITE 
Inlined call call __init 

CONTROL FLOW GRAPH SSA

(void()) sprites_init()
sprites_init: scope:[sprites_init]  from main::@4
  *((const nomodify byte*) SPRITES_ENABLE) ← (number) $f
  *((const nomodify byte*) SPRITES_MC) ← (number) 0
  *((const nomodify byte*) SPRITES_EXPAND_Y) ← *((const nomodify byte*) SPRITES_MC)
  *((const nomodify byte*) SPRITES_EXPAND_X) ← *((const nomodify byte*) SPRITES_EXPAND_Y)
  (byte) sprites_init::xpos#0 ← (byte)(number) $18+(number) $f*(number) 8
  (byte) sprites_init::s#0 ← (byte) 0
  to:sprites_init::@1
sprites_init::@1: scope:[sprites_init]  from sprites_init sprites_init::@1
  (byte) sprites_init::xpos#2 ← phi( sprites_init/(byte) sprites_init::xpos#0 sprites_init::@1/(byte) sprites_init::xpos#1 )
  (byte) sprites_init::s#2 ← phi( sprites_init/(byte) sprites_init::s#0 sprites_init::@1/(byte) sprites_init::s#1 )
  (number~) sprites_init::$0 ← (byte) sprites_init::s#2 * (number) 2
  (byte) sprites_init::s2#0 ← (number~) sprites_init::$0
  *((const nomodify byte*) SPRITES_XPOS + (byte) sprites_init::s2#0) ← (byte) sprites_init::xpos#2
  *((const nomodify byte*) SPRITES_COLOR + (byte) sprites_init::s#2) ← (const nomodify byte) BLACK
  (number~) sprites_init::$1 ← (byte) sprites_init::xpos#2 + (number) $18
  (byte) sprites_init::xpos#1 ← (number~) sprites_init::$1
  (byte) sprites_init::s#1 ← (byte) sprites_init::s#2 + rangenext(0,3)
  (bool~) sprites_init::$2 ← (byte) sprites_init::s#1 != rangelast(0,3)
  if((bool~) sprites_init::$2) goto sprites_init::@1
  to:sprites_init::@return
sprites_init::@return: scope:[sprites_init]  from sprites_init::@1
  return 
  to:@return

(void()) sprites_irq_init()
sprites_irq_init: scope:[sprites_irq_init]  from main::@2
  asm { sei  }
  *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  asm { ldaCIA1_INTERRUPT  }
  *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK
  *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR
  *((const nomodify byte*) VIC_CONTROL) ← *((const nomodify byte*) VIC_CONTROL) & (number) $7f
  *((const nomodify byte*) RASTER) ← (const nomodify byte) IRQ_RASTER_FIRST
  *((const nomodify byte*) IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER
  *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_CLOBBER)(void()) sprites_irq()
  asm { cli  }
  to:sprites_irq_init::@return
sprites_irq_init::@return: scope:[sprites_irq_init]  from sprites_irq_init
  return 
  to:@return

interrupt(HARDWARE_CLOBBER)(void()) sprites_irq()
sprites_irq: scope:[sprites_irq]  from
  asm { cld  }
  (byte) sprites_irq::ypos#0 ← (volatile byte) irq_sprite_ypos
  *((const nomodify byte*) SPRITES_YPOS + (number) 0) ← (byte) sprites_irq::ypos#0
  *((const nomodify byte*) SPRITES_YPOS + (number) 2) ← (byte) sprites_irq::ypos#0
  *((const nomodify byte*) SPRITES_YPOS + (number) 4) ← (byte) sprites_irq::ypos#0
  *((const nomodify byte*) SPRITES_YPOS + (number) 6) ← (byte) sprites_irq::ypos#0
  (number~) sprites_irq::$0 ← (volatile byte) irq_raster_next + (number) 1
  (volatile byte) sprites_irq::raster_sprite_gfx_modify ← (number~) sprites_irq::$0
  to:sprites_irq::@8
sprites_irq::@8: scope:[sprites_irq]  from sprites_irq sprites_irq::@8
  (bool~) sprites_irq::$4 ← *((const nomodify byte*) RASTER) < (volatile byte) sprites_irq::raster_sprite_gfx_modify
  if((bool~) sprites_irq::$4) goto sprites_irq::@8
  to:sprites_irq::@9
sprites_irq::@9: scope:[sprites_irq]  from sprites_irq::@8
  (byte) sprites_irq::ptr#0 ← (volatile byte) irq_sprite_ptr
  (bool~) sprites_irq::$1 ← (volatile byte) render_screen_showing == (number) 0
  if((bool~) sprites_irq::$1) goto sprites_irq::@1
  to:sprites_irq::@10
sprites_irq::@1: scope:[sprites_irq]  from sprites_irq::@9
  (byte) sprites_irq::ptr#5 ← phi( sprites_irq::@9/(byte) sprites_irq::ptr#0 )
  *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (number) 0) ← (byte) sprites_irq::ptr#5
  (byte) sprites_irq::ptr#1 ← ++ (byte) sprites_irq::ptr#5
  *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (number) 1) ← (byte) sprites_irq::ptr#1
  *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (number) 2) ← (byte) sprites_irq::ptr#1
  (byte) sprites_irq::ptr#2 ← ++ (byte) sprites_irq::ptr#1
  *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (number) 3) ← (byte) sprites_irq::ptr#2
  to:sprites_irq::@2
sprites_irq::@10: scope:[sprites_irq]  from sprites_irq::@9
  (byte) sprites_irq::ptr#6 ← phi( sprites_irq::@9/(byte) sprites_irq::ptr#0 )
  *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 + (number) 0) ← (byte) sprites_irq::ptr#6
  (byte) sprites_irq::ptr#3 ← ++ (byte) sprites_irq::ptr#6
  *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 + (number) 1) ← (byte) sprites_irq::ptr#3
  *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 + (number) 2) ← (byte) sprites_irq::ptr#3
  (byte) sprites_irq::ptr#4 ← ++ (byte) sprites_irq::ptr#3
  *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 + (number) 3) ← (byte) sprites_irq::ptr#4
  to:sprites_irq::@2
sprites_irq::@2: scope:[sprites_irq]  from sprites_irq::@1 sprites_irq::@10
  (volatile byte) irq_cnt ← ++ (volatile byte) irq_cnt
  (bool~) sprites_irq::$2 ← (volatile byte) irq_cnt == (number) 9
  if((bool~) sprites_irq::$2) goto sprites_irq::@3
  to:sprites_irq::@6
sprites_irq::@3: scope:[sprites_irq]  from sprites_irq::@2
  (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (number) $15
  (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS
  (byte*) sprites_irq::toSpritePtr1_sprite#0 ← (const byte*) PLAYFIELD_SPRITES
  to:sprites_irq::toSpritePtr1
sprites_irq::toSpritePtr1: scope:[sprites_irq]  from sprites_irq::@3
  (byte*) sprites_irq::toSpritePtr1_sprite#1 ← phi( sprites_irq::@3/(byte*) sprites_irq::toSpritePtr1_sprite#0 )
  (word~) sprites_irq::toSpritePtr1_$1 ← (word)(byte*) sprites_irq::toSpritePtr1_sprite#1
  (number~) sprites_irq::toSpritePtr1_$0 ← (word~) sprites_irq::toSpritePtr1_$1 / (number) $40
  (byte) sprites_irq::toSpritePtr1_return#0 ← (byte)(number~) sprites_irq::toSpritePtr1_$0
  to:sprites_irq::toSpritePtr1_@return
sprites_irq::toSpritePtr1_@return: scope:[sprites_irq]  from sprites_irq::toSpritePtr1
  (byte) sprites_irq::toSpritePtr1_return#2 ← phi( sprites_irq::toSpritePtr1/(byte) sprites_irq::toSpritePtr1_return#0 )
  (byte) sprites_irq::toSpritePtr1_return#1 ← (byte) sprites_irq::toSpritePtr1_return#2
  to:sprites_irq::@11
sprites_irq::@11: scope:[sprites_irq]  from sprites_irq::toSpritePtr1_@return
  (byte) sprites_irq::toSpritePtr1_return#3 ← phi( sprites_irq::toSpritePtr1_@return/(byte) sprites_irq::toSpritePtr1_return#1 )
  (byte~) sprites_irq::$5 ← (byte) sprites_irq::toSpritePtr1_return#3
  (volatile byte) irq_sprite_ptr ← (byte~) sprites_irq::$5
  to:sprites_irq::@5
sprites_irq::@6: scope:[sprites_irq]  from sprites_irq::@2
  (bool~) sprites_irq::$3 ← (volatile byte) irq_cnt == (number) $a
  if((bool~) sprites_irq::$3) goto sprites_irq::@4
  to:sprites_irq::@7
sprites_irq::@4: scope:[sprites_irq]  from sprites_irq::@6
  (volatile byte) irq_cnt ← (number) 0
  (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST
  (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (number) $15
  (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (number) 3
  to:sprites_irq::@5
sprites_irq::@7: scope:[sprites_irq]  from sprites_irq::@6
  (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (number) $14
  (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (number) $15
  (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (number) 3
  to:sprites_irq::@5
sprites_irq::@5: scope:[sprites_irq]  from sprites_irq::@11 sprites_irq::@4 sprites_irq::@7
  *((const nomodify byte*) RASTER) ← (volatile byte) irq_raster_next
  *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  to:sprites_irq::@return
sprites_irq::@return: scope:[sprites_irq]  from sprites_irq::@5
  return 
  to:@return

(void()) main()
main: scope:[main]  from __start::@1
  (byte) sin_idx#34 ← phi( __start::@1/(byte) sin_idx#18 )
  (byte*) main::vicSelectGfxBank1_gfx#0 ← (const nomodify byte*) PLAYFIELD_SCREEN_1
  to:main::vicSelectGfxBank1
main::vicSelectGfxBank1: scope:[main]  from main
  (byte) sin_idx#33 ← phi( main/(byte) sin_idx#34 )
  (byte*) main::vicSelectGfxBank1_gfx#1 ← phi( main/(byte*) main::vicSelectGfxBank1_gfx#0 )
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (number) 3
  (byte*) main::vicSelectGfxBank1_toDd001_gfx#0 ← (byte*) main::vicSelectGfxBank1_gfx#1
  to:main::vicSelectGfxBank1_toDd001
main::vicSelectGfxBank1_toDd001: scope:[main]  from main::vicSelectGfxBank1
  (byte) sin_idx#32 ← phi( main::vicSelectGfxBank1/(byte) sin_idx#33 )
  (byte*) main::vicSelectGfxBank1_toDd001_gfx#1 ← phi( main::vicSelectGfxBank1/(byte*) main::vicSelectGfxBank1_toDd001_gfx#0 )
  (byte~) main::vicSelectGfxBank1_toDd001_$0 ← > (word)(byte*) main::vicSelectGfxBank1_toDd001_gfx#1
  (number~) main::vicSelectGfxBank1_toDd001_$1 ← (byte~) main::vicSelectGfxBank1_toDd001_$0 / (number) $40
  (number~) main::vicSelectGfxBank1_toDd001_$2 ← (number) 3 ^ (number~) main::vicSelectGfxBank1_toDd001_$1
  (byte) main::vicSelectGfxBank1_toDd001_return#0 ← (number~) main::vicSelectGfxBank1_toDd001_$2
  to:main::vicSelectGfxBank1_toDd001_@return
main::vicSelectGfxBank1_toDd001_@return: scope:[main]  from main::vicSelectGfxBank1_toDd001
  (byte) sin_idx#31 ← phi( main::vicSelectGfxBank1_toDd001/(byte) sin_idx#32 )
  (byte) main::vicSelectGfxBank1_toDd001_return#2 ← phi( main::vicSelectGfxBank1_toDd001/(byte) main::vicSelectGfxBank1_toDd001_return#0 )
  (byte) main::vicSelectGfxBank1_toDd001_return#1 ← (byte) main::vicSelectGfxBank1_toDd001_return#2
  to:main::vicSelectGfxBank1_@1
main::vicSelectGfxBank1_@1: scope:[main]  from main::vicSelectGfxBank1_toDd001_@return
  (byte) sin_idx#30 ← phi( main::vicSelectGfxBank1_toDd001_@return/(byte) sin_idx#31 )
  (byte) main::vicSelectGfxBank1_toDd001_return#3 ← phi( main::vicSelectGfxBank1_toDd001_@return/(byte) main::vicSelectGfxBank1_toDd001_return#1 )
  (byte~) main::vicSelectGfxBank1_$0 ← (byte) main::vicSelectGfxBank1_toDd001_return#3
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A) ← (byte~) main::vicSelectGfxBank1_$0
  to:main::@3
main::@3: scope:[main]  from main::vicSelectGfxBank1_@1
  (byte) sin_idx#29 ← phi( main::vicSelectGfxBank1_@1/(byte) sin_idx#30 )
  (byte*) main::toD0181_screen#0 ← (const nomodify byte*) PLAYFIELD_SCREEN_1
  (byte*) main::toD0181_gfx#0 ← (const byte*) PLAYFIELD_CHARSET
  to:main::toD0181
main::toD0181: scope:[main]  from main::@3
  (byte) sin_idx#28 ← phi( main::@3/(byte) sin_idx#29 )
  (byte*) main::toD0181_gfx#1 ← phi( main::@3/(byte*) main::toD0181_gfx#0 )
  (byte*) main::toD0181_screen#1 ← phi( main::@3/(byte*) main::toD0181_screen#0 )
  (word~) main::toD0181_$7 ← (word)(byte*) main::toD0181_screen#1
  (number~) main::toD0181_$0 ← (word~) main::toD0181_$7 & (number) $3fff
  (number~) main::toD0181_$1 ← (number~) main::toD0181_$0 * (number) 4
  (number~) main::toD0181_$2 ← > (number~) main::toD0181_$1
  (byte~) main::toD0181_$3 ← > (word)(byte*) main::toD0181_gfx#1
  (number~) main::toD0181_$4 ← (byte~) main::toD0181_$3 / (number) 4
  (number~) main::toD0181_$5 ← (number~) main::toD0181_$4 & (number) $f
  (number~) main::toD0181_$6 ← (number~) main::toD0181_$2 | (number~) main::toD0181_$5
  (byte) main::toD0181_return#0 ← (number~) main::toD0181_$6
  to:main::toD0181_@return
main::toD0181_@return: scope:[main]  from main::toD0181
  (byte) sin_idx#27 ← phi( main::toD0181/(byte) sin_idx#28 )
  (byte) main::toD0181_return#2 ← phi( main::toD0181/(byte) main::toD0181_return#0 )
  (byte) main::toD0181_return#1 ← (byte) main::toD0181_return#2
  to:main::@4
main::@4: scope:[main]  from main::toD0181_@return
  (byte) sin_idx#26 ← phi( main::toD0181_@return/(byte) sin_idx#27 )
  (byte) main::toD0181_return#3 ← phi( main::toD0181_@return/(byte) main::toD0181_return#1 )
  (byte~) main::$1 ← (byte) main::toD0181_return#3
  *((const nomodify byte*) D018) ← (byte~) main::$1
  call sprites_init 
  to:main::@6
main::@6: scope:[main]  from main::@4
  (byte) sin_idx#25 ← phi( main::@4/(byte) sin_idx#26 )
  *((const nomodify byte*) SPRITES_ENABLE) ← (number) $ff
  (byte) main::xpos#0 ← (byte) $18
  (byte) main::ypos#0 ← (byte) $32
  (byte) main::s#0 ← (byte) 4
  to:main::@1
main::@1: scope:[main]  from main::@5 main::@6
  (byte) sin_idx#24 ← phi( main::@5/(byte) sin_idx#21 main::@6/(byte) sin_idx#25 )
  (byte) main::ypos#2 ← phi( main::@5/(byte) main::ypos#1 main::@6/(byte) main::ypos#0 )
  (byte) main::xpos#2 ← phi( main::@5/(byte) main::xpos#1 main::@6/(byte) main::xpos#0 )
  (byte) main::s#2 ← phi( main::@5/(byte) main::s#1 main::@6/(byte) main::s#0 )
  (number~) main::$5 ← (byte) main::s#2 * (number) 2
  (byte) main::s2#0 ← (number~) main::$5
  *((const nomodify byte*) SPRITES_XPOS + (byte) main::s2#0) ← (byte) main::xpos#2
  *((const nomodify byte*) SPRITES_YPOS + (byte) main::s2#0) ← (byte) main::ypos#2
  (number~) main::$6 ← (byte) main::s#2 - (number) 3
  *((const nomodify byte*) SPRITES_COLOR + (byte) main::s#2) ← (number~) main::$6
  (byte*) main::toSpritePtr1_sprite#0 ← (const byte*) SIN_SPRITE
  to:main::toSpritePtr1
main::toSpritePtr1: scope:[main]  from main::@1
  (byte) sin_idx#23 ← phi( main::@1/(byte) sin_idx#24 )
  (byte) main::ypos#5 ← phi( main::@1/(byte) main::ypos#2 )
  (byte) main::xpos#5 ← phi( main::@1/(byte) main::xpos#2 )
  (byte) main::s#5 ← phi( main::@1/(byte) main::s#2 )
  (byte*) main::toSpritePtr1_sprite#1 ← phi( main::@1/(byte*) main::toSpritePtr1_sprite#0 )
  (word~) main::toSpritePtr1_$1 ← (word)(byte*) main::toSpritePtr1_sprite#1
  (number~) main::toSpritePtr1_$0 ← (word~) main::toSpritePtr1_$1 / (number) $40
  (byte) main::toSpritePtr1_return#0 ← (byte)(number~) main::toSpritePtr1_$0
  to:main::toSpritePtr1_@return
main::toSpritePtr1_@return: scope:[main]  from main::toSpritePtr1
  (byte) sin_idx#22 ← phi( main::toSpritePtr1/(byte) sin_idx#23 )
  (byte) main::ypos#4 ← phi( main::toSpritePtr1/(byte) main::ypos#5 )
  (byte) main::xpos#4 ← phi( main::toSpritePtr1/(byte) main::xpos#5 )
  (byte) main::s#4 ← phi( main::toSpritePtr1/(byte) main::s#5 )
  (byte) main::toSpritePtr1_return#2 ← phi( main::toSpritePtr1/(byte) main::toSpritePtr1_return#0 )
  (byte) main::toSpritePtr1_return#1 ← (byte) main::toSpritePtr1_return#2
  to:main::@5
main::@5: scope:[main]  from main::toSpritePtr1_@return
  (byte) sin_idx#21 ← phi( main::toSpritePtr1_@return/(byte) sin_idx#22 )
  (byte) main::ypos#3 ← phi( main::toSpritePtr1_@return/(byte) main::ypos#4 )
  (byte) main::xpos#3 ← phi( main::toSpritePtr1_@return/(byte) main::xpos#4 )
  (byte) main::s#3 ← phi( main::toSpritePtr1_@return/(byte) main::s#4 )
  (byte) main::toSpritePtr1_return#3 ← phi( main::toSpritePtr1_@return/(byte) main::toSpritePtr1_return#1 )
  (byte~) main::$7 ← (byte) main::toSpritePtr1_return#3
  *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (byte) main::s#3) ← (byte~) main::$7
  (byte) main::xpos#1 ← (byte) main::xpos#3 + (number) $18
  (byte) main::ypos#1 ← (byte) main::ypos#3 + (number) $18
  (byte) main::s#1 ← (byte) main::s#3 + rangenext(4,7)
  (bool~) main::$8 ← (byte) main::s#1 != rangelast(4,7)
  if((bool~) main::$8) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@5
  (byte) sin_idx#19 ← phi( main::@5/(byte) sin_idx#21 )
  call sprites_irq_init 
  to:main::@7
main::@7: scope:[main]  from main::@2
  (byte) sin_idx#14 ← phi( main::@2/(byte) sin_idx#19 )
  call loop 
  to:main::@8
main::@8: scope:[main]  from main::@7
  (byte) sin_idx#7 ← phi( main::@7/(byte) sin_idx#3 )
  (byte) sin_idx#0 ← (byte) sin_idx#7
  to:main::@return
main::@return: scope:[main]  from main::@8
  (byte) sin_idx#8 ← phi( main::@8/(byte) sin_idx#0 )
  (byte) sin_idx#1 ← (byte) sin_idx#8
  return 
  to:@return

(void()) loop()
loop: scope:[loop]  from main::@7
  (byte) sin_idx#20 ← phi( main::@7/(byte) sin_idx#14 )
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@5
  (byte) sin_idx#17 ← phi( loop/(byte) sin_idx#20 loop::@5/(byte) sin_idx#2 )
  if(true) goto loop::@2
  to:loop::@return
loop::@2: scope:[loop]  from loop::@1 loop::@2
  (byte) sin_idx#15 ← phi( loop::@1/(byte) sin_idx#17 loop::@2/(byte) sin_idx#15 )
  (bool~) loop::$0 ← *((const nomodify byte*) RASTER) != (number) $ff
  if((bool~) loop::$0) goto loop::@2
  to:loop::@3
loop::@3: scope:[loop]  from loop::@2
  (byte) sin_idx#9 ← phi( loop::@2/(byte) sin_idx#15 )
  (byte) loop::idx#0 ← (byte) sin_idx#9
  (byte) loop::s#0 ← (byte) 4
  to:loop::@4
loop::@4: scope:[loop]  from loop::@3 loop::@4
  (byte) sin_idx#16 ← phi( loop::@3/(byte) sin_idx#9 loop::@4/(byte) sin_idx#16 )
  (byte) loop::idx#2 ← phi( loop::@3/(byte) loop::idx#0 loop::@4/(byte) loop::idx#1 )
  (byte) loop::s#2 ← phi( loop::@3/(byte) loop::s#0 loop::@4/(byte) loop::s#1 )
  (number~) loop::$1 ← (byte) loop::s#2 * (number) 2
  *((const nomodify byte*) SPRITES_YPOS + (number~) loop::$1) ← *((const byte*) SIN + (byte) loop::idx#2)
  (byte) loop::idx#1 ← (byte) loop::idx#2 + (number) $a
  (byte) loop::s#1 ← (byte) loop::s#2 + rangenext(4,7)
  (bool~) loop::$2 ← (byte) loop::s#1 != rangelast(4,7)
  if((bool~) loop::$2) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  (byte) sin_idx#10 ← phi( loop::@4/(byte) sin_idx#16 )
  (byte) sin_idx#2 ← ++ (byte) sin_idx#10
  to:loop::@1
loop::@return: scope:[loop]  from loop::@1
  (byte) sin_idx#11 ← phi( loop::@1/(byte) sin_idx#17 )
  (byte) sin_idx#3 ← (byte) sin_idx#11
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  (volatile byte) render_screen_showing ← (byte) 0
  (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST
  (volatile byte) irq_sprite_ypos ← (byte)(const nomodify byte) SPRITES_FIRST_YPOS+(number) $15
  (byte*) __start::__init1_toSpritePtr1_sprite#0 ← (const byte*) PLAYFIELD_SPRITES
  to:__start::__init1_toSpritePtr1
__start::__init1_toSpritePtr1: scope:[__start]  from __start::__init1
  (byte*) __start::__init1_toSpritePtr1_sprite#1 ← phi( __start::__init1/(byte*) __start::__init1_toSpritePtr1_sprite#0 )
  (word~) __start::__init1_toSpritePtr1_$1 ← (word)(byte*) __start::__init1_toSpritePtr1_sprite#1
  (number~) __start::__init1_toSpritePtr1_$0 ← (word~) __start::__init1_toSpritePtr1_$1 / (number) $40
  (byte) __start::__init1_toSpritePtr1_return#0 ← (byte)(number~) __start::__init1_toSpritePtr1_$0
  to:__start::__init1_toSpritePtr1_@return
__start::__init1_toSpritePtr1_@return: scope:[__start]  from __start::__init1_toSpritePtr1
  (byte) __start::__init1_toSpritePtr1_return#2 ← phi( __start::__init1_toSpritePtr1/(byte) __start::__init1_toSpritePtr1_return#0 )
  (byte) __start::__init1_toSpritePtr1_return#1 ← (byte) __start::__init1_toSpritePtr1_return#2
  to:__start::__init1_@1
__start::__init1_@1: scope:[__start]  from __start::__init1_toSpritePtr1_@return
  (byte) __start::__init1_toSpritePtr1_return#3 ← phi( __start::__init1_toSpritePtr1_@return/(byte) __start::__init1_toSpritePtr1_return#1 )
  (byte~) __start::__init1_$0 ← (byte) __start::__init1_toSpritePtr1_return#3
  (number~) __start::__init1_$1 ← (byte~) __start::__init1_$0 + (number) 3
  (volatile byte) irq_sprite_ptr ← (number~) __start::__init1_$1
  (volatile byte) irq_cnt ← (byte) 0
  (byte) sin_idx#4 ← (byte) 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1_@1
  (byte) sin_idx#18 ← phi( __start::__init1_@1/(byte) sin_idx#4 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  (byte) sin_idx#12 ← phi( __start::@1/(byte) sin_idx#1 )
  (byte) sin_idx#5 ← (byte) sin_idx#12
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  (byte) sin_idx#13 ← phi( __start::@2/(byte) sin_idx#5 )
  (byte) sin_idx#6 ← (byte) sin_idx#13
  return 
  to:@return

SYMBOL TABLE SSA
(const nomodify byte) BLACK = (byte) 0
(const nomodify struct MOS6526_CIA*) CIA1 = (struct MOS6526_CIA*)(number) $dc00
(const nomodify byte*) CIA1_INTERRUPT = (byte*)(number) $dc0d
(const nomodify struct MOS6526_CIA*) CIA2 = (struct MOS6526_CIA*)(number) $dd00
(const nomodify byte) CIA_INTERRUPT_CLEAR = (byte) $7f
(const nomodify byte*) D018 = (byte*)(number) $d018
(const nomodify void()**) HARDWARE_IRQ = (void()**)(number) $fffe
(const nomodify byte*) IRQ_ENABLE = (byte*)(number) $d01a
(const nomodify byte) IRQ_RASTER = (byte) 1
(const nomodify byte) IRQ_RASTER_FIRST = (byte)(const nomodify byte) SPRITES_FIRST_YPOS+(number) $13
(const nomodify byte*) IRQ_STATUS = (byte*)(number) $d019
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = (byte) $d
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A = (byte) 0
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = (byte) 2
(const byte*) PLAYFIELD_CHARSET[]  = kickasm {{ .fill 8,$00 // Place a filled char at the start of the charset
    .import binary "playfield-screen.imap"
 }}
(const nomodify byte*) PLAYFIELD_SCREEN_1 = (byte*)(number) $400
(const nomodify byte*) PLAYFIELD_SCREEN_2 = (byte*)(number) $2c00
(const byte*) PLAYFIELD_SPRITES[(number) $1e*(number) $40]  = kickasm {{ .var sprites = LoadPicture("playfield-sprites.png", List().add($010101, $000000))
	// Put the sprites into memory
	.for(var sy=0;sy<10;sy++) {
	    .var sprite_gfx_y = sy*20
		.for(var sx=0;sx<3;sx++) {
	    	.for (var y=0;y<21; y++) {
	    	    .var gfx_y =  sprite_gfx_y + mod(2100+y-sprite_gfx_y,21)
		    	.for (var c=0; c<3; c++) {
	            	.byte sprites.getSinglecolorByte(sx*3+c,gfx_y)
	            }
	        }
	    	.byte 0
	  	}
	}
 }}
(const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 = (const nomodify byte*) PLAYFIELD_SCREEN_1+(const nomodify word) SPRITE_PTRS
(const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 = (const nomodify byte*) PLAYFIELD_SCREEN_2+(const nomodify word) SPRITE_PTRS
(const nomodify byte*) PROCPORT = (byte*)(number) 1
(const nomodify byte*) PROCPORT_DDR = (byte*)(number) 0
(const nomodify byte) PROCPORT_DDR_MEMORY_MASK = (byte) 7
(const nomodify byte) PROCPORT_RAM_IO = (byte) 5
(const nomodify byte*) RASTER = (byte*)(number) $d012
(const byte*) SIN[(number) $100]  = kickasm {{ .var AMPL = 200-21
    .for(var i=0; i<256; i++) {
  	  .byte 51+AMPL/2+sin(toRadians([i*360]/256))*AMPL/2
    }
 }}
(const byte*) SIN_SPRITE[(number) $40]  = kickasm {{ .fill $40, $ff
 }}
(const nomodify byte*) SPRITES_COLOR = (byte*)(number) $d027
(const nomodify byte*) SPRITES_ENABLE = (byte*)(number) $d015
(const nomodify byte*) SPRITES_EXPAND_X = (byte*)(number) $d01d
(const nomodify byte*) SPRITES_EXPAND_Y = (byte*)(number) $d017
(const nomodify byte) SPRITES_FIRST_YPOS = (byte) $31
(const nomodify byte*) SPRITES_MC = (byte*)(number) $d01c
(const nomodify byte*) SPRITES_XPOS = (byte*)(number) $d000
(const nomodify byte*) SPRITES_YPOS = (byte*)(number) $d001
(const nomodify word) SPRITE_PTRS = (word) $3f8
(const nomodify byte*) VIC_CONTROL = (byte*)(number) $d011
(void()) __start()
(label) __start::@1
(label) __start::@2
(label) __start::@return
(label) __start::__init1
(byte~) __start::__init1_$0
(number~) __start::__init1_$1
(label) __start::__init1_@1
(label) __start::__init1_toSpritePtr1
(number~) __start::__init1_toSpritePtr1_$0
(word~) __start::__init1_toSpritePtr1_$1
(label) __start::__init1_toSpritePtr1_@return
(byte) __start::__init1_toSpritePtr1_return
(byte) __start::__init1_toSpritePtr1_return#0
(byte) __start::__init1_toSpritePtr1_return#1
(byte) __start::__init1_toSpritePtr1_return#2
(byte) __start::__init1_toSpritePtr1_return#3
(byte*) __start::__init1_toSpritePtr1_sprite
(byte*) __start::__init1_toSpritePtr1_sprite#0
(byte*) __start::__init1_toSpritePtr1_sprite#1
(volatile byte) irq_cnt loadstore
(volatile byte) irq_raster_next loadstore
(volatile byte) irq_sprite_ptr loadstore
(volatile byte) irq_sprite_ypos loadstore
(void()) loop()
(bool~) loop::$0
(number~) loop::$1
(bool~) loop::$2
(label) loop::@1
(label) loop::@2
(label) loop::@3
(label) loop::@4
(label) loop::@5
(label) loop::@return
(byte) loop::idx
(byte) loop::idx#0
(byte) loop::idx#1
(byte) loop::idx#2
(byte) loop::s
(byte) loop::s#0
(byte) loop::s#1
(byte) loop::s#2
(void()) main()
(byte~) main::$1
(number~) main::$5
(number~) main::$6
(byte~) main::$7
(bool~) main::$8
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@return
(byte) main::s
(byte) main::s#0
(byte) main::s#1
(byte) main::s#2
(byte) main::s#3
(byte) main::s#4
(byte) main::s#5
(byte) main::s2
(byte) main::s2#0
(label) main::toD0181
(number~) main::toD0181_$0
(number~) main::toD0181_$1
(number~) main::toD0181_$2
(byte~) main::toD0181_$3
(number~) main::toD0181_$4
(number~) main::toD0181_$5
(number~) main::toD0181_$6
(word~) main::toD0181_$7
(label) main::toD0181_@return
(byte*) main::toD0181_gfx
(byte*) main::toD0181_gfx#0
(byte*) main::toD0181_gfx#1
(byte) main::toD0181_return
(byte) main::toD0181_return#0
(byte) main::toD0181_return#1
(byte) main::toD0181_return#2
(byte) main::toD0181_return#3
(byte*) main::toD0181_screen
(byte*) main::toD0181_screen#0
(byte*) main::toD0181_screen#1
(label) main::toSpritePtr1
(number~) main::toSpritePtr1_$0
(word~) main::toSpritePtr1_$1
(label) main::toSpritePtr1_@return
(byte) main::toSpritePtr1_return
(byte) main::toSpritePtr1_return#0
(byte) main::toSpritePtr1_return#1
(byte) main::toSpritePtr1_return#2
(byte) main::toSpritePtr1_return#3
(byte*) main::toSpritePtr1_sprite
(byte*) main::toSpritePtr1_sprite#0
(byte*) main::toSpritePtr1_sprite#1
(label) main::vicSelectGfxBank1
(byte~) main::vicSelectGfxBank1_$0
(label) main::vicSelectGfxBank1_@1
(byte*) main::vicSelectGfxBank1_gfx
(byte*) main::vicSelectGfxBank1_gfx#0
(byte*) main::vicSelectGfxBank1_gfx#1
(label) main::vicSelectGfxBank1_toDd001
(byte~) main::vicSelectGfxBank1_toDd001_$0
(number~) main::vicSelectGfxBank1_toDd001_$1
(number~) main::vicSelectGfxBank1_toDd001_$2
(label) main::vicSelectGfxBank1_toDd001_@return
(byte*) main::vicSelectGfxBank1_toDd001_gfx
(byte*) main::vicSelectGfxBank1_toDd001_gfx#0
(byte*) main::vicSelectGfxBank1_toDd001_gfx#1
(byte) main::vicSelectGfxBank1_toDd001_return
(byte) main::vicSelectGfxBank1_toDd001_return#0
(byte) main::vicSelectGfxBank1_toDd001_return#1
(byte) main::vicSelectGfxBank1_toDd001_return#2
(byte) main::vicSelectGfxBank1_toDd001_return#3
(byte) main::xpos
(byte) main::xpos#0
(byte) main::xpos#1
(byte) main::xpos#2
(byte) main::xpos#3
(byte) main::xpos#4
(byte) main::xpos#5
(byte) main::ypos
(byte) main::ypos#0
(byte) main::ypos#1
(byte) main::ypos#2
(byte) main::ypos#3
(byte) main::ypos#4
(byte) main::ypos#5
(volatile byte) render_screen_showing loadstore
(byte) sin_idx
(byte) sin_idx#0
(byte) sin_idx#1
(byte) sin_idx#10
(byte) sin_idx#11
(byte) sin_idx#12
(byte) sin_idx#13
(byte) sin_idx#14
(byte) sin_idx#15
(byte) sin_idx#16
(byte) sin_idx#17
(byte) sin_idx#18
(byte) sin_idx#19
(byte) sin_idx#2
(byte) sin_idx#20
(byte) sin_idx#21
(byte) sin_idx#22
(byte) sin_idx#23
(byte) sin_idx#24
(byte) sin_idx#25
(byte) sin_idx#26
(byte) sin_idx#27
(byte) sin_idx#28
(byte) sin_idx#29
(byte) sin_idx#3
(byte) sin_idx#30
(byte) sin_idx#31
(byte) sin_idx#32
(byte) sin_idx#33
(byte) sin_idx#34
(byte) sin_idx#4
(byte) sin_idx#5
(byte) sin_idx#6
(byte) sin_idx#7
(byte) sin_idx#8
(byte) sin_idx#9
(void()) sprites_init()
(number~) sprites_init::$0
(number~) sprites_init::$1
(bool~) sprites_init::$2
(label) sprites_init::@1
(label) sprites_init::@return
(byte) sprites_init::s
(byte) sprites_init::s#0
(byte) sprites_init::s#1
(byte) sprites_init::s#2
(byte) sprites_init::s2
(byte) sprites_init::s2#0
(byte) sprites_init::xpos
(byte) sprites_init::xpos#0
(byte) sprites_init::xpos#1
(byte) sprites_init::xpos#2
interrupt(HARDWARE_CLOBBER)(void()) sprites_irq()
(number~) sprites_irq::$0
(bool~) sprites_irq::$1
(bool~) sprites_irq::$2
(bool~) sprites_irq::$3
(bool~) sprites_irq::$4
(byte~) sprites_irq::$5
(label) sprites_irq::@1
(label) sprites_irq::@10
(label) sprites_irq::@11
(label) sprites_irq::@2
(label) sprites_irq::@3
(label) sprites_irq::@4
(label) sprites_irq::@5
(label) sprites_irq::@6
(label) sprites_irq::@7
(label) sprites_irq::@8
(label) sprites_irq::@9
(label) sprites_irq::@return
(byte) sprites_irq::ptr
(byte) sprites_irq::ptr#0
(byte) sprites_irq::ptr#1
(byte) sprites_irq::ptr#2
(byte) sprites_irq::ptr#3
(byte) sprites_irq::ptr#4
(byte) sprites_irq::ptr#5
(byte) sprites_irq::ptr#6
(volatile byte) sprites_irq::raster_sprite_gfx_modify loadstore
(label) sprites_irq::toSpritePtr1
(number~) sprites_irq::toSpritePtr1_$0
(word~) sprites_irq::toSpritePtr1_$1
(label) sprites_irq::toSpritePtr1_@return
(byte) sprites_irq::toSpritePtr1_return
(byte) sprites_irq::toSpritePtr1_return#0
(byte) sprites_irq::toSpritePtr1_return#1
(byte) sprites_irq::toSpritePtr1_return#2
(byte) sprites_irq::toSpritePtr1_return#3
(byte*) sprites_irq::toSpritePtr1_sprite
(byte*) sprites_irq::toSpritePtr1_sprite#0
(byte*) sprites_irq::toSpritePtr1_sprite#1
(byte) sprites_irq::ypos
(byte) sprites_irq::ypos#0
(void()) sprites_irq_init()
(label) sprites_irq_init::@return

Adding number conversion cast (unumber) $13 in 
Adding number conversion cast (unumber) $f in *((const nomodify byte*) SPRITES_ENABLE) ← (number) $f
Adding number conversion cast (unumber) 0 in *((const nomodify byte*) SPRITES_MC) ← (number) 0
Adding number conversion cast (unumber) 2 in (number~) sprites_init::$0 ← (byte) sprites_init::s#2 * (number) 2
Adding number conversion cast (unumber) sprites_init::$0 in (number~) sprites_init::$0 ← (byte) sprites_init::s#2 * (unumber)(number) 2
Adding number conversion cast (unumber) $18 in (number~) sprites_init::$1 ← (byte) sprites_init::xpos#2 + (number) $18
Adding number conversion cast (unumber) sprites_init::$1 in (number~) sprites_init::$1 ← (byte) sprites_init::xpos#2 + (unumber)(number) $18
Adding number conversion cast (unumber) $7f in *((const nomodify byte*) VIC_CONTROL) ← *((const nomodify byte*) VIC_CONTROL) & (number) $7f
Adding number conversion cast (unumber) 0 in *((const nomodify byte*) SPRITES_YPOS + (number) 0) ← (byte) sprites_irq::ypos#0
Adding number conversion cast (unumber) 2 in *((const nomodify byte*) SPRITES_YPOS + (number) 2) ← (byte) sprites_irq::ypos#0
Adding number conversion cast (unumber) 4 in *((const nomodify byte*) SPRITES_YPOS + (number) 4) ← (byte) sprites_irq::ypos#0
Adding number conversion cast (unumber) 6 in *((const nomodify byte*) SPRITES_YPOS + (number) 6) ← (byte) sprites_irq::ypos#0
Adding number conversion cast (unumber) 1 in (number~) sprites_irq::$0 ← (volatile byte) irq_raster_next + (number) 1
Adding number conversion cast (unumber) sprites_irq::$0 in (number~) sprites_irq::$0 ← (volatile byte) irq_raster_next + (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) sprites_irq::$1 ← (volatile byte) render_screen_showing == (number) 0
Adding number conversion cast (unumber) 0 in *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (number) 0) ← (byte) sprites_irq::ptr#5
Adding number conversion cast (unumber) 1 in *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (number) 1) ← (byte) sprites_irq::ptr#1
Adding number conversion cast (unumber) 2 in *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (number) 2) ← (byte) sprites_irq::ptr#1
Adding number conversion cast (unumber) 3 in *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (number) 3) ← (byte) sprites_irq::ptr#2
Adding number conversion cast (unumber) 0 in *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 + (number) 0) ← (byte) sprites_irq::ptr#6
Adding number conversion cast (unumber) 1 in *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 + (number) 1) ← (byte) sprites_irq::ptr#3
Adding number conversion cast (unumber) 2 in *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 + (number) 2) ← (byte) sprites_irq::ptr#3
Adding number conversion cast (unumber) 3 in *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 + (number) 3) ← (byte) sprites_irq::ptr#4
Adding number conversion cast (unumber) 9 in (bool~) sprites_irq::$2 ← (volatile byte) irq_cnt == (number) 9
Adding number conversion cast (unumber) $15 in (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (number) $15
Adding number conversion cast (unumber) $40 in (number~) sprites_irq::toSpritePtr1_$0 ← (word~) sprites_irq::toSpritePtr1_$1 / (number) $40
Adding number conversion cast (unumber) sprites_irq::toSpritePtr1_$0 in (number~) sprites_irq::toSpritePtr1_$0 ← (word~) sprites_irq::toSpritePtr1_$1 / (unumber)(number) $40
Adding number conversion cast (unumber) $a in (bool~) sprites_irq::$3 ← (volatile byte) irq_cnt == (number) $a
Adding number conversion cast (unumber) 0 in (volatile byte) irq_cnt ← (number) 0
Adding number conversion cast (unumber) $15 in (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (number) $15
Adding number conversion cast (unumber) 3 in (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (number) 3
Adding number conversion cast (unumber) $14 in (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (number) $14
Adding number conversion cast (unumber) $15 in (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (number) $15
Adding number conversion cast (unumber) 3 in (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (number) 3
Adding number conversion cast (unumber) 3 in *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (number) 3
Adding number conversion cast (unumber) $40 in (number~) main::vicSelectGfxBank1_toDd001_$1 ← (byte~) main::vicSelectGfxBank1_toDd001_$0 / (number) $40
Adding number conversion cast (unumber) main::vicSelectGfxBank1_toDd001_$1 in (number~) main::vicSelectGfxBank1_toDd001_$1 ← (byte~) main::vicSelectGfxBank1_toDd001_$0 / (unumber)(number) $40
Adding number conversion cast (unumber) 3 in (number~) main::vicSelectGfxBank1_toDd001_$2 ← (number) 3 ^ (unumber~) main::vicSelectGfxBank1_toDd001_$1
Adding number conversion cast (unumber) main::vicSelectGfxBank1_toDd001_$2 in (number~) main::vicSelectGfxBank1_toDd001_$2 ← (unumber)(number) 3 ^ (unumber~) main::vicSelectGfxBank1_toDd001_$1
Adding number conversion cast (unumber) $3fff in (number~) main::toD0181_$0 ← (word~) main::toD0181_$7 & (number) $3fff
Adding number conversion cast (unumber) main::toD0181_$0 in (number~) main::toD0181_$0 ← (word~) main::toD0181_$7 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$1 ← (unumber~) main::toD0181_$0 * (number) 4
Adding number conversion cast (unumber) main::toD0181_$1 in (number~) main::toD0181_$1 ← (unumber~) main::toD0181_$0 * (unumber)(number) 4
Adding number conversion cast (unumber) main::toD0181_$2 in (number~) main::toD0181_$2 ← > (unumber~) main::toD0181_$1
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$4 ← (byte~) main::toD0181_$3 / (number) 4
Adding number conversion cast (unumber) main::toD0181_$4 in (number~) main::toD0181_$4 ← (byte~) main::toD0181_$3 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) main::toD0181_$5 ← (unumber~) main::toD0181_$4 & (number) $f
Adding number conversion cast (unumber) main::toD0181_$5 in (number~) main::toD0181_$5 ← (unumber~) main::toD0181_$4 & (unumber)(number) $f
Adding number conversion cast (unumber) main::toD0181_$6 in (number~) main::toD0181_$6 ← (unumber~) main::toD0181_$2 | (unumber~) main::toD0181_$5
Adding number conversion cast (unumber) $ff in *((const nomodify byte*) SPRITES_ENABLE) ← (number) $ff
Adding number conversion cast (unumber) 2 in (number~) main::$5 ← (byte) main::s#2 * (number) 2
Adding number conversion cast (unumber) main::$5 in (number~) main::$5 ← (byte) main::s#2 * (unumber)(number) 2
Adding number conversion cast (unumber) 3 in (number~) main::$6 ← (byte) main::s#2 - (number) 3
Adding number conversion cast (unumber) main::$6 in (number~) main::$6 ← (byte) main::s#2 - (unumber)(number) 3
Adding number conversion cast (unumber) $40 in (number~) main::toSpritePtr1_$0 ← (word~) main::toSpritePtr1_$1 / (number) $40
Adding number conversion cast (unumber) main::toSpritePtr1_$0 in (number~) main::toSpritePtr1_$0 ← (word~) main::toSpritePtr1_$1 / (unumber)(number) $40
Adding number conversion cast (unumber) $18 in (byte) main::xpos#1 ← (byte) main::xpos#3 + (number) $18
Adding number conversion cast (unumber) $18 in (byte) main::ypos#1 ← (byte) main::ypos#3 + (number) $18
Adding number conversion cast (unumber) $ff in (bool~) loop::$0 ← *((const nomodify byte*) RASTER) != (number) $ff
Adding number conversion cast (unumber) 2 in (number~) loop::$1 ← (byte) loop::s#2 * (number) 2
Adding number conversion cast (unumber) loop::$1 in (number~) loop::$1 ← (byte) loop::s#2 * (unumber)(number) 2
Adding number conversion cast (unumber) $a in (byte) loop::idx#1 ← (byte) loop::idx#2 + (number) $a
Adding number conversion cast (unumber) $15 in (volatile byte) irq_sprite_ypos ← (byte)(const nomodify byte) SPRITES_FIRST_YPOS+(number) $15
Adding number conversion cast (unumber) $40 in (number~) __start::__init1_toSpritePtr1_$0 ← (word~) __start::__init1_toSpritePtr1_$1 / (number) $40
Adding number conversion cast (unumber) __start::__init1_toSpritePtr1_$0 in (number~) __start::__init1_toSpritePtr1_$0 ← (word~) __start::__init1_toSpritePtr1_$1 / (unumber)(number) $40
Adding number conversion cast (unumber) 3 in (number~) __start::__init1_$1 ← (byte~) __start::__init1_$0 + (number) 3
Adding number conversion cast (unumber) __start::__init1_$1 in (number~) __start::__init1_$1 ← (byte~) __start::__init1_$0 + (unumber)(number) 3
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((const nomodify byte*) SPRITES_ENABLE) ← (unumber)(number) $f
Inlining cast *((const nomodify byte*) SPRITES_MC) ← (unumber)(number) 0
Inlining cast (volatile byte) irq_cnt ← (unumber)(number) 0
Inlining cast *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (unumber)(number) 3
Inlining cast *((const nomodify byte*) SPRITES_ENABLE) ← (unumber)(number) $ff
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 53249
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53271
Simplifying constant pointer cast (byte*) 53276
Simplifying constant pointer cast (byte*) 53277
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (byte*) 53272
Simplifying constant pointer cast (byte*) 53273
Simplifying constant pointer cast (byte*) 53274
Simplifying constant pointer cast (byte*) 0
Simplifying constant pointer cast (byte*) 1
Simplifying constant pointer cast (struct MOS6526_CIA*) 56320
Simplifying constant pointer cast (struct MOS6526_CIA*) 56576
Simplifying constant pointer cast (byte*) 56333
Simplifying constant pointer cast (void()**) 65534
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 11264
Simplifying constant integer cast $13
Simplifying constant integer cast $f
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $18
Simplifying constant integer cast $7f
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 6
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 3
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 3
Simplifying constant integer cast 9
Simplifying constant integer cast $15
Simplifying constant integer cast $40
Simplifying constant integer cast $a
Simplifying constant integer cast 0
Simplifying constant integer cast $15
Simplifying constant integer cast 3
Simplifying constant integer cast $14
Simplifying constant integer cast $15
Simplifying constant integer cast 3
Simplifying constant integer cast 3
Simplifying constant integer cast $40
Simplifying constant integer cast 3
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $ff
Simplifying constant integer cast 2
Simplifying constant integer cast 3
Simplifying constant integer cast $40
Simplifying constant integer cast $18
Simplifying constant integer cast $18
Simplifying constant integer cast $ff
Simplifying constant integer cast 2
Simplifying constant integer cast $a
Simplifying constant integer cast $15
Simplifying constant integer cast $40
Simplifying constant integer cast 3
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $13
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $14
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 3
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 3
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) sprites_init::$0 ← (byte) sprites_init::s#2 * (byte) 2
Inferred type updated to byte in (unumber~) sprites_init::$1 ← (byte) sprites_init::xpos#2 + (byte) $18
Inferred type updated to byte in (unumber~) sprites_irq::$0 ← (volatile byte) irq_raster_next + (byte) 1
Inferred type updated to word in (unumber~) sprites_irq::toSpritePtr1_$0 ← (word~) sprites_irq::toSpritePtr1_$1 / (byte) $40
Inferred type updated to byte in (unumber~) main::vicSelectGfxBank1_toDd001_$1 ← (byte~) main::vicSelectGfxBank1_toDd001_$0 / (byte) $40
Inferred type updated to byte in (unumber~) main::vicSelectGfxBank1_toDd001_$2 ← (byte) 3 ^ (byte~) main::vicSelectGfxBank1_toDd001_$1
Inferred type updated to word in (unumber~) main::toD0181_$0 ← (word~) main::toD0181_$7 & (word) $3fff
Inferred type updated to word in (unumber~) main::toD0181_$1 ← (word~) main::toD0181_$0 * (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$2 ← > (word~) main::toD0181_$1
Inferred type updated to byte in (unumber~) main::toD0181_$4 ← (byte~) main::toD0181_$3 / (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$5 ← (byte~) main::toD0181_$4 & (byte) $f
Inferred type updated to byte in (unumber~) main::toD0181_$6 ← (byte~) main::toD0181_$2 | (byte~) main::toD0181_$5
Inferred type updated to byte in (unumber~) main::$5 ← (byte) main::s#2 * (byte) 2
Inferred type updated to byte in (unumber~) main::$6 ← (byte) main::s#2 - (byte) 3
Inferred type updated to word in (unumber~) main::toSpritePtr1_$0 ← (word~) main::toSpritePtr1_$1 / (byte) $40
Inferred type updated to byte in (unumber~) loop::$1 ← (byte) loop::s#2 * (byte) 2
Inferred type updated to word in (unumber~) __start::__init1_toSpritePtr1_$0 ← (word~) __start::__init1_toSpritePtr1_$1 / (byte) $40
Inferred type updated to byte in (unumber~) __start::__init1_$1 ← (byte~) __start::__init1_$0 + (byte) 3
Alias candidate removed (volatile)sprites_irq::raster_sprite_gfx_modify = sprites_irq::$0 
Alias candidate removed (volatile)sprites_irq::toSpritePtr1_return#0 = sprites_irq::toSpritePtr1_return#2 sprites_irq::toSpritePtr1_return#1 sprites_irq::toSpritePtr1_return#3 sprites_irq::$5 irq_sprite_ptr __start::__init1_$1 
Alias sprites_init::s2#0 = sprites_init::$0 
Alias sprites_init::xpos#1 = sprites_init::$1 
Alias sprites_irq::ptr#0 = sprites_irq::ptr#5 sprites_irq::ptr#6 
Alias sprites_irq::toSpritePtr1_sprite#0 = sprites_irq::toSpritePtr1_sprite#1 
Alias main::vicSelectGfxBank1_gfx#0 = main::vicSelectGfxBank1_gfx#1 main::vicSelectGfxBank1_toDd001_gfx#0 main::vicSelectGfxBank1_toDd001_gfx#1 
Alias sin_idx#25 = sin_idx#33 sin_idx#34 sin_idx#32 sin_idx#31 sin_idx#30 sin_idx#29 sin_idx#28 sin_idx#27 sin_idx#26 
Alias main::vicSelectGfxBank1_toDd001_return#0 = main::vicSelectGfxBank1_toDd001_$2 main::vicSelectGfxBank1_toDd001_return#2 main::vicSelectGfxBank1_toDd001_return#1 main::vicSelectGfxBank1_toDd001_return#3 main::vicSelectGfxBank1_$0 
Alias main::toD0181_screen#0 = main::toD0181_screen#1 
Alias main::toD0181_gfx#0 = main::toD0181_gfx#1 
Alias main::toD0181_return#0 = main::toD0181_$6 main::toD0181_return#2 main::toD0181_return#1 main::toD0181_return#3 main::$1 
Alias main::s2#0 = main::$5 
Alias main::toSpritePtr1_sprite#0 = main::toSpritePtr1_sprite#1 
Alias main::s#2 = main::s#5 main::s#4 main::s#3 
Alias main::xpos#2 = main::xpos#5 main::xpos#4 main::xpos#3 
Alias main::ypos#2 = main::ypos#5 main::ypos#4 main::ypos#3 
Alias sin_idx#14 = sin_idx#23 sin_idx#24 sin_idx#22 sin_idx#21 sin_idx#19 
Alias main::toSpritePtr1_return#0 = main::toSpritePtr1_return#2 main::toSpritePtr1_return#1 main::toSpritePtr1_return#3 main::$7 
Alias sin_idx#0 = sin_idx#7 sin_idx#8 sin_idx#1 
Alias sin_idx#15 = sin_idx#9 
Alias sin_idx#10 = sin_idx#16 
Alias sin_idx#11 = sin_idx#17 sin_idx#3 
Alias __start::__init1_toSpritePtr1_sprite#0 = __start::__init1_toSpritePtr1_sprite#1 
Alias __start::__init1_toSpritePtr1_return#0 = __start::__init1_toSpritePtr1_return#2 __start::__init1_toSpritePtr1_return#1 __start::__init1_toSpritePtr1_return#3 __start::__init1_$0 
Alias sin_idx#18 = sin_idx#4 
Alias sin_idx#12 = sin_idx#5 sin_idx#13 sin_idx#6 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)sprites_irq::raster_sprite_gfx_modify = sprites_irq::$0 
Alias candidate removed (volatile)sprites_irq::toSpritePtr1_return#0 = sprites_irq::toSpritePtr1_return#2 sprites_irq::toSpritePtr1_return#1 sprites_irq::toSpritePtr1_return#3 sprites_irq::$5 irq_sprite_ptr __start::__init1_$1 
Identical Phi Values (byte) sprites_irq::toSpritePtr1_return#2 (byte) sprites_irq::toSpritePtr1_return#0
Identical Phi Values (byte) sprites_irq::toSpritePtr1_return#3 (byte) sprites_irq::toSpritePtr1_return#1
Identical Phi Values (byte) sin_idx#25 (byte) sin_idx#18
Identical Phi Values (byte) sin_idx#14 (byte) sin_idx#25
Identical Phi Values (byte) sin_idx#0 (byte) sin_idx#11
Identical Phi Values (byte) sin_idx#20 (byte) sin_idx#14
Identical Phi Values (byte) sin_idx#15 (byte) sin_idx#11
Identical Phi Values (byte) sin_idx#10 (byte) sin_idx#15
Identical Phi Values (byte) sin_idx#12 (byte) sin_idx#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) sprites_init::$2 [13] if((byte) sprites_init::s#1!=rangelast(0,3)) goto sprites_init::@1
Simple Condition (bool~) sprites_irq::$4 [36] if(*((const nomodify byte*) RASTER)<(volatile byte) sprites_irq::raster_sprite_gfx_modify) goto sprites_irq::@8
Simple Condition (bool~) sprites_irq::$1 [39] if((volatile byte) render_screen_showing==(byte) 0) goto sprites_irq::@1
Simple Condition (bool~) sprites_irq::$2 [54] if((volatile byte) irq_cnt==(byte) 9) goto sprites_irq::@3
Simple Condition (bool~) sprites_irq::$3 [67] if((volatile byte) irq_cnt==(byte) $a) goto sprites_irq::@4
Simple Condition (bool~) main::$8 [116] if((byte) main::s#1!=rangelast(4,7)) goto main::@1
Simple Condition (bool~) loop::$0 [126] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto loop::@2
Simple Condition (bool~) loop::$2 [135] if((byte) loop::s#1!=rangelast(4,7)) goto loop::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte) sprites_init::xpos#0 = (byte)$18+$f*8
Constant (const byte) sprites_init::s#0 = 0
Constant (const byte*) sprites_irq::toSpritePtr1_sprite#0 = PLAYFIELD_SPRITES
Constant (const byte*) main::vicSelectGfxBank1_gfx#0 = PLAYFIELD_SCREEN_1
Constant (const byte*) main::toD0181_screen#0 = PLAYFIELD_SCREEN_1
Constant (const byte*) main::toD0181_gfx#0 = PLAYFIELD_CHARSET
Constant (const byte) main::xpos#0 = $18
Constant (const byte) main::ypos#0 = $32
Constant (const byte) main::s#0 = 4
Constant (const byte*) main::toSpritePtr1_sprite#0 = SIN_SPRITE
Constant (const byte) loop::s#0 = 4
Constant (const byte*) __start::__init1_toSpritePtr1_sprite#0 = PLAYFIELD_SPRITES
Constant (const byte) sin_idx#18 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const word) sprites_irq::toSpritePtr1_$1 = (word)sprites_irq::toSpritePtr1_sprite#0
Constant (const word) main::toD0181_$7 = (word)main::toD0181_screen#0
Constant (const word) main::toSpritePtr1_$1 = (word)main::toSpritePtr1_sprite#0
Constant (const word) __start::__init1_toSpritePtr1_$1 = (word)__start::__init1_toSpritePtr1_sprite#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)main::vicSelectGfxBank1_gfx#0 in [81] (byte~) main::vicSelectGfxBank1_toDd001_$0 ← > (word)(const byte*) main::vicSelectGfxBank1_gfx#0
Constant value identified (word)main::toD0181_gfx#0 in [91] (byte~) main::toD0181_$3 ← > (word)(const byte*) main::toD0181_gfx#0
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [123] if(true) goto loop::@2
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [11] sprites_init::s#1 ← ++ sprites_init::s#2 to ++
Resolved ranged comparison value [13] if(sprites_init::s#1!=rangelast(0,3)) goto sprites_init::@1 to (number) 4
Resolved ranged next value [114] main::s#1 ← ++ main::s#2 to ++
Resolved ranged comparison value [116] if(main::s#1!=rangelast(4,7)) goto main::@1 to (number) 8
Resolved ranged next value [133] loop::s#1 ← ++ loop::s#2 to ++
Resolved ranged comparison value [135] if(loop::s#1!=rangelast(4,7)) goto loop::@4 to (number) 8
Simplifying expression containing zero SPRITES_YPOS in [29] *((const nomodify byte*) SPRITES_YPOS + (byte) 0) ← (byte) sprites_irq::ypos#0
Simplifying expression containing zero PLAYFIELD_SPRITE_PTRS_1 in [40] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (byte) 0) ← (byte) sprites_irq::ptr#0
Simplifying expression containing zero PLAYFIELD_SPRITE_PTRS_2 in [46] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 + (byte) 0) ← (byte) sprites_irq::ptr#0
Simplifying expression containing zero (byte*)CIA2 in [84] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A) ← (byte) main::vicSelectGfxBank1_toDd001_return#0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block loop::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 4 in if((byte) sprites_init::s#1!=(number) 4) goto sprites_init::@1
Adding number conversion cast (unumber) 8 in if((byte) main::s#1!=(number) 8) goto main::@1
Adding number conversion cast (unumber) 8 in if((byte) loop::s#1!=(number) 8) goto loop::@4
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const nomodify byte) SPRITES_FIRST_YPOS+(byte) $13
Simplifying constant integer cast 4
Simplifying constant integer cast 8
Simplifying constant integer cast 8
Simplifying constant integer cast (const nomodify byte) SPRITES_FIRST_YPOS+(byte) $15
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)sprites_irq::raster_sprite_gfx_modify = sprites_irq::$0 
Alias candidate removed (volatile)sprites_irq::toSpritePtr1_return#0 = sprites_irq::toSpritePtr1_return#1 sprites_irq::$5 irq_sprite_ptr __start::__init1_$1 
Constant right-side identified [51] (word~) sprites_irq::toSpritePtr1_$0 ← (const word) sprites_irq::toSpritePtr1_$1 / (byte) $40
Constant right-side identified [68] (byte~) main::vicSelectGfxBank1_toDd001_$0 ← > (word)(const byte*) main::vicSelectGfxBank1_gfx#0
Constant right-side identified [72] (word~) main::toD0181_$0 ← (const word) main::toD0181_$7 & (word) $3fff
Constant right-side identified [75] (byte~) main::toD0181_$3 ← > (word)(const byte*) main::toD0181_gfx#0
Constant right-side identified [88] (word~) main::toSpritePtr1_$0 ← (const word) main::toSpritePtr1_$1 / (byte) $40
Constant right-side identified [111] (word~) __start::__init1_toSpritePtr1_$0 ← (const word) __start::__init1_toSpritePtr1_$1 / (byte) $40
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) sprites_irq::toSpritePtr1_$0 = sprites_irq::toSpritePtr1_$1/$40
Constant (const byte) main::vicSelectGfxBank1_toDd001_$0 = >(word)main::vicSelectGfxBank1_gfx#0
Constant (const word) main::toD0181_$0 = main::toD0181_$7&$3fff
Constant (const byte) main::toD0181_$3 = >(word)main::toD0181_gfx#0
Constant (const word) main::toSpritePtr1_$0 = main::toSpritePtr1_$1/$40
Constant (const word) __start::__init1_toSpritePtr1_$0 = __start::__init1_toSpritePtr1_$1/$40
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) sprites_irq::toSpritePtr1_return#0 = (byte)sprites_irq::toSpritePtr1_$0
Constant (const byte) main::toSpritePtr1_return#0 = (byte)main::toSpritePtr1_$0
Constant (const byte) __start::__init1_toSpritePtr1_return#0 = (byte)__start::__init1_toSpritePtr1_$0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) sprites_irq::toSpritePtr1_return#1 = sprites_irq::toSpritePtr1_return#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) sprites_irq::$5 = sprites_irq::toSpritePtr1_return#1
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)sprites_irq::raster_sprite_gfx_modify = sprites_irq::$0 
Alias candidate removed (volatile)irq_sprite_ptr = __start::__init1_$1 
Constant right-side identified [64] (byte~) main::vicSelectGfxBank1_toDd001_$1 ← (const byte) main::vicSelectGfxBank1_toDd001_$0 / (byte) $40
Constant right-side identified [67] (word~) main::toD0181_$1 ← (const word) main::toD0181_$0 * (byte) 4
Constant right-side identified [69] (byte~) main::toD0181_$4 ← (const byte) main::toD0181_$3 / (byte) 4
Constant right-side identified [102] (byte~) __start::__init1_$1 ← (const byte) __start::__init1_toSpritePtr1_return#0 + (byte) 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::vicSelectGfxBank1_toDd001_$1 = main::vicSelectGfxBank1_toDd001_$0/$40
Constant (const word) main::toD0181_$1 = main::toD0181_$0*4
Constant (const byte) main::toD0181_$4 = main::toD0181_$3/4
Constant (const byte) __start::__init1_$1 = __start::__init1_toSpritePtr1_return#0+3
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero (const byte) main::vicSelectGfxBank1_toDd001_$0/(byte) $40 in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero 3 in [65] (byte) main::vicSelectGfxBank1_toDd001_return#0 ← (byte) 3 ^ (const byte) main::vicSelectGfxBank1_toDd001_$1
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) main::vicSelectGfxBank1_toDd001_$0
Eliminating unused constant (const byte) main::vicSelectGfxBank1_toDd001_$1
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte*) main::vicSelectGfxBank1_gfx#0
Successful SSA optimization PassNEliminateUnusedVars
Alias candidate removed (volatile)sprites_irq::raster_sprite_gfx_modify = sprites_irq::$0 
Constant right-side identified [66] (byte~) main::toD0181_$2 ← > (const word) main::toD0181_$1
Constant right-side identified [67] (byte~) main::toD0181_$5 ← (const byte) main::toD0181_$4 & (byte) $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::vicSelectGfxBank1_toDd001_return#0 = 3
Constant (const byte) main::toD0181_$2 = >main::toD0181_$1
Constant (const byte) main::toD0181_$5 = main::toD0181_$4&$f
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)sprites_irq::raster_sprite_gfx_modify = sprites_irq::$0 
Constant right-side identified [65] (byte) main::toD0181_return#0 ← (const byte) main::toD0181_$2 | (const byte) main::toD0181_$5
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::toD0181_return#0 = main::toD0181_$2|main::toD0181_$5
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)sprites_irq::raster_sprite_gfx_modify = sprites_irq::$0 
Rewriting multiplication to use shift [5] (byte) sprites_init::s2#0 ← (byte) sprites_init::s#2 * (byte) 2
Rewriting multiplication to use shift [69] (byte) main::s2#0 ← (byte) main::s#2 * (byte) 2
Rewriting multiplication to use shift [86] (byte~) loop::$1 ← (byte) loop::s#2 * (byte) 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) sprites_init::xpos#0
Inlining constant with var siblings (const byte) sprites_init::s#0
Inlining constant with different constant siblings (const byte) sprites_irq::toSpritePtr1_return#1
Inlining constant with var siblings (const byte) main::xpos#0
Inlining constant with var siblings (const byte) main::ypos#0
Inlining constant with var siblings (const byte) main::s#0
Inlining constant with var siblings (const byte) loop::s#0
Inlining constant with var siblings (const byte) sin_idx#18
Constant inlined main::toD0181_screen#0 = (const nomodify byte*) PLAYFIELD_SCREEN_1
Constant inlined main::toD0181_gfx#0 = (const byte*) PLAYFIELD_CHARSET
Constant inlined main::toSpritePtr1_$0 = (word)(const byte*) SIN_SPRITE/(byte) $40
Constant inlined sprites_irq::toSpritePtr1_sprite#0 = (const byte*) PLAYFIELD_SPRITES
Constant inlined sprites_irq::$5 = (const byte) sprites_irq::toSpritePtr1_return#0
Constant inlined sprites_init::xpos#0 = (byte)(number) $18+(number) $f*(number) 8
Constant inlined sin_idx#18 = (byte) 0
Constant inlined main::toSpritePtr1_$1 = (word)(const byte*) SIN_SPRITE
Constant inlined __start::__init1_toSpritePtr1_sprite#0 = (const byte*) PLAYFIELD_SPRITES
Constant inlined sprites_irq::toSpritePtr1_return#1 = (const byte) sprites_irq::toSpritePtr1_return#0
Constant inlined main::toSpritePtr1_sprite#0 = (const byte*) SIN_SPRITE
Constant inlined sprites_init::s#0 = (byte) 0
Constant inlined main::xpos#0 = (byte) $18
Constant inlined main::s#0 = (byte) 4
Constant inlined main::toD0181_$7 = (word)(const nomodify byte*) PLAYFIELD_SCREEN_1
Constant inlined __start::__init1_toSpritePtr1_$0 = (word)(const byte*) PLAYFIELD_SPRITES/(byte) $40
Constant inlined __start::__init1_toSpritePtr1_$1 = (word)(const byte*) PLAYFIELD_SPRITES
Constant inlined main::toD0181_$2 = >(word)(const nomodify byte*) PLAYFIELD_SCREEN_1&(word) $3fff*(byte) 4
Constant inlined sprites_irq::toSpritePtr1_$1 = (word)(const byte*) PLAYFIELD_SPRITES
Constant inlined main::toD0181_$1 = (word)(const nomodify byte*) PLAYFIELD_SCREEN_1&(word) $3fff*(byte) 4
Constant inlined sprites_irq::toSpritePtr1_$0 = (word)(const byte*) PLAYFIELD_SPRITES/(byte) $40
Constant inlined main::toD0181_$0 = (word)(const nomodify byte*) PLAYFIELD_SCREEN_1&(word) $3fff
Constant inlined main::toD0181_$5 = >(word)(const byte*) PLAYFIELD_CHARSET/(byte) 4&(byte) $f
Constant inlined main::toD0181_$4 = >(word)(const byte*) PLAYFIELD_CHARSET/(byte) 4
Constant inlined main::toD0181_$3 = >(word)(const byte*) PLAYFIELD_CHARSET
Constant inlined main::ypos#0 = (byte) $32
Constant inlined __start::__init1_$1 = (const byte) __start::__init1_toSpritePtr1_return#0+(byte) 3
Constant inlined loop::s#0 = (byte) 4
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(SPRITES_YPOS+2)
Consolidated array index constant in *(SPRITES_YPOS+4)
Consolidated array index constant in *(SPRITES_YPOS+6)
Consolidated array index constant in *(PLAYFIELD_SPRITE_PTRS_1+1)
Consolidated array index constant in *(PLAYFIELD_SPRITE_PTRS_1+2)
Consolidated array index constant in *(PLAYFIELD_SPRITE_PTRS_1+3)
Consolidated array index constant in *(PLAYFIELD_SPRITE_PTRS_2+1)
Consolidated array index constant in *(PLAYFIELD_SPRITE_PTRS_2+2)
Consolidated array index constant in *(PLAYFIELD_SPRITE_PTRS_2+3)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias candidate removed (volatile)sprites_irq::raster_sprite_gfx_modify = sprites_irq::$0 
Alias candidate removed (volatile)sprites_irq::raster_sprite_gfx_modify = sprites_irq::$0 
Added new block during phi lifting sprites_init::@2(between sprites_init::@1 and sprites_init::@1)
Added new block during phi lifting main::@9(between main::@5 and main::@1)
Added new block during phi lifting loop::@6(between loop::@4 and loop::@4)
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::__init1_toSpritePtr1
Adding NOP phi() at start of __start::__init1_toSpritePtr1_@return
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of __start::@2
Adding NOP phi() at start of sprites_irq::toSpritePtr1
Adding NOP phi() at start of sprites_irq::toSpritePtr1_@return
Adding NOP phi() at start of main
Adding NOP phi() at start of main::vicSelectGfxBank1_toDd001
Adding NOP phi() at start of main::vicSelectGfxBank1_toDd001_@return
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0181_@return
Adding NOP phi() at start of main::toSpritePtr1
Adding NOP phi() at start of main::toSpritePtr1_@return
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of loop
CALL GRAPH
Calls in [__start] to main:9 
Calls in [main] to sprites_init:62 sprites_irq_init:78 loop:80 

Created 8 initial phi equivalence classes
Coalesced [83] main::s#6 ← main::s#1
Coalesced [84] main::xpos#6 ← main::xpos#1
Coalesced [85] main::ypos#6 ← main::ypos#1
Coalesced [98] sprites_init::s#3 ← sprites_init::s#1
Coalesced [99] sprites_init::xpos#3 ← sprites_init::xpos#1
Coalesced [116] loop::idx#3 ← loop::idx#0
Coalesced [124] sin_idx#35 ← sin_idx#2
Coalesced [125] loop::s#3 ← loop::s#1
Coalesced [126] loop::idx#4 ← loop::idx#1
Coalesced down to 8 phi equivalence classes
Culled Empty Block (label) __start::__init1_toSpritePtr1_@return
Culled Empty Block (label) __start::@2
Culled Empty Block (label) sprites_irq::toSpritePtr1_@return
Culled Empty Block (label) main::vicSelectGfxBank1_toDd001_@return
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::toD0181_@return
Culled Empty Block (label) main::toSpritePtr1_@return
Culled Empty Block (label) main::@8
Culled Empty Block (label) main::@9
Culled Empty Block (label) sprites_init::@2
Culled Empty Block (label) loop::@6
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block main::@6 to main::@5
Renumbering block main::@7 to main::@6
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::__init1_toSpritePtr1
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of sprites_irq::toSpritePtr1
Adding NOP phi() at start of main
Adding NOP phi() at start of main::vicSelectGfxBank1_toDd001
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toSpritePtr1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of loop

FINAL CONTROL FLOW GRAPH

(void()) __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] (volatile byte) render_screen_showing ← (byte) 0
  [2] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST
  [3] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS+(byte) $15
  to:__start::__init1_toSpritePtr1
__start::__init1_toSpritePtr1: scope:[__start]  from __start::__init1
  [4] phi()
  to:__start::__init1_@1
__start::__init1_@1: scope:[__start]  from __start::__init1_toSpritePtr1
  [5] (volatile byte) irq_sprite_ptr ← (const byte) __start::__init1_toSpritePtr1_return#0+(byte) 3
  [6] (volatile byte) irq_cnt ← (byte) 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1_@1
  [7] phi()
  [8] call main 
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [9] return 
  to:@return

interrupt(HARDWARE_CLOBBER)(void()) sprites_irq()
sprites_irq: scope:[sprites_irq]  from
  asm { cld  }
  [11] (byte) sprites_irq::ypos#0 ← (volatile byte) irq_sprite_ypos
  [12] *((const nomodify byte*) SPRITES_YPOS) ← (byte) sprites_irq::ypos#0
  [13] *((const nomodify byte*) SPRITES_YPOS+(byte) 2) ← (byte) sprites_irq::ypos#0
  [14] *((const nomodify byte*) SPRITES_YPOS+(byte) 4) ← (byte) sprites_irq::ypos#0
  [15] *((const nomodify byte*) SPRITES_YPOS+(byte) 6) ← (byte) sprites_irq::ypos#0
  [16] (byte~) sprites_irq::$0 ← (volatile byte) irq_raster_next + (byte) 1
  [17] (volatile byte) sprites_irq::raster_sprite_gfx_modify ← (byte~) sprites_irq::$0
  to:sprites_irq::@8
sprites_irq::@8: scope:[sprites_irq]  from sprites_irq sprites_irq::@8
  [18] if(*((const nomodify byte*) RASTER)<(volatile byte) sprites_irq::raster_sprite_gfx_modify) goto sprites_irq::@8
  to:sprites_irq::@9
sprites_irq::@9: scope:[sprites_irq]  from sprites_irq::@8
  [19] (byte) sprites_irq::ptr#0 ← (volatile byte) irq_sprite_ptr
  [20] if((volatile byte) render_screen_showing==(byte) 0) goto sprites_irq::@1
  to:sprites_irq::@10
sprites_irq::@10: scope:[sprites_irq]  from sprites_irq::@9
  [21] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2) ← (byte) sprites_irq::ptr#0
  [22] (byte) sprites_irq::ptr#3 ← ++ (byte) sprites_irq::ptr#0
  [23] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 1) ← (byte) sprites_irq::ptr#3
  [24] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 2) ← (byte) sprites_irq::ptr#3
  [25] (byte) sprites_irq::ptr#4 ← ++ (byte) sprites_irq::ptr#3
  [26] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 3) ← (byte) sprites_irq::ptr#4
  to:sprites_irq::@2
sprites_irq::@2: scope:[sprites_irq]  from sprites_irq::@1 sprites_irq::@10
  [27] (volatile byte) irq_cnt ← ++ (volatile byte) irq_cnt
  [28] if((volatile byte) irq_cnt==(byte) 9) goto sprites_irq::@3
  to:sprites_irq::@6
sprites_irq::@6: scope:[sprites_irq]  from sprites_irq::@2
  [29] if((volatile byte) irq_cnt==(byte) $a) goto sprites_irq::@4
  to:sprites_irq::@7
sprites_irq::@7: scope:[sprites_irq]  from sprites_irq::@6
  [30] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $14
  [31] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15
  [32] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3
  to:sprites_irq::@5
sprites_irq::@5: scope:[sprites_irq]  from sprites_irq::@11 sprites_irq::@4 sprites_irq::@7
  [33] *((const nomodify byte*) RASTER) ← (volatile byte) irq_raster_next
  [34] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  to:sprites_irq::@return
sprites_irq::@return: scope:[sprites_irq]  from sprites_irq::@5
  [35] return 
  to:@return
sprites_irq::@4: scope:[sprites_irq]  from sprites_irq::@6
  [36] (volatile byte) irq_cnt ← (byte) 0
  [37] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST
  [38] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15
  [39] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3
  to:sprites_irq::@5
sprites_irq::@3: scope:[sprites_irq]  from sprites_irq::@2
  [40] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $15
  [41] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS
  to:sprites_irq::toSpritePtr1
sprites_irq::toSpritePtr1: scope:[sprites_irq]  from sprites_irq::@3
  [42] phi()
  to:sprites_irq::@11
sprites_irq::@11: scope:[sprites_irq]  from sprites_irq::toSpritePtr1
  [43] (volatile byte) irq_sprite_ptr ← (const byte) sprites_irq::toSpritePtr1_return#0
  to:sprites_irq::@5
sprites_irq::@1: scope:[sprites_irq]  from sprites_irq::@9
  [44] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1) ← (byte) sprites_irq::ptr#0
  [45] (byte) sprites_irq::ptr#1 ← ++ (byte) sprites_irq::ptr#0
  [46] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 1) ← (byte) sprites_irq::ptr#1
  [47] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 2) ← (byte) sprites_irq::ptr#1
  [48] (byte) sprites_irq::ptr#2 ← ++ (byte) sprites_irq::ptr#1
  [49] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 3) ← (byte) sprites_irq::ptr#2
  to:sprites_irq::@2

(void()) main()
main: scope:[main]  from __start::@1
  [50] phi()
  to:main::vicSelectGfxBank1
main::vicSelectGfxBank1: scope:[main]  from main
  [51] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) 3
  to:main::vicSelectGfxBank1_toDd001
main::vicSelectGfxBank1_toDd001: scope:[main]  from main::vicSelectGfxBank1
  [52] phi()
  to:main::vicSelectGfxBank1_@1
main::vicSelectGfxBank1_@1: scope:[main]  from main::vicSelectGfxBank1_toDd001
  [53] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0
  to:main::toD0181
main::toD0181: scope:[main]  from main::vicSelectGfxBank1_@1
  [54] phi()
  to:main::@3
main::@3: scope:[main]  from main::toD0181
  [55] *((const nomodify byte*) D018) ← (const byte) main::toD0181_return#0
  [56] call sprites_init 
  to:main::@5
main::@5: scope:[main]  from main::@3
  [57] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $ff
  to:main::@1
main::@1: scope:[main]  from main::@4 main::@5
  [58] (byte) main::ypos#2 ← phi( main::@4/(byte) main::ypos#1 main::@5/(byte) $32 )
  [58] (byte) main::xpos#2 ← phi( main::@4/(byte) main::xpos#1 main::@5/(byte) $18 )
  [58] (byte) main::s#2 ← phi( main::@4/(byte) main::s#1 main::@5/(byte) 4 )
  [59] (byte) main::s2#0 ← (byte) main::s#2 << (byte) 1
  [60] *((const nomodify byte*) SPRITES_XPOS + (byte) main::s2#0) ← (byte) main::xpos#2
  [61] *((const nomodify byte*) SPRITES_YPOS + (byte) main::s2#0) ← (byte) main::ypos#2
  [62] (byte~) main::$6 ← (byte) main::s#2 - (byte) 3
  [63] *((const nomodify byte*) SPRITES_COLOR + (byte) main::s#2) ← (byte~) main::$6
  to:main::toSpritePtr1
main::toSpritePtr1: scope:[main]  from main::@1
  [64] phi()
  to:main::@4
main::@4: scope:[main]  from main::toSpritePtr1
  [65] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (byte) main::s#2) ← (const byte) main::toSpritePtr1_return#0
  [66] (byte) main::xpos#1 ← (byte) main::xpos#2 + (byte) $18
  [67] (byte) main::ypos#1 ← (byte) main::ypos#2 + (byte) $18
  [68] (byte) main::s#1 ← ++ (byte) main::s#2
  [69] if((byte) main::s#1!=(byte) 8) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@4
  [70] phi()
  [71] call sprites_irq_init 
  to:main::@6
main::@6: scope:[main]  from main::@2
  [72] phi()
  [73] call loop 
  to:main::@return
main::@return: scope:[main]  from main::@6
  [74] return 
  to:@return

(void()) sprites_init()
sprites_init: scope:[sprites_init]  from main::@3
  [75] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $f
  [76] *((const nomodify byte*) SPRITES_MC) ← (byte) 0
  [77] *((const nomodify byte*) SPRITES_EXPAND_Y) ← *((const nomodify byte*) SPRITES_MC)
  [78] *((const nomodify byte*) SPRITES_EXPAND_X) ← *((const nomodify byte*) SPRITES_EXPAND_Y)
  to:sprites_init::@1
sprites_init::@1: scope:[sprites_init]  from sprites_init sprites_init::@1
  [79] (byte) sprites_init::xpos#2 ← phi( sprites_init/(byte)(number) $18+(number) $f*(number) 8 sprites_init::@1/(byte) sprites_init::xpos#1 )
  [79] (byte) sprites_init::s#2 ← phi( sprites_init/(byte) 0 sprites_init::@1/(byte) sprites_init::s#1 )
  [80] (byte) sprites_init::s2#0 ← (byte) sprites_init::s#2 << (byte) 1
  [81] *((const nomodify byte*) SPRITES_XPOS + (byte) sprites_init::s2#0) ← (byte) sprites_init::xpos#2
  [82] *((const nomodify byte*) SPRITES_COLOR + (byte) sprites_init::s#2) ← (const nomodify byte) BLACK
  [83] (byte) sprites_init::xpos#1 ← (byte) sprites_init::xpos#2 + (byte) $18
  [84] (byte) sprites_init::s#1 ← ++ (byte) sprites_init::s#2
  [85] if((byte) sprites_init::s#1!=(byte) 4) goto sprites_init::@1
  to:sprites_init::@return
sprites_init::@return: scope:[sprites_init]  from sprites_init::@1
  [86] return 
  to:@return

(void()) sprites_irq_init()
sprites_irq_init: scope:[sprites_irq_init]  from main::@2
  asm { sei  }
  [88] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  asm { ldaCIA1_INTERRUPT  }
  [90] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK
  [91] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO
  [92] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR
  [93] *((const nomodify byte*) VIC_CONTROL) ← *((const nomodify byte*) VIC_CONTROL) & (byte) $7f
  [94] *((const nomodify byte*) RASTER) ← (const nomodify byte) IRQ_RASTER_FIRST
  [95] *((const nomodify byte*) IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER
  [96] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_CLOBBER)(void()) sprites_irq()
  asm { cli  }
  to:sprites_irq_init::@return
sprites_irq_init::@return: scope:[sprites_irq_init]  from sprites_irq_init
  [98] return 
  to:@return

(void()) loop()
loop: scope:[loop]  from main::@6
  [99] phi()
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@5
  [100] (byte) sin_idx#11 ← phi( loop/(byte) 0 loop::@5/(byte) sin_idx#2 )
  to:loop::@2
loop::@2: scope:[loop]  from loop::@1 loop::@2
  [101] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto loop::@2
  to:loop::@3
loop::@3: scope:[loop]  from loop::@2
  [102] (byte) loop::idx#0 ← (byte) sin_idx#11
  to:loop::@4
loop::@4: scope:[loop]  from loop::@3 loop::@4
  [103] (byte) loop::idx#2 ← phi( loop::@3/(byte) loop::idx#0 loop::@4/(byte) loop::idx#1 )
  [103] (byte) loop::s#2 ← phi( loop::@3/(byte) 4 loop::@4/(byte) loop::s#1 )
  [104] (byte~) loop::$1 ← (byte) loop::s#2 << (byte) 1
  [105] *((const nomodify byte*) SPRITES_YPOS + (byte~) loop::$1) ← *((const byte*) SIN + (byte) loop::idx#2)
  [106] (byte) loop::idx#1 ← (byte) loop::idx#2 + (byte) $a
  [107] (byte) loop::s#1 ← ++ (byte) loop::s#2
  [108] if((byte) loop::s#1!=(byte) 8) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  [109] (byte) sin_idx#2 ← ++ (byte) sin_idx#11
  to:loop::@1


VARIABLE REGISTER WEIGHTS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(void()) __start()
(byte) __start::__init1_toSpritePtr1_return
(byte*) __start::__init1_toSpritePtr1_sprite
(volatile byte) irq_cnt loadstore 0.48000000000000004
(volatile byte) irq_raster_next loadstore 0.44444444444444453
(volatile byte) irq_sprite_ptr loadstore 0.45161290322580644
(volatile byte) irq_sprite_ypos loadstore 0.48275862068965525
(void()) loop()
(byte~) loop::$1 20002.0
(byte) loop::idx
(byte) loop::idx#0 2002.0
(byte) loop::idx#1 6667.333333333333
(byte) loop::idx#2 10334.666666666666
(byte) loop::s
(byte) loop::s#1 15001.5
(byte) loop::s#2 7500.75
(void()) main()
(byte~) main::$6 202.0
(byte) main::s
(byte) main::s#1 151.5
(byte) main::s#2 60.6
(byte) main::s2
(byte) main::s2#0 151.5
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(byte*) main::toD0181_screen
(byte) main::toSpritePtr1_return
(byte*) main::toSpritePtr1_sprite
(byte*) main::vicSelectGfxBank1_gfx
(byte*) main::vicSelectGfxBank1_toDd001_gfx
(byte) main::vicSelectGfxBank1_toDd001_return
(byte) main::xpos
(byte) main::xpos#1 50.5
(byte) main::xpos#2 37.875
(byte) main::ypos
(byte) main::ypos#1 67.33333333333333
(byte) main::ypos#2 33.666666666666664
(volatile byte) render_screen_showing loadstore 0.4
(byte) sin_idx
(byte) sin_idx#11 333.6666666666667
(byte) sin_idx#2 2002.0
(void()) sprites_init()
(byte) sprites_init::s
(byte) sprites_init::s#1 1501.5
(byte) sprites_init::s#2 800.8
(byte) sprites_init::s2
(byte) sprites_init::s2#0 2002.0
(byte) sprites_init::xpos
(byte) sprites_init::xpos#1 667.3333333333334
(byte) sprites_init::xpos#2 750.75
interrupt(HARDWARE_CLOBBER)(void()) sprites_irq()
(byte~) sprites_irq::$0 4.0
(byte) sprites_irq::ptr
(byte) sprites_irq::ptr#0 2.5
(byte) sprites_irq::ptr#1 2.6666666666666665
(byte) sprites_irq::ptr#2 4.0
(byte) sprites_irq::ptr#3 2.6666666666666665
(byte) sprites_irq::ptr#4 4.0
(volatile byte) sprites_irq::raster_sprite_gfx_modify loadstore 6.5
(byte) sprites_irq::toSpritePtr1_return
(byte*) sprites_irq::toSpritePtr1_sprite
(byte) sprites_irq::ypos
(byte) sprites_irq::ypos#0 2.5
(void()) sprites_irq_init()

Initial phi equivalence classes
[ main::s#2 main::s#1 ]
[ main::xpos#2 main::xpos#1 ]
[ main::ypos#2 main::ypos#1 ]
[ sprites_init::s#2 sprites_init::s#1 ]
[ sprites_init::xpos#2 sprites_init::xpos#1 ]
[ sin_idx#11 sin_idx#2 ]
[ loop::s#2 loop::s#1 ]
[ loop::idx#2 loop::idx#0 loop::idx#1 ]
Added variable render_screen_showing to live range equivalence class [ render_screen_showing ]
Added variable irq_raster_next to live range equivalence class [ irq_raster_next ]
Added variable irq_sprite_ypos to live range equivalence class [ irq_sprite_ypos ]
Added variable irq_sprite_ptr to live range equivalence class [ irq_sprite_ptr ]
Added variable irq_cnt to live range equivalence class [ irq_cnt ]
Added variable sprites_irq::ypos#0 to live range equivalence class [ sprites_irq::ypos#0 ]
Added variable sprites_irq::$0 to live range equivalence class [ sprites_irq::$0 ]
Added variable sprites_irq::raster_sprite_gfx_modify to live range equivalence class [ sprites_irq::raster_sprite_gfx_modify ]
Added variable sprites_irq::ptr#0 to live range equivalence class [ sprites_irq::ptr#0 ]
Added variable sprites_irq::ptr#3 to live range equivalence class [ sprites_irq::ptr#3 ]
Added variable sprites_irq::ptr#4 to live range equivalence class [ sprites_irq::ptr#4 ]
Added variable sprites_irq::ptr#1 to live range equivalence class [ sprites_irq::ptr#1 ]
Added variable sprites_irq::ptr#2 to live range equivalence class [ sprites_irq::ptr#2 ]
Added variable main::s2#0 to live range equivalence class [ main::s2#0 ]
Added variable main::$6 to live range equivalence class [ main::$6 ]
Added variable sprites_init::s2#0 to live range equivalence class [ sprites_init::s2#0 ]
Added variable loop::$1 to live range equivalence class [ loop::$1 ]
Complete equivalence classes
[ main::s#2 main::s#1 ]
[ main::xpos#2 main::xpos#1 ]
[ main::ypos#2 main::ypos#1 ]
[ sprites_init::s#2 sprites_init::s#1 ]
[ sprites_init::xpos#2 sprites_init::xpos#1 ]
[ sin_idx#11 sin_idx#2 ]
[ loop::s#2 loop::s#1 ]
[ loop::idx#2 loop::idx#0 loop::idx#1 ]
[ render_screen_showing ]
[ irq_raster_next ]
[ irq_sprite_ypos ]
[ irq_sprite_ptr ]
[ irq_cnt ]
[ sprites_irq::ypos#0 ]
[ sprites_irq::$0 ]
[ sprites_irq::raster_sprite_gfx_modify ]
[ sprites_irq::ptr#0 ]
[ sprites_irq::ptr#3 ]
[ sprites_irq::ptr#4 ]
[ sprites_irq::ptr#1 ]
[ sprites_irq::ptr#2 ]
[ main::s2#0 ]
[ main::$6 ]
[ sprites_init::s2#0 ]
[ loop::$1 ]
Allocated zp[1]:2 [ main::s#2 main::s#1 ]
Allocated zp[1]:3 [ main::xpos#2 main::xpos#1 ]
Allocated zp[1]:4 [ main::ypos#2 main::ypos#1 ]
Allocated zp[1]:5 [ sprites_init::s#2 sprites_init::s#1 ]
Allocated zp[1]:6 [ sprites_init::xpos#2 sprites_init::xpos#1 ]
Allocated zp[1]:7 [ sin_idx#11 sin_idx#2 ]
Allocated zp[1]:8 [ loop::s#2 loop::s#1 ]
Allocated zp[1]:9 [ loop::idx#2 loop::idx#0 loop::idx#1 ]
Allocated zp[1]:10 [ render_screen_showing ]
Allocated zp[1]:11 [ irq_raster_next ]
Allocated zp[1]:12 [ irq_sprite_ypos ]
Allocated zp[1]:13 [ irq_sprite_ptr ]
Allocated zp[1]:14 [ irq_cnt ]
Allocated zp[1]:15 [ sprites_irq::ypos#0 ]
Allocated zp[1]:16 [ sprites_irq::$0 ]
Allocated zp[1]:17 [ sprites_irq::raster_sprite_gfx_modify ]
Allocated zp[1]:18 [ sprites_irq::ptr#0 ]
Allocated zp[1]:19 [ sprites_irq::ptr#3 ]
Allocated zp[1]:20 [ sprites_irq::ptr#4 ]
Allocated zp[1]:21 [ sprites_irq::ptr#1 ]
Allocated zp[1]:22 [ sprites_irq::ptr#2 ]
Allocated zp[1]:23 [ main::s2#0 ]
Allocated zp[1]:24 [ main::$6 ]
Allocated zp[1]:25 [ sprites_init::s2#0 ]
Allocated zp[1]:26 [ loop::$1 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Tetris Game for the Commodore 64
// A sprite multiplexer covering the playfield with a black layer to allow for 3 single-pixel colors
// Commodore 64 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__start)
.pc = $80d "Program"
  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The offset of the sprite pointers from the screen start address
  .const SPRITE_PTRS = $3f8
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  // The colors of the C64
  .const BLACK = 0
  // The Y-position of the first sprite row
  .const SPRITES_FIRST_YPOS = $31
  // The line of the first IRQ
  .const IRQ_RASTER_FIRST = SPRITES_FIRST_YPOS+$13
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = 2
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_COLOR = $d027
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label RASTER = $d012
  .label VIC_CONTROL = $d011
  .label D018 = $d018
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#1 Interrupt for reading in ASM
  .label CIA1_INTERRUPT = $dc0d
  // The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Address of the first screen
  .label PLAYFIELD_SCREEN_1 = $400
  // Address of the second screen
  .label PLAYFIELD_SCREEN_2 = $2c00
  // Screen Sprite pointers on screen 1
  .label PLAYFIELD_SPRITE_PTRS_1 = PLAYFIELD_SCREEN_1+SPRITE_PTRS
  // Screen Sprite pointers on screen 2
  .label PLAYFIELD_SPRITE_PTRS_2 = PLAYFIELD_SCREEN_2+SPRITE_PTRS
  // The screen currently being showed to the user. 0x00 for screen 1 / 0x20 for screen 2.
  .label render_screen_showing = $a
  // The raster line of the next IRQ
  .label irq_raster_next = $b
  // Y-pos of the sprites on the next IRQ
  .label irq_sprite_ypos = $c
  // Index of the sprites to show on the next IRQ
  .label irq_sprite_ptr = $d
  // Counting the 10 IRQs
  .label irq_cnt = $e
  .label sin_idx = 7
  // __start
__start: {
    .const __init1_toSpritePtr1_return = $ff&PLAYFIELD_SPRITES/$40
    jmp __init1
    // __start::__init1
  __init1:
    // [1] (volatile byte) render_screen_showing ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z render_screen_showing
    // [2] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST -- vbuz1=vbuc1 
    lda #IRQ_RASTER_FIRST
    sta.z irq_raster_next
    // [3] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS+(byte) $15 -- vbuz1=vbuc1 
    lda #SPRITES_FIRST_YPOS+$15
    sta.z irq_sprite_ypos
    // [4] phi from __start::__init1 to __start::__init1_toSpritePtr1 [phi:__start::__init1->__start::__init1_toSpritePtr1]
  __init1_toSpritePtr1_from___init1:
    jmp __init1_toSpritePtr1
    // __start::__init1_toSpritePtr1
  __init1_toSpritePtr1:
    jmp __init1___b1
    // __start::__init1_@1
  __init1___b1:
    // [5] (volatile byte) irq_sprite_ptr ← (const byte) __start::__init1_toSpritePtr1_return#0+(byte) 3 -- vbuz1=vbuc1 
    lda #__init1_toSpritePtr1_return+3
    sta.z irq_sprite_ptr
    // [6] (volatile byte) irq_cnt ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z irq_cnt
    // [7] phi from __start::__init1_@1 to __start::@1 [phi:__start::__init1_@1->__start::@1]
  __b1_from___init1___b1:
    jmp __b1
    // __start::@1
  __b1:
    // [8] call main 
    // [50] phi from __start::@1 to main [phi:__start::@1->main]
  main_from___b1:
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [9] return 
    rts
}
  // sprites_irq
// Raster Interrupt Routine - sets up the sprites covering the playfield
// Repeats 10 timers every 2 lines from line IRQ_RASTER_FIRST
// Utilizes duplicated gfx in the sprites to allow for some leeway in updating the sprite pointers
sprites_irq: {
    .const toSpritePtr1_return = $ff&PLAYFIELD_SPRITES/$40
    .label raster_sprite_gfx_modify = $11
    .label __0 = $10
    .label ypos = $f
    .label ptr = $12
    .label ptr_1 = $15
    .label ptr_2 = $16
    .label ptr_3 = $13
    .label ptr_4 = $14
    // entry interrupt(HARDWARE_CLOBBER)
    sta rega+1
    stx regx+1
    sty regy+1
    // asm { cld  }
    //(*BG_COLOR)++;
    // Clear decimal flag (because it is used by the score algorithm)
    cld
    // [11] (byte) sprites_irq::ypos#0 ← (volatile byte) irq_sprite_ypos -- vbuz1=vbuz2 
    // Place the sprites
    lda.z irq_sprite_ypos
    sta.z ypos
    // [12] *((const nomodify byte*) SPRITES_YPOS) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuz1 
    lda.z ypos
    sta SPRITES_YPOS
    // [13] *((const nomodify byte*) SPRITES_YPOS+(byte) 2) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuz1 
    lda.z ypos
    sta SPRITES_YPOS+2
    // [14] *((const nomodify byte*) SPRITES_YPOS+(byte) 4) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuz1 
    lda.z ypos
    sta SPRITES_YPOS+4
    // [15] *((const nomodify byte*) SPRITES_YPOS+(byte) 6) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuz1 
    lda.z ypos
    sta SPRITES_YPOS+6
    // [16] (byte~) sprites_irq::$0 ← (volatile byte) irq_raster_next + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy.z irq_raster_next
    iny
    sty.z __0
    // [17] (volatile byte) sprites_irq::raster_sprite_gfx_modify ← (byte~) sprites_irq::$0 -- vbuz1=vbuz2 
    // Wait for the y-position before changing sprite pointers
    lda.z __0
    sta.z raster_sprite_gfx_modify
    jmp __b8
    // sprites_irq::@8
  __b8:
    // [18] if(*((const nomodify byte*) RASTER)<(volatile byte) sprites_irq::raster_sprite_gfx_modify) goto sprites_irq::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z raster_sprite_gfx_modify
    bcc __b8
    jmp __b9
    // sprites_irq::@9
  __b9:
    // [19] (byte) sprites_irq::ptr#0 ← (volatile byte) irq_sprite_ptr -- vbuz1=vbuz2 
    lda.z irq_sprite_ptr
    sta.z ptr
    // [20] if((volatile byte) render_screen_showing==(byte) 0) goto sprites_irq::@1 -- vbuz1_eq_0_then_la1 
    lda.z render_screen_showing
    cmp #0
    beq __b1
    jmp __b10
    // sprites_irq::@10
  __b10:
    // [21] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2) ← (byte) sprites_irq::ptr#0 -- _deref_pbuc1=vbuz1 
    lda.z ptr
    sta PLAYFIELD_SPRITE_PTRS_2
    // [22] (byte) sprites_irq::ptr#3 ← ++ (byte) sprites_irq::ptr#0 -- vbuz1=_inc_vbuz2 
    ldy.z ptr
    iny
    sty.z ptr_3
    // [23] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 1) ← (byte) sprites_irq::ptr#3 -- _deref_pbuc1=vbuz1 
    lda.z ptr_3
    sta PLAYFIELD_SPRITE_PTRS_2+1
    // [24] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 2) ← (byte) sprites_irq::ptr#3 -- _deref_pbuc1=vbuz1 
    lda.z ptr_3
    sta PLAYFIELD_SPRITE_PTRS_2+2
    // [25] (byte) sprites_irq::ptr#4 ← ++ (byte) sprites_irq::ptr#3 -- vbuz1=_inc_vbuz2 
    ldy.z ptr_3
    iny
    sty.z ptr_4
    // [26] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 3) ← (byte) sprites_irq::ptr#4 -- _deref_pbuc1=vbuz1 
    lda.z ptr_4
    sta PLAYFIELD_SPRITE_PTRS_2+3
    jmp __b2
    // sprites_irq::@2
  __b2:
    // [27] (volatile byte) irq_cnt ← ++ (volatile byte) irq_cnt -- vbuz1=_inc_vbuz1 
    inc.z irq_cnt
    // [28] if((volatile byte) irq_cnt==(byte) 9) goto sprites_irq::@3 -- vbuz1_eq_vbuc1_then_la1 
    lda #9
    cmp.z irq_cnt
    beq __b3
    jmp __b6
    // sprites_irq::@6
  __b6:
    // [29] if((volatile byte) irq_cnt==(byte) $a) goto sprites_irq::@4 -- vbuz1_eq_vbuc1_then_la1 
    lda #$a
    cmp.z irq_cnt
    beq __b4
    jmp __b7
    // sprites_irq::@7
  __b7:
    // [30] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $14 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_raster_next
    axs #-[$14]
    stx.z irq_raster_next
    // [31] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ypos
    axs #-[$15]
    stx.z irq_sprite_ypos
    // [32] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ptr
    axs #-[3]
    stx.z irq_sprite_ptr
    jmp __b5
    // sprites_irq::@5
  __b5:
    // [33] *((const nomodify byte*) RASTER) ← (volatile byte) irq_raster_next -- _deref_pbuc1=vbuz1 
    // Setup next interrupt
    lda.z irq_raster_next
    sta RASTER
    // [34] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ and setup the next one
    lda #IRQ_RASTER
    sta IRQ_STATUS
    jmp __breturn
    // sprites_irq::@return
  __breturn:
    // [35] return  - exit interrupt(HARDWARE_CLOBBER)
  rega:
    lda #00
  regx:
    ldx #00
  regy:
    ldy #00
    rti
    // sprites_irq::@4
  __b4:
    // [36] (volatile byte) irq_cnt ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z irq_cnt
    // [37] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST -- vbuz1=vbuc1 
    lda #IRQ_RASTER_FIRST
    sta.z irq_raster_next
    // [38] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ypos
    axs #-[$15]
    stx.z irq_sprite_ypos
    // [39] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ptr
    axs #-[3]
    stx.z irq_sprite_ptr
    jmp __b5
    // sprites_irq::@3
  __b3:
    // [40] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $15 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_raster_next
    axs #-[$15]
    stx.z irq_raster_next
    // [41] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS -- vbuz1=vbuc1 
    lda #SPRITES_FIRST_YPOS
    sta.z irq_sprite_ypos
    // [42] phi from sprites_irq::@3 to sprites_irq::toSpritePtr1 [phi:sprites_irq::@3->sprites_irq::toSpritePtr1]
  toSpritePtr1_from___b3:
    jmp toSpritePtr1
    // sprites_irq::toSpritePtr1
  toSpritePtr1:
    jmp __b11
    // sprites_irq::@11
  __b11:
    // [43] (volatile byte) irq_sprite_ptr ← (const byte) sprites_irq::toSpritePtr1_return#0 -- vbuz1=vbuc1 
    lda #toSpritePtr1_return
    sta.z irq_sprite_ptr
    jmp __b5
    // sprites_irq::@1
  __b1:
    // [44] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1) ← (byte) sprites_irq::ptr#0 -- _deref_pbuc1=vbuz1 
    lda.z ptr
    sta PLAYFIELD_SPRITE_PTRS_1
    // [45] (byte) sprites_irq::ptr#1 ← ++ (byte) sprites_irq::ptr#0 -- vbuz1=_inc_vbuz2 
    ldy.z ptr
    iny
    sty.z ptr_1
    // [46] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 1) ← (byte) sprites_irq::ptr#1 -- _deref_pbuc1=vbuz1 
    lda.z ptr_1
    sta PLAYFIELD_SPRITE_PTRS_1+1
    // [47] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 2) ← (byte) sprites_irq::ptr#1 -- _deref_pbuc1=vbuz1 
    lda.z ptr_1
    sta PLAYFIELD_SPRITE_PTRS_1+2
    // [48] (byte) sprites_irq::ptr#2 ← ++ (byte) sprites_irq::ptr#1 -- vbuz1=_inc_vbuz2 
    ldy.z ptr_1
    iny
    sty.z ptr_2
    // [49] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 3) ← (byte) sprites_irq::ptr#2 -- _deref_pbuc1=vbuz1 
    lda.z ptr_2
    sta PLAYFIELD_SPRITE_PTRS_1+3
    jmp __b2
}
  // main
main: {
    .const toSpritePtr1_return = $ff&SIN_SPRITE/$40
    .const vicSelectGfxBank1_toDd001_return = 3
    .const toD0181_return = (>(PLAYFIELD_SCREEN_1&$3fff)*4)|(>PLAYFIELD_CHARSET)/4&$f
    .label __6 = $18
    .label s2 = $17
    .label xpos = 3
    .label ypos = 4
    .label s = 2
    jmp vicSelectGfxBank1
    // main::vicSelectGfxBank1
  vicSelectGfxBank1:
    // [51] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR
    // [52] phi from main::vicSelectGfxBank1 to main::vicSelectGfxBank1_toDd001 [phi:main::vicSelectGfxBank1->main::vicSelectGfxBank1_toDd001]
  vicSelectGfxBank1_toDd001_from_vicSelectGfxBank1:
    jmp vicSelectGfxBank1_toDd001
    // main::vicSelectGfxBank1_toDd001
  vicSelectGfxBank1_toDd001:
    jmp vicSelectGfxBank1___b1
    // main::vicSelectGfxBank1_@1
  vicSelectGfxBank1___b1:
    // [53] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 -- _deref_pbuc1=vbuc2 
    lda #vicSelectGfxBank1_toDd001_return
    sta CIA2
    // [54] phi from main::vicSelectGfxBank1_@1 to main::toD0181 [phi:main::vicSelectGfxBank1_@1->main::toD0181]
  toD0181_from_vicSelectGfxBank1___b1:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp __b3
    // main::@3
  __b3:
    // [55] *((const nomodify byte*) D018) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // [56] call sprites_init 
    jsr sprites_init
    jmp __b5
    // main::@5
  __b5:
    // [57] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    lda #$ff
    sta SPRITES_ENABLE
    // [58] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  __b1_from___b5:
    // [58] phi (byte) main::ypos#2 = (byte) $32 [phi:main::@5->main::@1#0] -- vbuz1=vbuc1 
    lda #$32
    sta.z ypos
    // [58] phi (byte) main::xpos#2 = (byte) $18 [phi:main::@5->main::@1#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z xpos
    // [58] phi (byte) main::s#2 = (byte) 4 [phi:main::@5->main::@1#2] -- vbuz1=vbuc1 
    lda #4
    sta.z s
    jmp __b1
    // [58] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  __b1_from___b4:
    // [58] phi (byte) main::ypos#2 = (byte) main::ypos#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [58] phi (byte) main::xpos#2 = (byte) main::xpos#1 [phi:main::@4->main::@1#1] -- register_copy 
    // [58] phi (byte) main::s#2 = (byte) main::s#1 [phi:main::@4->main::@1#2] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [59] (byte) main::s2#0 ← (byte) main::s#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z s
    asl
    sta.z s2
    // [60] *((const nomodify byte*) SPRITES_XPOS + (byte) main::s2#0) ← (byte) main::xpos#2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z xpos
    ldy.z s2
    sta SPRITES_XPOS,y
    // [61] *((const nomodify byte*) SPRITES_YPOS + (byte) main::s2#0) ← (byte) main::ypos#2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z ypos
    ldy.z s2
    sta SPRITES_YPOS,y
    // [62] (byte~) main::$6 ← (byte) main::s#2 - (byte) 3 -- vbuz1=vbuz2_minus_vbuc1 
    lax.z s
    axs #3
    stx.z __6
    // [63] *((const nomodify byte*) SPRITES_COLOR + (byte) main::s#2) ← (byte~) main::$6 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z __6
    ldy.z s
    sta SPRITES_COLOR,y
    // [64] phi from main::@1 to main::toSpritePtr1 [phi:main::@1->main::toSpritePtr1]
  toSpritePtr1_from___b1:
    jmp toSpritePtr1
    // main::toSpritePtr1
  toSpritePtr1:
    jmp __b4
    // main::@4
  __b4:
    // [65] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (byte) main::s#2) ← (const byte) main::toSpritePtr1_return#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #toSpritePtr1_return
    ldy.z s
    sta PLAYFIELD_SPRITE_PTRS_1,y
    // [66] (byte) main::xpos#1 ← (byte) main::xpos#2 + (byte) $18 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z xpos
    axs #-[$18]
    stx.z xpos
    // [67] (byte) main::ypos#1 ← (byte) main::ypos#2 + (byte) $18 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z ypos
    axs #-[$18]
    stx.z ypos
    // [68] (byte) main::s#1 ← ++ (byte) main::s#2 -- vbuz1=_inc_vbuz1 
    inc.z s
    // [69] if((byte) main::s#1!=(byte) 8) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z s
    bne __b1_from___b4
    // [70] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  __b2_from___b4:
    jmp __b2
    // main::@2
  __b2:
    // [71] call sprites_irq_init 
    jsr sprites_irq_init
    // [72] phi from main::@2 to main::@6 [phi:main::@2->main::@6]
  __b6_from___b2:
    jmp __b6
    // main::@6
  __b6:
    // [73] call loop 
    // [99] phi from main::@6 to loop [phi:main::@6->loop]
  loop_from___b6:
    jsr loop
    jmp __breturn
    // main::@return
  __breturn:
    // [74] return 
    rts
}
  // sprites_init
// Setup the sprites
sprites_init: {
    .label s2 = $19
    .label xpos = 6
    .label s = 5
    // [75] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta SPRITES_ENABLE
    // [76] *((const nomodify byte*) SPRITES_MC) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    // [77] *((const nomodify byte*) SPRITES_EXPAND_Y) ← *((const nomodify byte*) SPRITES_MC) -- _deref_pbuc1=_deref_pbuc2 
    lda SPRITES_MC
    sta SPRITES_EXPAND_Y
    // [78] *((const nomodify byte*) SPRITES_EXPAND_X) ← *((const nomodify byte*) SPRITES_EXPAND_Y) -- _deref_pbuc1=_deref_pbuc2 
    lda SPRITES_EXPAND_Y
    sta SPRITES_EXPAND_X
    // [79] phi from sprites_init to sprites_init::@1 [phi:sprites_init->sprites_init::@1]
  __b1_from_sprites_init:
    // [79] phi (byte) sprites_init::xpos#2 = (byte)(number) $18+(number) $f*(number) 8 [phi:sprites_init->sprites_init::@1#0] -- vbuz1=vbuc1 
    lda #$18+$f*8
    sta.z xpos
    // [79] phi (byte) sprites_init::s#2 = (byte) 0 [phi:sprites_init->sprites_init::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z s
    jmp __b1
    // [79] phi from sprites_init::@1 to sprites_init::@1 [phi:sprites_init::@1->sprites_init::@1]
  __b1_from___b1:
    // [79] phi (byte) sprites_init::xpos#2 = (byte) sprites_init::xpos#1 [phi:sprites_init::@1->sprites_init::@1#0] -- register_copy 
    // [79] phi (byte) sprites_init::s#2 = (byte) sprites_init::s#1 [phi:sprites_init::@1->sprites_init::@1#1] -- register_copy 
    jmp __b1
    // sprites_init::@1
  __b1:
    // [80] (byte) sprites_init::s2#0 ← (byte) sprites_init::s#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z s
    asl
    sta.z s2
    // [81] *((const nomodify byte*) SPRITES_XPOS + (byte) sprites_init::s2#0) ← (byte) sprites_init::xpos#2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z xpos
    ldy.z s2
    sta SPRITES_XPOS,y
    // [82] *((const nomodify byte*) SPRITES_COLOR + (byte) sprites_init::s#2) ← (const nomodify byte) BLACK -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #BLACK
    ldy.z s
    sta SPRITES_COLOR,y
    // [83] (byte) sprites_init::xpos#1 ← (byte) sprites_init::xpos#2 + (byte) $18 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z xpos
    axs #-[$18]
    stx.z xpos
    // [84] (byte) sprites_init::s#1 ← ++ (byte) sprites_init::s#2 -- vbuz1=_inc_vbuz1 
    inc.z s
    // [85] if((byte) sprites_init::s#1!=(byte) 4) goto sprites_init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #4
    cmp.z s
    bne __b1_from___b1
    jmp __breturn
    // sprites_init::@return
  __breturn:
    // [86] return 
    rts
}
  // sprites_irq_init
// Setup the IRQ
sprites_irq_init: {
    // asm { sei  }
    sei
    // [88] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge any IRQ and setup the next one
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // asm { ldaCIA1_INTERRUPT  }
    lda CIA1_INTERRUPT
    // [90] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // Disable kernal & basic
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // [91] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // [92] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // [93] *((const nomodify byte*) VIC_CONTROL) ← *((const nomodify byte*) VIC_CONTROL) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
    // [94] *((const nomodify byte*) RASTER) ← (const nomodify byte) IRQ_RASTER_FIRST -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER_FIRST
    sta RASTER
    // [95] *((const nomodify byte*) IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // [96] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_CLOBBER)(void()) sprites_irq() -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<sprites_irq
    sta HARDWARE_IRQ
    lda #>sprites_irq
    sta HARDWARE_IRQ+1
    // asm { cli  }
    cli
    jmp __breturn
    // sprites_irq_init::@return
  __breturn:
    // [98] return 
    rts
}
  // loop
loop: {
    .label __1 = $1a
    .label idx = 9
    .label s = 8
    // [100] phi from loop to loop::@1 [phi:loop->loop::@1]
  __b1_from_loop:
    // [100] phi (byte) sin_idx#11 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    jmp __b1
    // loop::@1
  __b1:
    jmp __b2
    // loop::@2
  __b2:
    // [101] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto loop::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b2
    jmp __b3
    // loop::@3
  __b3:
    // [102] (byte) loop::idx#0 ← (byte) sin_idx#11 -- vbuz1=vbuz2 
    lda.z sin_idx
    sta.z idx
    // [103] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  __b4_from___b3:
    // [103] phi (byte) loop::idx#2 = (byte) loop::idx#0 [phi:loop::@3->loop::@4#0] -- register_copy 
    // [103] phi (byte) loop::s#2 = (byte) 4 [phi:loop::@3->loop::@4#1] -- vbuz1=vbuc1 
    lda #4
    sta.z s
    jmp __b4
    // [103] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  __b4_from___b4:
    // [103] phi (byte) loop::idx#2 = (byte) loop::idx#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [103] phi (byte) loop::s#2 = (byte) loop::s#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp __b4
    // loop::@4
  __b4:
    // [104] (byte~) loop::$1 ← (byte) loop::s#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z s
    asl
    sta.z __1
    // [105] *((const nomodify byte*) SPRITES_YPOS + (byte~) loop::$1) ← *((const byte*) SIN + (byte) loop::idx#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz2 
    ldy.z idx
    lda SIN,y
    ldy.z __1
    sta SPRITES_YPOS,y
    // [106] (byte) loop::idx#1 ← (byte) loop::idx#2 + (byte) $a -- vbuz1=vbuz1_plus_vbuc1 
    lax.z idx
    axs #-[$a]
    stx.z idx
    // [107] (byte) loop::s#1 ← ++ (byte) loop::s#2 -- vbuz1=_inc_vbuz1 
    inc.z s
    // [108] if((byte) loop::s#1!=(byte) 8) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z s
    bne __b4_from___b4
    jmp __b5
    // loop::@5
  __b5:
    // [109] (byte) sin_idx#2 ← ++ (byte) sin_idx#11 -- vbuz1=_inc_vbuz1 
    inc.z sin_idx
    // [100] phi from loop::@5 to loop::@1 [phi:loop::@5->loop::@1]
  __b1_from___b5:
    // [100] phi (byte) sin_idx#11 = (byte) sin_idx#2 [phi:loop::@5->loop::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
SIN:
.var AMPL = 200-21
    .for(var i=0; i<256; i++) {
  	  .byte 51+AMPL/2+sin(toRadians([i*360]/256))*AMPL/2
    }

.pc = $3000 "PLAYFIELD_SPRITES"
// Sprites covering the playfield
PLAYFIELD_SPRITES:
.var sprites = LoadPicture("playfield-sprites.png", List().add($010101, $000000))
	// Put the sprites into memory
	.for(var sy=0;sy<10;sy++) {
	    .var sprite_gfx_y = sy*20
		.for(var sx=0;sx<3;sx++) {
	    	.for (var y=0;y<21; y++) {
	    	    .var gfx_y =  sprite_gfx_y + mod(2100+y-sprite_gfx_y,21)
		    	.for (var c=0; c<3; c++) {
	            	.byte sprites.getSinglecolorByte(sx*3+c,gfx_y)
	            }
	        }
	    	.byte 0
	  	}
	}

.pc = $2800 "PLAYFIELD_CHARSET"
// Address of the charset
PLAYFIELD_CHARSET:
.fill 8,$00 // Place a filled char at the start of the charset
    .import binary "playfield-screen.imap"

.pc = $3800 "SIN_SPRITE"
SIN_SPRITE:
.fill $40, $ff


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] (volatile byte) render_screen_showing ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS+(byte) $15 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] (volatile byte) irq_sprite_ptr ← (const byte) __start::__init1_toSpritePtr1_return#0+(byte) 3 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] (volatile byte) irq_cnt ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [18] if(*((const nomodify byte*) RASTER)<(volatile byte) sprites_irq::raster_sprite_gfx_modify) goto sprites_irq::@8 [ render_screen_showing irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt sprites_irq::raster_sprite_gfx_modify ] (  [ render_screen_showing irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt sprites_irq::raster_sprite_gfx_modify ] { }  ) always clobbers reg byte a 
Statement [20] if((volatile byte) render_screen_showing==(byte) 0) goto sprites_irq::@1 [ irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt sprites_irq::ptr#0 ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt sprites_irq::ptr#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:18 [ sprites_irq::ptr#0 ]
Statement [28] if((volatile byte) irq_cnt==(byte) 9) goto sprites_irq::@3 [ irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt ] { }  ) always clobbers reg byte a 
Statement [29] if((volatile byte) irq_cnt==(byte) $a) goto sprites_irq::@4 [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] { }  ) always clobbers reg byte a 
Statement [30] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $14 [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] { }  ) always clobbers reg byte a reg byte x 
Statement [31] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 [ irq_raster_next irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ptr ] { }  ) always clobbers reg byte a reg byte x 
Statement [32] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a reg byte x 
Statement [33] *((const nomodify byte*) RASTER) ← (volatile byte) irq_raster_next [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [34] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [35] return  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [36] (volatile byte) irq_cnt ← (byte) 0 [ irq_sprite_ypos irq_sprite_ptr ] (  [ irq_sprite_ypos irq_sprite_ptr ] { }  ) always clobbers reg byte a 
Statement [37] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] { }  ) always clobbers reg byte a 
Statement [38] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 [ irq_raster_next irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ptr ] { }  ) always clobbers reg byte a reg byte x 
Statement [39] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a reg byte x 
Statement [40] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $15 [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a reg byte x 
Statement [41] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a 
Statement [43] (volatile byte) irq_sprite_ptr ← (const byte) sprites_irq::toSpritePtr1_return#0 [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a 
Statement [51] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) 3 [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [53] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [55] *((const nomodify byte*) D018) ← (const byte) main::toD0181_return#0 [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [57] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $ff [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [59] (byte) main::s2#0 ← (byte) main::s#2 << (byte) 1 [ main::s#2 main::xpos#2 main::ypos#2 main::s2#0 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 main::s2#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::s#2 main::s#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ main::xpos#2 main::xpos#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:4 [ main::ypos#2 main::ypos#1 ]
Statement [60] *((const nomodify byte*) SPRITES_XPOS + (byte) main::s2#0) ← (byte) main::xpos#2 [ main::s#2 main::xpos#2 main::ypos#2 main::s2#0 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 main::s2#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:23 [ main::s2#0 ]
Statement [61] *((const nomodify byte*) SPRITES_YPOS + (byte) main::s2#0) ← (byte) main::ypos#2 [ main::s#2 main::xpos#2 main::ypos#2 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 ] { }  ) always clobbers reg byte a 
Statement [62] (byte~) main::$6 ← (byte) main::s#2 - (byte) 3 [ main::s#2 main::xpos#2 main::ypos#2 main::$6 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 main::$6 ] { }  ) always clobbers reg byte a 
Statement [65] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (byte) main::s#2) ← (const byte) main::toSpritePtr1_return#0 [ main::s#2 main::xpos#2 main::ypos#2 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 ] { }  ) always clobbers reg byte a 
Statement [66] (byte) main::xpos#1 ← (byte) main::xpos#2 + (byte) $18 [ main::s#2 main::ypos#2 main::xpos#1 ] ( main:8 [ main::s#2 main::ypos#2 main::xpos#1 ] { }  ) always clobbers reg byte a 
Statement [67] (byte) main::ypos#1 ← (byte) main::ypos#2 + (byte) $18 [ main::s#2 main::xpos#1 main::ypos#1 ] ( main:8 [ main::s#2 main::xpos#1 main::ypos#1 ] { }  ) always clobbers reg byte a 
Statement [75] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $f [ ] ( main:8::sprites_init:56 [ ] { }  ) always clobbers reg byte a 
Statement [76] *((const nomodify byte*) SPRITES_MC) ← (byte) 0 [ ] ( main:8::sprites_init:56 [ ] { }  ) always clobbers reg byte a 
Statement [77] *((const nomodify byte*) SPRITES_EXPAND_Y) ← *((const nomodify byte*) SPRITES_MC) [ ] ( main:8::sprites_init:56 [ ] { }  ) always clobbers reg byte a 
Statement [78] *((const nomodify byte*) SPRITES_EXPAND_X) ← *((const nomodify byte*) SPRITES_EXPAND_Y) [ ] ( main:8::sprites_init:56 [ ] { }  ) always clobbers reg byte a 
Statement [80] (byte) sprites_init::s2#0 ← (byte) sprites_init::s#2 << (byte) 1 [ sprites_init::s#2 sprites_init::xpos#2 sprites_init::s2#0 ] ( main:8::sprites_init:56 [ sprites_init::s#2 sprites_init::xpos#2 sprites_init::s2#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ sprites_init::s#2 sprites_init::s#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ sprites_init::xpos#2 sprites_init::xpos#1 ]
Statement [81] *((const nomodify byte*) SPRITES_XPOS + (byte) sprites_init::s2#0) ← (byte) sprites_init::xpos#2 [ sprites_init::s#2 sprites_init::xpos#2 ] ( main:8::sprites_init:56 [ sprites_init::s#2 sprites_init::xpos#2 ] { }  ) always clobbers reg byte a 
Statement [82] *((const nomodify byte*) SPRITES_COLOR + (byte) sprites_init::s#2) ← (const nomodify byte) BLACK [ sprites_init::s#2 sprites_init::xpos#2 ] ( main:8::sprites_init:56 [ sprites_init::s#2 sprites_init::xpos#2 ] { }  ) always clobbers reg byte a 
Statement [83] (byte) sprites_init::xpos#1 ← (byte) sprites_init::xpos#2 + (byte) $18 [ sprites_init::s#2 sprites_init::xpos#1 ] ( main:8::sprites_init:56 [ sprites_init::s#2 sprites_init::xpos#1 ] { }  ) always clobbers reg byte a 
Statement [88] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement asm { ldaCIA1_INTERRUPT  } always clobbers reg byte a 
Statement [90] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [91] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [92] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [93] *((const nomodify byte*) VIC_CONTROL) ← *((const nomodify byte*) VIC_CONTROL) & (byte) $7f [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [94] *((const nomodify byte*) RASTER) ← (const nomodify byte) IRQ_RASTER_FIRST [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [95] *((const nomodify byte*) IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [96] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_CLOBBER)(void()) sprites_irq() [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [101] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto loop::@2 [ sin_idx#11 ] ( main:8::loop:73 [ sin_idx#11 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:7 [ sin_idx#11 sin_idx#2 ]
Statement [104] (byte~) loop::$1 ← (byte) loop::s#2 << (byte) 1 [ sin_idx#11 loop::s#2 loop::idx#2 loop::$1 ] ( main:8::loop:73 [ sin_idx#11 loop::s#2 loop::idx#2 loop::$1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:8 [ loop::s#2 loop::s#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:9 [ loop::idx#2 loop::idx#0 loop::idx#1 ]
Statement [105] *((const nomodify byte*) SPRITES_YPOS + (byte~) loop::$1) ← *((const byte*) SIN + (byte) loop::idx#2) [ sin_idx#11 loop::s#2 loop::idx#2 ] ( main:8::loop:73 [ sin_idx#11 loop::s#2 loop::idx#2 ] { }  ) always clobbers reg byte a 
Statement [106] (byte) loop::idx#1 ← (byte) loop::idx#2 + (byte) $a [ sin_idx#11 loop::s#2 loop::idx#1 ] ( main:8::loop:73 [ sin_idx#11 loop::s#2 loop::idx#1 ] { }  ) always clobbers reg byte a 
Statement [1] (volatile byte) render_screen_showing ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS+(byte) $15 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] (volatile byte) irq_sprite_ptr ← (const byte) __start::__init1_toSpritePtr1_return#0+(byte) 3 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] (volatile byte) irq_cnt ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [18] if(*((const nomodify byte*) RASTER)<(volatile byte) sprites_irq::raster_sprite_gfx_modify) goto sprites_irq::@8 [ render_screen_showing irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt sprites_irq::raster_sprite_gfx_modify ] (  [ render_screen_showing irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt sprites_irq::raster_sprite_gfx_modify ] { }  ) always clobbers reg byte a 
Statement [20] if((volatile byte) render_screen_showing==(byte) 0) goto sprites_irq::@1 [ irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt sprites_irq::ptr#0 ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt sprites_irq::ptr#0 ] { }  ) always clobbers reg byte a 
Statement [28] if((volatile byte) irq_cnt==(byte) 9) goto sprites_irq::@3 [ irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr irq_cnt ] { }  ) always clobbers reg byte a 
Statement [29] if((volatile byte) irq_cnt==(byte) $a) goto sprites_irq::@4 [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] { }  ) always clobbers reg byte a 
Statement [30] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $14 [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] { }  ) always clobbers reg byte a reg byte x 
Statement [31] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 [ irq_raster_next irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ptr ] { }  ) always clobbers reg byte a reg byte x 
Statement [32] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a reg byte x 
Statement [33] *((const nomodify byte*) RASTER) ← (volatile byte) irq_raster_next [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [34] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [35] return  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [36] (volatile byte) irq_cnt ← (byte) 0 [ irq_sprite_ypos irq_sprite_ptr ] (  [ irq_sprite_ypos irq_sprite_ptr ] { }  ) always clobbers reg byte a 
Statement [37] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ypos irq_sprite_ptr ] { }  ) always clobbers reg byte a 
Statement [38] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 [ irq_raster_next irq_sprite_ptr ] (  [ irq_raster_next irq_sprite_ptr ] { }  ) always clobbers reg byte a reg byte x 
Statement [39] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a reg byte x 
Statement [40] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $15 [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a reg byte x 
Statement [41] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a 
Statement [43] (volatile byte) irq_sprite_ptr ← (const byte) sprites_irq::toSpritePtr1_return#0 [ irq_raster_next ] (  [ irq_raster_next ] { }  ) always clobbers reg byte a 
Statement [51] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) 3 [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [53] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [55] *((const nomodify byte*) D018) ← (const byte) main::toD0181_return#0 [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [57] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $ff [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [59] (byte) main::s2#0 ← (byte) main::s#2 << (byte) 1 [ main::s#2 main::xpos#2 main::ypos#2 main::s2#0 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 main::s2#0 ] { }  ) always clobbers reg byte a 
Statement [60] *((const nomodify byte*) SPRITES_XPOS + (byte) main::s2#0) ← (byte) main::xpos#2 [ main::s#2 main::xpos#2 main::ypos#2 main::s2#0 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 main::s2#0 ] { }  ) always clobbers reg byte a 
Statement [61] *((const nomodify byte*) SPRITES_YPOS + (byte) main::s2#0) ← (byte) main::ypos#2 [ main::s#2 main::xpos#2 main::ypos#2 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 ] { }  ) always clobbers reg byte a 
Statement [62] (byte~) main::$6 ← (byte) main::s#2 - (byte) 3 [ main::s#2 main::xpos#2 main::ypos#2 main::$6 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 main::$6 ] { }  ) always clobbers reg byte a 
Statement [65] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (byte) main::s#2) ← (const byte) main::toSpritePtr1_return#0 [ main::s#2 main::xpos#2 main::ypos#2 ] ( main:8 [ main::s#2 main::xpos#2 main::ypos#2 ] { }  ) always clobbers reg byte a 
Statement [66] (byte) main::xpos#1 ← (byte) main::xpos#2 + (byte) $18 [ main::s#2 main::ypos#2 main::xpos#1 ] ( main:8 [ main::s#2 main::ypos#2 main::xpos#1 ] { }  ) always clobbers reg byte a 
Statement [67] (byte) main::ypos#1 ← (byte) main::ypos#2 + (byte) $18 [ main::s#2 main::xpos#1 main::ypos#1 ] ( main:8 [ main::s#2 main::xpos#1 main::ypos#1 ] { }  ) always clobbers reg byte a 
Statement [75] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $f [ ] ( main:8::sprites_init:56 [ ] { }  ) always clobbers reg byte a 
Statement [76] *((const nomodify byte*) SPRITES_MC) ← (byte) 0 [ ] ( main:8::sprites_init:56 [ ] { }  ) always clobbers reg byte a 
Statement [77] *((const nomodify byte*) SPRITES_EXPAND_Y) ← *((const nomodify byte*) SPRITES_MC) [ ] ( main:8::sprites_init:56 [ ] { }  ) always clobbers reg byte a 
Statement [78] *((const nomodify byte*) SPRITES_EXPAND_X) ← *((const nomodify byte*) SPRITES_EXPAND_Y) [ ] ( main:8::sprites_init:56 [ ] { }  ) always clobbers reg byte a 
Statement [80] (byte) sprites_init::s2#0 ← (byte) sprites_init::s#2 << (byte) 1 [ sprites_init::s#2 sprites_init::xpos#2 sprites_init::s2#0 ] ( main:8::sprites_init:56 [ sprites_init::s#2 sprites_init::xpos#2 sprites_init::s2#0 ] { }  ) always clobbers reg byte a 
Statement [81] *((const nomodify byte*) SPRITES_XPOS + (byte) sprites_init::s2#0) ← (byte) sprites_init::xpos#2 [ sprites_init::s#2 sprites_init::xpos#2 ] ( main:8::sprites_init:56 [ sprites_init::s#2 sprites_init::xpos#2 ] { }  ) always clobbers reg byte a 
Statement [82] *((const nomodify byte*) SPRITES_COLOR + (byte) sprites_init::s#2) ← (const nomodify byte) BLACK [ sprites_init::s#2 sprites_init::xpos#2 ] ( main:8::sprites_init:56 [ sprites_init::s#2 sprites_init::xpos#2 ] { }  ) always clobbers reg byte a 
Statement [83] (byte) sprites_init::xpos#1 ← (byte) sprites_init::xpos#2 + (byte) $18 [ sprites_init::s#2 sprites_init::xpos#1 ] ( main:8::sprites_init:56 [ sprites_init::s#2 sprites_init::xpos#1 ] { }  ) always clobbers reg byte a 
Statement [88] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement asm { ldaCIA1_INTERRUPT  } always clobbers reg byte a 
Statement [90] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [91] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [92] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [93] *((const nomodify byte*) VIC_CONTROL) ← *((const nomodify byte*) VIC_CONTROL) & (byte) $7f [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [94] *((const nomodify byte*) RASTER) ← (const nomodify byte) IRQ_RASTER_FIRST [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [95] *((const nomodify byte*) IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [96] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_CLOBBER)(void()) sprites_irq() [ ] ( main:8::sprites_irq_init:71 [ ] { }  ) always clobbers reg byte a 
Statement [101] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto loop::@2 [ sin_idx#11 ] ( main:8::loop:73 [ sin_idx#11 ] { }  ) always clobbers reg byte a 
Statement [104] (byte~) loop::$1 ← (byte) loop::s#2 << (byte) 1 [ sin_idx#11 loop::s#2 loop::idx#2 loop::$1 ] ( main:8::loop:73 [ sin_idx#11 loop::s#2 loop::idx#2 loop::$1 ] { }  ) always clobbers reg byte a 
Statement [105] *((const nomodify byte*) SPRITES_YPOS + (byte~) loop::$1) ← *((const byte*) SIN + (byte) loop::idx#2) [ sin_idx#11 loop::s#2 loop::idx#2 ] ( main:8::loop:73 [ sin_idx#11 loop::s#2 loop::idx#2 ] { }  ) always clobbers reg byte a 
Statement [106] (byte) loop::idx#1 ← (byte) loop::idx#2 + (byte) $a [ sin_idx#11 loop::s#2 loop::idx#1 ] ( main:8::loop:73 [ sin_idx#11 loop::s#2 loop::idx#1 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::s#2 main::s#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ main::xpos#2 main::xpos#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ main::ypos#2 main::ypos#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ sprites_init::s#2 sprites_init::s#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ sprites_init::xpos#2 sprites_init::xpos#1 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ sin_idx#11 sin_idx#2 ] : zp[1]:7 , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ loop::s#2 loop::s#1 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ loop::idx#2 loop::idx#0 loop::idx#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ render_screen_showing ] : zp[1]:10 , 
Potential registers zp[1]:11 [ irq_raster_next ] : zp[1]:11 , 
Potential registers zp[1]:12 [ irq_sprite_ypos ] : zp[1]:12 , 
Potential registers zp[1]:13 [ irq_sprite_ptr ] : zp[1]:13 , 
Potential registers zp[1]:14 [ irq_cnt ] : zp[1]:14 , 
Potential registers zp[1]:15 [ sprites_irq::ypos#0 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ sprites_irq::$0 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ sprites_irq::raster_sprite_gfx_modify ] : zp[1]:17 , 
Potential registers zp[1]:18 [ sprites_irq::ptr#0 ] : zp[1]:18 , reg byte x , reg byte y , 
Potential registers zp[1]:19 [ sprites_irq::ptr#3 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:20 [ sprites_irq::ptr#4 ] : zp[1]:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:21 [ sprites_irq::ptr#1 ] : zp[1]:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:22 [ sprites_irq::ptr#2 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:23 [ main::s2#0 ] : zp[1]:23 , reg byte x , reg byte y , 
Potential registers zp[1]:24 [ main::$6 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:25 [ sprites_init::s2#0 ] : zp[1]:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:26 [ loop::$1 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [loop] 22,502.25: zp[1]:8 [ loop::s#2 loop::s#1 ] 20,002: zp[1]:26 [ loop::$1 ] 19,004: zp[1]:9 [ loop::idx#2 loop::idx#0 loop::idx#1 ] 
Uplift Scope [sprites_init] 2,302.3: zp[1]:5 [ sprites_init::s#2 sprites_init::s#1 ] 2,002: zp[1]:25 [ sprites_init::s2#0 ] 1,418.08: zp[1]:6 [ sprites_init::xpos#2 sprites_init::xpos#1 ] 
Uplift Scope [] 2,335.67: zp[1]:7 [ sin_idx#11 sin_idx#2 ] 0.48: zp[1]:12 [ irq_sprite_ypos ] 0.48: zp[1]:14 [ irq_cnt ] 0.45: zp[1]:13 [ irq_sprite_ptr ] 0.44: zp[1]:11 [ irq_raster_next ] 0.4: zp[1]:10 [ render_screen_showing ] 
Uplift Scope [main] 212.1: zp[1]:2 [ main::s#2 main::s#1 ] 202: zp[1]:24 [ main::$6 ] 151.5: zp[1]:23 [ main::s2#0 ] 101: zp[1]:4 [ main::ypos#2 main::ypos#1 ] 88.38: zp[1]:3 [ main::xpos#2 main::xpos#1 ] 
Uplift Scope [sprites_irq] 6.5: zp[1]:17 [ sprites_irq::raster_sprite_gfx_modify ] 4: zp[1]:16 [ sprites_irq::$0 ] 4: zp[1]:20 [ sprites_irq::ptr#4 ] 4: zp[1]:22 [ sprites_irq::ptr#2 ] 2.67: zp[1]:19 [ sprites_irq::ptr#3 ] 2.67: zp[1]:21 [ sprites_irq::ptr#1 ] 2.5: zp[1]:15 [ sprites_irq::ypos#0 ] 2.5: zp[1]:18 [ sprites_irq::ptr#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [sprites_irq_init] 
Uplift Scope [__start] 

Uplifting [loop] best 8842 combination zp[1]:8 [ loop::s#2 loop::s#1 ] reg byte a [ loop::$1 ] reg byte x [ loop::idx#2 loop::idx#0 loop::idx#1 ] 
Uplifting [sprites_init] best 8672 combination reg byte y [ sprites_init::s#2 sprites_init::s#1 ] reg byte x [ sprites_init::s2#0 ] zp[1]:6 [ sprites_init::xpos#2 sprites_init::xpos#1 ] 
Uplifting [] best 8672 combination zp[1]:7 [ sin_idx#11 sin_idx#2 ] zp[1]:12 [ irq_sprite_ypos ] zp[1]:14 [ irq_cnt ] zp[1]:13 [ irq_sprite_ptr ] zp[1]:11 [ irq_raster_next ] zp[1]:10 [ render_screen_showing ] 
Uplifting [main] best 8392 combination reg byte y [ main::s#2 main::s#1 ] reg byte a [ main::$6 ] reg byte x [ main::s2#0 ] zp[1]:4 [ main::ypos#2 main::ypos#1 ] zp[1]:3 [ main::xpos#2 main::xpos#1 ] 
Limited combination testing to 100 combinations of 324 possible.
Uplifting [sprites_irq] best 8368 combination zp[1]:17 [ sprites_irq::raster_sprite_gfx_modify ] reg byte x [ sprites_irq::$0 ] reg byte a [ sprites_irq::ptr#4 ] reg byte a [ sprites_irq::ptr#2 ] reg byte a [ sprites_irq::ptr#3 ] zp[1]:21 [ sprites_irq::ptr#1 ] zp[1]:15 [ sprites_irq::ypos#0 ] zp[1]:18 [ sprites_irq::ptr#0 ] 
Limited combination testing to 100 combinations of 12288 possible.
Uplifting [MOS6526_CIA] best 8368 combination 
Uplifting [MOS6569_VICII] best 8368 combination 
Uplifting [MOS6581_SID] best 8368 combination 
Uplifting [sprites_irq_init] best 8368 combination 
Uplifting [__start] best 8368 combination 
Attempting to uplift remaining variables inzp[1]:8 [ loop::s#2 loop::s#1 ]
Uplifting [loop] best 8368 combination zp[1]:8 [ loop::s#2 loop::s#1 ] 
Attempting to uplift remaining variables inzp[1]:7 [ sin_idx#11 sin_idx#2 ]
Uplifting [] best 8368 combination zp[1]:7 [ sin_idx#11 sin_idx#2 ] 
Attempting to uplift remaining variables inzp[1]:6 [ sprites_init::xpos#2 sprites_init::xpos#1 ]
Uplifting [sprites_init] best 8368 combination zp[1]:6 [ sprites_init::xpos#2 sprites_init::xpos#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ main::ypos#2 main::ypos#1 ]
Uplifting [main] best 8368 combination zp[1]:4 [ main::ypos#2 main::ypos#1 ] 
Attempting to uplift remaining variables inzp[1]:3 [ main::xpos#2 main::xpos#1 ]
Uplifting [main] best 8368 combination zp[1]:3 [ main::xpos#2 main::xpos#1 ] 
Attempting to uplift remaining variables inzp[1]:17 [ sprites_irq::raster_sprite_gfx_modify ]
Uplifting [sprites_irq] best 8368 combination zp[1]:17 [ sprites_irq::raster_sprite_gfx_modify ] 
Attempting to uplift remaining variables inzp[1]:21 [ sprites_irq::ptr#1 ]
Uplifting [sprites_irq] best 8356 combination reg byte x [ sprites_irq::ptr#1 ] 
Attempting to uplift remaining variables inzp[1]:15 [ sprites_irq::ypos#0 ]
Uplifting [sprites_irq] best 8341 combination reg byte a [ sprites_irq::ypos#0 ] 
Attempting to uplift remaining variables inzp[1]:18 [ sprites_irq::ptr#0 ]
Uplifting [sprites_irq] best 8326 combination reg byte x [ sprites_irq::ptr#0 ] 
Attempting to uplift remaining variables inzp[1]:12 [ irq_sprite_ypos ]
Uplifting [] best 8326 combination zp[1]:12 [ irq_sprite_ypos ] 
Attempting to uplift remaining variables inzp[1]:14 [ irq_cnt ]
Uplifting [] best 8326 combination zp[1]:14 [ irq_cnt ] 
Attempting to uplift remaining variables inzp[1]:13 [ irq_sprite_ptr ]
Uplifting [] best 8326 combination zp[1]:13 [ irq_sprite_ptr ] 
Attempting to uplift remaining variables inzp[1]:11 [ irq_raster_next ]
Uplifting [] best 8326 combination zp[1]:11 [ irq_raster_next ] 
Attempting to uplift remaining variables inzp[1]:10 [ render_screen_showing ]
Uplifting [] best 8326 combination zp[1]:10 [ render_screen_showing ] 
Coalescing zero page register [ zp[1]:8 [ loop::s#2 loop::s#1 ] ] with [ zp[1]:6 [ sprites_init::xpos#2 sprites_init::xpos#1 ] ]
Allocated (was zp[1]:3) zp[1]:2 [ main::xpos#2 main::xpos#1 ]
Allocated (was zp[1]:4) zp[1]:3 [ main::ypos#2 main::ypos#1 ]
Allocated (was zp[1]:7) zp[1]:4 [ sin_idx#11 sin_idx#2 ]
Allocated (was zp[1]:8) zp[1]:5 [ loop::s#2 loop::s#1 sprites_init::xpos#2 sprites_init::xpos#1 ]
Allocated (was zp[1]:10) zp[1]:6 [ render_screen_showing ]
Allocated (was zp[1]:11) zp[1]:7 [ irq_raster_next ]
Allocated (was zp[1]:12) zp[1]:8 [ irq_sprite_ypos ]
Allocated (was zp[1]:13) zp[1]:9 [ irq_sprite_ptr ]
Allocated (was zp[1]:14) zp[1]:10 [ irq_cnt ]
Allocated (was zp[1]:17) zp[1]:11 [ sprites_irq::raster_sprite_gfx_modify ]
Interrupt procedure sprites_irq clobbers AXCNZV
Removing interrupt register storage sty regy+1 in 20 entry interrupt(HARDWARE_CLOBBER)
Removing interrupt register storage regy: in 54 [35] return  - exit interrupt(HARDWARE_CLOBBER)
Removing interrupt register storage ldy #00 in 54 [35] return  - exit interrupt(HARDWARE_CLOBBER)

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tetris Game for the Commodore 64
// A sprite multiplexer covering the playfield with a black layer to allow for 3 single-pixel colors
// Commodore 64 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__start)
.pc = $80d "Program"
  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The offset of the sprite pointers from the screen start address
  .const SPRITE_PTRS = $3f8
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  // The colors of the C64
  .const BLACK = 0
  // The Y-position of the first sprite row
  .const SPRITES_FIRST_YPOS = $31
  // The line of the first IRQ
  .const IRQ_RASTER_FIRST = SPRITES_FIRST_YPOS+$13
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = 2
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_COLOR = $d027
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label RASTER = $d012
  .label VIC_CONTROL = $d011
  .label D018 = $d018
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#1 Interrupt for reading in ASM
  .label CIA1_INTERRUPT = $dc0d
  // The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Address of the first screen
  .label PLAYFIELD_SCREEN_1 = $400
  // Address of the second screen
  .label PLAYFIELD_SCREEN_2 = $2c00
  // Screen Sprite pointers on screen 1
  .label PLAYFIELD_SPRITE_PTRS_1 = PLAYFIELD_SCREEN_1+SPRITE_PTRS
  // Screen Sprite pointers on screen 2
  .label PLAYFIELD_SPRITE_PTRS_2 = PLAYFIELD_SCREEN_2+SPRITE_PTRS
  // The screen currently being showed to the user. 0x00 for screen 1 / 0x20 for screen 2.
  .label render_screen_showing = 6
  // The raster line of the next IRQ
  .label irq_raster_next = 7
  // Y-pos of the sprites on the next IRQ
  .label irq_sprite_ypos = 8
  // Index of the sprites to show on the next IRQ
  .label irq_sprite_ptr = 9
  // Counting the 10 IRQs
  .label irq_cnt = $a
  .label sin_idx = 4
  // __start
__start: {
    .const __init1_toSpritePtr1_return = $ff&PLAYFIELD_SPRITES/$40
    jmp __init1
    // __start::__init1
  __init1:
    // [1] (volatile byte) render_screen_showing ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z render_screen_showing
    // [2] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST -- vbuz1=vbuc1 
    lda #IRQ_RASTER_FIRST
    sta.z irq_raster_next
    // [3] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS+(byte) $15 -- vbuz1=vbuc1 
    lda #SPRITES_FIRST_YPOS+$15
    sta.z irq_sprite_ypos
    // [4] phi from __start::__init1 to __start::__init1_toSpritePtr1 [phi:__start::__init1->__start::__init1_toSpritePtr1]
  __init1_toSpritePtr1_from___init1:
    jmp __init1_toSpritePtr1
    // __start::__init1_toSpritePtr1
  __init1_toSpritePtr1:
    jmp __init1___b1
    // __start::__init1_@1
  __init1___b1:
    // [5] (volatile byte) irq_sprite_ptr ← (const byte) __start::__init1_toSpritePtr1_return#0+(byte) 3 -- vbuz1=vbuc1 
    lda #__init1_toSpritePtr1_return+3
    sta.z irq_sprite_ptr
    // [6] (volatile byte) irq_cnt ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z irq_cnt
    // [7] phi from __start::__init1_@1 to __start::@1 [phi:__start::__init1_@1->__start::@1]
  __b1_from___init1___b1:
    jmp __b1
    // __start::@1
  __b1:
    // [8] call main 
    // [50] phi from __start::@1 to main [phi:__start::@1->main]
  main_from___b1:
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [9] return 
    rts
}
  // sprites_irq
// Raster Interrupt Routine - sets up the sprites covering the playfield
// Repeats 10 timers every 2 lines from line IRQ_RASTER_FIRST
// Utilizes duplicated gfx in the sprites to allow for some leeway in updating the sprite pointers
sprites_irq: {
    .const toSpritePtr1_return = $ff&PLAYFIELD_SPRITES/$40
    .label raster_sprite_gfx_modify = $b
    // entry interrupt(HARDWARE_CLOBBER)
    sta rega+1
    stx regx+1
    // asm { cld  }
    //(*BG_COLOR)++;
    // Clear decimal flag (because it is used by the score algorithm)
    cld
    // [11] (byte) sprites_irq::ypos#0 ← (volatile byte) irq_sprite_ypos -- vbuaa=vbuz1 
    // Place the sprites
    lda.z irq_sprite_ypos
    // [12] *((const nomodify byte*) SPRITES_YPOS) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuaa 
    sta SPRITES_YPOS
    // [13] *((const nomodify byte*) SPRITES_YPOS+(byte) 2) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuaa 
    sta SPRITES_YPOS+2
    // [14] *((const nomodify byte*) SPRITES_YPOS+(byte) 4) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuaa 
    sta SPRITES_YPOS+4
    // [15] *((const nomodify byte*) SPRITES_YPOS+(byte) 6) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuaa 
    sta SPRITES_YPOS+6
    // [16] (byte~) sprites_irq::$0 ← (volatile byte) irq_raster_next + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z irq_raster_next
    inx
    // [17] (volatile byte) sprites_irq::raster_sprite_gfx_modify ← (byte~) sprites_irq::$0 -- vbuz1=vbuxx 
    // Wait for the y-position before changing sprite pointers
    stx.z raster_sprite_gfx_modify
    jmp __b8
    // sprites_irq::@8
  __b8:
    // [18] if(*((const nomodify byte*) RASTER)<(volatile byte) sprites_irq::raster_sprite_gfx_modify) goto sprites_irq::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z raster_sprite_gfx_modify
    bcc __b8
    jmp __b9
    // sprites_irq::@9
  __b9:
    // [19] (byte) sprites_irq::ptr#0 ← (volatile byte) irq_sprite_ptr -- vbuxx=vbuz1 
    ldx.z irq_sprite_ptr
    // [20] if((volatile byte) render_screen_showing==(byte) 0) goto sprites_irq::@1 -- vbuz1_eq_0_then_la1 
    lda.z render_screen_showing
    cmp #0
    beq __b1
    jmp __b10
    // sprites_irq::@10
  __b10:
    // [21] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2) ← (byte) sprites_irq::ptr#0 -- _deref_pbuc1=vbuxx 
    stx PLAYFIELD_SPRITE_PTRS_2
    // [22] (byte) sprites_irq::ptr#3 ← ++ (byte) sprites_irq::ptr#0 -- vbuaa=_inc_vbuxx 
    inx
    txa
    // [23] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 1) ← (byte) sprites_irq::ptr#3 -- _deref_pbuc1=vbuaa 
    sta PLAYFIELD_SPRITE_PTRS_2+1
    // [24] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 2) ← (byte) sprites_irq::ptr#3 -- _deref_pbuc1=vbuaa 
    sta PLAYFIELD_SPRITE_PTRS_2+2
    // [25] (byte) sprites_irq::ptr#4 ← ++ (byte) sprites_irq::ptr#3 -- vbuaa=_inc_vbuaa 
    clc
    adc #1
    // [26] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 3) ← (byte) sprites_irq::ptr#4 -- _deref_pbuc1=vbuaa 
    sta PLAYFIELD_SPRITE_PTRS_2+3
    jmp __b2
    // sprites_irq::@2
  __b2:
    // [27] (volatile byte) irq_cnt ← ++ (volatile byte) irq_cnt -- vbuz1=_inc_vbuz1 
    inc.z irq_cnt
    // [28] if((volatile byte) irq_cnt==(byte) 9) goto sprites_irq::@3 -- vbuz1_eq_vbuc1_then_la1 
    lda #9
    cmp.z irq_cnt
    beq __b3
    jmp __b6
    // sprites_irq::@6
  __b6:
    // [29] if((volatile byte) irq_cnt==(byte) $a) goto sprites_irq::@4 -- vbuz1_eq_vbuc1_then_la1 
    lda #$a
    cmp.z irq_cnt
    beq __b4
    jmp __b7
    // sprites_irq::@7
  __b7:
    // [30] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $14 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_raster_next
    axs #-[$14]
    stx.z irq_raster_next
    // [31] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ypos
    axs #-[$15]
    stx.z irq_sprite_ypos
    // [32] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ptr
    axs #-[3]
    stx.z irq_sprite_ptr
    jmp __b5
    // sprites_irq::@5
  __b5:
    // [33] *((const nomodify byte*) RASTER) ← (volatile byte) irq_raster_next -- _deref_pbuc1=vbuz1 
    // Setup next interrupt
    lda.z irq_raster_next
    sta RASTER
    // [34] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ and setup the next one
    lda #IRQ_RASTER
    sta IRQ_STATUS
    jmp __breturn
    // sprites_irq::@return
  __breturn:
    // [35] return  - exit interrupt(HARDWARE_CLOBBER)
  rega:
    lda #00
  regx:
    ldx #00
    rti
    // sprites_irq::@4
  __b4:
    // [36] (volatile byte) irq_cnt ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z irq_cnt
    // [37] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST -- vbuz1=vbuc1 
    lda #IRQ_RASTER_FIRST
    sta.z irq_raster_next
    // [38] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ypos
    axs #-[$15]
    stx.z irq_sprite_ypos
    // [39] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ptr
    axs #-[3]
    stx.z irq_sprite_ptr
    jmp __b5
    // sprites_irq::@3
  __b3:
    // [40] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $15 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_raster_next
    axs #-[$15]
    stx.z irq_raster_next
    // [41] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS -- vbuz1=vbuc1 
    lda #SPRITES_FIRST_YPOS
    sta.z irq_sprite_ypos
    // [42] phi from sprites_irq::@3 to sprites_irq::toSpritePtr1 [phi:sprites_irq::@3->sprites_irq::toSpritePtr1]
  toSpritePtr1_from___b3:
    jmp toSpritePtr1
    // sprites_irq::toSpritePtr1
  toSpritePtr1:
    jmp __b11
    // sprites_irq::@11
  __b11:
    // [43] (volatile byte) irq_sprite_ptr ← (const byte) sprites_irq::toSpritePtr1_return#0 -- vbuz1=vbuc1 
    lda #toSpritePtr1_return
    sta.z irq_sprite_ptr
    jmp __b5
    // sprites_irq::@1
  __b1:
    // [44] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1) ← (byte) sprites_irq::ptr#0 -- _deref_pbuc1=vbuxx 
    stx PLAYFIELD_SPRITE_PTRS_1
    // [45] (byte) sprites_irq::ptr#1 ← ++ (byte) sprites_irq::ptr#0 -- vbuxx=_inc_vbuxx 
    inx
    // [46] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 1) ← (byte) sprites_irq::ptr#1 -- _deref_pbuc1=vbuxx 
    stx PLAYFIELD_SPRITE_PTRS_1+1
    // [47] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 2) ← (byte) sprites_irq::ptr#1 -- _deref_pbuc1=vbuxx 
    stx PLAYFIELD_SPRITE_PTRS_1+2
    // [48] (byte) sprites_irq::ptr#2 ← ++ (byte) sprites_irq::ptr#1 -- vbuaa=_inc_vbuxx 
    inx
    txa
    // [49] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 3) ← (byte) sprites_irq::ptr#2 -- _deref_pbuc1=vbuaa 
    sta PLAYFIELD_SPRITE_PTRS_1+3
    jmp __b2
}
  // main
main: {
    .const toSpritePtr1_return = $ff&SIN_SPRITE/$40
    .const vicSelectGfxBank1_toDd001_return = 3
    .const toD0181_return = (>(PLAYFIELD_SCREEN_1&$3fff)*4)|(>PLAYFIELD_CHARSET)/4&$f
    .label xpos = 2
    .label ypos = 3
    jmp vicSelectGfxBank1
    // main::vicSelectGfxBank1
  vicSelectGfxBank1:
    // [51] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR
    // [52] phi from main::vicSelectGfxBank1 to main::vicSelectGfxBank1_toDd001 [phi:main::vicSelectGfxBank1->main::vicSelectGfxBank1_toDd001]
  vicSelectGfxBank1_toDd001_from_vicSelectGfxBank1:
    jmp vicSelectGfxBank1_toDd001
    // main::vicSelectGfxBank1_toDd001
  vicSelectGfxBank1_toDd001:
    jmp vicSelectGfxBank1___b1
    // main::vicSelectGfxBank1_@1
  vicSelectGfxBank1___b1:
    // [53] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 -- _deref_pbuc1=vbuc2 
    lda #vicSelectGfxBank1_toDd001_return
    sta CIA2
    // [54] phi from main::vicSelectGfxBank1_@1 to main::toD0181 [phi:main::vicSelectGfxBank1_@1->main::toD0181]
  toD0181_from_vicSelectGfxBank1___b1:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp __b3
    // main::@3
  __b3:
    // [55] *((const nomodify byte*) D018) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // [56] call sprites_init 
    jsr sprites_init
    jmp __b5
    // main::@5
  __b5:
    // [57] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    lda #$ff
    sta SPRITES_ENABLE
    // [58] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  __b1_from___b5:
    // [58] phi (byte) main::ypos#2 = (byte) $32 [phi:main::@5->main::@1#0] -- vbuz1=vbuc1 
    lda #$32
    sta.z ypos
    // [58] phi (byte) main::xpos#2 = (byte) $18 [phi:main::@5->main::@1#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z xpos
    // [58] phi (byte) main::s#2 = (byte) 4 [phi:main::@5->main::@1#2] -- vbuyy=vbuc1 
    ldy #4
    jmp __b1
    // [58] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  __b1_from___b4:
    // [58] phi (byte) main::ypos#2 = (byte) main::ypos#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [58] phi (byte) main::xpos#2 = (byte) main::xpos#1 [phi:main::@4->main::@1#1] -- register_copy 
    // [58] phi (byte) main::s#2 = (byte) main::s#1 [phi:main::@4->main::@1#2] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [59] (byte) main::s2#0 ← (byte) main::s#2 << (byte) 1 -- vbuxx=vbuyy_rol_1 
    tya
    asl
    tax
    // [60] *((const nomodify byte*) SPRITES_XPOS + (byte) main::s2#0) ← (byte) main::xpos#2 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z xpos
    sta SPRITES_XPOS,x
    // [61] *((const nomodify byte*) SPRITES_YPOS + (byte) main::s2#0) ← (byte) main::ypos#2 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z ypos
    sta SPRITES_YPOS,x
    // [62] (byte~) main::$6 ← (byte) main::s#2 - (byte) 3 -- vbuaa=vbuyy_minus_vbuc1 
    tya
    sec
    sbc #3
    // [63] *((const nomodify byte*) SPRITES_COLOR + (byte) main::s#2) ← (byte~) main::$6 -- pbuc1_derefidx_vbuyy=vbuaa 
    sta SPRITES_COLOR,y
    // [64] phi from main::@1 to main::toSpritePtr1 [phi:main::@1->main::toSpritePtr1]
  toSpritePtr1_from___b1:
    jmp toSpritePtr1
    // main::toSpritePtr1
  toSpritePtr1:
    jmp __b4
    // main::@4
  __b4:
    // [65] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (byte) main::s#2) ← (const byte) main::toSpritePtr1_return#0 -- pbuc1_derefidx_vbuyy=vbuc2 
    lda #toSpritePtr1_return
    sta PLAYFIELD_SPRITE_PTRS_1,y
    // [66] (byte) main::xpos#1 ← (byte) main::xpos#2 + (byte) $18 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z xpos
    axs #-[$18]
    stx.z xpos
    // [67] (byte) main::ypos#1 ← (byte) main::ypos#2 + (byte) $18 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z ypos
    axs #-[$18]
    stx.z ypos
    // [68] (byte) main::s#1 ← ++ (byte) main::s#2 -- vbuyy=_inc_vbuyy 
    iny
    // [69] if((byte) main::s#1!=(byte) 8) goto main::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #8
    bne __b1_from___b4
    // [70] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  __b2_from___b4:
    jmp __b2
    // main::@2
  __b2:
    // [71] call sprites_irq_init 
    jsr sprites_irq_init
    // [72] phi from main::@2 to main::@6 [phi:main::@2->main::@6]
  __b6_from___b2:
    jmp __b6
    // main::@6
  __b6:
    // [73] call loop 
    // [99] phi from main::@6 to loop [phi:main::@6->loop]
  loop_from___b6:
    jsr loop
    jmp __breturn
    // main::@return
  __breturn:
    // [74] return 
    rts
}
  // sprites_init
// Setup the sprites
sprites_init: {
    .label xpos = 5
    // [75] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta SPRITES_ENABLE
    // [76] *((const nomodify byte*) SPRITES_MC) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    // [77] *((const nomodify byte*) SPRITES_EXPAND_Y) ← *((const nomodify byte*) SPRITES_MC) -- _deref_pbuc1=_deref_pbuc2 
    lda SPRITES_MC
    sta SPRITES_EXPAND_Y
    // [78] *((const nomodify byte*) SPRITES_EXPAND_X) ← *((const nomodify byte*) SPRITES_EXPAND_Y) -- _deref_pbuc1=_deref_pbuc2 
    lda SPRITES_EXPAND_Y
    sta SPRITES_EXPAND_X
    // [79] phi from sprites_init to sprites_init::@1 [phi:sprites_init->sprites_init::@1]
  __b1_from_sprites_init:
    // [79] phi (byte) sprites_init::xpos#2 = (byte)(number) $18+(number) $f*(number) 8 [phi:sprites_init->sprites_init::@1#0] -- vbuz1=vbuc1 
    lda #$18+$f*8
    sta.z xpos
    // [79] phi (byte) sprites_init::s#2 = (byte) 0 [phi:sprites_init->sprites_init::@1#1] -- vbuyy=vbuc1 
    ldy #0
    jmp __b1
    // [79] phi from sprites_init::@1 to sprites_init::@1 [phi:sprites_init::@1->sprites_init::@1]
  __b1_from___b1:
    // [79] phi (byte) sprites_init::xpos#2 = (byte) sprites_init::xpos#1 [phi:sprites_init::@1->sprites_init::@1#0] -- register_copy 
    // [79] phi (byte) sprites_init::s#2 = (byte) sprites_init::s#1 [phi:sprites_init::@1->sprites_init::@1#1] -- register_copy 
    jmp __b1
    // sprites_init::@1
  __b1:
    // [80] (byte) sprites_init::s2#0 ← (byte) sprites_init::s#2 << (byte) 1 -- vbuxx=vbuyy_rol_1 
    tya
    asl
    tax
    // [81] *((const nomodify byte*) SPRITES_XPOS + (byte) sprites_init::s2#0) ← (byte) sprites_init::xpos#2 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z xpos
    sta SPRITES_XPOS,x
    // [82] *((const nomodify byte*) SPRITES_COLOR + (byte) sprites_init::s#2) ← (const nomodify byte) BLACK -- pbuc1_derefidx_vbuyy=vbuc2 
    lda #BLACK
    sta SPRITES_COLOR,y
    // [83] (byte) sprites_init::xpos#1 ← (byte) sprites_init::xpos#2 + (byte) $18 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z xpos
    axs #-[$18]
    stx.z xpos
    // [84] (byte) sprites_init::s#1 ← ++ (byte) sprites_init::s#2 -- vbuyy=_inc_vbuyy 
    iny
    // [85] if((byte) sprites_init::s#1!=(byte) 4) goto sprites_init::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #4
    bne __b1_from___b1
    jmp __breturn
    // sprites_init::@return
  __breturn:
    // [86] return 
    rts
}
  // sprites_irq_init
// Setup the IRQ
sprites_irq_init: {
    // asm { sei  }
    sei
    // [88] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge any IRQ and setup the next one
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // asm { ldaCIA1_INTERRUPT  }
    lda CIA1_INTERRUPT
    // [90] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // Disable kernal & basic
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // [91] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // [92] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // [93] *((const nomodify byte*) VIC_CONTROL) ← *((const nomodify byte*) VIC_CONTROL) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
    // [94] *((const nomodify byte*) RASTER) ← (const nomodify byte) IRQ_RASTER_FIRST -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER_FIRST
    sta RASTER
    // [95] *((const nomodify byte*) IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // [96] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_CLOBBER)(void()) sprites_irq() -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<sprites_irq
    sta HARDWARE_IRQ
    lda #>sprites_irq
    sta HARDWARE_IRQ+1
    // asm { cli  }
    cli
    jmp __breturn
    // sprites_irq_init::@return
  __breturn:
    // [98] return 
    rts
}
  // loop
loop: {
    .label s = 5
    // [100] phi from loop to loop::@1 [phi:loop->loop::@1]
  __b1_from_loop:
    // [100] phi (byte) sin_idx#11 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    jmp __b1
    // loop::@1
  __b1:
    jmp __b2
    // loop::@2
  __b2:
    // [101] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto loop::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b2
    jmp __b3
    // loop::@3
  __b3:
    // [102] (byte) loop::idx#0 ← (byte) sin_idx#11 -- vbuxx=vbuz1 
    ldx.z sin_idx
    // [103] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  __b4_from___b3:
    // [103] phi (byte) loop::idx#2 = (byte) loop::idx#0 [phi:loop::@3->loop::@4#0] -- register_copy 
    // [103] phi (byte) loop::s#2 = (byte) 4 [phi:loop::@3->loop::@4#1] -- vbuz1=vbuc1 
    lda #4
    sta.z s
    jmp __b4
    // [103] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  __b4_from___b4:
    // [103] phi (byte) loop::idx#2 = (byte) loop::idx#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [103] phi (byte) loop::s#2 = (byte) loop::s#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp __b4
    // loop::@4
  __b4:
    // [104] (byte~) loop::$1 ← (byte) loop::s#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z s
    asl
    // [105] *((const nomodify byte*) SPRITES_YPOS + (byte~) loop::$1) ← *((const byte*) SIN + (byte) loop::idx#2) -- pbuc1_derefidx_vbuaa=pbuc2_derefidx_vbuxx 
    tay
    lda SIN,x
    sta SPRITES_YPOS,y
    // [106] (byte) loop::idx#1 ← (byte) loop::idx#2 + (byte) $a -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[$a]
    // [107] (byte) loop::s#1 ← ++ (byte) loop::s#2 -- vbuz1=_inc_vbuz1 
    inc.z s
    // [108] if((byte) loop::s#1!=(byte) 8) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z s
    bne __b4_from___b4
    jmp __b5
    // loop::@5
  __b5:
    // [109] (byte) sin_idx#2 ← ++ (byte) sin_idx#11 -- vbuz1=_inc_vbuz1 
    inc.z sin_idx
    // [100] phi from loop::@5 to loop::@1 [phi:loop::@5->loop::@1]
  __b1_from___b5:
    // [100] phi (byte) sin_idx#11 = (byte) sin_idx#2 [phi:loop::@5->loop::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
SIN:
.var AMPL = 200-21
    .for(var i=0; i<256; i++) {
  	  .byte 51+AMPL/2+sin(toRadians([i*360]/256))*AMPL/2
    }

.pc = $3000 "PLAYFIELD_SPRITES"
// Sprites covering the playfield
PLAYFIELD_SPRITES:
.var sprites = LoadPicture("playfield-sprites.png", List().add($010101, $000000))
	// Put the sprites into memory
	.for(var sy=0;sy<10;sy++) {
	    .var sprite_gfx_y = sy*20
		.for(var sx=0;sx<3;sx++) {
	    	.for (var y=0;y<21; y++) {
	    	    .var gfx_y =  sprite_gfx_y + mod(2100+y-sprite_gfx_y,21)
		    	.for (var c=0; c<3; c++) {
	            	.byte sprites.getSinglecolorByte(sx*3+c,gfx_y)
	            }
	        }
	    	.byte 0
	  	}
	}

.pc = $2800 "PLAYFIELD_CHARSET"
// Address of the charset
PLAYFIELD_CHARSET:
.fill 8,$00 // Place a filled char at the start of the charset
    .import binary "playfield-screen.imap"

.pc = $3800 "SIN_SPRITE"
SIN_SPRITE:
.fill $40, $ff


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __init1
Removing instruction jmp __init1_toSpritePtr1
Removing instruction jmp __init1___b1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __b2
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp toSpritePtr1
Removing instruction jmp __b11
Removing instruction jmp vicSelectGfxBank1
Removing instruction jmp vicSelectGfxBank1_toDd001
Removing instruction jmp vicSelectGfxBank1___b1
Removing instruction jmp toD0181
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __b1
Removing instruction jmp toSpritePtr1
Removing instruction jmp __b4
Removing instruction jmp __b2
Removing instruction jmp __b6
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda SPRITES_MC
Removing instruction lda SPRITES_EXPAND_Y
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b1_from___b4 with __b1
Replacing label __b1_from___b1 with __b1
Replacing label __b4_from___b4 with __b4
Replacing label __b1 with __b2
Removing instruction __init1_toSpritePtr1_from___init1:
Removing instruction __init1_toSpritePtr1:
Removing instruction __b1_from___init1___b1:
Removing instruction main_from___b1:
Removing instruction __breturn:
Removing instruction toSpritePtr1_from___b3:
Removing instruction toSpritePtr1:
Removing instruction vicSelectGfxBank1_toDd001_from_vicSelectGfxBank1:
Removing instruction vicSelectGfxBank1_toDd001:
Removing instruction toD0181_from_vicSelectGfxBank1___b1:
Removing instruction toD0181:
Removing instruction __b1_from___b4:
Removing instruction toSpritePtr1_from___b1:
Removing instruction toSpritePtr1:
Removing instruction __b2_from___b4:
Removing instruction __b6_from___b2:
Removing instruction loop_from___b6:
Removing instruction __b1_from___b1:
Removing instruction __b1:
Removing instruction __b4_from___b4:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __init1:
Removing instruction __init1___b1:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b11:
Removing instruction vicSelectGfxBank1:
Removing instruction vicSelectGfxBank1___b1:
Removing instruction __b3:
Removing instruction __b5:
Removing instruction __b1_from___b5:
Removing instruction __b4:
Removing instruction __b2:
Removing instruction __b6:
Removing instruction __breturn:
Removing instruction __b1_from_sprites_init:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b1_from_loop:
Removing instruction __b3:
Removing instruction __b4_from___b3:
Removing instruction __b5:
Removing instruction __b1_from___b5:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b4
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
(const nomodify byte) BLACK = (byte) 0
(const nomodify struct MOS6526_CIA*) CIA1 = (struct MOS6526_CIA*) 56320
(const nomodify byte*) CIA1_INTERRUPT = (byte*) 56333
(const nomodify struct MOS6526_CIA*) CIA2 = (struct MOS6526_CIA*) 56576
(const nomodify byte) CIA_INTERRUPT_CLEAR = (byte) $7f
(const nomodify byte*) D018 = (byte*) 53272
(const nomodify void()**) HARDWARE_IRQ = (void()**) 65534
(const nomodify byte*) IRQ_ENABLE = (byte*) 53274
(const nomodify byte) IRQ_RASTER = (byte) 1
(const nomodify byte) IRQ_RASTER_FIRST = (const nomodify byte) SPRITES_FIRST_YPOS+(byte) $13
(const nomodify byte*) IRQ_STATUS = (byte*) 53273
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = (byte) $d
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = (byte) 2
(const byte*) PLAYFIELD_CHARSET[]  = kickasm {{ .fill 8,$00 // Place a filled char at the start of the charset
    .import binary "playfield-screen.imap"
 }}
(const nomodify byte*) PLAYFIELD_SCREEN_1 = (byte*) 1024
(const nomodify byte*) PLAYFIELD_SCREEN_2 = (byte*) 11264
(const byte*) PLAYFIELD_SPRITES[(number) $1e*(number) $40]  = kickasm {{ .var sprites = LoadPicture("playfield-sprites.png", List().add($010101, $000000))
	// Put the sprites into memory
	.for(var sy=0;sy<10;sy++) {
	    .var sprite_gfx_y = sy*20
		.for(var sx=0;sx<3;sx++) {
	    	.for (var y=0;y<21; y++) {
	    	    .var gfx_y =  sprite_gfx_y + mod(2100+y-sprite_gfx_y,21)
		    	.for (var c=0; c<3; c++) {
	            	.byte sprites.getSinglecolorByte(sx*3+c,gfx_y)
	            }
	        }
	    	.byte 0
	  	}
	}
 }}
(const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 = (const nomodify byte*) PLAYFIELD_SCREEN_1+(const nomodify word) SPRITE_PTRS
(const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2 = (const nomodify byte*) PLAYFIELD_SCREEN_2+(const nomodify word) SPRITE_PTRS
(const nomodify byte*) PROCPORT = (byte*) 1
(const nomodify byte*) PROCPORT_DDR = (byte*) 0
(const nomodify byte) PROCPORT_DDR_MEMORY_MASK = (byte) 7
(const nomodify byte) PROCPORT_RAM_IO = (byte) 5
(const nomodify byte*) RASTER = (byte*) 53266
(const byte*) SIN[(number) $100]  = kickasm {{ .var AMPL = 200-21
    .for(var i=0; i<256; i++) {
  	  .byte 51+AMPL/2+sin(toRadians([i*360]/256))*AMPL/2
    }
 }}
(const byte*) SIN_SPRITE[(number) $40]  = kickasm {{ .fill $40, $ff
 }}
(const nomodify byte*) SPRITES_COLOR = (byte*) 53287
(const nomodify byte*) SPRITES_ENABLE = (byte*) 53269
(const nomodify byte*) SPRITES_EXPAND_X = (byte*) 53277
(const nomodify byte*) SPRITES_EXPAND_Y = (byte*) 53271
(const nomodify byte) SPRITES_FIRST_YPOS = (byte) $31
(const nomodify byte*) SPRITES_MC = (byte*) 53276
(const nomodify byte*) SPRITES_XPOS = (byte*) 53248
(const nomodify byte*) SPRITES_YPOS = (byte*) 53249
(const nomodify word) SPRITE_PTRS = (word) $3f8
(const nomodify byte*) VIC_CONTROL = (byte*) 53265
(void()) __start()
(label) __start::@1
(label) __start::@return
(label) __start::__init1
(label) __start::__init1_@1
(label) __start::__init1_toSpritePtr1
(byte) __start::__init1_toSpritePtr1_return
(const byte) __start::__init1_toSpritePtr1_return#0 __init1_toSpritePtr1_return = (byte)(word)(const byte*) PLAYFIELD_SPRITES/(byte) $40
(byte*) __start::__init1_toSpritePtr1_sprite
(volatile byte) irq_cnt loadstore zp[1]:10 0.48000000000000004
(volatile byte) irq_raster_next loadstore zp[1]:7 0.44444444444444453
(volatile byte) irq_sprite_ptr loadstore zp[1]:9 0.45161290322580644
(volatile byte) irq_sprite_ypos loadstore zp[1]:8 0.48275862068965525
(void()) loop()
(byte~) loop::$1 reg byte a 20002.0
(label) loop::@1
(label) loop::@2
(label) loop::@3
(label) loop::@4
(label) loop::@5
(byte) loop::idx
(byte) loop::idx#0 reg byte x 2002.0
(byte) loop::idx#1 reg byte x 6667.333333333333
(byte) loop::idx#2 reg byte x 10334.666666666666
(byte) loop::s
(byte) loop::s#1 s zp[1]:5 15001.5
(byte) loop::s#2 s zp[1]:5 7500.75
(void()) main()
(byte~) main::$6 reg byte a 202.0
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@return
(byte) main::s
(byte) main::s#1 reg byte y 151.5
(byte) main::s#2 reg byte y 60.6
(byte) main::s2
(byte) main::s2#0 reg byte x 151.5
(label) main::toD0181
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(const byte) main::toD0181_return#0 toD0181_return = >(word)(const nomodify byte*) PLAYFIELD_SCREEN_1&(word) $3fff*(byte) 4|>(word)(const byte*) PLAYFIELD_CHARSET/(byte) 4&(byte) $f
(byte*) main::toD0181_screen
(label) main::toSpritePtr1
(byte) main::toSpritePtr1_return
(const byte) main::toSpritePtr1_return#0 toSpritePtr1_return = (byte)(word)(const byte*) SIN_SPRITE/(byte) $40
(byte*) main::toSpritePtr1_sprite
(label) main::vicSelectGfxBank1
(label) main::vicSelectGfxBank1_@1
(byte*) main::vicSelectGfxBank1_gfx
(label) main::vicSelectGfxBank1_toDd001
(byte*) main::vicSelectGfxBank1_toDd001_gfx
(byte) main::vicSelectGfxBank1_toDd001_return
(const byte) main::vicSelectGfxBank1_toDd001_return#0 vicSelectGfxBank1_toDd001_return = (byte) 3
(byte) main::xpos
(byte) main::xpos#1 xpos zp[1]:2 50.5
(byte) main::xpos#2 xpos zp[1]:2 37.875
(byte) main::ypos
(byte) main::ypos#1 ypos zp[1]:3 67.33333333333333
(byte) main::ypos#2 ypos zp[1]:3 33.666666666666664
(volatile byte) render_screen_showing loadstore zp[1]:6 0.4
(byte) sin_idx
(byte) sin_idx#11 sin_idx zp[1]:4 333.6666666666667
(byte) sin_idx#2 sin_idx zp[1]:4 2002.0
(void()) sprites_init()
(label) sprites_init::@1
(label) sprites_init::@return
(byte) sprites_init::s
(byte) sprites_init::s#1 reg byte y 1501.5
(byte) sprites_init::s#2 reg byte y 800.8
(byte) sprites_init::s2
(byte) sprites_init::s2#0 reg byte x 2002.0
(byte) sprites_init::xpos
(byte) sprites_init::xpos#1 xpos zp[1]:5 667.3333333333334
(byte) sprites_init::xpos#2 xpos zp[1]:5 750.75
interrupt(HARDWARE_CLOBBER)(void()) sprites_irq()
(byte~) sprites_irq::$0 reg byte x 4.0
(label) sprites_irq::@1
(label) sprites_irq::@10
(label) sprites_irq::@11
(label) sprites_irq::@2
(label) sprites_irq::@3
(label) sprites_irq::@4
(label) sprites_irq::@5
(label) sprites_irq::@6
(label) sprites_irq::@7
(label) sprites_irq::@8
(label) sprites_irq::@9
(label) sprites_irq::@return
(byte) sprites_irq::ptr
(byte) sprites_irq::ptr#0 reg byte x 2.5
(byte) sprites_irq::ptr#1 reg byte x 2.6666666666666665
(byte) sprites_irq::ptr#2 reg byte a 4.0
(byte) sprites_irq::ptr#3 reg byte a 2.6666666666666665
(byte) sprites_irq::ptr#4 reg byte a 4.0
(volatile byte) sprites_irq::raster_sprite_gfx_modify loadstore zp[1]:11 6.5
(label) sprites_irq::toSpritePtr1
(byte) sprites_irq::toSpritePtr1_return
(const byte) sprites_irq::toSpritePtr1_return#0 toSpritePtr1_return = (byte)(word)(const byte*) PLAYFIELD_SPRITES/(byte) $40
(byte*) sprites_irq::toSpritePtr1_sprite
(byte) sprites_irq::ypos
(byte) sprites_irq::ypos#0 reg byte a 2.5
(void()) sprites_irq_init()
(label) sprites_irq_init::@return

reg byte y [ main::s#2 main::s#1 ]
zp[1]:2 [ main::xpos#2 main::xpos#1 ]
zp[1]:3 [ main::ypos#2 main::ypos#1 ]
reg byte y [ sprites_init::s#2 sprites_init::s#1 ]
zp[1]:4 [ sin_idx#11 sin_idx#2 ]
zp[1]:5 [ loop::s#2 loop::s#1 sprites_init::xpos#2 sprites_init::xpos#1 ]
reg byte x [ loop::idx#2 loop::idx#0 loop::idx#1 ]
zp[1]:6 [ render_screen_showing ]
zp[1]:7 [ irq_raster_next ]
zp[1]:8 [ irq_sprite_ypos ]
zp[1]:9 [ irq_sprite_ptr ]
zp[1]:10 [ irq_cnt ]
reg byte a [ sprites_irq::ypos#0 ]
reg byte x [ sprites_irq::$0 ]
zp[1]:11 [ sprites_irq::raster_sprite_gfx_modify ]
reg byte x [ sprites_irq::ptr#0 ]
reg byte a [ sprites_irq::ptr#3 ]
reg byte a [ sprites_irq::ptr#4 ]
reg byte x [ sprites_irq::ptr#1 ]
reg byte a [ sprites_irq::ptr#2 ]
reg byte x [ main::s2#0 ]
reg byte a [ main::$6 ]
reg byte x [ sprites_init::s2#0 ]
reg byte a [ loop::$1 ]


FINAL ASSEMBLER
Score: 6542

  // File Comments
// Tetris Game for the Commodore 64
// A sprite multiplexer covering the playfield with a black layer to allow for 3 single-pixel colors
// Commodore 64 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__start)
.pc = $80d "Program"
  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The offset of the sprite pointers from the screen start address
  .const SPRITE_PTRS = $3f8
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  // The colors of the C64
  .const BLACK = 0
  // The Y-position of the first sprite row
  .const SPRITES_FIRST_YPOS = $31
  // The line of the first IRQ
  .const IRQ_RASTER_FIRST = SPRITES_FIRST_YPOS+$13
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = 2
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_COLOR = $d027
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label RASTER = $d012
  .label VIC_CONTROL = $d011
  .label D018 = $d018
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#1 Interrupt for reading in ASM
  .label CIA1_INTERRUPT = $dc0d
  // The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Address of the first screen
  .label PLAYFIELD_SCREEN_1 = $400
  // Address of the second screen
  .label PLAYFIELD_SCREEN_2 = $2c00
  // Screen Sprite pointers on screen 1
  .label PLAYFIELD_SPRITE_PTRS_1 = PLAYFIELD_SCREEN_1+SPRITE_PTRS
  // Screen Sprite pointers on screen 2
  .label PLAYFIELD_SPRITE_PTRS_2 = PLAYFIELD_SCREEN_2+SPRITE_PTRS
  // The screen currently being showed to the user. 0x00 for screen 1 / 0x20 for screen 2.
  .label render_screen_showing = 6
  // The raster line of the next IRQ
  .label irq_raster_next = 7
  // Y-pos of the sprites on the next IRQ
  .label irq_sprite_ypos = 8
  // Index of the sprites to show on the next IRQ
  .label irq_sprite_ptr = 9
  // Counting the 10 IRQs
  .label irq_cnt = $a
  .label sin_idx = 4
  // __start
__start: {
    .const __init1_toSpritePtr1_return = $ff&PLAYFIELD_SPRITES/$40
    // __start::__init1
    // render_screen_showing = 0
    // [1] (volatile byte) render_screen_showing ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z render_screen_showing
    // irq_raster_next = IRQ_RASTER_FIRST
    // [2] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST -- vbuz1=vbuc1 
    lda #IRQ_RASTER_FIRST
    sta.z irq_raster_next
    // irq_sprite_ypos = SPRITES_FIRST_YPOS + 21
    // [3] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS+(byte) $15 -- vbuz1=vbuc1 
    lda #SPRITES_FIRST_YPOS+$15
    sta.z irq_sprite_ypos
    // [4] phi from __start::__init1 to __start::__init1_toSpritePtr1 [phi:__start::__init1->__start::__init1_toSpritePtr1]
    // __start::__init1_toSpritePtr1
    // __start::__init1_@1
    // irq_sprite_ptr = toSpritePtr(PLAYFIELD_SPRITES) + 3
    // [5] (volatile byte) irq_sprite_ptr ← (const byte) __start::__init1_toSpritePtr1_return#0+(byte) 3 -- vbuz1=vbuc1 
    lda #__init1_toSpritePtr1_return+3
    sta.z irq_sprite_ptr
    // irq_cnt = 0
    // [6] (volatile byte) irq_cnt ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z irq_cnt
    // [7] phi from __start::__init1_@1 to __start::@1 [phi:__start::__init1_@1->__start::@1]
    // __start::@1
    // [8] call main 
    // [50] phi from __start::@1 to main [phi:__start::@1->main]
    jsr main
    // __start::@return
    // [9] return 
    rts
}
  // sprites_irq
// Raster Interrupt Routine - sets up the sprites covering the playfield
// Repeats 10 timers every 2 lines from line IRQ_RASTER_FIRST
// Utilizes duplicated gfx in the sprites to allow for some leeway in updating the sprite pointers
sprites_irq: {
    .const toSpritePtr1_return = $ff&PLAYFIELD_SPRITES/$40
    .label raster_sprite_gfx_modify = $b
    // entry interrupt(HARDWARE_CLOBBER)
    sta rega+1
    stx regx+1
    // asm
    // asm { cld  }
    //(*BG_COLOR)++;
    // Clear decimal flag (because it is used by the score algorithm)
    cld
    // ypos = irq_sprite_ypos
    // [11] (byte) sprites_irq::ypos#0 ← (volatile byte) irq_sprite_ypos -- vbuaa=vbuz1 
    // Place the sprites
    lda.z irq_sprite_ypos
    // SPRITES_YPOS[0] = ypos
    // [12] *((const nomodify byte*) SPRITES_YPOS) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuaa 
    sta SPRITES_YPOS
    // SPRITES_YPOS[2] = ypos
    // [13] *((const nomodify byte*) SPRITES_YPOS+(byte) 2) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuaa 
    sta SPRITES_YPOS+2
    // SPRITES_YPOS[4] = ypos
    // [14] *((const nomodify byte*) SPRITES_YPOS+(byte) 4) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuaa 
    sta SPRITES_YPOS+4
    // SPRITES_YPOS[6] = ypos
    // [15] *((const nomodify byte*) SPRITES_YPOS+(byte) 6) ← (byte) sprites_irq::ypos#0 -- _deref_pbuc1=vbuaa 
    sta SPRITES_YPOS+6
    // irq_raster_next+1
    // [16] (byte~) sprites_irq::$0 ← (volatile byte) irq_raster_next + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z irq_raster_next
    inx
    // raster_sprite_gfx_modify = irq_raster_next+1
    // [17] (volatile byte) sprites_irq::raster_sprite_gfx_modify ← (byte~) sprites_irq::$0 -- vbuz1=vbuxx 
    // Wait for the y-position before changing sprite pointers
    stx.z raster_sprite_gfx_modify
    // sprites_irq::@8
  __b8:
    // while(*RASTER<raster_sprite_gfx_modify)
    // [18] if(*((const nomodify byte*) RASTER)<(volatile byte) sprites_irq::raster_sprite_gfx_modify) goto sprites_irq::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z raster_sprite_gfx_modify
    bcc __b8
    // sprites_irq::@9
    // ptr = irq_sprite_ptr
    // [19] (byte) sprites_irq::ptr#0 ← (volatile byte) irq_sprite_ptr -- vbuxx=vbuz1 
    ldx.z irq_sprite_ptr
    // if(render_screen_showing==0)
    // [20] if((volatile byte) render_screen_showing==(byte) 0) goto sprites_irq::@1 -- vbuz1_eq_0_then_la1 
    lda.z render_screen_showing
    cmp #0
    beq __b1
    // sprites_irq::@10
    // PLAYFIELD_SPRITE_PTRS_2[0] = ptr++
    // [21] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2) ← (byte) sprites_irq::ptr#0 -- _deref_pbuc1=vbuxx 
    stx PLAYFIELD_SPRITE_PTRS_2
    // PLAYFIELD_SPRITE_PTRS_2[0] = ptr++;
    // [22] (byte) sprites_irq::ptr#3 ← ++ (byte) sprites_irq::ptr#0 -- vbuaa=_inc_vbuxx 
    inx
    txa
    // PLAYFIELD_SPRITE_PTRS_2[1] = ptr
    // [23] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 1) ← (byte) sprites_irq::ptr#3 -- _deref_pbuc1=vbuaa 
    sta PLAYFIELD_SPRITE_PTRS_2+1
    // PLAYFIELD_SPRITE_PTRS_2[2] = ptr++
    // [24] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 2) ← (byte) sprites_irq::ptr#3 -- _deref_pbuc1=vbuaa 
    sta PLAYFIELD_SPRITE_PTRS_2+2
    // PLAYFIELD_SPRITE_PTRS_2[2] = ptr++;
    // [25] (byte) sprites_irq::ptr#4 ← ++ (byte) sprites_irq::ptr#3 -- vbuaa=_inc_vbuaa 
    clc
    adc #1
    // PLAYFIELD_SPRITE_PTRS_2[3] = ptr
    // [26] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_2+(byte) 3) ← (byte) sprites_irq::ptr#4 -- _deref_pbuc1=vbuaa 
    sta PLAYFIELD_SPRITE_PTRS_2+3
    // sprites_irq::@2
  __b2:
    // ++irq_cnt;
    // [27] (volatile byte) irq_cnt ← ++ (volatile byte) irq_cnt -- vbuz1=_inc_vbuz1 
    inc.z irq_cnt
    // if(irq_cnt==9)
    // [28] if((volatile byte) irq_cnt==(byte) 9) goto sprites_irq::@3 -- vbuz1_eq_vbuc1_then_la1 
    lda #9
    cmp.z irq_cnt
    beq __b3
    // sprites_irq::@6
    // if(irq_cnt==10)
    // [29] if((volatile byte) irq_cnt==(byte) $a) goto sprites_irq::@4 -- vbuz1_eq_vbuc1_then_la1 
    lda #$a
    cmp.z irq_cnt
    beq __b4
    // sprites_irq::@7
    // irq_raster_next += 20
    // [30] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $14 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_raster_next
    axs #-[$14]
    stx.z irq_raster_next
    // irq_sprite_ypos += 21
    // [31] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ypos
    axs #-[$15]
    stx.z irq_sprite_ypos
    // irq_sprite_ptr += 3
    // [32] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ptr
    axs #-[3]
    stx.z irq_sprite_ptr
    // sprites_irq::@5
  __b5:
    // *RASTER = irq_raster_next
    // [33] *((const nomodify byte*) RASTER) ← (volatile byte) irq_raster_next -- _deref_pbuc1=vbuz1 
    // Setup next interrupt
    lda.z irq_raster_next
    sta RASTER
    // *IRQ_STATUS = IRQ_RASTER
    // [34] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ and setup the next one
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // sprites_irq::@return
    // }
    // [35] return  - exit interrupt(HARDWARE_CLOBBER)
  rega:
    lda #00
  regx:
    ldx #00
    rti
    // sprites_irq::@4
  __b4:
    // irq_cnt = 0
    // [36] (volatile byte) irq_cnt ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z irq_cnt
    // irq_raster_next = IRQ_RASTER_FIRST
    // [37] (volatile byte) irq_raster_next ← (const nomodify byte) IRQ_RASTER_FIRST -- vbuz1=vbuc1 
    lda #IRQ_RASTER_FIRST
    sta.z irq_raster_next
    // irq_sprite_ypos += 21
    // [38] (volatile byte) irq_sprite_ypos ← (volatile byte) irq_sprite_ypos + (byte) $15 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ypos
    axs #-[$15]
    stx.z irq_sprite_ypos
    // irq_sprite_ptr += 3
    // [39] (volatile byte) irq_sprite_ptr ← (volatile byte) irq_sprite_ptr + (byte) 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_sprite_ptr
    axs #-[3]
    stx.z irq_sprite_ptr
    jmp __b5
    // sprites_irq::@3
  __b3:
    // irq_raster_next += 21
    // [40] (volatile byte) irq_raster_next ← (volatile byte) irq_raster_next + (byte) $15 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z irq_raster_next
    axs #-[$15]
    stx.z irq_raster_next
    // irq_sprite_ypos = SPRITES_FIRST_YPOS
    // [41] (volatile byte) irq_sprite_ypos ← (const nomodify byte) SPRITES_FIRST_YPOS -- vbuz1=vbuc1 
    lda #SPRITES_FIRST_YPOS
    sta.z irq_sprite_ypos
    // [42] phi from sprites_irq::@3 to sprites_irq::toSpritePtr1 [phi:sprites_irq::@3->sprites_irq::toSpritePtr1]
    // sprites_irq::toSpritePtr1
    // sprites_irq::@11
    // irq_sprite_ptr = toSpritePtr(PLAYFIELD_SPRITES)
    // [43] (volatile byte) irq_sprite_ptr ← (const byte) sprites_irq::toSpritePtr1_return#0 -- vbuz1=vbuc1 
    lda #toSpritePtr1_return
    sta.z irq_sprite_ptr
    jmp __b5
    // sprites_irq::@1
  __b1:
    // PLAYFIELD_SPRITE_PTRS_1[0] = ptr++
    // [44] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1) ← (byte) sprites_irq::ptr#0 -- _deref_pbuc1=vbuxx 
    stx PLAYFIELD_SPRITE_PTRS_1
    // PLAYFIELD_SPRITE_PTRS_1[0] = ptr++;
    // [45] (byte) sprites_irq::ptr#1 ← ++ (byte) sprites_irq::ptr#0 -- vbuxx=_inc_vbuxx 
    inx
    // PLAYFIELD_SPRITE_PTRS_1[1] = ptr
    // [46] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 1) ← (byte) sprites_irq::ptr#1 -- _deref_pbuc1=vbuxx 
    stx PLAYFIELD_SPRITE_PTRS_1+1
    // PLAYFIELD_SPRITE_PTRS_1[2] = ptr++
    // [47] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 2) ← (byte) sprites_irq::ptr#1 -- _deref_pbuc1=vbuxx 
    stx PLAYFIELD_SPRITE_PTRS_1+2
    // PLAYFIELD_SPRITE_PTRS_1[2] = ptr++;
    // [48] (byte) sprites_irq::ptr#2 ← ++ (byte) sprites_irq::ptr#1 -- vbuaa=_inc_vbuxx 
    inx
    txa
    // PLAYFIELD_SPRITE_PTRS_1[3] = ptr
    // [49] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1+(byte) 3) ← (byte) sprites_irq::ptr#2 -- _deref_pbuc1=vbuaa 
    sta PLAYFIELD_SPRITE_PTRS_1+3
    jmp __b2
}
  // main
main: {
    .const toSpritePtr1_return = $ff&SIN_SPRITE/$40
    .const vicSelectGfxBank1_toDd001_return = 3
    .const toD0181_return = (>(PLAYFIELD_SCREEN_1&$3fff)*4)|(>PLAYFIELD_CHARSET)/4&$f
    .label xpos = 2
    .label ypos = 3
    // main::vicSelectGfxBank1
    // CIA2->PORT_A_DDR = %00000011
    // [51] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR
    // [52] phi from main::vicSelectGfxBank1 to main::vicSelectGfxBank1_toDd001 [phi:main::vicSelectGfxBank1->main::vicSelectGfxBank1_toDd001]
    // main::vicSelectGfxBank1_toDd001
    // main::vicSelectGfxBank1_@1
    // CIA2->PORT_A = toDd00(gfx)
    // [53] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2) ← (const byte) main::vicSelectGfxBank1_toDd001_return#0 -- _deref_pbuc1=vbuc2 
    lda #vicSelectGfxBank1_toDd001_return
    sta CIA2
    // [54] phi from main::vicSelectGfxBank1_@1 to main::toD0181 [phi:main::vicSelectGfxBank1_@1->main::toD0181]
    // main::toD0181
    // main::@3
    // *D018 = toD018(PLAYFIELD_SCREEN_1, PLAYFIELD_CHARSET)
    // [55] *((const nomodify byte*) D018) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
    // sprites_init()
    // [56] call sprites_init 
    jsr sprites_init
    // main::@5
    // *SPRITES_ENABLE = 0xff
    // [57] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    lda #$ff
    sta SPRITES_ENABLE
    // [58] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
    // [58] phi (byte) main::ypos#2 = (byte) $32 [phi:main::@5->main::@1#0] -- vbuz1=vbuc1 
    lda #$32
    sta.z ypos
    // [58] phi (byte) main::xpos#2 = (byte) $18 [phi:main::@5->main::@1#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z xpos
    // [58] phi (byte) main::s#2 = (byte) 4 [phi:main::@5->main::@1#2] -- vbuyy=vbuc1 
    ldy #4
    // [58] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
    // [58] phi (byte) main::ypos#2 = (byte) main::ypos#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [58] phi (byte) main::xpos#2 = (byte) main::xpos#1 [phi:main::@4->main::@1#1] -- register_copy 
    // [58] phi (byte) main::s#2 = (byte) main::s#1 [phi:main::@4->main::@1#2] -- register_copy 
    // main::@1
  __b1:
    // s2 = s*2
    // [59] (byte) main::s2#0 ← (byte) main::s#2 << (byte) 1 -- vbuxx=vbuyy_rol_1 
    tya
    asl
    tax
    // SPRITES_XPOS[s2] = xpos
    // [60] *((const nomodify byte*) SPRITES_XPOS + (byte) main::s2#0) ← (byte) main::xpos#2 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z xpos
    sta SPRITES_XPOS,x
    // SPRITES_YPOS[s2] = ypos
    // [61] *((const nomodify byte*) SPRITES_YPOS + (byte) main::s2#0) ← (byte) main::ypos#2 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z ypos
    sta SPRITES_YPOS,x
    // s-3
    // [62] (byte~) main::$6 ← (byte) main::s#2 - (byte) 3 -- vbuaa=vbuyy_minus_vbuc1 
    tya
    sec
    sbc #3
    // SPRITES_COLOR[s] = s-3
    // [63] *((const nomodify byte*) SPRITES_COLOR + (byte) main::s#2) ← (byte~) main::$6 -- pbuc1_derefidx_vbuyy=vbuaa 
    sta SPRITES_COLOR,y
    // [64] phi from main::@1 to main::toSpritePtr1 [phi:main::@1->main::toSpritePtr1]
    // main::toSpritePtr1
    // main::@4
    // PLAYFIELD_SPRITE_PTRS_1[s] = toSpritePtr(SIN_SPRITE)
    // [65] *((const nomodify byte*) PLAYFIELD_SPRITE_PTRS_1 + (byte) main::s#2) ← (const byte) main::toSpritePtr1_return#0 -- pbuc1_derefidx_vbuyy=vbuc2 
    lda #toSpritePtr1_return
    sta PLAYFIELD_SPRITE_PTRS_1,y
    // xpos +=  24
    // [66] (byte) main::xpos#1 ← (byte) main::xpos#2 + (byte) $18 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z xpos
    axs #-[$18]
    stx.z xpos
    // ypos +=  24
    // [67] (byte) main::ypos#1 ← (byte) main::ypos#2 + (byte) $18 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z ypos
    axs #-[$18]
    stx.z ypos
    // for(char s:4..7)
    // [68] (byte) main::s#1 ← ++ (byte) main::s#2 -- vbuyy=_inc_vbuyy 
    iny
    // [69] if((byte) main::s#1!=(byte) 8) goto main::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #8
    bne __b1
    // [70] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
    // main::@2
    // sprites_irq_init()
    // [71] call sprites_irq_init 
    jsr sprites_irq_init
    // [72] phi from main::@2 to main::@6 [phi:main::@2->main::@6]
    // main::@6
    // loop()
    // [73] call loop 
    // [99] phi from main::@6 to loop [phi:main::@6->loop]
    jsr loop
    // main::@return
    // }
    // [74] return 
    rts
}
  // sprites_init
// Setup the sprites
sprites_init: {
    .label xpos = 5
    // *SPRITES_ENABLE = %00001111
    // [75] *((const nomodify byte*) SPRITES_ENABLE) ← (byte) $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta SPRITES_ENABLE
    // *SPRITES_MC = 0
    // [76] *((const nomodify byte*) SPRITES_MC) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    // *SPRITES_EXPAND_Y = *SPRITES_MC = 0
    // [77] *((const nomodify byte*) SPRITES_EXPAND_Y) ← *((const nomodify byte*) SPRITES_MC) -- _deref_pbuc1=_deref_pbuc2 
    sta SPRITES_EXPAND_Y
    // *SPRITES_EXPAND_X = *SPRITES_EXPAND_Y = *SPRITES_MC = 0
    // [78] *((const nomodify byte*) SPRITES_EXPAND_X) ← *((const nomodify byte*) SPRITES_EXPAND_Y) -- _deref_pbuc1=_deref_pbuc2 
    sta SPRITES_EXPAND_X
    // [79] phi from sprites_init to sprites_init::@1 [phi:sprites_init->sprites_init::@1]
    // [79] phi (byte) sprites_init::xpos#2 = (byte)(number) $18+(number) $f*(number) 8 [phi:sprites_init->sprites_init::@1#0] -- vbuz1=vbuc1 
    lda #$18+$f*8
    sta.z xpos
    // [79] phi (byte) sprites_init::s#2 = (byte) 0 [phi:sprites_init->sprites_init::@1#1] -- vbuyy=vbuc1 
    ldy #0
    // [79] phi from sprites_init::@1 to sprites_init::@1 [phi:sprites_init::@1->sprites_init::@1]
    // [79] phi (byte) sprites_init::xpos#2 = (byte) sprites_init::xpos#1 [phi:sprites_init::@1->sprites_init::@1#0] -- register_copy 
    // [79] phi (byte) sprites_init::s#2 = (byte) sprites_init::s#1 [phi:sprites_init::@1->sprites_init::@1#1] -- register_copy 
    // sprites_init::@1
  __b1:
    // s2 = s*2
    // [80] (byte) sprites_init::s2#0 ← (byte) sprites_init::s#2 << (byte) 1 -- vbuxx=vbuyy_rol_1 
    tya
    asl
    tax
    // SPRITES_XPOS[s2] = xpos
    // [81] *((const nomodify byte*) SPRITES_XPOS + (byte) sprites_init::s2#0) ← (byte) sprites_init::xpos#2 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z xpos
    sta SPRITES_XPOS,x
    // SPRITES_COLOR[s] = BLACK
    // [82] *((const nomodify byte*) SPRITES_COLOR + (byte) sprites_init::s#2) ← (const nomodify byte) BLACK -- pbuc1_derefidx_vbuyy=vbuc2 
    lda #BLACK
    sta SPRITES_COLOR,y
    // xpos = xpos+24
    // [83] (byte) sprites_init::xpos#1 ← (byte) sprites_init::xpos#2 + (byte) $18 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z xpos
    axs #-[$18]
    stx.z xpos
    // for(char s:0..3)
    // [84] (byte) sprites_init::s#1 ← ++ (byte) sprites_init::s#2 -- vbuyy=_inc_vbuyy 
    iny
    // [85] if((byte) sprites_init::s#1!=(byte) 4) goto sprites_init::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #4
    bne __b1
    // sprites_init::@return
    // }
    // [86] return 
    rts
}
  // sprites_irq_init
// Setup the IRQ
sprites_irq_init: {
    // asm
    // asm { sei  }
    sei
    // *IRQ_STATUS = IRQ_RASTER
    // [88] *((const nomodify byte*) IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge any IRQ and setup the next one
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // asm
    // asm { ldaCIA1_INTERRUPT  }
    lda CIA1_INTERRUPT
    // *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK
    // [90] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // Disable kernal & basic
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // *PROCPORT = PROCPORT_RAM_IO
    // [91] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // CIA1->INTERRUPT = CIA_INTERRUPT_CLEAR
    // [92] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // *VIC_CONTROL &=0x7f
    // [93] *((const nomodify byte*) VIC_CONTROL) ← *((const nomodify byte*) VIC_CONTROL) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
    // *RASTER = IRQ_RASTER_FIRST
    // [94] *((const nomodify byte*) RASTER) ← (const nomodify byte) IRQ_RASTER_FIRST -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER_FIRST
    sta RASTER
    // *IRQ_ENABLE = IRQ_RASTER
    // [95] *((const nomodify byte*) IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // *HARDWARE_IRQ = &sprites_irq
    // [96] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_CLOBBER)(void()) sprites_irq() -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<sprites_irq
    sta HARDWARE_IRQ
    lda #>sprites_irq
    sta HARDWARE_IRQ+1
    // asm
    // asm { cli  }
    cli
    // sprites_irq_init::@return
    // }
    // [98] return 
    rts
}
  // loop
loop: {
    .label s = 5
    // [100] phi from loop to loop::@1 [phi:loop->loop::@1]
    // [100] phi (byte) sin_idx#11 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    // loop::@1
    // loop::@2
  __b2:
    // while (*RASTER!=0xff)
    // [101] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto loop::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b2
    // loop::@3
    // idx = sin_idx
    // [102] (byte) loop::idx#0 ← (byte) sin_idx#11 -- vbuxx=vbuz1 
    ldx.z sin_idx
    // [103] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
    // [103] phi (byte) loop::idx#2 = (byte) loop::idx#0 [phi:loop::@3->loop::@4#0] -- register_copy 
    // [103] phi (byte) loop::s#2 = (byte) 4 [phi:loop::@3->loop::@4#1] -- vbuz1=vbuc1 
    lda #4
    sta.z s
    // [103] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
    // [103] phi (byte) loop::idx#2 = (byte) loop::idx#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [103] phi (byte) loop::s#2 = (byte) loop::s#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    // loop::@4
  __b4:
    // s*2
    // [104] (byte~) loop::$1 ← (byte) loop::s#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z s
    asl
    // SPRITES_YPOS[s*2] = SIN[idx]
    // [105] *((const nomodify byte*) SPRITES_YPOS + (byte~) loop::$1) ← *((const byte*) SIN + (byte) loop::idx#2) -- pbuc1_derefidx_vbuaa=pbuc2_derefidx_vbuxx 
    tay
    lda SIN,x
    sta SPRITES_YPOS,y
    // idx += 10
    // [106] (byte) loop::idx#1 ← (byte) loop::idx#2 + (byte) $a -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[$a]
    // for(char s:4..7)
    // [107] (byte) loop::s#1 ← ++ (byte) loop::s#2 -- vbuz1=_inc_vbuz1 
    inc.z s
    // [108] if((byte) loop::s#1!=(byte) 8) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z s
    bne __b4
    // loop::@5
    // sin_idx++;
    // [109] (byte) sin_idx#2 ← ++ (byte) sin_idx#11 -- vbuz1=_inc_vbuz1 
    inc.z sin_idx
    // [100] phi from loop::@5 to loop::@1 [phi:loop::@5->loop::@1]
    // [100] phi (byte) sin_idx#11 = (byte) sin_idx#2 [phi:loop::@5->loop::@1#0] -- register_copy 
    jmp __b2
}
  // File Data
SIN:
.var AMPL = 200-21
    .for(var i=0; i<256; i++) {
  	  .byte 51+AMPL/2+sin(toRadians([i*360]/256))*AMPL/2
    }

.pc = $3000 "PLAYFIELD_SPRITES"
// Sprites covering the playfield
PLAYFIELD_SPRITES:
.var sprites = LoadPicture("playfield-sprites.png", List().add($010101, $000000))
	// Put the sprites into memory
	.for(var sy=0;sy<10;sy++) {
	    .var sprite_gfx_y = sy*20
		.for(var sx=0;sx<3;sx++) {
	    	.for (var y=0;y<21; y++) {
	    	    .var gfx_y =  sprite_gfx_y + mod(2100+y-sprite_gfx_y,21)
		    	.for (var c=0; c<3; c++) {
	            	.byte sprites.getSinglecolorByte(sx*3+c,gfx_y)
	            }
	        }
	    	.byte 0
	  	}
	}

.pc = $2800 "PLAYFIELD_CHARSET"
// Address of the charset
PLAYFIELD_CHARSET:
.fill 8,$00 // Place a filled char at the start of the charset
    .import binary "playfield-screen.imap"

.pc = $3800 "SIN_SPRITE"
SIN_SPRITE:
.fill $40, $ff


