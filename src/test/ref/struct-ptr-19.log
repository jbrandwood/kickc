Setting struct to load/store in variable affected by address-of main::ptr = &main::point
Inlined call call __init 

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  idx#16 = phi( __start::@1/idx#17 )
  *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT)
  main::point = struct-unwound {*(&main::point)}
  print::p_x#0 = *((byte*)&main::point+OFFSET_STRUCT_POINT_X)
  print::p_y#0 = *((byte*)&main::point+OFFSET_STRUCT_POINT_Y)
  call print 
  to:main::@1
main::@1: scope:[main]  from main
  idx#9 = phi( main/idx#5 )
  idx#0 = idx#9
  main::$4 = (byte*)main::ptr
  main::$2 = main::$4 + OFFSET_STRUCT_POINT_X
  main::$5 = (byte*)main::ptr
  main::$3 = main::$5 + OFFSET_STRUCT_POINT_Y
  print::p_x#1 = *main::$2
  print::p_y#1 = *main::$3
  call print 
  to:main::@2
main::@2: scope:[main]  from main::@1
  idx#10 = phi( main::@1/idx#5 )
  idx#1 = idx#10
  to:main::@return
main::@return: scope:[main]  from main::@2
  idx#11 = phi( main::@2/idx#1 )
  idx#2 = idx#11
  return 
  to:@return

void print(byte print::p_x , byte print::p_y)
print: scope:[print]  from main main::@1
  print::p_y#2 = phi( main/print::p_y#0, main::@1/print::p_y#1 )
  idx#12 = phi( main/idx#16, main::@1/idx#0 )
  print::p_x#2 = phi( main/print::p_x#0, main::@1/print::p_x#1 )
  SCREEN[idx#12] = print::p_x#2
  idx#3 = ++ idx#12
  SCREEN[idx#3] = print::p_y#2
  idx#4 = ++ idx#3
  to:print::@return
print::@return: scope:[print]  from print
  idx#13 = phi( print/idx#4 )
  idx#5 = idx#13
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  idx#6 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  idx#17 = phi( __start::__init1/idx#6 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  idx#14 = phi( __start::@1/idx#2 )
  idx#7 = idx#14
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  idx#15 = phi( __start::@2/idx#7 )
  idx#8 = idx#15
  return 
  to:@return

SYMBOL TABLE SSA
constant struct Point $0 = { x: 1, y: 2 }
constant byte OFFSET_STRUCT_POINT_X = 0
constant byte OFFSET_STRUCT_POINT_Y = 1
constant byte* const SCREEN = (byte*)$400
constant byte SIZEOF_STRUCT_POINT = 2
void __start()
byte idx
byte idx#0
byte idx#1
byte idx#10
byte idx#11
byte idx#12
byte idx#13
byte idx#14
byte idx#15
byte idx#16
byte idx#17
byte idx#2
byte idx#3
byte idx#4
byte idx#5
byte idx#6
byte idx#7
byte idx#8
byte idx#9
void main()
byte*~ main::$2
byte*~ main::$3
byte*~ main::$4
byte*~ main::$5
volatile struct Point main::point loadstore
constant struct Point* main::ptr = &main::point
void print(byte print::p_x , byte print::p_y)
struct Point print::p
byte print::p_x
byte print::p_x#0
byte print::p_x#1
byte print::p_x#2
byte print::p_y
byte print::p_y#0
byte print::p_y#1
byte print::p_y#2

Simplifying constant pointer cast (byte*) 1024
Successful SSA optimization PassNCastSimplification
Alias idx#0 = idx#9 
Alias idx#1 = idx#10 idx#11 idx#2 
Alias idx#13 = idx#4 idx#5 
Alias idx#17 = idx#6 
Alias idx#14 = idx#7 idx#15 idx#8 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values idx#16 idx#17
Identical Phi Values idx#0 idx#13
Identical Phi Values idx#1 idx#13
Identical Phi Values idx#14 idx#1
Successful SSA optimization Pass2IdenticalPhiElimination
Removing C-classic struct-unwound assignment [2] main::point = struct-unwound {*(&main::point)}
Constant right-side identified [7] main::$4 = (byte*)main::ptr
Constant right-side identified [9] main::$5 = (byte*)main::ptr
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::$4 = (byte*)main::ptr
Constant main::$5 = (byte*)main::ptr
Constant idx#17 = 0
Successful SSA optimization Pass2ConstantIdentification
Converting *(pointer+n) to pointer[n] [11] print::p_x#1 = *main::$2  -- main::$4[OFFSET_STRUCT_POINT_X]
Converting *(pointer+n) to pointer[n] [12] print::p_y#1 = *main::$3  -- main::$5[OFFSET_STRUCT_POINT_Y]
Successful SSA optimization Pass2InlineDerefIdx
Simplifying expression containing zero (byte*)&main::point in [3] print::p_x#0 = *((byte*)&main::point+OFFSET_STRUCT_POINT_X)
Simplifying expression containing zero main::$4 in [8] main::$2 = main::$4 + OFFSET_STRUCT_POINT_X
Simplifying expression containing zero main::$4 in [11] print::p_x#1 = main::$4[OFFSET_STRUCT_POINT_X]
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable main::$2 and assignment [4] main::$2 = main::$4
Eliminating unused variable main::$3 and assignment [5] main::$3 = main::$5 + OFFSET_STRUCT_POINT_Y
Eliminating unused constant OFFSET_STRUCT_POINT_X
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings idx#17
Constant inlined main::$5 = (byte*)main::ptr
Constant inlined idx#17 = 0
Constant inlined main::$4 = (byte*)main::ptr
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *((byte*)main::ptr+OFFSET_STRUCT_POINT_Y)
Successful SSA optimization Pass2ConstantAdditionElimination
Adding NOP phi() at start of main::@2
CALL GRAPH
Calls in [main] to print:5 print:11 

Created 3 initial phi equivalence classes
Coalesced [3] print::p_x#3 = print::p_x#0
Coalesced [4] print::p_y#3 = print::p_y#0
Coalesced [8] print::p_x#4 = print::p_x#1
Coalesced [9] idx#18 = idx#13
Coalesced [10] print::p_y#4 = print::p_y#1
Coalesced down to 3 phi equivalence classes
Culled Empty Block label main::@2

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT)
  [1] print::p_x#0 = *((byte*)&main::point)
  [2] print::p_y#0 = *((byte*)&main::point+OFFSET_STRUCT_POINT_Y)
  [3] call print 
  to:main::@1
main::@1: scope:[main]  from main
  [4] print::p_x#1 = *((byte*)main::ptr)
  [5] print::p_y#1 = *((byte*)main::ptr+OFFSET_STRUCT_POINT_Y)
  [6] call print 
  to:main::@return
main::@return: scope:[main]  from main::@1
  [7] return 
  to:@return

void print(byte print::p_x , byte print::p_y)
print: scope:[print]  from main main::@1
  [8] print::p_y#2 = phi( main/print::p_y#0, main::@1/print::p_y#1 )
  [8] idx#12 = phi( main/0, main::@1/idx#13 )
  [8] print::p_x#2 = phi( main/print::p_x#0, main::@1/print::p_x#1 )
  [9] SCREEN[idx#12] = print::p_x#2
  [10] idx#3 = ++ idx#12
  [11] SCREEN[idx#3] = print::p_y#2
  [12] idx#13 = ++ idx#3
  to:print::@return
print::@return: scope:[print]  from print
  [13] return 
  to:@return


VARIABLE REGISTER WEIGHTS
byte idx
byte idx#12 12.0
byte idx#13 2.6
byte idx#3 16.5
void main()
volatile struct Point main::point loadstore
void print(byte print::p_x , byte print::p_y)
struct Point print::p
byte print::p_x
byte print::p_x#0 2.0
byte print::p_x#1 2.0
byte print::p_x#2 15.0
byte print::p_y
byte print::p_y#0 4.0
byte print::p_y#1 4.0
byte print::p_y#2 5.0

Initial phi equivalence classes
[ print::p_x#2 print::p_x#0 print::p_x#1 ]
[ idx#12 idx#13 ]
[ print::p_y#2 print::p_y#0 print::p_y#1 ]
Added variable idx#3 to live range equivalence class [ idx#3 ]
Added variable main::point to live range equivalence class [ main::point ]
Complete equivalence classes
[ print::p_x#2 print::p_x#0 print::p_x#1 ]
[ idx#12 idx#13 ]
[ print::p_y#2 print::p_y#0 print::p_y#1 ]
[ idx#3 ]
[ main::point ]
Allocated zp[1]:2 [ print::p_x#2 print::p_x#0 print::p_x#1 ]
Allocated zp[1]:3 [ idx#12 idx#13 ]
Allocated zp[1]:4 [ print::p_y#2 print::p_y#0 print::p_y#1 ]
Allocated zp[1]:5 [ idx#3 ]
Allocated zp[2]:6 [ main::point ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT) [ main::point ] (  [ main::point ] { { print::p_x#0 = print::p_x#2 } { print::p_y#0 = print::p_y#2 } }  ) always clobbers reg byte a reg byte y 
Potential registers zp[1]:2 [ print::p_x#2 print::p_x#0 print::p_x#1 ] : zp[1]:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ idx#12 idx#13 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ print::p_y#2 print::p_y#0 print::p_y#1 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ idx#3 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:6 [ main::point ] : zp[2]:6 , 

REGISTER UPLIFT SCOPES
Uplift Scope [print] 19: zp[1]:2 [ print::p_x#2 print::p_x#0 print::p_x#1 ] 13: zp[1]:4 [ print::p_y#2 print::p_y#0 print::p_y#1 ] 
Uplift Scope [] 16.5: zp[1]:5 [ idx#3 ] 14.6: zp[1]:3 [ idx#12 idx#13 ] 
Uplift Scope [Point] 
Uplift Scope [main] 0: zp[2]:6 [ main::point ] 

Uplifting [print] best 104 combination reg byte y [ print::p_x#2 print::p_x#0 print::p_x#1 ] reg byte x [ print::p_y#2 print::p_y#0 print::p_y#1 ] 
Uplifting [] best 95 combination reg byte y [ idx#3 ] zp[1]:3 [ idx#12 idx#13 ] 
Uplifting [Point] best 95 combination 
Uplifting [main] best 95 combination zp[2]:6 [ main::point ] 
Attempting to uplift remaining variables inzp[1]:3 [ idx#12 idx#13 ]
Uplifting [] best 95 combination zp[1]:3 [ idx#12 idx#13 ] 
Allocated (was zp[1]:3) zp[1]:2 [ idx#12 idx#13 ]
Allocated (was zp[2]:6) zp[2]:3 [ main::point ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Demonstrates problem with passing struct pointer deref as parameter to call
  // Upstart
  // Commodore 64 PRG executable file
.file [name="struct-ptr-19.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const SIZEOF_STRUCT_POINT = 2
  .const OFFSET_STRUCT_POINT_Y = 1
  .label SCREEN = $400
  .label idx = 2
.segment Code
  // main
main: {
    .label ptr = point
    .label point = 3
    // [0] *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT) -- _deref_pssc1=_deref_pssc2_memcpy_vbuc3 
    ldy #SIZEOF_STRUCT_POINT
  !:
    lda __0-1,y
    sta point-1,y
    dey
    bne !-
    // [1] print::p_x#0 = *((byte*)&main::point) -- vbuyy=_deref_pbuc1 
    ldy.z point
    // [2] print::p_y#0 = *((byte*)&main::point+OFFSET_STRUCT_POINT_Y) -- vbuxx=_deref_pbuc1 
    ldx point+OFFSET_STRUCT_POINT_Y
    // [3] call print 
    // [8] phi from main to print [phi:main->print]
  print_from_main:
    // [8] phi print::p_y#2 = print::p_y#0 [phi:main->print#0] -- register_copy 
    // [8] phi idx#12 = 0 [phi:main->print#1] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [8] phi print::p_x#2 = print::p_x#0 [phi:main->print#2] -- register_copy 
    jsr print
    jmp __b1
    // main::@1
  __b1:
    // [4] print::p_x#1 = *((byte*)main::ptr) -- vbuyy=_deref_pbuc1 
    ldy.z ptr
    // [5] print::p_y#1 = *((byte*)main::ptr+OFFSET_STRUCT_POINT_Y) -- vbuxx=_deref_pbuc1 
    ldx ptr+OFFSET_STRUCT_POINT_Y
    // [6] call print 
    // [8] phi from main::@1 to print [phi:main::@1->print]
  print_from___b1:
    // [8] phi print::p_y#2 = print::p_y#1 [phi:main::@1->print#0] -- register_copy 
    // [8] phi idx#12 = idx#13 [phi:main::@1->print#1] -- register_copy 
    // [8] phi print::p_x#2 = print::p_x#1 [phi:main::@1->print#2] -- register_copy 
    jsr print
    jmp __breturn
    // main::@return
  __breturn:
    // [7] return 
    rts
}
  // print
// print(byte register(Y) p_x, byte register(X) p_y)
print: {
    // [9] SCREEN[idx#12] = print::p_x#2 -- pbuc1_derefidx_vbuz1=vbuyy 
    tya
    ldy.z idx
    sta SCREEN,y
    // [10] idx#3 = ++ idx#12 -- vbuyy=_inc_vbuz1 
    ldy.z idx
    iny
    // [11] SCREEN[idx#3] = print::p_y#2 -- pbuc1_derefidx_vbuyy=vbuxx 
    txa
    sta SCREEN,y
    // [12] idx#13 = ++ idx#3 -- vbuz1=_inc_vbuyy 
    iny
    sty.z idx
    jmp __breturn
    // print::@return
  __breturn:
    // [13] return 
    rts
}
  // File Data
.segment Data
  __0: .byte 1, 2

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy.z idx
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction print_from_main:
Removing instruction __b1:
Removing instruction print_from___b1:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
constant struct Point $0 = { x: 1, y: 2 }
constant byte OFFSET_STRUCT_POINT_Y = 1
constant byte* const SCREEN = (byte*) 1024
constant byte SIZEOF_STRUCT_POINT = 2
byte idx
byte idx#12 idx zp[1]:2 12.0
byte idx#13 idx zp[1]:2 2.6
byte idx#3 reg byte y 16.5
void main()
volatile struct Point main::point loadstore zp[2]:3
constant struct Point* main::ptr = &main::point
void print(byte print::p_x , byte print::p_y)
struct Point print::p
byte print::p_x
byte print::p_x#0 reg byte y 2.0
byte print::p_x#1 reg byte y 2.0
byte print::p_x#2 reg byte y 15.0
byte print::p_y
byte print::p_y#0 reg byte x 4.0
byte print::p_y#1 reg byte x 4.0
byte print::p_y#2 reg byte x 5.0

reg byte y [ print::p_x#2 print::p_x#0 print::p_x#1 ]
zp[1]:2 [ idx#12 idx#13 ]
reg byte x [ print::p_y#2 print::p_y#0 print::p_y#1 ]
reg byte y [ idx#3 ]
zp[2]:3 [ main::point ]


FINAL ASSEMBLER
Score: 83

  // File Comments
// Demonstrates problem with passing struct pointer deref as parameter to call
  // Upstart
  // Commodore 64 PRG executable file
.file [name="struct-ptr-19.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const SIZEOF_STRUCT_POINT = 2
  .const OFFSET_STRUCT_POINT_Y = 1
  .label SCREEN = $400
  .label idx = 2
.segment Code
  // main
main: {
    .label ptr = point
    .label point = 3
    // point = { 1, 2 }
    // [0] *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT) -- _deref_pssc1=_deref_pssc2_memcpy_vbuc3 
    ldy #SIZEOF_STRUCT_POINT
  !:
    lda __0-1,y
    sta point-1,y
    dey
    bne !-
    // print(point)
    // [1] print::p_x#0 = *((byte*)&main::point) -- vbuyy=_deref_pbuc1 
    ldy.z point
    // [2] print::p_y#0 = *((byte*)&main::point+OFFSET_STRUCT_POINT_Y) -- vbuxx=_deref_pbuc1 
    ldx point+OFFSET_STRUCT_POINT_Y
    // [3] call print 
    // [8] phi from main to print [phi:main->print]
    // [8] phi print::p_y#2 = print::p_y#0 [phi:main->print#0] -- register_copy 
    // [8] phi idx#12 = 0 [phi:main->print#1] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [8] phi print::p_x#2 = print::p_x#0 [phi:main->print#2] -- register_copy 
    jsr print
    // main::@1
    // print(*ptr)
    // [4] print::p_x#1 = *((byte*)main::ptr) -- vbuyy=_deref_pbuc1 
    ldy.z ptr
    // [5] print::p_y#1 = *((byte*)main::ptr+OFFSET_STRUCT_POINT_Y) -- vbuxx=_deref_pbuc1 
    ldx ptr+OFFSET_STRUCT_POINT_Y
    // [6] call print 
    // [8] phi from main::@1 to print [phi:main::@1->print]
    // [8] phi print::p_y#2 = print::p_y#1 [phi:main::@1->print#0] -- register_copy 
    // [8] phi idx#12 = idx#13 [phi:main::@1->print#1] -- register_copy 
    // [8] phi print::p_x#2 = print::p_x#1 [phi:main::@1->print#2] -- register_copy 
    jsr print
    // main::@return
    // }
    // [7] return 
    rts
}
  // print
// print(byte register(Y) p_x, byte register(X) p_y)
print: {
    // SCREEN[idx++] = p.x
    // [9] SCREEN[idx#12] = print::p_x#2 -- pbuc1_derefidx_vbuz1=vbuyy 
    tya
    ldy.z idx
    sta SCREEN,y
    // SCREEN[idx++] = p.x;
    // [10] idx#3 = ++ idx#12 -- vbuyy=_inc_vbuz1 
    iny
    // SCREEN[idx++] = p.y
    // [11] SCREEN[idx#3] = print::p_y#2 -- pbuc1_derefidx_vbuyy=vbuxx 
    txa
    sta SCREEN,y
    // SCREEN[idx++] = p.y;
    // [12] idx#13 = ++ idx#3 -- vbuz1=_inc_vbuyy 
    iny
    sty.z idx
    // print::@return
    // }
    // [13] return 
    rts
}
  // File Data
.segment Data
  __0: .byte 1, 2

