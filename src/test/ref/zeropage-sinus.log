Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) @7
Culled Empty Block (label) @8

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@9

(void()) main()
main: scope:[main]  from @9
  asm { sei  }
  *((const byte*) SPRITES_ENABLE) ← (number) 1
  *((const byte*) SPRITES_YPOS + (number) 0) ← (number) $64
  *((const byte*) SPRITES_XPOS + (number) 0) ← (number) $64
  *((const byte*) SCREEN+(const word) SPRITE_PTRS) ← (byte)(const byte*) SPRITE/(number) $40
  call saveZeropage 
  to:main::@1
main::@1: scope:[main]  from main
  call sinZeropage 
  to:main::@2
main::@2: scope:[main]  from main::@1
  call animSprite 
  to:main::@3
main::@3: scope:[main]  from main::@2
  call restoreZeropage 
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return

(void()) saveZeropage()
saveZeropage: scope:[saveZeropage]  from main
  asm { ldx#0 !: lda$00,x staZP_STORAGE,x inx bne!-  }
  to:saveZeropage::@return
saveZeropage::@return: scope:[saveZeropage]  from saveZeropage
  return 
  to:@return

(void()) restoreZeropage()
restoreZeropage: scope:[restoreZeropage]  from main::@3
  asm { ldx#0 !: ldaZP_STORAGE,x sta$00,x inx bne!-  }
  to:restoreZeropage::@return
restoreZeropage::@return: scope:[restoreZeropage]  from restoreZeropage
  return 
  to:@return

(void()) sinZeropage()
sinZeropage: scope:[sinZeropage]  from main::@1
  asm { ldx#0 !: ldaSINTABLE,x sta$00,x inx bne!-  }
  to:sinZeropage::@return
sinZeropage::@return: scope:[sinZeropage]  from sinZeropage
  return 
  to:@return

(void()) animSprite()
animSprite: scope:[animSprite]  from main::@2
  kickasm() {{ ldx #$00
    repeat:
        lda #$fe
    !:
        cmp $d012
        bne !-
        lda #$ff
    !:
        cmp $d012
        bne !-
        .break
        lda $00,x
        clc
        adc #$38
        sta $d000
        lda #0
        adc #0
        sta $d010
        inx
        jmp repeat
     }}
  to:animSprite::@return
animSprite::@return: scope:[animSprite]  from animSprite
  return 
  to:@return
@9: scope:[]  from @begin
  call main 
  to:@10
@10: scope:[]  from @9
  to:@end
@end: scope:[]  from @10

SYMBOL TABLE SSA
(label) @10
(label) @9
(label) @begin
(label) @end
(const byte*) SCREEN = (byte*)(number) $400
(const byte*) SINTABLE[(number) $100]  = kickasm {{ .for(var i=0;i<$100;i++)
        .byte round(127.5+127.5*cos(toRadians(360*i/256)))
 }}
(const byte*) SPRITE[(number) $40]  = kickasm {{ .fill $40,$ff  }}
(const byte*) SPRITES_ENABLE = (byte*)(number) $d015
(const byte*) SPRITES_XPOS = (byte*)(number) $d000
(const byte*) SPRITES_YPOS = (byte*)(number) $d001
(const word) SPRITE_PTRS = (word) $3f8
(const byte*) ZP_STORAGE[(number) $100]  = { fill( $100, 0) }
(void()) animSprite()
(label) animSprite::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return
(void()) restoreZeropage()
(label) restoreZeropage::@return
(void()) saveZeropage()
(label) saveZeropage::@return
(void()) sinZeropage()
(label) sinZeropage::@return

Adding number conversion cast (unumber) 1 in *((const byte*) SPRITES_ENABLE) ← (number) 1
Adding number conversion cast (unumber) $64 in *((const byte*) SPRITES_YPOS + (number) 0) ← (number) $64
Adding number conversion cast (unumber) 0 in *((const byte*) SPRITES_YPOS + (number) 0) ← ((unumber)) (number) $64
Adding number conversion cast (unumber) $64 in *((const byte*) SPRITES_XPOS + (number) 0) ← (number) $64
Adding number conversion cast (unumber) 0 in *((const byte*) SPRITES_XPOS + (number) 0) ← ((unumber)) (number) $64
Adding number conversion cast (unumber) $40 in *((const byte*) SCREEN+(const word) SPRITE_PTRS) ← (byte)(const byte*) SPRITE/(number) $40
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((const byte*) SPRITES_ENABLE) ← (unumber)(number) 1
Inlining cast *((const byte*) SPRITES_YPOS + (unumber)(number) 0) ← (unumber)(number) $64
Inlining cast *((const byte*) SPRITES_XPOS + (unumber)(number) 0) ← (unumber)(number) $64
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 53249
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 1
Simplifying constant integer cast $64
Simplifying constant integer cast 0
Simplifying constant integer cast $64
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $64
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $64
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Successful SSA optimization PassNFinalizeNumberTypeConversions
Simplifying expression containing zero SPRITES_YPOS in [2] *((const byte*) SPRITES_YPOS + (byte) 0) ← (byte) $64
Simplifying expression containing zero SPRITES_XPOS in [3] *((const byte*) SPRITES_XPOS + (byte) 0) ← (byte) $64
Successful SSA optimization PassNSimplifyExpressionWithZero
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @9
Adding NOP phi() at start of @10
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to saveZeropage:10 sinZeropage:12 animSprite:14 restoreZeropage:16 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block (label) @10
Culled Empty Block (label) main::@4
Renumbering block @9 to @1
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  asm { sei  }
  [5] *((const byte*) SPRITES_ENABLE) ← (byte) 1
  [6] *((const byte*) SPRITES_YPOS) ← (byte) $64
  [7] *((const byte*) SPRITES_XPOS) ← (byte) $64
  [8] *((const byte*) SCREEN+(const word) SPRITE_PTRS) ← (byte)(const byte*) SPRITE/(byte) $40
  [9] call saveZeropage 
  to:main::@1
main::@1: scope:[main]  from main
  [10] phi()
  [11] call sinZeropage 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [12] phi()
  [13] call animSprite 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [14] phi()
  [15] call restoreZeropage 
  to:main::@return
main::@return: scope:[main]  from main::@3
  [16] return 
  to:@return

(void()) restoreZeropage()
restoreZeropage: scope:[restoreZeropage]  from main::@3
  asm { ldx#0 !: ldaZP_STORAGE,x sta$00,x inx bne!-  }
  to:restoreZeropage::@return
restoreZeropage::@return: scope:[restoreZeropage]  from restoreZeropage
  [18] return 
  to:@return

(void()) animSprite()
animSprite: scope:[animSprite]  from main::@2
  kickasm() {{ ldx #$00
    repeat:
        lda #$fe
    !:
        cmp $d012
        bne !-
        lda #$ff
    !:
        cmp $d012
        bne !-
        .break
        lda $00,x
        clc
        adc #$38
        sta $d000
        lda #0
        adc #0
        sta $d010
        inx
        jmp repeat
     }}
  to:animSprite::@return
animSprite::@return: scope:[animSprite]  from animSprite
  [20] return 
  to:@return

(void()) sinZeropage()
sinZeropage: scope:[sinZeropage]  from main::@1
  asm { ldx#0 !: ldaSINTABLE,x sta$00,x inx bne!-  }
  to:sinZeropage::@return
sinZeropage::@return: scope:[sinZeropage]  from sinZeropage
  [22] return 
  to:@return

(void()) saveZeropage()
saveZeropage: scope:[saveZeropage]  from main
  asm { ldx#0 !: lda$00,x staZP_STORAGE,x inx bne!-  }
  to:saveZeropage::@return
saveZeropage::@return: scope:[saveZeropage]  from saveZeropage
  [24] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) animSprite()
(void()) main()
(void()) restoreZeropage()
(void()) saveZeropage()
(void()) sinZeropage()

Initial phi equivalence classes
Complete equivalence classes

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Attempt to store and use a sinus on zeropage
// $00/$11 is carefully chosen to be $ff - which plays well with the processor port
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // The offset of the sprite pointers from the screen start address
  .const SPRITE_PTRS = $3f8
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_ENABLE = $d015
  .label SCREEN = $400
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // asm { sei  }
    // Stop interrupts
    sei
    // [5] *((const byte*) SPRITES_ENABLE) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    // Show sprite
    lda #1
    sta SPRITES_ENABLE
    // [6] *((const byte*) SPRITES_YPOS) ← (byte) $64 -- _deref_pbuc1=vbuc2 
    lda #$64
    sta SPRITES_YPOS
    // [7] *((const byte*) SPRITES_XPOS) ← (byte) $64 -- _deref_pbuc1=vbuc2 
    lda #$64
    sta SPRITES_XPOS
    // [8] *((const byte*) SCREEN+(const word) SPRITE_PTRS) ← (byte)(const byte*) SPRITE/(byte) $40 -- _deref_pbuc1=vbuc2 
    lda #$ff&SPRITE/$40
    sta SCREEN+SPRITE_PTRS
    // [9] call saveZeropage 
    jsr saveZeropage
    // [10] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [11] call sinZeropage 
    jsr sinZeropage
    // [12] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [13] call animSprite 
    jsr animSprite
    // [14] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [15] call restoreZeropage 
    jsr restoreZeropage
    jmp __breturn
    // main::@return
  __breturn:
    // [16] return 
    rts
}
  // restoreZeropage
// Save all values on zeropage
restoreZeropage: {
    // asm { ldx#0 !: ldaZP_STORAGE,x sta$00,x inx bne!-  }
    ldx #0
  !:
    lda ZP_STORAGE,x
    sta.z 0,x
    inx
    bne !-
    jmp __breturn
    // restoreZeropage::@return
  __breturn:
    // [18] return 
    rts
}
  // animSprite
// Move a sprite in the sinus on zeropage
animSprite: {
    // kickasm() {{ ldx #$00     repeat:         lda #$fe     !:         cmp $d012         bne !-         lda #$ff     !:         cmp $d012         bne !-         .break         lda $00,x         clc         adc #$38         sta $d000         lda #0         adc #0         sta $d010         inx         jmp repeat      }}
    ldx #$00
    repeat:
        lda #$fe
    !:
        cmp $d012
        bne !-
        lda #$ff
    !:
        cmp $d012
        bne !-
        .break
        lda $00,x
        clc
        adc #$38
        sta $d000
        lda #0
        adc #0
        sta $d010
        inx
        jmp repeat
    
    jmp __breturn
    // animSprite::@return
  __breturn:
    // [20] return 
    rts
}
  // sinZeropage
// Move the SINUS values to zeropage
sinZeropage: {
    // asm { ldx#0 !: ldaSINTABLE,x sta$00,x inx bne!-  }
    ldx #0
  !:
    lda SINTABLE,x
    sta.z 0,x
    inx
    bne !-
    jmp __breturn
    // sinZeropage::@return
  __breturn:
    // [22] return 
    rts
}
  // saveZeropage
// Save all values on zeropage
saveZeropage: {
    // asm { ldx#0 !: lda$00,x staZP_STORAGE,x inx bne!-  }
    ldx #0
  !:
    lda.z 0,x
    sta ZP_STORAGE,x
    inx
    bne !-
    jmp __breturn
    // saveZeropage::@return
  __breturn:
    // [24] return 
    rts
}
  // File Data
  // A 256-byte (co)sinus (with $ff in the first two entries)
  .align $100
SINTABLE:
.for(var i=0;i<$100;i++)
        .byte round(127.5+127.5*cos(toRadians(360*i/256)))

  // Storage for saving/restoring zeropage
  .align $100
  ZP_STORAGE: .fill $100, 0
  // A single sprite to animate
  .align $40
SPRITE:
.fill $40,$ff 

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [5] *((const byte*) SPRITES_ENABLE) ← (byte) 1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [6] *((const byte*) SPRITES_YPOS) ← (byte) $64 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((const byte*) SPRITES_XPOS) ← (byte) $64 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [8] *((const byte*) SCREEN+(const word) SPRITE_PTRS) ← (byte)(const byte*) SPRITE/(byte) $40 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement asm { ldx#0 !: ldaZP_STORAGE,x sta$00,x inx bne!-  } always clobbers reg byte a reg byte x 
Statement asm { ldx#0 !: ldaSINTABLE,x sta$00,x inx bne!-  } always clobbers reg byte a reg byte x 
Statement asm { ldx#0 !: lda$00,x staZP_STORAGE,x inx bne!-  } always clobbers reg byte a reg byte x 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 
Uplift Scope [saveZeropage] 
Uplift Scope [restoreZeropage] 
Uplift Scope [sinZeropage] 
Uplift Scope [animSprite] 
Uplift Scope [] 

Uplifting [main] best 417 combination 
Uplifting [saveZeropage] best 417 combination 
Uplifting [restoreZeropage] best 417 combination 
Uplifting [sinZeropage] best 417 combination 
Uplifting [animSprite] best 417 combination 
Uplifting [] best 417 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Attempt to store and use a sinus on zeropage
// $00/$11 is carefully chosen to be $ff - which plays well with the processor port
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // The offset of the sprite pointers from the screen start address
  .const SPRITE_PTRS = $3f8
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_ENABLE = $d015
  .label SCREEN = $400
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // asm { sei  }
    // Stop interrupts
    sei
    // [5] *((const byte*) SPRITES_ENABLE) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    // Show sprite
    lda #1
    sta SPRITES_ENABLE
    // [6] *((const byte*) SPRITES_YPOS) ← (byte) $64 -- _deref_pbuc1=vbuc2 
    lda #$64
    sta SPRITES_YPOS
    // [7] *((const byte*) SPRITES_XPOS) ← (byte) $64 -- _deref_pbuc1=vbuc2 
    lda #$64
    sta SPRITES_XPOS
    // [8] *((const byte*) SCREEN+(const word) SPRITE_PTRS) ← (byte)(const byte*) SPRITE/(byte) $40 -- _deref_pbuc1=vbuc2 
    lda #$ff&SPRITE/$40
    sta SCREEN+SPRITE_PTRS
    // [9] call saveZeropage 
    jsr saveZeropage
    // [10] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [11] call sinZeropage 
    jsr sinZeropage
    // [12] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [13] call animSprite 
    jsr animSprite
    // [14] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [15] call restoreZeropage 
    jsr restoreZeropage
    jmp __breturn
    // main::@return
  __breturn:
    // [16] return 
    rts
}
  // restoreZeropage
// Save all values on zeropage
restoreZeropage: {
    // asm { ldx#0 !: ldaZP_STORAGE,x sta$00,x inx bne!-  }
    ldx #0
  !:
    lda ZP_STORAGE,x
    sta.z 0,x
    inx
    bne !-
    jmp __breturn
    // restoreZeropage::@return
  __breturn:
    // [18] return 
    rts
}
  // animSprite
// Move a sprite in the sinus on zeropage
animSprite: {
    // kickasm() {{ ldx #$00     repeat:         lda #$fe     !:         cmp $d012         bne !-         lda #$ff     !:         cmp $d012         bne !-         .break         lda $00,x         clc         adc #$38         sta $d000         lda #0         adc #0         sta $d010         inx         jmp repeat      }}
    ldx #$00
    repeat:
        lda #$fe
    !:
        cmp $d012
        bne !-
        lda #$ff
    !:
        cmp $d012
        bne !-
        .break
        lda $00,x
        clc
        adc #$38
        sta $d000
        lda #0
        adc #0
        sta $d010
        inx
        jmp repeat
    
    jmp __breturn
    // animSprite::@return
  __breturn:
    // [20] return 
    rts
}
  // sinZeropage
// Move the SINUS values to zeropage
sinZeropage: {
    // asm { ldx#0 !: ldaSINTABLE,x sta$00,x inx bne!-  }
    ldx #0
  !:
    lda SINTABLE,x
    sta.z 0,x
    inx
    bne !-
    jmp __breturn
    // sinZeropage::@return
  __breturn:
    // [22] return 
    rts
}
  // saveZeropage
// Save all values on zeropage
saveZeropage: {
    // asm { ldx#0 !: lda$00,x staZP_STORAGE,x inx bne!-  }
    ldx #0
  !:
    lda.z 0,x
    sta ZP_STORAGE,x
    inx
    bne !-
    jmp __breturn
    // saveZeropage::@return
  __breturn:
    // [24] return 
    rts
}
  // File Data
  // A 256-byte (co)sinus (with $ff in the first two entries)
  .align $100
SINTABLE:
.for(var i=0;i<$100;i++)
        .byte round(127.5+127.5*cos(toRadians(360*i/256)))

  // Storage for saving/restoring zeropage
  .align $100
  ZP_STORAGE: .fill $100, 0
  // A single sprite to animate
  .align $40
SPRITE:
.fill $40,$ff 

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #$64
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b1_from___bbegin:
Removing instruction __b1:
Removing instruction __bend_from___b1:
Removing instruction __b1_from_main:
Removing instruction __b2_from___b1:
Removing instruction __b3_from___b2:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction __bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) SCREEN = (byte*) 1024
(const byte*) SINTABLE[(number) $100]  = kickasm {{ .for(var i=0;i<$100;i++)
        .byte round(127.5+127.5*cos(toRadians(360*i/256)))
 }}
(const byte*) SPRITE[(number) $40]  = kickasm {{ .fill $40,$ff  }}
(const byte*) SPRITES_ENABLE = (byte*) 53269
(const byte*) SPRITES_XPOS = (byte*) 53248
(const byte*) SPRITES_YPOS = (byte*) 53249
(const word) SPRITE_PTRS = (word) $3f8
(const byte*) ZP_STORAGE[(number) $100]  = { fill( $100, 0) }
(void()) animSprite()
(label) animSprite::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(void()) restoreZeropage()
(label) restoreZeropage::@return
(void()) saveZeropage()
(label) saveZeropage::@return
(void()) sinZeropage()
(label) sinZeropage::@return



FINAL ASSEMBLER
Score: 379

  // File Comments
// Attempt to store and use a sinus on zeropage
// $00/$11 is carefully chosen to be $ff - which plays well with the processor port
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // The offset of the sprite pointers from the screen start address
  .const SPRITE_PTRS = $3f8
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_ENABLE = $d015
  .label SCREEN = $400
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // asm
    // asm { sei  }
    // Stop interrupts
    sei
    // *SPRITES_ENABLE = 1
    // [5] *((const byte*) SPRITES_ENABLE) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    // Show sprite
    lda #1
    sta SPRITES_ENABLE
    // SPRITES_YPOS[0] = 100
    // [6] *((const byte*) SPRITES_YPOS) ← (byte) $64 -- _deref_pbuc1=vbuc2 
    lda #$64
    sta SPRITES_YPOS
    // SPRITES_XPOS[0] = 100
    // [7] *((const byte*) SPRITES_XPOS) ← (byte) $64 -- _deref_pbuc1=vbuc2 
    sta SPRITES_XPOS
    // *(SCREEN+SPRITE_PTRS) = (byte)(SPRITE/0x40)
    // [8] *((const byte*) SCREEN+(const word) SPRITE_PTRS) ← (byte)(const byte*) SPRITE/(byte) $40 -- _deref_pbuc1=vbuc2 
    lda #$ff&SPRITE/$40
    sta SCREEN+SPRITE_PTRS
    // saveZeropage()
    // [9] call saveZeropage 
    jsr saveZeropage
    // [10] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // sinZeropage()
    // [11] call sinZeropage 
    jsr sinZeropage
    // [12] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // animSprite()
    // [13] call animSprite 
    jsr animSprite
    // [14] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // main::@3
    // restoreZeropage()
    // [15] call restoreZeropage 
    jsr restoreZeropage
    // main::@return
    // }
    // [16] return 
    rts
}
  // restoreZeropage
// Save all values on zeropage
restoreZeropage: {
    // asm
    // asm { ldx#0 !: ldaZP_STORAGE,x sta$00,x inx bne!-  }
    ldx #0
  !:
    lda ZP_STORAGE,x
    sta.z 0,x
    inx
    bne !-
    // restoreZeropage::@return
    // }
    // [18] return 
    rts
}
  // animSprite
// Move a sprite in the sinus on zeropage
animSprite: {
    // kickasm
    // kickasm() {{ ldx #$00     repeat:         lda #$fe     !:         cmp $d012         bne !-         lda #$ff     !:         cmp $d012         bne !-         .break         lda $00,x         clc         adc #$38         sta $d000         lda #0         adc #0         sta $d010         inx         jmp repeat      }}
    ldx #$00
    repeat:
        lda #$fe
    !:
        cmp $d012
        bne !-
        lda #$ff
    !:
        cmp $d012
        bne !-
        .break
        lda $00,x
        clc
        adc #$38
        sta $d000
        lda #0
        adc #0
        sta $d010
        inx
        jmp repeat
    
    // animSprite::@return
    // }
    // [20] return 
    rts
}
  // sinZeropage
// Move the SINUS values to zeropage
sinZeropage: {
    // asm
    // asm { ldx#0 !: ldaSINTABLE,x sta$00,x inx bne!-  }
    ldx #0
  !:
    lda SINTABLE,x
    sta.z 0,x
    inx
    bne !-
    // sinZeropage::@return
    // }
    // [22] return 
    rts
}
  // saveZeropage
// Save all values on zeropage
saveZeropage: {
    // asm
    // asm { ldx#0 !: lda$00,x staZP_STORAGE,x inx bne!-  }
    ldx #0
  !:
    lda.z 0,x
    sta ZP_STORAGE,x
    inx
    bne !-
    // saveZeropage::@return
    // }
    // [24] return 
    rts
}
  // File Data
  // A 256-byte (co)sinus (with $ff in the first two entries)
  .align $100
SINTABLE:
.for(var i=0;i<$100;i++)
        .byte round(127.5+127.5*cos(toRadians(360*i/256)))

  // Storage for saving/restoring zeropage
  .align $100
  ZP_STORAGE: .fill $100, 0
  // A single sprite to animate
  .align $40
SPRITE:
.fill $40,$ff 

