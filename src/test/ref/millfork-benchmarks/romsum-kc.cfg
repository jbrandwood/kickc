
(void()) __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] (volatile word) last_time ← (word) 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [2] phi()
  [3] call main 
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [4] return 
  to:@return

(signed word()) main()
main: scope:[main]  from __start::@1
  [5] phi()
  [6] call start 
  to:main::@1
main::@1: scope:[main]  from main main::@6
  [7] (byte*) print_line_cursor#22 ← phi( main/(const byte*) print_screen#0 main::@6/(byte*) print_line_cursor#0 )
  [7] (byte*) print_char_cursor#54 ← phi( main/(const byte*) print_screen#0 main::@6/(byte*) print_char_cursor#73 )
  [7] (word) main::i#3 ← phi( main/(byte) 0 main::@6/(word) main::i#2 )
  [8] if((word) main::i#3<(byte) 6) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [9] phi()
  [10] call end 
  to:main::@return
main::@return: scope:[main]  from main::@3
  [11] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [12] phi()
  [13] call sum 
  [14] (word) sum::return#2 ← (word) sum::s#3
  to:main::@4
main::@4: scope:[main]  from main::@2
  [15] (word) print_uint_decimal::w#0 ← (word) sum::return#2
  [16] call print_uint_decimal 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [17] phi()
  [18] call print_ln 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [19] (word) main::i#2 ← ++ (word) main::i#3
  [20] (byte*) print_char_cursor#73 ← (byte*) print_line_cursor#0
  to:main::@1

(void()) start()
start: scope:[start]  from end main
  asm { jsr$FFDE staLAST_TIME stxLAST_TIME+1  }
  to:start::@return
start::@return: scope:[start]  from start
  [22] return 
  to:@return

(void()) end()
end: scope:[end]  from main::@3
  [23] (word) Ticks#0 ← (volatile word) last_time
  [24] call start 
  to:end::@1
end::@1: scope:[end]  from end
  [25] (volatile word) last_time ← (volatile word) last_time - (word) Ticks#0
  [26] (word) Ticks#1 ← (volatile word) last_time
  [27] (word) print_uint::w#0 ← (word) Ticks#1
  [28] call print_uint 
  to:end::@2
end::@2: scope:[end]  from end::@1
  [29] phi()
  [30] call print_ln 
  to:end::@return
end::@return: scope:[end]  from end::@2
  [31] return 
  to:@return

(word()) sum()
sum: scope:[sum]  from main::@2
  [32] phi()
  to:sum::@1
sum::@1: scope:[sum]  from sum sum::@3
  [33] (byte*) sum::p#5 ← phi( sum/(const nomodify byte*) rom sum::@3/(byte*) sum::p#2 )
  [33] (word) sum::s#3 ← phi( sum/(byte) 0 sum::@3/(word) sum::s#2 )
  [33] (byte) sum::page#3 ← phi( sum/(byte) 0 sum::@3/(byte) sum::page#2 )
  [34] if((byte) sum::page#3<(byte) $20) goto sum::@2
  to:sum::@return
sum::@return: scope:[sum]  from sum::@1
  [35] return 
  to:@return
sum::@2: scope:[sum]  from sum::@1 sum::@2
  [36] (word) sum::s#4 ← phi( sum::@1/(word) sum::s#3 sum::@2/(word) sum::s#2 )
  [36] (byte) sum::i#3 ← phi( sum::@1/(byte) 0 sum::@2/(byte) sum::i#2 )
  [37] (byte) sum::tmp#1 ← *((byte*) sum::p#5 + (byte) sum::i#3)
  [38] (word) sum::s#2 ← (word) sum::s#4 + (byte) sum::tmp#1
  [39] (byte) sum::i#2 ← ++ (byte) sum::i#3
  [40] if((byte) 0!=(byte) sum::i#2) goto sum::@2
  to:sum::@3
sum::@3: scope:[sum]  from sum::@2
  [41] (byte*) sum::p#2 ← (byte*) sum::p#5 + (word) $100
  [42] (byte) sum::page#2 ← ++ (byte) sum::page#3
  to:sum::@1

(void()) print_uint_decimal((word) print_uint_decimal::w)
print_uint_decimal: scope:[print_uint_decimal]  from main::@4
  [43] (word) utoa::value#1 ← (word) print_uint_decimal::w#0
  [44] call utoa 
  to:print_uint_decimal::@1
print_uint_decimal::@1: scope:[print_uint_decimal]  from print_uint_decimal
  [45] phi()
  [46] call print_str 
  to:print_uint_decimal::@return
print_uint_decimal::@return: scope:[print_uint_decimal]  from print_uint_decimal::@1
  [47] return 
  to:@return

(void()) print_ln()
print_ln: scope:[print_ln]  from end::@2 main::@5
  [48] (byte*) print_char_cursor#49 ← phi( end::@2/(byte*) print_char_cursor#12 main::@5/(byte*) print_char_cursor#1 )
  to:print_ln::@1
print_ln::@1: scope:[print_ln]  from print_ln print_ln::@1
  [49] (byte*) print_line_cursor#10 ← phi( print_ln/(byte*) print_line_cursor#22 print_ln::@1/(byte*) print_line_cursor#0 )
  [50] (byte*) print_line_cursor#0 ← (byte*) print_line_cursor#10 + (byte) $28
  [51] if((byte*) print_line_cursor#0<(byte*) print_char_cursor#49) goto print_ln::@1
  to:print_ln::@return
print_ln::@return: scope:[print_ln]  from print_ln::@1
  [52] return 
  to:@return

(void()) print_uint((word) print_uint::w)
print_uint: scope:[print_uint]  from end::@1
  [53] (byte) print_uchar::b#0 ← > (word) print_uint::w#0
  [54] call print_uchar 
  to:print_uint::@1
print_uint::@1: scope:[print_uint]  from print_uint
  [55] (byte) print_uchar::b#1 ← < (word) print_uint::w#0
  [56] call print_uchar 
  to:print_uint::@return
print_uint::@return: scope:[print_uint]  from print_uint::@1
  [57] return 
  to:@return

(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
utoa: scope:[utoa]  from print_uint_decimal
  [58] phi()
  to:utoa::@1
utoa::@1: scope:[utoa]  from utoa utoa::@4
  [59] (byte*) utoa::buffer#11 ← phi( utoa::@4/(byte*) utoa::buffer#14 utoa/(const byte*) decimal_digits )
  [59] (byte) utoa::started#2 ← phi( utoa::@4/(byte) utoa::started#4 utoa/(byte) 0 )
  [59] (word) utoa::value#2 ← phi( utoa::@4/(word) utoa::value#6 utoa/(word) utoa::value#1 )
  [59] (byte) utoa::digit#2 ← phi( utoa::@4/(byte) utoa::digit#1 utoa/(byte) 0 )
  [60] if((byte) utoa::digit#2<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@2
  to:utoa::@3
utoa::@3: scope:[utoa]  from utoa::@1
  [61] (byte~) utoa::$11 ← (byte)(word) utoa::value#2
  [62] *((byte*) utoa::buffer#11) ← *((const byte*) DIGITS + (byte~) utoa::$11)
  [63] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11
  [64] *((byte*) utoa::buffer#3) ← (byte) 0
  to:utoa::@return
utoa::@return: scope:[utoa]  from utoa::@3
  [65] return 
  to:@return
utoa::@2: scope:[utoa]  from utoa::@1
  [66] (byte~) utoa::$10 ← (byte) utoa::digit#2 << (byte) 1
  [67] (word) utoa::digit_value#0 ← *((const word*) RADIX_DECIMAL_VALUES + (byte~) utoa::$10)
  [68] if((byte) 0!=(byte) utoa::started#2) goto utoa::@5
  to:utoa::@7
utoa::@7: scope:[utoa]  from utoa::@2
  [69] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@5
  to:utoa::@4
utoa::@4: scope:[utoa]  from utoa::@6 utoa::@7
  [70] (byte*) utoa::buffer#14 ← phi( utoa::@7/(byte*) utoa::buffer#11 utoa::@6/(byte*) utoa::buffer#4 )
  [70] (byte) utoa::started#4 ← phi( utoa::@7/(byte) utoa::started#2 utoa::@6/(byte) 1 )
  [70] (word) utoa::value#6 ← phi( utoa::@7/(word) utoa::value#2 utoa::@6/(word) utoa::value#0 )
  [71] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2
  to:utoa::@1
utoa::@5: scope:[utoa]  from utoa::@2 utoa::@7
  [72] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11
  [73] (word) utoa_append::value#0 ← (word) utoa::value#2
  [74] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0
  [75] call utoa_append 
  [76] (word) utoa_append::return#0 ← (word) utoa_append::value#2
  to:utoa::@6
utoa::@6: scope:[utoa]  from utoa::@5
  [77] (word) utoa::value#0 ← (word) utoa_append::return#0
  [78] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#11
  to:utoa::@4

(void()) print_str((byte*) print_str::str)
print_str: scope:[print_str]  from print_uint_decimal::@1
  [79] phi()
  to:print_str::@1
print_str::@1: scope:[print_str]  from print_str print_str::@3
  [80] (byte*) print_char_cursor#1 ← phi( print_str/(byte*) print_char_cursor#54 print_str::@3/(byte*) print_char_cursor#12 )
  [80] (byte*) print_str::str#2 ← phi( print_str/(const byte*) decimal_digits print_str::@3/(byte*) print_str::str#0 )
  [81] if((byte) 0!=*((byte*) print_str::str#2)) goto print_str::@2
  to:print_str::@return
print_str::@return: scope:[print_str]  from print_str::@1
  [82] return 
  to:@return
print_str::@2: scope:[print_str]  from print_str::@1
  [83] (byte) print_char::ch#0 ← *((byte*) print_str::str#2)
  [84] call print_char 
  to:print_str::@3
print_str::@3: scope:[print_str]  from print_str::@2
  [85] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#2
  to:print_str::@1

(void()) print_uchar((byte) print_uchar::b)
print_uchar: scope:[print_uchar]  from print_uint print_uint::@1
  [86] (byte*) print_char_cursor#52 ← phi( print_uint/(byte*) print_char_cursor#54 print_uint::@1/(byte*) print_char_cursor#12 )
  [86] (byte) print_uchar::b#2 ← phi( print_uint/(byte) print_uchar::b#0 print_uint::@1/(byte) print_uchar::b#1 )
  [87] (byte~) print_uchar::$0 ← (byte) print_uchar::b#2 >> (byte) 4
  [88] (byte) print_char::ch#1 ← *((const byte*) DIGITS + (byte~) print_uchar::$0)
  [89] call print_char 
  to:print_uchar::@1
print_uchar::@1: scope:[print_uchar]  from print_uchar
  [90] (byte~) print_uchar::$2 ← (byte) print_uchar::b#2 & (byte) $f
  [91] (byte) print_char::ch#2 ← *((const byte*) DIGITS + (byte~) print_uchar::$2)
  [92] call print_char 
  to:print_uchar::@return
print_uchar::@return: scope:[print_uchar]  from print_uchar::@1
  [93] return 
  to:@return

(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
utoa_append: scope:[utoa_append]  from utoa::@5
  [94] phi()
  to:utoa_append::@1
utoa_append::@1: scope:[utoa_append]  from utoa_append utoa_append::@2
  [95] (byte) utoa_append::digit#2 ← phi( utoa_append/(byte) 0 utoa_append::@2/(byte) utoa_append::digit#1 )
  [95] (word) utoa_append::value#2 ← phi( utoa_append/(word) utoa_append::value#0 utoa_append::@2/(word) utoa_append::value#1 )
  [96] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2
  to:utoa_append::@3
utoa_append::@3: scope:[utoa_append]  from utoa_append::@1
  [97] *((byte*) utoa_append::buffer#0) ← *((const byte*) DIGITS + (byte) utoa_append::digit#2)
  to:utoa_append::@return
utoa_append::@return: scope:[utoa_append]  from utoa_append::@3
  [98] return 
  to:@return
utoa_append::@2: scope:[utoa_append]  from utoa_append::@1
  [99] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2
  [100] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0
  to:utoa_append::@1

(void()) print_char((byte) print_char::ch)
print_char: scope:[print_char]  from print_str::@2 print_uchar print_uchar::@1
  [101] (byte*) print_char_cursor#36 ← phi( print_str::@2/(byte*) print_char_cursor#1 print_uchar/(byte*) print_char_cursor#52 print_uchar::@1/(byte*) print_char_cursor#12 )
  [101] (byte) print_char::ch#3 ← phi( print_str::@2/(byte) print_char::ch#0 print_uchar/(byte) print_char::ch#1 print_uchar::@1/(byte) print_char::ch#2 )
  [102] *((byte*) print_char_cursor#36) ← (byte) print_char::ch#3
  [103] (byte*) print_char_cursor#12 ← ++ (byte*) print_char_cursor#36
  to:print_char::@return
print_char::@return: scope:[print_char]  from print_char
  [104] return 
  to:@return
