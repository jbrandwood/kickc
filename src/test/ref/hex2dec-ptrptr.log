Setting inferred volatile on symbol affected by address-of (byte~) utoa16w::$2 ← call utoa16n (byte~) utoa16w::$1 &(byte*) utoa16w::dst (byte) utoa16w::started 
Setting inferred volatile on symbol affected by address-of (byte~) utoa16w::$5 ← call utoa16n (number~) utoa16w::$4 &(volatile byte*) utoa16w::dst (byte) utoa16w::started 
Setting inferred volatile on symbol affected by address-of (byte~) utoa16w::$8 ← call utoa16n (byte~) utoa16w::$7 &(volatile byte*) utoa16w::dst (byte) utoa16w::started 
Setting inferred volatile on symbol affected by address-of (byte~) utoa16w::$11 ← call utoa16n (number~) utoa16w::$10 &(volatile byte*) utoa16w::dst (number) 1 

CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from __start
  call cls 
  to:main::@1
main::@1: scope:[main]  from main
  (byte*) main::screen#0 ← (byte*)(number) $400
  (word) utoa16w::value#0 ← (number) 0
  (volatile byte*) utoa16w::dst ← (byte*) main::screen#0
  call utoa16w 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte*) main::screen#5 ← phi( main::@1/(byte*) main::screen#0 )
  (byte*) main::screen#1 ← (byte*) main::screen#5 + (number) $28
  (word) utoa16w::value#1 ← (number) $4d2
  (volatile byte*) utoa16w::dst ← (byte*) main::screen#1
  call utoa16w 
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte*) main::screen#6 ← phi( main::@2/(byte*) main::screen#1 )
  (byte*) main::screen#2 ← (byte*) main::screen#6 + (number) $28
  (word) utoa16w::value#2 ← (number) $162e
  (volatile byte*) utoa16w::dst ← (byte*) main::screen#2
  call utoa16w 
  to:main::@4
main::@4: scope:[main]  from main::@3
  (byte*) main::screen#7 ← phi( main::@3/(byte*) main::screen#2 )
  (byte*) main::screen#3 ← (byte*) main::screen#7 + (number) $28
  (word) utoa16w::value#3 ← (number) $270f
  (volatile byte*) utoa16w::dst ← (byte*) main::screen#3
  call utoa16w 
  to:main::@5
main::@5: scope:[main]  from main::@4
  (byte*) main::screen#8 ← phi( main::@4/(byte*) main::screen#3 )
  (byte*) main::screen#4 ← (byte*) main::screen#8 + (number) $28
  (word) utoa16w::value#4 ← (number) $e608
  (volatile byte*) utoa16w::dst ← (byte*) main::screen#4
  call utoa16w 
  to:main::@6
main::@6: scope:[main]  from main::@5
  to:main::@return
main::@return: scope:[main]  from main::@6
  return 
  to:@return

(void()) cls()
cls: scope:[cls]  from main
  (byte*~) cls::$0 ← (const byte*) cls::screen + (number) $3e7
  (byte*) cls::sc#0 ← (const byte*) cls::screen
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  (byte*) cls::sc#2 ← phi( cls/(byte*) cls::sc#0 cls::@1/(byte*) cls::sc#1 )
  *((byte*) cls::sc#2) ← (byte) ' '
  (byte*) cls::sc#1 ← (byte*) cls::sc#2 + rangenext(cls::screen,cls::$0)
  (bool~) cls::$1 ← (byte*) cls::sc#1 != rangelast(cls::screen,cls::$0)
  if((bool~) cls::$1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  return 
  to:@return

(void()) utoa16w((word) utoa16w::value , (volatile byte*) utoa16w::dst)
utoa16w: scope:[utoa16w]  from main::@1 main::@2 main::@3 main::@4 main::@5
  (word) utoa16w::value#5 ← phi( main::@1/(word) utoa16w::value#0 main::@2/(word) utoa16w::value#1 main::@3/(word) utoa16w::value#2 main::@4/(word) utoa16w::value#3 main::@5/(word) utoa16w::value#4 )
  (byte) utoa16w::started#0 ← (byte) 0
  (byte~) utoa16w::$0 ← > (word) utoa16w::value#5
  (byte~) utoa16w::$1 ← (byte~) utoa16w::$0 >> (number) 4
  (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$1
  (word**) utoa16n::dst#0 ← &(volatile byte*) utoa16w::dst
  (byte) utoa16n::started#0 ← (byte) utoa16w::started#0
  call utoa16n 
  (byte) utoa16n::return#0 ← (byte) utoa16n::return#5
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  (word) utoa16w::value#6 ← phi( utoa16w/(word) utoa16w::value#5 )
  (byte) utoa16n::return#6 ← phi( utoa16w/(byte) utoa16n::return#0 )
  (byte~) utoa16w::$2 ← (byte) utoa16n::return#6
  (byte) utoa16w::started#1 ← (byte~) utoa16w::$2
  (byte~) utoa16w::$3 ← > (word) utoa16w::value#6
  (number~) utoa16w::$4 ← (byte~) utoa16w::$3 & (number) $f
  (byte) utoa16n::nybble#1 ← (number~) utoa16w::$4
  (word**) utoa16n::dst#1 ← &(volatile byte*) utoa16w::dst
  (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  call utoa16n 
  (byte) utoa16n::return#1 ← (byte) utoa16n::return#5
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  (word) utoa16w::value#7 ← phi( utoa16w::@1/(word) utoa16w::value#6 )
  (byte) utoa16n::return#7 ← phi( utoa16w::@1/(byte) utoa16n::return#1 )
  (byte~) utoa16w::$5 ← (byte) utoa16n::return#7
  (byte) utoa16w::started#2 ← (byte~) utoa16w::$5
  (byte~) utoa16w::$6 ← < (word) utoa16w::value#7
  (byte~) utoa16w::$7 ← (byte~) utoa16w::$6 >> (number) 4
  (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$7
  (word**) utoa16n::dst#2 ← &(volatile byte*) utoa16w::dst
  (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  call utoa16n 
  (byte) utoa16n::return#2 ← (byte) utoa16n::return#5
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  (word) utoa16w::value#8 ← phi( utoa16w::@2/(word) utoa16w::value#7 )
  (byte) utoa16n::return#8 ← phi( utoa16w::@2/(byte) utoa16n::return#2 )
  (byte~) utoa16w::$8 ← (byte) utoa16n::return#8
  (byte) utoa16w::started#3 ← (byte~) utoa16w::$8
  (byte~) utoa16w::$9 ← < (word) utoa16w::value#8
  (number~) utoa16w::$10 ← (byte~) utoa16w::$9 & (number) $f
  (byte) utoa16n::nybble#3 ← (number~) utoa16w::$10
  (word**) utoa16n::dst#3 ← &(volatile byte*) utoa16w::dst
  (byte) utoa16n::started#3 ← (number) 1
  call utoa16n 
  (byte) utoa16n::return#3 ← (byte) utoa16n::return#5
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  *((volatile byte*) utoa16w::dst) ← (number) 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  return 
  to:@return

(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  (word**) utoa16n::dst#6 ← phi( utoa16w/(word**) utoa16n::dst#0 utoa16w::@1/(word**) utoa16n::dst#1 utoa16w::@2/(word**) utoa16n::dst#2 utoa16w::@3/(word**) utoa16n::dst#3 )
  (byte) utoa16n::started#7 ← phi( utoa16w/(byte) utoa16n::started#0 utoa16w::@1/(byte) utoa16n::started#1 utoa16w::@2/(byte) utoa16n::started#2 utoa16w::@3/(byte) utoa16n::started#3 )
  (byte) utoa16n::nybble#4 ← phi( utoa16w/(byte) utoa16n::nybble#0 utoa16w::@1/(byte) utoa16n::nybble#1 utoa16w::@2/(byte) utoa16n::nybble#2 utoa16w::@3/(byte) utoa16n::nybble#3 )
  (bool~) utoa16n::$0 ← (byte) utoa16n::nybble#4 != (number) 0
  (bool~) utoa16n::$1 ← ! (bool~) utoa16n::$0
  if((bool~) utoa16n::$1) goto utoa16n::@1
  to:utoa16n::@3
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  (word**) utoa16n::dst#5 ← phi( utoa16n/(word**) utoa16n::dst#6 utoa16n::@3/(word**) utoa16n::dst#7 )
  (byte) utoa16n::nybble#6 ← phi( utoa16n/(byte) utoa16n::nybble#4 utoa16n::@3/(byte) utoa16n::nybble#7 )
  (byte) utoa16n::started#5 ← phi( utoa16n/(byte) utoa16n::started#7 utoa16n::@3/(byte) utoa16n::started#4 )
  (bool~) utoa16n::$2 ← (byte) utoa16n::started#5 != (number) 0
  (bool~) utoa16n::$3 ← ! (bool~) utoa16n::$2
  if((bool~) utoa16n::$3) goto utoa16n::@2
  to:utoa16n::@4
utoa16n::@3: scope:[utoa16n]  from utoa16n
  (word**) utoa16n::dst#7 ← phi( utoa16n/(word**) utoa16n::dst#6 )
  (byte) utoa16n::nybble#7 ← phi( utoa16n/(byte) utoa16n::nybble#4 )
  (byte) utoa16n::started#4 ← (number) 1
  to:utoa16n::@1
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1 utoa16n::@4
  (byte) utoa16n::started#6 ← phi( utoa16n::@1/(byte) utoa16n::started#5 utoa16n::@4/(byte) utoa16n::started#8 )
  (byte) utoa16n::return#4 ← (byte) utoa16n::started#6
  to:utoa16n::@return
utoa16n::@4: scope:[utoa16n]  from utoa16n::@1
  (byte) utoa16n::started#8 ← phi( utoa16n::@1/(byte) utoa16n::started#5 )
  (word**) utoa16n::dst#4 ← phi( utoa16n::@1/(word**) utoa16n::dst#5 )
  (byte) utoa16n::nybble#5 ← phi( utoa16n::@1/(byte) utoa16n::nybble#6 )
  *(*((word**) utoa16n::dst#4)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#5)
  *((word**) utoa16n::dst#4) ← ++ *((word**) utoa16n::dst#4)
  to:utoa16n::@2
utoa16n::@return: scope:[utoa16n]  from utoa16n::@2
  (byte) utoa16n::return#9 ← phi( utoa16n::@2/(byte) utoa16n::return#4 )
  (byte) utoa16n::return#5 ← (byte) utoa16n::return#9
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
(const byte*) DIGITS[]  = (byte*) "0123456789abcdef"
(void()) __start()
(label) __start::@1
(label) __start::@return
(void()) cls()
(byte*~) cls::$0
(bool~) cls::$1
(label) cls::@1
(label) cls::@return
(byte*) cls::sc
(byte*) cls::sc#0
(byte*) cls::sc#1
(byte*) cls::sc#2
(const byte*) cls::screen = (byte*)(number) $400
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@return
(byte*) main::screen
(byte*) main::screen#0
(byte*) main::screen#1
(byte*) main::screen#2
(byte*) main::screen#3
(byte*) main::screen#4
(byte*) main::screen#5
(byte*) main::screen#6
(byte*) main::screen#7
(byte*) main::screen#8
(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
(bool~) utoa16n::$0
(bool~) utoa16n::$1
(bool~) utoa16n::$2
(bool~) utoa16n::$3
(label) utoa16n::@1
(label) utoa16n::@2
(label) utoa16n::@3
(label) utoa16n::@4
(label) utoa16n::@return
(word**) utoa16n::dst
(word**) utoa16n::dst#0
(word**) utoa16n::dst#1
(word**) utoa16n::dst#2
(word**) utoa16n::dst#3
(word**) utoa16n::dst#4
(word**) utoa16n::dst#5
(word**) utoa16n::dst#6
(word**) utoa16n::dst#7
(byte) utoa16n::nybble
(byte) utoa16n::nybble#0
(byte) utoa16n::nybble#1
(byte) utoa16n::nybble#2
(byte) utoa16n::nybble#3
(byte) utoa16n::nybble#4
(byte) utoa16n::nybble#5
(byte) utoa16n::nybble#6
(byte) utoa16n::nybble#7
(byte) utoa16n::return
(byte) utoa16n::return#0
(byte) utoa16n::return#1
(byte) utoa16n::return#2
(byte) utoa16n::return#3
(byte) utoa16n::return#4
(byte) utoa16n::return#5
(byte) utoa16n::return#6
(byte) utoa16n::return#7
(byte) utoa16n::return#8
(byte) utoa16n::return#9
(byte) utoa16n::started
(byte) utoa16n::started#0
(byte) utoa16n::started#1
(byte) utoa16n::started#2
(byte) utoa16n::started#3
(byte) utoa16n::started#4
(byte) utoa16n::started#5
(byte) utoa16n::started#6
(byte) utoa16n::started#7
(byte) utoa16n::started#8
(void()) utoa16w((word) utoa16w::value , (volatile byte*) utoa16w::dst)
(byte~) utoa16w::$0
(byte~) utoa16w::$1
(number~) utoa16w::$10
(byte~) utoa16w::$2
(byte~) utoa16w::$3
(number~) utoa16w::$4
(byte~) utoa16w::$5
(byte~) utoa16w::$6
(byte~) utoa16w::$7
(byte~) utoa16w::$8
(byte~) utoa16w::$9
(label) utoa16w::@1
(label) utoa16w::@2
(label) utoa16w::@3
(label) utoa16w::@4
(label) utoa16w::@return
(volatile byte*) utoa16w::dst loadstore
(byte) utoa16w::started
(byte) utoa16w::started#0
(byte) utoa16w::started#1
(byte) utoa16w::started#2
(byte) utoa16w::started#3
(word) utoa16w::value
(word) utoa16w::value#0
(word) utoa16w::value#1
(word) utoa16w::value#2
(word) utoa16w::value#3
(word) utoa16w::value#4
(word) utoa16w::value#5
(word) utoa16w::value#6
(word) utoa16w::value#7
(word) utoa16w::value#8

Adding number conversion cast (unumber) 0 in (word) utoa16w::value#0 ← (number) 0
Adding number conversion cast (unumber) $28 in (byte*) main::screen#1 ← (byte*) main::screen#5 + (number) $28
Adding number conversion cast (unumber) $4d2 in (word) utoa16w::value#1 ← (number) $4d2
Adding number conversion cast (unumber) $28 in (byte*) main::screen#2 ← (byte*) main::screen#6 + (number) $28
Adding number conversion cast (unumber) $162e in (word) utoa16w::value#2 ← (number) $162e
Adding number conversion cast (unumber) $28 in (byte*) main::screen#3 ← (byte*) main::screen#7 + (number) $28
Adding number conversion cast (unumber) $270f in (word) utoa16w::value#3 ← (number) $270f
Adding number conversion cast (unumber) $28 in (byte*) main::screen#4 ← (byte*) main::screen#8 + (number) $28
Adding number conversion cast (unumber) $e608 in (word) utoa16w::value#4 ← (number) $e608
Adding number conversion cast (unumber) $3e7 in (byte*~) cls::$0 ← (const byte*) cls::screen + (number) $3e7
Adding number conversion cast (unumber) 4 in (byte~) utoa16w::$1 ← (byte~) utoa16w::$0 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) utoa16w::$4 ← (byte~) utoa16w::$3 & (number) $f
Adding number conversion cast (unumber) utoa16w::$4 in (number~) utoa16w::$4 ← (byte~) utoa16w::$3 & (unumber)(number) $f
Adding number conversion cast (unumber) 4 in (byte~) utoa16w::$7 ← (byte~) utoa16w::$6 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) utoa16w::$10 ← (byte~) utoa16w::$9 & (number) $f
Adding number conversion cast (unumber) utoa16w::$10 in (number~) utoa16w::$10 ← (byte~) utoa16w::$9 & (unumber)(number) $f
Adding number conversion cast (unumber) 1 in (byte) utoa16n::started#3 ← (number) 1
Adding number conversion cast (unumber) 0 in *((volatile byte*) utoa16w::dst) ← (number) 0
Adding number conversion cast (unumber) 0 in (bool~) utoa16n::$0 ← (byte) utoa16n::nybble#4 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) utoa16n::$2 ← (byte) utoa16n::started#5 != (number) 0
Adding number conversion cast (unumber) 1 in (byte) utoa16n::started#4 ← (number) 1
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (word) utoa16w::value#0 ← (unumber)(number) 0
Inlining cast (word) utoa16w::value#1 ← (unumber)(number) $4d2
Inlining cast (word) utoa16w::value#2 ← (unumber)(number) $162e
Inlining cast (word) utoa16w::value#3 ← (unumber)(number) $270f
Inlining cast (word) utoa16w::value#4 ← (unumber)(number) $e608
Inlining cast (byte) utoa16n::started#3 ← (unumber)(number) 1
Inlining cast *((volatile byte*) utoa16w::dst) ← (unumber)(number) 0
Inlining cast (byte) utoa16n::started#4 ← (unumber)(number) 1
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast $4d2
Simplifying constant integer cast $28
Simplifying constant integer cast $162e
Simplifying constant integer cast $28
Simplifying constant integer cast $270f
Simplifying constant integer cast $28
Simplifying constant integer cast $e608
Simplifying constant integer cast $3e7
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $4d2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $162e
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $270f
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $e608
Finalized unsigned number type (word) $3e7
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) utoa16w::$4 ← (byte~) utoa16w::$3 & (byte) $f
Inferred type updated to byte in (unumber~) utoa16w::$10 ← (byte~) utoa16w::$9 & (byte) $f
Inversing boolean not [77] (bool~) utoa16n::$1 ← (byte) utoa16n::nybble#4 == (byte) 0 from [76] (bool~) utoa16n::$0 ← (byte) utoa16n::nybble#4 != (byte) 0
Inversing boolean not [81] (bool~) utoa16n::$3 ← (byte) utoa16n::started#5 == (byte) 0 from [80] (bool~) utoa16n::$2 ← (byte) utoa16n::started#5 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias main::screen#0 = main::screen#5 
Alias main::screen#1 = main::screen#6 
Alias main::screen#2 = main::screen#7 
Alias main::screen#3 = main::screen#8 
Alias utoa16n::nybble#0 = utoa16w::$1 
Alias utoa16n::return#0 = utoa16n::return#6 
Alias utoa16w::value#5 = utoa16w::value#6 utoa16w::value#7 utoa16w::value#8 
Alias utoa16w::started#1 = utoa16w::$2 
Alias utoa16n::nybble#1 = utoa16w::$4 
Alias utoa16n::return#1 = utoa16n::return#7 
Alias utoa16w::started#2 = utoa16w::$5 
Alias utoa16n::nybble#2 = utoa16w::$7 
Alias utoa16n::return#2 = utoa16n::return#8 
Alias utoa16w::started#3 = utoa16w::$8 
Alias utoa16n::nybble#3 = utoa16w::$10 
Alias utoa16n::nybble#4 = utoa16n::nybble#7 
Alias utoa16n::dst#6 = utoa16n::dst#7 
Alias utoa16n::return#4 = utoa16n::started#6 utoa16n::return#9 utoa16n::return#5 
Alias utoa16n::nybble#5 = utoa16n::nybble#6 
Alias utoa16n::dst#4 = utoa16n::dst#5 
Alias utoa16n::started#5 = utoa16n::started#8 
Successful SSA optimization Pass2AliasElimination
Alias utoa16n::nybble#4 = utoa16n::nybble#5 
Alias utoa16n::dst#4 = utoa16n::dst#6 
Alias utoa16n::return#4 = utoa16n::started#5 
Successful SSA optimization Pass2AliasElimination
Simple Condition (bool~) cls::$1 [28] if((byte*) cls::sc#1!=rangelast(cls::screen,cls::$0)) goto cls::@1
Simple Condition (bool~) utoa16n::$1 [63] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@1
Simple Condition (bool~) utoa16n::$3 [66] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [22] (byte*~) cls::$0 ← (const byte*) cls::screen + (word) $3e7
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#0 = (byte*) 1024
Constant (const word) utoa16w::value#0 = 0
Constant (const word) utoa16w::value#1 = $4d2
Constant (const word) utoa16w::value#2 = $162e
Constant (const word) utoa16w::value#3 = $270f
Constant (const word) utoa16w::value#4 = $e608
Constant (const byte*) cls::$0 = cls::screen+$3e7
Constant (const byte*) cls::sc#0 = cls::screen
Constant (const byte) utoa16w::started#0 = 0
Constant (const word**) utoa16n::dst#0 = &utoa16w::dst
Constant (const word**) utoa16n::dst#1 = &utoa16w::dst
Constant (const word**) utoa16n::dst#2 = &utoa16w::dst
Constant (const word**) utoa16n::dst#3 = &utoa16w::dst
Constant (const byte) utoa16n::started#3 = 1
Constant (const byte) utoa16n::started#4 = 1
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) utoa16n::started#0 = utoa16w::started#0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [26] cls::sc#1 ← ++ cls::sc#2 to ++
Resolved ranged comparison value [28] if(cls::sc#1!=rangelast(cls::screen,cls::$0)) goto cls::@1 to (byte*)(const byte*) cls::$0+(number) 1
Eliminating unused variable (byte) utoa16w::started#3 and assignment [38] (byte) utoa16w::started#3 ← (byte) utoa16n::return#2
Eliminating unused variable (byte) utoa16n::return#3 and assignment [42] (byte) utoa16n::return#3 ← (byte) utoa16n::return#4
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused variable (byte) utoa16n::return#2 and assignment [37] (byte) utoa16n::return#2 ← (byte) utoa16n::return#4
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) 1 in [19] if((byte*) cls::sc#1!=(byte*)(const byte*) cls::$0+(number) 1) goto cls::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const byte*) cls::$0+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [3] (byte*) main::screen#1 ← (const byte*) main::screen#0 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#1 = main::screen#0+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [5] (byte*) main::screen#2 ← (const byte*) main::screen#1 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#2 = main::screen#1+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [7] (byte*) main::screen#3 ← (const byte*) main::screen#2 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#3 = main::screen#2+$28
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [9] (byte*) main::screen#4 ← (const byte*) main::screen#3 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#4 = main::screen#3+$28
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with different constant siblings (const byte*) main::screen#0
Inlining constant with different constant siblings (const byte*) main::screen#1
Inlining constant with different constant siblings (const byte*) main::screen#2
Inlining constant with different constant siblings (const byte*) main::screen#3
Inlining constant with different constant siblings (const byte*) main::screen#4
Inlining constant with var siblings (const byte*) cls::sc#0
Inlining constant with var siblings (const word) utoa16w::value#0
Inlining constant with var siblings (const word) utoa16w::value#1
Inlining constant with var siblings (const word) utoa16w::value#2
Inlining constant with var siblings (const word) utoa16w::value#3
Inlining constant with var siblings (const word) utoa16w::value#4
Inlining constant with var siblings (const byte) utoa16w::started#0
Inlining constant with var siblings (const word**) utoa16n::dst#0
Inlining constant with var siblings (const word**) utoa16n::dst#1
Inlining constant with var siblings (const word**) utoa16n::dst#2
Inlining constant with var siblings (const word**) utoa16n::dst#3
Inlining constant with var siblings (const byte) utoa16n::started#3
Inlining constant with var siblings (const byte) utoa16n::started#4
Inlining constant with var siblings (const byte) utoa16n::started#0
Constant inlined main::screen#0 = (byte*) 1024
Constant inlined main::screen#1 = (byte*) 1024+(byte) $28
Constant inlined main::screen#4 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28
Constant inlined utoa16w::value#2 = (word) $162e
Constant inlined cls::sc#0 = (const byte*) cls::screen
Constant inlined utoa16w::value#1 = (word) $4d2
Constant inlined main::screen#2 = (byte*) 1024+(byte) $28+(byte) $28
Constant inlined utoa16w::value#0 = (byte) 0
Constant inlined main::screen#3 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28
Constant inlined utoa16w::started#0 = (byte) 0
Constant inlined utoa16n::started#0 = (byte) 0
Constant inlined cls::$0 = (const byte*) cls::screen+(word) $3e7
Constant inlined utoa16n::dst#1 = &(volatile byte*) utoa16w::dst
Constant inlined utoa16n::dst#0 = &(volatile byte*) utoa16w::dst
Constant inlined utoa16w::value#4 = (word) $e608
Constant inlined utoa16w::value#3 = (word) $270f
Constant inlined utoa16n::started#3 = (byte) 1
Constant inlined utoa16n::dst#3 = &(volatile byte*) utoa16w::dst
Constant inlined utoa16n::started#4 = (byte) 1
Constant inlined utoa16n::dst#2 = &(volatile byte*) utoa16w::dst
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values (word**) utoa16n::dst#4 &(volatile byte*) utoa16w::dst
Successful SSA optimization Pass2IdenticalPhiElimination
Added new block during phi lifting cls::@2(between cls::@1 and cls::@1)
Added new block during phi lifting utoa16n::@5(between utoa16n and utoa16n::@1)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of utoa16n::@3
Adding NOP phi() at start of utoa16n::@2
Adding NOP phi() at start of cls
CALL GRAPH
Calls in [main] to cls:1 utoa16w:3 utoa16w:5 utoa16w:7 utoa16w:9 utoa16w:11 
Calls in [utoa16w] to utoa16n:18 utoa16n:26 utoa16n:34 utoa16n:38 

Created 5 initial phi equivalence classes
Coalesced [17] utoa16n::nybble#8 ← utoa16n::nybble#0
Coalesced [24] utoa16n::nybble#9 ← utoa16n::nybble#1
Coalesced [25] utoa16n::started#9 ← utoa16n::started#1
Coalesced [32] utoa16n::nybble#10 ← utoa16n::nybble#2
Coalesced [33] utoa16n::started#10 ← utoa16n::started#2
Coalesced [37] utoa16n::nybble#11 ← utoa16n::nybble#3
Coalesced [50] utoa16n::return#10 ← utoa16n::started#7
Coalesced [57] cls::sc#3 ← cls::sc#1
Coalesced down to 4 phi equivalence classes
Culled Empty Block (label) main::@6
Culled Empty Block (label) utoa16n::@3
Culled Empty Block (label) utoa16n::@2
Culled Empty Block (label) cls::@2
Renumbering block utoa16n::@4 to utoa16n::@2
Renumbering block utoa16n::@5 to utoa16n::@3
Adding NOP phi() at start of main
Adding NOP phi() at start of utoa16n::@3
Adding NOP phi() at start of cls

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call cls 
  to:main::@1
main::@1: scope:[main]  from main
  [2] (volatile byte*) utoa16w::dst ← (byte*) 1024
  [3] call utoa16w 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28
  [5] call utoa16w 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [6] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28
  [7] call utoa16w 
  to:main::@4
main::@4: scope:[main]  from main::@3
  [8] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28
  [9] call utoa16w 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [10] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28
  [11] call utoa16w 
  to:main::@return
main::@return: scope:[main]  from main::@5
  [12] return 
  to:@return

(void()) utoa16w((word) utoa16w::value , (volatile byte*) utoa16w::dst)
utoa16w: scope:[utoa16w]  from main::@1 main::@2 main::@3 main::@4 main::@5
  [13] (word) utoa16w::value#5 ← phi( main::@1/(byte) 0 main::@2/(word) $4d2 main::@3/(word) $162e main::@4/(word) $270f main::@5/(word) $e608 )
  [14] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5
  [15] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4
  [16] call utoa16n 
  [17] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  [18] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
  [19] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5
  [20] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$3 & (byte) $f
  [21] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  [22] call utoa16n 
  [23] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  [24] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
  [25] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5
  [26] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4
  [27] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  [28] call utoa16n 
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  [29] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5
  [30] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$9 & (byte) $f
  [31] call utoa16n 
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  [32] *((volatile byte*) utoa16w::dst) ← (byte) 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  [33] return 
  to:@return

(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  [34] (byte) utoa16n::started#7 ← phi( utoa16w/(byte) 0 utoa16w::@1/(byte) utoa16n::started#1 utoa16w::@2/(byte) utoa16n::started#2 utoa16w::@3/(byte) 1 )
  [34] (byte) utoa16n::nybble#4 ← phi( utoa16w/(byte) utoa16n::nybble#0 utoa16w::@1/(byte) utoa16n::nybble#1 utoa16w::@2/(byte) utoa16n::nybble#2 utoa16w::@3/(byte) utoa16n::nybble#3 )
  [35] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3
  to:utoa16n::@1
utoa16n::@3: scope:[utoa16n]  from utoa16n
  [36] phi()
  to:utoa16n::@1
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  [37] (byte) utoa16n::return#4 ← phi( utoa16n::@3/(byte) utoa16n::started#7 utoa16n/(byte) 1 )
  [38] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return
  to:utoa16n::@2
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1
  [39] *(*(&(volatile byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4)
  [40] *(&(volatile byte*) utoa16w::dst) ← ++ *(&(volatile byte*) utoa16w::dst)
  to:utoa16n::@return
utoa16n::@return: scope:[utoa16n]  from utoa16n::@1 utoa16n::@2
  [41] return 
  to:@return

(void()) cls()
cls: scope:[cls]  from main
  [42] phi()
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  [43] (byte*) cls::sc#2 ← phi( cls/(const byte*) cls::screen cls::@1/(byte*) cls::sc#1 )
  [44] *((byte*) cls::sc#2) ← (byte) ' '
  [45] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2
  [46] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  [47] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) cls()
(byte*) cls::sc
(byte*) cls::sc#1 151.5
(byte*) cls::sc#2 151.5
(void()) main()
(byte*) main::screen
(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
(word**) utoa16n::dst
(byte) utoa16n::nybble
(byte) utoa16n::nybble#0 22.0
(byte) utoa16n::nybble#1 11.0
(byte) utoa16n::nybble#2 11.0
(byte) utoa16n::nybble#3 22.0
(byte) utoa16n::nybble#4 49.2
(byte) utoa16n::return
(byte) utoa16n::return#0 22.0
(byte) utoa16n::return#1 22.0
(byte) utoa16n::return#4 32.0
(byte) utoa16n::started
(byte) utoa16n::started#1 22.0
(byte) utoa16n::started#2 22.0
(byte) utoa16n::started#7 41.0
(void()) utoa16w((word) utoa16w::value , (volatile byte*) utoa16w::dst)
(byte~) utoa16w::$0 22.0
(byte~) utoa16w::$3 22.0
(byte~) utoa16w::$6 22.0
(byte~) utoa16w::$9 22.0
(volatile byte*) utoa16w::dst loadstore 0.65625
(byte) utoa16w::started
(byte) utoa16w::started#1 7.333333333333333
(byte) utoa16w::started#2 7.333333333333333
(word) utoa16w::value
(word) utoa16w::value#5 2.75

Initial phi equivalence classes
[ utoa16w::value#5 ]
[ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
[ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
[ cls::sc#2 cls::sc#1 ]
Added variable utoa16w::dst to live range equivalence class [ utoa16w::dst ]
Added variable utoa16w::$0 to live range equivalence class [ utoa16w::$0 ]
Added variable utoa16n::return#0 to live range equivalence class [ utoa16n::return#0 ]
Added variable utoa16w::started#1 to live range equivalence class [ utoa16w::started#1 ]
Added variable utoa16w::$3 to live range equivalence class [ utoa16w::$3 ]
Added variable utoa16n::return#1 to live range equivalence class [ utoa16n::return#1 ]
Added variable utoa16w::started#2 to live range equivalence class [ utoa16w::started#2 ]
Added variable utoa16w::$6 to live range equivalence class [ utoa16w::$6 ]
Added variable utoa16w::$9 to live range equivalence class [ utoa16w::$9 ]
Complete equivalence classes
[ utoa16w::value#5 ]
[ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
[ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
[ cls::sc#2 cls::sc#1 ]
[ utoa16w::dst ]
[ utoa16w::$0 ]
[ utoa16n::return#0 ]
[ utoa16w::started#1 ]
[ utoa16w::$3 ]
[ utoa16n::return#1 ]
[ utoa16w::started#2 ]
[ utoa16w::$6 ]
[ utoa16w::$9 ]
Allocated zp[2]:2 [ utoa16w::value#5 ]
Allocated zp[1]:4 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
Allocated zp[1]:5 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Allocated zp[2]:6 [ cls::sc#2 cls::sc#1 ]
Allocated zp[2]:8 [ utoa16w::dst ]
Allocated zp[1]:10 [ utoa16w::$0 ]
Allocated zp[1]:11 [ utoa16n::return#0 ]
Allocated zp[1]:12 [ utoa16w::started#1 ]
Allocated zp[1]:13 [ utoa16w::$3 ]
Allocated zp[1]:14 [ utoa16n::return#1 ]
Allocated zp[1]:15 [ utoa16w::started#2 ]
Allocated zp[1]:16 [ utoa16w::$6 ]
Allocated zp[1]:17 [ utoa16w::$9 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Testing binary to hex conversion using pointer to pointer
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // main
main: {
    // [1] call cls 
    // [42] phi from main to cls [phi:main->cls]
  cls_from_main:
    jsr cls
    jmp __b1
    // main::@1
  __b1:
    // [2] (volatile byte*) utoa16w::dst ← (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z utoa16w.dst
    lda #>$400
    sta.z utoa16w.dst+1
    // [3] call utoa16w 
    // [13] phi from main::@1 to utoa16w [phi:main::@1->utoa16w]
  utoa16w_from___b1:
    // [13] phi (word) utoa16w::value#5 = (byte) 0 [phi:main::@1->utoa16w#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z utoa16w.value
    lda #>0
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b2
    // main::@2
  __b2:
    // [4] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28
    sta.z utoa16w.dst
    lda #>$400+$28
    sta.z utoa16w.dst+1
    // [5] call utoa16w 
    // [13] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
  utoa16w_from___b2:
    // [13] phi (word) utoa16w::value#5 = (word) $4d2 [phi:main::@2->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z utoa16w.value
    lda #>$4d2
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b3
    // main::@3
  __b3:
    // [6] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28
    sta.z utoa16w.dst+1
    // [7] call utoa16w 
    // [13] phi from main::@3 to utoa16w [phi:main::@3->utoa16w]
  utoa16w_from___b3:
    // [13] phi (word) utoa16w::value#5 = (word) $162e [phi:main::@3->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$162e
    sta.z utoa16w.value
    lda #>$162e
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b4
    // main::@4
  __b4:
    // [8] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28
    sta.z utoa16w.dst+1
    // [9] call utoa16w 
    // [13] phi from main::@4 to utoa16w [phi:main::@4->utoa16w]
  utoa16w_from___b4:
    // [13] phi (word) utoa16w::value#5 = (word) $270f [phi:main::@4->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$270f
    sta.z utoa16w.value
    lda #>$270f
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b5
    // main::@5
  __b5:
    // [10] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta.z utoa16w.dst+1
    // [11] call utoa16w 
    // [13] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
  utoa16w_from___b5:
    // [13] phi (word) utoa16w::value#5 = (word) $e608 [phi:main::@5->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$e608
    sta.z utoa16w.value
    lda #>$e608
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __breturn
    // main::@return
  __breturn:
    // [12] return 
    rts
}
  // utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zp(2) value, byte* zp(8) dst)
utoa16w: {
    .label dst = 8
    .label __0 = $a
    .label __3 = $d
    .label __6 = $10
    .label __9 = $11
    .label started = $c
    .label started_1 = $f
    .label value = 2
    // [14] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 -- vbuz1=_hi_vwuz2 
    lda.z value+1
    sta.z __0
    // [15] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda.z __0
    lsr
    lsr
    lsr
    lsr
    sta.z utoa16n.nybble
    // [16] call utoa16n 
    // [34] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
  utoa16n_from_utoa16w:
    // [34] phi (byte) utoa16n::started#7 = (byte) 0 [phi:utoa16w->utoa16n#0] -- vbuz1=vbuc1 
    lda #0
    sta.z utoa16n.started
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [17] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4 -- vbuz1=vbuz2 
    lda.z utoa16n.return_2
    sta.z utoa16n.return
    jmp __b1
    // utoa16w::@1
  __b1:
    // [18] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0 -- vbuz1=vbuz2 
    lda.z utoa16n.return
    sta.z started
    // [19] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5 -- vbuz1=_hi_vwuz2 
    lda.z value+1
    sta.z __3
    // [20] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$3 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and.z __3
    sta.z utoa16n.nybble
    // [21] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1 -- vbuz1=vbuz2 
    lda.z started
    sta.z utoa16n.started
    // [22] call utoa16n 
    // [34] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
  utoa16n_from___b1:
    // [34] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [23] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4 -- vbuz1=vbuz2 
    lda.z utoa16n.return_2
    sta.z utoa16n.return_1
    jmp __b2
    // utoa16w::@2
  __b2:
    // [24] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1 -- vbuz1=vbuz2 
    lda.z utoa16n.return_1
    sta.z started_1
    // [25] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5 -- vbuz1=_lo_vwuz2 
    lda.z value
    sta.z __6
    // [26] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda.z __6
    lsr
    lsr
    lsr
    lsr
    sta.z utoa16n.nybble
    // [27] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2 -- vbuz1=vbuz2 
    lda.z started_1
    sta.z utoa16n.started
    // [28] call utoa16n 
    // [34] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
  utoa16n_from___b2:
    // [34] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b3
    // utoa16w::@3
  __b3:
    // [29] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5 -- vbuz1=_lo_vwuz2 
    lda.z value
    sta.z __9
    // [30] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$9 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and.z __9
    sta.z utoa16n.nybble
    // [31] call utoa16n 
    // [34] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
  utoa16n_from___b3:
    // [34] phi (byte) utoa16n::started#7 = (byte) 1 [phi:utoa16w::@3->utoa16n#0] -- vbuz1=vbuc1 
    lda #1
    sta.z utoa16n.started
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b4
    // utoa16w::@4
  __b4:
    // [32] *((volatile byte*) utoa16w::dst) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp __breturn
    // utoa16w::@return
  __breturn:
    // [33] return 
    rts
}
  // utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte zp(4) nybble, byte zp(5) started)
utoa16n: {
    .label nybble = 4
    .label return = $b
    .label started = 5
    .label return_1 = $e
    .label return_2 = 5
    // [35] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3 -- vbuz1_eq_0_then_la1 
    lda.z nybble
    cmp #0
    beq __b3_from_utoa16n
    // [37] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
  __b1_from_utoa16n:
    // [37] phi (byte) utoa16n::return#4 = (byte) 1 [phi:utoa16n->utoa16n::@1#0] -- vbuz1=vbuc1 
    lda #1
    sta.z return_2
    jmp __b1
    // [36] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
  __b3_from_utoa16n:
    jmp __b3
    // utoa16n::@3
  __b3:
    // [37] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
  __b1_from___b3:
    // [37] phi (byte) utoa16n::return#4 = (byte) utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    jmp __b1
    // utoa16n::@1
  __b1:
    // [38] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return -- vbuz1_eq_0_then_la1 
    lda.z return_2
    cmp #0
    beq __breturn
    jmp __b2
    // utoa16n::@2
  __b2:
    // [39] *(*(&(volatile byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) -- _deref_(_deref_pptc1)=pbuc2_derefidx_vbuz1 
    ldy.z nybble
    lda DIGITS,y
    ldy.z utoa16w.dst
    sty.z $fe
    ldy.z utoa16w.dst+1
    sty.z $ff
    ldy #0
    sta ($fe),y
    // [40] *(&(volatile byte*) utoa16w::dst) ← ++ *(&(volatile byte*) utoa16w::dst) -- _deref_pptc1=_inc__deref_pptc1 
    inc.z utoa16w.dst
    bne !+
    inc.z utoa16w.dst+1
  !:
    jmp __breturn
    // utoa16n::@return
  __breturn:
    // [41] return 
    rts
}
  // cls
cls: {
    .label screen = $400
    .label sc = 6
    // [43] phi from cls to cls::@1 [phi:cls->cls::@1]
  __b1_from_cls:
    // [43] phi (byte*) cls::sc#2 = (const byte*) cls::screen [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta.z sc
    lda #>screen
    sta.z sc+1
    jmp __b1
    // [43] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
  __b1_from___b1:
    // [43] phi (byte*) cls::sc#2 = (byte*) cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    jmp __b1
    // cls::@1
  __b1:
    // [44] *((byte*) cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [45] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [46] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>screen+$3e7+1
    bne __b1_from___b1
    lda.z sc
    cmp #<screen+$3e7+1
    bne __b1_from___b1
    jmp __breturn
    // cls::@return
  __breturn:
    // [47] return 
    rts
}
  // File Data
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef"
  .byte 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] (volatile byte*) utoa16w::dst ← (byte*) 1024 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [4] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [6] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [8] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [10] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [15] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] ( utoa16w:3 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:5 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:7 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:9 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:11 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  ) always clobbers reg byte a 
Statement [26] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] ( utoa16w:3 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:5 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:7 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:9 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:11 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:15 [ utoa16w::started#2 ]
Statement [32] *((volatile byte*) utoa16w::dst) ← (byte) 0 [ ] ( utoa16w:3 [ ] { }  utoa16w:5 [ ] { }  utoa16w:7 [ ] { }  utoa16w:9 [ ] { }  utoa16w:11 [ ] { }  ) always clobbers reg byte a reg byte y 
Statement [39] *(*(&(volatile byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) [ utoa16w::dst utoa16n::return#4 ] ( utoa16w:3::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:5::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:7::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:9::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:11::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:3::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:5::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:7::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:9::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:11::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:3::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:5::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:7::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:9::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:11::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:3::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:5::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:7::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:9::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:11::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Removing always clobbered register reg byte y as potential for zp[1]:5 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Statement [44] *((byte*) cls::sc#2) ← (byte) ' ' [ cls::sc#2 ] ( cls:1 [ cls::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [46] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 [ cls::sc#1 ] ( cls:1 [ cls::sc#1 ] { }  ) always clobbers reg byte a 
Statement [2] (volatile byte*) utoa16w::dst ← (byte*) 1024 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [4] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [6] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [8] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [10] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 [ utoa16w::dst ] (  [ utoa16w::dst ] { }  ) always clobbers reg byte a 
Statement [15] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] ( utoa16w:3 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:5 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:7 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:9 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:11 [ utoa16w::dst utoa16w::value#5 utoa16n::nybble#0 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  ) always clobbers reg byte a 
Statement [26] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] ( utoa16w:3 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:5 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:7 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:9 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:11 [ utoa16w::dst utoa16w::value#5 utoa16w::started#2 utoa16n::nybble#2 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  ) always clobbers reg byte a 
Statement [32] *((volatile byte*) utoa16w::dst) ← (byte) 0 [ ] ( utoa16w:3 [ ] { }  utoa16w:5 [ ] { }  utoa16w:7 [ ] { }  utoa16w:9 [ ] { }  utoa16w:11 [ ] { }  ) always clobbers reg byte a reg byte y 
Statement [39] *(*(&(volatile byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) [ utoa16w::dst utoa16n::return#4 ] ( utoa16w:3::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:5::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:7::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:9::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:11::utoa16n:16 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#0 = utoa16n::nybble#4 } { utoa16n::return#0 = utoa16n::return#4 } }  utoa16w:3::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:5::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:7::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:9::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:11::utoa16n:22 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#1 = utoa16n::nybble#4 } { utoa16n::started#1 = utoa16n::started#7 utoa16w::started#1 } { utoa16n::return#1 = utoa16n::return#4 } }  utoa16w:3::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:5::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:7::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:9::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:11::utoa16n:28 [ utoa16w::value#5 utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#2 = utoa16n::nybble#4 } { utoa16n::started#2 = utoa16n::started#7 utoa16w::started#2 } }  utoa16w:3::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:5::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:7::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:9::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  utoa16w:11::utoa16n:31 [ utoa16w::dst utoa16n::return#4 ] { { utoa16n::nybble#3 = utoa16n::nybble#4 } }  ) always clobbers reg byte a reg byte y 
Statement [44] *((byte*) cls::sc#2) ← (byte) ' ' [ cls::sc#2 ] ( cls:1 [ cls::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [46] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 [ cls::sc#1 ] ( cls:1 [ cls::sc#1 ] { }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ utoa16w::value#5 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] : zp[1]:5 , reg byte x , 
Potential registers zp[2]:6 [ cls::sc#2 cls::sc#1 ] : zp[2]:6 , 
Potential registers zp[2]:8 [ utoa16w::dst ] : zp[2]:8 , 
Potential registers zp[1]:10 [ utoa16w::$0 ] : zp[1]:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ utoa16n::return#0 ] : zp[1]:11 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:12 [ utoa16w::started#1 ] : zp[1]:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ utoa16w::$3 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ utoa16n::return#1 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ utoa16w::started#2 ] : zp[1]:15 , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ utoa16w::$6 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ utoa16w::$9 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [cls] 303: zp[2]:6 [ cls::sc#2 cls::sc#1 ] 
Uplift Scope [utoa16n] 117: zp[1]:5 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] 115.2: zp[1]:4 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] 22: zp[1]:11 [ utoa16n::return#0 ] 22: zp[1]:14 [ utoa16n::return#1 ] 
Uplift Scope [utoa16w] 22: zp[1]:10 [ utoa16w::$0 ] 22: zp[1]:13 [ utoa16w::$3 ] 22: zp[1]:16 [ utoa16w::$6 ] 22: zp[1]:17 [ utoa16w::$9 ] 7.33: zp[1]:12 [ utoa16w::started#1 ] 7.33: zp[1]:15 [ utoa16w::started#2 ] 2.75: zp[2]:2 [ utoa16w::value#5 ] 0.66: zp[2]:8 [ utoa16w::dst ] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [cls] best 979 combination zp[2]:6 [ cls::sc#2 cls::sc#1 ] 
Uplifting [utoa16n] best 927 combination reg byte x [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] reg byte a [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] reg byte x [ utoa16n::return#0 ] reg byte x [ utoa16n::return#1 ] 
Limited combination testing to 100 combinations of 128 possible.
Uplifting [utoa16w] best 903 combination reg byte a [ utoa16w::$0 ] reg byte a [ utoa16w::$3 ] reg byte a [ utoa16w::$6 ] reg byte a [ utoa16w::$9 ] zp[1]:12 [ utoa16w::started#1 ] zp[1]:15 [ utoa16w::started#2 ] zp[2]:2 [ utoa16w::value#5 ] zp[2]:8 [ utoa16w::dst ] 
Limited combination testing to 100 combinations of 3072 possible.
Uplifting [main] best 903 combination 
Uplifting [] best 903 combination 
Attempting to uplift remaining variables inzp[1]:12 [ utoa16w::started#1 ]
Uplifting [utoa16w] best 897 combination reg byte x [ utoa16w::started#1 ] 
Attempting to uplift remaining variables inzp[1]:15 [ utoa16w::started#2 ]
Uplifting [utoa16w] best 891 combination reg byte x [ utoa16w::started#2 ] 
Coalescing zero page register [ zp[2]:6 [ cls::sc#2 cls::sc#1 ] ] with [ zp[2]:2 [ utoa16w::value#5 ] ]
Allocated (was zp[2]:6) zp[2]:2 [ cls::sc#2 cls::sc#1 utoa16w::value#5 ]
Allocated (was zp[2]:8) zp[2]:4 [ utoa16w::dst ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Testing binary to hex conversion using pointer to pointer
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // main
main: {
    // [1] call cls 
    // [42] phi from main to cls [phi:main->cls]
  cls_from_main:
    jsr cls
    jmp __b1
    // main::@1
  __b1:
    // [2] (volatile byte*) utoa16w::dst ← (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z utoa16w.dst
    lda #>$400
    sta.z utoa16w.dst+1
    // [3] call utoa16w 
    // [13] phi from main::@1 to utoa16w [phi:main::@1->utoa16w]
  utoa16w_from___b1:
    // [13] phi (word) utoa16w::value#5 = (byte) 0 [phi:main::@1->utoa16w#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z utoa16w.value
    lda #>0
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b2
    // main::@2
  __b2:
    // [4] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28
    sta.z utoa16w.dst
    lda #>$400+$28
    sta.z utoa16w.dst+1
    // [5] call utoa16w 
    // [13] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
  utoa16w_from___b2:
    // [13] phi (word) utoa16w::value#5 = (word) $4d2 [phi:main::@2->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z utoa16w.value
    lda #>$4d2
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b3
    // main::@3
  __b3:
    // [6] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28
    sta.z utoa16w.dst+1
    // [7] call utoa16w 
    // [13] phi from main::@3 to utoa16w [phi:main::@3->utoa16w]
  utoa16w_from___b3:
    // [13] phi (word) utoa16w::value#5 = (word) $162e [phi:main::@3->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$162e
    sta.z utoa16w.value
    lda #>$162e
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b4
    // main::@4
  __b4:
    // [8] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28
    sta.z utoa16w.dst+1
    // [9] call utoa16w 
    // [13] phi from main::@4 to utoa16w [phi:main::@4->utoa16w]
  utoa16w_from___b4:
    // [13] phi (word) utoa16w::value#5 = (word) $270f [phi:main::@4->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$270f
    sta.z utoa16w.value
    lda #>$270f
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __b5
    // main::@5
  __b5:
    // [10] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta.z utoa16w.dst+1
    // [11] call utoa16w 
    // [13] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
  utoa16w_from___b5:
    // [13] phi (word) utoa16w::value#5 = (word) $e608 [phi:main::@5->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$e608
    sta.z utoa16w.value
    lda #>$e608
    sta.z utoa16w.value+1
    jsr utoa16w
    jmp __breturn
    // main::@return
  __breturn:
    // [12] return 
    rts
}
  // utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zp(2) value, byte* zp(4) dst)
utoa16w: {
    .label dst = 4
    .label value = 2
    // [14] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // [15] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [16] call utoa16n 
    // [34] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
  utoa16n_from_utoa16w:
    // [34] phi (byte) utoa16n::started#7 = (byte) 0 [phi:utoa16w->utoa16n#0] -- vbuxx=vbuc1 
    ldx #0
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [17] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
    jmp __b1
    // utoa16w::@1
  __b1:
    // [18] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
    // [19] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // [20] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$3 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [21] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
    // [22] call utoa16n 
    // [34] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
  utoa16n_from___b1:
    // [34] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
    // [23] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
    jmp __b2
    // utoa16w::@2
  __b2:
    // [24] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
    // [25] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // [26] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [27] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
    // [28] call utoa16n 
    // [34] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
  utoa16n_from___b2:
    // [34] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b3
    // utoa16w::@3
  __b3:
    // [29] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // [30] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$9 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [31] call utoa16n 
    // [34] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
  utoa16n_from___b3:
    // [34] phi (byte) utoa16n::started#7 = (byte) 1 [phi:utoa16w::@3->utoa16n#0] -- vbuxx=vbuc1 
    ldx #1
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp __b4
    // utoa16w::@4
  __b4:
    // [32] *((volatile byte*) utoa16w::dst) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp __breturn
    // utoa16w::@return
  __breturn:
    // [33] return 
    rts
}
  // utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte register(A) nybble, byte register(X) started)
utoa16n: {
    // [35] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3_from_utoa16n
    // [37] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
  __b1_from_utoa16n:
    // [37] phi (byte) utoa16n::return#4 = (byte) 1 [phi:utoa16n->utoa16n::@1#0] -- vbuxx=vbuc1 
    ldx #1
    jmp __b1
    // [36] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
  __b3_from_utoa16n:
    jmp __b3
    // utoa16n::@3
  __b3:
    // [37] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
  __b1_from___b3:
    // [37] phi (byte) utoa16n::return#4 = (byte) utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    jmp __b1
    // utoa16n::@1
  __b1:
    // [38] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return -- vbuxx_eq_0_then_la1 
    cpx #0
    beq __breturn
    jmp __b2
    // utoa16n::@2
  __b2:
    // [39] *(*(&(volatile byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) -- _deref_(_deref_pptc1)=pbuc2_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy.z utoa16w.dst
    sty.z $fe
    ldy.z utoa16w.dst+1
    sty.z $ff
    ldy #0
    sta ($fe),y
    // [40] *(&(volatile byte*) utoa16w::dst) ← ++ *(&(volatile byte*) utoa16w::dst) -- _deref_pptc1=_inc__deref_pptc1 
    inc.z utoa16w.dst
    bne !+
    inc.z utoa16w.dst+1
  !:
    jmp __breturn
    // utoa16n::@return
  __breturn:
    // [41] return 
    rts
}
  // cls
cls: {
    .label screen = $400
    .label sc = 2
    // [43] phi from cls to cls::@1 [phi:cls->cls::@1]
  __b1_from_cls:
    // [43] phi (byte*) cls::sc#2 = (const byte*) cls::screen [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta.z sc
    lda #>screen
    sta.z sc+1
    jmp __b1
    // [43] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
  __b1_from___b1:
    // [43] phi (byte*) cls::sc#2 = (byte*) cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    jmp __b1
    // cls::@1
  __b1:
    // [44] *((byte*) cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [45] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [46] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>screen+$3e7+1
    bne __b1_from___b1
    lda.z sc
    cmp #<screen+$3e7+1
    bne __b1_from___b1
    jmp __breturn
    // cls::@return
  __breturn:
    // [47] return 
    rts
}
  // File Data
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef"
  .byte 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #>0
Replacing instruction ldy #0 with TAY
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b3_from_utoa16n with __b1
Replacing label __b1_from___b1 with __b1
Replacing label __b1_from___b1 with __b1
Removing instruction __b3_from_utoa16n:
Removing instruction __b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction cls_from_main:
Removing instruction __b1:
Removing instruction utoa16w_from___b1:
Removing instruction __b2:
Removing instruction utoa16w_from___b2:
Removing instruction __b3:
Removing instruction utoa16w_from___b3:
Removing instruction __b4:
Removing instruction utoa16w_from___b4:
Removing instruction __b5:
Removing instruction utoa16w_from___b5:
Removing instruction __breturn:
Removing instruction utoa16n_from_utoa16w:
Removing instruction __b1:
Removing instruction utoa16n_from___b1:
Removing instruction __b2:
Removing instruction utoa16n_from___b2:
Removing instruction __b3:
Removing instruction utoa16n_from___b3:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __b1_from_utoa16n:
Removing instruction __b2:
Removing instruction __b1_from_cls:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
(const byte*) DIGITS[]  = (byte*) "0123456789abcdef"
(void()) cls()
(label) cls::@1
(label) cls::@return
(byte*) cls::sc
(byte*) cls::sc#1 sc zp[2]:2 151.5
(byte*) cls::sc#2 sc zp[2]:2 151.5
(const byte*) cls::screen = (byte*) 1024
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@return
(byte*) main::screen
(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
(label) utoa16n::@1
(label) utoa16n::@2
(label) utoa16n::@3
(label) utoa16n::@return
(word**) utoa16n::dst
(byte) utoa16n::nybble
(byte) utoa16n::nybble#0 reg byte a 22.0
(byte) utoa16n::nybble#1 reg byte a 11.0
(byte) utoa16n::nybble#2 reg byte a 11.0
(byte) utoa16n::nybble#3 reg byte a 22.0
(byte) utoa16n::nybble#4 reg byte a 49.2
(byte) utoa16n::return
(byte) utoa16n::return#0 reg byte x 22.0
(byte) utoa16n::return#1 reg byte x 22.0
(byte) utoa16n::return#4 reg byte x 32.0
(byte) utoa16n::started
(byte) utoa16n::started#1 reg byte x 22.0
(byte) utoa16n::started#2 reg byte x 22.0
(byte) utoa16n::started#7 reg byte x 41.0
(void()) utoa16w((word) utoa16w::value , (volatile byte*) utoa16w::dst)
(byte~) utoa16w::$0 reg byte a 22.0
(byte~) utoa16w::$3 reg byte a 22.0
(byte~) utoa16w::$6 reg byte a 22.0
(byte~) utoa16w::$9 reg byte a 22.0
(label) utoa16w::@1
(label) utoa16w::@2
(label) utoa16w::@3
(label) utoa16w::@4
(label) utoa16w::@return
(volatile byte*) utoa16w::dst loadstore zp[2]:4 0.65625
(byte) utoa16w::started
(byte) utoa16w::started#1 reg byte x 7.333333333333333
(byte) utoa16w::started#2 reg byte x 7.333333333333333
(word) utoa16w::value
(word) utoa16w::value#5 value zp[2]:2 2.75

reg byte a [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
reg byte x [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
zp[2]:2 [ cls::sc#2 cls::sc#1 utoa16w::value#5 ]
zp[2]:4 [ utoa16w::dst ]
reg byte a [ utoa16w::$0 ]
reg byte x [ utoa16n::return#0 ]
reg byte x [ utoa16w::started#1 ]
reg byte a [ utoa16w::$3 ]
reg byte x [ utoa16n::return#1 ]
reg byte x [ utoa16w::started#2 ]
reg byte a [ utoa16w::$6 ]
reg byte a [ utoa16w::$9 ]


FINAL ASSEMBLER
Score: 751

  // File Comments
// Testing binary to hex conversion using pointer to pointer
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // main
main: {
    // cls()
    // [1] call cls 
    // [42] phi from main to cls [phi:main->cls]
    jsr cls
    // main::@1
    // utoa16w(00000, screen)
    // [2] (volatile byte*) utoa16w::dst ← (byte*) 1024 -- pbuz1=pbuc1 
    lda #<$400
    sta.z utoa16w.dst
    lda #>$400
    sta.z utoa16w.dst+1
    // [3] call utoa16w 
    // [13] phi from main::@1 to utoa16w [phi:main::@1->utoa16w]
    // [13] phi (word) utoa16w::value#5 = (byte) 0 [phi:main::@1->utoa16w#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z utoa16w.value
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@2
    // utoa16w(01234, screen)
    // [4] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28
    sta.z utoa16w.dst
    lda #>$400+$28
    sta.z utoa16w.dst+1
    // [5] call utoa16w 
    // [13] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
    // [13] phi (word) utoa16w::value#5 = (word) $4d2 [phi:main::@2->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z utoa16w.value
    lda #>$4d2
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@3
    // utoa16w(05678, screen)
    // [6] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28
    sta.z utoa16w.dst+1
    // [7] call utoa16w 
    // [13] phi from main::@3 to utoa16w [phi:main::@3->utoa16w]
    // [13] phi (word) utoa16w::value#5 = (word) $162e [phi:main::@3->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$162e
    sta.z utoa16w.value
    lda #>$162e
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@4
    // utoa16w(09999, screen)
    // [8] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28
    sta.z utoa16w.dst+1
    // [9] call utoa16w 
    // [13] phi from main::@4 to utoa16w [phi:main::@4->utoa16w]
    // [13] phi (word) utoa16w::value#5 = (word) $270f [phi:main::@4->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$270f
    sta.z utoa16w.value
    lda #>$270f
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@5
    // utoa16w(58888, screen)
    // [10] (volatile byte*) utoa16w::dst ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta.z utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta.z utoa16w.dst+1
    // [11] call utoa16w 
    // [13] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
    // [13] phi (word) utoa16w::value#5 = (word) $e608 [phi:main::@5->utoa16w#0] -- vwuz1=vwuc1 
    lda #<$e608
    sta.z utoa16w.value
    lda #>$e608
    sta.z utoa16w.value+1
    jsr utoa16w
    // main::@return
    // }
    // [12] return 
    rts
}
  // utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zp(2) value, byte* zp(4) dst)
utoa16w: {
    .label dst = 4
    .label value = 2
    // >value
    // [14] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // utoa16n((>value)>>4, &dst, started)
    // [15] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [16] call utoa16n 
    // [34] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
    // [34] phi (byte) utoa16n::started#7 = (byte) 0 [phi:utoa16w->utoa16n#0] -- vbuxx=vbuc1 
    ldx #0
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16n((>value)>>4, &dst, started)
    // [17] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
    // utoa16w::@1
    // started = utoa16n((>value)>>4, &dst, started)
    // [18] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
    // >value
    // [19] (byte~) utoa16w::$3 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda.z value+1
    // utoa16n((>value)&0x0f, &dst, started)
    // [20] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$3 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [21] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
    // [22] call utoa16n 
    // [34] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
    // [34] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16n((>value)&0x0f, &dst, started)
    // [23] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
    // utoa16w::@2
    // started = utoa16n((>value)&0x0f, &dst, started)
    // [24] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
    // <value
    // [25] (byte~) utoa16w::$6 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // utoa16n((<value)>>4, &dst, started)
    // [26] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$6 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
    // [27] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
    // [28] call utoa16n 
    // [34] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
    // [34] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16w::@3
    // <value
    // [29] (byte~) utoa16w::$9 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda.z value
    // utoa16n((<value)&0x0f, &dst, 1)
    // [30] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$9 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [31] call utoa16n 
    // [34] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
    // [34] phi (byte) utoa16n::started#7 = (byte) 1 [phi:utoa16w::@3->utoa16n#0] -- vbuxx=vbuc1 
    ldx #1
    // [34] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    // utoa16w::@4
    // *dst = 0
    // [32] *((volatile byte*) utoa16w::dst) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (dst),y
    // utoa16w::@return
    // }
    // [33] return 
    rts
}
  // utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte register(A) nybble, byte register(X) started)
utoa16n: {
    // if(nybble!=0)
    // [35] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b1
    // [37] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
    // [37] phi (byte) utoa16n::return#4 = (byte) 1 [phi:utoa16n->utoa16n::@1#0] -- vbuxx=vbuc1 
    ldx #1
    // [36] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
    // utoa16n::@3
    // [37] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
    // [37] phi (byte) utoa16n::return#4 = (byte) utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    // utoa16n::@1
  __b1:
    // if(started!=0)
    // [38] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return -- vbuxx_eq_0_then_la1 
    cpx #0
    beq __breturn
    // utoa16n::@2
    // *(*dst)++ = DIGITS[nybble]
    // [39] *(*(&(volatile byte*) utoa16w::dst)) ← *((const byte*) DIGITS + (byte) utoa16n::nybble#4) -- _deref_(_deref_pptc1)=pbuc2_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy.z utoa16w.dst
    sty.z $fe
    ldy.z utoa16w.dst+1
    sty.z $ff
    ldy #0
    sta ($fe),y
    // *(*dst)++ = DIGITS[nybble];
    // [40] *(&(volatile byte*) utoa16w::dst) ← ++ *(&(volatile byte*) utoa16w::dst) -- _deref_pptc1=_inc__deref_pptc1 
    inc.z utoa16w.dst
    bne !+
    inc.z utoa16w.dst+1
  !:
    // utoa16n::@return
  __breturn:
    // }
    // [41] return 
    rts
}
  // cls
cls: {
    .label screen = $400
    .label sc = 2
    // [43] phi from cls to cls::@1 [phi:cls->cls::@1]
    // [43] phi (byte*) cls::sc#2 = (const byte*) cls::screen [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta.z sc
    lda #>screen
    sta.z sc+1
    // [43] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
    // [43] phi (byte*) cls::sc#2 = (byte*) cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    // cls::@1
  __b1:
    // *sc=' '
    // [44] *((byte*) cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // for( unsigned char *sc: screen..screen+999)
    // [45] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [46] if((byte*) cls::sc#1!=(const byte*) cls::screen+(word) $3e7+(byte) 1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>screen+$3e7+1
    bne __b1
    lda.z sc
    cmp #<screen+$3e7+1
    bne __b1
    // cls::@return
    // }
    // [47] return 
    rts
}
  // File Data
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef"
  .byte 0

