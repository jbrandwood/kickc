// Example program for the Commander X16.
// Demonstrates the usage of the VERA tile map modes and layering.

// Author: Sven Van de Velde

#pragma target(cx16)
#include <cx16.h>
#include <cx16-veralib.h>
#include <stdio.h>

#include <cx16-bitmap.h>
#include <stdlib.h>
#include <division.h>

char fgetc();

void main() {

    do {
        vera_layer_mode_text(1, 0x00000, 0x0f800, 64, 64, 8, 8, 4);
        vera_display_set_scale_double();
        vera_layer_show(1);
        screenlayer(1);

        textcolor(WHITE);
        bgcolor(BLUE);
        clrscr();

        printf( "\n *** vera demo ***\n\n" );
        printf( "1. bitmap - 320x240 - 1 bpp.\n");
        printf( "2. bitmap - 640x480 - 1 bpp.\n");
        printf( "3. bitmap - 320x240 - 2 bpp.\n");
        printf( "4. bitmap - 640x480 - 2 bpp.\n");
        printf( "5. bitmap - 320x240 - 4 bpp.\n");
        printf( "6. bitmap - 320x240 - 8 bpp.\n");

        printf( "\na. text - 8x8 - 1 bpp, 16c.\n");
        printf( "b. text - 8x8 - 1 bpp, 256c.\n");

        printf( "\nc. tile - 8x8 - 2 bpp.\n");
        printf( "d. tile - 16x16 - 2 bpp.\n");
        printf( "e. tile - 8x8 - 4 bpp.\n");
        printf( "f. tile - 16x16 - 4 bpp.\n");
        printf( "g. tile - 8x8 - 8 bpp.\n");
        printf( "h. tile - 16x16 - 8 bpp.\n");

        printf( "\n0. exit.\n");

        byte menu = 0;
        while(menu==0) {
            menu = fgetc();
        }

        textcolor(WHITE);
        bgcolor(BLACK);
        clrscr();

        switch( menu ) {
            case 49:
                bitmap_320_x_240_1BPP();
                break;
            case 50:
                bitmap_640_x_480_1BPP();
                break;
            case 51:
                bitmap_320_x_240_2BPP();
                break;
            case 52:
                bitmap_640_x_480_2BPP();
                break;
            case 53:
                bitmap_320_x_240_4BPP();
                break;
            case 54:
                bitmap_320_x_240_8BPP();
                break;
            case 65:
                text_8_x_8_1BPP_16_color();
                break;
            case 66:
                //text_8_x_8_1BPP_256_color();
                break;
            case 67:
                tile_8_x_8_2BPP_4_color();
                break;
            case 68:
                //tile_16_x_16_2BPP_4_color();
                break;
            case 69:
                //tile_8_x_8_4BPP_16_color();
                break;
            case 70:
                //tile_16_x_16_4BPP_16_color();
                break;
            case 71:
                //tile_8_x_8_8BPP_256_color();
                break;
            case 72:
                //tile_16_x_16_8BPP_256_color();
                break;
        }

        vera_layer_hide(0);
        vera_layer_mode_text(1, 0x00000, 0x0f800, 64, 64, 8, 8, 4);
        vera_layer_show(1);

        screenlayer(1);
        textcolor(WHITE);
        bgcolor(BLUE);
        clrscr();

    } while( menu != 48 );

}

char fgetc() {
    char * const GETIN = 0xFFE4;
    char ch;
    asm {
        jsr GETIN
        sta ch
    }
    return ch;
}


void tile_16_x_16_8BPP_256_color() {

    vera_layer_mode_text( 1, 0x00000, 0x0F800, 128, 128, 8, 8, 256 );
    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    byte tiles[256] = {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    };

    // Before we can load the tiles into memory we need to re-arrange a few things!
    // The amount of tiles is 256, the color depth is 256, so each tile is 256 bytes!
    // That is 65356 bytes of memory, which is 64K. Yup! One memory bank in VRAM.
    // VERA VRAM holds in bank 1 many registers that interfere loading all of this data.
    // So it is better to load all in bank 0, but then there is an other issue.
    // So the default CX16 character set is located in bank 0, at address 0xF800.
    // So we need to move this character set to bank 1, suggested is at address 0xF000.
    // The CX16 by default writes textual output to layer 1 in text mode, so we need to
    // realign the moved character set to 0xf000 as the new tile base for layer 1.
    // We also will need to realign for layer 1 the map base from 0x00000 to 0x10000.
    // This is now all easily done with a few statements in the new kickc vera lib ...

    memcpy_in_vram(1, 0xF000, VERA_INC_1, 0, 0xF800, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
    vera_layer_mode_tile(1, 0x10000, 0x1F000, 128, 64, 8, 8, 1);
    vera_display_set_scale_none();

    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    // Now we can use the full bank 0!
    // We set the mapbase of the tile demo to output to 0x12000,
    // and the tilebase is set to 0x0000!
    vera_layer_mode_tile(0, 0x14000, 0x00000, 64, 64, 16, 16, 8);


    word tilebase = 0x0000;
    memcpy_to_vram(0, tilebase, tiles, 256);
    tilebase+=256;
    for(byte t:1..255) {
        for(byte p:0..255) {
            tiles[p]+=1;
        }
        memcpy_to_vram(0, tilebase, tiles, 256);
        tilebase+=256;
    }

    //vera_tile_area(byte layer, word tileindex, byte x, byte y, byte w, byte h, byte hflip, byte vflip, byte offset)

    vera_tile_area(0, 0, 0, 0, 40, 30, 0, 0, 0);

    word tile = 0;

    // Draw 4 squares with each tile, starting from row 4, width 1, height 1, separated by 2 characters.
    byte row = 1;
    for(byte r:0..11) {
        byte column = 0;
        for(byte c:0..19) {
            vera_tile_area(0, tile, column, row, 1, 1, 0, 0, 0);
            column+=2;
            tile++;
            tile &= 0xff;
        }
        row += 2;
    }

    gotoxy(0,50);
    printf("vera in tile mode 8 x 8, color depth 8 bits per pixel.\n");

    printf("in this mode, tiles are 8 pixels wide and 8 pixels tall.\n");
    printf("each tile can have a variation of 256 colors.\n");
    printf("the vera palette of 256 colors, can be used by setting the palette\n");
    printf("offset for each tile.\n");
    printf("here each column is displaying the same tile, but with different offsets!\n");
    printf("each offset aligns to multiples of 16 colors in the palette!.\n");
    printf("however, the first color will always be transparent (black).\n");

    vera_layer_show(0);

    while(!fgetc());

    vera_tile_area(0, 0, 0, 0, 40, 30, 0, 0, 0);

    tile = 0;
    row = 0;
    for(byte r:0..11) {
        byte column = 0;
        for(byte c:0..19) {
            vera_tile_area(0, tile, column, row, 2, 2, 0, 0, 0);
            column+=2;
            tile++;
            tile &= 0xff;
        }
        row += 2;
    }

    while(!fgetc());

    memcpy_in_vram(0, 0xF800, VERA_INC_1, 1, 0xF000, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
}


void tile_8_x_8_8BPP_256_color() {

    vera_layer_mode_tile(0, 0x04000, 0x14000, 128, 128, 8, 8, 8);
    vera_display_set_scale_none();

    vera_layer_mode_text( 1, 0x00000, 0x0F800, 128, 128, 8, 8, 256 );
    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    byte tiles[64] = {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };

    word tilebase = 0x4000;
    memcpy_to_vram(1, tilebase, tiles, 64);
    tilebase+=64;
    for(byte t:1..255) {
        for(byte p:0..63) {
            tiles[p]+=1;
        }
        memcpy_to_vram(1, tilebase, tiles, 64);
        tilebase+=64;
    }

    //vera_tile_area(byte layer, word tileindex, byte x, byte y, byte w, byte h, byte hflip, byte vflip, byte offset)

    vera_tile_area(0, 0, 0, 0, 80, 60, 0, 0, 0);

    word tile = 0;

    // Draw 4 squares with each tile, starting from row 4, width 1, height 1, separated by 2 characters.
    byte row = 1;
    for(byte r:0..7) {
        byte column = 1;
        for(byte c:0..31) {
            vera_tile_area(0, tile, column, row, 1, 1, 0, 0, 0);
            column+=2;
            tile++;
            tile &= 0xff;
        }
        row += 2;
    }

    tile = 0;
    row = 20;
    for(byte r:0..7) {
        byte column = 1;
        for(byte c:0..31) {
            vera_tile_area(0, tile, column, row, 2, 2, 0, 0, 0);
            column+=2;
            tile++;
            tile &= 0xff;
        }
        row += 2;
    }

    vera_layer_show(0);

    gotoxy(0,50);
    printf("vera in tile mode 8 x 8, color depth 8 bits per pixel.\n");

    printf("in this mode, tiles are 8 pixels wide and 8 pixels tall.\n");
    printf("each tile can have a variation of 256 colors.\n");
    printf("the vera palette of 256 colors, can be used by setting the palette\n");
    printf("offset for each tile.\n");
    printf("here each column is displaying the same tile, but with different offsets!\n");
    printf("each offset aligns to multiples of 16 colors in the palette!.\n");
    printf("however, the first color will always be transparent (black).\n");

    while(!fgetc());

    memcpy_in_vram(0, 0xF800, VERA_INC_1, 1, 0xF000, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
}


void tile_16_x_16_4BPP_16_color() {

    vera_layer_mode_tile(0, 0x04000, 0x14000, 128, 128, 16, 16, 4);
    vera_display_set_scale_none();

    vera_layer_mode_text( 1, 0x00000, 0x0F800, 128, 128, 8, 8, 256 );
    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    byte tiles[2048] = {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    };

    memcpy_to_vram(1, 0x4000, tiles, 2048);

    //vera_tile_area(byte layer, word tileindex, byte x, byte y, byte w, byte h, byte hflip, byte vflip, byte offset)

    vera_tile_area(0, 0, 0, 0, 40, 30, 0, 0, 0);

    word tile = 0;

    // Draw 4 squares with each tile, starting from row 4, width 1, height 1, separated by 2 characters.
    tile = 0;
    byte column = 1;
    for(byte c:0..7) {
        vera_tile_area(0, tile, column, 1, 1, 1, 0, 0, 0);
        column+=4;
        tile++;
    }
    column = 1;
    for(byte c:0..7) {
        vera_tile_area(0, tile, column, 3, 1, 1, 0, 0, 0);
        column+=4;
        tile++;
    }

    tile = 0;
    column = 1;
    for(byte c:0..7) {
        vera_tile_area(0, tile, column, 5, 3, 3, 0, 0, 0);
        column+=4;
        tile++;
    }
    column = 1;
    for(byte c:0..7) {
        vera_tile_area(0, tile, column, 9, 3, 3, 0, 0, 0);
        column+=4;
        tile++;
    }

    tile = 0;
    byte offset = 0;

    byte row = 13;

    for(byte r:0..7) {
        byte column = 1;
        for(byte c:0..31) {
            vera_tile_area(0, tile, column, row, 1, 1, 0, 0, offset);
            column+=1;
            tile++;
            if((c & 0x0f) == 0x0f) offset++;
            tile &= 0x0f;
        }
        row += 1;
    }

    vera_layer_show(0);

    gotoxy(0,50);
    printf("vera in tile mode 16 x 16, color depth 4 bits per pixel.\n");

    printf("in this mode, tiles are 16 pixels wide and 16 pixels tall.\n");
    printf("each tile can have a variation of 16 colors.\n");
    printf("the vera palette of 256 colors, can be used by setting the palette\n");
    printf("offset for each tile.\n");
    printf("here each column is displaying the same tile, but with different offsets!\n");
    printf("each offset aligns to multiples of 16 colors in the palette!.\n");
    printf("however, the first color will always be transparent (black).\n");

    while(!fgetc());
}


void tile_8_x_8_4BPP_16_color() {

    vera_layer_mode_tile(0, 0x04000, 0x14000, 128, 128, 8, 8, 4);
    vera_display_set_scale_none();

    vera_layer_mode_text( 1, 0x00000, 0x0F800, 128, 128, 8, 8, 256 );
    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    byte tiles[512] = {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    };

    memcpy_to_vram(1, 0x4000, tiles, 512);

    vera_tile_area(0, 0, 0, 0, 80, 60, 0, 0, 0);

    word tile = 0;

    // Draw 4 squares with each tile, starting from row 4, width 1, height 1, separated by 2 characters.
    tile = 0;
    byte column = 1;
    for(byte c:0..7) {
        vera_tile_area(0, tile, column, 1, 1, 1, 0, 0, 0);
        column+=8;
        tile++;
    }
    column = 1;
    for(byte c:0..7) {
        vera_tile_area(0, tile, column, 3, 1, 1, 0, 0, 0);
        column+=8;
        tile++;
    }

    tile = 0;
    column = 1;
    for(byte c:0..7) {
        vera_tile_area(0, tile, column, 5, 6, 6, 0, 0, 0);
        column+=8;
        tile++;
    }
    column = 1;
    for(byte c:0..7) {
        vera_tile_area(0, tile, column, 12, 6, 6, 0, 0, 0);
        column+=8;
        tile++;
    }

    tile = 0;
    byte offset = 0;

    byte row = 20;

    for(byte r:0..7) {
        byte column = 1;
        for(byte c:0..31) {
            vera_tile_area(0, tile, column, row, 2, 2, 0, 0, offset);
            column+=2;
            tile++;
            if((c & 0x0f) == 0x0f) offset++;
            tile &= 0x0f;
        }
        row += 2;
    }

    vera_layer_show(0);

    gotoxy(0,50);
    printf("vera in tile mode 8 x 8, color depth 4 bits per pixel.\n");

    printf("in this mode, tiles are 8 pixels wide and 8 pixels tall.\n");
    printf("each tile can have a variation of 16 colors.\n");
    printf("the vera palette of 256 colors, can be used by setting the palette\n");
    printf("offset for each tile.\n");
    printf("here each column is displaying the same tile, but with different offsets!\n");
    printf("each offset aligns to multiples of 16 colors in the palette!.\n");
    printf("however, the first color will always be transparent (black).\n");

    while(!fgetc());
}


void tile_16_x_16_2BPP_4_color() {

    vera_layer_mode_tile(0, 0x04000, 0x14000, 128, 128, 16, 16, 2);
    vera_display_set_scale_none();

    vera_layer_mode_text( 1, 0x00000, 0x0F800, 128, 128, 8, 8, 256 );
    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    byte tiles[256] = {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    };

    memcpy_to_vram(1, 0x4000, tiles, 256);

    //vera_tile_area(byte layer, word tileindex, byte x, byte y, byte w, byte h, byte hflip, byte vflip, byte offset)

    vera_tile_area(0, 0, 0, 0, 40, 30, 0, 0, 0);

    // Draw 4 squares with each tile, starting from row 4, width 1, height 1, separated by 2 characters.
    vera_tile_area(0, 0, 4, 2, 1, 1, 0, 0, 0);
    vera_tile_area(0, 1, 10, 2, 1, 1, 0, 0, 0);
    vera_tile_area(0, 2, 16, 2, 1, 1, 0, 0, 0);
    vera_tile_area(0, 3, 22, 2, 1, 1, 0, 0, 0);

    // Draw 4 squares with each tile, starting from row 6, width 4, height 4, separated by 2 characters.
    vera_tile_area(0, 0, 4, 4, 4, 4, 0, 0, 0);
    vera_tile_area(0, 1, 10, 4, 4, 4, 0, 0, 0);
    vera_tile_area(0, 2, 16, 4, 4, 4, 0, 0, 0);
    vera_tile_area(0, 3, 22, 4, 4, 4, 0, 0, 0);

    word tile = 0;
    byte offset = 0;

    byte row = 10;

    for(byte r:0..3) {
        byte column = 4;
        for(byte c:0..16) {
            vera_tile_area(0, tile, column, row, 1, 1, 0, 0, offset);
            column+=2;
            offset++;
        }
        tile++;
        tile &= 0x3;
        row += 2;
    }

    vera_layer_show(0);

    gotoxy(0,50);
    printf("vera in tile mode 8 x 8, color depth 2 bits per pixel.\n");

    printf("in this mode, tiles are 8 pixels wide and 8 pixels tall.\n");
    printf("each tile can have a variation of 4 colors.\n");
    printf("the vera palette of 256 colors, can be used by setting the palette\n");
    printf("offset for each tile.\n");
    printf("here each column is displaying the same tile, but with different offsets!\n");
    printf("each offset aligns to multiples of 16 colors, and only the first 4 colors\n");
    printf("can be used per offset!\n");
    printf("however, the first color will always be transparent (black).\n");

    while(!fgetc());
}

void tile_8_x_8_2BPP_4_color() {

    vera_layer_mode_tile(0, 0x04000, 0x14000, 128, 128, 8, 8, 2);
    vera_display_set_scale_none();

    vera_layer_mode_text( 1, 0x00000, 0x0F800, 128, 128, 8, 8, 256 );
    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    byte tiles[64] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                     0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
                     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
                     0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

    byte map[16] =  {0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x02,0x00,0x02,0x00,0x03,0x00,0x03,0x00};

    memcpy_to_vram(1, 0x4000, tiles, 64);

    //vera_tile_area(byte layer, word tileindex, byte x, byte y, byte w, byte h, byte hflip, byte vflip, byte offset)

    vera_tile_area(0, 0, 0, 0, 80, 60, 0, 0, 0);

    // Draw 4 squares with each tile, staring from row 2, width 10, height 10, separated by 2 characters.
    vera_tile_area(0, 0, 4, 4, 10, 10, 0, 0, 0);
    vera_tile_area(0, 1, 16, 4, 10, 10, 0, 0, 0);
    vera_tile_area(0, 2, 28, 4, 10, 10, 0, 0, 0);
    vera_tile_area(0, 3, 40, 4, 10, 10, 0, 0, 0);

    word tile = 0;
    byte offset = 0;

    byte row = 22;

    for(byte r:0..3) {
        byte column = 4;
        for(byte c:0..15) {
            vera_tile_area(0, tile, column, row, 3, 3, 0, 0, offset);
            column+=4;
            offset++;
        }
        tile++;
        tile &= 0x3;
        row += 4;
    }

    vera_layer_show(0);

    gotoxy(0,50);
    printf("vera in tile mode 8 x 8, color depth 2 bits per pixel.\n");

    printf("in this mode, tiles are 8 pixels wide and 8 pixels tall.\n");
    printf("each tile can have a variation of 4 colors.\n");
    printf("the vera palette of 256 colors, can be used by setting the palette\n");
    printf("offset for each tile.\n");
    printf("here each column is displaying the same tile, but with different offsets!\n");
    printf("each offset aligns to multiples of 16 colors, and only the first 4 colors\n");
    printf("can be used per offset!\n");
    printf("however, the first color will always be transparent (black).\n");

    while(!fgetc());
}


void text_8_x_8_1BPP_256_color() {

    // Configure the VERA card to work in text, 256 mode.
    // The color mode is here 256 colors, (256 foreground on a black transparent background).
    vera_layer_mode_text( 1, 0x00000, 0x0F800, 128, 128, 8, 8, 256 );
    vera_display_set_scale_none();
    screenlayer(1);

    for(byte c:0..255) {
        textcolor(c);
        printf(" ****** ");
    }

    vera_layer_show(1);

    gotoxy(0,50);
    textcolor(WHITE);
    bgcolor(BLACK);
    printf("vera in text mode 8 x 8, color depth 1 bits per pixel.\n");
    printf("in this mode, tiles are 8 pixels wide and 8 pixels tall.\n");
    printf("each character can have a variation of 256 foreground colors.\n");
    printf("here we display 6 stars (******) each with a different color.\n");
    printf("however, the first color will always be transparent (black).\n");
    printf("in this mode, the background color cannot be set and is always transparent.\n");

    while(!fgetc());
}

void text_8_x_8_1BPP_16_color() {

    // Configure the VERA card to work in text.
    // The color mode is here 16 colors, (16 foreground and 16 background colors).
    vera_layer_mode_text(1, 0x00000, 0x0F800, 128, 128, 8, 8, 16);
    vera_display_set_scale_none();
    screenlayer(1);

    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();


    for(byte c:0..255) {
        bgcolor(c);
        printf(" ++++++ ");
    }

    vera_layer_show(1);

    gotoxy(0,50);
    textcolor(WHITE);
    bgcolor(BLACK);
    printf("vera in text mode 8 x 8, color depth 1 bits per pixel.\n");
    printf("in this mode, tiles are 8 pixels wide and 8 pixels tall.\n");
    printf("each character can have a variation of 16 foreground colors and 16 background colors.\n");
    printf("here we display 6 stars (******) each with a different color.\n");
    printf("however, the first color will always be transparent (black).\n");
    printf("in this mode, the background color cannot be set and is always transparent.\n");

    while(!fgetc());
}


void bitmap_320_x_240_1BPP() {

    // Before we configure the bitmap pane into vera  memory we need to re-arrange a few things!
    // It is better to load all in bank 0, but then there is an issue.
    // So the default CX16 character set is located in bank 0, at address 0xF800.
    // So we need to move this character set to bank 1, suggested is at address 0xF000.
    // The CX16 by default writes textual output to layer 1 in text mode, so we need to
    // realign the moved character set to 0xf000 as the new tile base for layer 1.
    // We also will need to realign for layer 1 the map base from 0x00000 to 0x14000.
    // This is now all easily done with a few statements in the new kickc vera lib ...
    memcpy_in_vram(1, 0xF000, VERA_INC_1, 0, 0xF800, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
    vera_layer_mode_bitmap(0, (dword)0x00000, 320, 1);

    vera_layer_mode_tile(1, 0x14000, 0x1F000, 128, 64, 8, 8, 1);
    screenlayer(1);

    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,25);
    printf("vera in bitmap mode,\n");
    printf("color depth 1 bits per pixel.\n");
    printf("in this mode, it is possible to display\n");
    printf("graphics in 2 colors (black or color).\n");

    vera_layer_show(0);

    bitmap_init(0, 0x00000);
    bitmap_clear();

    gotoxy(0,29);
    textcolor(YELLOW);
    printf("press a key ...");

    while(!fgetc()) {
        bitmap_line(modr16u(rand(),320,0), modr16u(rand(),320,0), modr16u(rand(),200,0), modr16u(rand(),200,0), rand()&1);
    };

    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,26);
    printf("here you see all the colors possible.\n");

    gotoxy(0,29);
    textcolor(YELLOW);
    printf("press a key ...");

    word x = 0;
    byte color = 0;
    while(!fgetc()) {
        bitmap_line(x, x, 0, 199, color);
        color++;
        if(color>1) color=0;
        x++;
        if(x>319) x=0;
    };
    memcpy_in_vram(0, 0xF800, VERA_INC_1, 1, 0xF000, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
}

void bitmap_640_x_480_1BPP() {

    vera_display_set_scale_none();

    // Before we configure the bitmap pane into vera  memory we need to re-arrange a few things!
    // It is better to load all in bank 0, but then there is an issue.
    // So the default CX16 character set is located in bank 0, at address 0xF800.
    // So we need to move this character set to bank 1, suggested is at address 0xF000.
    // The CX16 by default writes textual output to layer 1 in text mode, so we need to
    // realign the moved character set to 0xf000 as the new tile base for layer 1.
    // We also will need to realign for layer 1 the map base from 0x00000 to 0x14000.
    // This is now all easily done with a few statements in the new kickc vera lib ...
    memcpy_in_vram(1, 0xF000, VERA_INC_1, 0, 0xF800, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
    vera_layer_mode_tile(1, 0x14000, 0x1F000, 128, 64, 8, 8, 1);

    vera_layer_mode_bitmap(0, (dword)0x00000, 640, 1);

    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,54);
    printf("vera in bitmap mode,\n");
    printf("color depth 1 bits per pixel.\n");
    printf("in this mode, it is possible to display\n");
    printf("graphics in 2 colors (black or color).\n");

    vera_layer_show(0);

    bitmap_init(0, 0x00000);
    bitmap_clear();

    gotoxy(0,59);
    textcolor(YELLOW);
    printf("press a key ...");

    while(!fgetc()) {
        bitmap_line(modr16u(rand(),639,0), modr16u(rand(),639,0), modr16u(rand(),399,0), modr16u(rand(),399,0), rand()&1);
    };

    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,54);
    printf("here you see all the colors possible.\n");

    gotoxy(0,59);
    textcolor(YELLOW);
    printf("press a key ...");

    word x = 0;
    byte color = 0;
    while(!fgetc()) {
        bitmap_line(x, x, 0, 399, color);
        color++;
        if(color>1) color=0;
        x++;
        if(x>639) x=0;
    };
    memcpy_in_vram(0, 0xF800, VERA_INC_1, 1, 0xF000, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
}

void bitmap_320_x_240_2BPP() {

    // Before we configure the bitmap pane into vera  memory we need to re-arrange a few things!
    // It is better to load all in bank 0, but then there is an issue.
    // So the default CX16 character set is located in bank 0, at address 0xF800.
    // So we need to move this character set to bank 1, suggested is at address 0xF000.
    // The CX16 by default writes textual output to layer 1 in text mode, so we need to
    // realign the moved character set to 0xf000 as the new tile base for layer 1.
    // We also will need to realign for layer 1 the map base from 0x00000 to 0x14000.
    // This is now all easily done with a few statements in the new kickc vera lib ...
    memcpy_in_vram(1, 0xF000, VERA_INC_1, 0, 0xF800, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
    vera_layer_mode_tile(1, 0x14000, 0x1F000, 128, 64, 8, 8, 1);

    vera_layer_mode_bitmap(0, (dword)0x00000, 320, 2);

    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,25);
    printf("vera in bitmap mode,\n");
    printf("color depth 2 bits per pixel.\n");
    printf("in this mode, it is possible to display\n");
    printf("graphics in 4 colors.\n");

    vera_layer_show(0);

    bitmap_init(0, 0x00000);
    bitmap_clear();

    gotoxy(0,29);
    textcolor(YELLOW);
    printf("press a key ...");

    while(!fgetc()) {
        bitmap_line(modr16u(rand(),320,0), modr16u(rand(),320,0), modr16u(rand(),200,0), modr16u(rand(),200,0), rand()&3);
    };

    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,26);
    printf("here you see all the colors possible.\n");

    gotoxy(0,29);
    textcolor(YELLOW);
    printf("press a key ...");

    word x = 0;
    byte color = 0;
    while(!fgetc()) {
        bitmap_line(x, x, 0, 199, color);
        color++;
        if(color>3) color=0;
        x++;
        if(x>319) x=0;
    };
    memcpy_in_vram(0, 0xF800, VERA_INC_1, 1, 0xF000, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
}

void bitmap_640_x_480_2BPP() {

    // Before we configure the bitmap pane into vera  memory we need to re-arrange a few things!
    // It is better to load all in bank 0, but then there is an issue.
    // So the default CX16 character set is located in bank 0, at address 0xF800.
    // So we need to move this character set to bank 1, suggested is at address 0xF000.
    // The CX16 by default writes textual output to layer 1 in text mode, so we need to
    // realign the moved character set to 0xf000 as the new tile base for layer 1.
    // We also will need to realign for layer 1 the map base from 0x00000 to 0x14000.
    // This is now all easily done with a few statements in the new kickc vera lib ...
    memcpy_in_vram(1, 0xF000, VERA_INC_1, 0, 0xF800, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
    vera_layer_mode_tile(1, 0x14000, 0x1F000, 128, 64, 8, 8, 1);

    vera_layer_mode_bitmap(0, (dword)0x00000, 640, 2);

    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,54);
    printf("vera in bitmap mode,\n");
    printf("color depth 1 bits per pixel.\n");
    printf("in this mode, it is possible to display\n");
    printf("graphics in 2 colors (black or color).\n");

    vera_layer_show(0);

    bitmap_init(0, 0x00000);
    bitmap_clear();

    gotoxy(0,59);
    textcolor(YELLOW);
    printf("press a key ...");

    while(!fgetc()) {
        bitmap_line(modr16u(rand(),639,0), modr16u(rand(),639,0), modr16u(rand(),399,0), modr16u(rand(),399,0), rand()&3);
    };

    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,54);
    printf("here you see all the colors possible.\n");

    gotoxy(0,59);
    textcolor(YELLOW);
    printf("press a key ...");

    word x = 0;
    byte color = 0;
    while(!fgetc()) {
        bitmap_line(x, x, 0, 399, color);
        color++;
        if(color>3) color=0;
        x++;
        if(x>639) x=0;
    };
    memcpy_in_vram(0, 0xF800, VERA_INC_1, 1, 0xF000, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
}

void bitmap_320_x_240_4BPP() {

    // Before we configure the bitmap pane into vera  memory we need to re-arrange a few things!
    // It is better to load all in bank 0, but then there is an issue.
    // So the default CX16 character set is located in bank 0, at address 0xF800.
    // So we need to move this character set to bank 1, suggested is at address 0xF000.
    // The CX16 by default writes textual output to layer 1 in text mode, so we need to
    // realign the moved character set to 0xf000 as the new tile base for layer 1.
    // We also will need to realign for layer 1 the map base from 0x00000 to 0x14000.
    // This is now all easily done with a few statements in the new kickc vera lib ...

    memcpy_in_vram(1, 0xF000, VERA_INC_1, 0, 0xF800, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
    vera_layer_mode_tile(1, 0x14000, 0x1F000, 128, 64, 8, 8, 1);

    vera_layer_mode_bitmap(0, (dword)0x00000, 320, 4);

    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,25);
    printf("vera in bitmap mode,\n");
    printf("color depth 4 bits per pixel.\n");
    printf("in this mode, it is possible to display\n");
    printf("graphics in 16 colors.\n");

    vera_layer_show(0);

    bitmap_init(0, 0x00000);
    bitmap_clear();

    gotoxy(0,29);
    textcolor(YELLOW);
    printf("press a key ...");

    while(!fgetc()) {
        bitmap_line(modr16u(rand(),320,0), modr16u(rand(),320,0), modr16u(rand(),200,0), modr16u(rand(),200,0), rand()&15);
    };

    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,26);
    printf("here you see all the colors possible.\n");

    gotoxy(0,29);
    textcolor(YELLOW);
    printf("press a key ...");

    word x = 0;
    byte color = 0;
    while(!fgetc()) {
        bitmap_line(x, x, 0, 199, color);
        color++;
        if(color>15) color=0;
        x++;
        if(x>319) x=0;
    };

    memcpy_in_vram(0, 0xF800, VERA_INC_1, 1, 0xF000, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
}

void bitmap_320_x_240_8BPP() {

    // Before we configure the bitmap pane into vera  memory we need to re-arrange a few things!
    // It is better to load all in bank 0, but then there is an issue.
    // So the default CX16 character set is located in bank 0, at address 0xF800.
    // So we need to move this character set to bank 1, suggested is at address 0xF000.
    // The CX16 by default writes textual output to layer 1 in text mode, so we need to
    // realign the moved character set to 0xf000 as the new tile base for layer 1.
    // We also will need to realign for layer 1 the map base from 0x00000 to 0x14000.
    // This is now all easily done with a few statements in the new kickc vera lib ...
    memcpy_in_vram(1, 0xF000, VERA_INC_1, 0, 0xF800, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
    vera_layer_mode_tile(1, 0x14000, 0x1F000, 128, 64, 8, 8, 1);

    vera_layer_mode_bitmap(0, (dword)0x00000, 320, 8);

    screenlayer(1);
    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,25);
    printf("vera in bitmap mode,\n");
    printf("color depth 8 bits per pixel.\n");
    printf("in this mode, it is possible to display\n");
    printf("graphics in 256 colors.\n");

    vera_layer_show(0);

    bitmap_init(0, 0x00000);
    bitmap_clear();

    gotoxy(0,29);
    textcolor(YELLOW);
    printf("press a key ...");

    while(!fgetc()) {
        bitmap_line(modr16u(rand(),320,0), modr16u(rand(),320,0), modr16u(rand(),200,0), modr16u(rand(),200,0), rand()&255);
    };

    textcolor(WHITE);
    bgcolor(BLACK);
    clrscr();

    gotoxy(0,26);
    printf("here you see all the colors possible.\n");

    gotoxy(0,29);
    textcolor(YELLOW);
    printf("press a key ...");

    word x = 0;
    byte color = 0;
    while(!fgetc()) {
        bitmap_line(x, x, 0, 199, color);
        color++;
        x++;
        if(x>319) x=0;
    };

    memcpy_in_vram(0, 0xF800, VERA_INC_1, 1, 0xF000, VERA_INC_1, 256*8); // We copy the 128 character set of 8 bytes each.
}
