byte cnt = 0;
byte cnt2 = 0;
byte cnt3 = 0;
byte[256] SCREEN=$0400;

main();

void main() {
  SCREEN[0]=inccnt();
  cnt++;
  SCREEN[1]=inccnt();
}

byte inccnt() {
    ++cnt;
    ++cnt2;
    ++cnt3;
    return cnt;
}




Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt2 ← ++ (byte) cnt2
Adding pre/post-modifier (byte) cnt3 ← ++ (byte) cnt3
PROGRAM
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte) cnt3 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
proc (void()) main()
  (byte~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte~) main::$1 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
main::@return:
  return 
endproc // main()
proc (byte()) inccnt()
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) cnt3 ← ++ (byte) cnt3
  (byte) inccnt::return ← (byte) cnt
  goto inccnt::@return
inccnt::@return:
  (byte) inccnt::return ← (byte) inccnt::return
  return (byte) inccnt::return
endproc // inccnt()

SYMBOLS
(void~) $0
(byte[256]) SCREEN
(byte) cnt
(byte) cnt2
(byte) cnt3
(byte()) inccnt()
(label) inccnt::@return
(byte) inccnt::return
(void()) main()
(byte~) main::$0
(byte~) main::$1
(label) main::@return

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte) cnt3 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@1
main: scope:[main]  from
  (byte~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte~) main::$1 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
@1: scope:[]  from @begin
  to:@2
inccnt: scope:[inccnt]  from
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) cnt3 ← ++ (byte) cnt3
  (byte) inccnt::return ← (byte) cnt
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt inccnt::@1
  (byte) inccnt::return ← (byte) inccnt::return
  return (byte) inccnt::return
  to:@return
inccnt::@1: scope:[inccnt]  from
  to:inccnt::@return
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

Removing empty block @1
Removing empty block inccnt::@1
Removing empty block @2
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte) cnt3 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@end
main: scope:[main]  from
  (byte~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte~) main::$1 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
inccnt: scope:[inccnt]  from
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) cnt3 ← ++ (byte) cnt3
  (byte) inccnt::return ← (byte) cnt
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) inccnt::return ← (byte) inccnt::return
  return (byte) inccnt::return
  to:@return
@end: scope:[]  from @begin

PROCEDURE MODIFY VARIABLE ANALYSIS
main modifies cnt
main modifies cnt2
main modifies cnt3
inccnt modifies cnt
inccnt modifies cnt2
inccnt modifies cnt3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte) cnt3 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  (byte) cnt3 ← (byte) cnt3
  to:@end
main: scope:[main]  from @begin
  (byte) inccnt::return ← call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inccnt::return
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  (byte) cnt3 ← (byte) cnt3
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte) inccnt::return ← call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$1 ← (byte) inccnt::return
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  (byte) cnt3 ← (byte) cnt3
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  (byte) cnt3 ← (byte) cnt3
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) cnt3 ← ++ (byte) cnt3
  (byte) inccnt::return ← (byte) cnt
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) inccnt::return ← (byte) inccnt::return
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  (byte) cnt3 ← (byte) cnt3
  return (byte) inccnt::return
  to:@return
@end: scope:[]  from @3

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) cnt#0 ← (byte) 0
  (byte) cnt2#0 ← (byte) 0
  (byte) cnt3#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt3#7 ← phi( @begin/(byte) cnt3#0 )
  (byte) cnt2#7 ← phi( @begin/(byte) cnt2#0 )
  (byte) cnt#8 ← phi( @begin/(byte) cnt#0 )
  (byte) cnt#1 ← (byte) cnt#8
  (byte) cnt2#1 ← (byte) cnt2#7
  (byte) cnt3#1 ← (byte) cnt3#7
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(byte[256]) SCREEN#0 )
  (byte) cnt3#13 ← phi( @begin/(byte) cnt3#0 )
  (byte) cnt2#13 ← phi( @begin/(byte) cnt2#0 )
  (byte) cnt#14 ← phi( @begin/(byte) cnt#0 )
  (byte) inccnt::return#0 ← call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt3#8 ← phi( main/(byte) cnt3#13 )
  (byte) cnt2#8 ← phi( main/(byte) cnt2#13 )
  (byte) cnt#9 ← phi( main/(byte) cnt#14 )
  (byte) inccnt::return#4 ← phi( main/(byte) inccnt::return#0 )
  (byte~) main::$0 ← (byte) inccnt::return#4
  (byte) cnt#2 ← (byte) cnt#9
  (byte) cnt2#2 ← (byte) cnt2#8
  (byte) cnt3#2 ← (byte) cnt3#8
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#2
  (byte) inccnt::return#1 ← call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt3#9 ← phi( main::@1/(byte) cnt3#2 )
  (byte) cnt2#9 ← phi( main::@1/(byte) cnt2#2 )
  (byte) cnt#10 ← phi( main::@1/(byte) cnt#3 )
  (byte) inccnt::return#5 ← phi( main::@1/(byte) inccnt::return#1 )
  (byte~) main::$1 ← (byte) inccnt::return#5
  (byte) cnt#4 ← (byte) cnt#10
  (byte) cnt2#3 ← (byte) cnt2#9
  (byte) cnt3#3 ← (byte) cnt3#9
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt3#10 ← phi( main::@2/(byte) cnt3#3 )
  (byte) cnt2#10 ← phi( main::@2/(byte) cnt2#3 )
  (byte) cnt#11 ← phi( main::@2/(byte) cnt#4 )
  (byte) cnt#5 ← (byte) cnt#11
  (byte) cnt2#4 ← (byte) cnt2#10
  (byte) cnt3#4 ← (byte) cnt3#10
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt3#11 ← phi( main/(byte) cnt3#13 main::@1/(byte) cnt3#2 )
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#2 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#6 ← ++ (byte) cnt#12
  (byte) cnt2#5 ← ++ (byte) cnt2#11
  (byte) cnt3#5 ← ++ (byte) cnt3#11
  (byte) inccnt::return#2 ← (byte) cnt#6
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt3#12 ← phi( inccnt/(byte) cnt3#5 )
  (byte) cnt2#12 ← phi( inccnt/(byte) cnt2#5 )
  (byte) cnt#13 ← phi( inccnt/(byte) cnt#6 )
  (byte) inccnt::return#6 ← phi( inccnt/(byte) inccnt::return#2 )
  (byte) inccnt::return#3 ← (byte) inccnt::return#6
  (byte) cnt#7 ← (byte) cnt#13
  (byte) cnt2#6 ← (byte) cnt2#12
  (byte) cnt3#6 ← (byte) cnt3#12
  return (byte) inccnt::return#3
  to:@return
@end: scope:[]  from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (byte) cnt#0 ← (byte) 0
  (byte) cnt2#0 ← (byte) 0
  (byte) cnt3#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt3#7 ← phi( @begin/(byte) cnt3#4 )
  (byte) cnt2#7 ← phi( @begin/(byte) cnt2#4 )
  (byte) cnt#8 ← phi( @begin/(byte) cnt#5 )
  (byte) cnt#1 ← (byte) cnt#8
  (byte) cnt2#1 ← (byte) cnt2#7
  (byte) cnt3#1 ← (byte) cnt3#7
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(byte[256]) SCREEN#0 )
  (byte) cnt3#13 ← phi( @begin/(byte) cnt3#0 )
  (byte) cnt2#13 ← phi( @begin/(byte) cnt2#0 )
  (byte) cnt#14 ← phi( @begin/(byte) cnt#0 )
  call inccnt param-assignment
  (byte) inccnt::return#0 ← (byte) inccnt::return#3
  to:main::@1
main::@1: scope:[main]  from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt3#8 ← phi( main/(byte) cnt3#6 )
  (byte) cnt2#8 ← phi( main/(byte) cnt2#6 )
  (byte) cnt#9 ← phi( main/(byte) cnt#7 )
  (byte) inccnt::return#4 ← phi( main/(byte) inccnt::return#0 )
  (byte~) main::$0 ← (byte) inccnt::return#4
  (byte) cnt#2 ← (byte) cnt#9
  (byte) cnt2#2 ← (byte) cnt2#8
  (byte) cnt3#2 ← (byte) cnt3#8
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  (byte) inccnt::return#1 ← (byte) inccnt::return#3
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt3#9 ← phi( main::@1/(byte) cnt3#6 )
  (byte) cnt2#9 ← phi( main::@1/(byte) cnt2#6 )
  (byte) cnt#10 ← phi( main::@1/(byte) cnt#7 )
  (byte) inccnt::return#5 ← phi( main::@1/(byte) inccnt::return#1 )
  (byte~) main::$1 ← (byte) inccnt::return#5
  (byte) cnt#4 ← (byte) cnt#10
  (byte) cnt2#3 ← (byte) cnt2#9
  (byte) cnt3#3 ← (byte) cnt3#9
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt3#10 ← phi( main::@2/(byte) cnt3#3 )
  (byte) cnt2#10 ← phi( main::@2/(byte) cnt2#3 )
  (byte) cnt#11 ← phi( main::@2/(byte) cnt#4 )
  (byte) cnt#5 ← (byte) cnt#11
  (byte) cnt2#4 ← (byte) cnt2#10
  (byte) cnt3#4 ← (byte) cnt3#10
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt3#11 ← phi( main/(byte) cnt3#13 main::@1/(byte) cnt3#2 )
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#2 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#6 ← ++ (byte) cnt#12
  (byte) cnt2#5 ← ++ (byte) cnt2#11
  (byte) cnt3#5 ← ++ (byte) cnt3#11
  (byte) inccnt::return#2 ← (byte) cnt#6
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt3#12 ← phi( inccnt/(byte) cnt3#5 )
  (byte) cnt2#12 ← phi( inccnt/(byte) cnt2#5 )
  (byte) cnt#13 ← phi( inccnt/(byte) cnt#6 )
  (byte) inccnt::return#6 ← phi( inccnt/(byte) inccnt::return#2 )
  (byte) inccnt::return#3 ← (byte) inccnt::return#6
  (byte) cnt#7 ← (byte) cnt#13
  (byte) cnt2#6 ← (byte) cnt2#12
  (byte) cnt3#6 ← (byte) cnt3#12
  return 
  to:@return
@end: scope:[]  from @3

INITIAL SSA SYMBOL TABLE
(label) @3
(label) @begin
(label) @end
(byte[256]) SCREEN
(byte[256]) SCREEN#0
(byte[256]) SCREEN#1
(byte[256]) SCREEN#2
(byte[256]) SCREEN#3
(byte) cnt
(byte) cnt#0
(byte) cnt#1
(byte) cnt#10
(byte) cnt#11
(byte) cnt#12
(byte) cnt#13
(byte) cnt#14
(byte) cnt#2
(byte) cnt#3
(byte) cnt#4
(byte) cnt#5
(byte) cnt#6
(byte) cnt#7
(byte) cnt#8
(byte) cnt#9
(byte) cnt2
(byte) cnt2#0
(byte) cnt2#1
(byte) cnt2#10
(byte) cnt2#11
(byte) cnt2#12
(byte) cnt2#13
(byte) cnt2#2
(byte) cnt2#3
(byte) cnt2#4
(byte) cnt2#5
(byte) cnt2#6
(byte) cnt2#7
(byte) cnt2#8
(byte) cnt2#9
(byte) cnt3
(byte) cnt3#0
(byte) cnt3#1
(byte) cnt3#10
(byte) cnt3#11
(byte) cnt3#12
(byte) cnt3#13
(byte) cnt3#2
(byte) cnt3#3
(byte) cnt3#4
(byte) cnt3#5
(byte) cnt3#6
(byte) cnt3#7
(byte) cnt3#8
(byte) cnt3#9
(byte()) inccnt()
(label) inccnt::@return
(byte) inccnt::return
(byte) inccnt::return#0
(byte) inccnt::return#1
(byte) inccnt::return#2
(byte) inccnt::return#3
(byte) inccnt::return#4
(byte) inccnt::return#5
(byte) inccnt::return#6
(void()) main()
(byte~) main::$0
(byte~) main::$1
(label) main::@1
(label) main::@2
(label) main::@return

Constant (byte) cnt#0 (byte) 0
Constant (byte) cnt2#0 (byte) 0
Constant (byte) cnt3#0 (byte) 0
Constant (byte[256]) SCREEN#0 (word) 1024
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt3#7 ← phi( @begin/(byte) cnt3#4 )
  (byte) cnt2#7 ← phi( @begin/(byte) cnt2#4 )
  (byte) cnt#8 ← phi( @begin/(byte) cnt#5 )
  (byte) cnt#1 ← (byte) cnt#8
  (byte) cnt2#1 ← (byte) cnt2#7
  (byte) cnt3#1 ← (byte) cnt3#7
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(word) 1024 )
  (byte) cnt3#13 ← phi( @begin/(byte) 0 )
  (byte) cnt2#13 ← phi( @begin/(byte) 0 )
  (byte) cnt#14 ← phi( @begin/(byte) 0 )
  call inccnt param-assignment
  (byte) inccnt::return#0 ← (byte) inccnt::return#3
  to:main::@1
main::@1: scope:[main]  from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt3#8 ← phi( main/(byte) cnt3#6 )
  (byte) cnt2#8 ← phi( main/(byte) cnt2#6 )
  (byte) cnt#9 ← phi( main/(byte) cnt#7 )
  (byte) inccnt::return#4 ← phi( main/(byte) inccnt::return#0 )
  (byte~) main::$0 ← (byte) inccnt::return#4
  (byte) cnt#2 ← (byte) cnt#9
  (byte) cnt2#2 ← (byte) cnt2#8
  (byte) cnt3#2 ← (byte) cnt3#8
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  (byte) inccnt::return#1 ← (byte) inccnt::return#3
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt3#9 ← phi( main::@1/(byte) cnt3#6 )
  (byte) cnt2#9 ← phi( main::@1/(byte) cnt2#6 )
  (byte) cnt#10 ← phi( main::@1/(byte) cnt#7 )
  (byte) inccnt::return#5 ← phi( main::@1/(byte) inccnt::return#1 )
  (byte~) main::$1 ← (byte) inccnt::return#5
  (byte) cnt#4 ← (byte) cnt#10
  (byte) cnt2#3 ← (byte) cnt2#9
  (byte) cnt3#3 ← (byte) cnt3#9
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt3#10 ← phi( main::@2/(byte) cnt3#3 )
  (byte) cnt2#10 ← phi( main::@2/(byte) cnt2#3 )
  (byte) cnt#11 ← phi( main::@2/(byte) cnt#4 )
  (byte) cnt#5 ← (byte) cnt#11
  (byte) cnt2#4 ← (byte) cnt2#10
  (byte) cnt3#4 ← (byte) cnt3#10
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt3#11 ← phi( main/(byte) cnt3#13 main::@1/(byte) cnt3#2 )
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#2 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#6 ← ++ (byte) cnt#12
  (byte) cnt2#5 ← ++ (byte) cnt2#11
  (byte) cnt3#5 ← ++ (byte) cnt3#11
  (byte) inccnt::return#2 ← (byte) cnt#6
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt3#12 ← phi( inccnt/(byte) cnt3#5 )
  (byte) cnt2#12 ← phi( inccnt/(byte) cnt2#5 )
  (byte) cnt#13 ← phi( inccnt/(byte) cnt#6 )
  (byte) inccnt::return#6 ← phi( inccnt/(byte) inccnt::return#2 )
  (byte) inccnt::return#3 ← (byte) inccnt::return#6
  (byte) cnt#7 ← (byte) cnt#13
  (byte) cnt2#6 ← (byte) cnt2#12
  (byte) cnt3#6 ← (byte) cnt3#12
  return 
  to:@return
@end: scope:[]  from @3

Not aliassing across scopes: main::$0 inccnt::return#4
Not aliassing across scopes: main::$1 inccnt::return#5
Not aliassing across scopes: inccnt::return#2 cnt#6
Alias (byte) cnt#1 = (byte) cnt#8 (byte) cnt#5 (byte) cnt#9 (byte) cnt#7 (byte) cnt#2 (byte) cnt#10 (byte) cnt#4 (byte) cnt#11 (byte) cnt#13 (byte) cnt#6 
Alias (byte) cnt2#1 = (byte) cnt2#7 (byte) cnt2#4 (byte) cnt2#8 (byte) cnt2#6 (byte) cnt2#2 (byte) cnt2#9 (byte) cnt2#3 (byte) cnt2#10 (byte) cnt2#12 (byte) cnt2#5 
Alias (byte) cnt3#1 = (byte) cnt3#7 (byte) cnt3#4 (byte) cnt3#8 (byte) cnt3#6 (byte) cnt3#2 (byte) cnt3#9 (byte) cnt3#3 (byte) cnt3#10 (byte) cnt3#12 (byte) cnt3#5 
Alias (byte) inccnt::return#0 = (byte) inccnt::return#3 (byte) inccnt::return#4 (byte) inccnt::return#1 (byte) inccnt::return#5 (byte) inccnt::return#6 (byte) inccnt::return#2 
Alias (byte[256]) SCREEN#1 = (byte[256]) SCREEN#3 (byte[256]) SCREEN#2 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#1 ← phi( @begin/(word) 1024 )
  (byte) cnt3#13 ← phi( @begin/(byte) 0 )
  (byte) cnt2#13 ← phi( @begin/(byte) 0 )
  (byte) cnt#14 ← phi( @begin/(byte) 0 )
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((byte[256]) SCREEN#1 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt3#11 ← phi( main/(byte) cnt3#13 main::@1/(byte) cnt3#1 )
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) cnt3#1 ← ++ (byte) cnt3#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @3

Redundant Phi (byte) cnt#14 (byte) 0
Redundant Phi (byte) cnt2#13 (byte) 0
Redundant Phi (byte) cnt3#13 (byte) 0
Redundant Phi (byte[256]) SCREEN#1 (word) 1024
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt3#11 ← phi( main/(byte) 0 main::@1/(byte) cnt3#1 )
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) cnt3#1 ← ++ (byte) cnt3#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @3

Culled Empty Block (label) @3
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt3#11 ← phi( main/(byte) 0 main::@1/(byte) cnt3#1 )
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) cnt3#1 ← ++ (byte) cnt3#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @begin

Consolidated assigned array index constant in assignment *(1024)
Consolidated assigned array index constant in assignment *(1025)
Succesful SSA optimization Pass2ConstantAdditionElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1025) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt3#11 ← phi( main/(byte) 0 main::@1/(byte) cnt3#1 )
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) cnt3#1 ← ++ (byte) cnt3#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @begin

Not aliassing across scopes: main::$0 inccnt::return#0
Not aliassing across scopes: main::$1 inccnt::return#0
Not aliassing across scopes: inccnt::return#0 cnt#1
Not aliassing across scopes: main::$0 inccnt::return#0
Not aliassing across scopes: main::$1 inccnt::return#0
Not aliassing across scopes: inccnt::return#0 cnt#1
FINAL SYMBOL TABLE
(label) @begin
(label) @end
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1
(byte) cnt#12
(byte) cnt#3
(byte) cnt2
(byte) cnt2#1
(byte) cnt2#11
(byte) cnt3
(byte) cnt3#1
(byte) cnt3#11
(byte()) inccnt()
(label) inccnt::@return
(byte) inccnt::return
(byte) inccnt::return#0
(void()) main()
(byte~) main::$0
(byte~) main::$1
(label) main::@1
(label) main::@2
(label) main::@return

Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  call main param-assignment
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  (byte~) cnt#15 ← (byte) cnt#3
  (byte~) cnt2#14 ← (byte) cnt2#1
  (byte~) cnt3#14 ← (byte) cnt3#1
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1025) ← (byte~) main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt3#11 ← phi( main/(byte) 0 main::@1/(byte~) cnt3#14 )
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte~) cnt2#14 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte~) cnt#15 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) cnt3#1 ← ++ (byte) cnt3#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  to:main::@1
main::@1: scope:[main]  from main
  [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 cnt3#1 ]
  [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 cnt3#1 ]
  [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 cnt3#1 ]
  [5] (byte~) cnt#15 ← (byte) cnt#3 [ cnt2#1 cnt3#1 cnt#15 ]
  [6] (byte~) cnt2#14 ← (byte) cnt2#1 [ cnt3#1 cnt#15 cnt2#14 ]
  [7] (byte~) cnt3#14 ← (byte) cnt3#1 [ cnt#15 cnt2#14 cnt3#14 ]
  [8] call inccnt param-assignment [ inccnt::return#0 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [9] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
  [10] *((word) 1025) ← (byte~) main::$1 [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [11] return  [ ]
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  [12] (byte) cnt3#11 ← phi( main/(byte) 0 main::@1/(byte~) cnt3#14 ) [ cnt#12 cnt2#11 cnt3#11 ]
  [12] (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte~) cnt2#14 ) [ cnt#12 cnt2#11 cnt3#11 ]
  [12] (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte~) cnt#15 ) [ cnt#12 cnt2#11 cnt3#11 ]
  [13] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 cnt3#11 ]
  [14] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 cnt3#11 ]
  [15] (byte) cnt3#1 ← ++ (byte) cnt3#11 [ cnt#1 cnt2#1 cnt3#1 ]
  [16] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  [17] return  [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  to:@return

Created 3 initial phi equivalence classes
Coalesced [5] cnt#15 ← cnt#3
Coalesced [6] cnt2#14 ← cnt2#1
Coalesced [7] cnt3#14 ← cnt3#1
Coalesced down to 3 phi equivalence classes
Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  to:main::@1
main::@1: scope:[main]  from main
  [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 cnt3#1 ]
  [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 cnt3#1 ]
  [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 cnt3#1 ]
  [5] call inccnt param-assignment [ inccnt::return#0 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
  [7] *((word) 1025) ← (byte~) main::$1 [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [8] return  [ ]
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  [9] (byte) cnt3#11 ← phi( main/(byte) 0 main::@1/(byte) cnt3#1 ) [ cnt#12 cnt2#11 cnt3#11 ]
  [9] (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 ) [ cnt#12 cnt2#11 cnt3#11 ]
  [9] (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 ) [ cnt#12 cnt2#11 cnt3#11 ]
  [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 cnt3#11 ]
  [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 cnt3#11 ]
  [12] (byte) cnt3#1 ← ++ (byte) cnt3#11 [ cnt#1 cnt2#1 cnt3#1 ]
  [13] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  [14] return  [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  to:@return

CALL GRAPH
Calls in [] to 0:main 
Calls in [main] to 1:inccnt 5:inccnt 

DOMINATORS
@begin dominated by  @begin 
@end dominated by  @end @begin 
main dominated by  @begin main 
main::@1 dominated by  @begin main::@1 main 
main::@2 dominated by  @begin main::@2 main::@1 main 
main::@return dominated by  main::@return @begin main::@2 main::@1 main 
inccnt dominated by  inccnt @begin main 
inccnt::@return dominated by  inccnt::@return inccnt @begin main 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [main]
Found 0 loops in scope [inccnt]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1 0.75
(byte) cnt#12 4.0
(byte) cnt#3 4.0
(byte) cnt2
(byte) cnt2#1 0.5
(byte) cnt2#11 2.0
(byte) cnt3
(byte) cnt3#1 0.5714285714285714
(byte) cnt3#11 1.3333333333333333
(byte()) inccnt()
(byte) inccnt::return
(byte) inccnt::return#0 1.5
(void()) main()
(byte~) main::$0 4.0
(byte~) main::$1 4.0

Initial phi equivalence classes
[ cnt#12 cnt#3 ]
[ cnt2#11 cnt2#1 ]
[ cnt3#11 cnt3#1 ]
Added variable main::$0 to zero page equivalence class [ main::$0 ]
Added variable main::$1 to zero page equivalence class [ main::$1 ]
Added variable cnt#1 to zero page equivalence class [ cnt#1 ]
Added variable inccnt::return#0 to zero page equivalence class [ inccnt::return#0 ]
Complete equivalence classes
[ cnt#12 cnt#3 ]
[ cnt2#11 cnt2#1 ]
[ cnt3#11 cnt3#1 ]
[ main::$0 ]
[ main::$1 ]
[ cnt#1 ]
[ inccnt::return#0 ]
Allocated zp ZP_BYTE:2 cnt#12 [ cnt#12 cnt#3 ]
Allocated zp ZP_BYTE:3 cnt2#11 [ cnt2#11 cnt2#1 ]
Allocated zp ZP_BYTE:4 cnt3#11 [ cnt3#11 cnt3#1 ]
Allocated zp ZP_BYTE:5 $0 [ main::$0 ]
Allocated zp ZP_BYTE:6 $1 [ main::$1 ]
Allocated zp ZP_BYTE:7 cnt#1 [ cnt#1 ]
Allocated zp ZP_BYTE:8 return#0 [ inccnt::return#0 ]
INITIAL ASM
//SEG0 Global ZP labels
  .label cnt = 7
  .label cnt2 = 3
  .label cnt3 = 4
  .label cnt#12 = 2
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
  jsr main
  jmp bend
//SEG3 @end
bend:
//SEG4 main
main: {
    .label $0 = 5
    .label $1 = 6
  //SEG5 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  //SEG6 [9] phi from main to inccnt
  inccnt_from_main:
  //SEG7 [9] phi (byte) cnt3#11 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta cnt3
  //SEG8 [9] phi (byte) cnt2#11 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta cnt2
  //SEG9 [9] phi (byte) cnt#12 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta cnt_12
    jsr inccnt
    jmp b1
  //SEG10 main::@1
  b1:
  //SEG11 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 cnt3#1 ] -- zpby1=zpby2 
    lda inccnt.return
    sta $0
  //SEG12 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 cnt3#1 ] -- _star_cowo1=zpby1 
    lda $0
    sta $400
  //SEG13 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 cnt3#1 ] -- zpby1=_inc_zpby2 
    lda cnt
    sta cnt_12
    inc cnt_12
  //SEG14 [5] call inccnt param-assignment [ inccnt::return#0 ]
  //SEG15 [9] phi from main::@1 to inccnt
  inccnt_from_b1:
  //SEG16 [9] phi (byte) cnt3#11 = (byte) cnt3#1 -- register_copy 
  //SEG17 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
  //SEG18 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
    jsr inccnt
    jmp b2
  //SEG19 main::@2
  b2:
  //SEG20 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ] -- zpby1=zpby2 
    lda inccnt.return
    sta $1
  //SEG21 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=zpby1 
    lda $1
    sta $401
    jmp breturn
  //SEG22 main::@return
  breturn:
  //SEG23 [8] return  [ ]
    rts
}
//SEG24 inccnt
inccnt: {
    .label return = 8
  //SEG25 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 cnt3#11 ] -- zpby1=_inc_zpby2 
    lda cnt_12
    sta cnt
    inc cnt
  //SEG26 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 cnt3#11 ] -- zpby1=_inc_zpby1 
    inc cnt2
  //SEG27 [12] (byte) cnt3#1 ← ++ (byte) cnt3#11 [ cnt#1 cnt2#1 cnt3#1 ] -- zpby1=_inc_zpby1 
    inc cnt3
  //SEG28 [13] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ] -- zpby1=zpby2 
    lda cnt
    sta return
    jmp breturn
  //SEG29 inccnt::@return
  breturn:
  //SEG30 [14] return  [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp ZP_BYTE:2 cnt#12 [ cnt#12 cnt#3 ] : zp ZP_BYTE:2 cnt#12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 cnt2 [ cnt2#11 cnt2#1 ] : zp ZP_BYTE:3 cnt2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 cnt3 [ cnt3#11 cnt3#1 ] : zp ZP_BYTE:4 cnt3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 $0 [ main::$0 ] : zp ZP_BYTE:5 $0 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 $1 [ main::$1 ] : zp ZP_BYTE:6 $1 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 cnt [ cnt#1 ] : zp ZP_BYTE:7 cnt , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 return [ inccnt::return#0 ] : zp ZP_BYTE:8 return , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 8: zp ZP_BYTE:2 cnt#12 [ cnt#12 cnt#3 ] 2.5: zp ZP_BYTE:3 cnt2 [ cnt2#11 cnt2#1 ] 1.9: zp ZP_BYTE:4 cnt3 [ cnt3#11 cnt3#1 ] 0.75: zp ZP_BYTE:7 cnt [ cnt#1 ] 
Uplift Scope [main] 4: zp ZP_BYTE:5 $0 [ main::$0 ] 4: zp ZP_BYTE:6 $1 [ main::$1 ] 
Uplift Scope [inccnt] 1.5: zp ZP_BYTE:8 return [ inccnt::return#0 ] 

Uplifting [] best 99 combination reg byte x [ cnt#12 cnt#3 ] reg byte y [ cnt2#11 cnt2#1 ] zp ZP_BYTE:4 cnt3 [ cnt3#11 cnt3#1 ] reg byte x [ cnt#1 ] 
Uplifting [main] best 87 combination reg byte a [ main::$0 ] reg byte a [ main::$1 ] 
Uplifting [inccnt] best 77 combination reg byte a [ inccnt::return#0 ] 
Allocated (was zp ZP_BYTE:4 cnt3) zp ZP_BYTE:2 cnt3#11 [ cnt3#11 cnt3#1 ]
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 Global ZP labels
  .label cnt3 = 2
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
  jsr main
//SEG3 @end
bend:
//SEG4 main
main: {
  //SEG5 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  //SEG6 [9] phi from main to inccnt
  inccnt_from_main:
  //SEG7 [9] phi (byte) cnt3#11 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta cnt3
  //SEG8 [9] phi (byte) cnt2#11 = (byte) 0 -- yby=coby1 
    ldy #$0
  //SEG9 [9] phi (byte) cnt#12 = (byte) 0 -- xby=coby1 
    ldx #$0
    jsr inccnt
  //SEG10 main::@1
  b1:
  //SEG11 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 cnt3#1 ]
    // (byte~) main::$0 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG12 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 cnt3#1 ] -- _star_cowo1=aby 
    sta $400
  //SEG13 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 cnt3#1 ] -- xby=_inc_xby 
    inx
  //SEG14 [5] call inccnt param-assignment [ inccnt::return#0 ]
  //SEG15 [9] phi from main::@1 to inccnt
  inccnt_from_b1:
  //SEG16 [9] phi (byte) cnt3#11 = (byte) cnt3#1 -- register_copy 
  //SEG17 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
  //SEG18 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
    jsr inccnt
  //SEG19 main::@2
  b2:
  //SEG20 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
    // (byte~) main::$1 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG21 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=aby 
    sta $401
  //SEG22 main::@return
  breturn:
  //SEG23 [8] return  [ ]
    rts
}
//SEG24 inccnt
inccnt: {
  //SEG25 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 cnt3#11 ] -- xby=_inc_xby 
    inx
  //SEG26 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 cnt3#11 ] -- yby=_inc_yby 
    iny
  //SEG27 [12] (byte) cnt3#1 ← ++ (byte) cnt3#11 [ cnt#1 cnt2#1 cnt3#1 ] -- zpby1=_inc_zpby1 
    inc cnt3
  //SEG28 [13] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ] -- aby=xby 
    txa
  //SEG29 inccnt::@return
  breturn:
  //SEG30 [14] return  [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
    rts
}

Removing instruction bbegin:
Removing instruction bend:
Removing instruction inccnt_from_main:
Removing instruction b1:
Removing instruction inccnt_from_b1:
Removing instruction b2:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
ASSEMBLER
//SEG0 Global ZP labels
  .label cnt3 = 2
//SEG1 @begin
//SEG2 [0] call main param-assignment [ ]
  jsr main
//SEG3 @end
//SEG4 main
main: {
  //SEG5 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  //SEG6 [9] phi from main to inccnt
  //SEG7 [9] phi (byte) cnt3#11 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta cnt3
  //SEG8 [9] phi (byte) cnt2#11 = (byte) 0 -- yby=coby1 
    ldy #$0
  //SEG9 [9] phi (byte) cnt#12 = (byte) 0 -- xby=coby1 
    ldx #$0
    jsr inccnt
  //SEG10 main::@1
  //SEG11 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 cnt3#1 ]
    // (byte~) main::$0 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG12 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 cnt3#1 ] -- _star_cowo1=aby 
    sta $400
  //SEG13 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 cnt3#1 ] -- xby=_inc_xby 
    inx
  //SEG14 [5] call inccnt param-assignment [ inccnt::return#0 ]
  //SEG15 [9] phi from main::@1 to inccnt
  //SEG16 [9] phi (byte) cnt3#11 = (byte) cnt3#1 -- register_copy 
  //SEG17 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
  //SEG18 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
    jsr inccnt
  //SEG19 main::@2
  //SEG20 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
    // (byte~) main::$1 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG21 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=aby 
    sta $401
  //SEG22 main::@return
  //SEG23 [8] return  [ ]
    rts
}
//SEG24 inccnt
inccnt: {
  //SEG25 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 cnt3#11 ] -- xby=_inc_xby 
    inx
  //SEG26 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 cnt3#11 ] -- yby=_inc_yby 
    iny
  //SEG27 [12] (byte) cnt3#1 ← ++ (byte) cnt3#11 [ cnt#1 cnt2#1 cnt3#1 ] -- zpby1=_inc_zpby1 
    inc cnt3
  //SEG28 [13] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ] -- aby=xby 
    txa
  //SEG29 inccnt::@return
  //SEG30 [14] return  [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
    rts
}

FINAL SYMBOL TABLE
(label) @begin
(label) @end
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1 reg byte x 0.75
(byte) cnt#12 reg byte x 4.0
(byte) cnt#3 reg byte x 4.0
(byte) cnt2
(byte) cnt2#1 reg byte y 0.5
(byte) cnt2#11 reg byte y 2.0
(byte) cnt3
(byte) cnt3#1 zp ZP_BYTE:2 cnt3 0.5714285714285714
(byte) cnt3#11 zp ZP_BYTE:2 cnt3 1.3333333333333333
(byte()) inccnt()
(label) inccnt::@return
(byte) inccnt::return
(byte) inccnt::return#0 reg byte a 1.5
(void()) main()
(byte~) main::$0 reg byte a 4.0
(byte~) main::$1 reg byte a 4.0
(label) main::@1
(label) main::@2
(label) main::@return

reg byte x [ cnt#12 cnt#3 ]
reg byte y [ cnt2#11 cnt2#1 ]
zp ZP_BYTE:2 cnt3 [ cnt3#11 cnt3#1 ]
reg byte a [ main::$0 ]
reg byte a [ main::$1 ]
reg byte x [ cnt#1 ]
reg byte a [ inccnt::return#0 ]

FINAL CODE
//SEG0 Global ZP labels
  .label cnt3 = 2
//SEG1 @begin
//SEG2 [0] call main param-assignment [ ]
  jsr main
//SEG3 @end
//SEG4 main
main: {
  //SEG5 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
  //SEG6 [9] phi from main to inccnt
  //SEG7 [9] phi (byte) cnt3#11 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta cnt3
  //SEG8 [9] phi (byte) cnt2#11 = (byte) 0 -- yby=coby1 
    ldy #$0
  //SEG9 [9] phi (byte) cnt#12 = (byte) 0 -- xby=coby1 
    ldx #$0
    jsr inccnt
  //SEG10 main::@1
  //SEG11 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 cnt3#1 ]
    // (byte~) main::$0 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG12 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 cnt3#1 ] -- _star_cowo1=aby 
    sta $400
  //SEG13 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 cnt3#1 ] -- xby=_inc_xby 
    inx
  //SEG14 [5] call inccnt param-assignment [ inccnt::return#0 ]
  //SEG15 [9] phi from main::@1 to inccnt
  //SEG16 [9] phi (byte) cnt3#11 = (byte) cnt3#1 -- register_copy 
  //SEG17 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
  //SEG18 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
    jsr inccnt
  //SEG19 main::@2
  //SEG20 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
    // (byte~) main::$1 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG21 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=aby 
    sta $401
  //SEG22 main::@return
  //SEG23 [8] return  [ ]
    rts
}
//SEG24 inccnt
inccnt: {
  //SEG25 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 cnt3#11 ] -- xby=_inc_xby 
    inx
  //SEG26 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 cnt3#11 ] -- yby=_inc_yby 
    iny
  //SEG27 [12] (byte) cnt3#1 ← ++ (byte) cnt3#11 [ cnt#1 cnt2#1 cnt3#1 ] -- zpby1=_inc_zpby1 
    inc cnt3
  //SEG28 [13] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ] -- aby=xby 
    txa
  //SEG29 inccnt::@return
  //SEG30 [14] return  [ inccnt::return#0 cnt#1 cnt2#1 cnt3#1 ]
    rts
}

