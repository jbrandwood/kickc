Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Fixing struct type size struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = byte1 &memcpy_dma_command
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = byte1 &memcpy_dma_command4
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = byte1 &memset_dma_command
Setting inferred volatile on symbol affected by address-of: memoryRemap::aVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap::xVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap::yVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap::zVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::lMb in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::uMb in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::aVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::xVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::yVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::zVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Inlined call vicSelectGfxBank::$0 = call toDd00(vicSelectGfxBank::gfx)
Eliminating unused variable with no statement memoryRemap::$0
Eliminating unused variable with no statement memoryRemap::$4
Eliminating unused variable with no statement memoryRemap::$5
Eliminating unused variable with no statement memoryRemap::$9
Eliminating unused variable with no statement memcpy_dma_command
Eliminating unused variable with no statement memcpy_dma_command4
Eliminating unused variable with no statement memset_dma_command

CONTROL FLOW GRAPH SSA

void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main
  memoryRemap::upperPageOffset#1 = phi( main/memoryRemap::upperPageOffset#0 )
  memoryRemap::remapBlocks#1 = phi( main/memoryRemap::remapBlocks#0 )
  memoryRemap::lowerPageOffset#1 = phi( main/memoryRemap::lowerPageOffset#0 )
  memoryRemap::aVal = byte0  memoryRemap::lowerPageOffset#1
  memoryRemap::$1 = memoryRemap::remapBlocks#1 << 4
  memoryRemap::$2 = byte1  memoryRemap::lowerPageOffset#1
  memoryRemap::$3 = memoryRemap::$2 & $f
  memoryRemap::xVal = memoryRemap::$1 | memoryRemap::$3
  memoryRemap::yVal = byte0  memoryRemap::upperPageOffset#1
  memoryRemap::$6 = memoryRemap::remapBlocks#1 & $f0
  memoryRemap::$7 = byte1  memoryRemap::upperPageOffset#1
  memoryRemap::$8 = memoryRemap::$7 & $f
  memoryRemap::zVal = memoryRemap::$6 | memoryRemap::$8
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  return 
  to:@return

void memcpy_dma256(char dest_mb , char dest_bank , void *dest , char src_mb , char src_bank , void *src , unsigned int num)
memcpy_dma256: scope:[memcpy_dma256]  from main::@1
  memcpy_dma256::dest#1 = phi( main::@1/memcpy_dma256::dest#0 )
  memcpy_dma256::dest_bank#1 = phi( main::@1/memcpy_dma256::dest_bank#0 )
  memcpy_dma256::src#1 = phi( main::@1/memcpy_dma256::src#0 )
  memcpy_dma256::src_bank#1 = phi( main::@1/memcpy_dma256::src_bank#0 )
  memcpy_dma256::num#1 = phi( main::@1/memcpy_dma256::num#0 )
  memcpy_dma256::dest_mb#1 = phi( main::@1/memcpy_dma256::dest_mb#0 )
  memcpy_dma256::src_mb#1 = phi( main::@1/memcpy_dma256::src_mb#0 )
  memcpy_dma256::dmaMode#0 = *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  memcpy_dma_command256[1] = memcpy_dma256::src_mb#1
  memcpy_dma_command256[3] = memcpy_dma256::dest_mb#1
  memcpy_dma256::$0 = & memcpy_dma_command256[6]
  memcpy_dma256::f018b#0 = (struct DMA_LIST_F018B *)memcpy_dma256::$0
  memcpy_dma256::$8 = (unsigned int *)memcpy_dma256::f018b#0
  memcpy_dma256::$3 = memcpy_dma256::$8 + OFFSET_STRUCT_DMA_LIST_F018B_COUNT
  *memcpy_dma256::$3 = memcpy_dma256::num#1
  memcpy_dma256::$9 = (char *)memcpy_dma256::f018b#0
  memcpy_dma256::$4 = memcpy_dma256::$9 + OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK
  *memcpy_dma256::$4 = memcpy_dma256::src_bank#1
  memcpy_dma256::$10 = (char **)memcpy_dma256::f018b#0
  memcpy_dma256::$5 = memcpy_dma256::$10 + OFFSET_STRUCT_DMA_LIST_F018B_SRC
  *memcpy_dma256::$5 = ((char *)) memcpy_dma256::src#1
  memcpy_dma256::$11 = (char *)memcpy_dma256::f018b#0
  memcpy_dma256::$6 = memcpy_dma256::$11 + OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
  *memcpy_dma256::$6 = memcpy_dma256::dest_bank#1
  memcpy_dma256::$12 = (char **)memcpy_dma256::f018b#0
  memcpy_dma256::$7 = memcpy_dma256::$12 + OFFSET_STRUCT_DMA_LIST_F018B_DEST
  *memcpy_dma256::$7 = ((char *)) memcpy_dma256::dest#1
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  memcpy_dma256::$1 = byte1  memcpy_dma_command256
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = memcpy_dma256::$1
  memcpy_dma256::$2 = byte0  memcpy_dma_command256
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = memcpy_dma256::$2
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma256::dmaMode#0
  to:memcpy_dma256::@return
memcpy_dma256::@return: scope:[memcpy_dma256]  from memcpy_dma256
  return 
  to:@return

void main()
main: scope:[main]  from __start
  memoryRemap::remapBlocks#0 = 0
  memoryRemap::lowerPageOffset#0 = 0
  memoryRemap::upperPageOffset#0 = 0
  call memoryRemap
  to:main::@1
main::@1: scope:[main]  from main
  memcpy_dma256::dest_mb#0 = 0
  memcpy_dma256::dest_bank#0 = 0
  memcpy_dma256::dest#0 = (void *)DEFAULT_SCREEN
  memcpy_dma256::src_mb#0 = 0
  memcpy_dma256::src_bank#0 = 0
  memcpy_dma256::src#0 = (void *)DEFAULT_SCREEN+$50
  memcpy_dma256::num#0 = $18*$50
  call memcpy_dma256
  to:main::@2
main::@2: scope:[main]  from main::@1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
__constant char * const DEFAULT_SCREEN = (char *)$800
__constant struct F018_DMAGIC * const DMA = (struct F018_DMAGIC *)$d700
__constant const char DMA_COMMAND_COPY = 0
__constant const char DMA_OPTION_DEST_MB = $81
__constant const char DMA_OPTION_END = 0
__constant const char DMA_OPTION_FORMAT_F018B = $a
__constant const char DMA_OPTION_SRC_MB = $80
__constant char OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
__constant char OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
__constant char OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
__constant char OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
__constant char OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
__constant char OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
__constant char OFFSET_STRUCT_F018_DMAGIC_ETRIG = 5
void __start()
void main()
void memcpy_dma256(char dest_mb , char dest_bank , void *dest , char src_mb , char src_bank , void *src , unsigned int num)
char *memcpy_dma256::$0
char memcpy_dma256::$1
char **memcpy_dma256::$10
char *memcpy_dma256::$11
char **memcpy_dma256::$12
char memcpy_dma256::$2
unsigned int *memcpy_dma256::$3
char *memcpy_dma256::$4
char **memcpy_dma256::$5
char *memcpy_dma256::$6
char **memcpy_dma256::$7
unsigned int *memcpy_dma256::$8
char *memcpy_dma256::$9
void *memcpy_dma256::dest
void *memcpy_dma256::dest#0
void *memcpy_dma256::dest#1
char memcpy_dma256::dest_bank
char memcpy_dma256::dest_bank#0
char memcpy_dma256::dest_bank#1
char memcpy_dma256::dest_mb
char memcpy_dma256::dest_mb#0
char memcpy_dma256::dest_mb#1
char memcpy_dma256::dmaMode
char memcpy_dma256::dmaMode#0
struct DMA_LIST_F018B *memcpy_dma256::f018b
struct DMA_LIST_F018B *memcpy_dma256::f018b#0
unsigned int memcpy_dma256::num
unsigned int memcpy_dma256::num#0
unsigned int memcpy_dma256::num#1
void *memcpy_dma256::src
void *memcpy_dma256::src#0
void *memcpy_dma256::src#1
char memcpy_dma256::src_bank
char memcpy_dma256::src_bank#0
char memcpy_dma256::src_bank#1
char memcpy_dma256::src_mb
char memcpy_dma256::src_mb#0
char memcpy_dma256::src_mb#1
__constant char memcpy_dma_command256[] = { DMA_OPTION_SRC_MB, 0, DMA_OPTION_DEST_MB, 0, DMA_OPTION_FORMAT_F018B, DMA_OPTION_END, DMA_COMMAND_COPY, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
char memoryRemap::$1
char memoryRemap::$2
number memoryRemap::$3
number memoryRemap::$6
char memoryRemap::$7
number memoryRemap::$8
__loadstore volatile char memoryRemap::aVal
unsigned int memoryRemap::lowerPageOffset
unsigned int memoryRemap::lowerPageOffset#0
unsigned int memoryRemap::lowerPageOffset#1
char memoryRemap::remapBlocks
char memoryRemap::remapBlocks#0
char memoryRemap::remapBlocks#1
unsigned int memoryRemap::upperPageOffset
unsigned int memoryRemap::upperPageOffset#0
unsigned int memoryRemap::upperPageOffset#1
__loadstore volatile char memoryRemap::xVal
__loadstore volatile char memoryRemap::yVal
__loadstore volatile char memoryRemap::zVal

Adding number conversion cast (unumber) 4 in memoryRemap::$1 = memoryRemap::remapBlocks#1 << 4
Adding number conversion cast (unumber) $f in memoryRemap::$3 = memoryRemap::$2 & $f
Adding number conversion cast (unumber) memoryRemap::$3 in memoryRemap::$3 = memoryRemap::$2 & (unumber)$f
Adding number conversion cast (unumber) $f0 in memoryRemap::$6 = memoryRemap::remapBlocks#1 & $f0
Adding number conversion cast (unumber) memoryRemap::$6 in memoryRemap::$6 = memoryRemap::remapBlocks#1 & (unumber)$f0
Adding number conversion cast (unumber) $f in memoryRemap::$8 = memoryRemap::$7 & $f
Adding number conversion cast (unumber) memoryRemap::$8 in memoryRemap::$8 = memoryRemap::$7 & (unumber)$f
Adding number conversion cast (unumber) 1 in memcpy_dma_command256[1] = memcpy_dma256::src_mb#1
Adding number conversion cast (unumber) 3 in memcpy_dma_command256[3] = memcpy_dma256::dest_mb#1
Adding number conversion cast (unumber) 6 in memcpy_dma256::$0 = & memcpy_dma_command256[6]
Adding number conversion cast (unumber) 1 in *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
Adding number conversion cast (unumber) 0 in *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
Adding number conversion cast (unumber) 0 in *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
Adding number conversion cast (unumber) 0 in memoryRemap::remapBlocks#0 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::lowerPageOffset#0 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::upperPageOffset#0 = 0
Adding number conversion cast (unumber) 0 in memcpy_dma256::dest_mb#0 = 0
Adding number conversion cast (unumber) 0 in memcpy_dma256::dest_bank#0 = 0
Adding number conversion cast (unumber) 0 in memcpy_dma256::src_mb#0 = 0
Adding number conversion cast (unumber) 0 in memcpy_dma256::src_bank#0 = 0
Adding number conversion cast (unumber) $50 in memcpy_dma256::src#0 = (void *)DEFAULT_SCREEN+$50
Adding number conversion cast (unumber) $18*$50 in memcpy_dma256::num#0 = $18*$50
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *memcpy_dma256::$5 = (char *)memcpy_dma256::src#1
Inlining cast *memcpy_dma256::$7 = (char *)memcpy_dma256::dest#1
Inlining cast *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = (unumber)1
Inlining cast *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = (unumber)0
Inlining cast *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = (unumber)0
Inlining cast memoryRemap::remapBlocks#0 = (unumber)0
Inlining cast memoryRemap::lowerPageOffset#0 = (unumber)0
Inlining cast memoryRemap::upperPageOffset#0 = (unumber)0
Inlining cast memcpy_dma256::dest_mb#0 = (unumber)0
Inlining cast memcpy_dma256::dest_bank#0 = (unumber)0
Inlining cast memcpy_dma256::src_mb#0 = (unumber)0
Inlining cast memcpy_dma256::src_bank#0 = (unumber)0
Inlining cast memcpy_dma256::num#0 = (unumber)$18*$50
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (struct F018_DMAGIC *) 55040
Simplifying constant pointer cast (char *) 2048
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast 3
Simplifying constant integer cast 6
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $50
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 4
Finalized unsigned number type (char) $f
Finalized unsigned number type (char) $f0
Finalized unsigned number type (char) $f
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 3
Finalized unsigned number type (char) 6
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $50
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to char in memoryRemap::$3 = memoryRemap::$2 & $f
Inferred type updated to char in memoryRemap::$6 = memoryRemap::remapBlocks#1 & $f0
Inferred type updated to char in memoryRemap::$8 = memoryRemap::$7 & $f
Identical Phi Values memoryRemap::lowerPageOffset#1 memoryRemap::lowerPageOffset#0
Identical Phi Values memoryRemap::remapBlocks#1 memoryRemap::remapBlocks#0
Identical Phi Values memoryRemap::upperPageOffset#1 memoryRemap::upperPageOffset#0
Identical Phi Values memcpy_dma256::src_mb#1 memcpy_dma256::src_mb#0
Identical Phi Values memcpy_dma256::dest_mb#1 memcpy_dma256::dest_mb#0
Identical Phi Values memcpy_dma256::num#1 memcpy_dma256::num#0
Identical Phi Values memcpy_dma256::src_bank#1 memcpy_dma256::src_bank#0
Identical Phi Values memcpy_dma256::src#1 memcpy_dma256::src#0
Identical Phi Values memcpy_dma256::dest_bank#1 memcpy_dma256::dest_bank#0
Identical Phi Values memcpy_dma256::dest#1 memcpy_dma256::dest#0
Successful SSA optimization Pass2IdenticalPhiElimination
Rewriting array member address-of to pointer addition [17] memcpy_dma256::$0 = memcpy_dma_command256 + 6
Successful SSA optimization PassNArrayElementAddressOfRewriting
Constant right-side identified [17] memcpy_dma256::$0 = memcpy_dma_command256 + 6
Constant right-side identified [37] memcpy_dma256::$1 = byte1  memcpy_dma_command256
Constant right-side identified [39] memcpy_dma256::$2 = byte0  memcpy_dma_command256
Constant right-side identified [53] memcpy_dma256::num#0 = (unumber)$18*$50
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memcpy_dma256::$0 = memcpy_dma_command256+6
Constant memcpy_dma256::$1 = byte1 memcpy_dma_command256
Constant memcpy_dma256::$2 = byte0 memcpy_dma_command256
Constant memoryRemap::remapBlocks#0 = 0
Constant memoryRemap::lowerPageOffset#0 = 0
Constant memoryRemap::upperPageOffset#0 = 0
Constant memcpy_dma256::dest_mb#0 = 0
Constant memcpy_dma256::dest_bank#0 = 0
Constant memcpy_dma256::dest#0 = (void *)DEFAULT_SCREEN
Constant memcpy_dma256::src_mb#0 = 0
Constant memcpy_dma256::src_bank#0 = 0
Constant memcpy_dma256::src#0 = (void *)DEFAULT_SCREEN+$50
Constant memcpy_dma256::num#0 = (unumber)$18*$50
Successful SSA optimization Pass2ConstantIdentification
Constant memcpy_dma256::f018b#0 = (struct DMA_LIST_F018B *)memcpy_dma256::$0
Successful SSA optimization Pass2ConstantIdentification
Constant memcpy_dma256::$8 = (unsigned int *)memcpy_dma256::f018b#0
Constant memcpy_dma256::$9 = (char *)memcpy_dma256::f018b#0
Constant memcpy_dma256::$10 = (char **)memcpy_dma256::f018b#0
Constant memcpy_dma256::$11 = (char *)memcpy_dma256::f018b#0
Constant memcpy_dma256::$12 = (char **)memcpy_dma256::f018b#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (char *)memcpy_dma256::src#0 in [27] *memcpy_dma256::$5 = (char *)memcpy_dma256::src#0
Constant value identified (char *)memcpy_dma256::dest#0 in [33] *memcpy_dma256::$7 = (char *)memcpy_dma256::dest#0
Successful SSA optimization Pass2ConstantValues
Converting *(pointer+n) to pointer[n] [21] *memcpy_dma256::$3 = memcpy_dma256::num#0  -- memcpy_dma256::$8[OFFSET_STRUCT_DMA_LIST_F018B_COUNT]
Converting *(pointer+n) to pointer[n] [24] *memcpy_dma256::$4 = memcpy_dma256::src_bank#0  -- memcpy_dma256::$9[OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK]
Converting *(pointer+n) to pointer[n] [27] *memcpy_dma256::$5 = (char *)memcpy_dma256::src#0  -- memcpy_dma256::$10[OFFSET_STRUCT_DMA_LIST_F018B_SRC]
Converting *(pointer+n) to pointer[n] [30] *memcpy_dma256::$6 = memcpy_dma256::dest_bank#0  -- memcpy_dma256::$11[OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK]
Converting *(pointer+n) to pointer[n] [33] *memcpy_dma256::$7 = (char *)memcpy_dma256::dest#0  -- memcpy_dma256::$12[OFFSET_STRUCT_DMA_LIST_F018B_DEST]
Successful SSA optimization Pass2InlineDerefIdx
Eliminating unused variable memcpy_dma256::$3 and assignment [15] memcpy_dma256::$3 = memcpy_dma256::$8 + OFFSET_STRUCT_DMA_LIST_F018B_COUNT
Eliminating unused variable memcpy_dma256::$4 and assignment [17] memcpy_dma256::$4 = memcpy_dma256::$9 + OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK
Eliminating unused variable memcpy_dma256::$5 and assignment [19] memcpy_dma256::$5 = memcpy_dma256::$10 + OFFSET_STRUCT_DMA_LIST_F018B_SRC
Eliminating unused variable memcpy_dma256::$6 and assignment [21] memcpy_dma256::$6 = memcpy_dma256::$11 + OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
Eliminating unused variable memcpy_dma256::$7 and assignment [23] memcpy_dma256::$7 = memcpy_dma256::$12 + OFFSET_STRUCT_DMA_LIST_F018B_DEST
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Constant right-side identified [0] memoryRemap::aVal = byte0  memoryRemap::lowerPageOffset#0
Constant right-side identified [1] memoryRemap::$1 = memoryRemap::remapBlocks#0 << 4
Constant right-side identified [2] memoryRemap::$2 = byte1  memoryRemap::lowerPageOffset#0
Constant right-side identified [5] memoryRemap::yVal = byte0  memoryRemap::upperPageOffset#0
Constant right-side identified [6] memoryRemap::$6 = memoryRemap::remapBlocks#0 & $f0
Constant right-side identified [7] memoryRemap::$7 = byte1  memoryRemap::upperPageOffset#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap::$1 = memoryRemap::remapBlocks#0<<4
Constant memoryRemap::$2 = byte1 memoryRemap::lowerPageOffset#0
Constant memoryRemap::$6 = memoryRemap::remapBlocks#0&$f0
Constant memoryRemap::$7 = byte1 memoryRemap::upperPageOffset#0
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero memoryRemap::remapBlocks#0<<4 in 
Simplifying constant evaluating to zero byte1 memoryRemap::lowerPageOffset#0 in 
Simplifying constant evaluating to zero memoryRemap::remapBlocks#0&$f0 in 
Simplifying constant evaluating to zero byte1 memoryRemap::upperPageOffset#0 in 
Simplifying constant evaluating to zero byte0 memoryRemap::lowerPageOffset#0 in [0] memoryRemap::aVal = byte0 memoryRemap::lowerPageOffset#0
Simplifying constant evaluating to zero byte0 memoryRemap::upperPageOffset#0 in [5] memoryRemap::yVal = byte0 memoryRemap::upperPageOffset#0
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero memoryRemap::$3 in [4] memoryRemap::xVal = memoryRemap::$1 | memoryRemap::$3
Simplifying expression containing zero memoryRemap::$8 in [9] memoryRemap::zVal = memoryRemap::$6 | memoryRemap::$8
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant memoryRemap::remapBlocks#0
Eliminating unused constant memoryRemap::lowerPageOffset#0
Eliminating unused constant memoryRemap::upperPageOffset#0
Eliminating unused constant memoryRemap::$1
Eliminating unused constant memoryRemap::$6
Successful SSA optimization PassNEliminateUnusedVars
Alias candidate removed (volatile)memoryRemap::xVal = memoryRemap::$3 
Alias candidate removed (volatile)memoryRemap::zVal = memoryRemap::$8 
Constant right-side identified [1] memoryRemap::$3 = memoryRemap::$2 & $f
Constant right-side identified [4] memoryRemap::$8 = memoryRemap::$7 & $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap::$3 = memoryRemap::$2&$f
Constant memoryRemap::$8 = memoryRemap::$7&$f
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero memoryRemap::$2&$f in 
Simplifying constant evaluating to zero memoryRemap::$7&$f in 
Successful SSA optimization PassNSimplifyConstantZero
Eliminating unused constant memoryRemap::$2
Eliminating unused constant memoryRemap::$7
Successful SSA optimization PassNEliminateUnusedVars
Constant inlined memcpy_dma256::$9 = (char *)memcpy_dma256::f018b#0
Constant inlined memcpy_dma256::$0 = memcpy_dma_command256+6
Constant inlined memoryRemap::$3 = 0
Constant inlined memcpy_dma256::$12 = (char **)memcpy_dma256::f018b#0
Constant inlined memcpy_dma256::$2 = byte0 memcpy_dma_command256
Constant inlined memcpy_dma256::$10 = (char **)memcpy_dma256::f018b#0
Constant inlined memcpy_dma256::$1 = byte1 memcpy_dma_command256
Constant inlined memcpy_dma256::$11 = (char *)memcpy_dma256::f018b#0
Constant inlined memoryRemap::$8 = 0
Constant inlined memcpy_dma256::$8 = (unsigned int *)memcpy_dma256::f018b#0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(memcpy_dma_command256+1)
Consolidated array index constant in *(memcpy_dma_command256+3)
Consolidated array index constant in *((unsigned int *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT)
Consolidated array index constant in *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK)
Consolidated array index constant in *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC)
Consolidated array index constant in *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK)
Consolidated array index constant in *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST)
Successful SSA optimization Pass2ConstantAdditionElimination
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) $18
Finalized unsigned number type (char) $50
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
CALL GRAPH
Calls in [main] to memoryRemap:1 memcpy_dma256:3 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block label main::@2
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call memoryRemap
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call memcpy_dma256
  to:main::@return
main::@return: scope:[main]  from main::@1
  [4] return 
  to:@return

void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main
  [5] memoryRemap::aVal = 0
  [6] memoryRemap::xVal = 0
  [7] memoryRemap::yVal = 0
  [8] memoryRemap::zVal = 0
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  [10] return 
  to:@return

void memcpy_dma256(char dest_mb , char dest_bank , void *dest , char src_mb , char src_bank , void *src , unsigned int num)
memcpy_dma256: scope:[memcpy_dma256]  from main::@1
  [11] memcpy_dma256::dmaMode#0 = *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  [12] *(memcpy_dma_command256+1) = memcpy_dma256::src_mb#0
  [13] *(memcpy_dma_command256+3) = memcpy_dma256::dest_mb#0
  [14] *((unsigned int *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma256::num#0
  [15] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma256::src_bank#0
  [16] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma256::src#0
  [17] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma256::dest_bank#0
  [18] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma256::dest#0
  [19] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  [20] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  [21] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  [22] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memcpy_dma_command256
  [23] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memcpy_dma_command256
  [24] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma256::dmaMode#0
  to:memcpy_dma256::@return
memcpy_dma256::@return: scope:[memcpy_dma256]  from memcpy_dma256
  [25] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void main()
void memcpy_dma256(char dest_mb , char dest_bank , void *dest , char src_mb , char src_bank , void *src , unsigned int num)
void *memcpy_dma256::dest
char memcpy_dma256::dest_bank
char memcpy_dma256::dest_mb
char memcpy_dma256::dmaMode
char memcpy_dma256::dmaMode#0 // 1.6923076923076923
struct DMA_LIST_F018B *memcpy_dma256::f018b
unsigned int memcpy_dma256::num
void *memcpy_dma256::src
char memcpy_dma256::src_bank
char memcpy_dma256::src_mb
void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
__loadstore volatile char memoryRemap::aVal // 2.75
unsigned int memoryRemap::lowerPageOffset
char memoryRemap::remapBlocks
unsigned int memoryRemap::upperPageOffset
__loadstore volatile char memoryRemap::xVal // 3.6666666666666665
__loadstore volatile char memoryRemap::yVal // 5.5
__loadstore volatile char memoryRemap::zVal // 11.0

Initial phi equivalence classes
Added variable memoryRemap::aVal to live range equivalence class [ memoryRemap::aVal ]
Added variable memoryRemap::xVal to live range equivalence class [ memoryRemap::xVal ]
Added variable memoryRemap::yVal to live range equivalence class [ memoryRemap::yVal ]
Added variable memoryRemap::zVal to live range equivalence class [ memoryRemap::zVal ]
Added variable memcpy_dma256::dmaMode#0 to live range equivalence class [ memcpy_dma256::dmaMode#0 ]
Complete equivalence classes
[ memoryRemap::aVal ]
[ memoryRemap::xVal ]
[ memoryRemap::yVal ]
[ memoryRemap::zVal ]
[ memcpy_dma256::dmaMode#0 ]
Allocated zp[1]:2 [ memoryRemap::zVal ]
Allocated zp[1]:3 [ memoryRemap::yVal ]
Allocated zp[1]:4 [ memoryRemap::xVal ]
Allocated zp[1]:5 [ memoryRemap::aVal ]
Allocated zp[1]:6 [ memcpy_dma256::dmaMode#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [5] memoryRemap::aVal = 0 [ memoryRemap::aVal ] ( memoryRemap:1 [ memoryRemap::aVal ] { }  ) always clobbers reg byte a 
Statement [6] memoryRemap::xVal = 0 [ memoryRemap::aVal memoryRemap::xVal ] ( memoryRemap:1 [ memoryRemap::aVal memoryRemap::xVal ] { }  ) always clobbers reg byte a 
Statement [7] memoryRemap::yVal = 0 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] ( memoryRemap:1 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  ) always clobbers reg byte a 
Statement [8] memoryRemap::zVal = 0 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::zVal ] ( memoryRemap:1 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::zVal ] { }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [12] *(memcpy_dma_command256+1) = memcpy_dma256::src_mb#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:6 [ memcpy_dma256::dmaMode#0 ]
Statement [13] *(memcpy_dma_command256+3) = memcpy_dma256::dest_mb#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [14] *((unsigned int *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma256::num#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [15] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma256::src_bank#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [16] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma256::src#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [17] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma256::dest_bank#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [18] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma256::dest#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [19] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [20] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [21] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [22] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memcpy_dma_command256 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [23] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memcpy_dma_command256 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [5] memoryRemap::aVal = 0 [ memoryRemap::aVal ] ( memoryRemap:1 [ memoryRemap::aVal ] { }  ) always clobbers reg byte a 
Statement [6] memoryRemap::xVal = 0 [ memoryRemap::aVal memoryRemap::xVal ] ( memoryRemap:1 [ memoryRemap::aVal memoryRemap::xVal ] { }  ) always clobbers reg byte a 
Statement [7] memoryRemap::yVal = 0 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] ( memoryRemap:1 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  ) always clobbers reg byte a 
Statement [8] memoryRemap::zVal = 0 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::zVal ] ( memoryRemap:1 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::zVal ] { }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [12] *(memcpy_dma_command256+1) = memcpy_dma256::src_mb#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [13] *(memcpy_dma_command256+3) = memcpy_dma256::dest_mb#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [14] *((unsigned int *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma256::num#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [15] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma256::src_bank#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [16] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma256::src#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [17] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma256::dest_bank#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [18] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma256::dest#0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [19] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [20] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [21] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [22] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memcpy_dma_command256 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [23] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memcpy_dma_command256 [ memcpy_dma256::dmaMode#0 ] ( memcpy_dma256:3 [ memcpy_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:5 [ memoryRemap::aVal ] : zp[1]:5 , 
Potential registers zp[1]:4 [ memoryRemap::xVal ] : zp[1]:4 , 
Potential registers zp[1]:3 [ memoryRemap::yVal ] : zp[1]:3 , 
Potential registers zp[1]:2 [ memoryRemap::zVal ] : zp[1]:2 , 
Potential registers zp[1]:6 [ memcpy_dma256::dmaMode#0 ] : zp[1]:6 , reg byte x , reg byte y , reg byte z , 

REGISTER UPLIFT SCOPES
Uplift Scope [memoryRemap] 11: zp[1]:2 [ memoryRemap::zVal ] 5.5: zp[1]:3 [ memoryRemap::yVal ] 3.67: zp[1]:4 [ memoryRemap::xVal ] 2.75: zp[1]:5 [ memoryRemap::aVal ] 
Uplift Scope [memcpy_dma256] 1.69: zp[1]:6 [ memcpy_dma256::dmaMode#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [MOS4569_VICIII] 
Uplift Scope [MEGA65_VICIV] 
Uplift Scope [F018_DMAGIC] 
Uplift Scope [DMA_LIST_F018A] 
Uplift Scope [DMA_LIST_F018B] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [memoryRemap] best 185 combination zp[1]:2 [ memoryRemap::zVal ] zp[1]:3 [ memoryRemap::yVal ] zp[1]:4 [ memoryRemap::xVal ] zp[1]:5 [ memoryRemap::aVal ] 
Uplifting [memcpy_dma256] best 179 combination reg byte x [ memcpy_dma256::dmaMode#0 ] 
Uplifting [MOS6526_CIA] best 179 combination 
Uplifting [MOS6569_VICII] best 179 combination 
Uplifting [MOS6581_SID] best 179 combination 
Uplifting [MOS4569_VICIII] best 179 combination 
Uplifting [MEGA65_VICIV] best 179 combination 
Uplifting [F018_DMAGIC] best 179 combination 
Uplifting [DMA_LIST_F018A] best 179 combination 
Uplifting [DMA_LIST_F018B] best 179 combination 
Uplifting [main] best 179 combination 
Uplifting [] best 179 combination 
Attempting to uplift remaining variables inzp[1]:2 [ memoryRemap::zVal ]
Uplifting [memoryRemap] best 179 combination zp[1]:2 [ memoryRemap::zVal ] 
Attempting to uplift remaining variables inzp[1]:3 [ memoryRemap::yVal ]
Uplifting [memoryRemap] best 179 combination zp[1]:3 [ memoryRemap::yVal ] 
Attempting to uplift remaining variables inzp[1]:4 [ memoryRemap::xVal ]
Uplifting [memoryRemap] best 179 combination zp[1]:4 [ memoryRemap::xVal ] 
Attempting to uplift remaining variables inzp[1]:5 [ memoryRemap::aVal ]
Uplifting [memoryRemap] best 179 combination zp[1]:5 [ memoryRemap::aVal ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// MEGA65 DMA test using 256MB version
// Appendix J in https://mega.scryptos.com/sharefolder-link/MEGA/MEGA65+filehost/Docs/MEGA65-Book_draft.pdf
/// @file
/// Functions for using the F018 DMA for very fast copying or filling of memory
/// @file
/// MEGA65 Registers and Constants
/// @file
/// The MOS 6526 Complex Interface Adapter (CIA)
///
/// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="dma-test4.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  /// DMA command copy
  .const DMA_COMMAND_COPY = 0
  /// $00 = End of options
  .const DMA_OPTION_END = 0
  /// $0B = Use F018B list format
  .const DMA_OPTION_FORMAT_F018B = $a
  /// $80 $xx = Set MB of source address
  .const DMA_OPTION_SRC_MB = $80
  /// $81 $xx = Set MB of destination address
  .const DMA_OPTION_DEST_MB = $81
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
  .const OFFSET_STRUCT_F018_DMAGIC_ETRIG = 5
  /// DMAgic F018 Controller
  .label DMA = $d700
  /// Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
.segment Code
  // main
main: {
    // [1] call memoryRemap
    // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    jsr memoryRemap
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call memcpy_dma256
    // Move screen up using DMA
    jsr memcpy_dma256
    jmp __breturn
    // main::@return
  __breturn:
    // [4] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// void memoryRemap(char remapBlocks, unsigned int lowerPageOffset, unsigned int upperPageOffset)
memoryRemap: {
    .label aVal = 5
    .label xVal = 4
    .label yVal = 3
    .label zVal = 2
    // [5] memoryRemap::aVal = 0 -- vbuz1=vbuc1 
    // lower blocks offset page low
    lda #0
    sta.z aVal
    // [6] memoryRemap::xVal = 0 -- vbuz1=vbuc1 
    // lower blocks to map + lower blocks offset high nibble
    lda #0
    sta.z xVal
    // [7] memoryRemap::yVal = 0 -- vbuz1=vbuc1 
    // upper blocks offset page
    lda #0
    sta.z yVal
    // [8] memoryRemap::zVal = 0 -- vbuz1=vbuc1 
    // upper blocks to map + upper blocks offset page high nibble
    lda #0
    sta.z zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [10] return 
    rts
}
  // memcpy_dma256
// Copy a memory block anywhere in the entire 256MB memory space using MEGA65 DMagic DMA
// Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination.
// - dest_mb The MB value for the destination (0-255)
// - dest_bank The 64KB bank for the destination (0-15)
// - dest The destination address (within the MB and bank)
// - src_mb The MB value for the source (0-255)
// - src_bank The 64KB bank for the source (0-15)
// - src The source address (within the MB and bank)
// - num The number of bytes to copy
// void memcpy_dma256(char dest_mb, char dest_bank, void *dest, char src_mb, char src_bank, void *src, unsigned int num)
memcpy_dma256: {
    .const dest_mb = 0
    .const dest_bank = 0
    .const src_mb = 0
    .const src_bank = 0
    .const num = $18*$50
    .label dest = DEFAULT_SCREEN
    .label src = DEFAULT_SCREEN+$50
    .label f018b = memcpy_dma_command256+6
    // [11] memcpy_dma256::dmaMode#0 = *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [12] *(memcpy_dma_command256+1) = memcpy_dma256::src_mb#0 -- _deref_pbuc1=vbuc2 
    // Set up command
    lda #src_mb
    sta memcpy_dma_command256+1
    // [13] *(memcpy_dma_command256+3) = memcpy_dma256::dest_mb#0 -- _deref_pbuc1=vbuc2 
    lda #dest_mb
    sta memcpy_dma_command256+3
    // [14] *((unsigned int *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma256::num#0 -- _deref_pwuc1=vwuc2 
    lda #<num
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // [15] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma256::src_bank#0 -- _deref_pbuc1=vbuc2 
    lda #src_bank
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK
    // [16] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma256::src#0 -- _deref_qbuc1=pbuc2 
    lda #<src
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>src
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // [17] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma256::dest_bank#0 -- _deref_pbuc1=vbuc2 
    lda #dest_bank
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
    // [18] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma256::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // [19] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [20] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // [21] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // [22] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memcpy_dma_command256 -- _deref_pbuc1=vbuc2 
    lda #>memcpy_dma_command256
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // [23] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memcpy_dma_command256 -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (with option lists)
    lda #<memcpy_dma_command256
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG
    // [24] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma256::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    jmp __breturn
    // memcpy_dma256::@return
  __breturn:
    // [25] return 
    rts
}
  // File Data
.segment Data
  // DMA list entry with options for copying data in the 256MB memory space
  // Contains DMA options options for setting MB followed by DMA_LIST_F018B struct.
  memcpy_dma_command256: .byte DMA_OPTION_SRC_MB, 0, DMA_OPTION_DEST_MB, 0, DMA_OPTION_FORMAT_F018B, DMA_OPTION_END, DMA_COMMAND_COPY, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b1_from_main:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
__constant char * const DEFAULT_SCREEN = (char *) 2048
__constant struct F018_DMAGIC * const DMA = (struct F018_DMAGIC *) 55040
__constant const char DMA_COMMAND_COPY = 0
__constant const char DMA_OPTION_DEST_MB = $81
__constant const char DMA_OPTION_END = 0
__constant const char DMA_OPTION_FORMAT_F018B = $a
__constant const char DMA_OPTION_SRC_MB = $80
__constant char OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
__constant char OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
__constant char OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
__constant char OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
__constant char OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
__constant char OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
__constant char OFFSET_STRUCT_F018_DMAGIC_ETRIG = 5
void main()
void memcpy_dma256(char dest_mb , char dest_bank , void *dest , char src_mb , char src_bank , void *src , unsigned int num)
void *memcpy_dma256::dest
__constant void *memcpy_dma256::dest#0 = (void *)DEFAULT_SCREEN // dest
char memcpy_dma256::dest_bank
__constant char memcpy_dma256::dest_bank#0 = 0 // dest_bank
char memcpy_dma256::dest_mb
__constant char memcpy_dma256::dest_mb#0 = 0 // dest_mb
char memcpy_dma256::dmaMode
char memcpy_dma256::dmaMode#0 // reg byte x 1.6923076923076923
struct DMA_LIST_F018B *memcpy_dma256::f018b
__constant struct DMA_LIST_F018B *memcpy_dma256::f018b#0 = (struct DMA_LIST_F018B *)memcpy_dma_command256+6 // f018b
unsigned int memcpy_dma256::num
__constant unsigned int memcpy_dma256::num#0 = (unsigned int)$18*$50 // num
void *memcpy_dma256::src
__constant void *memcpy_dma256::src#0 = (void *)DEFAULT_SCREEN+$50 // src
char memcpy_dma256::src_bank
__constant char memcpy_dma256::src_bank#0 = 0 // src_bank
char memcpy_dma256::src_mb
__constant char memcpy_dma256::src_mb#0 = 0 // src_mb
__constant char memcpy_dma_command256[] = { DMA_OPTION_SRC_MB, 0, DMA_OPTION_DEST_MB, 0, DMA_OPTION_FORMAT_F018B, DMA_OPTION_END, DMA_COMMAND_COPY, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
__loadstore volatile char memoryRemap::aVal // zp[1]:5 2.75
unsigned int memoryRemap::lowerPageOffset
char memoryRemap::remapBlocks
unsigned int memoryRemap::upperPageOffset
__loadstore volatile char memoryRemap::xVal // zp[1]:4 3.6666666666666665
__loadstore volatile char memoryRemap::yVal // zp[1]:3 5.5
__loadstore volatile char memoryRemap::zVal // zp[1]:2 11.0

zp[1]:5 [ memoryRemap::aVal ]
zp[1]:4 [ memoryRemap::xVal ]
zp[1]:3 [ memoryRemap::yVal ]
zp[1]:2 [ memoryRemap::zVal ]
reg byte x [ memcpy_dma256::dmaMode#0 ]


FINAL ASSEMBLER
Score: 159

  // File Comments
// MEGA65 DMA test using 256MB version
// Appendix J in https://mega.scryptos.com/sharefolder-link/MEGA/MEGA65+filehost/Docs/MEGA65-Book_draft.pdf
/// @file
/// Functions for using the F018 DMA for very fast copying or filling of memory
/// @file
/// MEGA65 Registers and Constants
/// @file
/// The MOS 6526 Complex Interface Adapter (CIA)
///
/// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="dma-test4.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  /// DMA command copy
  .const DMA_COMMAND_COPY = 0
  /// $00 = End of options
  .const DMA_OPTION_END = 0
  /// $0B = Use F018B list format
  .const DMA_OPTION_FORMAT_F018B = $a
  /// $80 $xx = Set MB of source address
  .const DMA_OPTION_SRC_MB = $80
  /// $81 $xx = Set MB of destination address
  .const DMA_OPTION_DEST_MB = $81
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
  .const OFFSET_STRUCT_F018_DMAGIC_ETRIG = 5
  /// DMAgic F018 Controller
  .label DMA = $d700
  /// Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
.segment Code
  // main
main: {
    // memoryRemap(0,0,0)
    // [1] call memoryRemap
    // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    jsr memoryRemap
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // memcpy_dma256(0,0, DEFAULT_SCREEN, 0,0, DEFAULT_SCREEN+80, 24*80)
    // [3] call memcpy_dma256
    // Move screen up using DMA
    jsr memcpy_dma256
    // main::@return
    // }
    // [4] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// void memoryRemap(char remapBlocks, unsigned int lowerPageOffset, unsigned int upperPageOffset)
memoryRemap: {
    .label aVal = 5
    .label xVal = 4
    .label yVal = 3
    .label zVal = 2
    // char aVal = BYTE0(lowerPageOffset)
    // [5] memoryRemap::aVal = 0 -- vbuz1=vbuc1 
    // lower blocks offset page low
    lda #0
    sta.z aVal
    // char xVal = (remapBlocks << 4)   | (BYTE1(lowerPageOffset) & 0xf)
    // [6] memoryRemap::xVal = 0 -- vbuz1=vbuc1 
    // lower blocks to map + lower blocks offset high nibble
    sta.z xVal
    // char yVal = BYTE0(upperPageOffset)
    // [7] memoryRemap::yVal = 0 -- vbuz1=vbuc1 
    // upper blocks offset page
    sta.z yVal
    // char zVal = (remapBlocks & 0xf0) | (BYTE1(upperPageOffset) & 0xf)
    // [8] memoryRemap::zVal = 0 -- vbuz1=vbuc1 
    // upper blocks to map + upper blocks offset page high nibble
    sta.z zVal
    // asm
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap::@return
    // }
    // [10] return 
    rts
}
  // memcpy_dma256
// Copy a memory block anywhere in the entire 256MB memory space using MEGA65 DMagic DMA
// Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination.
// - dest_mb The MB value for the destination (0-255)
// - dest_bank The 64KB bank for the destination (0-15)
// - dest The destination address (within the MB and bank)
// - src_mb The MB value for the source (0-255)
// - src_bank The 64KB bank for the source (0-15)
// - src The source address (within the MB and bank)
// - num The number of bytes to copy
// void memcpy_dma256(char dest_mb, char dest_bank, void *dest, char src_mb, char src_bank, void *src, unsigned int num)
memcpy_dma256: {
    .const dest_mb = 0
    .const dest_bank = 0
    .const src_mb = 0
    .const src_bank = 0
    .const num = $18*$50
    .label dest = DEFAULT_SCREEN
    .label src = DEFAULT_SCREEN+$50
    .label f018b = memcpy_dma_command256+6
    // char dmaMode = DMA->EN018B
    // [11] memcpy_dma256::dmaMode#0 = *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memcpy_dma_command256[1] = src_mb
    // [12] *(memcpy_dma_command256+1) = memcpy_dma256::src_mb#0 -- _deref_pbuc1=vbuc2 
    // Set up command
    lda #src_mb
    sta memcpy_dma_command256+1
    // memcpy_dma_command256[3] = dest_mb
    // [13] *(memcpy_dma_command256+3) = memcpy_dma256::dest_mb#0 -- _deref_pbuc1=vbuc2 
    lda #dest_mb
    sta memcpy_dma_command256+3
    // f018b->count = num
    // [14] *((unsigned int *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma256::num#0 -- _deref_pwuc1=vwuc2 
    lda #<num
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // f018b->src_bank = src_bank
    // [15] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma256::src_bank#0 -- _deref_pbuc1=vbuc2 
    lda #src_bank
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK
    // f018b->src = src
    // [16] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma256::src#0 -- _deref_qbuc1=pbuc2 
    lda #<src
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>src
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // f018b->dest_bank = dest_bank
    // [17] *((char *)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma256::dest_bank#0 -- _deref_pbuc1=vbuc2 
    lda #dest_bank
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
    // f018b->dest = dest
    // [18] *((char **)memcpy_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma256::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // DMA->EN018B = 1
    // [19] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // DMA->ADDRMB = 0
    // [20] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // DMA->ADDRBANK = 0
    // [21] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // DMA-> ADDRMSB = BYTE1(memcpy_dma_command256)
    // [22] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memcpy_dma_command256 -- _deref_pbuc1=vbuc2 
    lda #>memcpy_dma_command256
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // DMA-> ETRIG = BYTE0(memcpy_dma_command256)
    // [23] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memcpy_dma_command256 -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (with option lists)
    lda #<memcpy_dma_command256
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG
    // DMA->EN018B = dmaMode
    // [24] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma256::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memcpy_dma256::@return
    // }
    // [25] return 
    rts
}
  // File Data
.segment Data
  // DMA list entry with options for copying data in the 256MB memory space
  // Contains DMA options options for setting MB followed by DMA_LIST_F018B struct.
  memcpy_dma_command256: .byte DMA_OPTION_SRC_MB, 0, DMA_OPTION_DEST_MB, 0, DMA_OPTION_FORMAT_F018B, DMA_OPTION_END, DMA_COMMAND_COPY, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

