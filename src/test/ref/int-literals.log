Resolving typeid() (byte~) testSimpleTypes::$0 ← typeid  (byte) $c
Resolving typeid() (byte~) testSimpleTypes::$2 ← typeid  (byte) $c
Resolving typeid() (byte~) testSimpleTypes::$4 ← typeid  (signed byte) $c
Resolving typeid() (byte~) testSimpleTypes::$6 ← typeid  (signed byte) $c
Resolving typeid() (byte~) testSimpleTypes::$8 ← typeid  (word) $c
Resolving typeid() (byte~) testSimpleTypes::$10 ← typeid  (word) $c
Resolving typeid() (byte~) testSimpleTypes::$12 ← typeid  (word) $c
Resolving typeid() (byte~) testSimpleTypes::$14 ← typeid  (signed word) $c
Resolving typeid() (byte~) testSimpleTypes::$16 ← typeid  (signed word) $c
Resolving typeid() (byte~) testSimpleTypes::$18 ← typeid  (signed word) $c
Resolving typeid() (byte~) testSimpleTypes::$20 ← typeid  (dword) $c
Resolving typeid() (byte~) testSimpleTypes::$22 ← typeid  (dword) $c
Resolving typeid() (byte~) testSimpleTypes::$24 ← typeid  (signed dword) $c
Resolving typeid() (byte~) testSimpleTypes::$26 ← typeid  (signed dword) $c
Resolving typeid() (byte~) testSimpleTypes::$28 ← typeid  (signed dword) $c
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@6
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) assertType::@4

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) idx#0 ← (byte) 0
  to:@3

(void()) main()
main: scope:[main]  from @3
  (byte) idx#50 ← phi( @3/(byte) idx#48 )
  (byte*) main::s#0 ← (const byte*) SCREEN
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) idx#49 ← phi( main/(byte) idx#50 main::@2/(byte) idx#51 )
  (byte*) main::s#2 ← phi( main/(byte*) main::s#0 main::@2/(byte*) main::s#1 )
  (bool~) main::$1 ← (byte*) main::s#2 < (const byte*) SCREEN+(word) $3e8
  if((bool~) main::$1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  (byte) idx#51 ← phi( main::@1/(byte) idx#49 )
  (byte*) main::s#3 ← phi( main::@1/(byte*) main::s#2 )
  *((byte*) main::s#3) ← (byte) ' '
  (byte*) main::s#1 ← ++ (byte*) main::s#3
  to:main::@1
main::@3: scope:[main]  from main::@1
  (byte) idx#46 ← phi( main::@1/(byte) idx#49 )
  call testSimpleTypes 
  to:main::@7
main::@7: scope:[main]  from main::@3
  (byte) idx#23 ← phi( main::@3/(byte) idx#19 )
  (byte) idx#1 ← (byte) idx#23
  to:main::@return
main::@return: scope:[main]  from main::@7
  (byte) idx#24 ← phi( main::@7/(byte) idx#1 )
  (byte) idx#2 ← (byte) idx#24
  return 
  to:@return

(void()) testSimpleTypes()
testSimpleTypes: scope:[testSimpleTypes]  from main::@3
  (byte) idx#3 ← (byte) 0
  (byte~) testSimpleTypes::$0 ← (const byte) TYPEID_BYTE
  (byte) assertType::t1#0 ← (byte~) testSimpleTypes::$0
  (byte) assertType::t2#0 ← (const byte) TYPEID_BYTE
  call assertType 
  to:testSimpleTypes::@1
testSimpleTypes::@1: scope:[testSimpleTypes]  from testSimpleTypes
  (byte) idx#25 ← phi( testSimpleTypes/(byte) idx#21 )
  (byte) idx#4 ← (byte) idx#25
  (byte~) testSimpleTypes::$2 ← (const byte) TYPEID_BYTE
  (byte) assertType::t1#1 ← (byte~) testSimpleTypes::$2
  (byte) assertType::t2#1 ← (const byte) TYPEID_BYTE
  call assertType 
  to:testSimpleTypes::@2
testSimpleTypes::@2: scope:[testSimpleTypes]  from testSimpleTypes::@1
  (byte) idx#26 ← phi( testSimpleTypes::@1/(byte) idx#21 )
  (byte) idx#5 ← (byte) idx#26
  (byte~) testSimpleTypes::$4 ← (const byte) TYPEID_SIGNED_BYTE
  (byte) assertType::t1#2 ← (byte~) testSimpleTypes::$4
  (byte) assertType::t2#2 ← (const byte) TYPEID_SIGNED_BYTE
  call assertType 
  to:testSimpleTypes::@3
testSimpleTypes::@3: scope:[testSimpleTypes]  from testSimpleTypes::@2
  (byte) idx#27 ← phi( testSimpleTypes::@2/(byte) idx#21 )
  (byte) idx#6 ← (byte) idx#27
  (byte~) testSimpleTypes::$6 ← (const byte) TYPEID_SIGNED_BYTE
  (byte) assertType::t1#3 ← (byte~) testSimpleTypes::$6
  (byte) assertType::t2#3 ← (const byte) TYPEID_SIGNED_BYTE
  call assertType 
  to:testSimpleTypes::@4
testSimpleTypes::@4: scope:[testSimpleTypes]  from testSimpleTypes::@3
  (byte) idx#28 ← phi( testSimpleTypes::@3/(byte) idx#21 )
  (byte) idx#7 ← (byte) idx#28
  (byte~) testSimpleTypes::$8 ← (const byte) TYPEID_WORD
  (byte) assertType::t1#4 ← (byte~) testSimpleTypes::$8
  (byte) assertType::t2#4 ← (const byte) TYPEID_WORD
  call assertType 
  to:testSimpleTypes::@5
testSimpleTypes::@5: scope:[testSimpleTypes]  from testSimpleTypes::@4
  (byte) idx#29 ← phi( testSimpleTypes::@4/(byte) idx#21 )
  (byte) idx#8 ← (byte) idx#29
  (byte~) testSimpleTypes::$10 ← (const byte) TYPEID_WORD
  (byte) assertType::t1#5 ← (byte~) testSimpleTypes::$10
  (byte) assertType::t2#5 ← (const byte) TYPEID_WORD
  call assertType 
  to:testSimpleTypes::@6
testSimpleTypes::@6: scope:[testSimpleTypes]  from testSimpleTypes::@5
  (byte) idx#30 ← phi( testSimpleTypes::@5/(byte) idx#21 )
  (byte) idx#9 ← (byte) idx#30
  (byte~) testSimpleTypes::$12 ← (const byte) TYPEID_WORD
  (byte) assertType::t1#6 ← (byte~) testSimpleTypes::$12
  (byte) assertType::t2#6 ← (const byte) TYPEID_WORD
  call assertType 
  to:testSimpleTypes::@7
testSimpleTypes::@7: scope:[testSimpleTypes]  from testSimpleTypes::@6
  (byte) idx#31 ← phi( testSimpleTypes::@6/(byte) idx#21 )
  (byte) idx#10 ← (byte) idx#31
  (byte~) testSimpleTypes::$14 ← (const byte) TYPEID_SIGNED_WORD
  (byte) assertType::t1#7 ← (byte~) testSimpleTypes::$14
  (byte) assertType::t2#7 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:testSimpleTypes::@8
testSimpleTypes::@8: scope:[testSimpleTypes]  from testSimpleTypes::@7
  (byte) idx#32 ← phi( testSimpleTypes::@7/(byte) idx#21 )
  (byte) idx#11 ← (byte) idx#32
  (byte~) testSimpleTypes::$16 ← (const byte) TYPEID_SIGNED_WORD
  (byte) assertType::t1#8 ← (byte~) testSimpleTypes::$16
  (byte) assertType::t2#8 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:testSimpleTypes::@9
testSimpleTypes::@9: scope:[testSimpleTypes]  from testSimpleTypes::@8
  (byte) idx#33 ← phi( testSimpleTypes::@8/(byte) idx#21 )
  (byte) idx#12 ← (byte) idx#33
  (byte~) testSimpleTypes::$18 ← (const byte) TYPEID_SIGNED_WORD
  (byte) assertType::t1#9 ← (byte~) testSimpleTypes::$18
  (byte) assertType::t2#9 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:testSimpleTypes::@10
testSimpleTypes::@10: scope:[testSimpleTypes]  from testSimpleTypes::@9
  (byte) idx#34 ← phi( testSimpleTypes::@9/(byte) idx#21 )
  (byte) idx#13 ← (byte) idx#34
  (byte~) testSimpleTypes::$20 ← (const byte) TYPEID_DWORD
  (byte) assertType::t1#10 ← (byte~) testSimpleTypes::$20
  (byte) assertType::t2#10 ← (const byte) TYPEID_DWORD
  call assertType 
  to:testSimpleTypes::@11
testSimpleTypes::@11: scope:[testSimpleTypes]  from testSimpleTypes::@10
  (byte) idx#35 ← phi( testSimpleTypes::@10/(byte) idx#21 )
  (byte) idx#14 ← (byte) idx#35
  (byte~) testSimpleTypes::$22 ← (const byte) TYPEID_DWORD
  (byte) assertType::t1#11 ← (byte~) testSimpleTypes::$22
  (byte) assertType::t2#11 ← (const byte) TYPEID_DWORD
  call assertType 
  to:testSimpleTypes::@12
testSimpleTypes::@12: scope:[testSimpleTypes]  from testSimpleTypes::@11
  (byte) idx#36 ← phi( testSimpleTypes::@11/(byte) idx#21 )
  (byte) idx#15 ← (byte) idx#36
  (byte~) testSimpleTypes::$24 ← (const byte) TYPEID_SIGNED_DWORD
  (byte) assertType::t1#12 ← (byte~) testSimpleTypes::$24
  (byte) assertType::t2#12 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:testSimpleTypes::@13
testSimpleTypes::@13: scope:[testSimpleTypes]  from testSimpleTypes::@12
  (byte) idx#37 ← phi( testSimpleTypes::@12/(byte) idx#21 )
  (byte) idx#16 ← (byte) idx#37
  (byte~) testSimpleTypes::$26 ← (const byte) TYPEID_SIGNED_DWORD
  (byte) assertType::t1#13 ← (byte~) testSimpleTypes::$26
  (byte) assertType::t2#13 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:testSimpleTypes::@14
testSimpleTypes::@14: scope:[testSimpleTypes]  from testSimpleTypes::@13
  (byte) idx#38 ← phi( testSimpleTypes::@13/(byte) idx#21 )
  (byte) idx#17 ← (byte) idx#38
  (byte~) testSimpleTypes::$28 ← (const byte) TYPEID_SIGNED_DWORD
  (byte) assertType::t1#14 ← (byte~) testSimpleTypes::$28
  (byte) assertType::t2#14 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:testSimpleTypes::@15
testSimpleTypes::@15: scope:[testSimpleTypes]  from testSimpleTypes::@14
  (byte) idx#39 ← phi( testSimpleTypes::@14/(byte) idx#21 )
  (byte) idx#18 ← (byte) idx#39
  to:testSimpleTypes::@return
testSimpleTypes::@return: scope:[testSimpleTypes]  from testSimpleTypes::@15
  (byte) idx#40 ← phi( testSimpleTypes::@15/(byte) idx#18 )
  (byte) idx#19 ← (byte) idx#40
  return 
  to:@return

(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
assertType: scope:[assertType]  from testSimpleTypes testSimpleTypes::@1 testSimpleTypes::@10 testSimpleTypes::@11 testSimpleTypes::@12 testSimpleTypes::@13 testSimpleTypes::@14 testSimpleTypes::@2 testSimpleTypes::@3 testSimpleTypes::@4 testSimpleTypes::@5 testSimpleTypes::@6 testSimpleTypes::@7 testSimpleTypes::@8 testSimpleTypes::@9
  (byte) idx#47 ← phi( testSimpleTypes/(byte) idx#3 testSimpleTypes::@1/(byte) idx#4 testSimpleTypes::@10/(byte) idx#13 testSimpleTypes::@11/(byte) idx#14 testSimpleTypes::@12/(byte) idx#15 testSimpleTypes::@13/(byte) idx#16 testSimpleTypes::@14/(byte) idx#17 testSimpleTypes::@2/(byte) idx#5 testSimpleTypes::@3/(byte) idx#6 testSimpleTypes::@4/(byte) idx#7 testSimpleTypes::@5/(byte) idx#8 testSimpleTypes::@6/(byte) idx#9 testSimpleTypes::@7/(byte) idx#10 testSimpleTypes::@8/(byte) idx#11 testSimpleTypes::@9/(byte) idx#12 )
  (byte) assertType::t2#15 ← phi( testSimpleTypes/(byte) assertType::t2#0 testSimpleTypes::@1/(byte) assertType::t2#1 testSimpleTypes::@10/(byte) assertType::t2#10 testSimpleTypes::@11/(byte) assertType::t2#11 testSimpleTypes::@12/(byte) assertType::t2#12 testSimpleTypes::@13/(byte) assertType::t2#13 testSimpleTypes::@14/(byte) assertType::t2#14 testSimpleTypes::@2/(byte) assertType::t2#2 testSimpleTypes::@3/(byte) assertType::t2#3 testSimpleTypes::@4/(byte) assertType::t2#4 testSimpleTypes::@5/(byte) assertType::t2#5 testSimpleTypes::@6/(byte) assertType::t2#6 testSimpleTypes::@7/(byte) assertType::t2#7 testSimpleTypes::@8/(byte) assertType::t2#8 testSimpleTypes::@9/(byte) assertType::t2#9 )
  (byte) assertType::t1#15 ← phi( testSimpleTypes/(byte) assertType::t1#0 testSimpleTypes::@1/(byte) assertType::t1#1 testSimpleTypes::@10/(byte) assertType::t1#10 testSimpleTypes::@11/(byte) assertType::t1#11 testSimpleTypes::@12/(byte) assertType::t1#12 testSimpleTypes::@13/(byte) assertType::t1#13 testSimpleTypes::@14/(byte) assertType::t1#14 testSimpleTypes::@2/(byte) assertType::t1#2 testSimpleTypes::@3/(byte) assertType::t1#3 testSimpleTypes::@4/(byte) assertType::t1#4 testSimpleTypes::@5/(byte) assertType::t1#5 testSimpleTypes::@6/(byte) assertType::t1#6 testSimpleTypes::@7/(byte) assertType::t1#7 testSimpleTypes::@8/(byte) assertType::t1#8 testSimpleTypes::@9/(byte) assertType::t1#9 )
  (bool~) assertType::$0 ← (byte) assertType::t1#15 == (byte) assertType::t2#15
  if((bool~) assertType::$0) goto assertType::@1
  to:assertType::@3
assertType::@1: scope:[assertType]  from assertType
  (byte) assertType::t1#17 ← phi( assertType/(byte) assertType::t1#15 )
  (byte) idx#41 ← phi( assertType/(byte) idx#47 )
  *((const byte*) COLS + (byte) idx#41) ← (const byte) GREEN
  to:assertType::@2
assertType::@3: scope:[assertType]  from assertType
  (byte) assertType::t1#18 ← phi( assertType/(byte) assertType::t1#15 )
  (byte) idx#42 ← phi( assertType/(byte) idx#47 )
  *((const byte*) COLS + (byte) idx#42) ← (const byte) RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  (byte) idx#43 ← phi( assertType::@1/(byte) idx#41 assertType::@3/(byte) idx#42 )
  (byte) assertType::t1#16 ← phi( assertType::@1/(byte) assertType::t1#17 assertType::@3/(byte) assertType::t1#18 )
  *((const byte*) SCREEN + (byte) idx#43) ← (byte) assertType::t1#16
  (byte) idx#20 ← ++ (byte) idx#43
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  (byte) idx#44 ← phi( assertType::@2/(byte) idx#20 )
  (byte) idx#21 ← (byte) idx#44
  return 
  to:@return
@3: scope:[]  from @begin
  (byte) idx#48 ← phi( @begin/(byte) idx#0 )
  call main 
  to:@4
@4: scope:[]  from @3
  (byte) idx#45 ← phi( @3/(byte) idx#2 )
  (byte) idx#22 ← (byte) idx#45
  to:@end
@end: scope:[]  from @4

SYMBOL TABLE SSA
(label) @3
(label) @4
(label) @begin
(label) @end
(const byte*) COLS = (byte*)(word) $d800
(const byte) GREEN = (byte) 5
(const byte) RED = (byte) 2
(const byte*) SCREEN = (byte*)(word) $400
(const byte) TYPEID_BYTE = (number) 1
(const byte) TYPEID_DWORD = (number) 5
(const byte) TYPEID_SIGNED_BYTE = (number) 2
(const byte) TYPEID_SIGNED_DWORD = (number) 6
(const byte) TYPEID_SIGNED_WORD = (number) 4
(const byte) TYPEID_WORD = (number) 3
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(bool~) assertType::$0
(label) assertType::@1
(label) assertType::@2
(label) assertType::@3
(label) assertType::@return
(byte) assertType::t1
(byte) assertType::t1#0
(byte) assertType::t1#1
(byte) assertType::t1#10
(byte) assertType::t1#11
(byte) assertType::t1#12
(byte) assertType::t1#13
(byte) assertType::t1#14
(byte) assertType::t1#15
(byte) assertType::t1#16
(byte) assertType::t1#17
(byte) assertType::t1#18
(byte) assertType::t1#2
(byte) assertType::t1#3
(byte) assertType::t1#4
(byte) assertType::t1#5
(byte) assertType::t1#6
(byte) assertType::t1#7
(byte) assertType::t1#8
(byte) assertType::t1#9
(byte) assertType::t2
(byte) assertType::t2#0
(byte) assertType::t2#1
(byte) assertType::t2#10
(byte) assertType::t2#11
(byte) assertType::t2#12
(byte) assertType::t2#13
(byte) assertType::t2#14
(byte) assertType::t2#15
(byte) assertType::t2#2
(byte) assertType::t2#3
(byte) assertType::t2#4
(byte) assertType::t2#5
(byte) assertType::t2#6
(byte) assertType::t2#7
(byte) assertType::t2#8
(byte) assertType::t2#9
(byte) idx
(byte) idx#0
(byte) idx#1
(byte) idx#10
(byte) idx#11
(byte) idx#12
(byte) idx#13
(byte) idx#14
(byte) idx#15
(byte) idx#16
(byte) idx#17
(byte) idx#18
(byte) idx#19
(byte) idx#2
(byte) idx#20
(byte) idx#21
(byte) idx#22
(byte) idx#23
(byte) idx#24
(byte) idx#25
(byte) idx#26
(byte) idx#27
(byte) idx#28
(byte) idx#29
(byte) idx#3
(byte) idx#30
(byte) idx#31
(byte) idx#32
(byte) idx#33
(byte) idx#34
(byte) idx#35
(byte) idx#36
(byte) idx#37
(byte) idx#38
(byte) idx#39
(byte) idx#4
(byte) idx#40
(byte) idx#41
(byte) idx#42
(byte) idx#43
(byte) idx#44
(byte) idx#45
(byte) idx#46
(byte) idx#47
(byte) idx#48
(byte) idx#49
(byte) idx#5
(byte) idx#50
(byte) idx#51
(byte) idx#6
(byte) idx#7
(byte) idx#8
(byte) idx#9
(void()) main()
(bool~) main::$1
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@7
(label) main::@return
(byte*) main::s
(byte*) main::s#0
(byte*) main::s#1
(byte*) main::s#2
(byte*) main::s#3
(void()) testSimpleTypes()
(byte~) testSimpleTypes::$0
(byte~) testSimpleTypes::$10
(byte~) testSimpleTypes::$12
(byte~) testSimpleTypes::$14
(byte~) testSimpleTypes::$16
(byte~) testSimpleTypes::$18
(byte~) testSimpleTypes::$2
(byte~) testSimpleTypes::$20
(byte~) testSimpleTypes::$22
(byte~) testSimpleTypes::$24
(byte~) testSimpleTypes::$26
(byte~) testSimpleTypes::$28
(byte~) testSimpleTypes::$4
(byte~) testSimpleTypes::$6
(byte~) testSimpleTypes::$8
(label) testSimpleTypes::@1
(label) testSimpleTypes::@10
(label) testSimpleTypes::@11
(label) testSimpleTypes::@12
(label) testSimpleTypes::@13
(label) testSimpleTypes::@14
(label) testSimpleTypes::@15
(label) testSimpleTypes::@2
(label) testSimpleTypes::@3
(label) testSimpleTypes::@4
(label) testSimpleTypes::@5
(label) testSimpleTypes::@6
(label) testSimpleTypes::@7
(label) testSimpleTypes::@8
(label) testSimpleTypes::@9
(label) testSimpleTypes::@return

Alias (byte*) main::s#2 = (byte*) main::s#3 
Alias (byte) idx#46 = (byte) idx#51 (byte) idx#49 
Alias (byte) idx#1 = (byte) idx#23 (byte) idx#24 (byte) idx#2 
Alias (byte) assertType::t1#0 = (byte~) testSimpleTypes::$0 
Alias (byte) idx#25 = (byte) idx#4 
Alias (byte) assertType::t1#1 = (byte~) testSimpleTypes::$2 
Alias (byte) idx#26 = (byte) idx#5 
Alias (byte) assertType::t1#2 = (byte~) testSimpleTypes::$4 
Alias (byte) idx#27 = (byte) idx#6 
Alias (byte) assertType::t1#3 = (byte~) testSimpleTypes::$6 
Alias (byte) idx#28 = (byte) idx#7 
Alias (byte) assertType::t1#4 = (byte~) testSimpleTypes::$8 
Alias (byte) idx#29 = (byte) idx#8 
Alias (byte) assertType::t1#5 = (byte~) testSimpleTypes::$10 
Alias (byte) idx#30 = (byte) idx#9 
Alias (byte) assertType::t1#6 = (byte~) testSimpleTypes::$12 
Alias (byte) idx#10 = (byte) idx#31 
Alias (byte) assertType::t1#7 = (byte~) testSimpleTypes::$14 
Alias (byte) idx#11 = (byte) idx#32 
Alias (byte) assertType::t1#8 = (byte~) testSimpleTypes::$16 
Alias (byte) idx#12 = (byte) idx#33 
Alias (byte) assertType::t1#9 = (byte~) testSimpleTypes::$18 
Alias (byte) idx#13 = (byte) idx#34 
Alias (byte) assertType::t1#10 = (byte~) testSimpleTypes::$20 
Alias (byte) idx#14 = (byte) idx#35 
Alias (byte) assertType::t1#11 = (byte~) testSimpleTypes::$22 
Alias (byte) idx#15 = (byte) idx#36 
Alias (byte) assertType::t1#12 = (byte~) testSimpleTypes::$24 
Alias (byte) idx#16 = (byte) idx#37 
Alias (byte) assertType::t1#13 = (byte~) testSimpleTypes::$26 
Alias (byte) idx#17 = (byte) idx#38 
Alias (byte) assertType::t1#14 = (byte~) testSimpleTypes::$28 
Alias (byte) idx#18 = (byte) idx#39 (byte) idx#40 (byte) idx#19 
Alias (byte) idx#41 = (byte) idx#47 (byte) idx#42 
Alias (byte) assertType::t1#15 = (byte) assertType::t1#17 (byte) assertType::t1#18 
Alias (byte) idx#20 = (byte) idx#44 (byte) idx#21 
Alias (byte) idx#0 = (byte) idx#48 
Alias (byte) idx#22 = (byte) idx#45 
Successful SSA optimization Pass2AliasElimination
Alias (byte) assertType::t1#15 = (byte) assertType::t1#16 
Alias (byte) idx#41 = (byte) idx#43 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) idx#50 (byte) idx#0
Identical Phi Values (byte) idx#46 (byte) idx#50
Identical Phi Values (byte) idx#1 (byte) idx#18
Identical Phi Values (byte) idx#25 (byte) idx#20
Identical Phi Values (byte) idx#26 (byte) idx#20
Identical Phi Values (byte) idx#27 (byte) idx#20
Identical Phi Values (byte) idx#28 (byte) idx#20
Identical Phi Values (byte) idx#29 (byte) idx#20
Identical Phi Values (byte) idx#30 (byte) idx#20
Identical Phi Values (byte) idx#10 (byte) idx#20
Identical Phi Values (byte) idx#11 (byte) idx#20
Identical Phi Values (byte) idx#12 (byte) idx#20
Identical Phi Values (byte) idx#13 (byte) idx#20
Identical Phi Values (byte) idx#14 (byte) idx#20
Identical Phi Values (byte) idx#15 (byte) idx#20
Identical Phi Values (byte) idx#16 (byte) idx#20
Identical Phi Values (byte) idx#17 (byte) idx#20
Identical Phi Values (byte) idx#18 (byte) idx#20
Identical Phi Values (byte) idx#22 (byte) idx#1
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$1 [5] if((byte*) main::s#2<(const byte*) SCREEN+(word) $3e8) goto main::@2
Simple Condition (bool~) assertType::$0 [75] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte) idx#0 = 0
Constant (const byte*) main::s#0 = SCREEN
Constant (const byte) idx#3 = 0
Constant (const byte) assertType::t1#0 = TYPEID_BYTE
Constant (const byte) assertType::t2#0 = TYPEID_BYTE
Constant (const byte) assertType::t1#1 = TYPEID_BYTE
Constant (const byte) assertType::t2#1 = TYPEID_BYTE
Constant (const byte) assertType::t1#2 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t2#2 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t1#3 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t2#3 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t1#4 = TYPEID_WORD
Constant (const byte) assertType::t2#4 = TYPEID_WORD
Constant (const byte) assertType::t1#5 = TYPEID_WORD
Constant (const byte) assertType::t2#5 = TYPEID_WORD
Constant (const byte) assertType::t1#6 = TYPEID_WORD
Constant (const byte) assertType::t2#6 = TYPEID_WORD
Constant (const byte) assertType::t1#7 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#7 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t1#8 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#8 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t1#9 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#9 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t1#10 = TYPEID_DWORD
Constant (const byte) assertType::t2#10 = TYPEID_DWORD
Constant (const byte) assertType::t1#11 = TYPEID_DWORD
Constant (const byte) assertType::t2#11 = TYPEID_DWORD
Constant (const byte) assertType::t1#12 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#12 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t1#13 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#13 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t1#14 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#14 = TYPEID_SIGNED_DWORD
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant (const byte) idx#0
Successful SSA optimization PassNEliminateUnusedVars
Inlining constant with var siblings (const byte*) main::s#0
Inlining constant with var siblings (const byte) assertType::t1#0
Inlining constant with var siblings (const byte) assertType::t2#0
Inlining constant with var siblings (const byte) assertType::t1#1
Inlining constant with var siblings (const byte) assertType::t2#1
Inlining constant with var siblings (const byte) assertType::t1#2
Inlining constant with var siblings (const byte) assertType::t2#2
Inlining constant with var siblings (const byte) assertType::t1#3
Inlining constant with var siblings (const byte) assertType::t2#3
Inlining constant with var siblings (const byte) assertType::t1#4
Inlining constant with var siblings (const byte) assertType::t2#4
Inlining constant with var siblings (const byte) assertType::t1#5
Inlining constant with var siblings (const byte) assertType::t2#5
Inlining constant with var siblings (const byte) assertType::t1#6
Inlining constant with var siblings (const byte) assertType::t2#6
Inlining constant with var siblings (const byte) assertType::t1#7
Inlining constant with var siblings (const byte) assertType::t2#7
Inlining constant with var siblings (const byte) assertType::t1#8
Inlining constant with var siblings (const byte) assertType::t2#8
Inlining constant with var siblings (const byte) assertType::t1#9
Inlining constant with var siblings (const byte) assertType::t2#9
Inlining constant with var siblings (const byte) assertType::t1#10
Inlining constant with var siblings (const byte) assertType::t2#10
Inlining constant with var siblings (const byte) assertType::t1#11
Inlining constant with var siblings (const byte) assertType::t2#11
Inlining constant with var siblings (const byte) assertType::t1#12
Inlining constant with var siblings (const byte) assertType::t2#12
Inlining constant with var siblings (const byte) assertType::t1#13
Inlining constant with var siblings (const byte) assertType::t2#13
Inlining constant with var siblings (const byte) assertType::t1#14
Inlining constant with var siblings (const byte) assertType::t2#14
Inlining constant with var siblings (const byte) idx#3
Constant inlined assertType::t2#5 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#6 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#6 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#7 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#7 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t1#8 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#8 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t1#9 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#9 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#11 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#10 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#13 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#12 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#14 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#0 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#0 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#1 = (const byte) TYPEID_BYTE
Constant inlined idx#3 = (byte) 0
Constant inlined assertType::t2#1 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#2 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t2#2 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t1#3 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t2#3 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t1#4 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#4 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#5 = (const byte) TYPEID_WORD
Constant inlined main::s#0 = (const byte*) SCREEN
Constant inlined assertType::t1#10 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#12 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#11 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#14 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#13 = (const byte) TYPEID_SIGNED_DWORD
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @3
Adding NOP phi() at start of @4
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of testSimpleTypes
Adding NOP phi() at start of testSimpleTypes::@15
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to testSimpleTypes:9 
Calls in [testSimpleTypes] to assertType:16 assertType:18 assertType:20 assertType:22 assertType:24 assertType:26 assertType:28 assertType:30 assertType:32 assertType:34 assertType:36 assertType:38 assertType:40 assertType:42 assertType:44 

Created 4 initial phi equivalence classes
Coalesced [14] main::s#4 ← main::s#1
Coalesced [17] idx#52 ← idx#20
Coalesced (already) [19] idx#58 ← idx#20
Coalesced (already) [21] idx#59 ← idx#20
Coalesced (already) [23] idx#60 ← idx#20
Coalesced (already) [25] idx#61 ← idx#20
Coalesced (already) [27] idx#62 ← idx#20
Coalesced (already) [29] idx#63 ← idx#20
Coalesced (already) [31] idx#64 ← idx#20
Coalesced (already) [33] idx#65 ← idx#20
Coalesced (already) [35] idx#53 ← idx#20
Coalesced (already) [37] idx#54 ← idx#20
Coalesced (already) [39] idx#55 ← idx#20
Coalesced (already) [41] idx#56 ← idx#20
Coalesced (already) [43] idx#57 ← idx#20
Coalesced down to 4 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) main::@7
Culled Empty Block (label) testSimpleTypes::@15
Renumbering block @3 to @1
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of testSimpleTypes
Adding NOP phi() at start of testSimpleTypes::@1
Adding NOP phi() at start of testSimpleTypes::@2
Adding NOP phi() at start of testSimpleTypes::@3
Adding NOP phi() at start of testSimpleTypes::@4
Adding NOP phi() at start of testSimpleTypes::@5
Adding NOP phi() at start of testSimpleTypes::@6
Adding NOP phi() at start of testSimpleTypes::@7
Adding NOP phi() at start of testSimpleTypes::@8
Adding NOP phi() at start of testSimpleTypes::@9
Adding NOP phi() at start of testSimpleTypes::@10
Adding NOP phi() at start of testSimpleTypes::@11
Adding NOP phi() at start of testSimpleTypes::@12
Adding NOP phi() at start of testSimpleTypes::@13
Adding NOP phi() at start of testSimpleTypes::@14

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [5] (byte*) main::s#2 ← phi( main/(const byte*) SCREEN main::@2/(byte*) main::s#1 )
  [6] if((byte*) main::s#2<(const byte*) SCREEN+(word) $3e8) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [7] phi()
  [8] call testSimpleTypes 
  to:main::@return
main::@return: scope:[main]  from main::@3
  [9] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [10] *((byte*) main::s#2) ← (byte) ' '
  [11] (byte*) main::s#1 ← ++ (byte*) main::s#2
  to:main::@1

(void()) testSimpleTypes()
testSimpleTypes: scope:[testSimpleTypes]  from main::@3
  [12] phi()
  [13] call assertType 
  to:testSimpleTypes::@1
testSimpleTypes::@1: scope:[testSimpleTypes]  from testSimpleTypes
  [14] phi()
  [15] call assertType 
  to:testSimpleTypes::@2
testSimpleTypes::@2: scope:[testSimpleTypes]  from testSimpleTypes::@1
  [16] phi()
  [17] call assertType 
  to:testSimpleTypes::@3
testSimpleTypes::@3: scope:[testSimpleTypes]  from testSimpleTypes::@2
  [18] phi()
  [19] call assertType 
  to:testSimpleTypes::@4
testSimpleTypes::@4: scope:[testSimpleTypes]  from testSimpleTypes::@3
  [20] phi()
  [21] call assertType 
  to:testSimpleTypes::@5
testSimpleTypes::@5: scope:[testSimpleTypes]  from testSimpleTypes::@4
  [22] phi()
  [23] call assertType 
  to:testSimpleTypes::@6
testSimpleTypes::@6: scope:[testSimpleTypes]  from testSimpleTypes::@5
  [24] phi()
  [25] call assertType 
  to:testSimpleTypes::@7
testSimpleTypes::@7: scope:[testSimpleTypes]  from testSimpleTypes::@6
  [26] phi()
  [27] call assertType 
  to:testSimpleTypes::@8
testSimpleTypes::@8: scope:[testSimpleTypes]  from testSimpleTypes::@7
  [28] phi()
  [29] call assertType 
  to:testSimpleTypes::@9
testSimpleTypes::@9: scope:[testSimpleTypes]  from testSimpleTypes::@8
  [30] phi()
  [31] call assertType 
  to:testSimpleTypes::@10
testSimpleTypes::@10: scope:[testSimpleTypes]  from testSimpleTypes::@9
  [32] phi()
  [33] call assertType 
  to:testSimpleTypes::@11
testSimpleTypes::@11: scope:[testSimpleTypes]  from testSimpleTypes::@10
  [34] phi()
  [35] call assertType 
  to:testSimpleTypes::@12
testSimpleTypes::@12: scope:[testSimpleTypes]  from testSimpleTypes::@11
  [36] phi()
  [37] call assertType 
  to:testSimpleTypes::@13
testSimpleTypes::@13: scope:[testSimpleTypes]  from testSimpleTypes::@12
  [38] phi()
  [39] call assertType 
  to:testSimpleTypes::@14
testSimpleTypes::@14: scope:[testSimpleTypes]  from testSimpleTypes::@13
  [40] phi()
  [41] call assertType 
  to:testSimpleTypes::@return
testSimpleTypes::@return: scope:[testSimpleTypes]  from testSimpleTypes::@14
  [42] return 
  to:@return

(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
assertType: scope:[assertType]  from testSimpleTypes testSimpleTypes::@1 testSimpleTypes::@10 testSimpleTypes::@11 testSimpleTypes::@12 testSimpleTypes::@13 testSimpleTypes::@14 testSimpleTypes::@2 testSimpleTypes::@3 testSimpleTypes::@4 testSimpleTypes::@5 testSimpleTypes::@6 testSimpleTypes::@7 testSimpleTypes::@8 testSimpleTypes::@9
  [43] (byte) idx#41 ← phi( testSimpleTypes/(byte) 0 testSimpleTypes::@1/(byte) idx#20 testSimpleTypes::@10/(byte) idx#20 testSimpleTypes::@11/(byte) idx#20 testSimpleTypes::@12/(byte) idx#20 testSimpleTypes::@13/(byte) idx#20 testSimpleTypes::@14/(byte) idx#20 testSimpleTypes::@2/(byte) idx#20 testSimpleTypes::@3/(byte) idx#20 testSimpleTypes::@4/(byte) idx#20 testSimpleTypes::@5/(byte) idx#20 testSimpleTypes::@6/(byte) idx#20 testSimpleTypes::@7/(byte) idx#20 testSimpleTypes::@8/(byte) idx#20 testSimpleTypes::@9/(byte) idx#20 )
  [43] (byte) assertType::t2#15 ← phi( testSimpleTypes/(const byte) TYPEID_BYTE testSimpleTypes::@1/(const byte) TYPEID_BYTE testSimpleTypes::@10/(const byte) TYPEID_DWORD testSimpleTypes::@11/(const byte) TYPEID_DWORD testSimpleTypes::@12/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@13/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@14/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@2/(const byte) TYPEID_SIGNED_BYTE testSimpleTypes::@3/(const byte) TYPEID_SIGNED_BYTE testSimpleTypes::@4/(const byte) TYPEID_WORD testSimpleTypes::@5/(const byte) TYPEID_WORD testSimpleTypes::@6/(const byte) TYPEID_WORD testSimpleTypes::@7/(const byte) TYPEID_SIGNED_WORD testSimpleTypes::@8/(const byte) TYPEID_SIGNED_WORD testSimpleTypes::@9/(const byte) TYPEID_SIGNED_WORD )
  [43] (byte) assertType::t1#15 ← phi( testSimpleTypes/(const byte) TYPEID_BYTE testSimpleTypes::@1/(const byte) TYPEID_BYTE testSimpleTypes::@10/(const byte) TYPEID_DWORD testSimpleTypes::@11/(const byte) TYPEID_DWORD testSimpleTypes::@12/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@13/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@14/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@2/(const byte) TYPEID_SIGNED_BYTE testSimpleTypes::@3/(const byte) TYPEID_SIGNED_BYTE testSimpleTypes::@4/(const byte) TYPEID_WORD testSimpleTypes::@5/(const byte) TYPEID_WORD testSimpleTypes::@6/(const byte) TYPEID_WORD testSimpleTypes::@7/(const byte) TYPEID_SIGNED_WORD testSimpleTypes::@8/(const byte) TYPEID_SIGNED_WORD testSimpleTypes::@9/(const byte) TYPEID_SIGNED_WORD )
  [44] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1
  to:assertType::@3
assertType::@3: scope:[assertType]  from assertType
  [45] *((const byte*) COLS + (byte) idx#41) ← (const byte) RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  [46] *((const byte*) SCREEN + (byte) idx#41) ← (byte) assertType::t1#15
  [47] (byte) idx#20 ← ++ (byte) idx#41
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  [48] return 
  to:@return
assertType::@1: scope:[assertType]  from assertType
  [49] *((const byte*) COLS + (byte) idx#41) ← (const byte) GREEN
  to:assertType::@2


VARIABLE REGISTER WEIGHTS
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(byte) assertType::t1
(byte) assertType::t1#15 1.0
(byte) assertType::t2
(byte) assertType::t2#15 2.0
(byte) idx
(byte) idx#20 0.9999999999999999
(byte) idx#41 7.200000000000002
(void()) main()
(byte*) main::s
(byte*) main::s#1 22.0
(byte*) main::s#2 14.666666666666666
(void()) testSimpleTypes()

Initial phi equivalence classes
[ main::s#2 main::s#1 ]
[ assertType::t1#15 ]
[ assertType::t2#15 ]
[ idx#41 idx#20 ]
Complete equivalence classes
[ main::s#2 main::s#1 ]
[ assertType::t1#15 ]
[ assertType::t2#15 ]
[ idx#41 idx#20 ]
Allocated zp[2]:2 [ main::s#2 main::s#1 ]
Allocated zp[1]:4 [ assertType::t1#15 ]
Allocated zp[1]:5 [ assertType::t2#15 ]
Allocated zp[1]:6 [ idx#41 idx#20 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Tests different integer literal types
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .const RED = 2
  .const GREEN = 5
  .label SCREEN = $400
  .label COLS = $d800
  .const TYPEID_BYTE = 1
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_WORD = 3
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_DWORD = 5
  .const TYPEID_SIGNED_DWORD = 6
  .label idx = 6
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label s = 2
    // [5] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [5] phi (byte*) main::s#2 = (const byte*) SCREEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z s
    lda #>SCREEN
    sta.z s+1
    jmp __b1
    // main::@1
  __b1:
    // [6] if((byte*) main::s#2<(const byte*) SCREEN+(word) $3e8) goto main::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z s+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z s
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // [7] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [8] call testSimpleTypes 
    // [12] phi from main::@3 to testSimpleTypes [phi:main::@3->testSimpleTypes]
  testSimpleTypes_from___b3:
    jsr testSimpleTypes
    jmp __breturn
    // main::@return
  __breturn:
    // [9] return 
    rts
    // main::@2
  __b2:
    // [10] *((byte*) main::s#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
    // [11] (byte*) main::s#1 ← ++ (byte*) main::s#2 -- pbuz1=_inc_pbuz1 
    inc.z s
    bne !+
    inc.z s+1
  !:
    // [5] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [5] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // testSimpleTypes
testSimpleTypes: {
    // [13] call assertType 
    // [43] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
  assertType_from_testSimpleTypes:
    // [43] phi (byte) idx#41 = (byte) 0 [phi:testSimpleTypes->assertType#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t1
    jsr assertType
    // [14] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
  __b1_from_testSimpleTypes:
    jmp __b1
    // testSimpleTypes::@1
  __b1:
    // [15] call assertType 
    // [43] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
  assertType_from___b1:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t1
    jsr assertType
    // [16] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
  __b2_from___b1:
    jmp __b2
    // testSimpleTypes::@2
  __b2:
    // [17] call assertType 
    // [43] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
  assertType_from___b2:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t1
    jsr assertType
    // [18] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
  __b3_from___b2:
    jmp __b3
    // testSimpleTypes::@3
  __b3:
    // [19] call assertType 
    // [43] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
  assertType_from___b3:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t1
    jsr assertType
    // [20] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
  __b4_from___b3:
    jmp __b4
    // testSimpleTypes::@4
  __b4:
    // [21] call assertType 
    // [43] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
  assertType_from___b4:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [22] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
  __b5_from___b4:
    jmp __b5
    // testSimpleTypes::@5
  __b5:
    // [23] call assertType 
    // [43] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
  assertType_from___b5:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [24] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
  __b6_from___b5:
    jmp __b6
    // testSimpleTypes::@6
  __b6:
    // [25] call assertType 
    // [43] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
  assertType_from___b6:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t1
    jsr assertType
    // [26] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
  __b7_from___b6:
    jmp __b7
    // testSimpleTypes::@7
  __b7:
    // [27] call assertType 
    // [43] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
  assertType_from___b7:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t1
    jsr assertType
    // [28] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
  __b8_from___b7:
    jmp __b8
    // testSimpleTypes::@8
  __b8:
    // [29] call assertType 
    // [43] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
  assertType_from___b8:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t1
    jsr assertType
    // [30] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
  __b9_from___b8:
    jmp __b9
    // testSimpleTypes::@9
  __b9:
    // [31] call assertType 
    // [43] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
  assertType_from___b9:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t1
    jsr assertType
    // [32] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
  __b10_from___b9:
    jmp __b10
    // testSimpleTypes::@10
  __b10:
    // [33] call assertType 
    // [43] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
  assertType_from___b10:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [34] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
  __b11_from___b10:
    jmp __b11
    // testSimpleTypes::@11
  __b11:
    // [35] call assertType 
    // [43] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
  assertType_from___b11:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t1
    jsr assertType
    // [36] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
  __b12_from___b11:
    jmp __b12
    // testSimpleTypes::@12
  __b12:
    // [37] call assertType 
    // [43] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
  assertType_from___b12:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t1
    jsr assertType
    // [38] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
  __b13_from___b12:
    jmp __b13
    // testSimpleTypes::@13
  __b13:
    // [39] call assertType 
    // [43] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
  assertType_from___b13:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t1
    jsr assertType
    // [40] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
  __b14_from___b13:
    jmp __b14
    // testSimpleTypes::@14
  __b14:
    // [41] call assertType 
    // [43] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
  assertType_from___b14:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t1
    jsr assertType
    jmp __breturn
    // testSimpleTypes::@return
  __breturn:
    // [42] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte zp(4) t1, byte zp(5) t2)
assertType: {
    .label t1 = 4
    .label t2 = 5
    // [44] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1 -- vbuz1_eq_vbuz2_then_la1 
    lda.z t1
    cmp.z t2
    beq __b1
    jmp __b3
    // assertType::@3
  __b3:
    // [45] *((const byte*) COLS + (byte) idx#41) ← (const byte) RED -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #RED
    ldy.z idx
    sta COLS,y
    jmp __b2
    // assertType::@2
  __b2:
    // [46] *((const byte*) SCREEN + (byte) idx#41) ← (byte) assertType::t1#15 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z t1
    ldy.z idx
    sta SCREEN,y
    // [47] (byte) idx#20 ← ++ (byte) idx#41 -- vbuz1=_inc_vbuz1 
    inc.z idx
    jmp __breturn
    // assertType::@return
  __breturn:
    // [48] return 
    rts
    // assertType::@1
  __b1:
    // [49] *((const byte*) COLS + (byte) idx#41) ← (const byte) GREEN -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy.z idx
    sta COLS,y
    jmp __b2
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] if((byte*) main::s#2<(const byte*) SCREEN+(word) $3e8) goto main::@2 [ main::s#2 ] ( main:2 [ main::s#2 ] ) always clobbers reg byte a 
Statement [10] *((byte*) main::s#2) ← (byte) ' ' [ main::s#2 ] ( main:2 [ main::s#2 ] ) always clobbers reg byte a reg byte y 
Statement [45] *((const byte*) COLS + (byte) idx#41) ← (const byte) RED [ assertType::t1#15 idx#41 ] ( main:2::testSimpleTypes:8::assertType:13 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:15 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:17 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:19 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:21 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:23 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:25 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:27 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:29 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:31 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:33 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:35 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:37 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:39 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:41 [ assertType::t1#15 idx#41 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ assertType::t1#15 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ idx#41 idx#20 ]
Statement [46] *((const byte*) SCREEN + (byte) idx#41) ← (byte) assertType::t1#15 [ idx#41 ] ( main:2::testSimpleTypes:8::assertType:13 [ idx#41 ] main:2::testSimpleTypes:8::assertType:15 [ idx#41 ] main:2::testSimpleTypes:8::assertType:17 [ idx#41 ] main:2::testSimpleTypes:8::assertType:19 [ idx#41 ] main:2::testSimpleTypes:8::assertType:21 [ idx#41 ] main:2::testSimpleTypes:8::assertType:23 [ idx#41 ] main:2::testSimpleTypes:8::assertType:25 [ idx#41 ] main:2::testSimpleTypes:8::assertType:27 [ idx#41 ] main:2::testSimpleTypes:8::assertType:29 [ idx#41 ] main:2::testSimpleTypes:8::assertType:31 [ idx#41 ] main:2::testSimpleTypes:8::assertType:33 [ idx#41 ] main:2::testSimpleTypes:8::assertType:35 [ idx#41 ] main:2::testSimpleTypes:8::assertType:37 [ idx#41 ] main:2::testSimpleTypes:8::assertType:39 [ idx#41 ] main:2::testSimpleTypes:8::assertType:41 [ idx#41 ] ) always clobbers reg byte a 
Statement [49] *((const byte*) COLS + (byte) idx#41) ← (const byte) GREEN [ assertType::t1#15 idx#41 ] ( main:2::testSimpleTypes:8::assertType:13 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:15 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:17 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:19 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:21 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:23 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:25 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:27 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:29 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:31 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:33 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:35 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:37 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:39 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:41 [ assertType::t1#15 idx#41 ] ) always clobbers reg byte a 
Statement [6] if((byte*) main::s#2<(const byte*) SCREEN+(word) $3e8) goto main::@2 [ main::s#2 ] ( main:2 [ main::s#2 ] ) always clobbers reg byte a 
Statement [10] *((byte*) main::s#2) ← (byte) ' ' [ main::s#2 ] ( main:2 [ main::s#2 ] ) always clobbers reg byte a reg byte y 
Statement [45] *((const byte*) COLS + (byte) idx#41) ← (const byte) RED [ assertType::t1#15 idx#41 ] ( main:2::testSimpleTypes:8::assertType:13 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:15 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:17 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:19 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:21 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:23 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:25 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:27 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:29 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:31 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:33 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:35 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:37 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:39 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:41 [ assertType::t1#15 idx#41 ] ) always clobbers reg byte a 
Statement [46] *((const byte*) SCREEN + (byte) idx#41) ← (byte) assertType::t1#15 [ idx#41 ] ( main:2::testSimpleTypes:8::assertType:13 [ idx#41 ] main:2::testSimpleTypes:8::assertType:15 [ idx#41 ] main:2::testSimpleTypes:8::assertType:17 [ idx#41 ] main:2::testSimpleTypes:8::assertType:19 [ idx#41 ] main:2::testSimpleTypes:8::assertType:21 [ idx#41 ] main:2::testSimpleTypes:8::assertType:23 [ idx#41 ] main:2::testSimpleTypes:8::assertType:25 [ idx#41 ] main:2::testSimpleTypes:8::assertType:27 [ idx#41 ] main:2::testSimpleTypes:8::assertType:29 [ idx#41 ] main:2::testSimpleTypes:8::assertType:31 [ idx#41 ] main:2::testSimpleTypes:8::assertType:33 [ idx#41 ] main:2::testSimpleTypes:8::assertType:35 [ idx#41 ] main:2::testSimpleTypes:8::assertType:37 [ idx#41 ] main:2::testSimpleTypes:8::assertType:39 [ idx#41 ] main:2::testSimpleTypes:8::assertType:41 [ idx#41 ] ) always clobbers reg byte a 
Statement [49] *((const byte*) COLS + (byte) idx#41) ← (const byte) GREEN [ assertType::t1#15 idx#41 ] ( main:2::testSimpleTypes:8::assertType:13 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:15 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:17 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:19 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:21 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:23 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:25 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:27 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:29 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:31 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:33 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:35 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:37 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:39 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:8::assertType:41 [ assertType::t1#15 idx#41 ] ) always clobbers reg byte a 
Potential registers zp[2]:2 [ main::s#2 main::s#1 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ assertType::t1#15 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ assertType::t2#15 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ idx#41 idx#20 ] : zp[1]:6 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 36.67: zp[2]:2 [ main::s#2 main::s#1 ] 
Uplift Scope [] 8.2: zp[1]:6 [ idx#41 idx#20 ] 
Uplift Scope [assertType] 2: zp[1]:5 [ assertType::t2#15 ] 1: zp[1]:4 [ assertType::t1#15 ] 
Uplift Scope [testSimpleTypes] 

Uplifting [main] best 948 combination zp[2]:2 [ main::s#2 main::s#1 ] 
Uplifting [] best 933 combination reg byte x [ idx#41 idx#20 ] 
Uplifting [assertType] best 886 combination zp[1]:5 [ assertType::t2#15 ] reg byte y [ assertType::t1#15 ] 
Uplifting [testSimpleTypes] best 886 combination 
Attempting to uplift remaining variables inzp[1]:5 [ assertType::t2#15 ]
Uplifting [assertType] best 886 combination zp[1]:5 [ assertType::t2#15 ] 
Allocated (was zp[1]:5) zp[1]:4 [ assertType::t2#15 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests different integer literal types
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .const RED = 2
  .const GREEN = 5
  .label SCREEN = $400
  .label COLS = $d800
  .const TYPEID_BYTE = 1
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_WORD = 3
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_DWORD = 5
  .const TYPEID_SIGNED_DWORD = 6
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label s = 2
    // [5] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [5] phi (byte*) main::s#2 = (const byte*) SCREEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z s
    lda #>SCREEN
    sta.z s+1
    jmp __b1
    // main::@1
  __b1:
    // [6] if((byte*) main::s#2<(const byte*) SCREEN+(word) $3e8) goto main::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z s+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z s
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // [7] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [8] call testSimpleTypes 
    // [12] phi from main::@3 to testSimpleTypes [phi:main::@3->testSimpleTypes]
  testSimpleTypes_from___b3:
    jsr testSimpleTypes
    jmp __breturn
    // main::@return
  __breturn:
    // [9] return 
    rts
    // main::@2
  __b2:
    // [10] *((byte*) main::s#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
    // [11] (byte*) main::s#1 ← ++ (byte*) main::s#2 -- pbuz1=_inc_pbuz1 
    inc.z s
    bne !+
    inc.z s+1
  !:
    // [5] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [5] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // testSimpleTypes
testSimpleTypes: {
    // [13] call assertType 
    // [43] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
  assertType_from_testSimpleTypes:
    // [43] phi (byte) idx#41 = (byte) 0 [phi:testSimpleTypes->assertType#0] -- vbuxx=vbuc1 
    ldx #0
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
    // [14] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
  __b1_from_testSimpleTypes:
    jmp __b1
    // testSimpleTypes::@1
  __b1:
    // [15] call assertType 
    // [43] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
  assertType_from___b1:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
    // [16] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
  __b2_from___b1:
    jmp __b2
    // testSimpleTypes::@2
  __b2:
    // [17] call assertType 
    // [43] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
  assertType_from___b2:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    jsr assertType
    // [18] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
  __b3_from___b2:
    jmp __b3
    // testSimpleTypes::@3
  __b3:
    // [19] call assertType 
    // [43] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
  assertType_from___b3:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    jsr assertType
    // [20] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
  __b4_from___b3:
    jmp __b4
    // testSimpleTypes::@4
  __b4:
    // [21] call assertType 
    // [43] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
  assertType_from___b4:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [22] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
  __b5_from___b4:
    jmp __b5
    // testSimpleTypes::@5
  __b5:
    // [23] call assertType 
    // [43] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
  assertType_from___b5:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [24] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
  __b6_from___b5:
    jmp __b6
    // testSimpleTypes::@6
  __b6:
    // [25] call assertType 
    // [43] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
  assertType_from___b6:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
    // [26] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
  __b7_from___b6:
    jmp __b7
    // testSimpleTypes::@7
  __b7:
    // [27] call assertType 
    // [43] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
  assertType_from___b7:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
    // [28] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
  __b8_from___b7:
    jmp __b8
    // testSimpleTypes::@8
  __b8:
    // [29] call assertType 
    // [43] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
  assertType_from___b8:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
    // [30] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
  __b9_from___b8:
    jmp __b9
    // testSimpleTypes::@9
  __b9:
    // [31] call assertType 
    // [43] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
  assertType_from___b9:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
    // [32] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
  __b10_from___b9:
    jmp __b10
    // testSimpleTypes::@10
  __b10:
    // [33] call assertType 
    // [43] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
  assertType_from___b10:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [34] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
  __b11_from___b10:
    jmp __b11
    // testSimpleTypes::@11
  __b11:
    // [35] call assertType 
    // [43] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
  assertType_from___b11:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
    // [36] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
  __b12_from___b11:
    jmp __b12
    // testSimpleTypes::@12
  __b12:
    // [37] call assertType 
    // [43] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
  assertType_from___b12:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    // [38] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
  __b13_from___b12:
    jmp __b13
    // testSimpleTypes::@13
  __b13:
    // [39] call assertType 
    // [43] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
  assertType_from___b13:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    // [40] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
  __b14_from___b13:
    jmp __b14
    // testSimpleTypes::@14
  __b14:
    // [41] call assertType 
    // [43] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
  assertType_from___b14:
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    jmp __breturn
    // testSimpleTypes::@return
  __breturn:
    // [42] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(Y) t1, byte zp(4) t2)
assertType: {
    .label t2 = 4
    // [44] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp.z t2
    beq __b1
    jmp __b3
    // assertType::@3
  __b3:
    // [45] *((const byte*) COLS + (byte) idx#41) ← (const byte) RED -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta COLS,x
    jmp __b2
    // assertType::@2
  __b2:
    // [46] *((const byte*) SCREEN + (byte) idx#41) ← (byte) assertType::t1#15 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta SCREEN,x
    // [47] (byte) idx#20 ← ++ (byte) idx#41 -- vbuxx=_inc_vbuxx 
    inx
    jmp __breturn
    // assertType::@return
  __breturn:
    // [48] return 
    rts
    // assertType::@1
  __b1:
    // [49] *((const byte*) COLS + (byte) idx#41) ← (const byte) GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta COLS,x
    jmp __b2
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b13
Removing instruction jmp __b14
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_SIGNED_BYTE with TAY
Replacing instruction ldy #TYPEID_SIGNED_BYTE with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing label __bbegin with __b1
Removing instruction __bbegin:
Removing instruction __b1_from___bbegin:
Removing instruction main_from___b1:
Removing instruction __bend_from___b1:
Removing instruction __b3_from___b1:
Removing instruction testSimpleTypes_from___b3:
Removing instruction __b1_from_testSimpleTypes:
Removing instruction assertType_from___b1:
Removing instruction __b2_from___b1:
Removing instruction assertType_from___b2:
Removing instruction __b3_from___b2:
Removing instruction assertType_from___b3:
Removing instruction __b4_from___b3:
Removing instruction assertType_from___b4:
Removing instruction __b5_from___b4:
Removing instruction assertType_from___b5:
Removing instruction __b6_from___b5:
Removing instruction assertType_from___b6:
Removing instruction __b7_from___b6:
Removing instruction assertType_from___b7:
Removing instruction __b8_from___b7:
Removing instruction assertType_from___b8:
Removing instruction __b9_from___b8:
Removing instruction assertType_from___b9:
Removing instruction __b10_from___b9:
Removing instruction assertType_from___b10:
Removing instruction __b11_from___b10:
Removing instruction assertType_from___b11:
Removing instruction __b12_from___b11:
Removing instruction assertType_from___b12:
Removing instruction __b13_from___b12:
Removing instruction assertType_from___b13:
Removing instruction __b14_from___b13:
Removing instruction assertType_from___b14:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction assertType_from_testSimpleTypes:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b13:
Removing instruction __b14:
Removing instruction __breturn:
Removing instruction __b3:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction __b1:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) COLS = (byte*)(word) $d800
(const byte) GREEN = (byte) 5
(const byte) RED = (byte) 2
(const byte*) SCREEN = (byte*)(word) $400
(const byte) TYPEID_BYTE = (number) 1
(const byte) TYPEID_DWORD = (number) 5
(const byte) TYPEID_SIGNED_BYTE = (number) 2
(const byte) TYPEID_SIGNED_DWORD = (number) 6
(const byte) TYPEID_SIGNED_WORD = (number) 4
(const byte) TYPEID_WORD = (number) 3
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(label) assertType::@1
(label) assertType::@2
(label) assertType::@3
(label) assertType::@return
(byte) assertType::t1
(byte) assertType::t1#15 reg byte y 1.0
(byte) assertType::t2
(byte) assertType::t2#15 t2 zp[1]:4 2.0
(byte) idx
(byte) idx#20 reg byte x 0.9999999999999999
(byte) idx#41 reg byte x 7.200000000000002
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(byte*) main::s
(byte*) main::s#1 s zp[2]:2 22.0
(byte*) main::s#2 s zp[2]:2 14.666666666666666
(void()) testSimpleTypes()
(label) testSimpleTypes::@1
(label) testSimpleTypes::@10
(label) testSimpleTypes::@11
(label) testSimpleTypes::@12
(label) testSimpleTypes::@13
(label) testSimpleTypes::@14
(label) testSimpleTypes::@2
(label) testSimpleTypes::@3
(label) testSimpleTypes::@4
(label) testSimpleTypes::@5
(label) testSimpleTypes::@6
(label) testSimpleTypes::@7
(label) testSimpleTypes::@8
(label) testSimpleTypes::@9
(label) testSimpleTypes::@return

zp[2]:2 [ main::s#2 main::s#1 ]
reg byte y [ assertType::t1#15 ]
zp[1]:4 [ assertType::t2#15 ]
reg byte x [ idx#41 idx#20 ]


FINAL ASSEMBLER
Score: 784

  // File Comments
// Tests different integer literal types
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const RED = 2
  .const GREEN = 5
  .label SCREEN = $400
  .label COLS = $d800
  .const TYPEID_BYTE = 1
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_WORD = 3
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_DWORD = 5
  .const TYPEID_SIGNED_DWORD = 6
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label s = 2
    // [5] phi from main to main::@1 [phi:main->main::@1]
    // [5] phi (byte*) main::s#2 = (const byte*) SCREEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z s
    lda #>SCREEN
    sta.z s+1
    // main::@1
  __b1:
    // for(byte* s=SCREEN;s<SCREEN+1000uw;s++)
    // [6] if((byte*) main::s#2<(const byte*) SCREEN+(word) $3e8) goto main::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z s+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z s
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // [7] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // main::@3
    // testSimpleTypes()
    // [8] call testSimpleTypes 
    // [12] phi from main::@3 to testSimpleTypes [phi:main::@3->testSimpleTypes]
    jsr testSimpleTypes
    // main::@return
    // }
    // [9] return 
    rts
    // main::@2
  __b2:
    // *s = ' '
    // [10] *((byte*) main::s#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
    // for(byte* s=SCREEN;s<SCREEN+1000uw;s++)
    // [11] (byte*) main::s#1 ← ++ (byte*) main::s#2 -- pbuz1=_inc_pbuz1 
    inc.z s
    bne !+
    inc.z s+1
  !:
    // [5] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [5] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // testSimpleTypes
testSimpleTypes: {
    // assertType(typeid(12ub), typeid(unsigned byte))
    // [13] call assertType 
    // [43] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
    // [43] phi (byte) idx#41 = (byte) 0 [phi:testSimpleTypes->assertType#0] -- vbuxx=vbuc1 
    ldx #0
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [14] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
    // testSimpleTypes::@1
    // assertType(typeid(12uc), typeid(unsigned byte))
    // [15] call assertType 
    // [43] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [16] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
    // testSimpleTypes::@2
    // assertType(typeid(12sb), typeid(signed byte))
    // [17] call assertType 
    // [43] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [18] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
    // testSimpleTypes::@3
    // assertType(typeid(12sc), typeid(signed byte))
    // [19] call assertType 
    // [43] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [20] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
    // testSimpleTypes::@4
    // assertType(typeid(12uw), typeid(unsigned word))
    // [21] call assertType 
    // [43] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [22] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
    // testSimpleTypes::@5
    // assertType(typeid(12ui), typeid(unsigned word))
    // [23] call assertType 
    // [43] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [24] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
    // testSimpleTypes::@6
    // assertType(typeid(12us), typeid(unsigned word))
    // [25] call assertType 
    // [43] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [26] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
    // testSimpleTypes::@7
    // assertType(typeid(12sw), typeid(signed word))
    // [27] call assertType 
    // [43] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [28] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
    // testSimpleTypes::@8
    // assertType(typeid(12si), typeid(signed word))
    // [29] call assertType 
    // [43] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [30] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
    // testSimpleTypes::@9
    // assertType(typeid(12ss), typeid(signed word))
    // [31] call assertType 
    // [43] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [32] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
    // testSimpleTypes::@10
    // assertType(typeid(12ud), typeid(unsigned dword))
    // [33] call assertType 
    // [43] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [34] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
    // testSimpleTypes::@11
    // assertType(typeid(12ul), typeid(unsigned dword))
    // [35] call assertType 
    // [43] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [36] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
    // testSimpleTypes::@12
    // assertType(typeid(12sd), typeid(signed dword))
    // [37] call assertType 
    // [43] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [38] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
    // testSimpleTypes::@13
    // assertType(typeid(12sl), typeid(signed dword))
    // [39] call assertType 
    // [43] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // [40] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
    // testSimpleTypes::@14
    // assertType(typeid(12l), typeid(signed dword))
    // [41] call assertType 
    // [43] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
    // [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
    // [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta.z assertType.t2
    // [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
    // testSimpleTypes::@return
    // }
    // [42] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(Y) t1, byte zp(4) t2)
assertType: {
    .label t2 = 4
    // if(t1==t2)
    // [44] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp.z t2
    beq __b1
    // assertType::@3
    // COLS[idx] = RED
    // [45] *((const byte*) COLS + (byte) idx#41) ← (const byte) RED -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta COLS,x
    // assertType::@2
  __b2:
    // SCREEN[idx++] = t1
    // [46] *((const byte*) SCREEN + (byte) idx#41) ← (byte) assertType::t1#15 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta SCREEN,x
    // SCREEN[idx++] = t1;
    // [47] (byte) idx#20 ← ++ (byte) idx#41 -- vbuxx=_inc_vbuxx 
    inx
    // assertType::@return
    // }
    // [48] return 
    rts
    // assertType::@1
  __b1:
    // COLS[idx] = GREEN
    // [49] *((const byte*) COLS + (byte) idx#41) ← (const byte) GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta COLS,x
    jmp __b2
}
  // File Data

