(label) @1
(label) @begin
(label) @end
(word*) CALLS
(const word*) CALLS#0 CALLS = (word*)(const byte[]) SYSCALLS#0+(byte) 1
(byte) JMP
(const byte) JMP#0 JMP = (byte) $4c
(byte) NOP
(const byte) NOP#0 NOP = (byte) $ea
(byte[]) SYSCALLS
(const byte[]) SYSCALLS#0 SYSCALLS = { (const byte) JMP#0, <&(void()) fn1(), >&(void()) fn1(), (const byte) NOP#0, (const byte) JMP#0, <&(void()) fn2(), >&(void()) fn2(), (const byte) NOP#0 }
(void()) fn1()
(label) fn1::@return
(byte*) fn1::BORDERCOL
(const byte*) fn1::BORDERCOL#0 BORDERCOL = (byte*) 53280
(void()) fn2()
(label) fn2::@return
(byte*) fn2::BGCOL
(const byte*) fn2::BGCOL#0 BGCOL = (byte*) 53281
(void()) main()
(byte~) main::$0 reg byte a 202.0
(byte~) main::$5 reg byte a 202.0
(label) main::@1
(label) main::@2
(label) main::@3
(void()*) main::f
(word) main::fn
(word) main::fn#0 fn zp ZP_WORD:3 101.0
(byte) main::i
(byte) main::i#1 i zp ZP_BYTE:2 71.0
(byte) main::i#3 i zp ZP_BYTE:2 42.599999999999994

zp ZP_BYTE:2 [ main::i#3 main::i#1 ]
reg byte a [ main::$0 ]
reg byte a [ main::$5 ]
zp ZP_WORD:3 [ main::fn#0 ]
