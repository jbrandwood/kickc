@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] (word) last_time#0 ← (word) 0
  to:@2
@2: scope:[]  from @1
  [2] (word) rand_seed#20 ← (word) 0
  to:@3
@3: scope:[]  from @2
  [3] phi()
  [4] call main 
  to:@end
@end: scope:[]  from @3
  [5] phi()

(signed word()) main()
main: scope:[main]  from @3
  [6] phi()
  [7] call start 
  to:main::@1
main::@1: scope:[main]  from main
  [8] phi()
  [9] call round 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [10] phi()
  [11] call round 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [12] phi()
  [13] call round 
  to:main::@4
main::@4: scope:[main]  from main::@3
  [14] phi()
  [15] call round 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [16] phi()
  [17] call round 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [18] phi()
  [19] call round 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [20] phi()
  [21] call round 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [22] phi()
  [23] call round 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [24] phi()
  [25] call round 
  to:main::@10
main::@10: scope:[main]  from main::@9
  [26] phi()
  [27] call round 
  to:main::@11
main::@11: scope:[main]  from main::@10
  [28] phi()
  [29] call end 
  to:main::@return
main::@return: scope:[main]  from main::@11
  [30] return 
  to:@return

(void()) end()
end: scope:[end]  from main::@11
  [31] (word) Ticks#1 ← (word) last_time#0
  [32] call start 
  to:end::@1
end::@1: scope:[end]  from end
  [33] (word) last_time#1 ← (word) last_time#0 - (word) Ticks#1
  [34] (word) Ticks#2 ← (word) last_time#1
  [35] (word) print_word::w#0 ← (word) Ticks#2
  [36] call print_word 
  to:end::@2
end::@2: scope:[end]  from end::@1
  [37] phi()
  [38] call print_ln 
  to:end::@return
end::@return: scope:[end]  from end::@2
  [39] (word) last_time#2 ← (word) last_time#1
  [40] return 
  to:@return

(void()) print_ln()
print_ln: scope:[print_ln]  from end::@2
  [41] phi()
  to:print_ln::@1
print_ln::@1: scope:[print_ln]  from print_ln print_ln::@1
  [42] (byte*) print_line_cursor#8 ← phi( print_ln/(byte*) 1024 print_ln::@1/(byte*) print_line_cursor#1 )
  [43] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#8 + (byte) $28
  [44] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#10) goto print_ln::@1
  to:print_ln::@return
print_ln::@return: scope:[print_ln]  from print_ln::@1
  [45] return 
  to:@return

(void()) print_word((word) print_word::w)
print_word: scope:[print_word]  from end::@1
  [46] (byte) print_byte::b#0 ← > (word) print_word::w#0
  [47] call print_byte 
  to:print_word::@1
print_word::@1: scope:[print_word]  from print_word
  [48] (byte) print_byte::b#1 ← < (word) print_word::w#0
  [49] call print_byte 
  to:print_word::@return
print_word::@return: scope:[print_word]  from print_word::@1
  [50] return 
  to:@return

(void()) print_byte((byte) print_byte::b)
print_byte: scope:[print_byte]  from print_word print_word::@1
  [51] (byte*) print_char_cursor#35 ← phi( print_word/(byte*) 1024 print_word::@1/(byte*) print_char_cursor#10 )
  [51] (byte) print_byte::b#2 ← phi( print_word/(byte) print_byte::b#0 print_word::@1/(byte) print_byte::b#1 )
  [52] (byte~) print_byte::$0 ← (byte) print_byte::b#2 >> (byte) 4
  [53] (byte) print_char::ch#0 ← *((const byte*) print_hextab + (byte~) print_byte::$0)
  [54] call print_char 
  to:print_byte::@1
print_byte::@1: scope:[print_byte]  from print_byte
  [55] (byte~) print_byte::$2 ← (byte) print_byte::b#2 & (byte) $f
  [56] (byte) print_char::ch#1 ← *((const byte*) print_hextab + (byte~) print_byte::$2)
  [57] call print_char 
  to:print_byte::@return
print_byte::@return: scope:[print_byte]  from print_byte::@1
  [58] return 
  to:@return

(void()) print_char((byte) print_char::ch)
print_char: scope:[print_char]  from print_byte print_byte::@1
  [59] (byte*) print_char_cursor#25 ← phi( print_byte/(byte*) print_char_cursor#35 print_byte::@1/(byte*) print_char_cursor#10 )
  [59] (byte) print_char::ch#2 ← phi( print_byte/(byte) print_char::ch#0 print_byte::@1/(byte) print_char::ch#1 )
  [60] *((byte*) print_char_cursor#25) ← (byte) print_char::ch#2
  [61] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#25
  to:print_char::@return
print_char::@return: scope:[print_char]  from print_char
  [62] return 
  to:@return

(void()) start()
start: scope:[start]  from end main
  asm { jsr$FFDE staLAST_TIME stxLAST_TIME+1  }
  [64] (word) rand_seed#0 ← (word) $194a
  to:start::@return
start::@return: scope:[start]  from start
  [65] return 
  to:@return

(void()) round()
round: scope:[round]  from main::@1 main::@10 main::@2 main::@3 main::@4 main::@5 main::@6 main::@7 main::@8 main::@9
  [66] phi()
  to:round::@1
round::@1: scope:[round]  from round round::@2
  [67] (byte*) round::p#2 ← phi( round/(const byte*) Sieve round::@2/(byte*) round::p#1 )
  [68] if((byte*) round::p#2<(const byte*) Sieve+(const word) COUNT) goto round::@2
  to:round::@3
round::@3: scope:[round]  from round::@1 round::@5
  [69] (byte) round::I#3 ← phi( round::@5/(byte) round::I#2 round::@1/(byte) 2 )
  [70] if((byte) round::I#3<(const byte) SQRT_COUNT) goto round::@4
  to:round::@return
round::@return: scope:[round]  from round::@3
  [71] return 
  to:@return
round::@4: scope:[round]  from round::@3
  [72] if(*((const byte*) Sieve + (byte) round::I#3)!=(byte) 0) goto round::@5
  to:round::@8
round::@8: scope:[round]  from round::@4
  [73] (byte~) round::$4 ← (byte) round::I#3 << (byte) 1
  [74] (byte*) round::S#1 ← (const byte*) Sieve + (byte~) round::$4
  to:round::@6
round::@6: scope:[round]  from round::@7 round::@8
  [75] (byte*) round::S#3 ← phi( round::@7/(byte*) round::S#2 round::@8/(byte*) round::S#1 )
  [76] if((byte*) round::S#3<(const byte*) Sieve+(const word) COUNT) goto round::@7
  to:round::@5
round::@5: scope:[round]  from round::@4 round::@6
  [77] (byte) round::I#2 ← ++ (byte) round::I#3
  to:round::@3
round::@7: scope:[round]  from round::@6
  [78] *((byte*) round::S#3) ← (byte) 1
  [79] (byte*) round::S#2 ← (byte*) round::S#3 + (byte) round::I#3
  to:round::@6
round::@2: scope:[round]  from round::@1
  [80] *((byte*) round::p#2) ← (byte) 0
  [81] (byte*) round::p#1 ← ++ (byte*) round::p#2
  to:round::@1
