Culled Empty Block (label) main::@2
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) @5
Culled Empty Block (label) printother::@2
Calling convention STACK_CALL adding prepare/execute/finalize for call pval 
Calling convention STACK_CALL adding prepare/execute/finalize for call printother 
Calling convention STACK_CALL adding prepare/execute/finalize for call ival 
Calling convention STACK_CALL adding prepare/execute/finalize for call printval 
Calling convention STACK_CALL adding prepare/execute/finalize for call incval 
Calling convention STACK_CALL adding prepare/execute/finalize for call main 

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) val ← (byte) 0
  to:@6

__stackcall (void()) main()
main: scope:[main]  from
  (byte) main::i ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  callprepare pval 
  callexecute pval 
  callfinalize pval 
  callprepare printother 
  callexecute printother 
  callfinalize printother 
  callprepare ival 
  callexecute ival 
  callfinalize ival 
  (byte) main::i ← (byte) main::i + rangenext(0,5)
  (bool~) main::$3 ← (byte) main::i != rangelast(0,5)
  if((bool~) main::$3) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return

__stackcall (void()) pval()
pval: scope:[pval]  from
  callprepare printval 
  callexecute printval 
  callfinalize printval 
  to:pval::@return
pval::@return: scope:[pval]  from pval
  return 
  to:@return

__stackcall (void()) ival()
ival: scope:[ival]  from
  callprepare incval 
  callexecute incval 
  callfinalize incval 
  to:ival::@return
ival::@return: scope:[ival]  from ival
  return 
  to:@return

__stackcall (void()) printval()
printval: scope:[printval]  from
  *((const byte*) SCREEN + (number) 0) ← (byte) val
  to:printval::@return
printval::@return: scope:[printval]  from printval
  return 
  to:@return

__stackcall (void()) incval()
incval: scope:[incval]  from
  (byte) val ← ++ (byte) val
  to:incval::@return
incval::@return: scope:[incval]  from incval
  return 
  to:@return

__stackcall (void()) printother()
printother: scope:[printother]  from
  (byte) printother::i ← (byte) 0
  to:printother::@1
printother::@1: scope:[printother]  from printother printother::@1
  *((const byte*) SCREEN+(number) $28 + (byte) printother::i) ← ++ *((const byte*) SCREEN+(number) $28 + (byte) printother::i)
  (byte) printother::i ← (byte) printother::i + rangenext(0,5)
  (bool~) printother::$1 ← (byte) printother::i != rangelast(0,5)
  if((bool~) printother::$1) goto printother::@1
  to:printother::@return
printother::@return: scope:[printother]  from printother::@1
  return 
  to:@return
@6: scope:[]  from @begin
  callprepare main 
  callexecute main 
  callfinalize main 
  to:@end
@end: scope:[]  from @6

SYMBOL TABLE SSA
(label) @6
(label) @begin
(label) @end
(const byte*) SCREEN = (byte*)(number) $400
__stackcall (void()) incval()
(label) incval::@return
__stackcall (void()) ival()
(label) ival::@return
__stackcall (void()) main()
(bool~) main::$3
(label) main::@1
(label) main::@return
(byte) main::i loadstore
__stackcall (void()) printother()
(bool~) printother::$1
(label) printother::@1
(label) printother::@return
(byte) printother::i loadstore
__stackcall (void()) printval()
(label) printval::@return
__stackcall (void()) pval()
(label) pval::@return
(byte) val loadstore

Adding number conversion cast (unumber) 0 in *((const byte*) SCREEN + (number) 0) ← (byte) val
Adding number conversion cast (unumber) $28 in *((const byte*) SCREEN+(number) $28 + (byte) printother::i) ← ++ *((const byte*) SCREEN+(number) $28 + (byte) printother::i)
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Simple Condition (bool~) main::$3 [13] if((byte) main::i!=rangelast(0,5)) goto main::@1
Simple Condition (bool~) printother::$1 [31] if((byte) printother::i!=rangelast(0,5)) goto printother::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Resolved ranged next value [11] main::i ← ++ main::i to ++
Resolved ranged comparison value [13] if(main::i!=rangelast(0,5)) goto main::@1 to (number) 6
Resolved ranged next value [29] printother::i ← ++ printother::i to ++
Resolved ranged comparison value [31] if(printother::i!=rangelast(0,5)) goto printother::@1 to (number) 6
Simplifying expression containing zero SCREEN in [23] *((const byte*) SCREEN + (byte) 0) ← (byte) val
Successful SSA optimization PassNSimplifyExpressionWithZero
Adding number conversion cast (unumber) 6 in if((byte) main::i!=(number) 6) goto main::@1
Adding number conversion cast (unumber) 6 in if((byte) printother::i!=(number) 6) goto printother::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 6
Simplifying constant integer cast 6
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) 6
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of @end
CALL GRAPH
Calls in [] to main:2 
Calls in [ival] to incval:15 
Calls in [pval] to printval:19 
Calls in [main] to pval:24 printother:27 ival:30 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Renumbering block @6 to @1
Adding NOP phi() at start of @end

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] (byte) val ← (byte) 0
  to:@1
@1: scope:[]  from @begin
  [1] callprepare main 
  [2] callexecute main 
  [3] callfinalize main 
  to:@end
@end: scope:[]  from @1
  [4] phi()

__stackcall (void()) printother()
printother: scope:[printother]  from
  [5] (byte) printother::i ← (byte) 0
  to:printother::@1
printother::@1: scope:[printother]  from printother printother::@1
  [6] *((const byte*) SCREEN+(byte) $28 + (byte) printother::i) ← ++ *((const byte*) SCREEN+(byte) $28 + (byte) printother::i)
  [7] (byte) printother::i ← ++ (byte) printother::i
  [8] if((byte) printother::i!=(byte) 6) goto printother::@1
  to:printother::@return
printother::@return: scope:[printother]  from printother::@1
  [9] return 
  to:@return

__stackcall (void()) incval()
incval: scope:[incval]  from
  [10] (byte) val ← ++ (byte) val
  to:incval::@return
incval::@return: scope:[incval]  from incval
  [11] return 
  to:@return

__stackcall (void()) printval()
printval: scope:[printval]  from
  [12] *((const byte*) SCREEN) ← (byte) val
  to:printval::@return
printval::@return: scope:[printval]  from printval
  [13] return 
  to:@return

__stackcall (void()) ival()
ival: scope:[ival]  from
  [14] callprepare incval 
  [15] callexecute incval 
  [16] callfinalize incval 
  to:ival::@return
ival::@return: scope:[ival]  from ival
  [17] return 
  to:@return

__stackcall (void()) pval()
pval: scope:[pval]  from
  [18] callprepare printval 
  [19] callexecute printval 
  [20] callfinalize printval 
  to:pval::@return
pval::@return: scope:[pval]  from pval
  [21] return 
  to:@return

__stackcall (void()) main()
main: scope:[main]  from
  [22] (byte) main::i ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [23] callprepare pval 
  [24] callexecute pval 
  [25] callfinalize pval 
  [26] callprepare printother 
  [27] callexecute printother 
  [28] callfinalize printother 
  [29] callprepare ival 
  [30] callexecute ival 
  [31] callfinalize ival 
  [32] (byte) main::i ← ++ (byte) main::i
  [33] if((byte) main::i!=(byte) 6) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  [34] return 
  to:@return

null depth in calling loop Loop head: main::@1 tails: main::@1 blocks: main::@1  in scope printother
null depth in calling loop Loop head: main::@1 tails: main::@1 blocks: main::@1  in scope ival
null depth in calling loop Loop head: main::@1 tails: main::@1 blocks: main::@1  in scope pval
null depth in calling loop Loop head: main::@1 tails: main::@1 blocks: main::@1  in scope ival
null depth in calling loop Loop head: main::@1 tails: main::@1 blocks: main::@1  in scope pval

VARIABLE REGISTER WEIGHTS
__stackcall (void()) incval()
__stackcall (void()) ival()
__stackcall (void()) main()
(byte) main::i loadstore 2.9166666666666665
__stackcall (void()) printother()
(byte) printother::i loadstore 14.25
__stackcall (void()) printval()
__stackcall (void()) pval()
(byte) val loadstore 0.3076923076923077

Initial phi equivalence classes
Added variable val to live range equivalence class [ val ]
Added variable printother::i to live range equivalence class [ printother::i ]
Added variable main::i to live range equivalence class [ main::i ]
Complete equivalence classes
[ val ]
[ printother::i ]
[ main::i ]
Allocated zp[1]:2 [ val ]
Allocated zp[1]:3 [ printother::i ]
Allocated zp[1]:4 [ main::i ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Test a procedure with calling convention stack
// Illustrates live range problem with function variable printother::i and global variable val
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label val = 2
  // @begin
__bbegin:
  // [0] (byte) val ← (byte) 0 -- vbuz1=vbuc1 
  lda #0
  sta.z val
  jmp __b1
  // @1
__b1:
  // [1] callprepare main 
  // [2] callexecute main  -- jsr 
  jsr main
  // [3] callfinalize main 
  // [4] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // printother
printother: {
    .label i = 3
    // [5] (byte) printother::i ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // printother::@1
  __b1:
    // [6] *((const byte*) SCREEN+(byte) $28 + (byte) printother::i) ← ++ *((const byte*) SCREEN+(byte) $28 + (byte) printother::i) -- pbuc1_derefidx_vbuz1=_inc_pbuc1_derefidx_vbuz1 
    ldx.z i
    inc SCREEN+$28,x
    // [7] (byte) printother::i ← ++ (byte) printother::i -- vbuz1=_inc_vbuz1 
    inc.z i
    // [8] if((byte) printother::i!=(byte) 6) goto printother::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #6
    cmp.z i
    bne __b1
    jmp __breturn
    // printother::@return
  __breturn:
    // [9] return 
    rts
}
  // incval
incval: {
    // [10] (byte) val ← ++ (byte) val -- vbuz1=_inc_vbuz1 
    inc.z val
    jmp __breturn
    // incval::@return
  __breturn:
    // [11] return 
    rts
}
  // printval
printval: {
    // [12] *((const byte*) SCREEN) ← (byte) val -- _deref_pbuc1=vbuz1 
    lda.z val
    sta SCREEN
    jmp __breturn
    // printval::@return
  __breturn:
    // [13] return 
    rts
}
  // ival
ival: {
    // [14] callprepare incval 
    // [15] callexecute incval  -- jsr 
    jsr incval
    // [16] callfinalize incval 
    jmp __breturn
    // ival::@return
  __breturn:
    // [17] return 
    rts
}
  // pval
pval: {
    // [18] callprepare printval 
    // [19] callexecute printval  -- jsr 
    jsr printval
    // [20] callfinalize printval 
    jmp __breturn
    // pval::@return
  __breturn:
    // [21] return 
    rts
}
  // main
main: {
    .label i = 4
    // [22] (byte) main::i ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // main::@1
  __b1:
    // [23] callprepare pval 
    // [24] callexecute pval  -- jsr 
    jsr pval
    // [25] callfinalize pval 
    // [26] callprepare printother 
    // [27] callexecute printother  -- jsr 
    jsr printother
    // [28] callfinalize printother 
    // [29] callprepare ival 
    // [30] callexecute ival  -- jsr 
    jsr ival
    // [31] callfinalize ival 
    // [32] (byte) main::i ← ++ (byte) main::i -- vbuz1=_inc_vbuz1 
    inc.z i
    // [33] if((byte) main::i!=(byte) 6) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #6
    cmp.z i
    bne __b1
    jmp __breturn
    // main::@return
  __breturn:
    // [34] return 
    rts
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] (byte) val ← (byte) 0 [ val ] (  [ val ] ) always clobbers reg byte a 
Statement [5] (byte) printother::i ← (byte) 0 [ printother::i ] ( main:2::printother:27 [ val main::i printother::i ] ) always clobbers reg byte a 
Statement [6] *((const byte*) SCREEN+(byte) $28 + (byte) printother::i) ← ++ *((const byte*) SCREEN+(byte) $28 + (byte) printother::i) [ printother::i ] ( main:2::printother:27 [ val main::i printother::i ] ) always clobbers reg byte x 
Statement [8] if((byte) printother::i!=(byte) 6) goto printother::@1 [ printother::i ] ( main:2::printother:27 [ val main::i printother::i ] ) always clobbers reg byte a 
Statement [12] *((const byte*) SCREEN) ← (byte) val [ val ] ( main:2::pval:24::printval:19 [ main::i val ] ) always clobbers reg byte a 
Statement [22] (byte) main::i ← (byte) 0 [ val main::i ] ( main:2 [ val main::i ] ) always clobbers reg byte a 
Statement [33] if((byte) main::i!=(byte) 6) goto main::@1 [ val main::i ] ( main:2 [ val main::i ] ) always clobbers reg byte a 
Potential registers zp[1]:2 [ val ] : zp[1]:2 , 
Potential registers zp[1]:3 [ printother::i ] : zp[1]:3 , 
Potential registers zp[1]:4 [ main::i ] : zp[1]:4 , 

REGISTER UPLIFT SCOPES
Uplift Scope [printother] 14.25: zp[1]:3 [ printother::i ] 
Uplift Scope [main] 2.92: zp[1]:4 [ main::i ] 
Uplift Scope [] 0.31: zp[1]:2 [ val ] 
Uplift Scope [pval] 
Uplift Scope [ival] 
Uplift Scope [printval] 
Uplift Scope [incval] 

Uplifting [printother] best 695 combination zp[1]:3 [ printother::i ] 
Uplifting [main] best 695 combination zp[1]:4 [ main::i ] 
Uplifting [] best 695 combination zp[1]:2 [ val ] 
Uplifting [pval] best 695 combination 
Uplifting [ival] best 695 combination 
Uplifting [printval] best 695 combination 
Uplifting [incval] best 695 combination 
Attempting to uplift remaining variables inzp[1]:3 [ printother::i ]
Uplifting [printother] best 695 combination zp[1]:3 [ printother::i ] 
Attempting to uplift remaining variables inzp[1]:4 [ main::i ]
Uplifting [main] best 695 combination zp[1]:4 [ main::i ] 
Attempting to uplift remaining variables inzp[1]:2 [ val ]
Uplifting [] best 695 combination zp[1]:2 [ val ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test a procedure with calling convention stack
// Illustrates live range problem with function variable printother::i and global variable val
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label val = 2
  // @begin
__bbegin:
  // [0] (byte) val ← (byte) 0 -- vbuz1=vbuc1 
  lda #0
  sta.z val
  jmp __b1
  // @1
__b1:
  // [1] callprepare main 
  // [2] callexecute main  -- jsr 
  jsr main
  // [3] callfinalize main 
  // [4] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // printother
printother: {
    .label i = 3
    // [5] (byte) printother::i ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // printother::@1
  __b1:
    // [6] *((const byte*) SCREEN+(byte) $28 + (byte) printother::i) ← ++ *((const byte*) SCREEN+(byte) $28 + (byte) printother::i) -- pbuc1_derefidx_vbuz1=_inc_pbuc1_derefidx_vbuz1 
    ldx.z i
    inc SCREEN+$28,x
    // [7] (byte) printother::i ← ++ (byte) printother::i -- vbuz1=_inc_vbuz1 
    inc.z i
    // [8] if((byte) printother::i!=(byte) 6) goto printother::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #6
    cmp.z i
    bne __b1
    jmp __breturn
    // printother::@return
  __breturn:
    // [9] return 
    rts
}
  // incval
incval: {
    // [10] (byte) val ← ++ (byte) val -- vbuz1=_inc_vbuz1 
    inc.z val
    jmp __breturn
    // incval::@return
  __breturn:
    // [11] return 
    rts
}
  // printval
printval: {
    // [12] *((const byte*) SCREEN) ← (byte) val -- _deref_pbuc1=vbuz1 
    lda.z val
    sta SCREEN
    jmp __breturn
    // printval::@return
  __breturn:
    // [13] return 
    rts
}
  // ival
ival: {
    // [14] callprepare incval 
    // [15] callexecute incval  -- jsr 
    jsr incval
    // [16] callfinalize incval 
    jmp __breturn
    // ival::@return
  __breturn:
    // [17] return 
    rts
}
  // pval
pval: {
    // [18] callprepare printval 
    // [19] callexecute printval  -- jsr 
    jsr printval
    // [20] callfinalize printval 
    jmp __breturn
    // pval::@return
  __breturn:
    // [21] return 
    rts
}
  // main
main: {
    .label i = 4
    // [22] (byte) main::i ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // main::@1
  __b1:
    // [23] callprepare pval 
    // [24] callexecute pval  -- jsr 
    jsr pval
    // [25] callfinalize pval 
    // [26] callprepare printother 
    // [27] callexecute printother  -- jsr 
    jsr printother
    // [28] callfinalize printother 
    // [29] callprepare ival 
    // [30] callexecute ival  -- jsr 
    jsr ival
    // [31] callfinalize ival 
    // [32] (byte) main::i ← ++ (byte) main::i -- vbuz1=_inc_vbuz1 
    inc.z i
    // [33] if((byte) main::i!=(byte) 6) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #6
    cmp.z i
    bne __b1
    jmp __breturn
    // main::@return
  __breturn:
    // [34] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __bend_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1:
Removing instruction __bend:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) SCREEN = (byte*) 1024
__stackcall (void()) incval()
(label) incval::@return
__stackcall (void()) ival()
(label) ival::@return
__stackcall (void()) main()
(label) main::@1
(label) main::@return
(byte) main::i loadstore zp[1]:4 2.9166666666666665
__stackcall (void()) printother()
(label) printother::@1
(label) printother::@return
(byte) printother::i loadstore zp[1]:3 14.25
__stackcall (void()) printval()
(label) printval::@return
__stackcall (void()) pval()
(label) pval::@return
(byte) val loadstore zp[1]:2 0.3076923076923077

zp[1]:2 [ val ]
zp[1]:3 [ printother::i ]
zp[1]:4 [ main::i ]


FINAL ASSEMBLER
Score: 617

  // File Comments
// Test a procedure with calling convention stack
// Illustrates live range problem with function variable printother::i and global variable val
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label val = 2
  // @begin
__bbegin:
  // val = 0
  // [0] (byte) val ← (byte) 0 -- vbuz1=vbuc1 
  lda #0
  sta.z val
  // @1
  // [1] callprepare main 
  // [2] callexecute main  -- jsr 
  jsr main
  rts
  // [3] callfinalize main 
  // [4] phi from @1 to @end [phi:@1->@end]
  // @end
  // printother
printother: {
    .label i = 3
    // for(char i:0..5)
    // [5] (byte) printother::i ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // printother::@1
  __b1:
    // (SCREEN+40)[i]++;
    // [6] *((const byte*) SCREEN+(byte) $28 + (byte) printother::i) ← ++ *((const byte*) SCREEN+(byte) $28 + (byte) printother::i) -- pbuc1_derefidx_vbuz1=_inc_pbuc1_derefidx_vbuz1 
    ldx.z i
    inc SCREEN+$28,x
    // for(char i:0..5)
    // [7] (byte) printother::i ← ++ (byte) printother::i -- vbuz1=_inc_vbuz1 
    inc.z i
    // [8] if((byte) printother::i!=(byte) 6) goto printother::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #6
    cmp.z i
    bne __b1
    // printother::@return
    // }
    // [9] return 
    rts
}
  // incval
incval: {
    // val++;
    // [10] (byte) val ← ++ (byte) val -- vbuz1=_inc_vbuz1 
    inc.z val
    // incval::@return
    // }
    // [11] return 
    rts
}
  // printval
printval: {
    // SCREEN[0] = val
    // [12] *((const byte*) SCREEN) ← (byte) val -- _deref_pbuc1=vbuz1 
    lda.z val
    sta SCREEN
    // printval::@return
    // }
    // [13] return 
    rts
}
  // ival
ival: {
    // incval()
    // [14] callprepare incval 
    // [15] callexecute incval  -- jsr 
    jsr incval
    // [16] callfinalize incval 
    // ival::@return
    // }
    // [17] return 
    rts
}
  // pval
pval: {
    // printval()
    // [18] callprepare printval 
    // [19] callexecute printval  -- jsr 
    jsr printval
    // [20] callfinalize printval 
    // pval::@return
    // }
    // [21] return 
    rts
}
  // main
main: {
    .label i = 4
    // for(char i:0..5)
    // [22] (byte) main::i ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // main::@1
  __b1:
    // pval()
    // [23] callprepare pval 
    // [24] callexecute pval  -- jsr 
    jsr pval
    // [25] callfinalize pval 
    // printother()
    // [26] callprepare printother 
    // [27] callexecute printother  -- jsr 
    jsr printother
    // [28] callfinalize printother 
    // ival()
    // [29] callprepare ival 
    // [30] callexecute ival  -- jsr 
    jsr ival
    // [31] callfinalize ival 
    // for(char i:0..5)
    // [32] (byte) main::i ← ++ (byte) main::i -- vbuz1=_inc_vbuz1 
    inc.z i
    // [33] if((byte) main::i!=(byte) 6) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #6
    cmp.z i
    bne __b1
    // main::@return
    // }
    // [34] return 
    rts
}
  // File Data

