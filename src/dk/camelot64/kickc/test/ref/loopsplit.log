byte i=100;
byte s=0;
while(--i>0) {
    if(i>50) {
       s++;
    } else {
       s--;
    }
}

Adding pre/post-modifier (byte) i ← -- (byte) i
Adding pre/post-modifier (byte) s ← ++ (byte) s
Adding pre/post-modifier (byte) s ← -- (byte) s
PROGRAM
  (byte) i ← (byte) 100
  (byte) s ← (byte) 0
@1:
  (byte) i ← -- (byte) i
  (boolean~) $0 ← (byte) i > (byte) 0
  if((boolean~) $0) goto @2
  goto @3
@2:
  (boolean~) $1 ← (byte) i > (byte) 50
  if((boolean~) $1) goto @4
  goto @5
@4:
  (byte) s ← ++ (byte) s
  goto @6
@5:
  (byte) s ← -- (byte) s
@6:
  goto @1
@3:

SYMBOLS
(boolean~) $0
(boolean~) $1
(label) @1
(label) @2
(label) @3
(label) @4
(label) @5
(label) @6
(byte) i
(byte) s

INITIAL CONTROL FLOW GRAPH
@BEGIN: from
  (byte) i ← (byte) 100
  (byte) s ← (byte) 0
  to:@1
@1: from @6 @BEGIN
  (byte) i ← -- (byte) i
  (boolean~) $0 ← (byte) i > (byte) 0
  if((boolean~) $0) goto @2
  to:@7
@2: from @1 @8
  (boolean~) $1 ← (byte) i > (byte) 50
  if((boolean~) $1) goto @4
  to:@9
@7: from @1
  to:@3
@3: from @12 @7
  to:@END
@8: from
  to:@2
@4: from @10 @2
  (byte) s ← ++ (byte) s
  to:@6
@9: from @2
  to:@5
@5: from @11 @9
  (byte) s ← -- (byte) s
  to:@6
@10: from
  to:@4
@6: from @4 @5
  to:@1
@11: from
  to:@5
@12: from
  to:@3
@END: from @3

Removing empty block @7
Removing empty block @3
Removing empty block @8
Removing empty block @9
Removing empty block @10
Removing empty block @6
Removing empty block @11
Removing empty block @12
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) i ← (byte) 100
  (byte) s ← (byte) 0
  to:@1
@1: from @4 @5 @BEGIN
  (byte) i ← -- (byte) i
  (boolean~) $0 ← (byte) i > (byte) 0
  if((boolean~) $0) goto @2
  to:@END
@2: from @1
  (boolean~) $1 ← (byte) i > (byte) 50
  if((boolean~) $1) goto @4
  to:@5
@4: from @2
  (byte) s ← ++ (byte) s
  to:@1
@5: from @2
  (byte) s ← -- (byte) s
  to:@1
@END: from @1

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@BEGIN: from
  (byte) i ← (byte) 100
  (byte) s ← (byte) 0
  to:@1
@1: from @4 @5 @BEGIN
  (byte) i ← -- (byte) i
  (boolean~) $0 ← (byte) i > (byte) 0
  if((boolean~) $0) goto @2
  to:@END
@2: from @1
  (boolean~) $1 ← (byte) i > (byte) 50
  if((boolean~) $1) goto @4
  to:@5
@4: from @2
  (byte) s ← ++ (byte) s
  to:@1
@5: from @2
  (byte) s ← -- (byte) s
  to:@1
@END: from @1

Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@BEGIN: from
  (byte) i#0 ← (byte) 100
  (byte) s#0 ← (byte) 0
  to:@1
@1: from @4 @5 @BEGIN
  (byte) s#6 ← phi( @4/(byte) s#1 @5/(byte) s#2 @BEGIN/(byte) s#0 )
  (byte) i#2 ← phi( @4/(byte) i#4 @5/(byte) i#5 @BEGIN/(byte) i#0 )
  (byte) i#1 ← -- (byte) i#2
  (boolean~) $0 ← (byte) i#1 > (byte) 0
  if((boolean~) $0) goto @2
  to:@END
@2: from @1
  (byte) s#5 ← phi( @1/(byte) s#6 )
  (byte) i#3 ← phi( @1/(byte) i#1 )
  (boolean~) $1 ← (byte) i#3 > (byte) 50
  if((boolean~) $1) goto @4
  to:@5
@4: from @2
  (byte) i#4 ← phi( @2/(byte) i#3 )
  (byte) s#3 ← phi( @2/(byte) s#5 )
  (byte) s#1 ← ++ (byte) s#3
  to:@1
@5: from @2
  (byte) i#5 ← phi( @2/(byte) i#3 )
  (byte) s#4 ← phi( @2/(byte) s#5 )
  (byte) s#2 ← -- (byte) s#4
  to:@1
@END: from @1

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@BEGIN: from
  (byte) i#0 ← (byte) 100
  (byte) s#0 ← (byte) 0
  to:@1
@1: from @4 @5 @BEGIN
  (byte) s#6 ← phi( @4/(byte) s#1 @5/(byte) s#2 @BEGIN/(byte) s#0 )
  (byte) i#2 ← phi( @4/(byte) i#4 @5/(byte) i#5 @BEGIN/(byte) i#0 )
  (byte) i#1 ← -- (byte) i#2
  (boolean~) $0 ← (byte) i#1 > (byte) 0
  if((boolean~) $0) goto @2
  to:@END
@2: from @1
  (byte) s#5 ← phi( @1/(byte) s#6 )
  (byte) i#3 ← phi( @1/(byte) i#1 )
  (boolean~) $1 ← (byte) i#3 > (byte) 50
  if((boolean~) $1) goto @4
  to:@5
@4: from @2
  (byte) i#4 ← phi( @2/(byte) i#3 )
  (byte) s#3 ← phi( @2/(byte) s#5 )
  (byte) s#1 ← ++ (byte) s#3
  to:@1
@5: from @2
  (byte) i#5 ← phi( @2/(byte) i#3 )
  (byte) s#4 ← phi( @2/(byte) s#5 )
  (byte) s#2 ← -- (byte) s#4
  to:@1
@END: from @1

Constant (byte) i#0 (byte) 100
Constant (byte) s#0 (byte) 0
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  to:@1
@1: from @4 @5 @BEGIN
  (byte) s#6 ← phi( @4/(byte) s#1 @5/(byte) s#2 @BEGIN/(byte) 0 )
  (byte) i#2 ← phi( @4/(byte) i#4 @5/(byte) i#5 @BEGIN/(byte) 100 )
  (byte) i#1 ← -- (byte) i#2
  (boolean~) $0 ← (byte) i#1 > (byte) 0
  if((boolean~) $0) goto @2
  to:@END
@2: from @1
  (byte) s#5 ← phi( @1/(byte) s#6 )
  (byte) i#3 ← phi( @1/(byte) i#1 )
  (boolean~) $1 ← (byte) i#3 > (byte) 50
  if((boolean~) $1) goto @4
  to:@5
@4: from @2
  (byte) i#4 ← phi( @2/(byte) i#3 )
  (byte) s#3 ← phi( @2/(byte) s#5 )
  (byte) s#1 ← ++ (byte) s#3
  to:@1
@5: from @2
  (byte) i#5 ← phi( @2/(byte) i#3 )
  (byte) s#4 ← phi( @2/(byte) s#5 )
  (byte) s#2 ← -- (byte) s#4
  to:@1
@END: from @1

Alias (byte) i#1 = (byte) i#3 (byte) i#4 (byte) i#5 
Alias (byte) s#3 = (byte) s#5 (byte) s#6 (byte) s#4 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  to:@1
@1: from @4 @5 @BEGIN
  (byte) s#3 ← phi( @4/(byte) s#1 @5/(byte) s#2 @BEGIN/(byte) 0 )
  (byte) i#2 ← phi( @4/(byte) i#1 @5/(byte) i#1 @BEGIN/(byte) 100 )
  (byte) i#1 ← -- (byte) i#2
  (boolean~) $0 ← (byte) i#1 > (byte) 0
  if((boolean~) $0) goto @2
  to:@END
@2: from @1
  (boolean~) $1 ← (byte) i#1 > (byte) 50
  if((boolean~) $1) goto @4
  to:@5
@4: from @2
  (byte) s#1 ← ++ (byte) s#3
  to:@1
@5: from @2
  (byte) s#2 ← -- (byte) s#3
  to:@1
@END: from @1

Simple Condition (boolean~) $0 if((byte) i#1>(byte) 0) goto @2
Simple Condition (boolean~) $1 if((byte) i#1>(byte) 50) goto @4
Succesful SSA optimization Pass2ConditionalJumpSimplification
CONTROL FLOW GRAPH
@BEGIN: from
  to:@1
@1: from @4 @5 @BEGIN
  (byte) s#3 ← phi( @4/(byte) s#1 @5/(byte) s#2 @BEGIN/(byte) 0 )
  (byte) i#2 ← phi( @4/(byte) i#1 @5/(byte) i#1 @BEGIN/(byte) 100 )
  (byte) i#1 ← -- (byte) i#2
  if((byte) i#1>(byte) 0) goto @2
  to:@END
@2: from @1
  if((byte) i#1>(byte) 50) goto @4
  to:@5
@4: from @2
  (byte) s#1 ← ++ (byte) s#3
  to:@1
@5: from @2
  (byte) s#2 ← -- (byte) s#3
  to:@1
@END: from @1

Block Sequence Planned @BEGIN @1 @END @2 @5 @4 
Block Sequence Planned @BEGIN @1 @END @2 @5 @4 
CONTROL FLOW GRAPH - PHI LIFTED
@BEGIN: from
  to:@1
@1: from @4 @5 @BEGIN
  (byte) s#3 ← phi( @4/(byte~) s#7 @5/(byte~) s#8 @BEGIN/(byte) 0 )
  (byte) i#2 ← phi( @4/(byte~) i#6 @5/(byte~) i#7 @BEGIN/(byte) 100 )
  (byte) i#1 ← -- (byte) i#2
  if((byte) i#1>(byte) 0) goto @2
  to:@END
@END: from @1
@2: from @1
  if((byte) i#1>(byte) 50) goto @4
  to:@5
@5: from @2
  (byte) s#2 ← -- (byte) s#3
  (byte~) i#7 ← (byte) i#1
  (byte~) s#8 ← (byte) s#2
  to:@1
@4: from @2
  (byte) s#1 ← ++ (byte) s#3
  (byte~) i#6 ← (byte) i#1
  (byte~) s#7 ← (byte) s#1
  to:@1

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@BEGIN: from
  to:@1
@1: from @4 @5 @BEGIN
  [0] (byte) s#3 ← phi( @4/(byte~) s#7 @5/(byte~) s#8 @BEGIN/(byte) 0 ) [ i#2 s#3 ]
  [0] (byte) i#2 ← phi( @4/(byte~) i#6 @5/(byte~) i#7 @BEGIN/(byte) 100 ) [ i#2 s#3 ]
  [1] (byte) i#1 ← -- (byte) i#2 [ i#1 s#3 ]
  [2] if((byte) i#1>(byte) 0) goto @2 [ i#1 s#3 ]
  to:@END
@END: from @1
@2: from @1
  [3] if((byte) i#1>(byte) 50) goto @4 [ i#1 s#3 ]
  to:@5
@5: from @2
  [4] (byte) s#2 ← -- (byte) s#3 [ i#1 s#2 ]
  [5] (byte~) i#7 ← (byte) i#1 [ i#7 s#2 ]
  [6] (byte~) s#8 ← (byte) s#2 [ i#7 s#8 ]
  to:@1
@4: from @2
  [7] (byte) s#1 ← ++ (byte) s#3 [ i#1 s#1 ]
  [8] (byte~) i#6 ← (byte) i#1 [ i#6 s#1 ]
  [9] (byte~) s#7 ← (byte) s#1 [ i#6 s#7 ]
  to:@1

Created 2 initial phi equivalence classes
Coalesced [5] i#7 ← i#1
Coalesced [6] s#8 ← s#2
Coalesced (already) [8] i#6 ← i#1
Coalesced [9] s#7 ← s#1
Coalesced down to 2 phi equivalence classes
Block Sequence Planned @BEGIN @1 @END @2 @5 @4 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@BEGIN: from
  to:@1
@1: from @4 @5 @BEGIN
  [0] (byte) s#3 ← phi( @4/(byte) s#1 @5/(byte) s#2 @BEGIN/(byte) 0 ) [ i#2 s#3 ]
  [0] (byte) i#2 ← phi( @4/(byte) i#1 @5/(byte) i#1 @BEGIN/(byte) 100 ) [ i#2 s#3 ]
  [1] (byte) i#1 ← -- (byte) i#2 [ i#1 s#3 ]
  [2] if((byte) i#1>(byte) 0) goto @2 [ i#1 s#3 ]
  to:@END
@END: from @1
@2: from @1
  [3] if((byte) i#1>(byte) 50) goto @4 [ i#1 s#3 ]
  to:@5
@5: from @2
  [4] (byte) s#2 ← -- (byte) s#3 [ i#1 s#2 ]
  to:@1
@4: from @2
  [5] (byte) s#1 ← ++ (byte) s#3 [ i#1 s#1 ]
  to:@1

CALL GRAPH

DOMINATORS
@BEGIN dominated by  @BEGIN 
@1 dominated by  @1 @BEGIN 
@END dominated by  @1 @BEGIN @END 
@2 dominated by  @1 @BEGIN @2 
@5 dominated by  @1 @BEGIN @2 @5 
@4 dominated by  @1 @BEGIN @2 @4 

Found back edge: Loop head: @1 tails: @5 blocks: null
Found back edge: Loop head: @1 tails: @4 blocks: null
Populated: Loop head: @1 tails: @5 blocks: @5 @2 @1 
Populated: Loop head: @1 tails: @4 blocks: @4 @2 @1 
Coalesced: Loop head: @1 tails: @5 @4 blocks: @5 @2 @1 @4 
NATURAL LOOPS
Loop head: @1 tails: @5 @4 blocks: @5 @2 @1 @4 

Found 1 loops in scope []
  Loop head: @1 tails: @5 @4 blocks: @5 @2 @1 @4 
NATURAL LOOPS WITH DEPTH
Loop head: @1 tails: @5 @4 blocks: @5 @2 @1 @4  depth: 1

Initial phi equivalence classes
[ i#2 i#1 ]
[ s#3 s#1 s#2 ]
Copy Coalesced equivalence classes
[ i#2 i#1 ]
[ s#3 s#1 s#2 ]
Complete equivalence classes
[ i#2 i#1 ]
[ s#3 s#1 s#2 ]
Allocated zp byte:2 to [ i#2 i#1 ]
Allocated zp byte:3 to [ s#3 s#1 s#2 ]
INITIAL ASM
BBEGIN:
B1_from_BBEGIN:
  // (byte) s#3 = (byte) 0  // zpby1=coby1
  lda #0
  sta 3
  // (byte) i#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 2
  jmp B1
B1:
  // [1] (byte) i#1 ← -- (byte) i#2 [ i#1 s#3 ]  //  zpby1=_dec_zpby1
  dec 2
  // [2] if((byte) i#1>(byte) 0) goto @2 [ i#1 s#3 ]  //  zpby1_gt_0_then_la1
  lda 2
  bne B2
  jmp BEND
BEND:
B2:
  // [3] if((byte) i#1>(byte) 50) goto @4 [ i#1 s#3 ]  //  zpby1_gt_coby1_then_la1
  lda 2
  cmp #50
  beq !+
  bcs B4
!:
  jmp B5
B5:
  // [4] (byte) s#2 ← -- (byte) s#3 [ i#1 s#2 ]  //  zpby1=_dec_zpby1
  dec 3
B1_from_B5:
  // (byte) s#3 = (byte) s#2  // register copy 
  // (byte) i#2 = (byte) i#1  // register copy 
  jmp B1
B4:
  // [5] (byte) s#1 ← ++ (byte) s#3 [ i#1 s#1 ]  //  zpby1=_inc_zpby1
  inc 3
B1_from_B4:
  // (byte) s#3 = (byte) s#1  // register copy 
  // (byte) i#2 = (byte) i#1  // register copy 
  jmp B1

Removing instruction jmp B1
Removing instruction jmp BEND
Removing instruction jmp B5
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
BBEGIN:
B1_from_BBEGIN:
  // (byte) s#3 = (byte) 0  // zpby1=coby1
  lda #0
  sta 3
  // (byte) i#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 2
B1:
  // [1] (byte) i#1 ← -- (byte) i#2 [ i#1 s#3 ]  //  zpby1=_dec_zpby1
  dec 2
  // [2] if((byte) i#1>(byte) 0) goto @2 [ i#1 s#3 ]  //  zpby1_gt_0_then_la1
  lda 2
  bne B2
BEND:
B2:
  // [3] if((byte) i#1>(byte) 50) goto @4 [ i#1 s#3 ]  //  zpby1_gt_coby1_then_la1
  lda 2
  cmp #50
  beq !+
  bcs B4
!:
B5:
  // [4] (byte) s#2 ← -- (byte) s#3 [ i#1 s#2 ]  //  zpby1=_dec_zpby1
  dec 3
B1_from_B5:
  // (byte) s#3 = (byte) s#2  // register copy 
  // (byte) i#2 = (byte) i#1  // register copy 
  jmp B1
B4:
  // [5] (byte) s#1 ← ++ (byte) s#3 [ i#1 s#1 ]  //  zpby1=_inc_zpby1
  inc 3
B1_from_B4:
  // (byte) s#3 = (byte) s#1  // register copy 
  // (byte) i#2 = (byte) i#1  // register copy 
  jmp B1

Removing instruction bne B2
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
BBEGIN:
B1_from_BBEGIN:
  // (byte) s#3 = (byte) 0  // zpby1=coby1
  lda #0
  sta 3
  // (byte) i#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 2
B1:
  // [1] (byte) i#1 ← -- (byte) i#2 [ i#1 s#3 ]  //  zpby1=_dec_zpby1
  dec 2
  // [2] if((byte) i#1>(byte) 0) goto @2 [ i#1 s#3 ]  //  zpby1_gt_0_then_la1
  lda 2
BEND:
B2:
  // [3] if((byte) i#1>(byte) 50) goto @4 [ i#1 s#3 ]  //  zpby1_gt_coby1_then_la1
  lda 2
  cmp #50
  beq !+
  bcs B4
!:
B5:
  // [4] (byte) s#2 ← -- (byte) s#3 [ i#1 s#2 ]  //  zpby1=_dec_zpby1
  dec 3
B1_from_B5:
  // (byte) s#3 = (byte) s#2  // register copy 
  // (byte) i#2 = (byte) i#1  // register copy 
  jmp B1
B4:
  // [5] (byte) s#1 ← ++ (byte) s#3 [ i#1 s#1 ]  //  zpby1=_inc_zpby1
  inc 3
B1_from_B4:
  // (byte) s#3 = (byte) s#1  // register copy 
  // (byte) i#2 = (byte) i#1  // register copy 
  jmp B1

FINAL SYMBOL TABLE
(label) @1
(label) @2
(label) @4
(label) @5
(label) @BEGIN
(label) @END
(byte) i
(byte) i#1 zp byte:2
(byte) i#2 zp byte:2
(byte) s
(byte) s#1 zp byte:3
(byte) s#2 zp byte:3
(byte) s#3 zp byte:3

FINAL CODE
BBEGIN:
B1_from_BBEGIN:
  // (byte) s#3 = (byte) 0  // zpby1=coby1
  lda #0
  sta 3
  // (byte) i#2 = (byte) 100  // zpby1=coby1
  lda #100
  sta 2
B1:
  // [1] (byte) i#1 ← -- (byte) i#2 [ i#1 s#3 ]  //  zpby1=_dec_zpby1
  dec 2
  // [2] if((byte) i#1>(byte) 0) goto @2 [ i#1 s#3 ]  //  zpby1_gt_0_then_la1
  lda 2
BEND:
B2:
  // [3] if((byte) i#1>(byte) 50) goto @4 [ i#1 s#3 ]  //  zpby1_gt_coby1_then_la1
  lda 2
  cmp #50
  beq !+
  bcs B4
!:
B5:
  // [4] (byte) s#2 ← -- (byte) s#3 [ i#1 s#2 ]  //  zpby1=_dec_zpby1
  dec 3
B1_from_B5:
  // (byte) s#3 = (byte) s#2  // register copy 
  // (byte) i#2 = (byte) i#1  // register copy 
  jmp B1
B4:
  // [5] (byte) s#1 ← ++ (byte) s#3 [ i#1 s#1 ]  //  zpby1=_inc_zpby1
  inc 3
B1_from_B4:
  // (byte) s#3 = (byte) s#1  // register copy 
  // (byte) i#2 = (byte) i#1  // register copy 
  jmp B1

