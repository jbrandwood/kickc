Identified constant variable (byte*) screen1

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) screen#0 ← ((byte*)) (word/signed word/dword/signed dword) $400
  (byte*) screen1#0 ← ((byte*)) (word/signed word/dword/signed dword) $400
  (word/signed word/dword/signed dword~) $0 ← (word/signed word/dword/signed dword) $400 + (byte/signed byte/word/signed word/dword/signed dword) $28
  (byte*) screen2#0 ← ((byte*)) (word/signed word/dword/signed dword~) $0
  to:@2
main: scope:[main]  from @2
  (byte*) screen2#2 ← phi( @2/(byte*) screen2#3 )
  (byte*) screen#1 ← phi( @2/(byte*) screen#4 )
  (byte**~) main::$0 ← & (byte*) screen#1
  (byte**) setscreen::screen#0 ← (byte**~) main::$0
  (byte*) setscreen::val#0 ← (byte*) screen1#0
  call setscreen 
  to:main::@1
main::@1: scope:[main]  from main
  (byte*) screen2#1 ← phi( main/(byte*) screen2#2 )
  (byte*) screen#2 ← phi( main/(byte*) screen#1 )
  *((byte*) screen#2 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a'
  (byte**~) main::$2 ← & (byte*) screen#2
  (byte**) setscreen::screen#1 ← (byte**~) main::$2
  (byte*) setscreen::val#1 ← (byte*) screen2#1
  call setscreen 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte*) screen#3 ← phi( main::@1/(byte*) screen#2 )
  *((byte*) screen#3 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a'
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
setscreen: scope:[setscreen]  from main main::@1
  (byte**) setscreen::screen#2 ← phi( main/(byte**) setscreen::screen#0 main::@1/(byte**) setscreen::screen#1 )
  (byte*) setscreen::val#2 ← phi( main/(byte*) setscreen::val#0 main::@1/(byte*) setscreen::val#1 )
  *((byte**) setscreen::screen#2) ← (byte*) setscreen::val#2
  to:setscreen::@return
setscreen::@return: scope:[setscreen]  from setscreen
  return 
  to:@return
@2: scope:[]  from @begin
  (byte*) screen2#3 ← phi( @begin/(byte*) screen2#0 )
  (byte*) screen#4 ← phi( @begin/(byte*) screen#0 )
  call main 
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(word/signed word/dword/signed dword~) $0
(label) @2
(label) @3
(label) @begin
(label) @end
(void()) main()
(byte**~) main::$0
(byte**~) main::$2
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) screen
(byte*) screen#0
(byte*) screen#1
(byte*) screen#2
(byte*) screen#3
(byte*) screen#4
(byte*) screen1
(byte*) screen1#0
(byte*) screen2
(byte*) screen2#0
(byte*) screen2#1
(byte*) screen2#2
(byte*) screen2#3
(void()) setscreen((byte**) setscreen::screen , (byte*) setscreen::val)
(label) setscreen::@return
(byte**) setscreen::screen
(byte**) setscreen::screen#0
(byte**) setscreen::screen#1
(byte**) setscreen::screen#2
(byte*) setscreen::val
(byte*) setscreen::val#0
(byte*) setscreen::val#1
(byte*) setscreen::val#2

Culled Empty Block (label) @3
Successful SSA optimization Pass2CullEmptyBlocks
Alias (byte**) setscreen::screen#0 = (byte**~) main::$0 
Alias (byte*) screen#1 = (byte*) screen#2 (byte*) screen#3 
Alias (byte*) screen2#1 = (byte*) screen2#2 
Alias (byte**) setscreen::screen#1 = (byte**~) main::$2 
Alias (byte*) screen#0 = (byte*) screen#4 
Alias (byte*) screen2#0 = (byte*) screen2#3 
Successful SSA optimization Pass2AliasElimination
Redundant Phi (byte*) screen#1 (byte*) screen#0
Redundant Phi (byte*) screen2#1 (byte*) screen2#0
Successful SSA optimization Pass2RedundantPhiElimination
Constant right-side identified [0] (byte*) screen#0 ← ((byte*)) (word/signed word/dword/signed dword) $400
Constant (const byte*) screen1#0 = ((byte*))$400
Constant (const word/signed word/dword/signed dword) $0 = $400+$28
Constant (const byte**) setscreen::screen#0 = &screen#0
Constant (const byte**) setscreen::screen#1 = &screen#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) screen2#0 = ((byte*))$0
Constant (const byte*) setscreen::val#0 = screen1#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) setscreen::val#1 = screen2#0
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings (const byte**) setscreen::screen#0
Inlining constant with var siblings (const byte**) setscreen::screen#1
Inlining constant with var siblings (const byte*) setscreen::val#0
Inlining constant with var siblings (const byte*) setscreen::val#1
Constant inlined setscreen::screen#0 = &(byte*) screen#0
Constant inlined $0 = (word/signed word/dword/signed dword) $400+(byte/signed byte/word/signed word/dword/signed dword) $28
Constant inlined setscreen::val#1 = (const byte*) screen2#0
Constant inlined setscreen::screen#1 = &(byte*) screen#0
Constant inlined setscreen::val#0 = (const byte*) screen1#0
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to setscreen:5 setscreen:7 

Created 2 initial phi equivalence classes
Coalesced down to 2 phi equivalence classes
Renumbering block @2 to @1
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] (byte*) screen#0 ← ((byte*))(word/signed word/dword/signed dword) $400
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  [5] call setscreen 
  to:main::@1
main::@1: scope:[main]  from main
  [6] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a'
  [7] call setscreen 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a'
  to:main::@return
main::@return: scope:[main]  from main::@2
  [9] return 
  to:@return
setscreen: scope:[setscreen]  from main main::@1
  [10] (byte**) setscreen::screen#2 ← phi( main/&(byte*) screen#0 main::@1/&(byte*) screen#0 )
  [10] (byte*) setscreen::val#2 ← phi( main/(const byte*) screen1#0 main::@1/(const byte*) screen2#0 )
  [11] *((byte**) setscreen::screen#2) ← (byte*) setscreen::val#2
  to:setscreen::@return
setscreen::@return: scope:[setscreen]  from setscreen
  [12] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) main()
(byte*) screen
(byte*) screen#0 0.6666666666666666
(byte*) screen1
(byte*) screen2
(void()) setscreen((byte**) setscreen::screen , (byte*) setscreen::val)
(byte**) setscreen::screen
(byte**) setscreen::screen#2 2.0
(byte*) setscreen::val
(byte*) setscreen::val#2 2.0

Initial phi equivalence classes
[ setscreen::val#2 ]
[ setscreen::screen#2 ]
Added variable screen#0 to zero page equivalence class [ screen#0 ]
Complete equivalence classes
[ setscreen::val#2 ]
[ setscreen::screen#2 ]
[ screen#0 ]
Allocated zp ZP_WORD:2 [ setscreen::val#2 ]
Allocated zp ZP_WORD:4 [ setscreen::screen#2 ]
Allocated zp ZP_WORD:6 [ screen#0 ]

INITIAL ASM
//SEG0 File Comments
// Tests pointer to pointer in a more complex setup
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label screen1 = $400
  .label screen2 = $400+$28
  .label screen = 6
//SEG3 @begin
bbegin:
//SEG4 [0] (byte*) screen#0 ← ((byte*))(word/signed word/dword/signed dword) $400 -- pbuz1=pbuc1 
  lda #<$400
  sta screen
  lda #>$400
  sta screen+1
//SEG5 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG6 @1
b1:
//SEG7 [2] call main 
//SEG8 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG9 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG10 @end
bend:
//SEG11 main
main: {
  //SEG12 [5] call setscreen 
  //SEG13 [10] phi from main to setscreen [phi:main->setscreen]
  setscreen_from_main:
  //SEG14 [10] phi (byte**) setscreen::screen#2 = &(byte*) screen#0 [phi:main->setscreen#0] -- pptz1=pptc1 
    lda #<screen
    sta setscreen.screen
    lda #>screen
    sta setscreen.screen+1
  //SEG15 [10] phi (byte*) setscreen::val#2 = (const byte*) screen1#0 [phi:main->setscreen#1] -- pbuz1=pbuc1 
    lda #<screen1
    sta setscreen.val
    lda #>screen1
    sta setscreen.val+1
    jsr setscreen
    jmp b1
  //SEG16 main::@1
  b1:
  //SEG17 [6] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'a'
    ldy #0
    sta (screen),y
  //SEG18 [7] call setscreen 
  //SEG19 [10] phi from main::@1 to setscreen [phi:main::@1->setscreen]
  setscreen_from_b1:
  //SEG20 [10] phi (byte**) setscreen::screen#2 = &(byte*) screen#0 [phi:main::@1->setscreen#0] -- pptz1=pptc1 
    lda #<screen
    sta setscreen.screen
    lda #>screen
    sta setscreen.screen+1
  //SEG21 [10] phi (byte*) setscreen::val#2 = (const byte*) screen2#0 [phi:main::@1->setscreen#1] -- pbuz1=pbuc1 
    lda #<screen2
    sta setscreen.val
    lda #>screen2
    sta setscreen.val+1
    jsr setscreen
    jmp b2
  //SEG22 main::@2
  b2:
  //SEG23 [8] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'a'
    ldy #0
    sta (screen),y
    jmp breturn
  //SEG24 main::@return
  breturn:
  //SEG25 [9] return 
    rts
}
//SEG26 setscreen
// setscreen(byte** zeropage(4) screen, byte* zeropage(2) val)
setscreen: {
    .label val = 2
    .label screen = 4
  //SEG27 [11] *((byte**) setscreen::screen#2) ← (byte*) setscreen::val#2 -- _deref_pptz1=pbuz2 
    ldy #0
    lda val
    sta (screen),y
    iny
    lda val+1
    sta (screen),y
    jmp breturn
  //SEG28 setscreen::@return
  breturn:
  //SEG29 [12] return 
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] (byte*) screen#0 ← ((byte*))(word/signed word/dword/signed dword) $400 [ screen#0 ] ( ) always clobbers reg byte a 
Statement [6] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a' [ screen#0 ] ( main:2 [ screen#0 ] ) always clobbers reg byte a reg byte y 
Statement [8] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a' [ ] ( main:2 [ ] ) always clobbers reg byte a reg byte y 
Statement [11] *((byte**) setscreen::screen#2) ← (byte*) setscreen::val#2 [ screen#0 ] ( main:2::setscreen:5 [ screen#0 ] main:2::setscreen:7 [ screen#0 ] ) always clobbers reg byte a reg byte y 
Potential registers zp ZP_WORD:2 [ setscreen::val#2 ] : zp ZP_WORD:2 , 
Potential registers zp ZP_WORD:4 [ setscreen::screen#2 ] : zp ZP_WORD:4 , 
Potential registers zp ZP_WORD:6 [ screen#0 ] : zp ZP_WORD:6 , 

REGISTER UPLIFT SCOPES
Uplift Scope [setscreen] 2: zp ZP_WORD:2 [ setscreen::val#2 ] 2: zp ZP_WORD:4 [ setscreen::screen#2 ] 
Uplift Scope [] 0.67: zp ZP_WORD:6 [ screen#0 ] 
Uplift Scope [main] 

Uplifting [setscreen] best 140 combination zp ZP_WORD:2 [ setscreen::val#2 ] zp ZP_WORD:4 [ setscreen::screen#2 ] 
Uplifting [] best 140 combination zp ZP_WORD:6 [ screen#0 ] 
Uplifting [main] best 140 combination 

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Tests pointer to pointer in a more complex setup
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label screen1 = $400
  .label screen2 = $400+$28
  .label screen = 6
//SEG3 @begin
bbegin:
//SEG4 [0] (byte*) screen#0 ← ((byte*))(word/signed word/dword/signed dword) $400 -- pbuz1=pbuc1 
  lda #<$400
  sta screen
  lda #>$400
  sta screen+1
//SEG5 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG6 @1
b1:
//SEG7 [2] call main 
//SEG8 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG9 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG10 @end
bend:
//SEG11 main
main: {
  //SEG12 [5] call setscreen 
  //SEG13 [10] phi from main to setscreen [phi:main->setscreen]
  setscreen_from_main:
  //SEG14 [10] phi (byte**) setscreen::screen#2 = &(byte*) screen#0 [phi:main->setscreen#0] -- pptz1=pptc1 
    lda #<screen
    sta setscreen.screen
    lda #>screen
    sta setscreen.screen+1
  //SEG15 [10] phi (byte*) setscreen::val#2 = (const byte*) screen1#0 [phi:main->setscreen#1] -- pbuz1=pbuc1 
    lda #<screen1
    sta setscreen.val
    lda #>screen1
    sta setscreen.val+1
    jsr setscreen
    jmp b1
  //SEG16 main::@1
  b1:
  //SEG17 [6] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'a'
    ldy #0
    sta (screen),y
  //SEG18 [7] call setscreen 
  //SEG19 [10] phi from main::@1 to setscreen [phi:main::@1->setscreen]
  setscreen_from_b1:
  //SEG20 [10] phi (byte**) setscreen::screen#2 = &(byte*) screen#0 [phi:main::@1->setscreen#0] -- pptz1=pptc1 
    lda #<screen
    sta setscreen.screen
    lda #>screen
    sta setscreen.screen+1
  //SEG21 [10] phi (byte*) setscreen::val#2 = (const byte*) screen2#0 [phi:main::@1->setscreen#1] -- pbuz1=pbuc1 
    lda #<screen2
    sta setscreen.val
    lda #>screen2
    sta setscreen.val+1
    jsr setscreen
    jmp b2
  //SEG22 main::@2
  b2:
  //SEG23 [8] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'a'
    ldy #0
    sta (screen),y
    jmp breturn
  //SEG24 main::@return
  breturn:
  //SEG25 [9] return 
    rts
}
//SEG26 setscreen
// setscreen(byte** zeropage(4) screen, byte* zeropage(2) val)
setscreen: {
    .label val = 2
    .label screen = 4
  //SEG27 [11] *((byte**) setscreen::screen#2) ← (byte*) setscreen::val#2 -- _deref_pptz1=pbuz2 
    ldy #0
    lda val
    sta (screen),y
    iny
    lda val+1
    sta (screen),y
    jmp breturn
  //SEG28 setscreen::@return
  breturn:
  //SEG29 [12] return 
    rts
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction b1_from_bbegin:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b1:
Removing instruction bend:
Removing instruction setscreen_from_main:
Removing instruction b1:
Removing instruction setscreen_from_b1:
Removing instruction b2:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) screen
(byte*) screen#0 screen zp ZP_WORD:6 0.6666666666666666
(byte*) screen1
(const byte*) screen1#0 screen1 = ((byte*))(word/signed word/dword/signed dword) $400
(byte*) screen2
(const byte*) screen2#0 screen2 = ((byte*))(word/signed word/dword/signed dword) $400+(byte/signed byte/word/signed word/dword/signed dword) $28
(void()) setscreen((byte**) setscreen::screen , (byte*) setscreen::val)
(label) setscreen::@return
(byte**) setscreen::screen
(byte**) setscreen::screen#2 screen zp ZP_WORD:4 2.0
(byte*) setscreen::val
(byte*) setscreen::val#2 val zp ZP_WORD:2 2.0

zp ZP_WORD:2 [ setscreen::val#2 ]
zp ZP_WORD:4 [ setscreen::screen#2 ]
zp ZP_WORD:6 [ screen#0 ]


FINAL ASSEMBLER
Score: 128

//SEG0 File Comments
// Tests pointer to pointer in a more complex setup
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label screen1 = $400
  .label screen2 = $400+$28
  .label screen = 6
//SEG3 @begin
bbegin:
//SEG4 [0] (byte*) screen#0 ← ((byte*))(word/signed word/dword/signed dword) $400 -- pbuz1=pbuc1 
  lda #<$400
  sta screen
  lda #>$400
  sta screen+1
//SEG5 [1] phi from @begin to @1 [phi:@begin->@1]
//SEG6 @1
//SEG7 [2] call main 
//SEG8 [4] phi from @1 to main [phi:@1->main]
  jsr main
  rts
//SEG9 [3] phi from @1 to @end [phi:@1->@end]
//SEG10 @end
//SEG11 main
main: {
  //SEG12 [5] call setscreen 
  //SEG13 [10] phi from main to setscreen [phi:main->setscreen]
  //SEG14 [10] phi (byte**) setscreen::screen#2 = &(byte*) screen#0 [phi:main->setscreen#0] -- pptz1=pptc1 
    lda #<screen
    sta setscreen.screen
    lda #>screen
    sta setscreen.screen+1
  //SEG15 [10] phi (byte*) setscreen::val#2 = (const byte*) screen1#0 [phi:main->setscreen#1] -- pbuz1=pbuc1 
    lda #<screen1
    sta setscreen.val
    lda #>screen1
    sta setscreen.val+1
    jsr setscreen
  //SEG16 main::@1
  //SEG17 [6] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'a'
    ldy #0
    sta (screen),y
  //SEG18 [7] call setscreen 
  //SEG19 [10] phi from main::@1 to setscreen [phi:main::@1->setscreen]
  //SEG20 [10] phi (byte**) setscreen::screen#2 = &(byte*) screen#0 [phi:main::@1->setscreen#0] -- pptz1=pptc1 
    lda #<screen
    sta setscreen.screen
    lda #>screen
    sta setscreen.screen+1
  //SEG21 [10] phi (byte*) setscreen::val#2 = (const byte*) screen2#0 [phi:main::@1->setscreen#1] -- pbuz1=pbuc1 
    lda #<screen2
    sta setscreen.val
    lda #>screen2
    sta setscreen.val+1
    jsr setscreen
  //SEG22 main::@2
  //SEG23 [8] *((byte*) screen#0 + (byte/signed byte/word/signed word/dword/signed dword) 0) ← (byte) 'a' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'a'
    ldy #0
    sta (screen),y
  //SEG24 main::@return
  //SEG25 [9] return 
    rts
}
//SEG26 setscreen
// setscreen(byte** zeropage(4) screen, byte* zeropage(2) val)
setscreen: {
    .label val = 2
    .label screen = 4
  //SEG27 [11] *((byte**) setscreen::screen#2) ← (byte*) setscreen::val#2 -- _deref_pptz1=pbuz2 
    ldy #0
    lda val
    sta (screen),y
    iny
    lda val+1
    sta (screen),y
  //SEG28 setscreen::@return
  //SEG29 [12] return 
    rts
}

