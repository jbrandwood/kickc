
(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call init_screen 
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [2] (byte*) main::at#4 ← phi( main/(byte*) 1024+(byte) 4 main::@5/(byte*) main::at#1 )
  [2] (byte) main::k#2 ← phi( main/(byte) 0 main::@5/(byte) main::k#1 )
  [3] (signed byte) print_schar_at::b#1 ← *((const signed byte*) vals + (byte) main::k#2)
  [4] (byte*) print_schar_at::at#0 ← (byte*) main::at#4
  [5] call print_schar_at 
  to:main::@5
main::@5: scope:[main]  from main::@1
  [6] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4
  [7] (byte) main::k#1 ← ++ (byte) main::k#2
  [8] if((byte) main::k#1!=(byte) 9) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@4 main::@5
  [9] (byte) main::i#2 ← phi( main::@5/(byte) 0 main::@4/(byte) main::i#1 )
  [9] (byte*) main::at_line#2 ← phi( main::@5/(byte*) 1024 main::@4/(byte*) main::at#2 )
  [10] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28
  [11] (signed byte) print_schar_at::b#2 ← *((const signed byte*) vals + (byte) main::i#2)
  [12] (byte*) print_schar_at::at#1 ← (byte*) main::at#2
  [13] call print_schar_at 
  to:main::@6
main::@6: scope:[main]  from main::@2
  [14] (byte*) main::at#12 ← (byte*) main::at#2
  to:main::@3
main::@3: scope:[main]  from main::@6 main::@8
  [15] (byte) main::j#2 ← phi( main::@8/(byte) main::j#1 main::@6/(byte) 0 )
  [15] (byte*) main::at#6 ← phi( main::@8/(byte*) main::at#3 main::@6/(byte*) main::at#12 )
  [16] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4
  [17] (signed byte) fmul8::a#0 ← *((const signed byte*) vals + (byte) main::i#2)
  [18] (signed byte) fmul8::b#0 ← *((const signed byte*) vals + (byte) main::j#2)
  [19] call fmul8 
  [20] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1
  to:main::@7
main::@7: scope:[main]  from main::@3
  [21] (signed byte) main::r#0 ← (signed byte) fmul8::return#0
  [22] (signed byte) print_schar_at::b#3 ← (signed byte) main::r#0
  [23] (byte*) print_schar_at::at#2 ← (byte*) main::at#3
  [24] call print_schar_at 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [25] (byte) main::j#1 ← ++ (byte) main::j#2
  [26] if((byte) main::j#1!=(byte) 9) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@8
  [27] (byte) main::i#1 ← ++ (byte) main::i#2
  [28] if((byte) main::i#1!=(byte) 9) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@4
  [29] return 
  to:@return

(void()) init_screen()
init_screen: scope:[init_screen]  from main
  [30] phi()
  [31] call print_cls 
  to:init_screen::@1
init_screen::@1: scope:[init_screen]  from init_screen init_screen::@1
  [32] (byte) init_screen::l#2 ← phi( init_screen::@1/(byte) init_screen::l#1 init_screen/(byte) 0 )
  [33] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE
  [34] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2
  [35] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1
  to:init_screen::@2
init_screen::@2: scope:[init_screen]  from init_screen::@1 init_screen::@2
  [36] (byte) init_screen::m#2 ← phi( init_screen::@1/(byte) 0 init_screen::@2/(byte) init_screen::m#1 )
  [36] (byte*) init_screen::COLS#3 ← phi( init_screen::@1/(byte*) 55296 init_screen::@2/(byte*) init_screen::COLS#1 )
  [37] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE
  [38] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE
  [39] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE
  [40] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE
  [41] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28
  [42] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2
  [43] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2
  to:init_screen::@return
init_screen::@return: scope:[init_screen]  from init_screen::@2
  [44] return 
  to:@return

(void()) print_schar_at((signed byte) print_schar_at::b , (byte*) print_schar_at::at)
print_schar_at: scope:[print_schar_at]  from main::@1 main::@2 main::@7
  [45] (byte*) print_schar_at::at#3 ← phi( main::@1/(byte*) print_schar_at::at#0 main::@2/(byte*) print_schar_at::at#1 main::@7/(byte*) print_schar_at::at#2 )
  [45] (signed byte) print_schar_at::b#4 ← phi( main::@1/(signed byte) print_schar_at::b#1 main::@2/(signed byte) print_schar_at::b#2 main::@7/(signed byte) print_schar_at::b#3 )
  [46] if((signed byte) print_schar_at::b#4<(signed byte) 0) goto print_schar_at::@1
  to:print_schar_at::@3
print_schar_at::@3: scope:[print_schar_at]  from print_schar_at
  [47] (byte*) print_char_at::at#1 ← (byte*) print_schar_at::at#3
  [48] call print_char_at 
  to:print_schar_at::@2
print_schar_at::@2: scope:[print_schar_at]  from print_schar_at::@3 print_schar_at::@4
  [49] (signed byte) print_schar_at::b#6 ← phi( print_schar_at::@4/(signed byte) print_schar_at::b#0 print_schar_at::@3/(signed byte) print_schar_at::b#4 )
  [50] (byte*) print_uchar_at::at#0 ← (byte*) print_schar_at::at#3 + (byte) 1
  [51] (byte) print_uchar_at::b#0 ← (byte)(signed byte) print_schar_at::b#6
  [52] call print_uchar_at 
  to:print_schar_at::@return
print_schar_at::@return: scope:[print_schar_at]  from print_schar_at::@2
  [53] return 
  to:@return
print_schar_at::@1: scope:[print_schar_at]  from print_schar_at
  [54] (byte*) print_char_at::at#0 ← (byte*) print_schar_at::at#3
  [55] call print_char_at 
  to:print_schar_at::@4
print_schar_at::@4: scope:[print_schar_at]  from print_schar_at::@1
  [56] (signed byte) print_schar_at::b#0 ← - (signed byte) print_schar_at::b#4
  to:print_schar_at::@2

(signed byte()) fmul8((signed byte) fmul8::a , (signed byte) fmul8::b)
fmul8: scope:[fmul8]  from main::@3
  [57] *((const signed byte*) ap) ← (signed byte) fmul8::a#0
  [58] *((const signed byte*) bp) ← (signed byte) fmul8::b#0
  asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
  [60] (signed byte) fmul8::return#1 ← *((const signed byte*) cp)
  to:fmul8::@return
fmul8::@return: scope:[fmul8]  from fmul8
  [61] return 
  to:@return

(void()) print_cls()
print_cls: scope:[print_cls]  from init_screen
  [62] phi()
  [63] call memset 
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls
  [64] return 
  to:@return

(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
print_char_at: scope:[print_char_at]  from print_schar_at::@1 print_schar_at::@3 print_uchar_at print_uchar_at::@1
  [65] (byte*) print_char_at::at#4 ← phi( print_schar_at::@1/(byte*) print_char_at::at#0 print_schar_at::@3/(byte*) print_char_at::at#1 print_uchar_at/(byte*) print_char_at::at#2 print_uchar_at::@1/(byte*) print_char_at::at#3 )
  [65] (byte) print_char_at::ch#4 ← phi( print_schar_at::@1/(byte) '-' print_schar_at::@3/(byte) ' ' print_uchar_at/(byte) print_char_at::ch#2 print_uchar_at::@1/(byte) print_char_at::ch#3 )
  [66] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  [67] return 
  to:@return

(void()) print_uchar_at((byte) print_uchar_at::b , (byte*) print_uchar_at::at)
print_uchar_at: scope:[print_uchar_at]  from print_schar_at::@2
  [68] (byte~) print_uchar_at::$0 ← (byte) print_uchar_at::b#0 >> (byte) 4
  [69] (byte) print_char_at::ch#2 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$0)
  [70] (byte*) print_char_at::at#2 ← (byte*) print_uchar_at::at#0
  [71] call print_char_at 
  to:print_uchar_at::@1
print_uchar_at::@1: scope:[print_uchar_at]  from print_uchar_at
  [72] (byte~) print_uchar_at::$2 ← (byte) print_uchar_at::b#0 & (byte) $f
  [73] (byte*) print_char_at::at#3 ← (byte*) print_uchar_at::at#0 + (byte) 1
  [74] (byte) print_char_at::ch#3 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar_at::$2)
  [75] call print_char_at 
  to:print_uchar_at::@return
print_uchar_at::@return: scope:[print_uchar_at]  from print_uchar_at::@1
  [76] return 
  to:@return

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from print_cls
  [77] phi()
  to:memset::@1
memset::@1: scope:[memset]  from memset memset::@2
  [78] (byte*) memset::dst#2 ← phi( memset/(byte*)(const void*) memset::str#0 memset::@2/(byte*) memset::dst#1 )
  [79] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset::@1
  [80] return 
  to:@return
memset::@2: scope:[memset]  from memset::@1
  [81] *((byte*) memset::dst#2) ← (const byte) memset::c#0
  [82] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  to:memset::@1
