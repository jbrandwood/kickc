
CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start
  f::a#0 = 'a'
  call f 
  f::return#0 = f::return#3
  to:main::@1
main::@1: scope:[main]  from main
  f::return#4 = phi( main/f::return#0 )
  main::$0 = f::return#4
  main::SCREEN[0] = main::$0
  f::a#1 = 'b'
  call f 
  f::return#1 = f::return#3
  to:main::@2
main::@2: scope:[main]  from main::@1
  f::return#5 = phi( main::@1/f::return#1 )
  main::$1 = f::return#5
  main::SCREEN[1] = main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return

byte f(byte f::a)
f: scope:[f]  from main main::@1
  f::a#2 = phi( main/f::a#0, main::@1/f::a#1 )
  f::$0 = f::a#2 + 1
  f::return#2 = f::$0
  to:f::@return
f::@return: scope:[f]  from f
  f::return#6 = phi( f/f::return#2 )
  f::return#3 = f::return#6
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
void __start()
byte f(byte f::a)
number~ f::$0
byte f::a
byte f::a#0
byte f::a#1
byte f::a#2
byte f::return
byte f::return#0
byte f::return#1
byte f::return#2
byte f::return#3
byte f::return#4
byte f::return#5
byte f::return#6
void main()
byte~ main::$0
byte~ main::$1
constant byte* const main::SCREEN = (byte*)$400

Adding number conversion cast (unumber) 0 in main::SCREEN[0] = main::$0
Adding number conversion cast (unumber) 1 in main::SCREEN[1] = main::$1
Adding number conversion cast (unumber) 1 in f::$0 = f::a#2 + 1
Adding number conversion cast (unumber) f::$0 in f::$0 = f::a#2 + (unumber)1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in f::$0 = f::a#2 + 1
Alias f::return#0 = f::return#4 
Alias f::return#1 = f::return#5 
Alias f::return#2 = f::$0 f::return#6 f::return#3 
Successful SSA optimization Pass2AliasElimination
Constant f::a#0 = 'a'
Constant f::a#1 = 'b'
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero main::SCREEN in [4] main::SCREEN[0] = main::$0
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings f::a#0
Inlining constant with var siblings f::a#1
Constant inlined f::a#1 = 'b'
Constant inlined f::a#0 = 'a'
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(main::SCREEN+1)
Successful SSA optimization Pass2ConstantAdditionElimination
Adding NOP phi() at start of main
CALL GRAPH
Calls in [main] to f:1 f:5 

Created 1 initial phi equivalence classes
Coalesced down to 1 phi equivalence classes
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call f 
  [2] f::return#0 = f::return#2
  to:main::@1
main::@1: scope:[main]  from main
  [3] main::$0 = f::return#0
  [4] *main::SCREEN = main::$0
  [5] call f 
  [6] f::return#1 = f::return#2
  to:main::@2
main::@2: scope:[main]  from main::@1
  [7] main::$1 = f::return#1
  [8] *(main::SCREEN+1) = main::$1
  to:main::@return
main::@return: scope:[main]  from main::@2
  [9] return 
  to:@return

byte f(byte f::a)
f: scope:[f]  from main main::@1
  [10] f::a#2 = phi( main/'a', main::@1/'b' )
  [11] f::return#2 = f::a#2 + 1
  to:f::@return
f::@return: scope:[f]  from f
  [12] return 
  to:@return


VARIABLE REGISTER WEIGHTS
byte f(byte f::a)
byte f::a
byte f::a#2 11.0
byte f::return
byte f::return#0 4.0
byte f::return#1 4.0
byte f::return#2 3.75
void main()
byte~ main::$0 4.0
byte~ main::$1 4.0

Initial phi equivalence classes
[ f::a#2 ]
Added variable f::return#0 to live range equivalence class [ f::return#0 ]
Added variable main::$0 to live range equivalence class [ main::$0 ]
Added variable f::return#1 to live range equivalence class [ f::return#1 ]
Added variable main::$1 to live range equivalence class [ main::$1 ]
Added variable f::return#2 to live range equivalence class [ f::return#2 ]
Complete equivalence classes
[ f::a#2 ]
[ f::return#0 ]
[ main::$0 ]
[ f::return#1 ]
[ main::$1 ]
[ f::return#2 ]
Allocated zp[1]:2 [ f::a#2 ]
Allocated zp[1]:3 [ f::return#0 ]
Allocated zp[1]:4 [ main::$0 ]
Allocated zp[1]:5 [ f::return#1 ]
Allocated zp[1]:6 [ main::$1 ]
Allocated zp[1]:7 [ f::return#2 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp[1]:2 [ f::a#2 ] : zp[1]:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ f::return#0 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ main::$0 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ f::return#1 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ main::$1 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ f::return#2 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [f] 11: zp[1]:2 [ f::a#2 ] 4: zp[1]:3 [ f::return#0 ] 4: zp[1]:5 [ f::return#1 ] 3.75: zp[1]:7 [ f::return#2 ] 
Uplift Scope [main] 4: zp[1]:4 [ main::$0 ] 4: zp[1]:6 [ main::$1 ] 
Uplift Scope [] 

Uplifting [f] best 64 combination reg byte a [ f::a#2 ] reg byte a [ f::return#0 ] reg byte a [ f::return#1 ] reg byte a [ f::return#2 ] 
Limited combination testing to 100 combinations of 256 possible.
Uplifting [main] best 52 combination reg byte a [ main::$0 ] reg byte a [ main::$1 ] 
Uplifting [] best 52 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Procedure Declaration
  // Upstart
  // Commodore 64 PRG executable file
.file [name="procedure-declare-0.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    .label SCREEN = $400
    // [1] call f 
    // [10] phi from main to f [phi:main->f]
  f_from_main:
    // [10] phi f::a#2 = 'a' [phi:main->f#0] -- vbuaa=vbuc1 
    lda #'a'
    jsr f
    // [2] f::return#0 = f::return#2
    jmp __b1
    // main::@1
  __b1:
    // [3] main::$0 = f::return#0
    // [4] *main::SCREEN = main::$0 -- _deref_pbuc1=vbuaa 
    sta SCREEN
    // [5] call f 
    // [10] phi from main::@1 to f [phi:main::@1->f]
  f_from___b1:
    // [10] phi f::a#2 = 'b' [phi:main::@1->f#0] -- vbuaa=vbuc1 
    lda #'b'
    jsr f
    // [6] f::return#1 = f::return#2
    jmp __b2
    // main::@2
  __b2:
    // [7] main::$1 = f::return#1
    // [8] *(main::SCREEN+1) = main::$1 -- _deref_pbuc1=vbuaa 
    sta SCREEN+1
    jmp __breturn
    // main::@return
  __breturn:
    // [9] return 
    rts
}
  // f
// f(byte register(A) a)
f: {
    // [11] f::return#2 = f::a#2 + 1 -- vbuaa=vbuaa_plus_1 
    clc
    adc #1
    jmp __breturn
    // f::@return
  __breturn:
    // [12] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction f_from_main:
Removing instruction __b1:
Removing instruction f_from___b1:
Removing instruction __b2:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
byte f(byte f::a)
byte f::a
byte f::a#2 reg byte a 11.0
byte f::return
byte f::return#0 reg byte a 4.0
byte f::return#1 reg byte a 4.0
byte f::return#2 reg byte a 3.75
void main()
byte~ main::$0 reg byte a 4.0
byte~ main::$1 reg byte a 4.0
constant byte* const main::SCREEN = (byte*) 1024

reg byte a [ f::a#2 ]
reg byte a [ f::return#0 ]
reg byte a [ main::$0 ]
reg byte a [ f::return#1 ]
reg byte a [ main::$1 ]
reg byte a [ f::return#2 ]


FINAL ASSEMBLER
Score: 40

  // File Comments
// Procedure Declaration
  // Upstart
  // Commodore 64 PRG executable file
.file [name="procedure-declare-0.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    .label SCREEN = $400
    // f('a')
    // [1] call f 
    // [10] phi from main to f [phi:main->f]
    // [10] phi f::a#2 = 'a' [phi:main->f#0] -- vbuaa=vbuc1 
    lda #'a'
    jsr f
    // f('a')
    // [2] f::return#0 = f::return#2
    // main::@1
    // [3] main::$0 = f::return#0
    // SCREEN[0] = f('a')
    // [4] *main::SCREEN = main::$0 -- _deref_pbuc1=vbuaa 
    sta SCREEN
    // f('b')
    // [5] call f 
    // [10] phi from main::@1 to f [phi:main::@1->f]
    // [10] phi f::a#2 = 'b' [phi:main::@1->f#0] -- vbuaa=vbuc1 
    lda #'b'
    jsr f
    // f('b')
    // [6] f::return#1 = f::return#2
    // main::@2
    // [7] main::$1 = f::return#1
    // SCREEN[1] = f('b')
    // [8] *(main::SCREEN+1) = main::$1 -- _deref_pbuc1=vbuaa 
    sta SCREEN+1
    // main::@return
    // }
    // [9] return 
    rts
}
  // f
// f(byte register(A) a)
f: {
    // a+1
    // [11] f::return#2 = f::a#2 + 1 -- vbuaa=vbuaa_plus_1 
    clc
    adc #1
    // f::@return
    // }
    // [12] return 
    rts
}
  // File Data

