byte cnt = 0;
byte cnt2 = 0;
byte[256] SCREEN=$0400;

main();

void main() {
  SCREEN[0]=inccnt();
  cnt++;
  SCREEN[1]=inccnt();
}

byte inccnt() {
    ++cnt;
    ++cnt2;
    return cnt;
}




Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt2 ← ++ (byte) cnt2
PROGRAM
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  proc (void()) main()
  (byte~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte~) main::$1 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
main::@return:
  return 
  endproc // main()
  proc (byte()) inccnt()
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) inccnt::return ← (byte) cnt
  goto inccnt::@return
inccnt::@return:
  (byte) inccnt::return ← (byte) inccnt::return
  return (byte) inccnt::return
  endproc // inccnt()

SYMBOLS
(void~) $0
(byte[256]) SCREEN
(byte) cnt
(byte) cnt2
(byte()) inccnt()
(label) inccnt::@return
(byte) inccnt::return
(void()) main()
(byte~) main::$0
(byte~) main::$1
(label) main::@return

INITIAL CONTROL FLOW GRAPH
@begin: from
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@1
main: from
  (byte~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte~) main::$1 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main
  return 
  to:@return
@1: from @begin
  to:@2
inccnt: from
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) inccnt::return ← (byte) cnt
  to:inccnt::@return
inccnt::@return: from inccnt inccnt::@1
  (byte) inccnt::return ← (byte) inccnt::return
  return (byte) inccnt::return
  to:@return
inccnt::@1: from
  to:inccnt::@return
@2: from @1
  to:@end
@end: from @2

Removing empty block @1
Removing empty block inccnt::@1
Removing empty block @2
CONTROL FLOW GRAPH
@begin: from
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@end
main: from
  (byte~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte~) main::$1 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main
  return 
  to:@return
inccnt: from
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) inccnt::return ← (byte) cnt
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) inccnt::return ← (byte) inccnt::return
  return (byte) inccnt::return
  to:@return
@end: from @begin

PROCEDURE MODIFY VARIABLE ANALYSIS
main modifies cnt
main modifies cnt2
inccnt modifies cnt
inccnt modifies cnt2

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: from
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  call main param-assignment
  to:@3
@3: from @begin
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  to:@end
main: from @begin
  (byte) inccnt::return ← call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte) inccnt::return ← call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  return 
  to:@return
inccnt: from main main::@1
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) inccnt::return ← (byte) cnt
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) inccnt::return ← (byte) inccnt::return
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  return (byte) inccnt::return
  to:@return
@end: from @3

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: from
  (byte) cnt#0 ← (byte) 0
  (byte) cnt2#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: from @begin
  (byte) cnt2#7 ← phi( @begin/(byte) cnt2#0 )
  (byte) cnt#8 ← phi( @begin/(byte) cnt#0 )
  (byte) cnt#1 ← (byte) cnt#8
  (byte) cnt2#1 ← (byte) cnt2#7
  to:@end
main: from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(byte[256]) SCREEN#0 )
  (byte) cnt2#13 ← phi( @begin/(byte) cnt2#0 )
  (byte) cnt#14 ← phi( @begin/(byte) cnt#0 )
  (byte) inccnt::return#0 ← call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt2#8 ← phi( main/(byte) cnt2#13 )
  (byte) cnt#9 ← phi( main/(byte) cnt#14 )
  (byte) inccnt::return#4 ← phi( main/(byte) inccnt::return#0 )
  (byte~) main::$0 ← (byte) inccnt::return#4
  (byte) cnt#2 ← (byte) cnt#9
  (byte) cnt2#2 ← (byte) cnt2#8
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#2
  (byte) inccnt::return#1 ← call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt2#9 ← phi( main::@1/(byte) cnt2#2 )
  (byte) cnt#10 ← phi( main::@1/(byte) cnt#3 )
  (byte) inccnt::return#5 ← phi( main::@1/(byte) inccnt::return#1 )
  (byte~) main::$1 ← (byte) inccnt::return#5
  (byte) cnt#4 ← (byte) cnt#10
  (byte) cnt2#3 ← (byte) cnt2#9
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  (byte) cnt2#10 ← phi( main::@2/(byte) cnt2#3 )
  (byte) cnt#11 ← phi( main::@2/(byte) cnt#4 )
  (byte) cnt#5 ← (byte) cnt#11
  (byte) cnt2#4 ← (byte) cnt2#10
  return 
  to:@return
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#2 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#6 ← ++ (byte) cnt#12
  (byte) cnt2#5 ← ++ (byte) cnt2#11
  (byte) inccnt::return#2 ← (byte) cnt#6
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) cnt2#12 ← phi( inccnt/(byte) cnt2#5 )
  (byte) cnt#13 ← phi( inccnt/(byte) cnt#6 )
  (byte) inccnt::return#6 ← phi( inccnt/(byte) inccnt::return#2 )
  (byte) inccnt::return#3 ← (byte) inccnt::return#6
  (byte) cnt#7 ← (byte) cnt#13
  (byte) cnt2#6 ← (byte) cnt2#12
  return (byte) inccnt::return#3
  to:@return
@end: from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: from
  (byte) cnt#0 ← (byte) 0
  (byte) cnt2#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: from @begin
  (byte) cnt2#7 ← phi( @begin/(byte) cnt2#4 )
  (byte) cnt#8 ← phi( @begin/(byte) cnt#5 )
  (byte) cnt#1 ← (byte) cnt#8
  (byte) cnt2#1 ← (byte) cnt2#7
  to:@end
main: from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(byte[256]) SCREEN#0 )
  (byte) cnt2#13 ← phi( @begin/(byte) cnt2#0 )
  (byte) cnt#14 ← phi( @begin/(byte) cnt#0 )
  call inccnt param-assignment
  (byte) inccnt::return#0 ← (byte) inccnt::return#3
  to:main::@1
main::@1: from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt2#8 ← phi( main/(byte) cnt2#6 )
  (byte) cnt#9 ← phi( main/(byte) cnt#7 )
  (byte) inccnt::return#4 ← phi( main/(byte) inccnt::return#0 )
  (byte~) main::$0 ← (byte) inccnt::return#4
  (byte) cnt#2 ← (byte) cnt#9
  (byte) cnt2#2 ← (byte) cnt2#8
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  (byte) inccnt::return#1 ← (byte) inccnt::return#3
  to:main::@2
main::@2: from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt2#9 ← phi( main::@1/(byte) cnt2#6 )
  (byte) cnt#10 ← phi( main::@1/(byte) cnt#7 )
  (byte) inccnt::return#5 ← phi( main::@1/(byte) inccnt::return#1 )
  (byte~) main::$1 ← (byte) inccnt::return#5
  (byte) cnt#4 ← (byte) cnt#10
  (byte) cnt2#3 ← (byte) cnt2#9
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  (byte) cnt2#10 ← phi( main::@2/(byte) cnt2#3 )
  (byte) cnt#11 ← phi( main::@2/(byte) cnt#4 )
  (byte) cnt#5 ← (byte) cnt#11
  (byte) cnt2#4 ← (byte) cnt2#10
  return 
  to:@return
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#2 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#6 ← ++ (byte) cnt#12
  (byte) cnt2#5 ← ++ (byte) cnt2#11
  (byte) inccnt::return#2 ← (byte) cnt#6
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) cnt2#12 ← phi( inccnt/(byte) cnt2#5 )
  (byte) cnt#13 ← phi( inccnt/(byte) cnt#6 )
  (byte) inccnt::return#6 ← phi( inccnt/(byte) inccnt::return#2 )
  (byte) inccnt::return#3 ← (byte) inccnt::return#6
  (byte) cnt#7 ← (byte) cnt#13
  (byte) cnt2#6 ← (byte) cnt2#12
  return 
  to:@return
@end: from @3

Constant (byte) cnt#0 (byte) 0
Constant (byte) cnt2#0 (byte) 0
Constant (byte[256]) SCREEN#0 (word) 1024
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@begin: from
  call main param-assignment
  to:@3
@3: from @begin
  (byte) cnt2#7 ← phi( @begin/(byte) cnt2#4 )
  (byte) cnt#8 ← phi( @begin/(byte) cnt#5 )
  (byte) cnt#1 ← (byte) cnt#8
  (byte) cnt2#1 ← (byte) cnt2#7
  to:@end
main: from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(word) 1024 )
  (byte) cnt2#13 ← phi( @begin/(byte) 0 )
  (byte) cnt#14 ← phi( @begin/(byte) 0 )
  call inccnt param-assignment
  (byte) inccnt::return#0 ← (byte) inccnt::return#3
  to:main::@1
main::@1: from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt2#8 ← phi( main/(byte) cnt2#6 )
  (byte) cnt#9 ← phi( main/(byte) cnt#7 )
  (byte) inccnt::return#4 ← phi( main/(byte) inccnt::return#0 )
  (byte~) main::$0 ← (byte) inccnt::return#4
  (byte) cnt#2 ← (byte) cnt#9
  (byte) cnt2#2 ← (byte) cnt2#8
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  (byte) inccnt::return#1 ← (byte) inccnt::return#3
  to:main::@2
main::@2: from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt2#9 ← phi( main::@1/(byte) cnt2#6 )
  (byte) cnt#10 ← phi( main::@1/(byte) cnt#7 )
  (byte) inccnt::return#5 ← phi( main::@1/(byte) inccnt::return#1 )
  (byte~) main::$1 ← (byte) inccnt::return#5
  (byte) cnt#4 ← (byte) cnt#10
  (byte) cnt2#3 ← (byte) cnt2#9
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  (byte) cnt2#10 ← phi( main::@2/(byte) cnt2#3 )
  (byte) cnt#11 ← phi( main::@2/(byte) cnt#4 )
  (byte) cnt#5 ← (byte) cnt#11
  (byte) cnt2#4 ← (byte) cnt2#10
  return 
  to:@return
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#2 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#6 ← ++ (byte) cnt#12
  (byte) cnt2#5 ← ++ (byte) cnt2#11
  (byte) inccnt::return#2 ← (byte) cnt#6
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) cnt2#12 ← phi( inccnt/(byte) cnt2#5 )
  (byte) cnt#13 ← phi( inccnt/(byte) cnt#6 )
  (byte) inccnt::return#6 ← phi( inccnt/(byte) inccnt::return#2 )
  (byte) inccnt::return#3 ← (byte) inccnt::return#6
  (byte) cnt#7 ← (byte) cnt#13
  (byte) cnt2#6 ← (byte) cnt2#12
  return 
  to:@return
@end: from @3

Not aliassing across scopes: main::$0 inccnt::return#4
Not aliassing across scopes: main::$1 inccnt::return#5
Not aliassing across scopes: inccnt::return#2 cnt#6
Alias (byte) cnt#1 = (byte) cnt#8 (byte) cnt#5 (byte) cnt#9 (byte) cnt#7 (byte) cnt#2 (byte) cnt#10 (byte) cnt#4 (byte) cnt#11 (byte) cnt#13 (byte) cnt#6 
Alias (byte) cnt2#1 = (byte) cnt2#7 (byte) cnt2#4 (byte) cnt2#8 (byte) cnt2#6 (byte) cnt2#2 (byte) cnt2#9 (byte) cnt2#3 (byte) cnt2#10 (byte) cnt2#12 (byte) cnt2#5 
Alias (byte) inccnt::return#0 = (byte) inccnt::return#3 (byte) inccnt::return#4 (byte) inccnt::return#1 (byte) inccnt::return#5 (byte) inccnt::return#6 (byte) inccnt::return#2 
Alias (byte[256]) SCREEN#1 = (byte[256]) SCREEN#3 (byte[256]) SCREEN#2 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: from
  call main param-assignment
  to:@3
@3: from @begin
  to:@end
main: from @begin
  (byte[256]) SCREEN#1 ← phi( @begin/(word) 1024 )
  (byte) cnt2#13 ← phi( @begin/(byte) 0 )
  (byte) cnt#14 ← phi( @begin/(byte) 0 )
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((byte[256]) SCREEN#1 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@return
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@return
@end: from @3

Redundant Phi (byte) cnt#14 (byte) 0
Redundant Phi (byte) cnt2#13 (byte) 0
Redundant Phi (byte[256]) SCREEN#1 (word) 1024
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@begin: from
  call main param-assignment
  to:@3
@3: from @begin
  to:@end
main: from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@return
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@return
@end: from @3

Culled Empty Block (label) @3
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: from
  call main param-assignment
  to:@end
main: from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@return
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@return
@end: from @begin

Consolidated assigned array index constant in assignment *(1024)
Consolidated assigned array index constant in assignment *(1025)
Succesful SSA optimization Pass2ConstantAdditionElimination
CONTROL FLOW GRAPH
@begin: from
  call main param-assignment
  to:@end
main: from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1025) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@return
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@return
@end: from @begin

Not aliassing across scopes: main::$0 inccnt::return#0
Not aliassing across scopes: main::$1 inccnt::return#0
Not aliassing across scopes: inccnt::return#0 cnt#1
Not aliassing across scopes: main::$0 inccnt::return#0
Not aliassing across scopes: main::$1 inccnt::return#0
Not aliassing across scopes: inccnt::return#0 cnt#1
Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: from
  call main param-assignment
  to:@end
@end: from @begin
main: from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  (byte~) cnt#15 ← (byte) cnt#3
  (byte~) cnt2#14 ← (byte) cnt2#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1025) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@return
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte~) cnt2#14 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte~) cnt#15 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@return

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@begin: from
  [0] call main param-assignment [ ]
  to:@end
@end: from @begin
main: from @begin
  [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:main::@1
main::@1: from main
  [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ]
  [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ]
  [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ]
  [5] (byte~) cnt#15 ← (byte) cnt#3 [ cnt2#1 cnt#15 ]
  [6] (byte~) cnt2#14 ← (byte) cnt2#1 [ cnt#15 cnt2#14 ]
  [7] call inccnt param-assignment [ inccnt::return#0 ]
  to:main::@2
main::@2: from main::@1
  [8] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
  [9] *((word) 1025) ← (byte~) main::$1 [ ]
  to:main::@return
main::@return: from main::@2
  [10] return  [ ]
  to:@return
inccnt: from main main::@1
  [11] (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte~) cnt2#14 ) [ cnt#12 cnt2#11 ]
  [11] (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte~) cnt#15 ) [ cnt#12 cnt2#11 ]
  [12] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ]
  [13] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ]
  [14] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:inccnt::@return
inccnt::@return: from inccnt
  [15] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:@return

Created 2 initial phi equivalence classes
Coalesced [5] cnt#15 ← cnt#3
Coalesced [6] cnt2#14 ← cnt2#1
Coalesced down to 2 phi equivalence classes
Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: from
  [0] call main param-assignment [ ]
  to:@end
@end: from @begin
main: from @begin
  [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:main::@1
main::@1: from main
  [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ]
  [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ]
  [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ]
  [5] call inccnt param-assignment [ inccnt::return#0 ]
  to:main::@2
main::@2: from main::@1
  [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
  [7] *((word) 1025) ← (byte~) main::$1 [ ]
  to:main::@return
main::@return: from main::@2
  [8] return  [ ]
  to:@return
inccnt: from main main::@1
  [9] (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 ) [ cnt#12 cnt2#11 ]
  [9] (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 ) [ cnt#12 cnt2#11 ]
  [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ]
  [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ]
  [12] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:inccnt::@return
inccnt::@return: from inccnt
  [13] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:@return

CALL GRAPH
Calls in [] to 0:main 
Calls in [main] to 1:inccnt 5:inccnt 

DOMINATORS
@begin dominated by  @begin 
@end dominated by  @end @begin 
main dominated by  @begin main 
main::@1 dominated by  @begin main::@1 main 
main::@2 dominated by  @begin main::@2 main::@1 main 
main::@return dominated by  main::@return @begin main::@2 main::@1 main 
inccnt dominated by  inccnt @begin main 
inccnt::@return dominated by  inccnt::@return inccnt @begin main 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [main]
Found 0 loops in scope [inccnt]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1 0.8571428571428571
(byte) cnt#12 4.0
(byte) cnt#3 4.0
(byte) cnt2
(byte) cnt2#1 0.5714285714285714
(byte) cnt2#11 2.0
(byte()) inccnt()
(byte) inccnt::return
(byte) inccnt::return#0 1.5
(void()) main()
(byte~) main::$0 4.0
(byte~) main::$1 4.0

Initial phi equivalence classes
[ cnt#12 cnt#3 ]
[ cnt2#11 cnt2#1 ]
Added variable main::$0 to zero page equivalence class [ main::$0 ]
Added variable main::$1 to zero page equivalence class [ main::$1 ]
Added variable cnt#1 to zero page equivalence class [ cnt#1 ]
Added variable inccnt::return#0 to zero page equivalence class [ inccnt::return#0 ]
Complete equivalence classes
[ cnt#12 cnt#3 ]
[ cnt2#11 cnt2#1 ]
[ main::$0 ]
[ main::$1 ]
[ cnt#1 ]
[ inccnt::return#0 ]
Allocated zp byte:2 to zp byte:2 [ cnt#12 cnt#3 ]
Allocated zp byte:3 to zp byte:3 [ cnt2#11 cnt2#1 ]
Allocated zp byte:4 to zp byte:4 [ main::$0 ]
Allocated zp byte:5 to zp byte:5 [ main::$1 ]
Allocated zp byte:6 to zp byte:6 [ cnt#1 ]
Allocated zp byte:7 to zp byte:7 [ inccnt::return#0 ]
INITIAL ASM
//SEG0 @begin
bbegin:
//SEG1 [0] call main param-assignment [ ]
  jsr main
  jmp bend
//SEG2 @end
bend:
//SEG3 main
main: {
  //SEG4 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
  //SEG5 [9] phi from main to inccnt
  inccnt_from_main:
  //SEG6 [9] phi (byte) cnt2#11 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta $3
  //SEG7 [9] phi (byte) cnt#12 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta $2
    jsr inccnt
    jmp b1
  //SEG8 main::@1
  b1:
  //SEG9 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ] -- zpby1=zpby2 
    lda $7
    sta $4
  //SEG10 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ] -- _star_cowo1=zpby1 
    lda $4
    sta $400
  //SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ] -- zpby1=_inc_zpby2 
    lda $6
    sta $2
    inc $2
  //SEG12 [5] call inccnt param-assignment [ inccnt::return#0 ]
  //SEG13 [9] phi from main::@1 to inccnt
  inccnt_from_b1:
  //SEG14 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
  //SEG15 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
    jsr inccnt
    jmp b2
  //SEG16 main::@2
  b2:
  //SEG17 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ] -- zpby1=zpby2 
    lda $7
    sta $5
  //SEG18 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=zpby1 
    lda $5
    sta $401
    jmp breturn
  //SEG19 main::@return
  breturn:
  //SEG20 [8] return  [ ]
    rts
}
//SEG21 inccnt
inccnt: {
  //SEG22 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ] -- zpby1=_inc_zpby2 
    lda $2
    sta $6
    inc $6
  //SEG23 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ] -- zpby1=_inc_zpby1 
    inc $3
  //SEG24 [12] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ] -- zpby1=zpby2 
    lda $6
    sta $7
    jmp breturn
  //SEG25 inccnt::@return
  breturn:
  //SEG26 [13] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp byte:2 [ cnt#12 cnt#3 ] : zp byte:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:3 [ cnt2#11 cnt2#1 ] : zp byte:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:4 [ main::$0 ] : zp byte:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:5 [ main::$1 ] : zp byte:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:6 [ cnt#1 ] : zp byte:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:7 [ inccnt::return#0 ] : zp byte:7 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 8: zp byte:2 [ cnt#12 cnt#3 ] 2.57: zp byte:3 [ cnt2#11 cnt2#1 ] 0.86: zp byte:6 [ cnt#1 ] 
Uplift Scope [main] 4: zp byte:4 [ main::$0 ] 4: zp byte:5 [ main::$1 ] 
Uplift Scope [inccnt] 1.5: zp byte:7 [ inccnt::return#0 ] 

Uplifting [] best 84 combination reg byte x [ cnt#12 cnt#3 ] reg byte y [ cnt2#11 cnt2#1 ] reg byte x [ cnt#1 ] 
Uplifting [main] best 72 combination reg byte a [ main::$0 ] reg byte a [ main::$1 ] 
Uplifting [inccnt] best 65 combination reg byte a [ inccnt::return#0 ] 
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 @begin
bbegin:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @end
bend:
//SEG3 main
main: {
  //SEG4 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
  //SEG5 [9] phi from main to inccnt
  inccnt_from_main:
  //SEG6 [9] phi (byte) cnt2#11 = (byte) 0 -- yby=coby1 
    ldy #$0
  //SEG7 [9] phi (byte) cnt#12 = (byte) 0 -- xby=coby1 
    ldx #$0
    jsr inccnt
  //SEG8 main::@1
  b1:
  //SEG9 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ]
    // (byte~) main::$0 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG10 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ] -- _star_cowo1=aby 
    sta $400
  //SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ] -- xby=_inc_xby 
    inx
  //SEG12 [5] call inccnt param-assignment [ inccnt::return#0 ]
  //SEG13 [9] phi from main::@1 to inccnt
  inccnt_from_b1:
  //SEG14 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
  //SEG15 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
    jsr inccnt
  //SEG16 main::@2
  b2:
  //SEG17 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
    // (byte~) main::$1 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG18 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=aby 
    sta $401
  //SEG19 main::@return
  breturn:
  //SEG20 [8] return  [ ]
    rts
}
//SEG21 inccnt
inccnt: {
  //SEG22 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ] -- xby=_inc_xby 
    inx
  //SEG23 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ] -- yby=_inc_yby 
    iny
  //SEG24 [12] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ] -- aby=xby 
    txa
  //SEG25 inccnt::@return
  breturn:
  //SEG26 [13] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
    rts
}

FINAL SYMBOL TABLE
(label) @begin
(label) @end
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1 reg byte x 0.8571428571428571
(byte) cnt#12 reg byte x 4.0
(byte) cnt#3 reg byte x 4.0
(byte) cnt2
(byte) cnt2#1 reg byte y 0.5714285714285714
(byte) cnt2#11 reg byte y 2.0
(byte()) inccnt()
(label) inccnt::@return
(byte) inccnt::return
(byte) inccnt::return#0 reg byte a 1.5
(void()) main()
(byte~) main::$0 reg byte a 4.0
(byte~) main::$1 reg byte a 4.0
(label) main::@1
(label) main::@2
(label) main::@return

reg byte x [ cnt#12 cnt#3 ]
reg byte y [ cnt2#11 cnt2#1 ]
reg byte a [ main::$0 ]
reg byte a [ main::$1 ]
reg byte x [ cnt#1 ]
reg byte a [ inccnt::return#0 ]

FINAL CODE
//SEG0 @begin
bbegin:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @end
bend:
//SEG3 main
main: {
  //SEG4 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
  //SEG5 [9] phi from main to inccnt
  inccnt_from_main:
  //SEG6 [9] phi (byte) cnt2#11 = (byte) 0 -- yby=coby1 
    ldy #$0
  //SEG7 [9] phi (byte) cnt#12 = (byte) 0 -- xby=coby1 
    ldx #$0
    jsr inccnt
  //SEG8 main::@1
  b1:
  //SEG9 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ]
    // (byte~) main::$0 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG10 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ] -- _star_cowo1=aby 
    sta $400
  //SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ] -- xby=_inc_xby 
    inx
  //SEG12 [5] call inccnt param-assignment [ inccnt::return#0 ]
  //SEG13 [9] phi from main::@1 to inccnt
  inccnt_from_b1:
  //SEG14 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
  //SEG15 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
    jsr inccnt
  //SEG16 main::@2
  b2:
  //SEG17 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
    // (byte~) main::$1 = (byte) inccnt::return#0  // register copy reg byte a
  //SEG18 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=aby 
    sta $401
  //SEG19 main::@return
  breturn:
  //SEG20 [8] return  [ ]
    rts
}
//SEG21 inccnt
inccnt: {
  //SEG22 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ] -- xby=_inc_xby 
    inx
  //SEG23 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ] -- yby=_inc_yby 
    iny
  //SEG24 [12] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ] -- aby=xby 
    txa
  //SEG25 inccnt::@return
  breturn:
  //SEG26 [13] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
    rts
}

