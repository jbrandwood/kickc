// Implementation of the Seriously Fast Multiplication
// See http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
// Utilizes the fact that a*b = ((a+b)/2)^2 - ((a-b)/2)^2

import "print.kc"

byte* BGCOL = $d021;

void main() {
    *BGCOL = 5;
    print_cls();
    init_mul_tables();
    init_mul_tables_asm();
    mul_tables_compare();
    mul_results_compare();
}

// Perform a slow multiplication by repeated addition
word slow_multiply(byte a, byte b) {
    word m = 0;
    if(a>0) {
        for(byte i = 0; i!=a; i++) {
            m = m + b;
        }
    }
    return m;
}

// mul_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
// <f(x) = <(( x * x )/4)
byte[512] align($100) mul_sqr1_lo;
// >f(x) = >(( x * x )/4)
byte[512] align($100) mul_sqr1_hi;
// <g(x) =  <((( x - 255) * ( x - 255 ))/4)
byte[512] align($100) mul_sqr2_lo;
// >g(x) = >((( x - 255) * ( x - 255 ))/4)
byte[512] align($100) mul_sqr2_hi;

// Initialize the mul_sqr multiplication tables with f(x)=int(x*x/4)
void init_mul_tables() {
  // Fill mul_sqr1 = f(x) = int(x*x/4): If f(x) = x*x/4 then f(x+1) = f(x) + x/2 + 1/4
  word sqr = 0; // sqr = (x*x)/4
  byte x_2 = 0; // x/2
  byte c = 0;   // Counter used for determining x%2==0
  byte* sqr1_hi = mul_sqr1_hi+1;
  for(byte* sqr1_lo = mul_sqr1_lo+1; sqr1_lo!=mul_sqr1_lo+512; sqr1_lo++) {
    if((++c&1)==0) {
        x_2++; // increase i/2 on even numbers
        sqr++; // sqr++ on even numbers because 1 = 2*1/4 (from the two previous numbers) + 1/2 (half of the previous uneven number)
    }
    *sqr1_lo = <sqr;
    *sqr1_hi++ = >sqr;
    sqr = sqr + x_2; // sqr = sqr + i/2 (when uneven the 1/2 is not added here - see above)
  }
  // Fill mul_sqr2 = g(x) = f(x-255) : If x-255<0 then g(x)=f(255-x) (because x*x = -x*-x)
  // g(0) = f(255), g(1) = f(254), ..., g(254) = f(1), g(255) = f(0), g(256) = f(1), ..., g(510) = f(255), g(511) = f(256)
  byte x_255 = (byte)-1; //Start with g(0)=f(255)
  byte dir = $ff;  // Decrease or increase x_255 - initially we decrease
  byte* sqr2_hi = mul_sqr2_hi;
  for(byte* sqr2_lo = mul_sqr2_lo; sqr2_lo!=mul_sqr2_lo+511; sqr2_lo++) {
    *sqr2_lo = mul_sqr1_lo[x_255];
    *sqr2_hi++ = mul_sqr1_hi[x_255];
    x_255 = x_255 + dir;
    if(x_255==0) {
      dir = 1; // when x_255=0 then start counting up
    }
  }
  // Set the very last value g(511) = f(256)
  *(mul_sqr2_lo+511) = *(mul_sqr1_lo+256);
  *(mul_sqr2_hi+511) = *(mul_sqr1_hi+256);
}

// ASM based multiplication tables
// <(( x * x )/4)
byte[512] align($100) asm_mul_sqr1_lo;
// >(( x * x )/4)
byte[512] align($100) asm_mul_sqr1_hi;
// <((( x - 255) * ( x - 255 ))/4)
byte[512] align($100) asm_mul_sqr2_lo;
// >((( x - 255) * ( x - 255 ))/4)
byte[512] align($100) asm_mul_sqr2_hi;
// Initialize the multiplication tables using ASM code from
// http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
void init_mul_tables_asm() {
    asm{
        ldx #$00
        txa
        .byte $c9
    lb1:
        tya
        adc #$00
    ml1:
        sta asm_mul_sqr1_hi,x
        tay
        cmp #$40
        txa
        ror
    ml9:
        adc #$00
        sta ml9+1
        inx
    ml0:
        sta asm_mul_sqr1_lo,x
        bne lb1
        inc ml0+2
        inc ml1+2
        clc
        iny
        bne lb1
        ldx #$00
        ldy #$ff
    !:
        lda asm_mul_sqr1_hi+1,x
        sta asm_mul_sqr2_hi+$100,x
        lda asm_mul_sqr1_hi,x
        sta asm_mul_sqr2_hi,y
        lda asm_mul_sqr1_lo+1,x
        sta asm_mul_sqr2_lo+$100,x
        lda asm_mul_sqr1_lo,x
        sta asm_mul_sqr2_lo,y
        dey
        inx
        bne !-
    }
    // Ensure the ASM tables are not detected as unused by the optimizer
    byte* mem = $ff;
    *mem = *asm_mul_sqr1_lo;
    *mem = *asm_mul_sqr1_hi;
    *mem = *asm_mul_sqr2_lo;
    *mem = *asm_mul_sqr2_hi;
}

// Fast multiply two bytes using ASM
word asm_multiply(byte a, byte b) {
    const byte* memA = $fe;
    const byte* memB = $ff;
    *memA = a;
    *memB = b;
    asm {
        lda memA
        sta sm1+1
        sta sm3+1
        eor #$ff
        sta sm2+1
        sta sm4+1
        ldx memB
        sec
    sm1:
        lda asm_mul_sqr1_lo,x
    sm2:
        sbc asm_mul_sqr2_lo,x
        sta memA
    sm3:
        lda asm_mul_sqr1_hi,x
    sm4:
        sbc asm_mul_sqr2_hi,x
        sta memB
    }
    return { *memB, *memA };
}

// Compare the ASM-based mul tables with the KC-based mul tables
// Red screen on failure - green on success
void mul_tables_compare() {
    byte* asm_sqr = asm_mul_sqr1_lo;
    for( byte* kc_sqr=mul_sqr1_lo; kc_sqr<mul_sqr1_lo+512*4; kc_sqr++) {
        if(*kc_sqr != *asm_sqr) {
            *BGCOL = 2;
            print_str("multiply table mismatch at @");
            print_word((word)asm_sqr);
            print_str(" / @");
            print_word((word)kc_sqr);
            return;
        }
        asm_sqr++;
    }
    print_str("multiply tables match!@");
    print_ln();
}

// Perform all possible byte-multiplications (slow and ASM) and compare the results
void mul_results_compare() {
    for(byte a: 0..255) {
        for(byte b: 0..255) {
            word ms = slow_multiply(a, b);
            word ma = asm_multiply(a,b);
            if(ms!=ma) {
                *BGCOL = 2;
                print_str("multiply mismatch slow:@");
                print_word(ms);
                print_str(" / fast asm:");
                print_word(ma);
                return;
            }
        }
    }
    print_str("multiply results match!@");
    print_ln();
}