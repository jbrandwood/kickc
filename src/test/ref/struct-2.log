Adding pointer type conversion cast (byte*) main::SCREEN in (byte*) main::SCREEN ← (number) $400

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (struct Point) point1#0 ← {}
  (struct Point) point2#0 ← {}
  to:@1
main: scope:[main]  from @1
  (struct Point) point1#1 ← phi( @1/(struct Point) point1#2 )
  (struct Point) point1#1.x ← (number) 2
  (struct Point) point1#1.y ← (number) 3
  (struct Point) point2#1 ← (struct Point) point1#1
  (struct Point) point2#1.x ← (number) 4
  (byte*) main::SCREEN#0 ← ((byte*)) (number) $400
  *((byte*) main::SCREEN#0 + (number) 0) ← (struct Point) point1#1.x
  *((byte*) main::SCREEN#0 + (number) 1) ← (struct Point) point1#1.y
  *((byte*) main::SCREEN#0 + (number) 2) ← (struct Point) point2#1.x
  *((byte*) main::SCREEN#0 + (number) 3) ← (struct Point) point2#1.y
  to:main::@return
main::@return: scope:[main]  from main
  (struct Point) point2#4 ← phi( main/(struct Point) point2#1 )
  (struct Point) point2#2 ← (struct Point) point2#4
  return 
  to:@return
@1: scope:[]  from @begin
  (struct Point) point2#6 ← phi( @begin/(struct Point) point2#0 )
  (struct Point) point1#2 ← phi( @begin/(struct Point) point1#0 )
  call main 
  to:@2
@2: scope:[]  from @1
  (struct Point) point2#5 ← phi( @1/(struct Point) point2#2 )
  (struct Point) point2#3 ← (struct Point) point2#5
  to:@end
@end: scope:[]  from @2

SYMBOL TABLE SSA
(label) @1
(label) @2
(label) @begin
(label) @end
(byte) Point::x
(byte) Point::y
(void()) main()
(label) main::@return
(byte*) main::SCREEN
(byte*) main::SCREEN#0
(struct Point) point1
(struct Point) point1#0
(struct Point) point1#1
(struct Point) point1#2
(struct Point) point2
(struct Point) point2#0
(struct Point) point2#1
(struct Point) point2#2
(struct Point) point2#3
(struct Point) point2#4
(struct Point) point2#5
(struct Point) point2#6

Adding number conversion cast (unumber) 2 in (struct Point) point1#1.x ← (number) 2
Adding number conversion cast (unumber) 3 in (struct Point) point1#1.y ← (number) 3
Adding number conversion cast (unumber) 4 in (struct Point) point2#1.x ← (number) 4
Adding number conversion cast (unumber) 0 in *((byte*) main::SCREEN#0 + (number) 0) ← (struct Point) point1#1.x
Adding number conversion cast (unumber) 1 in *((byte*) main::SCREEN#0 + (number) 1) ← (struct Point) point1#1.y
Adding number conversion cast (unumber) 2 in *((byte*) main::SCREEN#0 + (number) 2) ← (struct Point) point2#1.x
Adding number conversion cast (unumber) 3 in *((byte*) main::SCREEN#0 + (number) 3) ← (struct Point) point2#1.y
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (struct Point) point1#1.x ← (unumber)(number) 2
Inlining cast (struct Point) point1#1.y ← (unumber)(number) 3
Inlining cast (struct Point) point2#1.x ← (unumber)(number) 4
Inlining cast (byte*) main::SCREEN#0 ← (byte*)(number) $400
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast 2
Simplifying constant integer cast 3
Simplifying constant integer cast 4
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 3
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)(struct Point) point2#1 = (struct Point) point1#1 (struct Point) point2#4 (struct Point) point2#2 
Alias (struct Point) point1#0 = (struct Point) point1#2 
Alias (struct Point) point2#0 = (struct Point) point2#6 
Alias (struct Point) point2#3 = (struct Point) point2#5 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(struct Point) point2#1 = (struct Point) point1#1 (struct Point) point2#4 (struct Point) point2#2 
Identical Phi Values (struct Point) point1#1 (struct Point) point1#0
Identical Phi Values (struct Point) point2#4 (struct Point) point2#1
Identical Phi Values (struct Point) point2#3 (struct Point) point2#2
Successful SSA optimization Pass2IdenticalPhiElimination
Constant (const byte*) main::SCREEN#0 = (byte*) 1024
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero main::SCREEN#0 in [8] *((const byte*) main::SCREEN#0 + (byte) 0) ← (struct Point) point1#0.x
Successful SSA optimization PassNSimplifyExpressionWithZero
Alias (struct Point) point2#1 = (struct Point) point2#2 
Successful SSA optimization Pass2AliasElimination
Consolidated array index constant in *(main::SCREEN#0+1)
Consolidated array index constant in *(main::SCREEN#0+2)
Consolidated array index constant in *(main::SCREEN#0+3)
Successful SSA optimization Pass2ConstantAdditionElimination
Adding NOP phi() at start of @1
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
CALL GRAPH
Calls in [] to main:3 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block (label) @2
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] (struct Point) point1#0 ← {}
  [1] (struct Point) point2#0 ← {}
  to:@1
@1: scope:[]  from @begin
  [2] phi()
  [3] call main 
  to:@end
@end: scope:[]  from @1
  [4] phi()
main: scope:[main]  from @1
  [5] (struct Point) point1#0.x ← (byte) 2
  [6] (struct Point) point1#0.y ← (byte) 3
  [7] (struct Point) point2#1 ← (struct Point) point1#0
  [8] (struct Point) point2#1.x ← (byte) 4
  [9] *((const byte*) main::SCREEN#0) ← (struct Point) point1#0.x
  [10] *((const byte*) main::SCREEN#0+(byte) 1) ← (struct Point) point1#0.y
  [11] *((const byte*) main::SCREEN#0+(byte) 2) ← (struct Point) point2#1.x
  [12] *((const byte*) main::SCREEN#0+(byte) 3) ← (struct Point) point2#1.y
  to:main::@return
main::@return: scope:[main]  from main
  [13] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) Point::x
(byte) Point::y
(void()) main()
(byte*) main::SCREEN
(struct Point) point1
(struct Point) point1#0 0.5
(struct Point) point2
(struct Point) point2#0 20.0
(struct Point) point2#1 0.4

Initial phi equivalence classes
Coalescing volatile variable equivalence classes [ point2#0 ] and [ point2#1 ]
Complete equivalence classes
[ point1#0 ]
[ point2#0 point2#1 ]
Allocated zp ZP_STRUCT:2 [ point1#0 ]
Allocated zp ZP_STRUCT:4 [ point2#0 point2#1 ]

INITIAL ASM
//SEG0 File Comments
// Minimal struct - different instances and copying
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label point1 = 2
  .label point2 = 4
//SEG3 @begin
bbegin:
//SEG4 [0] (struct Point) point1#0 ← {} -- vssz1=vssf2 
  lda #0
  sta point1
  sta point1+1
//SEG5 [1] (struct Point) point2#0 ← {} -- vssz1=vssf2 
  lda #0
  sta point2
  sta point2+1
//SEG6 [2] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG7 @1
b1:
//SEG8 [3] call main 
  jsr main
//SEG9 [4] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG10 @end
bend:
//SEG11 main
main: {
    .label SCREEN = $400
  //SEG12 [5] (struct Point) point1#0.x ← (byte) 2 -- vbuz1=vbuc1 
    lda #2
    sta point1+0
  //SEG13 [6] (struct Point) point1#0.y ← (byte) 3 -- vbuz1=vbuc1 
    lda #3
    sta point1+1
  //SEG14 [7] (struct Point) point2#1 ← (struct Point) point1#0 -- vssz1=vssz2 
    lda point1
    sta point2
    lda point1+1
    sta point2+1
  //SEG15 [8] (struct Point) point2#1.x ← (byte) 4 -- vbuz1=vbuc1 
    lda #4
    sta point2+0
  //SEG16 [9] *((const byte*) main::SCREEN#0) ← (struct Point) point1#0.x -- _deref_pbuc1=vbuz1 
    lda point1+0
    sta SCREEN
  //SEG17 [10] *((const byte*) main::SCREEN#0+(byte) 1) ← (struct Point) point1#0.y -- _deref_pbuc1=vbuz1 
    lda point1+1
    sta SCREEN+1
  //SEG18 [11] *((const byte*) main::SCREEN#0+(byte) 2) ← (struct Point) point2#1.x -- _deref_pbuc1=vbuz1 
    lda point2+0
    sta SCREEN+2
  //SEG19 [12] *((const byte*) main::SCREEN#0+(byte) 3) ← (struct Point) point2#1.y -- _deref_pbuc1=vbuz1 
    lda point2+1
    sta SCREEN+3
    jmp breturn
  //SEG20 main::@return
  breturn:
  //SEG21 [13] return 
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] (struct Point) point1#0 ← {} [ point1#0 ] ( ) always clobbers reg byte a 
Statement [1] (struct Point) point2#0 ← {} [ point1#0 ] ( ) always clobbers reg byte a 
Statement [5] (struct Point) point1#0.x ← (byte) 2 [ point1#0 ] ( main:3 [ point1#0 ] ) always clobbers reg byte a 
Statement [6] (struct Point) point1#0.y ← (byte) 3 [ point1#0 ] ( main:3 [ point1#0 ] ) always clobbers reg byte a 
Statement [7] (struct Point) point2#1 ← (struct Point) point1#0 [ point1#0 point2#1 ] ( main:3 [ point1#0 point2#1 ] ) always clobbers reg byte a 
Statement [8] (struct Point) point2#1.x ← (byte) 4 [ point1#0 point2#1 ] ( main:3 [ point1#0 point2#1 ] ) always clobbers reg byte a 
Statement [9] *((const byte*) main::SCREEN#0) ← (struct Point) point1#0.x [ point1#0 point2#1 ] ( main:3 [ point1#0 point2#1 ] ) always clobbers reg byte a 
Statement [10] *((const byte*) main::SCREEN#0+(byte) 1) ← (struct Point) point1#0.y [ point2#1 ] ( main:3 [ point2#1 ] ) always clobbers reg byte a 
Statement [11] *((const byte*) main::SCREEN#0+(byte) 2) ← (struct Point) point2#1.x [ point2#1 ] ( main:3 [ point2#1 ] ) always clobbers reg byte a 
Statement [12] *((const byte*) main::SCREEN#0+(byte) 3) ← (struct Point) point2#1.y [ ] ( main:3 [ ] ) always clobbers reg byte a 
Potential registers zp ZP_STRUCT:2 [ point1#0 ] : zp ZP_STRUCT:2 , 
Potential registers zp ZP_STRUCT:4 [ point2#0 point2#1 ] : zp ZP_STRUCT:4 , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 20.4: zp ZP_STRUCT:4 [ point2#0 point2#1 ] 0.5: zp ZP_STRUCT:2 [ point1#0 ] 
Uplift Scope [Point] 
Uplift Scope [main] 

Uplifting [] best 92 combination zp ZP_STRUCT:4 [ point2#0 point2#1 ] zp ZP_STRUCT:2 [ point1#0 ] 
Uplifting [Point] best 92 combination 
Uplifting [main] best 92 combination 

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Minimal struct - different instances and copying
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label point1 = 2
  .label point2 = 4
//SEG3 @begin
bbegin:
//SEG4 [0] (struct Point) point1#0 ← {} -- vssz1=vssf2 
  lda #0
  sta point1
  sta point1+1
//SEG5 [1] (struct Point) point2#0 ← {} -- vssz1=vssf2 
  lda #0
  sta point2
  sta point2+1
//SEG6 [2] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG7 @1
b1:
//SEG8 [3] call main 
  jsr main
//SEG9 [4] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG10 @end
bend:
//SEG11 main
main: {
    .label SCREEN = $400
  //SEG12 [5] (struct Point) point1#0.x ← (byte) 2 -- vbuz1=vbuc1 
    lda #2
    sta point1+0
  //SEG13 [6] (struct Point) point1#0.y ← (byte) 3 -- vbuz1=vbuc1 
    lda #3
    sta point1+1
  //SEG14 [7] (struct Point) point2#1 ← (struct Point) point1#0 -- vssz1=vssz2 
    lda point1
    sta point2
    lda point1+1
    sta point2+1
  //SEG15 [8] (struct Point) point2#1.x ← (byte) 4 -- vbuz1=vbuc1 
    lda #4
    sta point2+0
  //SEG16 [9] *((const byte*) main::SCREEN#0) ← (struct Point) point1#0.x -- _deref_pbuc1=vbuz1 
    lda point1+0
    sta SCREEN
  //SEG17 [10] *((const byte*) main::SCREEN#0+(byte) 1) ← (struct Point) point1#0.y -- _deref_pbuc1=vbuz1 
    lda point1+1
    sta SCREEN+1
  //SEG18 [11] *((const byte*) main::SCREEN#0+(byte) 2) ← (struct Point) point2#1.x -- _deref_pbuc1=vbuz1 
    lda point2+0
    sta SCREEN+2
  //SEG19 [12] *((const byte*) main::SCREEN#0+(byte) 3) ← (struct Point) point2#1.y -- _deref_pbuc1=vbuz1 
    lda point2+1
    sta SCREEN+3
    jmp breturn
  //SEG20 main::@return
  breturn:
  //SEG21 [13] return 
    rts
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction b1_from_bbegin:
Removing instruction bend_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b1:
Removing instruction bend:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte) Point::x
(byte) Point::y
(void()) main()
(label) main::@return
(byte*) main::SCREEN
(const byte*) main::SCREEN#0 SCREEN = (byte*) 1024
(struct Point) point1
(struct Point) point1#0 point1 zp ZP_STRUCT:2 0.5
(struct Point) point2
(struct Point) point2#0 point2 zp ZP_STRUCT:4 20.0
(struct Point) point2#1 point2 zp ZP_STRUCT:4 0.4

zp ZP_STRUCT:2 [ point1#0 ]
zp ZP_STRUCT:4 [ point2#0 point2#1 ]


FINAL ASSEMBLER
Score: 87

//SEG0 File Comments
// Minimal struct - different instances and copying
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label point1 = 2
  .label point2 = 4
//SEG3 @begin
bbegin:
//SEG4 [0] (struct Point) point1#0 ← {} -- vssz1=vssf2 
  lda #0
  sta point1
  sta point1+1
//SEG5 [1] (struct Point) point2#0 ← {} -- vssz1=vssf2 
  sta point2
  sta point2+1
//SEG6 [2] phi from @begin to @1 [phi:@begin->@1]
//SEG7 @1
//SEG8 [3] call main 
  jsr main
  rts
//SEG9 [4] phi from @1 to @end [phi:@1->@end]
//SEG10 @end
//SEG11 main
main: {
    .label SCREEN = $400
  //SEG12 [5] (struct Point) point1#0.x ← (byte) 2 -- vbuz1=vbuc1 
    lda #2
    sta point1+0
  //SEG13 [6] (struct Point) point1#0.y ← (byte) 3 -- vbuz1=vbuc1 
    lda #3
    sta point1+1
  //SEG14 [7] (struct Point) point2#1 ← (struct Point) point1#0 -- vssz1=vssz2 
    lda point1
    sta point2
    lda point1+1
    sta point2+1
  //SEG15 [8] (struct Point) point2#1.x ← (byte) 4 -- vbuz1=vbuc1 
    lda #4
    sta point2+0
  //SEG16 [9] *((const byte*) main::SCREEN#0) ← (struct Point) point1#0.x -- _deref_pbuc1=vbuz1 
    lda point1+0
    sta SCREEN
  //SEG17 [10] *((const byte*) main::SCREEN#0+(byte) 1) ← (struct Point) point1#0.y -- _deref_pbuc1=vbuz1 
    lda point1+1
    sta SCREEN+1
  //SEG18 [11] *((const byte*) main::SCREEN#0+(byte) 2) ← (struct Point) point2#1.x -- _deref_pbuc1=vbuz1 
    lda point2+0
    sta SCREEN+2
  //SEG19 [12] *((const byte*) main::SCREEN#0+(byte) 3) ← (struct Point) point2#1.y -- _deref_pbuc1=vbuz1 
    lda point2+1
    sta SCREEN+3
  //SEG20 main::@return
  //SEG21 [13] return 
    rts
}

