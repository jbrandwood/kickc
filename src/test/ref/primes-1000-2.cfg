@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] *((const word*) PRIMES+(byte) 1*(const byte) SIZEOF_WORD) ← (byte) 2
  [5] *((const word*) PRIMES+(byte) 2*(const byte) SIZEOF_WORD) ← (byte) 3
  to:main::@1
main::@1: scope:[main]  from main main::@11
  [6] (byte*) print_char_cursor#34 ← phi( main/(byte*) 1024 main::@11/(byte*) print_char_cursor#16 )
  [6] (word) prime_idx#15 ← phi( main/(byte) 2 main::@11/(word) prime_idx#10 )
  [6] (word) potential#13 ← phi( main/(byte) 3 main::@11/(word) potential#10 )
  [6] (byte) test_last#11 ← phi( main/(byte) 2 main::@11/(byte) test_last#17 )
  [7] (byte~) main::$14 ← (byte) test_last#11 << (byte) 1
  [8] (byte) main::p#0 ← (byte)*((const word*) PRIMES + (byte~) main::$14)
  [9] (byte) mul8u::a#1 ← (byte) main::p#0
  [10] (byte) mul8u::b#0 ← (byte) main::p#0
  [11] call mul8u 
  [12] (word) mul8u::return#2 ← (word) mul8u::res#2
  to:main::@8
main::@8: scope:[main]  from main::@1
  [13] (word~) main::$1 ← (word) mul8u::return#2
  [14] if((word) potential#13<=(word~) main::$1) goto main::@2
  to:main::@7
main::@7: scope:[main]  from main::@8
  [15] (byte) test_last#2 ← ++ (byte) test_last#11
  to:main::@2
main::@2: scope:[main]  from main::@7 main::@8
  [16] (byte) test_last#17 ← phi( main::@7/(byte) test_last#2 main::@8/(byte) test_last#11 )
  [17] (word) potential#2 ← (word) potential#13 + (byte) 2
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  [18] (word) potential#16 ← phi( main::@2/(word) potential#2 main::@4/(word) potential#10 )
  [18] (byte) test_idx#6 ← phi( main::@2/(byte) 2 main::@4/(byte) test_idx#11 )
  [19] (byte~) main::$15 ← (byte) test_idx#6 << (byte) 1
  [20] (byte) div16u8u::divisor#0 ← (byte)*((const word*) PRIMES + (byte~) main::$15)
  [21] (word) div16u8u::dividend#0 ← (word) potential#16
  [22] call div16u8u 
  to:main::@9
main::@9: scope:[main]  from main::@3
  [23] (byte) test_idx#2 ← ++ (byte) test_idx#6
  [24] if((byte) rem8u#1!=(byte) 0) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@9
  [25] (word) potential#3 ← (word) potential#16 + (byte) 2
  to:main::@4
main::@4: scope:[main]  from main::@5 main::@9
  [26] (word) potential#10 ← phi( main::@9/(word) potential#16 main::@5/(word) potential#3 )
  [26] (byte) test_idx#11 ← phi( main::@9/(byte) test_idx#2 main::@5/(byte) 2 )
  [27] if((byte) test_idx#11<=(byte) test_last#17) goto main::@3
  to:main::@6
main::@6: scope:[main]  from main::@4
  [28] (word) prime_idx#10 ← ++ (word) prime_idx#15
  [29] (word~) main::$16 ← (word) prime_idx#10 << (byte) 1
  [30] (word*~) main::$17 ← (const word*) PRIMES + (word~) main::$16
  [31] *((word*~) main::$17) ← (word) potential#10
  [32] (word) print_uint_decimal::w#0 ← (word) potential#10
  [33] call print_uint_decimal 
  to:main::@10
main::@10: scope:[main]  from main::@6
  [34] phi()
  [35] call print_char 
  to:main::@11
main::@11: scope:[main]  from main::@10
  [36] if((word) prime_idx#10<(word) $3e8) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@11
  [37] return 
  to:@return

(void()) print_char((byte) print_char::ch)
print_char: scope:[print_char]  from main::@10 print_str::@2
  [38] (byte) print_char::ch#2 ← phi( main::@10/(byte) ' ' print_str::@2/(byte) print_char::ch#0 )
  [39] *((byte*) print_char_cursor#12) ← (byte) print_char::ch#2
  [40] (byte*) print_char_cursor#16 ← ++ (byte*) print_char_cursor#12
  to:print_char::@return
print_char::@return: scope:[print_char]  from print_char
  [41] return 
  to:@return

(void()) print_uint_decimal((word) print_uint_decimal::w)
print_uint_decimal: scope:[print_uint_decimal]  from main::@6
  [42] (word) utoa::value#1 ← (word) print_uint_decimal::w#0
  [43] call utoa 
  to:print_uint_decimal::@1
print_uint_decimal::@1: scope:[print_uint_decimal]  from print_uint_decimal
  [44] phi()
  [45] call print_str 
  to:print_uint_decimal::@return
print_uint_decimal::@return: scope:[print_uint_decimal]  from print_uint_decimal::@1
  [46] return 
  to:@return

(void()) print_str((byte*) print_str::str)
print_str: scope:[print_str]  from print_uint_decimal::@1
  [47] phi()
  to:print_str::@1
print_str::@1: scope:[print_str]  from print_str print_str::@3
  [48] (byte*) print_char_cursor#12 ← phi( print_str/(byte*) print_char_cursor#34 print_str::@3/(byte*) print_char_cursor#16 )
  [48] (byte*) print_str::str#2 ← phi( print_str/(const byte*) decimal_digits print_str::@3/(byte*) print_str::str#0 )
  [49] if((byte) 0!=*((byte*) print_str::str#2)) goto print_str::@2
  to:print_str::@return
print_str::@return: scope:[print_str]  from print_str::@1
  [50] return 
  to:@return
print_str::@2: scope:[print_str]  from print_str::@1
  [51] (byte) print_char::ch#0 ← *((byte*) print_str::str#2)
  [52] call print_char 
  to:print_str::@3
print_str::@3: scope:[print_str]  from print_str::@2
  [53] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#2
  to:print_str::@1

(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
utoa: scope:[utoa]  from print_uint_decimal
  [54] phi()
  to:utoa::@1
utoa::@1: scope:[utoa]  from utoa utoa::@4
  [55] (byte*) utoa::buffer#11 ← phi( utoa::@4/(byte*) utoa::buffer#14 utoa/(const byte*) decimal_digits )
  [55] (byte) utoa::started#2 ← phi( utoa::@4/(byte) utoa::started#4 utoa/(byte) 0 )
  [55] (word) utoa::value#2 ← phi( utoa::@4/(word) utoa::value#6 utoa/(word) utoa::value#1 )
  [55] (byte) utoa::digit#2 ← phi( utoa::@4/(byte) utoa::digit#1 utoa/(byte) 0 )
  [56] if((byte) utoa::digit#2<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@2
  to:utoa::@3
utoa::@3: scope:[utoa]  from utoa::@1
  [57] (byte~) utoa::$4 ← (byte)(word) utoa::value#2
  [58] *((byte*) utoa::buffer#11) ← *((const byte*) DIGITS + (byte~) utoa::$4)
  [59] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11
  [60] *((byte*) utoa::buffer#3) ← (byte) 0
  to:utoa::@return
utoa::@return: scope:[utoa]  from utoa::@3
  [61] return 
  to:@return
utoa::@2: scope:[utoa]  from utoa::@1
  [62] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1
  [63] (word) utoa::digit_value#0 ← *((const word*) RADIX_DECIMAL_VALUES + (byte~) utoa::$11)
  [64] if((byte) 0!=(byte) utoa::started#2) goto utoa::@5
  to:utoa::@7
utoa::@7: scope:[utoa]  from utoa::@2
  [65] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@5
  to:utoa::@4
utoa::@4: scope:[utoa]  from utoa::@6 utoa::@7
  [66] (byte*) utoa::buffer#14 ← phi( utoa::@7/(byte*) utoa::buffer#11 utoa::@6/(byte*) utoa::buffer#4 )
  [66] (byte) utoa::started#4 ← phi( utoa::@7/(byte) utoa::started#2 utoa::@6/(byte) 1 )
  [66] (word) utoa::value#6 ← phi( utoa::@7/(word) utoa::value#2 utoa::@6/(word) utoa::value#0 )
  [67] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2
  to:utoa::@1
utoa::@5: scope:[utoa]  from utoa::@2 utoa::@7
  [68] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11
  [69] (word) utoa_append::value#0 ← (word) utoa::value#2
  [70] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0
  [71] call utoa_append 
  [72] (word) utoa_append::return#0 ← (word) utoa_append::value#2
  to:utoa::@6
utoa::@6: scope:[utoa]  from utoa::@5
  [73] (word) utoa::value#0 ← (word) utoa_append::return#0
  [74] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#11
  to:utoa::@4

(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
utoa_append: scope:[utoa_append]  from utoa::@5
  [75] phi()
  to:utoa_append::@1
utoa_append::@1: scope:[utoa_append]  from utoa_append utoa_append::@2
  [76] (byte) utoa_append::digit#2 ← phi( utoa_append/(byte) 0 utoa_append::@2/(byte) utoa_append::digit#1 )
  [76] (word) utoa_append::value#2 ← phi( utoa_append/(word) utoa_append::value#0 utoa_append::@2/(word) utoa_append::value#1 )
  [77] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2
  to:utoa_append::@3
utoa_append::@3: scope:[utoa_append]  from utoa_append::@1
  [78] *((byte*) utoa_append::buffer#0) ← *((const byte*) DIGITS + (byte) utoa_append::digit#2)
  to:utoa_append::@return
utoa_append::@return: scope:[utoa_append]  from utoa_append::@3
  [79] return 
  to:@return
utoa_append::@2: scope:[utoa_append]  from utoa_append::@1
  [80] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2
  [81] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0
  to:utoa_append::@1

(word()) div16u8u((word) div16u8u::dividend , (byte) div16u8u::divisor)
div16u8u: scope:[div16u8u]  from main::@3
  [82] (byte) divr8u::dividend#1 ← > (word) div16u8u::dividend#0
  [83] (byte) divr8u::divisor#0 ← (byte) div16u8u::divisor#0
  [84] call divr8u 
  to:div16u8u::@1
div16u8u::@1: scope:[div16u8u]  from div16u8u
  [85] (byte) divr8u::dividend#2 ← < (word) div16u8u::dividend#0
  [86] (byte) divr8u::divisor#1 ← (byte) div16u8u::divisor#0
  [87] (byte) divr8u::rem#4 ← (byte) rem8u#1
  [88] call divr8u 
  to:div16u8u::@return
div16u8u::@return: scope:[div16u8u]  from div16u8u::@1
  [89] return 
  to:@return

(byte()) divr8u((byte) divr8u::dividend , (byte) divr8u::divisor , (byte) divr8u::rem)
divr8u: scope:[divr8u]  from div16u8u div16u8u::@1
  [90] (byte) divr8u::divisor#6 ← phi( div16u8u/(byte) divr8u::divisor#0 div16u8u::@1/(byte) divr8u::divisor#1 )
  [90] (byte) divr8u::dividend#5 ← phi( div16u8u/(byte) divr8u::dividend#1 div16u8u::@1/(byte) divr8u::dividend#2 )
  [90] (byte) divr8u::rem#10 ← phi( div16u8u/(byte) 0 div16u8u::@1/(byte) divr8u::rem#4 )
  to:divr8u::@1
divr8u::@1: scope:[divr8u]  from divr8u divr8u::@3
  [91] (byte) divr8u::i#2 ← phi( divr8u/(byte) 0 divr8u::@3/(byte) divr8u::i#1 )
  [91] (byte) divr8u::quotient#3 ← phi( divr8u/(byte) 0 divr8u::@3/(byte) divr8u::return#0 )
  [91] (byte) divr8u::dividend#3 ← phi( divr8u/(byte) divr8u::dividend#5 divr8u::@3/(byte) divr8u::dividend#0 )
  [91] (byte) divr8u::rem#5 ← phi( divr8u/(byte) divr8u::rem#10 divr8u::@3/(byte) divr8u::rem#11 )
  [92] (byte) divr8u::rem#0 ← (byte) divr8u::rem#5 << (byte) 1
  [93] (byte~) divr8u::$1 ← (byte) divr8u::dividend#3 & (byte) $80
  [94] if((byte~) divr8u::$1==(byte) 0) goto divr8u::@2
  to:divr8u::@4
divr8u::@4: scope:[divr8u]  from divr8u::@1
  [95] (byte) divr8u::rem#1 ← (byte) divr8u::rem#0 | (byte) 1
  to:divr8u::@2
divr8u::@2: scope:[divr8u]  from divr8u::@1 divr8u::@4
  [96] (byte) divr8u::rem#6 ← phi( divr8u::@1/(byte) divr8u::rem#0 divr8u::@4/(byte) divr8u::rem#1 )
  [97] (byte) divr8u::dividend#0 ← (byte) divr8u::dividend#3 << (byte) 1
  [98] (byte) divr8u::quotient#1 ← (byte) divr8u::quotient#3 << (byte) 1
  [99] if((byte) divr8u::rem#6<(byte) divr8u::divisor#6) goto divr8u::@3
  to:divr8u::@5
divr8u::@5: scope:[divr8u]  from divr8u::@2
  [100] (byte) divr8u::quotient#2 ← ++ (byte) divr8u::quotient#1
  [101] (byte) divr8u::rem#2 ← (byte) divr8u::rem#6 - (byte) divr8u::divisor#6
  to:divr8u::@3
divr8u::@3: scope:[divr8u]  from divr8u::@2 divr8u::@5
  [102] (byte) divr8u::return#0 ← phi( divr8u::@2/(byte) divr8u::quotient#1 divr8u::@5/(byte) divr8u::quotient#2 )
  [102] (byte) divr8u::rem#11 ← phi( divr8u::@2/(byte) divr8u::rem#6 divr8u::@5/(byte) divr8u::rem#2 )
  [103] (byte) divr8u::i#1 ← ++ (byte) divr8u::i#2
  [104] if((byte) divr8u::i#1!=(byte) 8) goto divr8u::@1
  to:divr8u::@6
divr8u::@6: scope:[divr8u]  from divr8u::@3
  [105] (byte) rem8u#1 ← (byte) divr8u::rem#11
  to:divr8u::@return
divr8u::@return: scope:[divr8u]  from divr8u::@6
  [106] return 
  to:@return

(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
mul8u: scope:[mul8u]  from main::@1
  [107] (word) mul8u::mb#0 ← (word)(byte) mul8u::b#0
  to:mul8u::@1
mul8u::@1: scope:[mul8u]  from mul8u mul8u::@3
  [108] (word) mul8u::mb#2 ← phi( mul8u/(word) mul8u::mb#0 mul8u::@3/(word) mul8u::mb#1 )
  [108] (word) mul8u::res#2 ← phi( mul8u/(word) 0 mul8u::@3/(word) mul8u::res#6 )
  [108] (byte) mul8u::a#2 ← phi( mul8u/(byte) mul8u::a#1 mul8u::@3/(byte) mul8u::a#0 )
  [109] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2
  to:mul8u::@return
mul8u::@return: scope:[mul8u]  from mul8u::@1
  [110] return 
  to:@return
mul8u::@2: scope:[mul8u]  from mul8u::@1
  [111] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1
  [112] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@3
  to:mul8u::@4
mul8u::@4: scope:[mul8u]  from mul8u::@2
  [113] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2
  to:mul8u::@3
mul8u::@3: scope:[mul8u]  from mul8u::@2 mul8u::@4
  [114] (word) mul8u::res#6 ← phi( mul8u::@2/(word) mul8u::res#2 mul8u::@4/(word) mul8u::res#1 )
  [115] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte) 1
  [116] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte) 1
  to:mul8u::@1
