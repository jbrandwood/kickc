Resolved forward reference irq_bottom_1 to interrupt(KERNEL_MIN)(void()) irq_bottom_1()
Resolved forward reference irq_bottom_2 to interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2()
Fixing struct type size struct printf_buffer_number to 12
Fixing struct type size struct printf_buffer_number to 12
Fixing struct type SIZE_OF struct printf_buffer_number to 12
Fixing struct type SIZE_OF struct printf_buffer_number to 12
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call (byte~) $0 ← call toD018 (const nomodify byte*) SCREEN (const nomodify byte*) CANVAS2 
Inlined call (byte~) main::$15 ← call toD018 (const nomodify byte*) SCREEN (const nomodify byte*) CANVAS1 
Inlined call (byte~) main::$16 ← call toD018 (const nomodify byte*) SCREEN (const nomodify byte*) CANVAS2 
Inlined call (byte~) irq_bottom_1::$0 ← call toD018 (const nomodify byte*) CONSOLE (const nomodify byte*) PETSCII 
Inlined call (byte~) irq_bottom_2::$2 ← call toD018 (const nomodify byte*) SCREEN (const nomodify byte*) LINE_BUFFER 
Inlined call call plot (byte) line::x (byte) line::y 
Inlined call call plot (byte) line::x (byte~) line::$15 
Inlined call call plot (byte) line::x (byte) line::y 
Inlined call call plot (byte) line::x (byte) line::y 
Inlined call call plot (byte) line::x (byte) line::y 
Inlined call call plot (byte) line::x (byte) line::y 
Eliminating unused variable with no statement (struct printf_buffer_number) printf_buffer

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@1

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from main main::@13 main::@14 main::@18
  (byte) memset::c#7 ← phi( main/(byte) memset::c#0 main::@13/(byte) memset::c#1 main::@14/(byte) memset::c#2 main::@18/(byte) memset::c#3 )
  (void*) memset::str#6 ← phi( main/(void*) memset::str#0 main::@13/(void*) memset::str#1 main::@14/(void*) memset::str#2 main::@18/(void*) memset::str#3 )
  (word) memset::num#4 ← phi( main/(word) memset::num#0 main::@13/(word) memset::num#1 main::@14/(word) memset::num#2 main::@18/(word) memset::num#3 )
  (bool~) memset::$0 ← (word) memset::num#4 > (number) 0
  (bool~) memset::$1 ← ! (bool~) memset::$0
  if((bool~) memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@3
  (void*) memset::str#4 ← phi( memset/(void*) memset::str#6 memset::@3/(void*) memset::str#7 )
  (void*) memset::return#0 ← (void*) memset::str#4
  to:memset::@return
memset::@2: scope:[memset]  from memset
  (byte) memset::c#6 ← phi( memset/(byte) memset::c#7 )
  (word) memset::num#5 ← phi( memset/(word) memset::num#4 )
  (void*) memset::str#5 ← phi( memset/(void*) memset::str#6 )
  (byte*~) memset::$4 ← (byte*)(void*) memset::str#5
  (byte*~) memset::$2 ← (byte*~) memset::$4 + (word) memset::num#5
  (byte*) memset::end#0 ← (byte*~) memset::$2
  (byte*) memset::dst#0 ← ((byte*)) (void*) memset::str#5
  to:memset::@3
memset::@3: scope:[memset]  from memset::@2 memset::@4
  (byte) memset::c#5 ← phi( memset::@2/(byte) memset::c#6 memset::@4/(byte) memset::c#4 )
  (void*) memset::str#7 ← phi( memset::@2/(void*) memset::str#5 memset::@4/(void*) memset::str#8 )
  (byte*) memset::end#1 ← phi( memset::@2/(byte*) memset::end#0 memset::@4/(byte*) memset::end#2 )
  (byte*) memset::dst#2 ← phi( memset::@2/(byte*) memset::dst#0 memset::@4/(byte*) memset::dst#1 )
  (bool~) memset::$3 ← (byte*) memset::dst#2 != (byte*) memset::end#1
  if((bool~) memset::$3) goto memset::@4
  to:memset::@1
memset::@4: scope:[memset]  from memset::@3
  (void*) memset::str#8 ← phi( memset::@3/(void*) memset::str#7 )
  (byte*) memset::end#2 ← phi( memset::@3/(byte*) memset::end#1 )
  (byte*) memset::dst#3 ← phi( memset::@3/(byte*) memset::dst#2 )
  (byte) memset::c#4 ← phi( memset::@3/(byte) memset::c#5 )
  *((byte*) memset::dst#3) ← (byte) memset::c#4
  (byte*) memset::dst#1 ← ++ (byte*) memset::dst#3
  to:memset::@3
memset::@return: scope:[memset]  from memset::@1
  (void*) memset::return#6 ← phi( memset::@1/(void*) memset::return#0 )
  (void*) memset::return#1 ← (void*) memset::return#6
  return 
  to:@return

(dword()) clock()
clock: scope:[clock]  from main::@12
  (number~) clock::$0 ← (number) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
  (dword) clock::return#0 ← (number~) clock::$0
  to:clock::@return
clock::@return: scope:[clock]  from clock
  (dword) clock::return#3 ← phi( clock/(dword) clock::return#0 )
  (dword) clock::return#1 ← (dword) clock::return#3
  return 
  to:@return

(void()) clock_start()
clock_start: scope:[clock_start]  from main::@8
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  *((const nomodify dword*) CIA2_TIMER_AB) ← (number) $ffffffff
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  return 
  to:@return
@1: scope:[]  from @begin
  (byte) conio_textcolor ← (const nomodify byte) CONIO_TEXTCOLOR_DEFAULT
  to:@2

(byte()) textcolor((byte) textcolor::color)
textcolor: scope:[textcolor]  from main::@16
  (byte) textcolor::color#1 ← phi( main::@16/(byte) textcolor::color#0 )
  (byte) textcolor::old#0 ← (byte) conio_textcolor
  (byte) conio_textcolor ← (byte) textcolor::color#1
  (byte) textcolor::return#0 ← (byte) textcolor::old#0
  to:textcolor::@return
textcolor::@return: scope:[textcolor]  from textcolor
  (byte) textcolor::return#3 ← phi( textcolor/(byte) textcolor::return#0 )
  (byte) textcolor::return#1 ← (byte) textcolor::return#3
  return 
  to:@return

(byte()) kbhit()
kbhit: scope:[kbhit]  from irq_bottom_2
  *((const nomodify byte*) kbhit::CIA1_PORT_A) ← (number) 0
  (byte~) kbhit::$0 ← ~ *((const nomodify byte*) kbhit::CIA1_PORT_B)
  (byte) kbhit::return#0 ← (byte~) kbhit::$0
  to:kbhit::@return
kbhit::@return: scope:[kbhit]  from kbhit
  (byte) kbhit::return#3 ← phi( kbhit/(byte) kbhit::return#0 )
  (byte) kbhit::return#1 ← (byte) kbhit::return#3
  return 
  to:@return
@2: scope:[]  from @1
  (byte*) toD0181_screen#0 ← (const nomodify byte*) SCREEN
  (byte*) toD0181_gfx#0 ← (const nomodify byte*) CANVAS2
  to:toD0181
toD0181: scope:[]  from @2
  (byte*) toD0181_gfx#1 ← phi( @2/(byte*) toD0181_gfx#0 )
  (byte*) toD0181_screen#1 ← phi( @2/(byte*) toD0181_screen#0 )
  (word~) toD0181_$7 ← (word)(byte*) toD0181_screen#1
  (number~) toD0181_$0 ← (word~) toD0181_$7 & (number) $3fff
  (number~) toD0181_$1 ← (number~) toD0181_$0 * (number) 4
  (number~) toD0181_$2 ← > (number~) toD0181_$1
  (byte~) toD0181_$3 ← > (word)(byte*) toD0181_gfx#1
  (number~) toD0181_$4 ← (byte~) toD0181_$3 / (number) 4
  (number~) toD0181_$5 ← (number~) toD0181_$4 & (number) $f
  (number~) toD0181_$6 ← (number~) toD0181_$2 | (number~) toD0181_$5
  (byte) toD0181_return#0 ← (number~) toD0181_$6
  to:toD0181_@return
toD0181_@return: scope:[]  from toD0181
  (byte) toD0181_return#2 ← phi( toD0181/(byte) toD0181_return#0 )
  (byte) toD0181_return#1 ← (byte) toD0181_return#2
  to:@4
@4: scope:[]  from toD0181_@return
  (byte) toD0181_return#3 ← phi( toD0181_@return/(byte) toD0181_return#1 )
  (byte~) $0 ← (byte) toD0181_return#3
  (volatile byte) canvas_show_memory ← (byte~) $0
  (volatile byte) canvas_show_flag ← (byte) 0
  to:@3

(void()) main()
main: scope:[main]  from @3
  (void*) memset::str#0 ← (void*)(const nomodify byte*) CONSOLE
  (byte) memset::c#0 ← (byte) ' '
  (word) memset::num#0 ← (number) $28*(number) $19
  call memset 
  (void*) memset::return#2 ← (void*) memset::return#1
  to:main::@13
main::@13: scope:[main]  from main
  (void*) memset::str#1 ← (void*)(const nomodify byte*) SCREEN
  (byte) memset::c#1 ← (number) 0
  (word) memset::num#1 ← (number) $28*(number) $19
  call memset 
  (void*) memset::return#3 ← (void*) memset::return#1
  to:main::@14
main::@14: scope:[main]  from main::@13
  (void*) memset::str#2 ← (void*)(const nomodify byte*) COLS
  (byte) memset::c#2 ← (const nomodify byte) BLACK
  (word) memset::num#2 ← (number) $28*(number) $19
  call memset 
  (void*) memset::return#4 ← (void*) memset::return#1
  to:main::@15
main::@15: scope:[main]  from main::@14
  (byte*) main::screen#0 ← (const nomodify byte*) SCREEN+(number) $c
  (byte*) main::cols#0 ← (const nomodify byte*) COLS+(number) $c
  (byte) main::y#0 ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main::@15 main::@6
  (byte*) main::screen#6 ← phi( main::@15/(byte*) main::screen#0 main::@6/(byte*) main::screen#1 )
  (byte*) main::cols#6 ← phi( main::@15/(byte*) main::cols#0 main::@6/(byte*) main::cols#1 )
  (byte) main::y#2 ← phi( main::@15/(byte) main::y#0 main::@6/(byte) main::y#1 )
  (bool~) main::$7 ← (byte) main::y#2 < (number) $10
  if((bool~) main::$7) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  (byte*) main::screen#5 ← phi( main::@1/(byte*) main::screen#6 )
  (byte*) main::cols#5 ← phi( main::@1/(byte*) main::cols#6 )
  (byte) main::y#3 ← phi( main::@1/(byte) main::y#2 )
  (byte) main::c#0 ← (byte) main::y#3
  (byte) main::x#0 ← (byte) 0
  to:main::@4
main::@3: scope:[main]  from main::@1
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← (const nomodify byte) BLACK
  call setup_irq 
  to:main::@16
main::@16: scope:[main]  from main::@3
  (byte) textcolor::color#0 ← (const nomodify byte) WHITE
  call textcolor 
  (byte) textcolor::return#2 ← (byte) textcolor::return#1
  to:main::@17
main::@17: scope:[main]  from main::@16
  (byte) main::p0_idx#0 ← (byte) $b5
  (number~) main::$5 ← (byte) main::p0_idx#0 + (number) $f
  (byte) main::p1_idx#0 ← (number~) main::$5
  (number~) main::$6 ← (byte) main::p0_idx#0 + (number) $aa
  (byte) main::p2_idx#0 ← (number~) main::$6
  (byte*) main::canvas#0 ← (const nomodify byte*) CANVAS1
  to:main::@7
main::@4: scope:[main]  from main::@2 main::@5
  (byte) main::y#5 ← phi( main::@2/(byte) main::y#3 main::@5/(byte) main::y#6 )
  (byte*) main::screen#4 ← phi( main::@2/(byte*) main::screen#5 main::@5/(byte*) main::screen#2 )
  (byte) main::c#3 ← phi( main::@2/(byte) main::c#0 main::@5/(byte) main::c#1 )
  (byte*) main::cols#4 ← phi( main::@2/(byte*) main::cols#5 main::@5/(byte*) main::cols#2 )
  (byte) main::x#2 ← phi( main::@2/(byte) main::x#0 main::@5/(byte) main::x#1 )
  (bool~) main::$8 ← (byte) main::x#2 < (number) $10
  if((bool~) main::$8) goto main::@5
  to:main::@6
main::@5: scope:[main]  from main::@4
  (byte) main::y#6 ← phi( main::@4/(byte) main::y#5 )
  (byte*) main::screen#2 ← phi( main::@4/(byte*) main::screen#4 )
  (byte) main::c#2 ← phi( main::@4/(byte) main::c#3 )
  (byte) main::x#3 ← phi( main::@4/(byte) main::x#2 )
  (byte*) main::cols#2 ← phi( main::@4/(byte*) main::cols#4 )
  *((byte*) main::cols#2 + (byte) main::x#3) ← (const nomodify byte) WHITE
  *((byte*) main::screen#2 + (byte) main::x#3) ← (byte) main::c#2
  (byte) main::c#1 ← (byte) main::c#2 + (number) $10
  (byte) main::x#1 ← ++ (byte) main::x#3
  to:main::@4
main::@6: scope:[main]  from main::@4
  (byte) main::y#4 ← phi( main::@4/(byte) main::y#5 )
  (byte*) main::screen#3 ← phi( main::@4/(byte*) main::screen#4 )
  (byte*) main::cols#3 ← phi( main::@4/(byte*) main::cols#4 )
  (byte*) main::cols#1 ← (byte*) main::cols#3 + (number) $28
  (byte*) main::screen#1 ← (byte*) main::screen#3 + (number) $28
  (byte) main::y#1 ← ++ (byte) main::y#4
  to:main::@1
main::@7: scope:[main]  from main::@17 main::@24
  (byte*) main::canvas#11 ← phi( main::@17/(byte*) main::canvas#0 main::@24/(byte*) main::canvas#12 )
  (byte) main::p2_idx#8 ← phi( main::@17/(byte) main::p2_idx#0 main::@24/(byte) main::p2_idx#9 )
  (byte) main::p1_idx#8 ← phi( main::@17/(byte) main::p1_idx#0 main::@24/(byte) main::p1_idx#9 )
  (byte) main::p0_idx#8 ← phi( main::@17/(byte) main::p0_idx#0 main::@24/(byte) main::p0_idx#9 )
  (bool~) main::$21 ← (number) 0 != (number) 1
  if((bool~) main::$21) goto main::@8
  to:main::@return
main::@8: scope:[main]  from main::@7
  (byte*) main::canvas#10 ← phi( main::@7/(byte*) main::canvas#11 )
  (byte) main::p2_idx#7 ← phi( main::@7/(byte) main::p2_idx#8 )
  (byte) main::p1_idx#6 ← phi( main::@7/(byte) main::p1_idx#8 )
  (byte) main::p0_idx#6 ← phi( main::@7/(byte) main::p0_idx#8 )
  call clock_start 
  to:main::@18
main::@18: scope:[main]  from main::@8
  (byte*) main::canvas#9 ← phi( main::@8/(byte*) main::canvas#10 )
  (byte) main::p2_idx#6 ← phi( main::@8/(byte) main::p2_idx#7 )
  (byte) main::p1_idx#4 ← phi( main::@8/(byte) main::p1_idx#6 )
  (byte) main::p0_idx#4 ← phi( main::@8/(byte) main::p0_idx#6 )
  (void*) memset::str#3 ← (void*)(const nomodify byte*) LINE_BUFFER
  (byte) memset::c#3 ← (number) 0
  (word) memset::num#3 ← (number) $800
  call memset 
  (void*) memset::return#5 ← (void*) memset::return#1
  to:main::@19
main::@19: scope:[main]  from main::@18
  (byte*) main::canvas#8 ← phi( main::@18/(byte*) main::canvas#9 )
  (byte) main::p2_idx#4 ← phi( main::@18/(byte) main::p2_idx#6 )
  (byte) main::p1_idx#2 ← phi( main::@18/(byte) main::p1_idx#4 )
  (byte) main::p0_idx#2 ← phi( main::@18/(byte) main::p0_idx#4 )
  (byte) main::x0#0 ← *((const byte*) COSTAB + (byte) main::p0_idx#2)
  (byte) main::y0#0 ← *((const byte*) SINTAB + (byte) main::p0_idx#2)
  (byte) main::x1#0 ← *((const byte*) COSTAB + (byte) main::p1_idx#2)
  (byte) main::y1#0 ← *((const byte*) SINTAB + (byte) main::p1_idx#2)
  (byte*) line::canvas#0 ← (const nomodify byte*) LINE_BUFFER
  (byte) line::x1#0 ← (byte) main::x0#0
  (byte) line::y1#0 ← (byte) main::y0#0
  (byte) line::x2#0 ← (byte) main::x1#0
  (byte) line::y2#0 ← (byte) main::y1#0
  call line 
  to:main::@20
main::@20: scope:[main]  from main::@19
  (byte*) main::canvas#7 ← phi( main::@19/(byte*) main::canvas#8 )
  (byte) main::p1_idx#7 ← phi( main::@19/(byte) main::p1_idx#2 )
  (byte) main::p0_idx#7 ← phi( main::@19/(byte) main::p0_idx#2 )
  (byte) main::y0#2 ← phi( main::@19/(byte) main::y0#0 )
  (byte) main::x0#2 ← phi( main::@19/(byte) main::x0#0 )
  (byte) main::y1#1 ← phi( main::@19/(byte) main::y1#0 )
  (byte) main::x1#1 ← phi( main::@19/(byte) main::x1#0 )
  (byte) main::p2_idx#2 ← phi( main::@19/(byte) main::p2_idx#4 )
  (byte) main::x2#0 ← *((const byte*) COSTAB + (byte) main::p2_idx#2)
  (byte) main::y2#0 ← *((const byte*) SINTAB + (byte) main::p2_idx#2)
  (byte*) line::canvas#1 ← (const nomodify byte*) LINE_BUFFER
  (byte) line::x1#1 ← (byte) main::x1#1
  (byte) line::y1#1 ← (byte) main::y1#1
  (byte) line::x2#1 ← (byte) main::x2#0
  (byte) line::y2#1 ← (byte) main::y2#0
  call line 
  to:main::@21
main::@21: scope:[main]  from main::@20
  (byte*) main::canvas#6 ← phi( main::@20/(byte*) main::canvas#7 )
  (byte) main::p2_idx#5 ← phi( main::@20/(byte) main::p2_idx#2 )
  (byte) main::p1_idx#5 ← phi( main::@20/(byte) main::p1_idx#7 )
  (byte) main::p0_idx#5 ← phi( main::@20/(byte) main::p0_idx#7 )
  (byte) main::y0#1 ← phi( main::@20/(byte) main::y0#2 )
  (byte) main::x0#1 ← phi( main::@20/(byte) main::x0#2 )
  (byte) main::y2#1 ← phi( main::@20/(byte) main::y2#0 )
  (byte) main::x2#1 ← phi( main::@20/(byte) main::x2#0 )
  (byte*) line::canvas#2 ← (const nomodify byte*) LINE_BUFFER
  (byte) line::x1#2 ← (byte) main::x2#1
  (byte) line::y1#2 ← (byte) main::y2#1
  (byte) line::x2#2 ← (byte) main::x0#1
  (byte) line::y2#2 ← (byte) main::y0#1
  call line 
  to:main::@22
main::@22: scope:[main]  from main::@21
  (byte*) main::canvas#5 ← phi( main::@21/(byte*) main::canvas#6 )
  (byte) main::p2_idx#3 ← phi( main::@21/(byte) main::p2_idx#5 )
  (byte) main::p1_idx#3 ← phi( main::@21/(byte) main::p1_idx#5 )
  (byte) main::p0_idx#3 ← phi( main::@21/(byte) main::p0_idx#5 )
  (byte) main::p0_idx#1 ← ++ (byte) main::p0_idx#3
  (byte) main::p1_idx#1 ← ++ (byte) main::p1_idx#3
  (byte) main::p2_idx#1 ← ++ (byte) main::p2_idx#3
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) RED
  to:main::@9
main::@9: scope:[main]  from main::@22 main::@9
  (byte) main::p2_idx#18 ← phi( main::@22/(byte) main::p2_idx#1 main::@9/(byte) main::p2_idx#18 )
  (byte) main::p1_idx#18 ← phi( main::@22/(byte) main::p1_idx#1 main::@9/(byte) main::p1_idx#18 )
  (byte) main::p0_idx#18 ← phi( main::@22/(byte) main::p0_idx#1 main::@9/(byte) main::p0_idx#18 )
  (byte*) main::canvas#4 ← phi( main::@22/(byte*) main::canvas#5 main::@9/(byte*) main::canvas#4 )
  (bool~) main::$22 ← (number) 0 != (volatile byte) canvas_show_flag
  if((bool~) main::$22) goto main::@9
  to:main::@10
main::@10: scope:[main]  from main::@9
  (byte) main::p2_idx#17 ← phi( main::@9/(byte) main::p2_idx#18 )
  (byte) main::p1_idx#17 ← phi( main::@9/(byte) main::p1_idx#18 )
  (byte) main::p0_idx#17 ← phi( main::@9/(byte) main::p0_idx#18 )
  (byte*) main::canvas#2 ← phi( main::@9/(byte*) main::canvas#4 )
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK
  (byte*) eorfill::line_buffer#0 ← (const nomodify byte*) LINE_BUFFER
  (byte*) eorfill::canvas#0 ← (byte*) main::canvas#2
  call eorfill 
  to:main::@23
main::@23: scope:[main]  from main::@10
  (byte) main::p2_idx#16 ← phi( main::@10/(byte) main::p2_idx#17 )
  (byte) main::p1_idx#16 ← phi( main::@10/(byte) main::p1_idx#17 )
  (byte) main::p0_idx#16 ← phi( main::@10/(byte) main::p0_idx#17 )
  (byte*) main::canvas#3 ← phi( main::@10/(byte*) main::canvas#2 )
  (word~) main::$20 ← (byte*) main::canvas#3 ^ (const nomodify byte*) CANVAS1^(const nomodify byte*) CANVAS2
  (byte*) main::canvas#1 ← ((byte*)) (word~) main::$20
  (byte*) main::toD0181_screen#0 ← (const nomodify byte*) SCREEN
  (byte*) main::toD0181_gfx#0 ← (const nomodify byte*) CANVAS1
  to:main::toD0181
main::toD0181: scope:[main]  from main::@23
  (byte*) main::canvas#18 ← phi( main::@23/(byte*) main::canvas#1 )
  (byte) main::p2_idx#15 ← phi( main::@23/(byte) main::p2_idx#16 )
  (byte) main::p1_idx#15 ← phi( main::@23/(byte) main::p1_idx#16 )
  (byte) main::p0_idx#15 ← phi( main::@23/(byte) main::p0_idx#16 )
  (byte*) main::toD0181_gfx#1 ← phi( main::@23/(byte*) main::toD0181_gfx#0 )
  (byte*) main::toD0181_screen#1 ← phi( main::@23/(byte*) main::toD0181_screen#0 )
  (word~) main::toD0181_$7 ← (word)(byte*) main::toD0181_screen#1
  (number~) main::toD0181_$0 ← (word~) main::toD0181_$7 & (number) $3fff
  (number~) main::toD0181_$1 ← (number~) main::toD0181_$0 * (number) 4
  (number~) main::toD0181_$2 ← > (number~) main::toD0181_$1
  (byte~) main::toD0181_$3 ← > (word)(byte*) main::toD0181_gfx#1
  (number~) main::toD0181_$4 ← (byte~) main::toD0181_$3 / (number) 4
  (number~) main::toD0181_$5 ← (number~) main::toD0181_$4 & (number) $f
  (number~) main::toD0181_$6 ← (number~) main::toD0181_$2 | (number~) main::toD0181_$5
  (byte) main::toD0181_return#0 ← (number~) main::toD0181_$6
  to:main::toD0181_@return
main::toD0181_@return: scope:[main]  from main::toD0181
  (byte*) main::canvas#17 ← phi( main::toD0181/(byte*) main::canvas#18 )
  (byte) main::p2_idx#14 ← phi( main::toD0181/(byte) main::p2_idx#15 )
  (byte) main::p1_idx#14 ← phi( main::toD0181/(byte) main::p1_idx#15 )
  (byte) main::p0_idx#14 ← phi( main::toD0181/(byte) main::p0_idx#15 )
  (byte) main::toD0181_return#2 ← phi( main::toD0181/(byte) main::toD0181_return#0 )
  (byte) main::toD0181_return#1 ← (byte) main::toD0181_return#2
  to:main::@11
main::@11: scope:[main]  from main::toD0181_@return
  (byte*) main::canvas#16 ← phi( main::toD0181_@return/(byte*) main::canvas#17 )
  (byte) main::p2_idx#13 ← phi( main::toD0181_@return/(byte) main::p2_idx#14 )
  (byte) main::p1_idx#13 ← phi( main::toD0181_@return/(byte) main::p1_idx#14 )
  (byte) main::p0_idx#13 ← phi( main::toD0181_@return/(byte) main::p0_idx#14 )
  (byte) main::toD0181_return#3 ← phi( main::toD0181_@return/(byte) main::toD0181_return#1 )
  (byte~) main::$15 ← (byte) main::toD0181_return#3
  (byte*) main::toD0182_screen#0 ← (const nomodify byte*) SCREEN
  (byte*) main::toD0182_gfx#0 ← (const nomodify byte*) CANVAS2
  to:main::toD0182
main::toD0182: scope:[main]  from main::@11
  (byte*) main::canvas#15 ← phi( main::@11/(byte*) main::canvas#16 )
  (byte) main::p2_idx#12 ← phi( main::@11/(byte) main::p2_idx#13 )
  (byte) main::p1_idx#12 ← phi( main::@11/(byte) main::p1_idx#13 )
  (byte) main::p0_idx#12 ← phi( main::@11/(byte) main::p0_idx#13 )
  (byte*) main::toD0182_gfx#1 ← phi( main::@11/(byte*) main::toD0182_gfx#0 )
  (byte*) main::toD0182_screen#1 ← phi( main::@11/(byte*) main::toD0182_screen#0 )
  (word~) main::toD0182_$7 ← (word)(byte*) main::toD0182_screen#1
  (number~) main::toD0182_$0 ← (word~) main::toD0182_$7 & (number) $3fff
  (number~) main::toD0182_$1 ← (number~) main::toD0182_$0 * (number) 4
  (number~) main::toD0182_$2 ← > (number~) main::toD0182_$1
  (byte~) main::toD0182_$3 ← > (word)(byte*) main::toD0182_gfx#1
  (number~) main::toD0182_$4 ← (byte~) main::toD0182_$3 / (number) 4
  (number~) main::toD0182_$5 ← (number~) main::toD0182_$4 & (number) $f
  (number~) main::toD0182_$6 ← (number~) main::toD0182_$2 | (number~) main::toD0182_$5
  (byte) main::toD0182_return#0 ← (number~) main::toD0182_$6
  to:main::toD0182_@return
main::toD0182_@return: scope:[main]  from main::toD0182
  (byte*) main::canvas#14 ← phi( main::toD0182/(byte*) main::canvas#15 )
  (byte) main::p2_idx#11 ← phi( main::toD0182/(byte) main::p2_idx#12 )
  (byte) main::p1_idx#11 ← phi( main::toD0182/(byte) main::p1_idx#12 )
  (byte) main::p0_idx#11 ← phi( main::toD0182/(byte) main::p0_idx#12 )
  (byte) main::toD0182_return#2 ← phi( main::toD0182/(byte) main::toD0182_return#0 )
  (byte) main::toD0182_return#1 ← (byte) main::toD0182_return#2
  to:main::@12
main::@12: scope:[main]  from main::toD0182_@return
  (byte*) main::canvas#13 ← phi( main::toD0182_@return/(byte*) main::canvas#14 )
  (byte) main::p2_idx#10 ← phi( main::toD0182_@return/(byte) main::p2_idx#11 )
  (byte) main::p1_idx#10 ← phi( main::toD0182_@return/(byte) main::p1_idx#11 )
  (byte) main::p0_idx#10 ← phi( main::toD0182_@return/(byte) main::p0_idx#11 )
  (byte) main::toD0182_return#3 ← phi( main::toD0182_@return/(byte) main::toD0182_return#1 )
  (byte~) main::$16 ← (byte) main::toD0182_return#3
  (byte~) main::$17 ← (byte~) main::$15 ^ (byte~) main::$16
  (volatile byte) canvas_show_memory ← (volatile byte) canvas_show_memory ^ (byte~) main::$17
  (volatile byte) canvas_show_flag ← (number) 1
  call clock 
  (dword) clock::return#2 ← (dword) clock::return#1
  to:main::@24
main::@24: scope:[main]  from main::@12
  (byte*) main::canvas#12 ← phi( main::@12/(byte*) main::canvas#13 )
  (byte) main::p2_idx#9 ← phi( main::@12/(byte) main::p2_idx#10 )
  (byte) main::p1_idx#9 ← phi( main::@12/(byte) main::p1_idx#10 )
  (byte) main::p0_idx#9 ← phi( main::@12/(byte) main::p0_idx#10 )
  to:main::@7
main::@return: scope:[main]  from main::@7
  return 
  to:@return

(void()) setup_irq()
setup_irq: scope:[setup_irq]  from main::@3
  asm { sei  }
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (number) $7f
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(number) 8
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER
  *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1()
  asm { cli  }
  to:setup_irq::@return
setup_irq::@return: scope:[setup_irq]  from setup_irq
  return 
  to:@return

interrupt(KERNEL_MIN)(void()) irq_bottom_1()
irq_bottom_1: scope:[irq_bottom_1]  from
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) DARK_GREY
  (byte*) irq_bottom_1::toD0181_screen#0 ← (const nomodify byte*) CONSOLE
  (byte*) irq_bottom_1::toD0181_gfx#0 ← (const nomodify byte*) PETSCII
  to:irq_bottom_1::toD0181
irq_bottom_1::toD0181: scope:[irq_bottom_1]  from irq_bottom_1
  (byte*) irq_bottom_1::toD0181_gfx#1 ← phi( irq_bottom_1/(byte*) irq_bottom_1::toD0181_gfx#0 )
  (byte*) irq_bottom_1::toD0181_screen#1 ← phi( irq_bottom_1/(byte*) irq_bottom_1::toD0181_screen#0 )
  (word~) irq_bottom_1::toD0181_$7 ← (word)(byte*) irq_bottom_1::toD0181_screen#1
  (number~) irq_bottom_1::toD0181_$0 ← (word~) irq_bottom_1::toD0181_$7 & (number) $3fff
  (number~) irq_bottom_1::toD0181_$1 ← (number~) irq_bottom_1::toD0181_$0 * (number) 4
  (number~) irq_bottom_1::toD0181_$2 ← > (number~) irq_bottom_1::toD0181_$1
  (byte~) irq_bottom_1::toD0181_$3 ← > (word)(byte*) irq_bottom_1::toD0181_gfx#1
  (number~) irq_bottom_1::toD0181_$4 ← (byte~) irq_bottom_1::toD0181_$3 / (number) 4
  (number~) irq_bottom_1::toD0181_$5 ← (number~) irq_bottom_1::toD0181_$4 & (number) $f
  (number~) irq_bottom_1::toD0181_$6 ← (number~) irq_bottom_1::toD0181_$2 | (number~) irq_bottom_1::toD0181_$5
  (byte) irq_bottom_1::toD0181_return#0 ← (number~) irq_bottom_1::toD0181_$6
  to:irq_bottom_1::toD0181_@return
irq_bottom_1::toD0181_@return: scope:[irq_bottom_1]  from irq_bottom_1::toD0181
  (byte) irq_bottom_1::toD0181_return#2 ← phi( irq_bottom_1::toD0181/(byte) irq_bottom_1::toD0181_return#0 )
  (byte) irq_bottom_1::toD0181_return#1 ← (byte) irq_bottom_1::toD0181_return#2
  to:irq_bottom_1::@1
irq_bottom_1::@1: scope:[irq_bottom_1]  from irq_bottom_1::toD0181_@return
  (byte) irq_bottom_1::toD0181_return#3 ← phi( irq_bottom_1::toD0181_@return/(byte) irq_bottom_1::toD0181_return#1 )
  (byte~) irq_bottom_1::$0 ← (byte) irq_bottom_1::toD0181_return#3
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (byte~) irq_bottom_1::$0
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM
  *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2()
  to:irq_bottom_1::@return
irq_bottom_1::@return: scope:[irq_bottom_1]  from irq_bottom_1::@1
  return 
  to:@return

interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2()
irq_bottom_2: scope:[irq_bottom_2]  from
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK
  call kbhit 
  (byte) kbhit::return#2 ← (byte) kbhit::return#1
  to:irq_bottom_2::@5
irq_bottom_2::@5: scope:[irq_bottom_2]  from irq_bottom_2
  (byte) kbhit::return#4 ← phi( irq_bottom_2/(byte) kbhit::return#2 )
  (byte~) irq_bottom_2::$0 ← (byte) kbhit::return#4
  (bool~) irq_bottom_2::$3 ← (number) 0 != (byte~) irq_bottom_2::$0
  (bool~) irq_bottom_2::$1 ← ! (bool~) irq_bottom_2::$3
  if((bool~) irq_bottom_2::$1) goto irq_bottom_2::@1
  to:irq_bottom_2::@3
irq_bottom_2::@1: scope:[irq_bottom_2]  from irq_bottom_2::@5
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (volatile byte) canvas_show_memory
  to:irq_bottom_2::@2
irq_bottom_2::@3: scope:[irq_bottom_2]  from irq_bottom_2::@5
  (byte*) irq_bottom_2::toD0181_screen#0 ← (const nomodify byte*) SCREEN
  (byte*) irq_bottom_2::toD0181_gfx#0 ← (const nomodify byte*) LINE_BUFFER
  to:irq_bottom_2::toD0181
irq_bottom_2::toD0181: scope:[irq_bottom_2]  from irq_bottom_2::@3
  (byte*) irq_bottom_2::toD0181_gfx#1 ← phi( irq_bottom_2::@3/(byte*) irq_bottom_2::toD0181_gfx#0 )
  (byte*) irq_bottom_2::toD0181_screen#1 ← phi( irq_bottom_2::@3/(byte*) irq_bottom_2::toD0181_screen#0 )
  (word~) irq_bottom_2::toD0181_$7 ← (word)(byte*) irq_bottom_2::toD0181_screen#1
  (number~) irq_bottom_2::toD0181_$0 ← (word~) irq_bottom_2::toD0181_$7 & (number) $3fff
  (number~) irq_bottom_2::toD0181_$1 ← (number~) irq_bottom_2::toD0181_$0 * (number) 4
  (number~) irq_bottom_2::toD0181_$2 ← > (number~) irq_bottom_2::toD0181_$1
  (byte~) irq_bottom_2::toD0181_$3 ← > (word)(byte*) irq_bottom_2::toD0181_gfx#1
  (number~) irq_bottom_2::toD0181_$4 ← (byte~) irq_bottom_2::toD0181_$3 / (number) 4
  (number~) irq_bottom_2::toD0181_$5 ← (number~) irq_bottom_2::toD0181_$4 & (number) $f
  (number~) irq_bottom_2::toD0181_$6 ← (number~) irq_bottom_2::toD0181_$2 | (number~) irq_bottom_2::toD0181_$5
  (byte) irq_bottom_2::toD0181_return#0 ← (number~) irq_bottom_2::toD0181_$6
  to:irq_bottom_2::toD0181_@return
irq_bottom_2::toD0181_@return: scope:[irq_bottom_2]  from irq_bottom_2::toD0181
  (byte) irq_bottom_2::toD0181_return#2 ← phi( irq_bottom_2::toD0181/(byte) irq_bottom_2::toD0181_return#0 )
  (byte) irq_bottom_2::toD0181_return#1 ← (byte) irq_bottom_2::toD0181_return#2
  to:irq_bottom_2::@4
irq_bottom_2::@4: scope:[irq_bottom_2]  from irq_bottom_2::toD0181_@return
  (byte) irq_bottom_2::toD0181_return#3 ← phi( irq_bottom_2::toD0181_@return/(byte) irq_bottom_2::toD0181_return#1 )
  (byte~) irq_bottom_2::$2 ← (byte) irq_bottom_2::toD0181_return#3
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (byte~) irq_bottom_2::$2
  to:irq_bottom_2::@2
irq_bottom_2::@2: scope:[irq_bottom_2]  from irq_bottom_2::@1 irq_bottom_2::@4
  (volatile byte) canvas_show_flag ← (number) 0
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(number) 8
  *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1()
  to:irq_bottom_2::@return
irq_bottom_2::@return: scope:[irq_bottom_2]  from irq_bottom_2::@2
  return 
  to:@return

(void()) line((byte*) line::canvas , (byte) line::x1 , (byte) line::y1 , (byte) line::x2 , (byte) line::y2)
line: scope:[line]  from main::@19 main::@20 main::@21
  (byte) line::y2#8 ← phi( main::@19/(byte) line::y2#0 main::@20/(byte) line::y2#1 main::@21/(byte) line::y2#2 )
  (byte) line::x2#3 ← phi( main::@19/(byte) line::x2#0 main::@20/(byte) line::x2#1 main::@21/(byte) line::x2#2 )
  (byte) line::y1#3 ← phi( main::@19/(byte) line::y1#0 main::@20/(byte) line::y1#1 main::@21/(byte) line::y1#2 )
  (byte) line::x1#3 ← phi( main::@19/(byte) line::x1#0 main::@20/(byte) line::x1#1 main::@21/(byte) line::x1#2 )
  (byte) line::x#0 ← (byte) line::x1#3
  (byte) line::y#0 ← (byte) line::y1#3
  (byte~) line::$0 ← (byte) line::x2#3 - (byte) line::x1#3
  (byte) abs_u8::u#0 ← (byte~) line::$0
  call abs_u8 
  (byte) abs_u8::return#0 ← (byte) abs_u8::return#4
  to:line::@22
line::@22: scope:[line]  from line
  (byte) line::x#32 ← phi( line/(byte) line::x#0 )
  (byte) line::y#33 ← phi( line/(byte) line::y#0 )
  (byte) line::x1#5 ← phi( line/(byte) line::x1#3 )
  (byte) line::x2#7 ← phi( line/(byte) line::x2#3 )
  (byte) line::y1#4 ← phi( line/(byte) line::y1#3 )
  (byte) line::y2#4 ← phi( line/(byte) line::y2#8 )
  (byte) abs_u8::return#5 ← phi( line/(byte) abs_u8::return#0 )
  (byte~) line::$1 ← (byte) abs_u8::return#5
  (byte) line::dx#0 ← (byte~) line::$1
  (byte~) line::$2 ← (byte) line::y2#4 - (byte) line::y1#4
  (byte) abs_u8::u#1 ← (byte~) line::$2
  call abs_u8 
  (byte) abs_u8::return#1 ← (byte) abs_u8::return#4
  to:line::@23
line::@23: scope:[line]  from line::@22
  (byte) line::x#31 ← phi( line::@22/(byte) line::x#32 )
  (byte) line::y#31 ← phi( line::@22/(byte) line::y#33 )
  (byte) line::dx#22 ← phi( line::@22/(byte) line::dx#0 )
  (byte) line::y1#6 ← phi( line::@22/(byte) line::y1#4 )
  (byte) line::y2#9 ← phi( line::@22/(byte) line::y2#4 )
  (byte) line::x1#4 ← phi( line::@22/(byte) line::x1#5 )
  (byte) line::x2#4 ← phi( line::@22/(byte) line::x2#7 )
  (byte) abs_u8::return#6 ← phi( line::@22/(byte) abs_u8::return#1 )
  (byte~) line::$3 ← (byte) abs_u8::return#6
  (byte) line::dy#0 ← (byte~) line::$3
  (byte~) line::$4 ← (byte) line::x2#4 - (byte) line::x1#4
  (byte) sgn_u8::u#0 ← (byte~) line::$4
  call sgn_u8 
  (byte) sgn_u8::return#0 ← (byte) sgn_u8::return#4
  to:line::@24
line::@24: scope:[line]  from line::@23
  (byte) line::x2#22 ← phi( line::@23/(byte) line::x2#4 )
  (byte) line::x#29 ← phi( line::@23/(byte) line::x#31 )
  (byte) line::y#25 ← phi( line::@23/(byte) line::y#31 )
  (byte) line::dy#17 ← phi( line::@23/(byte) line::dy#0 )
  (byte) line::dx#16 ← phi( line::@23/(byte) line::dx#22 )
  (byte) line::y1#5 ← phi( line::@23/(byte) line::y1#6 )
  (byte) line::y2#5 ← phi( line::@23/(byte) line::y2#9 )
  (byte) sgn_u8::return#5 ← phi( line::@23/(byte) sgn_u8::return#0 )
  (byte~) line::$5 ← (byte) sgn_u8::return#5
  (byte) line::sx#0 ← (byte~) line::$5
  (byte~) line::$6 ← (byte) line::y2#5 - (byte) line::y1#5
  (byte) sgn_u8::u#1 ← (byte~) line::$6
  call sgn_u8 
  (byte) sgn_u8::return#1 ← (byte) sgn_u8::return#4
  to:line::@25
line::@25: scope:[line]  from line::@24
  (byte) line::x2#19 ← phi( line::@24/(byte) line::x2#22 )
  (byte) line::x#26 ← phi( line::@24/(byte) line::x#29 )
  (byte) line::y2#10 ← phi( line::@24/(byte) line::y2#5 )
  (byte) line::y#16 ← phi( line::@24/(byte) line::y#25 )
  (byte) line::dy#9 ← phi( line::@24/(byte) line::dy#17 )
  (byte) line::dx#8 ← phi( line::@24/(byte) line::dx#16 )
  (byte) line::sx#1 ← phi( line::@24/(byte) line::sx#0 )
  (byte) sgn_u8::return#6 ← phi( line::@24/(byte) sgn_u8::return#1 )
  (byte~) line::$7 ← (byte) sgn_u8::return#6
  (byte) line::sy#0 ← (byte~) line::$7
  (bool~) line::$8 ← (byte) line::sx#1 == (number) $ff
  (bool~) line::$9 ← ! (bool~) line::$8
  if((bool~) line::$9) goto line::@1
  to:line::@3
line::@1: scope:[line]  from line::@25 line::@3
  (byte) line::x2#17 ← phi( line::@25/(byte) line::x2#19 line::@3/(byte) line::x2#20 )
  (byte) line::y2#17 ← phi( line::@25/(byte) line::y2#10 line::@3/(byte) line::y2#3 )
  (byte) line::y#26 ← phi( line::@25/(byte) line::y#16 line::@3/(byte) line::y#1 )
  (byte) line::x#23 ← phi( line::@25/(byte) line::x#26 line::@3/(byte) line::x#27 )
  (byte) line::sy#6 ← phi( line::@25/(byte) line::sy#0 line::@3/(byte) line::sy#12 )
  (byte) line::sx#6 ← phi( line::@25/(byte) line::sx#1 line::@3/(byte) line::sx#10 )
  (byte) line::dy#1 ← phi( line::@25/(byte) line::dy#9 line::@3/(byte) line::dy#10 )
  (byte) line::dx#1 ← phi( line::@25/(byte) line::dx#8 line::@3/(byte) line::dx#9 )
  (bool~) line::$10 ← (byte) line::dx#1 > (byte) line::dy#1
  if((bool~) line::$10) goto line::@2
  to:line::@4
line::@3: scope:[line]  from line::@25
  (byte) line::x2#20 ← phi( line::@25/(byte) line::x2#19 )
  (byte) line::x#27 ← phi( line::@25/(byte) line::x#26 )
  (byte) line::sy#12 ← phi( line::@25/(byte) line::sy#0 )
  (byte) line::sx#10 ← phi( line::@25/(byte) line::sx#1 )
  (byte) line::dy#10 ← phi( line::@25/(byte) line::dy#9 )
  (byte) line::dx#9 ← phi( line::@25/(byte) line::dx#8 )
  (byte) line::y2#6 ← phi( line::@25/(byte) line::y2#10 )
  (byte) line::y#5 ← phi( line::@25/(byte) line::y#16 )
  (byte) line::y#1 ← ++ (byte) line::y#5
  (byte) line::y2#3 ← ++ (byte) line::y2#6
  to:line::@1
line::@2: scope:[line]  from line::@1
  (byte) line::sy#23 ← phi( line::@1/(byte) line::sy#6 )
  (byte) line::x2#16 ← phi( line::@1/(byte) line::x2#17 )
  (byte) line::dy#24 ← phi( line::@1/(byte) line::dy#1 )
  (byte) line::sx#19 ← phi( line::@1/(byte) line::sx#6 )
  (byte) line::y#23 ← phi( line::@1/(byte) line::y#26 )
  (byte) line::x#20 ← phi( line::@1/(byte) line::x#23 )
  (byte) line::dx#2 ← phi( line::@1/(byte) line::dx#1 )
  (number~) line::$26 ← (byte) line::dx#2 / (number) 2
  (byte) line::e2#0 ← (number~) line::$26
  to:line::@14
line::@4: scope:[line]  from line::@1
  (byte) line::x2#24 ← phi( line::@1/(byte) line::x2#17 )
  (byte) line::y2#15 ← phi( line::@1/(byte) line::y2#17 )
  (byte) line::dx#18 ← phi( line::@1/(byte) line::dx#1 )
  (byte) line::dy#11 ← phi( line::@1/(byte) line::dy#1 )
  (byte) line::y#17 ← phi( line::@1/(byte) line::y#26 )
  (byte) line::x#14 ← phi( line::@1/(byte) line::x#23 )
  (byte) line::sy#1 ← phi( line::@1/(byte) line::sy#6 )
  (byte) line::sx#2 ← phi( line::@1/(byte) line::sx#6 )
  (bool~) line::$11 ← (byte) line::sx#2 == (byte) line::sy#1
  if((bool~) line::$11) goto line::@6
  to:line::@5
line::@6: scope:[line]  from line::@4
  (byte) line::x2#23 ← phi( line::@4/(byte) line::x2#24 )
  (byte) line::sx#24 ← phi( line::@4/(byte) line::sx#2 )
  (byte) line::sy#21 ← phi( line::@4/(byte) line::sy#1 )
  (byte) line::dy#22 ← phi( line::@4/(byte) line::dy#11 )
  (byte) line::dx#17 ← phi( line::@4/(byte) line::dx#18 )
  (byte) line::y#6 ← phi( line::@4/(byte) line::y#17 )
  (byte) line::x#4 ← phi( line::@4/(byte) line::x#14 )
  (byte) line::plot1_x#0 ← (byte) line::x#4
  (byte) line::plot1_y#0 ← (byte) line::y#6
  to:line::plot1
line::plot1: scope:[line]  from line::@6
  (byte) line::x2#21 ← phi( line::@6/(byte) line::x2#23 )
  (byte) line::sx#20 ← phi( line::@6/(byte) line::sx#24 )
  (byte) line::x#30 ← phi( line::@6/(byte) line::x#4 )
  (byte) line::sy#17 ← phi( line::@6/(byte) line::sy#21 )
  (byte) line::y#32 ← phi( line::@6/(byte) line::y#6 )
  (byte) line::dy#18 ← phi( line::@6/(byte) line::dy#22 )
  (byte) line::dx#10 ← phi( line::@6/(byte) line::dx#17 )
  (byte) line::plot1_y#1 ← phi( line::@6/(byte) line::plot1_y#0 )
  (byte) line::plot1_x#1 ← phi( line::@6/(byte) line::plot1_x#0 )
  (number~) line::plot1_$0 ← (byte) line::plot1_x#1 / (number) 8
  (number~) line::plot1_$2 ← (number~) line::plot1_$0 * (const byte) SIZEOF_POINTER
  (byte*) line::plot1_column#0 ← *((const byte**) plot_column + (number~) line::plot1_$2)
  (number~) line::plot1_$1 ← (byte) line::plot1_x#1 & (number) 7
  *((byte*) line::plot1_column#0 + (byte) line::plot1_y#1) ← *((byte*) line::plot1_column#0 + (byte) line::plot1_y#1) | *((const byte*) plot_bit + (number~) line::plot1_$1)
  to:line::@18
line::@18: scope:[line]  from line::plot1
  (byte) line::x2#18 ← phi( line::plot1/(byte) line::x2#21 )
  (byte) line::sx#16 ← phi( line::plot1/(byte) line::sx#20 )
  (byte) line::x#28 ← phi( line::plot1/(byte) line::x#30 )
  (byte) line::sy#14 ← phi( line::plot1/(byte) line::sy#17 )
  (byte) line::y#28 ← phi( line::plot1/(byte) line::y#32 )
  (byte) line::dy#14 ← phi( line::plot1/(byte) line::dy#18 )
  (byte) line::dx#3 ← phi( line::plot1/(byte) line::dx#10 )
  (bool~) line::$20 ← (byte) line::dx#3 == (number) 0
  (bool~) line::$21 ← ! (bool~) line::$20
  if((bool~) line::$21) goto line::@11
  to:line::@return
line::@5: scope:[line]  from line::@4
  (byte) line::sx#21 ← phi( line::@4/(byte) line::sx#2 )
  (byte) line::x#24 ← phi( line::@4/(byte) line::x#14 )
  (byte) line::y2#13 ← phi( line::@4/(byte) line::y2#15 )
  (byte) line::dx#11 ← phi( line::@4/(byte) line::dx#18 )
  (byte) line::sy#7 ← phi( line::@4/(byte) line::sy#1 )
  (byte) line::y#18 ← phi( line::@4/(byte) line::y#17 )
  (byte) line::dy#2 ← phi( line::@4/(byte) line::dy#11 )
  (number~) line::$12 ← (byte) line::dy#2 / (number) 2
  (byte) line::e#0 ← (number~) line::$12
  to:line::@7
line::@7: scope:[line]  from line::@5 line::@8
  (byte) line::sx#15 ← phi( line::@5/(byte) line::sx#21 line::@8/(byte) line::sx#22 )
  (byte) line::x#15 ← phi( line::@5/(byte) line::x#24 line::@8/(byte) line::x#17 )
  (byte) line::y2#12 ← phi( line::@5/(byte) line::y2#13 line::@8/(byte) line::y2#7 )
  (byte) line::dy#3 ← phi( line::@5/(byte) line::dy#2 line::@8/(byte) line::dy#12 )
  (byte) line::dx#4 ← phi( line::@5/(byte) line::dx#11 line::@8/(byte) line::dx#12 )
  (byte) line::e#3 ← phi( line::@5/(byte) line::e#0 line::@8/(byte) line::e#5 )
  (byte) line::sy#2 ← phi( line::@5/(byte) line::sy#7 line::@8/(byte) line::sy#8 )
  (byte) line::y#7 ← phi( line::@5/(byte) line::y#18 line::@8/(byte) line::y#8 )
  (byte) line::y#2 ← (byte) line::y#7 + (byte) line::sy#2
  (byte) line::e#1 ← (byte) line::e#3 + (byte) line::dx#4
  (bool~) line::$13 ← (byte) line::e#1 > (byte) line::dy#3
  (bool~) line::$14 ← ! (bool~) line::$13
  if((bool~) line::$14) goto line::@8
  to:line::@9
line::@8: scope:[line]  from line::@19 line::@7
  (byte) line::sx#22 ← phi( line::@19/(byte) line::sx#3 line::@7/(byte) line::sx#15 )
  (byte) line::x#17 ← phi( line::@19/(byte) line::x#1 line::@7/(byte) line::x#15 )
  (byte) line::dy#12 ← phi( line::@19/(byte) line::dy#4 line::@7/(byte) line::dy#3 )
  (byte) line::dx#12 ← phi( line::@19/(byte) line::dx#19 line::@7/(byte) line::dx#4 )
  (byte) line::e#5 ← phi( line::@19/(byte) line::e#2 line::@7/(byte) line::e#1 )
  (byte) line::sy#8 ← phi( line::@19/(byte) line::sy#13 line::@7/(byte) line::sy#2 )
  (byte) line::y2#7 ← phi( line::@19/(byte) line::y2#11 line::@7/(byte) line::y2#12 )
  (byte) line::y#8 ← phi( line::@19/(byte) line::y#19 line::@7/(byte) line::y#2 )
  (bool~) line::$17 ← (byte) line::y#8 != (byte) line::y2#7
  if((bool~) line::$17) goto line::@7
  to:line::@10
line::@9: scope:[line]  from line::@7
  (byte) line::dx#26 ← phi( line::@7/(byte) line::dx#4 )
  (byte) line::y2#16 ← phi( line::@7/(byte) line::y2#12 )
  (byte) line::dy#19 ← phi( line::@7/(byte) line::dy#3 )
  (byte) line::e#7 ← phi( line::@7/(byte) line::e#1 )
  (byte) line::sx#11 ← phi( line::@7/(byte) line::sx#15 )
  (byte) line::x#5 ← phi( line::@7/(byte) line::x#15 )
  (byte) line::sy#3 ← phi( line::@7/(byte) line::sy#2 )
  (byte) line::y#9 ← phi( line::@7/(byte) line::y#2 )
  (byte~) line::$15 ← (byte) line::y#9 - (byte) line::sy#3
  (byte) line::plot2_x#0 ← (byte) line::x#5
  (byte) line::plot2_y#0 ← (byte~) line::$15
  to:line::plot2
line::plot2: scope:[line]  from line::@9
  (byte) line::dx#23 ← phi( line::@9/(byte) line::dx#26 )
  (byte) line::sy#18 ← phi( line::@9/(byte) line::sy#3 )
  (byte) line::y2#14 ← phi( line::@9/(byte) line::y2#16 )
  (byte) line::y#27 ← phi( line::@9/(byte) line::y#9 )
  (byte) line::dy#13 ← phi( line::@9/(byte) line::dy#19 )
  (byte) line::e#6 ← phi( line::@9/(byte) line::e#7 )
  (byte) line::sx#7 ← phi( line::@9/(byte) line::sx#11 )
  (byte) line::x#16 ← phi( line::@9/(byte) line::x#5 )
  (byte) line::plot2_y#1 ← phi( line::@9/(byte) line::plot2_y#0 )
  (byte) line::plot2_x#1 ← phi( line::@9/(byte) line::plot2_x#0 )
  (number~) line::plot2_$0 ← (byte) line::plot2_x#1 / (number) 8
  (number~) line::plot2_$2 ← (number~) line::plot2_$0 * (const byte) SIZEOF_POINTER
  (byte*) line::plot2_column#0 ← *((const byte**) plot_column + (number~) line::plot2_$2)
  (number~) line::plot2_$1 ← (byte) line::plot2_x#1 & (number) 7
  *((byte*) line::plot2_column#0 + (byte) line::plot2_y#1) ← *((byte*) line::plot2_column#0 + (byte) line::plot2_y#1) | *((const byte*) plot_bit + (number~) line::plot2_$1)
  to:line::@19
line::@19: scope:[line]  from line::plot2
  (byte) line::dx#19 ← phi( line::plot2/(byte) line::dx#23 )
  (byte) line::sy#13 ← phi( line::plot2/(byte) line::sy#18 )
  (byte) line::y2#11 ← phi( line::plot2/(byte) line::y2#14 )
  (byte) line::y#19 ← phi( line::plot2/(byte) line::y#27 )
  (byte) line::dy#4 ← phi( line::plot2/(byte) line::dy#13 )
  (byte) line::e#4 ← phi( line::plot2/(byte) line::e#6 )
  (byte) line::sx#3 ← phi( line::plot2/(byte) line::sx#7 )
  (byte) line::x#6 ← phi( line::plot2/(byte) line::x#16 )
  (byte) line::x#1 ← (byte) line::x#6 + (byte) line::sx#3
  (byte) line::e#2 ← (byte) line::e#4 - (byte) line::dy#4
  to:line::@8
line::@10: scope:[line]  from line::@8
  (byte) line::y#10 ← phi( line::@8/(byte) line::y#8 )
  (byte) line::x#7 ← phi( line::@8/(byte) line::x#17 )
  (byte) line::plot3_x#0 ← (byte) line::x#7
  (byte) line::plot3_y#0 ← (byte) line::y#10
  to:line::plot3
line::plot3: scope:[line]  from line::@10
  (byte) line::plot3_y#1 ← phi( line::@10/(byte) line::plot3_y#0 )
  (byte) line::plot3_x#1 ← phi( line::@10/(byte) line::plot3_x#0 )
  (number~) line::plot3_$0 ← (byte) line::plot3_x#1 / (number) 8
  (number~) line::plot3_$2 ← (number~) line::plot3_$0 * (const byte) SIZEOF_POINTER
  (byte*) line::plot3_column#0 ← *((const byte**) plot_column + (number~) line::plot3_$2)
  (number~) line::plot3_$1 ← (byte) line::plot3_x#1 & (number) 7
  *((byte*) line::plot3_column#0 + (byte) line::plot3_y#1) ← *((byte*) line::plot3_column#0 + (byte) line::plot3_y#1) | *((const byte*) plot_bit + (number~) line::plot3_$1)
  to:line::@return
line::@11: scope:[line]  from line::@18
  (byte) line::x2#15 ← phi( line::@18/(byte) line::x2#18 )
  (byte) line::sx#12 ← phi( line::@18/(byte) line::sx#16 )
  (byte) line::x#25 ← phi( line::@18/(byte) line::x#28 )
  (byte) line::dx#13 ← phi( line::@18/(byte) line::dx#3 )
  (byte) line::sy#9 ← phi( line::@18/(byte) line::sy#14 )
  (byte) line::y#20 ← phi( line::@18/(byte) line::y#28 )
  (byte) line::dy#5 ← phi( line::@18/(byte) line::dy#14 )
  (number~) line::$22 ← (byte) line::dy#5 / (number) 2
  (byte) line::e1#0 ← (number~) line::$22
  to:line::@12
line::@return: scope:[line]  from line::@18 line::@20 line::plot3 line::plot6
  return 
  to:@return
line::@12: scope:[line]  from line::@11 line::@12 line::@20
  (byte) line::x2#13 ← phi( line::@11/(byte) line::x2#15 line::@12/(byte) line::x2#13 line::@20/(byte) line::x2#5 )
  (byte) line::sx#8 ← phi( line::@11/(byte) line::sx#12 line::@12/(byte) line::sx#8 line::@20/(byte) line::sx#13 )
  (byte) line::x#18 ← phi( line::@11/(byte) line::x#25 line::@12/(byte) line::x#18 line::@20/(byte) line::x#9 )
  (byte) line::dy#6 ← phi( line::@11/(byte) line::dy#5 line::@12/(byte) line::dy#6 line::@20/(byte) line::dy#15 )
  (byte) line::dx#5 ← phi( line::@11/(byte) line::dx#13 line::@12/(byte) line::dx#5 line::@20/(byte) line::dx#14 )
  (byte) line::e1#3 ← phi( line::@11/(byte) line::e1#0 line::@12/(byte) line::e1#1 line::@20/(byte) line::e1#5 )
  (byte) line::sy#4 ← phi( line::@11/(byte) line::sy#9 line::@12/(byte) line::sy#4 line::@20/(byte) line::sy#10 )
  (byte) line::y#11 ← phi( line::@11/(byte) line::y#20 line::@12/(byte) line::y#3 line::@20/(byte) line::y#21 )
  (byte) line::y#3 ← (byte) line::y#11 + (byte) line::sy#4
  (byte) line::e1#1 ← (byte) line::e1#3 + (byte) line::dx#5
  (bool~) line::$23 ← (byte) line::e1#1 <= (byte) line::dy#6
  if((bool~) line::$23) goto line::@12
  to:line::@13
line::@13: scope:[line]  from line::@12
  (byte) line::dx#24 ← phi( line::@12/(byte) line::dx#5 )
  (byte) line::sy#19 ← phi( line::@12/(byte) line::sy#4 )
  (byte) line::x2#11 ← phi( line::@12/(byte) line::x2#13 )
  (byte) line::y#12 ← phi( line::@12/(byte) line::y#3 )
  (byte) line::dy#7 ← phi( line::@12/(byte) line::dy#6 )
  (byte) line::e1#4 ← phi( line::@12/(byte) line::e1#1 )
  (byte) line::sx#4 ← phi( line::@12/(byte) line::sx#8 )
  (byte) line::x#8 ← phi( line::@12/(byte) line::x#18 )
  (byte) line::x#2 ← (byte) line::x#8 + (byte) line::sx#4
  (byte) line::e1#2 ← (byte) line::e1#4 - (byte) line::dy#7
  (byte) line::plot4_x#0 ← (byte) line::x#2
  (byte) line::plot4_y#0 ← (byte) line::y#12
  to:line::plot4
line::plot4: scope:[line]  from line::@13
  (byte) line::sx#17 ← phi( line::@13/(byte) line::sx#4 )
  (byte) line::dy#20 ← phi( line::@13/(byte) line::dy#7 )
  (byte) line::dx#20 ← phi( line::@13/(byte) line::dx#24 )
  (byte) line::e1#6 ← phi( line::@13/(byte) line::e1#2 )
  (byte) line::sy#15 ← phi( line::@13/(byte) line::sy#19 )
  (byte) line::y#29 ← phi( line::@13/(byte) line::y#12 )
  (byte) line::x2#8 ← phi( line::@13/(byte) line::x2#11 )
  (byte) line::x#19 ← phi( line::@13/(byte) line::x#2 )
  (byte) line::plot4_y#1 ← phi( line::@13/(byte) line::plot4_y#0 )
  (byte) line::plot4_x#1 ← phi( line::@13/(byte) line::plot4_x#0 )
  (number~) line::plot4_$0 ← (byte) line::plot4_x#1 / (number) 8
  (number~) line::plot4_$2 ← (number~) line::plot4_$0 * (const byte) SIZEOF_POINTER
  (byte*) line::plot4_column#0 ← *((const byte**) plot_column + (number~) line::plot4_$2)
  (number~) line::plot4_$1 ← (byte) line::plot4_x#1 & (number) 7
  *((byte*) line::plot4_column#0 + (byte) line::plot4_y#1) ← *((byte*) line::plot4_column#0 + (byte) line::plot4_y#1) | *((const byte*) plot_bit + (number~) line::plot4_$1)
  to:line::@20
line::@20: scope:[line]  from line::plot4
  (byte) line::sx#13 ← phi( line::plot4/(byte) line::sx#17 )
  (byte) line::dy#15 ← phi( line::plot4/(byte) line::dy#20 )
  (byte) line::dx#14 ← phi( line::plot4/(byte) line::dx#20 )
  (byte) line::e1#5 ← phi( line::plot4/(byte) line::e1#6 )
  (byte) line::sy#10 ← phi( line::plot4/(byte) line::sy#15 )
  (byte) line::y#21 ← phi( line::plot4/(byte) line::y#29 )
  (byte) line::x2#5 ← phi( line::plot4/(byte) line::x2#8 )
  (byte) line::x#9 ← phi( line::plot4/(byte) line::x#19 )
  (bool~) line::$25 ← (byte) line::x#9 != (byte) line::x2#5
  if((bool~) line::$25) goto line::@12
  to:line::@return
line::@14: scope:[line]  from line::@15 line::@2
  (byte) line::sy#20 ← phi( line::@15/(byte) line::sy#22 line::@2/(byte) line::sy#23 )
  (byte) line::x2#14 ← phi( line::@15/(byte) line::x2#6 line::@2/(byte) line::x2#16 )
  (byte) line::dx#21 ← phi( line::@15/(byte) line::dx#25 line::@2/(byte) line::dx#2 )
  (byte) line::dy#21 ← phi( line::@15/(byte) line::dy#23 line::@2/(byte) line::dy#24 )
  (byte) line::e2#6 ← phi( line::@15/(byte) line::e2#7 line::@2/(byte) line::e2#0 )
  (byte) line::sx#14 ← phi( line::@15/(byte) line::sx#18 line::@2/(byte) line::sx#19 )
  (byte) line::y#13 ← phi( line::@15/(byte) line::y#22 line::@2/(byte) line::y#23 )
  (byte) line::x#10 ← phi( line::@15/(byte) line::x#12 line::@2/(byte) line::x#20 )
  (byte) line::plot5_x#0 ← (byte) line::x#10
  (byte) line::plot5_y#0 ← (byte) line::y#13
  to:line::plot5
line::plot5: scope:[line]  from line::@14
  (byte) line::sy#16 ← phi( line::@14/(byte) line::sy#20 )
  (byte) line::y#30 ← phi( line::@14/(byte) line::y#13 )
  (byte) line::x2#12 ← phi( line::@14/(byte) line::x2#14 )
  (byte) line::dx#15 ← phi( line::@14/(byte) line::dx#21 )
  (byte) line::dy#16 ← phi( line::@14/(byte) line::dy#21 )
  (byte) line::e2#5 ← phi( line::@14/(byte) line::e2#6 )
  (byte) line::sx#9 ← phi( line::@14/(byte) line::sx#14 )
  (byte) line::x#21 ← phi( line::@14/(byte) line::x#10 )
  (byte) line::plot5_y#1 ← phi( line::@14/(byte) line::plot5_y#0 )
  (byte) line::plot5_x#1 ← phi( line::@14/(byte) line::plot5_x#0 )
  (number~) line::plot5_$0 ← (byte) line::plot5_x#1 / (number) 8
  (number~) line::plot5_$2 ← (number~) line::plot5_$0 * (const byte) SIZEOF_POINTER
  (byte*) line::plot5_column#0 ← *((const byte**) plot_column + (number~) line::plot5_$2)
  (number~) line::plot5_$1 ← (byte) line::plot5_x#1 & (number) 7
  *((byte*) line::plot5_column#0 + (byte) line::plot5_y#1) ← *((byte*) line::plot5_column#0 + (byte) line::plot5_y#1) | *((const byte*) plot_bit + (number~) line::plot5_$1)
  to:line::@21
line::@21: scope:[line]  from line::plot5
  (byte) line::sy#11 ← phi( line::plot5/(byte) line::sy#16 )
  (byte) line::y#24 ← phi( line::plot5/(byte) line::y#30 )
  (byte) line::x2#10 ← phi( line::plot5/(byte) line::x2#12 )
  (byte) line::dx#6 ← phi( line::plot5/(byte) line::dx#15 )
  (byte) line::dy#8 ← phi( line::plot5/(byte) line::dy#16 )
  (byte) line::e2#3 ← phi( line::plot5/(byte) line::e2#5 )
  (byte) line::sx#5 ← phi( line::plot5/(byte) line::sx#9 )
  (byte) line::x#11 ← phi( line::plot5/(byte) line::x#21 )
  (byte) line::x#3 ← (byte) line::x#11 + (byte) line::sx#5
  (byte) line::e2#1 ← (byte) line::e2#3 + (byte) line::dy#8
  (bool~) line::$28 ← (byte) line::e2#1 > (byte) line::dx#6
  (bool~) line::$29 ← ! (bool~) line::$28
  if((bool~) line::$29) goto line::@15
  to:line::@16
line::@15: scope:[line]  from line::@16 line::@21
  (byte) line::sy#22 ← phi( line::@16/(byte) line::sy#5 line::@21/(byte) line::sy#11 )
  (byte) line::dx#25 ← phi( line::@16/(byte) line::dx#7 line::@21/(byte) line::dx#6 )
  (byte) line::dy#23 ← phi( line::@16/(byte) line::dy#25 line::@21/(byte) line::dy#8 )
  (byte) line::e2#7 ← phi( line::@16/(byte) line::e2#2 line::@21/(byte) line::e2#1 )
  (byte) line::sx#18 ← phi( line::@16/(byte) line::sx#23 line::@21/(byte) line::sx#5 )
  (byte) line::y#22 ← phi( line::@16/(byte) line::y#4 line::@21/(byte) line::y#24 )
  (byte) line::x2#6 ← phi( line::@16/(byte) line::x2#9 line::@21/(byte) line::x2#10 )
  (byte) line::x#12 ← phi( line::@16/(byte) line::x#22 line::@21/(byte) line::x#3 )
  (bool~) line::$30 ← (byte) line::x#12 != (byte) line::x2#6
  if((bool~) line::$30) goto line::@14
  to:line::@17
line::@16: scope:[line]  from line::@21
  (byte) line::dy#25 ← phi( line::@21/(byte) line::dy#8 )
  (byte) line::sx#23 ← phi( line::@21/(byte) line::sx#5 )
  (byte) line::x2#9 ← phi( line::@21/(byte) line::x2#10 )
  (byte) line::x#22 ← phi( line::@21/(byte) line::x#3 )
  (byte) line::dx#7 ← phi( line::@21/(byte) line::dx#6 )
  (byte) line::e2#4 ← phi( line::@21/(byte) line::e2#1 )
  (byte) line::sy#5 ← phi( line::@21/(byte) line::sy#11 )
  (byte) line::y#14 ← phi( line::@21/(byte) line::y#24 )
  (byte) line::y#4 ← (byte) line::y#14 + (byte) line::sy#5
  (byte) line::e2#2 ← (byte) line::e2#4 - (byte) line::dx#7
  to:line::@15
line::@17: scope:[line]  from line::@15
  (byte) line::y#15 ← phi( line::@15/(byte) line::y#22 )
  (byte) line::x#13 ← phi( line::@15/(byte) line::x#12 )
  (byte) line::plot6_x#0 ← (byte) line::x#13
  (byte) line::plot6_y#0 ← (byte) line::y#15
  to:line::plot6
line::plot6: scope:[line]  from line::@17
  (byte) line::plot6_y#1 ← phi( line::@17/(byte) line::plot6_y#0 )
  (byte) line::plot6_x#1 ← phi( line::@17/(byte) line::plot6_x#0 )
  (number~) line::plot6_$0 ← (byte) line::plot6_x#1 / (number) 8
  (number~) line::plot6_$2 ← (number~) line::plot6_$0 * (const byte) SIZEOF_POINTER
  (byte*) line::plot6_column#0 ← *((const byte**) plot_column + (number~) line::plot6_$2)
  (number~) line::plot6_$1 ← (byte) line::plot6_x#1 & (number) 7
  *((byte*) line::plot6_column#0 + (byte) line::plot6_y#1) ← *((byte*) line::plot6_column#0 + (byte) line::plot6_y#1) | *((const byte*) plot_bit + (number~) line::plot6_$1)
  to:line::@return

(void()) eorfill((byte*) eorfill::line_buffer , (byte*) eorfill::canvas)
eorfill: scope:[eorfill]  from main::@10
  (byte*) eorfill::canvas#1 ← phi( main::@10/(byte*) eorfill::canvas#0 )
  (byte*) eorfill::line_buffer#1 ← phi( main::@10/(byte*) eorfill::line_buffer#0 )
  (byte*) eorfill::line_column#0 ← (byte*) eorfill::line_buffer#1
  (byte*) eorfill::fill_column#0 ← (byte*) eorfill::canvas#1
  (byte) eorfill::x#0 ← (byte) 0
  to:eorfill::@1
eorfill::@1: scope:[eorfill]  from eorfill eorfill::@5
  (byte*) eorfill::fill_column#5 ← phi( eorfill/(byte*) eorfill::fill_column#0 eorfill::@5/(byte*) eorfill::fill_column#1 )
  (byte*) eorfill::line_column#5 ← phi( eorfill/(byte*) eorfill::line_column#0 eorfill::@5/(byte*) eorfill::line_column#1 )
  (byte) eorfill::x#2 ← phi( eorfill/(byte) eorfill::x#0 eorfill::@5/(byte) eorfill::x#1 )
  (bool~) eorfill::$0 ← (byte) eorfill::x#2 < (number) $10
  if((bool~) eorfill::$0) goto eorfill::@2
  to:eorfill::@return
eorfill::@2: scope:[eorfill]  from eorfill::@1
  (byte) eorfill::x#5 ← phi( eorfill::@1/(byte) eorfill::x#2 )
  (byte*) eorfill::fill_column#2 ← phi( eorfill::@1/(byte*) eorfill::fill_column#5 )
  (byte*) eorfill::line_column#2 ← phi( eorfill::@1/(byte*) eorfill::line_column#5 )
  (byte) eorfill::eor#0 ← *((byte*) eorfill::line_column#2 + (number) 0)
  *((byte*) eorfill::fill_column#2 + (number) 0) ← (byte) eorfill::eor#0
  (byte) eorfill::y#0 ← (byte) 1
  to:eorfill::@3
eorfill::@3: scope:[eorfill]  from eorfill::@2 eorfill::@4
  (byte) eorfill::x#4 ← phi( eorfill::@2/(byte) eorfill::x#5 eorfill::@4/(byte) eorfill::x#6 )
  (byte*) eorfill::fill_column#6 ← phi( eorfill::@2/(byte*) eorfill::fill_column#2 eorfill::@4/(byte*) eorfill::fill_column#3 )
  (byte*) eorfill::line_column#6 ← phi( eorfill::@2/(byte*) eorfill::line_column#2 eorfill::@4/(byte*) eorfill::line_column#3 )
  (byte) eorfill::eor#3 ← phi( eorfill::@2/(byte) eorfill::eor#0 eorfill::@4/(byte) eorfill::eor#1 )
  (byte) eorfill::y#2 ← phi( eorfill::@2/(byte) eorfill::y#0 eorfill::@4/(byte) eorfill::y#1 )
  (bool~) eorfill::$1 ← (byte) eorfill::y#2 < (number) $10*(number) 8
  if((bool~) eorfill::$1) goto eorfill::@4
  to:eorfill::@5
eorfill::@4: scope:[eorfill]  from eorfill::@3
  (byte) eorfill::x#6 ← phi( eorfill::@3/(byte) eorfill::x#4 )
  (byte*) eorfill::fill_column#3 ← phi( eorfill::@3/(byte*) eorfill::fill_column#6 )
  (byte) eorfill::y#3 ← phi( eorfill::@3/(byte) eorfill::y#2 )
  (byte*) eorfill::line_column#3 ← phi( eorfill::@3/(byte*) eorfill::line_column#6 )
  (byte) eorfill::eor#2 ← phi( eorfill::@3/(byte) eorfill::eor#3 )
  (byte) eorfill::eor#1 ← (byte) eorfill::eor#2 ^ *((byte*) eorfill::line_column#3 + (byte) eorfill::y#3)
  *((byte*) eorfill::fill_column#3 + (byte) eorfill::y#3) ← (byte) eorfill::eor#1
  (byte) eorfill::y#1 ← ++ (byte) eorfill::y#3
  to:eorfill::@3
eorfill::@5: scope:[eorfill]  from eorfill::@3
  (byte) eorfill::x#3 ← phi( eorfill::@3/(byte) eorfill::x#4 )
  (byte*) eorfill::fill_column#4 ← phi( eorfill::@3/(byte*) eorfill::fill_column#6 )
  (byte*) eorfill::line_column#4 ← phi( eorfill::@3/(byte*) eorfill::line_column#6 )
  (byte*) eorfill::line_column#1 ← (byte*) eorfill::line_column#4 + (number) $10*(number) 8
  (byte*) eorfill::fill_column#1 ← (byte*) eorfill::fill_column#4 + (number) $10*(number) 8
  (byte) eorfill::x#1 ← ++ (byte) eorfill::x#3
  to:eorfill::@1
eorfill::@return: scope:[eorfill]  from eorfill::@1
  return 
  to:@return

(byte()) abs_u8((byte) abs_u8::u)
abs_u8: scope:[abs_u8]  from line line::@22
  (byte) abs_u8::u#2 ← phi( line/(byte) abs_u8::u#0 line::@22/(byte) abs_u8::u#1 )
  (number~) abs_u8::$0 ← (byte) abs_u8::u#2 & (number) $80
  (bool~) abs_u8::$2 ← (number) 0 != (number~) abs_u8::$0
  if((bool~) abs_u8::$2) goto abs_u8::@1
  to:abs_u8::@2
abs_u8::@1: scope:[abs_u8]  from abs_u8
  (byte) abs_u8::u#3 ← phi( abs_u8/(byte) abs_u8::u#2 )
  (byte~) abs_u8::$1 ← - (byte) abs_u8::u#3
  (byte) abs_u8::return#2 ← (byte~) abs_u8::$1
  to:abs_u8::@return
abs_u8::@2: scope:[abs_u8]  from abs_u8
  (byte) abs_u8::u#4 ← phi( abs_u8/(byte) abs_u8::u#2 )
  (byte) abs_u8::return#3 ← (byte) abs_u8::u#4
  to:abs_u8::@return
abs_u8::@return: scope:[abs_u8]  from abs_u8::@1 abs_u8::@2
  (byte) abs_u8::return#7 ← phi( abs_u8::@1/(byte) abs_u8::return#2 abs_u8::@2/(byte) abs_u8::return#3 )
  (byte) abs_u8::return#4 ← (byte) abs_u8::return#7
  return 
  to:@return

(byte()) sgn_u8((byte) sgn_u8::u)
sgn_u8: scope:[sgn_u8]  from line::@23 line::@24
  (byte) sgn_u8::u#2 ← phi( line::@23/(byte) sgn_u8::u#0 line::@24/(byte) sgn_u8::u#1 )
  (number~) sgn_u8::$0 ← (byte) sgn_u8::u#2 & (number) $80
  (bool~) sgn_u8::$1 ← (number) 0 != (number~) sgn_u8::$0
  if((bool~) sgn_u8::$1) goto sgn_u8::@1
  to:sgn_u8::@2
sgn_u8::@1: scope:[sgn_u8]  from sgn_u8
  (byte) sgn_u8::return#2 ← (number) -1
  to:sgn_u8::@return
sgn_u8::@2: scope:[sgn_u8]  from sgn_u8
  (byte) sgn_u8::return#3 ← (number) 1
  to:sgn_u8::@return
sgn_u8::@return: scope:[sgn_u8]  from sgn_u8::@1 sgn_u8::@2
  (byte) sgn_u8::return#7 ← phi( sgn_u8::@1/(byte) sgn_u8::return#2 sgn_u8::@2/(byte) sgn_u8::return#3 )
  (byte) sgn_u8::return#4 ← (byte) sgn_u8::return#7
  return 
  to:@return
@3: scope:[]  from @4
  call main 
  to:@5
@5: scope:[]  from @3
  to:@end
@end: scope:[]  from @5

SYMBOL TABLE SSA
(byte~) $0
(label) @1
(label) @2
(label) @3
(label) @4
(label) @5
(label) @begin
(label) @end
(const nomodify byte) BLACK = (byte) 0
(const nomodify byte) BORDER_YPOS_BOTTOM = (byte) $fa
(const nomodify byte*) CANVAS1 = (byte*)(number) $3000
(const nomodify byte*) CANVAS2 = (byte*)(number) $3800
(const nomodify struct MOS6526_CIA*) CIA1 = (struct MOS6526_CIA*)(number) $dc00
(const nomodify struct MOS6526_CIA*) CIA2 = (struct MOS6526_CIA*)(number) $dd00
(const nomodify dword*) CIA2_TIMER_AB = (dword*)(number) $dd04
(const nomodify byte) CIA_INTERRUPT_CLEAR = (byte) $7f
(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES = (byte) 0
(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = (byte) $40
(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS = (byte) 0
(const nomodify byte) CIA_TIMER_CONTROL_START = (byte) 1
(const nomodify byte) CIA_TIMER_CONTROL_STOP = (byte) 0
(const nomodify byte*) COLS = (byte*)(number) $d800
(const nomodify byte) CONIO_TEXTCOLOR_DEFAULT = (const nomodify byte) LIGHT_BLUE
(const nomodify byte*) CONSOLE = (byte*)(number) $400
(const byte*) COSTAB = (const byte*) SINTAB+(number) $40
(const nomodify byte) DARK_GREY = (byte) $b
(const nomodify byte) IRQ_RASTER = (byte) 1
(const nomodify void()**) KERNEL_IRQ = (void()**)(number) $314
(const nomodify byte) LIGHT_BLUE = (byte) $e
(const nomodify byte*) LINE_BUFFER = (byte*)(number) $2000
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = (byte) $d
(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = (byte) $e
(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = (byte) $f
(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = (byte) $21
(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = (byte) $20
(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = (byte) $11
(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = (byte) $1a
(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = (byte) $19
(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY = (byte) $18
(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER = (byte) $12
(const nomodify byte*) PETSCII = (byte*)(number) $1000
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(const nomodify byte) RED = (byte) 2
(const nomodify byte*) SCREEN = (byte*)(number) $2c00
(const byte*) SINTAB[(number) $140]  = kickasm {{ .fill $200, round(63 + 63*sin(i*2*PI/$100))
 }}
(const byte) SIZEOF_POINTER = (byte) 2
(const nomodify struct MOS6569_VICII*) VICII = (struct MOS6569_VICII*)(number) $d000
(const nomodify byte) WHITE = (byte) 1
(byte()) abs_u8((byte) abs_u8::u)
(number~) abs_u8::$0
(byte~) abs_u8::$1
(bool~) abs_u8::$2
(label) abs_u8::@1
(label) abs_u8::@2
(label) abs_u8::@return
(byte) abs_u8::return
(byte) abs_u8::return#0
(byte) abs_u8::return#1
(byte) abs_u8::return#2
(byte) abs_u8::return#3
(byte) abs_u8::return#4
(byte) abs_u8::return#5
(byte) abs_u8::return#6
(byte) abs_u8::return#7
(byte) abs_u8::u
(byte) abs_u8::u#0
(byte) abs_u8::u#1
(byte) abs_u8::u#2
(byte) abs_u8::u#3
(byte) abs_u8::u#4
(volatile byte) canvas_show_flag loadstore
(volatile byte) canvas_show_memory loadstore
(dword()) clock()
(number~) clock::$0
(label) clock::@return
(dword) clock::return
(dword) clock::return#0
(dword) clock::return#1
(dword) clock::return#2
(dword) clock::return#3
(void()) clock_start()
(label) clock_start::@return
(byte) conio_textcolor loadstore
(void()) eorfill((byte*) eorfill::line_buffer , (byte*) eorfill::canvas)
(bool~) eorfill::$0
(bool~) eorfill::$1
(label) eorfill::@1
(label) eorfill::@2
(label) eorfill::@3
(label) eorfill::@4
(label) eorfill::@5
(label) eorfill::@return
(byte*) eorfill::canvas
(byte*) eorfill::canvas#0
(byte*) eorfill::canvas#1
(byte) eorfill::eor
(byte) eorfill::eor#0
(byte) eorfill::eor#1
(byte) eorfill::eor#2
(byte) eorfill::eor#3
(byte*) eorfill::fill_column
(byte*) eorfill::fill_column#0
(byte*) eorfill::fill_column#1
(byte*) eorfill::fill_column#2
(byte*) eorfill::fill_column#3
(byte*) eorfill::fill_column#4
(byte*) eorfill::fill_column#5
(byte*) eorfill::fill_column#6
(byte*) eorfill::line_buffer
(byte*) eorfill::line_buffer#0
(byte*) eorfill::line_buffer#1
(byte*) eorfill::line_column
(byte*) eorfill::line_column#0
(byte*) eorfill::line_column#1
(byte*) eorfill::line_column#2
(byte*) eorfill::line_column#3
(byte*) eorfill::line_column#4
(byte*) eorfill::line_column#5
(byte*) eorfill::line_column#6
(byte) eorfill::x
(byte) eorfill::x#0
(byte) eorfill::x#1
(byte) eorfill::x#2
(byte) eorfill::x#3
(byte) eorfill::x#4
(byte) eorfill::x#5
(byte) eorfill::x#6
(byte) eorfill::y
(byte) eorfill::y#0
(byte) eorfill::y#1
(byte) eorfill::y#2
(byte) eorfill::y#3
interrupt(KERNEL_MIN)(void()) irq_bottom_1()
(byte~) irq_bottom_1::$0
(label) irq_bottom_1::@1
(label) irq_bottom_1::@return
(label) irq_bottom_1::toD0181
(number~) irq_bottom_1::toD0181_$0
(number~) irq_bottom_1::toD0181_$1
(number~) irq_bottom_1::toD0181_$2
(byte~) irq_bottom_1::toD0181_$3
(number~) irq_bottom_1::toD0181_$4
(number~) irq_bottom_1::toD0181_$5
(number~) irq_bottom_1::toD0181_$6
(word~) irq_bottom_1::toD0181_$7
(label) irq_bottom_1::toD0181_@return
(byte*) irq_bottom_1::toD0181_gfx
(byte*) irq_bottom_1::toD0181_gfx#0
(byte*) irq_bottom_1::toD0181_gfx#1
(byte) irq_bottom_1::toD0181_return
(byte) irq_bottom_1::toD0181_return#0
(byte) irq_bottom_1::toD0181_return#1
(byte) irq_bottom_1::toD0181_return#2
(byte) irq_bottom_1::toD0181_return#3
(byte*) irq_bottom_1::toD0181_screen
(byte*) irq_bottom_1::toD0181_screen#0
(byte*) irq_bottom_1::toD0181_screen#1
interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2()
(byte~) irq_bottom_2::$0
(bool~) irq_bottom_2::$1
(byte~) irq_bottom_2::$2
(bool~) irq_bottom_2::$3
(label) irq_bottom_2::@1
(label) irq_bottom_2::@2
(label) irq_bottom_2::@3
(label) irq_bottom_2::@4
(label) irq_bottom_2::@5
(label) irq_bottom_2::@return
(label) irq_bottom_2::toD0181
(number~) irq_bottom_2::toD0181_$0
(number~) irq_bottom_2::toD0181_$1
(number~) irq_bottom_2::toD0181_$2
(byte~) irq_bottom_2::toD0181_$3
(number~) irq_bottom_2::toD0181_$4
(number~) irq_bottom_2::toD0181_$5
(number~) irq_bottom_2::toD0181_$6
(word~) irq_bottom_2::toD0181_$7
(label) irq_bottom_2::toD0181_@return
(byte*) irq_bottom_2::toD0181_gfx
(byte*) irq_bottom_2::toD0181_gfx#0
(byte*) irq_bottom_2::toD0181_gfx#1
(byte) irq_bottom_2::toD0181_return
(byte) irq_bottom_2::toD0181_return#0
(byte) irq_bottom_2::toD0181_return#1
(byte) irq_bottom_2::toD0181_return#2
(byte) irq_bottom_2::toD0181_return#3
(byte*) irq_bottom_2::toD0181_screen
(byte*) irq_bottom_2::toD0181_screen#0
(byte*) irq_bottom_2::toD0181_screen#1
(byte()) kbhit()
(byte~) kbhit::$0
(label) kbhit::@return
(const nomodify byte*) kbhit::CIA1_PORT_A = (byte*)(number) $dc00
(const nomodify byte*) kbhit::CIA1_PORT_B = (byte*)(number) $dc01
(byte) kbhit::return
(byte) kbhit::return#0
(byte) kbhit::return#1
(byte) kbhit::return#2
(byte) kbhit::return#3
(byte) kbhit::return#4
(void()) line((byte*) line::canvas , (byte) line::x1 , (byte) line::y1 , (byte) line::x2 , (byte) line::y2)
(byte~) line::$0
(byte~) line::$1
(bool~) line::$10
(bool~) line::$11
(number~) line::$12
(bool~) line::$13
(bool~) line::$14
(byte~) line::$15
(bool~) line::$17
(byte~) line::$2
(bool~) line::$20
(bool~) line::$21
(number~) line::$22
(bool~) line::$23
(bool~) line::$25
(number~) line::$26
(bool~) line::$28
(bool~) line::$29
(byte~) line::$3
(bool~) line::$30
(byte~) line::$4
(byte~) line::$5
(byte~) line::$6
(byte~) line::$7
(bool~) line::$8
(bool~) line::$9
(label) line::@1
(label) line::@10
(label) line::@11
(label) line::@12
(label) line::@13
(label) line::@14
(label) line::@15
(label) line::@16
(label) line::@17
(label) line::@18
(label) line::@19
(label) line::@2
(label) line::@20
(label) line::@21
(label) line::@22
(label) line::@23
(label) line::@24
(label) line::@25
(label) line::@3
(label) line::@4
(label) line::@5
(label) line::@6
(label) line::@7
(label) line::@8
(label) line::@9
(label) line::@return
(byte*) line::canvas
(byte*) line::canvas#0
(byte*) line::canvas#1
(byte*) line::canvas#2
(byte) line::dx
(byte) line::dx#0
(byte) line::dx#1
(byte) line::dx#10
(byte) line::dx#11
(byte) line::dx#12
(byte) line::dx#13
(byte) line::dx#14
(byte) line::dx#15
(byte) line::dx#16
(byte) line::dx#17
(byte) line::dx#18
(byte) line::dx#19
(byte) line::dx#2
(byte) line::dx#20
(byte) line::dx#21
(byte) line::dx#22
(byte) line::dx#23
(byte) line::dx#24
(byte) line::dx#25
(byte) line::dx#26
(byte) line::dx#3
(byte) line::dx#4
(byte) line::dx#5
(byte) line::dx#6
(byte) line::dx#7
(byte) line::dx#8
(byte) line::dx#9
(byte) line::dy
(byte) line::dy#0
(byte) line::dy#1
(byte) line::dy#10
(byte) line::dy#11
(byte) line::dy#12
(byte) line::dy#13
(byte) line::dy#14
(byte) line::dy#15
(byte) line::dy#16
(byte) line::dy#17
(byte) line::dy#18
(byte) line::dy#19
(byte) line::dy#2
(byte) line::dy#20
(byte) line::dy#21
(byte) line::dy#22
(byte) line::dy#23
(byte) line::dy#24
(byte) line::dy#25
(byte) line::dy#3
(byte) line::dy#4
(byte) line::dy#5
(byte) line::dy#6
(byte) line::dy#7
(byte) line::dy#8
(byte) line::dy#9
(byte) line::e
(byte) line::e#0
(byte) line::e#1
(byte) line::e#2
(byte) line::e#3
(byte) line::e#4
(byte) line::e#5
(byte) line::e#6
(byte) line::e#7
(byte) line::e1
(byte) line::e1#0
(byte) line::e1#1
(byte) line::e1#2
(byte) line::e1#3
(byte) line::e1#4
(byte) line::e1#5
(byte) line::e1#6
(byte) line::e2
(byte) line::e2#0
(byte) line::e2#1
(byte) line::e2#2
(byte) line::e2#3
(byte) line::e2#4
(byte) line::e2#5
(byte) line::e2#6
(byte) line::e2#7
(label) line::plot1
(number~) line::plot1_$0
(number~) line::plot1_$1
(number~) line::plot1_$2
(byte*) line::plot1_column
(byte*) line::plot1_column#0
(byte) line::plot1_x
(byte) line::plot1_x#0
(byte) line::plot1_x#1
(byte) line::plot1_y
(byte) line::plot1_y#0
(byte) line::plot1_y#1
(label) line::plot2
(number~) line::plot2_$0
(number~) line::plot2_$1
(number~) line::plot2_$2
(byte*) line::plot2_column
(byte*) line::plot2_column#0
(byte) line::plot2_x
(byte) line::plot2_x#0
(byte) line::plot2_x#1
(byte) line::plot2_y
(byte) line::plot2_y#0
(byte) line::plot2_y#1
(label) line::plot3
(number~) line::plot3_$0
(number~) line::plot3_$1
(number~) line::plot3_$2
(byte*) line::plot3_column
(byte*) line::plot3_column#0
(byte) line::plot3_x
(byte) line::plot3_x#0
(byte) line::plot3_x#1
(byte) line::plot3_y
(byte) line::plot3_y#0
(byte) line::plot3_y#1
(label) line::plot4
(number~) line::plot4_$0
(number~) line::plot4_$1
(number~) line::plot4_$2
(byte*) line::plot4_column
(byte*) line::plot4_column#0
(byte) line::plot4_x
(byte) line::plot4_x#0
(byte) line::plot4_x#1
(byte) line::plot4_y
(byte) line::plot4_y#0
(byte) line::plot4_y#1
(label) line::plot5
(number~) line::plot5_$0
(number~) line::plot5_$1
(number~) line::plot5_$2
(byte*) line::plot5_column
(byte*) line::plot5_column#0
(byte) line::plot5_x
(byte) line::plot5_x#0
(byte) line::plot5_x#1
(byte) line::plot5_y
(byte) line::plot5_y#0
(byte) line::plot5_y#1
(label) line::plot6
(number~) line::plot6_$0
(number~) line::plot6_$1
(number~) line::plot6_$2
(byte*) line::plot6_column
(byte*) line::plot6_column#0
(byte) line::plot6_x
(byte) line::plot6_x#0
(byte) line::plot6_x#1
(byte) line::plot6_y
(byte) line::plot6_y#0
(byte) line::plot6_y#1
(byte) line::sx
(byte) line::sx#0
(byte) line::sx#1
(byte) line::sx#10
(byte) line::sx#11
(byte) line::sx#12
(byte) line::sx#13
(byte) line::sx#14
(byte) line::sx#15
(byte) line::sx#16
(byte) line::sx#17
(byte) line::sx#18
(byte) line::sx#19
(byte) line::sx#2
(byte) line::sx#20
(byte) line::sx#21
(byte) line::sx#22
(byte) line::sx#23
(byte) line::sx#24
(byte) line::sx#3
(byte) line::sx#4
(byte) line::sx#5
(byte) line::sx#6
(byte) line::sx#7
(byte) line::sx#8
(byte) line::sx#9
(byte) line::sy
(byte) line::sy#0
(byte) line::sy#1
(byte) line::sy#10
(byte) line::sy#11
(byte) line::sy#12
(byte) line::sy#13
(byte) line::sy#14
(byte) line::sy#15
(byte) line::sy#16
(byte) line::sy#17
(byte) line::sy#18
(byte) line::sy#19
(byte) line::sy#2
(byte) line::sy#20
(byte) line::sy#21
(byte) line::sy#22
(byte) line::sy#23
(byte) line::sy#3
(byte) line::sy#4
(byte) line::sy#5
(byte) line::sy#6
(byte) line::sy#7
(byte) line::sy#8
(byte) line::sy#9
(byte) line::x
(byte) line::x#0
(byte) line::x#1
(byte) line::x#10
(byte) line::x#11
(byte) line::x#12
(byte) line::x#13
(byte) line::x#14
(byte) line::x#15
(byte) line::x#16
(byte) line::x#17
(byte) line::x#18
(byte) line::x#19
(byte) line::x#2
(byte) line::x#20
(byte) line::x#21
(byte) line::x#22
(byte) line::x#23
(byte) line::x#24
(byte) line::x#25
(byte) line::x#26
(byte) line::x#27
(byte) line::x#28
(byte) line::x#29
(byte) line::x#3
(byte) line::x#30
(byte) line::x#31
(byte) line::x#32
(byte) line::x#4
(byte) line::x#5
(byte) line::x#6
(byte) line::x#7
(byte) line::x#8
(byte) line::x#9
(byte) line::x1
(byte) line::x1#0
(byte) line::x1#1
(byte) line::x1#2
(byte) line::x1#3
(byte) line::x1#4
(byte) line::x1#5
(byte) line::x2
(byte) line::x2#0
(byte) line::x2#1
(byte) line::x2#10
(byte) line::x2#11
(byte) line::x2#12
(byte) line::x2#13
(byte) line::x2#14
(byte) line::x2#15
(byte) line::x2#16
(byte) line::x2#17
(byte) line::x2#18
(byte) line::x2#19
(byte) line::x2#2
(byte) line::x2#20
(byte) line::x2#21
(byte) line::x2#22
(byte) line::x2#23
(byte) line::x2#24
(byte) line::x2#3
(byte) line::x2#4
(byte) line::x2#5
(byte) line::x2#6
(byte) line::x2#7
(byte) line::x2#8
(byte) line::x2#9
(byte) line::y
(byte) line::y#0
(byte) line::y#1
(byte) line::y#10
(byte) line::y#11
(byte) line::y#12
(byte) line::y#13
(byte) line::y#14
(byte) line::y#15
(byte) line::y#16
(byte) line::y#17
(byte) line::y#18
(byte) line::y#19
(byte) line::y#2
(byte) line::y#20
(byte) line::y#21
(byte) line::y#22
(byte) line::y#23
(byte) line::y#24
(byte) line::y#25
(byte) line::y#26
(byte) line::y#27
(byte) line::y#28
(byte) line::y#29
(byte) line::y#3
(byte) line::y#30
(byte) line::y#31
(byte) line::y#32
(byte) line::y#33
(byte) line::y#4
(byte) line::y#5
(byte) line::y#6
(byte) line::y#7
(byte) line::y#8
(byte) line::y#9
(byte) line::y1
(byte) line::y1#0
(byte) line::y1#1
(byte) line::y1#2
(byte) line::y1#3
(byte) line::y1#4
(byte) line::y1#5
(byte) line::y1#6
(byte) line::y2
(byte) line::y2#0
(byte) line::y2#1
(byte) line::y2#10
(byte) line::y2#11
(byte) line::y2#12
(byte) line::y2#13
(byte) line::y2#14
(byte) line::y2#15
(byte) line::y2#16
(byte) line::y2#17
(byte) line::y2#2
(byte) line::y2#3
(byte) line::y2#4
(byte) line::y2#5
(byte) line::y2#6
(byte) line::y2#7
(byte) line::y2#8
(byte) line::y2#9
(void()) main()
(byte~) main::$15
(byte~) main::$16
(byte~) main::$17
(word~) main::$20
(bool~) main::$21
(bool~) main::$22
(number~) main::$5
(number~) main::$6
(bool~) main::$7
(bool~) main::$8
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@22
(label) main::@23
(label) main::@24
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return
(byte) main::c
(byte) main::c#0
(byte) main::c#1
(byte) main::c#2
(byte) main::c#3
(byte*) main::canvas
(byte*) main::canvas#0
(byte*) main::canvas#1
(byte*) main::canvas#10
(byte*) main::canvas#11
(byte*) main::canvas#12
(byte*) main::canvas#13
(byte*) main::canvas#14
(byte*) main::canvas#15
(byte*) main::canvas#16
(byte*) main::canvas#17
(byte*) main::canvas#18
(byte*) main::canvas#2
(byte*) main::canvas#3
(byte*) main::canvas#4
(byte*) main::canvas#5
(byte*) main::canvas#6
(byte*) main::canvas#7
(byte*) main::canvas#8
(byte*) main::canvas#9
(byte*) main::cols
(byte*) main::cols#0
(byte*) main::cols#1
(byte*) main::cols#2
(byte*) main::cols#3
(byte*) main::cols#4
(byte*) main::cols#5
(byte*) main::cols#6
(byte) main::p0_idx
(byte) main::p0_idx#0
(byte) main::p0_idx#1
(byte) main::p0_idx#10
(byte) main::p0_idx#11
(byte) main::p0_idx#12
(byte) main::p0_idx#13
(byte) main::p0_idx#14
(byte) main::p0_idx#15
(byte) main::p0_idx#16
(byte) main::p0_idx#17
(byte) main::p0_idx#18
(byte) main::p0_idx#2
(byte) main::p0_idx#3
(byte) main::p0_idx#4
(byte) main::p0_idx#5
(byte) main::p0_idx#6
(byte) main::p0_idx#7
(byte) main::p0_idx#8
(byte) main::p0_idx#9
(byte) main::p1_idx
(byte) main::p1_idx#0
(byte) main::p1_idx#1
(byte) main::p1_idx#10
(byte) main::p1_idx#11
(byte) main::p1_idx#12
(byte) main::p1_idx#13
(byte) main::p1_idx#14
(byte) main::p1_idx#15
(byte) main::p1_idx#16
(byte) main::p1_idx#17
(byte) main::p1_idx#18
(byte) main::p1_idx#2
(byte) main::p1_idx#3
(byte) main::p1_idx#4
(byte) main::p1_idx#5
(byte) main::p1_idx#6
(byte) main::p1_idx#7
(byte) main::p1_idx#8
(byte) main::p1_idx#9
(byte) main::p2_idx
(byte) main::p2_idx#0
(byte) main::p2_idx#1
(byte) main::p2_idx#10
(byte) main::p2_idx#11
(byte) main::p2_idx#12
(byte) main::p2_idx#13
(byte) main::p2_idx#14
(byte) main::p2_idx#15
(byte) main::p2_idx#16
(byte) main::p2_idx#17
(byte) main::p2_idx#18
(byte) main::p2_idx#2
(byte) main::p2_idx#3
(byte) main::p2_idx#4
(byte) main::p2_idx#5
(byte) main::p2_idx#6
(byte) main::p2_idx#7
(byte) main::p2_idx#8
(byte) main::p2_idx#9
(byte*) main::screen
(byte*) main::screen#0
(byte*) main::screen#1
(byte*) main::screen#2
(byte*) main::screen#3
(byte*) main::screen#4
(byte*) main::screen#5
(byte*) main::screen#6
(label) main::toD0181
(number~) main::toD0181_$0
(number~) main::toD0181_$1
(number~) main::toD0181_$2
(byte~) main::toD0181_$3
(number~) main::toD0181_$4
(number~) main::toD0181_$5
(number~) main::toD0181_$6
(word~) main::toD0181_$7
(label) main::toD0181_@return
(byte*) main::toD0181_gfx
(byte*) main::toD0181_gfx#0
(byte*) main::toD0181_gfx#1
(byte) main::toD0181_return
(byte) main::toD0181_return#0
(byte) main::toD0181_return#1
(byte) main::toD0181_return#2
(byte) main::toD0181_return#3
(byte*) main::toD0181_screen
(byte*) main::toD0181_screen#0
(byte*) main::toD0181_screen#1
(label) main::toD0182
(number~) main::toD0182_$0
(number~) main::toD0182_$1
(number~) main::toD0182_$2
(byte~) main::toD0182_$3
(number~) main::toD0182_$4
(number~) main::toD0182_$5
(number~) main::toD0182_$6
(word~) main::toD0182_$7
(label) main::toD0182_@return
(byte*) main::toD0182_gfx
(byte*) main::toD0182_gfx#0
(byte*) main::toD0182_gfx#1
(byte) main::toD0182_return
(byte) main::toD0182_return#0
(byte) main::toD0182_return#1
(byte) main::toD0182_return#2
(byte) main::toD0182_return#3
(byte*) main::toD0182_screen
(byte*) main::toD0182_screen#0
(byte*) main::toD0182_screen#1
(byte) main::x
(byte) main::x#0
(byte) main::x#1
(byte) main::x#2
(byte) main::x#3
(byte) main::x0
(byte) main::x0#0
(byte) main::x0#1
(byte) main::x0#2
(byte) main::x1
(byte) main::x1#0
(byte) main::x1#1
(byte) main::x2
(byte) main::x2#0
(byte) main::x2#1
(byte) main::y
(byte) main::y#0
(byte) main::y#1
(byte) main::y#2
(byte) main::y#3
(byte) main::y#4
(byte) main::y#5
(byte) main::y#6
(byte) main::y0
(byte) main::y0#0
(byte) main::y0#1
(byte) main::y0#2
(byte) main::y1
(byte) main::y1#0
(byte) main::y1#1
(byte) main::y2
(byte) main::y2#0
(byte) main::y2#1
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(bool~) memset::$0
(bool~) memset::$1
(byte*~) memset::$2
(bool~) memset::$3
(byte*~) memset::$4
(label) memset::@1
(label) memset::@2
(label) memset::@3
(label) memset::@4
(label) memset::@return
(byte) memset::c
(byte) memset::c#0
(byte) memset::c#1
(byte) memset::c#2
(byte) memset::c#3
(byte) memset::c#4
(byte) memset::c#5
(byte) memset::c#6
(byte) memset::c#7
(byte*) memset::dst
(byte*) memset::dst#0
(byte*) memset::dst#1
(byte*) memset::dst#2
(byte*) memset::dst#3
(byte*) memset::end
(byte*) memset::end#0
(byte*) memset::end#1
(byte*) memset::end#2
(word) memset::num
(word) memset::num#0
(word) memset::num#1
(word) memset::num#2
(word) memset::num#3
(word) memset::num#4
(word) memset::num#5
(void*) memset::return
(void*) memset::return#0
(void*) memset::return#1
(void*) memset::return#2
(void*) memset::return#3
(void*) memset::return#4
(void*) memset::return#5
(void*) memset::return#6
(void*) memset::str
(void*) memset::str#0
(void*) memset::str#1
(void*) memset::str#2
(void*) memset::str#3
(void*) memset::str#4
(void*) memset::str#5
(void*) memset::str#6
(void*) memset::str#7
(void*) memset::str#8
(const byte*) plot_bit[(number) 8]  = { (byte) $80, (byte) $40, (byte) $20, (byte) $10, (byte) 8, (byte) 4, (byte) 2, (byte) 1 }
(const byte**) plot_column[(number) $10]  = { (const nomodify byte*) LINE_BUFFER+(number) 0, (const nomodify byte*) LINE_BUFFER+(number) 1*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) 2*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) 3*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) 4*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) 5*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) 6*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) 7*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) 8*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) 9*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) $a*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) $b*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) $c*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) $d*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) $e*(number) $80, (const nomodify byte*) LINE_BUFFER+(number) $f*(number) $80 }
(const byte*) printf_buffer_number::digits[(number) $b]  = { fill( $b, 0) }
(byte) printf_buffer_number::sign
(byte) printf_format_number::justify_left
(byte) printf_format_number::min_length
(byte) printf_format_number::radix
(byte) printf_format_number::sign_always
(byte) printf_format_number::upper_case
(byte) printf_format_number::zero_padding
(byte) printf_format_string::justify_left
(byte) printf_format_string::min_length
(void()) setup_irq()
(label) setup_irq::@return
(byte()) sgn_u8((byte) sgn_u8::u)
(number~) sgn_u8::$0
(bool~) sgn_u8::$1
(label) sgn_u8::@1
(label) sgn_u8::@2
(label) sgn_u8::@return
(byte) sgn_u8::return
(byte) sgn_u8::return#0
(byte) sgn_u8::return#1
(byte) sgn_u8::return#2
(byte) sgn_u8::return#3
(byte) sgn_u8::return#4
(byte) sgn_u8::return#5
(byte) sgn_u8::return#6
(byte) sgn_u8::return#7
(byte) sgn_u8::u
(byte) sgn_u8::u#0
(byte) sgn_u8::u#1
(byte) sgn_u8::u#2
(byte()) textcolor((byte) textcolor::color)
(label) textcolor::@return
(byte) textcolor::color
(byte) textcolor::color#0
(byte) textcolor::color#1
(byte) textcolor::old
(byte) textcolor::old#0
(byte) textcolor::return
(byte) textcolor::return#0
(byte) textcolor::return#1
(byte) textcolor::return#2
(byte) textcolor::return#3
(label) toD0181
(number~) toD0181_$0
(number~) toD0181_$1
(number~) toD0181_$2
(byte~) toD0181_$3
(number~) toD0181_$4
(number~) toD0181_$5
(number~) toD0181_$6
(word~) toD0181_$7
(label) toD0181_@return
(byte*) toD0181_gfx
(byte*) toD0181_gfx#0
(byte*) toD0181_gfx#1
(byte) toD0181_return
(byte) toD0181_return#0
(byte) toD0181_return#1
(byte) toD0181_return#2
(byte) toD0181_return#3
(byte*) toD0181_screen
(byte*) toD0181_screen#0
(byte*) toD0181_screen#1

Adding number conversion cast (unumber) 0 in 
Adding number conversion cast (unumber) 1*$80 in 
Adding number conversion cast (unumber) 2*$80 in 
Adding number conversion cast (unumber) 3*$80 in 
Adding number conversion cast (unumber) 4*$80 in 
Adding number conversion cast (unumber) 5*$80 in 
Adding number conversion cast (unumber) 6*$80 in 
Adding number conversion cast (unumber) 7*$80 in 
Adding number conversion cast (unumber) 8*$80 in 
Adding number conversion cast (unumber) 9*$80 in 
Adding number conversion cast (unumber) $a*$80 in 
Adding number conversion cast (unumber) $b*$80 in 
Adding number conversion cast (unumber) $c*$80 in 
Adding number conversion cast (unumber) $d*$80 in 
Adding number conversion cast (unumber) $e*$80 in 
Adding number conversion cast (unumber) $f*$80 in 
Adding number conversion cast (unumber) $40 in 
Adding number conversion cast (unumber) 0 in (bool~) memset::$0 ← (word) memset::num#4 > (number) 0
Adding number conversion cast (unumber) $ffffffff in (number~) clock::$0 ← (number) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
Adding number conversion cast (unumber) clock::$0 in (number~) clock::$0 ← (unumber)(number) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
Adding number conversion cast (unumber) $ffffffff in *((const nomodify dword*) CIA2_TIMER_AB) ← (number) $ffffffff
Adding number conversion cast (unumber) 0 in *((const nomodify byte*) kbhit::CIA1_PORT_A) ← (number) 0
Adding number conversion cast (unumber) $3fff in (number~) toD0181_$0 ← (word~) toD0181_$7 & (number) $3fff
Adding number conversion cast (unumber) toD0181_$0 in (number~) toD0181_$0 ← (word~) toD0181_$7 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) toD0181_$1 ← (unumber~) toD0181_$0 * (number) 4
Adding number conversion cast (unumber) toD0181_$1 in (number~) toD0181_$1 ← (unumber~) toD0181_$0 * (unumber)(number) 4
Adding number conversion cast (unumber) toD0181_$2 in (number~) toD0181_$2 ← > (unumber~) toD0181_$1
Adding number conversion cast (unumber) 4 in (number~) toD0181_$4 ← (byte~) toD0181_$3 / (number) 4
Adding number conversion cast (unumber) toD0181_$4 in (number~) toD0181_$4 ← (byte~) toD0181_$3 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) toD0181_$5 ← (unumber~) toD0181_$4 & (number) $f
Adding number conversion cast (unumber) toD0181_$5 in (number~) toD0181_$5 ← (unumber~) toD0181_$4 & (unumber)(number) $f
Adding number conversion cast (unumber) toD0181_$6 in (number~) toD0181_$6 ← (unumber~) toD0181_$2 | (unumber~) toD0181_$5
Adding number conversion cast (unumber) $28*$19 in (word) memset::num#0 ← (number) $28*(number) $19
Adding number conversion cast (unumber) 0 in (byte) memset::c#1 ← (number) 0
Adding number conversion cast (unumber) $28*$19 in (word) memset::num#1 ← (number) $28*(number) $19
Adding number conversion cast (unumber) $28*$19 in (word) memset::num#2 ← (number) $28*(number) $19
Adding number conversion cast (unumber) $c in (byte*) main::screen#0 ← (const nomodify byte*) SCREEN+(number) $c
Adding number conversion cast (unumber) $c in (byte*) main::cols#0 ← (const nomodify byte*) COLS+(number) $c
Adding number conversion cast (unumber) $10 in (bool~) main::$7 ← (byte) main::y#2 < (number) $10
Adding number conversion cast (unumber) $f in (number~) main::$5 ← (byte) main::p0_idx#0 + (number) $f
Adding number conversion cast (unumber) main::$5 in (number~) main::$5 ← (byte) main::p0_idx#0 + (unumber)(number) $f
Adding number conversion cast (unumber) $aa in (number~) main::$6 ← (byte) main::p0_idx#0 + (number) $aa
Adding number conversion cast (unumber) main::$6 in (number~) main::$6 ← (byte) main::p0_idx#0 + (unumber)(number) $aa
Adding number conversion cast (unumber) $10 in (bool~) main::$8 ← (byte) main::x#2 < (number) $10
Adding number conversion cast (unumber) $10 in (byte) main::c#1 ← (byte) main::c#2 + (number) $10
Adding number conversion cast (unumber) $28 in (byte*) main::cols#1 ← (byte*) main::cols#3 + (number) $28
Adding number conversion cast (unumber) $28 in (byte*) main::screen#1 ← (byte*) main::screen#3 + (number) $28
Adding number conversion cast (unumber) 0 in (byte) memset::c#3 ← (number) 0
Adding number conversion cast (unumber) $800 in (word) memset::num#3 ← (number) $800
Adding number conversion cast (unumber) 0 in (bool~) main::$22 ← (number) 0 != (volatile byte) canvas_show_flag
Adding number conversion cast (unumber) $3fff in (number~) main::toD0181_$0 ← (word~) main::toD0181_$7 & (number) $3fff
Adding number conversion cast (unumber) main::toD0181_$0 in (number~) main::toD0181_$0 ← (word~) main::toD0181_$7 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$1 ← (unumber~) main::toD0181_$0 * (number) 4
Adding number conversion cast (unumber) main::toD0181_$1 in (number~) main::toD0181_$1 ← (unumber~) main::toD0181_$0 * (unumber)(number) 4
Adding number conversion cast (unumber) main::toD0181_$2 in (number~) main::toD0181_$2 ← > (unumber~) main::toD0181_$1
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$4 ← (byte~) main::toD0181_$3 / (number) 4
Adding number conversion cast (unumber) main::toD0181_$4 in (number~) main::toD0181_$4 ← (byte~) main::toD0181_$3 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) main::toD0181_$5 ← (unumber~) main::toD0181_$4 & (number) $f
Adding number conversion cast (unumber) main::toD0181_$5 in (number~) main::toD0181_$5 ← (unumber~) main::toD0181_$4 & (unumber)(number) $f
Adding number conversion cast (unumber) main::toD0181_$6 in (number~) main::toD0181_$6 ← (unumber~) main::toD0181_$2 | (unumber~) main::toD0181_$5
Adding number conversion cast (unumber) $3fff in (number~) main::toD0182_$0 ← (word~) main::toD0182_$7 & (number) $3fff
Adding number conversion cast (unumber) main::toD0182_$0 in (number~) main::toD0182_$0 ← (word~) main::toD0182_$7 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) main::toD0182_$1 ← (unumber~) main::toD0182_$0 * (number) 4
Adding number conversion cast (unumber) main::toD0182_$1 in (number~) main::toD0182_$1 ← (unumber~) main::toD0182_$0 * (unumber)(number) 4
Adding number conversion cast (unumber) main::toD0182_$2 in (number~) main::toD0182_$2 ← > (unumber~) main::toD0182_$1
Adding number conversion cast (unumber) 4 in (number~) main::toD0182_$4 ← (byte~) main::toD0182_$3 / (number) 4
Adding number conversion cast (unumber) main::toD0182_$4 in (number~) main::toD0182_$4 ← (byte~) main::toD0182_$3 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) main::toD0182_$5 ← (unumber~) main::toD0182_$4 & (number) $f
Adding number conversion cast (unumber) main::toD0182_$5 in (number~) main::toD0182_$5 ← (unumber~) main::toD0182_$4 & (unumber)(number) $f
Adding number conversion cast (unumber) main::toD0182_$6 in (number~) main::toD0182_$6 ← (unumber~) main::toD0182_$2 | (unumber~) main::toD0182_$5
Adding number conversion cast (unumber) 1 in (volatile byte) canvas_show_flag ← (number) 1
Adding number conversion cast (unumber) $7f in *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (number) $7f
Adding number conversion cast (unumber) BORDER_YPOS_BOTTOM-8 in *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(number) 8
Adding number conversion cast (unumber) 8 in *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← ((unumber)) (const nomodify byte) BORDER_YPOS_BOTTOM-(number) 8
Adding number conversion cast (unumber) $3fff in (number~) irq_bottom_1::toD0181_$0 ← (word~) irq_bottom_1::toD0181_$7 & (number) $3fff
Adding number conversion cast (unumber) irq_bottom_1::toD0181_$0 in (number~) irq_bottom_1::toD0181_$0 ← (word~) irq_bottom_1::toD0181_$7 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) irq_bottom_1::toD0181_$1 ← (unumber~) irq_bottom_1::toD0181_$0 * (number) 4
Adding number conversion cast (unumber) irq_bottom_1::toD0181_$1 in (number~) irq_bottom_1::toD0181_$1 ← (unumber~) irq_bottom_1::toD0181_$0 * (unumber)(number) 4
Adding number conversion cast (unumber) irq_bottom_1::toD0181_$2 in (number~) irq_bottom_1::toD0181_$2 ← > (unumber~) irq_bottom_1::toD0181_$1
Adding number conversion cast (unumber) 4 in (number~) irq_bottom_1::toD0181_$4 ← (byte~) irq_bottom_1::toD0181_$3 / (number) 4
Adding number conversion cast (unumber) irq_bottom_1::toD0181_$4 in (number~) irq_bottom_1::toD0181_$4 ← (byte~) irq_bottom_1::toD0181_$3 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) irq_bottom_1::toD0181_$5 ← (unumber~) irq_bottom_1::toD0181_$4 & (number) $f
Adding number conversion cast (unumber) irq_bottom_1::toD0181_$5 in (number~) irq_bottom_1::toD0181_$5 ← (unumber~) irq_bottom_1::toD0181_$4 & (unumber)(number) $f
Adding number conversion cast (unumber) irq_bottom_1::toD0181_$6 in (number~) irq_bottom_1::toD0181_$6 ← (unumber~) irq_bottom_1::toD0181_$2 | (unumber~) irq_bottom_1::toD0181_$5
Adding number conversion cast (unumber) 0 in (bool~) irq_bottom_2::$3 ← (number) 0 != (byte~) irq_bottom_2::$0
Adding number conversion cast (unumber) $3fff in (number~) irq_bottom_2::toD0181_$0 ← (word~) irq_bottom_2::toD0181_$7 & (number) $3fff
Adding number conversion cast (unumber) irq_bottom_2::toD0181_$0 in (number~) irq_bottom_2::toD0181_$0 ← (word~) irq_bottom_2::toD0181_$7 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) irq_bottom_2::toD0181_$1 ← (unumber~) irq_bottom_2::toD0181_$0 * (number) 4
Adding number conversion cast (unumber) irq_bottom_2::toD0181_$1 in (number~) irq_bottom_2::toD0181_$1 ← (unumber~) irq_bottom_2::toD0181_$0 * (unumber)(number) 4
Adding number conversion cast (unumber) irq_bottom_2::toD0181_$2 in (number~) irq_bottom_2::toD0181_$2 ← > (unumber~) irq_bottom_2::toD0181_$1
Adding number conversion cast (unumber) 4 in (number~) irq_bottom_2::toD0181_$4 ← (byte~) irq_bottom_2::toD0181_$3 / (number) 4
Adding number conversion cast (unumber) irq_bottom_2::toD0181_$4 in (number~) irq_bottom_2::toD0181_$4 ← (byte~) irq_bottom_2::toD0181_$3 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) irq_bottom_2::toD0181_$5 ← (unumber~) irq_bottom_2::toD0181_$4 & (number) $f
Adding number conversion cast (unumber) irq_bottom_2::toD0181_$5 in (number~) irq_bottom_2::toD0181_$5 ← (unumber~) irq_bottom_2::toD0181_$4 & (unumber)(number) $f
Adding number conversion cast (unumber) irq_bottom_2::toD0181_$6 in (number~) irq_bottom_2::toD0181_$6 ← (unumber~) irq_bottom_2::toD0181_$2 | (unumber~) irq_bottom_2::toD0181_$5
Adding number conversion cast (unumber) 0 in (volatile byte) canvas_show_flag ← (number) 0
Adding number conversion cast (unumber) BORDER_YPOS_BOTTOM-8 in *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(number) 8
Adding number conversion cast (unumber) 8 in *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← ((unumber)) (const nomodify byte) BORDER_YPOS_BOTTOM-(number) 8
Adding number conversion cast (unumber) $ff in (bool~) line::$8 ← (byte) line::sx#1 == (number) $ff
Adding number conversion cast (unumber) 2 in (number~) line::$26 ← (byte) line::dx#2 / (number) 2
Adding number conversion cast (unumber) line::$26 in (number~) line::$26 ← (byte) line::dx#2 / (unumber)(number) 2
Adding number conversion cast (unumber) 8 in (number~) line::plot1_$0 ← (byte) line::plot1_x#1 / (number) 8
Adding number conversion cast (unumber) line::plot1_$0 in (number~) line::plot1_$0 ← (byte) line::plot1_x#1 / (unumber)(number) 8
Adding number conversion cast (unumber) line::plot1_$2 in (number~) line::plot1_$2 ← (unumber~) line::plot1_$0 * (const byte) SIZEOF_POINTER
Adding number conversion cast (unumber) 7 in (number~) line::plot1_$1 ← (byte) line::plot1_x#1 & (number) 7
Adding number conversion cast (unumber) line::plot1_$1 in (number~) line::plot1_$1 ← (byte) line::plot1_x#1 & (unumber)(number) 7
Adding number conversion cast (unumber) 0 in (bool~) line::$20 ← (byte) line::dx#3 == (number) 0
Adding number conversion cast (unumber) 2 in (number~) line::$12 ← (byte) line::dy#2 / (number) 2
Adding number conversion cast (unumber) line::$12 in (number~) line::$12 ← (byte) line::dy#2 / (unumber)(number) 2
Adding number conversion cast (unumber) 8 in (number~) line::plot2_$0 ← (byte) line::plot2_x#1 / (number) 8
Adding number conversion cast (unumber) line::plot2_$0 in (number~) line::plot2_$0 ← (byte) line::plot2_x#1 / (unumber)(number) 8
Adding number conversion cast (unumber) line::plot2_$2 in (number~) line::plot2_$2 ← (unumber~) line::plot2_$0 * (const byte) SIZEOF_POINTER
Adding number conversion cast (unumber) 7 in (number~) line::plot2_$1 ← (byte) line::plot2_x#1 & (number) 7
Adding number conversion cast (unumber) line::plot2_$1 in (number~) line::plot2_$1 ← (byte) line::plot2_x#1 & (unumber)(number) 7
Adding number conversion cast (unumber) 8 in (number~) line::plot3_$0 ← (byte) line::plot3_x#1 / (number) 8
Adding number conversion cast (unumber) line::plot3_$0 in (number~) line::plot3_$0 ← (byte) line::plot3_x#1 / (unumber)(number) 8
Adding number conversion cast (unumber) line::plot3_$2 in (number~) line::plot3_$2 ← (unumber~) line::plot3_$0 * (const byte) SIZEOF_POINTER
Adding number conversion cast (unumber) 7 in (number~) line::plot3_$1 ← (byte) line::plot3_x#1 & (number) 7
Adding number conversion cast (unumber) line::plot3_$1 in (number~) line::plot3_$1 ← (byte) line::plot3_x#1 & (unumber)(number) 7
Adding number conversion cast (unumber) 2 in (number~) line::$22 ← (byte) line::dy#5 / (number) 2
Adding number conversion cast (unumber) line::$22 in (number~) line::$22 ← (byte) line::dy#5 / (unumber)(number) 2
Adding number conversion cast (unumber) 8 in (number~) line::plot4_$0 ← (byte) line::plot4_x#1 / (number) 8
Adding number conversion cast (unumber) line::plot4_$0 in (number~) line::plot4_$0 ← (byte) line::plot4_x#1 / (unumber)(number) 8
Adding number conversion cast (unumber) line::plot4_$2 in (number~) line::plot4_$2 ← (unumber~) line::plot4_$0 * (const byte) SIZEOF_POINTER
Adding number conversion cast (unumber) 7 in (number~) line::plot4_$1 ← (byte) line::plot4_x#1 & (number) 7
Adding number conversion cast (unumber) line::plot4_$1 in (number~) line::plot4_$1 ← (byte) line::plot4_x#1 & (unumber)(number) 7
Adding number conversion cast (unumber) 8 in (number~) line::plot5_$0 ← (byte) line::plot5_x#1 / (number) 8
Adding number conversion cast (unumber) line::plot5_$0 in (number~) line::plot5_$0 ← (byte) line::plot5_x#1 / (unumber)(number) 8
Adding number conversion cast (unumber) line::plot5_$2 in (number~) line::plot5_$2 ← (unumber~) line::plot5_$0 * (const byte) SIZEOF_POINTER
Adding number conversion cast (unumber) 7 in (number~) line::plot5_$1 ← (byte) line::plot5_x#1 & (number) 7
Adding number conversion cast (unumber) line::plot5_$1 in (number~) line::plot5_$1 ← (byte) line::plot5_x#1 & (unumber)(number) 7
Adding number conversion cast (unumber) 8 in (number~) line::plot6_$0 ← (byte) line::plot6_x#1 / (number) 8
Adding number conversion cast (unumber) line::plot6_$0 in (number~) line::plot6_$0 ← (byte) line::plot6_x#1 / (unumber)(number) 8
Adding number conversion cast (unumber) line::plot6_$2 in (number~) line::plot6_$2 ← (unumber~) line::plot6_$0 * (const byte) SIZEOF_POINTER
Adding number conversion cast (unumber) 7 in (number~) line::plot6_$1 ← (byte) line::plot6_x#1 & (number) 7
Adding number conversion cast (unumber) line::plot6_$1 in (number~) line::plot6_$1 ← (byte) line::plot6_x#1 & (unumber)(number) 7
Adding number conversion cast (unumber) $10 in (bool~) eorfill::$0 ← (byte) eorfill::x#2 < (number) $10
Adding number conversion cast (unumber) 0 in (byte) eorfill::eor#0 ← *((byte*) eorfill::line_column#2 + (number) 0)
Adding number conversion cast (unumber) 0 in *((byte*) eorfill::fill_column#2 + (number) 0) ← (byte) eorfill::eor#0
Adding number conversion cast (unumber) $10*8 in (bool~) eorfill::$1 ← (byte) eorfill::y#2 < (number) $10*(number) 8
Adding number conversion cast (unumber) $10*8 in (byte*) eorfill::line_column#1 ← (byte*) eorfill::line_column#4 + (number) $10*(number) 8
Adding number conversion cast (unumber) $10*8 in (byte*) eorfill::fill_column#1 ← (byte*) eorfill::fill_column#4 + (number) $10*(number) 8
Adding number conversion cast (unumber) $80 in (number~) abs_u8::$0 ← (byte) abs_u8::u#2 & (number) $80
Adding number conversion cast (unumber) abs_u8::$0 in (number~) abs_u8::$0 ← (byte) abs_u8::u#2 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) abs_u8::$2 ← (number) 0 != (unumber~) abs_u8::$0
Adding number conversion cast (unumber) $80 in (number~) sgn_u8::$0 ← (byte) sgn_u8::u#2 & (number) $80
Adding number conversion cast (unumber) sgn_u8::$0 in (number~) sgn_u8::$0 ← (byte) sgn_u8::u#2 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) sgn_u8::$1 ← (number) 0 != (unumber~) sgn_u8::$0
Adding number conversion cast (unumber) -1 in (byte) sgn_u8::return#2 ← (number) -1
Adding number conversion cast (unumber) 1 in (byte) sgn_u8::return#3 ← (number) 1
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) memset::dst#0 ← (byte*)(void*) memset::str#5
Inlining cast *((const nomodify dword*) CIA2_TIMER_AB) ← (unumber)(number) $ffffffff
Inlining cast *((const nomodify byte*) kbhit::CIA1_PORT_A) ← (unumber)(number) 0
Inlining cast (word) memset::num#0 ← (unumber)(number) $28*(number) $19
Inlining cast (byte) memset::c#1 ← (unumber)(number) 0
Inlining cast (word) memset::num#1 ← (unumber)(number) $28*(number) $19
Inlining cast (word) memset::num#2 ← (unumber)(number) $28*(number) $19
Inlining cast (byte) memset::c#3 ← (unumber)(number) 0
Inlining cast (word) memset::num#3 ← (unumber)(number) $800
Inlining cast (byte*) main::canvas#1 ← (byte*)(word~) main::$20
Inlining cast (volatile byte) canvas_show_flag ← (unumber)(number) 1
Inlining cast *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (unumber)(const nomodify byte) BORDER_YPOS_BOTTOM-(unumber)(number) 8
Inlining cast (volatile byte) canvas_show_flag ← (unumber)(number) 0
Inlining cast *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (unumber)(const nomodify byte) BORDER_YPOS_BOTTOM-(unumber)(number) 8
Inlining cast (byte) sgn_u8::return#2 ← (unumber)(number) -1
Inlining cast (byte) sgn_u8::return#3 ← (unumber)(number) 1
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (struct MOS6569_VICII*) 53248
Simplifying constant pointer cast (byte*) 55296
Simplifying constant pointer cast (struct MOS6526_CIA*) 56320
Simplifying constant pointer cast (struct MOS6526_CIA*) 56576
Simplifying constant pointer cast (dword*) 56580
Simplifying constant pointer cast (void()**) 788
Simplifying constant pointer cast (byte*) 56320
Simplifying constant pointer cast (byte*) 56321
Simplifying constant pointer cast (byte*) 8192
Simplifying constant pointer cast (byte*) 12288
Simplifying constant pointer cast (byte*) 14336
Simplifying constant pointer cast (byte*) 11264
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 4096
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast 0
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast 0
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 0
Simplifying constant integer cast $c
Simplifying constant integer cast $c
Simplifying constant integer cast $10
Simplifying constant integer cast $f
Simplifying constant integer cast $aa
Simplifying constant integer cast $10
Simplifying constant integer cast $10
Simplifying constant integer cast $28
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast $800
Simplifying constant integer cast 0
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast $7f
Simplifying constant integer cast (const nomodify byte) BORDER_YPOS_BOTTOM-(unumber)(number) 8
Simplifying constant integer cast 8
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 0
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 0
Simplifying constant integer cast (const nomodify byte) BORDER_YPOS_BOTTOM-(unumber)(number) 8
Simplifying constant integer cast 8
Simplifying constant integer cast $ff
Simplifying constant integer cast 2
Simplifying constant integer cast 8
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 8
Simplifying constant integer cast 7
Simplifying constant integer cast 8
Simplifying constant integer cast 7
Simplifying constant integer cast 2
Simplifying constant integer cast 8
Simplifying constant integer cast 7
Simplifying constant integer cast 8
Simplifying constant integer cast 7
Simplifying constant integer cast 8
Simplifying constant integer cast 7
Simplifying constant integer cast $10
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast -1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 0
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $c
Finalized unsigned number type (byte) $c
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $aa
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $800
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) 8
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) -1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to dword in (unumber~) clock::$0 ← (dword) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
Inferred type updated to word in (unumber~) toD0181_$0 ← (word~) toD0181_$7 & (word) $3fff
Inferred type updated to word in (unumber~) toD0181_$1 ← (word~) toD0181_$0 * (byte) 4
Inferred type updated to byte in (unumber~) toD0181_$2 ← > (word~) toD0181_$1
Inferred type updated to byte in (unumber~) toD0181_$4 ← (byte~) toD0181_$3 / (byte) 4
Inferred type updated to byte in (unumber~) toD0181_$5 ← (byte~) toD0181_$4 & (byte) $f
Inferred type updated to byte in (unumber~) toD0181_$6 ← (byte~) toD0181_$2 | (byte~) toD0181_$5
Inferred type updated to byte in (unumber~) main::$5 ← (byte) main::p0_idx#0 + (byte) $f
Inferred type updated to byte in (unumber~) main::$6 ← (byte) main::p0_idx#0 + (byte) $aa
Inferred type updated to word in (unumber~) main::toD0181_$0 ← (word~) main::toD0181_$7 & (word) $3fff
Inferred type updated to word in (unumber~) main::toD0181_$1 ← (word~) main::toD0181_$0 * (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$2 ← > (word~) main::toD0181_$1
Inferred type updated to byte in (unumber~) main::toD0181_$4 ← (byte~) main::toD0181_$3 / (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$5 ← (byte~) main::toD0181_$4 & (byte) $f
Inferred type updated to byte in (unumber~) main::toD0181_$6 ← (byte~) main::toD0181_$2 | (byte~) main::toD0181_$5
Inferred type updated to word in (unumber~) main::toD0182_$0 ← (word~) main::toD0182_$7 & (word) $3fff
Inferred type updated to word in (unumber~) main::toD0182_$1 ← (word~) main::toD0182_$0 * (byte) 4
Inferred type updated to byte in (unumber~) main::toD0182_$2 ← > (word~) main::toD0182_$1
Inferred type updated to byte in (unumber~) main::toD0182_$4 ← (byte~) main::toD0182_$3 / (byte) 4
Inferred type updated to byte in (unumber~) main::toD0182_$5 ← (byte~) main::toD0182_$4 & (byte) $f
Inferred type updated to byte in (unumber~) main::toD0182_$6 ← (byte~) main::toD0182_$2 | (byte~) main::toD0182_$5
Inferred type updated to word in (unumber~) irq_bottom_1::toD0181_$0 ← (word~) irq_bottom_1::toD0181_$7 & (word) $3fff
Inferred type updated to word in (unumber~) irq_bottom_1::toD0181_$1 ← (word~) irq_bottom_1::toD0181_$0 * (byte) 4
Inferred type updated to byte in (unumber~) irq_bottom_1::toD0181_$2 ← > (word~) irq_bottom_1::toD0181_$1
Inferred type updated to byte in (unumber~) irq_bottom_1::toD0181_$4 ← (byte~) irq_bottom_1::toD0181_$3 / (byte) 4
Inferred type updated to byte in (unumber~) irq_bottom_1::toD0181_$5 ← (byte~) irq_bottom_1::toD0181_$4 & (byte) $f
Inferred type updated to byte in (unumber~) irq_bottom_1::toD0181_$6 ← (byte~) irq_bottom_1::toD0181_$2 | (byte~) irq_bottom_1::toD0181_$5
Inferred type updated to word in (unumber~) irq_bottom_2::toD0181_$0 ← (word~) irq_bottom_2::toD0181_$7 & (word) $3fff
Inferred type updated to word in (unumber~) irq_bottom_2::toD0181_$1 ← (word~) irq_bottom_2::toD0181_$0 * (byte) 4
Inferred type updated to byte in (unumber~) irq_bottom_2::toD0181_$2 ← > (word~) irq_bottom_2::toD0181_$1
Inferred type updated to byte in (unumber~) irq_bottom_2::toD0181_$4 ← (byte~) irq_bottom_2::toD0181_$3 / (byte) 4
Inferred type updated to byte in (unumber~) irq_bottom_2::toD0181_$5 ← (byte~) irq_bottom_2::toD0181_$4 & (byte) $f
Inferred type updated to byte in (unumber~) irq_bottom_2::toD0181_$6 ← (byte~) irq_bottom_2::toD0181_$2 | (byte~) irq_bottom_2::toD0181_$5
Inferred type updated to byte in (unumber~) line::$26 ← (byte) line::dx#2 / (byte) 2
Inferred type updated to byte in (unumber~) line::plot1_$0 ← (byte) line::plot1_x#1 / (byte) 8
Inferred type updated to byte in (unumber~) line::plot1_$2 ← (byte~) line::plot1_$0 * (const byte) SIZEOF_POINTER
Inferred type updated to byte in (unumber~) line::plot1_$1 ← (byte) line::plot1_x#1 & (byte) 7
Inferred type updated to byte in (unumber~) line::$12 ← (byte) line::dy#2 / (byte) 2
Inferred type updated to byte in (unumber~) line::plot2_$0 ← (byte) line::plot2_x#1 / (byte) 8
Inferred type updated to byte in (unumber~) line::plot2_$2 ← (byte~) line::plot2_$0 * (const byte) SIZEOF_POINTER
Inferred type updated to byte in (unumber~) line::plot2_$1 ← (byte) line::plot2_x#1 & (byte) 7
Inferred type updated to byte in (unumber~) line::plot3_$0 ← (byte) line::plot3_x#1 / (byte) 8
Inferred type updated to byte in (unumber~) line::plot3_$2 ← (byte~) line::plot3_$0 * (const byte) SIZEOF_POINTER
Inferred type updated to byte in (unumber~) line::plot3_$1 ← (byte) line::plot3_x#1 & (byte) 7
Inferred type updated to byte in (unumber~) line::$22 ← (byte) line::dy#5 / (byte) 2
Inferred type updated to byte in (unumber~) line::plot4_$0 ← (byte) line::plot4_x#1 / (byte) 8
Inferred type updated to byte in (unumber~) line::plot4_$2 ← (byte~) line::plot4_$0 * (const byte) SIZEOF_POINTER
Inferred type updated to byte in (unumber~) line::plot4_$1 ← (byte) line::plot4_x#1 & (byte) 7
Inferred type updated to byte in (unumber~) line::plot5_$0 ← (byte) line::plot5_x#1 / (byte) 8
Inferred type updated to byte in (unumber~) line::plot5_$2 ← (byte~) line::plot5_$0 * (const byte) SIZEOF_POINTER
Inferred type updated to byte in (unumber~) line::plot5_$1 ← (byte) line::plot5_x#1 & (byte) 7
Inferred type updated to byte in (unumber~) line::plot6_$0 ← (byte) line::plot6_x#1 / (byte) 8
Inferred type updated to byte in (unumber~) line::plot6_$2 ← (byte~) line::plot6_$0 * (const byte) SIZEOF_POINTER
Inferred type updated to byte in (unumber~) line::plot6_$1 ← (byte) line::plot6_x#1 & (byte) 7
Inferred type updated to byte in (unumber~) abs_u8::$0 ← (byte) abs_u8::u#2 & (byte) $80
Inferred type updated to byte in (unumber~) sgn_u8::$0 ← (byte) sgn_u8::u#2 & (byte) $80
Inversing boolean not [2] (bool~) memset::$1 ← (word) memset::num#4 <= (byte) 0 from [1] (bool~) memset::$0 ← (word) memset::num#4 > (byte) 0
Inversing boolean not [240] (bool~) irq_bottom_2::$1 ← (byte) 0 == (byte~) irq_bottom_2::$0 from [239] (bool~) irq_bottom_2::$3 ← (byte) 0 != (byte~) irq_bottom_2::$0
Inversing boolean not [297] (bool~) line::$9 ← (byte) line::sx#1 != (byte) $ff from [296] (bool~) line::$8 ← (byte) line::sx#1 == (byte) $ff
Inversing boolean not [322] (bool~) line::$21 ← (byte) line::dx#3 != (byte) 0 from [321] (bool~) line::$20 ← (byte) line::dx#3 == (byte) 0
Inversing boolean not [331] (bool~) line::$14 ← (byte) line::e#1 <= (byte) line::dy#3 from [330] (bool~) line::$13 ← (byte) line::e#1 > (byte) line::dy#3
Inversing boolean not [394] (bool~) line::$29 ← (byte) line::e2#1 <= (byte) line::dx#6 from [393] (bool~) line::$28 ← (byte) line::e2#1 > (byte) line::dx#6
Successful SSA optimization Pass2UnaryNotSimplification
Alias candidate removed (volatile)toD0181_return#0 = toD0181_$6 toD0181_return#2 toD0181_return#1 toD0181_return#3 $0 canvas_show_memory 
Alias memset::return#0 = memset::str#4 memset::return#6 memset::return#1 
Alias memset::str#5 = memset::str#6 
Alias memset::num#4 = memset::num#5 
Alias memset::c#6 = memset::c#7 
Alias memset::end#0 = memset::$2 
Alias memset::c#4 = memset::c#5 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#7 = memset::str#8 
Alias clock::return#0 = clock::$0 clock::return#3 clock::return#1 
Alias textcolor::return#0 = textcolor::old#0 textcolor::return#3 textcolor::return#1 
Alias kbhit::return#0 = kbhit::$0 kbhit::return#3 kbhit::return#1 
Alias toD0181_screen#0 = toD0181_screen#1 
Alias toD0181_gfx#0 = toD0181_gfx#1 
Alias main::y#2 = main::y#3 main::c#0 
Alias main::cols#5 = main::cols#6 
Alias main::screen#5 = main::screen#6 
Alias main::p1_idx#0 = main::$5 
Alias main::p2_idx#0 = main::$6 
Alias main::cols#2 = main::cols#4 main::cols#3 
Alias main::x#2 = main::x#3 
Alias main::c#2 = main::c#3 
Alias main::screen#2 = main::screen#4 main::screen#3 
Alias main::y#4 = main::y#6 main::y#5 
Alias main::p0_idx#2 = main::p0_idx#6 main::p0_idx#8 main::p0_idx#4 main::p0_idx#7 main::p0_idx#5 main::p0_idx#3 
Alias main::p1_idx#2 = main::p1_idx#6 main::p1_idx#8 main::p1_idx#4 main::p1_idx#7 main::p1_idx#5 main::p1_idx#3 
Alias main::p2_idx#2 = main::p2_idx#7 main::p2_idx#8 main::p2_idx#6 main::p2_idx#4 main::p2_idx#5 main::p2_idx#3 
Alias main::canvas#10 = main::canvas#11 main::canvas#9 main::canvas#8 main::canvas#7 main::canvas#6 main::canvas#5 
Alias main::x1#0 = main::x1#1 
Alias main::y1#0 = main::y1#1 
Alias main::x0#0 = main::x0#2 main::x0#1 
Alias main::y0#0 = main::y0#2 main::y0#1 
Alias main::x2#0 = main::x2#1 
Alias main::y2#0 = main::y2#1 
Alias main::canvas#2 = main::canvas#4 main::canvas#3 
Alias main::p0_idx#10 = main::p0_idx#17 main::p0_idx#18 main::p0_idx#16 main::p0_idx#15 main::p0_idx#14 main::p0_idx#13 main::p0_idx#12 main::p0_idx#11 main::p0_idx#9 
Alias main::p1_idx#10 = main::p1_idx#17 main::p1_idx#18 main::p1_idx#16 main::p1_idx#15 main::p1_idx#14 main::p1_idx#13 main::p1_idx#12 main::p1_idx#11 main::p1_idx#9 
Alias main::p2_idx#10 = main::p2_idx#17 main::p2_idx#18 main::p2_idx#16 main::p2_idx#15 main::p2_idx#14 main::p2_idx#13 main::p2_idx#12 main::p2_idx#11 main::p2_idx#9 
Alias main::toD0181_screen#0 = main::toD0181_screen#1 
Alias main::toD0181_gfx#0 = main::toD0181_gfx#1 
Alias main::canvas#1 = main::canvas#18 main::canvas#17 main::canvas#16 main::canvas#15 main::canvas#14 main::canvas#13 main::canvas#12 
Alias main::toD0181_return#0 = main::toD0181_$6 main::toD0181_return#2 main::toD0181_return#1 main::toD0181_return#3 main::$15 
Alias main::toD0182_screen#0 = main::toD0182_screen#1 
Alias main::toD0182_gfx#0 = main::toD0182_gfx#1 
Alias main::toD0182_return#0 = main::toD0182_$6 main::toD0182_return#2 main::toD0182_return#1 main::toD0182_return#3 main::$16 
Alias irq_bottom_1::toD0181_screen#0 = irq_bottom_1::toD0181_screen#1 
Alias irq_bottom_1::toD0181_gfx#0 = irq_bottom_1::toD0181_gfx#1 
Alias irq_bottom_1::toD0181_return#0 = irq_bottom_1::toD0181_$6 irq_bottom_1::toD0181_return#2 irq_bottom_1::toD0181_return#1 irq_bottom_1::toD0181_return#3 irq_bottom_1::$0 
Alias kbhit::return#2 = kbhit::return#4 
Alias irq_bottom_2::toD0181_screen#0 = irq_bottom_2::toD0181_screen#1 
Alias irq_bottom_2::toD0181_gfx#0 = irq_bottom_2::toD0181_gfx#1 
Alias irq_bottom_2::toD0181_return#0 = irq_bottom_2::toD0181_$6 irq_bottom_2::toD0181_return#2 irq_bottom_2::toD0181_return#1 irq_bottom_2::toD0181_return#3 irq_bottom_2::$2 
Alias line::x#0 = line::x1#3 line::x1#5 line::x#32 line::x1#4 line::x#31 line::x#29 line::x#26 line::x#27 
Alias line::y#0 = line::y1#3 line::y1#4 line::y#33 line::y1#6 line::y#31 line::y1#5 line::y#25 line::y#16 line::y#5 
Alias abs_u8::u#0 = line::$0 
Alias abs_u8::return#0 = abs_u8::return#5 
Alias line::y2#10 = line::y2#4 line::y2#8 line::y2#9 line::y2#5 line::y2#6 
Alias line::x2#19 = line::x2#7 line::x2#3 line::x2#4 line::x2#22 line::x2#20 
Alias line::dx#0 = line::$1 line::dx#22 line::dx#16 line::dx#8 line::dx#9 
Alias abs_u8::u#1 = line::$2 
Alias abs_u8::return#1 = abs_u8::return#6 
Alias line::dy#0 = line::$3 line::dy#17 line::dy#9 line::dy#10 
Alias sgn_u8::u#0 = line::$4 
Alias sgn_u8::return#0 = sgn_u8::return#5 
Alias line::sx#0 = line::$5 line::sx#1 line::sx#10 
Alias sgn_u8::u#1 = line::$6 
Alias sgn_u8::return#1 = sgn_u8::return#6 
Alias line::sy#0 = line::$7 line::sy#12 
Alias line::dx#1 = line::dx#2 line::dx#18 line::dx#17 line::dx#10 line::dx#3 line::dx#11 line::dx#13 
Alias line::x#14 = line::x#20 line::x#23 line::x#4 line::plot1_x#0 line::plot1_x#1 line::x#30 line::x#28 line::x#24 line::x#25 
Alias line::y#17 = line::y#23 line::y#26 line::y#6 line::plot1_y#0 line::plot1_y#1 line::y#32 line::y#28 line::y#18 line::y#20 
Alias line::sx#12 = line::sx#19 line::sx#6 line::sx#2 line::sx#24 line::sx#20 line::sx#16 line::sx#21 
Alias line::dy#1 = line::dy#24 line::dy#11 line::dy#22 line::dy#18 line::dy#14 line::dy#2 line::dy#5 
Alias line::x2#15 = line::x2#16 line::x2#17 line::x2#24 line::x2#23 line::x2#21 line::x2#18 
Alias line::sy#1 = line::sy#23 line::sy#6 line::sy#21 line::sy#17 line::sy#14 line::sy#7 line::sy#9 
Alias line::e2#0 = line::$26 
Alias line::y2#13 = line::y2#15 line::y2#17 
Alias line::e#0 = line::$12 
Alias line::y#19 = line::y#9 line::y#2 line::y#27 
Alias line::sy#13 = line::sy#3 line::sy#2 line::sy#18 
Alias line::x#15 = line::x#5 line::plot2_x#0 line::plot2_x#1 line::x#16 line::x#6 
Alias line::sx#11 = line::sx#15 line::sx#7 line::sx#3 
Alias line::e#1 = line::e#7 line::e#6 line::e#4 
Alias line::dy#13 = line::dy#19 line::dy#3 line::dy#4 
Alias line::y2#11 = line::y2#16 line::y2#12 line::y2#14 
Alias line::dx#19 = line::dx#26 line::dx#4 line::dx#23 
Alias line::plot2_y#0 = line::$15 line::plot2_y#1 
Alias line::x#17 = line::x#7 line::plot3_x#0 line::plot3_x#1 
Alias line::y#10 = line::y#8 line::plot3_y#0 line::plot3_y#1 
Alias line::e1#0 = line::$22 
Alias line::x#18 = line::x#8 
Alias line::sx#13 = line::sx#4 line::sx#8 line::sx#17 
Alias line::e1#1 = line::e1#4 
Alias line::dy#15 = line::dy#7 line::dy#6 line::dy#20 
Alias line::y#12 = line::y#3 line::plot4_y#0 line::plot4_y#1 line::y#29 line::y#21 
Alias line::x2#11 = line::x2#13 line::x2#8 line::x2#5 
Alias line::sy#10 = line::sy#19 line::sy#4 line::sy#15 
Alias line::dx#14 = line::dx#24 line::dx#5 line::dx#20 
Alias line::x#19 = line::plot4_x#0 line::x#2 line::plot4_x#1 line::x#9 
Alias line::e1#2 = line::e1#6 line::e1#5 
Alias line::x#10 = line::plot5_x#0 line::plot5_x#1 line::x#21 line::x#11 
Alias line::y#13 = line::plot5_y#0 line::plot5_y#1 line::y#30 line::y#24 line::y#14 
Alias line::sx#14 = line::sx#9 line::sx#5 line::sx#23 
Alias line::e2#3 = line::e2#5 line::e2#6 
Alias line::dy#16 = line::dy#21 line::dy#8 line::dy#25 
Alias line::dx#15 = line::dx#21 line::dx#6 line::dx#7 
Alias line::x2#10 = line::x2#12 line::x2#14 line::x2#9 
Alias line::sy#11 = line::sy#16 line::sy#20 line::sy#5 
Alias line::e2#1 = line::e2#4 
Alias line::x#22 = line::x#3 
Alias line::x#12 = line::x#13 line::plot6_x#0 line::plot6_x#1 
Alias line::y#15 = line::y#22 line::plot6_y#0 line::plot6_y#1 
Alias eorfill::line_column#0 = eorfill::line_buffer#1 
Alias eorfill::fill_column#0 = eorfill::canvas#1 
Alias eorfill::line_column#2 = eorfill::line_column#5 
Alias eorfill::fill_column#2 = eorfill::fill_column#5 
Alias eorfill::x#2 = eorfill::x#5 
Alias eorfill::eor#2 = eorfill::eor#3 
Alias eorfill::line_column#3 = eorfill::line_column#6 eorfill::line_column#4 
Alias eorfill::y#2 = eorfill::y#3 
Alias eorfill::fill_column#3 = eorfill::fill_column#6 eorfill::fill_column#4 
Alias eorfill::x#3 = eorfill::x#6 eorfill::x#4 
Alias abs_u8::u#2 = abs_u8::u#3 abs_u8::u#4 abs_u8::return#3 
Alias abs_u8::return#2 = abs_u8::$1 
Alias abs_u8::return#4 = abs_u8::return#7 
Alias sgn_u8::return#4 = sgn_u8::return#7 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)toD0181_return#0 = toD0181_$6 toD0181_return#2 toD0181_return#1 toD0181_return#3 $0 canvas_show_memory 
Alias line::dx#0 = line::dx#1 
Alias line::dy#0 = line::dy#1 
Alias line::sx#0 = line::sx#12 
Alias line::sy#0 = line::sy#1 
Alias line::x#0 = line::x#14 
Alias line::x2#15 = line::x2#19 
Alias line::y#10 = line::y#19 
Alias line::y2#11 = line::y2#7 
Alias line::sy#13 = line::sy#8 
Alias line::dx#12 = line::dx#19 
Alias line::dy#12 = line::dy#13 
Alias line::sx#11 = line::sx#22 
Alias line::x#12 = line::x#22 
Alias line::x2#10 = line::x2#6 
Alias line::sx#14 = line::sx#18 
Alias line::dy#16 = line::dy#23 
Alias line::dx#15 = line::dx#25 
Alias line::sy#11 = line::sy#22 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)toD0181_return#0 = toD0181_$6 toD0181_return#2 toD0181_return#1 toD0181_return#3 $0 canvas_show_memory 
Identical Phi Values (byte*) memset::end#1 (byte*) memset::end#0
Identical Phi Values (void*) memset::str#7 (void*) memset::str#5
Identical Phi Values (byte) memset::c#4 (byte) memset::c#6
Identical Phi Values (byte) textcolor::color#1 (byte) textcolor::color#0
Identical Phi Values (byte) toD0181_return#2 (byte) toD0181_return#0
Identical Phi Values (byte) toD0181_return#3 (byte) toD0181_return#1
Identical Phi Values (byte*) main::cols#2 (byte*) main::cols#5
Identical Phi Values (byte*) main::screen#2 (byte*) main::screen#5
Identical Phi Values (byte) main::y#4 (byte) main::y#2
Identical Phi Values (byte*) main::canvas#2 (byte*) main::canvas#10
Identical Phi Values (byte) main::p0_idx#10 (byte) main::p0_idx#1
Identical Phi Values (byte) main::p1_idx#10 (byte) main::p1_idx#1
Identical Phi Values (byte) main::p2_idx#10 (byte) main::p2_idx#1
Identical Phi Values (byte) line::sy#13 (byte) line::sy#0
Identical Phi Values (byte) line::dx#12 (byte) line::dx#0
Identical Phi Values (byte) line::dy#12 (byte) line::dy#0
Identical Phi Values (byte) line::y2#11 (byte) line::y2#13
Identical Phi Values (byte) line::sx#11 (byte) line::sx#0
Identical Phi Values (byte) line::sy#10 (byte) line::sy#0
Identical Phi Values (byte) line::dx#14 (byte) line::dx#0
Identical Phi Values (byte) line::dy#15 (byte) line::dy#0
Identical Phi Values (byte) line::sx#13 (byte) line::sx#0
Identical Phi Values (byte) line::x2#11 (byte) line::x2#15
Identical Phi Values (byte) line::sx#14 (byte) line::sx#0
Identical Phi Values (byte) line::dy#16 (byte) line::dy#0
Identical Phi Values (byte) line::dx#15 (byte) line::dx#0
Identical Phi Values (byte) line::x2#10 (byte) line::x2#15
Identical Phi Values (byte) line::sy#11 (byte) line::sy#0
Identical Phi Values (byte*) eorfill::line_column#0 (byte*) eorfill::line_buffer#0
Identical Phi Values (byte*) eorfill::fill_column#0 (byte*) eorfill::canvas#0
Identical Phi Values (byte*) eorfill::line_column#3 (byte*) eorfill::line_column#2
Identical Phi Values (byte*) eorfill::fill_column#3 (byte*) eorfill::fill_column#2
Identical Phi Values (byte) eorfill::x#3 (byte) eorfill::x#2
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (void*) memset::return#0 (void*) memset::str#5
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) memset::$1 [2] if((word) memset::num#4<=(byte) 0) goto memset::@1
Simple Condition (bool~) memset::$3 [9] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@4
Simple Condition (bool~) main::$7 [66] if((byte) main::y#2<(byte) $10) goto main::@2
Simple Condition (bool~) main::$8 [80] if((byte) main::x#2<(byte) $10) goto main::@5
Simple Condition (bool~) main::$21 [90] if((number) 0!=(number) 1) goto main::@8
Simple Condition (bool~) main::$22 [127] if((byte) 0!=(volatile byte) canvas_show_flag) goto main::@9
Simple Condition (bool~) irq_bottom_2::$1 [189] if((byte) 0==(byte~) irq_bottom_2::$0) goto irq_bottom_2::@1
Simple Condition (bool~) line::$9 [225] if((byte) line::sx#0!=(byte) $ff) goto line::@1
Simple Condition (bool~) line::$10 [228] if((byte) line::dx#0>(byte) line::dy#0) goto line::@2
Simple Condition (bool~) line::$11 [233] if((byte) line::sx#0==(byte) line::sy#0) goto line::@6
Simple Condition (bool~) line::$21 [240] if((byte) line::dx#0!=(byte) 0) goto line::@11
Simple Condition (bool~) line::$14 [246] if((byte) line::e#1<=(byte) line::dy#0) goto line::@8
Simple Condition (bool~) line::$17 [249] if((byte) line::y#10!=(byte) line::y2#13) goto line::@7
Simple Condition (bool~) line::$23 [269] if((byte) line::e1#1<=(byte) line::dy#0) goto line::@12
Simple Condition (bool~) line::$25 [278] if((byte) line::x#19!=(byte) line::x2#15) goto line::@12
Simple Condition (bool~) line::$29 [288] if((byte) line::e2#1<=(byte) line::dx#0) goto line::@15
Simple Condition (bool~) line::$30 [291] if((byte) line::x#12!=(byte) line::x2#15) goto line::@14
Simple Condition (bool~) eorfill::$0 [303] if((byte) eorfill::x#2<(byte) $10) goto eorfill::@2
Simple Condition (bool~) eorfill::$1 [309] if((byte) eorfill::y#2<(byte)(number) $10*(number) 8) goto eorfill::@4
Simple Condition (bool~) abs_u8::$2 [320] if((byte) 0!=(byte~) abs_u8::$0) goto abs_u8::@1
Simple Condition (bool~) sgn_u8::$1 [327] if((byte) 0!=(byte~) sgn_u8::$0) goto sgn_u8::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [48] (word) memset::num#0 ← (unumber)(number) $28*(number) $19
Constant right-side identified [53] (word) memset::num#1 ← (unumber)(number) $28*(number) $19
Constant right-side identified [58] (word) memset::num#2 ← (unumber)(number) $28*(number) $19
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) toD0181_screen#0 = SCREEN
Constant (const byte*) toD0181_gfx#0 = CANVAS2
Constant (const void*) memset::str#0 = (void*)CONSOLE
Constant (const byte) memset::c#0 = ' '
Constant (const word) memset::num#0 = (unumber)$28*$19
Constant (const void*) memset::str#1 = (void*)SCREEN
Constant (const byte) memset::c#1 = 0
Constant (const word) memset::num#1 = (unumber)$28*$19
Constant (const void*) memset::str#2 = (void*)COLS
Constant (const byte) memset::c#2 = BLACK
Constant (const word) memset::num#2 = (unumber)$28*$19
Constant (const byte*) main::screen#0 = SCREEN+$c
Constant (const byte*) main::cols#0 = COLS+$c
Constant (const byte) main::y#0 = 0
Constant (const byte) main::x#0 = 0
Constant (const byte) textcolor::color#0 = WHITE
Constant (const byte) main::p0_idx#0 = $b5
Constant (const byte*) main::canvas#0 = CANVAS1
Constant (const void*) memset::str#3 = (void*)LINE_BUFFER
Constant (const byte) memset::c#3 = 0
Constant (const word) memset::num#3 = $800
Constant (const byte*) line::canvas#0 = LINE_BUFFER
Constant (const byte*) line::canvas#1 = LINE_BUFFER
Constant (const byte*) line::canvas#2 = LINE_BUFFER
Constant (const byte*) eorfill::line_buffer#0 = LINE_BUFFER
Constant (const byte*) main::toD0181_screen#0 = SCREEN
Constant (const byte*) main::toD0181_gfx#0 = CANVAS1
Constant (const byte*) main::toD0182_screen#0 = SCREEN
Constant (const byte*) main::toD0182_gfx#0 = CANVAS2
Constant (const byte*) irq_bottom_1::toD0181_screen#0 = CONSOLE
Constant (const byte*) irq_bottom_1::toD0181_gfx#0 = PETSCII
Constant (const byte*) irq_bottom_2::toD0181_screen#0 = SCREEN
Constant (const byte*) irq_bottom_2::toD0181_gfx#0 = LINE_BUFFER
Constant (const byte) eorfill::x#0 = 0
Constant (const byte) eorfill::y#0 = 1
Constant (const byte) sgn_u8::return#2 = -1
Constant (const byte) sgn_u8::return#3 = 1
Successful SSA optimization Pass2ConstantIdentification
Constant (const word) toD0181_$7 = (word)toD0181_screen#0
Constant (const word) main::toD0181_$7 = (word)main::toD0181_screen#0
Constant (const word) main::toD0182_$7 = (word)main::toD0182_screen#0
Constant (const word) irq_bottom_1::toD0181_$7 = (word)irq_bottom_1::toD0181_screen#0
Constant (const word) irq_bottom_2::toD0181_$7 = (word)irq_bottom_2::toD0181_screen#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)toD0181_gfx#0 in [35] (byte~) toD0181_$3 ← > (word)(const byte*) toD0181_gfx#0
Constant value identified (word)main::toD0181_gfx#0 in [140] (byte~) main::toD0181_$3 ← > (word)(const byte*) main::toD0181_gfx#0
Constant value identified (word)main::toD0182_gfx#0 in [150] (byte~) main::toD0182_$3 ← > (word)(const byte*) main::toD0182_gfx#0
Constant value identified (word)irq_bottom_1::toD0181_gfx#0 in [175] (byte~) irq_bottom_1::toD0181_$3 ← > (word)(const byte*) irq_bottom_1::toD0181_gfx#0
Constant value identified (word)irq_bottom_2::toD0181_gfx#0 in [197] (byte~) irq_bottom_2::toD0181_$3 ← > (word)(const byte*) irq_bottom_2::toD0181_gfx#0
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [90] if((number) 0!=(number) 1) goto main::@8
Successful SSA optimization Pass2ConstantIfs
Simplifying constant evaluating to zero (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES in [15] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
Simplifying constant evaluating to zero (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS in [16] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_STOP|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero LINE_BUFFER in 
Simplifying expression containing zero CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A in [16] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (byte) 0|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Simplifying expression containing zero CIA_TIMER_CONTROL_START in [18] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Simplifying expression containing zero CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_CONTINUOUS in [19] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS|(const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
Simplifying expression containing zero eorfill::line_column#2 in [304] (byte) eorfill::eor#0 ← *((byte*) eorfill::line_column#2 + (byte) 0)
Simplifying expression containing zero eorfill::fill_column#2 in [305] *((byte*) eorfill::fill_column#2 + (byte) 0) ← (byte) eorfill::eor#0
Successful SSA optimization PassNSimplifyExpressionWithZero
Simplifying expression containing zero CIA_TIMER_CONTROL_START in [19] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable (void*) memset::return#2 and assignment [38] (void*) memset::return#2 ← (void*) memset::str#5
Eliminating unused variable (void*) memset::return#3 and assignment [40] (void*) memset::return#3 ← (void*) memset::str#5
Eliminating unused variable (void*) memset::return#4 and assignment [42] (void*) memset::return#4 ← (void*) memset::str#5
Eliminating unused variable (byte) textcolor::return#2 and assignment [49] (byte) textcolor::return#2 ← (byte) textcolor::return#0
Eliminating unused variable (void*) memset::return#5 and assignment [64] (void*) memset::return#5 ← (void*) memset::str#5
Eliminating unused variable (dword) clock::return#2 and assignment [114] (dword) clock::return#2 ← (dword) clock::return#0
Eliminating unused constant (const nomodify byte) CIA_TIMER_CONTROL_STOP
Eliminating unused constant (const nomodify byte) CIA_TIMER_CONTROL_CONTINUOUS
Eliminating unused constant (const nomodify byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
Eliminating unused constant (const byte*) line::canvas#0
Eliminating unused constant (const byte*) line::canvas#1
Eliminating unused constant (const byte*) line::canvas#2
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused variable (dword) clock::return#0 and assignment [10] (dword) clock::return#0 ← (dword) $ffffffff - *((const nomodify dword*) CIA2_TIMER_AB)
Eliminating unused variable (byte) textcolor::return#0 and assignment [19] (byte) textcolor::return#0 ← (byte) conio_textcolor
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused variable (byte) conio_textcolor and assignment [17] (byte) conio_textcolor ← (const nomodify byte) CONIO_TEXTCOLOR_DEFAULT
Eliminating unused variable conio_textcolor(null) and assignment [18] conio_textcolor(null) ← (const byte) textcolor::color#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const nomodify byte) CONIO_TEXTCOLOR_DEFAULT
Eliminating unused constant (const byte) textcolor::color#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const nomodify byte) LIGHT_BLUE
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Alias candidate removed (volatile)toD0181_return#0 = toD0181_$6 toD0181_return#1 $0 canvas_show_memory 
Constant right-side identified [21] (word~) toD0181_$0 ← (const word) toD0181_$7 & (word) $3fff
Constant right-side identified [24] (byte~) toD0181_$3 ← > (word)(const byte*) toD0181_gfx#0
Constant right-side identified [42] (byte) main::p1_idx#0 ← (const byte) main::p0_idx#0 + (byte) $f
Constant right-side identified [43] (byte) main::p2_idx#0 ← (const byte) main::p0_idx#0 + (byte) $aa
Constant right-side identified [87] (word~) main::toD0181_$0 ← (const word) main::toD0181_$7 & (word) $3fff
Constant right-side identified [90] (byte~) main::toD0181_$3 ← > (word)(const byte*) main::toD0181_gfx#0
Constant right-side identified [94] (word~) main::toD0182_$0 ← (const word) main::toD0182_$7 & (word) $3fff
Constant right-side identified [97] (byte~) main::toD0182_$3 ← > (word)(const byte*) main::toD0182_gfx#0
Constant right-side identified [114] (word~) irq_bottom_1::toD0181_$0 ← (const word) irq_bottom_1::toD0181_$7 & (word) $3fff
Constant right-side identified [117] (byte~) irq_bottom_1::toD0181_$3 ← > (word)(const byte*) irq_bottom_1::toD0181_gfx#0
Constant right-side identified [132] (word~) irq_bottom_2::toD0181_$0 ← (const word) irq_bottom_2::toD0181_$7 & (word) $3fff
Constant right-side identified [135] (byte~) irq_bottom_2::toD0181_$3 ← > (word)(const byte*) irq_bottom_2::toD0181_gfx#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) toD0181_$0 = toD0181_$7&$3fff
Constant (const byte) toD0181_$3 = >(word)toD0181_gfx#0
Constant (const byte) main::p1_idx#0 = main::p0_idx#0+$f
Constant (const byte) main::p2_idx#0 = main::p0_idx#0+$aa
Constant (const word) main::toD0181_$0 = main::toD0181_$7&$3fff
Constant (const byte) main::toD0181_$3 = >(word)main::toD0181_gfx#0
Constant (const word) main::toD0182_$0 = main::toD0182_$7&$3fff
Constant (const byte) main::toD0182_$3 = >(word)main::toD0182_gfx#0
Constant (const word) irq_bottom_1::toD0181_$0 = irq_bottom_1::toD0181_$7&$3fff
Constant (const byte) irq_bottom_1::toD0181_$3 = >(word)irq_bottom_1::toD0181_gfx#0
Constant (const word) irq_bottom_2::toD0181_$0 = irq_bottom_2::toD0181_$7&$3fff
Constant (const byte) irq_bottom_2::toD0181_$3 = >(word)irq_bottom_2::toD0181_gfx#0
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)toD0181_return#0 = toD0181_$6 toD0181_return#1 $0 canvas_show_memory 
Constant right-side identified [21] (word~) toD0181_$1 ← (const word) toD0181_$0 * (byte) 4
Constant right-side identified [23] (byte~) toD0181_$4 ← (const byte) toD0181_$3 / (byte) 4
Constant right-side identified [83] (word~) main::toD0181_$1 ← (const word) main::toD0181_$0 * (byte) 4
Constant right-side identified [85] (byte~) main::toD0181_$4 ← (const byte) main::toD0181_$3 / (byte) 4
Constant right-side identified [88] (word~) main::toD0182_$1 ← (const word) main::toD0182_$0 * (byte) 4
Constant right-side identified [90] (byte~) main::toD0182_$4 ← (const byte) main::toD0182_$3 / (byte) 4
Constant right-side identified [106] (word~) irq_bottom_1::toD0181_$1 ← (const word) irq_bottom_1::toD0181_$0 * (byte) 4
Constant right-side identified [108] (byte~) irq_bottom_1::toD0181_$4 ← (const byte) irq_bottom_1::toD0181_$3 / (byte) 4
Constant right-side identified [122] (word~) irq_bottom_2::toD0181_$1 ← (const word) irq_bottom_2::toD0181_$0 * (byte) 4
Constant right-side identified [124] (byte~) irq_bottom_2::toD0181_$4 ← (const byte) irq_bottom_2::toD0181_$3 / (byte) 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) toD0181_$1 = toD0181_$0*4
Constant (const byte) toD0181_$4 = toD0181_$3/4
Constant (const word) main::toD0181_$1 = main::toD0181_$0*4
Constant (const byte) main::toD0181_$4 = main::toD0181_$3/4
Constant (const word) main::toD0182_$1 = main::toD0182_$0*4
Constant (const byte) main::toD0182_$4 = main::toD0182_$3/4
Constant (const word) irq_bottom_1::toD0181_$1 = irq_bottom_1::toD0181_$0*4
Constant (const byte) irq_bottom_1::toD0181_$4 = irq_bottom_1::toD0181_$3/4
Constant (const word) irq_bottom_2::toD0181_$1 = irq_bottom_2::toD0181_$0*4
Constant (const byte) irq_bottom_2::toD0181_$4 = irq_bottom_2::toD0181_$3/4
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)toD0181_return#0 = toD0181_$6 toD0181_return#1 $0 canvas_show_memory 
Constant right-side identified [21] (byte~) toD0181_$2 ← > (const word) toD0181_$1
Constant right-side identified [22] (byte~) toD0181_$5 ← (const byte) toD0181_$4 & (byte) $f
Constant right-side identified [81] (byte~) main::toD0181_$2 ← > (const word) main::toD0181_$1
Constant right-side identified [82] (byte~) main::toD0181_$5 ← (const byte) main::toD0181_$4 & (byte) $f
Constant right-side identified [84] (byte~) main::toD0182_$2 ← > (const word) main::toD0182_$1
Constant right-side identified [85] (byte~) main::toD0182_$5 ← (const byte) main::toD0182_$4 & (byte) $f
Constant right-side identified [100] (byte~) irq_bottom_1::toD0181_$2 ← > (const word) irq_bottom_1::toD0181_$1
Constant right-side identified [101] (byte~) irq_bottom_1::toD0181_$5 ← (const byte) irq_bottom_1::toD0181_$4 & (byte) $f
Constant right-side identified [114] (byte~) irq_bottom_2::toD0181_$2 ← > (const word) irq_bottom_2::toD0181_$1
Constant right-side identified [115] (byte~) irq_bottom_2::toD0181_$5 ← (const byte) irq_bottom_2::toD0181_$4 & (byte) $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) toD0181_$2 = >toD0181_$1
Constant (const byte) toD0181_$5 = toD0181_$4&$f
Constant (const byte) main::toD0181_$2 = >main::toD0181_$1
Constant (const byte) main::toD0181_$5 = main::toD0181_$4&$f
Constant (const byte) main::toD0182_$2 = >main::toD0182_$1
Constant (const byte) main::toD0182_$5 = main::toD0182_$4&$f
Constant (const byte) irq_bottom_1::toD0181_$2 = >irq_bottom_1::toD0181_$1
Constant (const byte) irq_bottom_1::toD0181_$5 = irq_bottom_1::toD0181_$4&$f
Constant (const byte) irq_bottom_2::toD0181_$2 = >irq_bottom_2::toD0181_$1
Constant (const byte) irq_bottom_2::toD0181_$5 = irq_bottom_2::toD0181_$4&$f
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)toD0181_return#0 = toD0181_$6 toD0181_return#1 $0 canvas_show_memory 
Constant right-side identified [21] (byte~) toD0181_$6 ← (const byte) toD0181_$2 | (const byte) toD0181_$5
Constant right-side identified [79] (byte) main::toD0181_return#0 ← (const byte) main::toD0181_$2 | (const byte) main::toD0181_$5
Constant right-side identified [80] (byte) main::toD0182_return#0 ← (const byte) main::toD0182_$2 | (const byte) main::toD0182_$5
Constant right-side identified [94] (byte) irq_bottom_1::toD0181_return#0 ← (const byte) irq_bottom_1::toD0181_$2 | (const byte) irq_bottom_1::toD0181_$5
Constant right-side identified [106] (byte) irq_bottom_2::toD0181_return#0 ← (const byte) irq_bottom_2::toD0181_$2 | (const byte) irq_bottom_2::toD0181_$5
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) toD0181_$6 = toD0181_$2|toD0181_$5
Constant (const byte) main::toD0181_return#0 = main::toD0181_$2|main::toD0181_$5
Constant (const byte) main::toD0182_return#0 = main::toD0182_$2|main::toD0182_$5
Constant (const byte) irq_bottom_1::toD0181_return#0 = irq_bottom_1::toD0181_$2|irq_bottom_1::toD0181_$5
Constant (const byte) irq_bottom_2::toD0181_return#0 = irq_bottom_2::toD0181_$2|irq_bottom_2::toD0181_$5
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) toD0181_return#0 = toD0181_$6
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) toD0181_return#1 = toD0181_return#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) $0 = toD0181_return#1
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [75] (byte~) main::$17 ← (const byte) main::toD0181_return#0 ^ (const byte) main::toD0182_return#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::$17 = main::toD0181_return#0^main::toD0182_return#0
Successful SSA optimization Pass2ConstantIdentification
Inlining Noop Cast [2] (byte*~) memset::$4 ← (byte*)(void*) memset::str#5 keeping memset::str#5
Inlining Noop Cast [4] (byte*) memset::dst#0 ← (byte*)(void*) memset::str#5 keeping memset::str#5
Successful SSA optimization Pass2NopCastInlining
Inlining Noop Cast [74] (byte*) main::canvas#1 ← (byte*)(word~) main::$20 keeping main::canvas#1
Successful SSA optimization Pass2NopCastInlining
Rewriting division to use shift [126] (byte) line::e2#0 ← (byte) line::dx#0 / (byte) 2
Rewriting division to use shift [128] (byte~) line::plot1_$0 ← (byte) line::x#0 / (byte) 8
Rewriting multiplication to use shift [129] (byte~) line::plot1_$2 ← (byte~) line::plot1_$0 * (const byte) SIZEOF_POINTER
Rewriting division to use shift [134] (byte) line::e#0 ← (byte) line::dy#0 / (byte) 2
Rewriting division to use shift [142] (byte~) line::plot2_$0 ← (byte) line::x#15 / (byte) 8
Rewriting multiplication to use shift [143] (byte~) line::plot2_$2 ← (byte~) line::plot2_$0 * (const byte) SIZEOF_POINTER
Rewriting division to use shift [149] (byte~) line::plot3_$0 ← (byte) line::x#17 / (byte) 8
Rewriting multiplication to use shift [150] (byte~) line::plot3_$2 ← (byte~) line::plot3_$0 * (const byte) SIZEOF_POINTER
Rewriting division to use shift [154] (byte) line::e1#0 ← (byte) line::dy#0 / (byte) 2
Rewriting division to use shift [162] (byte~) line::plot4_$0 ← (byte) line::x#19 / (byte) 8
Rewriting multiplication to use shift [163] (byte~) line::plot4_$2 ← (byte~) line::plot4_$0 * (const byte) SIZEOF_POINTER
Rewriting division to use shift [169] (byte~) line::plot5_$0 ← (byte) line::x#10 / (byte) 8
Rewriting multiplication to use shift [170] (byte~) line::plot5_$2 ← (byte~) line::plot5_$0 * (const byte) SIZEOF_POINTER
Rewriting division to use shift [181] (byte~) line::plot6_$0 ← (byte) line::x#12 / (byte) 8
Rewriting multiplication to use shift [182] (byte~) line::plot6_$2 ← (byte~) line::plot6_$0 * (const byte) SIZEOF_POINTER
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const void*) memset::str#0
Inlining constant with var siblings (const byte) memset::c#0
Inlining constant with var siblings (const word) memset::num#0
Inlining constant with var siblings (const void*) memset::str#1
Inlining constant with var siblings (const byte) memset::c#1
Inlining constant with var siblings (const word) memset::num#1
Inlining constant with var siblings (const void*) memset::str#2
Inlining constant with var siblings (const byte) memset::c#2
Inlining constant with var siblings (const word) memset::num#2
Inlining constant with var siblings (const void*) memset::str#3
Inlining constant with var siblings (const byte) memset::c#3
Inlining constant with var siblings (const word) memset::num#3
Inlining constant with var siblings (const byte*) main::screen#0
Inlining constant with var siblings (const byte*) main::cols#0
Inlining constant with var siblings (const byte) main::y#0
Inlining constant with var siblings (const byte) main::x#0
Inlining constant with var siblings (const byte) main::p0_idx#0
Inlining constant with var siblings (const byte*) main::canvas#0
Inlining constant with var siblings (const byte) main::p1_idx#0
Inlining constant with var siblings (const byte) main::p2_idx#0
Inlining constant with var siblings (const byte) eorfill::x#0
Inlining constant with var siblings (const byte) eorfill::y#0
Inlining constant with var siblings (const byte) sgn_u8::return#2
Inlining constant with var siblings (const byte) sgn_u8::return#3
Inlining constant with different constant siblings (const byte) toD0181_return#1
Constant inlined irq_bottom_1::toD0181_$7 = (word)(const nomodify byte*) CONSOLE
Constant inlined irq_bottom_2::toD0181_$7 = (word)(const nomodify byte*) SCREEN
Constant inlined irq_bottom_1::toD0181_screen#0 = (const nomodify byte*) CONSOLE
Constant inlined irq_bottom_1::toD0181_$4 = >(word)(const nomodify byte*) PETSCII/(byte) 4
Constant inlined irq_bottom_1::toD0181_$5 = >(word)(const nomodify byte*) PETSCII/(byte) 4&(byte) $f
Constant inlined toD0181_gfx#0 = (const nomodify byte*) CANVAS2
Constant inlined irq_bottom_2::toD0181_$4 = >(word)(const nomodify byte*) LINE_BUFFER/(byte) 4
Constant inlined memset::num#3 = (word) $800
Constant inlined irq_bottom_2::toD0181_$3 = >(word)(const nomodify byte*) LINE_BUFFER
Constant inlined memset::num#2 = (word)(number) $28*(number) $19
Constant inlined irq_bottom_2::toD0181_gfx#0 = (const nomodify byte*) LINE_BUFFER
Constant inlined irq_bottom_2::toD0181_$5 = >(word)(const nomodify byte*) LINE_BUFFER/(byte) 4&(byte) $f
Constant inlined main::toD0182_$4 = >(word)(const nomodify byte*) CANVAS2/(byte) 4
Constant inlined main::toD0182_$5 = >(word)(const nomodify byte*) CANVAS2/(byte) 4&(byte) $f
Constant inlined memset::num#1 = (word)(number) $28*(number) $19
Constant inlined main::toD0182_$7 = (word)(const nomodify byte*) SCREEN
Constant inlined memset::num#0 = (word)(number) $28*(number) $19
Constant inlined $0 = (const byte) toD0181_return#0
Constant inlined main::toD0182_$0 = (word)(const nomodify byte*) SCREEN&(word) $3fff
Constant inlined main::toD0182_$1 = (word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined main::toD0182_$2 = >(word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined main::toD0182_$3 = >(word)(const nomodify byte*) CANVAS2
Constant inlined main::p2_idx#0 = (byte) $b5+(byte) $aa
Constant inlined main::$17 = (const byte) main::toD0181_return#0^(const byte) main::toD0182_return#0
Constant inlined toD0181_screen#0 = (const nomodify byte*) SCREEN
Constant inlined toD0181_return#1 = (const byte) toD0181_return#0
Constant inlined main::toD0181_$7 = (word)(const nomodify byte*) SCREEN
Constant inlined main::toD0182_gfx#0 = (const nomodify byte*) CANVAS2
Constant inlined main::cols#0 = (const nomodify byte*) COLS+(byte) $c
Constant inlined main::p1_idx#0 = (byte) $b5+(byte) $f
Constant inlined main::toD0181_$2 = >(word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined main::toD0181_$1 = (word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined main::toD0181_$0 = (word)(const nomodify byte*) SCREEN&(word) $3fff
Constant inlined main::y#0 = (byte) 0
Constant inlined main::toD0181_$5 = >(word)(const nomodify byte*) CANVAS1/(byte) 4&(byte) $f
Constant inlined main::toD0181_$4 = >(word)(const nomodify byte*) CANVAS1/(byte) 4
Constant inlined main::toD0181_$3 = >(word)(const nomodify byte*) CANVAS1
Constant inlined irq_bottom_1::toD0181_gfx#0 = (const nomodify byte*) PETSCII
Constant inlined eorfill::x#0 = (byte) 0
Constant inlined memset::c#0 = (byte) ' '
Constant inlined memset::c#1 = (byte) 0
Constant inlined memset::c#2 = (const nomodify byte) BLACK
Constant inlined memset::c#3 = (byte) 0
Constant inlined main::screen#0 = (const nomodify byte*) SCREEN+(byte) $c
Constant inlined main::toD0181_screen#0 = (const nomodify byte*) SCREEN
Constant inlined main::toD0181_gfx#0 = (const nomodify byte*) CANVAS1
Constant inlined sgn_u8::return#3 = (byte) 1
Constant inlined sgn_u8::return#2 = (byte) -1
Constant inlined toD0181_$0 = (word)(const nomodify byte*) SCREEN&(word) $3fff
Constant inlined toD0181_$1 = (word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined toD0181_$2 = >(word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined toD0181_$3 = >(word)(const nomodify byte*) CANVAS2
Constant inlined toD0181_$4 = >(word)(const nomodify byte*) CANVAS2/(byte) 4
Constant inlined toD0181_$5 = >(word)(const nomodify byte*) CANVAS2/(byte) 4&(byte) $f
Constant inlined toD0181_$6 = >(word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4|>(word)(const nomodify byte*) CANVAS2/(byte) 4&(byte) $f
Constant inlined toD0181_$7 = (word)(const nomodify byte*) SCREEN
Constant inlined memset::str#2 = (void*)(const nomodify byte*) COLS
Constant inlined memset::str#1 = (void*)(const nomodify byte*) SCREEN
Constant inlined memset::str#0 = (void*)(const nomodify byte*) CONSOLE
Constant inlined memset::str#3 = (void*)(const nomodify byte*) LINE_BUFFER
Constant inlined main::x#0 = (byte) 0
Constant inlined main::canvas#0 = (const nomodify byte*) CANVAS1
Constant inlined main::toD0182_screen#0 = (const nomodify byte*) SCREEN
Constant inlined eorfill::y#0 = (byte) 1
Constant inlined irq_bottom_2::toD0181_$0 = (word)(const nomodify byte*) SCREEN&(word) $3fff
Constant inlined main::p0_idx#0 = (byte) $b5
Constant inlined irq_bottom_2::toD0181_$2 = >(word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined eorfill::line_buffer#0 = (const nomodify byte*) LINE_BUFFER
Constant inlined irq_bottom_2::toD0181_$1 = (word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4
Constant inlined irq_bottom_1::toD0181_$2 = >(word)(const nomodify byte*) CONSOLE&(word) $3fff*(byte) 4
Constant inlined irq_bottom_1::toD0181_$3 = >(word)(const nomodify byte*) PETSCII
Constant inlined irq_bottom_1::toD0181_$0 = (word)(const nomodify byte*) CONSOLE&(word) $3fff
Constant inlined irq_bottom_2::toD0181_screen#0 = (const nomodify byte*) SCREEN
Constant inlined irq_bottom_1::toD0181_$1 = (word)(const nomodify byte*) CONSOLE&(word) $3fff*(byte) 4
Successful SSA optimization Pass2ConstantInlining
Eliminating unused constant (const byte) SIZEOF_POINTER
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting line::@26(between line::@25 and line::@1)
Added new block during phi lifting line::@27(between line::@8 and line::@7)
Added new block during phi lifting line::@28(between line::@7 and line::@8)
Added new block during phi lifting line::@29(between line::@12 and line::@12)
Added new block during phi lifting line::@30(between line::@20 and line::@12)
Added new block during phi lifting line::@31(between line::@15 and line::@14)
Added new block during phi lifting line::@32(between line::@21 and line::@15)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @2
Adding NOP phi() at start of toD0181
Adding NOP phi() at start of toD0181_@return
Adding NOP phi() at start of @3
Adding NOP phi() at start of @5
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@16
Adding NOP phi() at start of main::@17
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@18
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0181_@return
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::toD0182
Adding NOP phi() at start of main::toD0182_@return
Adding NOP phi() at start of clock
Adding NOP phi() at start of line::@10
Adding NOP phi() at start of line::@6
Adding NOP phi() at start of line::@17
Adding NOP phi() at start of sgn_u8::@2
Adding NOP phi() at start of sgn_u8::@1
Adding NOP phi() at start of memset::@1
Adding NOP phi() at start of textcolor
Adding NOP phi() at start of irq_bottom_2::@3
Adding NOP phi() at start of irq_bottom_2::toD0181
Adding NOP phi() at start of irq_bottom_2::toD0181_@return
Adding NOP phi() at start of irq_bottom_1::toD0181
Adding NOP phi() at start of irq_bottom_1::toD0181_@return
CALL GRAPH
Calls in [] to main:8 
Calls in [main] to memset:12 memset:14 memset:16 setup_irq:22 textcolor:24 clock_start:28 memset:30 line:43 line:54 line:63 eorfill:71 clock:80 
Calls in [line] to abs_u8:125 abs_u8:130 sgn_u8:135 sgn_u8:140 
Calls in [irq_bottom_2] to kbhit:287 

Created 41 initial phi equivalence classes
Coalesced [39] line::x#33 ← line::x1#0
Coalesced [40] line::y#34 ← line::y1#0
Coalesced [41] line::x2#25 ← line::x2#0
Coalesced [42] line::y2#18 ← line::y2#0
Coalesced [50] line::x#34 ← line::x1#1
Coalesced [51] line::y#35 ← line::y1#1
Coalesced [52] line::x2#26 ← line::x2#1
Coalesced [53] line::y2#19 ← line::y2#1
Coalesced [59] line::x#35 ← line::x1#2
Coalesced [60] line::y#36 ← line::y1#2
Coalesced [61] line::x2#27 ← line::x2#2
Coalesced [62] line::y2#20 ← line::y2#2
Coalesced [81] main::p0_idx#19 ← main::p0_idx#1
Coalesced [82] main::p1_idx#19 ← main::p1_idx#1
Coalesced [83] main::p2_idx#19 ← main::p2_idx#1
Not coalescing [85] main::c#4 ← main::y#2
Coalesced [91] main::y#7 ← main::y#1
Coalesced [92] main::cols#7 ← main::cols#1
Coalesced [93] main::screen#7 ← main::screen#1
Coalesced [98] main::x#4 ← main::x#1
Coalesced [99] main::c#5 ← main::c#1
Coalesced [102] eorfill::fill_column#7 ← eorfill::canvas#0
Coalesced [108] eorfill::eor#4 ← eorfill::eor#0
Coalesced [114] eorfill::x#7 ← eorfill::x#1
Coalesced [115] eorfill::line_column#7 ← eorfill::line_column#1
Coalesced [116] eorfill::fill_column#8 ← eorfill::fill_column#1
Coalesced [120] eorfill::y#4 ← eorfill::y#1
Coalesced [121] eorfill::eor#5 ← eorfill::eor#1
Coalesced [124] abs_u8::u#5 ← abs_u8::u#0
Coalesced [129] abs_u8::u#6 ← abs_u8::u#1
Coalesced [134] sgn_u8::u#3 ← sgn_u8::u#0
Coalesced [139] sgn_u8::u#4 ← sgn_u8::u#1
Coalesced [146] line::y#38 ← line::y#1
Coalesced [147] line::y2#22 ← line::y2#3
Coalesced [152] line::y#39 ← line::y#17
Coalesced [153] line::e#8 ← line::e#0
Coalesced [154] line::x#36 ← line::x#0
Coalesced [167] line::e#10 ← line::e#2
Coalesced [168] line::x#38 ← line::x#1
Coalesced [178] line::y#40 ← line::y#10
Coalesced [179] line::e#9 ← line::e#5
Coalesced [180] line::x#37 ← line::x#17
Coalesced [181] line::e#11 ← line::e#1
Coalesced (already) [182] line::x#39 ← line::x#15
Coalesced [191] line::y#41 ← line::y#17
Coalesced [192] line::e1#7 ← line::e1#0
Coalesced [193] line::x#40 ← line::x#0
Coalesced [206] line::y#43 ← line::y#12
Coalesced [207] line::e1#9 ← line::e1#2
Coalesced [208] line::x#42 ← line::x#19
Coalesced (already) [209] line::y#42 ← line::y#12
Coalesced [210] line::e1#8 ← line::e1#1
Coalesced (already) [211] line::x#41 ← line::x#18
Coalesced [213] line::x#44 ← line::x#0
Coalesced [214] line::y#45 ← line::y#17
Coalesced [215] line::e2#9 ← line::e2#0
Coalesced [227] line::y#46 ← line::y#4
Coalesced [228] line::e2#10 ← line::e2#2
Coalesced [237] line::x#43 ← line::x#12
Coalesced [238] line::y#44 ← line::y#15
Coalesced [239] line::e2#8 ← line::e2#7
Coalesced (already) [240] line::y#47 ← line::y#13
Coalesced [241] line::e2#11 ← line::e2#1
Coalesced [242] line::y#37 ← line::y#0
Coalesced [243] line::y2#21 ← line::y2#10
Coalesced [254] abs_u8::return#9 ← abs_u8::u#2
Coalesced [258] abs_u8::return#8 ← abs_u8::return#2
Coalesced [269] memset::dst#5 ← memset::dst#1
Coalesced down to 28 phi equivalence classes
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) toD0181_@return
Culled Empty Block (label) @5
Culled Empty Block (label) main::@15
Culled Empty Block (label) main::@17
Culled Empty Block (label) main::toD0181_@return
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::toD0182_@return
Culled Empty Block (label) line::@10
Culled Empty Block (label) line::@27
Culled Empty Block (label) line::@28
Culled Empty Block (label) line::@6
Culled Empty Block (label) line::@30
Culled Empty Block (label) line::@29
Culled Empty Block (label) line::@17
Culled Empty Block (label) line::@31
Culled Empty Block (label) line::@32
Culled Empty Block (label) line::@26
Culled Empty Block (label) sgn_u8::@2
Culled Empty Block (label) abs_u8::@2
Culled Empty Block (label) memset::@1
Culled Empty Block (label) irq_bottom_2::@3
Culled Empty Block (label) irq_bottom_2::toD0181_@return
Culled Empty Block (label) irq_bottom_1::toD0181_@return
Renumbering block @3 to @1
Renumbering block @4 to @2
Renumbering block memset::@2 to memset::@1
Renumbering block memset::@3 to memset::@2
Renumbering block memset::@4 to memset::@3
Renumbering block main::@12 to main::@11
Renumbering block main::@13 to main::@12
Renumbering block main::@14 to main::@13
Renumbering block main::@16 to main::@14
Renumbering block main::@18 to main::@15
Renumbering block main::@19 to main::@16
Renumbering block main::@20 to main::@17
Renumbering block main::@21 to main::@18
Renumbering block main::@22 to main::@19
Renumbering block main::@23 to main::@20
Renumbering block main::@24 to main::@21
Renumbering block irq_bottom_2::@4 to irq_bottom_2::@3
Renumbering block irq_bottom_2::@5 to irq_bottom_2::@4
Renumbering block line::@7 to line::@6
Renumbering block line::@8 to line::@7
Renumbering block line::@9 to line::@8
Renumbering block line::@11 to line::@9
Renumbering block line::@12 to line::@10
Renumbering block line::@13 to line::@11
Renumbering block line::@14 to line::@12
Renumbering block line::@15 to line::@13
Renumbering block line::@16 to line::@14
Renumbering block line::@18 to line::@15
Renumbering block line::@19 to line::@16
Renumbering block line::@20 to line::@17
Renumbering block line::@21 to line::@18
Renumbering block line::@22 to line::@19
Renumbering block line::@23 to line::@20
Renumbering block line::@24 to line::@21
Renumbering block line::@25 to line::@22
Adding NOP phi() at start of @begin
Adding NOP phi() at start of toD0181
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@12
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0182
Adding NOP phi() at start of clock
Adding NOP phi() at start of eorfill
Adding NOP phi() at start of sgn_u8::@1
Adding NOP phi() at start of textcolor
Adding NOP phi() at start of irq_bottom_2::toD0181
Adding NOP phi() at start of irq_bottom_1::toD0181

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:toD0181
toD0181: scope:[]  from @begin
  [1] phi()
  to:@2
@2: scope:[]  from toD0181
  [2] (volatile byte) canvas_show_memory ← (const byte) toD0181_return#0
  [3] (volatile byte) canvas_show_flag ← (byte) 0
  to:@1
@1: scope:[]  from @2
  [4] phi()
  [5] call main 
  to:@end
@end: scope:[]  from @1
  [6] phi()

(void()) main()
main: scope:[main]  from @1
  [7] phi()
  [8] call memset 
  to:main::@12
main::@12: scope:[main]  from main
  [9] phi()
  [10] call memset 
  to:main::@13
main::@13: scope:[main]  from main::@12
  [11] phi()
  [12] call memset 
  to:main::@1
main::@1: scope:[main]  from main::@13 main::@6
  [13] (byte*) main::screen#5 ← phi( main::@13/(const nomodify byte*) SCREEN+(byte) $c main::@6/(byte*) main::screen#1 )
  [13] (byte*) main::cols#5 ← phi( main::@13/(const nomodify byte*) COLS+(byte) $c main::@6/(byte*) main::cols#1 )
  [13] (byte) main::y#2 ← phi( main::@13/(byte) 0 main::@6/(byte) main::y#1 )
  [14] if((byte) main::y#2<(byte) $10) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [15] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK
  [16] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← (const nomodify byte) BLACK
  [17] call setup_irq 
  to:main::@14
main::@14: scope:[main]  from main::@3
  [18] phi()
  [19] call textcolor 
  to:main::@7
main::@7: scope:[main]  from main::@14 main::@21
  [20] (byte*) main::canvas#10 ← phi( main::@14/(const nomodify byte*) CANVAS1 main::@21/(byte*) main::canvas#19 )
  [20] (byte) main::p2_idx#2 ← phi( main::@14/(byte) $b5+(byte) $aa main::@21/(byte) main::p2_idx#1 )
  [20] (byte) main::p1_idx#2 ← phi( main::@14/(byte) $b5+(byte) $f main::@21/(byte) main::p1_idx#1 )
  [20] (byte) main::p0_idx#2 ← phi( main::@14/(byte) $b5 main::@21/(byte) main::p0_idx#1 )
  to:main::@8
main::@8: scope:[main]  from main::@7
  [21] phi()
  [22] call clock_start 
  to:main::@15
main::@15: scope:[main]  from main::@8
  [23] phi()
  [24] call memset 
  to:main::@16
main::@16: scope:[main]  from main::@15
  [25] (byte) main::x0#0 ← *((const byte*) COSTAB + (byte) main::p0_idx#2)
  [26] (byte) main::y0#0 ← *((const byte*) SINTAB + (byte) main::p0_idx#2)
  [27] (byte) main::x1#0 ← *((const byte*) COSTAB + (byte) main::p1_idx#2)
  [28] (byte) main::y1#0 ← *((const byte*) SINTAB + (byte) main::p1_idx#2)
  [29] (byte) line::x1#0 ← (byte) main::x0#0
  [30] (byte) line::y1#0 ← (byte) main::y0#0
  [31] (byte) line::x2#0 ← (byte) main::x1#0
  [32] (byte) line::y2#0 ← (byte) main::y1#0
  [33] call line 
  to:main::@17
main::@17: scope:[main]  from main::@16
  [34] (byte) main::x2#0 ← *((const byte*) COSTAB + (byte) main::p2_idx#2)
  [35] (byte) main::y2#0 ← *((const byte*) SINTAB + (byte) main::p2_idx#2)
  [36] (byte) line::x1#1 ← (byte) main::x1#0
  [37] (byte) line::y1#1 ← (byte) main::y1#0
  [38] (byte) line::x2#1 ← (byte) main::x2#0
  [39] (byte) line::y2#1 ← (byte) main::y2#0
  [40] call line 
  to:main::@18
main::@18: scope:[main]  from main::@17
  [41] (byte) line::x1#2 ← (byte) main::x2#0
  [42] (byte) line::y1#2 ← (byte) main::y2#0
  [43] (byte) line::x2#2 ← (byte) main::x0#0
  [44] (byte) line::y2#2 ← (byte) main::y0#0
  [45] call line 
  to:main::@19
main::@19: scope:[main]  from main::@18
  [46] (byte) main::p0_idx#1 ← ++ (byte) main::p0_idx#2
  [47] (byte) main::p1_idx#1 ← ++ (byte) main::p1_idx#2
  [48] (byte) main::p2_idx#1 ← ++ (byte) main::p2_idx#2
  [49] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) RED
  to:main::@9
main::@9: scope:[main]  from main::@19 main::@9
  [50] if((byte) 0!=(volatile byte) canvas_show_flag) goto main::@9
  to:main::@10
main::@10: scope:[main]  from main::@9
  [51] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK
  [52] (byte*) eorfill::canvas#0 ← (byte*) main::canvas#10
  [53] call eorfill 
  to:main::@20
main::@20: scope:[main]  from main::@10
  [54] (word) main::canvas#1 ← (byte*) main::canvas#10 ^ (const nomodify byte*) CANVAS1^(const nomodify byte*) CANVAS2
  to:main::toD0181
main::toD0181: scope:[main]  from main::@20
  [55] phi()
  to:main::toD0182
main::toD0182: scope:[main]  from main::toD0181
  [56] phi()
  to:main::@11
main::@11: scope:[main]  from main::toD0182
  [57] (volatile byte) canvas_show_memory ← (volatile byte) canvas_show_memory ^ (const byte) main::toD0181_return#0^(const byte) main::toD0182_return#0
  [58] (volatile byte) canvas_show_flag ← (byte) 1
  [59] call clock 
  to:main::@21
main::@21: scope:[main]  from main::@11
  [60] (byte*) main::canvas#19 ← (byte*)(word) main::canvas#1
  to:main::@7
main::@2: scope:[main]  from main::@1
  [61] (byte) main::c#4 ← (byte) main::y#2
  to:main::@4
main::@4: scope:[main]  from main::@2 main::@5
  [62] (byte) main::c#2 ← phi( main::@2/(byte) main::c#4 main::@5/(byte) main::c#1 )
  [62] (byte) main::x#2 ← phi( main::@2/(byte) 0 main::@5/(byte) main::x#1 )
  [63] if((byte) main::x#2<(byte) $10) goto main::@5
  to:main::@6
main::@6: scope:[main]  from main::@4
  [64] (byte*) main::cols#1 ← (byte*) main::cols#5 + (byte) $28
  [65] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28
  [66] (byte) main::y#1 ← ++ (byte) main::y#2
  to:main::@1
main::@5: scope:[main]  from main::@4
  [67] *((byte*) main::cols#5 + (byte) main::x#2) ← (const nomodify byte) WHITE
  [68] *((byte*) main::screen#5 + (byte) main::x#2) ← (byte) main::c#2
  [69] (byte) main::c#1 ← (byte) main::c#2 + (byte) $10
  [70] (byte) main::x#1 ← ++ (byte) main::x#2
  to:main::@4

(dword()) clock()
clock: scope:[clock]  from main::@11
  [71] phi()
  to:clock::@return
clock::@return: scope:[clock]  from clock
  [72] return 
  to:@return

(void()) eorfill((byte*) eorfill::line_buffer , (byte*) eorfill::canvas)
eorfill: scope:[eorfill]  from main::@10
  [73] phi()
  to:eorfill::@1
eorfill::@1: scope:[eorfill]  from eorfill eorfill::@5
  [74] (byte*) eorfill::fill_column#2 ← phi( eorfill/(byte*) eorfill::canvas#0 eorfill::@5/(byte*) eorfill::fill_column#1 )
  [74] (byte*) eorfill::line_column#2 ← phi( eorfill/(const nomodify byte*) LINE_BUFFER eorfill::@5/(byte*) eorfill::line_column#1 )
  [74] (byte) eorfill::x#2 ← phi( eorfill/(byte) 0 eorfill::@5/(byte) eorfill::x#1 )
  [75] if((byte) eorfill::x#2<(byte) $10) goto eorfill::@2
  to:eorfill::@return
eorfill::@return: scope:[eorfill]  from eorfill::@1
  [76] return 
  to:@return
eorfill::@2: scope:[eorfill]  from eorfill::@1
  [77] (byte) eorfill::eor#0 ← *((byte*) eorfill::line_column#2)
  [78] *((byte*) eorfill::fill_column#2) ← (byte) eorfill::eor#0
  to:eorfill::@3
eorfill::@3: scope:[eorfill]  from eorfill::@2 eorfill::@4
  [79] (byte) eorfill::eor#2 ← phi( eorfill::@2/(byte) eorfill::eor#0 eorfill::@4/(byte) eorfill::eor#1 )
  [79] (byte) eorfill::y#2 ← phi( eorfill::@2/(byte) 1 eorfill::@4/(byte) eorfill::y#1 )
  [80] if((byte) eorfill::y#2<(byte)(number) $10*(number) 8) goto eorfill::@4
  to:eorfill::@5
eorfill::@5: scope:[eorfill]  from eorfill::@3
  [81] (byte*) eorfill::line_column#1 ← (byte*) eorfill::line_column#2 + (byte)(number) $10*(number) 8
  [82] (byte*) eorfill::fill_column#1 ← (byte*) eorfill::fill_column#2 + (byte)(number) $10*(number) 8
  [83] (byte) eorfill::x#1 ← ++ (byte) eorfill::x#2
  to:eorfill::@1
eorfill::@4: scope:[eorfill]  from eorfill::@3
  [84] (byte) eorfill::eor#1 ← (byte) eorfill::eor#2 ^ *((byte*) eorfill::line_column#2 + (byte) eorfill::y#2)
  [85] *((byte*) eorfill::fill_column#2 + (byte) eorfill::y#2) ← (byte) eorfill::eor#1
  [86] (byte) eorfill::y#1 ← ++ (byte) eorfill::y#2
  to:eorfill::@3

(void()) line((byte*) line::canvas , (byte) line::x1 , (byte) line::y1 , (byte) line::x2 , (byte) line::y2)
line: scope:[line]  from main::@16 main::@17 main::@18
  [87] (byte) line::y2#10 ← phi( main::@16/(byte) line::y2#0 main::@17/(byte) line::y2#1 main::@18/(byte) line::y2#2 )
  [87] (byte) line::x2#15 ← phi( main::@16/(byte) line::x2#0 main::@17/(byte) line::x2#1 main::@18/(byte) line::x2#2 )
  [87] (byte) line::y#0 ← phi( main::@16/(byte) line::y1#0 main::@17/(byte) line::y1#1 main::@18/(byte) line::y1#2 )
  [87] (byte) line::x#0 ← phi( main::@16/(byte) line::x1#0 main::@17/(byte) line::x1#1 main::@18/(byte) line::x1#2 )
  [88] (byte) abs_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0
  [89] call abs_u8 
  [90] (byte) abs_u8::return#0 ← (byte) abs_u8::return#4
  to:line::@19
line::@19: scope:[line]  from line
  [91] (byte) line::dx#0 ← (byte) abs_u8::return#0
  [92] (byte) abs_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0
  [93] call abs_u8 
  [94] (byte) abs_u8::return#1 ← (byte) abs_u8::return#4
  to:line::@20
line::@20: scope:[line]  from line::@19
  [95] (byte) line::dy#0 ← (byte) abs_u8::return#1
  [96] (byte) sgn_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0
  [97] call sgn_u8 
  [98] (byte) sgn_u8::return#0 ← (byte) sgn_u8::return#4
  to:line::@21
line::@21: scope:[line]  from line::@20
  [99] (byte) line::sx#0 ← (byte) sgn_u8::return#0
  [100] (byte) sgn_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0
  [101] call sgn_u8 
  [102] (byte) sgn_u8::return#1 ← (byte) sgn_u8::return#4
  to:line::@22
line::@22: scope:[line]  from line::@21
  [103] (byte) line::sy#0 ← (byte) sgn_u8::return#1
  [104] if((byte) line::sx#0!=(byte) $ff) goto line::@1
  to:line::@3
line::@3: scope:[line]  from line::@22
  [105] (byte) line::y#1 ← ++ (byte) line::y#0
  [106] (byte) line::y2#3 ← ++ (byte) line::y2#10
  to:line::@1
line::@1: scope:[line]  from line::@22 line::@3
  [107] (byte) line::y2#13 ← phi( line::@22/(byte) line::y2#10 line::@3/(byte) line::y2#3 )
  [107] (byte) line::y#17 ← phi( line::@22/(byte) line::y#0 line::@3/(byte) line::y#1 )
  [108] if((byte) line::dx#0>(byte) line::dy#0) goto line::@2
  to:line::@4
line::@4: scope:[line]  from line::@1
  [109] if((byte) line::sx#0==(byte) line::sy#0) goto line::plot1
  to:line::@5
line::@5: scope:[line]  from line::@4
  [110] (byte) line::e#0 ← (byte) line::dy#0 >> (byte) 1
  to:line::@6
line::@6: scope:[line]  from line::@5 line::@7
  [111] (byte) line::x#15 ← phi( line::@5/(byte) line::x#0 line::@7/(byte) line::x#17 )
  [111] (byte) line::e#3 ← phi( line::@5/(byte) line::e#0 line::@7/(byte) line::e#5 )
  [111] (byte) line::y#7 ← phi( line::@5/(byte) line::y#17 line::@7/(byte) line::y#10 )
  [112] (byte) line::y#10 ← (byte) line::y#7 + (byte) line::sy#0
  [113] (byte) line::e#1 ← (byte) line::e#3 + (byte) line::dx#0
  [114] if((byte) line::e#1<=(byte) line::dy#0) goto line::@7
  to:line::@8
line::@8: scope:[line]  from line::@6
  [115] (byte) line::plot2_y#0 ← (byte) line::y#10 - (byte) line::sy#0
  to:line::plot2
line::plot2: scope:[line]  from line::@8
  [116] (byte~) line::plot2_$0 ← (byte) line::x#15 >> (byte) 3
  [117] (byte~) line::plot2_$2 ← (byte~) line::plot2_$0 << (byte) 1
  [118] (byte*) line::plot2_column#0 ← *((const byte**) plot_column + (byte~) line::plot2_$2)
  [119] (byte~) line::plot2_$1 ← (byte) line::x#15 & (byte) 7
  [120] *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) ← *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) | *((const byte*) plot_bit + (byte~) line::plot2_$1)
  to:line::@16
line::@16: scope:[line]  from line::plot2
  [121] (byte) line::x#1 ← (byte) line::x#15 + (byte) line::sx#0
  [122] (byte) line::e#2 ← (byte) line::e#1 - (byte) line::dy#0
  to:line::@7
line::@7: scope:[line]  from line::@16 line::@6
  [123] (byte) line::x#17 ← phi( line::@16/(byte) line::x#1 line::@6/(byte) line::x#15 )
  [123] (byte) line::e#5 ← phi( line::@16/(byte) line::e#2 line::@6/(byte) line::e#1 )
  [124] if((byte) line::y#10!=(byte) line::y2#13) goto line::@6
  to:line::plot3
line::plot3: scope:[line]  from line::@7
  [125] (byte~) line::plot3_$0 ← (byte) line::x#17 >> (byte) 3
  [126] (byte~) line::plot3_$2 ← (byte~) line::plot3_$0 << (byte) 1
  [127] (byte*) line::plot3_column#0 ← *((const byte**) plot_column + (byte~) line::plot3_$2)
  [128] (byte~) line::plot3_$1 ← (byte) line::x#17 & (byte) 7
  [129] *((byte*) line::plot3_column#0 + (byte) line::y#10) ← *((byte*) line::plot3_column#0 + (byte) line::y#10) | *((const byte*) plot_bit + (byte~) line::plot3_$1)
  to:line::@return
line::@return: scope:[line]  from line::@15 line::@17 line::plot3 line::plot6
  [130] return 
  to:@return
line::plot1: scope:[line]  from line::@4
  [131] (byte~) line::plot1_$0 ← (byte) line::x#0 >> (byte) 3
  [132] (byte~) line::plot1_$2 ← (byte~) line::plot1_$0 << (byte) 1
  [133] (byte*) line::plot1_column#0 ← *((const byte**) plot_column + (byte~) line::plot1_$2)
  [134] (byte~) line::plot1_$1 ← (byte) line::x#0 & (byte) 7
  [135] *((byte*) line::plot1_column#0 + (byte) line::y#17) ← *((byte*) line::plot1_column#0 + (byte) line::y#17) | *((const byte*) plot_bit + (byte~) line::plot1_$1)
  to:line::@15
line::@15: scope:[line]  from line::plot1
  [136] if((byte) line::dx#0!=(byte) 0) goto line::@9
  to:line::@return
line::@9: scope:[line]  from line::@15
  [137] (byte) line::e1#0 ← (byte) line::dy#0 >> (byte) 1
  to:line::@10
line::@10: scope:[line]  from line::@10 line::@17 line::@9
  [138] (byte) line::x#18 ← phi( line::@9/(byte) line::x#0 line::@10/(byte) line::x#18 line::@17/(byte) line::x#19 )
  [138] (byte) line::e1#3 ← phi( line::@9/(byte) line::e1#0 line::@10/(byte) line::e1#1 line::@17/(byte) line::e1#2 )
  [138] (byte) line::y#11 ← phi( line::@9/(byte) line::y#17 line::@10/(byte) line::y#12 line::@17/(byte) line::y#12 )
  [139] (byte) line::y#12 ← (byte) line::y#11 + (byte) line::sy#0
  [140] (byte) line::e1#1 ← (byte) line::e1#3 + (byte) line::dx#0
  [141] if((byte) line::e1#1<=(byte) line::dy#0) goto line::@10
  to:line::@11
line::@11: scope:[line]  from line::@10
  [142] (byte) line::x#19 ← (byte) line::x#18 + (byte) line::sx#0
  [143] (byte) line::e1#2 ← (byte) line::e1#1 - (byte) line::dy#0
  to:line::plot4
line::plot4: scope:[line]  from line::@11
  [144] (byte~) line::plot4_$0 ← (byte) line::x#19 >> (byte) 3
  [145] (byte~) line::plot4_$2 ← (byte~) line::plot4_$0 << (byte) 1
  [146] (byte*) line::plot4_column#0 ← *((const byte**) plot_column + (byte~) line::plot4_$2)
  [147] (byte~) line::plot4_$1 ← (byte) line::x#19 & (byte) 7
  [148] *((byte*) line::plot4_column#0 + (byte) line::y#12) ← *((byte*) line::plot4_column#0 + (byte) line::y#12) | *((const byte*) plot_bit + (byte~) line::plot4_$1)
  to:line::@17
line::@17: scope:[line]  from line::plot4
  [149] if((byte) line::x#19!=(byte) line::x2#15) goto line::@10
  to:line::@return
line::@2: scope:[line]  from line::@1
  [150] (byte) line::e2#0 ← (byte) line::dx#0 >> (byte) 1
  to:line::@12
line::@12: scope:[line]  from line::@13 line::@2
  [151] (byte) line::e2#3 ← phi( line::@13/(byte) line::e2#7 line::@2/(byte) line::e2#0 )
  [151] (byte) line::y#13 ← phi( line::@13/(byte) line::y#15 line::@2/(byte) line::y#17 )
  [151] (byte) line::x#10 ← phi( line::@13/(byte) line::x#12 line::@2/(byte) line::x#0 )
  to:line::plot5
line::plot5: scope:[line]  from line::@12
  [152] (byte~) line::plot5_$0 ← (byte) line::x#10 >> (byte) 3
  [153] (byte~) line::plot5_$2 ← (byte~) line::plot5_$0 << (byte) 1
  [154] (byte*) line::plot5_column#0 ← *((const byte**) plot_column + (byte~) line::plot5_$2)
  [155] (byte~) line::plot5_$1 ← (byte) line::x#10 & (byte) 7
  [156] *((byte*) line::plot5_column#0 + (byte) line::y#13) ← *((byte*) line::plot5_column#0 + (byte) line::y#13) | *((const byte*) plot_bit + (byte~) line::plot5_$1)
  to:line::@18
line::@18: scope:[line]  from line::plot5
  [157] (byte) line::x#12 ← (byte) line::x#10 + (byte) line::sx#0
  [158] (byte) line::e2#1 ← (byte) line::e2#3 + (byte) line::dy#0
  [159] if((byte) line::e2#1<=(byte) line::dx#0) goto line::@13
  to:line::@14
line::@14: scope:[line]  from line::@18
  [160] (byte) line::y#4 ← (byte) line::y#13 + (byte) line::sy#0
  [161] (byte) line::e2#2 ← (byte) line::e2#1 - (byte) line::dx#0
  to:line::@13
line::@13: scope:[line]  from line::@14 line::@18
  [162] (byte) line::e2#7 ← phi( line::@14/(byte) line::e2#2 line::@18/(byte) line::e2#1 )
  [162] (byte) line::y#15 ← phi( line::@14/(byte) line::y#4 line::@18/(byte) line::y#13 )
  [163] if((byte) line::x#12!=(byte) line::x2#15) goto line::@12
  to:line::plot6
line::plot6: scope:[line]  from line::@13
  [164] (byte~) line::plot6_$0 ← (byte) line::x#12 >> (byte) 3
  [165] (byte~) line::plot6_$2 ← (byte~) line::plot6_$0 << (byte) 1
  [166] (byte*) line::plot6_column#0 ← *((const byte**) plot_column + (byte~) line::plot6_$2)
  [167] (byte~) line::plot6_$1 ← (byte) line::x#12 & (byte) 7
  [168] *((byte*) line::plot6_column#0 + (byte) line::y#15) ← *((byte*) line::plot6_column#0 + (byte) line::y#15) | *((const byte*) plot_bit + (byte~) line::plot6_$1)
  to:line::@return

(byte()) sgn_u8((byte) sgn_u8::u)
sgn_u8: scope:[sgn_u8]  from line::@20 line::@21
  [169] (byte) sgn_u8::u#2 ← phi( line::@20/(byte) sgn_u8::u#0 line::@21/(byte) sgn_u8::u#1 )
  [170] (byte~) sgn_u8::$0 ← (byte) sgn_u8::u#2 & (byte) $80
  [171] if((byte) 0!=(byte~) sgn_u8::$0) goto sgn_u8::@1
  to:sgn_u8::@return
sgn_u8::@1: scope:[sgn_u8]  from sgn_u8
  [172] phi()
  to:sgn_u8::@return
sgn_u8::@return: scope:[sgn_u8]  from sgn_u8 sgn_u8::@1
  [173] (byte) sgn_u8::return#4 ← phi( sgn_u8::@1/(byte) -1 sgn_u8/(byte) 1 )
  [174] return 
  to:@return

(byte()) abs_u8((byte) abs_u8::u)
abs_u8: scope:[abs_u8]  from line line::@19
  [175] (byte) abs_u8::u#2 ← phi( line/(byte) abs_u8::u#0 line::@19/(byte) abs_u8::u#1 )
  [176] (byte~) abs_u8::$0 ← (byte) abs_u8::u#2 & (byte) $80
  [177] if((byte) 0!=(byte~) abs_u8::$0) goto abs_u8::@1
  to:abs_u8::@return
abs_u8::@1: scope:[abs_u8]  from abs_u8
  [178] (byte) abs_u8::return#2 ← - (byte) abs_u8::u#2
  to:abs_u8::@return
abs_u8::@return: scope:[abs_u8]  from abs_u8 abs_u8::@1
  [179] (byte) abs_u8::return#4 ← phi( abs_u8::@1/(byte) abs_u8::return#2 abs_u8/(byte) abs_u8::u#2 )
  [180] return 
  to:@return

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from main main::@12 main::@13 main::@15
  [181] (byte) memset::c#6 ← phi( main/(byte) ' ' main::@12/(byte) 0 main::@13/(const nomodify byte) BLACK main::@15/(byte) 0 )
  [181] (void*) memset::str#5 ← phi( main/(void*)(const nomodify byte*) CONSOLE main::@12/(void*)(const nomodify byte*) SCREEN main::@13/(void*)(const nomodify byte*) COLS main::@15/(void*)(const nomodify byte*) LINE_BUFFER )
  [181] (word) memset::num#4 ← phi( main/(word)(number) $28*(number) $19 main::@12/(word)(number) $28*(number) $19 main::@13/(word)(number) $28*(number) $19 main::@15/(word) $800 )
  [182] if((word) memset::num#4<=(byte) 0) goto memset::@return
  to:memset::@1
memset::@1: scope:[memset]  from memset
  [183] (byte*) memset::end#0 ← (byte*)(void*) memset::str#5 + (word) memset::num#4
  [184] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#5
  to:memset::@2
memset::@2: scope:[memset]  from memset::@1 memset::@3
  [185] (byte*) memset::dst#2 ← phi( memset::@1/(byte*) memset::dst#4 memset::@3/(byte*) memset::dst#1 )
  [186] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3
  to:memset::@return
memset::@return: scope:[memset]  from memset memset::@2
  [187] return 
  to:@return
memset::@3: scope:[memset]  from memset::@2
  [188] *((byte*) memset::dst#2) ← (byte) memset::c#6
  [189] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  to:memset::@2

(void()) clock_start()
clock_start: scope:[clock_start]  from main::@8
  [190] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0
  [191] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  [192] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff
  [193] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  [194] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  [195] return 
  to:@return

(byte()) textcolor((byte) textcolor::color)
textcolor: scope:[textcolor]  from main::@14
  [196] phi()
  to:textcolor::@return
textcolor::@return: scope:[textcolor]  from textcolor
  [197] return 
  to:@return

(void()) setup_irq()
setup_irq: scope:[setup_irq]  from main::@3
  asm { sei  }
  [199] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR
  [200] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f
  [201] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8
  [202] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER
  [203] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1()
  asm { cli  }
  to:setup_irq::@return
setup_irq::@return: scope:[setup_irq]  from setup_irq
  [205] return 
  to:@return

interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2()
irq_bottom_2: scope:[irq_bottom_2]  from
  [206] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK
  [207] call kbhit 
  [208] (byte) kbhit::return#2 ← (byte) kbhit::return#0
  to:irq_bottom_2::@4
irq_bottom_2::@4: scope:[irq_bottom_2]  from irq_bottom_2
  [209] (byte~) irq_bottom_2::$0 ← (byte) kbhit::return#2
  [210] if((byte) 0==(byte~) irq_bottom_2::$0) goto irq_bottom_2::@1
  to:irq_bottom_2::toD0181
irq_bottom_2::toD0181: scope:[irq_bottom_2]  from irq_bottom_2::@4
  [211] phi()
  to:irq_bottom_2::@3
irq_bottom_2::@3: scope:[irq_bottom_2]  from irq_bottom_2::toD0181
  [212] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_2::toD0181_return#0
  to:irq_bottom_2::@2
irq_bottom_2::@2: scope:[irq_bottom_2]  from irq_bottom_2::@1 irq_bottom_2::@3
  [213] (volatile byte) canvas_show_flag ← (byte) 0
  [214] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  [215] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8
  [216] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1()
  to:irq_bottom_2::@return
irq_bottom_2::@return: scope:[irq_bottom_2]  from irq_bottom_2::@2
  [217] return 
  to:@return
irq_bottom_2::@1: scope:[irq_bottom_2]  from irq_bottom_2::@4
  [218] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (volatile byte) canvas_show_memory
  to:irq_bottom_2::@2

(byte()) kbhit()
kbhit: scope:[kbhit]  from irq_bottom_2
  [219] *((const nomodify byte*) kbhit::CIA1_PORT_A) ← (byte) 0
  [220] (byte) kbhit::return#0 ← ~ *((const nomodify byte*) kbhit::CIA1_PORT_B)
  to:kbhit::@return
kbhit::@return: scope:[kbhit]  from kbhit
  [221] return 
  to:@return

interrupt(KERNEL_MIN)(void()) irq_bottom_1()
irq_bottom_1: scope:[irq_bottom_1]  from
  [222] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) DARK_GREY
  to:irq_bottom_1::toD0181
irq_bottom_1::toD0181: scope:[irq_bottom_1]  from irq_bottom_1
  [223] phi()
  to:irq_bottom_1::@1
irq_bottom_1::@1: scope:[irq_bottom_1]  from irq_bottom_1::toD0181
  [224] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_1::toD0181_return#0
  [225] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  [226] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM
  [227] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2()
  to:irq_bottom_1::@return
irq_bottom_1::@return: scope:[irq_bottom_1]  from irq_bottom_1::@1
  [228] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(byte()) abs_u8((byte) abs_u8::u)
(byte~) abs_u8::$0 20002.0
(byte) abs_u8::return
(byte) abs_u8::return#0 2002.0
(byte) abs_u8::return#1 2002.0
(byte) abs_u8::return#2 20002.0
(byte) abs_u8::return#4 5501.0
(byte) abs_u8::u
(byte) abs_u8::u#0 2002.0
(byte) abs_u8::u#1 2002.0
(byte) abs_u8::u#2 10668.333333333332
(volatile byte) canvas_show_flag loadstore 18.74576271186441
(volatile byte) canvas_show_memory loadstore 2.8611111111111107
(dword()) clock()
(dword) clock::return
(void()) clock_start()
(void()) eorfill((byte*) eorfill::line_buffer , (byte*) eorfill::canvas)
(byte*) eorfill::canvas
(byte*) eorfill::canvas#0 551.0
(byte) eorfill::eor
(byte) eorfill::eor#0 150001.5
(byte) eorfill::eor#1 1000001.0
(byte) eorfill::eor#2 1050001.5
(byte*) eorfill::fill_column
(byte*) eorfill::fill_column#1 100001.0
(byte*) eorfill::fill_column#2 130100.5
(byte*) eorfill::line_buffer
(byte*) eorfill::line_column
(byte*) eorfill::line_column#1 66667.33333333333
(byte*) eorfill::line_column#2 144444.88888888888
(byte) eorfill::x
(byte) eorfill::x#1 200002.0
(byte) eorfill::x#2 27273.0
(byte) eorfill::y
(byte) eorfill::y#1 2000002.0
(byte) eorfill::y#2 1250001.25
interrupt(KERNEL_MIN)(void()) irq_bottom_1()
(byte*) irq_bottom_1::toD0181_gfx
(byte) irq_bottom_1::toD0181_return
(byte*) irq_bottom_1::toD0181_screen
interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2()
(byte~) irq_bottom_2::$0 4.0
(byte*) irq_bottom_2::toD0181_gfx
(byte) irq_bottom_2::toD0181_return
(byte*) irq_bottom_2::toD0181_screen
(byte()) kbhit()
(byte) kbhit::return
(byte) kbhit::return#0 4.333333333333333
(byte) kbhit::return#2 4.0
(void()) line((byte*) line::canvas , (byte) line::x1 , (byte) line::y1 , (byte) line::x2 , (byte) line::y2)
(byte*) line::canvas
(byte) line::dx
(byte) line::dx#0 19462.805970149253
(byte) line::dy
(byte) line::dy#0 22285.85714285714
(byte) line::e
(byte) line::e#0 2002.0
(byte) line::e#1 44444.88888888889
(byte) line::e#2 200002.0
(byte) line::e#3 100501.5
(byte) line::e#5 150001.5
(byte) line::e1
(byte) line::e1#0 2002.0
(byte) line::e1#1 1033334.6666666666
(byte) line::e1#2 28571.714285714286
(byte) line::e1#3 1050502.0
(byte) line::e2
(byte) line::e2#0 2002.0
(byte) line::e2#1 133334.66666666666
(byte) line::e2#2 200002.0
(byte) line::e2#3 28714.714285714286
(byte) line::e2#7 150001.5
(byte~) line::plot1_$0 2002.0
(byte~) line::plot1_$1 2002.0
(byte~) line::plot1_$2 2002.0
(byte*) line::plot1_column
(byte*) line::plot1_column#0 1501.5
(byte) line::plot1_x
(byte) line::plot1_y
(byte~) line::plot2_$0 200002.0
(byte~) line::plot2_$1 200002.0
(byte~) line::plot2_$2 200002.0
(byte*) line::plot2_column
(byte*) line::plot2_column#0 150001.5
(byte) line::plot2_x
(byte) line::plot2_y
(byte) line::plot2_y#0 60000.600000000006
(byte~) line::plot3_$0 2002.0
(byte~) line::plot3_$1 2002.0
(byte~) line::plot3_$2 2002.0
(byte*) line::plot3_column
(byte*) line::plot3_column#0 1501.5
(byte) line::plot3_x
(byte) line::plot3_y
(byte~) line::plot4_$0 200002.0
(byte~) line::plot4_$1 200002.0
(byte~) line::plot4_$2 200002.0
(byte*) line::plot4_column
(byte*) line::plot4_column#0 150001.5
(byte) line::plot4_x
(byte) line::plot4_y
(byte~) line::plot5_$0 200002.0
(byte~) line::plot5_$1 200002.0
(byte~) line::plot5_$2 200002.0
(byte*) line::plot5_column
(byte*) line::plot5_column#0 150001.5
(byte) line::plot5_x
(byte) line::plot5_y
(byte~) line::plot6_$0 2002.0
(byte~) line::plot6_$1 2002.0
(byte~) line::plot6_$2 2002.0
(byte*) line::plot6_column
(byte*) line::plot6_column#0 1501.5
(byte) line::plot6_x
(byte) line::plot6_y
(byte) line::sx
(byte) line::sx#0 5135.6949152542375
(byte) line::sy
(byte) line::sy#0 23672.836363636365
(byte) line::x
(byte) line::x#0 228.4375
(byte) line::x#1 100001.0
(byte) line::x#10 66834.16666666666
(byte) line::x#12 30200.5
(byte) line::x#15 50100.6
(byte) line::x#17 60401.0
(byte) line::x#18 550251.25
(byte) line::x#19 62500.625
(byte) line::x1
(byte) line::x1#0 50.5
(byte) line::x1#1 50.5
(byte) line::x1#2 50.5
(byte) line::x2
(byte) line::x2#0 101.0
(byte) line::x2#1 101.0
(byte) line::x2#15 3612.625
(byte) line::x2#2 101.0
(byte) line::y
(byte) line::y#0 239.27777777777777
(byte) line::y#1 1001.0
(byte) line::y#10 23647.411764705877
(byte) line::y#11 2101004.0
(byte) line::y#12 209091.36363636365
(byte) line::y#13 55667.33333333333
(byte) line::y#15 50334.16666666667
(byte) line::y#17 583.9166666666667
(byte) line::y#4 100001.0
(byte) line::y#7 201003.0
(byte) line::y1
(byte) line::y1#0 67.33333333333333
(byte) line::y1#1 67.33333333333333
(byte) line::y1#2 67.33333333333333
(byte) line::y2
(byte) line::y2#0 202.0
(byte) line::y2#1 202.0
(byte) line::y2#10 226.68421052631578
(byte) line::y2#13 5666.833333333334
(byte) line::y2#2 202.0
(byte) line::y2#3 2002.0
(void()) main()
(byte) main::c
(byte) main::c#1 1001.0
(byte) main::c#2 776.0
(byte) main::c#4 202.0
(byte*) main::canvas
(word) main::canvas#1 16.833333333333332
(byte*) main::canvas#10 8.911764705882353
(byte*) main::canvas#19 202.0
(byte*) main::cols
(byte*) main::cols#1 67.33333333333333
(byte*) main::cols#5 133.66666666666669
(byte) main::p0_idx
(byte) main::p0_idx#1 13.466666666666667
(byte) main::p0_idx#2 15.538461538461538
(byte) main::p1_idx
(byte) main::p1_idx#1 14.428571428571429
(byte) main::p1_idx#2 14.962962962962964
(byte) main::p2_idx
(byte) main::p2_idx#1 15.538461538461538
(byte) main::p2_idx#2 14.428571428571429
(byte*) main::screen
(byte*) main::screen#1 101.0
(byte*) main::screen#5 120.3
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(byte*) main::toD0181_screen
(byte*) main::toD0182_gfx
(byte) main::toD0182_return
(byte*) main::toD0182_screen
(byte) main::x
(byte) main::x#1 2002.0
(byte) main::x#2 1001.0
(byte) main::x0
(byte) main::x0#0 16.833333333333332
(byte) main::x1
(byte) main::x1#0 33.666666666666664
(byte) main::x2
(byte) main::x2#0 43.285714285714285
(byte) main::y
(byte) main::y#1 202.0
(byte) main::y#2 36.72727272727273
(byte) main::y0
(byte) main::y0#0 16.833333333333332
(byte) main::y1
(byte) main::y1#0 33.666666666666664
(byte) main::y2
(byte) main::y2#0 43.285714285714285
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(byte) memset::c
(byte) memset::c#6 12500.125
(byte*) memset::dst
(byte*) memset::dst#1 200002.0
(byte*) memset::dst#2 133668.3333333333
(byte*) memset::dst#4 2002.0
(byte*) memset::end
(byte*) memset::end#0 16833.666666666664
(word) memset::num
(word) memset::num#4 1001.0
(void*) memset::return
(void*) memset::str
(void*) memset::str#5
(byte) printf_buffer_number::sign
(byte) printf_format_number::justify_left
(byte) printf_format_number::min_length
(byte) printf_format_number::radix
(byte) printf_format_number::sign_always
(byte) printf_format_number::upper_case
(byte) printf_format_number::zero_padding
(byte) printf_format_string::justify_left
(byte) printf_format_string::min_length
(void()) setup_irq()
(byte()) sgn_u8((byte) sgn_u8::u)
(byte~) sgn_u8::$0 20002.0
(byte) sgn_u8::return
(byte) sgn_u8::return#0 2002.0
(byte) sgn_u8::return#1 2002.0
(byte) sgn_u8::return#4 500.5
(byte) sgn_u8::u
(byte) sgn_u8::u#0 2002.0
(byte) sgn_u8::u#1 2002.0
(byte) sgn_u8::u#2 12003.0
(byte()) textcolor((byte) textcolor::color)
(byte) textcolor::color
(byte) textcolor::old
(byte) textcolor::return
(byte*) toD0181_gfx
(byte) toD0181_return
(byte*) toD0181_screen

Initial phi equivalence classes
[ main::y#2 main::y#1 ]
[ main::cols#5 main::cols#1 ]
[ main::screen#5 main::screen#1 ]
[ main::p0_idx#2 main::p0_idx#1 ]
[ main::p1_idx#2 main::p1_idx#1 ]
[ main::p2_idx#2 main::p2_idx#1 ]
[ main::canvas#10 main::canvas#19 ]
[ main::x#2 main::x#1 ]
[ main::c#2 main::c#4 main::c#1 ]
[ eorfill::x#2 eorfill::x#1 ]
[ eorfill::line_column#2 eorfill::line_column#1 ]
[ eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ]
[ eorfill::y#2 eorfill::y#1 ]
[ eorfill::eor#2 eorfill::eor#0 eorfill::eor#1 ]
[ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ]
[ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ]
[ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ]
[ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ]
[ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ]
[ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ]
[ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ]
[ sgn_u8::u#2 sgn_u8::u#0 sgn_u8::u#1 ]
[ sgn_u8::return#4 ]
[ abs_u8::return#4 abs_u8::return#2 abs_u8::u#2 abs_u8::u#0 abs_u8::u#1 ]
[ memset::num#4 ]
[ memset::str#5 ]
[ memset::c#6 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
Added variable canvas_show_memory to live range equivalence class [ canvas_show_memory ]
Added variable canvas_show_flag to live range equivalence class [ canvas_show_flag ]
Added variable main::x0#0 to live range equivalence class [ main::x0#0 ]
Added variable main::y0#0 to live range equivalence class [ main::y0#0 ]
Added variable main::x1#0 to live range equivalence class [ main::x1#0 ]
Added variable main::y1#0 to live range equivalence class [ main::y1#0 ]
Added variable main::x2#0 to live range equivalence class [ main::x2#0 ]
Added variable main::y2#0 to live range equivalence class [ main::y2#0 ]
Added variable main::canvas#1 to live range equivalence class [ main::canvas#1 ]
Added variable abs_u8::return#0 to live range equivalence class [ abs_u8::return#0 ]
Added variable line::dx#0 to live range equivalence class [ line::dx#0 ]
Added variable abs_u8::return#1 to live range equivalence class [ abs_u8::return#1 ]
Added variable line::dy#0 to live range equivalence class [ line::dy#0 ]
Added variable sgn_u8::return#0 to live range equivalence class [ sgn_u8::return#0 ]
Added variable line::sx#0 to live range equivalence class [ line::sx#0 ]
Added variable sgn_u8::return#1 to live range equivalence class [ sgn_u8::return#1 ]
Added variable line::sy#0 to live range equivalence class [ line::sy#0 ]
Added variable line::plot2_y#0 to live range equivalence class [ line::plot2_y#0 ]
Added variable line::plot2_$0 to live range equivalence class [ line::plot2_$0 ]
Added variable line::plot2_$2 to live range equivalence class [ line::plot2_$2 ]
Added variable line::plot2_column#0 to live range equivalence class [ line::plot2_column#0 ]
Added variable line::plot2_$1 to live range equivalence class [ line::plot2_$1 ]
Added variable line::plot3_$0 to live range equivalence class [ line::plot3_$0 ]
Added variable line::plot3_$2 to live range equivalence class [ line::plot3_$2 ]
Added variable line::plot3_column#0 to live range equivalence class [ line::plot3_column#0 ]
Added variable line::plot3_$1 to live range equivalence class [ line::plot3_$1 ]
Added variable line::plot1_$0 to live range equivalence class [ line::plot1_$0 ]
Added variable line::plot1_$2 to live range equivalence class [ line::plot1_$2 ]
Added variable line::plot1_column#0 to live range equivalence class [ line::plot1_column#0 ]
Added variable line::plot1_$1 to live range equivalence class [ line::plot1_$1 ]
Added variable line::plot4_$0 to live range equivalence class [ line::plot4_$0 ]
Added variable line::plot4_$2 to live range equivalence class [ line::plot4_$2 ]
Added variable line::plot4_column#0 to live range equivalence class [ line::plot4_column#0 ]
Added variable line::plot4_$1 to live range equivalence class [ line::plot4_$1 ]
Added variable line::plot5_$0 to live range equivalence class [ line::plot5_$0 ]
Added variable line::plot5_$2 to live range equivalence class [ line::plot5_$2 ]
Added variable line::plot5_column#0 to live range equivalence class [ line::plot5_column#0 ]
Added variable line::plot5_$1 to live range equivalence class [ line::plot5_$1 ]
Added variable line::plot6_$0 to live range equivalence class [ line::plot6_$0 ]
Added variable line::plot6_$2 to live range equivalence class [ line::plot6_$2 ]
Added variable line::plot6_column#0 to live range equivalence class [ line::plot6_column#0 ]
Added variable line::plot6_$1 to live range equivalence class [ line::plot6_$1 ]
Added variable sgn_u8::$0 to live range equivalence class [ sgn_u8::$0 ]
Added variable abs_u8::$0 to live range equivalence class [ abs_u8::$0 ]
Added variable memset::end#0 to live range equivalence class [ memset::end#0 ]
Added variable kbhit::return#2 to live range equivalence class [ kbhit::return#2 ]
Added variable irq_bottom_2::$0 to live range equivalence class [ irq_bottom_2::$0 ]
Added variable kbhit::return#0 to live range equivalence class [ kbhit::return#0 ]
Complete equivalence classes
[ main::y#2 main::y#1 ]
[ main::cols#5 main::cols#1 ]
[ main::screen#5 main::screen#1 ]
[ main::p0_idx#2 main::p0_idx#1 ]
[ main::p1_idx#2 main::p1_idx#1 ]
[ main::p2_idx#2 main::p2_idx#1 ]
[ main::canvas#10 main::canvas#19 ]
[ main::x#2 main::x#1 ]
[ main::c#2 main::c#4 main::c#1 ]
[ eorfill::x#2 eorfill::x#1 ]
[ eorfill::line_column#2 eorfill::line_column#1 ]
[ eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ]
[ eorfill::y#2 eorfill::y#1 ]
[ eorfill::eor#2 eorfill::eor#0 eorfill::eor#1 ]
[ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ]
[ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ]
[ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ]
[ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ]
[ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ]
[ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ]
[ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ]
[ sgn_u8::u#2 sgn_u8::u#0 sgn_u8::u#1 ]
[ sgn_u8::return#4 ]
[ abs_u8::return#4 abs_u8::return#2 abs_u8::u#2 abs_u8::u#0 abs_u8::u#1 ]
[ memset::num#4 ]
[ memset::str#5 ]
[ memset::c#6 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
[ canvas_show_memory ]
[ canvas_show_flag ]
[ main::x0#0 ]
[ main::y0#0 ]
[ main::x1#0 ]
[ main::y1#0 ]
[ main::x2#0 ]
[ main::y2#0 ]
[ main::canvas#1 ]
[ abs_u8::return#0 ]
[ line::dx#0 ]
[ abs_u8::return#1 ]
[ line::dy#0 ]
[ sgn_u8::return#0 ]
[ line::sx#0 ]
[ sgn_u8::return#1 ]
[ line::sy#0 ]
[ line::plot2_y#0 ]
[ line::plot2_$0 ]
[ line::plot2_$2 ]
[ line::plot2_column#0 ]
[ line::plot2_$1 ]
[ line::plot3_$0 ]
[ line::plot3_$2 ]
[ line::plot3_column#0 ]
[ line::plot3_$1 ]
[ line::plot1_$0 ]
[ line::plot1_$2 ]
[ line::plot1_column#0 ]
[ line::plot1_$1 ]
[ line::plot4_$0 ]
[ line::plot4_$2 ]
[ line::plot4_column#0 ]
[ line::plot4_$1 ]
[ line::plot5_$0 ]
[ line::plot5_$2 ]
[ line::plot5_column#0 ]
[ line::plot5_$1 ]
[ line::plot6_$0 ]
[ line::plot6_$2 ]
[ line::plot6_column#0 ]
[ line::plot6_$1 ]
[ sgn_u8::$0 ]
[ abs_u8::$0 ]
[ memset::end#0 ]
[ kbhit::return#2 ]
[ irq_bottom_2::$0 ]
[ kbhit::return#0 ]
Allocated zp[1]:2 [ main::y#2 main::y#1 ]
Allocated zp[2]:3 [ main::cols#5 main::cols#1 ]
Allocated zp[2]:5 [ main::screen#5 main::screen#1 ]
Allocated zp[1]:7 [ main::p0_idx#2 main::p0_idx#1 ]
Allocated zp[1]:8 [ main::p1_idx#2 main::p1_idx#1 ]
Allocated zp[1]:9 [ main::p2_idx#2 main::p2_idx#1 ]
Allocated zp[2]:10 [ main::canvas#10 main::canvas#19 ]
Allocated zp[1]:12 [ main::x#2 main::x#1 ]
Allocated zp[1]:13 [ main::c#2 main::c#4 main::c#1 ]
Allocated zp[1]:14 [ eorfill::x#2 eorfill::x#1 ]
Allocated zp[2]:15 [ eorfill::line_column#2 eorfill::line_column#1 ]
Allocated zp[2]:17 [ eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ]
Allocated zp[1]:19 [ eorfill::y#2 eorfill::y#1 ]
Allocated zp[1]:20 [ eorfill::eor#2 eorfill::eor#0 eorfill::eor#1 ]
Allocated zp[1]:21 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ]
Allocated zp[1]:22 [ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ]
Allocated zp[1]:23 [ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ]
Allocated zp[1]:24 [ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ]
Allocated zp[1]:25 [ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ]
Allocated zp[1]:26 [ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ]
Allocated zp[1]:27 [ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ]
Allocated zp[1]:28 [ sgn_u8::u#2 sgn_u8::u#0 sgn_u8::u#1 ]
Allocated zp[1]:29 [ sgn_u8::return#4 ]
Allocated zp[1]:30 [ abs_u8::return#4 abs_u8::return#2 abs_u8::u#2 abs_u8::u#0 abs_u8::u#1 ]
Allocated zp[2]:31 [ memset::num#4 ]
Allocated zp[2]:33 [ memset::str#5 ]
Allocated zp[1]:35 [ memset::c#6 ]
Allocated zp[2]:36 [ memset::dst#2 memset::dst#4 memset::dst#1 ]
Allocated zp[1]:38 [ canvas_show_memory ]
Allocated zp[1]:39 [ canvas_show_flag ]
Allocated zp[1]:40 [ main::x0#0 ]
Allocated zp[1]:41 [ main::y0#0 ]
Allocated zp[1]:42 [ main::x1#0 ]
Allocated zp[1]:43 [ main::y1#0 ]
Allocated zp[1]:44 [ main::x2#0 ]
Allocated zp[1]:45 [ main::y2#0 ]
Allocated zp[2]:46 [ main::canvas#1 ]
Allocated zp[1]:48 [ abs_u8::return#0 ]
Allocated zp[1]:49 [ line::dx#0 ]
Allocated zp[1]:50 [ abs_u8::return#1 ]
Allocated zp[1]:51 [ line::dy#0 ]
Allocated zp[1]:52 [ sgn_u8::return#0 ]
Allocated zp[1]:53 [ line::sx#0 ]
Allocated zp[1]:54 [ sgn_u8::return#1 ]
Allocated zp[1]:55 [ line::sy#0 ]
Allocated zp[1]:56 [ line::plot2_y#0 ]
Allocated zp[1]:57 [ line::plot2_$0 ]
Allocated zp[1]:58 [ line::plot2_$2 ]
Allocated zp[2]:59 [ line::plot2_column#0 ]
Allocated zp[1]:61 [ line::plot2_$1 ]
Allocated zp[1]:62 [ line::plot3_$0 ]
Allocated zp[1]:63 [ line::plot3_$2 ]
Allocated zp[2]:64 [ line::plot3_column#0 ]
Allocated zp[1]:66 [ line::plot3_$1 ]
Allocated zp[1]:67 [ line::plot1_$0 ]
Allocated zp[1]:68 [ line::plot1_$2 ]
Allocated zp[2]:69 [ line::plot1_column#0 ]
Allocated zp[1]:71 [ line::plot1_$1 ]
Allocated zp[1]:72 [ line::plot4_$0 ]
Allocated zp[1]:73 [ line::plot4_$2 ]
Allocated zp[2]:74 [ line::plot4_column#0 ]
Allocated zp[1]:76 [ line::plot4_$1 ]
Allocated zp[1]:77 [ line::plot5_$0 ]
Allocated zp[1]:78 [ line::plot5_$2 ]
Allocated zp[2]:79 [ line::plot5_column#0 ]
Allocated zp[1]:81 [ line::plot5_$1 ]
Allocated zp[1]:82 [ line::plot6_$0 ]
Allocated zp[1]:83 [ line::plot6_$2 ]
Allocated zp[2]:84 [ line::plot6_column#0 ]
Allocated zp[1]:86 [ line::plot6_$1 ]
Allocated zp[1]:87 [ sgn_u8::$0 ]
Allocated zp[1]:88 [ abs_u8::$0 ]
Allocated zp[2]:89 [ memset::end#0 ]
Allocated zp[1]:91 [ kbhit::return#2 ]
Allocated zp[1]:92 [ irq_bottom_2::$0 ]
Allocated zp[1]:93 [ kbhit::return#0 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Filling a simple 16x16 2D polygon using EOR-filling
// - Clearing canvas
// - Trivial 2D rotation using sine tables
// - Line-drawing polygon edges (fill-ready lines)
// - Up-to-down EOR filling 
// - Double buffering
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  .const BORDER_YPOS_BOTTOM = $fa
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const DARK_GREY = $b
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
  .const OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
  .const OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = $21
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MOS6569_VICII_MEMORY = $18
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const toD0181_return = (>(SCREEN&$3fff)*4)|(>CANVAS2)/4&$f
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // Color Ram
  .label COLS = $d800
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#2 timer A&B as one single 32-bit value
  .label CIA2_TIMER_AB = $dd04
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  // The line buffer
  .label LINE_BUFFER = $2000
  // The two charsets used as screen buffers
  .label CANVAS1 = $3000
  .label CANVAS2 = $3800
  // The screen matrix
  .label SCREEN = $2c00
  // The screen console
  .label CONSOLE = $400
  // The default charset address
  .label PETSCII = $1000
  .label COSTAB = SINTAB+$40
  .label canvas_show_memory = $26
  .label canvas_show_flag = $27
  // @begin
__bbegin:
  // [1] phi from @begin to toD0181 [phi:@begin->toD0181]
toD0181_from___bbegin:
  jmp toD0181
  // toD0181
toD0181:
  jmp __b2
  // @2
__b2:
  // [2] (volatile byte) canvas_show_memory ← (const byte) toD0181_return#0 -- vbuz1=vbuc1 
  // The current canvas being rendered to the screen - in D018 format.
  lda #toD0181_return
  sta.z canvas_show_memory
  // [3] (volatile byte) canvas_show_flag ← (byte) 0 -- vbuz1=vbuc1 
  // Flag signalling that the canvas on screen needs to be updated.
  // Set to 1 by the renderer when a new canvas is ready for showing, and to 0 by the raster when the canvas is shown on screen.
  lda #0
  sta.z canvas_show_flag
  // [4] phi from @2 to @1 [phi:@2->@1]
__b1_from___b2:
  jmp __b1
  // @1
__b1:
  // [5] call main 
  // [7] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [6] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>CANVAS1)/4&$f
    .const toD0182_return = (>(SCREEN&$3fff)*4)|(>CANVAS2)/4&$f
    .label c = $d
    .label x = $c
    .label cols = 3
    // Setup 16x16 canvas for rendering
    .label screen = 5
    .label y = 2
    .label x0 = $28
    .label y0 = $29
    .label x1 = $2a
    .label y1 = $2b
    .label x2 = $2c
    .label y2 = $2d
    .label p0_idx = 7
    .label p1_idx = 8
    .label p2_idx = 9
    // The current canvas being rendered to
    .label canvas = $2e
    // The current canvas being rendered to
    .label canvas_1 = $a
    // [8] call memset 
  // Clear the console
    // [181] phi from main to memset [phi:main->memset]
  memset_from_main:
    // [181] phi (byte) memset::c#6 = (byte) ' ' [phi:main->memset#0] -- vbuz1=vbuc1 
    lda #' '
    sta.z memset.c
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) CONSOLE [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<CONSOLE
    sta.z memset.str
    lda #>CONSOLE
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word)(number) $28*(number) $19 [phi:main->memset#2] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta.z memset.num
    lda #>$28*$19
    sta.z memset.num+1
    jsr memset
    // [9] phi from main to main::@12 [phi:main->main::@12]
  __b12_from_main:
    jmp __b12
    // main::@12
  __b12:
    // [10] call memset 
  // Clear the screen
    // [181] phi from main::@12 to memset [phi:main::@12->memset]
  memset_from___b12:
    // [181] phi (byte) memset::c#6 = (byte) 0 [phi:main::@12->memset#0] -- vbuz1=vbuc1 
    lda #0
    sta.z memset.c
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) SCREEN [phi:main::@12->memset#1] -- pvoz1=pvoc1 
    lda #<SCREEN
    sta.z memset.str
    lda #>SCREEN
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word)(number) $28*(number) $19 [phi:main::@12->memset#2] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta.z memset.num
    lda #>$28*$19
    sta.z memset.num+1
    jsr memset
    // [11] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
  __b13_from___b12:
    jmp __b13
    // main::@13
  __b13:
    // [12] call memset 
    // [181] phi from main::@13 to memset [phi:main::@13->memset]
  memset_from___b13:
    // [181] phi (byte) memset::c#6 = (const nomodify byte) BLACK [phi:main::@13->memset#0] -- vbuz1=vbuc1 
    lda #BLACK
    sta.z memset.c
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) COLS [phi:main::@13->memset#1] -- pvoz1=pvoc1 
    lda #<COLS
    sta.z memset.str
    lda #>COLS
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word)(number) $28*(number) $19 [phi:main::@13->memset#2] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta.z memset.num
    lda #>$28*$19
    sta.z memset.num+1
    jsr memset
    // [13] phi from main::@13 to main::@1 [phi:main::@13->main::@1]
  __b1_from___b13:
    // [13] phi (byte*) main::screen#5 = (const nomodify byte*) SCREEN+(byte) $c [phi:main::@13->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$c
    sta.z screen
    lda #>SCREEN+$c
    sta.z screen+1
    // [13] phi (byte*) main::cols#5 = (const nomodify byte*) COLS+(byte) $c [phi:main::@13->main::@1#1] -- pbuz1=pbuc1 
    lda #<COLS+$c
    sta.z cols
    lda #>COLS+$c
    sta.z cols+1
    // [13] phi (byte) main::y#2 = (byte) 0 [phi:main::@13->main::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp __b1
    // main::@1
  __b1:
    // [14] if((byte) main::y#2<(byte) $10) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z y
    cmp #$10
    bcc __b2
    jmp __b3
    // main::@3
  __b3:
    // [15] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [16] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BG_COLOR
    // [17] call setup_irq 
    // Set-up the raster IRQ
    jsr setup_irq
    // [18] phi from main::@3 to main::@14 [phi:main::@3->main::@14]
  __b14_from___b3:
    jmp __b14
    // main::@14
  __b14:
    // [19] call textcolor 
  // Set text color
    // [196] phi from main::@14 to textcolor [phi:main::@14->textcolor]
  textcolor_from___b14:
    jsr textcolor
    // [20] phi from main::@14 to main::@7 [phi:main::@14->main::@7]
  __b7_from___b14:
    // [20] phi (byte*) main::canvas#10 = (const nomodify byte*) CANVAS1 [phi:main::@14->main::@7#0] -- pbuz1=pbuc1 
    lda #<CANVAS1
    sta.z canvas_1
    lda #>CANVAS1
    sta.z canvas_1+1
    // [20] phi (byte) main::p2_idx#2 = (byte) $b5+(byte) $aa [phi:main::@14->main::@7#1] -- vbuz1=vbuc1 
    lda #$b5+$aa
    sta.z p2_idx
    // [20] phi (byte) main::p1_idx#2 = (byte) $b5+(byte) $f [phi:main::@14->main::@7#2] -- vbuz1=vbuc1 
    lda #$b5+$f
    sta.z p1_idx
    // [20] phi (byte) main::p0_idx#2 = (byte) $b5 [phi:main::@14->main::@7#3] -- vbuz1=vbuc1 
    lda #$b5
    sta.z p0_idx
    jmp __b7
    // main::@7
  __b7:
    // [21] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  __b8_from___b7:
    jmp __b8
    // main::@8
  __b8:
    // [22] call clock_start 
    jsr clock_start
    // [23] phi from main::@8 to main::@15 [phi:main::@8->main::@15]
  __b15_from___b8:
    jmp __b15
    // main::@15
  __b15:
    // [24] call memset 
  // Clear line buffer
    // [181] phi from main::@15 to memset [phi:main::@15->memset]
  memset_from___b15:
    // [181] phi (byte) memset::c#6 = (byte) 0 [phi:main::@15->memset#0] -- vbuz1=vbuc1 
    lda #0
    sta.z memset.c
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) LINE_BUFFER [phi:main::@15->memset#1] -- pvoz1=pvoc1 
    lda #<LINE_BUFFER
    sta.z memset.str
    lda #>LINE_BUFFER
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word) $800 [phi:main::@15->memset#2] -- vwuz1=vwuc1 
    lda #<$800
    sta.z memset.num
    lda #>$800
    sta.z memset.num+1
    jsr memset
    jmp __b16
    // main::@16
  __b16:
    // [25] (byte) main::x0#0 ← *((const byte*) COSTAB + (byte) main::p0_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    // Plot in line buffer
    ldy.z p0_idx
    lda COSTAB,y
    sta.z x0
    // [26] (byte) main::y0#0 ← *((const byte*) SINTAB + (byte) main::p0_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p0_idx
    lda SINTAB,y
    sta.z y0
    // [27] (byte) main::x1#0 ← *((const byte*) COSTAB + (byte) main::p1_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p1_idx
    lda COSTAB,y
    sta.z x1
    // [28] (byte) main::y1#0 ← *((const byte*) SINTAB + (byte) main::p1_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p1_idx
    lda SINTAB,y
    sta.z y1
    // [29] (byte) line::x1#0 ← (byte) main::x0#0 -- vbuz1=vbuz2 
    lda.z x0
    sta.z line.x1
    // [30] (byte) line::y1#0 ← (byte) main::y0#0 -- vbuz1=vbuz2 
    lda.z y0
    sta.z line.y1
    // [31] (byte) line::x2#0 ← (byte) main::x1#0 -- vbuz1=vbuz2 
    lda.z x1
    sta.z line.x2
    // [32] (byte) line::y2#0 ← (byte) main::y1#0 -- vbuz1=vbuz2 
    lda.z y1
    sta.z line.y2
    // [33] call line 
    // [87] phi from main::@16 to line [phi:main::@16->line]
  line_from___b16:
    // [87] phi (byte) line::y2#10 = (byte) line::y2#0 [phi:main::@16->line#0] -- register_copy 
    // [87] phi (byte) line::x2#15 = (byte) line::x2#0 [phi:main::@16->line#1] -- register_copy 
    // [87] phi (byte) line::y#0 = (byte) line::y1#0 [phi:main::@16->line#2] -- register_copy 
    // [87] phi (byte) line::x#0 = (byte) line::x1#0 [phi:main::@16->line#3] -- register_copy 
    jsr line
    jmp __b17
    // main::@17
  __b17:
    // [34] (byte) main::x2#0 ← *((const byte*) COSTAB + (byte) main::p2_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p2_idx
    lda COSTAB,y
    sta.z x2
    // [35] (byte) main::y2#0 ← *((const byte*) SINTAB + (byte) main::p2_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p2_idx
    lda SINTAB,y
    sta.z y2
    // [36] (byte) line::x1#1 ← (byte) main::x1#0 -- vbuz1=vbuz2 
    lda.z x1
    sta.z line.x1
    // [37] (byte) line::y1#1 ← (byte) main::y1#0 -- vbuz1=vbuz2 
    lda.z y1
    sta.z line.y1
    // [38] (byte) line::x2#1 ← (byte) main::x2#0 -- vbuz1=vbuz2 
    lda.z x2
    sta.z line.x2
    // [39] (byte) line::y2#1 ← (byte) main::y2#0 -- vbuz1=vbuz2 
    lda.z y2
    sta.z line.y2
    // [40] call line 
    // [87] phi from main::@17 to line [phi:main::@17->line]
  line_from___b17:
    // [87] phi (byte) line::y2#10 = (byte) line::y2#1 [phi:main::@17->line#0] -- register_copy 
    // [87] phi (byte) line::x2#15 = (byte) line::x2#1 [phi:main::@17->line#1] -- register_copy 
    // [87] phi (byte) line::y#0 = (byte) line::y1#1 [phi:main::@17->line#2] -- register_copy 
    // [87] phi (byte) line::x#0 = (byte) line::x1#1 [phi:main::@17->line#3] -- register_copy 
    jsr line
    jmp __b18
    // main::@18
  __b18:
    // [41] (byte) line::x1#2 ← (byte) main::x2#0 -- vbuz1=vbuz2 
    lda.z x2
    sta.z line.x1
    // [42] (byte) line::y1#2 ← (byte) main::y2#0 -- vbuz1=vbuz2 
    lda.z y2
    sta.z line.y1
    // [43] (byte) line::x2#2 ← (byte) main::x0#0 -- vbuz1=vbuz2 
    lda.z x0
    sta.z line.x2
    // [44] (byte) line::y2#2 ← (byte) main::y0#0 -- vbuz1=vbuz2 
    lda.z y0
    sta.z line.y2
    // [45] call line 
    // [87] phi from main::@18 to line [phi:main::@18->line]
  line_from___b18:
    // [87] phi (byte) line::y2#10 = (byte) line::y2#2 [phi:main::@18->line#0] -- register_copy 
    // [87] phi (byte) line::x2#15 = (byte) line::x2#2 [phi:main::@18->line#1] -- register_copy 
    // [87] phi (byte) line::y#0 = (byte) line::y1#2 [phi:main::@18->line#2] -- register_copy 
    // [87] phi (byte) line::x#0 = (byte) line::x1#2 [phi:main::@18->line#3] -- register_copy 
    jsr line
    jmp __b19
    // main::@19
  __b19:
    // [46] (byte) main::p0_idx#1 ← ++ (byte) main::p0_idx#2 -- vbuz1=_inc_vbuz1 
    inc.z p0_idx
    // [47] (byte) main::p1_idx#1 ← ++ (byte) main::p1_idx#2 -- vbuz1=_inc_vbuz1 
    inc.z p1_idx
    // [48] (byte) main::p2_idx#1 ← ++ (byte) main::p2_idx#2 -- vbuz1=_inc_vbuz1 
    inc.z p2_idx
    // [49] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) RED -- _deref_pbuc1=vbuc2 
    // Wait until the canvas on screen has been switched before starting work on the next frame
    lda #RED
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    jmp __b9
    // main::@9
  __b9:
    // [50] if((byte) 0!=(volatile byte) canvas_show_flag) goto main::@9 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z canvas_show_flag
    bne __b9
    jmp __b10
    // main::@10
  __b10:
    // [51] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [52] (byte*) eorfill::canvas#0 ← (byte*) main::canvas#10 -- pbuz1=pbuz2 
    lda.z canvas_1
    sta.z eorfill.canvas
    lda.z canvas_1+1
    sta.z eorfill.canvas+1
    // [53] call eorfill 
  // Fill canvas
    // [73] phi from main::@10 to eorfill [phi:main::@10->eorfill]
  eorfill_from___b10:
    jsr eorfill
    jmp __b20
    // main::@20
  __b20:
    // [54] (word) main::canvas#1 ← (byte*) main::canvas#10 ^ (const nomodify byte*) CANVAS1^(const nomodify byte*) CANVAS2 -- vwuz1=pbuz2_bxor_vwuc1 
    // swap canvas being rendered to (using XOR)
    lda #<CANVAS1^CANVAS2
    eor.z canvas_1
    sta.z canvas
    lda #>CANVAS1^CANVAS2
    eor.z canvas_1+1
    sta.z canvas+1
    // [55] phi from main::@20 to main::toD0181 [phi:main::@20->main::toD0181]
  toD0181_from___b20:
    jmp toD0181
    // main::toD0181
  toD0181:
    // [56] phi from main::toD0181 to main::toD0182 [phi:main::toD0181->main::toD0182]
  toD0182_from_toD0181:
    jmp toD0182
    // main::toD0182
  toD0182:
    jmp __b11
    // main::@11
  __b11:
    // [57] (volatile byte) canvas_show_memory ← (volatile byte) canvas_show_memory ^ (const byte) main::toD0181_return#0^(const byte) main::toD0182_return#0 -- vbuz1=vbuz1_bxor_vbuc1 
    // Swap canvas to show on screen (using XOR)
    lda #toD0181_return^toD0182_return
    eor.z canvas_show_memory
    sta.z canvas_show_memory
    // [58] (volatile byte) canvas_show_flag ← (byte) 1 -- vbuz1=vbuc1 
    // Set flag used to signal when the canvas has been shown
    lda #1
    sta.z canvas_show_flag
    // [59] call clock 
    // [71] phi from main::@11 to clock [phi:main::@11->clock]
  clock_from___b11:
    jsr clock
    jmp __b21
    // main::@21
  __b21:
    // [60] (byte*) main::canvas#19 ← (byte*)(word) main::canvas#1 -- pbuz1=pbuz2 
    lda.z canvas
    sta.z canvas_1
    lda.z canvas+1
    sta.z canvas_1+1
    // [20] phi from main::@21 to main::@7 [phi:main::@21->main::@7]
  __b7_from___b21:
    // [20] phi (byte*) main::canvas#10 = (byte*) main::canvas#19 [phi:main::@21->main::@7#0] -- register_copy 
    // [20] phi (byte) main::p2_idx#2 = (byte) main::p2_idx#1 [phi:main::@21->main::@7#1] -- register_copy 
    // [20] phi (byte) main::p1_idx#2 = (byte) main::p1_idx#1 [phi:main::@21->main::@7#2] -- register_copy 
    // [20] phi (byte) main::p0_idx#2 = (byte) main::p0_idx#1 [phi:main::@21->main::@7#3] -- register_copy 
    jmp __b7
    // main::@2
  __b2:
    // [61] (byte) main::c#4 ← (byte) main::y#2 -- vbuz1=vbuz2 
    lda.z y
    sta.z c
    // [62] phi from main::@2 to main::@4 [phi:main::@2->main::@4]
  __b4_from___b2:
    // [62] phi (byte) main::c#2 = (byte) main::c#4 [phi:main::@2->main::@4#0] -- register_copy 
    // [62] phi (byte) main::x#2 = (byte) 0 [phi:main::@2->main::@4#1] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    jmp __b4
    // main::@4
  __b4:
    // [63] if((byte) main::x#2<(byte) $10) goto main::@5 -- vbuz1_lt_vbuc1_then_la1 
    lda.z x
    cmp #$10
    bcc __b5
    jmp __b6
    // main::@6
  __b6:
    // [64] (byte*) main::cols#1 ← (byte*) main::cols#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z cols
    sta.z cols
    bcc !+
    inc.z cols+1
  !:
    // [65] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [66] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [13] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
  __b1_from___b6:
    // [13] phi (byte*) main::screen#5 = (byte*) main::screen#1 [phi:main::@6->main::@1#0] -- register_copy 
    // [13] phi (byte*) main::cols#5 = (byte*) main::cols#1 [phi:main::@6->main::@1#1] -- register_copy 
    // [13] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@6->main::@1#2] -- register_copy 
    jmp __b1
    // main::@5
  __b5:
    // [67] *((byte*) main::cols#5 + (byte) main::x#2) ← (const nomodify byte) WHITE -- pbuz1_derefidx_vbuz2=vbuc1 
    lda #WHITE
    ldy.z x
    sta (cols),y
    // [68] *((byte*) main::screen#5 + (byte) main::x#2) ← (byte) main::c#2 -- pbuz1_derefidx_vbuz2=vbuz3 
    lda.z c
    ldy.z x
    sta (screen),y
    // [69] (byte) main::c#1 ← (byte) main::c#2 + (byte) $10 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z c
    axs #-[$10]
    stx.z c
    // [70] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [62] phi from main::@5 to main::@4 [phi:main::@5->main::@4]
  __b4_from___b5:
    // [62] phi (byte) main::c#2 = (byte) main::c#1 [phi:main::@5->main::@4#0] -- register_copy 
    // [62] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@5->main::@4#1] -- register_copy 
    jmp __b4
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    jmp __breturn
    // clock::@return
  __breturn:
    // [72] return 
    rts
}
  // eorfill
// EOR fill from the line buffer onto the canvas
// eorfill(byte* zp($11) canvas)
eorfill: {
    .label canvas = $11
    .label eor = $14
    .label y = $13
    .label line_column = $f
    .label fill_column = $11
    .label x = $e
    // [74] phi from eorfill to eorfill::@1 [phi:eorfill->eorfill::@1]
  __b1_from_eorfill:
    // [74] phi (byte*) eorfill::fill_column#2 = (byte*) eorfill::canvas#0 [phi:eorfill->eorfill::@1#0] -- register_copy 
    // [74] phi (byte*) eorfill::line_column#2 = (const nomodify byte*) LINE_BUFFER [phi:eorfill->eorfill::@1#1] -- pbuz1=pbuc1 
    lda #<LINE_BUFFER
    sta.z line_column
    lda #>LINE_BUFFER
    sta.z line_column+1
    // [74] phi (byte) eorfill::x#2 = (byte) 0 [phi:eorfill->eorfill::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    jmp __b1
    // eorfill::@1
  __b1:
    // [75] if((byte) eorfill::x#2<(byte) $10) goto eorfill::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z x
    cmp #$10
    bcc __b2
    jmp __breturn
    // eorfill::@return
  __breturn:
    // [76] return 
    rts
    // eorfill::@2
  __b2:
    // [77] (byte) eorfill::eor#0 ← *((byte*) eorfill::line_column#2) -- vbuz1=_deref_pbuz2 
    ldy #0
    lda (line_column),y
    sta.z eor
    // [78] *((byte*) eorfill::fill_column#2) ← (byte) eorfill::eor#0 -- _deref_pbuz1=vbuz2 
    lda.z eor
    ldy #0
    sta (fill_column),y
    // [79] phi from eorfill::@2 to eorfill::@3 [phi:eorfill::@2->eorfill::@3]
  __b3_from___b2:
    // [79] phi (byte) eorfill::eor#2 = (byte) eorfill::eor#0 [phi:eorfill::@2->eorfill::@3#0] -- register_copy 
    // [79] phi (byte) eorfill::y#2 = (byte) 1 [phi:eorfill::@2->eorfill::@3#1] -- vbuz1=vbuc1 
    lda #1
    sta.z y
    jmp __b3
    // eorfill::@3
  __b3:
    // [80] if((byte) eorfill::y#2<(byte)(number) $10*(number) 8) goto eorfill::@4 -- vbuz1_lt_vbuc1_then_la1 
    lda.z y
    cmp #$10*8
    bcc __b4
    jmp __b5
    // eorfill::@5
  __b5:
    // [81] (byte*) eorfill::line_column#1 ← (byte*) eorfill::line_column#2 + (byte)(number) $10*(number) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$10*8
    clc
    adc.z line_column
    sta.z line_column
    bcc !+
    inc.z line_column+1
  !:
    // [82] (byte*) eorfill::fill_column#1 ← (byte*) eorfill::fill_column#2 + (byte)(number) $10*(number) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$10*8
    clc
    adc.z fill_column
    sta.z fill_column
    bcc !+
    inc.z fill_column+1
  !:
    // [83] (byte) eorfill::x#1 ← ++ (byte) eorfill::x#2 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [74] phi from eorfill::@5 to eorfill::@1 [phi:eorfill::@5->eorfill::@1]
  __b1_from___b5:
    // [74] phi (byte*) eorfill::fill_column#2 = (byte*) eorfill::fill_column#1 [phi:eorfill::@5->eorfill::@1#0] -- register_copy 
    // [74] phi (byte*) eorfill::line_column#2 = (byte*) eorfill::line_column#1 [phi:eorfill::@5->eorfill::@1#1] -- register_copy 
    // [74] phi (byte) eorfill::x#2 = (byte) eorfill::x#1 [phi:eorfill::@5->eorfill::@1#2] -- register_copy 
    jmp __b1
    // eorfill::@4
  __b4:
    // [84] (byte) eorfill::eor#1 ← (byte) eorfill::eor#2 ^ *((byte*) eorfill::line_column#2 + (byte) eorfill::y#2) -- vbuz1=vbuz1_bxor_pbuz2_derefidx_vbuz3 
    lda.z eor
    ldy.z y
    eor (line_column),y
    sta.z eor
    // [85] *((byte*) eorfill::fill_column#2 + (byte) eorfill::y#2) ← (byte) eorfill::eor#1 -- pbuz1_derefidx_vbuz2=vbuz3 
    lda.z eor
    ldy.z y
    sta (fill_column),y
    // [86] (byte) eorfill::y#1 ← ++ (byte) eorfill::y#2 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [79] phi from eorfill::@4 to eorfill::@3 [phi:eorfill::@4->eorfill::@3]
  __b3_from___b4:
    // [79] phi (byte) eorfill::eor#2 = (byte) eorfill::eor#1 [phi:eorfill::@4->eorfill::@3#0] -- register_copy 
    // [79] phi (byte) eorfill::y#2 = (byte) eorfill::y#1 [phi:eorfill::@4->eorfill::@3#1] -- register_copy 
    jmp __b3
}
  // line
// Draw a EOR friendly line between two points
// Uses bresenham line drawing routine
// line(byte zp($19) x1, byte zp($1a) y1, byte zp($15) x2, byte zp($16) y2)
line: {
    .label plot1___0 = $43
    .label plot1___1 = $47
    .label plot1___2 = $44
    .label plot2___0 = $39
    .label plot2___1 = $3d
    .label plot2___2 = $3a
    .label plot3___0 = $3e
    .label plot3___1 = $42
    .label plot3___2 = $3f
    .label plot4___0 = $48
    .label plot4___1 = $4c
    .label plot4___2 = $49
    .label plot5___0 = $4d
    .label plot5___1 = $51
    .label plot5___2 = $4e
    .label plot6___0 = $52
    .label plot6___1 = $56
    .label plot6___2 = $53
    .label x1 = $19
    .label y1 = $1a
    .label x2 = $15
    .label y2 = $16
    .label x = $19
    .label y = $1a
    .label dx = $31
    .label dy = $33
    .label sx = $35
    .label sy = $37
    .label e2 = $1b
    .label plot1_column = $45
    .label e = $17
    .label plot2_y = $38
    .label plot2_column = $3b
    .label plot3_column = $40
    .label e1 = $18
    .label plot4_column = $4a
    .label plot5_column = $4f
    .label plot6_column = $54
    // [88] (byte) abs_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z x2
    sec
    sbc.z x
    sta.z abs_u8.u
    // [89] call abs_u8 
    // [175] phi from line to abs_u8 [phi:line->abs_u8]
  abs_u8_from_line:
    // [175] phi (byte) abs_u8::u#2 = (byte) abs_u8::u#0 [phi:line->abs_u8#0] -- register_copy 
    jsr abs_u8
    // [90] (byte) abs_u8::return#0 ← (byte) abs_u8::return#4 -- vbuz1=vbuz2 
    lda.z abs_u8.return_2
    sta.z abs_u8.return
    jmp __b19
    // line::@19
  __b19:
    // [91] (byte) line::dx#0 ← (byte) abs_u8::return#0 -- vbuz1=vbuz2 
    lda.z abs_u8.return
    sta.z dx
    // [92] (byte) abs_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z y2
    sec
    sbc.z y
    sta.z abs_u8.u
    // [93] call abs_u8 
    // [175] phi from line::@19 to abs_u8 [phi:line::@19->abs_u8]
  abs_u8_from___b19:
    // [175] phi (byte) abs_u8::u#2 = (byte) abs_u8::u#1 [phi:line::@19->abs_u8#0] -- register_copy 
    jsr abs_u8
    // [94] (byte) abs_u8::return#1 ← (byte) abs_u8::return#4 -- vbuz1=vbuz2 
    lda.z abs_u8.return_2
    sta.z abs_u8.return_1
    jmp __b20
    // line::@20
  __b20:
    // [95] (byte) line::dy#0 ← (byte) abs_u8::return#1 -- vbuz1=vbuz2 
    lda.z abs_u8.return_1
    sta.z dy
    // [96] (byte) sgn_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z x2
    sec
    sbc.z x
    sta.z sgn_u8.u
    // [97] call sgn_u8 
    // [169] phi from line::@20 to sgn_u8 [phi:line::@20->sgn_u8]
  sgn_u8_from___b20:
    // [169] phi (byte) sgn_u8::u#2 = (byte) sgn_u8::u#0 [phi:line::@20->sgn_u8#0] -- register_copy 
    jsr sgn_u8
    // [98] (byte) sgn_u8::return#0 ← (byte) sgn_u8::return#4 -- vbuz1=vbuz2 
    lda.z sgn_u8.return_2
    sta.z sgn_u8.return
    jmp __b21
    // line::@21
  __b21:
    // [99] (byte) line::sx#0 ← (byte) sgn_u8::return#0 -- vbuz1=vbuz2 
    lda.z sgn_u8.return
    sta.z sx
    // [100] (byte) sgn_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z y2
    sec
    sbc.z y
    sta.z sgn_u8.u
    // [101] call sgn_u8 
    // [169] phi from line::@21 to sgn_u8 [phi:line::@21->sgn_u8]
  sgn_u8_from___b21:
    // [169] phi (byte) sgn_u8::u#2 = (byte) sgn_u8::u#1 [phi:line::@21->sgn_u8#0] -- register_copy 
    jsr sgn_u8
    // [102] (byte) sgn_u8::return#1 ← (byte) sgn_u8::return#4 -- vbuz1=vbuz2 
    lda.z sgn_u8.return_2
    sta.z sgn_u8.return_1
    jmp __b22
    // line::@22
  __b22:
    // [103] (byte) line::sy#0 ← (byte) sgn_u8::return#1 -- vbuz1=vbuz2 
    lda.z sgn_u8.return_1
    sta.z sy
    // [104] if((byte) line::sx#0!=(byte) $ff) goto line::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z sx
    bne __b1_from___b22
    jmp __b3
    // line::@3
  __b3:
    // [105] (byte) line::y#1 ← ++ (byte) line::y#0 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [106] (byte) line::y2#3 ← ++ (byte) line::y2#10 -- vbuz1=_inc_vbuz1 
    inc.z y2
    // [107] phi from line::@22 line::@3 to line::@1 [phi:line::@22/line::@3->line::@1]
  __b1_from___b22:
  __b1_from___b3:
    // [107] phi (byte) line::y2#13 = (byte) line::y2#10 [phi:line::@22/line::@3->line::@1#0] -- register_copy 
    // [107] phi (byte) line::y#17 = (byte) line::y#0 [phi:line::@22/line::@3->line::@1#1] -- register_copy 
    jmp __b1
    // line::@1
  __b1:
    // [108] if((byte) line::dx#0>(byte) line::dy#0) goto line::@2 -- vbuz1_gt_vbuz2_then_la1 
    lda.z dy
    cmp.z dx
    bcc __b2
    jmp __b4
    // line::@4
  __b4:
    // [109] if((byte) line::sx#0==(byte) line::sy#0) goto line::plot1 -- vbuz1_eq_vbuz2_then_la1 
    // Steep slope - Y is the driver - only plot one plot per X
    lda.z sx
    cmp.z sy
    beq plot1
    jmp __b5
    // line::@5
  __b5:
    // [110] (byte) line::e#0 ← (byte) line::dy#0 >> (byte) 1 -- vbuz1=vbuz2_ror_1 
    lda.z dy
    lsr
    sta.z e
    // [111] phi from line::@5 line::@7 to line::@6 [phi:line::@5/line::@7->line::@6]
  __b6_from___b5:
  __b6_from___b7:
    // [111] phi (byte) line::x#15 = (byte) line::x#0 [phi:line::@5/line::@7->line::@6#0] -- register_copy 
    // [111] phi (byte) line::e#3 = (byte) line::e#0 [phi:line::@5/line::@7->line::@6#1] -- register_copy 
    // [111] phi (byte) line::y#7 = (byte) line::y#17 [phi:line::@5/line::@7->line::@6#2] -- register_copy 
    jmp __b6
    // line::@6
  __b6:
    // [112] (byte) line::y#10 ← (byte) line::y#7 + (byte) line::sy#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z y
    clc
    adc.z sy
    sta.z y
    // [113] (byte) line::e#1 ← (byte) line::e#3 + (byte) line::dx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z e
    clc
    adc.z dx
    sta.z e
    // [114] if((byte) line::e#1<=(byte) line::dy#0) goto line::@7 -- vbuz1_le_vbuz2_then_la1 
    lda.z dy
    cmp.z e
    bcs __b7_from___b6
    jmp __b8
    // line::@8
  __b8:
    // [115] (byte) line::plot2_y#0 ← (byte) line::y#10 - (byte) line::sy#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z y
    sec
    sbc.z sy
    sta.z plot2_y
    jmp plot2
    // line::plot2
  plot2:
    // [116] (byte~) line::plot2_$0 ← (byte) line::x#15 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    sta.z plot2___0
    // [117] (byte~) line::plot2_$2 ← (byte~) line::plot2_$0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plot2___0
    asl
    sta.z plot2___2
    // [118] (byte*) line::plot2_column#0 ← *((const byte**) plot_column + (byte~) line::plot2_$2) -- pbuz1=pptc1_derefidx_vbuz2 
    ldy.z plot2___2
    lda plot_column,y
    sta.z plot2_column
    lda plot_column+1,y
    sta.z plot2_column+1
    // [119] (byte~) line::plot2_$1 ← (byte) line::x#15 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot2___1
    // [120] *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) ← *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) | *((const byte*) plot_bit + (byte~) line::plot2_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z plot2_y
    lda (plot2_column),y
    ldy.z plot2___1
    ora plot_bit,y
    ldy.z plot2_y
    sta (plot2_column),y
    jmp __b16
    // line::@16
  __b16:
    // [121] (byte) line::x#1 ← (byte) line::x#15 + (byte) line::sx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z sx
    sta.z x
    // [122] (byte) line::e#2 ← (byte) line::e#1 - (byte) line::dy#0 -- vbuz1=vbuz1_minus_vbuz2 
    lda.z e
    sec
    sbc.z dy
    sta.z e
    // [123] phi from line::@16 line::@6 to line::@7 [phi:line::@16/line::@6->line::@7]
  __b7_from___b16:
  __b7_from___b6:
    // [123] phi (byte) line::x#17 = (byte) line::x#1 [phi:line::@16/line::@6->line::@7#0] -- register_copy 
    // [123] phi (byte) line::e#5 = (byte) line::e#2 [phi:line::@16/line::@6->line::@7#1] -- register_copy 
    jmp __b7
    // line::@7
  __b7:
    // [124] if((byte) line::y#10!=(byte) line::y2#13) goto line::@6 -- vbuz1_neq_vbuz2_then_la1 
    lda.z y
    cmp.z y2
    bne __b6_from___b7
    jmp plot3
    // line::plot3
  plot3:
    // [125] (byte~) line::plot3_$0 ← (byte) line::x#17 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    sta.z plot3___0
    // [126] (byte~) line::plot3_$2 ← (byte~) line::plot3_$0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plot3___0
    asl
    sta.z plot3___2
    // [127] (byte*) line::plot3_column#0 ← *((const byte**) plot_column + (byte~) line::plot3_$2) -- pbuz1=pptc1_derefidx_vbuz2 
    ldy.z plot3___2
    lda plot_column,y
    sta.z plot3_column
    lda plot_column+1,y
    sta.z plot3_column+1
    // [128] (byte~) line::plot3_$1 ← (byte) line::x#17 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot3___1
    // [129] *((byte*) line::plot3_column#0 + (byte) line::y#10) ← *((byte*) line::plot3_column#0 + (byte) line::y#10) | *((const byte*) plot_bit + (byte~) line::plot3_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z y
    lda (plot3_column),y
    ldy.z plot3___1
    ora plot_bit,y
    ldy.z y
    sta (plot3_column),y
    jmp __breturn
    // line::@return
  __breturn:
    // [130] return 
    rts
    // line::plot1
  plot1:
    // [131] (byte~) line::plot1_$0 ← (byte) line::x#0 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    sta.z plot1___0
    // [132] (byte~) line::plot1_$2 ← (byte~) line::plot1_$0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plot1___0
    asl
    sta.z plot1___2
    // [133] (byte*) line::plot1_column#0 ← *((const byte**) plot_column + (byte~) line::plot1_$2) -- pbuz1=pptc1_derefidx_vbuz2 
    ldy.z plot1___2
    lda plot_column,y
    sta.z plot1_column
    lda plot_column+1,y
    sta.z plot1_column+1
    // [134] (byte~) line::plot1_$1 ← (byte) line::x#0 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot1___1
    // [135] *((byte*) line::plot1_column#0 + (byte) line::y#17) ← *((byte*) line::plot1_column#0 + (byte) line::y#17) | *((const byte*) plot_bit + (byte~) line::plot1_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z y
    lda (plot1_column),y
    ldy.z plot1___1
    ora plot_bit,y
    ldy.z y
    sta (plot1_column),y
    jmp __b15
    // line::@15
  __b15:
    // [136] if((byte) line::dx#0!=(byte) 0) goto line::@9 -- vbuz1_neq_0_then_la1 
    lda.z dx
    cmp #0
    bne __b9
    jmp __breturn
    // line::@9
  __b9:
    // [137] (byte) line::e1#0 ← (byte) line::dy#0 >> (byte) 1 -- vbuz1=vbuz2_ror_1 
    lda.z dy
    lsr
    sta.z e1
    // [138] phi from line::@10 line::@17 line::@9 to line::@10 [phi:line::@10/line::@17/line::@9->line::@10]
  __b10_from___b10:
  __b10_from___b17:
  __b10_from___b9:
    // [138] phi (byte) line::x#18 = (byte) line::x#18 [phi:line::@10/line::@17/line::@9->line::@10#0] -- register_copy 
    // [138] phi (byte) line::e1#3 = (byte) line::e1#1 [phi:line::@10/line::@17/line::@9->line::@10#1] -- register_copy 
    // [138] phi (byte) line::y#11 = (byte) line::y#12 [phi:line::@10/line::@17/line::@9->line::@10#2] -- register_copy 
    jmp __b10
    // line::@10
  __b10:
    // [139] (byte) line::y#12 ← (byte) line::y#11 + (byte) line::sy#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z y
    clc
    adc.z sy
    sta.z y
    // [140] (byte) line::e1#1 ← (byte) line::e1#3 + (byte) line::dx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z e1
    clc
    adc.z dx
    sta.z e1
    // [141] if((byte) line::e1#1<=(byte) line::dy#0) goto line::@10 -- vbuz1_le_vbuz2_then_la1 
    lda.z dy
    cmp.z e1
    bcs __b10_from___b10
    jmp __b11
    // line::@11
  __b11:
    // [142] (byte) line::x#19 ← (byte) line::x#18 + (byte) line::sx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z sx
    sta.z x
    // [143] (byte) line::e1#2 ← (byte) line::e1#1 - (byte) line::dy#0 -- vbuz1=vbuz1_minus_vbuz2 
    lda.z e1
    sec
    sbc.z dy
    sta.z e1
    jmp plot4
    // line::plot4
  plot4:
    // [144] (byte~) line::plot4_$0 ← (byte) line::x#19 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    sta.z plot4___0
    // [145] (byte~) line::plot4_$2 ← (byte~) line::plot4_$0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plot4___0
    asl
    sta.z plot4___2
    // [146] (byte*) line::plot4_column#0 ← *((const byte**) plot_column + (byte~) line::plot4_$2) -- pbuz1=pptc1_derefidx_vbuz2 
    ldy.z plot4___2
    lda plot_column,y
    sta.z plot4_column
    lda plot_column+1,y
    sta.z plot4_column+1
    // [147] (byte~) line::plot4_$1 ← (byte) line::x#19 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot4___1
    // [148] *((byte*) line::plot4_column#0 + (byte) line::y#12) ← *((byte*) line::plot4_column#0 + (byte) line::y#12) | *((const byte*) plot_bit + (byte~) line::plot4_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z y
    lda (plot4_column),y
    ldy.z plot4___1
    ora plot_bit,y
    ldy.z y
    sta (plot4_column),y
    jmp __b17
    // line::@17
  __b17:
    // [149] if((byte) line::x#19!=(byte) line::x2#15) goto line::@10 -- vbuz1_neq_vbuz2_then_la1 
    lda.z x
    cmp.z x2
    bne __b10_from___b17
    jmp __breturn
    // line::@2
  __b2:
    // [150] (byte) line::e2#0 ← (byte) line::dx#0 >> (byte) 1 -- vbuz1=vbuz2_ror_1 
    lda.z dx
    lsr
    sta.z e2
    // [151] phi from line::@13 line::@2 to line::@12 [phi:line::@13/line::@2->line::@12]
  __b12_from___b13:
  __b12_from___b2:
    // [151] phi (byte) line::e2#3 = (byte) line::e2#7 [phi:line::@13/line::@2->line::@12#0] -- register_copy 
    // [151] phi (byte) line::y#13 = (byte) line::y#15 [phi:line::@13/line::@2->line::@12#1] -- register_copy 
    // [151] phi (byte) line::x#10 = (byte) line::x#12 [phi:line::@13/line::@2->line::@12#2] -- register_copy 
    jmp __b12
    // line::@12
  __b12:
    jmp plot5
    // line::plot5
  plot5:
    // [152] (byte~) line::plot5_$0 ← (byte) line::x#10 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    sta.z plot5___0
    // [153] (byte~) line::plot5_$2 ← (byte~) line::plot5_$0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plot5___0
    asl
    sta.z plot5___2
    // [154] (byte*) line::plot5_column#0 ← *((const byte**) plot_column + (byte~) line::plot5_$2) -- pbuz1=pptc1_derefidx_vbuz2 
    ldy.z plot5___2
    lda plot_column,y
    sta.z plot5_column
    lda plot_column+1,y
    sta.z plot5_column+1
    // [155] (byte~) line::plot5_$1 ← (byte) line::x#10 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot5___1
    // [156] *((byte*) line::plot5_column#0 + (byte) line::y#13) ← *((byte*) line::plot5_column#0 + (byte) line::y#13) | *((const byte*) plot_bit + (byte~) line::plot5_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z y
    lda (plot5_column),y
    ldy.z plot5___1
    ora plot_bit,y
    ldy.z y
    sta (plot5_column),y
    jmp __b18
    // line::@18
  __b18:
    // [157] (byte) line::x#12 ← (byte) line::x#10 + (byte) line::sx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z sx
    sta.z x
    // [158] (byte) line::e2#1 ← (byte) line::e2#3 + (byte) line::dy#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z e2
    clc
    adc.z dy
    sta.z e2
    // [159] if((byte) line::e2#1<=(byte) line::dx#0) goto line::@13 -- vbuz1_le_vbuz2_then_la1 
    lda.z dx
    cmp.z e2
    bcs __b13_from___b18
    jmp __b14
    // line::@14
  __b14:
    // [160] (byte) line::y#4 ← (byte) line::y#13 + (byte) line::sy#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z y
    clc
    adc.z sy
    sta.z y
    // [161] (byte) line::e2#2 ← (byte) line::e2#1 - (byte) line::dx#0 -- vbuz1=vbuz1_minus_vbuz2 
    lda.z e2
    sec
    sbc.z dx
    sta.z e2
    // [162] phi from line::@14 line::@18 to line::@13 [phi:line::@14/line::@18->line::@13]
  __b13_from___b14:
  __b13_from___b18:
    // [162] phi (byte) line::e2#7 = (byte) line::e2#2 [phi:line::@14/line::@18->line::@13#0] -- register_copy 
    // [162] phi (byte) line::y#15 = (byte) line::y#4 [phi:line::@14/line::@18->line::@13#1] -- register_copy 
    jmp __b13
    // line::@13
  __b13:
    // [163] if((byte) line::x#12!=(byte) line::x2#15) goto line::@12 -- vbuz1_neq_vbuz2_then_la1 
    lda.z x
    cmp.z x2
    bne __b12_from___b13
    jmp plot6
    // line::plot6
  plot6:
    // [164] (byte~) line::plot6_$0 ← (byte) line::x#12 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    sta.z plot6___0
    // [165] (byte~) line::plot6_$2 ← (byte~) line::plot6_$0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plot6___0
    asl
    sta.z plot6___2
    // [166] (byte*) line::plot6_column#0 ← *((const byte**) plot_column + (byte~) line::plot6_$2) -- pbuz1=pptc1_derefidx_vbuz2 
    ldy.z plot6___2
    lda plot_column,y
    sta.z plot6_column
    lda plot_column+1,y
    sta.z plot6_column+1
    // [167] (byte~) line::plot6_$1 ← (byte) line::x#12 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot6___1
    // [168] *((byte*) line::plot6_column#0 + (byte) line::y#15) ← *((byte*) line::plot6_column#0 + (byte) line::y#15) | *((const byte*) plot_bit + (byte~) line::plot6_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z y
    lda (plot6_column),y
    ldy.z plot6___1
    ora plot_bit,y
    ldy.z y
    sta (plot6_column),y
    jmp __breturn
}
  // sgn_u8
// Get the sign of a 8-bit unsigned number treated as a signed number.
// Returns unsigned -1 if the number is negative
// sgn_u8(byte zp($1c) u)
sgn_u8: {
    .label __0 = $57
    .label u = $1c
    .label return = $34
    .label return_1 = $36
    .label return_2 = $1d
    // [170] (byte~) sgn_u8::$0 ← (byte) sgn_u8::u#2 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and.z u
    sta.z __0
    // [171] if((byte) 0!=(byte~) sgn_u8::$0) goto sgn_u8::@1 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z __0
    bne __b1_from_sgn_u8
    // [173] phi from sgn_u8 to sgn_u8::@return [phi:sgn_u8->sgn_u8::@return]
  __breturn_from_sgn_u8:
    // [173] phi (byte) sgn_u8::return#4 = (byte) 1 [phi:sgn_u8->sgn_u8::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta.z return_2
    jmp __breturn
    // [172] phi from sgn_u8 to sgn_u8::@1 [phi:sgn_u8->sgn_u8::@1]
  __b1_from_sgn_u8:
    jmp __b1
    // sgn_u8::@1
  __b1:
    // [173] phi from sgn_u8::@1 to sgn_u8::@return [phi:sgn_u8::@1->sgn_u8::@return]
  __breturn_from___b1:
    // [173] phi (byte) sgn_u8::return#4 = (byte) -1 [phi:sgn_u8::@1->sgn_u8::@return#0] -- vbuz1=vbuc1 
    lda #-1
    sta.z return_2
    jmp __breturn
    // sgn_u8::@return
  __breturn:
    // [174] return 
    rts
}
  // abs_u8
// Get the absolute value of a u-bit unsigned number treated as a signed number.
// abs_u8(byte zp($1e) u)
abs_u8: {
    .label __0 = $58
    .label u = $1e
    .label return = $30
    .label return_1 = $32
    .label return_2 = $1e
    // [176] (byte~) abs_u8::$0 ← (byte) abs_u8::u#2 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and.z u
    sta.z __0
    // [177] if((byte) 0!=(byte~) abs_u8::$0) goto abs_u8::@1 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z __0
    bne __b1
    // [179] phi from abs_u8 abs_u8::@1 to abs_u8::@return [phi:abs_u8/abs_u8::@1->abs_u8::@return]
  __breturn_from_abs_u8:
  __breturn_from___b1:
    // [179] phi (byte) abs_u8::return#4 = (byte) abs_u8::u#2 [phi:abs_u8/abs_u8::@1->abs_u8::@return#0] -- register_copy 
    jmp __breturn
    // abs_u8::@1
  __b1:
    // [178] (byte) abs_u8::return#2 ← - (byte) abs_u8::u#2 -- vbuz1=_neg_vbuz1 
    lda.z return_2
    eor #$ff
    clc
    adc #1
    sta.z return_2
    jmp __breturn_from___b1
    // abs_u8::@return
  __breturn:
    // [180] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zp($21) str, byte zp($23) c, word zp($1f) num)
memset: {
    .label end = $59
    .label dst = $24
    .label num = $1f
    .label str = $21
    .label c = $23
    // [182] if((word) memset::num#4<=(byte) 0) goto memset::@return -- vwuz1_le_0_then_la1 
    lda.z num
    bne !+
    lda.z num+1
    beq __breturn
  !:
    jmp __b1
    // memset::@1
  __b1:
    // [183] (byte*) memset::end#0 ← (byte*)(void*) memset::str#5 + (word) memset::num#4 -- pbuz1=pbuz2_plus_vwuz3 
    lda.z str
    clc
    adc.z num
    sta.z end
    lda.z str+1
    adc.z num+1
    sta.z end+1
    // [184] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#5 -- pbuz1=pbuz2 
    lda.z str
    sta.z dst
    lda.z str+1
    sta.z dst+1
    // [185] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  __b2_from___b1:
  __b2_from___b3:
    // [185] phi (byte*) memset::dst#2 = (byte*) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp __b2
    // memset::@2
  __b2:
    // [186] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    jmp __breturn
    // memset::@return
  __breturn:
    // [187] return 
    rts
    // memset::@3
  __b3:
    // [188] *((byte*) memset::dst#2) ← (byte) memset::c#6 -- _deref_pbuz1=vbuz2 
    lda.z c
    ldy #0
    sta (dst),y
    // [189] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2_from___b3
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [190] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #0
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // [191] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [192] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [193] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [194] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    jmp __breturn
    // clock_start::@return
  __breturn:
    // [195] return 
    rts
}
  // textcolor
// Set the color for text output. The old color setting is returned.
textcolor: {
    jmp __breturn
    // textcolor::@return
  __breturn:
    // [197] return 
    rts
}
  // setup_irq
// Setup raster IRQ to change charset at different lines
setup_irq: {
    // asm { sei  }
    sei
    // [199] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // [200] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line to 8 pixels before the border
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // [201] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 -- _deref_pbuc1=vbuc2 
    lda #BORDER_YPOS_BOTTOM-8
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [202] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // [203] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() -- _deref_pptc1=pprc2 
    // Set the IRQ routine
    lda #<irq_bottom_1
    sta KERNEL_IRQ
    lda #>irq_bottom_1
    sta KERNEL_IRQ+1
    // asm { cli  }
    cli
    jmp __breturn
    // setup_irq::@return
  __breturn:
    // [205] return 
    rts
}
  // irq_bottom_2
// Interrupt Routine 2
irq_bottom_2: {
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>LINE_BUFFER)/4&$f
    .label __0 = $5c
    // entry interrupt(KERNEL_KEYBOARD)
    // [206] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    // Change border color
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [207] call kbhit 
    jsr kbhit
    // [208] (byte) kbhit::return#2 ← (byte) kbhit::return#0 -- vbuz1=vbuz2 
    lda.z kbhit.return
    sta.z kbhit.return_1
    jmp __b4
    // irq_bottom_2::@4
  __b4:
    // [209] (byte~) irq_bottom_2::$0 ← (byte) kbhit::return#2 -- vbuz1=vbuz2 
    lda.z kbhit.return_1
    sta.z __0
    // [210] if((byte) 0==(byte~) irq_bottom_2::$0) goto irq_bottom_2::@1 -- vbuc1_eq_vbuz1_then_la1 
    // Show the current canvas (unless a key is being pressed)
    lda #0
    cmp.z __0
    beq __b1
    // [211] phi from irq_bottom_2::@4 to irq_bottom_2::toD0181 [phi:irq_bottom_2::@4->irq_bottom_2::toD0181]
  toD0181_from___b4:
    jmp toD0181
    // irq_bottom_2::toD0181
  toD0181:
    jmp __b3
    // irq_bottom_2::@3
  __b3:
    // [212] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_2::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_MEMORY
    jmp __b2
    // irq_bottom_2::@2
  __b2:
    // [213] (volatile byte) canvas_show_flag ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z canvas_show_flag
    // [214] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // [215] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 -- _deref_pbuc1=vbuc2 
    // Trigger IRQ 1 at 8 pixels before the border
    lda #BORDER_YPOS_BOTTOM-8
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [216] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() -- _deref_pptc1=pprc2 
    lda #<irq_bottom_1
    sta KERNEL_IRQ
    lda #>irq_bottom_1
    sta KERNEL_IRQ+1
    jmp __breturn
    // irq_bottom_2::@return
  __breturn:
    // [217] return  - exit interrupt(KERNEL_KEYBOARD)
    jmp $ea31
    // irq_bottom_2::@1
  __b1:
    // [218] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (volatile byte) canvas_show_memory -- _deref_pbuc1=vbuz1 
    lda.z canvas_show_memory
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_MEMORY
    jmp __b2
}
  // kbhit
// Return true if there's a key waiting, return false if not
kbhit: {
    // CIA#1 Port A: keyboard matrix columns and joystick #2
    .label CIA1_PORT_A = $dc00
    // CIA#1 Port B: keyboard matrix rows and joystick #1.
    .label CIA1_PORT_B = $dc01
    .label return = $5d
    .label return_1 = $5b
    // [219] *((const nomodify byte*) kbhit::CIA1_PORT_A) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta CIA1_PORT_A
    // [220] (byte) kbhit::return#0 ← ~ *((const nomodify byte*) kbhit::CIA1_PORT_B) -- vbuz1=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    sta.z return
    jmp __breturn
    // kbhit::@return
  __breturn:
    // [221] return 
    rts
}
  // irq_bottom_1
// Interrupt Routine 1: Just above last text line.
irq_bottom_1: {
    .const toD0181_return = (>(CONSOLE&$3fff)*4)|(>PETSCII)/4&$f
    // entry interrupt(KERNEL_MIN)
    // [222] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) DARK_GREY -- _deref_pbuc1=vbuc2 
    // Change border color
    lda #DARK_GREY
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [223] phi from irq_bottom_1 to irq_bottom_1::toD0181 [phi:irq_bottom_1->irq_bottom_1::toD0181]
  toD0181_from_irq_bottom_1:
    jmp toD0181
    // irq_bottom_1::toD0181
  toD0181:
    jmp __b1
    // irq_bottom_1::@1
  __b1:
    // [224] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_1::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    // Show the cycle counter
    lda #toD0181_return
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_MEMORY
    // [225] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // [226] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM -- _deref_pbuc1=vbuc2 
    // Trigger IRQ 2 at bottom of text-line
    lda #BORDER_YPOS_BOTTOM
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [227] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2() -- _deref_pptc1=pprc2 
    lda #<irq_bottom_2
    sta KERNEL_IRQ
    lda #>irq_bottom_2
    sta KERNEL_IRQ+1
    jmp __breturn
    // irq_bottom_1::@return
  __breturn:
    // [228] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
}
  // File Data
  // SIN/COS tables
  .align $100
SINTAB:
.fill $200, round(63 + 63*sin(i*2*PI/$100))

  // Column offsets
  plot_column: .word LINE_BUFFER, LINE_BUFFER+1*$80, LINE_BUFFER+2*$80, LINE_BUFFER+3*$80, LINE_BUFFER+4*$80, LINE_BUFFER+5*$80, LINE_BUFFER+6*$80, LINE_BUFFER+7*$80, LINE_BUFFER+8*$80, LINE_BUFFER+9*$80, LINE_BUFFER+$a*$80, LINE_BUFFER+$b*$80, LINE_BUFFER+$c*$80, LINE_BUFFER+$d*$80, LINE_BUFFER+$e*$80, LINE_BUFFER+$f*$80
  // The bits used for plotting a pixel
  plot_bit: .byte $80, $40, $20, $10, 8, 4, 2, 1

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] (volatile byte) canvas_show_memory ← (const byte) toD0181_return#0 [ canvas_show_memory ] (  [ canvas_show_memory ] { }  ) always clobbers reg byte a 
Statement [3] (volatile byte) canvas_show_flag ← (byte) 0 [ canvas_show_memory canvas_show_flag ] (  [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [15] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK [ canvas_show_memory canvas_show_flag ] ( main:5 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [16] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← (const nomodify byte) BLACK [ canvas_show_memory canvas_show_flag ] ( main:5 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [49] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) RED [ canvas_show_memory canvas_show_flag main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:7 [ main::p0_idx#2 main::p0_idx#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:8 [ main::p1_idx#2 main::p1_idx#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:9 [ main::p2_idx#2 main::p2_idx#1 ]
Statement [50] if((byte) 0!=(volatile byte) canvas_show_flag) goto main::@9 [ canvas_show_memory canvas_show_flag main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] { }  ) always clobbers reg byte a 
Statement [51] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] ( main:5 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Statement [52] (byte*) eorfill::canvas#0 ← (byte*) main::canvas#10 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::canvas#0 ] ( main:5 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::canvas#0 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Statement [54] (word) main::canvas#1 ← (byte*) main::canvas#10 ^ (const nomodify byte*) CANVAS1^(const nomodify byte*) CANVAS2 [ canvas_show_memory main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] ( main:5 [ canvas_show_memory main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] { }  ) always clobbers reg byte a 
Statement [57] (volatile byte) canvas_show_memory ← (volatile byte) canvas_show_memory ^ (const byte) main::toD0181_return#0^(const byte) main::toD0182_return#0 [ canvas_show_memory main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] ( main:5 [ canvas_show_memory main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] { }  ) always clobbers reg byte a 
Statement [58] (volatile byte) canvas_show_flag ← (byte) 1 [ canvas_show_memory canvas_show_flag main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] { }  ) always clobbers reg byte a 
Statement [60] (byte*) main::canvas#19 ← (byte*)(word) main::canvas#1 [ canvas_show_memory canvas_show_flag main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#19 ] ( main:5 [ canvas_show_memory canvas_show_flag main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#19 ] { }  ) always clobbers reg byte a 
Statement [64] (byte*) main::cols#1 ← (byte*) main::cols#5 + (byte) $28 [ canvas_show_memory canvas_show_flag main::y#2 main::screen#5 main::cols#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::screen#5 main::cols#1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::y#2 main::y#1 ]
Statement [65] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#1 main::screen#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#1 main::screen#1 ] { }  ) always clobbers reg byte a 
Statement [67] *((byte*) main::cols#5 + (byte) main::x#2) ← (const nomodify byte) WHITE [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#2 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:12 [ main::x#2 main::x#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:13 [ main::c#2 main::c#4 main::c#1 ]
Statement [68] *((byte*) main::screen#5 + (byte) main::x#2) ← (byte) main::c#2 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#2 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#2 ] { }  ) always clobbers reg byte a 
Statement [69] (byte) main::c#1 ← (byte) main::c#2 + (byte) $10 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#1 ] { }  ) always clobbers reg byte a 
Statement [77] (byte) eorfill::eor#0 ← *((byte*) eorfill::line_column#2) [ eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::eor#0 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::eor#0 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:7 [ main::p0_idx#2 main::p0_idx#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:8 [ main::p1_idx#2 main::p1_idx#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:9 [ main::p2_idx#2 main::p2_idx#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:14 [ eorfill::x#2 eorfill::x#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:14 [ eorfill::x#2 eorfill::x#1 ]
Statement [78] *((byte*) eorfill::fill_column#2) ← (byte) eorfill::eor#0 [ eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::eor#0 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::eor#0 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:20 [ eorfill::eor#2 eorfill::eor#0 eorfill::eor#1 ]
Statement [81] (byte*) eorfill::line_column#1 ← (byte*) eorfill::line_column#2 + (byte)(number) $10*(number) 8 [ eorfill::x#2 eorfill::fill_column#2 eorfill::line_column#1 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::fill_column#2 eorfill::line_column#1 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Statement [82] (byte*) eorfill::fill_column#1 ← (byte*) eorfill::fill_column#2 + (byte)(number) $10*(number) 8 [ eorfill::x#2 eorfill::line_column#1 eorfill::fill_column#1 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::line_column#1 eorfill::fill_column#1 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Statement [84] (byte) eorfill::eor#1 ← (byte) eorfill::eor#2 ^ *((byte*) eorfill::line_column#2 + (byte) eorfill::y#2) [ eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::y#2 eorfill::eor#1 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::y#2 eorfill::eor#1 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:19 [ eorfill::y#2 eorfill::y#1 ]
Statement [88] (byte) abs_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 [ line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::u#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::u#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::u#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::u#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:40 [ main::x0#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:41 [ main::y0#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:42 [ main::x1#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:43 [ main::y1#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:25 [ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ]
Removing always clobbered register reg byte a as potential for zp[1]:26 [ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ]
Removing always clobbered register reg byte a as potential for zp[1]:21 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ]
Removing always clobbered register reg byte a as potential for zp[1]:22 [ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ]
Removing always clobbered register reg byte a as potential for zp[1]:44 [ main::x2#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:45 [ main::y2#0 ]
Statement [92] (byte) abs_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 [ line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::u#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::u#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::u#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::u#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:49 [ line::dx#0 ]
Statement [96] (byte) sgn_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 [ line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 sgn_u8::u#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 sgn_u8::u#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { sgn_u8::u#0 = sgn_u8::u#2 } { sgn_u8::return#0 = sgn_u8::return#4 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 sgn_u8::u#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { sgn_u8::u#0 = sgn_u8::u#2 } { sgn_u8::return#0 = sgn_u8::return#4 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 sgn_u8::u#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { sgn_u8::u#0 = sgn_u8::u#2 } { sgn_u8::return#0 = sgn_u8::return#4 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:51 [ line::dy#0 ]
Statement [100] (byte) sgn_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 [ line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 line::sx#0 sgn_u8::u#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 line::sx#0 sgn_u8::u#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { sgn_u8::u#1 = sgn_u8::u#2 } { sgn_u8::return#1 = sgn_u8::return#4 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 line::sx#0 sgn_u8::u#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { sgn_u8::u#1 = sgn_u8::u#2 } { sgn_u8::return#1 = sgn_u8::return#4 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 line::sx#0 sgn_u8::u#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { sgn_u8::u#1 = sgn_u8::u#2 } { sgn_u8::return#1 = sgn_u8::return#4 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:53 [ line::sx#0 ]
Statement [110] (byte) line::e#0 ← (byte) line::dy#0 >> (byte) 1 [ line::x#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::y2#13 line::e#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::y2#13 line::e#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::y2#13 line::e#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::y2#13 line::e#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:55 [ line::sy#0 ]
Statement [112] (byte) line::y#10 ← (byte) line::y#7 + (byte) line::sy#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::e#3 line::x#15 line::y#10 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::e#3 line::x#15 line::y#10 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::e#3 line::x#15 line::y#10 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::e#3 line::x#15 line::y#10 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:23 [ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ]
Statement [113] (byte) line::e#1 ← (byte) line::e#3 + (byte) line::dx#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [115] (byte) line::plot2_y#0 ← (byte) line::y#10 - (byte) line::sy#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [116] (byte~) line::plot2_$0 ← (byte) line::x#15 >> (byte) 3 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:56 [ line::plot2_y#0 ]
Statement [117] (byte~) line::plot2_$2 ← (byte~) line::plot2_$0 << (byte) 1 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [118] (byte*) line::plot2_column#0 ← *((const byte**) plot_column + (byte~) line::plot2_$2) [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [119] (byte~) line::plot2_$1 ← (byte) line::x#15 & (byte) 7 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 line::plot2_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 line::plot2_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 line::plot2_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 line::plot2_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [120] *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) ← *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) | *((const byte*) plot_bit + (byte~) line::plot2_$1) [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:40 [ main::x0#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:41 [ main::y0#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:42 [ main::x1#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:43 [ main::y1#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:49 [ line::dx#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:51 [ line::dy#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:53 [ line::sx#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:55 [ line::sy#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:22 [ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ]
Removing always clobbered register reg byte y as potential for zp[1]:25 [ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ]
Removing always clobbered register reg byte y as potential for zp[1]:26 [ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ]
Removing always clobbered register reg byte y as potential for zp[1]:23 [ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:44 [ main::x2#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:45 [ main::y2#0 ]
Statement [121] (byte) line::x#1 ← (byte) line::x#15 + (byte) line::sx#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::e#1 line::x#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::e#1 line::x#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::e#1 line::x#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::e#1 line::x#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [122] (byte) line::e#2 ← (byte) line::e#1 - (byte) line::dy#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::x#1 line::e#2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::x#1 line::e#2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::x#1 line::e#2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::x#1 line::e#2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [125] (byte~) line::plot3_$0 ← (byte) line::x#17 >> (byte) 3 [ line::y#10 line::x#17 line::plot3_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#10 line::x#17 line::plot3_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#10 line::x#17 line::plot3_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#10 line::x#17 line::plot3_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [126] (byte~) line::plot3_$2 ← (byte~) line::plot3_$0 << (byte) 1 [ line::y#10 line::x#17 line::plot3_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#10 line::x#17 line::plot3_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#10 line::x#17 line::plot3_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#10 line::x#17 line::plot3_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [127] (byte*) line::plot3_column#0 ← *((const byte**) plot_column + (byte~) line::plot3_$2) [ line::y#10 line::x#17 line::plot3_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#10 line::x#17 line::plot3_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#10 line::x#17 line::plot3_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#10 line::x#17 line::plot3_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [128] (byte~) line::plot3_$1 ← (byte) line::x#17 & (byte) 7 [ line::y#10 line::plot3_column#0 line::plot3_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#10 line::plot3_column#0 line::plot3_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#10 line::plot3_column#0 line::plot3_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#10 line::plot3_column#0 line::plot3_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [129] *((byte*) line::plot3_column#0 + (byte) line::y#10) ← *((byte*) line::plot3_column#0 + (byte) line::y#10) | *((const byte*) plot_bit + (byte~) line::plot3_$1) [ ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Statement [131] (byte~) line::plot1_$0 ← (byte) line::x#0 >> (byte) 3 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [132] (byte~) line::plot1_$2 ← (byte~) line::plot1_$0 << (byte) 1 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [133] (byte*) line::plot1_column#0 ← *((const byte**) plot_column + (byte~) line::plot1_$2) [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [134] (byte~) line::plot1_$1 ← (byte) line::x#0 & (byte) 7 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 line::plot1_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 line::plot1_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 line::plot1_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 line::plot1_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [135] *((byte*) line::plot1_column#0 + (byte) line::y#17) ← *((byte*) line::plot1_column#0 + (byte) line::y#17) | *((const byte*) plot_bit + (byte~) line::plot1_$1) [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:21 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ]
Statement [137] (byte) line::e1#0 ← (byte) line::dy#0 >> (byte) 1 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e1#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e1#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e1#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e1#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [139] (byte) line::y#12 ← (byte) line::y#11 + (byte) line::sy#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::e1#3 line::x#18 line::y#12 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::e1#3 line::x#18 line::y#12 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::e1#3 line::x#18 line::y#12 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::e1#3 line::x#18 line::y#12 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:24 [ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ]
Statement [140] (byte) line::e1#1 ← (byte) line::e1#3 + (byte) line::dx#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#18 line::y#12 line::e1#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#18 line::y#12 line::e1#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#18 line::y#12 line::e1#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#18 line::y#12 line::e1#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [142] (byte) line::x#19 ← (byte) line::x#18 + (byte) line::sx#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#1 line::x#19 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#1 line::x#19 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#1 line::x#19 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#1 line::x#19 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [143] (byte) line::e1#2 ← (byte) line::e1#1 - (byte) line::dy#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [144] (byte~) line::plot4_$0 ← (byte) line::x#19 >> (byte) 3 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [145] (byte~) line::plot4_$2 ← (byte~) line::plot4_$0 << (byte) 1 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [146] (byte*) line::plot4_column#0 ← *((const byte**) plot_column + (byte~) line::plot4_$2) [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [147] (byte~) line::plot4_$1 ← (byte) line::x#19 & (byte) 7 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 line::plot4_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 line::plot4_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 line::plot4_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 line::plot4_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [148] *((byte*) line::plot4_column#0 + (byte) line::y#12) ← *((byte*) line::plot4_column#0 + (byte) line::y#12) | *((const byte*) plot_bit + (byte~) line::plot4_$1) [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:24 [ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ]
Statement [150] (byte) line::e2#0 ← (byte) line::dx#0 >> (byte) 1 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e2#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e2#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e2#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e2#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [152] (byte~) line::plot5_$0 ← (byte) line::x#10 >> (byte) 3 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:27 [ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ]
Statement [153] (byte~) line::plot5_$2 ← (byte~) line::plot5_$0 << (byte) 1 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [154] (byte*) line::plot5_column#0 ← *((const byte**) plot_column + (byte~) line::plot5_$2) [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [155] (byte~) line::plot5_$1 ← (byte) line::x#10 & (byte) 7 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 line::plot5_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 line::plot5_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 line::plot5_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 line::plot5_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [156] *((byte*) line::plot5_column#0 + (byte) line::y#13) ← *((byte*) line::plot5_column#0 + (byte) line::y#13) | *((const byte*) plot_bit + (byte~) line::plot5_$1) [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:27 [ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ]
Statement [157] (byte) line::x#12 ← (byte) line::x#10 + (byte) line::sx#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::e2#3 line::x#12 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::e2#3 line::x#12 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::e2#3 line::x#12 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::e2#3 line::x#12 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [158] (byte) line::e2#1 ← (byte) line::e2#3 + (byte) line::dy#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::x#12 line::e2#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::x#12 line::e2#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::x#12 line::e2#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::x#12 line::e2#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [160] (byte) line::y#4 ← (byte) line::y#13 + (byte) line::sy#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::e2#1 line::y#4 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::e2#1 line::y#4 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::e2#1 line::y#4 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::e2#1 line::y#4 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [161] (byte) line::e2#2 ← (byte) line::e2#1 - (byte) line::dx#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::y#4 line::e2#2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::y#4 line::e2#2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::y#4 line::e2#2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::y#4 line::e2#2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [164] (byte~) line::plot6_$0 ← (byte) line::x#12 >> (byte) 3 [ line::x#12 line::y#15 line::plot6_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#12 line::y#15 line::plot6_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#12 line::y#15 line::plot6_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#12 line::y#15 line::plot6_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [165] (byte~) line::plot6_$2 ← (byte~) line::plot6_$0 << (byte) 1 [ line::x#12 line::y#15 line::plot6_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#12 line::y#15 line::plot6_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#12 line::y#15 line::plot6_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#12 line::y#15 line::plot6_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [166] (byte*) line::plot6_column#0 ← *((const byte**) plot_column + (byte~) line::plot6_$2) [ line::x#12 line::y#15 line::plot6_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#12 line::y#15 line::plot6_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#12 line::y#15 line::plot6_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#12 line::y#15 line::plot6_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [167] (byte~) line::plot6_$1 ← (byte) line::x#12 & (byte) 7 [ line::y#15 line::plot6_column#0 line::plot6_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#15 line::plot6_column#0 line::plot6_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#15 line::plot6_column#0 line::plot6_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#15 line::plot6_column#0 line::plot6_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [168] *((byte*) line::plot6_column#0 + (byte) line::y#15) ← *((byte*) line::plot6_column#0 + (byte) line::y#15) | *((const byte*) plot_bit + (byte~) line::plot6_$1) [ ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Statement [178] (byte) abs_u8::return#2 ← - (byte) abs_u8::u#2 [ abs_u8::return#2 ] ( main:5::line:33::abs_u8:89 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::return#2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:40::abs_u8:89 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::return#2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:45::abs_u8:89 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::return#2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:33::abs_u8:93 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::return#2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  main:5::line:40::abs_u8:93 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::return#2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  main:5::line:45::abs_u8:93 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::return#2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  ) always clobbers reg byte a 
Statement [182] if((word) memset::num#4<=(byte) 0) goto memset::@return [ memset::num#4 memset::str#5 memset::c#6 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::num#4 memset::str#5 memset::c#6 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::num#4 memset::str#5 memset::c#6 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::num#4 memset::str#5 memset::c#6 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::num#4 memset::str#5 memset::c#6 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:35 [ memset::c#6 ]
Statement [183] (byte*) memset::end#0 ← (byte*)(void*) memset::str#5 + (word) memset::num#4 [ memset::str#5 memset::c#6 memset::end#0 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::str#5 memset::c#6 memset::end#0 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::str#5 memset::c#6 memset::end#0 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::str#5 memset::c#6 memset::end#0 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::str#5 memset::c#6 memset::end#0 ] { }  ) always clobbers reg byte a 
Statement [184] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#5 [ memset::c#6 memset::end#0 memset::dst#4 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#4 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#4 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#4 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::c#6 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [186] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 [ memset::c#6 memset::end#0 memset::dst#2 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::c#6 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [188] *((byte*) memset::dst#2) ← (byte) memset::c#6 [ memset::c#6 memset::end#0 memset::dst#2 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::c#6 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:35 [ memset::c#6 ]
Statement [190] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [191] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [192] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [193] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [194] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [199] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [200] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [201] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [202] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [203] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [206] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK [ canvas_show_memory ] (  [ canvas_show_memory ] { { kbhit::return#0 = kbhit::return#2 } }  ) always clobbers reg byte a 
Statement [212] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_2::toD0181_return#0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [213] (volatile byte) canvas_show_flag ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [214] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [215] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [216] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [218] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (volatile byte) canvas_show_memory [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [219] *((const nomodify byte*) kbhit::CIA1_PORT_A) ← (byte) 0 [ ] ( kbhit:207 [ canvas_show_memory ] { { kbhit::return#0 = kbhit::return#2 } }  ) always clobbers reg byte a 
Statement [220] (byte) kbhit::return#0 ← ~ *((const nomodify byte*) kbhit::CIA1_PORT_B) [ kbhit::return#0 ] ( kbhit:207 [ canvas_show_memory kbhit::return#0 ] { { kbhit::return#0 = kbhit::return#2 } }  ) always clobbers reg byte a 
Statement [222] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) DARK_GREY [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [224] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_1::toD0181_return#0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [225] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [226] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [227] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2() [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] (volatile byte) canvas_show_memory ← (const byte) toD0181_return#0 [ canvas_show_memory ] (  [ canvas_show_memory ] { }  ) always clobbers reg byte a 
Statement [3] (volatile byte) canvas_show_flag ← (byte) 0 [ canvas_show_memory canvas_show_flag ] (  [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [15] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK [ canvas_show_memory canvas_show_flag ] ( main:5 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [16] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← (const nomodify byte) BLACK [ canvas_show_memory canvas_show_flag ] ( main:5 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [49] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) RED [ canvas_show_memory canvas_show_flag main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] { }  ) always clobbers reg byte a 
Statement [50] if((byte) 0!=(volatile byte) canvas_show_flag) goto main::@9 [ canvas_show_memory canvas_show_flag main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] { }  ) always clobbers reg byte a 
Statement [51] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] ( main:5 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Statement [52] (byte*) eorfill::canvas#0 ← (byte*) main::canvas#10 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::canvas#0 ] ( main:5 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::canvas#0 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Statement [54] (word) main::canvas#1 ← (byte*) main::canvas#10 ^ (const nomodify byte*) CANVAS1^(const nomodify byte*) CANVAS2 [ canvas_show_memory main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] ( main:5 [ canvas_show_memory main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] { }  ) always clobbers reg byte a 
Statement [57] (volatile byte) canvas_show_memory ← (volatile byte) canvas_show_memory ^ (const byte) main::toD0181_return#0^(const byte) main::toD0182_return#0 [ canvas_show_memory main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] ( main:5 [ canvas_show_memory main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] { }  ) always clobbers reg byte a 
Statement [58] (volatile byte) canvas_show_flag ← (byte) 1 [ canvas_show_memory canvas_show_flag main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#1 ] { }  ) always clobbers reg byte a 
Statement [60] (byte*) main::canvas#19 ← (byte*)(word) main::canvas#1 [ canvas_show_memory canvas_show_flag main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#19 ] ( main:5 [ canvas_show_memory canvas_show_flag main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 main::canvas#19 ] { }  ) always clobbers reg byte a 
Statement [64] (byte*) main::cols#1 ← (byte*) main::cols#5 + (byte) $28 [ canvas_show_memory canvas_show_flag main::y#2 main::screen#5 main::cols#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::screen#5 main::cols#1 ] { }  ) always clobbers reg byte a 
Statement [65] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#1 main::screen#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#1 main::screen#1 ] { }  ) always clobbers reg byte a 
Statement [67] *((byte*) main::cols#5 + (byte) main::x#2) ← (const nomodify byte) WHITE [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#2 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#2 ] { }  ) always clobbers reg byte a 
Statement [68] *((byte*) main::screen#5 + (byte) main::x#2) ← (byte) main::c#2 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#2 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#2 ] { }  ) always clobbers reg byte a 
Statement [69] (byte) main::c#1 ← (byte) main::c#2 + (byte) $10 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#1 ] ( main:5 [ canvas_show_memory canvas_show_flag main::y#2 main::cols#5 main::screen#5 main::x#2 main::c#1 ] { }  ) always clobbers reg byte a 
Statement [77] (byte) eorfill::eor#0 ← *((byte*) eorfill::line_column#2) [ eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::eor#0 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::eor#0 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a reg byte y 
Statement [78] *((byte*) eorfill::fill_column#2) ← (byte) eorfill::eor#0 [ eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::eor#0 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::eor#0 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte y 
Statement [81] (byte*) eorfill::line_column#1 ← (byte*) eorfill::line_column#2 + (byte)(number) $10*(number) 8 [ eorfill::x#2 eorfill::fill_column#2 eorfill::line_column#1 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::fill_column#2 eorfill::line_column#1 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Statement [82] (byte*) eorfill::fill_column#1 ← (byte*) eorfill::fill_column#2 + (byte)(number) $10*(number) 8 [ eorfill::x#2 eorfill::line_column#1 eorfill::fill_column#1 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::line_column#1 eorfill::fill_column#1 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Statement [84] (byte) eorfill::eor#1 ← (byte) eorfill::eor#2 ^ *((byte*) eorfill::line_column#2 + (byte) eorfill::y#2) [ eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::y#2 eorfill::eor#1 ] ( main:5::eorfill:53 [ canvas_show_memory main::canvas#10 main::p0_idx#1 main::p1_idx#1 main::p2_idx#1 eorfill::x#2 eorfill::line_column#2 eorfill::fill_column#2 eorfill::y#2 eorfill::eor#1 ] { { eorfill::canvas#0 = main::canvas#10 } }  ) always clobbers reg byte a 
Statement [88] (byte) abs_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 [ line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::u#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::u#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::u#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::u#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  ) always clobbers reg byte a 
Statement [92] (byte) abs_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 [ line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::u#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::u#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::u#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::u#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  ) always clobbers reg byte a 
Statement [96] (byte) sgn_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 [ line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 sgn_u8::u#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 sgn_u8::u#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { sgn_u8::u#0 = sgn_u8::u#2 } { sgn_u8::return#0 = sgn_u8::return#4 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 sgn_u8::u#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { sgn_u8::u#0 = sgn_u8::u#2 } { sgn_u8::return#0 = sgn_u8::return#4 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 sgn_u8::u#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { sgn_u8::u#0 = sgn_u8::u#2 } { sgn_u8::return#0 = sgn_u8::return#4 } }  ) always clobbers reg byte a 
Statement [100] (byte) sgn_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 [ line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 line::sx#0 sgn_u8::u#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 line::sx#0 sgn_u8::u#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { sgn_u8::u#1 = sgn_u8::u#2 } { sgn_u8::return#1 = sgn_u8::return#4 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 line::sx#0 sgn_u8::u#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { sgn_u8::u#1 = sgn_u8::u#2 } { sgn_u8::return#1 = sgn_u8::return#4 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 line::dy#0 line::sx#0 sgn_u8::u#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { sgn_u8::u#1 = sgn_u8::u#2 } { sgn_u8::return#1 = sgn_u8::return#4 } }  ) always clobbers reg byte a 
Statement [110] (byte) line::e#0 ← (byte) line::dy#0 >> (byte) 1 [ line::x#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::y2#13 line::e#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::y2#13 line::e#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::y2#13 line::e#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::y2#13 line::e#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [112] (byte) line::y#10 ← (byte) line::y#7 + (byte) line::sy#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::e#3 line::x#15 line::y#10 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::e#3 line::x#15 line::y#10 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::e#3 line::x#15 line::y#10 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::e#3 line::x#15 line::y#10 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [113] (byte) line::e#1 ← (byte) line::e#3 + (byte) line::dx#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [115] (byte) line::plot2_y#0 ← (byte) line::y#10 - (byte) line::sy#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [116] (byte~) line::plot2_$0 ← (byte) line::x#15 >> (byte) 3 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [117] (byte~) line::plot2_$2 ← (byte~) line::plot2_$0 << (byte) 1 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [118] (byte*) line::plot2_column#0 ← *((const byte**) plot_column + (byte~) line::plot2_$2) [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [119] (byte~) line::plot2_$1 ← (byte) line::x#15 & (byte) 7 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 line::plot2_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 line::plot2_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 line::plot2_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 line::plot2_y#0 line::plot2_column#0 line::plot2_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [120] *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) ← *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) | *((const byte*) plot_bit + (byte~) line::plot2_$1) [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::x#15 line::y#10 line::e#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Statement [121] (byte) line::x#1 ← (byte) line::x#15 + (byte) line::sx#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::e#1 line::x#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::e#1 line::x#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::e#1 line::x#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::e#1 line::x#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [122] (byte) line::e#2 ← (byte) line::e#1 - (byte) line::dy#0 [ line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::x#1 line::e#2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::x#1 line::e#2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::x#1 line::e#2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y2#13 line::y#10 line::x#1 line::e#2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [125] (byte~) line::plot3_$0 ← (byte) line::x#17 >> (byte) 3 [ line::y#10 line::x#17 line::plot3_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#10 line::x#17 line::plot3_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#10 line::x#17 line::plot3_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#10 line::x#17 line::plot3_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [126] (byte~) line::plot3_$2 ← (byte~) line::plot3_$0 << (byte) 1 [ line::y#10 line::x#17 line::plot3_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#10 line::x#17 line::plot3_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#10 line::x#17 line::plot3_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#10 line::x#17 line::plot3_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [127] (byte*) line::plot3_column#0 ← *((const byte**) plot_column + (byte~) line::plot3_$2) [ line::y#10 line::x#17 line::plot3_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#10 line::x#17 line::plot3_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#10 line::x#17 line::plot3_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#10 line::x#17 line::plot3_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [128] (byte~) line::plot3_$1 ← (byte) line::x#17 & (byte) 7 [ line::y#10 line::plot3_column#0 line::plot3_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#10 line::plot3_column#0 line::plot3_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#10 line::plot3_column#0 line::plot3_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#10 line::plot3_column#0 line::plot3_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [129] *((byte*) line::plot3_column#0 + (byte) line::y#10) ← *((byte*) line::plot3_column#0 + (byte) line::y#10) | *((const byte*) plot_bit + (byte~) line::plot3_$1) [ ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Statement [131] (byte~) line::plot1_$0 ← (byte) line::x#0 >> (byte) 3 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [132] (byte~) line::plot1_$2 ← (byte~) line::plot1_$0 << (byte) 1 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [133] (byte*) line::plot1_column#0 ← *((const byte**) plot_column + (byte~) line::plot1_$2) [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [134] (byte~) line::plot1_$1 ← (byte) line::x#0 & (byte) 7 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 line::plot1_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 line::plot1_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 line::plot1_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::plot1_column#0 line::plot1_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [135] *((byte*) line::plot1_column#0 + (byte) line::y#17) ← *((byte*) line::plot1_column#0 + (byte) line::y#17) | *((const byte*) plot_bit + (byte~) line::plot1_$1) [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Statement [137] (byte) line::e1#0 ← (byte) line::dy#0 >> (byte) 1 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e1#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e1#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e1#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e1#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [139] (byte) line::y#12 ← (byte) line::y#11 + (byte) line::sy#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::e1#3 line::x#18 line::y#12 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::e1#3 line::x#18 line::y#12 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::e1#3 line::x#18 line::y#12 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::e1#3 line::x#18 line::y#12 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [140] (byte) line::e1#1 ← (byte) line::e1#3 + (byte) line::dx#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#18 line::y#12 line::e1#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#18 line::y#12 line::e1#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#18 line::y#12 line::e1#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#18 line::y#12 line::e1#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [142] (byte) line::x#19 ← (byte) line::x#18 + (byte) line::sx#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#1 line::x#19 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#1 line::x#19 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#1 line::x#19 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#1 line::x#19 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [143] (byte) line::e1#2 ← (byte) line::e1#1 - (byte) line::dy#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [144] (byte~) line::plot4_$0 ← (byte) line::x#19 >> (byte) 3 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [145] (byte~) line::plot4_$2 ← (byte~) line::plot4_$0 << (byte) 1 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [146] (byte*) line::plot4_column#0 ← *((const byte**) plot_column + (byte~) line::plot4_$2) [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [147] (byte~) line::plot4_$1 ← (byte) line::x#19 & (byte) 7 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 line::plot4_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 line::plot4_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 line::plot4_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 line::plot4_column#0 line::plot4_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [148] *((byte*) line::plot4_column#0 + (byte) line::y#12) ← *((byte*) line::plot4_column#0 + (byte) line::y#12) | *((const byte*) plot_bit + (byte~) line::plot4_$1) [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#12 line::e1#2 line::x#19 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Statement [150] (byte) line::e2#0 ← (byte) line::dx#0 >> (byte) 1 [ line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e2#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e2#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e2#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#17 line::e2#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [152] (byte~) line::plot5_$0 ← (byte) line::x#10 >> (byte) 3 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [153] (byte~) line::plot5_$2 ← (byte~) line::plot5_$0 << (byte) 1 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [154] (byte*) line::plot5_column#0 ← *((const byte**) plot_column + (byte~) line::plot5_$2) [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [155] (byte~) line::plot5_$1 ← (byte) line::x#10 & (byte) 7 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 line::plot5_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 line::plot5_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 line::plot5_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 line::plot5_column#0 line::plot5_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [156] *((byte*) line::plot5_column#0 + (byte) line::y#13) ← *((byte*) line::plot5_column#0 + (byte) line::y#13) | *((const byte*) plot_bit + (byte~) line::plot5_$1) [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#10 line::y#13 line::e2#3 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Statement [157] (byte) line::x#12 ← (byte) line::x#10 + (byte) line::sx#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::e2#3 line::x#12 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::e2#3 line::x#12 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::e2#3 line::x#12 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::e2#3 line::x#12 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [158] (byte) line::e2#1 ← (byte) line::e2#3 + (byte) line::dy#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::x#12 line::e2#1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::x#12 line::e2#1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::x#12 line::e2#1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::y#13 line::x#12 line::e2#1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [160] (byte) line::y#4 ← (byte) line::y#13 + (byte) line::sy#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::e2#1 line::y#4 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::e2#1 line::y#4 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::e2#1 line::y#4 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::e2#1 line::y#4 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [161] (byte) line::e2#2 ← (byte) line::e2#1 - (byte) line::dx#0 [ line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::y#4 line::e2#2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::y#4 line::e2#2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::y#4 line::e2#2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x2#15 line::dx#0 line::dy#0 line::sx#0 line::sy#0 line::x#12 line::y#4 line::e2#2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [164] (byte~) line::plot6_$0 ← (byte) line::x#12 >> (byte) 3 [ line::x#12 line::y#15 line::plot6_$0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#12 line::y#15 line::plot6_$0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#12 line::y#15 line::plot6_$0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#12 line::y#15 line::plot6_$0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [165] (byte~) line::plot6_$2 ← (byte~) line::plot6_$0 << (byte) 1 [ line::x#12 line::y#15 line::plot6_$2 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#12 line::y#15 line::plot6_$2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#12 line::y#15 line::plot6_$2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#12 line::y#15 line::plot6_$2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [166] (byte*) line::plot6_column#0 ← *((const byte**) plot_column + (byte~) line::plot6_$2) [ line::x#12 line::y#15 line::plot6_column#0 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#12 line::y#15 line::plot6_column#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#12 line::y#15 line::plot6_column#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#12 line::y#15 line::plot6_column#0 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [167] (byte~) line::plot6_$1 ← (byte) line::x#12 & (byte) 7 [ line::y#15 line::plot6_column#0 line::plot6_$1 ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::y#15 line::plot6_column#0 line::plot6_$1 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::y#15 line::plot6_column#0 line::plot6_$1 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::y#15 line::plot6_column#0 line::plot6_$1 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a 
Statement [168] *((byte*) line::plot6_column#0 + (byte) line::y#15) ← *((byte*) line::plot6_column#0 + (byte) line::y#15) | *((const byte*) plot_bit + (byte~) line::plot6_$1) [ ] ( main:5::line:33 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } }  main:5::line:40 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } }  main:5::line:45 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } }  ) always clobbers reg byte a reg byte y 
Statement [178] (byte) abs_u8::return#2 ← - (byte) abs_u8::u#2 [ abs_u8::return#2 ] ( main:5::line:33::abs_u8:89 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::return#2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:40::abs_u8:89 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::return#2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:45::abs_u8:89 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 abs_u8::return#2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { abs_u8::u#0 = abs_u8::u#2 } { abs_u8::return#0 = abs_u8::return#4 } }  main:5::line:33::abs_u8:93 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x1#0 main::y1#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::return#2 ] { { line::x#0 = line::x1#0 main::x0#0 } { line::y#0 = line::y1#0 main::y0#0 } { line::x2#0 = line::x2#15 main::x1#0 } { line::y2#0 = line::y2#10 main::y1#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  main:5::line:40::abs_u8:93 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 main::x0#0 main::y0#0 main::x2#0 main::y2#0 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::return#2 ] { { line::x#0 = line::x1#1 main::x1#0 } { line::y#0 = line::y1#1 main::y1#0 } { line::x2#1 = line::x2#15 main::x2#0 } { line::y2#1 = line::y2#10 main::y2#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  main:5::line:45::abs_u8:93 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 line::x#0 line::y#0 line::x2#15 line::y2#10 line::dx#0 abs_u8::return#2 ] { { line::x#0 = line::x1#2 main::x2#0 } { line::y#0 = line::y1#2 main::y2#0 } { line::x2#15 = line::x2#2 main::x0#0 } { line::y2#10 = line::y2#2 main::y0#0 } { abs_u8::u#1 = abs_u8::u#2 } { abs_u8::return#1 = abs_u8::return#4 } }  ) always clobbers reg byte a 
Statement [182] if((word) memset::num#4<=(byte) 0) goto memset::@return [ memset::num#4 memset::str#5 memset::c#6 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::num#4 memset::str#5 memset::c#6 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::num#4 memset::str#5 memset::c#6 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::num#4 memset::str#5 memset::c#6 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::num#4 memset::str#5 memset::c#6 ] { }  ) always clobbers reg byte a 
Statement [183] (byte*) memset::end#0 ← (byte*)(void*) memset::str#5 + (word) memset::num#4 [ memset::str#5 memset::c#6 memset::end#0 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::str#5 memset::c#6 memset::end#0 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::str#5 memset::c#6 memset::end#0 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::str#5 memset::c#6 memset::end#0 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::str#5 memset::c#6 memset::end#0 ] { }  ) always clobbers reg byte a 
Statement [184] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#5 [ memset::c#6 memset::end#0 memset::dst#4 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#4 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#4 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#4 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::c#6 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [186] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 [ memset::c#6 memset::end#0 memset::dst#2 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::c#6 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [188] *((byte*) memset::dst#2) ← (byte) memset::c#6 [ memset::c#6 memset::end#0 memset::dst#2 ] ( main:5::memset:8 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:10 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:12 [ canvas_show_memory canvas_show_flag memset::c#6 memset::end#0 memset::dst#2 ] { }  main:5::memset:24 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 memset::c#6 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [190] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [191] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [192] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [193] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [194] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START [ ] ( main:5::clock_start:22 [ canvas_show_memory canvas_show_flag main::p0_idx#2 main::p1_idx#2 main::p2_idx#2 main::canvas#10 ] { }  ) always clobbers reg byte a 
Statement [199] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [200] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [201] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [202] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [203] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() [ ] ( main:5::setup_irq:17 [ canvas_show_memory canvas_show_flag ] { }  ) always clobbers reg byte a 
Statement [206] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK [ canvas_show_memory ] (  [ canvas_show_memory ] { { kbhit::return#0 = kbhit::return#2 } }  ) always clobbers reg byte a 
Statement [212] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_2::toD0181_return#0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [213] (volatile byte) canvas_show_flag ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [214] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [215] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [216] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [218] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (volatile byte) canvas_show_memory [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [219] *((const nomodify byte*) kbhit::CIA1_PORT_A) ← (byte) 0 [ ] ( kbhit:207 [ canvas_show_memory ] { { kbhit::return#0 = kbhit::return#2 } }  ) always clobbers reg byte a 
Statement [220] (byte) kbhit::return#0 ← ~ *((const nomodify byte*) kbhit::CIA1_PORT_B) [ kbhit::return#0 ] ( kbhit:207 [ canvas_show_memory kbhit::return#0 ] { { kbhit::return#0 = kbhit::return#2 } }  ) always clobbers reg byte a 
Statement [222] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) DARK_GREY [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [224] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_1::toD0181_return#0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [225] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [226] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [227] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2() [ ] (  [ ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::y#2 main::y#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[2]:3 [ main::cols#5 main::cols#1 ] : zp[2]:3 , 
Potential registers zp[2]:5 [ main::screen#5 main::screen#1 ] : zp[2]:5 , 
Potential registers zp[1]:7 [ main::p0_idx#2 main::p0_idx#1 ] : zp[1]:7 , reg byte x , 
Potential registers zp[1]:8 [ main::p1_idx#2 main::p1_idx#1 ] : zp[1]:8 , reg byte x , 
Potential registers zp[1]:9 [ main::p2_idx#2 main::p2_idx#1 ] : zp[1]:9 , reg byte x , 
Potential registers zp[2]:10 [ main::canvas#10 main::canvas#19 ] : zp[2]:10 , 
Potential registers zp[1]:12 [ main::x#2 main::x#1 ] : zp[1]:12 , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ main::c#2 main::c#4 main::c#1 ] : zp[1]:13 , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ eorfill::x#2 eorfill::x#1 ] : zp[1]:14 , reg byte x , 
Potential registers zp[2]:15 [ eorfill::line_column#2 eorfill::line_column#1 ] : zp[2]:15 , 
Potential registers zp[2]:17 [ eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ] : zp[2]:17 , 
Potential registers zp[1]:19 [ eorfill::y#2 eorfill::y#1 ] : zp[1]:19 , reg byte x , reg byte y , 
Potential registers zp[1]:20 [ eorfill::eor#2 eorfill::eor#0 eorfill::eor#1 ] : zp[1]:20 , reg byte a , reg byte x , 
Potential registers zp[1]:21 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ] : zp[1]:21 , reg byte x , 
Potential registers zp[1]:22 [ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ] : zp[1]:22 , reg byte x , 
Potential registers zp[1]:23 [ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ] : zp[1]:23 , reg byte x , 
Potential registers zp[1]:24 [ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ] : zp[1]:24 , reg byte x , 
Potential registers zp[1]:25 [ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ] : zp[1]:25 , reg byte x , 
Potential registers zp[1]:26 [ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ] : zp[1]:26 , reg byte x , 
Potential registers zp[1]:27 [ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ] : zp[1]:27 , reg byte x , 
Potential registers zp[1]:28 [ sgn_u8::u#2 sgn_u8::u#0 sgn_u8::u#1 ] : zp[1]:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:29 [ sgn_u8::return#4 ] : zp[1]:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:30 [ abs_u8::return#4 abs_u8::return#2 abs_u8::u#2 abs_u8::u#0 abs_u8::u#1 ] : zp[1]:30 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:31 [ memset::num#4 ] : zp[2]:31 , 
Potential registers zp[2]:33 [ memset::str#5 ] : zp[2]:33 , 
Potential registers zp[1]:35 [ memset::c#6 ] : zp[1]:35 , reg byte x , 
Potential registers zp[2]:36 [ memset::dst#2 memset::dst#4 memset::dst#1 ] : zp[2]:36 , 
Potential registers zp[1]:38 [ canvas_show_memory ] : zp[1]:38 , 
Potential registers zp[1]:39 [ canvas_show_flag ] : zp[1]:39 , 
Potential registers zp[1]:40 [ main::x0#0 ] : zp[1]:40 , reg byte x , 
Potential registers zp[1]:41 [ main::y0#0 ] : zp[1]:41 , reg byte x , 
Potential registers zp[1]:42 [ main::x1#0 ] : zp[1]:42 , reg byte x , 
Potential registers zp[1]:43 [ main::y1#0 ] : zp[1]:43 , reg byte x , 
Potential registers zp[1]:44 [ main::x2#0 ] : zp[1]:44 , reg byte x , 
Potential registers zp[1]:45 [ main::y2#0 ] : zp[1]:45 , reg byte x , 
Potential registers zp[2]:46 [ main::canvas#1 ] : zp[2]:46 , 
Potential registers zp[1]:48 [ abs_u8::return#0 ] : zp[1]:48 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:49 [ line::dx#0 ] : zp[1]:49 , reg byte x , 
Potential registers zp[1]:50 [ abs_u8::return#1 ] : zp[1]:50 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:51 [ line::dy#0 ] : zp[1]:51 , reg byte x , 
Potential registers zp[1]:52 [ sgn_u8::return#0 ] : zp[1]:52 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:53 [ line::sx#0 ] : zp[1]:53 , reg byte x , 
Potential registers zp[1]:54 [ sgn_u8::return#1 ] : zp[1]:54 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:55 [ line::sy#0 ] : zp[1]:55 , reg byte x , 
Potential registers zp[1]:56 [ line::plot2_y#0 ] : zp[1]:56 , reg byte x , reg byte y , 
Potential registers zp[1]:57 [ line::plot2_$0 ] : zp[1]:57 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:58 [ line::plot2_$2 ] : zp[1]:58 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:59 [ line::plot2_column#0 ] : zp[2]:59 , 
Potential registers zp[1]:61 [ line::plot2_$1 ] : zp[1]:61 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:62 [ line::plot3_$0 ] : zp[1]:62 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:63 [ line::plot3_$2 ] : zp[1]:63 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:64 [ line::plot3_column#0 ] : zp[2]:64 , 
Potential registers zp[1]:66 [ line::plot3_$1 ] : zp[1]:66 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:67 [ line::plot1_$0 ] : zp[1]:67 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:68 [ line::plot1_$2 ] : zp[1]:68 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:69 [ line::plot1_column#0 ] : zp[2]:69 , 
Potential registers zp[1]:71 [ line::plot1_$1 ] : zp[1]:71 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:72 [ line::plot4_$0 ] : zp[1]:72 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:73 [ line::plot4_$2 ] : zp[1]:73 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:74 [ line::plot4_column#0 ] : zp[2]:74 , 
Potential registers zp[1]:76 [ line::plot4_$1 ] : zp[1]:76 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:77 [ line::plot5_$0 ] : zp[1]:77 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:78 [ line::plot5_$2 ] : zp[1]:78 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:79 [ line::plot5_column#0 ] : zp[2]:79 , 
Potential registers zp[1]:81 [ line::plot5_$1 ] : zp[1]:81 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:82 [ line::plot6_$0 ] : zp[1]:82 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:83 [ line::plot6_$2 ] : zp[1]:83 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:84 [ line::plot6_column#0 ] : zp[2]:84 , 
Potential registers zp[1]:86 [ line::plot6_$1 ] : zp[1]:86 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:87 [ sgn_u8::$0 ] : zp[1]:87 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:88 [ abs_u8::$0 ] : zp[1]:88 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:89 [ memset::end#0 ] : zp[2]:89 , 
Potential registers zp[1]:91 [ kbhit::return#2 ] : zp[1]:91 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:92 [ irq_bottom_2::$0 ] : zp[1]:92 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:93 [ kbhit::return#0 ] : zp[1]:93 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [line] 2,742,774.47: zp[1]:26 [ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ] 2,114,410.38: zp[1]:24 [ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ] 920,669.08: zp[1]:25 [ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ] 514,054.88: zp[1]:27 [ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ] 496,951.89: zp[1]:23 [ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ] 200,002: zp[1]:57 [ line::plot2_$0 ] 200,002: zp[1]:58 [ line::plot2_$2 ] 200,002: zp[1]:61 [ line::plot2_$1 ] 200,002: zp[1]:72 [ line::plot4_$0 ] 200,002: zp[1]:73 [ line::plot4_$2 ] 200,002: zp[1]:76 [ line::plot4_$1 ] 200,002: zp[1]:77 [ line::plot5_$0 ] 200,002: zp[1]:78 [ line::plot5_$2 ] 200,002: zp[1]:81 [ line::plot5_$1 ] 150,001.5: zp[2]:59 [ line::plot2_column#0 ] 150,001.5: zp[2]:74 [ line::plot4_column#0 ] 150,001.5: zp[2]:79 [ line::plot5_column#0 ] 60,000.6: zp[1]:56 [ line::plot2_y#0 ] 23,672.84: zp[1]:55 [ line::sy#0 ] 22,285.86: zp[1]:51 [ line::dy#0 ] 19,462.81: zp[1]:49 [ line::dx#0 ] 8,501.52: zp[1]:22 [ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ] 5,135.69: zp[1]:53 [ line::sx#0 ] 3,915.62: zp[1]:21 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ] 2,002: zp[1]:62 [ line::plot3_$0 ] 2,002: zp[1]:63 [ line::plot3_$2 ] 2,002: zp[1]:66 [ line::plot3_$1 ] 2,002: zp[1]:67 [ line::plot1_$0 ] 2,002: zp[1]:68 [ line::plot1_$2 ] 2,002: zp[1]:71 [ line::plot1_$1 ] 2,002: zp[1]:82 [ line::plot6_$0 ] 2,002: zp[1]:83 [ line::plot6_$2 ] 2,002: zp[1]:86 [ line::plot6_$1 ] 1,501.5: zp[2]:64 [ line::plot3_column#0 ] 1,501.5: zp[2]:69 [ line::plot1_column#0 ] 1,501.5: zp[2]:84 [ line::plot6_column#0 ] 
Uplift Scope [eorfill] 3,250,003.25: zp[1]:19 [ eorfill::y#2 eorfill::y#1 ] 2,200,004: zp[1]:20 [ eorfill::eor#2 eorfill::eor#0 eorfill::eor#1 ] 230,652.5: zp[2]:17 [ eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ] 227,275: zp[1]:14 [ eorfill::x#2 eorfill::x#1 ] 211,112.22: zp[2]:15 [ eorfill::line_column#2 eorfill::line_column#1 ] 
Uplift Scope [memset] 335,672.33: zp[2]:36 [ memset::dst#2 memset::dst#4 memset::dst#1 ] 16,833.67: zp[2]:89 [ memset::end#0 ] 12,500.12: zp[1]:35 [ memset::c#6 ] 1,001: zp[2]:31 [ memset::num#4 ] 0: zp[2]:33 [ memset::str#5 ] 
Uplift Scope [abs_u8] 40,175.33: zp[1]:30 [ abs_u8::return#4 abs_u8::return#2 abs_u8::u#2 abs_u8::u#0 abs_u8::u#1 ] 20,002: zp[1]:88 [ abs_u8::$0 ] 2,002: zp[1]:48 [ abs_u8::return#0 ] 2,002: zp[1]:50 [ abs_u8::return#1 ] 
Uplift Scope [sgn_u8] 20,002: zp[1]:87 [ sgn_u8::$0 ] 16,007: zp[1]:28 [ sgn_u8::u#2 sgn_u8::u#0 sgn_u8::u#1 ] 2,002: zp[1]:52 [ sgn_u8::return#0 ] 2,002: zp[1]:54 [ sgn_u8::return#1 ] 500.5: zp[1]:29 [ sgn_u8::return#4 ] 
Uplift Scope [main] 3,003: zp[1]:12 [ main::x#2 main::x#1 ] 1,979: zp[1]:13 [ main::c#2 main::c#4 main::c#1 ] 238.73: zp[1]:2 [ main::y#2 main::y#1 ] 221.3: zp[2]:5 [ main::screen#5 main::screen#1 ] 210.91: zp[2]:10 [ main::canvas#10 main::canvas#19 ] 201: zp[2]:3 [ main::cols#5 main::cols#1 ] 43.29: zp[1]:44 [ main::x2#0 ] 43.29: zp[1]:45 [ main::y2#0 ] 33.67: zp[1]:42 [ main::x1#0 ] 33.67: zp[1]:43 [ main::y1#0 ] 29.97: zp[1]:9 [ main::p2_idx#2 main::p2_idx#1 ] 29.39: zp[1]:8 [ main::p1_idx#2 main::p1_idx#1 ] 29.01: zp[1]:7 [ main::p0_idx#2 main::p0_idx#1 ] 16.83: zp[1]:40 [ main::x0#0 ] 16.83: zp[1]:41 [ main::y0#0 ] 16.83: zp[2]:46 [ main::canvas#1 ] 
Uplift Scope [] 18.75: zp[1]:39 [ canvas_show_flag ] 2.86: zp[1]:38 [ canvas_show_memory ] 
Uplift Scope [kbhit] 4.33: zp[1]:93 [ kbhit::return#0 ] 4: zp[1]:91 [ kbhit::return#2 ] 
Uplift Scope [irq_bottom_2] 4: zp[1]:92 [ irq_bottom_2::$0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [clock] 
Uplift Scope [clock_start] 
Uplift Scope [RADIX] 
Uplift Scope [textcolor] 
Uplift Scope [printf_format_number] 
Uplift Scope [printf_buffer_number] 
Uplift Scope [printf_format_string] 
Uplift Scope [setup_irq] 
Uplift Scope [irq_bottom_1] 

Uplifting [eorfill] best 131739 combination reg byte y [ eorfill::y#2 eorfill::y#1 ] reg byte a [ eorfill::eor#2 eorfill::eor#0 eorfill::eor#1 ] zp[2]:17 [ eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ] reg byte x [ eorfill::x#2 eorfill::x#1 ] zp[2]:15 [ eorfill::line_column#2 eorfill::line_column#1 ] 
Uplifting [memset] best 131627 combination zp[2]:36 [ memset::dst#2 memset::dst#4 memset::dst#1 ] zp[2]:89 [ memset::end#0 ] reg byte x [ memset::c#6 ] zp[2]:31 [ memset::num#4 ] zp[2]:33 [ memset::str#5 ] 
Uplifting [abs_u8] best 131590 combination reg byte a [ abs_u8::return#4 abs_u8::return#2 abs_u8::u#2 abs_u8::u#0 abs_u8::u#1 ] reg byte x [ abs_u8::$0 ] reg byte a [ abs_u8::return#0 ] reg byte a [ abs_u8::return#1 ] 
Limited combination testing to 100 combinations of 256 possible.
Uplifting [sgn_u8] best 131563 combination reg byte a [ sgn_u8::$0 ] reg byte a [ sgn_u8::u#2 sgn_u8::u#0 sgn_u8::u#1 ] reg byte a [ sgn_u8::return#0 ] reg byte a [ sgn_u8::return#1 ] zp[1]:29 [ sgn_u8::return#4 ] 
Limited combination testing to 100 combinations of 1024 possible.
Uplifting [main] best 129533 combination reg byte y [ main::x#2 main::x#1 ] reg byte x [ main::c#2 main::c#4 main::c#1 ] zp[1]:2 [ main::y#2 main::y#1 ] zp[2]:5 [ main::screen#5 main::screen#1 ] zp[2]:10 [ main::canvas#10 main::canvas#19 ] zp[2]:3 [ main::cols#5 main::cols#1 ] zp[1]:44 [ main::x2#0 ] zp[1]:45 [ main::y2#0 ] zp[1]:42 [ main::x1#0 ] zp[1]:43 [ main::y1#0 ] zp[1]:9 [ main::p2_idx#2 main::p2_idx#1 ] zp[1]:8 [ main::p1_idx#2 main::p1_idx#1 ] zp[1]:7 [ main::p0_idx#2 main::p0_idx#1 ] zp[1]:40 [ main::x0#0 ] zp[1]:41 [ main::y0#0 ] zp[2]:46 [ main::canvas#1 ] 
Limited combination testing to 100 combinations of 13824 possible.
Uplifting [] best 129533 combination zp[1]:39 [ canvas_show_flag ] zp[1]:38 [ canvas_show_memory ] 
Uplifting [kbhit] best 129521 combination reg byte a [ kbhit::return#0 ] reg byte a [ kbhit::return#2 ] 
Uplifting [irq_bottom_2] best 129515 combination reg byte a [ irq_bottom_2::$0 ] 
Uplifting [MOS6526_CIA] best 129515 combination 
Uplifting [MOS6569_VICII] best 129515 combination 
Uplifting [MOS6581_SID] best 129515 combination 
Uplifting [clock] best 129515 combination 
Uplifting [clock_start] best 129515 combination 
Uplifting [RADIX] best 129515 combination 
Uplifting [textcolor] best 129515 combination 
Uplifting [printf_format_number] best 129515 combination 
Uplifting [printf_buffer_number] best 129515 combination 
Uplifting [printf_format_string] best 129515 combination 
Uplifting [setup_irq] best 129515 combination 
Uplifting [irq_bottom_1] best 129515 combination 
Attempting to uplift remaining variables inzp[1]:26 [ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ]
Uplifting [line] best 129515 combination zp[1]:26 [ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ] 
Attempting to uplift remaining variables inzp[1]:24 [ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ]
Uplifting [line] best 129515 combination zp[1]:24 [ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ] 
Attempting to uplift remaining variables inzp[1]:25 [ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ]
Uplifting [line] best 129515 combination zp[1]:25 [ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ] 
Attempting to uplift remaining variables inzp[1]:27 [ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ]
Uplifting [line] best 129414 combination reg byte x [ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ] 
Attempting to uplift remaining variables inzp[1]:23 [ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ]
Uplifting [line] best 129313 combination reg byte x [ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ] 
Attempting to uplift remaining variables inzp[1]:57 [ line::plot2_$0 ]
Uplifting [line] best 128713 combination reg byte a [ line::plot2_$0 ] 
Attempting to uplift remaining variables inzp[1]:58 [ line::plot2_$2 ]
Uplifting [line] best 128313 combination reg byte a [ line::plot2_$2 ] 
Attempting to uplift remaining variables inzp[1]:61 [ line::plot2_$1 ]
Uplifting [line] best 128313 combination zp[1]:61 [ line::plot2_$1 ] 
Attempting to uplift remaining variables inzp[1]:72 [ line::plot4_$0 ]
Uplifting [line] best 127713 combination reg byte a [ line::plot4_$0 ] 
Attempting to uplift remaining variables inzp[1]:73 [ line::plot4_$2 ]
Uplifting [line] best 127313 combination reg byte a [ line::plot4_$2 ] 
Attempting to uplift remaining variables inzp[1]:76 [ line::plot4_$1 ]
Uplifting [line] best 126913 combination reg byte a [ line::plot4_$1 ] 
Attempting to uplift remaining variables inzp[1]:77 [ line::plot5_$0 ]
Uplifting [line] best 126313 combination reg byte a [ line::plot5_$0 ] 
Attempting to uplift remaining variables inzp[1]:78 [ line::plot5_$2 ]
Uplifting [line] best 125913 combination reg byte a [ line::plot5_$2 ] 
Attempting to uplift remaining variables inzp[1]:81 [ line::plot5_$1 ]
Uplifting [line] best 125913 combination zp[1]:81 [ line::plot5_$1 ] 
Attempting to uplift remaining variables inzp[1]:56 [ line::plot2_y#0 ]
Uplifting [line] best 125913 combination zp[1]:56 [ line::plot2_y#0 ] 
Attempting to uplift remaining variables inzp[1]:55 [ line::sy#0 ]
Uplifting [line] best 125913 combination zp[1]:55 [ line::sy#0 ] 
Attempting to uplift remaining variables inzp[1]:51 [ line::dy#0 ]
Uplifting [line] best 125913 combination zp[1]:51 [ line::dy#0 ] 
Attempting to uplift remaining variables inzp[1]:49 [ line::dx#0 ]
Uplifting [line] best 125913 combination zp[1]:49 [ line::dx#0 ] 
Attempting to uplift remaining variables inzp[1]:22 [ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ]
Uplifting [line] best 125913 combination zp[1]:22 [ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ] 
Attempting to uplift remaining variables inzp[1]:53 [ line::sx#0 ]
Uplifting [line] best 125913 combination zp[1]:53 [ line::sx#0 ] 
Attempting to uplift remaining variables inzp[1]:21 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ]
Uplifting [line] best 125913 combination zp[1]:21 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ] 
Attempting to uplift remaining variables inzp[1]:62 [ line::plot3_$0 ]
Uplifting [line] best 125907 combination reg byte a [ line::plot3_$0 ] 
Attempting to uplift remaining variables inzp[1]:63 [ line::plot3_$2 ]
Uplifting [line] best 125903 combination reg byte a [ line::plot3_$2 ] 
Attempting to uplift remaining variables inzp[1]:66 [ line::plot3_$1 ]
Uplifting [line] best 125899 combination reg byte a [ line::plot3_$1 ] 
Attempting to uplift remaining variables inzp[1]:67 [ line::plot1_$0 ]
Uplifting [line] best 125893 combination reg byte a [ line::plot1_$0 ] 
Attempting to uplift remaining variables inzp[1]:68 [ line::plot1_$2 ]
Uplifting [line] best 125889 combination reg byte a [ line::plot1_$2 ] 
Attempting to uplift remaining variables inzp[1]:71 [ line::plot1_$1 ]
Uplifting [line] best 125885 combination reg byte a [ line::plot1_$1 ] 
Attempting to uplift remaining variables inzp[1]:82 [ line::plot6_$0 ]
Uplifting [line] best 125879 combination reg byte a [ line::plot6_$0 ] 
Attempting to uplift remaining variables inzp[1]:83 [ line::plot6_$2 ]
Uplifting [line] best 125875 combination reg byte a [ line::plot6_$2 ] 
Attempting to uplift remaining variables inzp[1]:86 [ line::plot6_$1 ]
Uplifting [line] best 125871 combination reg byte a [ line::plot6_$1 ] 
Attempting to uplift remaining variables inzp[1]:29 [ sgn_u8::return#4 ]
Uplifting [sgn_u8] best 125859 combination reg byte a [ sgn_u8::return#4 ] 
Attempting to uplift remaining variables inzp[1]:2 [ main::y#2 main::y#1 ]
Uplifting [main] best 125859 combination zp[1]:2 [ main::y#2 main::y#1 ] 
Attempting to uplift remaining variables inzp[1]:44 [ main::x2#0 ]
Uplifting [main] best 125859 combination zp[1]:44 [ main::x2#0 ] 
Attempting to uplift remaining variables inzp[1]:45 [ main::y2#0 ]
Uplifting [main] best 125859 combination zp[1]:45 [ main::y2#0 ] 
Attempting to uplift remaining variables inzp[1]:42 [ main::x1#0 ]
Uplifting [main] best 125859 combination zp[1]:42 [ main::x1#0 ] 
Attempting to uplift remaining variables inzp[1]:43 [ main::y1#0 ]
Uplifting [main] best 125859 combination zp[1]:43 [ main::y1#0 ] 
Attempting to uplift remaining variables inzp[1]:9 [ main::p2_idx#2 main::p2_idx#1 ]
Uplifting [main] best 125859 combination zp[1]:9 [ main::p2_idx#2 main::p2_idx#1 ] 
Attempting to uplift remaining variables inzp[1]:8 [ main::p1_idx#2 main::p1_idx#1 ]
Uplifting [main] best 125859 combination zp[1]:8 [ main::p1_idx#2 main::p1_idx#1 ] 
Attempting to uplift remaining variables inzp[1]:7 [ main::p0_idx#2 main::p0_idx#1 ]
Uplifting [main] best 125859 combination zp[1]:7 [ main::p0_idx#2 main::p0_idx#1 ] 
Attempting to uplift remaining variables inzp[1]:39 [ canvas_show_flag ]
Uplifting [] best 125859 combination zp[1]:39 [ canvas_show_flag ] 
Attempting to uplift remaining variables inzp[1]:40 [ main::x0#0 ]
Uplifting [main] best 125859 combination zp[1]:40 [ main::x0#0 ] 
Attempting to uplift remaining variables inzp[1]:41 [ main::y0#0 ]
Uplifting [main] best 125859 combination zp[1]:41 [ main::y0#0 ] 
Attempting to uplift remaining variables inzp[1]:38 [ canvas_show_memory ]
Uplifting [] best 125859 combination zp[1]:38 [ canvas_show_memory ] 
Coalescing zero page register [ zp[2]:10 [ main::canvas#10 main::canvas#19 ] ] with [ zp[2]:46 [ main::canvas#1 ] ] - score: 2
Coalescing zero page register [ zp[1]:21 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 ] ] with [ zp[1]:42 [ main::x1#0 ] ] - score: 1
Coalescing zero page register [ zp[1]:21 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 main::x1#0 ] ] with [ zp[1]:44 [ main::x2#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:31 [ memset::num#4 ] ] with [ zp[2]:89 [ memset::end#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:33 [ memset::str#5 ] ] with [ zp[2]:36 [ memset::dst#2 memset::dst#4 memset::dst#1 ] ] - score: 1
Coalescing zero page register [ zp[2]:31 [ memset::num#4 memset::end#0 ] ] with [ zp[2]:15 [ eorfill::line_column#2 eorfill::line_column#1 ] ]
Coalescing zero page register [ zp[2]:33 [ memset::str#5 memset::dst#2 memset::dst#4 memset::dst#1 ] ] with [ zp[2]:17 [ eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ] ]
Coalescing zero page register [ zp[2]:59 [ line::plot2_column#0 ] ] with [ zp[2]:31 [ memset::num#4 memset::end#0 eorfill::line_column#2 eorfill::line_column#1 ] ]
Coalescing zero page register [ zp[2]:64 [ line::plot3_column#0 ] ] with [ zp[2]:33 [ memset::str#5 memset::dst#2 memset::dst#4 memset::dst#1 eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ] ]
Allocated (was zp[1]:21) zp[1]:12 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 main::x1#0 main::x2#0 ]
Allocated (was zp[1]:22) zp[1]:13 [ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ]
Allocated (was zp[1]:24) zp[1]:14 [ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ]
Allocated (was zp[1]:25) zp[1]:15 [ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ]
Allocated (was zp[1]:26) zp[1]:16 [ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ]
Allocated (was zp[1]:38) zp[1]:17 [ canvas_show_memory ]
Allocated (was zp[1]:39) zp[1]:18 [ canvas_show_flag ]
Allocated (was zp[1]:40) zp[1]:19 [ main::x0#0 ]
Allocated (was zp[1]:41) zp[1]:20 [ main::y0#0 ]
Allocated (was zp[1]:43) zp[1]:21 [ main::y1#0 ]
Allocated (was zp[1]:45) zp[1]:22 [ main::y2#0 ]
Allocated (was zp[1]:49) zp[1]:23 [ line::dx#0 ]
Allocated (was zp[1]:51) zp[1]:24 [ line::dy#0 ]
Allocated (was zp[1]:53) zp[1]:25 [ line::sx#0 ]
Allocated (was zp[1]:55) zp[1]:26 [ line::sy#0 ]
Allocated (was zp[1]:56) zp[1]:27 [ line::plot2_y#0 ]
Allocated (was zp[2]:59) zp[2]:28 [ line::plot2_column#0 memset::num#4 memset::end#0 eorfill::line_column#2 eorfill::line_column#1 ]
Allocated (was zp[1]:61) zp[1]:30 [ line::plot2_$1 ]
Allocated (was zp[2]:64) zp[2]:31 [ line::plot3_column#0 memset::str#5 memset::dst#2 memset::dst#4 memset::dst#1 eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ]
Allocated (was zp[2]:69) zp[2]:33 [ line::plot1_column#0 ]
Allocated (was zp[2]:74) zp[2]:35 [ line::plot4_column#0 ]
Allocated (was zp[2]:79) zp[2]:37 [ line::plot5_column#0 ]
Allocated (was zp[1]:81) zp[1]:39 [ line::plot5_$1 ]
Allocated (was zp[2]:84) zp[2]:40 [ line::plot6_column#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Filling a simple 16x16 2D polygon using EOR-filling
// - Clearing canvas
// - Trivial 2D rotation using sine tables
// - Line-drawing polygon edges (fill-ready lines)
// - Up-to-down EOR filling 
// - Double buffering
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  .const BORDER_YPOS_BOTTOM = $fa
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const DARK_GREY = $b
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
  .const OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
  .const OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = $21
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MOS6569_VICII_MEMORY = $18
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const toD0181_return = (>(SCREEN&$3fff)*4)|(>CANVAS2)/4&$f
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // Color Ram
  .label COLS = $d800
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#2 timer A&B as one single 32-bit value
  .label CIA2_TIMER_AB = $dd04
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  // The line buffer
  .label LINE_BUFFER = $2000
  // The two charsets used as screen buffers
  .label CANVAS1 = $3000
  .label CANVAS2 = $3800
  // The screen matrix
  .label SCREEN = $2c00
  // The screen console
  .label CONSOLE = $400
  // The default charset address
  .label PETSCII = $1000
  .label COSTAB = SINTAB+$40
  .label canvas_show_memory = $11
  .label canvas_show_flag = $12
  // @begin
__bbegin:
  // [1] phi from @begin to toD0181 [phi:@begin->toD0181]
toD0181_from___bbegin:
  jmp toD0181
  // toD0181
toD0181:
  jmp __b2
  // @2
__b2:
  // [2] (volatile byte) canvas_show_memory ← (const byte) toD0181_return#0 -- vbuz1=vbuc1 
  // The current canvas being rendered to the screen - in D018 format.
  lda #toD0181_return
  sta.z canvas_show_memory
  // [3] (volatile byte) canvas_show_flag ← (byte) 0 -- vbuz1=vbuc1 
  // Flag signalling that the canvas on screen needs to be updated.
  // Set to 1 by the renderer when a new canvas is ready for showing, and to 0 by the raster when the canvas is shown on screen.
  lda #0
  sta.z canvas_show_flag
  // [4] phi from @2 to @1 [phi:@2->@1]
__b1_from___b2:
  jmp __b1
  // @1
__b1:
  // [5] call main 
  // [7] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [6] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>CANVAS1)/4&$f
    .const toD0182_return = (>(SCREEN&$3fff)*4)|(>CANVAS2)/4&$f
    .label cols = 3
    // Setup 16x16 canvas for rendering
    .label screen = 5
    .label y = 2
    .label x0 = $13
    .label y0 = $14
    .label x1 = $c
    .label y1 = $15
    .label x2 = $c
    .label y2 = $16
    .label p0_idx = 7
    .label p1_idx = 8
    .label p2_idx = 9
    // The current canvas being rendered to
    .label canvas = $a
    // [8] call memset 
  // Clear the console
    // [181] phi from main to memset [phi:main->memset]
  memset_from_main:
    // [181] phi (byte) memset::c#6 = (byte) ' ' [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #' '
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) CONSOLE [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<CONSOLE
    sta.z memset.str
    lda #>CONSOLE
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word)(number) $28*(number) $19 [phi:main->memset#2] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta.z memset.num
    lda #>$28*$19
    sta.z memset.num+1
    jsr memset
    // [9] phi from main to main::@12 [phi:main->main::@12]
  __b12_from_main:
    jmp __b12
    // main::@12
  __b12:
    // [10] call memset 
  // Clear the screen
    // [181] phi from main::@12 to memset [phi:main::@12->memset]
  memset_from___b12:
    // [181] phi (byte) memset::c#6 = (byte) 0 [phi:main::@12->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) SCREEN [phi:main::@12->memset#1] -- pvoz1=pvoc1 
    lda #<SCREEN
    sta.z memset.str
    lda #>SCREEN
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word)(number) $28*(number) $19 [phi:main::@12->memset#2] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta.z memset.num
    lda #>$28*$19
    sta.z memset.num+1
    jsr memset
    // [11] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
  __b13_from___b12:
    jmp __b13
    // main::@13
  __b13:
    // [12] call memset 
    // [181] phi from main::@13 to memset [phi:main::@13->memset]
  memset_from___b13:
    // [181] phi (byte) memset::c#6 = (const nomodify byte) BLACK [phi:main::@13->memset#0] -- vbuxx=vbuc1 
    ldx #BLACK
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) COLS [phi:main::@13->memset#1] -- pvoz1=pvoc1 
    lda #<COLS
    sta.z memset.str
    lda #>COLS
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word)(number) $28*(number) $19 [phi:main::@13->memset#2] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta.z memset.num
    lda #>$28*$19
    sta.z memset.num+1
    jsr memset
    // [13] phi from main::@13 to main::@1 [phi:main::@13->main::@1]
  __b1_from___b13:
    // [13] phi (byte*) main::screen#5 = (const nomodify byte*) SCREEN+(byte) $c [phi:main::@13->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$c
    sta.z screen
    lda #>SCREEN+$c
    sta.z screen+1
    // [13] phi (byte*) main::cols#5 = (const nomodify byte*) COLS+(byte) $c [phi:main::@13->main::@1#1] -- pbuz1=pbuc1 
    lda #<COLS+$c
    sta.z cols
    lda #>COLS+$c
    sta.z cols+1
    // [13] phi (byte) main::y#2 = (byte) 0 [phi:main::@13->main::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp __b1
    // main::@1
  __b1:
    // [14] if((byte) main::y#2<(byte) $10) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z y
    cmp #$10
    bcc __b2
    jmp __b3
    // main::@3
  __b3:
    // [15] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [16] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BG_COLOR
    // [17] call setup_irq 
    // Set-up the raster IRQ
    jsr setup_irq
    // [18] phi from main::@3 to main::@14 [phi:main::@3->main::@14]
  __b14_from___b3:
    jmp __b14
    // main::@14
  __b14:
    // [19] call textcolor 
  // Set text color
    // [196] phi from main::@14 to textcolor [phi:main::@14->textcolor]
  textcolor_from___b14:
    jsr textcolor
    // [20] phi from main::@14 to main::@7 [phi:main::@14->main::@7]
  __b7_from___b14:
    // [20] phi (byte*) main::canvas#10 = (const nomodify byte*) CANVAS1 [phi:main::@14->main::@7#0] -- pbuz1=pbuc1 
    lda #<CANVAS1
    sta.z canvas
    lda #>CANVAS1
    sta.z canvas+1
    // [20] phi (byte) main::p2_idx#2 = (byte) $b5+(byte) $aa [phi:main::@14->main::@7#1] -- vbuz1=vbuc1 
    lda #$b5+$aa
    sta.z p2_idx
    // [20] phi (byte) main::p1_idx#2 = (byte) $b5+(byte) $f [phi:main::@14->main::@7#2] -- vbuz1=vbuc1 
    lda #$b5+$f
    sta.z p1_idx
    // [20] phi (byte) main::p0_idx#2 = (byte) $b5 [phi:main::@14->main::@7#3] -- vbuz1=vbuc1 
    lda #$b5
    sta.z p0_idx
    jmp __b7
    // main::@7
  __b7:
    // [21] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
  __b8_from___b7:
    jmp __b8
    // main::@8
  __b8:
    // [22] call clock_start 
    jsr clock_start
    // [23] phi from main::@8 to main::@15 [phi:main::@8->main::@15]
  __b15_from___b8:
    jmp __b15
    // main::@15
  __b15:
    // [24] call memset 
  // Clear line buffer
    // [181] phi from main::@15 to memset [phi:main::@15->memset]
  memset_from___b15:
    // [181] phi (byte) memset::c#6 = (byte) 0 [phi:main::@15->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) LINE_BUFFER [phi:main::@15->memset#1] -- pvoz1=pvoc1 
    lda #<LINE_BUFFER
    sta.z memset.str
    lda #>LINE_BUFFER
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word) $800 [phi:main::@15->memset#2] -- vwuz1=vwuc1 
    lda #<$800
    sta.z memset.num
    lda #>$800
    sta.z memset.num+1
    jsr memset
    jmp __b16
    // main::@16
  __b16:
    // [25] (byte) main::x0#0 ← *((const byte*) COSTAB + (byte) main::p0_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    // Plot in line buffer
    ldy.z p0_idx
    lda COSTAB,y
    sta.z x0
    // [26] (byte) main::y0#0 ← *((const byte*) SINTAB + (byte) main::p0_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p0_idx
    lda SINTAB,y
    sta.z y0
    // [27] (byte) main::x1#0 ← *((const byte*) COSTAB + (byte) main::p1_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p1_idx
    lda COSTAB,y
    sta.z x1
    // [28] (byte) main::y1#0 ← *((const byte*) SINTAB + (byte) main::p1_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p1_idx
    lda SINTAB,y
    sta.z y1
    // [29] (byte) line::x1#0 ← (byte) main::x0#0 -- vbuz1=vbuz2 
    lda.z x0
    sta.z line.x1
    // [30] (byte) line::y1#0 ← (byte) main::y0#0 -- vbuz1=vbuz2 
    lda.z y0
    sta.z line.y1
    // [31] (byte) line::x2#0 ← (byte) main::x1#0
    // [32] (byte) line::y2#0 ← (byte) main::y1#0 -- vbuz1=vbuz2 
    lda.z y1
    sta.z line.y2
    // [33] call line 
    // [87] phi from main::@16 to line [phi:main::@16->line]
  line_from___b16:
    // [87] phi (byte) line::y2#10 = (byte) line::y2#0 [phi:main::@16->line#0] -- register_copy 
    // [87] phi (byte) line::x2#15 = (byte) line::x2#0 [phi:main::@16->line#1] -- register_copy 
    // [87] phi (byte) line::y#0 = (byte) line::y1#0 [phi:main::@16->line#2] -- register_copy 
    // [87] phi (byte) line::x#0 = (byte) line::x1#0 [phi:main::@16->line#3] -- register_copy 
    jsr line
    jmp __b17
    // main::@17
  __b17:
    // [34] (byte) main::x2#0 ← *((const byte*) COSTAB + (byte) main::p2_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p2_idx
    lda COSTAB,y
    sta.z x2
    // [35] (byte) main::y2#0 ← *((const byte*) SINTAB + (byte) main::p2_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p2_idx
    lda SINTAB,y
    sta.z y2
    // [36] (byte) line::x1#1 ← (byte) main::x1#0 -- vbuz1=vbuz2 
    lda.z x1
    sta.z line.x1
    // [37] (byte) line::y1#1 ← (byte) main::y1#0 -- vbuz1=vbuz2 
    lda.z y1
    sta.z line.y1
    // [38] (byte) line::x2#1 ← (byte) main::x2#0
    // [39] (byte) line::y2#1 ← (byte) main::y2#0 -- vbuz1=vbuz2 
    lda.z y2
    sta.z line.y2
    // [40] call line 
    // [87] phi from main::@17 to line [phi:main::@17->line]
  line_from___b17:
    // [87] phi (byte) line::y2#10 = (byte) line::y2#1 [phi:main::@17->line#0] -- register_copy 
    // [87] phi (byte) line::x2#15 = (byte) line::x2#1 [phi:main::@17->line#1] -- register_copy 
    // [87] phi (byte) line::y#0 = (byte) line::y1#1 [phi:main::@17->line#2] -- register_copy 
    // [87] phi (byte) line::x#0 = (byte) line::x1#1 [phi:main::@17->line#3] -- register_copy 
    jsr line
    jmp __b18
    // main::@18
  __b18:
    // [41] (byte) line::x1#2 ← (byte) main::x2#0 -- vbuz1=vbuz2 
    lda.z x2
    sta.z line.x1
    // [42] (byte) line::y1#2 ← (byte) main::y2#0 -- vbuz1=vbuz2 
    lda.z y2
    sta.z line.y1
    // [43] (byte) line::x2#2 ← (byte) main::x0#0 -- vbuz1=vbuz2 
    lda.z x0
    sta.z line.x2
    // [44] (byte) line::y2#2 ← (byte) main::y0#0 -- vbuz1=vbuz2 
    lda.z y0
    sta.z line.y2
    // [45] call line 
    // [87] phi from main::@18 to line [phi:main::@18->line]
  line_from___b18:
    // [87] phi (byte) line::y2#10 = (byte) line::y2#2 [phi:main::@18->line#0] -- register_copy 
    // [87] phi (byte) line::x2#15 = (byte) line::x2#2 [phi:main::@18->line#1] -- register_copy 
    // [87] phi (byte) line::y#0 = (byte) line::y1#2 [phi:main::@18->line#2] -- register_copy 
    // [87] phi (byte) line::x#0 = (byte) line::x1#2 [phi:main::@18->line#3] -- register_copy 
    jsr line
    jmp __b19
    // main::@19
  __b19:
    // [46] (byte) main::p0_idx#1 ← ++ (byte) main::p0_idx#2 -- vbuz1=_inc_vbuz1 
    inc.z p0_idx
    // [47] (byte) main::p1_idx#1 ← ++ (byte) main::p1_idx#2 -- vbuz1=_inc_vbuz1 
    inc.z p1_idx
    // [48] (byte) main::p2_idx#1 ← ++ (byte) main::p2_idx#2 -- vbuz1=_inc_vbuz1 
    inc.z p2_idx
    // [49] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) RED -- _deref_pbuc1=vbuc2 
    // Wait until the canvas on screen has been switched before starting work on the next frame
    lda #RED
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    jmp __b9
    // main::@9
  __b9:
    // [50] if((byte) 0!=(volatile byte) canvas_show_flag) goto main::@9 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z canvas_show_flag
    bne __b9
    jmp __b10
    // main::@10
  __b10:
    // [51] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [52] (byte*) eorfill::canvas#0 ← (byte*) main::canvas#10 -- pbuz1=pbuz2 
    lda.z canvas
    sta.z eorfill.canvas
    lda.z canvas+1
    sta.z eorfill.canvas+1
    // [53] call eorfill 
  // Fill canvas
    // [73] phi from main::@10 to eorfill [phi:main::@10->eorfill]
  eorfill_from___b10:
    jsr eorfill
    jmp __b20
    // main::@20
  __b20:
    // [54] (word) main::canvas#1 ← (byte*) main::canvas#10 ^ (const nomodify byte*) CANVAS1^(const nomodify byte*) CANVAS2 -- vwuz1=pbuz1_bxor_vwuc1 
    // swap canvas being rendered to (using XOR)
    lda #<CANVAS1^CANVAS2
    eor.z canvas
    sta.z canvas
    lda #>CANVAS1^CANVAS2
    eor.z canvas+1
    sta.z canvas+1
    // [55] phi from main::@20 to main::toD0181 [phi:main::@20->main::toD0181]
  toD0181_from___b20:
    jmp toD0181
    // main::toD0181
  toD0181:
    // [56] phi from main::toD0181 to main::toD0182 [phi:main::toD0181->main::toD0182]
  toD0182_from_toD0181:
    jmp toD0182
    // main::toD0182
  toD0182:
    jmp __b11
    // main::@11
  __b11:
    // [57] (volatile byte) canvas_show_memory ← (volatile byte) canvas_show_memory ^ (const byte) main::toD0181_return#0^(const byte) main::toD0182_return#0 -- vbuz1=vbuz1_bxor_vbuc1 
    // Swap canvas to show on screen (using XOR)
    lda #toD0181_return^toD0182_return
    eor.z canvas_show_memory
    sta.z canvas_show_memory
    // [58] (volatile byte) canvas_show_flag ← (byte) 1 -- vbuz1=vbuc1 
    // Set flag used to signal when the canvas has been shown
    lda #1
    sta.z canvas_show_flag
    // [59] call clock 
    // [71] phi from main::@11 to clock [phi:main::@11->clock]
  clock_from___b11:
    jsr clock
    jmp __b21
    // main::@21
  __b21:
    // [60] (byte*) main::canvas#19 ← (byte*)(word) main::canvas#1
    // [20] phi from main::@21 to main::@7 [phi:main::@21->main::@7]
  __b7_from___b21:
    // [20] phi (byte*) main::canvas#10 = (byte*) main::canvas#19 [phi:main::@21->main::@7#0] -- register_copy 
    // [20] phi (byte) main::p2_idx#2 = (byte) main::p2_idx#1 [phi:main::@21->main::@7#1] -- register_copy 
    // [20] phi (byte) main::p1_idx#2 = (byte) main::p1_idx#1 [phi:main::@21->main::@7#2] -- register_copy 
    // [20] phi (byte) main::p0_idx#2 = (byte) main::p0_idx#1 [phi:main::@21->main::@7#3] -- register_copy 
    jmp __b7
    // main::@2
  __b2:
    // [61] (byte) main::c#4 ← (byte) main::y#2 -- vbuxx=vbuz1 
    ldx.z y
    // [62] phi from main::@2 to main::@4 [phi:main::@2->main::@4]
  __b4_from___b2:
    // [62] phi (byte) main::c#2 = (byte) main::c#4 [phi:main::@2->main::@4#0] -- register_copy 
    // [62] phi (byte) main::x#2 = (byte) 0 [phi:main::@2->main::@4#1] -- vbuyy=vbuc1 
    ldy #0
    jmp __b4
    // main::@4
  __b4:
    // [63] if((byte) main::x#2<(byte) $10) goto main::@5 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$10
    bcc __b5
    jmp __b6
    // main::@6
  __b6:
    // [64] (byte*) main::cols#1 ← (byte*) main::cols#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z cols
    sta.z cols
    bcc !+
    inc.z cols+1
  !:
    // [65] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [66] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [13] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
  __b1_from___b6:
    // [13] phi (byte*) main::screen#5 = (byte*) main::screen#1 [phi:main::@6->main::@1#0] -- register_copy 
    // [13] phi (byte*) main::cols#5 = (byte*) main::cols#1 [phi:main::@6->main::@1#1] -- register_copy 
    // [13] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@6->main::@1#2] -- register_copy 
    jmp __b1
    // main::@5
  __b5:
    // [67] *((byte*) main::cols#5 + (byte) main::x#2) ← (const nomodify byte) WHITE -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #WHITE
    sta (cols),y
    // [68] *((byte*) main::screen#5 + (byte) main::x#2) ← (byte) main::c#2 -- pbuz1_derefidx_vbuyy=vbuxx 
    txa
    sta (screen),y
    // [69] (byte) main::c#1 ← (byte) main::c#2 + (byte) $10 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[$10]
    // [70] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuyy=_inc_vbuyy 
    iny
    // [62] phi from main::@5 to main::@4 [phi:main::@5->main::@4]
  __b4_from___b5:
    // [62] phi (byte) main::c#2 = (byte) main::c#1 [phi:main::@5->main::@4#0] -- register_copy 
    // [62] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@5->main::@4#1] -- register_copy 
    jmp __b4
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    jmp __breturn
    // clock::@return
  __breturn:
    // [72] return 
    rts
}
  // eorfill
// EOR fill from the line buffer onto the canvas
// eorfill(byte* zp($1f) canvas)
eorfill: {
    .label canvas = $1f
    .label line_column = $1c
    .label fill_column = $1f
    // [74] phi from eorfill to eorfill::@1 [phi:eorfill->eorfill::@1]
  __b1_from_eorfill:
    // [74] phi (byte*) eorfill::fill_column#2 = (byte*) eorfill::canvas#0 [phi:eorfill->eorfill::@1#0] -- register_copy 
    // [74] phi (byte*) eorfill::line_column#2 = (const nomodify byte*) LINE_BUFFER [phi:eorfill->eorfill::@1#1] -- pbuz1=pbuc1 
    lda #<LINE_BUFFER
    sta.z line_column
    lda #>LINE_BUFFER
    sta.z line_column+1
    // [74] phi (byte) eorfill::x#2 = (byte) 0 [phi:eorfill->eorfill::@1#2] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // eorfill::@1
  __b1:
    // [75] if((byte) eorfill::x#2<(byte) $10) goto eorfill::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$10
    bcc __b2
    jmp __breturn
    // eorfill::@return
  __breturn:
    // [76] return 
    rts
    // eorfill::@2
  __b2:
    // [77] (byte) eorfill::eor#0 ← *((byte*) eorfill::line_column#2) -- vbuaa=_deref_pbuz1 
    ldy #0
    lda (line_column),y
    // [78] *((byte*) eorfill::fill_column#2) ← (byte) eorfill::eor#0 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (fill_column),y
    // [79] phi from eorfill::@2 to eorfill::@3 [phi:eorfill::@2->eorfill::@3]
  __b3_from___b2:
    // [79] phi (byte) eorfill::eor#2 = (byte) eorfill::eor#0 [phi:eorfill::@2->eorfill::@3#0] -- register_copy 
    // [79] phi (byte) eorfill::y#2 = (byte) 1 [phi:eorfill::@2->eorfill::@3#1] -- vbuyy=vbuc1 
    ldy #1
    jmp __b3
    // eorfill::@3
  __b3:
    // [80] if((byte) eorfill::y#2<(byte)(number) $10*(number) 8) goto eorfill::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$10*8
    bcc __b4
    jmp __b5
    // eorfill::@5
  __b5:
    // [81] (byte*) eorfill::line_column#1 ← (byte*) eorfill::line_column#2 + (byte)(number) $10*(number) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$10*8
    clc
    adc.z line_column
    sta.z line_column
    bcc !+
    inc.z line_column+1
  !:
    // [82] (byte*) eorfill::fill_column#1 ← (byte*) eorfill::fill_column#2 + (byte)(number) $10*(number) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$10*8
    clc
    adc.z fill_column
    sta.z fill_column
    bcc !+
    inc.z fill_column+1
  !:
    // [83] (byte) eorfill::x#1 ← ++ (byte) eorfill::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [74] phi from eorfill::@5 to eorfill::@1 [phi:eorfill::@5->eorfill::@1]
  __b1_from___b5:
    // [74] phi (byte*) eorfill::fill_column#2 = (byte*) eorfill::fill_column#1 [phi:eorfill::@5->eorfill::@1#0] -- register_copy 
    // [74] phi (byte*) eorfill::line_column#2 = (byte*) eorfill::line_column#1 [phi:eorfill::@5->eorfill::@1#1] -- register_copy 
    // [74] phi (byte) eorfill::x#2 = (byte) eorfill::x#1 [phi:eorfill::@5->eorfill::@1#2] -- register_copy 
    jmp __b1
    // eorfill::@4
  __b4:
    // [84] (byte) eorfill::eor#1 ← (byte) eorfill::eor#2 ^ *((byte*) eorfill::line_column#2 + (byte) eorfill::y#2) -- vbuaa=vbuaa_bxor_pbuz1_derefidx_vbuyy 
    eor (line_column),y
    // [85] *((byte*) eorfill::fill_column#2 + (byte) eorfill::y#2) ← (byte) eorfill::eor#1 -- pbuz1_derefidx_vbuyy=vbuaa 
    sta (fill_column),y
    // [86] (byte) eorfill::y#1 ← ++ (byte) eorfill::y#2 -- vbuyy=_inc_vbuyy 
    iny
    // [79] phi from eorfill::@4 to eorfill::@3 [phi:eorfill::@4->eorfill::@3]
  __b3_from___b4:
    // [79] phi (byte) eorfill::eor#2 = (byte) eorfill::eor#1 [phi:eorfill::@4->eorfill::@3#0] -- register_copy 
    // [79] phi (byte) eorfill::y#2 = (byte) eorfill::y#1 [phi:eorfill::@4->eorfill::@3#1] -- register_copy 
    jmp __b3
}
  // line
// Draw a EOR friendly line between two points
// Uses bresenham line drawing routine
// line(byte zp($f) x1, byte zp($10) y1, byte zp($c) x2, byte zp($d) y2)
line: {
    .label plot2___1 = $1e
    .label plot5___1 = $27
    .label x1 = $f
    .label y1 = $10
    .label x2 = $c
    .label y2 = $d
    .label x = $f
    .label y = $10
    .label dx = $17
    .label dy = $18
    .label sx = $19
    .label sy = $1a
    .label plot1_column = $21
    .label plot2_y = $1b
    .label plot2_column = $1c
    .label plot3_column = $1f
    .label e1 = $e
    .label plot4_column = $23
    .label plot5_column = $25
    .label plot6_column = $28
    // [88] (byte) abs_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z x2
    sec
    sbc.z x
    // [89] call abs_u8 
    // [175] phi from line to abs_u8 [phi:line->abs_u8]
  abs_u8_from_line:
    // [175] phi (byte) abs_u8::u#2 = (byte) abs_u8::u#0 [phi:line->abs_u8#0] -- register_copy 
    jsr abs_u8
    // [90] (byte) abs_u8::return#0 ← (byte) abs_u8::return#4
    jmp __b19
    // line::@19
  __b19:
    // [91] (byte) line::dx#0 ← (byte) abs_u8::return#0 -- vbuz1=vbuaa 
    sta.z dx
    // [92] (byte) abs_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z y2
    sec
    sbc.z y
    // [93] call abs_u8 
    // [175] phi from line::@19 to abs_u8 [phi:line::@19->abs_u8]
  abs_u8_from___b19:
    // [175] phi (byte) abs_u8::u#2 = (byte) abs_u8::u#1 [phi:line::@19->abs_u8#0] -- register_copy 
    jsr abs_u8
    // [94] (byte) abs_u8::return#1 ← (byte) abs_u8::return#4
    jmp __b20
    // line::@20
  __b20:
    // [95] (byte) line::dy#0 ← (byte) abs_u8::return#1 -- vbuz1=vbuaa 
    sta.z dy
    // [96] (byte) sgn_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z x2
    sec
    sbc.z x
    // [97] call sgn_u8 
    // [169] phi from line::@20 to sgn_u8 [phi:line::@20->sgn_u8]
  sgn_u8_from___b20:
    // [169] phi (byte) sgn_u8::u#2 = (byte) sgn_u8::u#0 [phi:line::@20->sgn_u8#0] -- register_copy 
    jsr sgn_u8
    // [98] (byte) sgn_u8::return#0 ← (byte) sgn_u8::return#4
    jmp __b21
    // line::@21
  __b21:
    // [99] (byte) line::sx#0 ← (byte) sgn_u8::return#0 -- vbuz1=vbuaa 
    sta.z sx
    // [100] (byte) sgn_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z y2
    sec
    sbc.z y
    // [101] call sgn_u8 
    // [169] phi from line::@21 to sgn_u8 [phi:line::@21->sgn_u8]
  sgn_u8_from___b21:
    // [169] phi (byte) sgn_u8::u#2 = (byte) sgn_u8::u#1 [phi:line::@21->sgn_u8#0] -- register_copy 
    jsr sgn_u8
    // [102] (byte) sgn_u8::return#1 ← (byte) sgn_u8::return#4
    jmp __b22
    // line::@22
  __b22:
    // [103] (byte) line::sy#0 ← (byte) sgn_u8::return#1 -- vbuz1=vbuaa 
    sta.z sy
    // [104] if((byte) line::sx#0!=(byte) $ff) goto line::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z sx
    bne __b1_from___b22
    jmp __b3
    // line::@3
  __b3:
    // [105] (byte) line::y#1 ← ++ (byte) line::y#0 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [106] (byte) line::y2#3 ← ++ (byte) line::y2#10 -- vbuz1=_inc_vbuz1 
    inc.z y2
    // [107] phi from line::@22 line::@3 to line::@1 [phi:line::@22/line::@3->line::@1]
  __b1_from___b22:
  __b1_from___b3:
    // [107] phi (byte) line::y2#13 = (byte) line::y2#10 [phi:line::@22/line::@3->line::@1#0] -- register_copy 
    // [107] phi (byte) line::y#17 = (byte) line::y#0 [phi:line::@22/line::@3->line::@1#1] -- register_copy 
    jmp __b1
    // line::@1
  __b1:
    // [108] if((byte) line::dx#0>(byte) line::dy#0) goto line::@2 -- vbuz1_gt_vbuz2_then_la1 
    lda.z dy
    cmp.z dx
    bcc __b2
    jmp __b4
    // line::@4
  __b4:
    // [109] if((byte) line::sx#0==(byte) line::sy#0) goto line::plot1 -- vbuz1_eq_vbuz2_then_la1 
    // Steep slope - Y is the driver - only plot one plot per X
    lda.z sx
    cmp.z sy
    beq plot1
    jmp __b5
    // line::@5
  __b5:
    // [110] (byte) line::e#0 ← (byte) line::dy#0 >> (byte) 1 -- vbuxx=vbuz1_ror_1 
    lda.z dy
    lsr
    tax
    // [111] phi from line::@5 line::@7 to line::@6 [phi:line::@5/line::@7->line::@6]
  __b6_from___b5:
  __b6_from___b7:
    // [111] phi (byte) line::x#15 = (byte) line::x#0 [phi:line::@5/line::@7->line::@6#0] -- register_copy 
    // [111] phi (byte) line::e#3 = (byte) line::e#0 [phi:line::@5/line::@7->line::@6#1] -- register_copy 
    // [111] phi (byte) line::y#7 = (byte) line::y#17 [phi:line::@5/line::@7->line::@6#2] -- register_copy 
    jmp __b6
    // line::@6
  __b6:
    // [112] (byte) line::y#10 ← (byte) line::y#7 + (byte) line::sy#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z y
    clc
    adc.z sy
    sta.z y
    // [113] (byte) line::e#1 ← (byte) line::e#3 + (byte) line::dx#0 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc.z dx
    tax
    // [114] if((byte) line::e#1<=(byte) line::dy#0) goto line::@7 -- vbuxx_le_vbuz1_then_la1 
    lda.z dy
    stx.z $ff
    cmp.z $ff
    bcs __b7_from___b6
    jmp __b8
    // line::@8
  __b8:
    // [115] (byte) line::plot2_y#0 ← (byte) line::y#10 - (byte) line::sy#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z y
    sec
    sbc.z sy
    sta.z plot2_y
    jmp plot2
    // line::plot2
  plot2:
    // [116] (byte~) line::plot2_$0 ← (byte) line::x#15 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // [117] (byte~) line::plot2_$2 ← (byte~) line::plot2_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [118] (byte*) line::plot2_column#0 ← *((const byte**) plot_column + (byte~) line::plot2_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot2_column
    lda plot_column+1,y
    sta.z plot2_column+1
    // [119] (byte~) line::plot2_$1 ← (byte) line::x#15 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot2___1
    // [120] *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) ← *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) | *((const byte*) plot_bit + (byte~) line::plot2_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z plot2_y
    lda (plot2_column),y
    ldy.z plot2___1
    ora plot_bit,y
    ldy.z plot2_y
    sta (plot2_column),y
    jmp __b16
    // line::@16
  __b16:
    // [121] (byte) line::x#1 ← (byte) line::x#15 + (byte) line::sx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z sx
    sta.z x
    // [122] (byte) line::e#2 ← (byte) line::e#1 - (byte) line::dy#0 -- vbuxx=vbuxx_minus_vbuz1 
    txa
    sec
    sbc.z dy
    tax
    // [123] phi from line::@16 line::@6 to line::@7 [phi:line::@16/line::@6->line::@7]
  __b7_from___b16:
  __b7_from___b6:
    // [123] phi (byte) line::x#17 = (byte) line::x#1 [phi:line::@16/line::@6->line::@7#0] -- register_copy 
    // [123] phi (byte) line::e#5 = (byte) line::e#2 [phi:line::@16/line::@6->line::@7#1] -- register_copy 
    jmp __b7
    // line::@7
  __b7:
    // [124] if((byte) line::y#10!=(byte) line::y2#13) goto line::@6 -- vbuz1_neq_vbuz2_then_la1 
    lda.z y
    cmp.z y2
    bne __b6_from___b7
    jmp plot3
    // line::plot3
  plot3:
    // [125] (byte~) line::plot3_$0 ← (byte) line::x#17 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // [126] (byte~) line::plot3_$2 ← (byte~) line::plot3_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [127] (byte*) line::plot3_column#0 ← *((const byte**) plot_column + (byte~) line::plot3_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot3_column
    lda plot_column+1,y
    sta.z plot3_column+1
    // [128] (byte~) line::plot3_$1 ← (byte) line::x#17 & (byte) 7 -- vbuaa=vbuz1_band_vbuc1 
    lda #7
    and.z x
    // [129] *((byte*) line::plot3_column#0 + (byte) line::y#10) ← *((byte*) line::plot3_column#0 + (byte) line::y#10) | *((const byte*) plot_bit + (byte~) line::plot3_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuaa 
    ldy.z y
    tax
    lda (plot3_column),y
    ora plot_bit,x
    ldy.z y
    sta (plot3_column),y
    jmp __breturn
    // line::@return
  __breturn:
    // [130] return 
    rts
    // line::plot1
  plot1:
    // [131] (byte~) line::plot1_$0 ← (byte) line::x#0 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // [132] (byte~) line::plot1_$2 ← (byte~) line::plot1_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [133] (byte*) line::plot1_column#0 ← *((const byte**) plot_column + (byte~) line::plot1_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot1_column
    lda plot_column+1,y
    sta.z plot1_column+1
    // [134] (byte~) line::plot1_$1 ← (byte) line::x#0 & (byte) 7 -- vbuaa=vbuz1_band_vbuc1 
    lda #7
    and.z x
    // [135] *((byte*) line::plot1_column#0 + (byte) line::y#17) ← *((byte*) line::plot1_column#0 + (byte) line::y#17) | *((const byte*) plot_bit + (byte~) line::plot1_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuaa 
    ldy.z y
    tax
    lda (plot1_column),y
    ora plot_bit,x
    ldy.z y
    sta (plot1_column),y
    jmp __b15
    // line::@15
  __b15:
    // [136] if((byte) line::dx#0!=(byte) 0) goto line::@9 -- vbuz1_neq_0_then_la1 
    lda.z dx
    cmp #0
    bne __b9
    jmp __breturn
    // line::@9
  __b9:
    // [137] (byte) line::e1#0 ← (byte) line::dy#0 >> (byte) 1 -- vbuz1=vbuz2_ror_1 
    lda.z dy
    lsr
    sta.z e1
    // [138] phi from line::@10 line::@17 line::@9 to line::@10 [phi:line::@10/line::@17/line::@9->line::@10]
  __b10_from___b10:
  __b10_from___b17:
  __b10_from___b9:
    // [138] phi (byte) line::x#18 = (byte) line::x#18 [phi:line::@10/line::@17/line::@9->line::@10#0] -- register_copy 
    // [138] phi (byte) line::e1#3 = (byte) line::e1#1 [phi:line::@10/line::@17/line::@9->line::@10#1] -- register_copy 
    // [138] phi (byte) line::y#11 = (byte) line::y#12 [phi:line::@10/line::@17/line::@9->line::@10#2] -- register_copy 
    jmp __b10
    // line::@10
  __b10:
    // [139] (byte) line::y#12 ← (byte) line::y#11 + (byte) line::sy#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z y
    clc
    adc.z sy
    sta.z y
    // [140] (byte) line::e1#1 ← (byte) line::e1#3 + (byte) line::dx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z e1
    clc
    adc.z dx
    sta.z e1
    // [141] if((byte) line::e1#1<=(byte) line::dy#0) goto line::@10 -- vbuz1_le_vbuz2_then_la1 
    lda.z dy
    cmp.z e1
    bcs __b10_from___b10
    jmp __b11
    // line::@11
  __b11:
    // [142] (byte) line::x#19 ← (byte) line::x#18 + (byte) line::sx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z sx
    sta.z x
    // [143] (byte) line::e1#2 ← (byte) line::e1#1 - (byte) line::dy#0 -- vbuz1=vbuz1_minus_vbuz2 
    lda.z e1
    sec
    sbc.z dy
    sta.z e1
    jmp plot4
    // line::plot4
  plot4:
    // [144] (byte~) line::plot4_$0 ← (byte) line::x#19 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // [145] (byte~) line::plot4_$2 ← (byte~) line::plot4_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [146] (byte*) line::plot4_column#0 ← *((const byte**) plot_column + (byte~) line::plot4_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot4_column
    lda plot_column+1,y
    sta.z plot4_column+1
    // [147] (byte~) line::plot4_$1 ← (byte) line::x#19 & (byte) 7 -- vbuaa=vbuz1_band_vbuc1 
    lda #7
    and.z x
    // [148] *((byte*) line::plot4_column#0 + (byte) line::y#12) ← *((byte*) line::plot4_column#0 + (byte) line::y#12) | *((const byte*) plot_bit + (byte~) line::plot4_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuaa 
    ldy.z y
    tax
    lda (plot4_column),y
    ora plot_bit,x
    ldy.z y
    sta (plot4_column),y
    jmp __b17
    // line::@17
  __b17:
    // [149] if((byte) line::x#19!=(byte) line::x2#15) goto line::@10 -- vbuz1_neq_vbuz2_then_la1 
    lda.z x
    cmp.z x2
    bne __b10_from___b17
    jmp __breturn
    // line::@2
  __b2:
    // [150] (byte) line::e2#0 ← (byte) line::dx#0 >> (byte) 1 -- vbuxx=vbuz1_ror_1 
    lda.z dx
    lsr
    tax
    // [151] phi from line::@13 line::@2 to line::@12 [phi:line::@13/line::@2->line::@12]
  __b12_from___b13:
  __b12_from___b2:
    // [151] phi (byte) line::e2#3 = (byte) line::e2#7 [phi:line::@13/line::@2->line::@12#0] -- register_copy 
    // [151] phi (byte) line::y#13 = (byte) line::y#15 [phi:line::@13/line::@2->line::@12#1] -- register_copy 
    // [151] phi (byte) line::x#10 = (byte) line::x#12 [phi:line::@13/line::@2->line::@12#2] -- register_copy 
    jmp __b12
    // line::@12
  __b12:
    jmp plot5
    // line::plot5
  plot5:
    // [152] (byte~) line::plot5_$0 ← (byte) line::x#10 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // [153] (byte~) line::plot5_$2 ← (byte~) line::plot5_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [154] (byte*) line::plot5_column#0 ← *((const byte**) plot_column + (byte~) line::plot5_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot5_column
    lda plot_column+1,y
    sta.z plot5_column+1
    // [155] (byte~) line::plot5_$1 ← (byte) line::x#10 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot5___1
    // [156] *((byte*) line::plot5_column#0 + (byte) line::y#13) ← *((byte*) line::plot5_column#0 + (byte) line::y#13) | *((const byte*) plot_bit + (byte~) line::plot5_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z y
    lda (plot5_column),y
    ldy.z plot5___1
    ora plot_bit,y
    ldy.z y
    sta (plot5_column),y
    jmp __b18
    // line::@18
  __b18:
    // [157] (byte) line::x#12 ← (byte) line::x#10 + (byte) line::sx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z sx
    sta.z x
    // [158] (byte) line::e2#1 ← (byte) line::e2#3 + (byte) line::dy#0 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc.z dy
    tax
    // [159] if((byte) line::e2#1<=(byte) line::dx#0) goto line::@13 -- vbuxx_le_vbuz1_then_la1 
    lda.z dx
    stx.z $ff
    cmp.z $ff
    bcs __b13_from___b18
    jmp __b14
    // line::@14
  __b14:
    // [160] (byte) line::y#4 ← (byte) line::y#13 + (byte) line::sy#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z y
    clc
    adc.z sy
    sta.z y
    // [161] (byte) line::e2#2 ← (byte) line::e2#1 - (byte) line::dx#0 -- vbuxx=vbuxx_minus_vbuz1 
    txa
    sec
    sbc.z dx
    tax
    // [162] phi from line::@14 line::@18 to line::@13 [phi:line::@14/line::@18->line::@13]
  __b13_from___b14:
  __b13_from___b18:
    // [162] phi (byte) line::e2#7 = (byte) line::e2#2 [phi:line::@14/line::@18->line::@13#0] -- register_copy 
    // [162] phi (byte) line::y#15 = (byte) line::y#4 [phi:line::@14/line::@18->line::@13#1] -- register_copy 
    jmp __b13
    // line::@13
  __b13:
    // [163] if((byte) line::x#12!=(byte) line::x2#15) goto line::@12 -- vbuz1_neq_vbuz2_then_la1 
    lda.z x
    cmp.z x2
    bne __b12_from___b13
    jmp plot6
    // line::plot6
  plot6:
    // [164] (byte~) line::plot6_$0 ← (byte) line::x#12 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // [165] (byte~) line::plot6_$2 ← (byte~) line::plot6_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [166] (byte*) line::plot6_column#0 ← *((const byte**) plot_column + (byte~) line::plot6_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot6_column
    lda plot_column+1,y
    sta.z plot6_column+1
    // [167] (byte~) line::plot6_$1 ← (byte) line::x#12 & (byte) 7 -- vbuaa=vbuz1_band_vbuc1 
    lda #7
    and.z x
    // [168] *((byte*) line::plot6_column#0 + (byte) line::y#15) ← *((byte*) line::plot6_column#0 + (byte) line::y#15) | *((const byte*) plot_bit + (byte~) line::plot6_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuaa 
    ldy.z y
    tax
    lda (plot6_column),y
    ora plot_bit,x
    ldy.z y
    sta (plot6_column),y
    jmp __breturn
}
  // sgn_u8
// Get the sign of a 8-bit unsigned number treated as a signed number.
// Returns unsigned -1 if the number is negative
// sgn_u8(byte register(A) u)
sgn_u8: {
    // [170] (byte~) sgn_u8::$0 ← (byte) sgn_u8::u#2 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // [171] if((byte) 0!=(byte~) sgn_u8::$0) goto sgn_u8::@1 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b1_from_sgn_u8
    // [173] phi from sgn_u8 to sgn_u8::@return [phi:sgn_u8->sgn_u8::@return]
  __breturn_from_sgn_u8:
    // [173] phi (byte) sgn_u8::return#4 = (byte) 1 [phi:sgn_u8->sgn_u8::@return#0] -- vbuaa=vbuc1 
    lda #1
    jmp __breturn
    // [172] phi from sgn_u8 to sgn_u8::@1 [phi:sgn_u8->sgn_u8::@1]
  __b1_from_sgn_u8:
    jmp __b1
    // sgn_u8::@1
  __b1:
    // [173] phi from sgn_u8::@1 to sgn_u8::@return [phi:sgn_u8::@1->sgn_u8::@return]
  __breturn_from___b1:
    // [173] phi (byte) sgn_u8::return#4 = (byte) -1 [phi:sgn_u8::@1->sgn_u8::@return#0] -- vbuaa=vbuc1 
    lda #-1
    jmp __breturn
    // sgn_u8::@return
  __breturn:
    // [174] return 
    rts
}
  // abs_u8
// Get the absolute value of a u-bit unsigned number treated as a signed number.
// abs_u8(byte register(A) u)
abs_u8: {
    // [176] (byte~) abs_u8::$0 ← (byte) abs_u8::u#2 & (byte) $80 -- vbuxx=vbuaa_band_vbuc1 
    ldx #$80
    axs #0
    // [177] if((byte) 0!=(byte~) abs_u8::$0) goto abs_u8::@1 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne __b1
    // [179] phi from abs_u8 abs_u8::@1 to abs_u8::@return [phi:abs_u8/abs_u8::@1->abs_u8::@return]
  __breturn_from_abs_u8:
  __breturn_from___b1:
    // [179] phi (byte) abs_u8::return#4 = (byte) abs_u8::u#2 [phi:abs_u8/abs_u8::@1->abs_u8::@return#0] -- register_copy 
    jmp __breturn
    // abs_u8::@1
  __b1:
    // [178] (byte) abs_u8::return#2 ← - (byte) abs_u8::u#2 -- vbuaa=_neg_vbuaa 
    eor #$ff
    clc
    adc #1
    jmp __breturn_from___b1
    // abs_u8::@return
  __breturn:
    // [180] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zp($1f) str, byte register(X) c, word zp($1c) num)
memset: {
    .label end = $1c
    .label dst = $1f
    .label num = $1c
    .label str = $1f
    // [182] if((word) memset::num#4<=(byte) 0) goto memset::@return -- vwuz1_le_0_then_la1 
    lda.z num
    bne !+
    lda.z num+1
    beq __breturn
  !:
    jmp __b1
    // memset::@1
  __b1:
    // [183] (byte*) memset::end#0 ← (byte*)(void*) memset::str#5 + (word) memset::num#4 -- pbuz1=pbuz2_plus_vwuz1 
    lda.z end
    clc
    adc.z str
    sta.z end
    lda.z end+1
    adc.z str+1
    sta.z end+1
    // [184] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#5
    // [185] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  __b2_from___b1:
  __b2_from___b3:
    // [185] phi (byte*) memset::dst#2 = (byte*) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp __b2
    // memset::@2
  __b2:
    // [186] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    jmp __breturn
    // memset::@return
  __breturn:
    // [187] return 
    rts
    // memset::@3
  __b3:
    // [188] *((byte*) memset::dst#2) ← (byte) memset::c#6 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // [189] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2_from___b3
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [190] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #0
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // [191] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [192] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [193] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [194] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    jmp __breturn
    // clock_start::@return
  __breturn:
    // [195] return 
    rts
}
  // textcolor
// Set the color for text output. The old color setting is returned.
textcolor: {
    jmp __breturn
    // textcolor::@return
  __breturn:
    // [197] return 
    rts
}
  // setup_irq
// Setup raster IRQ to change charset at different lines
setup_irq: {
    // asm { sei  }
    sei
    // [199] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // [200] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line to 8 pixels before the border
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // [201] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 -- _deref_pbuc1=vbuc2 
    lda #BORDER_YPOS_BOTTOM-8
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [202] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // [203] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() -- _deref_pptc1=pprc2 
    // Set the IRQ routine
    lda #<irq_bottom_1
    sta KERNEL_IRQ
    lda #>irq_bottom_1
    sta KERNEL_IRQ+1
    // asm { cli  }
    cli
    jmp __breturn
    // setup_irq::@return
  __breturn:
    // [205] return 
    rts
}
  // irq_bottom_2
// Interrupt Routine 2
irq_bottom_2: {
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>LINE_BUFFER)/4&$f
    // entry interrupt(KERNEL_KEYBOARD)
    // [206] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    // Change border color
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [207] call kbhit 
    jsr kbhit
    // [208] (byte) kbhit::return#2 ← (byte) kbhit::return#0
    jmp __b4
    // irq_bottom_2::@4
  __b4:
    // [209] (byte~) irq_bottom_2::$0 ← (byte) kbhit::return#2
    // [210] if((byte) 0==(byte~) irq_bottom_2::$0) goto irq_bottom_2::@1 -- vbuc1_eq_vbuaa_then_la1 
    // Show the current canvas (unless a key is being pressed)
    cmp #0
    beq __b1
    // [211] phi from irq_bottom_2::@4 to irq_bottom_2::toD0181 [phi:irq_bottom_2::@4->irq_bottom_2::toD0181]
  toD0181_from___b4:
    jmp toD0181
    // irq_bottom_2::toD0181
  toD0181:
    jmp __b3
    // irq_bottom_2::@3
  __b3:
    // [212] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_2::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_MEMORY
    jmp __b2
    // irq_bottom_2::@2
  __b2:
    // [213] (volatile byte) canvas_show_flag ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z canvas_show_flag
    // [214] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // [215] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 -- _deref_pbuc1=vbuc2 
    // Trigger IRQ 1 at 8 pixels before the border
    lda #BORDER_YPOS_BOTTOM-8
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [216] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() -- _deref_pptc1=pprc2 
    lda #<irq_bottom_1
    sta KERNEL_IRQ
    lda #>irq_bottom_1
    sta KERNEL_IRQ+1
    jmp __breturn
    // irq_bottom_2::@return
  __breturn:
    // [217] return  - exit interrupt(KERNEL_KEYBOARD)
    jmp $ea31
    // irq_bottom_2::@1
  __b1:
    // [218] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (volatile byte) canvas_show_memory -- _deref_pbuc1=vbuz1 
    lda.z canvas_show_memory
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_MEMORY
    jmp __b2
}
  // kbhit
// Return true if there's a key waiting, return false if not
kbhit: {
    // CIA#1 Port A: keyboard matrix columns and joystick #2
    .label CIA1_PORT_A = $dc00
    // CIA#1 Port B: keyboard matrix rows and joystick #1.
    .label CIA1_PORT_B = $dc01
    // [219] *((const nomodify byte*) kbhit::CIA1_PORT_A) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta CIA1_PORT_A
    // [220] (byte) kbhit::return#0 ← ~ *((const nomodify byte*) kbhit::CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    jmp __breturn
    // kbhit::@return
  __breturn:
    // [221] return 
    rts
}
  // irq_bottom_1
// Interrupt Routine 1: Just above last text line.
irq_bottom_1: {
    .const toD0181_return = (>(CONSOLE&$3fff)*4)|(>PETSCII)/4&$f
    // entry interrupt(KERNEL_MIN)
    // [222] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) DARK_GREY -- _deref_pbuc1=vbuc2 
    // Change border color
    lda #DARK_GREY
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [223] phi from irq_bottom_1 to irq_bottom_1::toD0181 [phi:irq_bottom_1->irq_bottom_1::toD0181]
  toD0181_from_irq_bottom_1:
    jmp toD0181
    // irq_bottom_1::toD0181
  toD0181:
    jmp __b1
    // irq_bottom_1::@1
  __b1:
    // [224] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_1::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    // Show the cycle counter
    lda #toD0181_return
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_MEMORY
    // [225] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // [226] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM -- _deref_pbuc1=vbuc2 
    // Trigger IRQ 2 at bottom of text-line
    lda #BORDER_YPOS_BOTTOM
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [227] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2() -- _deref_pptc1=pprc2 
    lda #<irq_bottom_2
    sta KERNEL_IRQ
    lda #>irq_bottom_2
    sta KERNEL_IRQ+1
    jmp __breturn
    // irq_bottom_1::@return
  __breturn:
    // [228] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
}
  // File Data
  // SIN/COS tables
  .align $100
SINTAB:
.fill $200, round(63 + 63*sin(i*2*PI/$100))

  // Column offsets
  plot_column: .word LINE_BUFFER, LINE_BUFFER+1*$80, LINE_BUFFER+2*$80, LINE_BUFFER+3*$80, LINE_BUFFER+4*$80, LINE_BUFFER+5*$80, LINE_BUFFER+6*$80, LINE_BUFFER+7*$80, LINE_BUFFER+8*$80, LINE_BUFFER+9*$80, LINE_BUFFER+$a*$80, LINE_BUFFER+$b*$80, LINE_BUFFER+$c*$80, LINE_BUFFER+$d*$80, LINE_BUFFER+$e*$80, LINE_BUFFER+$f*$80
  // The bits used for plotting a pixel
  plot_bit: .byte $80, $40, $20, $10, 8, 4, 2, 1

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp toD0181
Removing instruction jmp __b2
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b12
Removing instruction jmp __b13
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b14
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b15
Removing instruction jmp __b16
Removing instruction jmp __b17
Removing instruction jmp __b18
Removing instruction jmp __b19
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __b20
Removing instruction jmp toD0181
Removing instruction jmp toD0182
Removing instruction jmp __b11
Removing instruction jmp __b21
Removing instruction jmp __b4
Removing instruction jmp __b6
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __b19
Removing instruction jmp __b20
Removing instruction jmp __b21
Removing instruction jmp __b22
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b8
Removing instruction jmp plot2
Removing instruction jmp __b16
Removing instruction jmp __b7
Removing instruction jmp plot3
Removing instruction jmp __breturn
Removing instruction jmp __b15
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp plot4
Removing instruction jmp __b17
Removing instruction jmp __b12
Removing instruction jmp plot5
Removing instruction jmp __b18
Removing instruction jmp __b14
Removing instruction jmp __b13
Removing instruction jmp plot6
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b4
Removing instruction jmp toD0181
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp toD0181
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #BLACK
Removing instruction ldy.z p0_idx
Removing instruction ldy.z p1_idx
Removing instruction ldy.z p2_idx
Removing instruction ldy #0
Removing instruction ldy.z y
Removing instruction ldy.z y
Removing instruction ldy.z y
Removing instruction ldy.z y
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b7 with __b8
Replacing label __b1_from___b22 with __b1
Replacing label __b7_from___b6 with __b7
Replacing label __b6_from___b7 with __b6
Replacing label __b10_from___b10 with __b10
Replacing label __b10_from___b17 with __b10
Replacing label __b13_from___b18 with __b13
Replacing label __b12_from___b13 with plot5
Replacing label __b1_from_sgn_u8 with __b1
Replacing label __b2_from___b3 with __b2
Removing instruction toD0181_from___bbegin:
Removing instruction toD0181:
Removing instruction __b2:
Removing instruction __b1_from___b2:
Removing instruction main_from___b1:
Removing instruction __bend_from___b1:
Removing instruction __b12_from_main:
Removing instruction __b13_from___b12:
Removing instruction memset_from___b13:
Removing instruction __b14_from___b3:
Removing instruction __b7:
Removing instruction __b8_from___b7:
Removing instruction __b15_from___b8:
Removing instruction toD0181_from___b20:
Removing instruction toD0181:
Removing instruction toD0182_from_toD0181:
Removing instruction toD0182:
Removing instruction __b7_from___b21:
Removing instruction __b1_from___b22:
Removing instruction __b1_from___b3:
Removing instruction __b6_from___b5:
Removing instruction __b6_from___b7:
Removing instruction __b7_from___b16:
Removing instruction __b7_from___b6:
Removing instruction __b10_from___b10:
Removing instruction __b10_from___b17:
Removing instruction __b10_from___b9:
Removing instruction __b12_from___b13:
Removing instruction __b12_from___b2:
Removing instruction __b12:
Removing instruction __b13_from___b14:
Removing instruction __b13_from___b18:
Removing instruction __b1_from_sgn_u8:
Removing instruction __breturn_from___b1:
Removing instruction __breturn_from_abs_u8:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b3:
Removing instruction toD0181_from___b4:
Removing instruction toD0181:
Removing instruction toD0181_from_irq_bottom_1:
Removing instruction toD0181:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1:
Removing instruction __bend:
Removing instruction memset_from_main:
Removing instruction __b12:
Removing instruction memset_from___b12:
Removing instruction __b13:
Removing instruction __b1_from___b13:
Removing instruction __b3:
Removing instruction __b14:
Removing instruction textcolor_from___b14:
Removing instruction __b7_from___b14:
Removing instruction __b15:
Removing instruction memset_from___b15:
Removing instruction __b16:
Removing instruction line_from___b16:
Removing instruction __b17:
Removing instruction line_from___b17:
Removing instruction __b18:
Removing instruction line_from___b18:
Removing instruction __b19:
Removing instruction __b10:
Removing instruction eorfill_from___b10:
Removing instruction __b20:
Removing instruction __b11:
Removing instruction clock_from___b11:
Removing instruction __b21:
Removing instruction __b4_from___b2:
Removing instruction __b6:
Removing instruction __b1_from___b6:
Removing instruction __b4_from___b5:
Removing instruction __breturn:
Removing instruction __b1_from_eorfill:
Removing instruction __breturn:
Removing instruction __b3_from___b2:
Removing instruction __b5:
Removing instruction __b1_from___b5:
Removing instruction __b3_from___b4:
Removing instruction abs_u8_from_line:
Removing instruction __b19:
Removing instruction abs_u8_from___b19:
Removing instruction __b20:
Removing instruction sgn_u8_from___b20:
Removing instruction __b21:
Removing instruction sgn_u8_from___b21:
Removing instruction __b22:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b8:
Removing instruction plot2:
Removing instruction __b16:
Removing instruction plot3:
Removing instruction __b15:
Removing instruction __b11:
Removing instruction plot4:
Removing instruction __b17:
Removing instruction __b18:
Removing instruction __b14:
Removing instruction plot6:
Removing instruction __breturn_from_sgn_u8:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b4:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b1:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Replacing jump to rts with rts in jmp __breturn
Replacing jump to rts with rts in jmp __breturn
Replacing jump to rts with rts in jmp __breturn
Replacing jump to rts with rts in jmp __breturn
Replacing jump to rts with rts in jmp __breturn
Skipping double jump to __breturn in jmp __breturn_from___b1
Succesful ASM optimization Pass5DoubleJumpElimination
Relabelling long label __breturn_from___b1 to __b2
Succesful ASM optimization Pass5RelabelLongLabels
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing instruction lda.z y with TYA
Removing instruction lda.z x
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b2:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Fixing long branch [133] bcc __b2 to bcs
Fixing long branch [373] bcc __b2 to bcs

FINAL SYMBOL TABLE
(label) @1
(label) @2
(label) @begin
(label) @end
(const nomodify byte) BLACK = (byte) 0
(const nomodify byte) BORDER_YPOS_BOTTOM = (byte) $fa
(const nomodify byte*) CANVAS1 = (byte*) 12288
(const nomodify byte*) CANVAS2 = (byte*) 14336
(const nomodify struct MOS6526_CIA*) CIA1 = (struct MOS6526_CIA*) 56320
(const nomodify struct MOS6526_CIA*) CIA2 = (struct MOS6526_CIA*) 56576
(const nomodify dword*) CIA2_TIMER_AB = (dword*) 56580
(const nomodify byte) CIA_INTERRUPT_CLEAR = (byte) $7f
(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = (byte) $40
(const nomodify byte) CIA_TIMER_CONTROL_START = (byte) 1
(const nomodify byte*) COLS = (byte*) 55296
(const nomodify byte*) CONSOLE = (byte*) 1024
(const byte*) COSTAB = (const byte*) SINTAB+(byte) $40
(const nomodify byte) DARK_GREY = (byte) $b
(const nomodify byte) IRQ_RASTER = (byte) 1
(const nomodify void()**) KERNEL_IRQ = (void()**) 788
(const nomodify byte*) LINE_BUFFER = (byte*) 8192
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = (byte) $d
(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = (byte) $e
(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = (byte) $f
(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = (byte) $21
(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = (byte) $20
(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = (byte) $11
(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = (byte) $1a
(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = (byte) $19
(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY = (byte) $18
(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER = (byte) $12
(const nomodify byte*) PETSCII = (byte*) 4096
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(const nomodify byte) RED = (byte) 2
(const nomodify byte*) SCREEN = (byte*) 11264
(const byte*) SINTAB[(number) $140]  = kickasm {{ .fill $200, round(63 + 63*sin(i*2*PI/$100))
 }}
(const nomodify struct MOS6569_VICII*) VICII = (struct MOS6569_VICII*) 53248
(const nomodify byte) WHITE = (byte) 1
(byte()) abs_u8((byte) abs_u8::u)
(byte~) abs_u8::$0 reg byte x 20002.0
(label) abs_u8::@1
(label) abs_u8::@return
(byte) abs_u8::return
(byte) abs_u8::return#0 reg byte a 2002.0
(byte) abs_u8::return#1 reg byte a 2002.0
(byte) abs_u8::return#2 reg byte a 20002.0
(byte) abs_u8::return#4 reg byte a 5501.0
(byte) abs_u8::u
(byte) abs_u8::u#0 reg byte a 2002.0
(byte) abs_u8::u#1 reg byte a 2002.0
(byte) abs_u8::u#2 reg byte a 10668.333333333332
(volatile byte) canvas_show_flag loadstore zp[1]:18 18.74576271186441
(volatile byte) canvas_show_memory loadstore zp[1]:17 2.8611111111111107
(dword()) clock()
(label) clock::@return
(dword) clock::return
(void()) clock_start()
(label) clock_start::@return
(void()) eorfill((byte*) eorfill::line_buffer , (byte*) eorfill::canvas)
(label) eorfill::@1
(label) eorfill::@2
(label) eorfill::@3
(label) eorfill::@4
(label) eorfill::@5
(label) eorfill::@return
(byte*) eorfill::canvas
(byte*) eorfill::canvas#0 canvas zp[2]:31 551.0
(byte) eorfill::eor
(byte) eorfill::eor#0 reg byte a 150001.5
(byte) eorfill::eor#1 reg byte a 1000001.0
(byte) eorfill::eor#2 reg byte a 1050001.5
(byte*) eorfill::fill_column
(byte*) eorfill::fill_column#1 fill_column zp[2]:31 100001.0
(byte*) eorfill::fill_column#2 fill_column zp[2]:31 130100.5
(byte*) eorfill::line_buffer
(byte*) eorfill::line_column
(byte*) eorfill::line_column#1 line_column zp[2]:28 66667.33333333333
(byte*) eorfill::line_column#2 line_column zp[2]:28 144444.88888888888
(byte) eorfill::x
(byte) eorfill::x#1 reg byte x 200002.0
(byte) eorfill::x#2 reg byte x 27273.0
(byte) eorfill::y
(byte) eorfill::y#1 reg byte y 2000002.0
(byte) eorfill::y#2 reg byte y 1250001.25
interrupt(KERNEL_MIN)(void()) irq_bottom_1()
(label) irq_bottom_1::@1
(label) irq_bottom_1::@return
(label) irq_bottom_1::toD0181
(byte*) irq_bottom_1::toD0181_gfx
(byte) irq_bottom_1::toD0181_return
(const byte) irq_bottom_1::toD0181_return#0 toD0181_return = >(word)(const nomodify byte*) CONSOLE&(word) $3fff*(byte) 4|>(word)(const nomodify byte*) PETSCII/(byte) 4&(byte) $f
(byte*) irq_bottom_1::toD0181_screen
interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2()
(byte~) irq_bottom_2::$0 reg byte a 4.0
(label) irq_bottom_2::@1
(label) irq_bottom_2::@2
(label) irq_bottom_2::@3
(label) irq_bottom_2::@4
(label) irq_bottom_2::@return
(label) irq_bottom_2::toD0181
(byte*) irq_bottom_2::toD0181_gfx
(byte) irq_bottom_2::toD0181_return
(const byte) irq_bottom_2::toD0181_return#0 toD0181_return = >(word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4|>(word)(const nomodify byte*) LINE_BUFFER/(byte) 4&(byte) $f
(byte*) irq_bottom_2::toD0181_screen
(byte()) kbhit()
(label) kbhit::@return
(const nomodify byte*) kbhit::CIA1_PORT_A = (byte*) 56320
(const nomodify byte*) kbhit::CIA1_PORT_B = (byte*) 56321
(byte) kbhit::return
(byte) kbhit::return#0 reg byte a 4.333333333333333
(byte) kbhit::return#2 reg byte a 4.0
(void()) line((byte*) line::canvas , (byte) line::x1 , (byte) line::y1 , (byte) line::x2 , (byte) line::y2)
(label) line::@1
(label) line::@10
(label) line::@11
(label) line::@12
(label) line::@13
(label) line::@14
(label) line::@15
(label) line::@16
(label) line::@17
(label) line::@18
(label) line::@19
(label) line::@2
(label) line::@20
(label) line::@21
(label) line::@22
(label) line::@3
(label) line::@4
(label) line::@5
(label) line::@6
(label) line::@7
(label) line::@8
(label) line::@9
(label) line::@return
(byte*) line::canvas
(byte) line::dx
(byte) line::dx#0 dx zp[1]:23 19462.805970149253
(byte) line::dy
(byte) line::dy#0 dy zp[1]:24 22285.85714285714
(byte) line::e
(byte) line::e#0 reg byte x 2002.0
(byte) line::e#1 reg byte x 44444.88888888889
(byte) line::e#2 reg byte x 200002.0
(byte) line::e#3 reg byte x 100501.5
(byte) line::e#5 reg byte x 150001.5
(byte) line::e1
(byte) line::e1#0 e1 zp[1]:14 2002.0
(byte) line::e1#1 e1 zp[1]:14 1033334.6666666666
(byte) line::e1#2 e1 zp[1]:14 28571.714285714286
(byte) line::e1#3 e1 zp[1]:14 1050502.0
(byte) line::e2
(byte) line::e2#0 reg byte x 2002.0
(byte) line::e2#1 reg byte x 133334.66666666666
(byte) line::e2#2 reg byte x 200002.0
(byte) line::e2#3 reg byte x 28714.714285714286
(byte) line::e2#7 reg byte x 150001.5
(label) line::plot1
(byte~) line::plot1_$0 reg byte a 2002.0
(byte~) line::plot1_$1 reg byte a 2002.0
(byte~) line::plot1_$2 reg byte a 2002.0
(byte*) line::plot1_column
(byte*) line::plot1_column#0 plot1_column zp[2]:33 1501.5
(byte) line::plot1_x
(byte) line::plot1_y
(label) line::plot2
(byte~) line::plot2_$0 reg byte a 200002.0
(byte~) line::plot2_$1 zp[1]:30 200002.0
(byte~) line::plot2_$2 reg byte a 200002.0
(byte*) line::plot2_column
(byte*) line::plot2_column#0 plot2_column zp[2]:28 150001.5
(byte) line::plot2_x
(byte) line::plot2_y
(byte) line::plot2_y#0 plot2_y zp[1]:27 60000.600000000006
(label) line::plot3
(byte~) line::plot3_$0 reg byte a 2002.0
(byte~) line::plot3_$1 reg byte a 2002.0
(byte~) line::plot3_$2 reg byte a 2002.0
(byte*) line::plot3_column
(byte*) line::plot3_column#0 plot3_column zp[2]:31 1501.5
(byte) line::plot3_x
(byte) line::plot3_y
(label) line::plot4
(byte~) line::plot4_$0 reg byte a 200002.0
(byte~) line::plot4_$1 reg byte a 200002.0
(byte~) line::plot4_$2 reg byte a 200002.0
(byte*) line::plot4_column
(byte*) line::plot4_column#0 plot4_column zp[2]:35 150001.5
(byte) line::plot4_x
(byte) line::plot4_y
(label) line::plot5
(byte~) line::plot5_$0 reg byte a 200002.0
(byte~) line::plot5_$1 zp[1]:39 200002.0
(byte~) line::plot5_$2 reg byte a 200002.0
(byte*) line::plot5_column
(byte*) line::plot5_column#0 plot5_column zp[2]:37 150001.5
(byte) line::plot5_x
(byte) line::plot5_y
(label) line::plot6
(byte~) line::plot6_$0 reg byte a 2002.0
(byte~) line::plot6_$1 reg byte a 2002.0
(byte~) line::plot6_$2 reg byte a 2002.0
(byte*) line::plot6_column
(byte*) line::plot6_column#0 plot6_column zp[2]:40 1501.5
(byte) line::plot6_x
(byte) line::plot6_y
(byte) line::sx
(byte) line::sx#0 sx zp[1]:25 5135.6949152542375
(byte) line::sy
(byte) line::sy#0 sy zp[1]:26 23672.836363636365
(byte) line::x
(byte) line::x#0 x zp[1]:15 228.4375
(byte) line::x#1 x zp[1]:15 100001.0
(byte) line::x#10 x zp[1]:15 66834.16666666666
(byte) line::x#12 x zp[1]:15 30200.5
(byte) line::x#15 x zp[1]:15 50100.6
(byte) line::x#17 x zp[1]:15 60401.0
(byte) line::x#18 x zp[1]:15 550251.25
(byte) line::x#19 x zp[1]:15 62500.625
(byte) line::x1
(byte) line::x1#0 x1 zp[1]:15 50.5
(byte) line::x1#1 x1 zp[1]:15 50.5
(byte) line::x1#2 x1 zp[1]:15 50.5
(byte) line::x2
(byte) line::x2#0 x2 zp[1]:12 101.0
(byte) line::x2#1 x2 zp[1]:12 101.0
(byte) line::x2#15 x2 zp[1]:12 3612.625
(byte) line::x2#2 x2 zp[1]:12 101.0
(byte) line::y
(byte) line::y#0 y zp[1]:16 239.27777777777777
(byte) line::y#1 y zp[1]:16 1001.0
(byte) line::y#10 y zp[1]:16 23647.411764705877
(byte) line::y#11 y zp[1]:16 2101004.0
(byte) line::y#12 y zp[1]:16 209091.36363636365
(byte) line::y#13 y zp[1]:16 55667.33333333333
(byte) line::y#15 y zp[1]:16 50334.16666666667
(byte) line::y#17 y zp[1]:16 583.9166666666667
(byte) line::y#4 y zp[1]:16 100001.0
(byte) line::y#7 y zp[1]:16 201003.0
(byte) line::y1
(byte) line::y1#0 y1 zp[1]:16 67.33333333333333
(byte) line::y1#1 y1 zp[1]:16 67.33333333333333
(byte) line::y1#2 y1 zp[1]:16 67.33333333333333
(byte) line::y2
(byte) line::y2#0 y2 zp[1]:13 202.0
(byte) line::y2#1 y2 zp[1]:13 202.0
(byte) line::y2#10 y2 zp[1]:13 226.68421052631578
(byte) line::y2#13 y2 zp[1]:13 5666.833333333334
(byte) line::y2#2 y2 zp[1]:13 202.0
(byte) line::y2#3 y2 zp[1]:13 2002.0
(void()) main()
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(byte) main::c
(byte) main::c#1 reg byte x 1001.0
(byte) main::c#2 reg byte x 776.0
(byte) main::c#4 reg byte x 202.0
(byte*) main::canvas
(word) main::canvas#1 canvas zp[2]:10 16.833333333333332
(byte*) main::canvas#10 canvas zp[2]:10 8.911764705882353
(byte*) main::canvas#19 canvas zp[2]:10 202.0
(byte*) main::cols
(byte*) main::cols#1 cols zp[2]:3 67.33333333333333
(byte*) main::cols#5 cols zp[2]:3 133.66666666666669
(byte) main::p0_idx
(byte) main::p0_idx#1 p0_idx zp[1]:7 13.466666666666667
(byte) main::p0_idx#2 p0_idx zp[1]:7 15.538461538461538
(byte) main::p1_idx
(byte) main::p1_idx#1 p1_idx zp[1]:8 14.428571428571429
(byte) main::p1_idx#2 p1_idx zp[1]:8 14.962962962962964
(byte) main::p2_idx
(byte) main::p2_idx#1 p2_idx zp[1]:9 15.538461538461538
(byte) main::p2_idx#2 p2_idx zp[1]:9 14.428571428571429
(byte*) main::screen
(byte*) main::screen#1 screen zp[2]:5 101.0
(byte*) main::screen#5 screen zp[2]:5 120.3
(label) main::toD0181
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(const byte) main::toD0181_return#0 toD0181_return = >(word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4|>(word)(const nomodify byte*) CANVAS1/(byte) 4&(byte) $f
(byte*) main::toD0181_screen
(label) main::toD0182
(byte*) main::toD0182_gfx
(byte) main::toD0182_return
(const byte) main::toD0182_return#0 toD0182_return = >(word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4|>(word)(const nomodify byte*) CANVAS2/(byte) 4&(byte) $f
(byte*) main::toD0182_screen
(byte) main::x
(byte) main::x#1 reg byte y 2002.0
(byte) main::x#2 reg byte y 1001.0
(byte) main::x0
(byte) main::x0#0 x0 zp[1]:19 16.833333333333332
(byte) main::x1
(byte) main::x1#0 x1 zp[1]:12 33.666666666666664
(byte) main::x2
(byte) main::x2#0 x2 zp[1]:12 43.285714285714285
(byte) main::y
(byte) main::y#1 y zp[1]:2 202.0
(byte) main::y#2 y zp[1]:2 36.72727272727273
(byte) main::y0
(byte) main::y0#0 y0 zp[1]:20 16.833333333333332
(byte) main::y1
(byte) main::y1#0 y1 zp[1]:21 33.666666666666664
(byte) main::y2
(byte) main::y2#0 y2 zp[1]:22 43.285714285714285
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(label) memset::@1
(label) memset::@2
(label) memset::@3
(label) memset::@return
(byte) memset::c
(byte) memset::c#6 reg byte x 12500.125
(byte*) memset::dst
(byte*) memset::dst#1 dst zp[2]:31 200002.0
(byte*) memset::dst#2 dst zp[2]:31 133668.3333333333
(byte*) memset::dst#4 dst zp[2]:31 2002.0
(byte*) memset::end
(byte*) memset::end#0 end zp[2]:28 16833.666666666664
(word) memset::num
(word) memset::num#4 num zp[2]:28 1001.0
(void*) memset::return
(void*) memset::str
(void*) memset::str#5 str zp[2]:31
(const byte*) plot_bit[(number) 8]  = { (byte) $80, (byte) $40, (byte) $20, (byte) $10, (byte) 8, (byte) 4, (byte) 2, (byte) 1 }
(const byte**) plot_column[(number) $10]  = { (const nomodify byte*) LINE_BUFFER, (const nomodify byte*) LINE_BUFFER+(byte)(number) 1*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) 2*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) 3*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) 4*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) 5*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) 6*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) 7*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) 8*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) 9*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) $a*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) $b*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) $c*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) $d*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) $e*(number) $80, (const nomodify byte*) LINE_BUFFER+(word)(number) $f*(number) $80 }
(const byte*) printf_buffer_number::digits[(number) $b]  = { fill( $b, 0) }
(byte) printf_buffer_number::sign
(byte) printf_format_number::justify_left
(byte) printf_format_number::min_length
(byte) printf_format_number::radix
(byte) printf_format_number::sign_always
(byte) printf_format_number::upper_case
(byte) printf_format_number::zero_padding
(byte) printf_format_string::justify_left
(byte) printf_format_string::min_length
(void()) setup_irq()
(label) setup_irq::@return
(byte()) sgn_u8((byte) sgn_u8::u)
(byte~) sgn_u8::$0 reg byte a 20002.0
(label) sgn_u8::@1
(label) sgn_u8::@return
(byte) sgn_u8::return
(byte) sgn_u8::return#0 reg byte a 2002.0
(byte) sgn_u8::return#1 reg byte a 2002.0
(byte) sgn_u8::return#4 reg byte a 500.5
(byte) sgn_u8::u
(byte) sgn_u8::u#0 reg byte a 2002.0
(byte) sgn_u8::u#1 reg byte a 2002.0
(byte) sgn_u8::u#2 reg byte a 12003.0
(byte()) textcolor((byte) textcolor::color)
(label) textcolor::@return
(byte) textcolor::color
(byte) textcolor::old
(byte) textcolor::return
(label) toD0181
(byte*) toD0181_gfx
(byte) toD0181_return
(const byte) toD0181_return#0 toD0181_return = >(word)(const nomodify byte*) SCREEN&(word) $3fff*(byte) 4|>(word)(const nomodify byte*) CANVAS2/(byte) 4&(byte) $f
(byte*) toD0181_screen

zp[1]:2 [ main::y#2 main::y#1 ]
zp[2]:3 [ main::cols#5 main::cols#1 ]
zp[2]:5 [ main::screen#5 main::screen#1 ]
zp[1]:7 [ main::p0_idx#2 main::p0_idx#1 ]
zp[1]:8 [ main::p1_idx#2 main::p1_idx#1 ]
zp[1]:9 [ main::p2_idx#2 main::p2_idx#1 ]
zp[2]:10 [ main::canvas#10 main::canvas#19 main::canvas#1 ]
reg byte y [ main::x#2 main::x#1 ]
reg byte x [ main::c#2 main::c#4 main::c#1 ]
reg byte x [ eorfill::x#2 eorfill::x#1 ]
reg byte y [ eorfill::y#2 eorfill::y#1 ]
reg byte a [ eorfill::eor#2 eorfill::eor#0 eorfill::eor#1 ]
zp[1]:12 [ line::x2#15 line::x2#0 line::x2#1 line::x2#2 main::x1#0 main::x2#0 ]
zp[1]:13 [ line::y2#13 line::y2#10 line::y2#0 line::y2#1 line::y2#2 line::y2#3 ]
reg byte x [ line::e#3 line::e#0 line::e#5 line::e#2 line::e#1 ]
zp[1]:14 [ line::e1#3 line::e1#0 line::e1#1 line::e1#2 ]
zp[1]:15 [ line::x#10 line::x#12 line::x#18 line::x#15 line::x#0 line::x1#0 line::x1#1 line::x1#2 line::x#17 line::x#1 line::x#19 ]
zp[1]:16 [ line::y#13 line::y#15 line::y#11 line::y#7 line::y#17 line::y#0 line::y1#0 line::y1#1 line::y1#2 line::y#1 line::y#10 line::y#12 line::y#4 ]
reg byte x [ line::e2#3 line::e2#7 line::e2#0 line::e2#2 line::e2#1 ]
reg byte a [ sgn_u8::u#2 sgn_u8::u#0 sgn_u8::u#1 ]
reg byte a [ sgn_u8::return#4 ]
reg byte a [ abs_u8::return#4 abs_u8::return#2 abs_u8::u#2 abs_u8::u#0 abs_u8::u#1 ]
reg byte x [ memset::c#6 ]
zp[1]:17 [ canvas_show_memory ]
zp[1]:18 [ canvas_show_flag ]
zp[1]:19 [ main::x0#0 ]
zp[1]:20 [ main::y0#0 ]
zp[1]:21 [ main::y1#0 ]
zp[1]:22 [ main::y2#0 ]
reg byte a [ abs_u8::return#0 ]
zp[1]:23 [ line::dx#0 ]
reg byte a [ abs_u8::return#1 ]
zp[1]:24 [ line::dy#0 ]
reg byte a [ sgn_u8::return#0 ]
zp[1]:25 [ line::sx#0 ]
reg byte a [ sgn_u8::return#1 ]
zp[1]:26 [ line::sy#0 ]
zp[1]:27 [ line::plot2_y#0 ]
reg byte a [ line::plot2_$0 ]
reg byte a [ line::plot2_$2 ]
zp[2]:28 [ line::plot2_column#0 memset::num#4 memset::end#0 eorfill::line_column#2 eorfill::line_column#1 ]
zp[1]:30 [ line::plot2_$1 ]
reg byte a [ line::plot3_$0 ]
reg byte a [ line::plot3_$2 ]
zp[2]:31 [ line::plot3_column#0 memset::str#5 memset::dst#2 memset::dst#4 memset::dst#1 eorfill::fill_column#2 eorfill::canvas#0 eorfill::fill_column#1 ]
reg byte a [ line::plot3_$1 ]
reg byte a [ line::plot1_$0 ]
reg byte a [ line::plot1_$2 ]
zp[2]:33 [ line::plot1_column#0 ]
reg byte a [ line::plot1_$1 ]
reg byte a [ line::plot4_$0 ]
reg byte a [ line::plot4_$2 ]
zp[2]:35 [ line::plot4_column#0 ]
reg byte a [ line::plot4_$1 ]
reg byte a [ line::plot5_$0 ]
reg byte a [ line::plot5_$2 ]
zp[2]:37 [ line::plot5_column#0 ]
zp[1]:39 [ line::plot5_$1 ]
reg byte a [ line::plot6_$0 ]
reg byte a [ line::plot6_$2 ]
zp[2]:40 [ line::plot6_column#0 ]
reg byte a [ line::plot6_$1 ]
reg byte a [ sgn_u8::$0 ]
reg byte x [ abs_u8::$0 ]
reg byte a [ kbhit::return#2 ]
reg byte a [ irq_bottom_2::$0 ]
reg byte a [ kbhit::return#0 ]


FINAL ASSEMBLER
Score: 106699

  // File Comments
// Filling a simple 16x16 2D polygon using EOR-filling
// - Clearing canvas
// - Trivial 2D rotation using sine tables
// - Line-drawing polygon edges (fill-ready lines)
// - Up-to-down EOR filling 
// - Double buffering
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  .const BORDER_YPOS_BOTTOM = $fa
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const DARK_GREY = $b
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
  .const OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
  .const OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = $21
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MOS6569_VICII_MEMORY = $18
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const toD0181_return = (>(SCREEN&$3fff)*4)|(>CANVAS2)/4&$f
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // Color Ram
  .label COLS = $d800
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#2 timer A&B as one single 32-bit value
  .label CIA2_TIMER_AB = $dd04
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  // The line buffer
  .label LINE_BUFFER = $2000
  // The two charsets used as screen buffers
  .label CANVAS1 = $3000
  .label CANVAS2 = $3800
  // The screen matrix
  .label SCREEN = $2c00
  // The screen console
  .label CONSOLE = $400
  // The default charset address
  .label PETSCII = $1000
  .label COSTAB = SINTAB+$40
  .label canvas_show_memory = $11
  .label canvas_show_flag = $12
  // @begin
__bbegin:
  // [1] phi from @begin to toD0181 [phi:@begin->toD0181]
  // toD0181
  // @2
  // canvas_show_memory = toD018(SCREEN, CANVAS2)
  // [2] (volatile byte) canvas_show_memory ← (const byte) toD0181_return#0 -- vbuz1=vbuc1 
  // The current canvas being rendered to the screen - in D018 format.
  lda #toD0181_return
  sta.z canvas_show_memory
  // canvas_show_flag = 0
  // [3] (volatile byte) canvas_show_flag ← (byte) 0 -- vbuz1=vbuc1 
  // Flag signalling that the canvas on screen needs to be updated.
  // Set to 1 by the renderer when a new canvas is ready for showing, and to 0 by the raster when the canvas is shown on screen.
  lda #0
  sta.z canvas_show_flag
  // [4] phi from @2 to @1 [phi:@2->@1]
  // @1
  // [5] call main 
  // [7] phi from @1 to main [phi:@1->main]
  jsr main
  rts
  // [6] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>CANVAS1)/4&$f
    .const toD0182_return = (>(SCREEN&$3fff)*4)|(>CANVAS2)/4&$f
    .label cols = 3
    // Setup 16x16 canvas for rendering
    .label screen = 5
    .label y = 2
    .label x0 = $13
    .label y0 = $14
    .label x1 = $c
    .label y1 = $15
    .label x2 = $c
    .label y2 = $16
    .label p0_idx = 7
    .label p1_idx = 8
    .label p2_idx = 9
    // The current canvas being rendered to
    .label canvas = $a
    // memset(CONSOLE, ' ', 40*25)
    // [8] call memset 
  // Clear the console
    // [181] phi from main to memset [phi:main->memset]
    // [181] phi (byte) memset::c#6 = (byte) ' ' [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #' '
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) CONSOLE [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<CONSOLE
    sta.z memset.str
    lda #>CONSOLE
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word)(number) $28*(number) $19 [phi:main->memset#2] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta.z memset.num
    lda #>$28*$19
    sta.z memset.num+1
    jsr memset
    // [9] phi from main to main::@12 [phi:main->main::@12]
    // main::@12
    // memset(SCREEN, 0, 40*25)
    // [10] call memset 
  // Clear the screen
    // [181] phi from main::@12 to memset [phi:main::@12->memset]
    // [181] phi (byte) memset::c#6 = (byte) 0 [phi:main::@12->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) SCREEN [phi:main::@12->memset#1] -- pvoz1=pvoc1 
    lda #<SCREEN
    sta.z memset.str
    lda #>SCREEN
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word)(number) $28*(number) $19 [phi:main::@12->memset#2] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta.z memset.num
    lda #>$28*$19
    sta.z memset.num+1
    jsr memset
    // [11] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
    // main::@13
    // memset(COLS, BLACK, 40*25)
    // [12] call memset 
    // [181] phi from main::@13 to memset [phi:main::@13->memset]
    // [181] phi (byte) memset::c#6 = (const nomodify byte) BLACK [phi:main::@13->memset#0] -- vbuxx=vbuc1 
    ldx #BLACK
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) COLS [phi:main::@13->memset#1] -- pvoz1=pvoc1 
    lda #<COLS
    sta.z memset.str
    lda #>COLS
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word)(number) $28*(number) $19 [phi:main::@13->memset#2] -- vwuz1=vwuc1 
    lda #<$28*$19
    sta.z memset.num
    lda #>$28*$19
    sta.z memset.num+1
    jsr memset
    // [13] phi from main::@13 to main::@1 [phi:main::@13->main::@1]
    // [13] phi (byte*) main::screen#5 = (const nomodify byte*) SCREEN+(byte) $c [phi:main::@13->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$c
    sta.z screen
    lda #>SCREEN+$c
    sta.z screen+1
    // [13] phi (byte*) main::cols#5 = (const nomodify byte*) COLS+(byte) $c [phi:main::@13->main::@1#1] -- pbuz1=pbuc1 
    lda #<COLS+$c
    sta.z cols
    lda #>COLS+$c
    sta.z cols+1
    // [13] phi (byte) main::y#2 = (byte) 0 [phi:main::@13->main::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // main::@1
  __b1:
    // for(char y=0;y<16;y++)
    // [14] if((byte) main::y#2<(byte) $10) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z y
    cmp #$10
    bcs !__b2+
    jmp __b2
  !__b2:
    // main::@3
    // VICII->BORDER_COLOR = BLACK
    // [15] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // VICII->BG_COLOR = BLACK
    // [16] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BG_COLOR
    // setup_irq()
    // [17] call setup_irq 
    // Set-up the raster IRQ
    jsr setup_irq
    // [18] phi from main::@3 to main::@14 [phi:main::@3->main::@14]
    // main::@14
    // textcolor(WHITE)
    // [19] call textcolor 
  // Set text color
    // [196] phi from main::@14 to textcolor [phi:main::@14->textcolor]
    jsr textcolor
    // [20] phi from main::@14 to main::@7 [phi:main::@14->main::@7]
    // [20] phi (byte*) main::canvas#10 = (const nomodify byte*) CANVAS1 [phi:main::@14->main::@7#0] -- pbuz1=pbuc1 
    lda #<CANVAS1
    sta.z canvas
    lda #>CANVAS1
    sta.z canvas+1
    // [20] phi (byte) main::p2_idx#2 = (byte) $b5+(byte) $aa [phi:main::@14->main::@7#1] -- vbuz1=vbuc1 
    lda #$b5+$aa
    sta.z p2_idx
    // [20] phi (byte) main::p1_idx#2 = (byte) $b5+(byte) $f [phi:main::@14->main::@7#2] -- vbuz1=vbuc1 
    lda #$b5+$f
    sta.z p1_idx
    // [20] phi (byte) main::p0_idx#2 = (byte) $b5 [phi:main::@14->main::@7#3] -- vbuz1=vbuc1 
    lda #$b5
    sta.z p0_idx
    // main::@7
    // [21] phi from main::@7 to main::@8 [phi:main::@7->main::@8]
    // main::@8
  __b8:
    // clock_start()
    // [22] call clock_start 
    jsr clock_start
    // [23] phi from main::@8 to main::@15 [phi:main::@8->main::@15]
    // main::@15
    // memset(LINE_BUFFER, 0, 0x0800)
    // [24] call memset 
  // Clear line buffer
    // [181] phi from main::@15 to memset [phi:main::@15->memset]
    // [181] phi (byte) memset::c#6 = (byte) 0 [phi:main::@15->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [181] phi (void*) memset::str#5 = (void*)(const nomodify byte*) LINE_BUFFER [phi:main::@15->memset#1] -- pvoz1=pvoc1 
    lda #<LINE_BUFFER
    sta.z memset.str
    lda #>LINE_BUFFER
    sta.z memset.str+1
    // [181] phi (word) memset::num#4 = (word) $800 [phi:main::@15->memset#2] -- vwuz1=vwuc1 
    lda #<$800
    sta.z memset.num
    lda #>$800
    sta.z memset.num+1
    jsr memset
    // main::@16
    // x0 = COSTAB[p0_idx]
    // [25] (byte) main::x0#0 ← *((const byte*) COSTAB + (byte) main::p0_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    // Plot in line buffer
    ldy.z p0_idx
    lda COSTAB,y
    sta.z x0
    // y0 = SINTAB[p0_idx]
    // [26] (byte) main::y0#0 ← *((const byte*) SINTAB + (byte) main::p0_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    lda SINTAB,y
    sta.z y0
    // x1 = COSTAB[p1_idx]
    // [27] (byte) main::x1#0 ← *((const byte*) COSTAB + (byte) main::p1_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p1_idx
    lda COSTAB,y
    sta.z x1
    // y1 = SINTAB[p1_idx]
    // [28] (byte) main::y1#0 ← *((const byte*) SINTAB + (byte) main::p1_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    lda SINTAB,y
    sta.z y1
    // line(LINE_BUFFER, x0, y0, x1, y1)
    // [29] (byte) line::x1#0 ← (byte) main::x0#0 -- vbuz1=vbuz2 
    lda.z x0
    sta.z line.x1
    // [30] (byte) line::y1#0 ← (byte) main::y0#0 -- vbuz1=vbuz2 
    lda.z y0
    sta.z line.y1
    // [31] (byte) line::x2#0 ← (byte) main::x1#0
    // [32] (byte) line::y2#0 ← (byte) main::y1#0 -- vbuz1=vbuz2 
    lda.z y1
    sta.z line.y2
    // [33] call line 
    // [87] phi from main::@16 to line [phi:main::@16->line]
    // [87] phi (byte) line::y2#10 = (byte) line::y2#0 [phi:main::@16->line#0] -- register_copy 
    // [87] phi (byte) line::x2#15 = (byte) line::x2#0 [phi:main::@16->line#1] -- register_copy 
    // [87] phi (byte) line::y#0 = (byte) line::y1#0 [phi:main::@16->line#2] -- register_copy 
    // [87] phi (byte) line::x#0 = (byte) line::x1#0 [phi:main::@16->line#3] -- register_copy 
    jsr line
    // main::@17
    // x2 = COSTAB[p2_idx]
    // [34] (byte) main::x2#0 ← *((const byte*) COSTAB + (byte) main::p2_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z p2_idx
    lda COSTAB,y
    sta.z x2
    // y2 = SINTAB[p2_idx]
    // [35] (byte) main::y2#0 ← *((const byte*) SINTAB + (byte) main::p2_idx#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    lda SINTAB,y
    sta.z y2
    // line(LINE_BUFFER, x1, y1, x2, y2)
    // [36] (byte) line::x1#1 ← (byte) main::x1#0 -- vbuz1=vbuz2 
    lda.z x1
    sta.z line.x1
    // [37] (byte) line::y1#1 ← (byte) main::y1#0 -- vbuz1=vbuz2 
    lda.z y1
    sta.z line.y1
    // [38] (byte) line::x2#1 ← (byte) main::x2#0
    // [39] (byte) line::y2#1 ← (byte) main::y2#0 -- vbuz1=vbuz2 
    lda.z y2
    sta.z line.y2
    // [40] call line 
    // [87] phi from main::@17 to line [phi:main::@17->line]
    // [87] phi (byte) line::y2#10 = (byte) line::y2#1 [phi:main::@17->line#0] -- register_copy 
    // [87] phi (byte) line::x2#15 = (byte) line::x2#1 [phi:main::@17->line#1] -- register_copy 
    // [87] phi (byte) line::y#0 = (byte) line::y1#1 [phi:main::@17->line#2] -- register_copy 
    // [87] phi (byte) line::x#0 = (byte) line::x1#1 [phi:main::@17->line#3] -- register_copy 
    jsr line
    // main::@18
    // line(LINE_BUFFER, x2, y2, x0, y0)
    // [41] (byte) line::x1#2 ← (byte) main::x2#0 -- vbuz1=vbuz2 
    lda.z x2
    sta.z line.x1
    // [42] (byte) line::y1#2 ← (byte) main::y2#0 -- vbuz1=vbuz2 
    lda.z y2
    sta.z line.y1
    // [43] (byte) line::x2#2 ← (byte) main::x0#0 -- vbuz1=vbuz2 
    lda.z x0
    sta.z line.x2
    // [44] (byte) line::y2#2 ← (byte) main::y0#0 -- vbuz1=vbuz2 
    lda.z y0
    sta.z line.y2
    // [45] call line 
    // [87] phi from main::@18 to line [phi:main::@18->line]
    // [87] phi (byte) line::y2#10 = (byte) line::y2#2 [phi:main::@18->line#0] -- register_copy 
    // [87] phi (byte) line::x2#15 = (byte) line::x2#2 [phi:main::@18->line#1] -- register_copy 
    // [87] phi (byte) line::y#0 = (byte) line::y1#2 [phi:main::@18->line#2] -- register_copy 
    // [87] phi (byte) line::x#0 = (byte) line::x1#2 [phi:main::@18->line#3] -- register_copy 
    jsr line
    // main::@19
    // p0_idx++;
    // [46] (byte) main::p0_idx#1 ← ++ (byte) main::p0_idx#2 -- vbuz1=_inc_vbuz1 
    inc.z p0_idx
    // p1_idx++;
    // [47] (byte) main::p1_idx#1 ← ++ (byte) main::p1_idx#2 -- vbuz1=_inc_vbuz1 
    inc.z p1_idx
    // p2_idx++;
    // [48] (byte) main::p2_idx#1 ← ++ (byte) main::p2_idx#2 -- vbuz1=_inc_vbuz1 
    inc.z p2_idx
    // VICII->BORDER_COLOR = RED
    // [49] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) RED -- _deref_pbuc1=vbuc2 
    // Wait until the canvas on screen has been switched before starting work on the next frame
    lda #RED
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // main::@9
  __b9:
    // while(canvas_show_flag)
    // [50] if((byte) 0!=(volatile byte) canvas_show_flag) goto main::@9 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z canvas_show_flag
    bne __b9
    // main::@10
    // VICII->BORDER_COLOR = BLACK
    // [51] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // eorfill(LINE_BUFFER, canvas)
    // [52] (byte*) eorfill::canvas#0 ← (byte*) main::canvas#10 -- pbuz1=pbuz2 
    lda.z canvas
    sta.z eorfill.canvas
    lda.z canvas+1
    sta.z eorfill.canvas+1
    // [53] call eorfill 
  // Fill canvas
    // [73] phi from main::@10 to eorfill [phi:main::@10->eorfill]
    jsr eorfill
    // main::@20
    // canvas ^= (CANVAS1^CANVAS2)
    // [54] (word) main::canvas#1 ← (byte*) main::canvas#10 ^ (const nomodify byte*) CANVAS1^(const nomodify byte*) CANVAS2 -- vwuz1=pbuz1_bxor_vwuc1 
    // swap canvas being rendered to (using XOR)
    lda #<CANVAS1^CANVAS2
    eor.z canvas
    sta.z canvas
    lda #>CANVAS1^CANVAS2
    eor.z canvas+1
    sta.z canvas+1
    // [55] phi from main::@20 to main::toD0181 [phi:main::@20->main::toD0181]
    // main::toD0181
    // [56] phi from main::toD0181 to main::toD0182 [phi:main::toD0181->main::toD0182]
    // main::toD0182
    // main::@11
    // canvas_show_memory ^= toD018(SCREEN,CANVAS1)^toD018(SCREEN,CANVAS2)
    // [57] (volatile byte) canvas_show_memory ← (volatile byte) canvas_show_memory ^ (const byte) main::toD0181_return#0^(const byte) main::toD0182_return#0 -- vbuz1=vbuz1_bxor_vbuc1 
    // Swap canvas to show on screen (using XOR)
    lda #toD0181_return^toD0182_return
    eor.z canvas_show_memory
    sta.z canvas_show_memory
    // canvas_show_flag = 1
    // [58] (volatile byte) canvas_show_flag ← (byte) 1 -- vbuz1=vbuc1 
    // Set flag used to signal when the canvas has been shown
    lda #1
    sta.z canvas_show_flag
    // clock()
    // [59] call clock 
    // [71] phi from main::@11 to clock [phi:main::@11->clock]
    jsr clock
    // main::@21
    // [60] (byte*) main::canvas#19 ← (byte*)(word) main::canvas#1
    // [20] phi from main::@21 to main::@7 [phi:main::@21->main::@7]
    // [20] phi (byte*) main::canvas#10 = (byte*) main::canvas#19 [phi:main::@21->main::@7#0] -- register_copy 
    // [20] phi (byte) main::p2_idx#2 = (byte) main::p2_idx#1 [phi:main::@21->main::@7#1] -- register_copy 
    // [20] phi (byte) main::p1_idx#2 = (byte) main::p1_idx#1 [phi:main::@21->main::@7#2] -- register_copy 
    // [20] phi (byte) main::p0_idx#2 = (byte) main::p0_idx#1 [phi:main::@21->main::@7#3] -- register_copy 
    jmp __b8
    // main::@2
  __b2:
    // [61] (byte) main::c#4 ← (byte) main::y#2 -- vbuxx=vbuz1 
    ldx.z y
    // [62] phi from main::@2 to main::@4 [phi:main::@2->main::@4]
    // [62] phi (byte) main::c#2 = (byte) main::c#4 [phi:main::@2->main::@4#0] -- register_copy 
    // [62] phi (byte) main::x#2 = (byte) 0 [phi:main::@2->main::@4#1] -- vbuyy=vbuc1 
    ldy #0
    // main::@4
  __b4:
    // for(char x=0;x<16;x++)
    // [63] if((byte) main::x#2<(byte) $10) goto main::@5 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$10
    bcc __b5
    // main::@6
    // cols += 40
    // [64] (byte*) main::cols#1 ← (byte*) main::cols#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z cols
    sta.z cols
    bcc !+
    inc.z cols+1
  !:
    // screen += 40
    // [65] (byte*) main::screen#1 ← (byte*) main::screen#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // for(char y=0;y<16;y++)
    // [66] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [13] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
    // [13] phi (byte*) main::screen#5 = (byte*) main::screen#1 [phi:main::@6->main::@1#0] -- register_copy 
    // [13] phi (byte*) main::cols#5 = (byte*) main::cols#1 [phi:main::@6->main::@1#1] -- register_copy 
    // [13] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@6->main::@1#2] -- register_copy 
    jmp __b1
    // main::@5
  __b5:
    // cols[x] = WHITE
    // [67] *((byte*) main::cols#5 + (byte) main::x#2) ← (const nomodify byte) WHITE -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #WHITE
    sta (cols),y
    // screen[x] = c
    // [68] *((byte*) main::screen#5 + (byte) main::x#2) ← (byte) main::c#2 -- pbuz1_derefidx_vbuyy=vbuxx 
    txa
    sta (screen),y
    // c+=0x10
    // [69] (byte) main::c#1 ← (byte) main::c#2 + (byte) $10 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[$10]
    // for(char x=0;x<16;x++)
    // [70] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuyy=_inc_vbuyy 
    iny
    // [62] phi from main::@5 to main::@4 [phi:main::@5->main::@4]
    // [62] phi (byte) main::c#2 = (byte) main::c#1 [phi:main::@5->main::@4#0] -- register_copy 
    // [62] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@5->main::@4#1] -- register_copy 
    jmp __b4
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    // clock::@return
    // }
    // [72] return 
    rts
}
  // eorfill
// EOR fill from the line buffer onto the canvas
// eorfill(byte* zp($1f) canvas)
eorfill: {
    .label canvas = $1f
    .label line_column = $1c
    .label fill_column = $1f
    // [74] phi from eorfill to eorfill::@1 [phi:eorfill->eorfill::@1]
    // [74] phi (byte*) eorfill::fill_column#2 = (byte*) eorfill::canvas#0 [phi:eorfill->eorfill::@1#0] -- register_copy 
    // [74] phi (byte*) eorfill::line_column#2 = (const nomodify byte*) LINE_BUFFER [phi:eorfill->eorfill::@1#1] -- pbuz1=pbuc1 
    lda #<LINE_BUFFER
    sta.z line_column
    lda #>LINE_BUFFER
    sta.z line_column+1
    // [74] phi (byte) eorfill::x#2 = (byte) 0 [phi:eorfill->eorfill::@1#2] -- vbuxx=vbuc1 
    ldx #0
    // eorfill::@1
  __b1:
    // for(char x=0;x<16;x++)
    // [75] if((byte) eorfill::x#2<(byte) $10) goto eorfill::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$10
    bcc __b2
    // eorfill::@return
    // }
    // [76] return 
    rts
    // eorfill::@2
  __b2:
    // eor = line_column[0]
    // [77] (byte) eorfill::eor#0 ← *((byte*) eorfill::line_column#2) -- vbuaa=_deref_pbuz1 
    ldy #0
    lda (line_column),y
    // fill_column[0] = eor
    // [78] *((byte*) eorfill::fill_column#2) ← (byte) eorfill::eor#0 -- _deref_pbuz1=vbuaa 
    sta (fill_column),y
    // [79] phi from eorfill::@2 to eorfill::@3 [phi:eorfill::@2->eorfill::@3]
    // [79] phi (byte) eorfill::eor#2 = (byte) eorfill::eor#0 [phi:eorfill::@2->eorfill::@3#0] -- register_copy 
    // [79] phi (byte) eorfill::y#2 = (byte) 1 [phi:eorfill::@2->eorfill::@3#1] -- vbuyy=vbuc1 
    ldy #1
    // eorfill::@3
  __b3:
    // for(char y=1;y<16*8;y++)
    // [80] if((byte) eorfill::y#2<(byte)(number) $10*(number) 8) goto eorfill::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$10*8
    bcc __b4
    // eorfill::@5
    // line_column += 16*8
    // [81] (byte*) eorfill::line_column#1 ← (byte*) eorfill::line_column#2 + (byte)(number) $10*(number) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$10*8
    clc
    adc.z line_column
    sta.z line_column
    bcc !+
    inc.z line_column+1
  !:
    // fill_column += 16*8
    // [82] (byte*) eorfill::fill_column#1 ← (byte*) eorfill::fill_column#2 + (byte)(number) $10*(number) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$10*8
    clc
    adc.z fill_column
    sta.z fill_column
    bcc !+
    inc.z fill_column+1
  !:
    // for(char x=0;x<16;x++)
    // [83] (byte) eorfill::x#1 ← ++ (byte) eorfill::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [74] phi from eorfill::@5 to eorfill::@1 [phi:eorfill::@5->eorfill::@1]
    // [74] phi (byte*) eorfill::fill_column#2 = (byte*) eorfill::fill_column#1 [phi:eorfill::@5->eorfill::@1#0] -- register_copy 
    // [74] phi (byte*) eorfill::line_column#2 = (byte*) eorfill::line_column#1 [phi:eorfill::@5->eorfill::@1#1] -- register_copy 
    // [74] phi (byte) eorfill::x#2 = (byte) eorfill::x#1 [phi:eorfill::@5->eorfill::@1#2] -- register_copy 
    jmp __b1
    // eorfill::@4
  __b4:
    // eor ^= line_column[y]
    // [84] (byte) eorfill::eor#1 ← (byte) eorfill::eor#2 ^ *((byte*) eorfill::line_column#2 + (byte) eorfill::y#2) -- vbuaa=vbuaa_bxor_pbuz1_derefidx_vbuyy 
    eor (line_column),y
    // fill_column[y] = eor
    // [85] *((byte*) eorfill::fill_column#2 + (byte) eorfill::y#2) ← (byte) eorfill::eor#1 -- pbuz1_derefidx_vbuyy=vbuaa 
    sta (fill_column),y
    // for(char y=1;y<16*8;y++)
    // [86] (byte) eorfill::y#1 ← ++ (byte) eorfill::y#2 -- vbuyy=_inc_vbuyy 
    iny
    // [79] phi from eorfill::@4 to eorfill::@3 [phi:eorfill::@4->eorfill::@3]
    // [79] phi (byte) eorfill::eor#2 = (byte) eorfill::eor#1 [phi:eorfill::@4->eorfill::@3#0] -- register_copy 
    // [79] phi (byte) eorfill::y#2 = (byte) eorfill::y#1 [phi:eorfill::@4->eorfill::@3#1] -- register_copy 
    jmp __b3
}
  // line
// Draw a EOR friendly line between two points
// Uses bresenham line drawing routine
// line(byte zp($f) x1, byte zp($10) y1, byte zp($c) x2, byte zp($d) y2)
line: {
    .label plot2___1 = $1e
    .label plot5___1 = $27
    .label x1 = $f
    .label y1 = $10
    .label x2 = $c
    .label y2 = $d
    .label x = $f
    .label y = $10
    .label dx = $17
    .label dy = $18
    .label sx = $19
    .label sy = $1a
    .label plot1_column = $21
    .label plot2_y = $1b
    .label plot2_column = $1c
    .label plot3_column = $1f
    .label e1 = $e
    .label plot4_column = $23
    .label plot5_column = $25
    .label plot6_column = $28
    // abs_u8(x2-x1)
    // [88] (byte) abs_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z x2
    sec
    sbc.z x
    // [89] call abs_u8 
    // [175] phi from line to abs_u8 [phi:line->abs_u8]
    // [175] phi (byte) abs_u8::u#2 = (byte) abs_u8::u#0 [phi:line->abs_u8#0] -- register_copy 
    jsr abs_u8
    // abs_u8(x2-x1)
    // [90] (byte) abs_u8::return#0 ← (byte) abs_u8::return#4
    // line::@19
    // dx = abs_u8(x2-x1)
    // [91] (byte) line::dx#0 ← (byte) abs_u8::return#0 -- vbuz1=vbuaa 
    sta.z dx
    // abs_u8(y2-y1)
    // [92] (byte) abs_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z y2
    sec
    sbc.z y
    // [93] call abs_u8 
    // [175] phi from line::@19 to abs_u8 [phi:line::@19->abs_u8]
    // [175] phi (byte) abs_u8::u#2 = (byte) abs_u8::u#1 [phi:line::@19->abs_u8#0] -- register_copy 
    jsr abs_u8
    // abs_u8(y2-y1)
    // [94] (byte) abs_u8::return#1 ← (byte) abs_u8::return#4
    // line::@20
    // dy = abs_u8(y2-y1)
    // [95] (byte) line::dy#0 ← (byte) abs_u8::return#1 -- vbuz1=vbuaa 
    sta.z dy
    // sgn_u8(x2-x1)
    // [96] (byte) sgn_u8::u#0 ← (byte) line::x2#15 - (byte) line::x#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z x2
    sec
    sbc.z x
    // [97] call sgn_u8 
    // [169] phi from line::@20 to sgn_u8 [phi:line::@20->sgn_u8]
    // [169] phi (byte) sgn_u8::u#2 = (byte) sgn_u8::u#0 [phi:line::@20->sgn_u8#0] -- register_copy 
    jsr sgn_u8
    // sgn_u8(x2-x1)
    // [98] (byte) sgn_u8::return#0 ← (byte) sgn_u8::return#4
    // line::@21
    // sx = sgn_u8(x2-x1)
    // [99] (byte) line::sx#0 ← (byte) sgn_u8::return#0 -- vbuz1=vbuaa 
    sta.z sx
    // sgn_u8(y2-y1)
    // [100] (byte) sgn_u8::u#1 ← (byte) line::y2#10 - (byte) line::y#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z y2
    sec
    sbc.z y
    // [101] call sgn_u8 
    // [169] phi from line::@21 to sgn_u8 [phi:line::@21->sgn_u8]
    // [169] phi (byte) sgn_u8::u#2 = (byte) sgn_u8::u#1 [phi:line::@21->sgn_u8#0] -- register_copy 
    jsr sgn_u8
    // sgn_u8(y2-y1)
    // [102] (byte) sgn_u8::return#1 ← (byte) sgn_u8::return#4
    // line::@22
    // sy = sgn_u8(y2-y1)
    // [103] (byte) line::sy#0 ← (byte) sgn_u8::return#1 -- vbuz1=vbuaa 
    sta.z sy
    // if(sx==0xff)
    // [104] if((byte) line::sx#0!=(byte) $ff) goto line::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z sx
    bne __b1
    // line::@3
    // y++;
    // [105] (byte) line::y#1 ← ++ (byte) line::y#0 -- vbuz1=_inc_vbuz1 
    inc.z y
    // y2++;
    // [106] (byte) line::y2#3 ← ++ (byte) line::y2#10 -- vbuz1=_inc_vbuz1 
    inc.z y2
    // [107] phi from line::@22 line::@3 to line::@1 [phi:line::@22/line::@3->line::@1]
    // [107] phi (byte) line::y2#13 = (byte) line::y2#10 [phi:line::@22/line::@3->line::@1#0] -- register_copy 
    // [107] phi (byte) line::y#17 = (byte) line::y#0 [phi:line::@22/line::@3->line::@1#1] -- register_copy 
    // line::@1
  __b1:
    // if(dx > dy)
    // [108] if((byte) line::dx#0>(byte) line::dy#0) goto line::@2 -- vbuz1_gt_vbuz2_then_la1 
    lda.z dy
    cmp.z dx
    bcs !__b2+
    jmp __b2
  !__b2:
    // line::@4
    // if(sx==sy)
    // [109] if((byte) line::sx#0==(byte) line::sy#0) goto line::plot1 -- vbuz1_eq_vbuz2_then_la1 
    // Steep slope - Y is the driver - only plot one plot per X
    lda.z sx
    cmp.z sy
    beq plot1
    // line::@5
    // e = dy/2
    // [110] (byte) line::e#0 ← (byte) line::dy#0 >> (byte) 1 -- vbuxx=vbuz1_ror_1 
    lda.z dy
    lsr
    tax
    // [111] phi from line::@5 line::@7 to line::@6 [phi:line::@5/line::@7->line::@6]
    // [111] phi (byte) line::x#15 = (byte) line::x#0 [phi:line::@5/line::@7->line::@6#0] -- register_copy 
    // [111] phi (byte) line::e#3 = (byte) line::e#0 [phi:line::@5/line::@7->line::@6#1] -- register_copy 
    // [111] phi (byte) line::y#7 = (byte) line::y#17 [phi:line::@5/line::@7->line::@6#2] -- register_copy 
    // line::@6
  __b6:
    // y += sy
    // [112] (byte) line::y#10 ← (byte) line::y#7 + (byte) line::sy#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z y
    clc
    adc.z sy
    sta.z y
    // e += dx
    // [113] (byte) line::e#1 ← (byte) line::e#3 + (byte) line::dx#0 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc.z dx
    tax
    // if(e>dy)
    // [114] if((byte) line::e#1<=(byte) line::dy#0) goto line::@7 -- vbuxx_le_vbuz1_then_la1 
    lda.z dy
    stx.z $ff
    cmp.z $ff
    bcs __b7
    // line::@8
    // plot(x, y-sy)
    // [115] (byte) line::plot2_y#0 ← (byte) line::y#10 - (byte) line::sy#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z y
    sec
    sbc.z sy
    sta.z plot2_y
    // line::plot2
    // x/8
    // [116] (byte~) line::plot2_$0 ← (byte) line::x#15 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // column = plot_column[x/8]
    // [117] (byte~) line::plot2_$2 ← (byte~) line::plot2_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [118] (byte*) line::plot2_column#0 ← *((const byte**) plot_column + (byte~) line::plot2_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot2_column
    lda plot_column+1,y
    sta.z plot2_column+1
    // x&7
    // [119] (byte~) line::plot2_$1 ← (byte) line::x#15 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot2___1
    // column[y] |= plot_bit[x&7]
    // [120] *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) ← *((byte*) line::plot2_column#0 + (byte) line::plot2_y#0) | *((const byte*) plot_bit + (byte~) line::plot2_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z plot2_y
    lda (plot2_column),y
    ldy.z plot2___1
    ora plot_bit,y
    ldy.z plot2_y
    sta (plot2_column),y
    // line::@16
    // x += sx
    // [121] (byte) line::x#1 ← (byte) line::x#15 + (byte) line::sx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z sx
    sta.z x
    // e -= dy
    // [122] (byte) line::e#2 ← (byte) line::e#1 - (byte) line::dy#0 -- vbuxx=vbuxx_minus_vbuz1 
    txa
    sec
    sbc.z dy
    tax
    // [123] phi from line::@16 line::@6 to line::@7 [phi:line::@16/line::@6->line::@7]
    // [123] phi (byte) line::x#17 = (byte) line::x#1 [phi:line::@16/line::@6->line::@7#0] -- register_copy 
    // [123] phi (byte) line::e#5 = (byte) line::e#2 [phi:line::@16/line::@6->line::@7#1] -- register_copy 
    // line::@7
  __b7:
    // while (y != y2)
    // [124] if((byte) line::y#10!=(byte) line::y2#13) goto line::@6 -- vbuz1_neq_vbuz2_then_la1 
    lda.z y
    cmp.z y2
    bne __b6
    // line::plot3
    // x/8
    // [125] (byte~) line::plot3_$0 ← (byte) line::x#17 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // column = plot_column[x/8]
    // [126] (byte~) line::plot3_$2 ← (byte~) line::plot3_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [127] (byte*) line::plot3_column#0 ← *((const byte**) plot_column + (byte~) line::plot3_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot3_column
    lda plot_column+1,y
    sta.z plot3_column+1
    // x&7
    // [128] (byte~) line::plot3_$1 ← (byte) line::x#17 & (byte) 7 -- vbuaa=vbuz1_band_vbuc1 
    lda #7
    and.z x
    // column[y] |= plot_bit[x&7]
    // [129] *((byte*) line::plot3_column#0 + (byte) line::y#10) ← *((byte*) line::plot3_column#0 + (byte) line::y#10) | *((const byte*) plot_bit + (byte~) line::plot3_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuaa 
    ldy.z y
    tax
    lda (plot3_column),y
    ora plot_bit,x
    sta (plot3_column),y
    // line::@return
    // }
    // [130] return 
    rts
    // line::plot1
  plot1:
    // x/8
    // [131] (byte~) line::plot1_$0 ← (byte) line::x#0 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // column = plot_column[x/8]
    // [132] (byte~) line::plot1_$2 ← (byte~) line::plot1_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [133] (byte*) line::plot1_column#0 ← *((const byte**) plot_column + (byte~) line::plot1_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot1_column
    lda plot_column+1,y
    sta.z plot1_column+1
    // x&7
    // [134] (byte~) line::plot1_$1 ← (byte) line::x#0 & (byte) 7 -- vbuaa=vbuz1_band_vbuc1 
    lda #7
    and.z x
    // column[y] |= plot_bit[x&7]
    // [135] *((byte*) line::plot1_column#0 + (byte) line::y#17) ← *((byte*) line::plot1_column#0 + (byte) line::y#17) | *((const byte*) plot_bit + (byte~) line::plot1_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuaa 
    ldy.z y
    tax
    lda (plot1_column),y
    ora plot_bit,x
    sta (plot1_column),y
    // line::@15
    // if(dx==0)
    // [136] if((byte) line::dx#0!=(byte) 0) goto line::@9 -- vbuz1_neq_0_then_la1 
    lda.z dx
    cmp #0
    bne __b9
    rts
    // line::@9
  __b9:
    // e = dy/2
    // [137] (byte) line::e1#0 ← (byte) line::dy#0 >> (byte) 1 -- vbuz1=vbuz2_ror_1 
    lda.z dy
    lsr
    sta.z e1
    // [138] phi from line::@10 line::@17 line::@9 to line::@10 [phi:line::@10/line::@17/line::@9->line::@10]
    // [138] phi (byte) line::x#18 = (byte) line::x#18 [phi:line::@10/line::@17/line::@9->line::@10#0] -- register_copy 
    // [138] phi (byte) line::e1#3 = (byte) line::e1#1 [phi:line::@10/line::@17/line::@9->line::@10#1] -- register_copy 
    // [138] phi (byte) line::y#11 = (byte) line::y#12 [phi:line::@10/line::@17/line::@9->line::@10#2] -- register_copy 
    // line::@10
  __b10:
    // y += sy
    // [139] (byte) line::y#12 ← (byte) line::y#11 + (byte) line::sy#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z y
    clc
    adc.z sy
    sta.z y
    // e += dx
    // [140] (byte) line::e1#1 ← (byte) line::e1#3 + (byte) line::dx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z e1
    clc
    adc.z dx
    sta.z e1
    // while(e<=dy)
    // [141] if((byte) line::e1#1<=(byte) line::dy#0) goto line::@10 -- vbuz1_le_vbuz2_then_la1 
    lda.z dy
    cmp.z e1
    bcs __b10
    // line::@11
    // x += sx
    // [142] (byte) line::x#19 ← (byte) line::x#18 + (byte) line::sx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z sx
    sta.z x
    // e -= dy
    // [143] (byte) line::e1#2 ← (byte) line::e1#1 - (byte) line::dy#0 -- vbuz1=vbuz1_minus_vbuz2 
    lda.z e1
    sec
    sbc.z dy
    sta.z e1
    // line::plot4
    // x/8
    // [144] (byte~) line::plot4_$0 ← (byte) line::x#19 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // column = plot_column[x/8]
    // [145] (byte~) line::plot4_$2 ← (byte~) line::plot4_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [146] (byte*) line::plot4_column#0 ← *((const byte**) plot_column + (byte~) line::plot4_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot4_column
    lda plot_column+1,y
    sta.z plot4_column+1
    // x&7
    // [147] (byte~) line::plot4_$1 ← (byte) line::x#19 & (byte) 7 -- vbuaa=vbuz1_band_vbuc1 
    lda #7
    and.z x
    // column[y] |= plot_bit[x&7]
    // [148] *((byte*) line::plot4_column#0 + (byte) line::y#12) ← *((byte*) line::plot4_column#0 + (byte) line::y#12) | *((const byte*) plot_bit + (byte~) line::plot4_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuaa 
    ldy.z y
    tax
    lda (plot4_column),y
    ora plot_bit,x
    sta (plot4_column),y
    // line::@17
    // while (x != x2)
    // [149] if((byte) line::x#19!=(byte) line::x2#15) goto line::@10 -- vbuz1_neq_vbuz2_then_la1 
    lda.z x
    cmp.z x2
    bne __b10
    rts
    // line::@2
  __b2:
    // e = dx/2
    // [150] (byte) line::e2#0 ← (byte) line::dx#0 >> (byte) 1 -- vbuxx=vbuz1_ror_1 
    lda.z dx
    lsr
    tax
    // [151] phi from line::@13 line::@2 to line::@12 [phi:line::@13/line::@2->line::@12]
    // [151] phi (byte) line::e2#3 = (byte) line::e2#7 [phi:line::@13/line::@2->line::@12#0] -- register_copy 
    // [151] phi (byte) line::y#13 = (byte) line::y#15 [phi:line::@13/line::@2->line::@12#1] -- register_copy 
    // [151] phi (byte) line::x#10 = (byte) line::x#12 [phi:line::@13/line::@2->line::@12#2] -- register_copy 
    // line::@12
    // line::plot5
  plot5:
    // x/8
    // [152] (byte~) line::plot5_$0 ← (byte) line::x#10 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lda.z x
    lsr
    lsr
    lsr
    // column = plot_column[x/8]
    // [153] (byte~) line::plot5_$2 ← (byte~) line::plot5_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [154] (byte*) line::plot5_column#0 ← *((const byte**) plot_column + (byte~) line::plot5_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot5_column
    lda plot_column+1,y
    sta.z plot5_column+1
    // x&7
    // [155] (byte~) line::plot5_$1 ← (byte) line::x#10 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z x
    sta.z plot5___1
    // column[y] |= plot_bit[x&7]
    // [156] *((byte*) line::plot5_column#0 + (byte) line::y#13) ← *((byte*) line::plot5_column#0 + (byte) line::y#13) | *((const byte*) plot_bit + (byte~) line::plot5_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuz3 
    ldy.z y
    lda (plot5_column),y
    ldy.z plot5___1
    ora plot_bit,y
    ldy.z y
    sta (plot5_column),y
    // line::@18
    // x += sx
    // [157] (byte) line::x#12 ← (byte) line::x#10 + (byte) line::sx#0 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x
    clc
    adc.z sx
    sta.z x
    // e += dy
    // [158] (byte) line::e2#1 ← (byte) line::e2#3 + (byte) line::dy#0 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc.z dy
    tax
    // if(e>dx)
    // [159] if((byte) line::e2#1<=(byte) line::dx#0) goto line::@13 -- vbuxx_le_vbuz1_then_la1 
    lda.z dx
    stx.z $ff
    cmp.z $ff
    bcs __b13
    // line::@14
    // y += sy
    // [160] (byte) line::y#4 ← (byte) line::y#13 + (byte) line::sy#0 -- vbuz1=vbuz1_plus_vbuz2 
    tya
    clc
    adc.z sy
    sta.z y
    // e -= dx
    // [161] (byte) line::e2#2 ← (byte) line::e2#1 - (byte) line::dx#0 -- vbuxx=vbuxx_minus_vbuz1 
    txa
    sec
    sbc.z dx
    tax
    // [162] phi from line::@14 line::@18 to line::@13 [phi:line::@14/line::@18->line::@13]
    // [162] phi (byte) line::e2#7 = (byte) line::e2#2 [phi:line::@14/line::@18->line::@13#0] -- register_copy 
    // [162] phi (byte) line::y#15 = (byte) line::y#4 [phi:line::@14/line::@18->line::@13#1] -- register_copy 
    // line::@13
  __b13:
    // while (x != x2)
    // [163] if((byte) line::x#12!=(byte) line::x2#15) goto line::@12 -- vbuz1_neq_vbuz2_then_la1 
    lda.z x
    cmp.z x2
    bne plot5
    // line::plot6
    // x/8
    // [164] (byte~) line::plot6_$0 ← (byte) line::x#12 >> (byte) 3 -- vbuaa=vbuz1_ror_3 
    lsr
    lsr
    lsr
    // column = plot_column[x/8]
    // [165] (byte~) line::plot6_$2 ← (byte~) line::plot6_$0 << (byte) 1 -- vbuaa=vbuaa_rol_1 
    asl
    // [166] (byte*) line::plot6_column#0 ← *((const byte**) plot_column + (byte~) line::plot6_$2) -- pbuz1=pptc1_derefidx_vbuaa 
    tay
    lda plot_column,y
    sta.z plot6_column
    lda plot_column+1,y
    sta.z plot6_column+1
    // x&7
    // [167] (byte~) line::plot6_$1 ← (byte) line::x#12 & (byte) 7 -- vbuaa=vbuz1_band_vbuc1 
    lda #7
    and.z x
    // column[y] |= plot_bit[x&7]
    // [168] *((byte*) line::plot6_column#0 + (byte) line::y#15) ← *((byte*) line::plot6_column#0 + (byte) line::y#15) | *((const byte*) plot_bit + (byte~) line::plot6_$1) -- pbuz1_derefidx_vbuz2=pbuz1_derefidx_vbuz2_bor_pbuc1_derefidx_vbuaa 
    ldy.z y
    tax
    lda (plot6_column),y
    ora plot_bit,x
    sta (plot6_column),y
    rts
}
  // sgn_u8
// Get the sign of a 8-bit unsigned number treated as a signed number.
// Returns unsigned -1 if the number is negative
// sgn_u8(byte register(A) u)
sgn_u8: {
    // u & 0x80
    // [170] (byte~) sgn_u8::$0 ← (byte) sgn_u8::u#2 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // if(u & 0x80)
    // [171] if((byte) 0!=(byte~) sgn_u8::$0) goto sgn_u8::@1 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b1
    // [173] phi from sgn_u8 to sgn_u8::@return [phi:sgn_u8->sgn_u8::@return]
    // [173] phi (byte) sgn_u8::return#4 = (byte) 1 [phi:sgn_u8->sgn_u8::@return#0] -- vbuaa=vbuc1 
    lda #1
    rts
    // [172] phi from sgn_u8 to sgn_u8::@1 [phi:sgn_u8->sgn_u8::@1]
    // sgn_u8::@1
  __b1:
    // [173] phi from sgn_u8::@1 to sgn_u8::@return [phi:sgn_u8::@1->sgn_u8::@return]
    // [173] phi (byte) sgn_u8::return#4 = (byte) -1 [phi:sgn_u8::@1->sgn_u8::@return#0] -- vbuaa=vbuc1 
    lda #-1
    // sgn_u8::@return
    // }
    // [174] return 
    rts
}
  // abs_u8
// Get the absolute value of a u-bit unsigned number treated as a signed number.
// abs_u8(byte register(A) u)
abs_u8: {
    // u & 0x80
    // [176] (byte~) abs_u8::$0 ← (byte) abs_u8::u#2 & (byte) $80 -- vbuxx=vbuaa_band_vbuc1 
    ldx #$80
    axs #0
    // if(u & 0x80)
    // [177] if((byte) 0!=(byte~) abs_u8::$0) goto abs_u8::@1 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne __b1
    // [179] phi from abs_u8 abs_u8::@1 to abs_u8::@return [phi:abs_u8/abs_u8::@1->abs_u8::@return]
    // [179] phi (byte) abs_u8::return#4 = (byte) abs_u8::u#2 [phi:abs_u8/abs_u8::@1->abs_u8::@return#0] -- register_copy 
    rts
    // abs_u8::@1
  __b1:
    // return -u;
    // [178] (byte) abs_u8::return#2 ← - (byte) abs_u8::u#2 -- vbuaa=_neg_vbuaa 
    eor #$ff
    clc
    adc #1
    // abs_u8::@return
    // }
    // [180] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zp($1f) str, byte register(X) c, word zp($1c) num)
memset: {
    .label end = $1c
    .label dst = $1f
    .label num = $1c
    .label str = $1f
    // if(num>0)
    // [182] if((word) memset::num#4<=(byte) 0) goto memset::@return -- vwuz1_le_0_then_la1 
    lda.z num
    bne !+
    lda.z num+1
    beq __breturn
  !:
    // memset::@1
    // end = (char*)str + num
    // [183] (byte*) memset::end#0 ← (byte*)(void*) memset::str#5 + (word) memset::num#4 -- pbuz1=pbuz2_plus_vwuz1 
    lda.z end
    clc
    adc.z str
    sta.z end
    lda.z end+1
    adc.z str+1
    sta.z end+1
    // [184] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#5
    // [185] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
    // [185] phi (byte*) memset::dst#2 = (byte*) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    // memset::@2
  __b2:
    // for(char* dst = str; dst!=end; dst++)
    // [186] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    // memset::@return
  __breturn:
    // }
    // [187] return 
    rts
    // memset::@3
  __b3:
    // *dst = c
    // [188] *((byte*) memset::dst#2) ← (byte) memset::c#6 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [189] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // CIA2->TIMER_A_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [190] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #0
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // CIA2->TIMER_B_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [191] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // *CIA2_TIMER_AB = 0xffffffff
    // [192] *((const nomodify dword*) CIA2_TIMER_AB) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // CIA2->TIMER_B_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [193] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START|(const nomodify byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // CIA2->TIMER_A_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [194] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2+(const byte) OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) ← (const nomodify byte) CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // clock_start::@return
    // }
    // [195] return 
    rts
}
  // textcolor
// Set the color for text output. The old color setting is returned.
textcolor: {
    // textcolor::@return
    // [197] return 
    rts
}
  // setup_irq
// Setup raster IRQ to change charset at different lines
setup_irq: {
    // asm
    // asm { sei  }
    sei
    // CIA1->INTERRUPT = CIA_INTERRUPT_CLEAR
    // [199] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // VICII->CONTROL1 &= 0x7f
    // [200] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Set raster line to 8 pixels before the border
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // VICII->RASTER = BORDER_YPOS_BOTTOM-8
    // [201] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 -- _deref_pbuc1=vbuc2 
    lda #BORDER_YPOS_BOTTOM-8
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // VICII->IRQ_ENABLE = IRQ_RASTER
    // [202] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // *KERNEL_IRQ = &irq_bottom_1
    // [203] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() -- _deref_pptc1=pprc2 
    // Set the IRQ routine
    lda #<irq_bottom_1
    sta KERNEL_IRQ
    lda #>irq_bottom_1
    sta KERNEL_IRQ+1
    // asm
    // asm { cli  }
    cli
    // setup_irq::@return
    // }
    // [205] return 
    rts
}
  // irq_bottom_2
// Interrupt Routine 2
irq_bottom_2: {
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>LINE_BUFFER)/4&$f
    // entry interrupt(KERNEL_KEYBOARD)
    // VICII->BORDER_COLOR = BLACK
    // [206] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) BLACK -- _deref_pbuc1=vbuc2 
    // Change border color
    lda #BLACK
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // kbhit()
    // [207] call kbhit 
    jsr kbhit
    // [208] (byte) kbhit::return#2 ← (byte) kbhit::return#0
    // irq_bottom_2::@4
    // [209] (byte~) irq_bottom_2::$0 ← (byte) kbhit::return#2
    // if(!kbhit())
    // [210] if((byte) 0==(byte~) irq_bottom_2::$0) goto irq_bottom_2::@1 -- vbuc1_eq_vbuaa_then_la1 
    // Show the current canvas (unless a key is being pressed)
    cmp #0
    beq __b1
    // [211] phi from irq_bottom_2::@4 to irq_bottom_2::toD0181 [phi:irq_bottom_2::@4->irq_bottom_2::toD0181]
    // irq_bottom_2::toD0181
    // irq_bottom_2::@3
    // VICII->MEMORY = toD018(SCREEN, LINE_BUFFER)
    // [212] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_2::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_MEMORY
    // irq_bottom_2::@2
  __b2:
    // canvas_show_flag = 0
    // [213] (volatile byte) canvas_show_flag ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z canvas_show_flag
    // VICII->IRQ_STATUS = IRQ_RASTER
    // [214] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // VICII->RASTER = BORDER_YPOS_BOTTOM-8
    // [215] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM-(byte) 8 -- _deref_pbuc1=vbuc2 
    // Trigger IRQ 1 at 8 pixels before the border
    lda #BORDER_YPOS_BOTTOM-8
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // *KERNEL_IRQ = &irq_bottom_1
    // [216] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) irq_bottom_1() -- _deref_pptc1=pprc2 
    lda #<irq_bottom_1
    sta KERNEL_IRQ
    lda #>irq_bottom_1
    sta KERNEL_IRQ+1
    // irq_bottom_2::@return
    // }
    // [217] return  - exit interrupt(KERNEL_KEYBOARD)
    jmp $ea31
    // irq_bottom_2::@1
  __b1:
    // VICII->MEMORY = canvas_show_memory
    // [218] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (volatile byte) canvas_show_memory -- _deref_pbuc1=vbuz1 
    lda.z canvas_show_memory
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_MEMORY
    jmp __b2
}
  // kbhit
// Return true if there's a key waiting, return false if not
kbhit: {
    // CIA#1 Port A: keyboard matrix columns and joystick #2
    .label CIA1_PORT_A = $dc00
    // CIA#1 Port B: keyboard matrix rows and joystick #1.
    .label CIA1_PORT_B = $dc01
    // *CIA1_PORT_A = 0
    // [219] *((const nomodify byte*) kbhit::CIA1_PORT_A) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta CIA1_PORT_A
    // ~*CIA1_PORT_B
    // [220] (byte) kbhit::return#0 ← ~ *((const nomodify byte*) kbhit::CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    // kbhit::@return
    // }
    // [221] return 
    rts
}
  // irq_bottom_1
// Interrupt Routine 1: Just above last text line.
irq_bottom_1: {
    .const toD0181_return = (>(CONSOLE&$3fff)*4)|(>PETSCII)/4&$f
    // entry interrupt(KERNEL_MIN)
    // VICII->BORDER_COLOR = DARK_GREY
    // [222] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) ← (const nomodify byte) DARK_GREY -- _deref_pbuc1=vbuc2 
    // Change border color
    lda #DARK_GREY
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [223] phi from irq_bottom_1 to irq_bottom_1::toD0181 [phi:irq_bottom_1->irq_bottom_1::toD0181]
    // irq_bottom_1::toD0181
    // irq_bottom_1::@1
    // VICII->MEMORY = toD018(CONSOLE, PETSCII)
    // [224] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_MEMORY) ← (const byte) irq_bottom_1::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    // Show the cycle counter
    lda #toD0181_return
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_MEMORY
    // VICII->IRQ_STATUS = IRQ_RASTER
    // [225] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // VICII->RASTER = BORDER_YPOS_BOTTOM
    // [226] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) BORDER_YPOS_BOTTOM -- _deref_pbuc1=vbuc2 
    // Trigger IRQ 2 at bottom of text-line
    lda #BORDER_YPOS_BOTTOM
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // *KERNEL_IRQ = &irq_bottom_2
    // [227] *((const nomodify void()**) KERNEL_IRQ) ← &interrupt(KERNEL_KEYBOARD)(void()) irq_bottom_2() -- _deref_pptc1=pprc2 
    lda #<irq_bottom_2
    sta KERNEL_IRQ
    lda #>irq_bottom_2
    sta KERNEL_IRQ+1
    // irq_bottom_1::@return
    // }
    // [228] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
}
  // File Data
  // SIN/COS tables
  .align $100
SINTAB:
.fill $200, round(63 + 63*sin(i*2*PI/$100))

  // Column offsets
  plot_column: .word LINE_BUFFER, LINE_BUFFER+1*$80, LINE_BUFFER+2*$80, LINE_BUFFER+3*$80, LINE_BUFFER+4*$80, LINE_BUFFER+5*$80, LINE_BUFFER+6*$80, LINE_BUFFER+7*$80, LINE_BUFFER+8*$80, LINE_BUFFER+9*$80, LINE_BUFFER+$a*$80, LINE_BUFFER+$b*$80, LINE_BUFFER+$c*$80, LINE_BUFFER+$d*$80, LINE_BUFFER+$e*$80, LINE_BUFFER+$f*$80
  // The bits used for plotting a pixel
  plot_bit: .byte $80, $40, $20, $10, 8, 4, 2, 1

