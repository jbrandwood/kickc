Resolved forward reference plex_irq to interrupt(KERNEL_MIN)(void()) plex_irq()
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) init::sx)
Adding pointer type conversion cast (byte*) PROCPORT_DDR in (byte*) PROCPORT_DDR ← (number) 0
Adding pointer type conversion cast (byte*) PROCPORT in (byte*) PROCPORT ← (number) 1
Adding pointer type conversion cast (byte*) CHARGEN in (byte*) CHARGEN ← (number) $d000
Adding pointer type conversion cast (byte*) SPRITES_XPOS in (byte*) SPRITES_XPOS ← (number) $d000
Adding pointer type conversion cast (byte*) SPRITES_YPOS in (byte*) SPRITES_YPOS ← (number) $d001
Adding pointer type conversion cast (byte*) SPRITES_XMSB in (byte*) SPRITES_XMSB ← (number) $d010
Adding pointer type conversion cast (byte*) RASTER in (byte*) RASTER ← (number) $d012
Adding pointer type conversion cast (byte*) SPRITES_ENABLE in (byte*) SPRITES_ENABLE ← (number) $d015
Adding pointer type conversion cast (byte*) SPRITES_EXPAND_Y in (byte*) SPRITES_EXPAND_Y ← (number) $d017
Adding pointer type conversion cast (byte*) SPRITES_PRIORITY in (byte*) SPRITES_PRIORITY ← (number) $d01b
Adding pointer type conversion cast (byte*) SPRITES_MC in (byte*) SPRITES_MC ← (number) $d01c
Adding pointer type conversion cast (byte*) SPRITES_EXPAND_X in (byte*) SPRITES_EXPAND_X ← (number) $d01d
Adding pointer type conversion cast (byte*) BORDERCOL in (byte*) BORDERCOL ← (number) $d020
Adding pointer type conversion cast (byte*) BGCOL in (byte*) BGCOL ← (number) $d021
Adding pointer type conversion cast (byte*) BGCOL1 in (byte*) BGCOL1 ← (number) $d021
Adding pointer type conversion cast (byte*) BGCOL2 in (byte*) BGCOL2 ← (number) $d022
Adding pointer type conversion cast (byte*) BGCOL3 in (byte*) BGCOL3 ← (number) $d023
Adding pointer type conversion cast (byte*) BGCOL4 in (byte*) BGCOL4 ← (number) $d024
Adding pointer type conversion cast (byte*) SPRITES_MC1 in (byte*) SPRITES_MC1 ← (number) $d025
Adding pointer type conversion cast (byte*) SPRITES_MC2 in (byte*) SPRITES_MC2 ← (number) $d026
Adding pointer type conversion cast (byte*) SPRITES_COLS in (byte*) SPRITES_COLS ← (number) $d027
Adding pointer type conversion cast (byte*) VIC_CONTROL in (byte*) VIC_CONTROL ← (number) $d011
Adding pointer type conversion cast (byte*) D011 in (byte*) D011 ← (number) $d011
Adding pointer type conversion cast (byte*) VIC_CONTROL2 in (byte*) VIC_CONTROL2 ← (number) $d016
Adding pointer type conversion cast (byte*) D016 in (byte*) D016 ← (number) $d016
Adding pointer type conversion cast (byte*) D018 in (byte*) D018 ← (number) $d018
Adding pointer type conversion cast (byte*) VIC_MEMORY in (byte*) VIC_MEMORY ← (number) $d018
Adding pointer type conversion cast (byte*) LIGHTPEN_X in (byte*) LIGHTPEN_X ← (number) $d013
Adding pointer type conversion cast (byte*) LIGHTPEN_Y in (byte*) LIGHTPEN_Y ← (number) $d014
Adding pointer type conversion cast (byte*) IRQ_STATUS in (byte*) IRQ_STATUS ← (number) $d019
Adding pointer type conversion cast (byte*) IRQ_ENABLE in (byte*) IRQ_ENABLE ← (number) $d01a
Adding pointer type conversion cast (byte*) COLS in (byte*) COLS ← (number) $d800
Adding pointer type conversion cast (byte*) CIA1_PORT_A in (byte*) CIA1_PORT_A ← (number) $dc00
Adding pointer type conversion cast (byte*) CIA1_PORT_B in (byte*) CIA1_PORT_B ← (number) $dc01
Adding pointer type conversion cast (byte*) CIA1_PORT_A_DDR in (byte*) CIA1_PORT_A_DDR ← (number) $dc02
Adding pointer type conversion cast (byte*) CIA1_PORT_B_DDR in (byte*) CIA1_PORT_B_DDR ← (number) $dc03
Adding pointer type conversion cast (byte*) CIA1_INTERRUPT in (byte*) CIA1_INTERRUPT ← (number) $dc0d
Adding pointer type conversion cast (byte*) CIA2_PORT_A in (byte*) CIA2_PORT_A ← (number) $dd00
Adding pointer type conversion cast (byte*) CIA2_PORT_B in (byte*) CIA2_PORT_B ← (number) $dd01
Adding pointer type conversion cast (byte*) CIA2_PORT_A_DDR in (byte*) CIA2_PORT_A_DDR ← (number) $dd02
Adding pointer type conversion cast (byte*) CIA2_PORT_B_DDR in (byte*) CIA2_PORT_B_DDR ← (number) $dd03
Adding pointer type conversion cast (byte*) CIA2_INTERRUPT in (byte*) CIA2_INTERRUPT ← (number) $dd0d
Adding pointer type conversion cast (void()**) KERNEL_IRQ in (void()**) KERNEL_IRQ ← (number) $314
Adding pointer type conversion cast (void()**) HARDWARE_IRQ in (void()**) HARDWARE_IRQ ← (number) $fffe
Adding pointer type conversion cast (byte*) PLEX_SCREEN_PTR in (byte*) PLEX_SCREEN_PTR ← (number~) $0
Adding pointer type conversion cast (byte*) SCREEN in (byte*) SCREEN ← (number) $400
Adding pointer type conversion cast (byte*) SPRITE in (byte*) SPRITE ← (number) $2000
Adding pointer type conversion cast (byte*) YSIN in (byte*) YSIN ← (number) $2100
Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) SPRITE
Identified constant variable (byte*) YSIN
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call plexSetScreen (byte*) plexInit::screen 
Inlined call call plexFreePrepare 
Inlined call call plexFreeAdd (byte) plexShowSprite::ypos 
Inlined call (byte~) plex_irq::$2 ← call plexFreeNextYpos 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) plexInit::plexSetScreen1_@return
Culled Empty Block (label) plexInit::@2
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) plexSort::plexFreePrepare1_@return
Culled Empty Block (label) plexSort::@7
Culled Empty Block (label) @7
Culled Empty Block (label) plexShowSprite::plexFreeAdd1_@return
Culled Empty Block (label) plexShowSprite::@5
Culled Empty Block (label) plexShowSprite::@3
Culled Empty Block (label) @8
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) @13
Culled Empty Block (label) plex_irq::plexFreeNextYpos1_@1
Culled Empty Block (label) plex_irq::@6
Culled Empty Block (label) @15
Culled Empty Block (label) loop::@2
Culled Empty Block (label) loop::@13
Culled Empty Block (label) loop::@3
Culled Empty Block (label) loop::@14
Culled Empty Block (label) loop::@5
Culled Empty Block (label) loop::@7
Culled Empty Block (label) loop::@8
Culled Empty Block (label) loop::@9
Culled Empty Block (label) loop::@12

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) SPRITES_XPOS#0 ← ((byte*)) (number) $d000
  (byte*) SPRITES_YPOS#0 ← ((byte*)) (number) $d001
  (byte*) SPRITES_XMSB#0 ← ((byte*)) (number) $d010
  (byte*) RASTER#0 ← ((byte*)) (number) $d012
  (byte*) SPRITES_ENABLE#0 ← ((byte*)) (number) $d015
  (byte*) BORDERCOL#0 ← ((byte*)) (number) $d020
  (byte*) SPRITES_COLS#0 ← ((byte*)) (number) $d027
  (byte*) VIC_CONTROL#0 ← ((byte*)) (number) $d011
  (byte*) D011#0 ← ((byte*)) (number) $d011
  (byte) VIC_DEN#0 ← (number) $10
  (byte) VIC_RSEL#0 ← (number) 8
  (byte*) IRQ_STATUS#0 ← ((byte*)) (number) $d019
  (byte*) IRQ_ENABLE#0 ← ((byte*)) (number) $d01a
  (byte) IRQ_RASTER#0 ← (number) 1
  (byte*) CIA1_INTERRUPT#0 ← ((byte*)) (number) $dc0d
  (byte) CIA_INTERRUPT_CLEAR#0 ← (number) $7f
  (void()**) KERNEL_IRQ#0 ← ((void()**)) (number) $314
  (byte) WHITE#0 ← (number) 1
  (byte) RED#0 ← (number) 2
  (byte) GREEN#0 ← (number) 5
  to:@4
@4: scope:[]  from @begin
  (byte) PLEX_COUNT#0 ← (number) $20
  (word[PLEX_COUNT#0]) PLEX_XPOS#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte[PLEX_COUNT#0]) PLEX_YPOS#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte[PLEX_COUNT#0]) PLEX_PTR#0 ← { fill( PLEX_COUNT#0, 0) }
  (number~) $0 ← (number) $400 + (number) $3f8
  (byte*) PLEX_SCREEN_PTR#0 ← ((byte*)) (number~) $0
  (byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte) plex_show_idx#0 ← (number) 0
  (byte) plex_sprite_idx#0 ← (number) 0
  (byte) plex_sprite_msb#0 ← (number) 1
  to:@9
plexInit: scope:[plexInit]  from init
  (byte*) plexInit::screen#1 ← phi( init/(byte*) plexInit::screen#0 )
  (byte*) plexInit::plexSetScreen1_screen#0 ← (byte*) plexInit::screen#1
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  (byte*) plexInit::plexSetScreen1_screen#1 ← phi( plexInit/(byte*) plexInit::plexSetScreen1_screen#0 )
  (byte*~) plexInit::plexSetScreen1_$0#0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
  (byte*) PLEX_SCREEN_PTR#1 ← (byte*~) plexInit::plexSetScreen1_$0#0
  to:plexInit::@3
plexInit::@3: scope:[plexInit]  from plexInit::plexSetScreen1
  (byte*) PLEX_SCREEN_PTR#22 ← phi( plexInit::plexSetScreen1/(byte*) PLEX_SCREEN_PTR#1 )
  (number~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) plexInit::i#0 ← (number) 0
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::@3
  (byte*) PLEX_SCREEN_PTR#15 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 plexInit::@3/(byte*) PLEX_SCREEN_PTR#22 )
  (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::@3/(byte) plexInit::i#0 )
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  (byte) plexInit::i#1 ← (byte) plexInit::i#2 + rangenext(0,plexInit::$1)
  (bool~) plexInit::$2 ← (byte) plexInit::i#1 != rangelast(0,plexInit::$1)
  if((bool~) plexInit::$2) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  (byte*) PLEX_SCREEN_PTR#8 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 )
  (byte*) PLEX_SCREEN_PTR#2 ← (byte*) PLEX_SCREEN_PTR#8
  return 
  to:@return
plexSort: scope:[plexSort]  from loop::@11
  (number~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (number) 2
  (byte) plexSort::m#0 ← (number) 0
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  (byte) plexSort::m#2 ← phi( plexSort/(byte) plexSort::m#0 plexSort::@2/(byte) plexSort::m#1 )
  (number~) plexSort::$2 ← (byte) plexSort::m#2 + (number) 1
  (byte) plexSort::nxt_idx#0 ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (number~) plexSort::$2)
  (byte) plexSort::nxt_y#0 ← *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0)
  (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))
  (bool~) plexSort::$4 ← ! (bool~) plexSort::$3
  if((bool~) plexSort::$4) goto plexSort::@2
  to:plexSort::@5
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  (byte) plexSort::m#3 ← phi( plexSort::@1/(byte) plexSort::m#2 plexSort::@4/(byte) plexSort::m#5 )
  (byte) plexSort::m#1 ← (byte) plexSort::m#3 + rangenext(0,plexSort::$1)
  (bool~) plexSort::$9 ← (byte) plexSort::m#1 != rangelast(0,plexSort::$1)
  if((bool~) plexSort::$9) goto plexSort::@1
  to:plexSort::@6
plexSort::@5: scope:[plexSort]  from plexSort::@1
  (byte) plexSort::nxt_idx#3 ← phi( plexSort::@1/(byte) plexSort::nxt_idx#0 )
  (byte) plexSort::nxt_y#2 ← phi( plexSort::@1/(byte) plexSort::nxt_y#0 )
  (byte) plexSort::m#4 ← phi( plexSort::@1/(byte) plexSort::m#2 )
  (byte) plexSort::s#0 ← (byte) plexSort::m#4
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@3 plexSort::@5
  (byte) plexSort::m#6 ← phi( plexSort::@3/(byte) plexSort::m#6 plexSort::@5/(byte) plexSort::m#4 )
  (byte) plexSort::nxt_idx#2 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 plexSort::@5/(byte) plexSort::nxt_idx#3 )
  (byte) plexSort::nxt_y#1 ← phi( plexSort::@3/(byte) plexSort::nxt_y#1 plexSort::@5/(byte) plexSort::nxt_y#2 )
  (byte) plexSort::s#3 ← phi( plexSort::@3/(byte) plexSort::s#1 plexSort::@5/(byte) plexSort::s#0 )
  (number~) plexSort::$5 ← (byte) plexSort::s#3 + (number) 1
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (number~) plexSort::$5) ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3)
  (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  (bool~) plexSort::$6 ← (byte) plexSort::s#1 != (number) $ff
  (bool~) plexSort::$7 ← (byte) plexSort::nxt_y#1 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))
  (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
  if((bool~) plexSort::$8) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3
  (byte) plexSort::m#5 ← phi( plexSort::@3/(byte) plexSort::m#6 )
  (byte) plexSort::nxt_idx#1 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 )
  (byte) plexSort::s#4 ← phi( plexSort::@3/(byte) plexSort::s#1 )
  (byte) plexSort::s#2 ← ++ (byte) plexSort::s#4
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#1
  to:plexSort::@2
plexSort::@6: scope:[plexSort]  from plexSort::@2
  (byte) plex_show_idx#1 ← (number) 0
  (byte) plex_sprite_idx#1 ← (number) 0
  (byte) plex_sprite_msb#1 ← (number) 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  (byte) plex_sprite_msb#43 ← phi( plexSort::@6/(byte) plex_sprite_msb#1 )
  (byte) plex_sprite_idx#44 ← phi( plexSort::@6/(byte) plex_sprite_idx#1 )
  (byte) plex_show_idx#47 ← phi( plexSort::@6/(byte) plex_show_idx#1 )
  (byte) plexSort::plexFreePrepare1_s#0 ← (number) 0
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#33 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_msb#43 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#33 )
  (byte) plex_sprite_idx#35 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_idx#44 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#35 )
  (byte) plex_show_idx#38 ← phi( plexSort::plexFreePrepare1/(byte) plex_show_idx#47 plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#38 )
  (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) plexSort::plexFreePrepare1_s#0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
  (byte) plexSort::plexFreePrepare1_s#1 ← (byte) plexSort::plexFreePrepare1_s#2 + rangenext(0,7)
  (bool~) plexSort::plexFreePrepare1_$0#0 ← (byte) plexSort::plexFreePrepare1_s#1 != rangelast(0,7)
  if((bool~) plexSort::plexFreePrepare1_$0#0) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#25 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#33 )
  (byte) plex_sprite_idx#24 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#35 )
  (byte) plex_show_idx#26 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#38 )
  (byte) plex_free_next#0 ← (number) 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  (byte) plex_free_next#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_free_next#0 )
  (byte) plex_sprite_msb#13 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_msb#25 )
  (byte) plex_sprite_idx#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_idx#24 )
  (byte) plex_show_idx#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_show_idx#26 )
  (byte) plex_show_idx#2 ← (byte) plex_show_idx#12
  (byte) plex_sprite_idx#2 ← (byte) plex_sprite_idx#12
  (byte) plex_sprite_msb#2 ← (byte) plex_sprite_msb#13
  (byte) plex_free_next#1 ← (byte) plex_free_next#12
  return 
  to:@return
plexShowSprite: scope:[plexShowSprite]  from plex_irq::@3
  (byte) plex_sprite_msb#44 ← phi( plex_irq::@3/(byte) plex_sprite_msb#28 )
  (byte*) PLEX_SCREEN_PTR#23 ← phi( plex_irq::@3/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) plex_free_next#23 ← phi( plex_irq::@3/(byte) plex_free_next#27 )
  (byte) plex_show_idx#13 ← phi( plex_irq::@3/(byte) plex_show_idx#27 )
  (byte) plex_sprite_idx#13 ← phi( plex_irq::@3/(byte) plex_sprite_idx#25 )
  (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#13 * (number) 2
  (byte) plexShowSprite::plex_sprite_idx2#0 ← (number~) plexShowSprite::$0
  (byte) plexShowSprite::ypos#0 ← *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#13))
  *((byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::ypos#0
  (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← (byte) plexShowSprite::ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  (byte) plex_sprite_msb#34 ← phi( plexShowSprite/(byte) plex_sprite_msb#44 )
  (byte) plexShowSprite::plex_sprite_idx2#2 ← phi( plexShowSprite/(byte) plexShowSprite::plex_sprite_idx2#0 )
  (byte) plex_sprite_idx#26 ← phi( plexShowSprite/(byte) plex_sprite_idx#13 )
  (byte*) PLEX_SCREEN_PTR#16 ← phi( plexShowSprite/(byte*) PLEX_SCREEN_PTR#23 )
  (byte) plex_show_idx#28 ← phi( plexShowSprite/(byte) plex_show_idx#13 )
  (byte) plex_free_next#13 ← phi( plexShowSprite/(byte) plex_free_next#23 )
  (byte) plexShowSprite::plexFreeAdd1_ypos#1 ← phi( plexShowSprite/(byte) plexShowSprite::plexFreeAdd1_ypos#0 )
  (number~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
  *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#13) ← (number~) plexShowSprite::plexFreeAdd1_$0#0
  (number~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#13 + (number) 1
  (number~) plexShowSprite::plexFreeAdd1_$2#0 ← (number~) plexShowSprite::plexFreeAdd1_$1#0 & (number) 7
  (byte) plex_free_next#2 ← (number~) plexShowSprite::plexFreeAdd1_$2#0
  to:plexShowSprite::@7
plexShowSprite::@7: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  (byte) plex_free_next#42 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_free_next#2 )
  (byte) plex_sprite_msb#26 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_msb#34 )
  (byte) plexShowSprite::plex_sprite_idx2#1 ← phi( plexShowSprite::plexFreeAdd1/(byte) plexShowSprite::plex_sprite_idx2#2 )
  (byte) plex_sprite_idx#14 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_idx#26 )
  (byte*) PLEX_SCREEN_PTR#9 ← phi( plexShowSprite::plexFreeAdd1/(byte*) PLEX_SCREEN_PTR#16 )
  (byte) plex_show_idx#14 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_show_idx#28 )
  *((byte*) PLEX_SCREEN_PTR#9 + (byte) plex_sprite_idx#14) ← *((byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#14))
  (byte) plexShowSprite::xpos_idx#0 ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#14)
  (byte~) plexShowSprite::$10 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$2 ← < *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$10)
  *((byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#1) ← (byte~) plexShowSprite::$2
  (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$3 ← > *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11)
  (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
  if((bool~) plexShowSprite::$4) goto plexShowSprite::@1
  to:plexShowSprite::@4
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#32 ← phi( plexShowSprite::@7/(byte) plex_free_next#42 )
  (byte) plex_show_idx#29 ← phi( plexShowSprite::@7/(byte) plex_show_idx#14 )
  (byte) plex_sprite_idx#27 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#14 )
  (byte) plex_sprite_msb#14 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#26 )
  *((byte*) SPRITES_XMSB#0) ← *((byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#14
  to:plexShowSprite::@2
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#33 ← phi( plexShowSprite::@7/(byte) plex_free_next#42 )
  (byte) plex_show_idx#30 ← phi( plexShowSprite::@7/(byte) plex_show_idx#14 )
  (byte) plex_sprite_idx#28 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#14 )
  (byte) plex_sprite_msb#15 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#26 )
  (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#15
  *((byte*) SPRITES_XMSB#0) ← *((byte*) SPRITES_XMSB#0) & (number~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@4
  (byte) plex_free_next#24 ← phi( plexShowSprite::@1/(byte) plex_free_next#32 plexShowSprite::@4/(byte) plex_free_next#33 )
  (byte) plex_sprite_msb#16 ← phi( plexShowSprite::@1/(byte) plex_sprite_msb#14 plexShowSprite::@4/(byte) plex_sprite_msb#15 )
  (byte) plex_show_idx#15 ← phi( plexShowSprite::@1/(byte) plex_show_idx#29 plexShowSprite::@4/(byte) plex_show_idx#30 )
  (byte) plex_sprite_idx#15 ← phi( plexShowSprite::@1/(byte) plex_sprite_idx#27 plexShowSprite::@4/(byte) plex_sprite_idx#28 )
  (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#15 + (number) 1
  (number~) plexShowSprite::$6 ← (number~) plexShowSprite::$5 & (number) 7
  (byte) plex_sprite_idx#3 ← (number~) plexShowSprite::$6
  (byte) plex_show_idx#3 ← ++ (byte) plex_show_idx#15
  (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#16 << (number) 1
  (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
  (bool~) plexShowSprite::$8 ← ! (bool~) plexShowSprite::$7
  if((bool~) plexShowSprite::$8) goto plexShowSprite::@return
  to:plexShowSprite::@6
plexShowSprite::@6: scope:[plexShowSprite]  from plexShowSprite::@2
  (byte) plex_show_idx#31 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 )
  (byte) plex_sprite_idx#29 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 )
  (byte) plex_free_next#25 ← phi( plexShowSprite::@2/(byte) plex_free_next#24 )
  (byte) plex_sprite_msb#4 ← (number) 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@6
  (byte) plex_sprite_msb#17 ← phi( plexShowSprite::@2/(byte) plex_sprite_msb#3 plexShowSprite::@6/(byte) plex_sprite_msb#4 )
  (byte) plex_show_idx#16 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 plexShowSprite::@6/(byte) plex_show_idx#31 )
  (byte) plex_sprite_idx#16 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 plexShowSprite::@6/(byte) plex_sprite_idx#29 )
  (byte) plex_free_next#14 ← phi( plexShowSprite::@2/(byte) plex_free_next#24 plexShowSprite::@6/(byte) plex_free_next#25 )
  (byte) plex_free_next#3 ← (byte) plex_free_next#14
  (byte) plex_sprite_idx#4 ← (byte) plex_sprite_idx#16
  (byte) plex_show_idx#4 ← (byte) plex_show_idx#16
  (byte) plex_sprite_msb#5 ← (byte) plex_sprite_msb#17
  return 
  to:@return
@9: scope:[]  from @4
  (byte) plex_sprite_msb#49 ← phi( @4/(byte) plex_sprite_msb#0 )
  (byte) plex_sprite_idx#49 ← phi( @4/(byte) plex_sprite_idx#0 )
  (byte) plex_show_idx#50 ← phi( @4/(byte) plex_show_idx#0 )
  (byte*) PLEX_SCREEN_PTR#29 ← phi( @4/(byte*) PLEX_SCREEN_PTR#0 )
  (byte[8]) PLEX_FREE_YPOS#0 ← { fill( 8, 0) }
  (byte) plex_free_next#4 ← (number) 0
  to:@12
@12: scope:[]  from @9
  (byte) plex_free_next#43 ← phi( @9/(byte) plex_free_next#4 )
  (byte) plex_sprite_msb#45 ← phi( @9/(byte) plex_sprite_msb#49 )
  (byte) plex_sprite_idx#45 ← phi( @9/(byte) plex_sprite_idx#49 )
  (byte) plex_show_idx#48 ← phi( @9/(byte) plex_show_idx#50 )
  (byte*) PLEX_SCREEN_PTR#28 ← phi( @9/(byte*) PLEX_SCREEN_PTR#29 )
  (byte*) SCREEN#0 ← ((byte*)) (number) $400
  (byte*) SPRITE#0 ← ((byte*)) (number) $2000
  (byte*) YSIN#0 ← ((byte*)) (number) $2100
  kickasm(location (byte*) YSIN#0) {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
  kickasm(location (byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  to:@14
main: scope:[main]  from @16
  (bool) framedone#18 ← phi( @16/(bool) framedone#17 )
  (byte) plex_free_next#34 ← phi( @16/(byte) plex_free_next#31 )
  (byte) plex_sprite_msb#35 ← phi( @16/(byte) plex_sprite_msb#32 )
  (byte) plex_sprite_idx#36 ← phi( @16/(byte) plex_sprite_idx#34 )
  (byte) plex_show_idx#39 ← phi( @16/(byte) plex_show_idx#37 )
  (byte*) PLEX_SCREEN_PTR#17 ← phi( @16/(byte*) PLEX_SCREEN_PTR#21 )
  asm { sei  }
  call init 
  to:main::@1
main::@1: scope:[main]  from main
  (bool) framedone#14 ← phi( main/(bool) framedone#18 )
  (byte) plex_free_next#26 ← phi( main/(byte) plex_free_next#34 )
  (byte) plex_sprite_msb#27 ← phi( main/(byte) plex_sprite_msb#35 )
  (byte) plex_sprite_idx#30 ← phi( main/(byte) plex_sprite_idx#36 )
  (byte) plex_show_idx#32 ← phi( main/(byte) plex_show_idx#39 )
  (byte*) PLEX_SCREEN_PTR#10 ← phi( main/(byte*) PLEX_SCREEN_PTR#6 )
  (byte*) PLEX_SCREEN_PTR#3 ← (byte*) PLEX_SCREEN_PTR#10
  call loop 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte*) PLEX_SCREEN_PTR#18 ← phi( main::@1/(byte*) PLEX_SCREEN_PTR#3 )
  (bool) framedone#8 ← phi( main::@1/(bool) framedone#6 )
  (byte) plex_free_next#15 ← phi( main::@1/(byte) plex_free_next#10 )
  (byte) plex_sprite_msb#18 ← phi( main::@1/(byte) plex_sprite_msb#11 )
  (byte) plex_sprite_idx#17 ← phi( main::@1/(byte) plex_sprite_idx#10 )
  (byte) plex_show_idx#17 ← phi( main::@1/(byte) plex_show_idx#10 )
  (byte) plex_show_idx#5 ← (byte) plex_show_idx#17
  (byte) plex_sprite_idx#5 ← (byte) plex_sprite_idx#17
  (byte) plex_sprite_msb#6 ← (byte) plex_sprite_msb#18
  (byte) plex_free_next#5 ← (byte) plex_free_next#15
  (bool) framedone#0 ← (bool) framedone#8
  to:main::@return
main::@return: scope:[main]  from main::@2
  (bool) framedone#9 ← phi( main::@2/(bool) framedone#0 )
  (byte) plex_free_next#16 ← phi( main::@2/(byte) plex_free_next#5 )
  (byte) plex_sprite_msb#19 ← phi( main::@2/(byte) plex_sprite_msb#6 )
  (byte) plex_sprite_idx#18 ← phi( main::@2/(byte) plex_sprite_idx#5 )
  (byte) plex_show_idx#18 ← phi( main::@2/(byte) plex_show_idx#5 )
  (byte*) PLEX_SCREEN_PTR#11 ← phi( main::@2/(byte*) PLEX_SCREEN_PTR#18 )
  (byte*) PLEX_SCREEN_PTR#4 ← (byte*) PLEX_SCREEN_PTR#11
  (byte) plex_show_idx#6 ← (byte) plex_show_idx#18
  (byte) plex_sprite_idx#6 ← (byte) plex_sprite_idx#18
  (byte) plex_sprite_msb#7 ← (byte) plex_sprite_msb#19
  (byte) plex_free_next#6 ← (byte) plex_free_next#16
  (bool) framedone#1 ← (bool) framedone#9
  return 
  to:@return
init: scope:[init]  from main
  (byte*) PLEX_SCREEN_PTR#19 ← phi( main/(byte*) PLEX_SCREEN_PTR#17 )
  (byte~) init::$0 ← (byte) VIC_DEN#0 | (byte) VIC_RSEL#0
  (number~) init::$1 ← (byte~) init::$0 | (number) 3
  *((byte*) D011#0) ← (number~) init::$1
  (byte*) plexInit::screen#0 ← (byte*) SCREEN#0
  call plexInit 
  to:init::@5
init::@5: scope:[init]  from init
  (byte*) PLEX_SCREEN_PTR#12 ← phi( init/(byte*) PLEX_SCREEN_PTR#2 )
  (byte*) PLEX_SCREEN_PTR#5 ← (byte*) PLEX_SCREEN_PTR#12
  (word) init::xp#0 ← (number) $20
  (number~) init::$4 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) init::sx#0 ← (number) 0
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@5
  (byte*) PLEX_SCREEN_PTR#30 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#30 init::@5/(byte*) PLEX_SCREEN_PTR#5 )
  (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init::@5/(word) init::xp#0 )
  (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init::@5/(byte) init::sx#0 )
  (byte*~) init::$5 ← (byte*) SPRITE#0 / (number) $40
  (byte~) init::$6 ← ((byte)) (byte*~) init::$5
  *((byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte~) init::$6
  (byte~) init::$9 ← (byte) init::sx#2 * (const byte) SIZEOF_WORD
  *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$9) ← (word) init::xp#2
  (word) init::xp#1 ← (word) init::xp#2 + (number) 9
  (byte) init::sx#1 ← (byte) init::sx#2 + rangenext(0,init::$4)
  (bool~) init::$7 ← (byte) init::sx#1 != rangelast(0,init::$4)
  if((bool~) init::$7) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  (byte*) PLEX_SCREEN_PTR#27 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#30 )
  *((byte*) SPRITES_ENABLE#0) ← (number) $ff
  (byte) init::ss#0 ← (number) 0
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  (byte*) PLEX_SCREEN_PTR#24 ← phi( init::@2/(byte*) PLEX_SCREEN_PTR#27 init::@3/(byte*) PLEX_SCREEN_PTR#24 )
  (byte) init::ss#2 ← phi( init::@2/(byte) init::ss#0 init::@3/(byte) init::ss#1 )
  *((byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (byte) GREEN#0
  (byte) init::ss#1 ← (byte) init::ss#2 + rangenext(0,7)
  (bool~) init::$8 ← (byte) init::ss#1 != rangelast(0,7)
  if((bool~) init::$8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  (byte*) PLEX_SCREEN_PTR#20 ← phi( init::@3/(byte*) PLEX_SCREEN_PTR#24 )
  asm { sei  }
  *((byte*) CIA1_INTERRUPT#0) ← (byte) CIA_INTERRUPT_CLEAR#0
  *((byte*) IRQ_ENABLE#0) ← (byte) IRQ_RASTER#0
  *((byte*) IRQ_STATUS#0) ← (byte) IRQ_RASTER#0
  (void()*~) init::$3 ← & interrupt(KERNEL_MIN)(void()) plex_irq()
  *((void()**) KERNEL_IRQ#0) ← (void()*~) init::$3
  asm { cli  }
  to:init::@return
init::@return: scope:[init]  from init::@4
  (byte*) PLEX_SCREEN_PTR#13 ← phi( init::@4/(byte*) PLEX_SCREEN_PTR#20 )
  (byte*) PLEX_SCREEN_PTR#6 ← (byte*) PLEX_SCREEN_PTR#13
  return 
  to:@return
@14: scope:[]  from @12
  (byte) plex_free_next#41 ← phi( @12/(byte) plex_free_next#43 )
  (byte) plex_sprite_msb#42 ← phi( @12/(byte) plex_sprite_msb#45 )
  (byte) plex_sprite_idx#43 ← phi( @12/(byte) plex_sprite_idx#45 )
  (byte) plex_show_idx#46 ← phi( @12/(byte) plex_show_idx#48 )
  (byte*) PLEX_SCREEN_PTR#25 ← phi( @12/(byte*) PLEX_SCREEN_PTR#28 )
  (bool) framedone#2 ← true
  to:@16
plex_irq: scope:[plex_irq]  from
  (bool) framedone#27 ← phi( @16/(bool) framedone#17 )
  (byte*) PLEX_SCREEN_PTR#31 ← phi( @16/(byte*) PLEX_SCREEN_PTR#21 )
  (byte) plex_sprite_msb#36 ← phi( @16/(byte) plex_sprite_msb#32 )
  (byte) plex_free_next#35 ← phi( @16/(byte) plex_free_next#31 )
  (byte) plex_show_idx#40 ← phi( @16/(byte) plex_show_idx#37 )
  (byte) plex_sprite_idx#37 ← phi( @16/(byte) plex_sprite_idx#34 )
  (byte) plex_irq::rasterY#0 ← (byte) 0
  *((byte*) BORDERCOL#0) ← (byte) WHITE#0
  to:plex_irq::@3
plex_irq::@3: scope:[plex_irq]  from plex_irq plex_irq::@7
  (bool) framedone#26 ← phi( plex_irq/(bool) framedone#27 plex_irq::@7/(bool) framedone#22 )
  (byte*) PLEX_SCREEN_PTR#26 ← phi( plex_irq/(byte*) PLEX_SCREEN_PTR#31 plex_irq::@7/(byte*) PLEX_SCREEN_PTR#32 )
  (byte) plex_sprite_msb#28 ← phi( plex_irq/(byte) plex_sprite_msb#36 plex_irq::@7/(byte) plex_sprite_msb#37 )
  (byte) plex_free_next#27 ← phi( plex_irq/(byte) plex_free_next#35 plex_irq::@7/(byte) plex_free_next#36 )
  (byte) plex_show_idx#27 ← phi( plex_irq/(byte) plex_show_idx#40 plex_irq::@7/(byte) plex_show_idx#20 )
  (byte) plex_sprite_idx#25 ← phi( plex_irq/(byte) plex_sprite_idx#37 plex_irq::@7/(byte) plex_sprite_idx#38 )
  call plexShowSprite 
  to:plex_irq::@8
plex_irq::@8: scope:[plex_irq]  from plex_irq::@3
  (bool) framedone#25 ← phi( plex_irq::@3/(bool) framedone#26 )
  (byte*) PLEX_SCREEN_PTR#35 ← phi( plex_irq::@3/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) plex_sprite_msb#20 ← phi( plex_irq::@3/(byte) plex_sprite_msb#5 )
  (byte) plex_show_idx#19 ← phi( plex_irq::@3/(byte) plex_show_idx#4 )
  (byte) plex_sprite_idx#19 ← phi( plex_irq::@3/(byte) plex_sprite_idx#4 )
  (byte) plex_free_next#17 ← phi( plex_irq::@3/(byte) plex_free_next#3 )
  (byte) plex_free_next#7 ← (byte) plex_free_next#17
  (byte) plex_sprite_idx#7 ← (byte) plex_sprite_idx#19
  (byte) plex_show_idx#7 ← (byte) plex_show_idx#19
  (byte) plex_sprite_msb#8 ← (byte) plex_sprite_msb#20
  to:plex_irq::plexFreeNextYpos1
plex_irq::plexFreeNextYpos1: scope:[plex_irq]  from plex_irq::@8
  (bool) framedone#24 ← phi( plex_irq::@8/(bool) framedone#25 )
  (byte*) PLEX_SCREEN_PTR#34 ← phi( plex_irq::@8/(byte*) PLEX_SCREEN_PTR#35 )
  (byte) plex_sprite_msb#50 ← phi( plex_irq::@8/(byte) plex_sprite_msb#8 )
  (byte) plex_sprite_idx#50 ← phi( plex_irq::@8/(byte) plex_sprite_idx#7 )
  (byte) plex_show_idx#41 ← phi( plex_irq::@8/(byte) plex_show_idx#7 )
  (byte) plex_free_next#18 ← phi( plex_irq::@8/(byte) plex_free_next#7 )
  (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#18)
  to:plex_irq::plexFreeNextYpos1_@return
plex_irq::plexFreeNextYpos1_@return: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1
  (bool) framedone#23 ← phi( plex_irq::plexFreeNextYpos1/(bool) framedone#24 )
  (byte*) PLEX_SCREEN_PTR#33 ← phi( plex_irq::plexFreeNextYpos1/(byte*) PLEX_SCREEN_PTR#34 )
  (byte) plex_sprite_msb#46 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_sprite_msb#50 )
  (byte) plex_free_next#44 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_free_next#18 )
  (byte) plex_sprite_idx#46 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_sprite_idx#50 )
  (byte) plex_show_idx#33 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_show_idx#41 )
  (byte) plex_irq::plexFreeNextYpos1_return#2 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_irq::plexFreeNextYpos1_return#0 )
  (byte) plex_irq::plexFreeNextYpos1_return#1 ← (byte) plex_irq::plexFreeNextYpos1_return#2
  to:plex_irq::@7
plex_irq::@7: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1_@return
  (bool) framedone#22 ← phi( plex_irq::plexFreeNextYpos1_@return/(bool) framedone#23 )
  (byte*) PLEX_SCREEN_PTR#32 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte*) PLEX_SCREEN_PTR#33 )
  (byte) plex_sprite_msb#37 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_sprite_msb#46 )
  (byte) plex_free_next#36 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_free_next#44 )
  (byte) plex_sprite_idx#38 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_sprite_idx#46 )
  (byte) plex_show_idx#20 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_show_idx#33 )
  (byte) plex_irq::plexFreeNextYpos1_return#3 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_irq::plexFreeNextYpos1_return#1 )
  (byte~) plex_irq::$2 ← (byte) plex_irq::plexFreeNextYpos1_return#3
  (byte) plex_irq::rasterY#1 ← (byte~) plex_irq::$2
  (bool~) plex_irq::$3 ← (byte) plex_show_idx#20 < (byte) PLEX_COUNT#0
  (number~) plex_irq::$4 ← *((byte*) RASTER#0) + (number) 2
  (bool~) plex_irq::$5 ← (byte) plex_irq::rasterY#1 < (number~) plex_irq::$4
  (bool~) plex_irq::$6 ← (bool~) plex_irq::$3 && (bool~) plex_irq::$5
  if((bool~) plex_irq::$6) goto plex_irq::@3
  to:plex_irq::@4
plex_irq::@4: scope:[plex_irq]  from plex_irq::@7
  (bool) framedone#21 ← phi( plex_irq::@7/(bool) framedone#22 )
  (byte) plex_sprite_msb#47 ← phi( plex_irq::@7/(byte) plex_sprite_msb#37 )
  (byte) plex_sprite_idx#47 ← phi( plex_irq::@7/(byte) plex_sprite_idx#38 )
  (byte) plex_free_next#45 ← phi( plex_irq::@7/(byte) plex_free_next#36 )
  (byte) plex_irq::rasterY#3 ← phi( plex_irq::@7/(byte) plex_irq::rasterY#1 )
  (byte) plex_show_idx#21 ← phi( plex_irq::@7/(byte) plex_show_idx#20 )
  *((byte*) IRQ_STATUS#0) ← (byte) IRQ_RASTER#0
  (bool~) plex_irq::$0 ← (byte) plex_show_idx#21 < (byte) PLEX_COUNT#0
  if((bool~) plex_irq::$0) goto plex_irq::@1
  to:plex_irq::@5
plex_irq::@1: scope:[plex_irq]  from plex_irq::@4
  (bool) framedone#19 ← phi( plex_irq::@4/(bool) framedone#21 )
  (byte) plex_sprite_msb#38 ← phi( plex_irq::@4/(byte) plex_sprite_msb#47 )
  (byte) plex_show_idx#42 ← phi( plex_irq::@4/(byte) plex_show_idx#21 )
  (byte) plex_sprite_idx#39 ← phi( plex_irq::@4/(byte) plex_sprite_idx#47 )
  (byte) plex_free_next#37 ← phi( plex_irq::@4/(byte) plex_free_next#45 )
  (byte) plex_irq::rasterY#2 ← phi( plex_irq::@4/(byte) plex_irq::rasterY#3 )
  *((byte*) RASTER#0) ← (byte) plex_irq::rasterY#2
  to:plex_irq::@2
plex_irq::@5: scope:[plex_irq]  from plex_irq::@4
  (byte) plex_sprite_msb#39 ← phi( plex_irq::@4/(byte) plex_sprite_msb#47 )
  (byte) plex_show_idx#43 ← phi( plex_irq::@4/(byte) plex_show_idx#21 )
  (byte) plex_sprite_idx#40 ← phi( plex_irq::@4/(byte) plex_sprite_idx#47 )
  (byte) plex_free_next#38 ← phi( plex_irq::@4/(byte) plex_free_next#45 )
  (bool) framedone#3 ← true
  to:plex_irq::@2
plex_irq::@2: scope:[plex_irq]  from plex_irq::@1 plex_irq::@5
  (bool) framedone#15 ← phi( plex_irq::@1/(bool) framedone#19 plex_irq::@5/(bool) framedone#3 )
  (byte) plex_sprite_msb#29 ← phi( plex_irq::@1/(byte) plex_sprite_msb#38 plex_irq::@5/(byte) plex_sprite_msb#39 )
  (byte) plex_show_idx#34 ← phi( plex_irq::@1/(byte) plex_show_idx#42 plex_irq::@5/(byte) plex_show_idx#43 )
  (byte) plex_sprite_idx#31 ← phi( plex_irq::@1/(byte) plex_sprite_idx#39 plex_irq::@5/(byte) plex_sprite_idx#40 )
  (byte) plex_free_next#28 ← phi( plex_irq::@1/(byte) plex_free_next#37 plex_irq::@5/(byte) plex_free_next#38 )
  *((byte*) BORDERCOL#0) ← (number) 0
  to:plex_irq::@return
plex_irq::@return: scope:[plex_irq]  from plex_irq::@2
  (bool) framedone#10 ← phi( plex_irq::@2/(bool) framedone#15 )
  (byte) plex_sprite_msb#21 ← phi( plex_irq::@2/(byte) plex_sprite_msb#29 )
  (byte) plex_show_idx#22 ← phi( plex_irq::@2/(byte) plex_show_idx#34 )
  (byte) plex_sprite_idx#20 ← phi( plex_irq::@2/(byte) plex_sprite_idx#31 )
  (byte) plex_free_next#19 ← phi( plex_irq::@2/(byte) plex_free_next#28 )
  (byte) plex_free_next#8 ← (byte) plex_free_next#19
  (byte) plex_sprite_idx#8 ← (byte) plex_sprite_idx#20
  (byte) plex_show_idx#8 ← (byte) plex_show_idx#22
  (byte) plex_sprite_msb#9 ← (byte) plex_sprite_msb#21
  (bool) framedone#4 ← (bool) framedone#10
  return 
  to:@return
loop: scope:[loop]  from main::@1
  (byte) plex_free_next#39 ← phi( main::@1/(byte) plex_free_next#26 )
  (byte) plex_sprite_msb#40 ← phi( main::@1/(byte) plex_sprite_msb#27 )
  (byte) plex_sprite_idx#41 ← phi( main::@1/(byte) plex_sprite_idx#30 )
  (byte) plex_show_idx#44 ← phi( main::@1/(byte) plex_show_idx#32 )
  (bool) framedone#20 ← phi( main::@1/(bool) framedone#14 )
  (byte) loop::sin_idx#0 ← (number) 0
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@15
  (byte) loop::sin_idx#6 ← phi( loop/(byte) loop::sin_idx#0 loop::@15/(byte) loop::sin_idx#7 )
  (byte) plex_free_next#30 ← phi( loop/(byte) plex_free_next#39 loop::@15/(byte) plex_free_next#9 )
  (byte) plex_sprite_msb#31 ← phi( loop/(byte) plex_sprite_msb#40 loop::@15/(byte) plex_sprite_msb#10 )
  (byte) plex_sprite_idx#33 ← phi( loop/(byte) plex_sprite_idx#41 loop::@15/(byte) plex_sprite_idx#9 )
  (byte) plex_show_idx#36 ← phi( loop/(byte) plex_show_idx#44 loop::@15/(byte) plex_show_idx#9 )
  (bool) framedone#16 ← phi( loop/(bool) framedone#20 loop::@15/(bool) framedone#5 )
  if(true) goto loop::@4
  to:loop::@return
loop::@4: scope:[loop]  from loop::@1 loop::@4
  (byte) plex_free_next#47 ← phi( loop::@1/(byte) plex_free_next#30 loop::@4/(byte) plex_free_next#47 )
  (byte) plex_sprite_msb#51 ← phi( loop::@1/(byte) plex_sprite_msb#31 loop::@4/(byte) plex_sprite_msb#51 )
  (byte) plex_sprite_idx#51 ← phi( loop::@1/(byte) plex_sprite_idx#33 loop::@4/(byte) plex_sprite_idx#51 )
  (byte) plex_show_idx#51 ← phi( loop::@1/(byte) plex_show_idx#36 loop::@4/(byte) plex_show_idx#51 )
  (byte) loop::sin_idx#4 ← phi( loop::@1/(byte) loop::sin_idx#6 loop::@4/(byte) loop::sin_idx#4 )
  (bool) framedone#11 ← phi( loop::@1/(bool) framedone#16 loop::@4/(bool) framedone#11 )
  (bool~) loop::$0 ← ! (bool) framedone#11
  if((bool~) loop::$0) goto loop::@4
  to:loop::@6
loop::@6: scope:[loop]  from loop::@4
  (byte) plex_free_next#46 ← phi( loop::@4/(byte) plex_free_next#47 )
  (byte) plex_sprite_msb#48 ← phi( loop::@4/(byte) plex_sprite_msb#51 )
  (byte) plex_sprite_idx#48 ← phi( loop::@4/(byte) plex_sprite_idx#51 )
  (byte) plex_show_idx#49 ← phi( loop::@4/(byte) plex_show_idx#51 )
  (byte) loop::sin_idx#2 ← phi( loop::@4/(byte) loop::sin_idx#4 )
  *((byte*) BORDERCOL#0) ← (byte) RED#0
  (byte) loop::y_idx#0 ← (byte) loop::sin_idx#2
  (number~) loop::$1 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) loop::sy#0 ← (number) 0
  to:loop::@10
loop::@10: scope:[loop]  from loop::@10 loop::@6
  (byte) plex_free_next#40 ← phi( loop::@10/(byte) plex_free_next#40 loop::@6/(byte) plex_free_next#46 )
  (byte) plex_sprite_msb#41 ← phi( loop::@10/(byte) plex_sprite_msb#41 loop::@6/(byte) plex_sprite_msb#48 )
  (byte) plex_sprite_idx#42 ← phi( loop::@10/(byte) plex_sprite_idx#42 loop::@6/(byte) plex_sprite_idx#48 )
  (byte) plex_show_idx#45 ← phi( loop::@10/(byte) plex_show_idx#45 loop::@6/(byte) plex_show_idx#49 )
  (byte) loop::sin_idx#5 ← phi( loop::@10/(byte) loop::sin_idx#5 loop::@6/(byte) loop::sin_idx#2 )
  (byte) loop::sy#2 ← phi( loop::@10/(byte) loop::sy#1 loop::@6/(byte) loop::sy#0 )
  (byte) loop::y_idx#2 ← phi( loop::@10/(byte) loop::y_idx#1 loop::@6/(byte) loop::y_idx#0 )
  *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((byte*) YSIN#0 + (byte) loop::y_idx#2)
  (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (number) 8
  (byte) loop::sy#1 ← (byte) loop::sy#2 + rangenext(0,loop::$1)
  (bool~) loop::$2 ← (byte) loop::sy#1 != rangelast(0,loop::$1)
  if((bool~) loop::$2) goto loop::@10
  to:loop::@11
loop::@11: scope:[loop]  from loop::@10
  (byte) plex_free_next#29 ← phi( loop::@10/(byte) plex_free_next#40 )
  (byte) plex_sprite_msb#30 ← phi( loop::@10/(byte) plex_sprite_msb#41 )
  (byte) plex_sprite_idx#32 ← phi( loop::@10/(byte) plex_sprite_idx#42 )
  (byte) plex_show_idx#35 ← phi( loop::@10/(byte) plex_show_idx#45 )
  (byte) loop::sin_idx#3 ← phi( loop::@10/(byte) loop::sin_idx#5 )
  (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#3 + (number) 1
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  call plexSort 
  to:loop::@15
loop::@15: scope:[loop]  from loop::@11
  (byte) loop::sin_idx#7 ← phi( loop::@11/(byte) loop::sin_idx#1 )
  (byte) plex_free_next#20 ← phi( loop::@11/(byte) plex_free_next#1 )
  (byte) plex_sprite_msb#22 ← phi( loop::@11/(byte) plex_sprite_msb#2 )
  (byte) plex_sprite_idx#21 ← phi( loop::@11/(byte) plex_sprite_idx#2 )
  (byte) plex_show_idx#23 ← phi( loop::@11/(byte) plex_show_idx#2 )
  (byte) plex_show_idx#9 ← (byte) plex_show_idx#23
  (byte) plex_sprite_idx#9 ← (byte) plex_sprite_idx#21
  (byte) plex_sprite_msb#10 ← (byte) plex_sprite_msb#22
  (byte) plex_free_next#9 ← (byte) plex_free_next#20
  *((byte*) BORDERCOL#0) ← (byte) GREEN#0
  (bool) framedone#5 ← false
  *((byte*) VIC_CONTROL#0) ← *((byte*) VIC_CONTROL#0) & (number) $7f
  *((byte*) RASTER#0) ← (number) 0
  to:loop::@1
loop::@return: scope:[loop]  from loop::@1
  (bool) framedone#12 ← phi( loop::@1/(bool) framedone#16 )
  (byte) plex_free_next#21 ← phi( loop::@1/(byte) plex_free_next#30 )
  (byte) plex_sprite_msb#23 ← phi( loop::@1/(byte) plex_sprite_msb#31 )
  (byte) plex_sprite_idx#22 ← phi( loop::@1/(byte) plex_sprite_idx#33 )
  (byte) plex_show_idx#24 ← phi( loop::@1/(byte) plex_show_idx#36 )
  (byte) plex_show_idx#10 ← (byte) plex_show_idx#24
  (byte) plex_sprite_idx#10 ← (byte) plex_sprite_idx#22
  (byte) plex_sprite_msb#11 ← (byte) plex_sprite_msb#23
  (byte) plex_free_next#10 ← (byte) plex_free_next#21
  (bool) framedone#6 ← (bool) framedone#12
  return 
  to:@return
@16: scope:[]  from @14
  (bool) framedone#17 ← phi( @14/(bool) framedone#2 )
  (byte) plex_free_next#31 ← phi( @14/(byte) plex_free_next#41 )
  (byte) plex_sprite_msb#32 ← phi( @14/(byte) plex_sprite_msb#42 )
  (byte) plex_sprite_idx#34 ← phi( @14/(byte) plex_sprite_idx#43 )
  (byte) plex_show_idx#37 ← phi( @14/(byte) plex_show_idx#46 )
  (byte*) PLEX_SCREEN_PTR#21 ← phi( @14/(byte*) PLEX_SCREEN_PTR#25 )
  call main 
  to:@17
@17: scope:[]  from @16
  (bool) framedone#13 ← phi( @16/(bool) framedone#1 )
  (byte) plex_free_next#22 ← phi( @16/(byte) plex_free_next#6 )
  (byte) plex_sprite_msb#24 ← phi( @16/(byte) plex_sprite_msb#7 )
  (byte) plex_sprite_idx#23 ← phi( @16/(byte) plex_sprite_idx#6 )
  (byte) plex_show_idx#25 ← phi( @16/(byte) plex_show_idx#6 )
  (byte*) PLEX_SCREEN_PTR#14 ← phi( @16/(byte*) PLEX_SCREEN_PTR#4 )
  (byte*) PLEX_SCREEN_PTR#7 ← (byte*) PLEX_SCREEN_PTR#14
  (byte) plex_show_idx#11 ← (byte) plex_show_idx#25
  (byte) plex_sprite_idx#11 ← (byte) plex_sprite_idx#23
  (byte) plex_sprite_msb#12 ← (byte) plex_sprite_msb#24
  (byte) plex_free_next#11 ← (byte) plex_free_next#22
  (bool) framedone#7 ← (bool) framedone#13
  to:@end
@end: scope:[]  from @17

SYMBOL TABLE SSA
(number~) $0
(label) @12
(label) @14
(label) @16
(label) @17
(label) @4
(label) @9
(label) @begin
(label) @end
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte*) CIA1_INTERRUPT
(byte*) CIA1_INTERRUPT#0
(byte) CIA_INTERRUPT_CLEAR
(byte) CIA_INTERRUPT_CLEAR#0
(byte*) D011
(byte*) D011#0
(byte) GREEN
(byte) GREEN#0
(byte*) IRQ_ENABLE
(byte*) IRQ_ENABLE#0
(byte) IRQ_RASTER
(byte) IRQ_RASTER#0
(byte*) IRQ_STATUS
(byte*) IRQ_STATUS#0
(void()**) KERNEL_IRQ
(void()**) KERNEL_IRQ#0
(byte) PLEX_COUNT
(byte) PLEX_COUNT#0
(byte[8]) PLEX_FREE_YPOS
(byte[8]) PLEX_FREE_YPOS#0
(byte[PLEX_COUNT#0]) PLEX_PTR
(byte[PLEX_COUNT#0]) PLEX_PTR#0
(byte*) PLEX_SCREEN_PTR
(byte*) PLEX_SCREEN_PTR#0
(byte*) PLEX_SCREEN_PTR#1
(byte*) PLEX_SCREEN_PTR#10
(byte*) PLEX_SCREEN_PTR#11
(byte*) PLEX_SCREEN_PTR#12
(byte*) PLEX_SCREEN_PTR#13
(byte*) PLEX_SCREEN_PTR#14
(byte*) PLEX_SCREEN_PTR#15
(byte*) PLEX_SCREEN_PTR#16
(byte*) PLEX_SCREEN_PTR#17
(byte*) PLEX_SCREEN_PTR#18
(byte*) PLEX_SCREEN_PTR#19
(byte*) PLEX_SCREEN_PTR#2
(byte*) PLEX_SCREEN_PTR#20
(byte*) PLEX_SCREEN_PTR#21
(byte*) PLEX_SCREEN_PTR#22
(byte*) PLEX_SCREEN_PTR#23
(byte*) PLEX_SCREEN_PTR#24
(byte*) PLEX_SCREEN_PTR#25
(byte*) PLEX_SCREEN_PTR#26
(byte*) PLEX_SCREEN_PTR#27
(byte*) PLEX_SCREEN_PTR#28
(byte*) PLEX_SCREEN_PTR#29
(byte*) PLEX_SCREEN_PTR#3
(byte*) PLEX_SCREEN_PTR#30
(byte*) PLEX_SCREEN_PTR#31
(byte*) PLEX_SCREEN_PTR#32
(byte*) PLEX_SCREEN_PTR#33
(byte*) PLEX_SCREEN_PTR#34
(byte*) PLEX_SCREEN_PTR#35
(byte*) PLEX_SCREEN_PTR#4
(byte*) PLEX_SCREEN_PTR#5
(byte*) PLEX_SCREEN_PTR#6
(byte*) PLEX_SCREEN_PTR#7
(byte*) PLEX_SCREEN_PTR#8
(byte*) PLEX_SCREEN_PTR#9
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0
(word[PLEX_COUNT#0]) PLEX_XPOS
(word[PLEX_COUNT#0]) PLEX_XPOS#0
(byte[PLEX_COUNT#0]) PLEX_YPOS
(byte[PLEX_COUNT#0]) PLEX_YPOS#0
(byte*) RASTER
(byte*) RASTER#0
(byte) RED
(byte) RED#0
(byte*) SCREEN
(byte*) SCREEN#0
(const byte) SIZEOF_WORD = (byte) 2
(byte*) SPRITE
(byte*) SPRITE#0
(byte*) SPRITES_COLS
(byte*) SPRITES_COLS#0
(byte*) SPRITES_ENABLE
(byte*) SPRITES_ENABLE#0
(byte*) SPRITES_XMSB
(byte*) SPRITES_XMSB#0
(byte*) SPRITES_XPOS
(byte*) SPRITES_XPOS#0
(byte*) SPRITES_YPOS
(byte*) SPRITES_YPOS#0
(byte*) VIC_CONTROL
(byte*) VIC_CONTROL#0
(byte) VIC_DEN
(byte) VIC_DEN#0
(byte) VIC_RSEL
(byte) VIC_RSEL#0
(byte) WHITE
(byte) WHITE#0
(byte*) YSIN
(byte*) YSIN#0
(bool) framedone
(bool) framedone#0
(bool) framedone#1
(bool) framedone#10
(bool) framedone#11
(bool) framedone#12
(bool) framedone#13
(bool) framedone#14
(bool) framedone#15
(bool) framedone#16
(bool) framedone#17
(bool) framedone#18
(bool) framedone#19
(bool) framedone#2
(bool) framedone#20
(bool) framedone#21
(bool) framedone#22
(bool) framedone#23
(bool) framedone#24
(bool) framedone#25
(bool) framedone#26
(bool) framedone#27
(bool) framedone#3
(bool) framedone#4
(bool) framedone#5
(bool) framedone#6
(bool) framedone#7
(bool) framedone#8
(bool) framedone#9
(void()) init()
(byte~) init::$0
(number~) init::$1
(void()*~) init::$3
(number~) init::$4
(byte*~) init::$5
(byte~) init::$6
(bool~) init::$7
(bool~) init::$8
(byte~) init::$9
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@5
(label) init::@return
(byte) init::ss
(byte) init::ss#0
(byte) init::ss#1
(byte) init::ss#2
(byte) init::sx
(byte) init::sx#0
(byte) init::sx#1
(byte) init::sx#2
(word) init::xp
(word) init::xp#0
(word) init::xp#1
(word) init::xp#2
(void()) loop()
(bool~) loop::$0
(number~) loop::$1
(bool~) loop::$2
(label) loop::@1
(label) loop::@10
(label) loop::@11
(label) loop::@15
(label) loop::@4
(label) loop::@6
(label) loop::@return
(byte) loop::sin_idx
(byte) loop::sin_idx#0
(byte) loop::sin_idx#1
(byte) loop::sin_idx#2
(byte) loop::sin_idx#3
(byte) loop::sin_idx#4
(byte) loop::sin_idx#5
(byte) loop::sin_idx#6
(byte) loop::sin_idx#7
(byte) loop::sy
(byte) loop::sy#0
(byte) loop::sy#1
(byte) loop::sy#2
(byte) loop::y_idx
(byte) loop::y_idx#0
(byte) loop::y_idx#1
(byte) loop::y_idx#2
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(number~) plexInit::$1
(bool~) plexInit::$2
(label) plexInit::@1
(label) plexInit::@3
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#0
(byte) plexInit::i#1
(byte) plexInit::i#2
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*~) plexInit::plexSetScreen1_$0#0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::plexSetScreen1_screen#0
(byte*) plexInit::plexSetScreen1_screen#1
(byte*) plexInit::screen
(byte*) plexInit::screen#0
(byte*) plexInit::screen#1
(void()) plexShowSprite()
(number~) plexShowSprite::$0
(byte~) plexShowSprite::$10
(byte~) plexShowSprite::$11
(byte~) plexShowSprite::$2
(byte~) plexShowSprite::$3
(bool~) plexShowSprite::$4
(number~) plexShowSprite::$5
(number~) plexShowSprite::$6
(bool~) plexShowSprite::$7
(bool~) plexShowSprite::$8
(number~) plexShowSprite::$9
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@4
(label) plexShowSprite::@6
(label) plexShowSprite::@7
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(number~) plexShowSprite::plexFreeAdd1_$0
(number~) plexShowSprite::plexFreeAdd1_$0#0
(number~) plexShowSprite::plexFreeAdd1_$1
(number~) plexShowSprite::plexFreeAdd1_$1#0
(number~) plexShowSprite::plexFreeAdd1_$2
(number~) plexShowSprite::plexFreeAdd1_$2#0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0
(byte) plexShowSprite::plexFreeAdd1_ypos#1
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0
(byte) plexShowSprite::plex_sprite_idx2#1
(byte) plexShowSprite::plex_sprite_idx2#2
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0
(byte) plexShowSprite::ypos
(byte) plexShowSprite::ypos#0
(void()) plexSort()
(number~) plexSort::$1
(number~) plexSort::$2
(bool~) plexSort::$3
(bool~) plexSort::$4
(number~) plexSort::$5
(bool~) plexSort::$6
(bool~) plexSort::$7
(bool~) plexSort::$8
(bool~) plexSort::$9
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#0
(byte) plexSort::m#1
(byte) plexSort::m#2
(byte) plexSort::m#3
(byte) plexSort::m#4
(byte) plexSort::m#5
(byte) plexSort::m#6
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0
(byte) plexSort::nxt_idx#1
(byte) plexSort::nxt_idx#2
(byte) plexSort::nxt_idx#3
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0
(byte) plexSort::nxt_y#1
(byte) plexSort::nxt_y#2
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(bool~) plexSort::plexFreePrepare1_$0#0
(label) plexSort::plexFreePrepare1_@1
(label) plexSort::plexFreePrepare1_@2
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#0
(byte) plexSort::plexFreePrepare1_s#1
(byte) plexSort::plexFreePrepare1_s#2
(byte) plexSort::s
(byte) plexSort::s#0
(byte) plexSort::s#1
(byte) plexSort::s#2
(byte) plexSort::s#3
(byte) plexSort::s#4
(byte) plex_free_next
(byte) plex_free_next#0
(byte) plex_free_next#1
(byte) plex_free_next#10
(byte) plex_free_next#11
(byte) plex_free_next#12
(byte) plex_free_next#13
(byte) plex_free_next#14
(byte) plex_free_next#15
(byte) plex_free_next#16
(byte) plex_free_next#17
(byte) plex_free_next#18
(byte) plex_free_next#19
(byte) plex_free_next#2
(byte) plex_free_next#20
(byte) plex_free_next#21
(byte) plex_free_next#22
(byte) plex_free_next#23
(byte) plex_free_next#24
(byte) plex_free_next#25
(byte) plex_free_next#26
(byte) plex_free_next#27
(byte) plex_free_next#28
(byte) plex_free_next#29
(byte) plex_free_next#3
(byte) plex_free_next#30
(byte) plex_free_next#31
(byte) plex_free_next#32
(byte) plex_free_next#33
(byte) plex_free_next#34
(byte) plex_free_next#35
(byte) plex_free_next#36
(byte) plex_free_next#37
(byte) plex_free_next#38
(byte) plex_free_next#39
(byte) plex_free_next#4
(byte) plex_free_next#40
(byte) plex_free_next#41
(byte) plex_free_next#42
(byte) plex_free_next#43
(byte) plex_free_next#44
(byte) plex_free_next#45
(byte) plex_free_next#46
(byte) plex_free_next#47
(byte) plex_free_next#5
(byte) plex_free_next#6
(byte) plex_free_next#7
(byte) plex_free_next#8
(byte) plex_free_next#9
interrupt(KERNEL_MIN)(void()) plex_irq()
(bool~) plex_irq::$0
(byte~) plex_irq::$2
(bool~) plex_irq::$3
(number~) plex_irq::$4
(bool~) plex_irq::$5
(bool~) plex_irq::$6
(label) plex_irq::@1
(label) plex_irq::@2
(label) plex_irq::@3
(label) plex_irq::@4
(label) plex_irq::@5
(label) plex_irq::@7
(label) plex_irq::@8
(label) plex_irq::@return
(label) plex_irq::plexFreeNextYpos1
(label) plex_irq::plexFreeNextYpos1_@return
(byte) plex_irq::plexFreeNextYpos1_return
(byte) plex_irq::plexFreeNextYpos1_return#0
(byte) plex_irq::plexFreeNextYpos1_return#1
(byte) plex_irq::plexFreeNextYpos1_return#2
(byte) plex_irq::plexFreeNextYpos1_return#3
(byte) plex_irq::rasterY
(byte) plex_irq::rasterY#0
(byte) plex_irq::rasterY#1
(byte) plex_irq::rasterY#2
(byte) plex_irq::rasterY#3
(byte) plex_show_idx
(byte) plex_show_idx#0
(byte) plex_show_idx#1
(byte) plex_show_idx#10
(byte) plex_show_idx#11
(byte) plex_show_idx#12
(byte) plex_show_idx#13
(byte) plex_show_idx#14
(byte) plex_show_idx#15
(byte) plex_show_idx#16
(byte) plex_show_idx#17
(byte) plex_show_idx#18
(byte) plex_show_idx#19
(byte) plex_show_idx#2
(byte) plex_show_idx#20
(byte) plex_show_idx#21
(byte) plex_show_idx#22
(byte) plex_show_idx#23
(byte) plex_show_idx#24
(byte) plex_show_idx#25
(byte) plex_show_idx#26
(byte) plex_show_idx#27
(byte) plex_show_idx#28
(byte) plex_show_idx#29
(byte) plex_show_idx#3
(byte) plex_show_idx#30
(byte) plex_show_idx#31
(byte) plex_show_idx#32
(byte) plex_show_idx#33
(byte) plex_show_idx#34
(byte) plex_show_idx#35
(byte) plex_show_idx#36
(byte) plex_show_idx#37
(byte) plex_show_idx#38
(byte) plex_show_idx#39
(byte) plex_show_idx#4
(byte) plex_show_idx#40
(byte) plex_show_idx#41
(byte) plex_show_idx#42
(byte) plex_show_idx#43
(byte) plex_show_idx#44
(byte) plex_show_idx#45
(byte) plex_show_idx#46
(byte) plex_show_idx#47
(byte) plex_show_idx#48
(byte) plex_show_idx#49
(byte) plex_show_idx#5
(byte) plex_show_idx#50
(byte) plex_show_idx#51
(byte) plex_show_idx#6
(byte) plex_show_idx#7
(byte) plex_show_idx#8
(byte) plex_show_idx#9
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0
(byte) plex_sprite_idx#1
(byte) plex_sprite_idx#10
(byte) plex_sprite_idx#11
(byte) plex_sprite_idx#12
(byte) plex_sprite_idx#13
(byte) plex_sprite_idx#14
(byte) plex_sprite_idx#15
(byte) plex_sprite_idx#16
(byte) plex_sprite_idx#17
(byte) plex_sprite_idx#18
(byte) plex_sprite_idx#19
(byte) plex_sprite_idx#2
(byte) plex_sprite_idx#20
(byte) plex_sprite_idx#21
(byte) plex_sprite_idx#22
(byte) plex_sprite_idx#23
(byte) plex_sprite_idx#24
(byte) plex_sprite_idx#25
(byte) plex_sprite_idx#26
(byte) plex_sprite_idx#27
(byte) plex_sprite_idx#28
(byte) plex_sprite_idx#29
(byte) plex_sprite_idx#3
(byte) plex_sprite_idx#30
(byte) plex_sprite_idx#31
(byte) plex_sprite_idx#32
(byte) plex_sprite_idx#33
(byte) plex_sprite_idx#34
(byte) plex_sprite_idx#35
(byte) plex_sprite_idx#36
(byte) plex_sprite_idx#37
(byte) plex_sprite_idx#38
(byte) plex_sprite_idx#39
(byte) plex_sprite_idx#4
(byte) plex_sprite_idx#40
(byte) plex_sprite_idx#41
(byte) plex_sprite_idx#42
(byte) plex_sprite_idx#43
(byte) plex_sprite_idx#44
(byte) plex_sprite_idx#45
(byte) plex_sprite_idx#46
(byte) plex_sprite_idx#47
(byte) plex_sprite_idx#48
(byte) plex_sprite_idx#49
(byte) plex_sprite_idx#5
(byte) plex_sprite_idx#50
(byte) plex_sprite_idx#51
(byte) plex_sprite_idx#6
(byte) plex_sprite_idx#7
(byte) plex_sprite_idx#8
(byte) plex_sprite_idx#9
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0
(byte) plex_sprite_msb#1
(byte) plex_sprite_msb#10
(byte) plex_sprite_msb#11
(byte) plex_sprite_msb#12
(byte) plex_sprite_msb#13
(byte) plex_sprite_msb#14
(byte) plex_sprite_msb#15
(byte) plex_sprite_msb#16
(byte) plex_sprite_msb#17
(byte) plex_sprite_msb#18
(byte) plex_sprite_msb#19
(byte) plex_sprite_msb#2
(byte) plex_sprite_msb#20
(byte) plex_sprite_msb#21
(byte) plex_sprite_msb#22
(byte) plex_sprite_msb#23
(byte) plex_sprite_msb#24
(byte) plex_sprite_msb#25
(byte) plex_sprite_msb#26
(byte) plex_sprite_msb#27
(byte) plex_sprite_msb#28
(byte) plex_sprite_msb#29
(byte) plex_sprite_msb#3
(byte) plex_sprite_msb#30
(byte) plex_sprite_msb#31
(byte) plex_sprite_msb#32
(byte) plex_sprite_msb#33
(byte) plex_sprite_msb#34
(byte) plex_sprite_msb#35
(byte) plex_sprite_msb#36
(byte) plex_sprite_msb#37
(byte) plex_sprite_msb#38
(byte) plex_sprite_msb#39
(byte) plex_sprite_msb#4
(byte) plex_sprite_msb#40
(byte) plex_sprite_msb#41
(byte) plex_sprite_msb#42
(byte) plex_sprite_msb#43
(byte) plex_sprite_msb#44
(byte) plex_sprite_msb#45
(byte) plex_sprite_msb#46
(byte) plex_sprite_msb#47
(byte) plex_sprite_msb#48
(byte) plex_sprite_msb#49
(byte) plex_sprite_msb#5
(byte) plex_sprite_msb#50
(byte) plex_sprite_msb#51
(byte) plex_sprite_msb#6
(byte) plex_sprite_msb#7
(byte) plex_sprite_msb#8
(byte) plex_sprite_msb#9

Adding number conversion cast (unumber) $10 in (byte) VIC_DEN#0 ← (number) $10
Adding number conversion cast (unumber) 8 in (byte) VIC_RSEL#0 ← (number) 8
Adding number conversion cast (unumber) 1 in (byte) IRQ_RASTER#0 ← (number) 1
Adding number conversion cast (unumber) $7f in (byte) CIA_INTERRUPT_CLEAR#0 ← (number) $7f
Adding number conversion cast (unumber) 1 in (byte) WHITE#0 ← (number) 1
Adding number conversion cast (unumber) 2 in (byte) RED#0 ← (number) 2
Adding number conversion cast (unumber) 5 in (byte) GREEN#0 ← (number) 5
Adding number conversion cast (unumber) $20 in (byte) PLEX_COUNT#0 ← (number) $20
Adding number conversion cast (unumber) 0 in (byte) plex_show_idx#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_sprite_idx#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#0 ← (number) 1
Adding number conversion cast (unumber) $3f8 in (byte*~) plexInit::plexSetScreen1_$0#0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
Adding number conversion cast (unumber) 1 in (number~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) plexInit::$1 in (number~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (byte) plexInit::i#0 ← (number) 0
Adding number conversion cast (unumber) 2 in (number~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (number) 2
Adding number conversion cast (unumber) plexSort::$1 in (number~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (unumber)(number) 2
Adding number conversion cast (unumber) 0 in (byte) plexSort::m#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (number~) plexSort::$2 ← (byte) plexSort::m#2 + (number) 1
Adding number conversion cast (unumber) plexSort::$2 in (number~) plexSort::$2 ← (byte) plexSort::m#2 + (unumber)(number) 1
Adding number conversion cast (unumber) 1 in (number~) plexSort::$5 ← (byte) plexSort::s#3 + (number) 1
Adding number conversion cast (unumber) plexSort::$5 in (number~) plexSort::$5 ← (byte) plexSort::s#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $ff in (bool~) plexSort::$6 ← (byte) plexSort::s#1 != (number) $ff
Adding number conversion cast (unumber) 0 in (byte) plex_show_idx#1 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_sprite_idx#1 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#1 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) plexSort::plexFreePrepare1_s#0 ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_free_next#0 ← (number) 0
Adding number conversion cast (unumber) 2 in (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#13 * (number) 2
Adding number conversion cast (unumber) plexShowSprite::$0 in (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#13 * (unumber)(number) 2
Adding number conversion cast (unumber) $15 in (number~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$0#0 in (number~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (unumber)(number) $15
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#13 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$1#0 in (number~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#13 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::plexFreeAdd1_$2#0 ← (unumber~) plexShowSprite::plexFreeAdd1_$1#0 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$2#0 in (number~) plexShowSprite::plexFreeAdd1_$2#0 ← (unumber~) plexShowSprite::plexFreeAdd1_$1#0 & (unumber)(number) 7
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
Adding number conversion cast (unumber) $ff in (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#15
Adding number conversion cast (unumber) plexShowSprite::$9 in (number~) plexShowSprite::$9 ← (unumber)(number) $ff ^ (byte) plex_sprite_msb#15
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#15 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::$5 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#15 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::$6 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (unumber)(number) 7
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#16 << (number) 1
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#4 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) plex_free_next#4 ← (number) 0
Adding number conversion cast (unumber) 3 in (number~) init::$1 ← (byte~) init::$0 | (number) 3
Adding number conversion cast (unumber) init::$1 in (number~) init::$1 ← (byte~) init::$0 | (unumber)(number) 3
Adding number conversion cast (unumber) $20 in (word) init::xp#0 ← (number) $20
Adding number conversion cast (unumber) 1 in (number~) init::$4 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) init::$4 in (number~) init::$4 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (byte) init::sx#0 ← (number) 0
Adding number conversion cast (unumber) $40 in (byte*~) init::$5 ← (byte*) SPRITE#0 / (number) $40
Adding number conversion cast (unumber) 9 in (word) init::xp#1 ← (word) init::xp#2 + (number) 9
Adding number conversion cast (unumber) $ff in *((byte*) SPRITES_ENABLE#0) ← (number) $ff
Adding number conversion cast (unumber) 0 in (byte) init::ss#0 ← (number) 0
Adding number conversion cast (unumber) 2 in (number~) plex_irq::$4 ← *((byte*) RASTER#0) + (number) 2
Adding number conversion cast (unumber) plex_irq::$4 in (number~) plex_irq::$4 ← *((byte*) RASTER#0) + (unumber)(number) 2
Adding number conversion cast (unumber) 0 in *((byte*) BORDERCOL#0) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) loop::sin_idx#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (number~) loop::$1 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) loop::$1 in (number~) loop::$1 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (byte) loop::sy#0 ← (number) 0
Adding number conversion cast (unumber) 8 in (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (number) 8
Adding number conversion cast (unumber) 1 in (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#3 + (number) 1
Adding number conversion cast (unumber) $7f in *((byte*) VIC_CONTROL#0) ← *((byte*) VIC_CONTROL#0) & (number) $7f
Adding number conversion cast (unumber) 0 in *((byte*) RASTER#0) ← (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) SPRITES_XPOS#0 ← (byte*)(number) $d000
Inlining cast (byte*) SPRITES_YPOS#0 ← (byte*)(number) $d001
Inlining cast (byte*) SPRITES_XMSB#0 ← (byte*)(number) $d010
Inlining cast (byte*) RASTER#0 ← (byte*)(number) $d012
Inlining cast (byte*) SPRITES_ENABLE#0 ← (byte*)(number) $d015
Inlining cast (byte*) BORDERCOL#0 ← (byte*)(number) $d020
Inlining cast (byte*) SPRITES_COLS#0 ← (byte*)(number) $d027
Inlining cast (byte*) VIC_CONTROL#0 ← (byte*)(number) $d011
Inlining cast (byte*) D011#0 ← (byte*)(number) $d011
Inlining cast (byte) VIC_DEN#0 ← (unumber)(number) $10
Inlining cast (byte) VIC_RSEL#0 ← (unumber)(number) 8
Inlining cast (byte*) IRQ_STATUS#0 ← (byte*)(number) $d019
Inlining cast (byte*) IRQ_ENABLE#0 ← (byte*)(number) $d01a
Inlining cast (byte) IRQ_RASTER#0 ← (unumber)(number) 1
Inlining cast (byte*) CIA1_INTERRUPT#0 ← (byte*)(number) $dc0d
Inlining cast (byte) CIA_INTERRUPT_CLEAR#0 ← (unumber)(number) $7f
Inlining cast (void()**) KERNEL_IRQ#0 ← (void()**)(number) $314
Inlining cast (byte) WHITE#0 ← (unumber)(number) 1
Inlining cast (byte) RED#0 ← (unumber)(number) 2
Inlining cast (byte) GREEN#0 ← (unumber)(number) 5
Inlining cast (byte) PLEX_COUNT#0 ← (unumber)(number) $20
Inlining cast (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(number~) $0
Inlining cast (byte) plex_show_idx#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_idx#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#0 ← (unumber)(number) 1
Inlining cast (byte) plexInit::i#0 ← (unumber)(number) 0
Inlining cast (byte) plexSort::m#0 ← (unumber)(number) 0
Inlining cast (byte) plex_show_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#1 ← (unumber)(number) 1
Inlining cast (byte) plexSort::plexFreePrepare1_s#0 ← (unumber)(number) 0
Inlining cast *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (unumber)(number) 0
Inlining cast (byte) plex_free_next#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#4 ← (unumber)(number) 1
Inlining cast (byte) plex_free_next#4 ← (unumber)(number) 0
Inlining cast (byte*) SCREEN#0 ← (byte*)(number) $400
Inlining cast (byte*) SPRITE#0 ← (byte*)(number) $2000
Inlining cast (byte*) YSIN#0 ← (byte*)(number) $2100
Inlining cast (word) init::xp#0 ← (unumber)(number) $20
Inlining cast (byte) init::sx#0 ← (unumber)(number) 0
Inlining cast (byte~) init::$6 ← (byte)(byte*~) init::$5
Inlining cast *((byte*) SPRITES_ENABLE#0) ← (unumber)(number) $ff
Inlining cast (byte) init::ss#0 ← (unumber)(number) 0
Inlining cast *((byte*) BORDERCOL#0) ← (unumber)(number) 0
Inlining cast (byte) loop::sin_idx#0 ← (unumber)(number) 0
Inlining cast (byte) loop::sy#0 ← (unumber)(number) 0
Inlining cast *((byte*) RASTER#0) ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 53249
Simplifying constant pointer cast (byte*) 53264
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (byte*) 53265
Simplifying constant integer cast $10
Simplifying constant integer cast 8
Simplifying constant pointer cast (byte*) 53273
Simplifying constant pointer cast (byte*) 53274
Simplifying constant integer cast 1
Simplifying constant pointer cast (byte*) 56333
Simplifying constant integer cast $7f
Simplifying constant pointer cast (void()**) 788
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 5
Simplifying constant integer cast $20
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast $3f8
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $15
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 8192
Simplifying constant pointer cast (byte*) 8448
Simplifying constant integer cast 3
Simplifying constant integer cast $20
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast 9
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 8
Simplifying constant integer cast 1
Simplifying constant integer cast $7f
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $3f8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (byte) 1
Inferred type updated to byte in (unumber~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (byte) 2
Inferred type updated to byte in (unumber~) plexSort::$2 ← (byte) plexSort::m#2 + (byte) 1
Inferred type updated to byte in (unumber~) plexSort::$5 ← (byte) plexSort::s#3 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::$0 ← (byte) plex_sprite_idx#13 * (byte) 2
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (byte) $15
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#13 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7
Inferred type updated to byte in (unumber~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#15
Inferred type updated to byte in (unumber~) plexShowSprite::$5 ← (byte) plex_sprite_idx#15 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7
Inferred type updated to byte in (unumber~) init::$1 ← (byte~) init::$0 | (byte) 3
Inferred type updated to byte in (unumber~) init::$4 ← (byte) PLEX_COUNT#0 - (byte) 1
Inferred type updated to byte in (unumber~) plex_irq::$4 ← *((byte*) RASTER#0) + (byte) 2
Inferred type updated to byte in (unumber~) loop::$1 ← (byte) PLEX_COUNT#0 - (byte) 1
Inversing boolean not [53] (bool~) plexSort::$4 ← (byte) plexSort::nxt_y#0 >= *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2)) from [52] (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))
Inversing boolean not [124] (bool~) plexShowSprite::$8 ← (byte) plex_sprite_msb#3 != (byte) 0 from [123] (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 (byte) plex_free_next#42 (byte) plex_free_next#32 (byte) plex_free_next#33 
Alias candidate removed (volatile)(byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#3 (byte~) plexShowSprite::$6 
Alias (byte*) plexInit::plexSetScreen1_screen#0 = (byte*) plexInit::screen#1 (byte*) plexInit::plexSetScreen1_screen#1 
Alias (byte*) PLEX_SCREEN_PTR#1 = (byte*~) plexInit::plexSetScreen1_$0#0 (byte*) PLEX_SCREEN_PTR#22 
Alias (byte*) PLEX_SCREEN_PTR#15 = (byte*) PLEX_SCREEN_PTR#8 (byte*) PLEX_SCREEN_PTR#2 
Alias (byte) plexSort::m#2 = (byte) plexSort::m#4 (byte) plexSort::s#0 
Alias (byte) plexSort::nxt_y#0 = (byte) plexSort::nxt_y#2 
Alias (byte) plexSort::nxt_idx#0 = (byte) plexSort::nxt_idx#3 
Alias (byte) plexSort::s#1 = (byte) plexSort::s#4 
Alias (byte) plexSort::nxt_idx#1 = (byte) plexSort::nxt_idx#2 
Alias (byte) plexSort::m#5 = (byte) plexSort::m#6 
Alias (byte) plex_show_idx#1 = (byte) plex_show_idx#47 
Alias (byte) plex_sprite_idx#1 = (byte) plex_sprite_idx#44 
Alias (byte) plex_sprite_msb#1 = (byte) plex_sprite_msb#43 
Alias (byte) plex_show_idx#12 = (byte) plex_show_idx#26 (byte) plex_show_idx#38 (byte) plex_show_idx#2 
Alias (byte) plex_sprite_idx#12 = (byte) plex_sprite_idx#24 (byte) plex_sprite_idx#35 (byte) plex_sprite_idx#2 
Alias (byte) plex_sprite_msb#13 = (byte) plex_sprite_msb#25 (byte) plex_sprite_msb#33 (byte) plex_sprite_msb#2 
Alias (byte) plex_free_next#0 = (byte) plex_free_next#12 (byte) plex_free_next#1 
Alias (byte) plexShowSprite::plex_sprite_idx2#0 = (byte~) plexShowSprite::$0 (byte) plexShowSprite::plex_sprite_idx2#2 (byte) plexShowSprite::plex_sprite_idx2#1 
Alias (byte) plexShowSprite::plexFreeAdd1_ypos#0 = (byte) plexShowSprite::ypos#0 (byte) plexShowSprite::plexFreeAdd1_ypos#1 
Alias (byte) plex_free_next#13 = (byte) plex_free_next#23 
Alias (byte) plex_show_idx#13 = (byte) plex_show_idx#28 (byte) plex_show_idx#14 (byte) plex_show_idx#29 (byte) plex_show_idx#30 
Alias (byte*) PLEX_SCREEN_PTR#16 = (byte*) PLEX_SCREEN_PTR#23 (byte*) PLEX_SCREEN_PTR#9 
Alias (byte) plex_sprite_idx#13 = (byte) plex_sprite_idx#26 (byte) plex_sprite_idx#14 (byte) plex_sprite_idx#27 (byte) plex_sprite_idx#28 
Alias (byte) plex_sprite_msb#14 = (byte) plex_sprite_msb#34 (byte) plex_sprite_msb#44 (byte) plex_sprite_msb#26 (byte) plex_sprite_msb#15 
Alias (byte) plex_free_next#24 = (byte) plex_free_next#25 
Alias (byte) plex_show_idx#3 = (byte) plex_show_idx#31 
Alias (byte) plex_free_next#14 = (byte) plex_free_next#3 
Alias (byte) plex_sprite_idx#16 = (byte) plex_sprite_idx#4 
Alias (byte) plex_show_idx#16 = (byte) plex_show_idx#4 
Alias (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#5 
Alias (byte*) PLEX_SCREEN_PTR#0 = (byte*) PLEX_SCREEN_PTR#29 (byte*) PLEX_SCREEN_PTR#28 (byte*) PLEX_SCREEN_PTR#25 (byte*) PLEX_SCREEN_PTR#21 
Alias (byte) plex_show_idx#0 = (byte) plex_show_idx#50 (byte) plex_show_idx#48 (byte) plex_show_idx#46 (byte) plex_show_idx#37 
Alias (byte) plex_sprite_idx#0 = (byte) plex_sprite_idx#49 (byte) plex_sprite_idx#45 (byte) plex_sprite_idx#43 (byte) plex_sprite_idx#34 
Alias (byte) plex_sprite_msb#0 = (byte) plex_sprite_msb#49 (byte) plex_sprite_msb#45 (byte) plex_sprite_msb#42 (byte) plex_sprite_msb#32 
Alias (byte) plex_free_next#31 = (byte) plex_free_next#43 (byte) plex_free_next#4 (byte) plex_free_next#41 
Alias (byte) plex_show_idx#32 = (byte) plex_show_idx#39 
Alias (byte) plex_sprite_idx#30 = (byte) plex_sprite_idx#36 
Alias (byte) plex_sprite_msb#27 = (byte) plex_sprite_msb#35 
Alias (byte) plex_free_next#26 = (byte) plex_free_next#34 
Alias (bool) framedone#14 = (bool) framedone#18 
Alias (byte*) PLEX_SCREEN_PTR#10 = (byte*) PLEX_SCREEN_PTR#3 (byte*) PLEX_SCREEN_PTR#18 (byte*) PLEX_SCREEN_PTR#11 (byte*) PLEX_SCREEN_PTR#4 
Alias (byte) plex_show_idx#17 = (byte) plex_show_idx#5 (byte) plex_show_idx#18 (byte) plex_show_idx#6 
Alias (byte) plex_sprite_idx#17 = (byte) plex_sprite_idx#5 (byte) plex_sprite_idx#18 (byte) plex_sprite_idx#6 
Alias (byte) plex_sprite_msb#18 = (byte) plex_sprite_msb#6 (byte) plex_sprite_msb#19 (byte) plex_sprite_msb#7 
Alias (byte) plex_free_next#15 = (byte) plex_free_next#5 (byte) plex_free_next#16 (byte) plex_free_next#6 
Alias (bool) framedone#0 = (bool) framedone#8 (bool) framedone#9 (bool) framedone#1 
Alias (byte*) PLEX_SCREEN_PTR#12 = (byte*) PLEX_SCREEN_PTR#5 
Alias (byte*) PLEX_SCREEN_PTR#27 = (byte*) PLEX_SCREEN_PTR#30 
Alias (byte*) PLEX_SCREEN_PTR#13 = (byte*) PLEX_SCREEN_PTR#20 (byte*) PLEX_SCREEN_PTR#24 (byte*) PLEX_SCREEN_PTR#6 
Alias (byte*) PLEX_SCREEN_PTR#26 = (byte*) PLEX_SCREEN_PTR#35 (byte*) PLEX_SCREEN_PTR#34 (byte*) PLEX_SCREEN_PTR#33 (byte*) PLEX_SCREEN_PTR#32 
Alias (bool) framedone#19 = (bool) framedone#25 (bool) framedone#26 (bool) framedone#24 (bool) framedone#23 (bool) framedone#22 (bool) framedone#21 
Alias (byte) plex_free_next#17 = (byte) plex_free_next#7 (byte) plex_free_next#18 (byte) plex_free_next#44 (byte) plex_free_next#36 (byte) plex_free_next#45 (byte) plex_free_next#37 (byte) plex_free_next#38 
Alias (byte) plex_sprite_idx#19 = (byte) plex_sprite_idx#7 (byte) plex_sprite_idx#50 (byte) plex_sprite_idx#46 (byte) plex_sprite_idx#38 (byte) plex_sprite_idx#47 (byte) plex_sprite_idx#39 (byte) plex_sprite_idx#40 
Alias (byte) plex_show_idx#19 = (byte) plex_show_idx#7 (byte) plex_show_idx#41 (byte) plex_show_idx#33 (byte) plex_show_idx#20 (byte) plex_show_idx#21 (byte) plex_show_idx#42 (byte) plex_show_idx#43 
Alias (byte) plex_sprite_msb#20 = (byte) plex_sprite_msb#8 (byte) plex_sprite_msb#50 (byte) plex_sprite_msb#46 (byte) plex_sprite_msb#37 (byte) plex_sprite_msb#47 (byte) plex_sprite_msb#38 (byte) plex_sprite_msb#39 
Alias (byte) plex_irq::plexFreeNextYpos1_return#0 = (byte) plex_irq::plexFreeNextYpos1_return#2 (byte) plex_irq::plexFreeNextYpos1_return#1 (byte) plex_irq::plexFreeNextYpos1_return#3 (byte~) plex_irq::$2 (byte) plex_irq::rasterY#1 (byte) plex_irq::rasterY#3 (byte) plex_irq::rasterY#2 
Alias (byte) plex_free_next#19 = (byte) plex_free_next#28 (byte) plex_free_next#8 
Alias (byte) plex_sprite_idx#20 = (byte) plex_sprite_idx#31 (byte) plex_sprite_idx#8 
Alias (byte) plex_show_idx#22 = (byte) plex_show_idx#34 (byte) plex_show_idx#8 
Alias (byte) plex_sprite_msb#21 = (byte) plex_sprite_msb#29 (byte) plex_sprite_msb#9 
Alias (bool) framedone#10 = (bool) framedone#15 (bool) framedone#4 
Alias (byte) loop::sin_idx#2 = (byte) loop::sin_idx#4 (byte) loop::y_idx#0 
Alias (byte) plex_show_idx#49 = (byte) plex_show_idx#51 
Alias (byte) plex_sprite_idx#48 = (byte) plex_sprite_idx#51 
Alias (byte) plex_sprite_msb#48 = (byte) plex_sprite_msb#51 
Alias (byte) plex_free_next#46 = (byte) plex_free_next#47 
Alias (byte) loop::sin_idx#3 = (byte) loop::sin_idx#5 
Alias (byte) plex_show_idx#35 = (byte) plex_show_idx#45 
Alias (byte) plex_sprite_idx#32 = (byte) plex_sprite_idx#42 
Alias (byte) plex_sprite_msb#30 = (byte) plex_sprite_msb#41 
Alias (byte) plex_free_next#29 = (byte) plex_free_next#40 
Alias (byte) loop::sin_idx#1 = (byte) loop::sin_idx#7 
Alias (byte) plex_show_idx#23 = (byte) plex_show_idx#9 
Alias (byte) plex_sprite_idx#21 = (byte) plex_sprite_idx#9 
Alias (byte) plex_sprite_msb#10 = (byte) plex_sprite_msb#22 
Alias (byte) plex_free_next#20 = (byte) plex_free_next#9 
Alias (byte) plex_show_idx#10 = (byte) plex_show_idx#24 (byte) plex_show_idx#36 
Alias (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#22 (byte) plex_sprite_idx#33 
Alias (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#23 (byte) plex_sprite_msb#31 
Alias (byte) plex_free_next#10 = (byte) plex_free_next#21 (byte) plex_free_next#30 
Alias (bool) framedone#12 = (bool) framedone#16 (bool) framedone#6 
Alias (bool) framedone#17 = (bool) framedone#2 
Alias (byte*) PLEX_SCREEN_PTR#14 = (byte*) PLEX_SCREEN_PTR#7 
Alias (byte) plex_show_idx#11 = (byte) plex_show_idx#25 
Alias (byte) plex_sprite_idx#11 = (byte) plex_sprite_idx#23 
Alias (byte) plex_sprite_msb#12 = (byte) plex_sprite_msb#24 
Alias (byte) plex_free_next#11 = (byte) plex_free_next#22 
Alias (bool) framedone#13 = (bool) framedone#7 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 (byte) plex_free_next#42 (byte) plex_free_next#32 (byte) plex_free_next#33 
Alias candidate removed (volatile)(byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#3 (byte~) plexShowSprite::$6 
Alias (byte) plex_sprite_idx#13 = (byte) plex_sprite_idx#15 
Alias (byte) plex_show_idx#13 = (byte) plex_show_idx#15 
Alias (byte) plex_sprite_msb#14 = (byte) plex_sprite_msb#16 
Alias (byte) plex_free_next#14 = (byte) plex_free_next#24 
Alias (byte) plex_show_idx#16 = (byte) plex_show_idx#3 
Alias (byte) plex_free_next#17 = (byte) plex_free_next#19 
Alias (byte) plex_sprite_idx#19 = (byte) plex_sprite_idx#20 
Alias (byte) plex_show_idx#19 = (byte) plex_show_idx#22 
Alias (byte) plex_sprite_msb#20 = (byte) plex_sprite_msb#21 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 (byte) plex_free_next#42 (byte) plex_free_next#32 (byte) plex_free_next#33 
Alias candidate removed (volatile)(byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#3 (byte~) plexShowSprite::$6 
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#15
Self Phi Eliminated (byte) plexSort::nxt_y#1
Self Phi Eliminated (byte) plexSort::nxt_idx#1
Self Phi Eliminated (byte) plexSort::m#5
Self Phi Eliminated (byte) plex_show_idx#12
Self Phi Eliminated (byte) plex_sprite_idx#12
Self Phi Eliminated (byte) plex_sprite_msb#13
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#27
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#13
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#26
Self Phi Eliminated (bool) framedone#19
Self Phi Eliminated (bool) framedone#11
Self Phi Eliminated (byte) loop::sin_idx#2
Self Phi Eliminated (byte) plex_show_idx#49
Self Phi Eliminated (byte) plex_sprite_idx#48
Self Phi Eliminated (byte) plex_sprite_msb#48
Self Phi Eliminated (byte) plex_free_next#46
Self Phi Eliminated (byte) loop::sin_idx#3
Self Phi Eliminated (byte) plex_show_idx#35
Self Phi Eliminated (byte) plex_sprite_idx#32
Self Phi Eliminated (byte) plex_sprite_msb#30
Self Phi Eliminated (byte) plex_free_next#29
Successful SSA optimization Pass2SelfPhiElimination
Identical Phi Values (byte*) plexInit::plexSetScreen1_screen#0 (byte*) plexInit::screen#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#15 (byte*) PLEX_SCREEN_PTR#1
Identical Phi Values (byte) plexSort::nxt_y#1 (byte) plexSort::nxt_y#0
Identical Phi Values (byte) plexSort::nxt_idx#1 (byte) plexSort::nxt_idx#0
Identical Phi Values (byte) plexSort::m#5 (byte) plexSort::m#2
Identical Phi Values (byte) plex_show_idx#12 (byte) plex_show_idx#1
Identical Phi Values (byte) plex_sprite_idx#12 (byte) plex_sprite_idx#1
Identical Phi Values (byte) plex_sprite_msb#13 (byte) plex_sprite_msb#1
Identical Phi Values (byte) plex_sprite_idx#13 (byte) plex_sprite_idx#25
Identical Phi Values (byte) plex_show_idx#13 (byte) plex_show_idx#27
Identical Phi Values (byte) plex_free_next#13 (byte) plex_free_next#27
Identical Phi Values (byte*) PLEX_SCREEN_PTR#16 (byte*) PLEX_SCREEN_PTR#26
Identical Phi Values (byte) plex_sprite_msb#14 (byte) plex_sprite_msb#28
Identical Phi Values (byte) plex_free_next#42 (byte) plex_free_next#2
Identical Phi Values (byte) plex_free_next#32 (byte) plex_free_next#42
Identical Phi Values (byte) plex_free_next#33 (byte) plex_free_next#42
Identical Phi Values (byte) plex_sprite_idx#29 (byte) plex_sprite_idx#3
Identical Phi Values (byte*) PLEX_SCREEN_PTR#17 (byte*) PLEX_SCREEN_PTR#0
Identical Phi Values (byte) plex_show_idx#32 (byte) plex_show_idx#0
Identical Phi Values (byte) plex_sprite_idx#30 (byte) plex_sprite_idx#0
Identical Phi Values (byte) plex_sprite_msb#27 (byte) plex_sprite_msb#0
Identical Phi Values (byte) plex_free_next#26 (byte) plex_free_next#31
Identical Phi Values (bool) framedone#14 (bool) framedone#17
Identical Phi Values (byte*) PLEX_SCREEN_PTR#10 (byte*) PLEX_SCREEN_PTR#13
Identical Phi Values (byte) plex_show_idx#17 (byte) plex_show_idx#10
Identical Phi Values (byte) plex_sprite_idx#17 (byte) plex_sprite_idx#10
Identical Phi Values (byte) plex_sprite_msb#18 (byte) plex_sprite_msb#11
Identical Phi Values (byte) plex_free_next#15 (byte) plex_free_next#10
Identical Phi Values (bool) framedone#0 (bool) framedone#12
Identical Phi Values (byte*) PLEX_SCREEN_PTR#19 (byte*) PLEX_SCREEN_PTR#17
Identical Phi Values (byte*) PLEX_SCREEN_PTR#12 (byte*) PLEX_SCREEN_PTR#15
Identical Phi Values (byte*) PLEX_SCREEN_PTR#27 (byte*) PLEX_SCREEN_PTR#12
Identical Phi Values (byte*) PLEX_SCREEN_PTR#13 (byte*) PLEX_SCREEN_PTR#27
Identical Phi Values (byte) plex_sprite_idx#37 (byte) plex_sprite_idx#0
Identical Phi Values (byte) plex_show_idx#40 (byte) plex_show_idx#0
Identical Phi Values (byte) plex_free_next#35 (byte) plex_free_next#31
Identical Phi Values (byte) plex_sprite_msb#36 (byte) plex_sprite_msb#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#31 (byte*) PLEX_SCREEN_PTR#0
Identical Phi Values (bool) framedone#27 (bool) framedone#17
Identical Phi Values (byte*) PLEX_SCREEN_PTR#26 (byte*) PLEX_SCREEN_PTR#31
Identical Phi Values (bool) framedone#19 (bool) framedone#27
Identical Phi Values (byte) plex_free_next#17 (byte) plex_free_next#14
Identical Phi Values (byte) plex_sprite_idx#19 (byte) plex_sprite_idx#16
Identical Phi Values (byte) plex_show_idx#19 (byte) plex_show_idx#16
Identical Phi Values (byte) plex_sprite_msb#20 (byte) plex_sprite_msb#17
Identical Phi Values (bool) framedone#20 (bool) framedone#14
Identical Phi Values (byte) plex_show_idx#44 (byte) plex_show_idx#32
Identical Phi Values (byte) plex_sprite_idx#41 (byte) plex_sprite_idx#30
Identical Phi Values (byte) plex_sprite_msb#40 (byte) plex_sprite_msb#27
Identical Phi Values (byte) plex_free_next#39 (byte) plex_free_next#26
Identical Phi Values (bool) framedone#11 (bool) framedone#12
Identical Phi Values (byte) loop::sin_idx#2 (byte) loop::sin_idx#6
Identical Phi Values (byte) plex_show_idx#49 (byte) plex_show_idx#10
Identical Phi Values (byte) plex_sprite_idx#48 (byte) plex_sprite_idx#10
Identical Phi Values (byte) plex_sprite_msb#48 (byte) plex_sprite_msb#11
Identical Phi Values (byte) plex_free_next#46 (byte) plex_free_next#10
Identical Phi Values (byte) loop::sin_idx#3 (byte) loop::sin_idx#2
Identical Phi Values (byte) plex_show_idx#35 (byte) plex_show_idx#49
Identical Phi Values (byte) plex_sprite_idx#32 (byte) plex_sprite_idx#48
Identical Phi Values (byte) plex_sprite_msb#30 (byte) plex_sprite_msb#48
Identical Phi Values (byte) plex_free_next#29 (byte) plex_free_next#46
Identical Phi Values (byte) plex_show_idx#23 (byte) plex_show_idx#12
Identical Phi Values (byte) plex_sprite_idx#21 (byte) plex_sprite_idx#12
Identical Phi Values (byte) plex_sprite_msb#10 (byte) plex_sprite_msb#13
Identical Phi Values (byte) plex_free_next#20 (byte) plex_free_next#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#14 (byte*) PLEX_SCREEN_PTR#10
Identical Phi Values (byte) plex_show_idx#11 (byte) plex_show_idx#17
Identical Phi Values (byte) plex_sprite_idx#11 (byte) plex_sprite_idx#17
Identical Phi Values (byte) plex_sprite_msb#12 (byte) plex_sprite_msb#18
Identical Phi Values (byte) plex_free_next#11 (byte) plex_free_next#15
Identical Phi Values (bool) framedone#13 (bool) framedone#0
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte) plexSort::m#3 (byte) plexSort::m#2
Identical Phi Values (byte) plex_free_next#14 (byte) plex_free_next#2
Identical Phi Values (byte) plex_sprite_idx#16 (byte) plex_sprite_idx#3
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) plexInit::$2 [42] if((byte) plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1
Simple Condition (bool~) plexSort::$4 [54] if((byte) plexSort::nxt_y#0>=*((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2
Simple Condition (bool~) plexSort::$9 [58] if((byte) plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1
Simple Condition (bool~) plexSort::plexFreePrepare1_$0#0 [81] if((byte) plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1
Simple Condition (bool~) plexShowSprite::$4 [111] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
Simple Condition (bool~) plexShowSprite::$8 [125] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return
Simple Condition (bool~) init::$7 [183] if((byte) init::sx#1!=rangelast(0,init::$4)) goto init::@1
Simple Condition (bool~) init::$8 [191] if((byte) init::ss#1!=rangelast(0,7)) goto init::@3
Simple Condition (bool~) plex_irq::$0 [230] if((byte) plex_show_idx#16<(byte) PLEX_COUNT#0) goto plex_irq::@1
Simple Condition (bool~) loop::$2 [261] if((byte) loop::sy#1!=rangelast(0,loop::$1)) goto loop::@10
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [67] (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
Successful SSA optimization Pass2ConditionalAndOrRewriting
Rewriting && if()-condition to two if()s [225] (bool~) plex_irq::$6 ← (bool~) plex_irq::$3 && (bool~) plex_irq::$5
Successful SSA optimization Pass2ConditionalAndOrRewriting
Rewriting ! if()-condition to reversed if() [249] (bool~) loop::$0 ← ! (bool) framedone#12
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant right-side identified [24] (number~) $0 ← (number) $400 + (number) $3f8
Constant right-side identified [135] (byte[8]) PLEX_FREE_YPOS#0 ← { fill( 8, 0) }
Constant right-side identified [197] (void()*~) init::$3 ← & interrupt(KERNEL_MIN)(void()) plex_irq()
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) SPRITES_XPOS#0 = (byte*) 53248
Constant (const byte*) SPRITES_YPOS#0 = (byte*) 53249
Constant (const byte*) SPRITES_XMSB#0 = (byte*) 53264
Constant (const byte*) RASTER#0 = (byte*) 53266
Constant (const byte*) SPRITES_ENABLE#0 = (byte*) 53269
Constant (const byte*) BORDERCOL#0 = (byte*) 53280
Constant (const byte*) SPRITES_COLS#0 = (byte*) 53287
Constant (const byte*) VIC_CONTROL#0 = (byte*) 53265
Constant (const byte*) D011#0 = (byte*) 53265
Constant (const byte) VIC_DEN#0 = $10
Constant (const byte) VIC_RSEL#0 = 8
Constant (const byte*) IRQ_STATUS#0 = (byte*) 53273
Constant (const byte*) IRQ_ENABLE#0 = (byte*) 53274
Constant (const byte) IRQ_RASTER#0 = 1
Constant (const byte*) CIA1_INTERRUPT#0 = (byte*) 56333
Constant (const byte) CIA_INTERRUPT_CLEAR#0 = $7f
Constant (const void()**) KERNEL_IRQ#0 = (void()**) 788
Constant (const byte) WHITE#0 = 1
Constant (const byte) RED#0 = 2
Constant (const byte) GREEN#0 = 5
Constant (const byte) PLEX_COUNT#0 = $20
Constant (const number) $0 = $400+$3f8
Constant (const byte) plexInit::i#0 = 0
Constant (const byte) plexSort::m#0 = 0
Constant (const byte) plexSort::plexFreePrepare1_s#0 = 0
Constant (const byte[8]) PLEX_FREE_YPOS#0 = { fill( 8, 0) }
Constant (const byte*) SCREEN#0 = (byte*) 1024
Constant (const byte*) SPRITE#0 = (byte*) 8192
Constant (const byte*) YSIN#0 = (byte*) 8448
Constant (const word) init::xp#0 = $20
Constant (const byte) init::sx#0 = 0
Constant (const byte) init::ss#0 = 0
Constant (const void()*) init::$3 = &plex_irq
Constant (const byte) plex_irq::rasterY#0 = 0
Constant (const byte) loop::sin_idx#0 = 0
Constant (const byte) loop::sy#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) plexInit::screen#0 = SCREEN#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified { fill( PLEX_COUNT#0, 0) } in [21] (word[PLEX_COUNT#0]) PLEX_XPOS#0 ← { fill( PLEX_COUNT#0, 0) }
Constant value identified { fill( PLEX_COUNT#0, 0) } in [22] (byte[PLEX_COUNT#0]) PLEX_YPOS#0 ← { fill( PLEX_COUNT#0, 0) }
Constant value identified { fill( PLEX_COUNT#0, 0) } in [23] (byte[PLEX_COUNT#0]) PLEX_PTR#0 ← { fill( PLEX_COUNT#0, 0) }
Constant value identified (byte*)$0 in [25] (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(const number) $0
Constant value identified { fill( PLEX_COUNT#0, 0) } in [26] (byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 ← { fill( PLEX_COUNT#0, 0) }
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [247] if(true) goto loop::@4
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [79] plexSort::plexFreePrepare1_s#1 ← ++ plexSort::plexFreePrepare1_s#2 to ++
Resolved ranged comparison value [81] if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1 to (number) 8
Resolved ranged next value [189] init::ss#1 ← ++ init::ss#2 to ++
Resolved ranged comparison value [191] if(init::ss#1!=rangelast(0,7)) goto init::@3 to (number) 8
Eliminating unused variable (byte*) PLEX_SCREEN_PTR#1 and assignment [8] (byte*) PLEX_SCREEN_PTR#1 ← (const byte*) plexInit::screen#0 + (word) $3f8
Eliminating unused variable - keeping the phi block (bool) framedone#10
Eliminating unused variable - keeping the phi block (byte) plex_show_idx#10
Eliminating unused variable - keeping the phi block (byte) plex_sprite_idx#10
Eliminating unused variable - keeping the phi block (byte) plex_sprite_msb#11
Eliminating unused variable - keeping the phi block (byte) plex_free_next#10
Eliminating unused constant (const byte) plex_irq::rasterY#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte*) plexInit::screen#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte*) SCREEN#0
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block loop::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 8 in if((byte) plexSort::plexFreePrepare1_s#1!=(number) 8) goto plexSort::plexFreePrepare1_@1
Adding number conversion cast (unumber) 8 in if((byte) init::ss#1!=(number) 8) goto init::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Alias (byte~) plexShowSprite::$11 = (byte~) plexShowSprite::$10 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Simple Condition (bool~) plexSort::$6 [28] if((byte) plexSort::s#1!=(byte) $ff) goto plexSort::@8
Simple Condition (bool~) plex_irq::$3 [109] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@9
Simple Condition (bool~) plexSort::$7 [134] if((byte) plexSort::nxt_y#0<*((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3
Simple Condition (bool~) plex_irq::$5 [135] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [28] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
Negating conditional jump and destination [109] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT#0) goto plex_irq::@4
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [8] (byte~) plexInit::$1 ← (const byte) PLEX_COUNT#0 - (byte) 1
Constant right-side identified [14] (byte~) plexSort::$1 ← (const byte) PLEX_COUNT#0 - (byte) 2
Constant right-side identified [75] (byte~) init::$0 ← (const byte) VIC_DEN#0 | (const byte) VIC_RSEL#0
Constant right-side identified [79] (byte~) init::$4 ← (const byte) PLEX_COUNT#0 - (byte) 1
Constant right-side identified [81] (byte*~) init::$5 ← (const byte*) SPRITE#0 / (byte) $40
Constant right-side identified [120] (byte~) loop::$1 ← (const byte) PLEX_COUNT#0 - (byte) 1
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word[PLEX_COUNT#0]) PLEX_XPOS#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_YPOS#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_PTR#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte*) PLEX_SCREEN_PTR#0 = (byte*)$0
Constant (const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte) plexInit::$1 = PLEX_COUNT#0-1
Constant (const byte) plexSort::$1 = PLEX_COUNT#0-2
Constant (const byte) init::$0 = VIC_DEN#0|VIC_RSEL#0
Constant (const byte) init::$4 = PLEX_COUNT#0-1
Constant (const byte*) init::$5 = SPRITE#0/$40
Constant (const byte) loop::$1 = PLEX_COUNT#0-1
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)init::$5 in [82] (byte~) init::$6 ← (byte)(const byte*) init::$5
Successful SSA optimization Pass2ConstantValues
Resolved ranged next value [11] plexInit::i#1 ← ++ plexInit::i#2 to ++
Resolved ranged comparison value [12] if(plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1 to (const byte) plexInit::$1+(number) 1
Resolved ranged next value [20] plexSort::m#1 ← ++ plexSort::m#2 to ++
Resolved ranged comparison value [21] if(plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1 to (const byte) plexSort::$1+(number) 1
Resolved ranged next value [87] init::sx#1 ← ++ init::sx#2 to ++
Resolved ranged comparison value [88] if(init::sx#1!=rangelast(0,init::$4)) goto init::@1 to (const byte) init::$4+(number) 1
Resolved ranged next value [124] loop::sy#1 ← ++ loop::sy#2 to ++
Resolved ranged comparison value [125] if(loop::sy#1!=rangelast(0,loop::$1)) goto loop::@10 to (const byte) loop::$1+(number) 1
Adding number conversion cast (unumber) plexInit::$1+1 in if((byte) plexInit::i#1!=(const byte) plexInit::$1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) 1 in if((byte) plexInit::i#1!=(unumber)(const byte) plexInit::$1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) plexSort::$1+1 in if((byte) plexSort::m#1!=(const byte) plexSort::$1+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) 1 in if((byte) plexSort::m#1!=(unumber)(const byte) plexSort::$1+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) init::$4+1 in if((byte) init::sx#1!=(const byte) init::$4+(number) 1) goto init::@1
Adding number conversion cast (unumber) 1 in if((byte) init::sx#1!=(unumber)(const byte) init::$4+(number) 1) goto init::@1
Adding number conversion cast (unumber) loop::$1+1 in if((byte) loop::sy#1!=(const byte) loop::$1+(number) 1) goto loop::@10
Adding number conversion cast (unumber) 1 in if((byte) loop::sy#1!=(unumber)(const byte) loop::$1+(number) 1) goto loop::@10
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const byte) plexInit::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) plexSort::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) init::$4+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) loop::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Constant right-side identified [65] (byte~) init::$1 ← (const byte) init::$0 | (byte) 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) init::$1 = init::$0|3
Constant (const byte) init::$6 = (byte)init::$5
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Rewriting multiplication to use shift [31] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 * (byte) 2
Rewriting multiplication to use shift [41] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [69] (byte~) init::$9 ← (byte) init::sx#2 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) plexInit::i#0
Inlining constant with var siblings (const byte) plexSort::m#0
Inlining constant with var siblings (const byte) plexSort::plexFreePrepare1_s#0
Inlining constant with var siblings (const word) init::xp#0
Inlining constant with var siblings (const byte) init::sx#0
Inlining constant with var siblings (const byte) init::ss#0
Inlining constant with var siblings (const byte) loop::sin_idx#0
Inlining constant with var siblings (const byte) loop::sy#0
Constant inlined init::xp#0 = (byte) $20
Constant inlined plexInit::$1 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined plexSort::$1 = (const byte) PLEX_COUNT#0-(byte) 2
Constant inlined plexSort::plexFreePrepare1_s#0 = (byte) 0
Constant inlined init::ss#0 = (byte) 0
Constant inlined plexInit::i#0 = (byte) 0
Constant inlined plexSort::m#0 = (byte) 0
Constant inlined init::$3 = &interrupt(KERNEL_MIN)(void()) plex_irq()
Constant inlined $0 = (number) $400+(number) $3f8
Constant inlined init::$1 = (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3
Constant inlined loop::sin_idx#0 = (byte) 0
Constant inlined init::$0 = (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0
Constant inlined init::$6 = (byte)(const byte*) SPRITE#0/(byte) $40
Constant inlined init::$5 = (const byte*) SPRITE#0/(byte) $40
Constant inlined init::$4 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined loop::$1 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined loop::sy#0 = (byte) 0
Constant inlined init::sx#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(PLEX_SORTED_IDX#0+1 + plexSort::$2)
Consolidated array index constant in assignment *(PLEX_SORTED_IDX#0+1 + plexSort::$5)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Alias (byte) plexSort::m#2 = (byte~) plexSort::$2 
Alias (byte) plexSort::s#3 = (byte~) plexSort::$5 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Added new block during phi lifting plexInit::@4(between plexInit::@1 and plexInit::@1)
Added new block during phi lifting plexSort::@9(between plexSort::@2 and plexSort::@1)
Added new block during phi lifting plexSort::@10(between plexSort::@8 and plexSort::@3)
Added new block during phi lifting plexSort::@11(between plexSort::plexFreePrepare1_@1 and plexSort::plexFreePrepare1_@1)
Added new block during phi lifting plexShowSprite::@8(between plexShowSprite::@2 and plexShowSprite::@return)
Added new block during phi lifting init::@6(between init::@1 and init::@1)
Added new block during phi lifting init::@7(between init::@3 and init::@3)
Added new block during phi lifting plex_irq::@10(between plex_irq::@9 and plex_irq::@3)
Added new block during phi lifting loop::@16(between loop::@10 and loop::@10)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @16
Adding NOP phi() at start of @17
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of init::@5
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1
Adding NOP phi() at start of plexInit::@3
Adding NOP phi() at start of plex_irq::@8
Adding NOP phi() at start of plex_irq::plexFreeNextYpos1_@return
CALL GRAPH
Calls in [] to main:9 
Calls in [main] to init:13 loop:15 
Calls in [loop] to plexSort:30 
Calls in [init] to plexInit:68 
Calls in [plex_irq] to plexShowSprite:107 

Created 16 initial phi equivalence classes
Coalesced [18] framedone#28 ← framedone#17
Not coalescing [22] loop::y_idx#4 ← loop::sin_idx#6
Coalesced [35] framedone#29 ← framedone#5
Coalesced [36] loop::sin_idx#8 ← loop::sin_idx#1
Coalesced [37] loop::y_idx#3 ← loop::y_idx#1
Coalesced [38] loop::sy#3 ← loop::sy#1
Not coalescing [44] plexSort::s#6 ← plexSort::m#2
Coalesced [64] plexSort::plexFreePrepare1_s#3 ← plexSort::plexFreePrepare1_s#1
Coalesced [65] plexSort::m#7 ← plexSort::m#1
Coalesced [66] plexSort::s#5 ← plexSort::s#1
Coalesced [89] init::ss#3 ← init::ss#1
Coalesced [90] init::sx#3 ← init::sx#1
Coalesced [91] init::xp#3 ← init::xp#1
Coalesced [100] plexInit::i#3 ← plexInit::i#1
Coalesced [102] plex_sprite_idx#52 ← plex_sprite_idx#0
Coalesced [103] plex_show_idx#52 ← plex_show_idx#0
Coalesced [104] plex_free_next#48 ← plex_free_next#31
Coalesced [105] plex_sprite_msb#54 ← plex_sprite_msb#0
Coalesced [120] plex_sprite_idx#53 ← plex_sprite_idx#3
Coalesced [121] plex_show_idx#53 ← plex_show_idx#16
Coalesced [122] plex_free_next#49 ← plex_free_next#2
Coalesced [123] plex_sprite_msb#55 ← plex_sprite_msb#17
Coalesced [131] plex_free_next#2 ← plexShowSprite::plexFreeAdd1_$2#0
Coalesced [143] plex_sprite_idx#3 ← plexShowSprite::$6
Coalesced [148] plex_sprite_msb#53 ← plex_sprite_msb#4
Coalesced [151] plex_sprite_msb#52 ← plex_sprite_msb#3
Coalesced down to 15 phi equivalence classes
Culled Empty Block (label) @17
Culled Empty Block (label) main::@2
Culled Empty Block (label) loop::@16
Culled Empty Block (label) plexSort::@11
Culled Empty Block (label) plexSort::@9
Culled Empty Block (label) plexSort::@10
Culled Empty Block (label) init::@5
Culled Empty Block (label) init::@7
Culled Empty Block (label) init::@6
Culled Empty Block (label) plexInit::@3
Culled Empty Block (label) plexInit::@4
Culled Empty Block (label) plex_irq::@8
Culled Empty Block (label) plex_irq::plexFreeNextYpos1_@return
Culled Empty Block (label) plex_irq::@10
Culled Empty Block (label) plexShowSprite::@8
Renumbering block @4 to @1
Renumbering block @9 to @2
Renumbering block @12 to @3
Renumbering block @14 to @4
Renumbering block @16 to @5
Renumbering block plexSort::@8 to plexSort::@7
Renumbering block plexShowSprite::@4 to plexShowSprite::@3
Renumbering block plexShowSprite::@6 to plexShowSprite::@4
Renumbering block plexShowSprite::@7 to plexShowSprite::@5
Renumbering block plex_irq::@7 to plex_irq::@6
Renumbering block plex_irq::@9 to plex_irq::@7
Renumbering block loop::@4 to loop::@2
Renumbering block loop::@6 to loop::@3
Renumbering block loop::@10 to loop::@4
Renumbering block loop::@11 to loop::@5
Renumbering block loop::@15 to loop::@6
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @5
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of loop
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] (byte) plex_show_idx#0 ← (byte) 0
  [2] (byte) plex_sprite_idx#0 ← (byte) 0
  [3] (byte) plex_sprite_msb#0 ← (byte) 1
  to:@2
@2: scope:[]  from @1
  [4] (byte) plex_free_next#31 ← (byte) 0
  to:@3
@3: scope:[]  from @2
  kickasm(location (const byte*) YSIN#0) {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
  kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  to:@4
@4: scope:[]  from @3
  [7] (bool) framedone#17 ← true
  to:@5
@5: scope:[]  from @4
  [8] phi()
  [9] call main 
  to:@end
@end: scope:[]  from @5
  [10] phi()
main: scope:[main]  from @5
  asm { sei  }
  [12] call init 
  to:main::@1
main::@1: scope:[main]  from main
  [13] phi()
  [14] call loop 
  to:main::@return
main::@return: scope:[main]  from main::@1
  [15] return 
  to:@return
loop: scope:[loop]  from main::@1
  [16] phi()
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@6
  [17] (byte) loop::sin_idx#6 ← phi( loop/(byte) 0 loop::@6/(byte) loop::sin_idx#1 )
  [17] (bool) framedone#12 ← phi( loop/(bool) framedone#17 loop::@6/(bool) framedone#5 )
  to:loop::@2
loop::@2: scope:[loop]  from loop::@1 loop::@2
  [18] if((bool) framedone#12) goto loop::@3
  to:loop::@2
loop::@3: scope:[loop]  from loop::@2
  [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0
  [20] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6
  to:loop::@4
loop::@4: scope:[loop]  from loop::@3 loop::@4
  [21] (byte) loop::sy#2 ← phi( loop::@4/(byte) loop::sy#1 loop::@3/(byte) 0 )
  [21] (byte) loop::y_idx#2 ← phi( loop::@4/(byte) loop::y_idx#1 loop::@3/(byte~) loop::y_idx#4 )
  [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2)
  [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8
  [24] (byte) loop::sy#1 ← ++ (byte) loop::sy#2
  [25] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  [26] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1
  [27] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  [28] call plexSort 
  to:loop::@6
loop::@6: scope:[loop]  from loop::@5
  [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0
  [30] (bool) framedone#5 ← false
  [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte) $7f
  [32] *((const byte*) RASTER#0) ← (byte) 0
  to:loop::@1
plexSort: scope:[plexSort]  from loop::@5
  [33] phi()
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  [34] (byte) plexSort::m#2 ← phi( plexSort/(byte) 0 plexSort::@2/(byte) plexSort::m#1 )
  [35] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2)
  [36] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0)
  [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2
  to:plexSort::@5
plexSort::@5: scope:[plexSort]  from plexSort::@1
  [38] (byte~) plexSort::s#6 ← (byte) plexSort::m#2
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@5 plexSort::@7
  [39] (byte) plexSort::s#3 ← phi( plexSort::@7/(byte) plexSort::s#1 plexSort::@5/(byte~) plexSort::s#6 )
  [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3)
  [41] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  [42] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
  to:plexSort::@7
plexSort::@7: scope:[plexSort]  from plexSort::@3
  [43] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3 plexSort::@7
  [44] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1
  [45] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0
  to:plexSort::@2
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  [46] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2
  [47] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1
  to:plexSort::@6
plexSort::@6: scope:[plexSort]  from plexSort::@2
  [48] (byte) plex_show_idx#1 ← (byte) 0
  [49] (byte) plex_sprite_idx#1 ← (byte) 0
  [50] (byte) plex_sprite_msb#1 ← (byte) 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  [51] phi()
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  [52] (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) 0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  [53] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0
  [54] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2
  [55] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  [56] (byte) plex_free_next#0 ← (byte) 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  [57] return 
  to:@return
init: scope:[init]  from main
  [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3
  [59] call plexInit 
  to:init::@1
init::@1: scope:[init]  from init init::@1
  [60] (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init/(byte) $20 )
  [60] (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init/(byte) 0 )
  [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40
  [62] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1
  [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$9) ← (word) init::xp#2
  [64] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9
  [65] (byte) init::sx#1 ← ++ (byte) init::sx#2
  [66] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  [67] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  [68] (byte) init::ss#2 ← phi( init::@2/(byte) 0 init::@3/(byte) init::ss#1 )
  [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0
  [70] (byte) init::ss#1 ← ++ (byte) init::ss#2
  [71] if((byte) init::ss#1!=(byte) 8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  asm { sei  }
  [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0
  [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0
  [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0
  [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq()
  asm { cli  }
  to:init::@return
init::@return: scope:[init]  from init::@4
  [78] return 
  to:@return
plexInit: scope:[plexInit]  from init
  [79] phi()
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  [80] phi()
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::plexSetScreen1
  [81] (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::plexSetScreen1/(byte) 0 )
  [82] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  [83] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2
  [84] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  [85] return 
  to:@return
plex_irq: scope:[plex_irq]  from
  [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0
  to:plex_irq::@3
plex_irq::@3: scope:[plex_irq]  from plex_irq plex_irq::@7
  [87] (byte) plex_sprite_msb#28 ← phi( plex_irq/(byte) plex_sprite_msb#0 plex_irq::@7/(byte) plex_sprite_msb#17 )
  [87] (byte) plex_free_next#27 ← phi( plex_irq/(byte) plex_free_next#31 plex_irq::@7/(byte~) plexShowSprite::plexFreeAdd1_$2#0 )
  [87] (byte) plex_show_idx#27 ← phi( plex_irq/(byte) plex_show_idx#0 plex_irq::@7/(byte) plex_show_idx#16 )
  [87] (byte) plex_sprite_idx#25 ← phi( plex_irq/(byte) plex_sprite_idx#0 plex_irq::@7/(byte~) plexShowSprite::$6 )
  [88] call plexShowSprite 
  to:plex_irq::plexFreeNextYpos1
plex_irq::plexFreeNextYpos1: scope:[plex_irq]  from plex_irq::@3
  [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte~) plexShowSprite::plexFreeAdd1_$2#0)
  to:plex_irq::@6
plex_irq::@6: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1
  [90] (byte~) plex_irq::$4 ← *((const byte*) RASTER#0) + (byte) 2
  [91] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT#0) goto plex_irq::@4
  to:plex_irq::@7
plex_irq::@7: scope:[plex_irq]  from plex_irq::@6
  [92] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3
  to:plex_irq::@4
plex_irq::@4: scope:[plex_irq]  from plex_irq::@6 plex_irq::@7
  [93] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0
  [94] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1
  to:plex_irq::@5
plex_irq::@5: scope:[plex_irq]  from plex_irq::@4
  [95] (bool) framedone#3 ← true
  to:plex_irq::@2
plex_irq::@2: scope:[plex_irq]  from plex_irq::@1 plex_irq::@5
  [96] *((const byte*) BORDERCOL#0) ← (byte) 0
  to:plex_irq::@return
plex_irq::@return: scope:[plex_irq]  from plex_irq::@2
  [97] return 
  to:@return
plex_irq::@1: scope:[plex_irq]  from plex_irq::@4
  [98] *((const byte*) RASTER#0) ← (byte) plex_irq::plexFreeNextYpos1_return#0
  to:plex_irq::@2
plexShowSprite: scope:[plexShowSprite]  from plex_irq::@3
  [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1
  [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27))
  [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  [102] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15
  [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0
  [104] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#27 + (byte) 1
  [105] (byte~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7
  to:plexShowSprite::@5
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27))
  [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)
  [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1
  [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11)
  [110] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2
  [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11)
  [112] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@5
  [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28
  [114] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  [115] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#25 + (byte) 1
  [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7
  [117] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27
  [118] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#28 << (byte) 1
  [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@2
  [120] (byte) plex_sprite_msb#4 ← (byte) 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@4
  [121] (byte) plex_sprite_msb#17 ← phi( plexShowSprite::@2/(byte) plex_sprite_msb#3 plexShowSprite::@4/(byte) plex_sprite_msb#4 )
  [122] return 
  to:@return
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@5
  [123] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#28
  to:plexShowSprite::@2


VARIABLE REGISTER WEIGHTS
(byte*) BORDERCOL
(byte*) CIA1_INTERRUPT
(byte) CIA_INTERRUPT_CLEAR
(byte*) D011
(byte) GREEN
(byte*) IRQ_ENABLE
(byte) IRQ_RASTER
(byte*) IRQ_STATUS
(void()**) KERNEL_IRQ
(byte) PLEX_COUNT
(byte[8]) PLEX_FREE_YPOS
(byte[PLEX_COUNT#0]) PLEX_PTR
(byte*) PLEX_SCREEN_PTR
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(word[PLEX_COUNT#0]) PLEX_XPOS
(byte[PLEX_COUNT#0]) PLEX_YPOS
(byte*) RASTER
(byte) RED
(byte*) SCREEN
(byte*) SPRITE
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_XMSB
(byte*) SPRITES_XPOS
(byte*) SPRITES_YPOS
(byte*) VIC_CONTROL
(byte) VIC_DEN
(byte) VIC_RSEL
(byte) WHITE
(byte*) YSIN
(bool) framedone
(bool) framedone#12 57.0
(bool) framedone#17 0.6666666666666666
(bool) framedone#3 20.0
(bool) framedone#5 7.333333333333333
(void()) init()
(byte~) init::$9 22.0
(byte) init::ss
(byte) init::ss#1 16.5
(byte) init::ss#2 16.5
(byte) init::sx
(byte) init::sx#1 16.5
(byte) init::sx#2 8.8
(word) init::xp
(word) init::xp#1 7.333333333333333
(word) init::xp#2 8.25
(void()) loop()
(byte) loop::sin_idx
(byte) loop::sin_idx#1 3.142857142857143
(byte) loop::sin_idx#6 3.666666666666667
(byte) loop::sy
(byte) loop::sy#1 151.5
(byte) loop::sy#2 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 67.33333333333333
(byte) loop::y_idx#2 157.0
(byte~) loop::y_idx#4 22.0
(void()) main()
(void()) plexInit((byte*) plexInit::screen)
(byte) plexInit::i
(byte) plexInit::i#1 16.5
(byte) plexInit::i#2 22.0
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 2.0
(byte~) plexShowSprite::$2 4.0
(byte~) plexShowSprite::$3 4.0
(byte~) plexShowSprite::$5 4.0
(byte~) plexShowSprite::$6 1.0833333333333333
(byte~) plexShowSprite::$9 4.0
(number~) plexShowSprite::plexFreeAdd1_$0
(byte~) plexShowSprite::plexFreeAdd1_$0#0 4.0
(number~) plexShowSprite::plexFreeAdd1_$1
(byte~) plexShowSprite::plexFreeAdd1_$1#0 4.0
(number~) plexShowSprite::plexFreeAdd1_$2
(byte~) plexShowSprite::plexFreeAdd1_$2#0 1.0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 0.5454545454545454
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 4.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(byte) plexSort::m
(byte) plexSort::m#1 151.5
(byte) plexSort::m#2 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 150.375
(bool~) plexSort::plexFreePrepare1_$0
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 151.5
(byte) plexSort::plexFreePrepare1_s#2 151.5
(byte) plexSort::s
(byte) plexSort::s#1 1368.3333333333335
(byte) plexSort::s#2 202.0
(byte) plexSort::s#3 2052.5
(byte~) plexSort::s#6 202.0
(byte) plex_free_next
(byte) plex_free_next#0 20.0
(byte) plex_free_next#27 2.8333333333333335
(byte) plex_free_next#31 4.0
interrupt(KERNEL_MIN)(void()) plex_irq()
(byte~) plex_irq::$4 11.0
(byte) plex_irq::plexFreeNextYpos1_return
(byte) plex_irq::plexFreeNextYpos1_return#0 4.0
(byte) plex_irq::rasterY
(byte) plex_show_idx
(byte) plex_show_idx#0 4.0
(byte) plex_show_idx#1 20.0
(byte) plex_show_idx#16 2.1666666666666665
(byte) plex_show_idx#27 1.05
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0 4.0
(byte) plex_sprite_idx#1 20.0
(byte) plex_sprite_idx#25 1.0555555555555558
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0 4.0
(byte) plex_sprite_msb#1 20.0
(byte) plex_sprite_msb#17 2.142857142857143
(byte) plex_sprite_msb#28 0.9047619047619048
(byte) plex_sprite_msb#3 3.0
(byte) plex_sprite_msb#4 4.0

Initial phi equivalence classes
[ framedone#12 framedone#17 framedone#5 ]
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 ]
[ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ]
[ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
[ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ]
Coalescing volatile variable equivalence classes [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ] and [ plex_show_idx#1 ]
Coalescing volatile variable equivalence classes [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 ] and [ plex_sprite_idx#1 ]
Coalescing volatile variable equivalence classes [ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ] and [ plex_sprite_msb#1 ]
Coalescing volatile variable equivalence classes [ plex_free_next#0 ] and [ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
Coalescing volatile variable equivalence classes [ framedone#3 ] and [ framedone#12 framedone#17 framedone#5 ]
Added variable plexSort::nxt_idx#0 to zero page equivalence class [ plexSort::nxt_idx#0 ]
Added variable plexSort::nxt_y#0 to zero page equivalence class [ plexSort::nxt_y#0 ]
Added variable plexSort::s#2 to zero page equivalence class [ plexSort::s#2 ]
Added variable init::$9 to zero page equivalence class [ init::$9 ]
Added variable plex_irq::plexFreeNextYpos1_return#0 to zero page equivalence class [ plex_irq::plexFreeNextYpos1_return#0 ]
Added variable plex_irq::$4 to zero page equivalence class [ plex_irq::$4 ]
Added variable plexShowSprite::plex_sprite_idx2#0 to zero page equivalence class [ plexShowSprite::plex_sprite_idx2#0 ]
Added variable plexShowSprite::plexFreeAdd1_ypos#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Added variable plexShowSprite::plexFreeAdd1_$0#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$0#0 ]
Added variable plexShowSprite::plexFreeAdd1_$1#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$1#0 ]
Added variable plexShowSprite::xpos_idx#0 to zero page equivalence class [ plexShowSprite::xpos_idx#0 ]
Added variable plexShowSprite::$11 to zero page equivalence class [ plexShowSprite::$11 ]
Added variable plexShowSprite::$2 to zero page equivalence class [ plexShowSprite::$2 ]
Added variable plexShowSprite::$3 to zero page equivalence class [ plexShowSprite::$3 ]
Added variable plexShowSprite::$9 to zero page equivalence class [ plexShowSprite::$9 ]
Added variable plexShowSprite::$5 to zero page equivalence class [ plexShowSprite::$5 ]
Complete equivalence classes
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 plex_sprite_idx#1 ]
[ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ]
[ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 plex_sprite_msb#1 ]
[ plex_free_next#0 plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
[ framedone#3 framedone#12 framedone#17 framedone#5 ]
[ plexSort::nxt_idx#0 ]
[ plexSort::nxt_y#0 ]
[ plexSort::s#2 ]
[ init::$9 ]
[ plex_irq::plexFreeNextYpos1_return#0 ]
[ plex_irq::$4 ]
[ plexShowSprite::plex_sprite_idx2#0 ]
[ plexShowSprite::plexFreeAdd1_ypos#0 ]
[ plexShowSprite::plexFreeAdd1_$0#0 ]
[ plexShowSprite::plexFreeAdd1_$1#0 ]
[ plexShowSprite::xpos_idx#0 ]
[ plexShowSprite::$11 ]
[ plexShowSprite::$2 ]
[ plexShowSprite::$3 ]
[ plexShowSprite::$9 ]
[ plexShowSprite::$5 ]
Allocated zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Allocated zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Allocated zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ]
Allocated zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ]
Allocated zp ZP_BYTE:6 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Allocated zp ZP_BYTE:7 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Allocated zp ZP_BYTE:8 [ init::sx#2 init::sx#1 ]
Allocated zp ZP_WORD:9 [ init::xp#2 init::xp#1 ]
Allocated zp ZP_BYTE:11 [ init::ss#2 init::ss#1 ]
Allocated zp ZP_BYTE:12 [ plexInit::i#2 plexInit::i#1 ]
Allocated zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 plex_sprite_idx#1 ]
Allocated zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ]
Allocated zp ZP_BYTE:15 [ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 plex_sprite_msb#1 ]
Allocated zp ZP_BYTE:16 [ plex_free_next#0 plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
Allocated zp ZP_BOOL:17 [ framedone#3 framedone#12 framedone#17 framedone#5 ]
Allocated zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ]
Allocated zp ZP_BYTE:19 [ plexSort::nxt_y#0 ]
Allocated zp ZP_BYTE:20 [ plexSort::s#2 ]
Allocated zp ZP_BYTE:21 [ init::$9 ]
Allocated zp ZP_BYTE:22 [ plex_irq::plexFreeNextYpos1_return#0 ]
Allocated zp ZP_BYTE:23 [ plex_irq::$4 ]
Allocated zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Allocated zp ZP_BYTE:26 [ plexShowSprite::plexFreeAdd1_$0#0 ]
Allocated zp ZP_BYTE:27 [ plexShowSprite::plexFreeAdd1_$1#0 ]
Allocated zp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ]
Allocated zp ZP_BYTE:29 [ plexShowSprite::$11 ]
Allocated zp ZP_BYTE:30 [ plexShowSprite::$2 ]
Allocated zp ZP_BYTE:31 [ plexShowSprite::$3 ]
Allocated zp ZP_BYTE:32 [ plexShowSprite::$9 ]
Allocated zp ZP_BYTE:33 [ plexShowSprite::$5 ]

INITIAL ASM
//SEG0 File Comments
// A simple usage of the flexible sprite multiplexer routine
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label VIC_CONTROL = $d011
  .label D011 = $d011
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Bits for the IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // CIA#1 Interrupt Status & Control Register
  .label CIA1_INTERRUPT = $dc0d
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .label SPRITE = $2000
  .label YSIN = $2100
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = $400+$3f8
  .label plex_show_idx = $e
  .label plex_sprite_idx = $d
  .label plex_sprite_msb = $f
  .label plex_free_next = $10
  .label framedone = $11
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 [1] (byte) plex_show_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index in the PLEX tables of the next sprite to show
  lda #0
  sta plex_show_idx
//SEG6 [2] (byte) plex_sprite_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index the next sprite to use for showing (sprites are used round-robin)
  lda #0
  sta plex_sprite_idx
//SEG7 [3] (byte) plex_sprite_msb#0 ← (byte) 1 -- vbuz1=vbuc1 
  // The MSB bit of the next sprite to use for showing
  lda #1
  sta plex_sprite_msb
  jmp b2
//SEG8 @2
b2:
//SEG9 [4] (byte) plex_free_next#31 ← (byte) 0 -- vbuz1=vbuc1 
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  lda #0
  sta plex_free_next
  jmp b3
//SEG10 @3
b3:
//SEG11 kickasm(location (const byte*) YSIN#0) {{ .var min = 50     .var max = 250-21     .var ampl = max-min;     .for(var i=0;i<256;i++)         .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))  }}
//SEG12 kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  jmp b4
//SEG13 @4
b4:
//SEG14 [7] (bool) framedone#17 ← true -- vboz1=vboc1 
  lda #1
  sta framedone
//SEG15 [8] phi from @4 to @5 [phi:@4->@5]
b5_from_b4:
  jmp b5
//SEG16 @5
b5:
//SEG17 [9] call main 
  jsr main
//SEG18 [10] phi from @5 to @end [phi:@5->@end]
bend_from_b5:
  jmp bend
//SEG19 @end
bend:
//SEG20 main
main: {
  //SEG21 asm { sei  }
    sei
  //SEG22 [12] call init 
    jsr init
  //SEG23 [13] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG24 main::@1
  b1:
  //SEG25 [14] call loop 
  //SEG26 [16] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from_b1:
    jsr loop
    jmp breturn
  //SEG27 main::@return
  breturn:
  //SEG28 [15] return 
    rts
}
//SEG29 loop
// The raster loop
loop: {
    .label y_idx = 3
    .label sy = 4
    .label sin_idx = 2
  //SEG30 [17] phi from loop to loop::@1 [phi:loop->loop::@1]
  b1_from_loop:
  //SEG31 [17] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta sin_idx
  //SEG32 [17] phi (bool) framedone#12 = (bool) framedone#17 [phi:loop->loop::@1#1] -- register_copy 
    jmp b1
  //SEG33 loop::@1
  b1:
    jmp b2
  //SEG34 loop::@2
  b2:
  //SEG35 [18] if((bool) framedone#12) goto loop::@3 -- vboz1_then_la1 
    lda framedone
    cmp #0
    bne b3
    jmp b2
  //SEG36 loop::@3
  b3:
  //SEG37 [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
  //SEG38 [20] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuz1=vbuz2 
    lda sin_idx
    sta y_idx
  //SEG39 [21] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  b4_from_b3:
  //SEG40 [21] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta sy
  //SEG41 [21] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp b4
  //SEG42 [21] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  b4_from_b4:
  //SEG43 [21] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
  //SEG44 [21] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp b4
  //SEG45 loop::@4
  b4:
  //SEG46 [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz2 
    ldy y_idx
    lda YSIN,y
    ldy sy
    sta PLEX_YPOS,y
  //SEG47 [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuz1=vbuz1_plus_vbuc1 
    lax y_idx
    axs #-[8]
    stx y_idx
  //SEG48 [24] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuz1=_inc_vbuz1 
    inc sy
  //SEG49 [25] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp sy
    bne b4_from_b4
    jmp b5
  //SEG50 loop::@5
  b5:
  //SEG51 [26] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc sin_idx
  //SEG52 [27] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG53 [28] call plexSort 
  //SEG54 [33] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from_b5:
    jsr plexSort
    jmp b6
  //SEG55 loop::@6
  b6:
  //SEG56 [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
  //SEG57 [30] (bool) framedone#5 ← false -- vboz1=vboc1 
    lda #0
    sta framedone
  //SEG58 [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
  //SEG59 [32] *((const byte*) RASTER#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
  //SEG60 [17] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
  b1_from_b6:
  //SEG61 [17] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
  //SEG62 [17] phi (bool) framedone#12 = (bool) framedone#5 [phi:loop::@6->loop::@1#1] -- register_copy 
    jmp b1
}
//SEG63 plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $12
    .label nxt_y = $13
    .label m = 5
    .label s = 6
    .label s_2 = $14
    .label plexFreePrepare1_s = 7
  //SEG64 [34] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  b1_from_plexSort:
  //SEG65 [34] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta m
    jmp b1
  //SEG66 [34] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  b1_from_b2:
  //SEG67 [34] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp b1
  //SEG68 plexSort::@1
  b1:
  //SEG69 [35] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy m
    lda PLEX_SORTED_IDX+1,y
    sta nxt_idx
  //SEG70 [36] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy nxt_idx
    lda PLEX_YPOS,y
    sta nxt_y
  //SEG71 [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    lda nxt_y
    ldx m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
    jmp b5
  //SEG72 plexSort::@5
  b5:
  //SEG73 [38] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuz1=vbuz2 
    lda m
    sta s
  //SEG74 [39] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
  b3_from_b5:
  b3_from_b7:
  //SEG75 [39] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
    jmp b3
  //SEG76 plexSort::@3
  b3:
  //SEG77 [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy s
    lda PLEX_SORTED_IDX,y
    sta PLEX_SORTED_IDX+1,y
  //SEG78 [41] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuz1=_dec_vbuz1 
    dec s
  //SEG79 [42] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuz1_eq_vbuc1_then_la1 
    lda #$ff
    cmp s
    beq b4
    jmp b7
  //SEG80 plexSort::@7
  b7:
  //SEG81 [43] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    lda nxt_y
    ldx s
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3_from_b7
    jmp b4
  //SEG82 plexSort::@4
  b4:
  //SEG83 [44] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuz1=_inc_vbuz2 
    ldy s
    iny
    sty s_2
  //SEG84 [45] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda nxt_idx
    ldy s_2
    sta PLEX_SORTED_IDX,y
    jmp b2
  //SEG85 plexSort::@2
  b2:
  //SEG86 [46] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG87 [47] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp m
    bne b1_from_b2
    jmp b6
  //SEG88 plexSort::@6
  b6:
  //SEG89 [48] (byte) plex_show_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta plex_show_idx
  //SEG90 [49] (byte) plex_sprite_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta plex_sprite_idx
  //SEG91 [50] (byte) plex_sprite_msb#1 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG92 [51] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
  plexFreePrepare1_from_b6:
    jmp plexFreePrepare1
  //SEG93 plexSort::plexFreePrepare1
  plexFreePrepare1:
  //SEG94 [52] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1:
  //SEG95 [52] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuz1=vbuc1 
    lda #0
    sta plexFreePrepare1_s
    jmp plexFreePrepare1_b1
  //SEG96 [52] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1_b1:
  //SEG97 [52] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1_b1
  //SEG98 plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
  //SEG99 [53] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #0
    ldy plexFreePrepare1_s
    sta PLEX_FREE_YPOS,y
  //SEG100 [54] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuz1=_inc_vbuz1 
    inc plexFreePrepare1_s
  //SEG101 [55] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp plexFreePrepare1_s
    bne plexFreePrepare1_b1_from_plexFreePrepare1_b1
    jmp plexFreePrepare1_b2
  //SEG102 plexSort::plexFreePrepare1_@2
  plexFreePrepare1_b2:
  //SEG103 [56] (byte) plex_free_next#0 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta plex_free_next
    jmp breturn
  //SEG104 plexSort::@return
  breturn:
  //SEG105 [57] return 
    rts
}
//SEG106 init
// Initialize the program
init: {
    .label _9 = $15
    .label xp = 9
    .label sx = 8
    .label ss = $b
  //SEG107 [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
  //SEG108 [59] call plexInit 
  //SEG109 [79] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
  //SEG110 [60] phi from init to init::@1 [phi:init->init::@1]
  b1_from_init:
  //SEG111 [60] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #$20
    sta xp
    lda #0
    sta xp+1
  //SEG112 [60] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta sx
    jmp b1
  //SEG113 [60] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
  //SEG114 [60] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
  //SEG115 [60] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp b1
  //SEG116 init::@1
  b1:
  //SEG117 [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #SPRITE/$40
    ldy sx
    sta PLEX_PTR,y
  //SEG118 [62] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda sx
    asl
    sta _9
  //SEG119 [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$9) ← (word) init::xp#2 -- pwuc1_derefidx_vbuz1=vwuz2 
    ldy _9
    lda xp
    sta PLEX_XPOS,y
    lda xp+1
    sta PLEX_XPOS+1,y
  //SEG120 [64] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc xp
    sta xp
    bcc !+
    inc xp+1
  !:
  //SEG121 [65] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuz1=_inc_vbuz1 
    inc sx
  //SEG122 [66] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp sx
    bne b1_from_b1
    jmp b2
  //SEG123 init::@2
  b2:
  //SEG124 [67] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
  //SEG125 [68] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
  //SEG126 [68] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta ss
    jmp b3
  //SEG127 [68] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  b3_from_b3:
  //SEG128 [68] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp b3
  //SEG129 init::@3
  b3:
  //SEG130 [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy ss
    sta SPRITES_COLS,y
  //SEG131 [70] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuz1=_inc_vbuz1 
    inc ss
  //SEG132 [71] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp ss
    bne b3_from_b3
    jmp b4
  //SEG133 init::@4
  b4:
  //SEG134 asm { sei  }
    // enable the interrupt
    sei
  //SEG135 [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
  //SEG136 [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
  //SEG137 [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG138 [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() -- _deref_pptc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
  //SEG139 asm { cli  }
    cli
    jmp breturn
  //SEG140 init::@return
  breturn:
  //SEG141 [78] return 
    rts
}
//SEG142 plexInit
// Initialize the multiplexer data structures
plexInit: {
    .label i = $c
  //SEG143 [80] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
  //SEG144 plexInit::plexSetScreen1
  plexSetScreen1:
  //SEG145 [81] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  b1_from_plexSetScreen1:
  //SEG146 [81] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b1
  //SEG147 [81] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  b1_from_b1:
  //SEG148 [81] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp b1
  //SEG149 plexInit::@1
  b1:
  //SEG150 [82] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuz1=vbuz1 
    ldy i
    tya
    sta PLEX_SORTED_IDX,y
  //SEG151 [83] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG152 [84] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp i
    bne b1_from_b1
    jmp breturn
  //SEG153 plexInit::@return
  breturn:
  //SEG154 [85] return 
    rts
}
//SEG155 plex_irq
plex_irq: {
    .label _4 = $17
    .label plexFreeNextYpos1_return = $16
  //SEG156 entry interrupt(KERNEL_MIN)
  //SEG157 [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
  //SEG158 [87] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
  b3_from_plex_irq:
  b3_from_b7:
  //SEG159 [87] phi (byte) plex_sprite_msb#28 = (byte) plex_sprite_msb#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#0] -- register_copy 
  //SEG160 [87] phi (byte) plex_free_next#27 = (byte) plex_free_next#31 [phi:plex_irq/plex_irq::@7->plex_irq::@3#1] -- register_copy 
  //SEG161 [87] phi (byte) plex_show_idx#27 = (byte) plex_show_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#2] -- register_copy 
  //SEG162 [87] phi (byte) plex_sprite_idx#25 = (byte) plex_sprite_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#3] -- register_copy 
    jmp b3
  //SEG163 plex_irq::@3
  b3:
  //SEG164 [88] call plexShowSprite 
    jsr plexShowSprite
    jmp plexFreeNextYpos1
  //SEG165 plex_irq::plexFreeNextYpos1
  plexFreeNextYpos1:
  //SEG166 [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte~) plexShowSprite::plexFreeAdd1_$2#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy plexShowSprite.plexFreeAdd1__2
    lda PLEX_FREE_YPOS,y
    sta plexFreeNextYpos1_return
    jmp b6
  //SEG167 plex_irq::@6
  b6:
  //SEG168 [90] (byte~) plex_irq::$4 ← *((const byte*) RASTER#0) + (byte) 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta _4
  //SEG169 [91] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT#0) goto plex_irq::@4 -- vbuz1_ge_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcs b4
    jmp b7
  //SEG170 plex_irq::@7
  b7:
  //SEG171 [92] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3 -- vbuz1_lt_vbuz2_then_la1 
    lda plexFreeNextYpos1_return
    cmp _4
    bcc b3_from_b7
    jmp b4
  //SEG172 plex_irq::@4
  b4:
  //SEG173 [93] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG174 [94] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcc b1
    jmp b5
  //SEG175 plex_irq::@5
  b5:
  //SEG176 [95] (bool) framedone#3 ← true -- vboz1=vboc1 
    lda #1
    sta framedone
    jmp b2
  //SEG177 plex_irq::@2
  b2:
  //SEG178 [96] *((const byte*) BORDERCOL#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDERCOL
    jmp breturn
  //SEG179 plex_irq::@return
  breturn:
  //SEG180 [97] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
  //SEG181 plex_irq::@1
  b1:
  //SEG182 [98] *((const byte*) RASTER#0) ← (byte) plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuz1 
    lda plexFreeNextYpos1_return
    sta RASTER
    jmp b2
}
//SEG183 plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label _2 = $1e
    .label _3 = $1f
    .label _5 = $21
    .label _6 = $d
    .label _9 = $20
    .label _11 = $1d
    .label plex_sprite_idx2 = $18
    .label plexFreeAdd1_ypos = $19
    .label plexFreeAdd1__0 = $1a
    .label plexFreeAdd1__1 = $1b
    .label plexFreeAdd1__2 = $10
    .label xpos_idx = $1c
  //SEG184 [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda plex_sprite_idx
    asl
    sta plex_sprite_idx2
  //SEG185 [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- vbuz1=pbuc1_derefidx_pbuc2_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    ldx PLEX_YPOS,y
    stx plexFreeAdd1_ypos
  //SEG186 [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda plexFreeAdd1_ypos
    ldy plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
  //SEG187 plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
  //SEG188 [102] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuz1=vbuz2_plus_vbuc1 
    lax plexFreeAdd1_ypos
    axs #-[$15]
    stx plexFreeAdd1__0
  //SEG189 [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda plexFreeAdd1__0
    ldy plex_free_next
    sta PLEX_FREE_YPOS,y
  //SEG190 [104] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#27 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy plex_free_next
    iny
    sty plexFreeAdd1__1
  //SEG191 [105] (byte~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and plexFreeAdd1__1
    sta plexFreeAdd1__2
    jmp b5
  //SEG192 plexShowSprite::@5
  b5:
  //SEG193 [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_pbuc3_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
  //SEG194 [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy plex_show_idx
    lda PLEX_SORTED_IDX,y
    sta xpos_idx
  //SEG195 [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda xpos_idx
    asl
    sta _11
  //SEG196 [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuz1=_lo_pwuc1_derefidx_vbuz2 
    ldy _11
    lda PLEX_XPOS,y
    sta _2
  //SEG197 [110] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _2
    ldy plex_sprite_idx2
    sta SPRITES_XPOS,y
  //SEG198 [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuz1=_hi_pwuc1_derefidx_vbuz2 
    ldy _11
    lda PLEX_XPOS+1,y
    sta _3
  //SEG199 [112] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuz1_neq_0_then_la1 
    lda _3
    cmp #0
    bne b1
    jmp b3
  //SEG200 plexShowSprite::@3
  b3:
  //SEG201 [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 -- vbuz1=vbuc1_bxor_vbuz2 
    lda #$ff
    eor plex_sprite_msb
    sta _9
  //SEG202 [114] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuz1 
    lda SPRITES_XMSB
    and _9
    sta SPRITES_XMSB
    jmp b2
  //SEG203 plexShowSprite::@2
  b2:
  //SEG204 [115] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#25 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy plex_sprite_idx
    iny
    sty _5
  //SEG205 [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and _5
    sta _6
  //SEG206 [117] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27 -- vbuz1=_inc_vbuz1 
    inc plex_show_idx
  //SEG207 [118] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#28 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl plex_sprite_msb
  //SEG208 [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda plex_sprite_msb
    cmp #0
    bne breturn_from_b2
    jmp b4
  //SEG209 plexShowSprite::@4
  b4:
  //SEG210 [120] (byte) plex_sprite_msb#4 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG211 [121] phi from plexShowSprite::@2 plexShowSprite::@4 to plexShowSprite::@return [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return]
  breturn_from_b2:
  breturn_from_b4:
  //SEG212 [121] phi (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return#0] -- register_copy 
    jmp breturn
  //SEG213 plexShowSprite::@return
  breturn:
  //SEG214 [122] return 
    rts
  //SEG215 plexShowSprite::@1
  b1:
  //SEG216 [123] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#28 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = YSIN "YSIN"
  .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] (byte) plex_show_idx#0 ← (byte) 0 [ ] ( ) always clobbers reg byte a 
Statement [2] (byte) plex_sprite_idx#0 ← (byte) 0 [ ] ( ) always clobbers reg byte a 
Statement [3] (byte) plex_sprite_msb#0 ← (byte) 1 [ ] ( ) always clobbers reg byte a 
Statement [4] (byte) plex_free_next#31 ← (byte) 0 [ ] ( ) always clobbers reg byte a 
Statement [7] (bool) framedone#17 ← true [ framedone#17 ] ( ) always clobbers reg byte a 
Statement [18] if((bool) framedone#12) goto loop::@3 [ framedone#12 loop::sin_idx#6 ] ( main:9::loop:14 [ framedone#12 loop::sin_idx#6 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Statement [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 [ loop::sin_idx#6 ] ( main:9::loop:14 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ]
Statement [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ loop::sin_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [30] (bool) framedone#5 ← false [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte) $7f [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [32] *((const byte*) RASTER#0) ← (byte) 0 [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:19 [ plexSort::nxt_y#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Statement [43] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [45] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [48] (byte) plex_show_idx#1 ← (byte) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [49] (byte) plex_sprite_idx#1 ← (byte) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [50] (byte) plex_sprite_msb#1 ← (byte) 1 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [53] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Statement [56] (byte) plex_free_next#0 ← (byte) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:8 [ init::sx#2 init::sx#1 ]
Statement [62] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$9 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#2 init::$9 ] ) always clobbers reg byte a 
Statement [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$9) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [64] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [67] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:9::init:12 [ framedone#17 init::ss#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:11 [ init::ss#2 init::ss#1 ]
Statement [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] ) always clobbers reg byte a 
Statement [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte~) plexShowSprite::plexFreeAdd1_$2#0) [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte y 
Statement [91] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT#0) goto plex_irq::@4 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:22 [ plex_irq::plexFreeNextYpos1_return#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:23 [ plex_irq::$4 ]
Statement [93] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [94] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 [ plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [95] (bool) framedone#3 ← true [ ] (  [ ] ) always clobbers reg byte a 
Statement [96] *((const byte*) BORDERCOL#0) ← (byte) 0 [ ] (  [ ] ) always clobbers reg byte a 
Statement [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte x reg byte y 
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte y 
Statement [105] (byte~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte y 
Statement [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:29 [ plexShowSprite::$11 ]
Statement [110] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$11 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$11 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:29 [ plexShowSprite::$11 ]
Statement [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$3 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$9 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [114] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 [ plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#3 ] ( plexShowSprite:88 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#3 ] ) always clobbers reg byte a 
Statement [120] (byte) plex_sprite_msb#4 ← (byte) 1 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ( plexShowSprite:88 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ) always clobbers reg byte a 
Statement [123] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [1] (byte) plex_show_idx#0 ← (byte) 0 [ ] ( ) always clobbers reg byte a 
Statement [2] (byte) plex_sprite_idx#0 ← (byte) 0 [ ] ( ) always clobbers reg byte a 
Statement [3] (byte) plex_sprite_msb#0 ← (byte) 1 [ ] ( ) always clobbers reg byte a 
Statement [4] (byte) plex_free_next#31 ← (byte) 0 [ ] ( ) always clobbers reg byte a 
Statement [7] (bool) framedone#17 ← true [ framedone#17 ] ( ) always clobbers reg byte a 
Statement [18] if((bool) framedone#12) goto loop::@3 [ framedone#12 loop::sin_idx#6 ] ( main:9::loop:14 [ framedone#12 loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 [ loop::sin_idx#6 ] ( main:9::loop:14 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Statement [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ loop::sin_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [30] (bool) framedone#5 ← false [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte) $7f [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [32] *((const byte*) RASTER#0) ← (byte) 0 [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ) always clobbers reg byte a 
Statement [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Statement [43] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [45] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [48] (byte) plex_show_idx#1 ← (byte) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [49] (byte) plex_sprite_idx#1 ← (byte) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [50] (byte) plex_sprite_msb#1 ← (byte) 1 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [53] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Statement [56] (byte) plex_free_next#0 ← (byte) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [62] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$9 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#2 init::$9 ] ) always clobbers reg byte a 
Statement [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$9) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [64] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [67] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:9::init:12 [ framedone#17 init::ss#2 ] ) always clobbers reg byte a 
Statement [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] ) always clobbers reg byte a 
Statement [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte~) plexShowSprite::plexFreeAdd1_$2#0) [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte y 
Statement [91] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT#0) goto plex_irq::@4 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] ) always clobbers reg byte a 
Statement [93] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [94] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 [ plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [95] (bool) framedone#3 ← true [ ] (  [ ] ) always clobbers reg byte a 
Statement [96] *((const byte*) BORDERCOL#0) ← (byte) 0 [ ] (  [ ] ) always clobbers reg byte a 
Statement [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte x reg byte y 
Statement [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Statement [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte y 
Statement [105] (byte~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte y 
Statement [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Statement [110] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$11 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$11 ] ) always clobbers reg byte y 
Statement [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$3 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$9 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [114] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 [ plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#3 ] ( plexShowSprite:88 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#3 ] ) always clobbers reg byte a 
Statement [120] (byte) plex_sprite_msb#4 ← (byte) 1 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ( plexShowSprite:88 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ) always clobbers reg byte a 
Statement [123] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [1] (byte) plex_show_idx#0 ← (byte) 0 [ ] ( ) always clobbers reg byte a 
Statement [2] (byte) plex_sprite_idx#0 ← (byte) 0 [ ] ( ) always clobbers reg byte a 
Statement [3] (byte) plex_sprite_msb#0 ← (byte) 1 [ ] ( ) always clobbers reg byte a 
Statement [4] (byte) plex_free_next#31 ← (byte) 0 [ ] ( ) always clobbers reg byte a 
Statement [7] (bool) framedone#17 ← true [ framedone#17 ] ( ) always clobbers reg byte a 
Statement [18] if((bool) framedone#12) goto loop::@3 [ framedone#12 loop::sin_idx#6 ] ( main:9::loop:14 [ framedone#12 loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 [ loop::sin_idx#6 ] ( main:9::loop:14 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Statement [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ loop::sin_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [30] (bool) framedone#5 ← false [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte) $7f [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [32] *((const byte*) RASTER#0) ← (byte) 0 [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ) always clobbers reg byte a 
Statement [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Statement [43] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [45] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [48] (byte) plex_show_idx#1 ← (byte) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [49] (byte) plex_sprite_idx#1 ← (byte) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [50] (byte) plex_sprite_msb#1 ← (byte) 1 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [53] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Statement [56] (byte) plex_free_next#0 ← (byte) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [62] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$9 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#2 init::$9 ] ) always clobbers reg byte a 
Statement [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$9) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [64] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:9::init:12 [ framedone#17 init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [67] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:9::init:12 [ framedone#17 init::ss#2 ] ) always clobbers reg byte a 
Statement [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() [ ] ( main:9::init:12 [ framedone#17 ] ) always clobbers reg byte a 
Statement [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] ) always clobbers reg byte a 
Statement [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte~) plexShowSprite::plexFreeAdd1_$2#0) [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte y 
Statement [91] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT#0) goto plex_irq::@4 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] ) always clobbers reg byte a 
Statement [93] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [94] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 [ plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [95] (bool) framedone#3 ← true [ ] (  [ ] ) always clobbers reg byte a 
Statement [96] *((const byte*) BORDERCOL#0) ← (byte) 0 [ ] (  [ ] ) always clobbers reg byte a 
Statement [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte x reg byte y 
Statement [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte y 
Statement [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte y 
Statement [105] (byte~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte y 
Statement [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Statement [110] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$11 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$11 ] ) always clobbers reg byte y 
Statement [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$3 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$9 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [114] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 [ plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#3 ] ( plexShowSprite:88 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#3 ] ) always clobbers reg byte a 
Statement [120] (byte) plex_sprite_msb#4 ← (byte) 1 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ( plexShowSprite:88 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ) always clobbers reg byte a 
Statement [123] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] : zp ZP_BYTE:3 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ] : zp ZP_BYTE:5 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] : zp ZP_BYTE:6 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] : zp ZP_BYTE:7 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ init::sx#2 init::sx#1 ] : zp ZP_BYTE:8 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:9 [ init::xp#2 init::xp#1 ] : zp ZP_WORD:9 , 
Potential registers zp ZP_BYTE:11 [ init::ss#2 init::ss#1 ] : zp ZP_BYTE:11 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:12 [ plexInit::i#2 plexInit::i#1 ] : zp ZP_BYTE:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 plex_sprite_idx#1 ] : zp ZP_BYTE:13 , 
Potential registers zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ] : zp ZP_BYTE:14 , 
Potential registers zp ZP_BYTE:15 [ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 plex_sprite_msb#1 ] : zp ZP_BYTE:15 , 
Potential registers zp ZP_BYTE:16 [ plex_free_next#0 plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ] : zp ZP_BYTE:16 , 
Potential registers zp ZP_BOOL:17 [ framedone#3 framedone#12 framedone#17 framedone#5 ] : zp ZP_BOOL:17 , 
Potential registers zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] : zp ZP_BYTE:18 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] : zp ZP_BYTE:19 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:20 [ plexSort::s#2 ] : zp ZP_BYTE:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:21 [ init::$9 ] : zp ZP_BYTE:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:22 [ plex_irq::plexFreeNextYpos1_return#0 ] : zp ZP_BYTE:22 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:23 [ plex_irq::$4 ] : zp ZP_BYTE:23 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] : zp ZP_BYTE:24 , 
Potential registers zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ] : zp ZP_BYTE:25 , reg byte a , reg byte x , 
Potential registers zp ZP_BYTE:26 [ plexShowSprite::plexFreeAdd1_$0#0 ] : zp ZP_BYTE:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:27 [ plexShowSprite::plexFreeAdd1_$1#0 ] : zp ZP_BYTE:27 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ] : zp ZP_BYTE:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:29 [ plexShowSprite::$11 ] : zp ZP_BYTE:29 , reg byte x , 
Potential registers zp ZP_BYTE:30 [ plexShowSprite::$2 ] : zp ZP_BYTE:30 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:31 [ plexShowSprite::$3 ] : zp ZP_BYTE:31 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:32 [ plexShowSprite::$9 ] : zp ZP_BYTE:32 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:33 [ plexShowSprite::$5 ] : zp ZP_BYTE:33 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [plexSort] 3,622.83: zp ZP_BYTE:6 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] 303: zp ZP_BYTE:7 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] 202: zp ZP_BYTE:20 [ plexSort::s#2 ] 193.58: zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ] 150.38: zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] 30.3: zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] 
Uplift Scope [loop] 252.5: zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ] 246.33: zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] 6.81: zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Uplift Scope [] 85: zp ZP_BOOL:17 [ framedone#3 framedone#12 framedone#17 framedone#5 ] 34.05: zp ZP_BYTE:15 [ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 plex_sprite_msb#1 ] 27.83: zp ZP_BYTE:16 [ plex_free_next#0 plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ] 27.22: zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ] 26.14: zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 plex_sprite_idx#1 ] 
Uplift Scope [init] 33: zp ZP_BYTE:11 [ init::ss#2 init::ss#1 ] 25.3: zp ZP_BYTE:8 [ init::sx#2 init::sx#1 ] 22: zp ZP_BYTE:21 [ init::$9 ] 15.58: zp ZP_WORD:9 [ init::xp#2 init::xp#1 ] 
Uplift Scope [plexInit] 38.5: zp ZP_BYTE:12 [ plexInit::i#2 plexInit::i#1 ] 
Uplift Scope [plexShowSprite] 4: zp ZP_BYTE:26 [ plexShowSprite::plexFreeAdd1_$0#0 ] 4: zp ZP_BYTE:27 [ plexShowSprite::plexFreeAdd1_$1#0 ] 4: zp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ] 4: zp ZP_BYTE:30 [ plexShowSprite::$2 ] 4: zp ZP_BYTE:31 [ plexShowSprite::$3 ] 4: zp ZP_BYTE:32 [ plexShowSprite::$9 ] 4: zp ZP_BYTE:33 [ plexShowSprite::$5 ] 3: zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ] 2: zp ZP_BYTE:29 [ plexShowSprite::$11 ] 0.55: zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] 
Uplift Scope [plex_irq] 11: zp ZP_BYTE:23 [ plex_irq::$4 ] 4: zp ZP_BYTE:22 [ plex_irq::plexFreeNextYpos1_return#0 ] 
Uplift Scope [main] 

Uplifting [plexSort] best 60882 combination reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] zp ZP_BYTE:20 [ plexSort::s#2 ] zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ] zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] 
Limited combination testing to 10 combinations of 972 possible.
Uplifting [loop] best 58952 combination reg byte y [ loop::sy#2 loop::sy#1 ] reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Limited combination testing to 10 combinations of 27 possible.
Uplifting [] best 58952 combination zp ZP_BOOL:17 [ framedone#3 framedone#12 framedone#17 framedone#5 ] zp ZP_BYTE:15 [ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 plex_sprite_msb#1 ] zp ZP_BYTE:16 [ plex_free_next#0 plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ] zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ] zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 plex_sprite_idx#1 ] 
Uplifting [init] best 58702 combination reg byte x [ init::ss#2 init::ss#1 ] reg byte x [ init::sx#2 init::sx#1 ] zp ZP_BYTE:21 [ init::$9 ] zp ZP_WORD:9 [ init::xp#2 init::xp#1 ] 
Limited combination testing to 10 combinations of 36 possible.
Uplifting [plexInit] best 58582 combination reg byte x [ plexInit::i#2 plexInit::i#1 ] 
Uplifting [plexShowSprite] best 58572 combination reg byte a [ plexShowSprite::plexFreeAdd1_$0#0 ] reg byte x [ plexShowSprite::plexFreeAdd1_$1#0 ] zp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ] zp ZP_BYTE:30 [ plexShowSprite::$2 ] zp ZP_BYTE:31 [ plexShowSprite::$3 ] zp ZP_BYTE:32 [ plexShowSprite::$9 ] zp ZP_BYTE:33 [ plexShowSprite::$5 ] zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ] zp ZP_BYTE:29 [ plexShowSprite::$11 ] zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] 
Limited combination testing to 10 combinations of 98304 possible.
Uplifting [plex_irq] best 58509 combination zp ZP_BYTE:23 [ plex_irq::$4 ] reg byte x [ plex_irq::plexFreeNextYpos1_return#0 ] 
Uplifting [main] best 58509 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:20 [ plexSort::s#2 ]
Uplifting [plexSort] best 57909 combination reg byte x [ plexSort::s#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ]
Uplifting [plexSort] best 57909 combination zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:19 [ plexSort::nxt_y#0 ]
Uplifting [plexSort] best 57909 combination zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:15 [ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 plex_sprite_msb#1 ]
Uplifting [] best 57909 combination zp ZP_BYTE:15 [ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 plex_sprite_msb#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:18 [ plexSort::nxt_idx#0 ]
Uplifting [plexSort] best 57909 combination zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:16 [ plex_free_next#0 plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
Uplifting [] best 57909 combination zp ZP_BYTE:16 [ plex_free_next#0 plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ]
Uplifting [] best 57909 combination zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 plex_sprite_idx#1 ]
Uplifting [] best 57909 combination zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 plex_sprite_idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:21 [ init::$9 ]
Uplifting [init] best 57869 combination reg byte a [ init::$9 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:23 [ plex_irq::$4 ]
Uplifting [plex_irq] best 57869 combination zp ZP_BYTE:23 [ plex_irq::$4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Uplifting [loop] best 57869 combination zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ]
Uplifting [plexShowSprite] best 57863 combination reg byte a [ plexShowSprite::xpos_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:30 [ plexShowSprite::$2 ]
Uplifting [plexShowSprite] best 57857 combination reg byte a [ plexShowSprite::$2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:31 [ plexShowSprite::$3 ]
Uplifting [plexShowSprite] best 57851 combination reg byte a [ plexShowSprite::$3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:32 [ plexShowSprite::$9 ]
Uplifting [plexShowSprite] best 57845 combination reg byte a [ plexShowSprite::$9 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:33 [ plexShowSprite::$5 ]
Uplifting [plexShowSprite] best 57839 combination reg byte x [ plexShowSprite::$5 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Uplifting [plexShowSprite] best 57830 combination reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:29 [ plexShowSprite::$11 ]
Uplifting [plexShowSprite] best 57823 combination reg byte x [ plexShowSprite::$11 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Uplifting [plexShowSprite] best 57823 combination zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] 
Coalescing zero page register [ zp ZP_BYTE:23 [ plex_irq::$4 ] ] with [ zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] ]
Allocated (was zp ZP_BYTE:5) zp ZP_BYTE:3 [ plexSort::m#2 plexSort::m#1 ]
Allocated (was zp ZP_WORD:9) zp ZP_WORD:4 [ init::xp#2 init::xp#1 ]
Allocated (was zp ZP_BYTE:13) zp ZP_BYTE:6 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 plex_sprite_idx#1 ]
Allocated (was zp ZP_BYTE:14) zp ZP_BYTE:7 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ]
Allocated (was zp ZP_BYTE:15) zp ZP_BYTE:8 [ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 plex_sprite_msb#1 ]
Allocated (was zp ZP_BYTE:16) zp ZP_BYTE:9 [ plex_free_next#0 plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
Allocated (was zp ZP_BOOL:17) zp ZP_BOOL:10 [ framedone#3 framedone#12 framedone#17 framedone#5 ]
Allocated (was zp ZP_BYTE:18) zp ZP_BYTE:11 [ plexSort::nxt_idx#0 ]
Allocated (was zp ZP_BYTE:19) zp ZP_BYTE:12 [ plexSort::nxt_y#0 ]
Allocated (was zp ZP_BYTE:23) zp ZP_BYTE:13 [ plex_irq::$4 plexShowSprite::plex_sprite_idx2#0 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// A simple usage of the flexible sprite multiplexer routine
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label VIC_CONTROL = $d011
  .label D011 = $d011
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Bits for the IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // CIA#1 Interrupt Status & Control Register
  .label CIA1_INTERRUPT = $dc0d
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .label SPRITE = $2000
  .label YSIN = $2100
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = $400+$3f8
  .label plex_show_idx = 7
  .label plex_sprite_idx = 6
  .label plex_sprite_msb = 8
  .label plex_free_next = 9
  .label framedone = $a
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 [1] (byte) plex_show_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index in the PLEX tables of the next sprite to show
  lda #0
  sta plex_show_idx
//SEG6 [2] (byte) plex_sprite_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index the next sprite to use for showing (sprites are used round-robin)
  lda #0
  sta plex_sprite_idx
//SEG7 [3] (byte) plex_sprite_msb#0 ← (byte) 1 -- vbuz1=vbuc1 
  // The MSB bit of the next sprite to use for showing
  lda #1
  sta plex_sprite_msb
  jmp b2
//SEG8 @2
b2:
//SEG9 [4] (byte) plex_free_next#31 ← (byte) 0 -- vbuz1=vbuc1 
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  lda #0
  sta plex_free_next
  jmp b3
//SEG10 @3
b3:
//SEG11 kickasm(location (const byte*) YSIN#0) {{ .var min = 50     .var max = 250-21     .var ampl = max-min;     .for(var i=0;i<256;i++)         .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))  }}
//SEG12 kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  jmp b4
//SEG13 @4
b4:
//SEG14 [7] (bool) framedone#17 ← true -- vboz1=vboc1 
  lda #1
  sta framedone
//SEG15 [8] phi from @4 to @5 [phi:@4->@5]
b5_from_b4:
  jmp b5
//SEG16 @5
b5:
//SEG17 [9] call main 
  jsr main
//SEG18 [10] phi from @5 to @end [phi:@5->@end]
bend_from_b5:
  jmp bend
//SEG19 @end
bend:
//SEG20 main
main: {
  //SEG21 asm { sei  }
    sei
  //SEG22 [12] call init 
    jsr init
  //SEG23 [13] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG24 main::@1
  b1:
  //SEG25 [14] call loop 
  //SEG26 [16] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from_b1:
    jsr loop
    jmp breturn
  //SEG27 main::@return
  breturn:
  //SEG28 [15] return 
    rts
}
//SEG29 loop
// The raster loop
loop: {
    .label sin_idx = 2
  //SEG30 [17] phi from loop to loop::@1 [phi:loop->loop::@1]
  b1_from_loop:
  //SEG31 [17] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta sin_idx
  //SEG32 [17] phi (bool) framedone#12 = (bool) framedone#17 [phi:loop->loop::@1#1] -- register_copy 
    jmp b1
  //SEG33 loop::@1
  b1:
    jmp b2
  //SEG34 loop::@2
  b2:
  //SEG35 [18] if((bool) framedone#12) goto loop::@3 -- vboz1_then_la1 
    lda framedone
    cmp #0
    bne b3
    jmp b2
  //SEG36 loop::@3
  b3:
  //SEG37 [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
  //SEG38 [20] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx sin_idx
  //SEG39 [21] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  b4_from_b3:
  //SEG40 [21] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
  //SEG41 [21] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp b4
  //SEG42 [21] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  b4_from_b4:
  //SEG43 [21] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
  //SEG44 [21] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp b4
  //SEG45 loop::@4
  b4:
  //SEG46 [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
  //SEG47 [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
  //SEG48 [24] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG49 [25] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne b4_from_b4
    jmp b5
  //SEG50 loop::@5
  b5:
  //SEG51 [26] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc sin_idx
  //SEG52 [27] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG53 [28] call plexSort 
  //SEG54 [33] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from_b5:
    jsr plexSort
    jmp b6
  //SEG55 loop::@6
  b6:
  //SEG56 [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
  //SEG57 [30] (bool) framedone#5 ← false -- vboz1=vboc1 
    lda #0
    sta framedone
  //SEG58 [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
  //SEG59 [32] *((const byte*) RASTER#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
  //SEG60 [17] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
  b1_from_b6:
  //SEG61 [17] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
  //SEG62 [17] phi (bool) framedone#12 = (bool) framedone#5 [phi:loop::@6->loop::@1#1] -- register_copy 
    jmp b1
}
//SEG63 plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $b
    .label nxt_y = $c
    .label m = 3
  //SEG64 [34] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  b1_from_plexSort:
  //SEG65 [34] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta m
    jmp b1
  //SEG66 [34] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  b1_from_b2:
  //SEG67 [34] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp b1
  //SEG68 plexSort::@1
  b1:
  //SEG69 [35] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy m
    lda PLEX_SORTED_IDX+1,y
    sta nxt_idx
  //SEG70 [36] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy nxt_idx
    lda PLEX_YPOS,y
    sta nxt_y
  //SEG71 [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    lda nxt_y
    ldx m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
    jmp b5
  //SEG72 plexSort::@5
  b5:
  //SEG73 [38] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
    ldx m
  //SEG74 [39] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
  b3_from_b5:
  b3_from_b7:
  //SEG75 [39] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
    jmp b3
  //SEG76 plexSort::@3
  b3:
  //SEG77 [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
  //SEG78 [41] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
  //SEG79 [42] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq b4
    jmp b7
  //SEG80 plexSort::@7
  b7:
  //SEG81 [43] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_pbuc2_derefidx_vbuxx_then_la1 
    lda nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3_from_b7
    jmp b4
  //SEG82 plexSort::@4
  b4:
  //SEG83 [44] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
  //SEG84 [45] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda nxt_idx
    sta PLEX_SORTED_IDX,x
    jmp b2
  //SEG85 plexSort::@2
  b2:
  //SEG86 [46] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG87 [47] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp m
    bne b1_from_b2
    jmp b6
  //SEG88 plexSort::@6
  b6:
  //SEG89 [48] (byte) plex_show_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta plex_show_idx
  //SEG90 [49] (byte) plex_sprite_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta plex_sprite_idx
  //SEG91 [50] (byte) plex_sprite_msb#1 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG92 [51] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
  plexFreePrepare1_from_b6:
    jmp plexFreePrepare1
  //SEG93 plexSort::plexFreePrepare1
  plexFreePrepare1:
  //SEG94 [52] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1:
  //SEG95 [52] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp plexFreePrepare1_b1
  //SEG96 [52] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1_b1:
  //SEG97 [52] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1_b1
  //SEG98 plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
  //SEG99 [53] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
  //SEG100 [54] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG101 [55] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1_b1_from_plexFreePrepare1_b1
    jmp plexFreePrepare1_b2
  //SEG102 plexSort::plexFreePrepare1_@2
  plexFreePrepare1_b2:
  //SEG103 [56] (byte) plex_free_next#0 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta plex_free_next
    jmp breturn
  //SEG104 plexSort::@return
  breturn:
  //SEG105 [57] return 
    rts
}
//SEG106 init
// Initialize the program
init: {
    .label xp = 4
  //SEG107 [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
  //SEG108 [59] call plexInit 
  //SEG109 [79] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
  //SEG110 [60] phi from init to init::@1 [phi:init->init::@1]
  b1_from_init:
  //SEG111 [60] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #$20
    sta xp
    lda #0
    sta xp+1
  //SEG112 [60] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG113 [60] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
  //SEG114 [60] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
  //SEG115 [60] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp b1
  //SEG116 init::@1
  b1:
  //SEG117 [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta PLEX_PTR,x
  //SEG118 [62] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG119 [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$9) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda xp
    sta PLEX_XPOS,y
    lda xp+1
    sta PLEX_XPOS+1,y
  //SEG120 [64] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc xp
    sta xp
    bcc !+
    inc xp+1
  !:
  //SEG121 [65] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG122 [66] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1_from_b1
    jmp b2
  //SEG123 init::@2
  b2:
  //SEG124 [67] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
  //SEG125 [68] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
  //SEG126 [68] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b3
  //SEG127 [68] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  b3_from_b3:
  //SEG128 [68] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp b3
  //SEG129 init::@3
  b3:
  //SEG130 [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
  //SEG131 [70] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG132 [71] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b3_from_b3
    jmp b4
  //SEG133 init::@4
  b4:
  //SEG134 asm { sei  }
    // enable the interrupt
    sei
  //SEG135 [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
  //SEG136 [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
  //SEG137 [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG138 [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() -- _deref_pptc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
  //SEG139 asm { cli  }
    cli
    jmp breturn
  //SEG140 init::@return
  breturn:
  //SEG141 [78] return 
    rts
}
//SEG142 plexInit
// Initialize the multiplexer data structures
plexInit: {
  //SEG143 [80] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
  //SEG144 plexInit::plexSetScreen1
  plexSetScreen1:
  //SEG145 [81] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  b1_from_plexSetScreen1:
  //SEG146 [81] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG147 [81] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  b1_from_b1:
  //SEG148 [81] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp b1
  //SEG149 plexInit::@1
  b1:
  //SEG150 [82] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
  //SEG151 [83] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG152 [84] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1_from_b1
    jmp breturn
  //SEG153 plexInit::@return
  breturn:
  //SEG154 [85] return 
    rts
}
//SEG155 plex_irq
plex_irq: {
    .label _4 = $d
  //SEG156 entry interrupt(KERNEL_MIN)
  //SEG157 [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
  //SEG158 [87] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
  b3_from_plex_irq:
  b3_from_b7:
  //SEG159 [87] phi (byte) plex_sprite_msb#28 = (byte) plex_sprite_msb#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#0] -- register_copy 
  //SEG160 [87] phi (byte) plex_free_next#27 = (byte) plex_free_next#31 [phi:plex_irq/plex_irq::@7->plex_irq::@3#1] -- register_copy 
  //SEG161 [87] phi (byte) plex_show_idx#27 = (byte) plex_show_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#2] -- register_copy 
  //SEG162 [87] phi (byte) plex_sprite_idx#25 = (byte) plex_sprite_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#3] -- register_copy 
    jmp b3
  //SEG163 plex_irq::@3
  b3:
  //SEG164 [88] call plexShowSprite 
    jsr plexShowSprite
    jmp plexFreeNextYpos1
  //SEG165 plex_irq::plexFreeNextYpos1
  plexFreeNextYpos1:
  //SEG166 [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte~) plexShowSprite::plexFreeAdd1_$2#0) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy plexShowSprite.plexFreeAdd1__2
    ldx PLEX_FREE_YPOS,y
    jmp b6
  //SEG167 plex_irq::@6
  b6:
  //SEG168 [90] (byte~) plex_irq::$4 ← *((const byte*) RASTER#0) + (byte) 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta _4
  //SEG169 [91] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT#0) goto plex_irq::@4 -- vbuz1_ge_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcs b4
    jmp b7
  //SEG170 plex_irq::@7
  b7:
  //SEG171 [92] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3 -- vbuxx_lt_vbuz1_then_la1 
    cpx _4
    bcc b3_from_b7
    jmp b4
  //SEG172 plex_irq::@4
  b4:
  //SEG173 [93] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG174 [94] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcc b1
    jmp b5
  //SEG175 plex_irq::@5
  b5:
  //SEG176 [95] (bool) framedone#3 ← true -- vboz1=vboc1 
    lda #1
    sta framedone
    jmp b2
  //SEG177 plex_irq::@2
  b2:
  //SEG178 [96] *((const byte*) BORDERCOL#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDERCOL
    jmp breturn
  //SEG179 plex_irq::@return
  breturn:
  //SEG180 [97] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
  //SEG181 plex_irq::@1
  b1:
  //SEG182 [98] *((const byte*) RASTER#0) ← (byte) plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuxx 
    stx RASTER
    jmp b2
}
//SEG183 plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label _6 = 6
    .label plex_sprite_idx2 = $d
    .label plexFreeAdd1__2 = 9
  //SEG184 [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda plex_sprite_idx
    asl
    sta plex_sprite_idx2
  //SEG185 [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- vbuaa=pbuc1_derefidx_pbuc2_derefidx_vbuz1 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
  //SEG186 [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
  //SEG187 plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
  //SEG188 [102] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
  //SEG189 [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_free_next
    sta PLEX_FREE_YPOS,y
  //SEG190 [104] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#27 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_free_next
    inx
  //SEG191 [105] (byte~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax plexFreeAdd1__2
    jmp b5
  //SEG192 plexShowSprite::@5
  b5:
  //SEG193 [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_pbuc3_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
  //SEG194 [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy plex_show_idx
    lda PLEX_SORTED_IDX,y
  //SEG195 [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
  //SEG196 [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
  //SEG197 [110] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_XPOS,y
  //SEG198 [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
  //SEG199 [112] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b1
    jmp b3
  //SEG200 plexShowSprite::@3
  b3:
  //SEG201 [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor plex_sprite_msb
  //SEG202 [114] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    jmp b2
  //SEG203 plexShowSprite::@2
  b2:
  //SEG204 [115] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#25 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_sprite_idx
    inx
  //SEG205 [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax _6
  //SEG206 [117] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27 -- vbuz1=_inc_vbuz1 
    inc plex_show_idx
  //SEG207 [118] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#28 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl plex_sprite_msb
  //SEG208 [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda plex_sprite_msb
    cmp #0
    bne breturn_from_b2
    jmp b4
  //SEG209 plexShowSprite::@4
  b4:
  //SEG210 [120] (byte) plex_sprite_msb#4 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG211 [121] phi from plexShowSprite::@2 plexShowSprite::@4 to plexShowSprite::@return [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return]
  breturn_from_b2:
  breturn_from_b4:
  //SEG212 [121] phi (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return#0] -- register_copy 
    jmp breturn
  //SEG213 plexShowSprite::@return
  breturn:
  //SEG214 [122] return 
    rts
  //SEG215 plexShowSprite::@1
  b1:
  //SEG216 [123] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#28 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = YSIN "YSIN"
  .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b6
Removing instruction jmp b1
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b7
Removing instruction jmp b4
Removing instruction jmp b2
Removing instruction jmp b6
Removing instruction jmp plexFreePrepare1
Removing instruction jmp plexFreePrepare1_b1
Removing instruction jmp plexFreePrepare1_b2
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp plexSetScreen1
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b3
Removing instruction jmp plexFreeNextYpos1
Removing instruction jmp b6
Removing instruction jmp b7
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp plexFreeAdd1
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Replacing instruction ldy nxt_idx with TAY
Removing instruction lda nxt_y
Removing instruction lda #0
Replacing instruction ldx #0 with TAX
Removing instruction lda #IRQ_RASTER
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b4_from_b4 with b4
Replacing label b1 with b2
Replacing label b3_from_b7 with b3
Replacing label b1_from_b2 with b1
Replacing label plexFreePrepare1_b1_from_plexFreePrepare1_b1 with plexFreePrepare1_b1
Replacing label b1_from_b1 with b1
Replacing label b3_from_b3 with b3
Replacing label b1_from_b1 with b1
Replacing label b3_from_b7 with b3
Replacing label breturn_from_b2 with breturn
Removing instruction b1:
Removing instruction b3:
Removing instruction b5_from_b4:
Removing instruction bend_from_b5:
Removing instruction b1_from_main:
Removing instruction loop_from_b1:
Removing instruction b1:
Removing instruction b4_from_b4:
Removing instruction b1_from_b2:
Removing instruction b3_from_b5:
Removing instruction b3_from_b7:
Removing instruction plexFreePrepare1_from_b6:
Removing instruction plexFreePrepare1_b1_from_plexFreePrepare1:
Removing instruction plexFreePrepare1_b1_from_plexFreePrepare1_b1:
Removing instruction b1_from_b1:
Removing instruction b3_from_b3:
Removing instruction plexSetScreen1_from_plexInit:
Removing instruction b1_from_plexSetScreen1:
Removing instruction b1_from_b1:
Removing instruction b3_from_plex_irq:
Removing instruction b3_from_b7:
Removing instruction breturn_from_b2:
Removing instruction breturn_from_b4:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b2:
Removing instruction b4:
Removing instruction b5:
Removing instruction bend:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_loop:
Removing instruction b4_from_b3:
Removing instruction b5:
Removing instruction plexSort_from_b5:
Removing instruction b6:
Removing instruction b1_from_b6:
Removing instruction b1_from_plexSort:
Removing instruction b5:
Removing instruction b7:
Removing instruction b6:
Removing instruction plexFreePrepare1:
Removing instruction plexFreePrepare1_b2:
Removing instruction breturn:
Removing instruction plexInit_from_init:
Removing instruction b1_from_init:
Removing instruction b2:
Removing instruction b3_from_b2:
Removing instruction b4:
Removing instruction breturn:
Removing instruction plexSetScreen1:
Removing instruction breturn:
Removing instruction plexFreeNextYpos1:
Removing instruction b6:
Removing instruction b7:
Removing instruction b5:
Removing instruction breturn:
Removing instruction plexFreeAdd1:
Removing instruction b5:
Removing instruction b3:
Removing instruction b4:
Succesful ASM optimization Pass5UnusedLabelElimination
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts
Removing instruction jmp b4
Removing instruction jmp b1
Removing instruction jmp plexFreePrepare1_b1
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldx m
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination

FINAL SYMBOL TABLE
(label) @1
(label) @2
(label) @3
(label) @4
(label) @5
(label) @begin
(label) @end
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = (byte*) 53280
(byte*) CIA1_INTERRUPT
(const byte*) CIA1_INTERRUPT#0 CIA1_INTERRUPT = (byte*) 56333
(byte) CIA_INTERRUPT_CLEAR
(const byte) CIA_INTERRUPT_CLEAR#0 CIA_INTERRUPT_CLEAR = (byte) $7f
(byte*) D011
(const byte*) D011#0 D011 = (byte*) 53265
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte) 5
(byte*) IRQ_ENABLE
(const byte*) IRQ_ENABLE#0 IRQ_ENABLE = (byte*) 53274
(byte) IRQ_RASTER
(const byte) IRQ_RASTER#0 IRQ_RASTER = (byte) 1
(byte*) IRQ_STATUS
(const byte*) IRQ_STATUS#0 IRQ_STATUS = (byte*) 53273
(void()**) KERNEL_IRQ
(const void()**) KERNEL_IRQ#0 KERNEL_IRQ = (void()**) 788
(byte) PLEX_COUNT
(const byte) PLEX_COUNT#0 PLEX_COUNT = (byte) $20
(byte[8]) PLEX_FREE_YPOS
(const byte[8]) PLEX_FREE_YPOS#0 PLEX_FREE_YPOS = { fill( 8, 0) }
(byte[PLEX_COUNT#0]) PLEX_PTR
(const byte[PLEX_COUNT#0]) PLEX_PTR#0 PLEX_PTR = { fill( PLEX_COUNT#0, 0) }
(byte*) PLEX_SCREEN_PTR
(const byte*) PLEX_SCREEN_PTR#0 PLEX_SCREEN_PTR = (byte*)(number) $400+(number) $3f8
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 PLEX_SORTED_IDX = { fill( PLEX_COUNT#0, 0) }
(word[PLEX_COUNT#0]) PLEX_XPOS
(const word[PLEX_COUNT#0]) PLEX_XPOS#0 PLEX_XPOS = { fill( PLEX_COUNT#0, 0) }
(byte[PLEX_COUNT#0]) PLEX_YPOS
(const byte[PLEX_COUNT#0]) PLEX_YPOS#0 PLEX_YPOS = { fill( PLEX_COUNT#0, 0) }
(byte*) RASTER
(const byte*) RASTER#0 RASTER = (byte*) 53266
(byte) RED
(const byte) RED#0 RED = (byte) 2
(byte*) SCREEN
(byte*) SPRITE
(const byte*) SPRITE#0 SPRITE = (byte*) 8192
(byte*) SPRITES_COLS
(const byte*) SPRITES_COLS#0 SPRITES_COLS = (byte*) 53287
(byte*) SPRITES_ENABLE
(const byte*) SPRITES_ENABLE#0 SPRITES_ENABLE = (byte*) 53269
(byte*) SPRITES_XMSB
(const byte*) SPRITES_XMSB#0 SPRITES_XMSB = (byte*) 53264
(byte*) SPRITES_XPOS
(const byte*) SPRITES_XPOS#0 SPRITES_XPOS = (byte*) 53248
(byte*) SPRITES_YPOS
(const byte*) SPRITES_YPOS#0 SPRITES_YPOS = (byte*) 53249
(byte*) VIC_CONTROL
(const byte*) VIC_CONTROL#0 VIC_CONTROL = (byte*) 53265
(byte) VIC_DEN
(const byte) VIC_DEN#0 VIC_DEN = (byte) $10
(byte) VIC_RSEL
(const byte) VIC_RSEL#0 VIC_RSEL = (byte) 8
(byte) WHITE
(const byte) WHITE#0 WHITE = (byte) 1
(byte*) YSIN
(const byte*) YSIN#0 YSIN = (byte*) 8448
(bool) framedone
(bool) framedone#12 framedone zp ZP_BOOL:10 57.0
(bool) framedone#17 framedone zp ZP_BOOL:10 0.6666666666666666
(bool) framedone#3 framedone zp ZP_BOOL:10 20.0
(bool) framedone#5 framedone zp ZP_BOOL:10 7.333333333333333
(void()) init()
(byte~) init::$9 reg byte a 22.0
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@return
(byte) init::ss
(byte) init::ss#1 reg byte x 16.5
(byte) init::ss#2 reg byte x 16.5
(byte) init::sx
(byte) init::sx#1 reg byte x 16.5
(byte) init::sx#2 reg byte x 8.8
(word) init::xp
(word) init::xp#1 xp zp ZP_WORD:4 7.333333333333333
(word) init::xp#2 xp zp ZP_WORD:4 8.25
(void()) loop()
(label) loop::@1
(label) loop::@2
(label) loop::@3
(label) loop::@4
(label) loop::@5
(label) loop::@6
(byte) loop::sin_idx
(byte) loop::sin_idx#1 sin_idx zp ZP_BYTE:2 3.142857142857143
(byte) loop::sin_idx#6 sin_idx zp ZP_BYTE:2 3.666666666666667
(byte) loop::sy
(byte) loop::sy#1 reg byte y 151.5
(byte) loop::sy#2 reg byte y 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 reg byte x 67.33333333333333
(byte) loop::y_idx#2 reg byte x 157.0
(byte~) loop::y_idx#4 reg byte x 22.0
(void()) main()
(label) main::@1
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(label) plexInit::@1
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#1 reg byte x 16.5
(byte) plexInit::i#2 reg byte x 22.0
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 reg byte x 2.0
(byte~) plexShowSprite::$2 reg byte a 4.0
(byte~) plexShowSprite::$3 reg byte a 4.0
(byte~) plexShowSprite::$5 reg byte x 4.0
(byte~) plexShowSprite::$6 $6 zp ZP_BYTE:6 1.0833333333333333
(byte~) plexShowSprite::$9 reg byte a 4.0
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@3
(label) plexShowSprite::@4
(label) plexShowSprite::@5
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(number~) plexShowSprite::plexFreeAdd1_$0
(byte~) plexShowSprite::plexFreeAdd1_$0#0 reg byte a 4.0
(number~) plexShowSprite::plexFreeAdd1_$1
(byte~) plexShowSprite::plexFreeAdd1_$1#0 reg byte x 4.0
(number~) plexShowSprite::plexFreeAdd1_$2
(byte~) plexShowSprite::plexFreeAdd1_$2#0 plexFreeAdd1_$2 zp ZP_BYTE:9 1.0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 reg byte a 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 plex_sprite_idx2 zp ZP_BYTE:13 0.5454545454545454
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 reg byte a 4.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@7
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#1 m zp ZP_BYTE:3 151.5
(byte) plexSort::m#2 m zp ZP_BYTE:3 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 nxt_idx zp ZP_BYTE:11 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 nxt_y zp ZP_BYTE:12 150.375
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(label) plexSort::plexFreePrepare1_@1
(label) plexSort::plexFreePrepare1_@2
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 reg byte x 151.5
(byte) plexSort::plexFreePrepare1_s#2 reg byte x 151.5
(byte) plexSort::s
(byte) plexSort::s#1 reg byte x 1368.3333333333335
(byte) plexSort::s#2 reg byte x 202.0
(byte) plexSort::s#3 reg byte x 2052.5
(byte~) plexSort::s#6 reg byte x 202.0
(byte) plex_free_next
(byte) plex_free_next#0 plex_free_next zp ZP_BYTE:9 20.0
(byte) plex_free_next#27 plex_free_next zp ZP_BYTE:9 2.8333333333333335
(byte) plex_free_next#31 plex_free_next zp ZP_BYTE:9 4.0
interrupt(KERNEL_MIN)(void()) plex_irq()
(byte~) plex_irq::$4 $4 zp ZP_BYTE:13 11.0
(label) plex_irq::@1
(label) plex_irq::@2
(label) plex_irq::@3
(label) plex_irq::@4
(label) plex_irq::@5
(label) plex_irq::@6
(label) plex_irq::@7
(label) plex_irq::@return
(label) plex_irq::plexFreeNextYpos1
(byte) plex_irq::plexFreeNextYpos1_return
(byte) plex_irq::plexFreeNextYpos1_return#0 reg byte x 4.0
(byte) plex_irq::rasterY
(byte) plex_show_idx
(byte) plex_show_idx#0 plex_show_idx zp ZP_BYTE:7 4.0
(byte) plex_show_idx#1 plex_show_idx zp ZP_BYTE:7 20.0
(byte) plex_show_idx#16 plex_show_idx zp ZP_BYTE:7 2.1666666666666665
(byte) plex_show_idx#27 plex_show_idx zp ZP_BYTE:7 1.05
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0 plex_sprite_idx zp ZP_BYTE:6 4.0
(byte) plex_sprite_idx#1 plex_sprite_idx zp ZP_BYTE:6 20.0
(byte) plex_sprite_idx#25 plex_sprite_idx zp ZP_BYTE:6 1.0555555555555558
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0 plex_sprite_msb zp ZP_BYTE:8 4.0
(byte) plex_sprite_msb#1 plex_sprite_msb zp ZP_BYTE:8 20.0
(byte) plex_sprite_msb#17 plex_sprite_msb zp ZP_BYTE:8 2.142857142857143
(byte) plex_sprite_msb#28 plex_sprite_msb zp ZP_BYTE:8 0.9047619047619048
(byte) plex_sprite_msb#3 plex_sprite_msb zp ZP_BYTE:8 3.0
(byte) plex_sprite_msb#4 plex_sprite_msb zp ZP_BYTE:8 4.0

zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
reg byte y [ loop::sy#2 loop::sy#1 ]
zp ZP_BYTE:3 [ plexSort::m#2 plexSort::m#1 ]
reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
reg byte x [ init::sx#2 init::sx#1 ]
zp ZP_WORD:4 [ init::xp#2 init::xp#1 ]
reg byte x [ init::ss#2 init::ss#1 ]
reg byte x [ plexInit::i#2 plexInit::i#1 ]
zp ZP_BYTE:6 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$6 plex_sprite_idx#1 ]
zp ZP_BYTE:7 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ]
zp ZP_BYTE:8 [ plex_sprite_msb#28 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 plex_sprite_msb#1 ]
zp ZP_BYTE:9 [ plex_free_next#0 plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
zp ZP_BOOL:10 [ framedone#3 framedone#12 framedone#17 framedone#5 ]
zp ZP_BYTE:11 [ plexSort::nxt_idx#0 ]
zp ZP_BYTE:12 [ plexSort::nxt_y#0 ]
reg byte x [ plexSort::s#2 ]
reg byte a [ init::$9 ]
reg byte x [ plex_irq::plexFreeNextYpos1_return#0 ]
zp ZP_BYTE:13 [ plex_irq::$4 plexShowSprite::plex_sprite_idx2#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$0#0 ]
reg byte x [ plexShowSprite::plexFreeAdd1_$1#0 ]
reg byte a [ plexShowSprite::xpos_idx#0 ]
reg byte x [ plexShowSprite::$11 ]
reg byte a [ plexShowSprite::$2 ]
reg byte a [ plexShowSprite::$3 ]
reg byte a [ plexShowSprite::$9 ]
reg byte x [ plexShowSprite::$5 ]


FINAL ASSEMBLER
Score: 44248

//SEG0 File Comments
// A simple usage of the flexible sprite multiplexer routine
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label VIC_CONTROL = $d011
  .label D011 = $d011
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Bits for the IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // CIA#1 Interrupt Status & Control Register
  .label CIA1_INTERRUPT = $dc0d
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .label SPRITE = $2000
  .label YSIN = $2100
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = $400+$3f8
  .label plex_show_idx = 7
  .label plex_sprite_idx = 6
  .label plex_sprite_msb = 8
  .label plex_free_next = 9
  .label framedone = $a
//SEG3 @begin
bbegin:
//SEG4 @1
//SEG5 [1] (byte) plex_show_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index in the PLEX tables of the next sprite to show
  lda #0
  sta plex_show_idx
//SEG6 [2] (byte) plex_sprite_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index the next sprite to use for showing (sprites are used round-robin)
  sta plex_sprite_idx
//SEG7 [3] (byte) plex_sprite_msb#0 ← (byte) 1 -- vbuz1=vbuc1 
  // The MSB bit of the next sprite to use for showing
  lda #1
  sta plex_sprite_msb
//SEG8 @2
//SEG9 [4] (byte) plex_free_next#31 ← (byte) 0 -- vbuz1=vbuc1 
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  lda #0
  sta plex_free_next
//SEG10 @3
//SEG11 kickasm(location (const byte*) YSIN#0) {{ .var min = 50     .var max = 250-21     .var ampl = max-min;     .for(var i=0;i<256;i++)         .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))  }}
//SEG12 kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
//SEG13 @4
//SEG14 [7] (bool) framedone#17 ← true -- vboz1=vboc1 
  lda #1
  sta framedone
//SEG15 [8] phi from @4 to @5 [phi:@4->@5]
//SEG16 @5
//SEG17 [9] call main 
  jsr main
  rts
//SEG18 [10] phi from @5 to @end [phi:@5->@end]
//SEG19 @end
//SEG20 main
main: {
  //SEG21 asm { sei  }
    sei
  //SEG22 [12] call init 
    jsr init
  //SEG23 [13] phi from main to main::@1 [phi:main->main::@1]
  //SEG24 main::@1
  //SEG25 [14] call loop 
  //SEG26 [16] phi from main::@1 to loop [phi:main::@1->loop]
    jsr loop
  //SEG27 main::@return
  //SEG28 [15] return 
    rts
}
//SEG29 loop
// The raster loop
loop: {
    .label sin_idx = 2
  //SEG30 [17] phi from loop to loop::@1 [phi:loop->loop::@1]
  //SEG31 [17] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta sin_idx
  //SEG32 [17] phi (bool) framedone#12 = (bool) framedone#17 [phi:loop->loop::@1#1] -- register_copy 
  //SEG33 loop::@1
  //SEG34 loop::@2
  b2:
  //SEG35 [18] if((bool) framedone#12) goto loop::@3 -- vboz1_then_la1 
    lda framedone
    cmp #0
    bne b3
    jmp b2
  //SEG36 loop::@3
  b3:
  //SEG37 [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
  //SEG38 [20] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx sin_idx
  //SEG39 [21] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  //SEG40 [21] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
  //SEG41 [21] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
  //SEG42 [21] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  //SEG43 [21] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
  //SEG44 [21] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
  //SEG45 loop::@4
  b4:
  //SEG46 [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
  //SEG47 [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
  //SEG48 [24] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG49 [25] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne b4
  //SEG50 loop::@5
  //SEG51 [26] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc sin_idx
  //SEG52 [27] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG53 [28] call plexSort 
  //SEG54 [33] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
    jsr plexSort
  //SEG55 loop::@6
  //SEG56 [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
  //SEG57 [30] (bool) framedone#5 ← false -- vboz1=vboc1 
    lda #0
    sta framedone
  //SEG58 [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
  //SEG59 [32] *((const byte*) RASTER#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
  //SEG60 [17] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
  //SEG61 [17] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
  //SEG62 [17] phi (bool) framedone#12 = (bool) framedone#5 [phi:loop::@6->loop::@1#1] -- register_copy 
    jmp b2
}
//SEG63 plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $b
    .label nxt_y = $c
    .label m = 3
  //SEG64 [34] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  //SEG65 [34] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta m
  //SEG66 [34] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  //SEG67 [34] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
  //SEG68 plexSort::@1
  b1:
  //SEG69 [35] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy m
    lda PLEX_SORTED_IDX+1,y
    sta nxt_idx
  //SEG70 [36] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    tay
    lda PLEX_YPOS,y
    sta nxt_y
  //SEG71 [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    ldx m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
  //SEG72 plexSort::@5
  //SEG73 [38] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
  //SEG74 [39] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
  //SEG75 [39] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
  //SEG76 plexSort::@3
  b3:
  //SEG77 [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
  //SEG78 [41] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
  //SEG79 [42] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq b4
  //SEG80 plexSort::@7
  //SEG81 [43] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_pbuc2_derefidx_vbuxx_then_la1 
    lda nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3
  //SEG82 plexSort::@4
  b4:
  //SEG83 [44] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
  //SEG84 [45] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda nxt_idx
    sta PLEX_SORTED_IDX,x
  //SEG85 plexSort::@2
  b2:
  //SEG86 [46] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG87 [47] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp m
    bne b1
  //SEG88 plexSort::@6
  //SEG89 [48] (byte) plex_show_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta plex_show_idx
  //SEG90 [49] (byte) plex_sprite_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    sta plex_sprite_idx
  //SEG91 [50] (byte) plex_sprite_msb#1 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG92 [51] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
  //SEG93 plexSort::plexFreePrepare1
  //SEG94 [52] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  //SEG95 [52] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG96 [52] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  //SEG97 [52] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
  //SEG98 plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
  //SEG99 [53] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
  //SEG100 [54] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG101 [55] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1_b1
  //SEG102 plexSort::plexFreePrepare1_@2
  //SEG103 [56] (byte) plex_free_next#0 ← (byte) 0 -- vbuz1=vbuc1 
    sta plex_free_next
  //SEG104 plexSort::@return
  //SEG105 [57] return 
    rts
}
//SEG106 init
// Initialize the program
init: {
    .label xp = 4
  //SEG107 [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
  //SEG108 [59] call plexInit 
  //SEG109 [79] phi from init to plexInit [phi:init->plexInit]
    jsr plexInit
  //SEG110 [60] phi from init to init::@1 [phi:init->init::@1]
  //SEG111 [60] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #$20
    sta xp
    lda #0
    sta xp+1
  //SEG112 [60] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    tax
  //SEG113 [60] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  //SEG114 [60] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
  //SEG115 [60] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
  //SEG116 init::@1
  b1:
  //SEG117 [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta PLEX_PTR,x
  //SEG118 [62] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG119 [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$9) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda xp
    sta PLEX_XPOS,y
    lda xp+1
    sta PLEX_XPOS+1,y
  //SEG120 [64] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc xp
    sta xp
    bcc !+
    inc xp+1
  !:
  //SEG121 [65] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG122 [66] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1
  //SEG123 init::@2
  //SEG124 [67] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
  //SEG125 [68] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  //SEG126 [68] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG127 [68] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  //SEG128 [68] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
  //SEG129 init::@3
  b3:
  //SEG130 [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
  //SEG131 [70] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG132 [71] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b3
  //SEG133 init::@4
  //SEG134 asm { sei  }
    // enable the interrupt
    sei
  //SEG135 [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
  //SEG136 [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
  //SEG137 [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    sta IRQ_STATUS
  //SEG138 [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() -- _deref_pptc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
  //SEG139 asm { cli  }
    cli
  //SEG140 init::@return
  //SEG141 [78] return 
    rts
}
//SEG142 plexInit
// Initialize the multiplexer data structures
plexInit: {
  //SEG143 [80] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  //SEG144 plexInit::plexSetScreen1
  //SEG145 [81] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  //SEG146 [81] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG147 [81] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  //SEG148 [81] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
  //SEG149 plexInit::@1
  b1:
  //SEG150 [82] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
  //SEG151 [83] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG152 [84] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1
  //SEG153 plexInit::@return
  //SEG154 [85] return 
    rts
}
//SEG155 plex_irq
plex_irq: {
    .label _4 = $d
  //SEG156 entry interrupt(KERNEL_MIN)
  //SEG157 [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
  //SEG158 [87] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
  //SEG159 [87] phi (byte) plex_sprite_msb#28 = (byte) plex_sprite_msb#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#0] -- register_copy 
  //SEG160 [87] phi (byte) plex_free_next#27 = (byte) plex_free_next#31 [phi:plex_irq/plex_irq::@7->plex_irq::@3#1] -- register_copy 
  //SEG161 [87] phi (byte) plex_show_idx#27 = (byte) plex_show_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#2] -- register_copy 
  //SEG162 [87] phi (byte) plex_sprite_idx#25 = (byte) plex_sprite_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#3] -- register_copy 
  //SEG163 plex_irq::@3
  b3:
  //SEG164 [88] call plexShowSprite 
    jsr plexShowSprite
  //SEG165 plex_irq::plexFreeNextYpos1
  //SEG166 [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte~) plexShowSprite::plexFreeAdd1_$2#0) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy plexShowSprite.plexFreeAdd1__2
    ldx PLEX_FREE_YPOS,y
  //SEG167 plex_irq::@6
  //SEG168 [90] (byte~) plex_irq::$4 ← *((const byte*) RASTER#0) + (byte) 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta _4
  //SEG169 [91] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT#0) goto plex_irq::@4 -- vbuz1_ge_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcs b4
  //SEG170 plex_irq::@7
  //SEG171 [92] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3 -- vbuxx_lt_vbuz1_then_la1 
    cpx _4
    bcc b3
  //SEG172 plex_irq::@4
  b4:
  //SEG173 [93] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG174 [94] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcc b1
  //SEG175 plex_irq::@5
  //SEG176 [95] (bool) framedone#3 ← true -- vboz1=vboc1 
    lda #1
    sta framedone
  //SEG177 plex_irq::@2
  b2:
  //SEG178 [96] *((const byte*) BORDERCOL#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDERCOL
  //SEG179 plex_irq::@return
  //SEG180 [97] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
  //SEG181 plex_irq::@1
  b1:
  //SEG182 [98] *((const byte*) RASTER#0) ← (byte) plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuxx 
    stx RASTER
    jmp b2
}
//SEG183 plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label _6 = 6
    .label plex_sprite_idx2 = $d
    .label plexFreeAdd1__2 = 9
  //SEG184 [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda plex_sprite_idx
    asl
    sta plex_sprite_idx2
  //SEG185 [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- vbuaa=pbuc1_derefidx_pbuc2_derefidx_vbuz1 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
  //SEG186 [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_YPOS,y
  //SEG187 plexShowSprite::plexFreeAdd1
  //SEG188 [102] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
  //SEG189 [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_free_next
    sta PLEX_FREE_YPOS,y
  //SEG190 [104] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#27 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_free_next
    inx
  //SEG191 [105] (byte~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax plexFreeAdd1__2
  //SEG192 plexShowSprite::@5
  //SEG193 [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_pbuc3_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
  //SEG194 [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy plex_show_idx
    lda PLEX_SORTED_IDX,y
  //SEG195 [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
  //SEG196 [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
  //SEG197 [110] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_XPOS,y
  //SEG198 [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
  //SEG199 [112] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b1
  //SEG200 plexShowSprite::@3
  //SEG201 [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor plex_sprite_msb
  //SEG202 [114] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
  //SEG203 plexShowSprite::@2
  b2:
  //SEG204 [115] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#25 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_sprite_idx
    inx
  //SEG205 [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax _6
  //SEG206 [117] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27 -- vbuz1=_inc_vbuz1 
    inc plex_show_idx
  //SEG207 [118] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#28 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl plex_sprite_msb
  //SEG208 [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda plex_sprite_msb
    cmp #0
    bne breturn
  //SEG209 plexShowSprite::@4
  //SEG210 [120] (byte) plex_sprite_msb#4 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG211 [121] phi from plexShowSprite::@2 plexShowSprite::@4 to plexShowSprite::@return [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return]
  //SEG212 [121] phi (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return#0] -- register_copy 
  //SEG213 plexShowSprite::@return
  breturn:
  //SEG214 [122] return 
    rts
  //SEG215 plexShowSprite::@1
  b1:
  //SEG216 [123] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#28 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = YSIN "YSIN"
  .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


