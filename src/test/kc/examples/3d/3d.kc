// 3D Rotation using a Rotation Matrix
// Based on: 
// - C= Hacking Magazine Issue 8. http://www.ffd2.com/fridge/chacking/c=hacking8.txt
// - Codebase64 Article http://codebase64.org/doku.php?id=base:3d_rotation  

import "c64"

// Sine and Cosine Tables   
// Angles: $00=0, $80=PI,$100=2*PI
// Half Sine/Cosine: signed fixed [-$1f,$1f]
signed byte* COSH = $2000;
signed byte* SINH = COSH+$40; // sin(x) = cos(x+PI/2)
// Quarter Sine/Cosine: signed fixed [-$0f,$0f]
signed byte* COSQ = $2200;
signed byte* SINQ = COSQ+$40; // sin(x) = cos(x+PI/2)
kickasm(pc COSH) {{
    {
    .var min = -$1fff
    .var max = $1fff
    .var ampl = max-min;
    .for(var i=0;i<$140;i++) {
        .var rad = i*2*PI/256;
        .byte >round(min+(ampl/2)+(ampl/2)*cos(rad))
    }
    }
}}
kickasm(pc COSQ) {{
    {
    .var min = -$0fff
    .var max = $0fff
    .var ampl = max-min;
    .for(var i=0;i<$140;i++) {
        .var rad = i*2*PI/256;
        .byte >round(min+(ampl/2)+(ampl/2)*cos(rad))
    }
    }
}}

// mulf_sqr tables will contain f(x)=int(x*x/2) and g(x) = f(1-x).
// f(x) = >(( x * x )/2)
byte[512] align($100) mulf_sqr1;
// g(x) =  >((( 1 - x ) * ( 1 - x ))/2)
byte[512] align($100) mulf_sqr2;

// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/2) and g(x) = f(1-x) 
void mulf_init() {
	signed word sqr1 = 0;	
	signed word add = 1;
	for( byte i:0..128) {
		mulf_sqr1[i] = >sqr1;
		mulf_sqr1[-i] = >sqr1;
		mulf_sqr2[i+1] = >sqr1;
		mulf_sqr2[1-i] = >sqr1;
		sqr1 += add;
		add +=2;
	}
}

// The rotated point - updated by calling rotate()
signed byte* xr = $f0;
signed byte* yr = $f1;
signed byte* zr = $f2;

void main() {
	byte* SCREEN = $400;
	asm { sei }
	mulf_init();
	prepare_matrix(0,0,0);
	while(true) {
		while(*RASTER!=$ff) {}
        (*BORDERCOL)++; 
		rotate(0,0,$3f);
		SCREEN[0] = (byte)*xr;
		SCREEN[1] = (byte)*yr;
		SCREEN[2] = (byte)*zr;
        (*BORDERCOL)++;
		rotate(0,$3f,0);
		SCREEN[40] = (byte)*xr;
		SCREEN[41] = (byte)*yr;
		SCREEN[42] = (byte)*zr;
        (*BORDERCOL)++;
		rotate($3f,0,0);
		SCREEN[80] = (byte)*xr;
		SCREEN[81] = (byte)*yr;
		SCREEN[82] = (byte)*zr;
        *BORDERCOL = LIGHT_BLUE; 
	}	
}

// The rotation matrix
signed byte[9] rotation_matrix;

// Prepare the rotation matrix [ [A,B,C],[D,E,F],[G,H,I]]
// Angles sx, sy, sz are based on 2*PI=$100 
// Method described in C= Hacking Magazine Issue 8. http://www.ffd2.com/fridge/chacking/c=hacking8.txt
void prepare_matrix(signed byte sx, signed byte sy, signed byte sz) {
	signed byte t1 = sy-sz;
	signed byte t2 = sy+sz;
	signed byte t3 = sx+sz;
	signed byte t4 = sx-sz;
	signed byte t5 = sx+t2; // = sx+sy+sz
	signed byte t6 = sx-t1; // = sx-sy+sz
	signed byte t7 = sx+t1; // = sx+sy-sz
	signed byte t8 = t2-sx; //  = sy+sz-sx
	signed byte t9 = sy-sx;
	signed byte t10 = sy+sx;

	rotation_matrix[0] = COSH[t1]+COSH[t2];
	rotation_matrix[1] = SINH[t1]-SINH[t2];
	rotation_matrix[2] = SINH[sy]+SINH[sy];
	rotation_matrix[3] = SINH[t3]-SINH[t4] + COSQ[t6]-COSQ[t5]+COSQ[t8]-COSQ[t7];
	rotation_matrix[4] = COSH[t3]+COSH[t4] + SINQ[t5]-SINQ[t6]-SINQ[t7]-SINQ[t8];
	rotation_matrix[5] = SINH[t9]-SINH[t10];
	rotation_matrix[6] = COSH[t4]-COSH[t3] + SINQ[t6]-SINQ[t5]-SINQ[t8]-SINQ[t7];
	rotation_matrix[7] = SINH[t3]+SINH[t4] + COSQ[t6]-COSQ[t5]+COSQ[t7]-COSQ[t8];
	rotation_matrix[8] = COSH[t9]+COSH[t10];	

	asm {
		lda rotation_matrix+0
		sta rotate.A1+1
		eor #$ff
		sta rotate.A2+1
		lda rotation_matrix+1
		sta rotate.B1+1
		eor #$ff
		sta rotate.B2+1
		lda rotation_matrix+2
		sta rotate.C1+1
		eor #$ff
		sta rotate.C2+1
		lda rotation_matrix+3
		sta rotate.D1+1
		eor #$ff
		sta rotate.D2+1
		lda rotation_matrix+4
		sta rotate.E1+1
		eor #$ff
		sta rotate.E2+1
		lda rotation_matrix+5
		sta rotate.F1+1
		eor #$ff
		sta rotate.F2+1
		lda rotation_matrix+6
		sta rotate.G1+1
		eor #$ff
		sta rotate.G2+1
		lda rotation_matrix+7
		sta rotate.H1+1
		eor #$ff
		sta rotate.H2+1
		lda rotation_matrix+8
		sta rotate.I1+1
		eor #$ff
		sta rotate.I2+1
	}

}


// Rotate a 3D point (x,y,z) using the rotation matrix
// The rotation matrix is prepared by calling prepare_matrix() 
// The passed points must be in the interval [-$3f;$3f].
// Implemented in assembler to utilize seriously fast multiplication 
void rotate(signed byte x, signed byte y, signed byte z) {

	*xr = x;
	*yr = y;
	*zr = z;

	asm {
			clc
			ldx zr //z
			// C*z 
			lda #$80
		C1:	adc mulf_sqr1,x
		C2: sbc mulf_sqr2,x
			sta C3+1
			// F*z 
			lda #$80
		F1:	adc mulf_sqr1,x
		F2: sbc mulf_sqr2,x
			sta F3+1
			// I*z 
			lda #$80
		I1:	adc mulf_sqr1,x
		I2: sbc mulf_sqr2,x
			sta I3+1

			ldx xr //x
			ldy yr //y

		C3: lda #0 // C*z
		A1:	adc mulf_sqr1,x
		A2: sbc mulf_sqr2,x
		B1:	adc mulf_sqr1,y
		B2: sbc mulf_sqr2,y
			sta xr

		F3: lda #0 // F*z
		D1:	adc mulf_sqr1,x
		D2: sbc mulf_sqr2,x
		E1:	adc mulf_sqr1,y
		E2: sbc mulf_sqr2,y
			sta yr

		I3: lda #0 // I*z
		G1:	adc mulf_sqr1,x
		G2: sbc mulf_sqr2,x
		H1:	adc mulf_sqr1,y
		H2: sbc mulf_sqr2,y		
			sta zr
	}

}