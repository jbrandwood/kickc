Loading link script "xmega65.ld"
Inlined call call __init
Eliminating unused variable with no statement memset::$2

CONTROL FLOW GRAPH SSA

void * memset(void *str , char c , unsigned int num)
memset: scope:[memset]  from main main::@7
  memset::c#5 = phi( main/memset::c#0, main::@7/memset::c#1 )
  memset::str#4 = phi( main/memset::str#0, main::@7/memset::str#1 )
  memset::num#2 = phi( main/memset::num#0, main::@7/memset::num#1 )
  memset::$0 = memset::num#2 > 0
  memset::$1 = ! memset::$0
  if(memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@3
  memset::str#2 = phi( memset/memset::str#4, memset::@3/memset::str#5 )
  memset::return#0 = memset::str#2
  to:memset::@return
memset::@2: scope:[memset]  from memset
  memset::c#4 = phi( memset/memset::c#5 )
  memset::num#3 = phi( memset/memset::num#2 )
  memset::str#3 = phi( memset/memset::str#4 )
  memset::$4 = (char *)memset::str#3
  memset::end#0 = memset::$4 + memset::num#3
  memset::dst#0 = ((char *)) memset::str#3
  to:memset::@3
memset::@3: scope:[memset]  from memset::@2 memset::@4
  memset::c#3 = phi( memset::@2/memset::c#4, memset::@4/memset::c#2 )
  memset::str#5 = phi( memset::@2/memset::str#3, memset::@4/memset::str#6 )
  memset::end#1 = phi( memset::@2/memset::end#0, memset::@4/memset::end#2 )
  memset::dst#2 = phi( memset::@2/memset::dst#0, memset::@4/memset::dst#1 )
  memset::$3 = memset::dst#2 != memset::end#1
  if(memset::$3) goto memset::@4
  to:memset::@1
memset::@4: scope:[memset]  from memset::@3
  memset::str#6 = phi( memset::@3/memset::str#5 )
  memset::end#2 = phi( memset::@3/memset::end#1 )
  memset::dst#3 = phi( memset::@3/memset::dst#2 )
  memset::c#2 = phi( memset::@3/memset::c#3 )
  *memset::dst#3 = memset::c#2
  memset::dst#1 = ++ memset::dst#3
  to:memset::@3
memset::@return: scope:[memset]  from memset::@1
  memset::return#4 = phi( memset::@1/memset::return#0 )
  memset::return#1 = memset::return#4
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  *VICII_MEMORY = $14
  memset::str#0 = (void *)SCREEN
  memset::c#0 = ' '
  memset::num#0 = $28*$19
  call memset
  memset::return#2 = memset::return#1
  to:main::@7
main::@7: scope:[main]  from main
  memset::str#1 = (void *)COLS
  memset::c#1 = WHITE
  memset::num#1 = $28*$19
  call memset
  memset::return#3 = memset::return#1
  to:main::@8
main::@8: scope:[main]  from main::@7
  main::sc#0 = SCREEN+$28
  main::msg#0 = MESSAGE
  to:main::@1
main::@1: scope:[main]  from main::@2 main::@8
  main::sc#3 = phi( main::@2/main::sc#1, main::@8/main::sc#0 )
  main::msg#2 = phi( main::@2/main::msg#1, main::@8/main::msg#0 )
  main::$5 = 0 != *main::msg#2
  if(main::$5) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  main::sc#2 = phi( main::@1/main::sc#3 )
  main::msg#3 = phi( main::@1/main::msg#2 )
  *main::sc#2 = *main::msg#3
  main::sc#1 = ++ main::sc#2
  main::msg#1 = ++ main::msg#3
  to:main::@1
main::@3: scope:[main]  from main::@1 main::@5 main::@6
  if(true) goto main::@4
  to:main::@return
main::@4: scope:[main]  from main::@3
  main::$2 = *RASTER == $36
  main::$3 = *RASTER == $42
  main::$4 = main::$2 || main::$3
  if(main::$4) goto main::@5
  to:main::@6
main::@5: scope:[main]  from main::@4
  *BG_COLOR = WHITE
  to:main::@3
main::@6: scope:[main]  from main::@4
  *BG_COLOR = BLACK
  to:main::@3
main::@return: scope:[main]  from main::@3
  return 
  to:@return

void syscall1()
syscall1: scope:[syscall1]  from
  *(SCREEN+$4f) = '>'
  to:syscall1::@return
syscall1::@return: scope:[syscall1]  from syscall1
  return 
  to:@return

void syscall2()
syscall2: scope:[syscall2]  from
  *(SCREEN+$4e) = '<'
  to:syscall2::@return
syscall2::@return: scope:[syscall2]  from syscall2
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
__constant char * const BG_COLOR = (char *)$d021
__constant const char BLACK = 0
__constant char * const COLS = (char *)$d800
__constant const char JMP = $4c
__constant char MESSAGE[] = "hello world!"
__constant const char NOP = $ea
__constant char * const RASTER = (char *)$d012
__constant char * const SCREEN = (char *)$400
__constant struct SysCall SYSCALLS[] = { { xjmp: JMP, syscall: &syscall1, xnop: NOP }, { xjmp: JMP, syscall: &syscall2, xnop: NOP } }
__constant struct SysCall SYSCALL_RESET[] = { { xjmp: JMP, syscall: &main, xnop: NOP } }
__constant char * const VICII_MEMORY = (char *)$d018
__constant const char WHITE = 1
void __start()
void main()
bool main::$2
bool main::$3
bool main::$4
bool main::$5
char *main::msg
char *main::msg#0
char *main::msg#1
char *main::msg#2
char *main::msg#3
char *main::sc
char *main::sc#0
char *main::sc#1
char *main::sc#2
char *main::sc#3
void * memset(void *str , char c , unsigned int num)
bool memset::$0
bool memset::$1
bool memset::$3
char *memset::$4
char memset::c
char memset::c#0
char memset::c#1
char memset::c#2
char memset::c#3
char memset::c#4
char memset::c#5
char *memset::dst
char *memset::dst#0
char *memset::dst#1
char *memset::dst#2
char *memset::dst#3
char *memset::end
char *memset::end#0
char *memset::end#1
char *memset::end#2
unsigned int memset::num
unsigned int memset::num#0
unsigned int memset::num#1
unsigned int memset::num#2
unsigned int memset::num#3
void *memset::return
void *memset::return#0
void *memset::return#1
void *memset::return#2
void *memset::return#3
void *memset::return#4
void *memset::str
void *memset::str#0
void *memset::str#1
void *memset::str#2
void *memset::str#3
void *memset::str#4
void *memset::str#5
void *memset::str#6
void syscall1()
void syscall2()

Adding number conversion cast (unumber) 0 in memset::$0 = memset::num#2 > 0
Adding number conversion cast (unumber) $14 in *VICII_MEMORY = $14
Adding number conversion cast (unumber) $28*$19 in memset::num#0 = $28*$19
Adding number conversion cast (unumber) $28*$19 in memset::num#1 = $28*$19
Adding number conversion cast (unumber) $28 in main::sc#0 = SCREEN+$28
Adding number conversion cast (unumber) 0 in main::$5 = 0 != *main::msg#2
Adding number conversion cast (unumber) $36 in main::$2 = *RASTER == $36
Adding number conversion cast (unumber) $42 in main::$3 = *RASTER == $42
Adding number conversion cast (unumber) $4f in *(SCREEN+$4f) = '>'
Adding number conversion cast (unumber) $4e in *(SCREEN+$4e) = '<'
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast memset::dst#0 = (char *)memset::str#3
Inlining cast *VICII_MEMORY = (unumber)$14
Inlining cast memset::num#0 = (unumber)$28*$19
Inlining cast memset::num#1 = (unumber)$28*$19
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (char *) 53266
Simplifying constant pointer cast (char *) 53272
Simplifying constant pointer cast (char *) 1024
Simplifying constant pointer cast (char *) 53281
Simplifying constant pointer cast (char *) 55296
Simplifying constant integer cast 0
Simplifying constant integer cast $14
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast $36
Simplifying constant integer cast $42
Simplifying constant integer cast $4f
Simplifying constant integer cast $4e
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $14
Finalized unsigned number type (char) $28
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $36
Finalized unsigned number type (char) $42
Finalized unsigned number type (char) $4f
Finalized unsigned number type (char) $4e
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inversing boolean not [2] memset::$1 = memset::num#2 <= 0 from [1] memset::$0 = memset::num#2 > 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias memset::return#0 = memset::str#2 memset::return#4 memset::return#1 
Alias memset::str#3 = memset::str#4 
Alias memset::num#2 = memset::num#3 
Alias memset::c#4 = memset::c#5 
Alias memset::c#2 = memset::c#3 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#5 = memset::str#6 
Alias main::msg#2 = main::msg#3 
Alias main::sc#2 = main::sc#3 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values memset::end#1 memset::end#0
Identical Phi Values memset::str#5 memset::str#3
Identical Phi Values memset::c#2 memset::c#4
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values memset::return#0 memset::str#3
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition memset::$1 [2] if(memset::num#2<=0) goto memset::@1
Simple Condition memset::$3 [9] if(memset::dst#2!=memset::end#0) goto memset::@4
Simple Condition main::$5 [28] if(0!=*main::msg#2) goto main::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting || if()-condition to two if()s [35] main::$4 = main::$2 || main::$3
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant right-side identified [16] memset::num#0 = (unumber)$28*$19
Constant right-side identified [21] memset::num#1 = (unumber)$28*$19
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memset::str#0 = (void *)SCREEN
Constant memset::c#0 = ' '
Constant memset::num#0 = (unumber)$28*$19
Constant memset::str#1 = (void *)COLS
Constant memset::c#1 = WHITE
Constant memset::num#1 = (unumber)$28*$19
Constant main::sc#0 = SCREEN+$28
Constant main::msg#0 = MESSAGE
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [32] if(true) goto main::@4
Successful SSA optimization Pass2ConstantIfs
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused variable memset::return#2 and assignment [12] memset::return#2 = memset::str#3
Eliminating unused variable memset::return#3 and assignment [14] memset::return#3 = memset::str#3
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Simple Condition main::$2 [20] if(*RASTER==$36) goto main::@5
Simple Condition main::$3 [23] if(*RASTER==$42) goto main::@5
Successful SSA optimization Pass2ConditionalJumpSimplification
Inlining Noop Cast [2] memset::$4 = (char *)memset::str#3 keeping memset::str#3
Inlining Noop Cast [4] memset::dst#0 = (char *)memset::str#3 keeping memset::str#3
Successful SSA optimization Pass2NopCastInlining
Inlining constant with var siblings memset::str#0
Inlining constant with var siblings memset::c#0
Inlining constant with var siblings memset::num#0
Inlining constant with var siblings memset::str#1
Inlining constant with var siblings memset::c#1
Inlining constant with var siblings memset::num#1
Inlining constant with var siblings main::sc#0
Inlining constant with var siblings main::msg#0
Constant inlined memset::str#1 = (void *)COLS
Constant inlined memset::str#0 = (void *)SCREEN
Constant inlined main::msg#0 = MESSAGE
Constant inlined memset::num#1 = (unsigned int)$28*$19
Constant inlined main::sc#0 = SCREEN+$28
Constant inlined memset::c#0 = ' '
Constant inlined memset::num#0 = (unsigned int)$28*$19
Constant inlined memset::c#1 = WHITE
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values memset::num#2 (unsigned int)$28*$19
Successful SSA optimization Pass2IdenticalPhiElimination
if() condition always false - eliminating [1] if((unsigned int)$28*$19<=0) goto memset::@1
Successful SSA optimization Pass2ConstantIfs
Finalized unsigned number type (char) $28
Finalized unsigned number type (char) $19
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of memset::@1
CALL GRAPH
Calls in [main] to memset:5 memset:7 

Created 5 initial phi equivalence classes
Coalesced [19] main::msg#4 = main::msg#1
Coalesced [20] main::sc#4 = main::sc#1
Coalesced [30] memset::dst#5 = memset::dst#1
Coalesced down to 5 phi equivalence classes
Culled Empty Block label main::@8
Culled Empty Block label main::@3
Culled Empty Block label memset::@1
Renumbering block memset::@2 to memset::@1
Renumbering block memset::@3 to memset::@2
Renumbering block memset::@4 to memset::@3
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block main::@6 to main::@5
Renumbering block main::@7 to main::@6
Renumbering block main::@9 to main::@7
Adding NOP phi() at start of main::@6

FINAL CONTROL FLOW GRAPH

void syscall2()
syscall2: scope:[syscall2]  from
  [0] *(SCREEN+$4e) = '<'
  to:syscall2::@return
syscall2::@return: scope:[syscall2]  from syscall2
  [1] return 
  to:@return

void syscall1()
syscall1: scope:[syscall1]  from
  [2] *(SCREEN+$4f) = '>'
  to:syscall1::@return
syscall1::@return: scope:[syscall1]  from syscall1
  [3] return 
  to:@return

void main()
main: scope:[main]  from
  [4] *VICII_MEMORY = $14
  [5] call memset
  to:main::@6
main::@6: scope:[main]  from main
  [6] phi()
  [7] call memset
  to:main::@1
main::@1: scope:[main]  from main::@2 main::@6
  [8] main::sc#2 = phi( main::@2/main::sc#1, main::@6/SCREEN+$28 )
  [8] main::msg#2 = phi( main::@2/main::msg#1, main::@6/MESSAGE )
  [9] if(0!=*main::msg#2) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1 main::@4 main::@5
  [10] if(*RASTER==$36) goto main::@4
  to:main::@7
main::@7: scope:[main]  from main::@3
  [11] if(*RASTER==$42) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@7
  [12] *BG_COLOR = BLACK
  to:main::@3
main::@4: scope:[main]  from main::@3 main::@7
  [13] *BG_COLOR = WHITE
  to:main::@3
main::@2: scope:[main]  from main::@1
  [14] *main::sc#2 = *main::msg#2
  [15] main::sc#1 = ++ main::sc#2
  [16] main::msg#1 = ++ main::msg#2
  to:main::@1

void * memset(void *str , char c , unsigned int num)
memset: scope:[memset]  from main main::@6
  [17] memset::c#4 = phi( main/' ', main::@6/WHITE )
  [17] memset::str#3 = phi( main/(void *)SCREEN, main::@6/(void *)COLS )
  to:memset::@1
memset::@1: scope:[memset]  from memset
  [18] memset::end#0 = (char *)memset::str#3 + (unsigned int)$28*$19
  [19] memset::dst#4 = (char *)memset::str#3
  to:memset::@2
memset::@2: scope:[memset]  from memset::@1 memset::@3
  [20] memset::dst#2 = phi( memset::@1/memset::dst#4, memset::@3/memset::dst#1 )
  [21] if(memset::dst#2!=memset::end#0) goto memset::@3
  to:memset::@return
memset::@return: scope:[memset]  from memset::@2
  [22] return 
  to:@return
memset::@3: scope:[memset]  from memset::@2
  [23] *memset::dst#2 = memset::c#4
  [24] memset::dst#1 = ++ memset::dst#2
  to:memset::@2


VARIABLE REGISTER WEIGHTS
void main()
char *main::msg
char *main::msg#1 // 22.0
char *main::msg#2 // 11.0
char *main::sc
char *main::sc#1 // 11.0
char *main::sc#2 // 11.0
void * memset(void *str , char c , unsigned int num)
char memset::c
char memset::c#4 // 14.428571428571429
char *memset::dst
char *memset::dst#1 // 202.0
char *memset::dst#2 // 138.33333333333331
char *memset::dst#4 // 22.0
char *memset::end
char *memset::end#0 // 18.666666666666664
unsigned int memset::num
void *memset::return
void *memset::str
void *memset::str#3
void syscall1()
void syscall2()

Initial phi equivalence classes
[ main::msg#2 main::msg#1 ]
[ main::sc#2 main::sc#1 ]
[ memset::str#3 ]
[ memset::c#4 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
Added variable memset::end#0 to live range equivalence class [ memset::end#0 ]
Complete equivalence classes
[ main::msg#2 main::msg#1 ]
[ main::sc#2 main::sc#1 ]
[ memset::str#3 ]
[ memset::c#4 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
[ memset::end#0 ]
Allocated zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ]
Allocated zp[2]:4 [ main::msg#2 main::msg#1 ]
Allocated zp[2]:6 [ main::sc#2 main::sc#1 ]
Allocated zp[2]:8 [ memset::end#0 ]
Allocated zp[1]:10 [ memset::c#4 ]
Allocated zp[2]:11 [ memset::str#3 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] *(SCREEN+$4e) = '<' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] *(SCREEN+$4f) = '>' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] *VICII_MEMORY = $14 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] if(0!=*main::msg#2) goto main::@2 [ main::msg#2 main::sc#2 ] (  [ main::msg#2 main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [10] if(*RASTER==$36) goto main::@4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [11] if(*RASTER==$42) goto main::@4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [12] *BG_COLOR = BLACK [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [13] *BG_COLOR = WHITE [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [14] *main::sc#2 = *main::msg#2 [ main::msg#2 main::sc#2 ] (  [ main::msg#2 main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [18] memset::end#0 = (char *)memset::str#3 + (unsigned int)$28*$19 [ memset::str#3 memset::c#4 memset::end#0 ] ( memset:5 [ memset::str#3 memset::c#4 memset::end#0 ] { }  memset:7 [ memset::str#3 memset::c#4 memset::end#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ memset::c#4 ]
Statement [19] memset::dst#4 = (char *)memset::str#3 [ memset::c#4 memset::end#0 memset::dst#4 ] ( memset:5 [ memset::c#4 memset::end#0 memset::dst#4 ] { }  memset:7 [ memset::c#4 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [21] if(memset::dst#2!=memset::end#0) goto memset::@3 [ memset::c#4 memset::end#0 memset::dst#2 ] ( memset:5 [ memset::c#4 memset::end#0 memset::dst#2 ] { }  memset:7 [ memset::c#4 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [23] *memset::dst#2 = memset::c#4 [ memset::c#4 memset::end#0 memset::dst#2 ] ( memset:5 [ memset::c#4 memset::end#0 memset::dst#2 ] { }  memset:7 [ memset::c#4 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:10 [ memset::c#4 ]
Statement [0] *(SCREEN+$4e) = '<' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] *(SCREEN+$4f) = '>' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] *VICII_MEMORY = $14 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] if(0!=*main::msg#2) goto main::@2 [ main::msg#2 main::sc#2 ] (  [ main::msg#2 main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [10] if(*RASTER==$36) goto main::@4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [11] if(*RASTER==$42) goto main::@4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [12] *BG_COLOR = BLACK [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [13] *BG_COLOR = WHITE [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [14] *main::sc#2 = *main::msg#2 [ main::msg#2 main::sc#2 ] (  [ main::msg#2 main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [18] memset::end#0 = (char *)memset::str#3 + (unsigned int)$28*$19 [ memset::str#3 memset::c#4 memset::end#0 ] ( memset:5 [ memset::str#3 memset::c#4 memset::end#0 ] { }  memset:7 [ memset::str#3 memset::c#4 memset::end#0 ] { }  ) always clobbers reg byte a 
Statement [19] memset::dst#4 = (char *)memset::str#3 [ memset::c#4 memset::end#0 memset::dst#4 ] ( memset:5 [ memset::c#4 memset::end#0 memset::dst#4 ] { }  memset:7 [ memset::c#4 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [21] if(memset::dst#2!=memset::end#0) goto memset::@3 [ memset::c#4 memset::end#0 memset::dst#2 ] ( memset:5 [ memset::c#4 memset::end#0 memset::dst#2 ] { }  memset:7 [ memset::c#4 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [23] *memset::dst#2 = memset::c#4 [ memset::c#4 memset::end#0 memset::dst#2 ] ( memset:5 [ memset::c#4 memset::end#0 memset::dst#2 ] { }  memset:7 [ memset::c#4 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Potential registers zp[2]:4 [ main::msg#2 main::msg#1 ] : zp[2]:4 , 
Potential registers zp[2]:6 [ main::sc#2 main::sc#1 ] : zp[2]:6 , 
Potential registers zp[2]:11 [ memset::str#3 ] : zp[2]:11 , 
Potential registers zp[1]:10 [ memset::c#4 ] : zp[1]:10 , reg byte x , 
Potential registers zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ] : zp[2]:2 , 
Potential registers zp[2]:8 [ memset::end#0 ] : zp[2]:8 , 

REGISTER UPLIFT SCOPES
Uplift Scope [memset] 362.33: zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ] 18.67: zp[2]:8 [ memset::end#0 ] 14.43: zp[1]:10 [ memset::c#4 ] 0: zp[2]:11 [ memset::str#3 ] 
Uplift Scope [main] 33: zp[2]:4 [ main::msg#2 main::msg#1 ] 22: zp[2]:6 [ main::sc#2 main::sc#1 ] 
Uplift Scope [syscall1] 
Uplift Scope [syscall2] 
Uplift Scope [SysCall] 
Uplift Scope [] 

Uplifting [memset] best 1851 combination zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ] zp[2]:8 [ memset::end#0 ] reg byte x [ memset::c#4 ] zp[2]:11 [ memset::str#3 ] 
Uplifting [main] best 1851 combination zp[2]:4 [ main::msg#2 main::msg#1 ] zp[2]:6 [ main::sc#2 main::sc#1 ] 
Uplifting [syscall1] best 1851 combination 
Uplifting [syscall2] best 1851 combination 
Uplifting [SysCall] best 1851 combination 
Uplifting [] best 1851 combination 
Coalescing zero page register [ zp[2]:11 [ memset::str#3 ] ] with [ zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ] ] - score: 1
Allocated (was zp[2]:11) zp[2]:2 [ memset::str#3 memset::dst#2 memset::dst#4 memset::dst#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// XMega65 Kernal Development Template
// Each function of the kernal is a no-args function
// The functions are placed in the SYSCALLS table surrounded by JMP and NOP
  // Upstart
  .file [name="xmega65.bin", type="bin", segments="XMega65Bin"]
.segmentdef XMega65Bin [segments="Syscall, Code, Data, Stack, Zeropage"]
.segmentdef Syscall [start=$8000, max=$81ff]
.segmentdef Code [start=$8200, min=$8200, max=$bdff]
.segmentdef Data [startAfter="Code", min=$8200, max=$bdff]
.segmentdef Stack [min=$be00, max=$beff, fill]
.segmentdef Zeropage [min=$bf00, max=$bfff, fill]
  // Global Constants & labels
  .const BLACK = 0
  .const WHITE = 1
  .const JMP = $4c
  .const NOP = $ea
  .label RASTER = $d012
  .label VICII_MEMORY = $d018
  .label SCREEN = $400
  .label BG_COLOR = $d021
  .label COLS = $d800
.segment Code
  // syscall2
syscall2: {
    // [0] *(SCREEN+$4e) = '<' -- _deref_pbuc1=vbuc2 
    lda #'<'
    sta SCREEN+$4e
    jmp __breturn
    // syscall2::@return
  __breturn:
    // [1] return 
    rts
}
  // syscall1
syscall1: {
    // [2] *(SCREEN+$4f) = '>' -- _deref_pbuc1=vbuc2 
    lda #'>'
    sta SCREEN+$4f
    jmp __breturn
    // syscall1::@return
  __breturn:
    // [3] return 
    rts
}
  // main
main: {
    // Print message
    .label sc = 6
    .label msg = 4
    // [4] *VICII_MEMORY = $14 -- _deref_pbuc1=vbuc2 
    // Initialize screen memory
    lda #$14
    sta VICII_MEMORY
    // [5] call memset
  // Init screen/colors
    // [17] phi from main to memset [phi:main->memset]
  memset_from_main:
    // [17] phi memset::c#4 = ' ' [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #' '
    // [17] phi memset::str#3 = (void *)SCREEN [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<SCREEN
    sta.z memset.str
    lda #>SCREEN
    sta.z memset.str+1
    jsr memset
    // [6] phi from main to main::@6 [phi:main->main::@6]
  __b6_from_main:
    jmp __b6
    // main::@6
  __b6:
    // [7] call memset
    // [17] phi from main::@6 to memset [phi:main::@6->memset]
  memset_from___b6:
    // [17] phi memset::c#4 = WHITE [phi:main::@6->memset#0] -- vbuxx=vbuc1 
    ldx #WHITE
    // [17] phi memset::str#3 = (void *)COLS [phi:main::@6->memset#1] -- pvoz1=pvoc1 
    lda #<COLS
    sta.z memset.str
    lda #>COLS
    sta.z memset.str+1
    jsr memset
    // [8] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
  __b1_from___b6:
    // [8] phi main::sc#2 = SCREEN+$28 [phi:main::@6->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$28
    sta.z sc
    lda #>SCREEN+$28
    sta.z sc+1
    // [8] phi main::msg#2 = MESSAGE [phi:main::@6->main::@1#1] -- pbuz1=pbuc1 
    lda #<MESSAGE
    sta.z msg
    lda #>MESSAGE
    sta.z msg+1
    jmp __b1
    // main::@1
  __b1:
    // [9] if(0!=*main::msg#2) goto main::@2 -- 0_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (msg),y
    cmp #0
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [10] if(*RASTER==$36) goto main::@4 -- _deref_pbuc1_eq_vbuc2_then_la1 
    lda #$36
    cmp RASTER
    beq __b4
    jmp __b7
    // main::@7
  __b7:
    // [11] if(*RASTER==$42) goto main::@4 -- _deref_pbuc1_eq_vbuc2_then_la1 
    lda #$42
    cmp RASTER
    beq __b4
    jmp __b5
    // main::@5
  __b5:
    // [12] *BG_COLOR = BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BG_COLOR
    jmp __b3
    // main::@4
  __b4:
    // [13] *BG_COLOR = WHITE -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BG_COLOR
    jmp __b3
    // main::@2
  __b2:
    // [14] *main::sc#2 = *main::msg#2 -- _deref_pbuz1=_deref_pbuz2 
    ldy #0
    lda (msg),y
    ldy #0
    sta (sc),y
    // [15] main::sc#1 = ++ main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [16] main::msg#1 = ++ main::msg#2 -- pbuz1=_inc_pbuz1 
    inc.z msg
    bne !+
    inc.z msg+1
  !:
    // [8] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [8] phi main::sc#2 = main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    // [8] phi main::msg#2 = main::msg#1 [phi:main::@2->main::@1#1] -- register_copy 
    jmp __b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// void * memset(__zp(2) void *str, __register(X) char c, unsigned int num)
memset: {
    .label end = 8
    .label dst = 2
    .label str = 2
    jmp __b1
    // memset::@1
  __b1:
    // [18] memset::end#0 = (char *)memset::str#3 + (unsigned int)$28*$19 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$28*$19
    sta.z end
    lda.z str+1
    adc #>$28*$19
    sta.z end+1
    // [19] memset::dst#4 = (char *)memset::str#3
    // [20] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  __b2_from___b1:
  __b2_from___b3:
    // [20] phi memset::dst#2 = memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp __b2
    // memset::@2
  __b2:
    // [21] if(memset::dst#2!=memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    jmp __breturn
    // memset::@return
  __breturn:
    // [22] return 
    rts
    // memset::@3
  __b3:
    // [23] *memset::dst#2 = memset::c#4 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // [24] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2_from___b3
}
  // File Data
.segment Data
  MESSAGE: .text "hello world!"
  .byte 0
.segment Syscall
  SYSCALLS: .byte JMP
  .word syscall1
  .byte NOP, JMP
  .word syscall2
  .byte NOP
  .align $100
  SYSCALL_RESET: .byte JMP
  .word main
  .byte NOP

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b6
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b7
Removing instruction jmp __b5
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b2_from___b3 with __b2
Removing instruction __b6_from_main:
Removing instruction memset_from___b6:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction memset_from_main:
Removing instruction __b6:
Removing instruction __b1_from___b6:
Removing instruction __b7:
Removing instruction __b5:
Removing instruction __b1_from___b2:
Removing instruction __b1:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
__constant char * const BG_COLOR = (char *) 53281
__constant const char BLACK = 0
__constant char * const COLS = (char *) 55296
__constant const char JMP = $4c
__constant char MESSAGE[] = "hello world!"
__constant const char NOP = $ea
__constant char * const RASTER = (char *) 53266
__constant char * const SCREEN = (char *) 1024
__constant struct SysCall SYSCALLS[] = { { xjmp: JMP, syscall: &syscall1, xnop: NOP }, { xjmp: JMP, syscall: &syscall2, xnop: NOP } }
__constant struct SysCall SYSCALL_RESET[] = { { xjmp: JMP, syscall: &main, xnop: NOP } }
__constant char * const VICII_MEMORY = (char *) 53272
__constant const char WHITE = 1
void main()
char *main::msg
char *main::msg#1 // msg zp[2]:4 22.0
char *main::msg#2 // msg zp[2]:4 11.0
char *main::sc
char *main::sc#1 // sc zp[2]:6 11.0
char *main::sc#2 // sc zp[2]:6 11.0
void * memset(void *str , char c , unsigned int num)
char memset::c
char memset::c#4 // reg byte x 14.428571428571429
char *memset::dst
char *memset::dst#1 // dst zp[2]:2 202.0
char *memset::dst#2 // dst zp[2]:2 138.33333333333331
char *memset::dst#4 // dst zp[2]:2 22.0
char *memset::end
char *memset::end#0 // end zp[2]:8 18.666666666666664
unsigned int memset::num
void *memset::return
void *memset::str
void *memset::str#3 // str zp[2]:2
void syscall1()
void syscall2()

zp[2]:4 [ main::msg#2 main::msg#1 ]
zp[2]:6 [ main::sc#2 main::sc#1 ]
zp[2]:2 [ memset::str#3 memset::dst#2 memset::dst#4 memset::dst#1 ]
reg byte x [ memset::c#4 ]
zp[2]:8 [ memset::end#0 ]


FINAL ASSEMBLER
Score: 1600

  // File Comments
// XMega65 Kernal Development Template
// Each function of the kernal is a no-args function
// The functions are placed in the SYSCALLS table surrounded by JMP and NOP
  // Upstart
  .file [name="xmega65.bin", type="bin", segments="XMega65Bin"]
.segmentdef XMega65Bin [segments="Syscall, Code, Data, Stack, Zeropage"]
.segmentdef Syscall [start=$8000, max=$81ff]
.segmentdef Code [start=$8200, min=$8200, max=$bdff]
.segmentdef Data [startAfter="Code", min=$8200, max=$bdff]
.segmentdef Stack [min=$be00, max=$beff, fill]
.segmentdef Zeropage [min=$bf00, max=$bfff, fill]
  // Global Constants & labels
  .const BLACK = 0
  .const WHITE = 1
  .const JMP = $4c
  .const NOP = $ea
  .label RASTER = $d012
  .label VICII_MEMORY = $d018
  .label SCREEN = $400
  .label BG_COLOR = $d021
  .label COLS = $d800
.segment Code
  // syscall2
syscall2: {
    // *(SCREEN+78) = '<'
    // [0] *(SCREEN+$4e) = '<' -- _deref_pbuc1=vbuc2 
    lda #'<'
    sta SCREEN+$4e
    // syscall2::@return
    // }
    // [1] return 
    rts
}
  // syscall1
syscall1: {
    // *(SCREEN+79) = '>'
    // [2] *(SCREEN+$4f) = '>' -- _deref_pbuc1=vbuc2 
    lda #'>'
    sta SCREEN+$4f
    // syscall1::@return
    // }
    // [3] return 
    rts
}
  // main
main: {
    // Print message
    .label sc = 6
    .label msg = 4
    // *VICII_MEMORY = 0x14
    // [4] *VICII_MEMORY = $14 -- _deref_pbuc1=vbuc2 
    // Initialize screen memory
    lda #$14
    sta VICII_MEMORY
    // memset(SCREEN, ' ', 40*25)
    // [5] call memset
  // Init screen/colors
    // [17] phi from main to memset [phi:main->memset]
    // [17] phi memset::c#4 = ' ' [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #' '
    // [17] phi memset::str#3 = (void *)SCREEN [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<SCREEN
    sta.z memset.str
    lda #>SCREEN
    sta.z memset.str+1
    jsr memset
    // [6] phi from main to main::@6 [phi:main->main::@6]
    // main::@6
    // memset(COLS, WHITE, 40*25)
    // [7] call memset
    // [17] phi from main::@6 to memset [phi:main::@6->memset]
    // [17] phi memset::c#4 = WHITE [phi:main::@6->memset#0] -- vbuxx=vbuc1 
    ldx #WHITE
    // [17] phi memset::str#3 = (void *)COLS [phi:main::@6->memset#1] -- pvoz1=pvoc1 
    lda #<COLS
    sta.z memset.str
    lda #>COLS
    sta.z memset.str+1
    jsr memset
    // [8] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
    // [8] phi main::sc#2 = SCREEN+$28 [phi:main::@6->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$28
    sta.z sc
    lda #>SCREEN+$28
    sta.z sc+1
    // [8] phi main::msg#2 = MESSAGE [phi:main::@6->main::@1#1] -- pbuz1=pbuc1 
    lda #<MESSAGE
    sta.z msg
    lda #>MESSAGE
    sta.z msg+1
    // main::@1
  __b1:
    // while(*msg)
    // [9] if(0!=*main::msg#2) goto main::@2 -- 0_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (msg),y
    cmp #0
    bne __b2
    // main::@3
  __b3:
    // if(*RASTER==54 || *RASTER==66)
    // [10] if(*RASTER==$36) goto main::@4 -- _deref_pbuc1_eq_vbuc2_then_la1 
    lda #$36
    cmp RASTER
    beq __b4
    // main::@7
    // [11] if(*RASTER==$42) goto main::@4 -- _deref_pbuc1_eq_vbuc2_then_la1 
    lda #$42
    cmp RASTER
    beq __b4
    // main::@5
    // *BG_COLOR = BLACK
    // [12] *BG_COLOR = BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BG_COLOR
    jmp __b3
    // main::@4
  __b4:
    // *BG_COLOR = WHITE
    // [13] *BG_COLOR = WHITE -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BG_COLOR
    jmp __b3
    // main::@2
  __b2:
    // *sc++ = *msg++
    // [14] *main::sc#2 = *main::msg#2 -- _deref_pbuz1=_deref_pbuz2 
    ldy #0
    lda (msg),y
    sta (sc),y
    // *sc++ = *msg++;
    // [15] main::sc#1 = ++ main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [16] main::msg#1 = ++ main::msg#2 -- pbuz1=_inc_pbuz1 
    inc.z msg
    bne !+
    inc.z msg+1
  !:
    // [8] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [8] phi main::sc#2 = main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    // [8] phi main::msg#2 = main::msg#1 [phi:main::@2->main::@1#1] -- register_copy 
    jmp __b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// void * memset(__zp(2) void *str, __register(X) char c, unsigned int num)
memset: {
    .label end = 8
    .label dst = 2
    .label str = 2
    // memset::@1
    // char* end = (char*)str + num
    // [18] memset::end#0 = (char *)memset::str#3 + (unsigned int)$28*$19 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$28*$19
    sta.z end
    lda.z str+1
    adc #>$28*$19
    sta.z end+1
    // [19] memset::dst#4 = (char *)memset::str#3
    // [20] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
    // [20] phi memset::dst#2 = memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    // memset::@2
  __b2:
    // for(char* dst = str; dst!=end; dst++)
    // [21] if(memset::dst#2!=memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    // memset::@return
    // }
    // [22] return 
    rts
    // memset::@3
  __b3:
    // *dst = c
    // [23] *memset::dst#2 = memset::c#4 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [24] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2
}
  // File Data
.segment Data
  MESSAGE: .text "hello world!"
  .byte 0
.segment Syscall
  SYSCALLS: .byte JMP
  .word syscall1
  .byte NOP, JMP
  .word syscall2
  .byte NOP
  .align $100
  SYSCALL_RESET: .byte JMP
  .word main
  .byte NOP

