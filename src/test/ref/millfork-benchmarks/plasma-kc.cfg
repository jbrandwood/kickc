
(void()) __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] (volatile word) last_time ← (word) 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [2] phi()
  [3] call main 
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [4] return 
  to:@return

(signed word()) main()
main: scope:[main]  from __start::@1
  [5] phi()
  [6] call makechar 
  to:main::@4
main::@4: scope:[main]  from main
  [7] phi()
  [8] call start 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [9] (byte) main::block#1 ← *((byte*)(const nomodify struct MOS6526_CIA*) CIA2)
  [10] (byte) main::tmp#1 ← (byte) main::block#1 & (byte) $fc
  [11] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2) ← (byte) main::tmp#1
  [12] (byte) main::v#1 ← *((const nomodify byte*) VIC_MEMORY)
  to:main::@1
main::@1: scope:[main]  from main::@5 main::@7
  [13] (word) main::count#2 ← phi( main::@5/(word) $1f4 main::@7/(word) main::count#1 )
  [14] if((byte) 0!=(word) main::count#2) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [15] *((const nomodify byte*) VIC_MEMORY) ← (byte) main::v#1
  [16] *((byte*)(const nomodify struct MOS6526_CIA*) CIA2) ← (byte) main::block#1
  [17] call end 
  to:main::@return
main::@return: scope:[main]  from main::@3
  [18] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [19] phi()
  [20] call doplasma 
  to:main::@6
main::@6: scope:[main]  from main::@2
  [21] *((const nomodify byte*) VIC_MEMORY) ← (const nomodify byte) PAGE1
  [22] call doplasma 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [23] *((const nomodify byte*) VIC_MEMORY) ← (const nomodify byte) PAGE2
  [24] (word) main::count#1 ← -- (word) main::count#2
  to:main::@1

(void()) makechar()
makechar: scope:[makechar]  from main
  [25] phi()
  to:makechar::@1
makechar::@1: scope:[makechar]  from makechar makechar::@4
  [26] (word) rand_state#14 ← phi( makechar/(word) 1 makechar::@4/(word) rand_state#25 )
  [26] (word) makechar::c#3 ← phi( makechar/(byte) 0 makechar::@4/(word) makechar::c#2 )
  [27] if((word) makechar::c#3<(word) $100) goto makechar::@2
  to:makechar::@return
makechar::@return: scope:[makechar]  from makechar::@1
  [28] return 
  to:@return
makechar::@2: scope:[makechar]  from makechar::@1
  [29] (byte~) makechar::$9 ← (byte)(word) makechar::c#3
  [30] (byte) makechar::s#1 ← *((const to_nomodify byte*) sinustable + (byte~) makechar::$9)
  to:makechar::@3
makechar::@3: scope:[makechar]  from makechar::@2 makechar::@7
  [31] (word) rand_state#25 ← phi( makechar::@2/(word) rand_state#14 makechar::@7/(word) rand_state#19 )
  [31] (byte) makechar::i#3 ← phi( makechar::@2/(byte) 0 makechar::@7/(byte) makechar::i#2 )
  [32] if((byte) makechar::i#3<(byte) 8) goto makechar::@5
  to:makechar::@4
makechar::@4: scope:[makechar]  from makechar::@3
  [33] (word) makechar::c#2 ← ++ (word) makechar::c#3
  to:makechar::@1
makechar::@5: scope:[makechar]  from makechar::@3 makechar::@8
  [34] (word) rand_state#19 ← phi( makechar::@3/(word) rand_state#25 makechar::@8/(word) rand_state#12 )
  [34] (byte) makechar::b#3 ← phi( makechar::@3/(byte) 0 makechar::@8/(byte) makechar::b#7 )
  [34] (byte) makechar::ii#3 ← phi( makechar::@3/(byte) 0 makechar::@8/(byte) makechar::ii#2 )
  [35] if((byte) makechar::ii#3<(byte) 8) goto makechar::@6
  to:makechar::@7
makechar::@7: scope:[makechar]  from makechar::@5
  [36] (word~) makechar::$7 ← (word) makechar::c#3 << (byte) 3
  [37] (word~) makechar::$8 ← (word~) makechar::$7 + (byte) makechar::i#3
  [38] (byte*~) makechar::$10 ← (const nomodify byte*) CHARSET + (word~) makechar::$8
  [39] *((byte*~) makechar::$10) ← (byte) makechar::b#3
  [40] (byte) makechar::i#2 ← ++ (byte) makechar::i#3
  to:makechar::@3
makechar::@6: scope:[makechar]  from makechar::@5
  [41] phi()
  [42] call rand 
  [43] (word) rand::return#2 ← (word) rand::return#0
  to:makechar::@10
makechar::@10: scope:[makechar]  from makechar::@6
  [44] (word~) makechar::$3 ← (word) rand::return#2
  [45] (byte~) makechar::$4 ← (word~) makechar::$3 & (byte) $ff
  [46] if((byte~) makechar::$4<=(byte) makechar::s#1) goto makechar::@8
  to:makechar::@9
makechar::@9: scope:[makechar]  from makechar::@10
  [47] (byte) makechar::b#2 ← (byte) makechar::b#3 | *((const to_nomodify byte*) bittab + (byte) makechar::ii#3)
  to:makechar::@8
makechar::@8: scope:[makechar]  from makechar::@10 makechar::@9
  [48] (byte) makechar::b#7 ← phi( makechar::@9/(byte) makechar::b#2 makechar::@10/(byte) makechar::b#3 )
  [49] (byte) makechar::ii#2 ← ++ (byte) makechar::ii#3
  to:makechar::@5

(void()) start()
start: scope:[start]  from end main::@4
  asm { jsr$FFDE staLAST_TIME stxLAST_TIME+1  }
  to:start::@return
start::@return: scope:[start]  from start
  [51] return 
  to:@return

(void()) end()
end: scope:[end]  from main::@3
  [52] (word) Ticks#0 ← (volatile word) last_time
  [53] call start 
  to:end::@1
end::@1: scope:[end]  from end
  [54] (volatile word) last_time ← (volatile word) last_time - (word) Ticks#0
  [55] (word) Ticks#1 ← (volatile word) last_time
  [56] (word) print_uint::w#0 ← (word) Ticks#1
  [57] call print_uint 
  to:end::@2
end::@2: scope:[end]  from end::@1
  [58] phi()
  [59] call print_ln 
  to:end::@return
end::@return: scope:[end]  from end::@2
  [60] return 
  to:@return

(void()) doplasma((byte*) doplasma::scrn)
doplasma: scope:[doplasma]  from main::@2 main::@6
  [61] (byte*) doplasma::scrn#13 ← phi( main::@2/(const nomodify byte*) SCREEN1 main::@6/(const nomodify byte*) SCREEN2 )
  to:doplasma::@1
doplasma::@1: scope:[doplasma]  from doplasma doplasma::@2
  [62] (byte) doplasma::c1b#3 ← phi( doplasma/(byte) 0 doplasma::@2/(byte) doplasma::c1b#2 )
  [62] (byte) doplasma::c1a#3 ← phi( doplasma/(byte) 0 doplasma::@2/(byte) doplasma::c1a#2 )
  [62] (byte) doplasma::ii#3 ← phi( doplasma/(byte) 0 doplasma::@2/(byte) doplasma::ii#2 )
  [63] if((byte) doplasma::ii#3<(byte) $19) goto doplasma::@2
  to:doplasma::@3
doplasma::@3: scope:[doplasma]  from doplasma::@1 doplasma::@4
  [64] (byte) doplasma::c2b#3 ← phi( doplasma::@1/(const byte) doplasma::c2B#0 doplasma::@4/(byte) doplasma::c2b#2 )
  [64] (byte) doplasma::c2a#3 ← phi( doplasma::@1/(const byte) doplasma::c2A#0 doplasma::@4/(byte) doplasma::c2a#2 )
  [64] (byte) doplasma::i#3 ← phi( doplasma::@1/(byte) 0 doplasma::@4/(byte) doplasma::i#2 )
  [65] if((byte) doplasma::i#3<(byte) $28) goto doplasma::@4
  to:doplasma::@5
doplasma::@5: scope:[doplasma]  from doplasma::@3 doplasma::@8
  [66] (byte*) doplasma::scrn#6 ← phi( doplasma::@8/(byte*) doplasma::scrn#0 doplasma::@3/(byte*) doplasma::scrn#13 )
  [66] (byte) doplasma::jj#3 ← phi( doplasma::@8/(byte) doplasma::jj#2 doplasma::@3/(byte) 0 )
  [67] if((byte) doplasma::jj#3<(byte) $19) goto doplasma::@6
  to:doplasma::@return
doplasma::@return: scope:[doplasma]  from doplasma::@5
  [68] return 
  to:@return
doplasma::@6: scope:[doplasma]  from doplasma::@5 doplasma::@7
  [69] (byte) doplasma::j#3 ← phi( doplasma::@7/(byte) doplasma::j#2 doplasma::@5/(byte) 0 )
  [70] if((byte) doplasma::j#3<(byte) $28) goto doplasma::@7
  to:doplasma::@8
doplasma::@8: scope:[doplasma]  from doplasma::@6
  [71] (byte*) doplasma::scrn#0 ← (byte*) doplasma::scrn#6 + (byte) $28
  [72] (byte) doplasma::jj#2 ← ++ (byte) doplasma::jj#3
  to:doplasma::@5
doplasma::@7: scope:[doplasma]  from doplasma::@6
  [73] (byte~) doplasma::$6 ← *((const byte*) xbuf + (byte) doplasma::j#3) + *((const byte*) ybuf + (byte) doplasma::jj#3)
  [74] *((byte*) doplasma::scrn#6 + (byte) doplasma::j#3) ← (byte~) doplasma::$6
  [75] (byte) doplasma::j#2 ← ++ (byte) doplasma::j#3
  to:doplasma::@6
doplasma::@4: scope:[doplasma]  from doplasma::@3
  [76] (byte~) doplasma::$3 ← *((const to_nomodify byte*) sinustable + (byte) doplasma::c2a#3) + *((const to_nomodify byte*) sinustable + (byte) doplasma::c2b#3)
  [77] *((const byte*) xbuf + (byte) doplasma::i#3) ← (byte~) doplasma::$3
  [78] (byte) doplasma::c2a#2 ← (byte) doplasma::c2a#3 + (byte) 3
  [79] (byte) doplasma::c2b#2 ← (byte) doplasma::c2b#3 + (byte) 7
  [80] (byte) doplasma::i#2 ← ++ (byte) doplasma::i#3
  to:doplasma::@3
doplasma::@2: scope:[doplasma]  from doplasma::@1
  [81] (byte~) doplasma::$1 ← *((const to_nomodify byte*) sinustable + (byte) doplasma::c1a#3) + *((const to_nomodify byte*) sinustable + (byte) doplasma::c1b#3)
  [82] *((const byte*) ybuf + (byte) doplasma::ii#3) ← (byte~) doplasma::$1
  [83] (byte) doplasma::c1a#2 ← (byte) doplasma::c1a#3 + (byte) 4
  [84] (byte) doplasma::c1b#2 ← (byte) doplasma::c1b#3 + (byte) 9
  [85] (byte) doplasma::ii#2 ← ++ (byte) doplasma::ii#3
  to:doplasma::@1

(word()) rand()
rand: scope:[rand]  from makechar::@6
  [86] (word~) rand::$0 ← (word) rand_state#19 << (byte) 7
  [87] (word) rand_state#0 ← (word) rand_state#19 ^ (word~) rand::$0
  [88] (word~) rand::$1 ← (word) rand_state#0 >> (byte) 9
  [89] (word) rand_state#1 ← (word) rand_state#0 ^ (word~) rand::$1
  [90] (word~) rand::$2 ← (word) rand_state#1 << (byte) 8
  [91] (word) rand_state#12 ← (word) rand_state#1 ^ (word~) rand::$2
  [92] (word) rand::return#0 ← (word) rand_state#12
  to:rand::@return
rand::@return: scope:[rand]  from rand
  [93] return 
  to:@return

(void()) print_uint((word) print_uint::w)
print_uint: scope:[print_uint]  from end::@1
  [94] (byte) print_uchar::b#0 ← > (word) print_uint::w#0
  [95] call print_uchar 
  to:print_uint::@1
print_uint::@1: scope:[print_uint]  from print_uint
  [96] (byte) print_uchar::b#1 ← < (word) print_uint::w#0
  [97] call print_uchar 
  to:print_uint::@return
print_uint::@return: scope:[print_uint]  from print_uint::@1
  [98] return 
  to:@return

(void()) print_ln()
print_ln: scope:[print_ln]  from end::@2
  [99] phi()
  to:print_ln::@1
print_ln::@1: scope:[print_ln]  from print_ln print_ln::@1
  [100] (byte*) print_line_cursor#9 ← phi( print_ln/(const byte*) print_screen#0 print_ln::@1/(byte*) print_line_cursor#0 )
  [101] (byte*) print_line_cursor#0 ← (byte*) print_line_cursor#9 + (byte) $28
  [102] if((byte*) print_line_cursor#0<(byte*) print_char_cursor#27) goto print_ln::@1
  to:print_ln::@return
print_ln::@return: scope:[print_ln]  from print_ln::@1
  [103] return 
  to:@return

(void()) print_uchar((byte) print_uchar::b)
print_uchar: scope:[print_uchar]  from print_uint print_uint::@1
  [104] (byte*) print_char_cursor#37 ← phi( print_uint/(const byte*) print_screen#0 print_uint::@1/(byte*) print_char_cursor#27 )
  [104] (byte) print_uchar::b#2 ← phi( print_uint/(byte) print_uchar::b#0 print_uint::@1/(byte) print_uchar::b#1 )
  [105] (byte~) print_uchar::$0 ← (byte) print_uchar::b#2 >> (byte) 4
  [106] (byte) print_char::ch#0 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar::$0)
  [107] call print_char 
  to:print_uchar::@1
print_uchar::@1: scope:[print_uchar]  from print_uchar
  [108] (byte~) print_uchar::$2 ← (byte) print_uchar::b#2 & (byte) $f
  [109] (byte) print_char::ch#1 ← *((const to_nomodify byte*) print_hextab + (byte~) print_uchar::$2)
  [110] call print_char 
  to:print_uchar::@return
print_uchar::@return: scope:[print_uchar]  from print_uchar::@1
  [111] return 
  to:@return

(void()) print_char((byte) print_char::ch)
print_char: scope:[print_char]  from print_uchar print_uchar::@1
  [112] (byte*) print_char_cursor#26 ← phi( print_uchar/(byte*) print_char_cursor#37 print_uchar::@1/(byte*) print_char_cursor#27 )
  [112] (byte) print_char::ch#2 ← phi( print_uchar/(byte) print_char::ch#0 print_uchar::@1/(byte) print_char::ch#1 )
  [113] *((byte*) print_char_cursor#26) ← (byte) print_char::ch#2
  [114] (byte*) print_char_cursor#27 ← ++ (byte*) print_char_cursor#26
  to:print_char::@return
print_char::@return: scope:[print_char]  from print_char
  [115] return 
  to:@return
