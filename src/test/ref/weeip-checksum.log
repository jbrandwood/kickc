Fixing struct type size union $0 to 2
Fixing struct type size union $0 to 2
Fixing struct type SIZE_OF union $0 to 2
Fixing struct type SIZE_OF union $0 to 2
Inlined call call __init

CONTROL FLOW GRAPH SSA

void add_checksum(unsigned int v)
add_checksum: scope:[add_checksum]  from main main::@1 main::@2
  add_checksum::v#3 = phi( main/add_checksum::v#0, main::@1/add_checksum::v#1, main::@2/add_checksum::v#2 )
  _a#0 = ((char *)&chks+OFFSET_UNION_$0_B)[0]
  add_checksum::$0 = byte1  add_checksum::v#3
  add_checksum::$14 = (unsigned int)_a#0
  add_checksum::$1 = add_checksum::$14 + add_checksum::$0
  _b16#0 = add_checksum::$1
  add_checksum::$2 = byte0  _b16#0
  _b#0 = add_checksum::$2
  add_checksum::$3 = _b16#0 >> 8
  add_checksum::$4 = byte1  add_checksum::$3
  _c#0 = add_checksum::$4
  ((char *)&chks+OFFSET_UNION_$0_B)[0] = _b#0
  _a#1 = ((char *)&chks+OFFSET_UNION_$0_B)[1]
  add_checksum::$5 = byte0  add_checksum::v#3
  add_checksum::$15 = (unsigned int)_a#1
  add_checksum::$6 = add_checksum::$15 + add_checksum::$5
  add_checksum::$7 = add_checksum::$6 + _c#0
  _b16#1 = add_checksum::$7
  add_checksum::$8 = byte0  _b16#1
  _b#1 = add_checksum::$8
  add_checksum::$9 = byte1  _b16#1
  _c#1 = add_checksum::$9
  ((char *)&chks+OFFSET_UNION_$0_B)[1] = _b#1
  add_checksum::$16 = 0 != _c#1
  add_checksum::$10 = ! add_checksum::$16
  if(add_checksum::$10) goto add_checksum::@return
  to:add_checksum::@1
add_checksum::@1: scope:[add_checksum]  from add_checksum
  _c#17 = phi( add_checksum/_c#1 )
  _b#17 = phi( add_checksum/_b#1 )
  _b16#17 = phi( add_checksum/_b16#1 )
  _a#17 = phi( add_checksum/_a#1 )
  ((char *)&chks+OFFSET_UNION_$0_B)[0] = ++ ((char *)&chks+OFFSET_UNION_$0_B)[0]
  add_checksum::$11 = ((char *)&chks+OFFSET_UNION_$0_B)[0] == 0
  add_checksum::$12 = ! add_checksum::$11
  if(add_checksum::$12) goto add_checksum::@return
  to:add_checksum::@2
add_checksum::@2: scope:[add_checksum]  from add_checksum::@1
  _c#18 = phi( add_checksum::@1/_c#17 )
  _b#18 = phi( add_checksum::@1/_b#17 )
  _b16#18 = phi( add_checksum::@1/_b16#17 )
  _a#18 = phi( add_checksum::@1/_a#17 )
  ((char *)&chks+OFFSET_UNION_$0_B)[1] = ++ ((char *)&chks+OFFSET_UNION_$0_B)[1]
  to:add_checksum::@return
add_checksum::@return: scope:[add_checksum]  from add_checksum add_checksum::@1 add_checksum::@2
  _c#10 = phi( add_checksum/_c#1, add_checksum::@1/_c#17, add_checksum::@2/_c#18 )
  _b#10 = phi( add_checksum/_b#1, add_checksum::@1/_b#17, add_checksum::@2/_b#18 )
  _b16#10 = phi( add_checksum/_b16#1, add_checksum::@1/_b16#17, add_checksum::@2/_b16#18 )
  _a#10 = phi( add_checksum/_a#1, add_checksum::@1/_a#17, add_checksum::@2/_a#18 )
  _a#2 = _a#10
  _b16#2 = _b16#10
  _b#2 = _b#10
  _c#2 = _c#10
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  _c#19 = phi( __start::@1/_c#20 )
  _b#19 = phi( __start::@1/_b#20 )
  _b16#19 = phi( __start::@1/_b16#20 )
  _a#19 = phi( __start::@1/_a#20 )
  *((unsigned int *)&chks+OFFSET_UNION_$0_U) = 0
  add_checksum::v#0 = $1234
  call add_checksum
  to:main::@1
main::@1: scope:[main]  from main
  _c#11 = phi( main/_c#2 )
  _b#11 = phi( main/_b#2 )
  _b16#11 = phi( main/_b16#2 )
  _a#11 = phi( main/_a#2 )
  _a#3 = _a#11
  _b16#3 = _b16#11
  _b#3 = _b#11
  _c#3 = _c#11
  main::$3 = 0 * SIZEOF_UNSIGNED_INT
  SCREEN[main::$3] = *((unsigned int *)&chks+OFFSET_UNION_$0_U)
  add_checksum::v#1 = $2345
  call add_checksum
  to:main::@2
main::@2: scope:[main]  from main::@1
  _c#12 = phi( main::@1/_c#2 )
  _b#12 = phi( main::@1/_b#2 )
  _b16#12 = phi( main::@1/_b16#2 )
  _a#12 = phi( main::@1/_a#2 )
  _a#4 = _a#12
  _b16#4 = _b16#12
  _b#4 = _b#12
  _c#4 = _c#12
  main::$4 = 1 * SIZEOF_UNSIGNED_INT
  SCREEN[main::$4] = *((unsigned int *)&chks+OFFSET_UNION_$0_U)
  add_checksum::v#2 = $3456
  call add_checksum
  to:main::@3
main::@3: scope:[main]  from main::@2
  _c#13 = phi( main::@2/_c#2 )
  _b#13 = phi( main::@2/_b#2 )
  _b16#13 = phi( main::@2/_b16#2 )
  _a#13 = phi( main::@2/_a#2 )
  _a#5 = _a#13
  _b16#5 = _b16#13
  _b#5 = _b#13
  _c#5 = _c#13
  main::$5 = 1 * SIZEOF_UNSIGNED_INT
  SCREEN[main::$5] = *((unsigned int *)&chks+OFFSET_UNION_$0_U)
  to:main::@return
main::@return: scope:[main]  from main::@3
  _c#14 = phi( main::@3/_c#5 )
  _b#14 = phi( main::@3/_b#5 )
  _b16#14 = phi( main::@3/_b16#5 )
  _a#14 = phi( main::@3/_a#5 )
  _a#6 = _a#14
  _b16#6 = _b16#14
  _b#6 = _b#14
  _c#6 = _c#14
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  _a#7 = 0
  _b#7 = 0
  _c#7 = 0
  _b16#7 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  _c#20 = phi( __start::__init1/_c#7 )
  _b#20 = phi( __start::__init1/_b#7 )
  _b16#20 = phi( __start::__init1/_b16#7 )
  _a#20 = phi( __start::__init1/_a#7 )
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  _c#15 = phi( __start::@1/_c#6 )
  _b#15 = phi( __start::@1/_b#6 )
  _b16#15 = phi( __start::@1/_b16#6 )
  _a#15 = phi( __start::@1/_a#6 )
  _a#8 = _a#15
  _b16#8 = _b16#15
  _b#8 = _b#15
  _c#8 = _c#15
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  _b16#16 = phi( __start::@2/_b16#8 )
  _c#16 = phi( __start::@2/_c#8 )
  _b#16 = phi( __start::@2/_b#8 )
  _a#16 = phi( __start::@2/_a#8 )
  _a#9 = _a#16
  _b#9 = _b#16
  _c#9 = _c#16
  _b16#9 = _b16#16
  return 
  to:@return

SYMBOL TABLE SSA
__constant char OFFSET_UNION_$0_B = 0
__constant char OFFSET_UNION_$0_U = 0
__constant unsigned int * const SCREEN = (unsigned int *)$400
__constant char SIZEOF_UNSIGNED_INT = 2
void __start()
char _a
char _a#0
char _a#1
char _a#10
char _a#11
char _a#12
char _a#13
char _a#14
char _a#15
char _a#16
char _a#17
char _a#18
char _a#19
char _a#2
char _a#20
char _a#3
char _a#4
char _a#5
char _a#6
char _a#7
char _a#8
char _a#9
char _b
char _b#0
char _b#1
char _b#10
char _b#11
char _b#12
char _b#13
char _b#14
char _b#15
char _b#16
char _b#17
char _b#18
char _b#19
char _b#2
char _b#20
char _b#3
char _b#4
char _b#5
char _b#6
char _b#7
char _b#8
char _b#9
unsigned int _b16
unsigned int _b16#0
unsigned int _b16#1
unsigned int _b16#10
unsigned int _b16#11
unsigned int _b16#12
unsigned int _b16#13
unsigned int _b16#14
unsigned int _b16#15
unsigned int _b16#16
unsigned int _b16#17
unsigned int _b16#18
unsigned int _b16#19
unsigned int _b16#2
unsigned int _b16#20
unsigned int _b16#3
unsigned int _b16#4
unsigned int _b16#5
unsigned int _b16#6
unsigned int _b16#7
unsigned int _b16#8
unsigned int _b16#9
char _c
char _c#0
char _c#1
char _c#10
char _c#11
char _c#12
char _c#13
char _c#14
char _c#15
char _c#16
char _c#17
char _c#18
char _c#19
char _c#2
char _c#20
char _c#3
char _c#4
char _c#5
char _c#6
char _c#7
char _c#8
char _c#9
void add_checksum(unsigned int v)
char add_checksum::$0
unsigned int add_checksum::$1
bool add_checksum::$10
bool add_checksum::$11
bool add_checksum::$12
unsigned int add_checksum::$14
unsigned int add_checksum::$15
bool add_checksum::$16
char add_checksum::$2
unsigned int add_checksum::$3
char add_checksum::$4
char add_checksum::$5
unsigned int add_checksum::$6
unsigned int add_checksum::$7
char add_checksum::$8
char add_checksum::$9
unsigned int add_checksum::v
unsigned int add_checksum::v#0
unsigned int add_checksum::v#1
unsigned int add_checksum::v#2
unsigned int add_checksum::v#3
__loadstore union $0 chks = {}
void main()
number main::$3
number main::$4
number main::$5

Adding number conversion cast (unumber) 0 in _a#0 = ((char *)&chks+OFFSET_UNION_$0_B)[0]
Adding number conversion cast (unumber) 8 in add_checksum::$3 = _b16#0 >> 8
Adding number conversion cast (unumber) 0 in ((char *)&chks+OFFSET_UNION_$0_B)[0] = _b#0
Adding number conversion cast (unumber) 1 in _a#1 = ((char *)&chks+OFFSET_UNION_$0_B)[1]
Adding number conversion cast (unumber) 1 in ((char *)&chks+OFFSET_UNION_$0_B)[1] = _b#1
Adding number conversion cast (unumber) 0 in add_checksum::$16 = 0 != _c#1
Adding number conversion cast (unumber) 0 in ((char *)&chks+OFFSET_UNION_$0_B)[0] = ++ ((char *)&chks+OFFSET_UNION_$0_B)[0]
Adding number conversion cast (unumber) 0 in ((char *)&chks+OFFSET_UNION_$0_B)[0] = ++ ((char *)&chks+OFFSET_UNION_$0_B)[(unumber)0]
Adding number conversion cast (unumber) 0 in add_checksum::$11 = ((char *)&chks+OFFSET_UNION_$0_B)[0] == 0
Adding number conversion cast (unumber) 0 in add_checksum::$11 = ((char *)&chks+OFFSET_UNION_$0_B)[0] == (unumber)0
Adding number conversion cast (unumber) 1 in ((char *)&chks+OFFSET_UNION_$0_B)[1] = ++ ((char *)&chks+OFFSET_UNION_$0_B)[1]
Adding number conversion cast (unumber) 1 in ((char *)&chks+OFFSET_UNION_$0_B)[1] = ++ ((char *)&chks+OFFSET_UNION_$0_B)[(unumber)1]
Adding number conversion cast (unumber) 0 in *((unsigned int *)&chks+OFFSET_UNION_$0_U) = 0
Adding number conversion cast (unumber) $1234 in add_checksum::v#0 = $1234
Adding number conversion cast (unumber) 0 in main::$3 = 0 * SIZEOF_UNSIGNED_INT
Adding number conversion cast (unumber) main::$3 in main::$3 = (unumber)0 * SIZEOF_UNSIGNED_INT
Adding number conversion cast (unumber) $2345 in add_checksum::v#1 = $2345
Adding number conversion cast (unumber) 1 in main::$4 = 1 * SIZEOF_UNSIGNED_INT
Adding number conversion cast (unumber) main::$4 in main::$4 = (unumber)1 * SIZEOF_UNSIGNED_INT
Adding number conversion cast (unumber) $3456 in add_checksum::v#2 = $3456
Adding number conversion cast (unumber) 1 in main::$5 = 1 * SIZEOF_UNSIGNED_INT
Adding number conversion cast (unumber) main::$5 in main::$5 = (unumber)1 * SIZEOF_UNSIGNED_INT
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((unsigned int *)&chks+OFFSET_UNION_$0_U) = (unumber)0
Inlining cast add_checksum::v#0 = (unumber)$1234
Inlining cast add_checksum::v#1 = (unumber)$2345
Inlining cast add_checksum::v#2 = (unumber)$3456
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (unsigned int *) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $1234
Simplifying constant integer cast 0
Simplifying constant integer cast $2345
Simplifying constant integer cast 1
Simplifying constant integer cast $3456
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (unsigned int) $1234
Finalized unsigned number type (char) 0
Finalized unsigned number type (unsigned int) $2345
Finalized unsigned number type (char) 1
Finalized unsigned number type (unsigned int) $3456
Finalized unsigned number type (char) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to char in main::$3 = 0 * SIZEOF_UNSIGNED_INT
Inferred type updated to char in main::$4 = 1 * SIZEOF_UNSIGNED_INT
Inferred type updated to char in main::$5 = 1 * SIZEOF_UNSIGNED_INT
Inversing boolean not [24] add_checksum::$10 = 0 == _c#1 from [23] add_checksum::$16 = 0 != _c#1
Inversing boolean not [29] add_checksum::$12 = ((char *)&chks+OFFSET_UNION_$0_B)[0] != 0 from [28] add_checksum::$11 = ((char *)&chks+OFFSET_UNION_$0_B)[0] == 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias _b16#0 = add_checksum::$1 
Alias _b#0 = add_checksum::$2 
Alias _c#0 = add_checksum::$4 
Alias _b16#1 = add_checksum::$7 _b16#17 _b16#18 
Alias _b#1 = add_checksum::$8 _b#17 _b#18 
Alias _c#1 = add_checksum::$9 _c#17 _c#18 
Alias _a#1 = _a#17 _a#18 
Alias _a#10 = _a#2 
Alias _b16#10 = _b16#2 
Alias _b#10 = _b#2 
Alias _c#10 = _c#2 
Alias _a#11 = _a#3 
Alias _b16#11 = _b16#3 
Alias _b#11 = _b#3 
Alias _c#11 = _c#3 
Alias _a#12 = _a#4 
Alias _b16#12 = _b16#4 
Alias _b#12 = _b#4 
Alias _c#12 = _c#4 
Alias _a#13 = _a#5 _a#14 _a#6 
Alias _b16#13 = _b16#5 _b16#14 _b16#6 
Alias _b#13 = _b#5 _b#14 _b#6 
Alias _c#13 = _c#5 _c#14 _c#6 
Alias _a#20 = _a#7 
Alias _b16#20 = _b16#7 
Alias _b#20 = _b#7 
Alias _c#20 = _c#7 
Alias _a#15 = _a#8 _a#16 _a#9 
Alias _b16#15 = _b16#8 _b16#16 _b16#9 
Alias _b#15 = _b#8 _b#16 _b#9 
Alias _c#15 = _c#8 _c#16 _c#9 
Successful SSA optimization Pass2AliasElimination
Alias _a#1 = _a#10 
Alias _b16#1 = _b16#10 
Alias _b#1 = _b#10 
Alias _c#1 = _c#10 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values _a#19 _a#20
Identical Phi Values _b16#19 _b16#20
Identical Phi Values _b#19 _b#20
Identical Phi Values _c#19 _c#20
Identical Phi Values _a#11 _a#1
Identical Phi Values _b16#11 _b16#1
Identical Phi Values _b#11 _b#1
Identical Phi Values _c#11 _c#1
Identical Phi Values _a#12 _a#1
Identical Phi Values _b16#12 _b16#1
Identical Phi Values _b#12 _b#1
Identical Phi Values _c#12 _c#1
Identical Phi Values _a#13 _a#1
Identical Phi Values _b16#13 _b16#1
Identical Phi Values _b#13 _b#1
Identical Phi Values _c#13 _c#1
Identical Phi Values _a#15 _a#13
Identical Phi Values _b16#15 _b16#13
Identical Phi Values _b#15 _b#13
Identical Phi Values _c#15 _c#13
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition add_checksum::$10 [18] if(0==_c#1) goto add_checksum::@return
Simple Condition add_checksum::$12 [21] if(((char *)&chks+OFFSET_UNION_$0_B)[0]!=0) goto add_checksum::@return
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [29] main::$3 = 0 * SIZEOF_UNSIGNED_INT
Constant right-side identified [34] main::$4 = 1 * SIZEOF_UNSIGNED_INT
Constant right-side identified [39] main::$5 = 1 * SIZEOF_UNSIGNED_INT
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant add_checksum::v#0 = $1234
Constant main::$3 = 0*SIZEOF_UNSIGNED_INT
Constant add_checksum::v#1 = $2345
Constant main::$4 = 1*SIZEOF_UNSIGNED_INT
Constant add_checksum::v#2 = $3456
Constant main::$5 = 1*SIZEOF_UNSIGNED_INT
Constant _a#20 = 0
Constant _b#20 = 0
Constant _c#20 = 0
Constant _b16#20 = 0
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero 0*SIZEOF_UNSIGNED_INT in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero (char *)&chks+OFFSET_UNION_$0_B in [1] _a#0 = ((char *)&chks+OFFSET_UNION_$0_B)[0]
Simplifying expression containing zero (char *)&chks in [1] _a#0 = *((char *)&chks+OFFSET_UNION_$0_B)
Simplifying expression containing zero (char *)&chks+OFFSET_UNION_$0_B in [8] ((char *)&chks+OFFSET_UNION_$0_B)[0] = _b#0
Simplifying expression containing zero (char *)&chks in [8] *((char *)&chks+OFFSET_UNION_$0_B) = _b#0
Simplifying expression containing zero (char *)&chks in [9] _a#1 = ((char *)&chks+OFFSET_UNION_$0_B)[1]
Simplifying expression containing zero (char *)&chks in [16] ((char *)&chks+OFFSET_UNION_$0_B)[1] = _b#1
Simplifying expression containing zero (char *)&chks+OFFSET_UNION_$0_B in [19] ((char *)&chks+OFFSET_UNION_$0_B)[0] = ++ ((char *)&chks+OFFSET_UNION_$0_B)[0]
Simplifying expression containing zero (char *)&chks in [19] ((char *)&chks+OFFSET_UNION_$0_B)[0] = ++ *((char *)&chks+OFFSET_UNION_$0_B)
Simplifying expression containing zero (char *)&chks+OFFSET_UNION_$0_B in [19] ((char *)&chks+OFFSET_UNION_$0_B)[0] = ++ *((char *)&chks)
Simplifying expression containing zero (char *)&chks in [19] *((char *)&chks+OFFSET_UNION_$0_B) = ++ *((char *)&chks)
Simplifying expression containing zero (char *)&chks+OFFSET_UNION_$0_B in [21] if(((char *)&chks+OFFSET_UNION_$0_B)[0]!=0) goto add_checksum::@return
Simplifying expression containing zero (char *)&chks in [21] if(*((char *)&chks+OFFSET_UNION_$0_B)!=0) goto add_checksum::@return
Simplifying expression containing zero (char *)&chks in [22] ((char *)&chks+OFFSET_UNION_$0_B)[1] = ++ ((char *)&chks+OFFSET_UNION_$0_B)[1]
Simplifying expression containing zero (char *)&chks in [22] ((char *)&chks+OFFSET_UNION_$0_B)[1] = ++ ((char *)&chks)[1]
Simplifying expression containing zero (unsigned int *)&chks in [25] *((unsigned int *)&chks+OFFSET_UNION_$0_U) = 0
Simplifying expression containing zero (unsigned int *)&chks in [30] SCREEN[main::$3] = *((unsigned int *)&chks+OFFSET_UNION_$0_U)
Simplifying expression containing zero SCREEN in [30] SCREEN[main::$3] = *((unsigned int *)&chks)
Simplifying expression containing zero (unsigned int *)&chks in [35] SCREEN[main::$4] = *((unsigned int *)&chks+OFFSET_UNION_$0_U)
Simplifying expression containing zero (unsigned int *)&chks in [40] SCREEN[main::$5] = *((unsigned int *)&chks+OFFSET_UNION_$0_U)
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant main::$3
Eliminating unused constant OFFSET_UNION_$0_B
Eliminating unused constant OFFSET_UNION_$0_U
Eliminating unused constant _a#20
Eliminating unused constant _b#20
Eliminating unused constant _c#20
Eliminating unused constant _b16#20
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings add_checksum::v#0
Inlining constant with var siblings add_checksum::v#1
Inlining constant with var siblings add_checksum::v#2
Constant inlined main::$5 = 1*SIZEOF_UNSIGNED_INT
Constant inlined add_checksum::v#1 = $2345
Constant inlined add_checksum::v#0 = $1234
Constant inlined main::$4 = 1*SIZEOF_UNSIGNED_INT
Constant inlined add_checksum::v#2 = $3456
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *((char *)&chks+1)
Consolidated array index constant in *((char *)&chks+1)
Consolidated array index constant in *((char *)&chks+1)
Consolidated array index constant in *((char *)&chks+1)
Consolidated array index constant in *(SCREEN+1*SIZEOF_UNSIGNED_INT)
Consolidated array index constant in *(SCREEN+1*SIZEOF_UNSIGNED_INT)
Successful SSA optimization Pass2ConstantAdditionElimination
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 2
Successful SSA optimization PassNFinalizeNumberTypeConversions
CALL GRAPH
Calls in [main] to add_checksum:1 add_checksum:3 add_checksum:5 

Created 1 initial phi equivalence classes
Coalesced down to 1 phi equivalence classes

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] *((unsigned int *)&chks) = 0
  [1] call add_checksum
  to:main::@1
main::@1: scope:[main]  from main
  [2] *SCREEN = *((unsigned int *)&chks)
  [3] call add_checksum
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks)
  [5] call add_checksum
  to:main::@3
main::@3: scope:[main]  from main::@2
  [6] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks)
  to:main::@return
main::@return: scope:[main]  from main::@3
  [7] return 
  to:@return

void add_checksum(unsigned int v)
add_checksum: scope:[add_checksum]  from main main::@1 main::@2
  [8] add_checksum::v#3 = phi( main/$1234, main::@1/$2345, main::@2/$3456 )
  [9] _a#0 = *((char *)&chks)
  [10] add_checksum::$0 = byte1  add_checksum::v#3
  [11] add_checksum::$14 = (unsigned int)_a#0
  [12] _b16#0 = add_checksum::$14 + add_checksum::$0
  [13] _b#0 = byte0  _b16#0
  [14] add_checksum::$3 = _b16#0 >> 8
  [15] _c#0 = byte1  add_checksum::$3
  [16] *((char *)&chks) = _b#0
  [17] _a#1 = *((char *)&chks+1)
  [18] add_checksum::$5 = byte0  add_checksum::v#3
  [19] add_checksum::$15 = (unsigned int)_a#1
  [20] add_checksum::$6 = add_checksum::$15 + add_checksum::$5
  [21] _b16#1 = add_checksum::$6 + _c#0
  [22] _b#1 = byte0  _b16#1
  [23] _c#1 = byte1  _b16#1
  [24] *((char *)&chks+1) = _b#1
  [25] if(0==_c#1) goto add_checksum::@return
  to:add_checksum::@1
add_checksum::@1: scope:[add_checksum]  from add_checksum
  [26] *((char *)&chks) = ++ *((char *)&chks)
  [27] if(*((char *)&chks)!=0) goto add_checksum::@return
  to:add_checksum::@2
add_checksum::@2: scope:[add_checksum]  from add_checksum::@1
  [28] *((char *)&chks+1) = ++ *((char *)&chks+1)
  to:add_checksum::@return
add_checksum::@return: scope:[add_checksum]  from add_checksum add_checksum::@1 add_checksum::@2
  [29] return 
  to:@return


VARIABLE REGISTER WEIGHTS
char _a
char _a#0 // 5.5
char _a#1 // 5.5
char _b
char _b#0 // 7.333333333333333
char _b#1 // 11.0
unsigned int _b16
unsigned int _b16#0 // 16.5
unsigned int _b16#1 // 16.5
char _c
char _c#0 // 3.6666666666666665
char _c#1 // 11.0
void add_checksum(unsigned int v)
char add_checksum::$0 // 11.0
unsigned int add_checksum::$14 // 22.0
unsigned int add_checksum::$15 // 22.0
unsigned int add_checksum::$3 // 22.0
char add_checksum::$5 // 11.0
unsigned int add_checksum::$6 // 22.0
unsigned int add_checksum::v
unsigned int add_checksum::v#3 // 2.2
__loadstore union $0 chks = {}
void main()

Initial phi equivalence classes
[ add_checksum::v#3 ]
Added variable _a#0 to live range equivalence class [ _a#0 ]
Added variable add_checksum::$0 to live range equivalence class [ add_checksum::$0 ]
Added variable add_checksum::$14 to live range equivalence class [ add_checksum::$14 ]
Added variable _b16#0 to live range equivalence class [ _b16#0 ]
Added variable _b#0 to live range equivalence class [ _b#0 ]
Added variable add_checksum::$3 to live range equivalence class [ add_checksum::$3 ]
Added variable _c#0 to live range equivalence class [ _c#0 ]
Added variable _a#1 to live range equivalence class [ _a#1 ]
Added variable add_checksum::$5 to live range equivalence class [ add_checksum::$5 ]
Added variable add_checksum::$15 to live range equivalence class [ add_checksum::$15 ]
Added variable add_checksum::$6 to live range equivalence class [ add_checksum::$6 ]
Added variable _b16#1 to live range equivalence class [ _b16#1 ]
Added variable _b#1 to live range equivalence class [ _b#1 ]
Added variable _c#1 to live range equivalence class [ _c#1 ]
Added variable chks to live range equivalence class [ chks ]
Complete equivalence classes
[ add_checksum::v#3 ]
[ _a#0 ]
[ add_checksum::$0 ]
[ add_checksum::$14 ]
[ _b16#0 ]
[ _b#0 ]
[ add_checksum::$3 ]
[ _c#0 ]
[ _a#1 ]
[ add_checksum::$5 ]
[ add_checksum::$15 ]
[ add_checksum::$6 ]
[ _b16#1 ]
[ _b#1 ]
[ _c#1 ]
[ chks ]
Allocated zp[2]:2 [ add_checksum::v#3 ]
Allocated zp[1]:4 [ _a#0 ]
Allocated zp[1]:5 [ add_checksum::$0 ]
Allocated zp[2]:6 [ add_checksum::$14 ]
Allocated zp[2]:8 [ _b16#0 ]
Allocated zp[1]:10 [ _b#0 ]
Allocated zp[2]:11 [ add_checksum::$3 ]
Allocated zp[1]:13 [ _c#0 ]
Allocated zp[1]:14 [ _a#1 ]
Allocated zp[1]:15 [ add_checksum::$5 ]
Allocated zp[2]:16 [ add_checksum::$15 ]
Allocated zp[2]:18 [ add_checksum::$6 ]
Allocated zp[2]:20 [ _b16#1 ]
Allocated zp[1]:22 [ _b#1 ]
Allocated zp[1]:23 [ _c#1 ]
Allocated mem[2] [ chks ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] *((unsigned int *)&chks) = 0 [ chks ] (  [ chks ] { }  ) always clobbers reg byte a 
Statement [2] *SCREEN = *((unsigned int *)&chks) [ chks ] (  [ chks ] { }  ) always clobbers reg byte a 
Statement [4] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks) [ chks ] (  [ chks ] { }  ) always clobbers reg byte a 
Statement [6] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [11] add_checksum::$14 = (unsigned int)_a#0 [ chks add_checksum::v#3 add_checksum::$0 add_checksum::$14 ] ( add_checksum:1 [ chks add_checksum::v#3 add_checksum::$0 add_checksum::$14 ] { }  add_checksum:3 [ chks add_checksum::v#3 add_checksum::$0 add_checksum::$14 ] { }  add_checksum:5 [ chks add_checksum::v#3 add_checksum::$0 add_checksum::$14 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ add_checksum::$0 ]
Statement [12] _b16#0 = add_checksum::$14 + add_checksum::$0 [ chks add_checksum::v#3 _b16#0 ] ( add_checksum:1 [ chks add_checksum::v#3 _b16#0 ] { }  add_checksum:3 [ chks add_checksum::v#3 _b16#0 ] { }  add_checksum:5 [ chks add_checksum::v#3 _b16#0 ] { }  ) always clobbers reg byte a 
Statement [14] add_checksum::$3 = _b16#0 >> 8 [ chks add_checksum::v#3 _b#0 add_checksum::$3 ] ( add_checksum:1 [ chks add_checksum::v#3 _b#0 add_checksum::$3 ] { }  add_checksum:3 [ chks add_checksum::v#3 _b#0 add_checksum::$3 ] { }  add_checksum:5 [ chks add_checksum::v#3 _b#0 add_checksum::$3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ _b#0 ]
Statement [19] add_checksum::$15 = (unsigned int)_a#1 [ chks _c#0 add_checksum::$5 add_checksum::$15 ] ( add_checksum:1 [ chks _c#0 add_checksum::$5 add_checksum::$15 ] { }  add_checksum:3 [ chks _c#0 add_checksum::$5 add_checksum::$15 ] { }  add_checksum:5 [ chks _c#0 add_checksum::$5 add_checksum::$15 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:13 [ _c#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:15 [ add_checksum::$5 ]
Statement [20] add_checksum::$6 = add_checksum::$15 + add_checksum::$5 [ chks _c#0 add_checksum::$6 ] ( add_checksum:1 [ chks _c#0 add_checksum::$6 ] { }  add_checksum:3 [ chks _c#0 add_checksum::$6 ] { }  add_checksum:5 [ chks _c#0 add_checksum::$6 ] { }  ) always clobbers reg byte a 
Statement [21] _b16#1 = add_checksum::$6 + _c#0 [ chks _b16#1 ] ( add_checksum:1 [ chks _b16#1 ] { }  add_checksum:3 [ chks _b16#1 ] { }  add_checksum:5 [ chks _b16#1 ] { }  ) always clobbers reg byte a 
Statement [27] if(*((char *)&chks)!=0) goto add_checksum::@return [ chks ] ( add_checksum:1 [ chks ] { }  add_checksum:3 [ chks ] { }  add_checksum:5 [ chks ] { }  ) always clobbers reg byte a 
Statement [0] *((unsigned int *)&chks) = 0 [ chks ] (  [ chks ] { }  ) always clobbers reg byte a 
Statement [2] *SCREEN = *((unsigned int *)&chks) [ chks ] (  [ chks ] { }  ) always clobbers reg byte a 
Statement [4] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks) [ chks ] (  [ chks ] { }  ) always clobbers reg byte a 
Statement [6] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [11] add_checksum::$14 = (unsigned int)_a#0 [ chks add_checksum::v#3 add_checksum::$0 add_checksum::$14 ] ( add_checksum:1 [ chks add_checksum::v#3 add_checksum::$0 add_checksum::$14 ] { }  add_checksum:3 [ chks add_checksum::v#3 add_checksum::$0 add_checksum::$14 ] { }  add_checksum:5 [ chks add_checksum::v#3 add_checksum::$0 add_checksum::$14 ] { }  ) always clobbers reg byte a 
Statement [12] _b16#0 = add_checksum::$14 + add_checksum::$0 [ chks add_checksum::v#3 _b16#0 ] ( add_checksum:1 [ chks add_checksum::v#3 _b16#0 ] { }  add_checksum:3 [ chks add_checksum::v#3 _b16#0 ] { }  add_checksum:5 [ chks add_checksum::v#3 _b16#0 ] { }  ) always clobbers reg byte a 
Statement [14] add_checksum::$3 = _b16#0 >> 8 [ chks add_checksum::v#3 _b#0 add_checksum::$3 ] ( add_checksum:1 [ chks add_checksum::v#3 _b#0 add_checksum::$3 ] { }  add_checksum:3 [ chks add_checksum::v#3 _b#0 add_checksum::$3 ] { }  add_checksum:5 [ chks add_checksum::v#3 _b#0 add_checksum::$3 ] { }  ) always clobbers reg byte a 
Statement [19] add_checksum::$15 = (unsigned int)_a#1 [ chks _c#0 add_checksum::$5 add_checksum::$15 ] ( add_checksum:1 [ chks _c#0 add_checksum::$5 add_checksum::$15 ] { }  add_checksum:3 [ chks _c#0 add_checksum::$5 add_checksum::$15 ] { }  add_checksum:5 [ chks _c#0 add_checksum::$5 add_checksum::$15 ] { }  ) always clobbers reg byte a 
Statement [20] add_checksum::$6 = add_checksum::$15 + add_checksum::$5 [ chks _c#0 add_checksum::$6 ] ( add_checksum:1 [ chks _c#0 add_checksum::$6 ] { }  add_checksum:3 [ chks _c#0 add_checksum::$6 ] { }  add_checksum:5 [ chks _c#0 add_checksum::$6 ] { }  ) always clobbers reg byte a 
Statement [21] _b16#1 = add_checksum::$6 + _c#0 [ chks _b16#1 ] ( add_checksum:1 [ chks _b16#1 ] { }  add_checksum:3 [ chks _b16#1 ] { }  add_checksum:5 [ chks _b16#1 ] { }  ) always clobbers reg byte a 
Statement [27] if(*((char *)&chks)!=0) goto add_checksum::@return [ chks ] ( add_checksum:1 [ chks ] { }  add_checksum:3 [ chks ] { }  add_checksum:5 [ chks ] { }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ add_checksum::v#3 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ _a#0 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ add_checksum::$0 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[2]:6 [ add_checksum::$14 ] : zp[2]:6 , 
Potential registers zp[2]:8 [ _b16#0 ] : zp[2]:8 , 
Potential registers zp[1]:10 [ _b#0 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[2]:11 [ add_checksum::$3 ] : zp[2]:11 , 
Potential registers zp[1]:13 [ _c#0 ] : zp[1]:13 , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ _a#1 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ add_checksum::$5 ] : zp[1]:15 , reg byte x , reg byte y , 
Potential registers zp[2]:16 [ add_checksum::$15 ] : zp[2]:16 , 
Potential registers zp[2]:18 [ add_checksum::$6 ] : zp[2]:18 , 
Potential registers zp[2]:20 [ _b16#1 ] : zp[2]:20 , 
Potential registers zp[1]:22 [ _b#1 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:23 [ _c#1 ] : zp[1]:23 , reg byte a , reg byte x , reg byte y , 
Potential registers mem[2] [ chks ] : mem[2] , 

REGISTER UPLIFT SCOPES
Uplift Scope [add_checksum] 22: zp[2]:6 [ add_checksum::$14 ] 22: zp[2]:11 [ add_checksum::$3 ] 22: zp[2]:16 [ add_checksum::$15 ] 22: zp[2]:18 [ add_checksum::$6 ] 11: zp[1]:5 [ add_checksum::$0 ] 11: zp[1]:15 [ add_checksum::$5 ] 2.2: zp[2]:2 [ add_checksum::v#3 ] 
Uplift Scope [] 16.5: zp[2]:8 [ _b16#0 ] 16.5: zp[2]:20 [ _b16#1 ] 11: zp[1]:22 [ _b#1 ] 11: zp[1]:23 [ _c#1 ] 7.33: zp[1]:10 [ _b#0 ] 5.5: zp[1]:4 [ _a#0 ] 5.5: zp[1]:14 [ _a#1 ] 3.67: zp[1]:13 [ _c#0 ] 0: mem[2] [ chks ] 
Uplift Scope [$0] 
Uplift Scope [main] 

Uplifting [add_checksum] best 310 combination zp[2]:6 [ add_checksum::$14 ] zp[2]:11 [ add_checksum::$3 ] zp[2]:16 [ add_checksum::$15 ] zp[2]:18 [ add_checksum::$6 ] reg byte x [ add_checksum::$0 ] reg byte x [ add_checksum::$5 ] zp[2]:2 [ add_checksum::v#3 ] 
Uplifting [] best 288 combination zp[2]:8 [ _b16#0 ] zp[2]:20 [ _b16#1 ] reg byte x [ _b#1 ] reg byte a [ _c#1 ] reg byte x [ _b#0 ] reg byte a [ _a#0 ] zp[1]:14 [ _a#1 ] zp[1]:13 [ _c#0 ] mem[2] [ chks ] 
Limited combination testing to 100 combinations of 2304 possible.
Uplifting [$0] best 288 combination 
Uplifting [main] best 288 combination 
Attempting to uplift remaining variables inzp[1]:14 [ _a#1 ]
Uplifting [] best 282 combination reg byte a [ _a#1 ] 
Attempting to uplift remaining variables inzp[1]:13 [ _c#0 ]
Uplifting [] best 278 combination reg byte y [ _c#0 ] 
Coalescing zero page register [ zp[2]:6 [ add_checksum::$14 ] ] with [ zp[2]:8 [ _b16#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:16 [ add_checksum::$15 ] ] with [ zp[2]:18 [ add_checksum::$6 ] ] - score: 1
Coalescing zero page register [ zp[2]:6 [ add_checksum::$14 _b16#0 ] ] with [ zp[2]:11 [ add_checksum::$3 ] ] - score: 1
Coalescing zero page register [ zp[2]:16 [ add_checksum::$15 add_checksum::$6 ] ] with [ zp[2]:20 [ _b16#1 ] ] - score: 1
Allocated (was zp[2]:6) zp[2]:4 [ add_checksum::$14 _b16#0 add_checksum::$3 ]
Allocated (was zp[2]:16) zp[2]:6 [ add_checksum::$15 add_checksum::$6 _b16#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
/**
 * @file checksum.c
 * @brief Helper functions for calculating IP checksums.
 * @compiler CPIK 0.7.3 / MCC18 3.36
 * @author Bruno Basseto (bruno@wise-ware.org)
 */
  // Upstart
  // Commodore 64 PRG executable file
.file [name="weeip-checksum.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const SIZEOF_UNSIGNED_INT = 2
  .const SIZEOF_UNION___0 = 2
  .label SCREEN = $400
  .label _b16 = 4
  .label _b16_1 = 6
.segment Code
  // main
main: {
    // [0] *((unsigned int *)&chks) = 0 -- _deref_pwuc1=vbuc2 
    lda #<0
    sta chks
    lda #>0
    sta chks+1
    // [1] call add_checksum
    // [8] phi from main to add_checksum [phi:main->add_checksum]
  add_checksum_from_main:
    // [8] phi add_checksum::v#3 = $1234 [phi:main->add_checksum#0] -- vwuz1=vwuc1 
    lda #<$1234
    sta.z add_checksum.v
    lda #>$1234
    sta.z add_checksum.v+1
    jsr add_checksum
    jmp __b1
    // main::@1
  __b1:
    // [2] *SCREEN = *((unsigned int *)&chks) -- _deref_pwuc1=_deref_pwuc2 
    lda chks
    sta SCREEN
    lda chks+1
    sta SCREEN+1
    // [3] call add_checksum
    // [8] phi from main::@1 to add_checksum [phi:main::@1->add_checksum]
  add_checksum_from___b1:
    // [8] phi add_checksum::v#3 = $2345 [phi:main::@1->add_checksum#0] -- vwuz1=vwuc1 
    lda #<$2345
    sta.z add_checksum.v
    lda #>$2345
    sta.z add_checksum.v+1
    jsr add_checksum
    jmp __b2
    // main::@2
  __b2:
    // [4] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks) -- _deref_pwuc1=_deref_pwuc2 
    lda chks
    sta SCREEN+1*SIZEOF_UNSIGNED_INT
    lda chks+1
    sta SCREEN+1*SIZEOF_UNSIGNED_INT+1
    // [5] call add_checksum
    // [8] phi from main::@2 to add_checksum [phi:main::@2->add_checksum]
  add_checksum_from___b2:
    // [8] phi add_checksum::v#3 = $3456 [phi:main::@2->add_checksum#0] -- vwuz1=vwuc1 
    lda #<$3456
    sta.z add_checksum.v
    lda #>$3456
    sta.z add_checksum.v+1
    jsr add_checksum
    jmp __b3
    // main::@3
  __b3:
    // [6] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks) -- _deref_pwuc1=_deref_pwuc2 
    lda chks
    sta SCREEN+1*SIZEOF_UNSIGNED_INT
    lda chks+1
    sta SCREEN+1*SIZEOF_UNSIGNED_INT+1
    jmp __breturn
    // main::@return
  __breturn:
    // [7] return 
    rts
}
  // add_checksum
/**
 * Sums a 16-bit word to the current checksum value.
 * Optimized for 8-bit word processors.
 * The result is found in chks.
 * @param v Value to sum.
 */
// void add_checksum(__zp(2) unsigned int v)
add_checksum: {
    .label __3 = 4
    .label __6 = 6
    .label __14 = 4
    .label __15 = 6
    .label v = 2
    // [9] _a#0 = *((char *)&chks) -- vbuaa=_deref_pbuc1 
    /*
    * First byte (MSB).
    */
    lda chks
    // [10] add_checksum::$0 = byte1  add_checksum::v#3 -- vbuxx=_byte1_vwuz1 
    ldx.z v+1
    // [11] add_checksum::$14 = (unsigned int)_a#0 -- vwuz1=_word_vbuaa 
    sta.z __14
    lda #0
    sta.z __14+1
    // [12] _b16#0 = add_checksum::$14 + add_checksum::$0 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z _b16
    sta.z _b16
    bcc !+
    inc.z _b16+1
  !:
    // [13] _b#0 = byte0  _b16#0 -- vbuxx=_byte0_vwuz1 
    ldx.z _b16
    // [14] add_checksum::$3 = _b16#0 >> 8 -- vwuz1=vwuz1_ror_8 
    lda.z __3+1
    sta.z __3
    lda #0
    sta.z __3+1
    // [15] _c#0 = byte1  add_checksum::$3 -- vbuyy=_byte1_vwuz1 
    ldy.z __3+1
    // [16] *((char *)&chks) = _b#0 -- _deref_pbuc1=vbuxx 
    stx chks
    // [17] _a#1 = *((char *)&chks+1) -- vbuaa=_deref_pbuc1 
    /*
    * Second byte (LSB).
    */
    lda chks+1
    // [18] add_checksum::$5 = byte0  add_checksum::v#3 -- vbuxx=_byte0_vwuz1 
    ldx.z v
    // [19] add_checksum::$15 = (unsigned int)_a#1 -- vwuz1=_word_vbuaa 
    sta.z __15
    lda #0
    sta.z __15+1
    // [20] add_checksum::$6 = add_checksum::$15 + add_checksum::$5 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z __6
    sta.z __6
    bcc !+
    inc.z __6+1
  !:
    // [21] _b16#1 = add_checksum::$6 + _c#0 -- vwuz1=vwuz1_plus_vbuyy 
    tya
    clc
    adc.z _b16_1
    sta.z _b16_1
    bcc !+
    inc.z _b16_1+1
  !:
    // [22] _b#1 = byte0  _b16#1 -- vbuxx=_byte0_vwuz1 
    ldx.z _b16_1
    // [23] _c#1 = byte1  _b16#1 -- vbuaa=_byte1_vwuz1 
    lda.z _b16_1+1
    // [24] *((char *)&chks+1) = _b#1 -- _deref_pbuc1=vbuxx 
    stx chks+1
    // [25] if(0==_c#1) goto add_checksum::@return -- 0_eq_vbuaa_then_la1 
    cmp #0
    beq __breturn
    jmp __b1
    // add_checksum::@1
  __b1:
    // [26] *((char *)&chks) = ++ *((char *)&chks) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc chks
    // [27] if(*((char *)&chks)!=0) goto add_checksum::@return -- _deref_pbuc1_neq_0_then_la1 
    lda chks
    bne __breturn
    jmp __b2
    // add_checksum::@2
  __b2:
    // [28] *((char *)&chks+1) = ++ *((char *)&chks+1) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc chks+1
    jmp __breturn
    // add_checksum::@return
  __breturn:
    // [29] return 
    rts
}
  // File Data
.segment Data
  /**
 * Last checksum computation result.
 */
  chks: .fill SIZEOF_UNION___0, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #>0
Replacing instruction ldy.z __3+1 with TAY
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction add_checksum_from_main:
Removing instruction __b1:
Removing instruction add_checksum_from___b1:
Removing instruction __b2:
Removing instruction add_checksum_from___b2:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1:
Removing instruction __b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Replacing instruction lda #0 with TYA

FINAL SYMBOL TABLE
__constant unsigned int * const SCREEN = (unsigned int *) 1024
__constant char SIZEOF_UNION_$0 = 2
__constant char SIZEOF_UNSIGNED_INT = 2
char _a
char _a#0 // reg byte a 5.5
char _a#1 // reg byte a 5.5
char _b
char _b#0 // reg byte x 7.333333333333333
char _b#1 // reg byte x 11.0
unsigned int _b16
unsigned int _b16#0 // _b16 zp[2]:4 16.5
unsigned int _b16#1 // _b16_1 zp[2]:6 16.5
char _c
char _c#0 // reg byte y 3.6666666666666665
char _c#1 // reg byte a 11.0
void add_checksum(unsigned int v)
char add_checksum::$0 // reg byte x 11.0
unsigned int add_checksum::$14 // zp[2]:4 22.0
unsigned int add_checksum::$15 // zp[2]:6 22.0
unsigned int add_checksum::$3 // zp[2]:4 22.0
char add_checksum::$5 // reg byte x 11.0
unsigned int add_checksum::$6 // zp[2]:6 22.0
unsigned int add_checksum::v
unsigned int add_checksum::v#3 // v zp[2]:2 2.2
__loadstore union $0 chks = {} // mem[2]
void main()

zp[2]:2 [ add_checksum::v#3 ]
reg byte a [ _a#0 ]
reg byte x [ add_checksum::$0 ]
zp[2]:4 [ add_checksum::$14 _b16#0 add_checksum::$3 ]
reg byte x [ _b#0 ]
reg byte y [ _c#0 ]
reg byte a [ _a#1 ]
reg byte x [ add_checksum::$5 ]
zp[2]:6 [ add_checksum::$15 add_checksum::$6 _b16#1 ]
reg byte x [ _b#1 ]
reg byte a [ _c#1 ]
mem[2] [ chks ]


FINAL ASSEMBLER
Score: 251

  // File Comments
/**
 * @file checksum.c
 * @brief Helper functions for calculating IP checksums.
 * @compiler CPIK 0.7.3 / MCC18 3.36
 * @author Bruno Basseto (bruno@wise-ware.org)
 */
  // Upstart
  // Commodore 64 PRG executable file
.file [name="weeip-checksum.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const SIZEOF_UNSIGNED_INT = 2
  .const SIZEOF_UNION___0 = 2
  .label SCREEN = $400
  .label _b16 = 4
  .label _b16_1 = 6
.segment Code
  // main
main: {
    // checksum_init
    // [0] *((unsigned int *)&chks) = 0 -- _deref_pwuc1=vbuc2 
    lda #<0
    sta chks
    sta chks+1
    // add_checksum(0x1234)
    // [1] call add_checksum
    // [8] phi from main to add_checksum [phi:main->add_checksum]
    // [8] phi add_checksum::v#3 = $1234 [phi:main->add_checksum#0] -- vwuz1=vwuc1 
    lda #<$1234
    sta.z add_checksum.v
    lda #>$1234
    sta.z add_checksum.v+1
    jsr add_checksum
    // main::@1
    // SCREEN[0] = chks.u
    // [2] *SCREEN = *((unsigned int *)&chks) -- _deref_pwuc1=_deref_pwuc2 
    lda chks
    sta SCREEN
    lda chks+1
    sta SCREEN+1
    // add_checksum(0x2345)
    // [3] call add_checksum
    // [8] phi from main::@1 to add_checksum [phi:main::@1->add_checksum]
    // [8] phi add_checksum::v#3 = $2345 [phi:main::@1->add_checksum#0] -- vwuz1=vwuc1 
    lda #<$2345
    sta.z add_checksum.v
    lda #>$2345
    sta.z add_checksum.v+1
    jsr add_checksum
    // main::@2
    // SCREEN[1] = chks.u
    // [4] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks) -- _deref_pwuc1=_deref_pwuc2 
    lda chks
    sta SCREEN+1*SIZEOF_UNSIGNED_INT
    lda chks+1
    sta SCREEN+1*SIZEOF_UNSIGNED_INT+1
    // add_checksum(0x3456)
    // [5] call add_checksum
    // [8] phi from main::@2 to add_checksum [phi:main::@2->add_checksum]
    // [8] phi add_checksum::v#3 = $3456 [phi:main::@2->add_checksum#0] -- vwuz1=vwuc1 
    lda #<$3456
    sta.z add_checksum.v
    lda #>$3456
    sta.z add_checksum.v+1
    jsr add_checksum
    // main::@3
    // SCREEN[1] = chks.u
    // [6] *(SCREEN+1*SIZEOF_UNSIGNED_INT) = *((unsigned int *)&chks) -- _deref_pwuc1=_deref_pwuc2 
    lda chks
    sta SCREEN+1*SIZEOF_UNSIGNED_INT
    lda chks+1
    sta SCREEN+1*SIZEOF_UNSIGNED_INT+1
    // main::@return
    // }
    // [7] return 
    rts
}
  // add_checksum
/**
 * Sums a 16-bit word to the current checksum value.
 * Optimized for 8-bit word processors.
 * The result is found in chks.
 * @param v Value to sum.
 */
// void add_checksum(__zp(2) unsigned int v)
add_checksum: {
    .label __3 = 4
    .label __6 = 6
    .label __14 = 4
    .label __15 = 6
    .label v = 2
    // _a = chks.b[0]
    // [9] _a#0 = *((char *)&chks) -- vbuaa=_deref_pbuc1 
    /*
    * First byte (MSB).
    */
    lda chks
    // HIGH
    // [10] add_checksum::$0 = byte1  add_checksum::v#3 -- vbuxx=_byte1_vwuz1 
    ldx.z v+1
    // (uint16_t)_a + HIGH
    // [11] add_checksum::$14 = (unsigned int)_a#0 -- vwuz1=_word_vbuaa 
    sta.z __14
    lda #0
    sta.z __14+1
    // _b16 = (uint16_t)_a + HIGH
    // [12] _b16#0 = add_checksum::$14 + add_checksum::$0 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z _b16
    sta.z _b16
    bcc !+
    inc.z _b16+1
  !:
    // _b = LOW
    // [13] _b#0 = byte0  _b16#0 -- vbuxx=_byte0_vwuz1 
    ldx.z _b16
    // HIGH
    // [14] add_checksum::$3 = _b16#0 >> 8 -- vwuz1=vwuz1_ror_8 
    lda.z __3+1
    sta.z __3
    lda #0
    sta.z __3+1
    // _c = HIGH
    // [15] _c#0 = byte1  add_checksum::$3 -- vbuyy=_byte1_vwuz1 
    tay
    // chks.b[0] = _b
    // [16] *((char *)&chks) = _b#0 -- _deref_pbuc1=vbuxx 
    stx chks
    // _a = chks.b[1]
    // [17] _a#1 = *((char *)&chks+1) -- vbuaa=_deref_pbuc1 
    /*
    * Second byte (LSB).
    */
    lda chks+1
    // LOW
    // [18] add_checksum::$5 = byte0  add_checksum::v#3 -- vbuxx=_byte0_vwuz1 
    ldx.z v
    // (uint16_t)_a + (LOW(v))
    // [19] add_checksum::$15 = (unsigned int)_a#1 -- vwuz1=_word_vbuaa 
    sta.z __15
    tya
    sta.z __15+1
    // [20] add_checksum::$6 = add_checksum::$15 + add_checksum::$5 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z __6
    sta.z __6
    bcc !+
    inc.z __6+1
  !:
    // _b16 = (uint16_t)_a + (LOW(v)) + _c
    // [21] _b16#1 = add_checksum::$6 + _c#0 -- vwuz1=vwuz1_plus_vbuyy 
    tya
    clc
    adc.z _b16_1
    sta.z _b16_1
    bcc !+
    inc.z _b16_1+1
  !:
    // _b = LOW
    // [22] _b#1 = byte0  _b16#1 -- vbuxx=_byte0_vwuz1 
    ldx.z _b16_1
    // _c = HIGH
    // [23] _c#1 = byte1  _b16#1 -- vbuaa=_byte1_vwuz1 
    lda.z _b16_1+1
    // chks.b[1] = _b
    // [24] *((char *)&chks+1) = _b#1 -- _deref_pbuc1=vbuxx 
    stx chks+1
    // if(_c)
    // [25] if(0==_c#1) goto add_checksum::@return -- 0_eq_vbuaa_then_la1 
    cmp #0
    beq __breturn
    // add_checksum::@1
    // if(++chks.b[0] == 0)
    // [26] *((char *)&chks) = ++ *((char *)&chks) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc chks
    // [27] if(*((char *)&chks)!=0) goto add_checksum::@return -- _deref_pbuc1_neq_0_then_la1 
    lda chks
    bne __breturn
    // add_checksum::@2
    // chks.b[1]++;
    // [28] *((char *)&chks+1) = ++ *((char *)&chks+1) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc chks+1
    // add_checksum::@return
  __breturn:
    // }
    // [29] return 
    rts
}
  // File Data
.segment Data
  /**
 * Last checksum computation result.
 */
  chks: .fill SIZEOF_UNION___0, 0

