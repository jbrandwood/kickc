Fixing struct type size struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Inlined call vicSelectGfxBank::$0 = call toDd00 vicSelectGfxBank::gfx 

CONTROL FLOW GRAPH SSA

void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main::@8 memoryRemapBlock
  memoryRemap::upperPageOffset#2 = phi( main::@8/memoryRemap::upperPageOffset#1, memoryRemapBlock/memoryRemap::upperPageOffset#0 )
  memoryRemap::remapBlocks#2 = phi( main::@8/memoryRemap::remapBlocks#1, memoryRemapBlock/memoryRemap::remapBlocks#0 )
  memoryRemap::lowerPageOffset#2 = phi( main::@8/memoryRemap::lowerPageOffset#1, memoryRemapBlock/memoryRemap::lowerPageOffset#0 )
  memoryRemap::$0 = < memoryRemap::lowerPageOffset#2
  *memoryRemap::aVal = memoryRemap::$0
  memoryRemap::$1 = memoryRemap::remapBlocks#2 << 4
  memoryRemap::$2 = > memoryRemap::lowerPageOffset#2
  memoryRemap::$3 = memoryRemap::$2 & $f
  memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
  *memoryRemap::xVal = memoryRemap::$4
  memoryRemap::$5 = < memoryRemap::upperPageOffset#2
  *memoryRemap::yVal = memoryRemap::$5
  memoryRemap::$6 = memoryRemap::remapBlocks#2 & $f0
  memoryRemap::$7 = > memoryRemap::upperPageOffset#2
  memoryRemap::$8 = memoryRemap::$7 & $f
  memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
  *memoryRemap::zVal = memoryRemap::$9
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  return 
  to:@return

void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
memoryRemapBlock: scope:[memoryRemapBlock]  from main main::@7
  memoryRemapBlock::blockPage#2 = phi( main/memoryRemapBlock::blockPage#0, main::@7/memoryRemapBlock::blockPage#1 )
  memoryRemapBlock::memoryPage#2 = phi( main/memoryRemapBlock::memoryPage#0, main::@7/memoryRemapBlock::memoryPage#1 )
  memoryRemapBlock::$0 = memoryRemapBlock::memoryPage#2 - memoryRemapBlock::blockPage#2
  memoryRemapBlock::pageOffset#0 = memoryRemapBlock::$0
  memoryRemapBlock::$1 = memoryRemapBlock::blockPage#2 / $20
  memoryRemapBlock::block#0 = memoryRemapBlock::$1
  memoryRemapBlock::$2 = 1 << memoryRemapBlock::block#0
  memoryRemapBlock::blockBits#0 = memoryRemapBlock::$2
  memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0
  memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
  memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0
  call memoryRemap 
  to:memoryRemapBlock::@1
memoryRemapBlock::@1: scope:[memoryRemapBlock]  from memoryRemapBlock
  to:memoryRemapBlock::@return
memoryRemapBlock::@return: scope:[memoryRemapBlock]  from memoryRemapBlock::@1
  return 
  to:@return

void memoryRemap256M(byte memoryRemap256M::remapBlocks , dword memoryRemap256M::lowerPageOffset , dword memoryRemap256M::upperPageOffset)
memoryRemap256M: scope:[memoryRemap256M]  from main::@3 main::@6
  memoryRemap256M::remapBlocks#2 = phi( main::@3/memoryRemap256M::remapBlocks#0, main::@6/memoryRemap256M::remapBlocks#1 )
  memoryRemap256M::upperPageOffset#2 = phi( main::@3/memoryRemap256M::upperPageOffset#0, main::@6/memoryRemap256M::upperPageOffset#1 )
  memoryRemap256M::lowerPageOffset#2 = phi( main::@3/memoryRemap256M::lowerPageOffset#0, main::@6/memoryRemap256M::lowerPageOffset#1 )
  memoryRemap256M::$0 = memoryRemap256M::lowerPageOffset#2 >> 4
  memoryRemap256M::$1 = > (word)memoryRemap256M::$0
  *memoryRemap256M::lMb = memoryRemap256M::$1
  memoryRemap256M::$2 = memoryRemap256M::upperPageOffset#2 >> 4
  memoryRemap256M::$3 = > (word)memoryRemap256M::$2
  *memoryRemap256M::uMb = memoryRemap256M::$3
  memoryRemap256M::$4 = < memoryRemap256M::lowerPageOffset#2
  memoryRemap256M::$5 = < memoryRemap256M::$4
  *memoryRemap256M::aVal = memoryRemap256M::$5
  memoryRemap256M::$6 = memoryRemap256M::remapBlocks#2 << 4
  memoryRemap256M::$7 = < memoryRemap256M::lowerPageOffset#2
  memoryRemap256M::$8 = > memoryRemap256M::$7
  memoryRemap256M::$9 = memoryRemap256M::$8 & $f
  memoryRemap256M::$10 = memoryRemap256M::$6 | memoryRemap256M::$9
  *memoryRemap256M::xVal = memoryRemap256M::$10
  memoryRemap256M::$11 = < memoryRemap256M::upperPageOffset#2
  memoryRemap256M::$12 = < memoryRemap256M::$11
  *memoryRemap256M::yVal = memoryRemap256M::$12
  memoryRemap256M::$13 = memoryRemap256M::remapBlocks#2 & $f0
  memoryRemap256M::$14 = < memoryRemap256M::upperPageOffset#2
  memoryRemap256M::$15 = > memoryRemap256M::$14
  memoryRemap256M::$16 = memoryRemap256M::$15 & $f
  memoryRemap256M::$17 = memoryRemap256M::$13 | memoryRemap256M::$16
  *memoryRemap256M::zVal = memoryRemap256M::$17
  asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap256M::@return
memoryRemap256M::@return: scope:[memoryRemap256M]  from memoryRemap256M
  return 
  to:@return

void main()
main: scope:[main]  from __start
  memoryRemapBlock::blockPage#0 = $40
  memoryRemapBlock::memoryPage#0 = $100
  call memoryRemapBlock 
  to:main::@7
main::@7: scope:[main]  from main
  main::BLOCK_4000[0] = '-'
  main::BLOCK_4000[1] = '*'
  memoryRemapBlock::blockPage#1 = $80
  memoryRemapBlock::memoryPage#1 = $100
  call memoryRemapBlock 
  to:main::@8
main::@8: scope:[main]  from main::@7
  main::BLOCK_8000[2] = '-'
  main::BLOCK_8000[3] = '*'
  memoryRemap::remapBlocks#1 = MEMORYBLOCK_4000|MEMORYBLOCK_8000
  memoryRemap::lowerPageOffset#1 = $c0
  memoryRemap::upperPageOffset#1 = $80
  call memoryRemap 
  to:main::@9
main::@9: scope:[main]  from main::@8
  main::BLOCK_8000[4] = main::BLOCK_4000[2]
  main::BLOCK_4000[5] = main::BLOCK_8000[1]
  main::i#0 = 0
  to:main::@1
main::@1: scope:[main]  from main::@2 main::@9
  main::i#2 = phi( main::@2/main::i#1, main::@9/main::i#0 )
  main::$5 = main::i#2 < 6
  if(main::$5) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  main::i#3 = phi( main::@1/main::i#2 )
  (DEFAULT_SCREEN+$50-6)[main::i#3] = main::BLOCK_4000[main::i#3]
  main::i#1 = ++ main::i#3
  to:main::@1
main::@3: scope:[main]  from main::@1
  memoryRemap256M::remapBlocks#0 = MEMORYBLOCK_4000
  memoryRemap256M::lowerPageOffset#0 = $ff800-$40
  memoryRemap256M::upperPageOffset#0 = 0
  call memoryRemap256M 
  to:main::@10
main::@10: scope:[main]  from main::@3
  main::i1#0 = 0
  to:main::@4
main::@4: scope:[main]  from main::@10 main::@5
  main::i1#2 = phi( main::@10/main::i1#0, main::@5/main::i1#1 )
  main::$6 = main::i1#2 < $10
  if(main::$6) goto main::@5
  to:main::@6
main::@5: scope:[main]  from main::@4
  main::i1#3 = phi( main::@4/main::i1#2 )
  main::$7 = $40 + main::i1#3
  main::BLOCK_4000[main::i1#3] = main::$7
  main::i1#1 = ++ main::i1#3
  to:main::@4
main::@6: scope:[main]  from main::@4
  memoryRemap256M::remapBlocks#1 = 0
  memoryRemap256M::lowerPageOffset#1 = 0
  memoryRemap256M::upperPageOffset#1 = 0
  call memoryRemap256M 
  to:main::@11
main::@11: scope:[main]  from main::@6
  to:main::@return
main::@return: scope:[main]  from main::@11
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
const nomodify byte* DEFAULT_SCREEN = (byte*)$800
const nomodify byte MEMORYBLOCK_4000 = 4
const nomodify byte MEMORYBLOCK_8000 = $10
void __start()
void main()
bool~ main::$5
bool~ main::$6
number~ main::$7
const byte* main::BLOCK_4000 = (byte*)$4000
const byte* main::BLOCK_8000 = (byte*)$8000
byte main::i
byte main::i#0
byte main::i#1
byte main::i#2
byte main::i#3
byte main::i1
byte main::i1#0
byte main::i1#1
byte main::i1#2
byte main::i1#3
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
byte~ memoryRemap::$0
byte~ memoryRemap::$1
byte~ memoryRemap::$2
number~ memoryRemap::$3
number~ memoryRemap::$4
byte~ memoryRemap::$5
number~ memoryRemap::$6
byte~ memoryRemap::$7
number~ memoryRemap::$8
number~ memoryRemap::$9
const byte* memoryRemap::aVal = (byte*)$fc
word memoryRemap::lowerPageOffset
word memoryRemap::lowerPageOffset#0
word memoryRemap::lowerPageOffset#1
word memoryRemap::lowerPageOffset#2
byte memoryRemap::remapBlocks
byte memoryRemap::remapBlocks#0
byte memoryRemap::remapBlocks#1
byte memoryRemap::remapBlocks#2
word memoryRemap::upperPageOffset
word memoryRemap::upperPageOffset#0
word memoryRemap::upperPageOffset#1
word memoryRemap::upperPageOffset#2
const byte* memoryRemap::xVal = (byte*)$fd
const byte* memoryRemap::yVal = (byte*)$fe
const byte* memoryRemap::zVal = (byte*)$ff
void memoryRemap256M(byte memoryRemap256M::remapBlocks , dword memoryRemap256M::lowerPageOffset , dword memoryRemap256M::upperPageOffset)
dword~ memoryRemap256M::$0
byte~ memoryRemap256M::$1
number~ memoryRemap256M::$10
word~ memoryRemap256M::$11
byte~ memoryRemap256M::$12
number~ memoryRemap256M::$13
word~ memoryRemap256M::$14
byte~ memoryRemap256M::$15
number~ memoryRemap256M::$16
number~ memoryRemap256M::$17
dword~ memoryRemap256M::$2
byte~ memoryRemap256M::$3
word~ memoryRemap256M::$4
byte~ memoryRemap256M::$5
byte~ memoryRemap256M::$6
word~ memoryRemap256M::$7
byte~ memoryRemap256M::$8
number~ memoryRemap256M::$9
const byte* memoryRemap256M::aVal = (byte*)$fc
const byte* memoryRemap256M::lMb = (byte*)$fa
dword memoryRemap256M::lowerPageOffset
dword memoryRemap256M::lowerPageOffset#0
dword memoryRemap256M::lowerPageOffset#1
dword memoryRemap256M::lowerPageOffset#2
byte memoryRemap256M::remapBlocks
byte memoryRemap256M::remapBlocks#0
byte memoryRemap256M::remapBlocks#1
byte memoryRemap256M::remapBlocks#2
const byte* memoryRemap256M::uMb = (byte*)$fb
dword memoryRemap256M::upperPageOffset
dword memoryRemap256M::upperPageOffset#0
dword memoryRemap256M::upperPageOffset#1
dword memoryRemap256M::upperPageOffset#2
const byte* memoryRemap256M::xVal = (byte*)$fd
const byte* memoryRemap256M::yVal = (byte*)$fe
const byte* memoryRemap256M::zVal = (byte*)$ff
void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
word~ memoryRemapBlock::$0
number~ memoryRemapBlock::$1
number~ memoryRemapBlock::$2
byte memoryRemapBlock::block
byte memoryRemapBlock::block#0
byte memoryRemapBlock::blockBits
byte memoryRemapBlock::blockBits#0
byte memoryRemapBlock::blockPage
byte memoryRemapBlock::blockPage#0
byte memoryRemapBlock::blockPage#1
byte memoryRemapBlock::blockPage#2
word memoryRemapBlock::memoryPage
word memoryRemapBlock::memoryPage#0
word memoryRemapBlock::memoryPage#1
word memoryRemapBlock::memoryPage#2
word memoryRemapBlock::pageOffset
word memoryRemapBlock::pageOffset#0

Adding number conversion cast (unumber) 4 in memoryRemap::$1 = memoryRemap::remapBlocks#2 << 4
Adding number conversion cast (unumber) $f in memoryRemap::$3 = memoryRemap::$2 & $f
Adding number conversion cast (unumber) memoryRemap::$3 in memoryRemap::$3 = memoryRemap::$2 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap::$4 in memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Adding number conversion cast (unumber) $f0 in memoryRemap::$6 = memoryRemap::remapBlocks#2 & $f0
Adding number conversion cast (unumber) memoryRemap::$6 in memoryRemap::$6 = memoryRemap::remapBlocks#2 & (unumber)$f0
Adding number conversion cast (unumber) $f in memoryRemap::$8 = memoryRemap::$7 & $f
Adding number conversion cast (unumber) memoryRemap::$8 in memoryRemap::$8 = memoryRemap::$7 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap::$9 in memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Adding number conversion cast (unumber) $20 in memoryRemapBlock::$1 = memoryRemapBlock::blockPage#2 / $20
Adding number conversion cast (unumber) memoryRemapBlock::$1 in memoryRemapBlock::$1 = memoryRemapBlock::blockPage#2 / (unumber)$20
Adding number conversion cast (unumber) 1 in memoryRemapBlock::$2 = 1 << memoryRemapBlock::block#0
Adding number conversion cast (unumber) memoryRemapBlock::$2 in memoryRemapBlock::$2 = (unumber)1 << memoryRemapBlock::block#0
Adding number conversion cast (unumber) 4 in memoryRemap256M::$0 = memoryRemap256M::lowerPageOffset#2 >> 4
Adding number conversion cast (unumber) 4 in memoryRemap256M::$2 = memoryRemap256M::upperPageOffset#2 >> 4
Adding number conversion cast (unumber) 4 in memoryRemap256M::$6 = memoryRemap256M::remapBlocks#2 << 4
Adding number conversion cast (unumber) $f in memoryRemap256M::$9 = memoryRemap256M::$8 & $f
Adding number conversion cast (unumber) memoryRemap256M::$9 in memoryRemap256M::$9 = memoryRemap256M::$8 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap256M::$10 in memoryRemap256M::$10 = memoryRemap256M::$6 | memoryRemap256M::$9
Adding number conversion cast (unumber) $f0 in memoryRemap256M::$13 = memoryRemap256M::remapBlocks#2 & $f0
Adding number conversion cast (unumber) memoryRemap256M::$13 in memoryRemap256M::$13 = memoryRemap256M::remapBlocks#2 & (unumber)$f0
Adding number conversion cast (unumber) $f in memoryRemap256M::$16 = memoryRemap256M::$15 & $f
Adding number conversion cast (unumber) memoryRemap256M::$16 in memoryRemap256M::$16 = memoryRemap256M::$15 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap256M::$17 in memoryRemap256M::$17 = memoryRemap256M::$13 | memoryRemap256M::$16
Adding number conversion cast (unumber) $40 in memoryRemapBlock::blockPage#0 = $40
Adding number conversion cast (unumber) $100 in memoryRemapBlock::memoryPage#0 = $100
Adding number conversion cast (unumber) 0 in main::BLOCK_4000[0] = '-'
Adding number conversion cast (unumber) 1 in main::BLOCK_4000[1] = '*'
Adding number conversion cast (unumber) $80 in memoryRemapBlock::blockPage#1 = $80
Adding number conversion cast (unumber) $100 in memoryRemapBlock::memoryPage#1 = $100
Adding number conversion cast (unumber) 2 in main::BLOCK_8000[2] = '-'
Adding number conversion cast (unumber) 3 in main::BLOCK_8000[3] = '*'
Adding number conversion cast (unumber) $c0 in memoryRemap::lowerPageOffset#1 = $c0
Adding number conversion cast (unumber) $80 in memoryRemap::upperPageOffset#1 = $80
Adding number conversion cast (unumber) 2 in main::BLOCK_8000[4] = main::BLOCK_4000[2]
Adding number conversion cast (unumber) 4 in main::BLOCK_8000[4] = main::BLOCK_4000[(unumber)2]
Adding number conversion cast (unumber) 1 in main::BLOCK_4000[5] = main::BLOCK_8000[1]
Adding number conversion cast (unumber) 5 in main::BLOCK_4000[5] = main::BLOCK_8000[(unumber)1]
Adding number conversion cast (unumber) 6 in main::$5 = main::i#2 < 6
Adding number conversion cast (unumber) 6 in (DEFAULT_SCREEN+$50-6)[main::i#3] = main::BLOCK_4000[main::i#3]
Adding number conversion cast (unumber) $50 in (DEFAULT_SCREEN+$50-(unumber)6)[main::i#3] = main::BLOCK_4000[main::i#3]
Adding number conversion cast (unumber) $ff800-$40 in memoryRemap256M::lowerPageOffset#0 = $ff800-$40
Adding number conversion cast (unumber) 0 in memoryRemap256M::upperPageOffset#0 = 0
Adding number conversion cast (unumber) $10 in main::$6 = main::i1#2 < $10
Adding number conversion cast (unumber) $40 in main::$7 = $40 + main::i1#3
Adding number conversion cast (unumber) main::$7 in main::$7 = (unumber)$40 + main::i1#3
Adding number conversion cast (unumber) 0 in memoryRemap256M::remapBlocks#1 = 0
Adding number conversion cast (unumber) 0 in memoryRemap256M::lowerPageOffset#1 = 0
Adding number conversion cast (unumber) 0 in memoryRemap256M::upperPageOffset#1 = 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast memoryRemapBlock::blockPage#0 = (unumber)$40
Inlining cast memoryRemapBlock::memoryPage#0 = (unumber)$100
Inlining cast memoryRemapBlock::blockPage#1 = (unumber)$80
Inlining cast memoryRemapBlock::memoryPage#1 = (unumber)$100
Inlining cast memoryRemap::lowerPageOffset#1 = (unumber)$c0
Inlining cast memoryRemap::upperPageOffset#1 = (unumber)$80
Inlining cast memoryRemap256M::lowerPageOffset#0 = (unumber)$ff800-$40
Inlining cast memoryRemap256M::upperPageOffset#0 = (unumber)0
Inlining cast memoryRemap256M::remapBlocks#1 = (unumber)0
Inlining cast memoryRemap256M::lowerPageOffset#1 = (unumber)0
Inlining cast memoryRemap256M::upperPageOffset#1 = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 252
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant pointer cast (byte*) 250
Simplifying constant pointer cast (byte*) 251
Simplifying constant pointer cast (byte*) 252
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant pointer cast (byte*) 2048
Simplifying constant pointer cast (byte*) 16384
Simplifying constant pointer cast (byte*) 32768
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Simplifying constant integer cast $20
Simplifying constant integer cast 1
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Simplifying constant integer cast $40
Simplifying constant integer cast $100
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast $80
Simplifying constant integer cast $100
Simplifying constant integer cast 2
Simplifying constant integer cast 3
Simplifying constant integer cast $c0
Simplifying constant integer cast $80
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 1
Simplifying constant integer cast 5
Simplifying constant integer cast 6
Simplifying constant integer cast $50
Simplifying constant integer cast 6
Simplifying constant integer cast 0
Simplifying constant integer cast $10
Simplifying constant integer cast $40
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type 4
Finalized unsigned number type $f
Finalized unsigned number type $f0
Finalized unsigned number type $f
Finalized unsigned number type $20
Finalized unsigned number type 1
Finalized unsigned number type 4
Finalized unsigned number type 4
Finalized unsigned number type 4
Finalized unsigned number type $f
Finalized unsigned number type $f0
Finalized unsigned number type $f
Finalized unsigned number type $40
Finalized unsigned number type $100
Finalized unsigned number type 0
Finalized unsigned number type 1
Finalized unsigned number type $80
Finalized unsigned number type $100
Finalized unsigned number type 2
Finalized unsigned number type 3
Finalized unsigned number type $c0
Finalized unsigned number type $80
Finalized unsigned number type 2
Finalized unsigned number type 4
Finalized unsigned number type 1
Finalized unsigned number type 5
Finalized unsigned number type 6
Finalized unsigned number type $50
Finalized unsigned number type 6
Finalized unsigned number type 0
Finalized unsigned number type $10
Finalized unsigned number type $40
Finalized unsigned number type 0
Finalized unsigned number type 0
Finalized unsigned number type 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in memoryRemap::$3 = memoryRemap::$2 & $f
Inferred type updated to byte in memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Inferred type updated to byte in memoryRemap::$6 = memoryRemap::remapBlocks#2 & $f0
Inferred type updated to byte in memoryRemap::$8 = memoryRemap::$7 & $f
Inferred type updated to byte in memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Inferred type updated to byte in memoryRemapBlock::$1 = memoryRemapBlock::blockPage#2 / $20
Inferred type updated to byte in memoryRemapBlock::$2 = 1 << memoryRemapBlock::block#0
Inferred type updated to byte in memoryRemap256M::$9 = memoryRemap256M::$8 & $f
Inferred type updated to byte in memoryRemap256M::$10 = memoryRemap256M::$6 | memoryRemap256M::$9
Inferred type updated to byte in memoryRemap256M::$13 = memoryRemap256M::remapBlocks#2 & $f0
Inferred type updated to byte in memoryRemap256M::$16 = memoryRemap256M::$15 & $f
Inferred type updated to byte in memoryRemap256M::$17 = memoryRemap256M::$13 | memoryRemap256M::$16
Inferred type updated to byte in main::$7 = $40 + main::i1#3
Alias memoryRemapBlock::pageOffset#0 = memoryRemapBlock::$0 
Alias memoryRemapBlock::block#0 = memoryRemapBlock::$1 
Alias memoryRemapBlock::blockBits#0 = memoryRemapBlock::$2 
Alias main::i#2 = main::i#3 
Alias main::i1#2 = main::i1#3 
Successful SSA optimization Pass2AliasElimination
Simple Condition main::$5 [72] if(main::i#2<6) goto main::@2
Simple Condition main::$6 [82] if(main::i1#2<$10) goto main::@5
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [76] memoryRemap256M::lowerPageOffset#0 = (unumber)$ff800-$40
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemapBlock::blockPage#0 = $40
Constant memoryRemapBlock::memoryPage#0 = $100
Constant memoryRemapBlock::blockPage#1 = $80
Constant memoryRemapBlock::memoryPage#1 = $100
Constant memoryRemap::remapBlocks#1 = MEMORYBLOCK_4000|MEMORYBLOCK_8000
Constant memoryRemap::lowerPageOffset#1 = $c0
Constant memoryRemap::upperPageOffset#1 = $80
Constant main::i#0 = 0
Constant memoryRemap256M::remapBlocks#0 = MEMORYBLOCK_4000
Constant memoryRemap256M::lowerPageOffset#0 = (unumber)$ff800-$40
Constant memoryRemap256M::upperPageOffset#0 = 0
Constant main::i1#0 = 0
Constant memoryRemap256M::remapBlocks#1 = 0
Constant memoryRemap256M::lowerPageOffset#1 = 0
Constant memoryRemap256M::upperPageOffset#1 = 0
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero main::BLOCK_4000 in [56] main::BLOCK_4000[0] = '-'
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Rewriting division to use shift [19] memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 / $20
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings memoryRemap::remapBlocks#1
Inlining constant with var siblings memoryRemap::lowerPageOffset#1
Inlining constant with var siblings memoryRemap::upperPageOffset#1
Inlining constant with var siblings memoryRemapBlock::blockPage#0
Inlining constant with var siblings memoryRemapBlock::memoryPage#0
Inlining constant with var siblings memoryRemapBlock::blockPage#1
Inlining constant with var siblings memoryRemapBlock::memoryPage#1
Inlining constant with var siblings memoryRemap256M::remapBlocks#0
Inlining constant with var siblings memoryRemap256M::lowerPageOffset#0
Inlining constant with var siblings memoryRemap256M::upperPageOffset#0
Inlining constant with var siblings memoryRemap256M::remapBlocks#1
Inlining constant with var siblings memoryRemap256M::lowerPageOffset#1
Inlining constant with var siblings memoryRemap256M::upperPageOffset#1
Inlining constant with var siblings main::i#0
Inlining constant with var siblings main::i1#0
Constant inlined memoryRemap::remapBlocks#1 = MEMORYBLOCK_4000|MEMORYBLOCK_8000
Constant inlined memoryRemapBlock::blockPage#1 = $80
Constant inlined memoryRemapBlock::blockPage#0 = $40
Constant inlined memoryRemap::upperPageOffset#1 = $80
Constant inlined memoryRemapBlock::memoryPage#1 = $100
Constant inlined memoryRemapBlock::memoryPage#0 = $100
Constant inlined memoryRemap256M::upperPageOffset#1 = 0
Constant inlined memoryRemap256M::upperPageOffset#0 = 0
Constant inlined memoryRemap::lowerPageOffset#1 = $c0
Constant inlined main::i#0 = 0
Constant inlined main::i1#0 = 0
Constant inlined memoryRemap256M::lowerPageOffset#0 = (dword)$ff800-$40
Constant inlined memoryRemap256M::lowerPageOffset#1 = 0
Constant inlined memoryRemap256M::remapBlocks#1 = 0
Constant inlined memoryRemap256M::remapBlocks#0 = MEMORYBLOCK_4000
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(main::BLOCK_4000+1)
Consolidated array index constant in *(main::BLOCK_8000+2)
Consolidated array index constant in *(main::BLOCK_8000+3)
Consolidated array index constant in *(main::BLOCK_4000+2)
Consolidated array index constant in *(main::BLOCK_8000+4)
Consolidated array index constant in *(main::BLOCK_8000+1)
Consolidated array index constant in *(main::BLOCK_4000+5)
Successful SSA optimization Pass2ConstantAdditionElimination
Identical Phi Values memoryRemapBlock::memoryPage#2 $100
Identical Phi Values memoryRemap256M::upperPageOffset#2 0
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [30] memoryRemap256M::$2 = 0 >> 4
Constant right-side identified [42] memoryRemap256M::$11 = < 0
Constant right-side identified [46] memoryRemap256M::$14 = < 0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap256M::$2 = 0>>4
Constant memoryRemap256M::$11 = <0
Constant memoryRemap256M::$14 = <0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)memoryRemap256M::$2 in [31] memoryRemap256M::$3 = > (word)memoryRemap256M::$2
Successful SSA optimization Pass2ConstantValues
Simplifying constant evaluating to zero 0>>4 in 
Simplifying constant evaluating to zero <0 in 
Simplifying constant evaluating to zero <0 in 
Simplifying constant evaluating to zero (word)memoryRemap256M::$2 in [31] memoryRemap256M::$3 = > (word)memoryRemap256M::$2
Successful SSA optimization PassNSimplifyConstantZero
Eliminating unused constant memoryRemap256M::$2
Successful SSA optimization PassNEliminateUnusedVars
Constant inlined memoryRemap256M::$11 = 0
Constant inlined memoryRemap256M::$14 = 0
Successful SSA optimization Pass2ConstantInlining
Constant right-side identified [30] memoryRemap256M::$3 = > 0
Constant right-side identified [41] memoryRemap256M::$12 = < 0
Constant right-side identified [44] memoryRemap256M::$15 = > 0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap256M::$3 = >0
Constant memoryRemap256M::$12 = <0
Constant memoryRemap256M::$15 = >0
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero >0 in 
Simplifying constant evaluating to zero <0 in 
Simplifying constant evaluating to zero >0 in 
Successful SSA optimization PassNSimplifyConstantZero
Constant inlined memoryRemap256M::$15 = 0
Constant inlined memoryRemap256M::$12 = 0
Constant inlined memoryRemap256M::$3 = 0
Successful SSA optimization Pass2ConstantInlining
Constant right-side identified [42] memoryRemap256M::$16 = 0 & $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap256M::$16 = 0&$f
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero 0&$f in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero memoryRemap256M::$13 in [43] memoryRemap256M::$17 = memoryRemap256M::$13 | memoryRemap256M::$16
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant memoryRemap256M::$16
Successful SSA optimization PassNEliminateUnusedVars
Alias memoryRemap256M::$17 = memoryRemap256M::$13 
Successful SSA optimization Pass2AliasElimination
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of memoryRemapBlock::@1
CALL GRAPH
Calls in [main] to memoryRemapBlock:1 memoryRemapBlock:4 memoryRemap:7 memoryRemap256M:13 memoryRemap256M:18 
Calls in [memoryRemapBlock] to memoryRemap:38 

Created 8 initial phi equivalence classes
Coalesced [24] main::i1#4 = main::i1#1
Coalesced [27] main::i#4 = main::i#1
Coalesced [35] memoryRemap::lowerPageOffset#3 = memoryRemap::lowerPageOffset#0
Coalesced [36] memoryRemap::remapBlocks#3 = memoryRemap::remapBlocks#0
Coalesced [37] memoryRemap::upperPageOffset#3 = memoryRemap::upperPageOffset#0
Coalesced down to 8 phi equivalence classes
Culled Empty Block label main::@10
Culled Empty Block label main::@11
Culled Empty Block label memoryRemapBlock::@1
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@6

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call memoryRemapBlock 
  to:main::@7
main::@7: scope:[main]  from main
  [2] *main::BLOCK_4000 = '-'
  [3] *(main::BLOCK_4000+1) = '*'
  [4] call memoryRemapBlock 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [5] *(main::BLOCK_8000+2) = '-'
  [6] *(main::BLOCK_8000+3) = '*'
  [7] call memoryRemap 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [8] *(main::BLOCK_8000+4) = *(main::BLOCK_4000+2)
  [9] *(main::BLOCK_4000+5) = *(main::BLOCK_8000+1)
  to:main::@1
main::@1: scope:[main]  from main::@2 main::@9
  [10] main::i#2 = phi( main::@2/main::i#1, main::@9/0 )
  [11] if(main::i#2<6) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [12] phi()
  [13] call memoryRemap256M 
  to:main::@4
main::@4: scope:[main]  from main::@3 main::@5
  [14] main::i1#2 = phi( main::@3/0, main::@5/main::i1#1 )
  [15] if(main::i1#2<$10) goto main::@5
  to:main::@6
main::@6: scope:[main]  from main::@4
  [16] phi()
  [17] call memoryRemap256M 
  to:main::@return
main::@return: scope:[main]  from main::@6
  [18] return 
  to:@return
main::@5: scope:[main]  from main::@4
  [19] main::$7 = $40 + main::i1#2
  [20] main::BLOCK_4000[main::i1#2] = main::$7
  [21] main::i1#1 = ++ main::i1#2
  to:main::@4
main::@2: scope:[main]  from main::@1
  [22] (DEFAULT_SCREEN+$50-6)[main::i#2] = main::BLOCK_4000[main::i#2]
  [23] main::i#1 = ++ main::i#2
  to:main::@1

void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
memoryRemapBlock: scope:[memoryRemapBlock]  from main main::@7
  [24] memoryRemapBlock::blockPage#2 = phi( main/$40, main::@7/$80 )
  [25] memoryRemapBlock::pageOffset#0 = $100 - memoryRemapBlock::blockPage#2
  [26] memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 >> 5
  [27] memoryRemapBlock::blockBits#0 = 1 << memoryRemapBlock::block#0
  [28] memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0
  [29] memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
  [30] memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0
  [31] call memoryRemap 
  to:memoryRemapBlock::@return
memoryRemapBlock::@return: scope:[memoryRemapBlock]  from memoryRemapBlock
  [32] return 
  to:@return

void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main::@8 memoryRemapBlock
  [33] memoryRemap::upperPageOffset#2 = phi( main::@8/$80, memoryRemapBlock/memoryRemap::upperPageOffset#0 )
  [33] memoryRemap::remapBlocks#2 = phi( main::@8/MEMORYBLOCK_4000|MEMORYBLOCK_8000, memoryRemapBlock/memoryRemap::remapBlocks#0 )
  [33] memoryRemap::lowerPageOffset#2 = phi( main::@8/$c0, memoryRemapBlock/memoryRemap::lowerPageOffset#0 )
  [34] memoryRemap::$0 = < memoryRemap::lowerPageOffset#2
  [35] *memoryRemap::aVal = memoryRemap::$0
  [36] memoryRemap::$1 = memoryRemap::remapBlocks#2 << 4
  [37] memoryRemap::$2 = > memoryRemap::lowerPageOffset#2
  [38] memoryRemap::$3 = memoryRemap::$2 & $f
  [39] memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
  [40] *memoryRemap::xVal = memoryRemap::$4
  [41] memoryRemap::$5 = < memoryRemap::upperPageOffset#2
  [42] *memoryRemap::yVal = memoryRemap::$5
  [43] memoryRemap::$6 = memoryRemap::remapBlocks#2 & $f0
  [44] memoryRemap::$7 = > memoryRemap::upperPageOffset#2
  [45] memoryRemap::$8 = memoryRemap::$7 & $f
  [46] memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
  [47] *memoryRemap::zVal = memoryRemap::$9
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  [49] return 
  to:@return

void memoryRemap256M(byte memoryRemap256M::remapBlocks , dword memoryRemap256M::lowerPageOffset , dword memoryRemap256M::upperPageOffset)
memoryRemap256M: scope:[memoryRemap256M]  from main::@3 main::@6
  [50] memoryRemap256M::remapBlocks#2 = phi( main::@3/MEMORYBLOCK_4000, main::@6/0 )
  [50] memoryRemap256M::lowerPageOffset#2 = phi( main::@3/(dword)$ff800-$40, main::@6/0 )
  [51] memoryRemap256M::$0 = memoryRemap256M::lowerPageOffset#2 >> 4
  [52] memoryRemap256M::$1 = > (word)memoryRemap256M::$0
  [53] *memoryRemap256M::lMb = memoryRemap256M::$1
  [54] *memoryRemap256M::uMb = 0
  [55] memoryRemap256M::$4 = < memoryRemap256M::lowerPageOffset#2
  [56] memoryRemap256M::$5 = < memoryRemap256M::$4
  [57] *memoryRemap256M::aVal = memoryRemap256M::$5
  [58] memoryRemap256M::$6 = memoryRemap256M::remapBlocks#2 << 4
  [59] memoryRemap256M::$7 = < memoryRemap256M::lowerPageOffset#2
  [60] memoryRemap256M::$8 = > memoryRemap256M::$7
  [61] memoryRemap256M::$9 = memoryRemap256M::$8 & $f
  [62] memoryRemap256M::$10 = memoryRemap256M::$6 | memoryRemap256M::$9
  [63] *memoryRemap256M::xVal = memoryRemap256M::$10
  [64] *memoryRemap256M::yVal = 0
  [65] memoryRemap256M::$17 = memoryRemap256M::remapBlocks#2 & $f0
  [66] *memoryRemap256M::zVal = memoryRemap256M::$17
  asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap256M::@return
memoryRemap256M::@return: scope:[memoryRemap256M]  from memoryRemap256M
  [68] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void main()
byte~ main::$7 22.0
byte main::i
byte main::i#1 22.0
byte main::i#2 18.333333333333332
byte main::i1
byte main::i1#1 22.0
byte main::i1#2 13.75
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
byte~ memoryRemap::$0 202.0
byte~ memoryRemap::$1 67.33333333333333
byte~ memoryRemap::$2 202.0
byte~ memoryRemap::$3 202.0
byte~ memoryRemap::$4 202.0
byte~ memoryRemap::$5 202.0
byte~ memoryRemap::$6 67.33333333333333
byte~ memoryRemap::$7 202.0
byte~ memoryRemap::$8 202.0
byte~ memoryRemap::$9 202.0
word memoryRemap::lowerPageOffset
word memoryRemap::lowerPageOffset#0 11.0
word memoryRemap::lowerPageOffset#2 53.25
byte memoryRemap::remapBlocks
byte memoryRemap::remapBlocks#0 7.333333333333333
byte memoryRemap::remapBlocks#2 21.299999999999997
word memoryRemap::upperPageOffset
word memoryRemap::upperPageOffset#0 22.0
word memoryRemap::upperPageOffset#2 19.363636363636363
void memoryRemap256M(byte memoryRemap256M::remapBlocks , dword memoryRemap256M::lowerPageOffset , dword memoryRemap256M::upperPageOffset)
dword~ memoryRemap256M::$0 11.0
byte~ memoryRemap256M::$1 22.0
byte~ memoryRemap256M::$10 22.0
byte~ memoryRemap256M::$17 22.0
word~ memoryRemap256M::$4 22.0
byte~ memoryRemap256M::$5 22.0
byte~ memoryRemap256M::$6 5.5
word~ memoryRemap256M::$7 22.0
byte~ memoryRemap256M::$8 22.0
byte~ memoryRemap256M::$9 22.0
dword memoryRemap256M::lowerPageOffset
dword memoryRemap256M::lowerPageOffset#2 3.666666666666667
byte memoryRemap256M::remapBlocks
byte memoryRemap256M::remapBlocks#2 1.4666666666666666
dword memoryRemap256M::upperPageOffset
void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
byte memoryRemapBlock::block
byte memoryRemapBlock::block#0 22.0
byte memoryRemapBlock::blockBits
byte memoryRemapBlock::blockBits#0 22.0
byte memoryRemapBlock::blockPage
byte memoryRemapBlock::blockPage#2 11.0
word memoryRemapBlock::memoryPage
word memoryRemapBlock::pageOffset
word memoryRemapBlock::pageOffset#0 6.6000000000000005

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ main::i1#2 main::i1#1 ]
[ memoryRemapBlock::blockPage#2 ]
[ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 ]
[ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ]
[ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#0 ]
[ memoryRemap256M::lowerPageOffset#2 ]
[ memoryRemap256M::remapBlocks#2 ]
Added variable main::$7 to live range equivalence class [ main::$7 ]
Added variable memoryRemapBlock::pageOffset#0 to live range equivalence class [ memoryRemapBlock::pageOffset#0 ]
Added variable memoryRemapBlock::block#0 to live range equivalence class [ memoryRemapBlock::block#0 ]
Added variable memoryRemapBlock::blockBits#0 to live range equivalence class [ memoryRemapBlock::blockBits#0 ]
Added variable memoryRemap::$0 to live range equivalence class [ memoryRemap::$0 ]
Added variable memoryRemap::$1 to live range equivalence class [ memoryRemap::$1 ]
Added variable memoryRemap::$2 to live range equivalence class [ memoryRemap::$2 ]
Added variable memoryRemap::$3 to live range equivalence class [ memoryRemap::$3 ]
Added variable memoryRemap::$4 to live range equivalence class [ memoryRemap::$4 ]
Added variable memoryRemap::$5 to live range equivalence class [ memoryRemap::$5 ]
Added variable memoryRemap::$6 to live range equivalence class [ memoryRemap::$6 ]
Added variable memoryRemap::$7 to live range equivalence class [ memoryRemap::$7 ]
Added variable memoryRemap::$8 to live range equivalence class [ memoryRemap::$8 ]
Added variable memoryRemap::$9 to live range equivalence class [ memoryRemap::$9 ]
Added variable memoryRemap256M::$0 to live range equivalence class [ memoryRemap256M::$0 ]
Added variable memoryRemap256M::$1 to live range equivalence class [ memoryRemap256M::$1 ]
Added variable memoryRemap256M::$4 to live range equivalence class [ memoryRemap256M::$4 ]
Added variable memoryRemap256M::$5 to live range equivalence class [ memoryRemap256M::$5 ]
Added variable memoryRemap256M::$6 to live range equivalence class [ memoryRemap256M::$6 ]
Added variable memoryRemap256M::$7 to live range equivalence class [ memoryRemap256M::$7 ]
Added variable memoryRemap256M::$8 to live range equivalence class [ memoryRemap256M::$8 ]
Added variable memoryRemap256M::$9 to live range equivalence class [ memoryRemap256M::$9 ]
Added variable memoryRemap256M::$10 to live range equivalence class [ memoryRemap256M::$10 ]
Added variable memoryRemap256M::$17 to live range equivalence class [ memoryRemap256M::$17 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ main::i1#2 main::i1#1 ]
[ memoryRemapBlock::blockPage#2 ]
[ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 ]
[ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ]
[ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#0 ]
[ memoryRemap256M::lowerPageOffset#2 ]
[ memoryRemap256M::remapBlocks#2 ]
[ main::$7 ]
[ memoryRemapBlock::pageOffset#0 ]
[ memoryRemapBlock::block#0 ]
[ memoryRemapBlock::blockBits#0 ]
[ memoryRemap::$0 ]
[ memoryRemap::$1 ]
[ memoryRemap::$2 ]
[ memoryRemap::$3 ]
[ memoryRemap::$4 ]
[ memoryRemap::$5 ]
[ memoryRemap::$6 ]
[ memoryRemap::$7 ]
[ memoryRemap::$8 ]
[ memoryRemap::$9 ]
[ memoryRemap256M::$0 ]
[ memoryRemap256M::$1 ]
[ memoryRemap256M::$4 ]
[ memoryRemap256M::$5 ]
[ memoryRemap256M::$6 ]
[ memoryRemap256M::$7 ]
[ memoryRemap256M::$8 ]
[ memoryRemap256M::$9 ]
[ memoryRemap256M::$10 ]
[ memoryRemap256M::$17 ]
Allocated zp[1]:2 [ main::i#2 main::i#1 ]
Allocated zp[1]:3 [ main::i1#2 main::i1#1 ]
Allocated zp[1]:4 [ memoryRemapBlock::blockPage#2 ]
Allocated zp[2]:5 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 ]
Allocated zp[1]:7 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ]
Allocated zp[2]:8 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#0 ]
Allocated zp[4]:10 [ memoryRemap256M::lowerPageOffset#2 ]
Allocated zp[1]:14 [ memoryRemap256M::remapBlocks#2 ]
Allocated zp[1]:15 [ main::$7 ]
Allocated zp[2]:16 [ memoryRemapBlock::pageOffset#0 ]
Allocated zp[1]:18 [ memoryRemapBlock::block#0 ]
Allocated zp[1]:19 [ memoryRemapBlock::blockBits#0 ]
Allocated zp[1]:20 [ memoryRemap::$0 ]
Allocated zp[1]:21 [ memoryRemap::$1 ]
Allocated zp[1]:22 [ memoryRemap::$2 ]
Allocated zp[1]:23 [ memoryRemap::$3 ]
Allocated zp[1]:24 [ memoryRemap::$4 ]
Allocated zp[1]:25 [ memoryRemap::$5 ]
Allocated zp[1]:26 [ memoryRemap::$6 ]
Allocated zp[1]:27 [ memoryRemap::$7 ]
Allocated zp[1]:28 [ memoryRemap::$8 ]
Allocated zp[1]:29 [ memoryRemap::$9 ]
Allocated zp[4]:30 [ memoryRemap256M::$0 ]
Allocated zp[1]:34 [ memoryRemap256M::$1 ]
Allocated zp[2]:35 [ memoryRemap256M::$4 ]
Allocated zp[1]:37 [ memoryRemap256M::$5 ]
Allocated zp[1]:38 [ memoryRemap256M::$6 ]
Allocated zp[2]:39 [ memoryRemap256M::$7 ]
Allocated zp[1]:41 [ memoryRemap256M::$8 ]
Allocated zp[1]:42 [ memoryRemap256M::$9 ]
Allocated zp[1]:43 [ memoryRemap256M::$10 ]
Allocated zp[1]:44 [ memoryRemap256M::$17 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] *main::BLOCK_4000 = '-' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] *(main::BLOCK_4000+1) = '*' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *(main::BLOCK_8000+2) = '-' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] *(main::BLOCK_8000+3) = '*' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] *(main::BLOCK_8000+4) = *(main::BLOCK_4000+2) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] *(main::BLOCK_4000+5) = *(main::BLOCK_8000+1) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [19] main::$7 = $40 + main::i1#2 [ main::i1#2 main::$7 ] (  [ main::i1#2 main::$7 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:3 [ main::i1#2 main::i1#1 ]
Statement [22] (DEFAULT_SCREEN+$50-6)[main::i#2] = main::BLOCK_4000[main::i#2] [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::i#2 main::i#1 ]
Statement [25] memoryRemapBlock::pageOffset#0 = $100 - memoryRemapBlock::blockPage#2 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ memoryRemapBlock::blockPage#2 ]
Statement [26] memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 >> 5 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [27] memoryRemapBlock::blockBits#0 = 1 << memoryRemapBlock::block#0 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [29] memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:7 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ]
Statement [30] memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0 [ memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 memoryRemap::upperPageOffset#0 ] ( memoryRemapBlock:1 [ memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 memoryRemap::upperPageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 memoryRemap::upperPageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [36] memoryRemap::$1 = memoryRemap::remapBlocks#2 << 4 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] ( memoryRemap:7 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { }  memoryRemapBlock:1::memoryRemap:31 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:31 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [38] memoryRemap::$3 = memoryRemap::$2 & $f [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] ( memoryRemap:7 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:1::memoryRemap:31 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:31 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:21 [ memoryRemap::$1 ]
Statement [43] memoryRemap::$6 = memoryRemap::remapBlocks#2 & $f0 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] ( memoryRemap:7 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { }  memoryRemapBlock:1::memoryRemap:31 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:31 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [45] memoryRemap::$8 = memoryRemap::$7 & $f [ memoryRemap::$6 memoryRemap::$8 ] ( memoryRemap:7 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:1::memoryRemap:31 [ memoryRemap::$6 memoryRemap::$8 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:31 [ memoryRemap::$6 memoryRemap::$8 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:26 [ memoryRemap::$6 ]
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [51] memoryRemap256M::$0 = memoryRemap256M::lowerPageOffset#2 >> 4 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] ( memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] { }  memoryRemap256M:17 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:14 [ memoryRemap256M::remapBlocks#2 ]
Statement [54] *memoryRemap256M::uMb = 0 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] ( memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] { }  memoryRemap256M:17 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] { }  ) always clobbers reg byte a 
Statement [55] memoryRemap256M::$4 = < memoryRemap256M::lowerPageOffset#2 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$4 ] ( memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$4 ] { }  memoryRemap256M:17 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$4 ] { }  ) always clobbers reg byte a 
Statement [58] memoryRemap256M::$6 = memoryRemap256M::remapBlocks#2 << 4 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 ] ( memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 ] { }  memoryRemap256M:17 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 ] { }  ) always clobbers reg byte a 
Statement [59] memoryRemap256M::$7 = < memoryRemap256M::lowerPageOffset#2 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$7 ] ( memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$7 ] { }  memoryRemap256M:17 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$7 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:38 [ memoryRemap256M::$6 ]
Statement [61] memoryRemap256M::$9 = memoryRemap256M::$8 & $f [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] ( memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] { }  memoryRemap256M:17 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] { }  ) always clobbers reg byte a 
Statement [64] *memoryRemap256M::yVal = 0 [ memoryRemap256M::remapBlocks#2 ] ( memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 ] { }  memoryRemap256M:17 [ memoryRemap256M::remapBlocks#2 ] { }  ) always clobbers reg byte a 
Statement [65] memoryRemap256M::$17 = memoryRemap256M::remapBlocks#2 & $f0 [ memoryRemap256M::$17 ] ( memoryRemap256M:13 [ memoryRemap256M::$17 ] { }  memoryRemap256M:17 [ memoryRemap256M::$17 ] { }  ) always clobbers reg byte a 
Statement asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [2] *main::BLOCK_4000 = '-' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] *(main::BLOCK_4000+1) = '*' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *(main::BLOCK_8000+2) = '-' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] *(main::BLOCK_8000+3) = '*' [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] *(main::BLOCK_8000+4) = *(main::BLOCK_4000+2) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] *(main::BLOCK_4000+5) = *(main::BLOCK_8000+1) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [19] main::$7 = $40 + main::i1#2 [ main::i1#2 main::$7 ] (  [ main::i1#2 main::$7 ] { }  ) always clobbers reg byte a 
Statement [22] (DEFAULT_SCREEN+$50-6)[main::i#2] = main::BLOCK_4000[main::i#2] [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [25] memoryRemapBlock::pageOffset#0 = $100 - memoryRemapBlock::blockPage#2 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::blockPage#2 memoryRemapBlock::pageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [26] memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 >> 5 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::block#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [27] memoryRemapBlock::blockBits#0 = 1 << memoryRemapBlock::block#0 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemapBlock::blockBits#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [29] memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 ] ( memoryRemapBlock:1 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemapBlock::pageOffset#0 memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [30] memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0 [ memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 memoryRemap::upperPageOffset#0 ] ( memoryRemapBlock:1 [ memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 memoryRemap::upperPageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4 [ memoryRemap::remapBlocks#0 memoryRemap::lowerPageOffset#0 memoryRemap::upperPageOffset#0 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [36] memoryRemap::$1 = memoryRemap::remapBlocks#2 << 4 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] ( memoryRemap:7 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { }  memoryRemapBlock:1::memoryRemap:31 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:31 [ memoryRemap::lowerPageOffset#2 memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [38] memoryRemap::$3 = memoryRemap::$2 & $f [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] ( memoryRemap:7 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:1::memoryRemap:31 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:31 [ memoryRemap::remapBlocks#2 memoryRemap::upperPageOffset#2 memoryRemap::$1 memoryRemap::$3 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [43] memoryRemap::$6 = memoryRemap::remapBlocks#2 & $f0 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] ( memoryRemap:7 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { }  memoryRemapBlock:1::memoryRemap:31 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:31 [ memoryRemap::upperPageOffset#2 memoryRemap::$6 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement [45] memoryRemap::$8 = memoryRemap::$7 & $f [ memoryRemap::$6 memoryRemap::$8 ] ( memoryRemap:7 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:1::memoryRemap:31 [ memoryRemap::$6 memoryRemap::$8 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  memoryRemapBlock:4::memoryRemap:31 [ memoryRemap::$6 memoryRemap::$8 ] { { memoryRemap::remapBlocks#0 = memoryRemap::remapBlocks#2 memoryRemapBlock::blockBits#0 } { memoryRemap::upperPageOffset#0 = memoryRemap::upperPageOffset#2 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 } }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [51] memoryRemap256M::$0 = memoryRemap256M::lowerPageOffset#2 >> 4 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] ( memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] { }  memoryRemap256M:17 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$0 ] { }  ) always clobbers reg byte a 
Statement [54] *memoryRemap256M::uMb = 0 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] ( memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] { }  memoryRemap256M:17 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 ] { }  ) always clobbers reg byte a 
Statement [55] memoryRemap256M::$4 = < memoryRemap256M::lowerPageOffset#2 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$4 ] ( memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$4 ] { }  memoryRemap256M:17 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$4 ] { }  ) always clobbers reg byte a 
Statement [58] memoryRemap256M::$6 = memoryRemap256M::remapBlocks#2 << 4 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 ] ( memoryRemap256M:13 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 ] { }  memoryRemap256M:17 [ memoryRemap256M::lowerPageOffset#2 memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 ] { }  ) always clobbers reg byte a 
Statement [59] memoryRemap256M::$7 = < memoryRemap256M::lowerPageOffset#2 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$7 ] ( memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$7 ] { }  memoryRemap256M:17 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$7 ] { }  ) always clobbers reg byte a 
Statement [61] memoryRemap256M::$9 = memoryRemap256M::$8 & $f [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] ( memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] { }  memoryRemap256M:17 [ memoryRemap256M::remapBlocks#2 memoryRemap256M::$6 memoryRemap256M::$9 ] { }  ) always clobbers reg byte a 
Statement [64] *memoryRemap256M::yVal = 0 [ memoryRemap256M::remapBlocks#2 ] ( memoryRemap256M:13 [ memoryRemap256M::remapBlocks#2 ] { }  memoryRemap256M:17 [ memoryRemap256M::remapBlocks#2 ] { }  ) always clobbers reg byte a 
Statement [65] memoryRemap256M::$17 = memoryRemap256M::remapBlocks#2 & $f0 [ memoryRemap256M::$17 ] ( memoryRemap256M:13 [ memoryRemap256M::$17 ] { }  memoryRemap256M:17 [ memoryRemap256M::$17 ] { }  ) always clobbers reg byte a 
Statement asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Potential registers zp[1]:2 [ main::i#2 main::i#1 ] : zp[1]:2 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:3 [ main::i1#2 main::i1#1 ] : zp[1]:3 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:4 [ memoryRemapBlock::blockPage#2 ] : zp[1]:4 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:5 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 ] : zp[2]:5 , 
Potential registers zp[1]:7 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ] : zp[1]:7 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:8 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#0 ] : zp[2]:8 , 
Potential registers zp[4]:10 [ memoryRemap256M::lowerPageOffset#2 ] : zp[4]:10 , 
Potential registers zp[1]:14 [ memoryRemap256M::remapBlocks#2 ] : zp[1]:14 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:15 [ main::$7 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:16 [ memoryRemapBlock::pageOffset#0 ] : zp[2]:16 , 
Potential registers zp[1]:18 [ memoryRemapBlock::block#0 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:19 [ memoryRemapBlock::blockBits#0 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:20 [ memoryRemap::$0 ] : zp[1]:20 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:21 [ memoryRemap::$1 ] : zp[1]:21 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:22 [ memoryRemap::$2 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:23 [ memoryRemap::$3 ] : zp[1]:23 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:24 [ memoryRemap::$4 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:25 [ memoryRemap::$5 ] : zp[1]:25 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:26 [ memoryRemap::$6 ] : zp[1]:26 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:27 [ memoryRemap::$7 ] : zp[1]:27 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:28 [ memoryRemap::$8 ] : zp[1]:28 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:29 [ memoryRemap::$9 ] : zp[1]:29 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[4]:30 [ memoryRemap256M::$0 ] : zp[4]:30 , 
Potential registers zp[1]:34 [ memoryRemap256M::$1 ] : zp[1]:34 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:35 [ memoryRemap256M::$4 ] : zp[2]:35 , 
Potential registers zp[1]:37 [ memoryRemap256M::$5 ] : zp[1]:37 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:38 [ memoryRemap256M::$6 ] : zp[1]:38 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:39 [ memoryRemap256M::$7 ] : zp[2]:39 , 
Potential registers zp[1]:41 [ memoryRemap256M::$8 ] : zp[1]:41 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:42 [ memoryRemap256M::$9 ] : zp[1]:42 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:43 [ memoryRemap256M::$10 ] : zp[1]:43 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:44 [ memoryRemap256M::$17 ] : zp[1]:44 , reg byte a , reg byte x , reg byte y , reg byte z , 

REGISTER UPLIFT SCOPES
Uplift Scope [memoryRemap] 202: zp[1]:20 [ memoryRemap::$0 ] 202: zp[1]:22 [ memoryRemap::$2 ] 202: zp[1]:23 [ memoryRemap::$3 ] 202: zp[1]:24 [ memoryRemap::$4 ] 202: zp[1]:25 [ memoryRemap::$5 ] 202: zp[1]:27 [ memoryRemap::$7 ] 202: zp[1]:28 [ memoryRemap::$8 ] 202: zp[1]:29 [ memoryRemap::$9 ] 67.33: zp[1]:21 [ memoryRemap::$1 ] 67.33: zp[1]:26 [ memoryRemap::$6 ] 64.25: zp[2]:5 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 ] 41.36: zp[2]:8 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#0 ] 28.63: zp[1]:7 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ] 
Uplift Scope [memoryRemap256M] 22: zp[1]:34 [ memoryRemap256M::$1 ] 22: zp[2]:35 [ memoryRemap256M::$4 ] 22: zp[1]:37 [ memoryRemap256M::$5 ] 22: zp[2]:39 [ memoryRemap256M::$7 ] 22: zp[1]:41 [ memoryRemap256M::$8 ] 22: zp[1]:42 [ memoryRemap256M::$9 ] 22: zp[1]:43 [ memoryRemap256M::$10 ] 22: zp[1]:44 [ memoryRemap256M::$17 ] 11: zp[4]:30 [ memoryRemap256M::$0 ] 5.5: zp[1]:38 [ memoryRemap256M::$6 ] 3.67: zp[4]:10 [ memoryRemap256M::lowerPageOffset#2 ] 1.47: zp[1]:14 [ memoryRemap256M::remapBlocks#2 ] 
Uplift Scope [main] 40.33: zp[1]:2 [ main::i#2 main::i#1 ] 35.75: zp[1]:3 [ main::i1#2 main::i1#1 ] 22: zp[1]:15 [ main::$7 ] 
Uplift Scope [memoryRemapBlock] 22: zp[1]:18 [ memoryRemapBlock::block#0 ] 22: zp[1]:19 [ memoryRemapBlock::blockBits#0 ] 11: zp[1]:4 [ memoryRemapBlock::blockPage#2 ] 6.6: zp[2]:16 [ memoryRemapBlock::pageOffset#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [MOS4569_VICIII] 
Uplift Scope [MEGA65_VICIV] 
Uplift Scope [F018_DMAGIC] 
Uplift Scope [DMA_LIST_F018A] 
Uplift Scope [DMA_LIST_F018B] 
Uplift Scope [] 

Uplifting [memoryRemap] best 1450 combination reg byte a [ memoryRemap::$0 ] reg byte a [ memoryRemap::$2 ] reg byte a [ memoryRemap::$3 ] zp[1]:24 [ memoryRemap::$4 ] zp[1]:25 [ memoryRemap::$5 ] zp[1]:27 [ memoryRemap::$7 ] zp[1]:28 [ memoryRemap::$8 ] zp[1]:29 [ memoryRemap::$9 ] zp[1]:21 [ memoryRemap::$1 ] zp[1]:26 [ memoryRemap::$6 ] zp[2]:5 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 ] zp[2]:8 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#0 ] zp[1]:7 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ] 
Limited combination testing to 100 combinations of 25000000 possible.
Uplifting [memoryRemap256M] best 1432 combination reg byte a [ memoryRemap256M::$1 ] zp[2]:35 [ memoryRemap256M::$4 ] reg byte a [ memoryRemap256M::$5 ] zp[2]:39 [ memoryRemap256M::$7 ] reg byte a [ memoryRemap256M::$8 ] zp[1]:42 [ memoryRemap256M::$9 ] zp[1]:43 [ memoryRemap256M::$10 ] zp[1]:44 [ memoryRemap256M::$17 ] zp[4]:30 [ memoryRemap256M::$0 ] zp[1]:38 [ memoryRemap256M::$6 ] zp[4]:10 [ memoryRemap256M::lowerPageOffset#2 ] zp[1]:14 [ memoryRemap256M::remapBlocks#2 ] 
Limited combination testing to 100 combinations of 250000 possible.
Uplifting [main] best 1122 combination reg byte x [ main::i#2 main::i#1 ] reg byte x [ main::i1#2 main::i1#1 ] reg byte a [ main::$7 ] 
Uplifting [memoryRemapBlock] best 1108 combination reg byte a [ memoryRemapBlock::block#0 ] reg byte a [ memoryRemapBlock::blockBits#0 ] reg byte x [ memoryRemapBlock::blockPage#2 ] zp[2]:16 [ memoryRemapBlock::pageOffset#0 ] 
Uplifting [MOS6526_CIA] best 1108 combination 
Uplifting [MOS6569_VICII] best 1108 combination 
Uplifting [MOS6581_SID] best 1108 combination 
Uplifting [MOS4569_VICIII] best 1108 combination 
Uplifting [MEGA65_VICIV] best 1108 combination 
Uplifting [F018_DMAGIC] best 1108 combination 
Uplifting [DMA_LIST_F018A] best 1108 combination 
Uplifting [DMA_LIST_F018B] best 1108 combination 
Uplifting [] best 1108 combination 
Attempting to uplift remaining variables inzp[1]:24 [ memoryRemap::$4 ]
Uplifting [memoryRemap] best 1102 combination reg byte a [ memoryRemap::$4 ] 
Attempting to uplift remaining variables inzp[1]:25 [ memoryRemap::$5 ]
Uplifting [memoryRemap] best 1096 combination reg byte a [ memoryRemap::$5 ] 
Attempting to uplift remaining variables inzp[1]:27 [ memoryRemap::$7 ]
Uplifting [memoryRemap] best 1090 combination reg byte a [ memoryRemap::$7 ] 
Attempting to uplift remaining variables inzp[1]:28 [ memoryRemap::$8 ]
Uplifting [memoryRemap] best 1084 combination reg byte a [ memoryRemap::$8 ] 
Attempting to uplift remaining variables inzp[1]:29 [ memoryRemap::$9 ]
Uplifting [memoryRemap] best 1078 combination reg byte a [ memoryRemap::$9 ] 
Attempting to uplift remaining variables inzp[1]:21 [ memoryRemap::$1 ]
Uplifting [memoryRemap] best 1078 combination zp[1]:21 [ memoryRemap::$1 ] 
Attempting to uplift remaining variables inzp[1]:26 [ memoryRemap::$6 ]
Uplifting [memoryRemap] best 1078 combination zp[1]:26 [ memoryRemap::$6 ] 
Attempting to uplift remaining variables inzp[1]:7 [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ]
Uplifting [memoryRemap] best 1069 combination reg byte z [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ] 
Attempting to uplift remaining variables inzp[1]:42 [ memoryRemap256M::$9 ]
Uplifting [memoryRemap256M] best 1063 combination reg byte a [ memoryRemap256M::$9 ] 
Attempting to uplift remaining variables inzp[1]:43 [ memoryRemap256M::$10 ]
Uplifting [memoryRemap256M] best 1057 combination reg byte a [ memoryRemap256M::$10 ] 
Attempting to uplift remaining variables inzp[1]:44 [ memoryRemap256M::$17 ]
Uplifting [memoryRemap256M] best 1051 combination reg byte a [ memoryRemap256M::$17 ] 
Attempting to uplift remaining variables inzp[1]:38 [ memoryRemap256M::$6 ]
Uplifting [memoryRemap256M] best 1051 combination zp[1]:38 [ memoryRemap256M::$6 ] 
Attempting to uplift remaining variables inzp[1]:14 [ memoryRemap256M::remapBlocks#2 ]
Uplifting [memoryRemap256M] best 1041 combination reg byte z [ memoryRemap256M::remapBlocks#2 ] 
Coalescing zero page register [ zp[2]:5 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 ] ] with [ zp[2]:16 [ memoryRemapBlock::pageOffset#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:35 [ memoryRemap256M::$4 ] ] with [ zp[2]:5 [ memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 ] ]
Coalescing zero page register [ zp[1]:38 [ memoryRemap256M::$6 ] ] with [ zp[1]:21 [ memoryRemap::$1 ] ]
Coalescing zero page register [ zp[2]:39 [ memoryRemap256M::$7 ] ] with [ zp[2]:8 [ memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#0 ] ]
Allocated (was zp[4]:10) zp[4]:2 [ memoryRemap256M::lowerPageOffset#2 ]
Allocated (was zp[1]:26) zp[1]:6 [ memoryRemap::$6 ]
Allocated (was zp[4]:30) zp[4]:7 [ memoryRemap256M::$0 ]
Allocated (was zp[2]:35) zp[2]:11 [ memoryRemap256M::$4 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 ]
Allocated (was zp[1]:38) zp[1]:13 [ memoryRemap256M::$6 memoryRemap::$1 ]
Allocated (was zp[2]:39) zp[2]:14 [ memoryRemap256M::$7 memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test the MAP instruction for remapping memory
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in https://mega.scryptos.com/sharefolder-link/MEGA/MEGA65+filehost/Docs/MEGA65-Book_draft.pdf for a description of the CPU memory remapper of the MEGA65.
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="memorymap-test.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // Bit representing 8K block #2 of the 64K addressable memory ($4000-$5fff)
  .const MEMORYBLOCK_4000 = 4
  // Bit representing 8K block #4 of the 64K addressable memory ($8000-$9fff)
  .const MEMORYBLOCK_8000 = $10
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
.segment Code
  // main
main: {
    .label BLOCK_4000 = $4000
    .label BLOCK_8000 = $8000
    // [1] call memoryRemapBlock 
  // Remap [$4000-$5fff] to point to [$10000-$11fff]
    // [24] phi from main to memoryRemapBlock [phi:main->memoryRemapBlock]
  memoryRemapBlock_from_main:
    // [24] phi memoryRemapBlock::blockPage#2 = $40 [phi:main->memoryRemapBlock#0] -- vbuxx=vbuc1 
    ldx #$40
    jsr memoryRemapBlock
    jmp __b7
    // main::@7
  __b7:
    // [2] *main::BLOCK_4000 = '-' -- _deref_pbuc1=vbuc2 
    // Put '-', '*' into $10000
    lda #'-'
    sta BLOCK_4000
    // [3] *(main::BLOCK_4000+1) = '*' -- _deref_pbuc1=vbuc2 
    lda #'*'
    sta BLOCK_4000+1
    // [4] call memoryRemapBlock 
  // Remap [$8000-$9fff] to point to [$10000-$11fff]
    // [24] phi from main::@7 to memoryRemapBlock [phi:main::@7->memoryRemapBlock]
  memoryRemapBlock_from___b7:
    // [24] phi memoryRemapBlock::blockPage#2 = $80 [phi:main::@7->memoryRemapBlock#0] -- vbuxx=vbuc1 
    ldx #$80
    jsr memoryRemapBlock
    jmp __b8
    // main::@8
  __b8:
    // [5] *(main::BLOCK_8000+2) = '-' -- _deref_pbuc1=vbuc2 
    // Put '-', '*' into $10002
    lda #'-'
    sta BLOCK_8000+2
    // [6] *(main::BLOCK_8000+3) = '*' -- _deref_pbuc1=vbuc2 
    lda #'*'
    sta BLOCK_8000+3
    // [7] call memoryRemap 
  // Remap [$4000-$5fff] and [$8000-$9fff] to both point to [$10000-$11fff] (notice usage of page offsets)
    // [33] phi from main::@8 to memoryRemap [phi:main::@8->memoryRemap]
  memoryRemap_from___b8:
    // [33] phi memoryRemap::upperPageOffset#2 = $80 [phi:main::@8->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<$80
    sta.z memoryRemap.upperPageOffset
    lda #>$80
    sta.z memoryRemap.upperPageOffset+1
    // [33] phi memoryRemap::remapBlocks#2 = MEMORYBLOCK_4000|MEMORYBLOCK_8000 [phi:main::@8->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #MEMORYBLOCK_4000|MEMORYBLOCK_8000
    // [33] phi memoryRemap::lowerPageOffset#2 = $c0 [phi:main::@8->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<$c0
    sta.z memoryRemap.lowerPageOffset
    lda #>$c0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __b9
    // main::@9
  __b9:
    // [8] *(main::BLOCK_8000+4) = *(main::BLOCK_4000+2) -- _deref_pbuc1=_deref_pbuc2 
    // Put '-', '*' into $10004 in a convoluted way
    lda BLOCK_4000+2
    sta BLOCK_8000+4
    // [9] *(main::BLOCK_4000+5) = *(main::BLOCK_8000+1) -- _deref_pbuc1=_deref_pbuc2 
    lda BLOCK_8000+1
    sta BLOCK_4000+5
    // [10] phi from main::@9 to main::@1 [phi:main::@9->main::@1]
  __b1_from___b9:
    // [10] phi main::i#2 = 0 [phi:main::@9->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
  // copy the resulting values onto the screen
    // main::@1
  __b1:
    // [11] if(main::i#2<6) goto main::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #6
    bcc __b2
    // [12] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [13] call memoryRemap256M 
  // Remap [$4000-$5fff] to both point to [$ff80000-$ff81fff] COLORAM! (notice usage of page offsets)
    // [50] phi from main::@3 to memoryRemap256M [phi:main::@3->memoryRemap256M]
  memoryRemap256M_from___b3:
    // [50] phi memoryRemap256M::remapBlocks#2 = MEMORYBLOCK_4000 [phi:main::@3->memoryRemap256M#0] -- vbuzz=vbuc1 
    ldz #MEMORYBLOCK_4000
    // [50] phi memoryRemap256M::lowerPageOffset#2 = (dword)$ff800-$40 [phi:main::@3->memoryRemap256M#1] -- vduz1=vduc1 
    lda #<$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset
    lda #>$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset+1
    lda #<$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+2
    lda #>$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    // [14] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  __b4_from___b3:
    // [14] phi main::i1#2 = 0 [phi:main::@3->main::@4#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b4
  // Put colors in the upper screen line
    // main::@4
  __b4:
    // [15] if(main::i1#2<$10) goto main::@5 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$10
    bcc __b5
    // [16] phi from main::@4 to main::@6 [phi:main::@4->main::@6]
  __b6_from___b4:
    jmp __b6
    // main::@6
  __b6:
    // [17] call memoryRemap256M 
  // Remap [$4000-$5fff] back to normal memory!
    // [50] phi from main::@6 to memoryRemap256M [phi:main::@6->memoryRemap256M]
  memoryRemap256M_from___b6:
    // [50] phi memoryRemap256M::remapBlocks#2 = 0 [phi:main::@6->memoryRemap256M#0] -- vbuzz=vbuc1 
    ldz #0
    // [50] phi memoryRemap256M::lowerPageOffset#2 = 0 [phi:main::@6->memoryRemap256M#1] -- vduz1=vbuc1 
    lda #0
    sta.z memoryRemap256M.lowerPageOffset
    lda #0
    sta.z memoryRemap256M.lowerPageOffset+1
    sta.z memoryRemap256M.lowerPageOffset+2
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    jmp __breturn
    // main::@return
  __breturn:
    // [18] return 
    rts
    // main::@5
  __b5:
    // [19] main::$7 = $40 + main::i1#2 -- vbuaa=vbuc1_plus_vbuxx 
    txa
    clc
    adc #$40
    // [20] main::BLOCK_4000[main::i1#2] = main::$7 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta BLOCK_4000,x
    // [21] main::i1#1 = ++ main::i1#2 -- vbuxx=_inc_vbuxx 
    inx
    // [14] phi from main::@5 to main::@4 [phi:main::@5->main::@4]
  __b4_from___b5:
    // [14] phi main::i1#2 = main::i1#1 [phi:main::@5->main::@4#0] -- register_copy 
    jmp __b4
    // main::@2
  __b2:
    // [22] (DEFAULT_SCREEN+$50-6)[main::i#2] = main::BLOCK_4000[main::i#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda BLOCK_4000,x
    sta DEFAULT_SCREEN+$50-6,x
    // [23] main::i#1 = ++ main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [10] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [10] phi main::i#2 = main::i#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // memoryRemapBlock
// Remap a single 8K memory block in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// All the other 8K memory blocks will not be mapped and will point to their own address in the lowest 64K of the MEGA65 memory.
// blockPage: Page address of the 8K memory block to remap (ie. the block that is remapped is $100 * the passed page address.)
// memoryPage: Page address of the memory that the block should point to in the 1MB memory space of the MEGA65.
// Ie. the memory that will be pointed to is $100 * the passed page address. Only the lower 12bits of the passed value is used.
// memoryRemapBlock(byte register(X) blockPage)
memoryRemapBlock: {
    .label pageOffset = $b
    // [25] memoryRemapBlock::pageOffset#0 = $100 - memoryRemapBlock::blockPage#2 -- vwuz1=vwuc1_minus_vbuxx 
    stx.z $ff
    lda #<$100
    sec
    sbc.z $ff
    sta.z pageOffset
    lda #>$100
    sbc #0
    sta.z pageOffset+1
    // [26] memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 >> 5 -- vbuaa=vbuxx_ror_5 
    txa
    lsr
    lsr
    lsr
    lsr
    lsr
    // [27] memoryRemapBlock::blockBits#0 = 1 << memoryRemapBlock::block#0 -- vbuaa=vbuc1_rol_vbuaa 
    tay
    lda #1
    cpy #0
    beq !e+
  !:
    asl
    dey
    bne !-
  !e:
    // [28] memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0 -- vbuzz=vbuaa 
    taz
    // [29] memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
    // [30] memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0 -- vwuz1=vwuz2 
    lda.z pageOffset
    sta.z memoryRemap.upperPageOffset
    lda.z pageOffset+1
    sta.z memoryRemap.upperPageOffset+1
    // [31] call memoryRemap 
    // [33] phi from memoryRemapBlock to memoryRemap [phi:memoryRemapBlock->memoryRemap]
  memoryRemap_from_memoryRemapBlock:
    // [33] phi memoryRemap::upperPageOffset#2 = memoryRemap::upperPageOffset#0 [phi:memoryRemapBlock->memoryRemap#0] -- register_copy 
    // [33] phi memoryRemap::remapBlocks#2 = memoryRemap::remapBlocks#0 [phi:memoryRemapBlock->memoryRemap#1] -- register_copy 
    // [33] phi memoryRemap::lowerPageOffset#2 = memoryRemap::lowerPageOffset#0 [phi:memoryRemapBlock->memoryRemap#2] -- register_copy 
    jsr memoryRemap
    jmp __breturn
    // memoryRemapBlock::@return
  __breturn:
    // [32] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// memoryRemap(byte register(Z) remapBlocks, word zp($b) lowerPageOffset, word zp($e) upperPageOffset)
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __1 = $d
    .label __6 = 6
    .label lowerPageOffset = $b
    .label upperPageOffset = $e
    // [34] memoryRemap::$0 = < memoryRemap::lowerPageOffset#2 -- vbuaa=_lo_vwuz1 
    lda.z lowerPageOffset
    // [35] *memoryRemap::aVal = memoryRemap::$0 -- _deref_pbuc1=vbuaa 
    sta aVal
    // [36] memoryRemap::$1 = memoryRemap::remapBlocks#2 << 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __1
    // [37] memoryRemap::$2 = > memoryRemap::lowerPageOffset#2 -- vbuaa=_hi_vwuz1 
    lda.z lowerPageOffset+1
    // [38] memoryRemap::$3 = memoryRemap::$2 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [39] memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // [40] *memoryRemap::xVal = memoryRemap::$4 -- _deref_pbuc1=vbuaa 
    sta xVal
    // [41] memoryRemap::$5 = < memoryRemap::upperPageOffset#2 -- vbuaa=_lo_vwuz1 
    lda.z upperPageOffset
    // [42] *memoryRemap::yVal = memoryRemap::$5 -- _deref_pbuc1=vbuaa 
    sta yVal
    // [43] memoryRemap::$6 = memoryRemap::remapBlocks#2 & $f0 -- vbuz1=vbuzz_band_vbuc1 
    tza
    and #$f0
    sta.z __6
    // [44] memoryRemap::$7 = > memoryRemap::upperPageOffset#2 -- vbuaa=_hi_vwuz1 
    lda.z upperPageOffset+1
    // [45] memoryRemap::$8 = memoryRemap::$7 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [46] memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // [47] *memoryRemap::zVal = memoryRemap::$9 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [49] return 
    rts
}
  // memoryRemap256M
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the entire 256MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in file:///Users/jespergravgaard/Downloads/MEGA65-Book_draft%20(5).pdf for a description of the CPU memory remapper of the MEGA65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// memoryRemap256M(byte register(Z) remapBlocks, dword zp(2) lowerPageOffset)
memoryRemap256M: {
    .label lMb = $fa
    .label uMb = $fb
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __0 = 7
    .label __4 = $b
    .label __6 = $d
    .label __7 = $e
    .label lowerPageOffset = 2
    // [51] memoryRemap256M::$0 = memoryRemap256M::lowerPageOffset#2 >> 4 -- vduz1=vduz2_ror_4 
    lda.z lowerPageOffset+3
    lsr
    sta.z __0+3
    lda.z lowerPageOffset+2
    ror
    sta.z __0+2
    lda.z lowerPageOffset+1
    ror
    sta.z __0+1
    lda.z lowerPageOffset
    ror
    sta.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    // [52] memoryRemap256M::$1 = > (word)memoryRemap256M::$0 -- vbuaa=_hi__word_vduz1 
    lda.z __0+1
    // [53] *memoryRemap256M::lMb = memoryRemap256M::$1 -- _deref_pbuc1=vbuaa 
    sta lMb
    // [54] *memoryRemap256M::uMb = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta uMb
    // [55] memoryRemap256M::$4 = < memoryRemap256M::lowerPageOffset#2 -- vwuz1=_lo_vduz2 
    lda.z lowerPageOffset
    sta.z __4
    lda.z lowerPageOffset+1
    sta.z __4+1
    // [56] memoryRemap256M::$5 = < memoryRemap256M::$4 -- vbuaa=_lo_vwuz1 
    lda.z __4
    // [57] *memoryRemap256M::aVal = memoryRemap256M::$5 -- _deref_pbuc1=vbuaa 
    sta aVal
    // [58] memoryRemap256M::$6 = memoryRemap256M::remapBlocks#2 << 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __6
    // [59] memoryRemap256M::$7 = < memoryRemap256M::lowerPageOffset#2 -- vwuz1=_lo_vduz2 
    lda.z lowerPageOffset
    sta.z __7
    lda.z lowerPageOffset+1
    sta.z __7+1
    // [60] memoryRemap256M::$8 = > memoryRemap256M::$7 -- vbuaa=_hi_vwuz1 
    lda.z __7+1
    // [61] memoryRemap256M::$9 = memoryRemap256M::$8 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [62] memoryRemap256M::$10 = memoryRemap256M::$6 | memoryRemap256M::$9 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // [63] *memoryRemap256M::xVal = memoryRemap256M::$10 -- _deref_pbuc1=vbuaa 
    sta xVal
    // [64] *memoryRemap256M::yVal = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta yVal
    // [65] memoryRemap256M::$17 = memoryRemap256M::remapBlocks#2 & $f0 -- vbuaa=vbuzz_band_vbuc1 
    tza
    and #$f0
    // [66] *memoryRemap256M::zVal = memoryRemap256M::$17 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda lMb
    ldx #$f
    ldy uMb
    ldz #0
    map
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap256M::@return
  __breturn:
    // [68] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b6
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda.z __7+1
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b3_from___b1:
Removing instruction __b6_from___b4:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction memoryRemapBlock_from_main:
Removing instruction __b7:
Removing instruction memoryRemapBlock_from___b7:
Removing instruction __b8:
Removing instruction memoryRemap_from___b8:
Removing instruction __b9:
Removing instruction __b1_from___b9:
Removing instruction __b3:
Removing instruction memoryRemap256M_from___b3:
Removing instruction __b4_from___b3:
Removing instruction __b6:
Removing instruction memoryRemap256M_from___b6:
Removing instruction __breturn:
Removing instruction __b4_from___b5:
Removing instruction __b1_from___b2:
Removing instruction memoryRemap_from_memoryRemapBlock:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
const nomodify byte* DEFAULT_SCREEN = (byte*) 2048
const nomodify byte MEMORYBLOCK_4000 = 4
const nomodify byte MEMORYBLOCK_8000 = $10
void main()
byte~ main::$7 reg byte a 22.0
const byte* main::BLOCK_4000 = (byte*) 16384
const byte* main::BLOCK_8000 = (byte*) 32768
byte main::i
byte main::i#1 reg byte x 22.0
byte main::i#2 reg byte x 18.333333333333332
byte main::i1
byte main::i1#1 reg byte x 22.0
byte main::i1#2 reg byte x 13.75
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
byte~ memoryRemap::$0 reg byte a 202.0
byte~ memoryRemap::$1 zp[1]:13 67.33333333333333
byte~ memoryRemap::$2 reg byte a 202.0
byte~ memoryRemap::$3 reg byte a 202.0
byte~ memoryRemap::$4 reg byte a 202.0
byte~ memoryRemap::$5 reg byte a 202.0
byte~ memoryRemap::$6 zp[1]:6 67.33333333333333
byte~ memoryRemap::$7 reg byte a 202.0
byte~ memoryRemap::$8 reg byte a 202.0
byte~ memoryRemap::$9 reg byte a 202.0
const byte* memoryRemap::aVal = (byte*) 252
word memoryRemap::lowerPageOffset
word memoryRemap::lowerPageOffset#0 lowerPageOffset zp[2]:11 11.0
word memoryRemap::lowerPageOffset#2 lowerPageOffset zp[2]:11 53.25
byte memoryRemap::remapBlocks
byte memoryRemap::remapBlocks#0 reg byte z 7.333333333333333
byte memoryRemap::remapBlocks#2 reg byte z 21.299999999999997
word memoryRemap::upperPageOffset
word memoryRemap::upperPageOffset#0 upperPageOffset zp[2]:14 22.0
word memoryRemap::upperPageOffset#2 upperPageOffset zp[2]:14 19.363636363636363
const byte* memoryRemap::xVal = (byte*) 253
const byte* memoryRemap::yVal = (byte*) 254
const byte* memoryRemap::zVal = (byte*) 255
void memoryRemap256M(byte memoryRemap256M::remapBlocks , dword memoryRemap256M::lowerPageOffset , dword memoryRemap256M::upperPageOffset)
dword~ memoryRemap256M::$0 zp[4]:7 11.0
byte~ memoryRemap256M::$1 reg byte a 22.0
byte~ memoryRemap256M::$10 reg byte a 22.0
byte~ memoryRemap256M::$17 reg byte a 22.0
word~ memoryRemap256M::$4 zp[2]:11 22.0
byte~ memoryRemap256M::$5 reg byte a 22.0
byte~ memoryRemap256M::$6 zp[1]:13 5.5
word~ memoryRemap256M::$7 zp[2]:14 22.0
byte~ memoryRemap256M::$8 reg byte a 22.0
byte~ memoryRemap256M::$9 reg byte a 22.0
const byte* memoryRemap256M::aVal = (byte*) 252
const byte* memoryRemap256M::lMb = (byte*) 250
dword memoryRemap256M::lowerPageOffset
dword memoryRemap256M::lowerPageOffset#2 lowerPageOffset zp[4]:2 3.666666666666667
byte memoryRemap256M::remapBlocks
byte memoryRemap256M::remapBlocks#2 reg byte z 1.4666666666666666
const byte* memoryRemap256M::uMb = (byte*) 251
dword memoryRemap256M::upperPageOffset
const byte* memoryRemap256M::xVal = (byte*) 253
const byte* memoryRemap256M::yVal = (byte*) 254
const byte* memoryRemap256M::zVal = (byte*) 255
void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
byte memoryRemapBlock::block
byte memoryRemapBlock::block#0 reg byte a 22.0
byte memoryRemapBlock::blockBits
byte memoryRemapBlock::blockBits#0 reg byte a 22.0
byte memoryRemapBlock::blockPage
byte memoryRemapBlock::blockPage#2 reg byte x 11.0
word memoryRemapBlock::memoryPage
word memoryRemapBlock::pageOffset
word memoryRemapBlock::pageOffset#0 pageOffset zp[2]:11 6.6000000000000005

reg byte x [ main::i#2 main::i#1 ]
reg byte x [ main::i1#2 main::i1#1 ]
reg byte x [ memoryRemapBlock::blockPage#2 ]
reg byte z [ memoryRemap::remapBlocks#2 memoryRemap::remapBlocks#0 ]
zp[4]:2 [ memoryRemap256M::lowerPageOffset#2 ]
reg byte z [ memoryRemap256M::remapBlocks#2 ]
reg byte a [ main::$7 ]
reg byte a [ memoryRemapBlock::block#0 ]
reg byte a [ memoryRemapBlock::blockBits#0 ]
reg byte a [ memoryRemap::$0 ]
reg byte a [ memoryRemap::$2 ]
reg byte a [ memoryRemap::$3 ]
reg byte a [ memoryRemap::$4 ]
reg byte a [ memoryRemap::$5 ]
zp[1]:6 [ memoryRemap::$6 ]
reg byte a [ memoryRemap::$7 ]
reg byte a [ memoryRemap::$8 ]
reg byte a [ memoryRemap::$9 ]
zp[4]:7 [ memoryRemap256M::$0 ]
reg byte a [ memoryRemap256M::$1 ]
zp[2]:11 [ memoryRemap256M::$4 memoryRemap::lowerPageOffset#2 memoryRemap::lowerPageOffset#0 memoryRemapBlock::pageOffset#0 ]
reg byte a [ memoryRemap256M::$5 ]
zp[1]:13 [ memoryRemap256M::$6 memoryRemap::$1 ]
zp[2]:14 [ memoryRemap256M::$7 memoryRemap::upperPageOffset#2 memoryRemap::upperPageOffset#0 ]
reg byte a [ memoryRemap256M::$8 ]
reg byte a [ memoryRemap256M::$9 ]
reg byte a [ memoryRemap256M::$10 ]
reg byte a [ memoryRemap256M::$17 ]


FINAL ASSEMBLER
Score: 937

  // File Comments
// Test the MAP instruction for remapping memory
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in https://mega.scryptos.com/sharefolder-link/MEGA/MEGA65+filehost/Docs/MEGA65-Book_draft.pdf for a description of the CPU memory remapper of the MEGA65.
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="memorymap-test.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // Bit representing 8K block #2 of the 64K addressable memory ($4000-$5fff)
  .const MEMORYBLOCK_4000 = 4
  // Bit representing 8K block #4 of the 64K addressable memory ($8000-$9fff)
  .const MEMORYBLOCK_8000 = $10
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
.segment Code
  // main
main: {
    .label BLOCK_4000 = $4000
    .label BLOCK_8000 = $8000
    // memoryRemapBlock(0x40, 0x100)
    // [1] call memoryRemapBlock 
  // Remap [$4000-$5fff] to point to [$10000-$11fff]
    // [24] phi from main to memoryRemapBlock [phi:main->memoryRemapBlock]
    // [24] phi memoryRemapBlock::blockPage#2 = $40 [phi:main->memoryRemapBlock#0] -- vbuxx=vbuc1 
    ldx #$40
    jsr memoryRemapBlock
    // main::@7
    // BLOCK_4000[0] = '-'
    // [2] *main::BLOCK_4000 = '-' -- _deref_pbuc1=vbuc2 
    // Put '-', '*' into $10000
    lda #'-'
    sta BLOCK_4000
    // BLOCK_4000[1] = '*'
    // [3] *(main::BLOCK_4000+1) = '*' -- _deref_pbuc1=vbuc2 
    lda #'*'
    sta BLOCK_4000+1
    // memoryRemapBlock(0x80, 0x100)
    // [4] call memoryRemapBlock 
  // Remap [$8000-$9fff] to point to [$10000-$11fff]
    // [24] phi from main::@7 to memoryRemapBlock [phi:main::@7->memoryRemapBlock]
    // [24] phi memoryRemapBlock::blockPage#2 = $80 [phi:main::@7->memoryRemapBlock#0] -- vbuxx=vbuc1 
    ldx #$80
    jsr memoryRemapBlock
    // main::@8
    // BLOCK_8000[2] = '-'
    // [5] *(main::BLOCK_8000+2) = '-' -- _deref_pbuc1=vbuc2 
    // Put '-', '*' into $10002
    lda #'-'
    sta BLOCK_8000+2
    // BLOCK_8000[3] = '*'
    // [6] *(main::BLOCK_8000+3) = '*' -- _deref_pbuc1=vbuc2 
    lda #'*'
    sta BLOCK_8000+3
    // memoryRemap(MEMORYBLOCK_4000|MEMORYBLOCK_8000, 0x0c0, 0x080)
    // [7] call memoryRemap 
  // Remap [$4000-$5fff] and [$8000-$9fff] to both point to [$10000-$11fff] (notice usage of page offsets)
    // [33] phi from main::@8 to memoryRemap [phi:main::@8->memoryRemap]
    // [33] phi memoryRemap::upperPageOffset#2 = $80 [phi:main::@8->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<$80
    sta.z memoryRemap.upperPageOffset
    lda #>$80
    sta.z memoryRemap.upperPageOffset+1
    // [33] phi memoryRemap::remapBlocks#2 = MEMORYBLOCK_4000|MEMORYBLOCK_8000 [phi:main::@8->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #MEMORYBLOCK_4000|MEMORYBLOCK_8000
    // [33] phi memoryRemap::lowerPageOffset#2 = $c0 [phi:main::@8->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<$c0
    sta.z memoryRemap.lowerPageOffset
    lda #>$c0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // main::@9
    // BLOCK_8000[4] = BLOCK_4000[2]
    // [8] *(main::BLOCK_8000+4) = *(main::BLOCK_4000+2) -- _deref_pbuc1=_deref_pbuc2 
    // Put '-', '*' into $10004 in a convoluted way
    lda BLOCK_4000+2
    sta BLOCK_8000+4
    // BLOCK_4000[5] = BLOCK_8000[1]
    // [9] *(main::BLOCK_4000+5) = *(main::BLOCK_8000+1) -- _deref_pbuc1=_deref_pbuc2 
    lda BLOCK_8000+1
    sta BLOCK_4000+5
    // [10] phi from main::@9 to main::@1 [phi:main::@9->main::@1]
    // [10] phi main::i#2 = 0 [phi:main::@9->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
  // copy the resulting values onto the screen
    // main::@1
  __b1:
    // for(char i=0;i<6;i++)
    // [11] if(main::i#2<6) goto main::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #6
    bcc __b2
    // [12] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // main::@3
    // memoryRemap256M(MEMORYBLOCK_4000, 0xff800-0x00040, 0)
    // [13] call memoryRemap256M 
  // Remap [$4000-$5fff] to both point to [$ff80000-$ff81fff] COLORAM! (notice usage of page offsets)
    // [50] phi from main::@3 to memoryRemap256M [phi:main::@3->memoryRemap256M]
    // [50] phi memoryRemap256M::remapBlocks#2 = MEMORYBLOCK_4000 [phi:main::@3->memoryRemap256M#0] -- vbuzz=vbuc1 
    ldz #MEMORYBLOCK_4000
    // [50] phi memoryRemap256M::lowerPageOffset#2 = (dword)$ff800-$40 [phi:main::@3->memoryRemap256M#1] -- vduz1=vduc1 
    lda #<$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset
    lda #>$ff800-$40
    sta.z memoryRemap256M.lowerPageOffset+1
    lda #<$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+2
    lda #>$ff800-$40>>$10
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    // [14] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
    // [14] phi main::i1#2 = 0 [phi:main::@3->main::@4#0] -- vbuxx=vbuc1 
    ldx #0
  // Put colors in the upper screen line
    // main::@4
  __b4:
    // for( char i=0; i<16; i++)
    // [15] if(main::i1#2<$10) goto main::@5 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$10
    bcc __b5
    // [16] phi from main::@4 to main::@6 [phi:main::@4->main::@6]
    // main::@6
    // memoryRemap256M(0, 0, 0)
    // [17] call memoryRemap256M 
  // Remap [$4000-$5fff] back to normal memory!
    // [50] phi from main::@6 to memoryRemap256M [phi:main::@6->memoryRemap256M]
    // [50] phi memoryRemap256M::remapBlocks#2 = 0 [phi:main::@6->memoryRemap256M#0] -- vbuzz=vbuc1 
    ldz #0
    // [50] phi memoryRemap256M::lowerPageOffset#2 = 0 [phi:main::@6->memoryRemap256M#1] -- vduz1=vbuc1 
    lda #0
    sta.z memoryRemap256M.lowerPageOffset
    sta.z memoryRemap256M.lowerPageOffset+1
    sta.z memoryRemap256M.lowerPageOffset+2
    sta.z memoryRemap256M.lowerPageOffset+3
    jsr memoryRemap256M
    // main::@return
    // }
    // [18] return 
    rts
    // main::@5
  __b5:
    // 0x40+i
    // [19] main::$7 = $40 + main::i1#2 -- vbuaa=vbuc1_plus_vbuxx 
    txa
    clc
    adc #$40
    // BLOCK_4000[i] = 0x40+i
    // [20] main::BLOCK_4000[main::i1#2] = main::$7 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta BLOCK_4000,x
    // for( char i=0; i<16; i++)
    // [21] main::i1#1 = ++ main::i1#2 -- vbuxx=_inc_vbuxx 
    inx
    // [14] phi from main::@5 to main::@4 [phi:main::@5->main::@4]
    // [14] phi main::i1#2 = main::i1#1 [phi:main::@5->main::@4#0] -- register_copy 
    jmp __b4
    // main::@2
  __b2:
    // (DEFAULT_SCREEN+80-6)[i] = BLOCK_4000[i]
    // [22] (DEFAULT_SCREEN+$50-6)[main::i#2] = main::BLOCK_4000[main::i#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda BLOCK_4000,x
    sta DEFAULT_SCREEN+$50-6,x
    // for(char i=0;i<6;i++)
    // [23] main::i#1 = ++ main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [10] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [10] phi main::i#2 = main::i#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // memoryRemapBlock
// Remap a single 8K memory block in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// All the other 8K memory blocks will not be mapped and will point to their own address in the lowest 64K of the MEGA65 memory.
// blockPage: Page address of the 8K memory block to remap (ie. the block that is remapped is $100 * the passed page address.)
// memoryPage: Page address of the memory that the block should point to in the 1MB memory space of the MEGA65.
// Ie. the memory that will be pointed to is $100 * the passed page address. Only the lower 12bits of the passed value is used.
// memoryRemapBlock(byte register(X) blockPage)
memoryRemapBlock: {
    .label pageOffset = $b
    // pageOffset = memoryPage-blockPage
    // [25] memoryRemapBlock::pageOffset#0 = $100 - memoryRemapBlock::blockPage#2 -- vwuz1=vwuc1_minus_vbuxx 
    stx.z $ff
    lda #<$100
    sec
    sbc.z $ff
    sta.z pageOffset
    lda #>$100
    sbc #0
    sta.z pageOffset+1
    // block = blockPage / $20
    // [26] memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 >> 5 -- vbuaa=vbuxx_ror_5 
    txa
    lsr
    lsr
    lsr
    lsr
    lsr
    // blockBits = 1<<block
    // [27] memoryRemapBlock::blockBits#0 = 1 << memoryRemapBlock::block#0 -- vbuaa=vbuc1_rol_vbuaa 
    tay
    lda #1
    cpy #0
    beq !e+
  !:
    asl
    dey
    bne !-
  !e:
    // memoryRemap(blockBits, pageOffset, pageOffset)
    // [28] memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0 -- vbuzz=vbuaa 
    taz
    // [29] memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
    // [30] memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0 -- vwuz1=vwuz2 
    lda.z pageOffset
    sta.z memoryRemap.upperPageOffset
    lda.z pageOffset+1
    sta.z memoryRemap.upperPageOffset+1
    // [31] call memoryRemap 
    // [33] phi from memoryRemapBlock to memoryRemap [phi:memoryRemapBlock->memoryRemap]
    // [33] phi memoryRemap::upperPageOffset#2 = memoryRemap::upperPageOffset#0 [phi:memoryRemapBlock->memoryRemap#0] -- register_copy 
    // [33] phi memoryRemap::remapBlocks#2 = memoryRemap::remapBlocks#0 [phi:memoryRemapBlock->memoryRemap#1] -- register_copy 
    // [33] phi memoryRemap::lowerPageOffset#2 = memoryRemap::lowerPageOffset#0 [phi:memoryRemapBlock->memoryRemap#2] -- register_copy 
    jsr memoryRemap
    // memoryRemapBlock::@return
    // }
    // [32] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// memoryRemap(byte register(Z) remapBlocks, word zp($b) lowerPageOffset, word zp($e) upperPageOffset)
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __1 = $d
    .label __6 = 6
    .label lowerPageOffset = $b
    .label upperPageOffset = $e
    // <lowerPageOffset
    // [34] memoryRemap::$0 = < memoryRemap::lowerPageOffset#2 -- vbuaa=_lo_vwuz1 
    lda.z lowerPageOffset
    // *aVal = <lowerPageOffset
    // [35] *memoryRemap::aVal = memoryRemap::$0 -- _deref_pbuc1=vbuaa 
    sta aVal
    // remapBlocks << 4
    // [36] memoryRemap::$1 = memoryRemap::remapBlocks#2 << 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __1
    // >lowerPageOffset
    // [37] memoryRemap::$2 = > memoryRemap::lowerPageOffset#2 -- vbuaa=_hi_vwuz1 
    lda.z lowerPageOffset+1
    // >lowerPageOffset & 0xf
    // [38] memoryRemap::$3 = memoryRemap::$2 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // (remapBlocks << 4)   | (>lowerPageOffset & 0xf)
    // [39] memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // *xVal = (remapBlocks << 4)   | (>lowerPageOffset & 0xf)
    // [40] *memoryRemap::xVal = memoryRemap::$4 -- _deref_pbuc1=vbuaa 
    sta xVal
    // <upperPageOffset
    // [41] memoryRemap::$5 = < memoryRemap::upperPageOffset#2 -- vbuaa=_lo_vwuz1 
    lda.z upperPageOffset
    // *yVal = <upperPageOffset
    // [42] *memoryRemap::yVal = memoryRemap::$5 -- _deref_pbuc1=vbuaa 
    sta yVal
    // remapBlocks & 0xf0
    // [43] memoryRemap::$6 = memoryRemap::remapBlocks#2 & $f0 -- vbuz1=vbuzz_band_vbuc1 
    tza
    and #$f0
    sta.z __6
    // >upperPageOffset
    // [44] memoryRemap::$7 = > memoryRemap::upperPageOffset#2 -- vbuaa=_hi_vwuz1 
    lda.z upperPageOffset+1
    // >upperPageOffset & 0xf
    // [45] memoryRemap::$8 = memoryRemap::$7 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // (remapBlocks & 0xf0) | (>upperPageOffset & 0xf)
    // [46] memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // *zVal = (remapBlocks & 0xf0) | (>upperPageOffset & 0xf)
    // [47] *memoryRemap::zVal = memoryRemap::$9 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap::@return
    // }
    // [49] return 
    rts
}
  // memoryRemap256M
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the entire 256MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// See Appendix G in file:///Users/jespergravgaard/Downloads/MEGA65-Book_draft%20(5).pdf for a description of the CPU memory remapper of the MEGA65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 20bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// memoryRemap256M(byte register(Z) remapBlocks, dword zp(2) lowerPageOffset)
memoryRemap256M: {
    .label lMb = $fa
    .label uMb = $fb
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __0 = 7
    .label __4 = $b
    .label __6 = $d
    .label __7 = $e
    .label lowerPageOffset = 2
    // lowerPageOffset>>4
    // [51] memoryRemap256M::$0 = memoryRemap256M::lowerPageOffset#2 >> 4 -- vduz1=vduz2_ror_4 
    lda.z lowerPageOffset+3
    lsr
    sta.z __0+3
    lda.z lowerPageOffset+2
    ror
    sta.z __0+2
    lda.z lowerPageOffset+1
    ror
    sta.z __0+1
    lda.z lowerPageOffset
    ror
    sta.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    lsr.z __0+3
    ror.z __0+2
    ror.z __0+1
    ror.z __0
    // >((unsigned int)(lowerPageOffset>>4))
    // [52] memoryRemap256M::$1 = > (word)memoryRemap256M::$0 -- vbuaa=_hi__word_vduz1 
    lda.z __0+1
    // *lMb = >((unsigned int)(lowerPageOffset>>4))
    // [53] *memoryRemap256M::lMb = memoryRemap256M::$1 -- _deref_pbuc1=vbuaa 
    sta lMb
    // *uMb = >((unsigned int)(upperPageOffset>>4))
    // [54] *memoryRemap256M::uMb = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta uMb
    // <lowerPageOffset
    // [55] memoryRemap256M::$4 = < memoryRemap256M::lowerPageOffset#2 -- vwuz1=_lo_vduz2 
    lda.z lowerPageOffset
    sta.z __4
    lda.z lowerPageOffset+1
    sta.z __4+1
    // < <lowerPageOffset
    // [56] memoryRemap256M::$5 = < memoryRemap256M::$4 -- vbuaa=_lo_vwuz1 
    lda.z __4
    // *aVal = < <lowerPageOffset
    // [57] *memoryRemap256M::aVal = memoryRemap256M::$5 -- _deref_pbuc1=vbuaa 
    sta aVal
    // remapBlocks << 4
    // [58] memoryRemap256M::$6 = memoryRemap256M::remapBlocks#2 << 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __6
    // <lowerPageOffset
    // [59] memoryRemap256M::$7 = < memoryRemap256M::lowerPageOffset#2 -- vwuz1=_lo_vduz2 
    lda.z lowerPageOffset
    sta.z __7
    lda.z lowerPageOffset+1
    sta.z __7+1
    // > <lowerPageOffset
    // [60] memoryRemap256M::$8 = > memoryRemap256M::$7 -- vbuaa=_hi_vwuz1 
    // > <lowerPageOffset & 0xf
    // [61] memoryRemap256M::$9 = memoryRemap256M::$8 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // (remapBlocks << 4)   | (> <lowerPageOffset & 0xf)
    // [62] memoryRemap256M::$10 = memoryRemap256M::$6 | memoryRemap256M::$9 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // *xVal = (remapBlocks << 4)   | (> <lowerPageOffset & 0xf)
    // [63] *memoryRemap256M::xVal = memoryRemap256M::$10 -- _deref_pbuc1=vbuaa 
    sta xVal
    // *yVal = < <upperPageOffset
    // [64] *memoryRemap256M::yVal = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta yVal
    // (remapBlocks & 0xf0) | (> <upperPageOffset & 0xf)
    // [65] memoryRemap256M::$17 = memoryRemap256M::remapBlocks#2 & $f0 -- vbuaa=vbuzz_band_vbuc1 
    tza
    and #$f0
    // *zVal = (remapBlocks & 0xf0) | (> <upperPageOffset & 0xf)
    // [66] *memoryRemap256M::zVal = memoryRemap256M::$17 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm
    // asm { ldalMb ldx#$0f ldyuMb ldz#$00 map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda lMb
    ldx #$f
    ldy uMb
    ldz #0
    map
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap256M::@return
    // }
    // [68] return 
    rts
}
  // File Data

