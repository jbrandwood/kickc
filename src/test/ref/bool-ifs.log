
CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start
  call bool_and 
  to:main::@1
main::@1: scope:[main]  from main
  call bool_or 
  to:main::@2
main::@2: scope:[main]  from main::@1
  call bool_not 
  to:main::@3
main::@3: scope:[main]  from main::@2
  call bool_complex 
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return

void bool_and()
bool_and: scope:[bool_and]  from main
  bool_and::i#0 = 0
  to:bool_and::@1
bool_and::@1: scope:[bool_and]  from bool_and bool_and::@3
  bool_and::i#2 = phi( bool_and/bool_and::i#0, bool_and::@3/bool_and::i#1 )
  bool_and::$0 = bool_and::i#2 < $a
  bool_and::$1 = bool_and::i#2 & 1
  bool_and::$2 = bool_and::$1 == 0
  bool_and::$3 = bool_and::$0 && bool_and::$2
  if(bool_and::$3) goto bool_and::@2
  to:bool_and::@4
bool_and::@2: scope:[bool_and]  from bool_and::@1
  bool_and::i#3 = phi( bool_and::@1/bool_and::i#2 )
  bool_and::screen[bool_and::i#3] = '*'
  to:bool_and::@3
bool_and::@4: scope:[bool_and]  from bool_and::@1
  bool_and::i#4 = phi( bool_and::@1/bool_and::i#2 )
  bool_and::screen[bool_and::i#4] = ' '
  to:bool_and::@3
bool_and::@3: scope:[bool_and]  from bool_and::@2 bool_and::@4
  bool_and::i#5 = phi( bool_and::@2/bool_and::i#3, bool_and::@4/bool_and::i#4 )
  bool_and::i#1 = bool_and::i#5 + rangenext(0,$14)
  bool_and::$4 = bool_and::i#1 != rangelast(0,$14)
  if(bool_and::$4) goto bool_and::@1
  to:bool_and::@return
bool_and::@return: scope:[bool_and]  from bool_and::@3
  return 
  to:@return

void bool_or()
bool_or: scope:[bool_or]  from main::@1
  bool_or::i#0 = 0
  to:bool_or::@1
bool_or::@1: scope:[bool_or]  from bool_or bool_or::@3
  bool_or::i#2 = phi( bool_or/bool_or::i#0, bool_or::@3/bool_or::i#1 )
  bool_or::$0 = bool_or::i#2 < $a
  bool_or::$1 = bool_or::i#2 & 1
  bool_or::$2 = bool_or::$1 == 0
  bool_or::$3 = bool_or::$0 || bool_or::$2
  if(bool_or::$3) goto bool_or::@2
  to:bool_or::@4
bool_or::@2: scope:[bool_or]  from bool_or::@1
  bool_or::i#3 = phi( bool_or::@1/bool_or::i#2 )
  bool_or::screen[bool_or::i#3] = '*'
  to:bool_or::@3
bool_or::@4: scope:[bool_or]  from bool_or::@1
  bool_or::i#4 = phi( bool_or::@1/bool_or::i#2 )
  bool_or::screen[bool_or::i#4] = ' '
  to:bool_or::@3
bool_or::@3: scope:[bool_or]  from bool_or::@2 bool_or::@4
  bool_or::i#5 = phi( bool_or::@2/bool_or::i#3, bool_or::@4/bool_or::i#4 )
  bool_or::i#1 = bool_or::i#5 + rangenext(0,$14)
  bool_or::$4 = bool_or::i#1 != rangelast(0,$14)
  if(bool_or::$4) goto bool_or::@1
  to:bool_or::@return
bool_or::@return: scope:[bool_or]  from bool_or::@3
  return 
  to:@return

void bool_not()
bool_not: scope:[bool_not]  from main::@2
  bool_not::i#0 = 0
  to:bool_not::@1
bool_not::@1: scope:[bool_not]  from bool_not bool_not::@3
  bool_not::i#2 = phi( bool_not/bool_not::i#0, bool_not::@3/bool_not::i#1 )
  bool_not::$0 = bool_not::i#2 < $a
  bool_not::$1 = bool_not::i#2 & 1
  bool_not::$2 = bool_not::$1 == 0
  bool_not::$3 = bool_not::$0 || bool_not::$2
  bool_not::$4 = ! bool_not::$3
  if(bool_not::$4) goto bool_not::@2
  to:bool_not::@4
bool_not::@2: scope:[bool_not]  from bool_not::@1
  bool_not::i#3 = phi( bool_not::@1/bool_not::i#2 )
  bool_not::screen[bool_not::i#3] = '*'
  to:bool_not::@3
bool_not::@4: scope:[bool_not]  from bool_not::@1
  bool_not::i#4 = phi( bool_not::@1/bool_not::i#2 )
  bool_not::screen[bool_not::i#4] = ' '
  to:bool_not::@3
bool_not::@3: scope:[bool_not]  from bool_not::@2 bool_not::@4
  bool_not::i#5 = phi( bool_not::@2/bool_not::i#3, bool_not::@4/bool_not::i#4 )
  bool_not::i#1 = bool_not::i#5 + rangenext(0,$14)
  bool_not::$5 = bool_not::i#1 != rangelast(0,$14)
  if(bool_not::$5) goto bool_not::@1
  to:bool_not::@return
bool_not::@return: scope:[bool_not]  from bool_not::@3
  return 
  to:@return

void bool_complex()
bool_complex: scope:[bool_complex]  from main::@3
  bool_complex::i#0 = 0
  to:bool_complex::@1
bool_complex::@1: scope:[bool_complex]  from bool_complex bool_complex::@3
  bool_complex::i#2 = phi( bool_complex/bool_complex::i#0, bool_complex::@3/bool_complex::i#1 )
  bool_complex::$0 = bool_complex::i#2 < $a
  bool_complex::$1 = bool_complex::i#2 & 1
  bool_complex::$2 = bool_complex::$1 == 0
  bool_complex::$3 = bool_complex::$0 && bool_complex::$2
  bool_complex::$4 = bool_complex::i#2 < $a
  bool_complex::$5 = bool_complex::i#2 & 1
  bool_complex::$6 = bool_complex::$5 == 0
  bool_complex::$7 = bool_complex::$4 || bool_complex::$6
  bool_complex::$8 = ! bool_complex::$7
  bool_complex::$9 = bool_complex::$3 || bool_complex::$8
  if(bool_complex::$9) goto bool_complex::@2
  to:bool_complex::@4
bool_complex::@2: scope:[bool_complex]  from bool_complex::@1
  bool_complex::i#3 = phi( bool_complex::@1/bool_complex::i#2 )
  bool_complex::screen[bool_complex::i#3] = '*'
  to:bool_complex::@3
bool_complex::@4: scope:[bool_complex]  from bool_complex::@1
  bool_complex::i#4 = phi( bool_complex::@1/bool_complex::i#2 )
  bool_complex::screen[bool_complex::i#4] = ' '
  to:bool_complex::@3
bool_complex::@3: scope:[bool_complex]  from bool_complex::@2 bool_complex::@4
  bool_complex::i#5 = phi( bool_complex::@2/bool_complex::i#3, bool_complex::@4/bool_complex::i#4 )
  bool_complex::i#1 = bool_complex::i#5 + rangenext(0,$14)
  bool_complex::$10 = bool_complex::i#1 != rangelast(0,$14)
  if(bool_complex::$10) goto bool_complex::@1
  to:bool_complex::@return
bool_complex::@return: scope:[bool_complex]  from bool_complex::@3
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
void __start()
void bool_and()
bool~ bool_and::$0
number~ bool_and::$1
bool~ bool_and::$2
bool~ bool_and::$3
bool~ bool_and::$4
byte bool_and::i
byte bool_and::i#0
byte bool_and::i#1
byte bool_and::i#2
byte bool_and::i#3
byte bool_and::i#4
byte bool_and::i#5
constant byte* const bool_and::screen = (byte*)$400
void bool_complex()
bool~ bool_complex::$0
number~ bool_complex::$1
bool~ bool_complex::$10
bool~ bool_complex::$2
bool~ bool_complex::$3
bool~ bool_complex::$4
number~ bool_complex::$5
bool~ bool_complex::$6
bool~ bool_complex::$7
bool~ bool_complex::$8
bool~ bool_complex::$9
byte bool_complex::i
byte bool_complex::i#0
byte bool_complex::i#1
byte bool_complex::i#2
byte bool_complex::i#3
byte bool_complex::i#4
byte bool_complex::i#5
constant byte* const bool_complex::screen = (byte*)$478
void bool_not()
bool~ bool_not::$0
number~ bool_not::$1
bool~ bool_not::$2
bool~ bool_not::$3
bool~ bool_not::$4
bool~ bool_not::$5
byte bool_not::i
byte bool_not::i#0
byte bool_not::i#1
byte bool_not::i#2
byte bool_not::i#3
byte bool_not::i#4
byte bool_not::i#5
constant byte* const bool_not::screen = (byte*)$450
void bool_or()
bool~ bool_or::$0
number~ bool_or::$1
bool~ bool_or::$2
bool~ bool_or::$3
bool~ bool_or::$4
byte bool_or::i
byte bool_or::i#0
byte bool_or::i#1
byte bool_or::i#2
byte bool_or::i#3
byte bool_or::i#4
byte bool_or::i#5
constant byte* const bool_or::screen = (byte*)$428
void main()

Adding number conversion cast (unumber) $a in bool_and::$0 = bool_and::i#2 < $a
Adding number conversion cast (unumber) 1 in bool_and::$1 = bool_and::i#2 & 1
Adding number conversion cast (unumber) bool_and::$1 in bool_and::$1 = bool_and::i#2 & (unumber)1
Adding number conversion cast (unumber) 0 in bool_and::$2 = bool_and::$1 == 0
Adding number conversion cast (unumber) $a in bool_or::$0 = bool_or::i#2 < $a
Adding number conversion cast (unumber) 1 in bool_or::$1 = bool_or::i#2 & 1
Adding number conversion cast (unumber) bool_or::$1 in bool_or::$1 = bool_or::i#2 & (unumber)1
Adding number conversion cast (unumber) 0 in bool_or::$2 = bool_or::$1 == 0
Adding number conversion cast (unumber) $a in bool_not::$0 = bool_not::i#2 < $a
Adding number conversion cast (unumber) 1 in bool_not::$1 = bool_not::i#2 & 1
Adding number conversion cast (unumber) bool_not::$1 in bool_not::$1 = bool_not::i#2 & (unumber)1
Adding number conversion cast (unumber) 0 in bool_not::$2 = bool_not::$1 == 0
Adding number conversion cast (unumber) $a in bool_complex::$0 = bool_complex::i#2 < $a
Adding number conversion cast (unumber) 1 in bool_complex::$1 = bool_complex::i#2 & 1
Adding number conversion cast (unumber) bool_complex::$1 in bool_complex::$1 = bool_complex::i#2 & (unumber)1
Adding number conversion cast (unumber) 0 in bool_complex::$2 = bool_complex::$1 == 0
Adding number conversion cast (unumber) $a in bool_complex::$4 = bool_complex::i#2 < $a
Adding number conversion cast (unumber) 1 in bool_complex::$5 = bool_complex::i#2 & 1
Adding number conversion cast (unumber) bool_complex::$5 in bool_complex::$5 = bool_complex::i#2 & (unumber)1
Adding number conversion cast (unumber) 0 in bool_complex::$6 = bool_complex::$5 == 0
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 1064
Simplifying constant pointer cast (byte*) 1104
Simplifying constant pointer cast (byte*) 1144
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in bool_and::$1 = bool_and::i#2 & 1
Inferred type updated to byte in bool_or::$1 = bool_or::i#2 & 1
Inferred type updated to byte in bool_not::$1 = bool_not::i#2 & 1
Inferred type updated to byte in bool_complex::$1 = bool_complex::i#2 & 1
Inferred type updated to byte in bool_complex::$5 = bool_complex::i#2 & 1
Alias bool_and::i#2 = bool_and::i#3 bool_and::i#4 
Alias bool_or::i#2 = bool_or::i#3 bool_or::i#4 
Alias bool_not::i#2 = bool_not::i#3 bool_not::i#4 
Alias bool_complex::i#2 = bool_complex::i#3 bool_complex::i#4 
Successful SSA optimization Pass2AliasElimination
Alias bool_and::i#2 = bool_and::i#5 
Alias bool_or::i#2 = bool_or::i#5 
Alias bool_not::i#2 = bool_not::i#5 
Alias bool_complex::i#2 = bool_complex::i#5 
Successful SSA optimization Pass2AliasElimination
Identified duplicate assignment right side [61] bool_complex::$5 = bool_complex::i#2 & 1
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition bool_and::$4 [16] if(bool_and::i#1!=rangelast(0,$14)) goto bool_and::@1
Simple Condition bool_or::$4 [29] if(bool_or::i#1!=rangelast(0,$14)) goto bool_or::@1
Simple Condition bool_not::$5 [43] if(bool_not::i#1!=rangelast(0,$14)) goto bool_not::@1
Simple Condition bool_complex::$10 [62] if(bool_complex::i#1!=rangelast(0,$14)) goto bool_complex::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [10] bool_and::$3 = bool_and::$0 && bool_and::$2
Rewriting || if()-condition to two if()s [23] bool_or::$3 = bool_or::$0 || bool_or::$2
Rewriting ! if()-condition to reversed if() [37] bool_not::$4 = ! bool_not::$3
Rewriting || if()-condition to two if()s [36] bool_not::$3 = bool_not::$0 || bool_not::$2
Rewriting || if()-condition to two if()s [56] bool_complex::$9 = bool_complex::$3 || bool_complex::$8
Rewriting && if()-condition to two if()s [50] bool_complex::$3 = bool_complex::$0 && bool_complex::$2
Rewriting ! if()-condition to reversed if() [55] bool_complex::$8 = ! bool_complex::$7
Rewriting || if()-condition to two if()s [54] bool_complex::$7 = bool_complex::$4 || bool_complex::$6
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant bool_and::i#0 = 0
Constant bool_or::i#0 = 0
Constant bool_not::i#0 = 0
Constant bool_complex::i#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [14] bool_and::i#1 = ++ bool_and::i#2 to ++
Resolved ranged comparison value [16] if(bool_and::i#1!=rangelast(0,$14)) goto bool_and::@1 to $15
Resolved ranged next value [27] bool_or::i#1 = ++ bool_or::i#2 to ++
Resolved ranged comparison value [29] if(bool_or::i#1!=rangelast(0,$14)) goto bool_or::@1 to $15
Resolved ranged next value [41] bool_not::i#1 = ++ bool_not::i#2 to ++
Resolved ranged comparison value [43] if(bool_not::i#1!=rangelast(0,$14)) goto bool_not::@1 to $15
Resolved ranged next value [60] bool_complex::i#1 = ++ bool_complex::i#2 to ++
Resolved ranged comparison value [62] if(bool_complex::i#1!=rangelast(0,$14)) goto bool_complex::@1 to $15
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) $15 in [13] if(bool_and::i#1!=$15) goto bool_and::@1
Adding number conversion cast (unumber) $15 in [23] if(bool_or::i#1!=$15) goto bool_or::@1
Adding number conversion cast (unumber) $15 in [33] if(bool_not::i#1!=$15) goto bool_not::@1
Adding number conversion cast (unumber) $15 in [46] if(bool_complex::i#1!=$15) goto bool_complex::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $15
Simplifying constant integer cast $15
Simplifying constant integer cast $15
Simplifying constant integer cast $15
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) $15
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias bool_complex::$5 = bool_complex::$1 
Successful SSA optimization Pass2AliasElimination
Simple Condition bool_and::$0 [9] if(bool_and::i#2<$a) goto bool_and::@5
Simple Condition bool_or::$0 [19] if(bool_or::i#2<$a) goto bool_or::@2
Simple Condition bool_not::$0 [29] if(bool_not::i#2<$a) goto bool_not::@4
Simple Condition bool_complex::$0 [41] if(bool_complex::i#2<$a) goto bool_complex::@6
Simple Condition bool_and::$2 [47] if(bool_and::$1==0) goto bool_and::@2
Simple Condition bool_or::$2 [48] if(bool_or::$1==0) goto bool_or::@2
Simple Condition bool_not::$2 [49] if(bool_not::$1==0) goto bool_not::@4
Simple Condition bool_complex::$4 [50] if(bool_complex::i#2<$a) goto bool_complex::@4
Simple Condition bool_complex::$2 [51] if(bool_complex::$5==0) goto bool_complex::@2
Simple Condition bool_complex::$6 [52] if(bool_complex::$5==0) goto bool_complex::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [9] if(bool_and::i#2>=$a) goto bool_and::@4
Negating conditional jump and destination [41] if(bool_complex::i#2>=$a) goto bool_complex::@5
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Inlining constant with var siblings bool_and::i#0
Inlining constant with var siblings bool_or::i#0
Inlining constant with var siblings bool_not::i#0
Inlining constant with var siblings bool_complex::i#0
Constant inlined bool_complex::i#0 = 0
Constant inlined bool_or::i#0 = 0
Constant inlined bool_not::i#0 = 0
Constant inlined bool_and::i#0 = 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting bool_and::@6(between bool_and::@3 and bool_and::@1)
Added new block during phi lifting bool_or::@6(between bool_or::@3 and bool_or::@1)
Added new block during phi lifting bool_not::@6(between bool_not::@3 and bool_not::@1)
Added new block during phi lifting bool_complex::@8(between bool_complex::@3 and bool_complex::@1)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of bool_and
Adding NOP phi() at start of bool_or
Adding NOP phi() at start of bool_not
Adding NOP phi() at start of bool_complex
CALL GRAPH
Calls in [main] to bool_and:1 bool_or:3 bool_not:5 bool_complex:7 

Created 4 initial phi equivalence classes
Coalesced [19] bool_and::i#6 = bool_and::i#1
Coalesced [30] bool_or::i#6 = bool_or::i#1
Coalesced [41] bool_not::i#6 = bool_not::i#1
Coalesced [54] bool_complex::i#6 = bool_complex::i#1
Coalesced down to 4 phi equivalence classes
Culled Empty Block label main::@4
Culled Empty Block label bool_and::@6
Culled Empty Block label bool_or::@6
Culled Empty Block label bool_not::@6
Culled Empty Block label bool_complex::@8
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of bool_and
Adding NOP phi() at start of bool_or
Adding NOP phi() at start of bool_not
Adding NOP phi() at start of bool_complex

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call bool_and 
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call bool_or 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] phi()
  [5] call bool_not 
  to:main::@3
main::@3: scope:[main]  from main::@2
  [6] phi()
  [7] call bool_complex 
  to:main::@return
main::@return: scope:[main]  from main::@3
  [8] return 
  to:@return

void bool_and()
bool_and: scope:[bool_and]  from main
  [9] phi()
  to:bool_and::@1
bool_and::@1: scope:[bool_and]  from bool_and bool_and::@3
  [10] bool_and::i#2 = phi( bool_and/0, bool_and::@3/bool_and::i#1 )
  [11] bool_and::$1 = bool_and::i#2 & 1
  [12] if(bool_and::i#2>=$a) goto bool_and::@4
  to:bool_and::@5
bool_and::@5: scope:[bool_and]  from bool_and::@1
  [13] if(bool_and::$1==0) goto bool_and::@2
  to:bool_and::@4
bool_and::@4: scope:[bool_and]  from bool_and::@1 bool_and::@5
  [14] bool_and::screen[bool_and::i#2] = ' '
  to:bool_and::@3
bool_and::@3: scope:[bool_and]  from bool_and::@2 bool_and::@4
  [15] bool_and::i#1 = ++ bool_and::i#2
  [16] if(bool_and::i#1!=$15) goto bool_and::@1
  to:bool_and::@return
bool_and::@return: scope:[bool_and]  from bool_and::@3
  [17] return 
  to:@return
bool_and::@2: scope:[bool_and]  from bool_and::@5
  [18] bool_and::screen[bool_and::i#2] = '*'
  to:bool_and::@3

void bool_or()
bool_or: scope:[bool_or]  from main::@1
  [19] phi()
  to:bool_or::@1
bool_or::@1: scope:[bool_or]  from bool_or bool_or::@3
  [20] bool_or::i#2 = phi( bool_or/0, bool_or::@3/bool_or::i#1 )
  [21] bool_or::$1 = bool_or::i#2 & 1
  [22] if(bool_or::i#2<$a) goto bool_or::@2
  to:bool_or::@5
bool_or::@5: scope:[bool_or]  from bool_or::@1
  [23] if(bool_or::$1==0) goto bool_or::@2
  to:bool_or::@4
bool_or::@4: scope:[bool_or]  from bool_or::@5
  [24] bool_or::screen[bool_or::i#2] = ' '
  to:bool_or::@3
bool_or::@3: scope:[bool_or]  from bool_or::@2 bool_or::@4
  [25] bool_or::i#1 = ++ bool_or::i#2
  [26] if(bool_or::i#1!=$15) goto bool_or::@1
  to:bool_or::@return
bool_or::@return: scope:[bool_or]  from bool_or::@3
  [27] return 
  to:@return
bool_or::@2: scope:[bool_or]  from bool_or::@1 bool_or::@5
  [28] bool_or::screen[bool_or::i#2] = '*'
  to:bool_or::@3

void bool_not()
bool_not: scope:[bool_not]  from main::@2
  [29] phi()
  to:bool_not::@1
bool_not::@1: scope:[bool_not]  from bool_not bool_not::@3
  [30] bool_not::i#2 = phi( bool_not/0, bool_not::@3/bool_not::i#1 )
  [31] bool_not::$1 = bool_not::i#2 & 1
  [32] if(bool_not::i#2<$a) goto bool_not::@4
  to:bool_not::@5
bool_not::@5: scope:[bool_not]  from bool_not::@1
  [33] if(bool_not::$1==0) goto bool_not::@4
  to:bool_not::@2
bool_not::@2: scope:[bool_not]  from bool_not::@5
  [34] bool_not::screen[bool_not::i#2] = '*'
  to:bool_not::@3
bool_not::@3: scope:[bool_not]  from bool_not::@2 bool_not::@4
  [35] bool_not::i#1 = ++ bool_not::i#2
  [36] if(bool_not::i#1!=$15) goto bool_not::@1
  to:bool_not::@return
bool_not::@return: scope:[bool_not]  from bool_not::@3
  [37] return 
  to:@return
bool_not::@4: scope:[bool_not]  from bool_not::@1 bool_not::@5
  [38] bool_not::screen[bool_not::i#2] = ' '
  to:bool_not::@3

void bool_complex()
bool_complex: scope:[bool_complex]  from main::@3
  [39] phi()
  to:bool_complex::@1
bool_complex::@1: scope:[bool_complex]  from bool_complex bool_complex::@3
  [40] bool_complex::i#2 = phi( bool_complex/0, bool_complex::@3/bool_complex::i#1 )
  [41] bool_complex::$5 = bool_complex::i#2 & 1
  [42] if(bool_complex::i#2>=$a) goto bool_complex::@5
  to:bool_complex::@6
bool_complex::@6: scope:[bool_complex]  from bool_complex::@1
  [43] if(bool_complex::$5==0) goto bool_complex::@2
  to:bool_complex::@5
bool_complex::@5: scope:[bool_complex]  from bool_complex::@1 bool_complex::@6
  [44] if(bool_complex::i#2<$a) goto bool_complex::@4
  to:bool_complex::@7
bool_complex::@7: scope:[bool_complex]  from bool_complex::@5
  [45] if(bool_complex::$5==0) goto bool_complex::@4
  to:bool_complex::@2
bool_complex::@2: scope:[bool_complex]  from bool_complex::@6 bool_complex::@7
  [46] bool_complex::screen[bool_complex::i#2] = '*'
  to:bool_complex::@3
bool_complex::@3: scope:[bool_complex]  from bool_complex::@2 bool_complex::@4
  [47] bool_complex::i#1 = ++ bool_complex::i#2
  [48] if(bool_complex::i#1!=$15) goto bool_complex::@1
  to:bool_complex::@return
bool_complex::@return: scope:[bool_complex]  from bool_complex::@3
  [49] return 
  to:@return
bool_complex::@4: scope:[bool_complex]  from bool_complex::@5 bool_complex::@7
  [50] bool_complex::screen[bool_complex::i#2] = ' '
  to:bool_complex::@3


VARIABLE REGISTER WEIGHTS
void bool_and()
byte~ bool_and::$1 101.0
byte bool_and::i
byte bool_and::i#1 151.5
byte bool_and::i#2 100.99999999999999
void bool_complex()
byte~ bool_complex::$5 75.75
byte bool_complex::i
byte bool_complex::i#1 151.5
byte bool_complex::i#2 88.375
void bool_not()
byte~ bool_not::$1 101.0
byte bool_not::i
byte bool_not::i#1 151.5
byte bool_not::i#2 100.99999999999999
void bool_or()
byte~ bool_or::$1 101.0
byte bool_or::i
byte bool_or::i#1 151.5
byte bool_or::i#2 100.99999999999999
void main()

Initial phi equivalence classes
[ bool_and::i#2 bool_and::i#1 ]
[ bool_or::i#2 bool_or::i#1 ]
[ bool_not::i#2 bool_not::i#1 ]
[ bool_complex::i#2 bool_complex::i#1 ]
Added variable bool_and::$1 to live range equivalence class [ bool_and::$1 ]
Added variable bool_or::$1 to live range equivalence class [ bool_or::$1 ]
Added variable bool_not::$1 to live range equivalence class [ bool_not::$1 ]
Added variable bool_complex::$5 to live range equivalence class [ bool_complex::$5 ]
Complete equivalence classes
[ bool_and::i#2 bool_and::i#1 ]
[ bool_or::i#2 bool_or::i#1 ]
[ bool_not::i#2 bool_not::i#1 ]
[ bool_complex::i#2 bool_complex::i#1 ]
[ bool_and::$1 ]
[ bool_or::$1 ]
[ bool_not::$1 ]
[ bool_complex::$5 ]
Allocated zp[1]:2 [ bool_and::i#2 bool_and::i#1 ]
Allocated zp[1]:3 [ bool_or::i#2 bool_or::i#1 ]
Allocated zp[1]:4 [ bool_not::i#2 bool_not::i#1 ]
Allocated zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ]
Allocated zp[1]:6 [ bool_and::$1 ]
Allocated zp[1]:7 [ bool_or::$1 ]
Allocated zp[1]:8 [ bool_not::$1 ]
Allocated zp[1]:9 [ bool_complex::$5 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [14] bool_and::screen[bool_and::i#2] = ' ' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ bool_and::i#2 bool_and::i#1 ]
Statement [18] bool_and::screen[bool_and::i#2] = '*' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Statement [24] bool_or::screen[bool_or::i#2] = ' ' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:3 [ bool_or::i#2 bool_or::i#1 ]
Statement [28] bool_or::screen[bool_or::i#2] = '*' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Statement [34] bool_not::screen[bool_not::i#2] = '*' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ bool_not::i#2 bool_not::i#1 ]
Statement [38] bool_not::screen[bool_not::i#2] = ' ' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Statement [46] bool_complex::screen[bool_complex::i#2] = '*' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ]
Statement [50] bool_complex::screen[bool_complex::i#2] = ' ' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Statement [11] bool_and::$1 = bool_and::i#2 & 1 [ bool_and::i#2 bool_and::$1 ] ( bool_and:1 [ bool_and::i#2 bool_and::$1 ] { }  ) always clobbers reg byte a 
Statement [14] bool_and::screen[bool_and::i#2] = ' ' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Statement [18] bool_and::screen[bool_and::i#2] = '*' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Statement [21] bool_or::$1 = bool_or::i#2 & 1 [ bool_or::i#2 bool_or::$1 ] ( bool_or:3 [ bool_or::i#2 bool_or::$1 ] { }  ) always clobbers reg byte a 
Statement [24] bool_or::screen[bool_or::i#2] = ' ' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Statement [28] bool_or::screen[bool_or::i#2] = '*' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Statement [31] bool_not::$1 = bool_not::i#2 & 1 [ bool_not::i#2 bool_not::$1 ] ( bool_not:5 [ bool_not::i#2 bool_not::$1 ] { }  ) always clobbers reg byte a 
Statement [34] bool_not::screen[bool_not::i#2] = '*' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Statement [38] bool_not::screen[bool_not::i#2] = ' ' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Statement [41] bool_complex::$5 = bool_complex::i#2 & 1 [ bool_complex::i#2 bool_complex::$5 ] ( bool_complex:7 [ bool_complex::i#2 bool_complex::$5 ] { }  ) always clobbers reg byte a 
Statement [46] bool_complex::screen[bool_complex::i#2] = '*' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Statement [50] bool_complex::screen[bool_complex::i#2] = ' ' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ bool_and::i#2 bool_and::i#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ bool_or::i#2 bool_or::i#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ bool_not::i#2 bool_not::i#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ bool_and::$1 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ bool_or::$1 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ bool_not::$1 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ bool_complex::$5 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [bool_and] 252.5: zp[1]:2 [ bool_and::i#2 bool_and::i#1 ] 101: zp[1]:6 [ bool_and::$1 ] 
Uplift Scope [bool_or] 252.5: zp[1]:3 [ bool_or::i#2 bool_or::i#1 ] 101: zp[1]:7 [ bool_or::$1 ] 
Uplift Scope [bool_not] 252.5: zp[1]:4 [ bool_not::i#2 bool_not::i#1 ] 101: zp[1]:8 [ bool_not::$1 ] 
Uplift Scope [bool_complex] 239.88: zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ] 75.75: zp[1]:9 [ bool_complex::$5 ] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [bool_and] best 3206 combination reg byte x [ bool_and::i#2 bool_and::i#1 ] reg byte a [ bool_and::$1 ] 
Uplifting [bool_or] best 2976 combination reg byte x [ bool_or::i#2 bool_or::i#1 ] reg byte a [ bool_or::$1 ] 
Uplifting [bool_not] best 2746 combination reg byte x [ bool_not::i#2 bool_not::i#1 ] reg byte a [ bool_not::$1 ] 
Uplifting [bool_complex] best 2476 combination reg byte x [ bool_complex::i#2 bool_complex::i#1 ] reg byte a [ bool_complex::$5 ] 
Uplifting [main] best 2476 combination 
Uplifting [] best 2476 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// A test of boolean conditions using && || and !
  // Upstart
  // Commodore 64 PRG executable file
.file [name="bool-ifs.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    // [1] call bool_and 
    // [9] phi from main to bool_and [phi:main->bool_and]
  bool_and_from_main:
    jsr bool_and
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call bool_or 
    // [19] phi from main::@1 to bool_or [phi:main::@1->bool_or]
  bool_or_from___b1:
    jsr bool_or
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [5] call bool_not 
    // [29] phi from main::@2 to bool_not [phi:main::@2->bool_not]
  bool_not_from___b2:
    jsr bool_not
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [7] call bool_complex 
    // [39] phi from main::@3 to bool_complex [phi:main::@3->bool_complex]
  bool_complex_from___b3:
    jsr bool_complex
    jmp __breturn
    // main::@return
  __breturn:
    // [8] return 
    rts
}
  // bool_and
bool_and: {
    .label screen = $400
    // [10] phi from bool_and to bool_and::@1 [phi:bool_and->bool_and::@1]
  __b1_from_bool_and:
    // [10] phi bool_and::i#2 = 0 [phi:bool_and->bool_and::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [10] phi from bool_and::@3 to bool_and::@1 [phi:bool_and::@3->bool_and::@1]
  __b1_from___b3:
    // [10] phi bool_and::i#2 = bool_and::i#1 [phi:bool_and::@3->bool_and::@1#0] -- register_copy 
    jmp __b1
    // bool_and::@1
  __b1:
    // [11] bool_and::$1 = bool_and::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [12] if(bool_and::i#2>=$a) goto bool_and::@4 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b4
    jmp __b5
    // bool_and::@5
  __b5:
    // [13] if(bool_and::$1==0) goto bool_and::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    jmp __b4
    // bool_and::@4
  __b4:
    // [14] bool_and::screen[bool_and::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
    // bool_and::@3
  __b3:
    // [15] bool_and::i#1 = ++ bool_and::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [16] if(bool_and::i#1!=$15) goto bool_and::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_and::@return
  __breturn:
    // [17] return 
    rts
    // bool_and::@2
  __b2:
    // [18] bool_and::screen[bool_and::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_or
bool_or: {
    .label screen = $428
    // [20] phi from bool_or to bool_or::@1 [phi:bool_or->bool_or::@1]
  __b1_from_bool_or:
    // [20] phi bool_or::i#2 = 0 [phi:bool_or->bool_or::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [20] phi from bool_or::@3 to bool_or::@1 [phi:bool_or::@3->bool_or::@1]
  __b1_from___b3:
    // [20] phi bool_or::i#2 = bool_or::i#1 [phi:bool_or::@3->bool_or::@1#0] -- register_copy 
    jmp __b1
    // bool_or::@1
  __b1:
    // [21] bool_or::$1 = bool_or::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [22] if(bool_or::i#2<$a) goto bool_or::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b2
    jmp __b5
    // bool_or::@5
  __b5:
    // [23] if(bool_or::$1==0) goto bool_or::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    jmp __b4
    // bool_or::@4
  __b4:
    // [24] bool_or::screen[bool_or::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
    // bool_or::@3
  __b3:
    // [25] bool_or::i#1 = ++ bool_or::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [26] if(bool_or::i#1!=$15) goto bool_or::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_or::@return
  __breturn:
    // [27] return 
    rts
    // bool_or::@2
  __b2:
    // [28] bool_or::screen[bool_or::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_not
bool_not: {
    .label screen = $450
    // [30] phi from bool_not to bool_not::@1 [phi:bool_not->bool_not::@1]
  __b1_from_bool_not:
    // [30] phi bool_not::i#2 = 0 [phi:bool_not->bool_not::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [30] phi from bool_not::@3 to bool_not::@1 [phi:bool_not::@3->bool_not::@1]
  __b1_from___b3:
    // [30] phi bool_not::i#2 = bool_not::i#1 [phi:bool_not::@3->bool_not::@1#0] -- register_copy 
    jmp __b1
    // bool_not::@1
  __b1:
    // [31] bool_not::$1 = bool_not::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [32] if(bool_not::i#2<$a) goto bool_not::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    jmp __b5
    // bool_not::@5
  __b5:
    // [33] if(bool_not::$1==0) goto bool_not::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    jmp __b2
    // bool_not::@2
  __b2:
    // [34] bool_not::screen[bool_not::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
    // bool_not::@3
  __b3:
    // [35] bool_not::i#1 = ++ bool_not::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] if(bool_not::i#1!=$15) goto bool_not::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_not::@return
  __breturn:
    // [37] return 
    rts
    // bool_not::@4
  __b4:
    // [38] bool_not::screen[bool_not::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // bool_complex
bool_complex: {
    .label screen = $478
    // [40] phi from bool_complex to bool_complex::@1 [phi:bool_complex->bool_complex::@1]
  __b1_from_bool_complex:
    // [40] phi bool_complex::i#2 = 0 [phi:bool_complex->bool_complex::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [40] phi from bool_complex::@3 to bool_complex::@1 [phi:bool_complex::@3->bool_complex::@1]
  __b1_from___b3:
    // [40] phi bool_complex::i#2 = bool_complex::i#1 [phi:bool_complex::@3->bool_complex::@1#0] -- register_copy 
    jmp __b1
    // bool_complex::@1
  __b1:
    // [41] bool_complex::$5 = bool_complex::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [42] if(bool_complex::i#2>=$a) goto bool_complex::@5 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b5
    jmp __b6
    // bool_complex::@6
  __b6:
    // [43] if(bool_complex::$5==0) goto bool_complex::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    jmp __b5
    // bool_complex::@5
  __b5:
    // [44] if(bool_complex::i#2<$a) goto bool_complex::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    jmp __b7
    // bool_complex::@7
  __b7:
    // [45] if(bool_complex::$5==0) goto bool_complex::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    jmp __b2
    // bool_complex::@2
  __b2:
    // [46] bool_complex::screen[bool_complex::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
    // bool_complex::@3
  __b3:
    // [47] bool_complex::i#1 = ++ bool_complex::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [48] if(bool_complex::i#1!=$15) goto bool_complex::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_complex::@return
  __breturn:
    // [49] return 
    rts
    // bool_complex::@4
  __b4:
    // [50] bool_complex::screen[bool_complex::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b6
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Removing instruction __b1_from_main:
Removing instruction bool_or_from___b1:
Removing instruction __b2_from___b1:
Removing instruction bool_not_from___b2:
Removing instruction __b3_from___b2:
Removing instruction bool_complex_from___b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bool_and_from_main:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from_bool_and:
Removing instruction __b5:
Removing instruction __breturn:
Removing instruction __b1_from_bool_or:
Removing instruction __b5:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __b1_from_bool_not:
Removing instruction __b5:
Removing instruction __b2:
Removing instruction __breturn:
Removing instruction __b1_from_bool_complex:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
void bool_and()
byte~ bool_and::$1 reg byte a 101.0
byte bool_and::i
byte bool_and::i#1 reg byte x 151.5
byte bool_and::i#2 reg byte x 100.99999999999999
constant byte* const bool_and::screen = (byte*) 1024
void bool_complex()
byte~ bool_complex::$5 reg byte a 75.75
byte bool_complex::i
byte bool_complex::i#1 reg byte x 151.5
byte bool_complex::i#2 reg byte x 88.375
constant byte* const bool_complex::screen = (byte*) 1144
void bool_not()
byte~ bool_not::$1 reg byte a 101.0
byte bool_not::i
byte bool_not::i#1 reg byte x 151.5
byte bool_not::i#2 reg byte x 100.99999999999999
constant byte* const bool_not::screen = (byte*) 1104
void bool_or()
byte~ bool_or::$1 reg byte a 101.0
byte bool_or::i
byte bool_or::i#1 reg byte x 151.5
byte bool_or::i#2 reg byte x 100.99999999999999
constant byte* const bool_or::screen = (byte*) 1064
void main()

reg byte x [ bool_and::i#2 bool_and::i#1 ]
reg byte x [ bool_or::i#2 bool_or::i#1 ]
reg byte x [ bool_not::i#2 bool_not::i#1 ]
reg byte x [ bool_complex::i#2 bool_complex::i#1 ]
reg byte a [ bool_and::$1 ]
reg byte a [ bool_or::$1 ]
reg byte a [ bool_not::$1 ]
reg byte a [ bool_complex::$5 ]


FINAL ASSEMBLER
Score: 1684

  // File Comments
// A test of boolean conditions using && || and !
  // Upstart
  // Commodore 64 PRG executable file
.file [name="bool-ifs.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    // bool_and()
    // [1] call bool_and 
    // [9] phi from main to bool_and [phi:main->bool_and]
    jsr bool_and
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // bool_or()
    // [3] call bool_or 
    // [19] phi from main::@1 to bool_or [phi:main::@1->bool_or]
    jsr bool_or
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // bool_not()
    // [5] call bool_not 
    // [29] phi from main::@2 to bool_not [phi:main::@2->bool_not]
    jsr bool_not
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // main::@3
    // bool_complex()
    // [7] call bool_complex 
    // [39] phi from main::@3 to bool_complex [phi:main::@3->bool_complex]
    jsr bool_complex
    // main::@return
    // }
    // [8] return 
    rts
}
  // bool_and
bool_and: {
    .label screen = $400
    // [10] phi from bool_and to bool_and::@1 [phi:bool_and->bool_and::@1]
    // [10] phi bool_and::i#2 = 0 [phi:bool_and->bool_and::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [10] phi from bool_and::@3 to bool_and::@1 [phi:bool_and::@3->bool_and::@1]
    // [10] phi bool_and::i#2 = bool_and::i#1 [phi:bool_and::@3->bool_and::@1#0] -- register_copy 
    // bool_and::@1
  __b1:
    // i&1
    // [11] bool_and::$1 = bool_and::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if( (i<10) && ((i&1)==0) )
    // [12] if(bool_and::i#2>=$a) goto bool_and::@4 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b4
    // bool_and::@5
    // [13] if(bool_and::$1==0) goto bool_and::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // bool_and::@4
  __b4:
    // screen[i] = ' '
    // [14] bool_and::screen[bool_and::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    // bool_and::@3
  __b3:
    // for( byte i : 0..20)
    // [15] bool_and::i#1 = ++ bool_and::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [16] if(bool_and::i#1!=$15) goto bool_and::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_and::@return
    // }
    // [17] return 
    rts
    // bool_and::@2
  __b2:
    // screen[i] = '*'
    // [18] bool_and::screen[bool_and::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_or
bool_or: {
    .label screen = $428
    // [20] phi from bool_or to bool_or::@1 [phi:bool_or->bool_or::@1]
    // [20] phi bool_or::i#2 = 0 [phi:bool_or->bool_or::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [20] phi from bool_or::@3 to bool_or::@1 [phi:bool_or::@3->bool_or::@1]
    // [20] phi bool_or::i#2 = bool_or::i#1 [phi:bool_or::@3->bool_or::@1#0] -- register_copy 
    // bool_or::@1
  __b1:
    // i&1
    // [21] bool_or::$1 = bool_or::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if( (i<10) || ((i&1)==0) )
    // [22] if(bool_or::i#2<$a) goto bool_or::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b2
    // bool_or::@5
    // [23] if(bool_or::$1==0) goto bool_or::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // bool_or::@4
    // screen[i] = ' '
    // [24] bool_or::screen[bool_or::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    // bool_or::@3
  __b3:
    // for( byte i : 0..20)
    // [25] bool_or::i#1 = ++ bool_or::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [26] if(bool_or::i#1!=$15) goto bool_or::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_or::@return
    // }
    // [27] return 
    rts
    // bool_or::@2
  __b2:
    // screen[i] = '*'
    // [28] bool_or::screen[bool_or::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_not
bool_not: {
    .label screen = $450
    // [30] phi from bool_not to bool_not::@1 [phi:bool_not->bool_not::@1]
    // [30] phi bool_not::i#2 = 0 [phi:bool_not->bool_not::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [30] phi from bool_not::@3 to bool_not::@1 [phi:bool_not::@3->bool_not::@1]
    // [30] phi bool_not::i#2 = bool_not::i#1 [phi:bool_not::@3->bool_not::@1#0] -- register_copy 
    // bool_not::@1
  __b1:
    // i&1
    // [31] bool_not::$1 = bool_not::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if( !((i<10) || (i&1)==0))
    // [32] if(bool_not::i#2<$a) goto bool_not::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    // bool_not::@5
    // [33] if(bool_not::$1==0) goto bool_not::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    // bool_not::@2
    // screen[i] = '*'
    // [34] bool_not::screen[bool_not::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    // bool_not::@3
  __b3:
    // for( byte i : 0..20)
    // [35] bool_not::i#1 = ++ bool_not::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] if(bool_not::i#1!=$15) goto bool_not::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_not::@return
    // }
    // [37] return 
    rts
    // bool_not::@4
  __b4:
    // screen[i] = ' '
    // [38] bool_not::screen[bool_not::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // bool_complex
bool_complex: {
    .label screen = $478
    // [40] phi from bool_complex to bool_complex::@1 [phi:bool_complex->bool_complex::@1]
    // [40] phi bool_complex::i#2 = 0 [phi:bool_complex->bool_complex::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [40] phi from bool_complex::@3 to bool_complex::@1 [phi:bool_complex::@3->bool_complex::@1]
    // [40] phi bool_complex::i#2 = bool_complex::i#1 [phi:bool_complex::@3->bool_complex::@1#0] -- register_copy 
    // bool_complex::@1
  __b1:
    // i&1
    // [41] bool_complex::$5 = bool_complex::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if( ((i<10) && (i&1)==0) || !((i<10) || (i&1)==0) )
    // [42] if(bool_complex::i#2>=$a) goto bool_complex::@5 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b5
    // bool_complex::@6
    // [43] if(bool_complex::$5==0) goto bool_complex::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // bool_complex::@5
  __b5:
    // [44] if(bool_complex::i#2<$a) goto bool_complex::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    // bool_complex::@7
    // [45] if(bool_complex::$5==0) goto bool_complex::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    // bool_complex::@2
  __b2:
    // screen[i] = '*'
    // [46] bool_complex::screen[bool_complex::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    // bool_complex::@3
  __b3:
    // for( byte i : 0..20)
    // [47] bool_complex::i#1 = ++ bool_complex::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [48] if(bool_complex::i#1!=$15) goto bool_complex::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_complex::@return
    // }
    // [49] return 
    rts
    // bool_complex::@4
  __b4:
    // screen[i] = ' '
    // [50] bool_complex::screen[bool_complex::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // File Data

