Resolved forward reference plex_irq to interrupt(KERNEL_MIN)(void()) plex_irq()
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) init::sx)
Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) SPRITE
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call plexSetScreen (byte*) plexInit::screen 
Inlined call call plexFreePrepare 
Inlined call call plexFreeAdd (byte) plexShowSprite::ypos 
Inlined call (byte~) plex_irq::$2 ← call plexFreeNextYpos 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) plexInit::plexSetScreen1_@return
Culled Empty Block (label) plexInit::@2
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) plexSort::plexFreePrepare1_@return
Culled Empty Block (label) plexSort::@7
Culled Empty Block (label) @7
Culled Empty Block (label) plexShowSprite::plexFreeAdd1_@return
Culled Empty Block (label) plexShowSprite::@5
Culled Empty Block (label) plexShowSprite::@3
Culled Empty Block (label) @8
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) @13
Culled Empty Block (label) plex_irq::plexFreeNextYpos1_@1
Culled Empty Block (label) plex_irq::@6
Culled Empty Block (label) @15
Culled Empty Block (label) loop::@2
Culled Empty Block (label) loop::@13
Culled Empty Block (label) loop::@3
Culled Empty Block (label) loop::@14
Culled Empty Block (label) loop::@5
Culled Empty Block (label) loop::@7
Culled Empty Block (label) loop::@8
Culled Empty Block (label) loop::@9
Culled Empty Block (label) loop::@12

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) SPRITES_XPOS ← ((byte*)) (number) $d000
  (byte*) SPRITES_YPOS ← ((byte*)) (number) $d001
  (byte*) SPRITES_XMSB ← ((byte*)) (number) $d010
  (byte*) RASTER ← ((byte*)) (number) $d012
  (byte*) SPRITES_ENABLE ← ((byte*)) (number) $d015
  (byte*) BORDERCOL ← ((byte*)) (number) $d020
  (byte*) SPRITES_COLS ← ((byte*)) (number) $d027
  (byte*) VIC_CONTROL ← ((byte*)) (number) $d011
  (byte*) D011 ← ((byte*)) (number) $d011
  (byte) VIC_DEN ← (number) $10
  (byte) VIC_RSEL ← (number) 8
  (byte*) IRQ_STATUS ← ((byte*)) (number) $d019
  (byte*) IRQ_ENABLE ← ((byte*)) (number) $d01a
  (byte) IRQ_RASTER ← (number) 1
  (byte*) CIA1_INTERRUPT ← ((byte*)) (number) $dc0d
  (byte) CIA_INTERRUPT_CLEAR ← (number) $7f
  (void()**) KERNEL_IRQ ← ((void()**)) (number) $314
  (byte) WHITE ← (number) 1
  (byte) RED ← (number) 2
  (byte) GREEN ← (number) 5
  to:@4
@4: scope:[]  from @begin
  (byte) PLEX_COUNT ← (number) $20
  (word[PLEX_COUNT]) PLEX_XPOS ← { fill( PLEX_COUNT, 0) }
  (byte[PLEX_COUNT]) PLEX_YPOS ← { fill( PLEX_COUNT, 0) }
  (byte[PLEX_COUNT]) PLEX_PTR ← { fill( PLEX_COUNT, 0) }
  (byte*) PLEX_SCREEN_PTR#0 ← ((byte*)) (number) $400+(number) $3f8
  (byte[PLEX_COUNT]) PLEX_SORTED_IDX ← { fill( PLEX_COUNT, 0) }
  (byte) plex_show_idx#0 ← (number) 0
  (byte) plex_sprite_idx#0 ← (number) 0
  (byte) plex_sprite_msb#0 ← (number) 1
  to:@9

(void()) plexInit((byte*) plexInit::screen)
plexInit: scope:[plexInit]  from init
  (byte*) plexInit::screen#1 ← phi( init/(byte*) plexInit::screen#0 )
  (byte*) plexInit::plexSetScreen1_screen#0 ← (byte*) plexInit::screen#1
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  (byte*) plexInit::plexSetScreen1_screen#1 ← phi( plexInit/(byte*) plexInit::plexSetScreen1_screen#0 )
  (byte*~) plexInit::plexSetScreen1_$0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
  (byte*) PLEX_SCREEN_PTR#1 ← (byte*~) plexInit::plexSetScreen1_$0
  to:plexInit::@3
plexInit::@3: scope:[plexInit]  from plexInit::plexSetScreen1
  (byte*) PLEX_SCREEN_PTR#22 ← phi( plexInit::plexSetScreen1/(byte*) PLEX_SCREEN_PTR#1 )
  (number~) plexInit::$1 ← (byte) PLEX_COUNT - (number) 1
  (byte) plexInit::i#0 ← (byte) 0
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::@3
  (byte*) PLEX_SCREEN_PTR#15 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 plexInit::@3/(byte*) PLEX_SCREEN_PTR#22 )
  (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::@3/(byte) plexInit::i#0 )
  *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  (byte) plexInit::i#1 ← (byte) plexInit::i#2 + rangenext(0,plexInit::$1)
  (bool~) plexInit::$2 ← (byte) plexInit::i#1 != rangelast(0,plexInit::$1)
  if((bool~) plexInit::$2) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  (byte*) PLEX_SCREEN_PTR#8 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 )
  (byte*) PLEX_SCREEN_PTR#2 ← (byte*) PLEX_SCREEN_PTR#8
  return 
  to:@return

(void()) plexSort()
plexSort: scope:[plexSort]  from loop::@11
  (number~) plexSort::$1 ← (byte) PLEX_COUNT - (number) 2
  (byte) plexSort::m#0 ← (byte) 0
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  (byte) plexSort::m#2 ← phi( plexSort/(byte) plexSort::m#0 plexSort::@2/(byte) plexSort::m#1 )
  (number~) plexSort::$2 ← (byte) plexSort::m#2 + (number) 1
  (byte) plexSort::nxt_idx#0 ← *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (number~) plexSort::$2)
  (byte) plexSort::nxt_y#0 ← *((byte[PLEX_COUNT]) PLEX_YPOS + (byte) plexSort::nxt_idx#0)
  (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT]) PLEX_YPOS + *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2))
  (bool~) plexSort::$4 ← ! (bool~) plexSort::$3
  if((bool~) plexSort::$4) goto plexSort::@2
  to:plexSort::@5
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  (byte) plexSort::m#3 ← phi( plexSort::@1/(byte) plexSort::m#2 plexSort::@4/(byte) plexSort::m#5 )
  (byte) plexSort::m#1 ← (byte) plexSort::m#3 + rangenext(0,plexSort::$1)
  (bool~) plexSort::$9 ← (byte) plexSort::m#1 != rangelast(0,plexSort::$1)
  if((bool~) plexSort::$9) goto plexSort::@1
  to:plexSort::@6
plexSort::@5: scope:[plexSort]  from plexSort::@1
  (byte) plexSort::nxt_idx#3 ← phi( plexSort::@1/(byte) plexSort::nxt_idx#0 )
  (byte) plexSort::nxt_y#2 ← phi( plexSort::@1/(byte) plexSort::nxt_y#0 )
  (byte) plexSort::m#4 ← phi( plexSort::@1/(byte) plexSort::m#2 )
  (byte) plexSort::s#0 ← (byte) plexSort::m#4
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@3 plexSort::@5
  (byte) plexSort::m#6 ← phi( plexSort::@3/(byte) plexSort::m#6 plexSort::@5/(byte) plexSort::m#4 )
  (byte) plexSort::nxt_idx#2 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 plexSort::@5/(byte) plexSort::nxt_idx#3 )
  (byte) plexSort::nxt_y#1 ← phi( plexSort::@3/(byte) plexSort::nxt_y#1 plexSort::@5/(byte) plexSort::nxt_y#2 )
  (byte) plexSort::s#3 ← phi( plexSort::@3/(byte) plexSort::s#1 plexSort::@5/(byte) plexSort::s#0 )
  (number~) plexSort::$5 ← (byte) plexSort::s#3 + (number) 1
  *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (number~) plexSort::$5) ← *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#3)
  (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  (bool~) plexSort::$6 ← (byte) plexSort::s#1 != (number) $ff
  (bool~) plexSort::$7 ← (byte) plexSort::nxt_y#1 < *((byte[PLEX_COUNT]) PLEX_YPOS + *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#1))
  (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
  if((bool~) plexSort::$8) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3
  (byte) plexSort::m#5 ← phi( plexSort::@3/(byte) plexSort::m#6 )
  (byte) plexSort::nxt_idx#1 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 )
  (byte) plexSort::s#4 ← phi( plexSort::@3/(byte) plexSort::s#1 )
  (byte) plexSort::s#2 ← ++ (byte) plexSort::s#4
  *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#1
  to:plexSort::@2
plexSort::@6: scope:[plexSort]  from plexSort::@2
  (byte) plex_show_idx#1 ← (number) 0
  (byte) plex_sprite_idx#1 ← (number) 0
  (byte) plex_sprite_msb#1 ← (number) 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  (byte) plex_sprite_msb#43 ← phi( plexSort::@6/(byte) plex_sprite_msb#1 )
  (byte) plex_sprite_idx#44 ← phi( plexSort::@6/(byte) plex_sprite_idx#1 )
  (byte) plex_show_idx#47 ← phi( plexSort::@6/(byte) plex_show_idx#1 )
  (byte) plexSort::plexFreePrepare1_s#0 ← (byte) 0
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#33 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_msb#43 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#33 )
  (byte) plex_sprite_idx#35 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_idx#44 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#35 )
  (byte) plex_show_idx#38 ← phi( plexSort::plexFreePrepare1/(byte) plex_show_idx#47 plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#38 )
  (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) plexSort::plexFreePrepare1_s#0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  *((byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
  (byte) plexSort::plexFreePrepare1_s#1 ← (byte) plexSort::plexFreePrepare1_s#2 + rangenext(0,7)
  (bool~) plexSort::plexFreePrepare1_$0 ← (byte) plexSort::plexFreePrepare1_s#1 != rangelast(0,7)
  if((bool~) plexSort::plexFreePrepare1_$0) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#25 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#33 )
  (byte) plex_sprite_idx#24 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#35 )
  (byte) plex_show_idx#26 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#38 )
  (byte) plex_free_next#0 ← (number) 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  (byte) plex_free_next#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_free_next#0 )
  (byte) plex_sprite_msb#13 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_msb#25 )
  (byte) plex_sprite_idx#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_idx#24 )
  (byte) plex_show_idx#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_show_idx#26 )
  (byte) plex_show_idx#2 ← (byte) plex_show_idx#12
  (byte) plex_sprite_idx#2 ← (byte) plex_sprite_idx#12
  (byte) plex_sprite_msb#2 ← (byte) plex_sprite_msb#13
  (byte) plex_free_next#1 ← (byte) plex_free_next#12
  return 
  to:@return

(void()) plexShowSprite()
plexShowSprite: scope:[plexShowSprite]  from plex_irq::@3
  (byte) plex_sprite_msb#44 ← phi( plex_irq::@3/(byte) plex_sprite_msb#28 )
  (byte*) PLEX_SCREEN_PTR#23 ← phi( plex_irq::@3/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) plex_free_next#23 ← phi( plex_irq::@3/(byte) plex_free_next#27 )
  (byte) plex_show_idx#13 ← phi( plex_irq::@3/(byte) plex_show_idx#27 )
  (byte) plex_sprite_idx#13 ← phi( plex_irq::@3/(byte) plex_sprite_idx#25 )
  (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#13 * (number) 2
  (byte) plexShowSprite::plex_sprite_idx2#0 ← (number~) plexShowSprite::$0
  (byte) plexShowSprite::ypos#0 ← *((byte[PLEX_COUNT]) PLEX_YPOS + *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#13))
  *((byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::ypos#0
  (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← (byte) plexShowSprite::ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  (byte) plex_sprite_msb#34 ← phi( plexShowSprite/(byte) plex_sprite_msb#44 )
  (byte) plexShowSprite::plex_sprite_idx2#2 ← phi( plexShowSprite/(byte) plexShowSprite::plex_sprite_idx2#0 )
  (byte) plex_sprite_idx#26 ← phi( plexShowSprite/(byte) plex_sprite_idx#13 )
  (byte*) PLEX_SCREEN_PTR#16 ← phi( plexShowSprite/(byte*) PLEX_SCREEN_PTR#23 )
  (byte) plex_show_idx#28 ← phi( plexShowSprite/(byte) plex_show_idx#13 )
  (byte) plex_free_next#13 ← phi( plexShowSprite/(byte) plex_free_next#23 )
  (byte) plexShowSprite::plexFreeAdd1_ypos#1 ← phi( plexShowSprite/(byte) plexShowSprite::plexFreeAdd1_ypos#0 )
  (number~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
  *((byte[8]) PLEX_FREE_YPOS + (byte) plex_free_next#13) ← (number~) plexShowSprite::plexFreeAdd1_$0
  (number~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#13 + (number) 1
  (number~) plexShowSprite::plexFreeAdd1_$2 ← (number~) plexShowSprite::plexFreeAdd1_$1 & (number) 7
  (byte) plex_free_next#2 ← (number~) plexShowSprite::plexFreeAdd1_$2
  to:plexShowSprite::@7
plexShowSprite::@7: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  (byte) plex_free_next#42 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_free_next#2 )
  (byte) plex_sprite_msb#26 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_msb#34 )
  (byte) plexShowSprite::plex_sprite_idx2#1 ← phi( plexShowSprite::plexFreeAdd1/(byte) plexShowSprite::plex_sprite_idx2#2 )
  (byte) plex_sprite_idx#14 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_idx#26 )
  (byte*) PLEX_SCREEN_PTR#9 ← phi( plexShowSprite::plexFreeAdd1/(byte*) PLEX_SCREEN_PTR#16 )
  (byte) plex_show_idx#14 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_show_idx#28 )
  *((byte*) PLEX_SCREEN_PTR#9 + (byte) plex_sprite_idx#14) ← *((byte[PLEX_COUNT]) PLEX_PTR + *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#14))
  (byte) plexShowSprite::xpos_idx#0 ← *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#14)
  (byte~) plexShowSprite::$10 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$2 ← < *((word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$10)
  *((byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#1) ← (byte~) plexShowSprite::$2
  (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$3 ← > *((word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11)
  (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
  if((bool~) plexShowSprite::$4) goto plexShowSprite::@1
  to:plexShowSprite::@4
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#32 ← phi( plexShowSprite::@7/(byte) plex_free_next#42 )
  (byte) plex_show_idx#29 ← phi( plexShowSprite::@7/(byte) plex_show_idx#14 )
  (byte) plex_sprite_idx#27 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#14 )
  (byte) plex_sprite_msb#14 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#26 )
  *((byte*) SPRITES_XMSB) ← *((byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#14
  to:plexShowSprite::@2
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#33 ← phi( plexShowSprite::@7/(byte) plex_free_next#42 )
  (byte) plex_show_idx#30 ← phi( plexShowSprite::@7/(byte) plex_show_idx#14 )
  (byte) plex_sprite_idx#28 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#14 )
  (byte) plex_sprite_msb#15 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#26 )
  (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#15
  *((byte*) SPRITES_XMSB) ← *((byte*) SPRITES_XMSB) & (number~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@4
  (byte) plex_free_next#24 ← phi( plexShowSprite::@1/(byte) plex_free_next#32 plexShowSprite::@4/(byte) plex_free_next#33 )
  (byte) plex_sprite_msb#16 ← phi( plexShowSprite::@1/(byte) plex_sprite_msb#14 plexShowSprite::@4/(byte) plex_sprite_msb#15 )
  (byte) plex_show_idx#15 ← phi( plexShowSprite::@1/(byte) plex_show_idx#29 plexShowSprite::@4/(byte) plex_show_idx#30 )
  (byte) plex_sprite_idx#15 ← phi( plexShowSprite::@1/(byte) plex_sprite_idx#27 plexShowSprite::@4/(byte) plex_sprite_idx#28 )
  (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#15 + (number) 1
  (number~) plexShowSprite::$6 ← (number~) plexShowSprite::$5 & (number) 7
  (byte) plex_sprite_idx#3 ← (number~) plexShowSprite::$6
  (byte) plex_show_idx#3 ← ++ (byte) plex_show_idx#15
  (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#16 << (number) 1
  (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
  (bool~) plexShowSprite::$8 ← ! (bool~) plexShowSprite::$7
  if((bool~) plexShowSprite::$8) goto plexShowSprite::@return
  to:plexShowSprite::@6
plexShowSprite::@6: scope:[plexShowSprite]  from plexShowSprite::@2
  (byte) plex_show_idx#31 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 )
  (byte) plex_sprite_idx#29 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 )
  (byte) plex_free_next#25 ← phi( plexShowSprite::@2/(byte) plex_free_next#24 )
  (byte) plex_sprite_msb#4 ← (number) 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@6
  (byte) plex_sprite_msb#17 ← phi( plexShowSprite::@2/(byte) plex_sprite_msb#3 plexShowSprite::@6/(byte) plex_sprite_msb#4 )
  (byte) plex_show_idx#16 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 plexShowSprite::@6/(byte) plex_show_idx#31 )
  (byte) plex_sprite_idx#16 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 plexShowSprite::@6/(byte) plex_sprite_idx#29 )
  (byte) plex_free_next#14 ← phi( plexShowSprite::@2/(byte) plex_free_next#24 plexShowSprite::@6/(byte) plex_free_next#25 )
  (byte) plex_free_next#3 ← (byte) plex_free_next#14
  (byte) plex_sprite_idx#4 ← (byte) plex_sprite_idx#16
  (byte) plex_show_idx#4 ← (byte) plex_show_idx#16
  (byte) plex_sprite_msb#5 ← (byte) plex_sprite_msb#17
  return 
  to:@return
@9: scope:[]  from @4
  (byte) plex_sprite_msb#49 ← phi( @4/(byte) plex_sprite_msb#0 )
  (byte) plex_sprite_idx#49 ← phi( @4/(byte) plex_sprite_idx#0 )
  (byte) plex_show_idx#50 ← phi( @4/(byte) plex_show_idx#0 )
  (byte*) PLEX_SCREEN_PTR#29 ← phi( @4/(byte*) PLEX_SCREEN_PTR#0 )
  (byte[8]) PLEX_FREE_YPOS ← { fill( 8, 0) }
  (byte) plex_free_next#4 ← (number) 0
  to:@12
@12: scope:[]  from @9
  (byte) plex_free_next#43 ← phi( @9/(byte) plex_free_next#4 )
  (byte) plex_sprite_msb#45 ← phi( @9/(byte) plex_sprite_msb#49 )
  (byte) plex_sprite_idx#45 ← phi( @9/(byte) plex_sprite_idx#49 )
  (byte) plex_show_idx#48 ← phi( @9/(byte) plex_show_idx#50 )
  (byte*) PLEX_SCREEN_PTR#28 ← phi( @9/(byte*) PLEX_SCREEN_PTR#29 )
  (byte*) SCREEN ← ((byte*)) (number) $400
  (byte*) SPRITE ← ((byte*)) (number) $2000
  kickasm(location (byte*) SPRITE) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  (byte[$100]) YSIN ← kickasm {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
  to:@14

(void()) main()
main: scope:[main]  from @16
  (bool) framedone#18 ← phi( @16/(bool) framedone#17 )
  (byte) plex_free_next#34 ← phi( @16/(byte) plex_free_next#31 )
  (byte) plex_sprite_msb#35 ← phi( @16/(byte) plex_sprite_msb#32 )
  (byte) plex_sprite_idx#36 ← phi( @16/(byte) plex_sprite_idx#34 )
  (byte) plex_show_idx#39 ← phi( @16/(byte) plex_show_idx#37 )
  (byte*) PLEX_SCREEN_PTR#17 ← phi( @16/(byte*) PLEX_SCREEN_PTR#21 )
  asm { sei  }
  call init 
  to:main::@1
main::@1: scope:[main]  from main
  (bool) framedone#14 ← phi( main/(bool) framedone#18 )
  (byte) plex_free_next#26 ← phi( main/(byte) plex_free_next#34 )
  (byte) plex_sprite_msb#27 ← phi( main/(byte) plex_sprite_msb#35 )
  (byte) plex_sprite_idx#30 ← phi( main/(byte) plex_sprite_idx#36 )
  (byte) plex_show_idx#32 ← phi( main/(byte) plex_show_idx#39 )
  (byte*) PLEX_SCREEN_PTR#10 ← phi( main/(byte*) PLEX_SCREEN_PTR#6 )
  (byte*) PLEX_SCREEN_PTR#3 ← (byte*) PLEX_SCREEN_PTR#10
  call loop 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte*) PLEX_SCREEN_PTR#18 ← phi( main::@1/(byte*) PLEX_SCREEN_PTR#3 )
  (bool) framedone#8 ← phi( main::@1/(bool) framedone#6 )
  (byte) plex_free_next#15 ← phi( main::@1/(byte) plex_free_next#10 )
  (byte) plex_sprite_msb#18 ← phi( main::@1/(byte) plex_sprite_msb#11 )
  (byte) plex_sprite_idx#17 ← phi( main::@1/(byte) plex_sprite_idx#10 )
  (byte) plex_show_idx#17 ← phi( main::@1/(byte) plex_show_idx#10 )
  (byte) plex_show_idx#5 ← (byte) plex_show_idx#17
  (byte) plex_sprite_idx#5 ← (byte) plex_sprite_idx#17
  (byte) plex_sprite_msb#6 ← (byte) plex_sprite_msb#18
  (byte) plex_free_next#5 ← (byte) plex_free_next#15
  (bool) framedone#0 ← (bool) framedone#8
  to:main::@return
main::@return: scope:[main]  from main::@2
  (bool) framedone#9 ← phi( main::@2/(bool) framedone#0 )
  (byte) plex_free_next#16 ← phi( main::@2/(byte) plex_free_next#5 )
  (byte) plex_sprite_msb#19 ← phi( main::@2/(byte) plex_sprite_msb#6 )
  (byte) plex_sprite_idx#18 ← phi( main::@2/(byte) plex_sprite_idx#5 )
  (byte) plex_show_idx#18 ← phi( main::@2/(byte) plex_show_idx#5 )
  (byte*) PLEX_SCREEN_PTR#11 ← phi( main::@2/(byte*) PLEX_SCREEN_PTR#18 )
  (byte*) PLEX_SCREEN_PTR#4 ← (byte*) PLEX_SCREEN_PTR#11
  (byte) plex_show_idx#6 ← (byte) plex_show_idx#18
  (byte) plex_sprite_idx#6 ← (byte) plex_sprite_idx#18
  (byte) plex_sprite_msb#7 ← (byte) plex_sprite_msb#19
  (byte) plex_free_next#6 ← (byte) plex_free_next#16
  (bool) framedone#1 ← (bool) framedone#9
  return 
  to:@return

(void()) init()
init: scope:[init]  from main
  (byte*) PLEX_SCREEN_PTR#19 ← phi( main/(byte*) PLEX_SCREEN_PTR#17 )
  (byte~) init::$0 ← (byte) VIC_DEN | (byte) VIC_RSEL
  (number~) init::$1 ← (byte~) init::$0 | (number) 3
  *((byte*) D011) ← (number~) init::$1
  (byte*) plexInit::screen#0 ← (byte*) SCREEN
  call plexInit 
  to:init::@5
init::@5: scope:[init]  from init
  (byte*) PLEX_SCREEN_PTR#12 ← phi( init/(byte*) PLEX_SCREEN_PTR#2 )
  (byte*) PLEX_SCREEN_PTR#5 ← (byte*) PLEX_SCREEN_PTR#12
  (word) init::xp#0 ← (number) $20
  (number~) init::$4 ← (byte) PLEX_COUNT - (number) 1
  (byte) init::sx#0 ← (byte) 0
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@5
  (byte*) PLEX_SCREEN_PTR#30 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#30 init::@5/(byte*) PLEX_SCREEN_PTR#5 )
  (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init::@5/(word) init::xp#0 )
  (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init::@5/(byte) init::sx#0 )
  (byte*~) init::$5 ← (byte*) SPRITE / (number) $40
  (byte~) init::$6 ← ((byte)) (byte*~) init::$5
  *((byte[PLEX_COUNT]) PLEX_PTR + (byte) init::sx#2) ← (byte~) init::$6
  (byte~) init::$9 ← (byte) init::sx#2 * (const byte) SIZEOF_WORD
  *((word[PLEX_COUNT]) PLEX_XPOS + (byte~) init::$9) ← (word) init::xp#2
  (word) init::xp#1 ← (word) init::xp#2 + (number) 9
  (byte) init::sx#1 ← (byte) init::sx#2 + rangenext(0,init::$4)
  (bool~) init::$7 ← (byte) init::sx#1 != rangelast(0,init::$4)
  if((bool~) init::$7) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  (byte*) PLEX_SCREEN_PTR#27 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#30 )
  *((byte*) SPRITES_ENABLE) ← (number) $ff
  (byte) init::ss#0 ← (byte) 0
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  (byte*) PLEX_SCREEN_PTR#24 ← phi( init::@2/(byte*) PLEX_SCREEN_PTR#27 init::@3/(byte*) PLEX_SCREEN_PTR#24 )
  (byte) init::ss#2 ← phi( init::@2/(byte) init::ss#0 init::@3/(byte) init::ss#1 )
  *((byte*) SPRITES_COLS + (byte) init::ss#2) ← (byte) GREEN
  (byte) init::ss#1 ← (byte) init::ss#2 + rangenext(0,7)
  (bool~) init::$8 ← (byte) init::ss#1 != rangelast(0,7)
  if((bool~) init::$8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  (byte*) PLEX_SCREEN_PTR#20 ← phi( init::@3/(byte*) PLEX_SCREEN_PTR#24 )
  asm { sei  }
  *((byte*) CIA1_INTERRUPT) ← (byte) CIA_INTERRUPT_CLEAR
  *((byte*) IRQ_ENABLE) ← (byte) IRQ_RASTER
  *((byte*) IRQ_STATUS) ← (byte) IRQ_RASTER
  (void()*~) init::$3 ← & interrupt(KERNEL_MIN)(void()) plex_irq()
  *((void()**) KERNEL_IRQ) ← (void()*~) init::$3
  asm { cli  }
  to:init::@return
init::@return: scope:[init]  from init::@4
  (byte*) PLEX_SCREEN_PTR#13 ← phi( init::@4/(byte*) PLEX_SCREEN_PTR#20 )
  (byte*) PLEX_SCREEN_PTR#6 ← (byte*) PLEX_SCREEN_PTR#13
  return 
  to:@return
@14: scope:[]  from @12
  (byte) plex_free_next#41 ← phi( @12/(byte) plex_free_next#43 )
  (byte) plex_sprite_msb#42 ← phi( @12/(byte) plex_sprite_msb#45 )
  (byte) plex_sprite_idx#43 ← phi( @12/(byte) plex_sprite_idx#45 )
  (byte) plex_show_idx#46 ← phi( @12/(byte) plex_show_idx#48 )
  (byte*) PLEX_SCREEN_PTR#25 ← phi( @12/(byte*) PLEX_SCREEN_PTR#28 )
  (bool) framedone#2 ← true
  to:@16

interrupt(KERNEL_MIN)(void()) plex_irq()
plex_irq: scope:[plex_irq]  from
  (bool) framedone#27 ← phi( @16/(bool) framedone#17 )
  (byte*) PLEX_SCREEN_PTR#31 ← phi( @16/(byte*) PLEX_SCREEN_PTR#21 )
  (byte) plex_sprite_msb#36 ← phi( @16/(byte) plex_sprite_msb#32 )
  (byte) plex_free_next#35 ← phi( @16/(byte) plex_free_next#31 )
  (byte) plex_show_idx#40 ← phi( @16/(byte) plex_show_idx#37 )
  (byte) plex_sprite_idx#37 ← phi( @16/(byte) plex_sprite_idx#34 )
  (byte) plex_irq::rasterY#0 ← (byte) 0
  *((byte*) BORDERCOL) ← (byte) WHITE
  to:plex_irq::@3
plex_irq::@3: scope:[plex_irq]  from plex_irq plex_irq::@7
  (bool) framedone#26 ← phi( plex_irq/(bool) framedone#27 plex_irq::@7/(bool) framedone#22 )
  (byte*) PLEX_SCREEN_PTR#26 ← phi( plex_irq/(byte*) PLEX_SCREEN_PTR#31 plex_irq::@7/(byte*) PLEX_SCREEN_PTR#32 )
  (byte) plex_sprite_msb#28 ← phi( plex_irq/(byte) plex_sprite_msb#36 plex_irq::@7/(byte) plex_sprite_msb#37 )
  (byte) plex_free_next#27 ← phi( plex_irq/(byte) plex_free_next#35 plex_irq::@7/(byte) plex_free_next#36 )
  (byte) plex_show_idx#27 ← phi( plex_irq/(byte) plex_show_idx#40 plex_irq::@7/(byte) plex_show_idx#20 )
  (byte) plex_sprite_idx#25 ← phi( plex_irq/(byte) plex_sprite_idx#37 plex_irq::@7/(byte) plex_sprite_idx#38 )
  call plexShowSprite 
  to:plex_irq::@8
plex_irq::@8: scope:[plex_irq]  from plex_irq::@3
  (bool) framedone#25 ← phi( plex_irq::@3/(bool) framedone#26 )
  (byte*) PLEX_SCREEN_PTR#35 ← phi( plex_irq::@3/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) plex_sprite_msb#20 ← phi( plex_irq::@3/(byte) plex_sprite_msb#5 )
  (byte) plex_show_idx#19 ← phi( plex_irq::@3/(byte) plex_show_idx#4 )
  (byte) plex_sprite_idx#19 ← phi( plex_irq::@3/(byte) plex_sprite_idx#4 )
  (byte) plex_free_next#17 ← phi( plex_irq::@3/(byte) plex_free_next#3 )
  (byte) plex_free_next#7 ← (byte) plex_free_next#17
  (byte) plex_sprite_idx#7 ← (byte) plex_sprite_idx#19
  (byte) plex_show_idx#7 ← (byte) plex_show_idx#19
  (byte) plex_sprite_msb#8 ← (byte) plex_sprite_msb#20
  to:plex_irq::plexFreeNextYpos1
plex_irq::plexFreeNextYpos1: scope:[plex_irq]  from plex_irq::@8
  (bool) framedone#24 ← phi( plex_irq::@8/(bool) framedone#25 )
  (byte*) PLEX_SCREEN_PTR#34 ← phi( plex_irq::@8/(byte*) PLEX_SCREEN_PTR#35 )
  (byte) plex_sprite_msb#50 ← phi( plex_irq::@8/(byte) plex_sprite_msb#8 )
  (byte) plex_sprite_idx#50 ← phi( plex_irq::@8/(byte) plex_sprite_idx#7 )
  (byte) plex_show_idx#41 ← phi( plex_irq::@8/(byte) plex_show_idx#7 )
  (byte) plex_free_next#18 ← phi( plex_irq::@8/(byte) plex_free_next#7 )
  (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((byte[8]) PLEX_FREE_YPOS + (byte) plex_free_next#18)
  to:plex_irq::plexFreeNextYpos1_@return
plex_irq::plexFreeNextYpos1_@return: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1
  (bool) framedone#23 ← phi( plex_irq::plexFreeNextYpos1/(bool) framedone#24 )
  (byte*) PLEX_SCREEN_PTR#33 ← phi( plex_irq::plexFreeNextYpos1/(byte*) PLEX_SCREEN_PTR#34 )
  (byte) plex_sprite_msb#46 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_sprite_msb#50 )
  (byte) plex_free_next#44 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_free_next#18 )
  (byte) plex_sprite_idx#46 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_sprite_idx#50 )
  (byte) plex_show_idx#33 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_show_idx#41 )
  (byte) plex_irq::plexFreeNextYpos1_return#2 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_irq::plexFreeNextYpos1_return#0 )
  (byte) plex_irq::plexFreeNextYpos1_return#1 ← (byte) plex_irq::plexFreeNextYpos1_return#2
  to:plex_irq::@7
plex_irq::@7: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1_@return
  (bool) framedone#22 ← phi( plex_irq::plexFreeNextYpos1_@return/(bool) framedone#23 )
  (byte*) PLEX_SCREEN_PTR#32 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte*) PLEX_SCREEN_PTR#33 )
  (byte) plex_sprite_msb#37 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_sprite_msb#46 )
  (byte) plex_free_next#36 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_free_next#44 )
  (byte) plex_sprite_idx#38 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_sprite_idx#46 )
  (byte) plex_show_idx#20 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_show_idx#33 )
  (byte) plex_irq::plexFreeNextYpos1_return#3 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_irq::plexFreeNextYpos1_return#1 )
  (byte~) plex_irq::$2 ← (byte) plex_irq::plexFreeNextYpos1_return#3
  (byte) plex_irq::rasterY#1 ← (byte~) plex_irq::$2
  (bool~) plex_irq::$3 ← (byte) plex_show_idx#20 < (byte) PLEX_COUNT
  (number~) plex_irq::$4 ← *((byte*) RASTER) + (number) 2
  (bool~) plex_irq::$5 ← (byte) plex_irq::rasterY#1 < (number~) plex_irq::$4
  (bool~) plex_irq::$6 ← (bool~) plex_irq::$3 && (bool~) plex_irq::$5
  if((bool~) plex_irq::$6) goto plex_irq::@3
  to:plex_irq::@4
plex_irq::@4: scope:[plex_irq]  from plex_irq::@7
  (bool) framedone#21 ← phi( plex_irq::@7/(bool) framedone#22 )
  (byte) plex_sprite_msb#47 ← phi( plex_irq::@7/(byte) plex_sprite_msb#37 )
  (byte) plex_sprite_idx#47 ← phi( plex_irq::@7/(byte) plex_sprite_idx#38 )
  (byte) plex_free_next#45 ← phi( plex_irq::@7/(byte) plex_free_next#36 )
  (byte) plex_irq::rasterY#3 ← phi( plex_irq::@7/(byte) plex_irq::rasterY#1 )
  (byte) plex_show_idx#21 ← phi( plex_irq::@7/(byte) plex_show_idx#20 )
  *((byte*) IRQ_STATUS) ← (byte) IRQ_RASTER
  (bool~) plex_irq::$0 ← (byte) plex_show_idx#21 < (byte) PLEX_COUNT
  if((bool~) plex_irq::$0) goto plex_irq::@1
  to:plex_irq::@5
plex_irq::@1: scope:[plex_irq]  from plex_irq::@4
  (bool) framedone#19 ← phi( plex_irq::@4/(bool) framedone#21 )
  (byte) plex_sprite_msb#38 ← phi( plex_irq::@4/(byte) plex_sprite_msb#47 )
  (byte) plex_show_idx#42 ← phi( plex_irq::@4/(byte) plex_show_idx#21 )
  (byte) plex_sprite_idx#39 ← phi( plex_irq::@4/(byte) plex_sprite_idx#47 )
  (byte) plex_free_next#37 ← phi( plex_irq::@4/(byte) plex_free_next#45 )
  (byte) plex_irq::rasterY#2 ← phi( plex_irq::@4/(byte) plex_irq::rasterY#3 )
  *((byte*) RASTER) ← (byte) plex_irq::rasterY#2
  to:plex_irq::@2
plex_irq::@5: scope:[plex_irq]  from plex_irq::@4
  (byte) plex_sprite_msb#39 ← phi( plex_irq::@4/(byte) plex_sprite_msb#47 )
  (byte) plex_show_idx#43 ← phi( plex_irq::@4/(byte) plex_show_idx#21 )
  (byte) plex_sprite_idx#40 ← phi( plex_irq::@4/(byte) plex_sprite_idx#47 )
  (byte) plex_free_next#38 ← phi( plex_irq::@4/(byte) plex_free_next#45 )
  (bool) framedone#3 ← true
  to:plex_irq::@2
plex_irq::@2: scope:[plex_irq]  from plex_irq::@1 plex_irq::@5
  (bool) framedone#15 ← phi( plex_irq::@1/(bool) framedone#19 plex_irq::@5/(bool) framedone#3 )
  (byte) plex_sprite_msb#29 ← phi( plex_irq::@1/(byte) plex_sprite_msb#38 plex_irq::@5/(byte) plex_sprite_msb#39 )
  (byte) plex_show_idx#34 ← phi( plex_irq::@1/(byte) plex_show_idx#42 plex_irq::@5/(byte) plex_show_idx#43 )
  (byte) plex_sprite_idx#31 ← phi( plex_irq::@1/(byte) plex_sprite_idx#39 plex_irq::@5/(byte) plex_sprite_idx#40 )
  (byte) plex_free_next#28 ← phi( plex_irq::@1/(byte) plex_free_next#37 plex_irq::@5/(byte) plex_free_next#38 )
  *((byte*) BORDERCOL) ← (number) 0
  to:plex_irq::@return
plex_irq::@return: scope:[plex_irq]  from plex_irq::@2
  (bool) framedone#10 ← phi( plex_irq::@2/(bool) framedone#15 )
  (byte) plex_sprite_msb#21 ← phi( plex_irq::@2/(byte) plex_sprite_msb#29 )
  (byte) plex_show_idx#22 ← phi( plex_irq::@2/(byte) plex_show_idx#34 )
  (byte) plex_sprite_idx#20 ← phi( plex_irq::@2/(byte) plex_sprite_idx#31 )
  (byte) plex_free_next#19 ← phi( plex_irq::@2/(byte) plex_free_next#28 )
  (byte) plex_free_next#8 ← (byte) plex_free_next#19
  (byte) plex_sprite_idx#8 ← (byte) plex_sprite_idx#20
  (byte) plex_show_idx#8 ← (byte) plex_show_idx#22
  (byte) plex_sprite_msb#9 ← (byte) plex_sprite_msb#21
  (bool) framedone#4 ← (bool) framedone#10
  return 
  to:@return

(void()) loop()
loop: scope:[loop]  from main::@1
  (byte) plex_free_next#39 ← phi( main::@1/(byte) plex_free_next#26 )
  (byte) plex_sprite_msb#40 ← phi( main::@1/(byte) plex_sprite_msb#27 )
  (byte) plex_sprite_idx#41 ← phi( main::@1/(byte) plex_sprite_idx#30 )
  (byte) plex_show_idx#44 ← phi( main::@1/(byte) plex_show_idx#32 )
  (bool) framedone#20 ← phi( main::@1/(bool) framedone#14 )
  (byte) loop::sin_idx#0 ← (number) 0
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@15
  (byte) loop::sin_idx#6 ← phi( loop/(byte) loop::sin_idx#0 loop::@15/(byte) loop::sin_idx#7 )
  (byte) plex_free_next#30 ← phi( loop/(byte) plex_free_next#39 loop::@15/(byte) plex_free_next#9 )
  (byte) plex_sprite_msb#31 ← phi( loop/(byte) plex_sprite_msb#40 loop::@15/(byte) plex_sprite_msb#10 )
  (byte) plex_sprite_idx#33 ← phi( loop/(byte) plex_sprite_idx#41 loop::@15/(byte) plex_sprite_idx#9 )
  (byte) plex_show_idx#36 ← phi( loop/(byte) plex_show_idx#44 loop::@15/(byte) plex_show_idx#9 )
  (bool) framedone#16 ← phi( loop/(bool) framedone#20 loop::@15/(bool) framedone#5 )
  if(true) goto loop::@4
  to:loop::@return
loop::@4: scope:[loop]  from loop::@1 loop::@4
  (byte) plex_free_next#47 ← phi( loop::@1/(byte) plex_free_next#30 loop::@4/(byte) plex_free_next#47 )
  (byte) plex_sprite_msb#51 ← phi( loop::@1/(byte) plex_sprite_msb#31 loop::@4/(byte) plex_sprite_msb#51 )
  (byte) plex_sprite_idx#51 ← phi( loop::@1/(byte) plex_sprite_idx#33 loop::@4/(byte) plex_sprite_idx#51 )
  (byte) plex_show_idx#51 ← phi( loop::@1/(byte) plex_show_idx#36 loop::@4/(byte) plex_show_idx#51 )
  (byte) loop::sin_idx#4 ← phi( loop::@1/(byte) loop::sin_idx#6 loop::@4/(byte) loop::sin_idx#4 )
  (bool) framedone#11 ← phi( loop::@1/(bool) framedone#16 loop::@4/(bool) framedone#11 )
  (bool~) loop::$0 ← ! (bool) framedone#11
  if((bool~) loop::$0) goto loop::@4
  to:loop::@6
loop::@6: scope:[loop]  from loop::@4
  (byte) plex_free_next#46 ← phi( loop::@4/(byte) plex_free_next#47 )
  (byte) plex_sprite_msb#48 ← phi( loop::@4/(byte) plex_sprite_msb#51 )
  (byte) plex_sprite_idx#48 ← phi( loop::@4/(byte) plex_sprite_idx#51 )
  (byte) plex_show_idx#49 ← phi( loop::@4/(byte) plex_show_idx#51 )
  (byte) loop::sin_idx#2 ← phi( loop::@4/(byte) loop::sin_idx#4 )
  *((byte*) BORDERCOL) ← (byte) RED
  (byte) loop::y_idx#0 ← (byte) loop::sin_idx#2
  (number~) loop::$1 ← (byte) PLEX_COUNT - (number) 1
  (byte) loop::sy#0 ← (byte) 0
  to:loop::@10
loop::@10: scope:[loop]  from loop::@10 loop::@6
  (byte) plex_free_next#40 ← phi( loop::@10/(byte) plex_free_next#40 loop::@6/(byte) plex_free_next#46 )
  (byte) plex_sprite_msb#41 ← phi( loop::@10/(byte) plex_sprite_msb#41 loop::@6/(byte) plex_sprite_msb#48 )
  (byte) plex_sprite_idx#42 ← phi( loop::@10/(byte) plex_sprite_idx#42 loop::@6/(byte) plex_sprite_idx#48 )
  (byte) plex_show_idx#45 ← phi( loop::@10/(byte) plex_show_idx#45 loop::@6/(byte) plex_show_idx#49 )
  (byte) loop::sin_idx#5 ← phi( loop::@10/(byte) loop::sin_idx#5 loop::@6/(byte) loop::sin_idx#2 )
  (byte) loop::sy#2 ← phi( loop::@10/(byte) loop::sy#1 loop::@6/(byte) loop::sy#0 )
  (byte) loop::y_idx#2 ← phi( loop::@10/(byte) loop::y_idx#1 loop::@6/(byte) loop::y_idx#0 )
  *((byte[PLEX_COUNT]) PLEX_YPOS + (byte) loop::sy#2) ← *((byte[$100]) YSIN + (byte) loop::y_idx#2)
  (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (number) 8
  (byte) loop::sy#1 ← (byte) loop::sy#2 + rangenext(0,loop::$1)
  (bool~) loop::$2 ← (byte) loop::sy#1 != rangelast(0,loop::$1)
  if((bool~) loop::$2) goto loop::@10
  to:loop::@11
loop::@11: scope:[loop]  from loop::@10
  (byte) plex_free_next#29 ← phi( loop::@10/(byte) plex_free_next#40 )
  (byte) plex_sprite_msb#30 ← phi( loop::@10/(byte) plex_sprite_msb#41 )
  (byte) plex_sprite_idx#32 ← phi( loop::@10/(byte) plex_sprite_idx#42 )
  (byte) plex_show_idx#35 ← phi( loop::@10/(byte) plex_show_idx#45 )
  (byte) loop::sin_idx#3 ← phi( loop::@10/(byte) loop::sin_idx#5 )
  (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#3 + (number) 1
  *((byte*) BORDERCOL) ← ++ *((byte*) BORDERCOL)
  call plexSort 
  to:loop::@15
loop::@15: scope:[loop]  from loop::@11
  (byte) loop::sin_idx#7 ← phi( loop::@11/(byte) loop::sin_idx#1 )
  (byte) plex_free_next#20 ← phi( loop::@11/(byte) plex_free_next#1 )
  (byte) plex_sprite_msb#22 ← phi( loop::@11/(byte) plex_sprite_msb#2 )
  (byte) plex_sprite_idx#21 ← phi( loop::@11/(byte) plex_sprite_idx#2 )
  (byte) plex_show_idx#23 ← phi( loop::@11/(byte) plex_show_idx#2 )
  (byte) plex_show_idx#9 ← (byte) plex_show_idx#23
  (byte) plex_sprite_idx#9 ← (byte) plex_sprite_idx#21
  (byte) plex_sprite_msb#10 ← (byte) plex_sprite_msb#22
  (byte) plex_free_next#9 ← (byte) plex_free_next#20
  *((byte*) BORDERCOL) ← (byte) GREEN
  (bool) framedone#5 ← false
  *((byte*) VIC_CONTROL) ← *((byte*) VIC_CONTROL) & (number) $7f
  *((byte*) RASTER) ← (number) 0
  to:loop::@1
loop::@return: scope:[loop]  from loop::@1
  (bool) framedone#12 ← phi( loop::@1/(bool) framedone#16 )
  (byte) plex_free_next#21 ← phi( loop::@1/(byte) plex_free_next#30 )
  (byte) plex_sprite_msb#23 ← phi( loop::@1/(byte) plex_sprite_msb#31 )
  (byte) plex_sprite_idx#22 ← phi( loop::@1/(byte) plex_sprite_idx#33 )
  (byte) plex_show_idx#24 ← phi( loop::@1/(byte) plex_show_idx#36 )
  (byte) plex_show_idx#10 ← (byte) plex_show_idx#24
  (byte) plex_sprite_idx#10 ← (byte) plex_sprite_idx#22
  (byte) plex_sprite_msb#11 ← (byte) plex_sprite_msb#23
  (byte) plex_free_next#10 ← (byte) plex_free_next#21
  (bool) framedone#6 ← (bool) framedone#12
  return 
  to:@return
@16: scope:[]  from @14
  (bool) framedone#17 ← phi( @14/(bool) framedone#2 )
  (byte) plex_free_next#31 ← phi( @14/(byte) plex_free_next#41 )
  (byte) plex_sprite_msb#32 ← phi( @14/(byte) plex_sprite_msb#42 )
  (byte) plex_sprite_idx#34 ← phi( @14/(byte) plex_sprite_idx#43 )
  (byte) plex_show_idx#37 ← phi( @14/(byte) plex_show_idx#46 )
  (byte*) PLEX_SCREEN_PTR#21 ← phi( @14/(byte*) PLEX_SCREEN_PTR#25 )
  call main 
  to:@17
@17: scope:[]  from @16
  (bool) framedone#13 ← phi( @16/(bool) framedone#1 )
  (byte) plex_free_next#22 ← phi( @16/(byte) plex_free_next#6 )
  (byte) plex_sprite_msb#24 ← phi( @16/(byte) plex_sprite_msb#7 )
  (byte) plex_sprite_idx#23 ← phi( @16/(byte) plex_sprite_idx#6 )
  (byte) plex_show_idx#25 ← phi( @16/(byte) plex_show_idx#6 )
  (byte*) PLEX_SCREEN_PTR#14 ← phi( @16/(byte*) PLEX_SCREEN_PTR#4 )
  (byte*) PLEX_SCREEN_PTR#7 ← (byte*) PLEX_SCREEN_PTR#14
  (byte) plex_show_idx#11 ← (byte) plex_show_idx#25
  (byte) plex_sprite_idx#11 ← (byte) plex_sprite_idx#23
  (byte) plex_sprite_msb#12 ← (byte) plex_sprite_msb#24
  (byte) plex_free_next#11 ← (byte) plex_free_next#22
  (bool) framedone#7 ← (bool) framedone#13
  to:@end
@end: scope:[]  from @17

SYMBOL TABLE SSA
(label) @12
(label) @14
(label) @16
(label) @17
(label) @4
(label) @9
(label) @begin
(label) @end
(byte*) BORDERCOL
(byte*) CIA1_INTERRUPT
(byte) CIA_INTERRUPT_CLEAR
(byte*) D011
(byte) GREEN
(byte*) IRQ_ENABLE
(byte) IRQ_RASTER
(byte*) IRQ_STATUS
(void()**) KERNEL_IRQ
(byte) PLEX_COUNT
(byte[8]) PLEX_FREE_YPOS
(byte[PLEX_COUNT]) PLEX_PTR
(byte*) PLEX_SCREEN_PTR
(byte*) PLEX_SCREEN_PTR#0
(byte*) PLEX_SCREEN_PTR#1
(byte*) PLEX_SCREEN_PTR#10
(byte*) PLEX_SCREEN_PTR#11
(byte*) PLEX_SCREEN_PTR#12
(byte*) PLEX_SCREEN_PTR#13
(byte*) PLEX_SCREEN_PTR#14
(byte*) PLEX_SCREEN_PTR#15
(byte*) PLEX_SCREEN_PTR#16
(byte*) PLEX_SCREEN_PTR#17
(byte*) PLEX_SCREEN_PTR#18
(byte*) PLEX_SCREEN_PTR#19
(byte*) PLEX_SCREEN_PTR#2
(byte*) PLEX_SCREEN_PTR#20
(byte*) PLEX_SCREEN_PTR#21
(byte*) PLEX_SCREEN_PTR#22
(byte*) PLEX_SCREEN_PTR#23
(byte*) PLEX_SCREEN_PTR#24
(byte*) PLEX_SCREEN_PTR#25
(byte*) PLEX_SCREEN_PTR#26
(byte*) PLEX_SCREEN_PTR#27
(byte*) PLEX_SCREEN_PTR#28
(byte*) PLEX_SCREEN_PTR#29
(byte*) PLEX_SCREEN_PTR#3
(byte*) PLEX_SCREEN_PTR#30
(byte*) PLEX_SCREEN_PTR#31
(byte*) PLEX_SCREEN_PTR#32
(byte*) PLEX_SCREEN_PTR#33
(byte*) PLEX_SCREEN_PTR#34
(byte*) PLEX_SCREEN_PTR#35
(byte*) PLEX_SCREEN_PTR#4
(byte*) PLEX_SCREEN_PTR#5
(byte*) PLEX_SCREEN_PTR#6
(byte*) PLEX_SCREEN_PTR#7
(byte*) PLEX_SCREEN_PTR#8
(byte*) PLEX_SCREEN_PTR#9
(byte[PLEX_COUNT]) PLEX_SORTED_IDX
(word[PLEX_COUNT]) PLEX_XPOS
(byte[PLEX_COUNT]) PLEX_YPOS
(byte*) RASTER
(byte) RED
(byte*) SCREEN
(const byte) SIZEOF_WORD = (byte) 2
(byte*) SPRITE
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_XMSB
(byte*) SPRITES_XPOS
(byte*) SPRITES_YPOS
(byte*) VIC_CONTROL
(byte) VIC_DEN
(byte) VIC_RSEL
(byte) WHITE
(byte[$100]) YSIN
(bool) framedone
(bool) framedone#0
(bool) framedone#1
(bool) framedone#10
(bool) framedone#11
(bool) framedone#12
(bool) framedone#13
(bool) framedone#14
(bool) framedone#15
(bool) framedone#16
(bool) framedone#17
(bool) framedone#18
(bool) framedone#19
(bool) framedone#2
(bool) framedone#20
(bool) framedone#21
(bool) framedone#22
(bool) framedone#23
(bool) framedone#24
(bool) framedone#25
(bool) framedone#26
(bool) framedone#27
(bool) framedone#3
(bool) framedone#4
(bool) framedone#5
(bool) framedone#6
(bool) framedone#7
(bool) framedone#8
(bool) framedone#9
(void()) init()
(byte~) init::$0
(number~) init::$1
(void()*~) init::$3
(number~) init::$4
(byte*~) init::$5
(byte~) init::$6
(bool~) init::$7
(bool~) init::$8
(byte~) init::$9
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@5
(label) init::@return
(byte) init::ss
(byte) init::ss#0
(byte) init::ss#1
(byte) init::ss#2
(byte) init::sx
(byte) init::sx#0
(byte) init::sx#1
(byte) init::sx#2
(word) init::xp
(word) init::xp#0
(word) init::xp#1
(word) init::xp#2
(void()) loop()
(bool~) loop::$0
(number~) loop::$1
(bool~) loop::$2
(label) loop::@1
(label) loop::@10
(label) loop::@11
(label) loop::@15
(label) loop::@4
(label) loop::@6
(label) loop::@return
(byte) loop::sin_idx
(byte) loop::sin_idx#0
(byte) loop::sin_idx#1
(byte) loop::sin_idx#2
(byte) loop::sin_idx#3
(byte) loop::sin_idx#4
(byte) loop::sin_idx#5
(byte) loop::sin_idx#6
(byte) loop::sin_idx#7
(byte) loop::sy
(byte) loop::sy#0
(byte) loop::sy#1
(byte) loop::sy#2
(byte) loop::y_idx
(byte) loop::y_idx#0
(byte) loop::y_idx#1
(byte) loop::y_idx#2
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(number~) plexInit::$1
(bool~) plexInit::$2
(label) plexInit::@1
(label) plexInit::@3
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#0
(byte) plexInit::i#1
(byte) plexInit::i#2
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::plexSetScreen1_screen#0
(byte*) plexInit::plexSetScreen1_screen#1
(byte*) plexInit::screen
(byte*) plexInit::screen#0
(byte*) plexInit::screen#1
(void()) plexShowSprite()
(number~) plexShowSprite::$0
(byte~) plexShowSprite::$10
(byte~) plexShowSprite::$11
(byte~) plexShowSprite::$2
(byte~) plexShowSprite::$3
(bool~) plexShowSprite::$4
(number~) plexShowSprite::$5
(number~) plexShowSprite::$6
(bool~) plexShowSprite::$7
(bool~) plexShowSprite::$8
(number~) plexShowSprite::$9
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@4
(label) plexShowSprite::@6
(label) plexShowSprite::@7
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(number~) plexShowSprite::plexFreeAdd1_$0
(number~) plexShowSprite::plexFreeAdd1_$1
(number~) plexShowSprite::plexFreeAdd1_$2
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0
(byte) plexShowSprite::plexFreeAdd1_ypos#1
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0
(byte) plexShowSprite::plex_sprite_idx2#1
(byte) plexShowSprite::plex_sprite_idx2#2
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0
(byte) plexShowSprite::ypos
(byte) plexShowSprite::ypos#0
(void()) plexSort()
(number~) plexSort::$1
(number~) plexSort::$2
(bool~) plexSort::$3
(bool~) plexSort::$4
(number~) plexSort::$5
(bool~) plexSort::$6
(bool~) plexSort::$7
(bool~) plexSort::$8
(bool~) plexSort::$9
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#0
(byte) plexSort::m#1
(byte) plexSort::m#2
(byte) plexSort::m#3
(byte) plexSort::m#4
(byte) plexSort::m#5
(byte) plexSort::m#6
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0
(byte) plexSort::nxt_idx#1
(byte) plexSort::nxt_idx#2
(byte) plexSort::nxt_idx#3
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0
(byte) plexSort::nxt_y#1
(byte) plexSort::nxt_y#2
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(label) plexSort::plexFreePrepare1_@1
(label) plexSort::plexFreePrepare1_@2
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#0
(byte) plexSort::plexFreePrepare1_s#1
(byte) plexSort::plexFreePrepare1_s#2
(byte) plexSort::s
(byte) plexSort::s#0
(byte) plexSort::s#1
(byte) plexSort::s#2
(byte) plexSort::s#3
(byte) plexSort::s#4
(byte) plex_free_next
(byte) plex_free_next#0
(byte) plex_free_next#1
(byte) plex_free_next#10
(byte) plex_free_next#11
(byte) plex_free_next#12
(byte) plex_free_next#13
(byte) plex_free_next#14
(byte) plex_free_next#15
(byte) plex_free_next#16
(byte) plex_free_next#17
(byte) plex_free_next#18
(byte) plex_free_next#19
(byte) plex_free_next#2
(byte) plex_free_next#20
(byte) plex_free_next#21
(byte) plex_free_next#22
(byte) plex_free_next#23
(byte) plex_free_next#24
(byte) plex_free_next#25
(byte) plex_free_next#26
(byte) plex_free_next#27
(byte) plex_free_next#28
(byte) plex_free_next#29
(byte) plex_free_next#3
(byte) plex_free_next#30
(byte) plex_free_next#31
(byte) plex_free_next#32
(byte) plex_free_next#33
(byte) plex_free_next#34
(byte) plex_free_next#35
(byte) plex_free_next#36
(byte) plex_free_next#37
(byte) plex_free_next#38
(byte) plex_free_next#39
(byte) plex_free_next#4
(byte) plex_free_next#40
(byte) plex_free_next#41
(byte) plex_free_next#42
(byte) plex_free_next#43
(byte) plex_free_next#44
(byte) plex_free_next#45
(byte) plex_free_next#46
(byte) plex_free_next#47
(byte) plex_free_next#5
(byte) plex_free_next#6
(byte) plex_free_next#7
(byte) plex_free_next#8
(byte) plex_free_next#9
interrupt(KERNEL_MIN)(void()) plex_irq()
(bool~) plex_irq::$0
(byte~) plex_irq::$2
(bool~) plex_irq::$3
(number~) plex_irq::$4
(bool~) plex_irq::$5
(bool~) plex_irq::$6
(label) plex_irq::@1
(label) plex_irq::@2
(label) plex_irq::@3
(label) plex_irq::@4
(label) plex_irq::@5
(label) plex_irq::@7
(label) plex_irq::@8
(label) plex_irq::@return
(label) plex_irq::plexFreeNextYpos1
(label) plex_irq::plexFreeNextYpos1_@return
(byte) plex_irq::plexFreeNextYpos1_return
(byte) plex_irq::plexFreeNextYpos1_return#0
(byte) plex_irq::plexFreeNextYpos1_return#1
(byte) plex_irq::plexFreeNextYpos1_return#2
(byte) plex_irq::plexFreeNextYpos1_return#3
(byte) plex_irq::rasterY
(byte) plex_irq::rasterY#0
(byte) plex_irq::rasterY#1
(byte) plex_irq::rasterY#2
(byte) plex_irq::rasterY#3
(byte) plex_show_idx
(byte) plex_show_idx#0
(byte) plex_show_idx#1
(byte) plex_show_idx#10
(byte) plex_show_idx#11
(byte) plex_show_idx#12
(byte) plex_show_idx#13
(byte) plex_show_idx#14
(byte) plex_show_idx#15
(byte) plex_show_idx#16
(byte) plex_show_idx#17
(byte) plex_show_idx#18
(byte) plex_show_idx#19
(byte) plex_show_idx#2
(byte) plex_show_idx#20
(byte) plex_show_idx#21
(byte) plex_show_idx#22
(byte) plex_show_idx#23
(byte) plex_show_idx#24
(byte) plex_show_idx#25
(byte) plex_show_idx#26
(byte) plex_show_idx#27
(byte) plex_show_idx#28
(byte) plex_show_idx#29
(byte) plex_show_idx#3
(byte) plex_show_idx#30
(byte) plex_show_idx#31
(byte) plex_show_idx#32
(byte) plex_show_idx#33
(byte) plex_show_idx#34
(byte) plex_show_idx#35
(byte) plex_show_idx#36
(byte) plex_show_idx#37
(byte) plex_show_idx#38
(byte) plex_show_idx#39
(byte) plex_show_idx#4
(byte) plex_show_idx#40
(byte) plex_show_idx#41
(byte) plex_show_idx#42
(byte) plex_show_idx#43
(byte) plex_show_idx#44
(byte) plex_show_idx#45
(byte) plex_show_idx#46
(byte) plex_show_idx#47
(byte) plex_show_idx#48
(byte) plex_show_idx#49
(byte) plex_show_idx#5
(byte) plex_show_idx#50
(byte) plex_show_idx#51
(byte) plex_show_idx#6
(byte) plex_show_idx#7
(byte) plex_show_idx#8
(byte) plex_show_idx#9
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0
(byte) plex_sprite_idx#1
(byte) plex_sprite_idx#10
(byte) plex_sprite_idx#11
(byte) plex_sprite_idx#12
(byte) plex_sprite_idx#13
(byte) plex_sprite_idx#14
(byte) plex_sprite_idx#15
(byte) plex_sprite_idx#16
(byte) plex_sprite_idx#17
(byte) plex_sprite_idx#18
(byte) plex_sprite_idx#19
(byte) plex_sprite_idx#2
(byte) plex_sprite_idx#20
(byte) plex_sprite_idx#21
(byte) plex_sprite_idx#22
(byte) plex_sprite_idx#23
(byte) plex_sprite_idx#24
(byte) plex_sprite_idx#25
(byte) plex_sprite_idx#26
(byte) plex_sprite_idx#27
(byte) plex_sprite_idx#28
(byte) plex_sprite_idx#29
(byte) plex_sprite_idx#3
(byte) plex_sprite_idx#30
(byte) plex_sprite_idx#31
(byte) plex_sprite_idx#32
(byte) plex_sprite_idx#33
(byte) plex_sprite_idx#34
(byte) plex_sprite_idx#35
(byte) plex_sprite_idx#36
(byte) plex_sprite_idx#37
(byte) plex_sprite_idx#38
(byte) plex_sprite_idx#39
(byte) plex_sprite_idx#4
(byte) plex_sprite_idx#40
(byte) plex_sprite_idx#41
(byte) plex_sprite_idx#42
(byte) plex_sprite_idx#43
(byte) plex_sprite_idx#44
(byte) plex_sprite_idx#45
(byte) plex_sprite_idx#46
(byte) plex_sprite_idx#47
(byte) plex_sprite_idx#48
(byte) plex_sprite_idx#49
(byte) plex_sprite_idx#5
(byte) plex_sprite_idx#50
(byte) plex_sprite_idx#51
(byte) plex_sprite_idx#6
(byte) plex_sprite_idx#7
(byte) plex_sprite_idx#8
(byte) plex_sprite_idx#9
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0
(byte) plex_sprite_msb#1
(byte) plex_sprite_msb#10
(byte) plex_sprite_msb#11
(byte) plex_sprite_msb#12
(byte) plex_sprite_msb#13
(byte) plex_sprite_msb#14
(byte) plex_sprite_msb#15
(byte) plex_sprite_msb#16
(byte) plex_sprite_msb#17
(byte) plex_sprite_msb#18
(byte) plex_sprite_msb#19
(byte) plex_sprite_msb#2
(byte) plex_sprite_msb#20
(byte) plex_sprite_msb#21
(byte) plex_sprite_msb#22
(byte) plex_sprite_msb#23
(byte) plex_sprite_msb#24
(byte) plex_sprite_msb#25
(byte) plex_sprite_msb#26
(byte) plex_sprite_msb#27
(byte) plex_sprite_msb#28
(byte) plex_sprite_msb#29
(byte) plex_sprite_msb#3
(byte) plex_sprite_msb#30
(byte) plex_sprite_msb#31
(byte) plex_sprite_msb#32
(byte) plex_sprite_msb#33
(byte) plex_sprite_msb#34
(byte) plex_sprite_msb#35
(byte) plex_sprite_msb#36
(byte) plex_sprite_msb#37
(byte) plex_sprite_msb#38
(byte) plex_sprite_msb#39
(byte) plex_sprite_msb#4
(byte) plex_sprite_msb#40
(byte) plex_sprite_msb#41
(byte) plex_sprite_msb#42
(byte) plex_sprite_msb#43
(byte) plex_sprite_msb#44
(byte) plex_sprite_msb#45
(byte) plex_sprite_msb#46
(byte) plex_sprite_msb#47
(byte) plex_sprite_msb#48
(byte) plex_sprite_msb#49
(byte) plex_sprite_msb#5
(byte) plex_sprite_msb#50
(byte) plex_sprite_msb#51
(byte) plex_sprite_msb#6
(byte) plex_sprite_msb#7
(byte) plex_sprite_msb#8
(byte) plex_sprite_msb#9

Adding number conversion cast (unumber) $10 in (byte) VIC_DEN ← (number) $10
Adding number conversion cast (unumber) 8 in (byte) VIC_RSEL ← (number) 8
Adding number conversion cast (unumber) 1 in (byte) IRQ_RASTER ← (number) 1
Adding number conversion cast (unumber) $7f in (byte) CIA_INTERRUPT_CLEAR ← (number) $7f
Adding number conversion cast (unumber) 1 in (byte) WHITE ← (number) 1
Adding number conversion cast (unumber) 2 in (byte) RED ← (number) 2
Adding number conversion cast (unumber) 5 in (byte) GREEN ← (number) 5
Adding number conversion cast (unumber) $20 in (byte) PLEX_COUNT ← (number) $20
Adding number conversion cast (unumber) 0 in (byte) plex_show_idx#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_sprite_idx#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#0 ← (number) 1
Adding number conversion cast (unumber) $3f8 in (byte*~) plexInit::plexSetScreen1_$0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
Adding number conversion cast (unumber) 1 in (number~) plexInit::$1 ← (byte) PLEX_COUNT - (number) 1
Adding number conversion cast (unumber) plexInit::$1 in (number~) plexInit::$1 ← (byte) PLEX_COUNT - (unumber)(number) 1
Adding number conversion cast (unumber) 2 in (number~) plexSort::$1 ← (byte) PLEX_COUNT - (number) 2
Adding number conversion cast (unumber) plexSort::$1 in (number~) plexSort::$1 ← (byte) PLEX_COUNT - (unumber)(number) 2
Adding number conversion cast (unumber) 1 in (number~) plexSort::$2 ← (byte) plexSort::m#2 + (number) 1
Adding number conversion cast (unumber) plexSort::$2 in (number~) plexSort::$2 ← (byte) plexSort::m#2 + (unumber)(number) 1
Adding number conversion cast (unumber) 1 in (number~) plexSort::$5 ← (byte) plexSort::s#3 + (number) 1
Adding number conversion cast (unumber) plexSort::$5 in (number~) plexSort::$5 ← (byte) plexSort::s#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $ff in (bool~) plexSort::$6 ← (byte) plexSort::s#1 != (number) $ff
Adding number conversion cast (unumber) 0 in (byte) plex_show_idx#1 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_sprite_idx#1 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#1 ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_free_next#0 ← (number) 0
Adding number conversion cast (unumber) 2 in (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#13 * (number) 2
Adding number conversion cast (unumber) plexShowSprite::$0 in (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#13 * (unumber)(number) 2
Adding number conversion cast (unumber) $15 in (number~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$0 in (number~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (unumber)(number) $15
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#13 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$1 in (number~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#13 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::plexFreeAdd1_$2 ← (unumber~) plexShowSprite::plexFreeAdd1_$1 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$2 in (number~) plexShowSprite::plexFreeAdd1_$2 ← (unumber~) plexShowSprite::plexFreeAdd1_$1 & (unumber)(number) 7
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
Adding number conversion cast (unumber) $ff in (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#15
Adding number conversion cast (unumber) plexShowSprite::$9 in (number~) plexShowSprite::$9 ← (unumber)(number) $ff ^ (byte) plex_sprite_msb#15
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#15 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::$5 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#15 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::$6 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (unumber)(number) 7
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#16 << (number) 1
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#4 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) plex_free_next#4 ← (number) 0
Adding number conversion cast (unumber) 3 in (number~) init::$1 ← (byte~) init::$0 | (number) 3
Adding number conversion cast (unumber) init::$1 in (number~) init::$1 ← (byte~) init::$0 | (unumber)(number) 3
Adding number conversion cast (unumber) $20 in (word) init::xp#0 ← (number) $20
Adding number conversion cast (unumber) 1 in (number~) init::$4 ← (byte) PLEX_COUNT - (number) 1
Adding number conversion cast (unumber) init::$4 in (number~) init::$4 ← (byte) PLEX_COUNT - (unumber)(number) 1
Adding number conversion cast (unumber) $40 in (byte*~) init::$5 ← (byte*) SPRITE / (number) $40
Adding number conversion cast (unumber) 9 in (word) init::xp#1 ← (word) init::xp#2 + (number) 9
Adding number conversion cast (unumber) $ff in *((byte*) SPRITES_ENABLE) ← (number) $ff
Adding number conversion cast (unumber) 2 in (number~) plex_irq::$4 ← *((byte*) RASTER) + (number) 2
Adding number conversion cast (unumber) plex_irq::$4 in (number~) plex_irq::$4 ← *((byte*) RASTER) + (unumber)(number) 2
Adding number conversion cast (unumber) 0 in *((byte*) BORDERCOL) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) loop::sin_idx#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (number~) loop::$1 ← (byte) PLEX_COUNT - (number) 1
Adding number conversion cast (unumber) loop::$1 in (number~) loop::$1 ← (byte) PLEX_COUNT - (unumber)(number) 1
Adding number conversion cast (unumber) 8 in (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (number) 8
Adding number conversion cast (unumber) 1 in (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#3 + (number) 1
Adding number conversion cast (unumber) $7f in *((byte*) VIC_CONTROL) ← *((byte*) VIC_CONTROL) & (number) $7f
Adding number conversion cast (unumber) 0 in *((byte*) RASTER) ← (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) SPRITES_XPOS ← (byte*)(number) $d000
Inlining cast (byte*) SPRITES_YPOS ← (byte*)(number) $d001
Inlining cast (byte*) SPRITES_XMSB ← (byte*)(number) $d010
Inlining cast (byte*) RASTER ← (byte*)(number) $d012
Inlining cast (byte*) SPRITES_ENABLE ← (byte*)(number) $d015
Inlining cast (byte*) BORDERCOL ← (byte*)(number) $d020
Inlining cast (byte*) SPRITES_COLS ← (byte*)(number) $d027
Inlining cast (byte*) VIC_CONTROL ← (byte*)(number) $d011
Inlining cast (byte*) D011 ← (byte*)(number) $d011
Inlining cast (byte) VIC_DEN ← (unumber)(number) $10
Inlining cast (byte) VIC_RSEL ← (unumber)(number) 8
Inlining cast (byte*) IRQ_STATUS ← (byte*)(number) $d019
Inlining cast (byte*) IRQ_ENABLE ← (byte*)(number) $d01a
Inlining cast (byte) IRQ_RASTER ← (unumber)(number) 1
Inlining cast (byte*) CIA1_INTERRUPT ← (byte*)(number) $dc0d
Inlining cast (byte) CIA_INTERRUPT_CLEAR ← (unumber)(number) $7f
Inlining cast (void()**) KERNEL_IRQ ← (void()**)(number) $314
Inlining cast (byte) WHITE ← (unumber)(number) 1
Inlining cast (byte) RED ← (unumber)(number) 2
Inlining cast (byte) GREEN ← (unumber)(number) 5
Inlining cast (byte) PLEX_COUNT ← (unumber)(number) $20
Inlining cast (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(number) $400+(number) $3f8
Inlining cast (byte) plex_show_idx#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_idx#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#0 ← (unumber)(number) 1
Inlining cast (byte) plex_show_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#1 ← (unumber)(number) 1
Inlining cast *((byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (unumber)(number) 0
Inlining cast (byte) plex_free_next#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#4 ← (unumber)(number) 1
Inlining cast (byte) plex_free_next#4 ← (unumber)(number) 0
Inlining cast (byte*) SCREEN ← (byte*)(number) $400
Inlining cast (byte*) SPRITE ← (byte*)(number) $2000
Inlining cast (word) init::xp#0 ← (unumber)(number) $20
Inlining cast (byte~) init::$6 ← (byte)(byte*~) init::$5
Inlining cast *((byte*) SPRITES_ENABLE) ← (unumber)(number) $ff
Inlining cast *((byte*) BORDERCOL) ← (unumber)(number) 0
Inlining cast (byte) loop::sin_idx#0 ← (unumber)(number) 0
Inlining cast *((byte*) RASTER) ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 53249
Simplifying constant pointer cast (byte*) 53264
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (byte*) 53265
Simplifying constant integer cast $10
Simplifying constant integer cast 8
Simplifying constant pointer cast (byte*) 53273
Simplifying constant pointer cast (byte*) 53274
Simplifying constant integer cast 1
Simplifying constant pointer cast (byte*) 56333
Simplifying constant integer cast $7f
Simplifying constant pointer cast (void()**) 788
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 5
Simplifying constant integer cast $20
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast $3f8
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $15
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 8192
Simplifying constant integer cast 3
Simplifying constant integer cast $20
Simplifying constant integer cast 1
Simplifying constant integer cast $40
Simplifying constant integer cast 9
Simplifying constant integer cast $ff
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Simplifying constant integer cast 1
Simplifying constant integer cast $7f
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $3f8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) plexInit::$1 ← (byte) PLEX_COUNT - (byte) 1
Inferred type updated to byte in (unumber~) plexSort::$1 ← (byte) PLEX_COUNT - (byte) 2
Inferred type updated to byte in (unumber~) plexSort::$2 ← (byte) plexSort::m#2 + (byte) 1
Inferred type updated to byte in (unumber~) plexSort::$5 ← (byte) plexSort::s#3 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::$0 ← (byte) plex_sprite_idx#13 * (byte) 2
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (byte) $15
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#13 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$2 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7
Inferred type updated to byte in (unumber~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#15
Inferred type updated to byte in (unumber~) plexShowSprite::$5 ← (byte) plex_sprite_idx#15 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7
Inferred type updated to byte in (unumber~) init::$1 ← (byte~) init::$0 | (byte) 3
Inferred type updated to byte in (unumber~) init::$4 ← (byte) PLEX_COUNT - (byte) 1
Inferred type updated to byte in (unumber~) plex_irq::$4 ← *((byte*) RASTER) + (byte) 2
Inferred type updated to byte in (unumber~) loop::$1 ← (byte) PLEX_COUNT - (byte) 1
Inversing boolean not [52] (bool~) plexSort::$4 ← (byte) plexSort::nxt_y#0 >= *((byte[PLEX_COUNT]) PLEX_YPOS + *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2)) from [51] (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT]) PLEX_YPOS + *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2))
Inversing boolean not [123] (bool~) plexShowSprite::$8 ← (byte) plex_sprite_msb#3 != (byte) 0 from [122] (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 (byte) plex_free_next#42 (byte) plex_free_next#32 (byte) plex_free_next#33 
Alias candidate removed (volatile)(byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#3 (byte~) plexShowSprite::$6 
Alias (byte*) plexInit::plexSetScreen1_screen#0 = (byte*) plexInit::screen#1 (byte*) plexInit::plexSetScreen1_screen#1 
Alias (byte*) PLEX_SCREEN_PTR#1 = (byte*~) plexInit::plexSetScreen1_$0 (byte*) PLEX_SCREEN_PTR#22 
Alias (byte*) PLEX_SCREEN_PTR#15 = (byte*) PLEX_SCREEN_PTR#8 (byte*) PLEX_SCREEN_PTR#2 
Alias (byte) plexSort::m#2 = (byte) plexSort::m#4 (byte) plexSort::s#0 
Alias (byte) plexSort::nxt_y#0 = (byte) plexSort::nxt_y#2 
Alias (byte) plexSort::nxt_idx#0 = (byte) plexSort::nxt_idx#3 
Alias (byte) plexSort::s#1 = (byte) plexSort::s#4 
Alias (byte) plexSort::nxt_idx#1 = (byte) plexSort::nxt_idx#2 
Alias (byte) plexSort::m#5 = (byte) plexSort::m#6 
Alias (byte) plex_show_idx#1 = (byte) plex_show_idx#47 
Alias (byte) plex_sprite_idx#1 = (byte) plex_sprite_idx#44 
Alias (byte) plex_sprite_msb#1 = (byte) plex_sprite_msb#43 
Alias (byte) plex_show_idx#12 = (byte) plex_show_idx#26 (byte) plex_show_idx#38 (byte) plex_show_idx#2 
Alias (byte) plex_sprite_idx#12 = (byte) plex_sprite_idx#24 (byte) plex_sprite_idx#35 (byte) plex_sprite_idx#2 
Alias (byte) plex_sprite_msb#13 = (byte) plex_sprite_msb#25 (byte) plex_sprite_msb#33 (byte) plex_sprite_msb#2 
Alias (byte) plex_free_next#0 = (byte) plex_free_next#12 (byte) plex_free_next#1 
Alias (byte) plexShowSprite::plex_sprite_idx2#0 = (byte~) plexShowSprite::$0 (byte) plexShowSprite::plex_sprite_idx2#2 (byte) plexShowSprite::plex_sprite_idx2#1 
Alias (byte) plexShowSprite::plexFreeAdd1_ypos#0 = (byte) plexShowSprite::ypos#0 (byte) plexShowSprite::plexFreeAdd1_ypos#1 
Alias (byte) plex_free_next#13 = (byte) plex_free_next#23 
Alias (byte) plex_show_idx#13 = (byte) plex_show_idx#28 (byte) plex_show_idx#14 (byte) plex_show_idx#29 (byte) plex_show_idx#30 
Alias (byte*) PLEX_SCREEN_PTR#16 = (byte*) PLEX_SCREEN_PTR#23 (byte*) PLEX_SCREEN_PTR#9 
Alias (byte) plex_sprite_idx#13 = (byte) plex_sprite_idx#26 (byte) plex_sprite_idx#14 (byte) plex_sprite_idx#27 (byte) plex_sprite_idx#28 
Alias (byte) plex_sprite_msb#14 = (byte) plex_sprite_msb#34 (byte) plex_sprite_msb#44 (byte) plex_sprite_msb#26 (byte) plex_sprite_msb#15 
Alias (byte) plex_free_next#24 = (byte) plex_free_next#25 
Alias (byte) plex_show_idx#3 = (byte) plex_show_idx#31 
Alias (byte) plex_free_next#14 = (byte) plex_free_next#3 
Alias (byte) plex_sprite_idx#16 = (byte) plex_sprite_idx#4 
Alias (byte) plex_show_idx#16 = (byte) plex_show_idx#4 
Alias (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#5 
Alias (byte*) PLEX_SCREEN_PTR#0 = (byte*) PLEX_SCREEN_PTR#29 (byte*) PLEX_SCREEN_PTR#28 (byte*) PLEX_SCREEN_PTR#25 (byte*) PLEX_SCREEN_PTR#21 
Alias (byte) plex_show_idx#0 = (byte) plex_show_idx#50 (byte) plex_show_idx#48 (byte) plex_show_idx#46 (byte) plex_show_idx#37 
Alias (byte) plex_sprite_idx#0 = (byte) plex_sprite_idx#49 (byte) plex_sprite_idx#45 (byte) plex_sprite_idx#43 (byte) plex_sprite_idx#34 
Alias (byte) plex_sprite_msb#0 = (byte) plex_sprite_msb#49 (byte) plex_sprite_msb#45 (byte) plex_sprite_msb#42 (byte) plex_sprite_msb#32 
Alias (byte) plex_free_next#31 = (byte) plex_free_next#43 (byte) plex_free_next#4 (byte) plex_free_next#41 
Alias (byte) plex_show_idx#32 = (byte) plex_show_idx#39 
Alias (byte) plex_sprite_idx#30 = (byte) plex_sprite_idx#36 
Alias (byte) plex_sprite_msb#27 = (byte) plex_sprite_msb#35 
Alias (byte) plex_free_next#26 = (byte) plex_free_next#34 
Alias (bool) framedone#14 = (bool) framedone#18 
Alias (byte*) PLEX_SCREEN_PTR#10 = (byte*) PLEX_SCREEN_PTR#3 (byte*) PLEX_SCREEN_PTR#18 (byte*) PLEX_SCREEN_PTR#11 (byte*) PLEX_SCREEN_PTR#4 
Alias (byte) plex_show_idx#17 = (byte) plex_show_idx#5 (byte) plex_show_idx#18 (byte) plex_show_idx#6 
Alias (byte) plex_sprite_idx#17 = (byte) plex_sprite_idx#5 (byte) plex_sprite_idx#18 (byte) plex_sprite_idx#6 
Alias (byte) plex_sprite_msb#18 = (byte) plex_sprite_msb#6 (byte) plex_sprite_msb#19 (byte) plex_sprite_msb#7 
Alias (byte) plex_free_next#15 = (byte) plex_free_next#5 (byte) plex_free_next#16 (byte) plex_free_next#6 
Alias (bool) framedone#0 = (bool) framedone#8 (bool) framedone#9 (bool) framedone#1 
Alias (byte*) PLEX_SCREEN_PTR#12 = (byte*) PLEX_SCREEN_PTR#5 
Alias (byte*) PLEX_SCREEN_PTR#27 = (byte*) PLEX_SCREEN_PTR#30 
Alias (byte*) PLEX_SCREEN_PTR#13 = (byte*) PLEX_SCREEN_PTR#20 (byte*) PLEX_SCREEN_PTR#24 (byte*) PLEX_SCREEN_PTR#6 
Alias (byte*) PLEX_SCREEN_PTR#26 = (byte*) PLEX_SCREEN_PTR#35 (byte*) PLEX_SCREEN_PTR#34 (byte*) PLEX_SCREEN_PTR#33 (byte*) PLEX_SCREEN_PTR#32 
Alias (bool) framedone#19 = (bool) framedone#25 (bool) framedone#26 (bool) framedone#24 (bool) framedone#23 (bool) framedone#22 (bool) framedone#21 
Alias (byte) plex_free_next#17 = (byte) plex_free_next#7 (byte) plex_free_next#18 (byte) plex_free_next#44 (byte) plex_free_next#36 (byte) plex_free_next#45 (byte) plex_free_next#37 (byte) plex_free_next#38 
Alias (byte) plex_sprite_idx#19 = (byte) plex_sprite_idx#7 (byte) plex_sprite_idx#50 (byte) plex_sprite_idx#46 (byte) plex_sprite_idx#38 (byte) plex_sprite_idx#47 (byte) plex_sprite_idx#39 (byte) plex_sprite_idx#40 
Alias (byte) plex_show_idx#19 = (byte) plex_show_idx#7 (byte) plex_show_idx#41 (byte) plex_show_idx#33 (byte) plex_show_idx#20 (byte) plex_show_idx#21 (byte) plex_show_idx#42 (byte) plex_show_idx#43 
Alias (byte) plex_sprite_msb#20 = (byte) plex_sprite_msb#8 (byte) plex_sprite_msb#50 (byte) plex_sprite_msb#46 (byte) plex_sprite_msb#37 (byte) plex_sprite_msb#47 (byte) plex_sprite_msb#38 (byte) plex_sprite_msb#39 
Alias (byte) plex_irq::plexFreeNextYpos1_return#0 = (byte) plex_irq::plexFreeNextYpos1_return#2 (byte) plex_irq::plexFreeNextYpos1_return#1 (byte) plex_irq::plexFreeNextYpos1_return#3 (byte~) plex_irq::$2 (byte) plex_irq::rasterY#1 (byte) plex_irq::rasterY#3 (byte) plex_irq::rasterY#2 
Alias (byte) plex_free_next#19 = (byte) plex_free_next#28 (byte) plex_free_next#8 
Alias (byte) plex_sprite_idx#20 = (byte) plex_sprite_idx#31 (byte) plex_sprite_idx#8 
Alias (byte) plex_show_idx#22 = (byte) plex_show_idx#34 (byte) plex_show_idx#8 
Alias (byte) plex_sprite_msb#21 = (byte) plex_sprite_msb#29 (byte) plex_sprite_msb#9 
Alias (bool) framedone#10 = (bool) framedone#15 (bool) framedone#4 
Alias (byte) loop::sin_idx#2 = (byte) loop::sin_idx#4 (byte) loop::y_idx#0 
Alias (byte) plex_show_idx#49 = (byte) plex_show_idx#51 
Alias (byte) plex_sprite_idx#48 = (byte) plex_sprite_idx#51 
Alias (byte) plex_sprite_msb#48 = (byte) plex_sprite_msb#51 
Alias (byte) plex_free_next#46 = (byte) plex_free_next#47 
Alias (byte) loop::sin_idx#3 = (byte) loop::sin_idx#5 
Alias (byte) plex_show_idx#35 = (byte) plex_show_idx#45 
Alias (byte) plex_sprite_idx#32 = (byte) plex_sprite_idx#42 
Alias (byte) plex_sprite_msb#30 = (byte) plex_sprite_msb#41 
Alias (byte) plex_free_next#29 = (byte) plex_free_next#40 
Alias (byte) loop::sin_idx#1 = (byte) loop::sin_idx#7 
Alias (byte) plex_show_idx#23 = (byte) plex_show_idx#9 
Alias (byte) plex_sprite_idx#21 = (byte) plex_sprite_idx#9 
Alias (byte) plex_sprite_msb#10 = (byte) plex_sprite_msb#22 
Alias (byte) plex_free_next#20 = (byte) plex_free_next#9 
Alias (byte) plex_show_idx#10 = (byte) plex_show_idx#24 (byte) plex_show_idx#36 
Alias (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#22 (byte) plex_sprite_idx#33 
Alias (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#23 (byte) plex_sprite_msb#31 
Alias (byte) plex_free_next#10 = (byte) plex_free_next#21 (byte) plex_free_next#30 
Alias (bool) framedone#12 = (bool) framedone#16 (bool) framedone#6 
Alias (bool) framedone#17 = (bool) framedone#2 
Alias (byte*) PLEX_SCREEN_PTR#14 = (byte*) PLEX_SCREEN_PTR#7 
Alias (byte) plex_show_idx#11 = (byte) plex_show_idx#25 
Alias (byte) plex_sprite_idx#11 = (byte) plex_sprite_idx#23 
Alias (byte) plex_sprite_msb#12 = (byte) plex_sprite_msb#24 
Alias (byte) plex_free_next#11 = (byte) plex_free_next#22 
Alias (bool) framedone#13 = (bool) framedone#7 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 (byte) plex_free_next#42 (byte) plex_free_next#32 (byte) plex_free_next#33 
Alias candidate removed (volatile)(byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#3 (byte~) plexShowSprite::$6 
Alias (byte) plex_sprite_idx#13 = (byte) plex_sprite_idx#15 
Alias (byte) plex_show_idx#13 = (byte) plex_show_idx#15 
Alias (byte) plex_sprite_msb#14 = (byte) plex_sprite_msb#16 
Alias (byte) plex_free_next#14 = (byte) plex_free_next#24 
Alias (byte) plex_show_idx#16 = (byte) plex_show_idx#3 
Alias (byte) plex_free_next#17 = (byte) plex_free_next#19 
Alias (byte) plex_sprite_idx#19 = (byte) plex_sprite_idx#20 
Alias (byte) plex_show_idx#19 = (byte) plex_show_idx#22 
Alias (byte) plex_sprite_msb#20 = (byte) plex_sprite_msb#21 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 (byte) plex_free_next#42 (byte) plex_free_next#32 (byte) plex_free_next#33 
Alias candidate removed (volatile)(byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#3 (byte~) plexShowSprite::$6 
Identical Phi Values (byte*) plexInit::plexSetScreen1_screen#0 (byte*) plexInit::screen#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#15 (byte*) PLEX_SCREEN_PTR#1
Identical Phi Values (byte) plexSort::nxt_y#1 (byte) plexSort::nxt_y#0
Identical Phi Values (byte) plexSort::nxt_idx#1 (byte) plexSort::nxt_idx#0
Identical Phi Values (byte) plexSort::m#5 (byte) plexSort::m#2
Identical Phi Values (byte) plex_show_idx#12 (byte) plex_show_idx#1
Identical Phi Values (byte) plex_sprite_idx#12 (byte) plex_sprite_idx#1
Identical Phi Values (byte) plex_sprite_msb#13 (byte) plex_sprite_msb#1
Identical Phi Values (byte) plex_sprite_idx#13 (byte) plex_sprite_idx#25
Identical Phi Values (byte) plex_show_idx#13 (byte) plex_show_idx#27
Identical Phi Values (byte) plex_free_next#13 (byte) plex_free_next#27
Identical Phi Values (byte*) PLEX_SCREEN_PTR#16 (byte*) PLEX_SCREEN_PTR#26
Identical Phi Values (byte) plex_sprite_msb#14 (byte) plex_sprite_msb#28
Identical Phi Values (byte) plex_free_next#42 (byte) plex_free_next#2
Identical Phi Values (byte) plex_free_next#32 (byte) plex_free_next#42
Identical Phi Values (byte) plex_free_next#33 (byte) plex_free_next#42
Identical Phi Values (byte) plex_sprite_idx#29 (byte) plex_sprite_idx#3
Identical Phi Values (byte*) PLEX_SCREEN_PTR#17 (byte*) PLEX_SCREEN_PTR#0
Identical Phi Values (byte) plex_show_idx#32 (byte) plex_show_idx#0
Identical Phi Values (byte) plex_sprite_idx#30 (byte) plex_sprite_idx#0
Identical Phi Values (byte) plex_sprite_msb#27 (byte) plex_sprite_msb#0
Identical Phi Values (byte) plex_free_next#26 (byte) plex_free_next#31
Identical Phi Values (bool) framedone#14 (bool) framedone#17
Identical Phi Values (byte*) PLEX_SCREEN_PTR#10 (byte*) PLEX_SCREEN_PTR#13
Identical Phi Values (byte) plex_show_idx#17 (byte) plex_show_idx#10
Identical Phi Values (byte) plex_sprite_idx#17 (byte) plex_sprite_idx#10
Identical Phi Values (byte) plex_sprite_msb#18 (byte) plex_sprite_msb#11
Identical Phi Values (byte) plex_free_next#15 (byte) plex_free_next#10
Identical Phi Values (bool) framedone#0 (bool) framedone#12
Identical Phi Values (byte*) PLEX_SCREEN_PTR#19 (byte*) PLEX_SCREEN_PTR#17
Identical Phi Values (byte*) PLEX_SCREEN_PTR#12 (byte*) PLEX_SCREEN_PTR#15
Identical Phi Values (byte*) PLEX_SCREEN_PTR#27 (byte*) PLEX_SCREEN_PTR#12
Identical Phi Values (byte*) PLEX_SCREEN_PTR#13 (byte*) PLEX_SCREEN_PTR#27
Identical Phi Values (byte) plex_sprite_idx#37 (byte) plex_sprite_idx#0
Identical Phi Values (byte) plex_show_idx#40 (byte) plex_show_idx#0
Identical Phi Values (byte) plex_free_next#35 (byte) plex_free_next#31
Identical Phi Values (byte) plex_sprite_msb#36 (byte) plex_sprite_msb#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#31 (byte*) PLEX_SCREEN_PTR#0
Identical Phi Values (bool) framedone#27 (bool) framedone#17
Identical Phi Values (byte*) PLEX_SCREEN_PTR#26 (byte*) PLEX_SCREEN_PTR#31
Identical Phi Values (bool) framedone#19 (bool) framedone#27
Identical Phi Values (byte) plex_free_next#17 (byte) plex_free_next#14
Identical Phi Values (byte) plex_sprite_idx#19 (byte) plex_sprite_idx#16
Identical Phi Values (byte) plex_show_idx#19 (byte) plex_show_idx#16
Identical Phi Values (byte) plex_sprite_msb#20 (byte) plex_sprite_msb#17
Identical Phi Values (bool) framedone#20 (bool) framedone#14
Identical Phi Values (byte) plex_show_idx#44 (byte) plex_show_idx#32
Identical Phi Values (byte) plex_sprite_idx#41 (byte) plex_sprite_idx#30
Identical Phi Values (byte) plex_sprite_msb#40 (byte) plex_sprite_msb#27
Identical Phi Values (byte) plex_free_next#39 (byte) plex_free_next#26
Identical Phi Values (bool) framedone#11 (bool) framedone#12
Identical Phi Values (byte) loop::sin_idx#2 (byte) loop::sin_idx#6
Identical Phi Values (byte) plex_show_idx#49 (byte) plex_show_idx#10
Identical Phi Values (byte) plex_sprite_idx#48 (byte) plex_sprite_idx#10
Identical Phi Values (byte) plex_sprite_msb#48 (byte) plex_sprite_msb#11
Identical Phi Values (byte) plex_free_next#46 (byte) plex_free_next#10
Identical Phi Values (byte) loop::sin_idx#3 (byte) loop::sin_idx#2
Identical Phi Values (byte) plex_show_idx#35 (byte) plex_show_idx#49
Identical Phi Values (byte) plex_sprite_idx#32 (byte) plex_sprite_idx#48
Identical Phi Values (byte) plex_sprite_msb#30 (byte) plex_sprite_msb#48
Identical Phi Values (byte) plex_free_next#29 (byte) plex_free_next#46
Identical Phi Values (byte) plex_show_idx#23 (byte) plex_show_idx#12
Identical Phi Values (byte) plex_sprite_idx#21 (byte) plex_sprite_idx#12
Identical Phi Values (byte) plex_sprite_msb#10 (byte) plex_sprite_msb#13
Identical Phi Values (byte) plex_free_next#20 (byte) plex_free_next#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#14 (byte*) PLEX_SCREEN_PTR#10
Identical Phi Values (byte) plex_show_idx#11 (byte) plex_show_idx#17
Identical Phi Values (byte) plex_sprite_idx#11 (byte) plex_sprite_idx#17
Identical Phi Values (byte) plex_sprite_msb#12 (byte) plex_sprite_msb#18
Identical Phi Values (byte) plex_free_next#11 (byte) plex_free_next#15
Identical Phi Values (bool) framedone#13 (bool) framedone#0
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte) plexSort::m#3 (byte) plexSort::m#2
Identical Phi Values (byte) plex_free_next#14 (byte) plex_free_next#2
Identical Phi Values (byte) plex_sprite_idx#16 (byte) plex_sprite_idx#3
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [107] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) plexInit::$2 [41] if((byte) plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1
Simple Condition (bool~) plexSort::$4 [53] if((byte) plexSort::nxt_y#0>=*((byte[PLEX_COUNT]) PLEX_YPOS + *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2
Simple Condition (bool~) plexSort::$9 [57] if((byte) plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1
Simple Condition (bool~) plexSort::plexFreePrepare1_$0 [80] if((byte) plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1
Simple Condition (bool~) plexShowSprite::$4 [110] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
Simple Condition (bool~) plexShowSprite::$8 [124] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return
Simple Condition (bool~) init::$7 [181] if((byte) init::sx#1!=rangelast(0,init::$4)) goto init::@1
Simple Condition (bool~) init::$8 [189] if((byte) init::ss#1!=rangelast(0,7)) goto init::@3
Simple Condition (bool~) plex_irq::$0 [228] if((byte) plex_show_idx#16<(byte) PLEX_COUNT) goto plex_irq::@1
Simple Condition (bool~) loop::$2 [259] if((byte) loop::sy#1!=rangelast(0,loop::$1)) goto loop::@10
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [66] (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
Rewriting && if()-condition to two if()s [223] (bool~) plex_irq::$6 ← (bool~) plex_irq::$3 && (bool~) plex_irq::$5
Rewriting ! if()-condition to reversed if() [247] (bool~) loop::$0 ← ! (bool) framedone#12
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant right-side identified [24] (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(number) $400+(number) $3f8
Constant right-side identified [134] (byte[8]) PLEX_FREE_YPOS ← { fill( 8, 0) }
Constant right-side identified [195] (void()*~) init::$3 ← & interrupt(KERNEL_MIN)(void()) plex_irq()
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) SPRITES_XPOS = (byte*) 53248
Constant (const byte*) SPRITES_YPOS = (byte*) 53249
Constant (const byte*) SPRITES_XMSB = (byte*) 53264
Constant (const byte*) RASTER = (byte*) 53266
Constant (const byte*) SPRITES_ENABLE = (byte*) 53269
Constant (const byte*) BORDERCOL = (byte*) 53280
Constant (const byte*) SPRITES_COLS = (byte*) 53287
Constant (const byte*) VIC_CONTROL = (byte*) 53265
Constant (const byte*) D011 = (byte*) 53265
Constant (const byte) VIC_DEN = $10
Constant (const byte) VIC_RSEL = 8
Constant (const byte*) IRQ_STATUS = (byte*) 53273
Constant (const byte*) IRQ_ENABLE = (byte*) 53274
Constant (const byte) IRQ_RASTER = 1
Constant (const byte*) CIA1_INTERRUPT = (byte*) 56333
Constant (const byte) CIA_INTERRUPT_CLEAR = $7f
Constant (const void()**) KERNEL_IRQ = (void()**) 788
Constant (const byte) WHITE = 1
Constant (const byte) RED = 2
Constant (const byte) GREEN = 5
Constant (const byte) PLEX_COUNT = $20
Constant (const byte*) PLEX_SCREEN_PTR#0 = (byte*)$400+$3f8
Constant (const byte) plexInit::i#0 = 0
Constant (const byte) plexSort::m#0 = 0
Constant (const byte) plexSort::plexFreePrepare1_s#0 = 0
Constant (const byte[8]) PLEX_FREE_YPOS = { fill( 8, 0) }
Constant (const byte*) SCREEN = (byte*) 1024
Constant (const byte*) SPRITE = (byte*) 8192
Constant (const byte[$100]) YSIN = kickasm {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
Constant (const word) init::xp#0 = $20
Constant (const byte) init::sx#0 = 0
Constant (const byte) init::ss#0 = 0
Constant (const void()*) init::$3 = &plex_irq
Constant (const byte) plex_irq::rasterY#0 = 0
Constant (const byte) loop::sin_idx#0 = 0
Constant (const byte) loop::sy#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) plexInit::screen#0 = SCREEN
Successful SSA optimization Pass2ConstantIdentification
Constant value identified { fill( PLEX_COUNT, 0) } in [21] (word[PLEX_COUNT]) PLEX_XPOS ← { fill( PLEX_COUNT, 0) }
Constant value identified { fill( PLEX_COUNT, 0) } in [22] (byte[PLEX_COUNT]) PLEX_YPOS ← { fill( PLEX_COUNT, 0) }
Constant value identified { fill( PLEX_COUNT, 0) } in [23] (byte[PLEX_COUNT]) PLEX_PTR ← { fill( PLEX_COUNT, 0) }
Constant value identified { fill( PLEX_COUNT, 0) } in [25] (byte[PLEX_COUNT]) PLEX_SORTED_IDX ← { fill( PLEX_COUNT, 0) }
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [245] if(true) goto loop::@4
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [78] plexSort::plexFreePrepare1_s#1 ← ++ plexSort::plexFreePrepare1_s#2 to ++
Resolved ranged comparison value [80] if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1 to (number) 8
Resolved ranged next value [187] init::ss#1 ← ++ init::ss#2 to ++
Resolved ranged comparison value [189] if(init::ss#1!=rangelast(0,7)) goto init::@3 to (number) 8
Eliminating unused variable (byte*) PLEX_SCREEN_PTR#1 and assignment [7] (byte*) PLEX_SCREEN_PTR#1 ← (const byte*) plexInit::screen#0 + (word) $3f8
Eliminating unused constant (const byte) plex_irq::rasterY#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte*) plexInit::screen#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte*) SCREEN
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block loop::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 8 in if((byte) plexSort::plexFreePrepare1_s#1!=(number) 8) goto plexSort::plexFreePrepare1_@1
Adding number conversion cast (unumber) 8 in if((byte) init::ss#1!=(number) 8) goto init::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Alias (byte~) plexShowSprite::$11 = (byte~) plexShowSprite::$10 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Simple Condition (bool~) plexSort::$6 [27] if((byte) plexSort::s#1!=(byte) $ff) goto plexSort::@8
Simple Condition (bool~) plex_irq::$3 [107] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT) goto plex_irq::@9
Simple Condition (bool~) plexSort::$7 [132] if((byte) plexSort::nxt_y#0<*((byte[PLEX_COUNT]) PLEX_YPOS + *((byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3
Simple Condition (bool~) plex_irq::$5 [133] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [27] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
Negating conditional jump and destination [107] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT) goto plex_irq::@4
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [7] (byte~) plexInit::$1 ← (const byte) PLEX_COUNT - (byte) 1
Constant right-side identified [13] (byte~) plexSort::$1 ← (const byte) PLEX_COUNT - (byte) 2
Constant right-side identified [73] (byte~) init::$0 ← (const byte) VIC_DEN | (const byte) VIC_RSEL
Constant right-side identified [77] (byte~) init::$4 ← (const byte) PLEX_COUNT - (byte) 1
Constant right-side identified [79] (byte*~) init::$5 ← (const byte*) SPRITE / (byte) $40
Constant right-side identified [118] (byte~) loop::$1 ← (const byte) PLEX_COUNT - (byte) 1
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word[PLEX_COUNT]) PLEX_XPOS = { fill( PLEX_COUNT, 0) }
Constant (const byte[PLEX_COUNT]) PLEX_YPOS = { fill( PLEX_COUNT, 0) }
Constant (const byte[PLEX_COUNT]) PLEX_PTR = { fill( PLEX_COUNT, 0) }
Constant (const byte[PLEX_COUNT]) PLEX_SORTED_IDX = { fill( PLEX_COUNT, 0) }
Constant (const byte) plexInit::$1 = PLEX_COUNT-1
Constant (const byte) plexSort::$1 = PLEX_COUNT-2
Constant (const byte) init::$0 = VIC_DEN|VIC_RSEL
Constant (const byte) init::$4 = PLEX_COUNT-1
Constant (const byte*) init::$5 = SPRITE/$40
Constant (const byte) loop::$1 = PLEX_COUNT-1
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)init::$5 in [80] (byte~) init::$6 ← (byte)(const byte*) init::$5
Successful SSA optimization Pass2ConstantValues
Resolved ranged next value [10] plexInit::i#1 ← ++ plexInit::i#2 to ++
Resolved ranged comparison value [11] if(plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1 to (const byte) plexInit::$1+(number) 1
Resolved ranged next value [19] plexSort::m#1 ← ++ plexSort::m#2 to ++
Resolved ranged comparison value [20] if(plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1 to (const byte) plexSort::$1+(number) 1
Resolved ranged next value [85] init::sx#1 ← ++ init::sx#2 to ++
Resolved ranged comparison value [86] if(init::sx#1!=rangelast(0,init::$4)) goto init::@1 to (const byte) init::$4+(number) 1
Resolved ranged next value [122] loop::sy#1 ← ++ loop::sy#2 to ++
Resolved ranged comparison value [123] if(loop::sy#1!=rangelast(0,loop::$1)) goto loop::@10 to (const byte) loop::$1+(number) 1
Adding number conversion cast (unumber) plexInit::$1+1 in if((byte) plexInit::i#1!=(const byte) plexInit::$1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) 1 in if((byte) plexInit::i#1!=(unumber)(const byte) plexInit::$1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) plexSort::$1+1 in if((byte) plexSort::m#1!=(const byte) plexSort::$1+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) 1 in if((byte) plexSort::m#1!=(unumber)(const byte) plexSort::$1+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) init::$4+1 in if((byte) init::sx#1!=(const byte) init::$4+(number) 1) goto init::@1
Adding number conversion cast (unumber) 1 in if((byte) init::sx#1!=(unumber)(const byte) init::$4+(number) 1) goto init::@1
Adding number conversion cast (unumber) loop::$1+1 in if((byte) loop::sy#1!=(const byte) loop::$1+(number) 1) goto loop::@10
Adding number conversion cast (unumber) 1 in if((byte) loop::sy#1!=(unumber)(const byte) loop::$1+(number) 1) goto loop::@10
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const byte) plexInit::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) plexSort::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) init::$4+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) loop::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Constant right-side identified [64] (byte~) init::$1 ← (const byte) init::$0 | (byte) 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) init::$1 = init::$0|3
Constant (const byte) init::$6 = (byte)init::$5
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Rewriting multiplication to use shift [31] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 * (byte) 2
Rewriting multiplication to use shift [41] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [68] (byte~) init::$9 ← (byte) init::sx#2 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) plexInit::i#0
Inlining constant with var siblings (const byte) plexSort::m#0
Inlining constant with var siblings (const byte) plexSort::plexFreePrepare1_s#0
Inlining constant with var siblings (const word) init::xp#0
Inlining constant with var siblings (const byte) init::sx#0
Inlining constant with var siblings (const byte) init::ss#0
Inlining constant with var siblings (const byte) loop::sin_idx#0
Inlining constant with var siblings (const byte) loop::sy#0
Constant inlined init::xp#0 = (byte) $20
Constant inlined plexInit::$1 = (const byte) PLEX_COUNT-(byte) 1
Constant inlined plexSort::$1 = (const byte) PLEX_COUNT-(byte) 2
Constant inlined plexSort::plexFreePrepare1_s#0 = (byte) 0
Constant inlined init::ss#0 = (byte) 0
Constant inlined plexInit::i#0 = (byte) 0
Constant inlined plexSort::m#0 = (byte) 0
Constant inlined init::$3 = &interrupt(KERNEL_MIN)(void()) plex_irq()
Constant inlined init::$1 = (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3
Constant inlined loop::sin_idx#0 = (byte) 0
Constant inlined init::$0 = (const byte) VIC_DEN|(const byte) VIC_RSEL
Constant inlined init::$6 = (byte)(const byte*) SPRITE/(byte) $40
Constant inlined init::$5 = (const byte*) SPRITE/(byte) $40
Constant inlined init::$4 = (const byte) PLEX_COUNT-(byte) 1
Constant inlined loop::$1 = (const byte) PLEX_COUNT-(byte) 1
Constant inlined loop::sy#0 = (byte) 0
Constant inlined init::sx#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(PLEX_SORTED_IDX+1 + plexSort::$2)
Consolidated array index constant in assignment *(PLEX_SORTED_IDX+1 + plexSort::$5)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Alias (byte) plexSort::m#2 = (byte~) plexSort::$2 
Alias (byte) plexSort::s#3 = (byte~) plexSort::$5 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte~) plexShowSprite::$6 
Added new block during phi lifting plexInit::@4(between plexInit::@1 and plexInit::@1)
Added new block during phi lifting plexSort::@9(between plexSort::@2 and plexSort::@1)
Added new block during phi lifting plexSort::@10(between plexSort::@8 and plexSort::@3)
Added new block during phi lifting plexSort::@11(between plexSort::plexFreePrepare1_@1 and plexSort::plexFreePrepare1_@1)
Added new block during phi lifting plexShowSprite::@8(between plexShowSprite::@2 and plexShowSprite::@return)
Added new block during phi lifting init::@6(between init::@1 and init::@1)
Added new block during phi lifting init::@7(between init::@3 and init::@3)
Added new block during phi lifting plex_irq::@10(between plex_irq::@9 and plex_irq::@3)
Added new block during phi lifting loop::@16(between loop::@10 and loop::@10)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @16
Adding NOP phi() at start of @17
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of init::@5
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1
Adding NOP phi() at start of plexInit::@3
Adding NOP phi() at start of plex_irq::@8
Adding NOP phi() at start of plex_irq::plexFreeNextYpos1_@return
CALL GRAPH
Calls in [] to main:8 
Calls in [main] to init:12 loop:14 
Calls in [loop] to plexSort:33 
Calls in [init] to plexInit:75 
Calls in [plex_irq] to plexShowSprite:114 

Created 21 initial phi equivalence classes
Coalesced [17] framedone#30 ← framedone#17
Coalesced [18] plex_show_idx#54 ← plex_show_idx#0
Coalesced [19] plex_sprite_idx#54 ← plex_sprite_idx#0
Coalesced [20] plex_sprite_msb#56 ← plex_sprite_msb#0
Coalesced [21] plex_free_next#50 ← plex_free_next#31
Not coalescing [25] loop::y_idx#4 ← loop::sin_idx#6
Coalesced [38] framedone#31 ← framedone#5
Coalesced [39] plex_show_idx#55 ← plex_show_idx#1
Coalesced [40] plex_sprite_idx#55 ← plex_sprite_idx#1
Coalesced [41] plex_sprite_msb#57 ← plex_sprite_msb#1
Coalesced [42] plex_free_next#51 ← plex_free_next#0
Coalesced [43] loop::sin_idx#8 ← loop::sin_idx#1
Coalesced [44] loop::y_idx#3 ← loop::y_idx#1
Coalesced [45] loop::sy#3 ← loop::sy#1
Not coalescing [51] plexSort::s#6 ← plexSort::m#2
Coalesced [71] plexSort::plexFreePrepare1_s#3 ← plexSort::plexFreePrepare1_s#1
Coalesced [72] plexSort::m#7 ← plexSort::m#1
Coalesced [73] plexSort::s#5 ← plexSort::s#1
Coalesced [96] init::ss#3 ← init::ss#1
Coalesced [97] init::sx#3 ← init::sx#1
Coalesced [98] init::xp#3 ← init::xp#1
Coalesced [107] plexInit::i#3 ← plexInit::i#1
Coalesced [109] plex_sprite_idx#52 ← plex_sprite_idx#0
Coalesced [110] plex_show_idx#52 ← plex_show_idx#0
Coalesced [111] plex_free_next#48 ← plex_free_next#31
Coalesced [112] plex_sprite_msb#54 ← plex_sprite_msb#0
Coalesced [124] framedone#29 ← framedone#3
Coalesced [129] framedone#28 ← framedone#17
Coalesced [130] plex_sprite_idx#53 ← plex_sprite_idx#3
Coalesced [131] plex_show_idx#53 ← plex_show_idx#16
Coalesced [132] plex_free_next#49 ← plex_free_next#2
Coalesced [133] plex_sprite_msb#55 ← plex_sprite_msb#17
Coalesced [141] plex_free_next#2 ← plexShowSprite::plexFreeAdd1_$2
Coalesced [153] plex_sprite_idx#3 ← plexShowSprite::$6
Coalesced [158] plex_sprite_msb#53 ← plex_sprite_msb#4
Coalesced [161] plex_sprite_msb#52 ← plex_sprite_msb#3
Coalesced down to 15 phi equivalence classes
Culled Empty Block (label) @17
Culled Empty Block (label) main::@2
Culled Empty Block (label) loop::@16
Culled Empty Block (label) plexSort::@11
Culled Empty Block (label) plexSort::@9
Culled Empty Block (label) plexSort::@10
Culled Empty Block (label) init::@5
Culled Empty Block (label) init::@7
Culled Empty Block (label) init::@6
Culled Empty Block (label) plexInit::@3
Culled Empty Block (label) plexInit::@4
Culled Empty Block (label) plex_irq::@8
Culled Empty Block (label) plex_irq::plexFreeNextYpos1_@return
Culled Empty Block (label) plex_irq::@10
Culled Empty Block (label) plexShowSprite::@8
Renumbering block @4 to @1
Renumbering block @9 to @2
Renumbering block @12 to @3
Renumbering block @14 to @4
Renumbering block @16 to @5
Renumbering block plexSort::@8 to plexSort::@7
Renumbering block plexShowSprite::@4 to plexShowSprite::@3
Renumbering block plexShowSprite::@6 to plexShowSprite::@4
Renumbering block plexShowSprite::@7 to plexShowSprite::@5
Renumbering block plex_irq::@7 to plex_irq::@6
Renumbering block plex_irq::@9 to plex_irq::@7
Renumbering block loop::@4 to loop::@2
Renumbering block loop::@6 to loop::@3
Renumbering block loop::@10 to loop::@4
Renumbering block loop::@11 to loop::@5
Renumbering block loop::@15 to loop::@6
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @5
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of loop
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] (byte) plex_show_idx#0 ← (byte) 0
  [2] (byte) plex_sprite_idx#0 ← (byte) 0
  [3] (byte) plex_sprite_msb#0 ← (byte) 1
  to:@2
@2: scope:[]  from @1
  [4] (byte) plex_free_next#31 ← (byte) 0
  to:@3
@3: scope:[]  from @2
  kickasm(location (const byte*) SPRITE) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  to:@4
@4: scope:[]  from @3
  [6] (bool) framedone#17 ← true
  to:@5
@5: scope:[]  from @4
  [7] phi()
  [8] call main 
  to:@end
@end: scope:[]  from @5
  [9] phi()

(void()) main()
main: scope:[main]  from @5
  asm { sei  }
  [11] call init 
  to:main::@1
main::@1: scope:[main]  from main
  [12] phi()
  [13] call loop 
  to:main::@return
main::@return: scope:[main]  from main::@1
  [14] return 
  to:@return

(void()) loop()
loop: scope:[loop]  from main::@1
  [15] phi()
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@6
  [16] (byte) loop::sin_idx#6 ← phi( loop/(byte) 0 loop::@6/(byte) loop::sin_idx#1 )
  [16] (byte) plex_free_next#10 ← phi( loop/(byte) plex_free_next#31 loop::@6/(byte) plex_free_next#0 )
  [16] (byte) plex_sprite_msb#11 ← phi( loop/(byte) plex_sprite_msb#0 loop::@6/(byte) plex_sprite_msb#1 )
  [16] (byte) plex_sprite_idx#10 ← phi( loop/(byte) plex_sprite_idx#0 loop::@6/(byte) plex_sprite_idx#1 )
  [16] (byte) plex_show_idx#10 ← phi( loop/(byte) plex_show_idx#0 loop::@6/(byte) plex_show_idx#1 )
  [16] (bool) framedone#12 ← phi( loop/(bool) framedone#17 loop::@6/(bool) framedone#5 )
  to:loop::@2
loop::@2: scope:[loop]  from loop::@1 loop::@2
  [17] if((bool) framedone#12) goto loop::@3
  to:loop::@2
loop::@3: scope:[loop]  from loop::@2
  [18] *((const byte*) BORDERCOL) ← (const byte) RED
  [19] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6
  to:loop::@4
loop::@4: scope:[loop]  from loop::@3 loop::@4
  [20] (byte) loop::sy#2 ← phi( loop::@4/(byte) loop::sy#1 loop::@3/(byte) 0 )
  [20] (byte) loop::y_idx#2 ← phi( loop::@4/(byte) loop::y_idx#1 loop::@3/(byte~) loop::y_idx#4 )
  [21] *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) loop::sy#2) ← *((const byte[$100]) YSIN + (byte) loop::y_idx#2)
  [22] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8
  [23] (byte) loop::sy#1 ← ++ (byte) loop::sy#2
  [24] if((byte) loop::sy#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  [25] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1
  [26] *((const byte*) BORDERCOL) ← ++ *((const byte*) BORDERCOL)
  [27] call plexSort 
  to:loop::@6
loop::@6: scope:[loop]  from loop::@5
  [28] *((const byte*) BORDERCOL) ← (const byte) GREEN
  [29] (bool) framedone#5 ← false
  [30] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f
  [31] *((const byte*) RASTER) ← (byte) 0
  to:loop::@1

(void()) plexSort()
plexSort: scope:[plexSort]  from loop::@5
  [32] phi()
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  [33] (byte) plexSort::m#2 ← phi( plexSort/(byte) 0 plexSort::@2/(byte) plexSort::m#1 )
  [34] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::m#2)
  [35] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) plexSort::nxt_idx#0)
  [36] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2
  to:plexSort::@5
plexSort::@5: scope:[plexSort]  from plexSort::@1
  [37] (byte~) plexSort::s#6 ← (byte) plexSort::m#2
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@5 plexSort::@7
  [38] (byte) plexSort::s#3 ← phi( plexSort::@7/(byte) plexSort::s#1 plexSort::@5/(byte~) plexSort::s#6 )
  [39] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#3)
  [40] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  [41] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
  to:plexSort::@7
plexSort::@7: scope:[plexSort]  from plexSort::@3
  [42] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3 plexSort::@7
  [43] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1
  [44] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0
  to:plexSort::@2
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  [45] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2
  [46] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT-(byte) 2+(byte) 1) goto plexSort::@1
  to:plexSort::@6
plexSort::@6: scope:[plexSort]  from plexSort::@2
  [47] (byte) plex_show_idx#1 ← (byte) 0
  [48] (byte) plex_sprite_idx#1 ← (byte) 0
  [49] (byte) plex_sprite_msb#1 ← (byte) 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  [50] phi()
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  [51] (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) 0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  [52] *((const byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0
  [53] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2
  [54] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  [55] (byte) plex_free_next#0 ← (byte) 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  [56] return 
  to:@return

(void()) init()
init: scope:[init]  from main
  [57] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3
  [58] call plexInit 
  to:init::@1
init::@1: scope:[init]  from init init::@1
  [59] (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init/(byte) $20 )
  [59] (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init/(byte) 0 )
  [60] *((const byte[PLEX_COUNT]) PLEX_PTR + (byte) init::sx#2) ← (byte)(const byte*) SPRITE/(byte) $40
  [61] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1
  [62] *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) init::$9) ← (word) init::xp#2
  [63] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9
  [64] (byte) init::sx#1 ← ++ (byte) init::sx#2
  [65] if((byte) init::sx#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  [66] *((const byte*) SPRITES_ENABLE) ← (byte) $ff
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  [67] (byte) init::ss#2 ← phi( init::@2/(byte) 0 init::@3/(byte) init::ss#1 )
  [68] *((const byte*) SPRITES_COLS + (byte) init::ss#2) ← (const byte) GREEN
  [69] (byte) init::ss#1 ← ++ (byte) init::ss#2
  [70] if((byte) init::ss#1!=(byte) 8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  asm { sei  }
  [72] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR
  [73] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER
  [74] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER
  [75] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) plex_irq()
  asm { cli  }
  to:init::@return
init::@return: scope:[init]  from init::@4
  [77] return 
  to:@return

(void()) plexInit((byte*) plexInit::screen)
plexInit: scope:[plexInit]  from init
  [78] phi()
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  [79] phi()
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::plexSetScreen1
  [80] (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::plexSetScreen1/(byte) 0 )
  [81] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  [82] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2
  [83] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  [84] return 
  to:@return

interrupt(KERNEL_MIN)(void()) plex_irq()
plex_irq: scope:[plex_irq]  from
  [85] *((const byte*) BORDERCOL) ← (const byte) WHITE
  to:plex_irq::@3
plex_irq::@3: scope:[plex_irq]  from plex_irq plex_irq::@7
  [86] (byte) plex_sprite_msb#28 ← phi( plex_irq/(byte) plex_sprite_msb#0 plex_irq::@7/(byte) plex_sprite_msb#17 )
  [86] (byte) plex_free_next#27 ← phi( plex_irq/(byte) plex_free_next#31 plex_irq::@7/(byte~) plexShowSprite::plexFreeAdd1_$2 )
  [86] (byte) plex_show_idx#27 ← phi( plex_irq/(byte) plex_show_idx#0 plex_irq::@7/(byte) plex_show_idx#16 )
  [86] (byte) plex_sprite_idx#25 ← phi( plex_irq/(byte) plex_sprite_idx#0 plex_irq::@7/(byte~) plexShowSprite::$6 )
  [87] call plexShowSprite 
  to:plex_irq::plexFreeNextYpos1
plex_irq::plexFreeNextYpos1: scope:[plex_irq]  from plex_irq::@3
  [88] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS + (byte~) plexShowSprite::plexFreeAdd1_$2)
  to:plex_irq::@6
plex_irq::@6: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1
  [89] (byte~) plex_irq::$4 ← *((const byte*) RASTER) + (byte) 2
  [90] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT) goto plex_irq::@4
  to:plex_irq::@7
plex_irq::@7: scope:[plex_irq]  from plex_irq::@6
  [91] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3
  to:plex_irq::@4
plex_irq::@4: scope:[plex_irq]  from plex_irq::@6 plex_irq::@7
  [92] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER
  [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT) goto plex_irq::@1
  to:plex_irq::@5
plex_irq::@5: scope:[plex_irq]  from plex_irq::@4
  [94] (bool) framedone#3 ← true
  to:plex_irq::@2
plex_irq::@2: scope:[plex_irq]  from plex_irq::@1 plex_irq::@5
  [95] (bool) framedone#10 ← phi( plex_irq::@1/(bool) framedone#17 plex_irq::@5/(bool) framedone#3 )
  [96] *((const byte*) BORDERCOL) ← (byte) 0
  to:plex_irq::@return
plex_irq::@return: scope:[plex_irq]  from plex_irq::@2
  [97] return 
  to:@return
plex_irq::@1: scope:[plex_irq]  from plex_irq::@4
  [98] *((const byte*) RASTER) ← (byte) plex_irq::plexFreeNextYpos1_return#0
  to:plex_irq::@2

(void()) plexShowSprite()
plexShowSprite: scope:[plexShowSprite]  from plex_irq::@3
  [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1
  [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27))
  [101] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  [102] (byte~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15
  [103] *((const byte[8]) PLEX_FREE_YPOS + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0
  [104] (byte~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#27 + (byte) 1
  [105] (byte~) plexShowSprite::plexFreeAdd1_$2 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7
  to:plexShowSprite::@5
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT]) PLEX_PTR + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27))
  [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)
  [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1
  [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11)
  [110] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2
  [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11)
  [112] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@5
  [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28
  [114] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  [115] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#25 + (byte) 1
  [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7
  [117] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27
  [118] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#28 << (byte) 1
  [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@2
  [120] (byte) plex_sprite_msb#4 ← (byte) 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@4
  [121] (byte) plex_sprite_msb#17 ← phi( plexShowSprite::@2/(byte) plex_sprite_msb#3 plexShowSprite::@4/(byte) plex_sprite_msb#4 )
  [122] return 
  to:@return
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@5
  [123] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#28
  to:plexShowSprite::@2


VARIABLE REGISTER WEIGHTS
(byte*) PLEX_SCREEN_PTR
(bool) framedone
(bool) framedone#10 40.0
(bool) framedone#12 57.0
(bool) framedone#17 0.375
(bool) framedone#3 4.0
(bool) framedone#5 7.333333333333333
(void()) init()
(byte~) init::$9 22.0
(byte) init::ss
(byte) init::ss#1 16.5
(byte) init::ss#2 16.5
(byte) init::sx
(byte) init::sx#1 16.5
(byte) init::sx#2 8.8
(word) init::xp
(word) init::xp#1 7.333333333333333
(word) init::xp#2 8.25
(void()) loop()
(byte) loop::sin_idx
(byte) loop::sin_idx#1 3.142857142857143
(byte) loop::sin_idx#6 3.666666666666667
(byte) loop::sy
(byte) loop::sy#1 151.5
(byte) loop::sy#2 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 67.33333333333333
(byte) loop::y_idx#2 157.0
(byte~) loop::y_idx#4 22.0
(void()) main()
(void()) plexInit((byte*) plexInit::screen)
(byte) plexInit::i
(byte) plexInit::i#1 16.5
(byte) plexInit::i#2 22.0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 2.0
(byte~) plexShowSprite::$2 4.0
(byte~) plexShowSprite::$3 4.0
(byte~) plexShowSprite::$5 4.0
(byte~) plexShowSprite::$6 1.0833333333333333
(byte~) plexShowSprite::$9 4.0
(byte~) plexShowSprite::plexFreeAdd1_$0 4.0
(byte~) plexShowSprite::plexFreeAdd1_$1 4.0
(byte~) plexShowSprite::plexFreeAdd1_$2 1.0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 0.5454545454545454
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 4.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(byte) plexSort::m
(byte) plexSort::m#1 151.5
(byte) plexSort::m#2 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 150.375
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 151.5
(byte) plexSort::plexFreePrepare1_s#2 151.5
(byte) plexSort::s
(byte) plexSort::s#1 1368.3333333333335
(byte) plexSort::s#2 202.0
(byte) plexSort::s#3 2052.5
(byte~) plexSort::s#6 202.0
(byte) plex_free_next
(byte) plex_free_next#0 1.8571428571428572
(byte) plex_free_next#10 130.0
(byte) plex_free_next#27 2.8333333333333335
(byte) plex_free_next#31 0.6666666666666666
interrupt(KERNEL_MIN)(void()) plex_irq()
(byte~) plex_irq::$4 11.0
(byte) plex_irq::plexFreeNextYpos1_return
(byte) plex_irq::plexFreeNextYpos1_return#0 4.0
(byte) plex_irq::rasterY
(byte) plex_show_idx
(byte) plex_show_idx#0 0.5
(byte) plex_show_idx#1 0.8666666666666666
(byte) plex_show_idx#10 130.0
(byte) plex_show_idx#16 2.1666666666666665
(byte) plex_show_idx#27 1.05
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0 0.5454545454545454
(byte) plex_sprite_idx#1 0.9285714285714286
(byte) plex_sprite_idx#10 130.0
(byte) plex_sprite_idx#25 1.0555555555555558
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0 0.6000000000000001
(byte) plex_sprite_msb#1 1.0
(byte) plex_sprite_msb#11 130.0
(byte) plex_sprite_msb#17 2.142857142857143
(byte) plex_sprite_msb#28 0.9047619047619048
(byte) plex_sprite_msb#3 3.0
(byte) plex_sprite_msb#4 4.0

Initial phi equivalence classes
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ]
[ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ]
[ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ]
[ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ]
[ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ]
Added variable plexSort::nxt_idx#0 to zero page equivalence class [ plexSort::nxt_idx#0 ]
Added variable plexSort::nxt_y#0 to zero page equivalence class [ plexSort::nxt_y#0 ]
Added variable plexSort::s#2 to zero page equivalence class [ plexSort::s#2 ]
Added variable init::$9 to zero page equivalence class [ init::$9 ]
Added variable plex_irq::plexFreeNextYpos1_return#0 to zero page equivalence class [ plex_irq::plexFreeNextYpos1_return#0 ]
Added variable plex_irq::$4 to zero page equivalence class [ plex_irq::$4 ]
Added variable plexShowSprite::plex_sprite_idx2#0 to zero page equivalence class [ plexShowSprite::plex_sprite_idx2#0 ]
Added variable plexShowSprite::plexFreeAdd1_ypos#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Added variable plexShowSprite::plexFreeAdd1_$0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$0 ]
Added variable plexShowSprite::plexFreeAdd1_$1 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$1 ]
Added variable plexShowSprite::xpos_idx#0 to zero page equivalence class [ plexShowSprite::xpos_idx#0 ]
Added variable plexShowSprite::$11 to zero page equivalence class [ plexShowSprite::$11 ]
Added variable plexShowSprite::$2 to zero page equivalence class [ plexShowSprite::$2 ]
Added variable plexShowSprite::$3 to zero page equivalence class [ plexShowSprite::$3 ]
Added variable plexShowSprite::$9 to zero page equivalence class [ plexShowSprite::$9 ]
Added variable plexShowSprite::$5 to zero page equivalence class [ plexShowSprite::$5 ]
Complete equivalence classes
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ]
[ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ]
[ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ]
[ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ]
[ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ]
[ plexSort::nxt_idx#0 ]
[ plexSort::nxt_y#0 ]
[ plexSort::s#2 ]
[ init::$9 ]
[ plex_irq::plexFreeNextYpos1_return#0 ]
[ plex_irq::$4 ]
[ plexShowSprite::plex_sprite_idx2#0 ]
[ plexShowSprite::plexFreeAdd1_ypos#0 ]
[ plexShowSprite::plexFreeAdd1_$0 ]
[ plexShowSprite::plexFreeAdd1_$1 ]
[ plexShowSprite::xpos_idx#0 ]
[ plexShowSprite::$11 ]
[ plexShowSprite::$2 ]
[ plexShowSprite::$3 ]
[ plexShowSprite::$9 ]
[ plexShowSprite::$5 ]
Allocated zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Allocated zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Allocated zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ]
Allocated zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ]
Allocated zp ZP_BYTE:6 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Allocated zp ZP_BYTE:7 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Allocated zp ZP_BYTE:8 [ init::sx#2 init::sx#1 ]
Allocated zp ZP_WORD:9 [ init::xp#2 init::xp#1 ]
Allocated zp ZP_BYTE:11 [ init::ss#2 init::ss#1 ]
Allocated zp ZP_BYTE:12 [ plexInit::i#2 plexInit::i#1 ]
Allocated zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ]
Allocated zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ]
Allocated zp ZP_BYTE:15 [ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ]
Allocated zp ZP_BYTE:16 [ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ]
Allocated zp ZP_BOOL:17 [ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ]
Allocated zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ]
Allocated zp ZP_BYTE:19 [ plexSort::nxt_y#0 ]
Allocated zp ZP_BYTE:20 [ plexSort::s#2 ]
Allocated zp ZP_BYTE:21 [ init::$9 ]
Allocated zp ZP_BYTE:22 [ plex_irq::plexFreeNextYpos1_return#0 ]
Allocated zp ZP_BYTE:23 [ plex_irq::$4 ]
Allocated zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Allocated zp ZP_BYTE:26 [ plexShowSprite::plexFreeAdd1_$0 ]
Allocated zp ZP_BYTE:27 [ plexShowSprite::plexFreeAdd1_$1 ]
Allocated zp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ]
Allocated zp ZP_BYTE:29 [ plexShowSprite::$11 ]
Allocated zp ZP_BYTE:30 [ plexShowSprite::$2 ]
Allocated zp ZP_BYTE:31 [ plexShowSprite::$3 ]
Allocated zp ZP_BYTE:32 [ plexShowSprite::$9 ]
Allocated zp ZP_BYTE:33 [ plexShowSprite::$5 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// A simple usage of the flexible sprite multiplexer routine
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label VIC_CONTROL = $d011
  .label D011 = $d011
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Bits for the IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // CIA#1 Interrupt Status & Control Register
  .label CIA1_INTERRUPT = $dc0d
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = $400+$3f8
  .label SPRITE = $2000
  .label plex_show_idx = $e
  .label plex_sprite_idx = $d
  .label plex_sprite_msb = $10
  .label plex_free_next = $f
  .label framedone = $11
  // @begin
__bbegin:
  jmp __b1
  // @1
__b1:
  // [1] (byte) plex_show_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index in the PLEX tables of the next sprite to show
  lda #0
  sta.z plex_show_idx
  // [2] (byte) plex_sprite_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index the next sprite to use for showing (sprites are used round-robin)
  lda #0
  sta.z plex_sprite_idx
  // [3] (byte) plex_sprite_msb#0 ← (byte) 1 -- vbuz1=vbuc1 
  // The MSB bit of the next sprite to use for showing
  lda #1
  sta.z plex_sprite_msb
  jmp __b2
  // @2
__b2:
  // [4] (byte) plex_free_next#31 ← (byte) 0 -- vbuz1=vbuc1 
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  lda #0
  sta.z plex_free_next
  jmp __b3
  // @3
__b3:
  // kickasm(location (const byte*) SPRITE) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  jmp __b4
  // @4
__b4:
  // [6] (bool) framedone#17 ← true -- vboz1=vboc1 
  lda #1
  sta.z framedone
  // [7] phi from @4 to @5 [phi:@4->@5]
__b5_from___b4:
  jmp __b5
  // @5
__b5:
  // [8] call main 
  jsr main
  // [9] phi from @5 to @end [phi:@5->@end]
__bend_from___b5:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // asm { sei  }
    sei
    // [11] call init 
    jsr init
    // [12] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [13] call loop 
    // [15] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from___b1:
    jsr loop
    jmp __breturn
    // main::@return
  __breturn:
    // [14] return 
    rts
}
  // loop
// The raster loop
loop: {
    .label y_idx = 3
    .label sy = 4
    .label sin_idx = 2
    // [16] phi from loop to loop::@1 [phi:loop->loop::@1]
  __b1_from_loop:
    // [16] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    // [16] phi (byte) plex_free_next#10 = (byte) plex_free_next#31 [phi:loop->loop::@1#1] -- register_copy 
    // [16] phi (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#0 [phi:loop->loop::@1#2] -- register_copy 
    // [16] phi (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#0 [phi:loop->loop::@1#3] -- register_copy 
    // [16] phi (byte) plex_show_idx#10 = (byte) plex_show_idx#0 [phi:loop->loop::@1#4] -- register_copy 
    // [16] phi (bool) framedone#12 = (bool) framedone#17 [phi:loop->loop::@1#5] -- register_copy 
    jmp __b1
    // loop::@1
  __b1:
    jmp __b2
    // loop::@2
  __b2:
    // [17] if((bool) framedone#12) goto loop::@3 -- vboz1_then_la1 
    lda.z framedone
    cmp #0
    bne __b3
    jmp __b2
    // loop::@3
  __b3:
    // [18] *((const byte*) BORDERCOL) ← (const byte) RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
    // [19] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuz1=vbuz2 
    lda.z sin_idx
    sta.z y_idx
    // [20] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  __b4_from___b3:
    // [20] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sy
    // [20] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp __b4
    // [20] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  __b4_from___b4:
    // [20] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [20] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp __b4
    // loop::@4
  __b4:
    // [21] *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) loop::sy#2) ← *((const byte[$100]) YSIN + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz2 
    ldy.z y_idx
    lda YSIN,y
    ldy.z sy
    sta PLEX_YPOS,y
    // [22] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z y_idx
    axs #-[8]
    stx.z y_idx
    // [23] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuz1=_inc_vbuz1 
    inc.z sy
    // [24] if((byte) loop::sy#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z sy
    bne __b4_from___b4
    jmp __b5
    // loop::@5
  __b5:
    // [25] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc.z sin_idx
    // [26] *((const byte*) BORDERCOL) ← ++ *((const byte*) BORDERCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [27] call plexSort 
    // [32] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from___b5:
    jsr plexSort
    jmp __b6
    // loop::@6
  __b6:
    // [28] *((const byte*) BORDERCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // [29] (bool) framedone#5 ← false -- vboz1=vboc1 
    lda #0
    sta.z framedone
    // [30] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
    // [31] *((const byte*) RASTER) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
    // [16] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
  __b1_from___b6:
    // [16] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
    // [16] phi (byte) plex_free_next#10 = (byte) plex_free_next#0 [phi:loop::@6->loop::@1#1] -- register_copy 
    // [16] phi (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#1 [phi:loop::@6->loop::@1#2] -- register_copy 
    // [16] phi (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#1 [phi:loop::@6->loop::@1#3] -- register_copy 
    // [16] phi (byte) plex_show_idx#10 = (byte) plex_show_idx#1 [phi:loop::@6->loop::@1#4] -- register_copy 
    // [16] phi (bool) framedone#12 = (bool) framedone#5 [phi:loop::@6->loop::@1#5] -- register_copy 
    jmp __b1
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $12
    .label nxt_y = $13
    .label m = 5
    .label s = 6
    .label s_2 = $14
    .label plexFreePrepare1_s = 7
    // [33] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  __b1_from_plexSort:
    // [33] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    jmp __b1
    // [33] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  __b1_from___b2:
    // [33] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp __b1
    // plexSort::@1
  __b1:
    // [34] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // [35] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z nxt_idx
    lda PLEX_YPOS,y
    sta.z nxt_y
    // [36] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    jmp __b5
    // plexSort::@5
  __b5:
    // [37] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuz1=vbuz2 
    lda.z m
    sta.z s
    // [38] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
  __b3_from___b5:
  __b3_from___b7:
    // [38] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
    jmp __b3
    // plexSort::@3
  __b3:
    // [39] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z s
    lda PLEX_SORTED_IDX,y
    sta PLEX_SORTED_IDX+1,y
    // [40] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuz1=_dec_vbuz1 
    dec.z s
    // [41] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuz1_eq_vbuc1_then_la1 
    lda #$ff
    cmp.z s
    beq __b4
    jmp __b7
    // plexSort::@7
  __b7:
    // [42] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z s
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3_from___b7
    jmp __b4
    // plexSort::@4
  __b4:
    // [43] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuz1=_inc_vbuz2 
    ldy.z s
    iny
    sty.z s_2
    // [44] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z nxt_idx
    ldy.z s_2
    sta PLEX_SORTED_IDX,y
    jmp __b2
    // plexSort::@2
  __b2:
    // [45] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [46] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1_from___b2
    jmp __b6
    // plexSort::@6
  __b6:
    // [47] (byte) plex_show_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta.z plex_show_idx
    // [48] (byte) plex_sprite_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [49] (byte) plex_sprite_msb#1 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [50] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
  plexFreePrepare1_from___b6:
    jmp plexFreePrepare1
    // plexSort::plexFreePrepare1
  plexFreePrepare1:
    // [51] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1:
    // [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z plexFreePrepare1_s
    jmp plexFreePrepare1___b1
    // [51] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1___b1:
    // [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1___b1
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // [52] *((const byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #0
    ldy.z plexFreePrepare1_s
    sta PLEX_FREE_YPOS,y
    // [53] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuz1=_inc_vbuz1 
    inc.z plexFreePrepare1_s
    // [54] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z plexFreePrepare1_s
    bne plexFreePrepare1___b1_from_plexFreePrepare1___b1
    jmp plexFreePrepare1___b2
    // plexSort::plexFreePrepare1_@2
  plexFreePrepare1___b2:
    // [55] (byte) plex_free_next#0 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    jmp __breturn
    // plexSort::@return
  __breturn:
    // [56] return 
    rts
}
  // init
// Initialize the program
init: {
    .label __9 = $15
    .label xp = 9
    .label sx = 8
    .label ss = $b
    // [57] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // [58] call plexInit 
    // [78] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
    // [59] phi from init to init::@1 [phi:init->init::@1]
  __b1_from_init:
    // [59] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #<$20
    sta.z xp
    lda #>$20
    sta.z xp+1
    // [59] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z sx
    jmp __b1
    // [59] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  __b1_from___b1:
    // [59] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
    // [59] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp __b1
    // init::@1
  __b1:
    // [60] *((const byte[PLEX_COUNT]) PLEX_PTR + (byte) init::sx#2) ← (byte)(const byte*) SPRITE/(byte) $40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #SPRITE/$40
    ldy.z sx
    sta PLEX_PTR,y
    // [61] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z sx
    asl
    sta.z __9
    // [62] *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) init::$9) ← (word) init::xp#2 -- pwuc1_derefidx_vbuz1=vwuz2 
    ldy.z __9
    lda.z xp
    sta PLEX_XPOS,y
    lda.z xp+1
    sta PLEX_XPOS+1,y
    // [63] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc.z xp
    sta.z xp
    bcc !+
    inc.z xp+1
  !:
    // [64] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuz1=_inc_vbuz1 
    inc.z sx
    // [65] if((byte) init::sx#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z sx
    bne __b1_from___b1
    jmp __b2
    // init::@2
  __b2:
    // [66] *((const byte*) SPRITES_ENABLE) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [67] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  __b3_from___b2:
    // [67] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z ss
    jmp __b3
    // [67] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  __b3_from___b3:
    // [67] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp __b3
    // init::@3
  __b3:
    // [68] *((const byte*) SPRITES_COLS + (byte) init::ss#2) ← (const byte) GREEN -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy.z ss
    sta SPRITES_COLS,y
    // [69] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuz1=_inc_vbuz1 
    inc.z ss
    // [70] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z ss
    bne __b3_from___b3
    jmp __b4
    // init::@4
  __b4:
    // asm { sei  }
    // enable the interrupt
    sei
    // [72] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
    // [73] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // [74] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // [75] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) plex_irq() -- _deref_pptc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
    // asm { cli  }
    cli
    jmp __breturn
    // init::@return
  __breturn:
    // [77] return 
    rts
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    .label i = $c
    // [79] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
    // plexInit::plexSetScreen1
  plexSetScreen1:
    // [80] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  __b1_from_plexSetScreen1:
    // [80] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [80] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  __b1_from___b1:
    // [80] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp __b1
    // plexInit::@1
  __b1:
    // [81] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuz1=vbuz1 
    ldy.z i
    tya
    sta PLEX_SORTED_IDX,y
    // [82] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [83] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i
    bne __b1_from___b1
    jmp __breturn
    // plexInit::@return
  __breturn:
    // [84] return 
    rts
}
  // plex_irq
plex_irq: {
    .label __4 = $17
    .label plexFreeNextYpos1_return = $16
    // entry interrupt(KERNEL_MIN)
    // [85] *((const byte*) BORDERCOL) ← (const byte) WHITE -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
    // [86] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
  __b3_from_plex_irq:
  __b3_from___b7:
    // [86] phi (byte) plex_sprite_msb#28 = (byte) plex_sprite_msb#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#0] -- register_copy 
    // [86] phi (byte) plex_free_next#27 = (byte) plex_free_next#31 [phi:plex_irq/plex_irq::@7->plex_irq::@3#1] -- register_copy 
    // [86] phi (byte) plex_show_idx#27 = (byte) plex_show_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#2] -- register_copy 
    // [86] phi (byte) plex_sprite_idx#25 = (byte) plex_sprite_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#3] -- register_copy 
    jmp __b3
    // plex_irq::@3
  __b3:
    // [87] call plexShowSprite 
    jsr plexShowSprite
    jmp plexFreeNextYpos1
    // plex_irq::plexFreeNextYpos1
  plexFreeNextYpos1:
    // [88] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS + (byte~) plexShowSprite::plexFreeAdd1_$2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plexShowSprite.plexFreeAdd1___2
    lda PLEX_FREE_YPOS,y
    sta.z plexFreeNextYpos1_return
    jmp __b6
    // plex_irq::@6
  __b6:
    // [89] (byte~) plex_irq::$4 ← *((const byte*) RASTER) + (byte) 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta.z __4
    // [90] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT) goto plex_irq::@4 -- vbuz1_ge_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcs __b4
    jmp __b7
    // plex_irq::@7
  __b7:
    // [91] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3 -- vbuz1_lt_vbuz2_then_la1 
    lda.z plexFreeNextYpos1_return
    cmp.z __4
    bcc __b3_from___b7
    jmp __b4
    // plex_irq::@4
  __b4:
    // [92] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcc __b1
    jmp __b5
    // plex_irq::@5
  __b5:
    // [94] (bool) framedone#3 ← true -- vboz1=vboc1 
    lda #1
    sta.z framedone
    // [95] phi from plex_irq::@1 plex_irq::@5 to plex_irq::@2 [phi:plex_irq::@1/plex_irq::@5->plex_irq::@2]
  __b2_from___b1:
  __b2_from___b5:
    // [95] phi (bool) framedone#10 = (bool) framedone#17 [phi:plex_irq::@1/plex_irq::@5->plex_irq::@2#0] -- register_copy 
    jmp __b2
    // plex_irq::@2
  __b2:
    // [96] *((const byte*) BORDERCOL) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDERCOL
    jmp __breturn
    // plex_irq::@return
  __breturn:
    // [97] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
    // plex_irq::@1
  __b1:
    // [98] *((const byte*) RASTER) ← (byte) plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuz1 
    lda.z plexFreeNextYpos1_return
    sta RASTER
    jmp __b2_from___b1
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label __2 = $1e
    .label __3 = $1f
    .label __5 = $21
    .label __6 = $d
    .label __9 = $20
    .label __11 = $1d
    .label plexFreeAdd1___0 = $1a
    .label plexFreeAdd1___1 = $1b
    .label plexFreeAdd1___2 = $f
    .label plex_sprite_idx2 = $18
    .label plexFreeAdd1_ypos = $19
    .label xpos_idx = $1c
    // [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) -- vbuz1=pbuc1_derefidx_(pbuc2_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    ldx PLEX_YPOS,y
    stx.z plexFreeAdd1_ypos
    // [101] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z plexFreeAdd1_ypos
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
    // plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
    // [102] (byte~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuz1=vbuz2_plus_vbuc1 
    lax.z plexFreeAdd1_ypos
    axs #-[$15]
    stx.z plexFreeAdd1___0
    // [103] *((const byte[8]) PLEX_FREE_YPOS + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z plexFreeAdd1___0
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // [104] (byte~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#27 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy.z plex_free_next
    iny
    sty.z plexFreeAdd1___1
    // [105] (byte~) plexShowSprite::plexFreeAdd1_$2 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z plexFreeAdd1___1
    sta.z plexFreeAdd1___2
    jmp __b5
    // plexShowSprite::@5
  __b5:
    // [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT]) PLEX_PTR + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx.z plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
    // [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    sta.z xpos_idx
    // [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z xpos_idx
    asl
    sta.z __11
    // [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuz1=_lo_pwuc1_derefidx_vbuz2 
    ldy.z __11
    lda PLEX_XPOS,y
    sta.z __2
    // [110] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z __2
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuz1=_hi_pwuc1_derefidx_vbuz2 
    ldy.z __11
    lda PLEX_XPOS+1,y
    sta.z __3
    // [112] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuz1_neq_0_then_la1 
    lda.z __3
    cmp #0
    bne __b1
    jmp __b3
    // plexShowSprite::@3
  __b3:
    // [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 -- vbuz1=vbuc1_bxor_vbuz2 
    lda #$ff
    eor.z plex_sprite_msb
    sta.z __9
    // [114] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuz1 
    lda SPRITES_XMSB
    and.z __9
    sta SPRITES_XMSB
    jmp __b2
    // plexShowSprite::@2
  __b2:
    // [115] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#25 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy.z plex_sprite_idx
    iny
    sty.z __5
    // [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z __5
    sta.z __6
    // [117] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27 -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // [118] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#28 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne __breturn_from___b2
    jmp __b4
    // plexShowSprite::@4
  __b4:
    // [120] (byte) plex_sprite_msb#4 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [121] phi from plexShowSprite::@2 plexShowSprite::@4 to plexShowSprite::@return [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return]
  __breturn_from___b2:
  __breturn_from___b4:
    // [121] phi (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return#0] -- register_copy 
    jmp __breturn
    // plexShowSprite::@return
  __breturn:
    // [122] return 
    rts
    // plexShowSprite::@1
  __b1:
    // [123] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#28 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // File Data
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  .align $100
YSIN:
.var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] (byte) plex_show_idx#0 ← (byte) 0 [ plex_show_idx#0 ] (  [ plex_show_idx#0 ] ) always clobbers reg byte a 
Statement [2] (byte) plex_sprite_idx#0 ← (byte) 0 [ plex_show_idx#0 plex_sprite_idx#0 ] (  [ plex_show_idx#0 plex_sprite_idx#0 ] ) always clobbers reg byte a 
Statement [3] (byte) plex_sprite_msb#0 ← (byte) 1 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 ] ) always clobbers reg byte a 
Statement [4] (byte) plex_free_next#31 ← (byte) 0 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] ) always clobbers reg byte a 
Statement [6] (bool) framedone#17 ← true [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [17] if((bool) framedone#12) goto loop::@3 [ framedone#12 loop::sin_idx#6 ] ( main:8::loop:13 [ framedone#12 loop::sin_idx#6 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Statement [18] *((const byte*) BORDERCOL) ← (const byte) RED [ loop::sin_idx#6 ] ( main:8::loop:13 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [21] *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) loop::sy#2) ← *((const byte[$100]) YSIN + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:8::loop:13 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ]
Statement [22] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:8::loop:13 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [28] *((const byte*) BORDERCOL) ← (const byte) GREEN [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [29] (bool) framedone#5 ← false [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [30] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) RASTER) ← (byte) 0 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [39] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:19 [ plexSort::nxt_y#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Statement [42] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [44] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [47] (byte) plex_show_idx#1 ← (byte) 0 [ plex_show_idx#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 ] ) always clobbers reg byte a 
Statement [48] (byte) plex_sprite_idx#1 ← (byte) 0 [ plex_show_idx#1 plex_sprite_idx#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 ] ) always clobbers reg byte a 
Statement [49] (byte) plex_sprite_msb#1 ← (byte) 1 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 ] ) always clobbers reg byte a 
Statement [52] *((const byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plexSort::plexFreePrepare1_s#2 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Statement [55] (byte) plex_free_next#0 ← (byte) 0 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 ] ) always clobbers reg byte a 
Statement [57] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [60] *((const byte[PLEX_COUNT]) PLEX_PTR + (byte) init::sx#2) ← (byte)(const byte*) SPRITE/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:8 [ init::sx#2 init::sx#1 ]
Statement [61] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$9 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#2 init::$9 ] ) always clobbers reg byte a 
Statement [62] *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) init::$9) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [63] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [66] *((const byte*) SPRITES_ENABLE) ← (byte) $ff [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [68] *((const byte*) SPRITES_COLS + (byte) init::ss#2) ← (const byte) GREEN [ init::ss#2 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::ss#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:11 [ init::ss#2 init::ss#1 ]
Statement [72] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [73] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [74] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [75] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) plex_irq() [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [85] *((const byte*) BORDERCOL) ← (const byte) WHITE [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [88] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS + (byte~) plexShowSprite::plexFreeAdd1_$2) [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte y 
Statement [90] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT) goto plex_irq::@4 [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:22 [ plex_irq::plexFreeNextYpos1_return#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:23 [ plex_irq::$4 ]
Statement [92] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER [ framedone#17 plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] (  [ framedone#17 plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT) goto plex_irq::@1 [ framedone#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ framedone#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [94] (bool) framedone#3 ← true [ framedone#3 ] (  [ framedone#3 ] ) always clobbers reg byte a 
Statement [96] *((const byte*) BORDERCOL) ← (byte) 0 [ ] (  [ ] ) always clobbers reg byte a 
Statement [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte x reg byte y 
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [103] *((const byte[8]) PLEX_FREE_YPOS + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte y 
Statement [105] (byte~) plexShowSprite::plexFreeAdd1_$2 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT]) PLEX_PTR + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte y 
Statement [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:29 [ plexShowSprite::$11 ]
Statement [110] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$11 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$11 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:29 [ plexShowSprite::$11 ]
Statement [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$3 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$9 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [114] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ) always clobbers reg byte a 
Statement [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 [ plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2 ] ( plexShowSprite:87 [ framedone#17 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2 ] ) always clobbers reg byte a 
Statement [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#3 ] ( plexShowSprite:87 [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#3 ] ) always clobbers reg byte a 
Statement [120] (byte) plex_sprite_msb#4 ← (byte) 1 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#4 ] ( plexShowSprite:87 [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#4 ] ) always clobbers reg byte a 
Statement [123] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ) always clobbers reg byte a 
Statement [1] (byte) plex_show_idx#0 ← (byte) 0 [ plex_show_idx#0 ] (  [ plex_show_idx#0 ] ) always clobbers reg byte a 
Statement [2] (byte) plex_sprite_idx#0 ← (byte) 0 [ plex_show_idx#0 plex_sprite_idx#0 ] (  [ plex_show_idx#0 plex_sprite_idx#0 ] ) always clobbers reg byte a 
Statement [3] (byte) plex_sprite_msb#0 ← (byte) 1 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 ] ) always clobbers reg byte a 
Statement [4] (byte) plex_free_next#31 ← (byte) 0 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] ) always clobbers reg byte a 
Statement [6] (bool) framedone#17 ← true [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [17] if((bool) framedone#12) goto loop::@3 [ framedone#12 loop::sin_idx#6 ] ( main:8::loop:13 [ framedone#12 loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [18] *((const byte*) BORDERCOL) ← (const byte) RED [ loop::sin_idx#6 ] ( main:8::loop:13 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [21] *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) loop::sy#2) ← *((const byte[$100]) YSIN + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:8::loop:13 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Statement [22] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:8::loop:13 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [28] *((const byte*) BORDERCOL) ← (const byte) GREEN [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [29] (bool) framedone#5 ← false [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [30] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) RASTER) ← (byte) 0 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [36] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ) always clobbers reg byte a 
Statement [39] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Statement [42] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [44] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [47] (byte) plex_show_idx#1 ← (byte) 0 [ plex_show_idx#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 ] ) always clobbers reg byte a 
Statement [48] (byte) plex_sprite_idx#1 ← (byte) 0 [ plex_show_idx#1 plex_sprite_idx#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 ] ) always clobbers reg byte a 
Statement [49] (byte) plex_sprite_msb#1 ← (byte) 1 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 ] ) always clobbers reg byte a 
Statement [52] *((const byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plexSort::plexFreePrepare1_s#2 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Statement [55] (byte) plex_free_next#0 ← (byte) 0 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 ] ) always clobbers reg byte a 
Statement [57] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [60] *((const byte[PLEX_COUNT]) PLEX_PTR + (byte) init::sx#2) ← (byte)(const byte*) SPRITE/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [61] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$9 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#2 init::$9 ] ) always clobbers reg byte a 
Statement [62] *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) init::$9) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [63] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [66] *((const byte*) SPRITES_ENABLE) ← (byte) $ff [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [68] *((const byte*) SPRITES_COLS + (byte) init::ss#2) ← (const byte) GREEN [ init::ss#2 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::ss#2 ] ) always clobbers reg byte a 
Statement [72] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [73] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [74] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [75] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) plex_irq() [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [85] *((const byte*) BORDERCOL) ← (const byte) WHITE [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [88] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS + (byte~) plexShowSprite::plexFreeAdd1_$2) [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte y 
Statement [90] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT) goto plex_irq::@4 [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] ) always clobbers reg byte a 
Statement [92] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER [ framedone#17 plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] (  [ framedone#17 plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT) goto plex_irq::@1 [ framedone#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ framedone#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [94] (bool) framedone#3 ← true [ framedone#3 ] (  [ framedone#3 ] ) always clobbers reg byte a 
Statement [96] *((const byte*) BORDERCOL) ← (byte) 0 [ ] (  [ ] ) always clobbers reg byte a 
Statement [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte x reg byte y 
Statement [101] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Statement [103] *((const byte[8]) PLEX_FREE_YPOS + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte y 
Statement [105] (byte~) plexShowSprite::plexFreeAdd1_$2 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT]) PLEX_PTR + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte y 
Statement [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Statement [110] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$11 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$11 ] ) always clobbers reg byte y 
Statement [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$3 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$9 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [114] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ) always clobbers reg byte a 
Statement [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 [ plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2 ] ( plexShowSprite:87 [ framedone#17 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2 ] ) always clobbers reg byte a 
Statement [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#3 ] ( plexShowSprite:87 [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#3 ] ) always clobbers reg byte a 
Statement [120] (byte) plex_sprite_msb#4 ← (byte) 1 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#4 ] ( plexShowSprite:87 [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#4 ] ) always clobbers reg byte a 
Statement [123] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ) always clobbers reg byte a 
Statement [1] (byte) plex_show_idx#0 ← (byte) 0 [ plex_show_idx#0 ] (  [ plex_show_idx#0 ] ) always clobbers reg byte a 
Statement [2] (byte) plex_sprite_idx#0 ← (byte) 0 [ plex_show_idx#0 plex_sprite_idx#0 ] (  [ plex_show_idx#0 plex_sprite_idx#0 ] ) always clobbers reg byte a 
Statement [3] (byte) plex_sprite_msb#0 ← (byte) 1 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 ] ) always clobbers reg byte a 
Statement [4] (byte) plex_free_next#31 ← (byte) 0 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] ) always clobbers reg byte a 
Statement [6] (bool) framedone#17 ← true [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [17] if((bool) framedone#12) goto loop::@3 [ framedone#12 loop::sin_idx#6 ] ( main:8::loop:13 [ framedone#12 loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [18] *((const byte*) BORDERCOL) ← (const byte) RED [ loop::sin_idx#6 ] ( main:8::loop:13 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [21] *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) loop::sy#2) ← *((const byte[$100]) YSIN + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:8::loop:13 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Statement [22] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:8::loop:13 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [28] *((const byte*) BORDERCOL) ← (const byte) GREEN [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [29] (bool) framedone#5 ← false [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [30] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) RASTER) ← (byte) 0 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ( main:8::loop:13 [ framedone#5 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [36] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ) always clobbers reg byte a 
Statement [39] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Statement [42] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [44] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [47] (byte) plex_show_idx#1 ← (byte) 0 [ plex_show_idx#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 ] ) always clobbers reg byte a 
Statement [48] (byte) plex_sprite_idx#1 ← (byte) 0 [ plex_show_idx#1 plex_sprite_idx#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 ] ) always clobbers reg byte a 
Statement [49] (byte) plex_sprite_msb#1 ← (byte) 1 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 ] ) always clobbers reg byte a 
Statement [52] *((const byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plexSort::plexFreePrepare1_s#2 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Statement [55] (byte) plex_free_next#0 ← (byte) 0 [ plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 ] ( main:8::loop:13::plexSort:27 [ loop::sin_idx#1 plex_show_idx#1 plex_sprite_idx#1 plex_sprite_msb#1 plex_free_next#0 ] ) always clobbers reg byte a 
Statement [57] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [60] *((const byte[PLEX_COUNT]) PLEX_PTR + (byte) init::sx#2) ← (byte)(const byte*) SPRITE/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [61] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$9 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#2 init::$9 ] ) always clobbers reg byte a 
Statement [62] *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) init::$9) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [63] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [66] *((const byte*) SPRITES_ENABLE) ← (byte) $ff [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [68] *((const byte*) SPRITES_COLS + (byte) init::ss#2) ← (const byte) GREEN [ init::ss#2 ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 init::ss#2 ] ) always clobbers reg byte a 
Statement [72] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [73] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [74] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [75] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) plex_irq() [ ] ( main:8::init:11 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [85] *((const byte*) BORDERCOL) ← (const byte) WHITE [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 framedone#17 ] ) always clobbers reg byte a 
Statement [88] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS + (byte~) plexShowSprite::plexFreeAdd1_$2) [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte y 
Statement [90] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT) goto plex_irq::@4 [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] ) always clobbers reg byte a 
Statement [92] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER [ framedone#17 plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] (  [ framedone#17 plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT) goto plex_irq::@1 [ framedone#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ framedone#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [94] (bool) framedone#3 ← true [ framedone#3 ] (  [ framedone#3 ] ) always clobbers reg byte a 
Statement [96] *((const byte*) BORDERCOL) ← (byte) 0 [ ] (  [ ] ) always clobbers reg byte a 
Statement [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte x reg byte y 
Statement [101] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte y 
Statement [103] *((const byte[8]) PLEX_FREE_YPOS + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#28 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte y 
Statement [105] (byte~) plexShowSprite::plexFreeAdd1_$2 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT]) PLEX_PTR + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte y 
Statement [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Statement [110] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$11 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$11 ] ) always clobbers reg byte y 
Statement [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$3 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$9 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [114] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ) always clobbers reg byte a 
Statement [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 [ plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2 ] ( plexShowSprite:87 [ framedone#17 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::$6 plexShowSprite::plexFreeAdd1_$2 ] ) always clobbers reg byte a 
Statement [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#3 ] ( plexShowSprite:87 [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#3 ] ) always clobbers reg byte a 
Statement [120] (byte) plex_sprite_msb#4 ← (byte) 1 [ plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#4 ] ( plexShowSprite:87 [ framedone#17 plexShowSprite::$6 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2 plex_sprite_msb#4 ] ) always clobbers reg byte a 
Statement [123] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#28 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ( plexShowSprite:87 [ framedone#17 plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#28 plexShowSprite::plexFreeAdd1_$2 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] : zp ZP_BYTE:3 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ] : zp ZP_BYTE:5 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] : zp ZP_BYTE:6 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] : zp ZP_BYTE:7 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ init::sx#2 init::sx#1 ] : zp ZP_BYTE:8 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:9 [ init::xp#2 init::xp#1 ] : zp ZP_WORD:9 , 
Potential registers zp ZP_BYTE:11 [ init::ss#2 init::ss#1 ] : zp ZP_BYTE:11 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:12 [ plexInit::i#2 plexInit::i#1 ] : zp ZP_BYTE:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ] : zp ZP_BYTE:13 , 
Potential registers zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ] : zp ZP_BYTE:14 , 
Potential registers zp ZP_BYTE:15 [ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ] : zp ZP_BYTE:15 , 
Potential registers zp ZP_BYTE:16 [ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ] : zp ZP_BYTE:16 , 
Potential registers zp ZP_BOOL:17 [ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ] : zp ZP_BOOL:17 , 
Potential registers zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] : zp ZP_BYTE:18 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] : zp ZP_BYTE:19 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:20 [ plexSort::s#2 ] : zp ZP_BYTE:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:21 [ init::$9 ] : zp ZP_BYTE:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:22 [ plex_irq::plexFreeNextYpos1_return#0 ] : zp ZP_BYTE:22 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:23 [ plex_irq::$4 ] : zp ZP_BYTE:23 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] : zp ZP_BYTE:24 , 
Potential registers zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ] : zp ZP_BYTE:25 , reg byte a , reg byte x , 
Potential registers zp ZP_BYTE:26 [ plexShowSprite::plexFreeAdd1_$0 ] : zp ZP_BYTE:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:27 [ plexShowSprite::plexFreeAdd1_$1 ] : zp ZP_BYTE:27 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ] : zp ZP_BYTE:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:29 [ plexShowSprite::$11 ] : zp ZP_BYTE:29 , reg byte x , 
Potential registers zp ZP_BYTE:30 [ plexShowSprite::$2 ] : zp ZP_BYTE:30 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:31 [ plexShowSprite::$3 ] : zp ZP_BYTE:31 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:32 [ plexShowSprite::$9 ] : zp ZP_BYTE:32 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:33 [ plexShowSprite::$5 ] : zp ZP_BYTE:33 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [plexSort] 3,622.83: zp ZP_BYTE:6 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] 303: zp ZP_BYTE:7 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] 202: zp ZP_BYTE:20 [ plexSort::s#2 ] 193.58: zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ] 150.38: zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] 30.3: zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] 
Uplift Scope [] 141.65: zp ZP_BYTE:16 [ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ] 136.36: zp ZP_BYTE:15 [ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ] 134.58: zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ] 133.61: zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ] 108.71: zp ZP_BOOL:17 [ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ] 
Uplift Scope [loop] 252.5: zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ] 246.33: zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] 6.81: zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Uplift Scope [init] 33: zp ZP_BYTE:11 [ init::ss#2 init::ss#1 ] 25.3: zp ZP_BYTE:8 [ init::sx#2 init::sx#1 ] 22: zp ZP_BYTE:21 [ init::$9 ] 15.58: zp ZP_WORD:9 [ init::xp#2 init::xp#1 ] 
Uplift Scope [plexInit] 38.5: zp ZP_BYTE:12 [ plexInit::i#2 plexInit::i#1 ] 
Uplift Scope [plexShowSprite] 4: zp ZP_BYTE:26 [ plexShowSprite::plexFreeAdd1_$0 ] 4: zp ZP_BYTE:27 [ plexShowSprite::plexFreeAdd1_$1 ] 4: zp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ] 4: zp ZP_BYTE:30 [ plexShowSprite::$2 ] 4: zp ZP_BYTE:31 [ plexShowSprite::$3 ] 4: zp ZP_BYTE:32 [ plexShowSprite::$9 ] 4: zp ZP_BYTE:33 [ plexShowSprite::$5 ] 3: zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ] 2: zp ZP_BYTE:29 [ plexShowSprite::$11 ] 0.55: zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] 
Uplift Scope [plex_irq] 11: zp ZP_BYTE:23 [ plex_irq::$4 ] 4: zp ZP_BYTE:22 [ plex_irq::plexFreeNextYpos1_return#0 ] 
Uplift Scope [main] 

Uplifting [plexSort] best 62930 combination reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] zp ZP_BYTE:20 [ plexSort::s#2 ] zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ] zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] 
Limited combination testing to 10 combinations of 972 possible.
Uplifting [] best 62930 combination zp ZP_BYTE:16 [ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ] zp ZP_BYTE:15 [ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ] zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ] zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ] zp ZP_BOOL:17 [ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ] 
Uplifting [loop] best 61000 combination reg byte y [ loop::sy#2 loop::sy#1 ] reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Limited combination testing to 10 combinations of 27 possible.
Uplifting [init] best 60750 combination reg byte x [ init::ss#2 init::ss#1 ] reg byte x [ init::sx#2 init::sx#1 ] zp ZP_BYTE:21 [ init::$9 ] zp ZP_WORD:9 [ init::xp#2 init::xp#1 ] 
Limited combination testing to 10 combinations of 36 possible.
Uplifting [plexInit] best 60630 combination reg byte x [ plexInit::i#2 plexInit::i#1 ] 
Uplifting [plexShowSprite] best 60620 combination reg byte a [ plexShowSprite::plexFreeAdd1_$0 ] reg byte x [ plexShowSprite::plexFreeAdd1_$1 ] zp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ] zp ZP_BYTE:30 [ plexShowSprite::$2 ] zp ZP_BYTE:31 [ plexShowSprite::$3 ] zp ZP_BYTE:32 [ plexShowSprite::$9 ] zp ZP_BYTE:33 [ plexShowSprite::$5 ] zp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ] zp ZP_BYTE:29 [ plexShowSprite::$11 ] zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] 
Limited combination testing to 10 combinations of 98304 possible.
Uplifting [plex_irq] best 60557 combination zp ZP_BYTE:23 [ plex_irq::$4 ] reg byte x [ plex_irq::plexFreeNextYpos1_return#0 ] 
Uplifting [main] best 60557 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:20 [ plexSort::s#2 ]
Uplifting [plexSort] best 59957 combination reg byte x [ plexSort::s#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ]
Uplifting [plexSort] best 59957 combination zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:19 [ plexSort::nxt_y#0 ]
Uplifting [plexSort] best 59957 combination zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:16 [ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ]
Uplifting [] best 59957 combination zp ZP_BYTE:16 [ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:15 [ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ]
Uplifting [] best 59957 combination zp ZP_BYTE:15 [ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ]
Uplifting [] best 59957 combination zp ZP_BYTE:14 [ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ]
Uplifting [] best 59957 combination zp ZP_BYTE:13 [ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ] 
Attempting to uplift remaining variables inzp ZP_BOOL:17 [ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ]
Uplifting [] best 59957 combination zp ZP_BOOL:17 [ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:18 [ plexSort::nxt_idx#0 ]
Uplifting [plexSort] best 59957 combination zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:21 [ init::$9 ]
Uplifting [init] best 59917 combination reg byte a [ init::$9 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:23 [ plex_irq::$4 ]
Uplifting [plex_irq] best 59917 combination zp ZP_BYTE:23 [ plex_irq::$4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Uplifting [loop] best 59917 combination zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:28 [ plexShowSprite::xpos_idx#0 ]
Uplifting [plexShowSprite] best 59911 combination reg byte a [ plexShowSprite::xpos_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:30 [ plexShowSprite::$2 ]
Uplifting [plexShowSprite] best 59905 combination reg byte a [ plexShowSprite::$2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:31 [ plexShowSprite::$3 ]
Uplifting [plexShowSprite] best 59899 combination reg byte a [ plexShowSprite::$3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:32 [ plexShowSprite::$9 ]
Uplifting [plexShowSprite] best 59893 combination reg byte a [ plexShowSprite::$9 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:33 [ plexShowSprite::$5 ]
Uplifting [plexShowSprite] best 59887 combination reg byte x [ plexShowSprite::$5 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:25 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Uplifting [plexShowSprite] best 59878 combination reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:29 [ plexShowSprite::$11 ]
Uplifting [plexShowSprite] best 59871 combination reg byte x [ plexShowSprite::$11 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ]
Uplifting [plexShowSprite] best 59871 combination zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] 
Coalescing zero page register [ zp ZP_BYTE:24 [ plexShowSprite::plex_sprite_idx2#0 ] ] with [ zp ZP_BYTE:23 [ plex_irq::$4 ] ]
Allocated (was zp ZP_BYTE:5) zp ZP_BYTE:3 [ plexSort::m#2 plexSort::m#1 ]
Allocated (was zp ZP_WORD:9) zp ZP_WORD:4 [ init::xp#2 init::xp#1 ]
Allocated (was zp ZP_BYTE:13) zp ZP_BYTE:6 [ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ]
Allocated (was zp ZP_BYTE:14) zp ZP_BYTE:7 [ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ]
Allocated (was zp ZP_BYTE:15) zp ZP_BYTE:8 [ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ]
Allocated (was zp ZP_BYTE:16) zp ZP_BYTE:9 [ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ]
Allocated (was zp ZP_BOOL:17) zp ZP_BOOL:10 [ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ]
Allocated (was zp ZP_BYTE:18) zp ZP_BYTE:11 [ plexSort::nxt_idx#0 ]
Allocated (was zp ZP_BYTE:19) zp ZP_BYTE:12 [ plexSort::nxt_y#0 ]
Allocated (was zp ZP_BYTE:24) zp ZP_BYTE:13 [ plexShowSprite::plex_sprite_idx2#0 plex_irq::$4 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// A simple usage of the flexible sprite multiplexer routine
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label VIC_CONTROL = $d011
  .label D011 = $d011
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Bits for the IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // CIA#1 Interrupt Status & Control Register
  .label CIA1_INTERRUPT = $dc0d
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = $400+$3f8
  .label SPRITE = $2000
  .label plex_show_idx = 7
  .label plex_sprite_idx = 6
  .label plex_sprite_msb = 9
  .label plex_free_next = 8
  .label framedone = $a
  // @begin
__bbegin:
  jmp __b1
  // @1
__b1:
  // [1] (byte) plex_show_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index in the PLEX tables of the next sprite to show
  lda #0
  sta.z plex_show_idx
  // [2] (byte) plex_sprite_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index the next sprite to use for showing (sprites are used round-robin)
  lda #0
  sta.z plex_sprite_idx
  // [3] (byte) plex_sprite_msb#0 ← (byte) 1 -- vbuz1=vbuc1 
  // The MSB bit of the next sprite to use for showing
  lda #1
  sta.z plex_sprite_msb
  jmp __b2
  // @2
__b2:
  // [4] (byte) plex_free_next#31 ← (byte) 0 -- vbuz1=vbuc1 
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  lda #0
  sta.z plex_free_next
  jmp __b3
  // @3
__b3:
  // kickasm(location (const byte*) SPRITE) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  jmp __b4
  // @4
__b4:
  // [6] (bool) framedone#17 ← true -- vboz1=vboc1 
  lda #1
  sta.z framedone
  // [7] phi from @4 to @5 [phi:@4->@5]
__b5_from___b4:
  jmp __b5
  // @5
__b5:
  // [8] call main 
  jsr main
  // [9] phi from @5 to @end [phi:@5->@end]
__bend_from___b5:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // asm { sei  }
    sei
    // [11] call init 
    jsr init
    // [12] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [13] call loop 
    // [15] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from___b1:
    jsr loop
    jmp __breturn
    // main::@return
  __breturn:
    // [14] return 
    rts
}
  // loop
// The raster loop
loop: {
    .label sin_idx = 2
    // [16] phi from loop to loop::@1 [phi:loop->loop::@1]
  __b1_from_loop:
    // [16] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    // [16] phi (byte) plex_free_next#10 = (byte) plex_free_next#31 [phi:loop->loop::@1#1] -- register_copy 
    // [16] phi (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#0 [phi:loop->loop::@1#2] -- register_copy 
    // [16] phi (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#0 [phi:loop->loop::@1#3] -- register_copy 
    // [16] phi (byte) plex_show_idx#10 = (byte) plex_show_idx#0 [phi:loop->loop::@1#4] -- register_copy 
    // [16] phi (bool) framedone#12 = (bool) framedone#17 [phi:loop->loop::@1#5] -- register_copy 
    jmp __b1
    // loop::@1
  __b1:
    jmp __b2
    // loop::@2
  __b2:
    // [17] if((bool) framedone#12) goto loop::@3 -- vboz1_then_la1 
    lda.z framedone
    cmp #0
    bne __b3
    jmp __b2
    // loop::@3
  __b3:
    // [18] *((const byte*) BORDERCOL) ← (const byte) RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
    // [19] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx.z sin_idx
    // [20] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  __b4_from___b3:
    // [20] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
    // [20] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp __b4
    // [20] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  __b4_from___b4:
    // [20] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [20] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp __b4
    // loop::@4
  __b4:
    // [21] *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) loop::sy#2) ← *((const byte[$100]) YSIN + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
    // [22] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
    // [23] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
    // [24] if((byte) loop::sy#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne __b4_from___b4
    jmp __b5
    // loop::@5
  __b5:
    // [25] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc.z sin_idx
    // [26] *((const byte*) BORDERCOL) ← ++ *((const byte*) BORDERCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [27] call plexSort 
    // [32] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from___b5:
    jsr plexSort
    jmp __b6
    // loop::@6
  __b6:
    // [28] *((const byte*) BORDERCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // [29] (bool) framedone#5 ← false -- vboz1=vboc1 
    lda #0
    sta.z framedone
    // [30] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
    // [31] *((const byte*) RASTER) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
    // [16] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
  __b1_from___b6:
    // [16] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
    // [16] phi (byte) plex_free_next#10 = (byte) plex_free_next#0 [phi:loop::@6->loop::@1#1] -- register_copy 
    // [16] phi (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#1 [phi:loop::@6->loop::@1#2] -- register_copy 
    // [16] phi (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#1 [phi:loop::@6->loop::@1#3] -- register_copy 
    // [16] phi (byte) plex_show_idx#10 = (byte) plex_show_idx#1 [phi:loop::@6->loop::@1#4] -- register_copy 
    // [16] phi (bool) framedone#12 = (bool) framedone#5 [phi:loop::@6->loop::@1#5] -- register_copy 
    jmp __b1
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $b
    .label nxt_y = $c
    .label m = 3
    // [33] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  __b1_from_plexSort:
    // [33] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    jmp __b1
    // [33] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  __b1_from___b2:
    // [33] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp __b1
    // plexSort::@1
  __b1:
    // [34] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // [35] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z nxt_idx
    lda PLEX_YPOS,y
    sta.z nxt_y
    // [36] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    jmp __b5
    // plexSort::@5
  __b5:
    // [37] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
    ldx.z m
    // [38] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
  __b3_from___b5:
  __b3_from___b7:
    // [38] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
    jmp __b3
    // plexSort::@3
  __b3:
    // [39] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // [40] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // [41] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq __b4
    jmp __b7
    // plexSort::@7
  __b7:
    // [42] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3_from___b7
    jmp __b4
    // plexSort::@4
  __b4:
    // [43] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // [44] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    jmp __b2
    // plexSort::@2
  __b2:
    // [45] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [46] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1_from___b2
    jmp __b6
    // plexSort::@6
  __b6:
    // [47] (byte) plex_show_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta.z plex_show_idx
    // [48] (byte) plex_sprite_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [49] (byte) plex_sprite_msb#1 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [50] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
  plexFreePrepare1_from___b6:
    jmp plexFreePrepare1
    // plexSort::plexFreePrepare1
  plexFreePrepare1:
    // [51] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1:
    // [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp plexFreePrepare1___b1
    // [51] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1___b1:
    // [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1___b1
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // [52] *((const byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // [53] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [54] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1___b1_from_plexFreePrepare1___b1
    jmp plexFreePrepare1___b2
    // plexSort::plexFreePrepare1_@2
  plexFreePrepare1___b2:
    // [55] (byte) plex_free_next#0 ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    jmp __breturn
    // plexSort::@return
  __breturn:
    // [56] return 
    rts
}
  // init
// Initialize the program
init: {
    .label xp = 4
    // [57] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // [58] call plexInit 
    // [78] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
    // [59] phi from init to init::@1 [phi:init->init::@1]
  __b1_from_init:
    // [59] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #<$20
    sta.z xp
    lda #>$20
    sta.z xp+1
    // [59] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [59] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  __b1_from___b1:
    // [59] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
    // [59] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp __b1
    // init::@1
  __b1:
    // [60] *((const byte[PLEX_COUNT]) PLEX_PTR + (byte) init::sx#2) ← (byte)(const byte*) SPRITE/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta PLEX_PTR,x
    // [61] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [62] *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) init::$9) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda.z xp
    sta PLEX_XPOS,y
    lda.z xp+1
    sta PLEX_XPOS+1,y
    // [63] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc.z xp
    sta.z xp
    bcc !+
    inc.z xp+1
  !:
    // [64] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
    // [65] if((byte) init::sx#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1_from___b1
    jmp __b2
    // init::@2
  __b2:
    // [66] *((const byte*) SPRITES_ENABLE) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [67] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  __b3_from___b2:
    // [67] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b3
    // [67] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  __b3_from___b3:
    // [67] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp __b3
    // init::@3
  __b3:
    // [68] *((const byte*) SPRITES_COLS + (byte) init::ss#2) ← (const byte) GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
    // [69] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
    // [70] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3_from___b3
    jmp __b4
    // init::@4
  __b4:
    // asm { sei  }
    // enable the interrupt
    sei
    // [72] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
    // [73] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // [74] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // [75] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) plex_irq() -- _deref_pptc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
    // asm { cli  }
    cli
    jmp __breturn
    // init::@return
  __breturn:
    // [77] return 
    rts
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    // [79] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
    // plexInit::plexSetScreen1
  plexSetScreen1:
    // [80] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  __b1_from_plexSetScreen1:
    // [80] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [80] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  __b1_from___b1:
    // [80] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp __b1
    // plexInit::@1
  __b1:
    // [81] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // [82] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [83] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1_from___b1
    jmp __breturn
    // plexInit::@return
  __breturn:
    // [84] return 
    rts
}
  // plex_irq
plex_irq: {
    .label __4 = $d
    // entry interrupt(KERNEL_MIN)
    // [85] *((const byte*) BORDERCOL) ← (const byte) WHITE -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
    // [86] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
  __b3_from_plex_irq:
  __b3_from___b7:
    // [86] phi (byte) plex_sprite_msb#28 = (byte) plex_sprite_msb#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#0] -- register_copy 
    // [86] phi (byte) plex_free_next#27 = (byte) plex_free_next#31 [phi:plex_irq/plex_irq::@7->plex_irq::@3#1] -- register_copy 
    // [86] phi (byte) plex_show_idx#27 = (byte) plex_show_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#2] -- register_copy 
    // [86] phi (byte) plex_sprite_idx#25 = (byte) plex_sprite_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#3] -- register_copy 
    jmp __b3
    // plex_irq::@3
  __b3:
    // [87] call plexShowSprite 
    jsr plexShowSprite
    jmp plexFreeNextYpos1
    // plex_irq::plexFreeNextYpos1
  plexFreeNextYpos1:
    // [88] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS + (byte~) plexShowSprite::plexFreeAdd1_$2) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z plexShowSprite.plexFreeAdd1___2
    ldx PLEX_FREE_YPOS,y
    jmp __b6
    // plex_irq::@6
  __b6:
    // [89] (byte~) plex_irq::$4 ← *((const byte*) RASTER) + (byte) 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta.z __4
    // [90] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT) goto plex_irq::@4 -- vbuz1_ge_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcs __b4
    jmp __b7
    // plex_irq::@7
  __b7:
    // [91] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3 -- vbuxx_lt_vbuz1_then_la1 
    cpx.z __4
    bcc __b3_from___b7
    jmp __b4
    // plex_irq::@4
  __b4:
    // [92] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcc __b1
    jmp __b5
    // plex_irq::@5
  __b5:
    // [94] (bool) framedone#3 ← true -- vboz1=vboc1 
    lda #1
    sta.z framedone
    // [95] phi from plex_irq::@1 plex_irq::@5 to plex_irq::@2 [phi:plex_irq::@1/plex_irq::@5->plex_irq::@2]
  __b2_from___b1:
  __b2_from___b5:
    // [95] phi (bool) framedone#10 = (bool) framedone#17 [phi:plex_irq::@1/plex_irq::@5->plex_irq::@2#0] -- register_copy 
    jmp __b2
    // plex_irq::@2
  __b2:
    // [96] *((const byte*) BORDERCOL) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDERCOL
    jmp __breturn
    // plex_irq::@return
  __breturn:
    // [97] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
    // plex_irq::@1
  __b1:
    // [98] *((const byte*) RASTER) ← (byte) plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuxx 
    stx RASTER
    jmp __b2_from___b1
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label __6 = 6
    .label plexFreeAdd1___2 = 8
    .label plex_sprite_idx2 = $d
    // [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // [101] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
    // plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
    // [102] (byte~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
    // [103] *((const byte[8]) PLEX_FREE_YPOS + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // [104] (byte~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#27 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_free_next
    inx
    // [105] (byte~) plexShowSprite::plexFreeAdd1_$2 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plexFreeAdd1___2
    jmp __b5
    // plexShowSprite::@5
  __b5:
    // [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT]) PLEX_PTR + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx.z plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
    // [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
    // [110] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // [112] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b1
    jmp __b3
    // plexShowSprite::@3
  __b3:
    // [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // [114] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    jmp __b2
    // plexShowSprite::@2
  __b2:
    // [115] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#25 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z __6
    // [117] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27 -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // [118] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#28 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne __breturn_from___b2
    jmp __b4
    // plexShowSprite::@4
  __b4:
    // [120] (byte) plex_sprite_msb#4 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [121] phi from plexShowSprite::@2 plexShowSprite::@4 to plexShowSprite::@return [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return]
  __breturn_from___b2:
  __breturn_from___b4:
    // [121] phi (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return#0] -- register_copy 
    jmp __breturn
    // plexShowSprite::@return
  __breturn:
    // [122] return 
    rts
    // plexShowSprite::@1
  __b1:
    // [123] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#28 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // File Data
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  .align $100
YSIN:
.var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b7
Removing instruction jmp __b4
Removing instruction jmp __b2
Removing instruction jmp __b6
Removing instruction jmp plexFreePrepare1
Removing instruction jmp plexFreePrepare1___b1
Removing instruction jmp plexFreePrepare1___b2
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp plexSetScreen1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp plexFreeNextYpos1
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp plexFreeAdd1
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Replacing instruction ldy.z nxt_idx with TAY
Removing instruction lda.z nxt_y
Removing instruction lda #0
Removing instruction lda #IRQ_RASTER
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __bbegin with __b1
Replacing label __b4_from___b4 with __b4
Replacing label __b1 with __b2
Replacing label __b3_from___b7 with __b3
Replacing label __b1_from___b2 with __b1
Replacing label plexFreePrepare1___b1_from_plexFreePrepare1___b1 with plexFreePrepare1___b1
Replacing label __b1_from___b1 with __b1
Replacing label __b3_from___b3 with __b3
Replacing label __b1_from___b1 with __b1
Replacing label __b3_from___b7 with __b3
Replacing label __b2_from___b1 with __b2
Replacing label __breturn_from___b2 with __breturn
Removing instruction __bbegin:
Removing instruction __b3:
Removing instruction __b5_from___b4:
Removing instruction __bend_from___b5:
Removing instruction __b1_from_main:
Removing instruction loop_from___b1:
Removing instruction __b1:
Removing instruction __b4_from___b4:
Removing instruction __b1_from___b2:
Removing instruction __b3_from___b5:
Removing instruction __b3_from___b7:
Removing instruction plexFreePrepare1_from___b6:
Removing instruction plexFreePrepare1___b1_from_plexFreePrepare1:
Removing instruction plexFreePrepare1___b1_from_plexFreePrepare1___b1:
Removing instruction __b1_from___b1:
Removing instruction __b3_from___b3:
Removing instruction plexSetScreen1_from_plexInit:
Removing instruction __b1_from_plexSetScreen1:
Removing instruction __b1_from___b1:
Removing instruction __b3_from_plex_irq:
Removing instruction __b3_from___b7:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b5:
Removing instruction __breturn_from___b2:
Removing instruction __breturn_from___b4:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b2:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __bend:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b1_from_loop:
Removing instruction __b4_from___b3:
Removing instruction __b5:
Removing instruction plexSort_from___b5:
Removing instruction __b6:
Removing instruction __b1_from___b6:
Removing instruction __b1_from_plexSort:
Removing instruction __b5:
Removing instruction __b7:
Removing instruction __b6:
Removing instruction plexFreePrepare1:
Removing instruction plexFreePrepare1___b2:
Removing instruction __breturn:
Removing instruction plexInit_from_init:
Removing instruction __b1_from_init:
Removing instruction __b2:
Removing instruction __b3_from___b2:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction plexSetScreen1:
Removing instruction __breturn:
Removing instruction plexFreeNextYpos1:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b5:
Removing instruction __breturn:
Removing instruction plexFreeAdd1:
Removing instruction __b5:
Removing instruction __b3:
Removing instruction __b4:
Succesful ASM optimization Pass5UnusedLabelElimination
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts
Removing instruction jmp __b4
Removing instruction jmp __b1
Removing instruction jmp plexFreePrepare1___b1
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldx.z m
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination

FINAL SYMBOL TABLE
(label) @1
(label) @2
(label) @3
(label) @4
(label) @5
(label) @begin
(label) @end
(const byte*) BORDERCOL BORDERCOL = (byte*) 53280
(const byte*) CIA1_INTERRUPT CIA1_INTERRUPT = (byte*) 56333
(const byte) CIA_INTERRUPT_CLEAR CIA_INTERRUPT_CLEAR = (byte) $7f
(const byte*) D011 D011 = (byte*) 53265
(const byte) GREEN GREEN = (byte) 5
(const byte*) IRQ_ENABLE IRQ_ENABLE = (byte*) 53274
(const byte) IRQ_RASTER IRQ_RASTER = (byte) 1
(const byte*) IRQ_STATUS IRQ_STATUS = (byte*) 53273
(const void()**) KERNEL_IRQ KERNEL_IRQ = (void()**) 788
(const byte) PLEX_COUNT PLEX_COUNT = (byte) $20
(const byte[8]) PLEX_FREE_YPOS PLEX_FREE_YPOS = { fill( 8, 0) }
(const byte[PLEX_COUNT]) PLEX_PTR PLEX_PTR = { fill( PLEX_COUNT, 0) }
(byte*) PLEX_SCREEN_PTR
(const byte*) PLEX_SCREEN_PTR#0 PLEX_SCREEN_PTR = (byte*)(number) $400+(number) $3f8
(const byte[PLEX_COUNT]) PLEX_SORTED_IDX PLEX_SORTED_IDX = { fill( PLEX_COUNT, 0) }
(const word[PLEX_COUNT]) PLEX_XPOS PLEX_XPOS = { fill( PLEX_COUNT, 0) }
(const byte[PLEX_COUNT]) PLEX_YPOS PLEX_YPOS = { fill( PLEX_COUNT, 0) }
(const byte*) RASTER RASTER = (byte*) 53266
(const byte) RED RED = (byte) 2
(const byte*) SPRITE SPRITE = (byte*) 8192
(const byte*) SPRITES_COLS SPRITES_COLS = (byte*) 53287
(const byte*) SPRITES_ENABLE SPRITES_ENABLE = (byte*) 53269
(const byte*) SPRITES_XMSB SPRITES_XMSB = (byte*) 53264
(const byte*) SPRITES_XPOS SPRITES_XPOS = (byte*) 53248
(const byte*) SPRITES_YPOS SPRITES_YPOS = (byte*) 53249
(const byte*) VIC_CONTROL VIC_CONTROL = (byte*) 53265
(const byte) VIC_DEN VIC_DEN = (byte) $10
(const byte) VIC_RSEL VIC_RSEL = (byte) 8
(const byte) WHITE WHITE = (byte) 1
(const byte[$100]) YSIN YSIN = kickasm {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
(bool) framedone
(bool) framedone#10 framedone zp ZP_BOOL:10 40.0
(bool) framedone#12 framedone zp ZP_BOOL:10 57.0
(bool) framedone#17 framedone zp ZP_BOOL:10 0.375
(bool) framedone#3 framedone zp ZP_BOOL:10 4.0
(bool) framedone#5 framedone zp ZP_BOOL:10 7.333333333333333
(void()) init()
(byte~) init::$9 reg byte a 22.0
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@return
(byte) init::ss
(byte) init::ss#1 reg byte x 16.5
(byte) init::ss#2 reg byte x 16.5
(byte) init::sx
(byte) init::sx#1 reg byte x 16.5
(byte) init::sx#2 reg byte x 8.8
(word) init::xp
(word) init::xp#1 xp zp ZP_WORD:4 7.333333333333333
(word) init::xp#2 xp zp ZP_WORD:4 8.25
(void()) loop()
(label) loop::@1
(label) loop::@2
(label) loop::@3
(label) loop::@4
(label) loop::@5
(label) loop::@6
(byte) loop::sin_idx
(byte) loop::sin_idx#1 sin_idx zp ZP_BYTE:2 3.142857142857143
(byte) loop::sin_idx#6 sin_idx zp ZP_BYTE:2 3.666666666666667
(byte) loop::sy
(byte) loop::sy#1 reg byte y 151.5
(byte) loop::sy#2 reg byte y 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 reg byte x 67.33333333333333
(byte) loop::y_idx#2 reg byte x 157.0
(byte~) loop::y_idx#4 reg byte x 22.0
(void()) main()
(label) main::@1
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(label) plexInit::@1
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#1 reg byte x 16.5
(byte) plexInit::i#2 reg byte x 22.0
(label) plexInit::plexSetScreen1
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 reg byte x 2.0
(byte~) plexShowSprite::$2 reg byte a 4.0
(byte~) plexShowSprite::$3 reg byte a 4.0
(byte~) plexShowSprite::$5 reg byte x 4.0
(byte~) plexShowSprite::$6 $6 zp ZP_BYTE:6 1.0833333333333333
(byte~) plexShowSprite::$9 reg byte a 4.0
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@3
(label) plexShowSprite::@4
(label) plexShowSprite::@5
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(byte~) plexShowSprite::plexFreeAdd1_$0 reg byte a 4.0
(byte~) plexShowSprite::plexFreeAdd1_$1 reg byte x 4.0
(byte~) plexShowSprite::plexFreeAdd1_$2 plexFreeAdd1_$2 zp ZP_BYTE:8 1.0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 reg byte a 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 plex_sprite_idx2 zp ZP_BYTE:13 0.5454545454545454
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 reg byte a 4.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@7
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#1 m zp ZP_BYTE:3 151.5
(byte) plexSort::m#2 m zp ZP_BYTE:3 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 nxt_idx zp ZP_BYTE:11 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 nxt_y zp ZP_BYTE:12 150.375
(label) plexSort::plexFreePrepare1
(label) plexSort::plexFreePrepare1_@1
(label) plexSort::plexFreePrepare1_@2
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 reg byte x 151.5
(byte) plexSort::plexFreePrepare1_s#2 reg byte x 151.5
(byte) plexSort::s
(byte) plexSort::s#1 reg byte x 1368.3333333333335
(byte) plexSort::s#2 reg byte x 202.0
(byte) plexSort::s#3 reg byte x 2052.5
(byte~) plexSort::s#6 reg byte x 202.0
(byte) plex_free_next
(byte) plex_free_next#0 plex_free_next zp ZP_BYTE:8 1.8571428571428572
(byte) plex_free_next#10 plex_free_next zp ZP_BYTE:8 130.0
(byte) plex_free_next#27 plex_free_next zp ZP_BYTE:8 2.8333333333333335
(byte) plex_free_next#31 plex_free_next zp ZP_BYTE:8 0.6666666666666666
interrupt(KERNEL_MIN)(void()) plex_irq()
(byte~) plex_irq::$4 $4 zp ZP_BYTE:13 11.0
(label) plex_irq::@1
(label) plex_irq::@2
(label) plex_irq::@3
(label) plex_irq::@4
(label) plex_irq::@5
(label) plex_irq::@6
(label) plex_irq::@7
(label) plex_irq::@return
(label) plex_irq::plexFreeNextYpos1
(byte) plex_irq::plexFreeNextYpos1_return
(byte) plex_irq::plexFreeNextYpos1_return#0 reg byte x 4.0
(byte) plex_irq::rasterY
(byte) plex_show_idx
(byte) plex_show_idx#0 plex_show_idx zp ZP_BYTE:7 0.5
(byte) plex_show_idx#1 plex_show_idx zp ZP_BYTE:7 0.8666666666666666
(byte) plex_show_idx#10 plex_show_idx zp ZP_BYTE:7 130.0
(byte) plex_show_idx#16 plex_show_idx zp ZP_BYTE:7 2.1666666666666665
(byte) plex_show_idx#27 plex_show_idx zp ZP_BYTE:7 1.05
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0 plex_sprite_idx zp ZP_BYTE:6 0.5454545454545454
(byte) plex_sprite_idx#1 plex_sprite_idx zp ZP_BYTE:6 0.9285714285714286
(byte) plex_sprite_idx#10 plex_sprite_idx zp ZP_BYTE:6 130.0
(byte) plex_sprite_idx#25 plex_sprite_idx zp ZP_BYTE:6 1.0555555555555558
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0 plex_sprite_msb zp ZP_BYTE:9 0.6000000000000001
(byte) plex_sprite_msb#1 plex_sprite_msb zp ZP_BYTE:9 1.0
(byte) plex_sprite_msb#11 plex_sprite_msb zp ZP_BYTE:9 130.0
(byte) plex_sprite_msb#17 plex_sprite_msb zp ZP_BYTE:9 2.142857142857143
(byte) plex_sprite_msb#28 plex_sprite_msb zp ZP_BYTE:9 0.9047619047619048
(byte) plex_sprite_msb#3 plex_sprite_msb zp ZP_BYTE:9 3.0
(byte) plex_sprite_msb#4 plex_sprite_msb zp ZP_BYTE:9 4.0

zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
reg byte y [ loop::sy#2 loop::sy#1 ]
zp ZP_BYTE:3 [ plexSort::m#2 plexSort::m#1 ]
reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
reg byte x [ init::sx#2 init::sx#1 ]
zp ZP_WORD:4 [ init::xp#2 init::xp#1 ]
reg byte x [ init::ss#2 init::ss#1 ]
reg byte x [ plexInit::i#2 plexInit::i#1 ]
zp ZP_BYTE:6 [ plex_sprite_idx#25 plex_sprite_idx#10 plex_sprite_idx#0 plex_sprite_idx#1 plexShowSprite::$6 ]
zp ZP_BYTE:7 [ plex_show_idx#27 plex_show_idx#10 plex_show_idx#0 plex_show_idx#1 plex_show_idx#16 ]
zp ZP_BYTE:8 [ plex_free_next#27 plex_free_next#10 plex_free_next#31 plex_free_next#0 plexShowSprite::plexFreeAdd1_$2 ]
zp ZP_BYTE:9 [ plex_sprite_msb#28 plex_sprite_msb#11 plex_sprite_msb#0 plex_sprite_msb#1 plex_sprite_msb#17 plex_sprite_msb#3 plex_sprite_msb#4 ]
zp ZP_BOOL:10 [ framedone#10 framedone#12 framedone#17 framedone#5 framedone#3 ]
zp ZP_BYTE:11 [ plexSort::nxt_idx#0 ]
zp ZP_BYTE:12 [ plexSort::nxt_y#0 ]
reg byte x [ plexSort::s#2 ]
reg byte a [ init::$9 ]
reg byte x [ plex_irq::plexFreeNextYpos1_return#0 ]
zp ZP_BYTE:13 [ plexShowSprite::plex_sprite_idx2#0 plex_irq::$4 ]
reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$0 ]
reg byte x [ plexShowSprite::plexFreeAdd1_$1 ]
reg byte a [ plexShowSprite::xpos_idx#0 ]
reg byte x [ plexShowSprite::$11 ]
reg byte a [ plexShowSprite::$2 ]
reg byte a [ plexShowSprite::$3 ]
reg byte a [ plexShowSprite::$9 ]
reg byte x [ plexShowSprite::$5 ]


FINAL ASSEMBLER
Score: 46296

  // File Comments
// A simple usage of the flexible sprite multiplexer routine
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__b1)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label VIC_CONTROL = $d011
  .label D011 = $d011
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Bits for the IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // CIA#1 Interrupt Status & Control Register
  .label CIA1_INTERRUPT = $dc0d
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = $400+$3f8
  .label SPRITE = $2000
  .label plex_show_idx = 7
  .label plex_sprite_idx = 6
  .label plex_sprite_msb = 9
  .label plex_free_next = 8
  .label framedone = $a
  // @begin
  // @1
__b1:
  // plex_show_idx=0
  // [1] (byte) plex_show_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index in the PLEX tables of the next sprite to show
  lda #0
  sta.z plex_show_idx
  // plex_sprite_idx=0
  // [2] (byte) plex_sprite_idx#0 ← (byte) 0 -- vbuz1=vbuc1 
  // The index the next sprite to use for showing (sprites are used round-robin)
  sta.z plex_sprite_idx
  // plex_sprite_msb=1
  // [3] (byte) plex_sprite_msb#0 ← (byte) 1 -- vbuz1=vbuc1 
  // The MSB bit of the next sprite to use for showing
  lda #1
  sta.z plex_sprite_msb
  // @2
  // plex_free_next = 0
  // [4] (byte) plex_free_next#31 ← (byte) 0 -- vbuz1=vbuc1 
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  lda #0
  sta.z plex_free_next
  // @3
  // kickasm
  // kickasm(location (const byte*) SPRITE) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  // @4
  // framedone = true
  // [6] (bool) framedone#17 ← true -- vboz1=vboc1 
  lda #1
  sta.z framedone
  // [7] phi from @4 to @5 [phi:@4->@5]
  // @5
  // [8] call main 
  jsr main
  rts
  // [9] phi from @5 to @end [phi:@5->@end]
  // @end
  // main
main: {
    // asm
    // asm { sei  }
    sei
    // init()
    // [11] call init 
    jsr init
    // [12] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // loop()
    // [13] call loop 
    // [15] phi from main::@1 to loop [phi:main::@1->loop]
    jsr loop
    // main::@return
    // }
    // [14] return 
    rts
}
  // loop
// The raster loop
loop: {
    .label sin_idx = 2
    // [16] phi from loop to loop::@1 [phi:loop->loop::@1]
    // [16] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    // [16] phi (byte) plex_free_next#10 = (byte) plex_free_next#31 [phi:loop->loop::@1#1] -- register_copy 
    // [16] phi (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#0 [phi:loop->loop::@1#2] -- register_copy 
    // [16] phi (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#0 [phi:loop->loop::@1#3] -- register_copy 
    // [16] phi (byte) plex_show_idx#10 = (byte) plex_show_idx#0 [phi:loop->loop::@1#4] -- register_copy 
    // [16] phi (bool) framedone#12 = (bool) framedone#17 [phi:loop->loop::@1#5] -- register_copy 
    // loop::@1
    // loop::@2
  __b2:
    // while(!framedone)
    // [17] if((bool) framedone#12) goto loop::@3 -- vboz1_then_la1 
    lda.z framedone
    cmp #0
    bne __b3
    jmp __b2
    // loop::@3
  __b3:
    // *BORDERCOL = RED
    // [18] *((const byte*) BORDERCOL) ← (const byte) RED -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
    // [19] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx.z sin_idx
    // [20] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
    // [20] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
    // [20] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    // [20] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
    // [20] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [20] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    // loop::@4
  __b4:
    // PLEX_YPOS[sy] = YSIN[y_idx]
    // [21] *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) loop::sy#2) ← *((const byte[$100]) YSIN + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
    // y_idx += 8
    // [22] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
    // for(byte sy: 0..PLEX_COUNT-1)
    // [23] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
    // [24] if((byte) loop::sy#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne __b4
    // loop::@5
    // sin_idx +=1
    // [25] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc.z sin_idx
    // (*BORDERCOL)++;
    // [26] *((const byte*) BORDERCOL) ← ++ *((const byte*) BORDERCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // plexSort()
    // [27] call plexSort 
    // [32] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
    jsr plexSort
    // loop::@6
    // *BORDERCOL = GREEN
    // [28] *((const byte*) BORDERCOL) ← (const byte) GREEN -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
    // framedone = false
    // [29] (bool) framedone#5 ← false -- vboz1=vboc1 
    lda #0
    sta.z framedone
    // *VIC_CONTROL &=$7f
    // [30] *((const byte*) VIC_CONTROL) ← *((const byte*) VIC_CONTROL) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
    // *RASTER = $0
    // [31] *((const byte*) RASTER) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
    // [16] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
    // [16] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
    // [16] phi (byte) plex_free_next#10 = (byte) plex_free_next#0 [phi:loop::@6->loop::@1#1] -- register_copy 
    // [16] phi (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#1 [phi:loop::@6->loop::@1#2] -- register_copy 
    // [16] phi (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#1 [phi:loop::@6->loop::@1#3] -- register_copy 
    // [16] phi (byte) plex_show_idx#10 = (byte) plex_show_idx#1 [phi:loop::@6->loop::@1#4] -- register_copy 
    // [16] phi (bool) framedone#12 = (bool) framedone#5 [phi:loop::@6->loop::@1#5] -- register_copy 
    jmp __b2
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $b
    .label nxt_y = $c
    .label m = 3
    // [33] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
    // [33] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    // [33] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
    // [33] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    // plexSort::@1
  __b1:
    // nxt_idx = PLEX_SORTED_IDX[m+1]
    // [34] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // nxt_y = PLEX_YPOS[nxt_idx]
    // [35] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    tay
    lda PLEX_YPOS,y
    sta.z nxt_y
    // if(nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[m]])
    // [36] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    // plexSort::@5
    // [37] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
    // [38] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
    // [38] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
    // plexSort::@3
  __b3:
    // PLEX_SORTED_IDX[s+1] = PLEX_SORTED_IDX[s]
    // [39] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // s--;
    // [40] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // while((s!=$ff) && (nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[s]]))
    // [41] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq __b4
    // plexSort::@7
    // [42] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3
    // plexSort::@4
  __b4:
    // s++;
    // [43] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // PLEX_SORTED_IDX[s] = nxt_idx
    // [44] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    // plexSort::@2
  __b2:
    // for(byte m: 0..PLEX_COUNT-2)
    // [45] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [46] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1
    // plexSort::@6
    // plex_show_idx = 0
    // [47] (byte) plex_show_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta.z plex_show_idx
    // plex_sprite_idx = 0
    // [48] (byte) plex_sprite_idx#1 ← (byte) 0 -- vbuz1=vbuc1 
    sta.z plex_sprite_idx
    // plex_sprite_msb = 1
    // [49] (byte) plex_sprite_msb#1 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [50] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
    // plexSort::plexFreePrepare1
    // [51] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
    // [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [51] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
    // [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // PLEX_FREE_YPOS[s] = 0
    // [52] *((const byte[8]) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // for( byte s: 0..7)
    // [53] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [54] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1___b1
    // plexSort::plexFreePrepare1_@2
    // plex_free_next = 0
    // [55] (byte) plex_free_next#0 ← (byte) 0 -- vbuz1=vbuc1 
    sta.z plex_free_next
    // plexSort::@return
    // }
    // [56] return 
    rts
}
  // init
// Initialize the program
init: {
    .label xp = 4
    // *D011 = VIC_DEN | VIC_RSEL | 3
    // [57] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // plexInit(SCREEN)
    // [58] call plexInit 
    // [78] phi from init to plexInit [phi:init->plexInit]
    jsr plexInit
    // [59] phi from init to init::@1 [phi:init->init::@1]
    // [59] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #<$20
    sta.z xp
    lda #>$20
    sta.z xp+1
    // [59] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [59] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
    // [59] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
    // [59] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    // init::@1
  __b1:
    // PLEX_PTR[sx] = (byte)(SPRITE/$40)
    // [60] *((const byte[PLEX_COUNT]) PLEX_PTR + (byte) init::sx#2) ← (byte)(const byte*) SPRITE/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta PLEX_PTR,x
    // PLEX_XPOS[sx] = xp
    // [61] (byte~) init::$9 ← (byte) init::sx#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [62] *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) init::$9) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda.z xp
    sta PLEX_XPOS,y
    lda.z xp+1
    sta PLEX_XPOS+1,y
    // xp += 9
    // [63] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc.z xp
    sta.z xp
    bcc !+
    inc.z xp+1
  !:
    // for(byte sx: 0..PLEX_COUNT-1)
    // [64] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
    // [65] if((byte) init::sx#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1
    // init::@2
    // *SPRITES_ENABLE = $ff
    // [66] *((const byte*) SPRITES_ENABLE) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [67] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
    // [67] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    // [67] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
    // [67] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    // init::@3
  __b3:
    // SPRITES_COLS[ss] = GREEN
    // [68] *((const byte*) SPRITES_COLS + (byte) init::ss#2) ← (const byte) GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
    // for(byte ss: 0..7)
    // [69] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
    // [70] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3
    // init::@4
    // asm
    // asm { sei  }
    // enable the interrupt
    sei
    // *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR
    // [72] *((const byte*) CIA1_INTERRUPT) ← (const byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
    // *IRQ_ENABLE = IRQ_RASTER
    // [73] *((const byte*) IRQ_ENABLE) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
    // *IRQ_STATUS = IRQ_RASTER
    // [74] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    sta IRQ_STATUS
    // *KERNEL_IRQ = &plex_irq
    // [75] *((const void()**) KERNEL_IRQ) ← &interrupt(KERNEL_MIN)(void()) plex_irq() -- _deref_pptc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
    // asm
    // asm { cli  }
    cli
    // init::@return
    // }
    // [77] return 
    rts
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    // [79] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
    // plexInit::plexSetScreen1
    // [80] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
    // [80] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [80] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
    // [80] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    // plexInit::@1
  __b1:
    // PLEX_SORTED_IDX[i] = i
    // [81] *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // for(byte i: 0..PLEX_COUNT-1)
    // [82] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [83] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1
    // plexInit::@return
    // }
    // [84] return 
    rts
}
  // plex_irq
plex_irq: {
    .label __4 = $d
    // entry interrupt(KERNEL_MIN)
    // *BORDERCOL = WHITE
    // [85] *((const byte*) BORDERCOL) ← (const byte) WHITE -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
    // [86] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
    // [86] phi (byte) plex_sprite_msb#28 = (byte) plex_sprite_msb#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#0] -- register_copy 
    // [86] phi (byte) plex_free_next#27 = (byte) plex_free_next#31 [phi:plex_irq/plex_irq::@7->plex_irq::@3#1] -- register_copy 
    // [86] phi (byte) plex_show_idx#27 = (byte) plex_show_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#2] -- register_copy 
    // [86] phi (byte) plex_sprite_idx#25 = (byte) plex_sprite_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#3] -- register_copy 
    // plex_irq::@3
  __b3:
    // plexShowSprite()
    // [87] call plexShowSprite 
    jsr plexShowSprite
    // plex_irq::plexFreeNextYpos1
    // return PLEX_FREE_YPOS[plex_free_next];
    // [88] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS + (byte~) plexShowSprite::plexFreeAdd1_$2) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z plexShowSprite.plexFreeAdd1___2
    ldx PLEX_FREE_YPOS,y
    // plex_irq::@6
    // *RASTER+2
    // [89] (byte~) plex_irq::$4 ← *((const byte*) RASTER) + (byte) 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta.z __4
    // while (plex_show_idx < PLEX_COUNT && rasterY < *RASTER+2)
    // [90] if((byte) plex_show_idx#16>=(const byte) PLEX_COUNT) goto plex_irq::@4 -- vbuz1_ge_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcs __b4
    // plex_irq::@7
    // [91] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte~) plex_irq::$4) goto plex_irq::@3 -- vbuxx_lt_vbuz1_then_la1 
    cpx.z __4
    bcc __b3
    // plex_irq::@4
  __b4:
    // *IRQ_STATUS = IRQ_RASTER
    // [92] *((const byte*) IRQ_STATUS) ← (const byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
    // if (plex_show_idx<PLEX_COUNT)
    // [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda.z plex_show_idx
    cmp #PLEX_COUNT
    bcc __b1
    // plex_irq::@5
    // framedone = true
    // [94] (bool) framedone#3 ← true -- vboz1=vboc1 
    lda #1
    sta.z framedone
    // [95] phi from plex_irq::@1 plex_irq::@5 to plex_irq::@2 [phi:plex_irq::@1/plex_irq::@5->plex_irq::@2]
    // [95] phi (bool) framedone#10 = (bool) framedone#17 [phi:plex_irq::@1/plex_irq::@5->plex_irq::@2#0] -- register_copy 
    // plex_irq::@2
  __b2:
    // *BORDERCOL = 0
    // [96] *((const byte*) BORDERCOL) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDERCOL
    // plex_irq::@return
    // }
    // [97] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
    // plex_irq::@1
  __b1:
    // *RASTER = rasterY
    // [98] *((const byte*) RASTER) ← (byte) plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuxx 
    stx RASTER
    jmp __b2
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label __6 = 6
    .label plexFreeAdd1___2 = 8
    .label plex_sprite_idx2 = $d
    // plex_sprite_idx2 = plex_sprite_idx*2
    // [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // ypos = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]]
    // [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT]) PLEX_YPOS + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // SPRITES_YPOS[plex_sprite_idx2] = ypos
    // [101] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    // plexShowSprite::plexFreeAdd1
    // ypos+21
    // [102] (byte~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
    // PLEX_FREE_YPOS[plex_free_next] =  ypos+21
    // [103] *((const byte[8]) PLEX_FREE_YPOS + (byte) plex_free_next#27) ← (byte~) plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // plex_free_next+1
    // [104] (byte~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#27 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_free_next
    inx
    // (plex_free_next+1)&7
    // [105] (byte~) plexShowSprite::plexFreeAdd1_$2 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plexFreeAdd1___2
    // plexShowSprite::@5
    // PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]]
    // [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT]) PLEX_PTR + *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx.z plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
    // xpos_idx = PLEX_SORTED_IDX[plex_show_idx]
    // [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT]) PLEX_SORTED_IDX + (byte) plex_show_idx#27) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // <PLEX_XPOS[xpos_idx]
    // [108] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [109] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
    // SPRITES_XPOS[plex_sprite_idx2] = <PLEX_XPOS[xpos_idx]
    // [110] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // >PLEX_XPOS[xpos_idx]
    // [111] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT]) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // if(>PLEX_XPOS[xpos_idx]!=0)
    // [112] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b1
    // plexShowSprite::@3
    // $ff^plex_sprite_msb
    // [113] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#28 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // *SPRITES_XMSB &= ($ff^plex_sprite_msb)
    // [114] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    // plexShowSprite::@2
  __b2:
    // plex_sprite_idx+1
    // [115] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#25 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // (plex_sprite_idx+1)&7
    // [116] (byte~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z __6
    // plex_show_idx++;
    // [117] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27 -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // plex_sprite_msb <<=1
    // [118] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#28 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // if(plex_sprite_msb==0)
    // [119] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne __breturn
    // plexShowSprite::@4
    // plex_sprite_msb = 1
    // [120] (byte) plex_sprite_msb#4 ← (byte) 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [121] phi from plexShowSprite::@2 plexShowSprite::@4 to plexShowSprite::@return [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return]
    // [121] phi (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return#0] -- register_copy 
    // plexShowSprite::@return
  __breturn:
    // }
    // [122] return 
    rts
    // plexShowSprite::@1
  __b1:
    // *SPRITES_XMSB |= plex_sprite_msb
    // [123] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#28 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // File Data
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  .align $100
YSIN:
.var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


