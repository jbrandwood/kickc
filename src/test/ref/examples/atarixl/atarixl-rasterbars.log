Resolved forward reference DISPLAY_LIST to DISPLAY_LIST
Fixing struct type size struct ATARI_GTIA_READ to 32
Fixing struct type size struct ATARI_POKEY_READ to 16
Fixing struct type SIZE_OF struct ATARI_GTIA_READ to 32
Fixing struct type SIZE_OF struct ATARI_POKEY_READ to 16
Fixing struct type SIZE_OF struct ATARI_GTIA_READ to 32
Fixing struct type SIZE_OF struct ATARI_POKEY_READ to 16
Inlined call call __init

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  asm { sei  }
  *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DMACTL) = $21
  *((char **)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST) = DISPLAY_LIST
  *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0) = $28
  *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1) = $48
  *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2) = $80
  *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3) = $c8
  main::col#0 = 0
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@5
  main::col#3 = phi( main/main::col#0, main::@1/main::col#3, main::@5/main::col#4 )
  main::$0 = *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT) != $28
  if(main::$0) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  main::col#2 = phi( main::@1/main::col#3 )
  main::c#0 = main::col#2
  main::col#1 = ++ main::col#2
  main::l#0 = 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  main::col#5 = phi( main::@2/main::col#1, main::@4/main::col#6 )
  main::c#3 = phi( main::@2/main::c#0, main::@4/main::c#1 )
  main::l#2 = phi( main::@2/main::l#0, main::@4/main::l#1 )
  main::$1 = main::l#2 < $64
  if(main::$1) goto main::@4
  to:main::@5
main::@4: scope:[main]  from main::@3
  main::col#6 = phi( main::@3/main::col#5 )
  main::l#3 = phi( main::@3/main::l#2 )
  main::c#2 = phi( main::@3/main::c#3 )
  *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_WSYNC) = main::c#2
  *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = main::c#2
  main::c#1 = ++ main::c#2
  main::l#1 = ++ main::l#3
  to:main::@3
main::@5: scope:[main]  from main::@3
  main::col#4 = phi( main::@3/main::col#5 )
  *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = 0
  to:main::@1
main::@return: scope:[main]  from
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
__constant struct ATARI_ANTIC * const ANTIC = (struct ATARI_ANTIC *)$d400
__constant const char BLANK4 = $30
__constant const char BLANK8 = $70
__constant char DISPLAY_LIST[] = { BLANK8, BLANK8, BLANK8, LMS|MODE7, byte0 TEXT, byte1 TEXT, BLANK4, MODE2, JVB, byte0 DISPLAY_LIST, byte1 DISPLAY_LIST }
__constant struct ATARI_GTIA_WRITE * const GTIA = (struct ATARI_GTIA_WRITE *)$d000
__constant const char JVB = $41
__constant const char LMS = $40
__constant const char MODE2 = 2
__constant const char MODE7 = 7
__constant char OFFSET_STRUCT_ATARI_ANTIC_DLIST = 2
__constant char OFFSET_STRUCT_ATARI_ANTIC_DMACTL = 0
__constant char OFFSET_STRUCT_ATARI_ANTIC_VCOUNT = $b
__constant char OFFSET_STRUCT_ATARI_ANTIC_WSYNC = $a
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK = $1a
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0 = $16
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1 = $17
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2 = $18
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3 = $19
__constant char TEXT[] = "HELLO atari 8BITDemonstrates ANTIC display list!"sa
void __start()
void main()
bool main::$0
bool main::$1
char main::c
char main::c#0
char main::c#1
char main::c#2
char main::c#3
char main::col
char main::col#0
char main::col#1
char main::col#2
char main::col#3
char main::col#4
char main::col#5
char main::col#6
char main::l
char main::l#0
char main::l#1
char main::l#2
char main::l#3

Adding number conversion cast (unumber) $21 in *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DMACTL) = $21
Adding number conversion cast (unumber) $28 in *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0) = $28
Adding number conversion cast (unumber) $48 in *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1) = $48
Adding number conversion cast (unumber) $80 in *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2) = $80
Adding number conversion cast (unumber) $c8 in *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3) = $c8
Adding number conversion cast (unumber) $28 in main::$0 = *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT) != $28
Adding number conversion cast (unumber) $64 in main::$1 = main::l#2 < $64
Adding number conversion cast (unumber) 0 in *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DMACTL) = (unumber)$21
Inlining cast *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0) = (unumber)$28
Inlining cast *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1) = (unumber)$48
Inlining cast *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2) = (unumber)$80
Inlining cast *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3) = (unumber)$c8
Inlining cast *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (struct ATARI_GTIA_WRITE *) 53248
Simplifying constant pointer cast (struct ATARI_ANTIC *) 54272
Simplifying constant integer cast $21
Simplifying constant integer cast $28
Simplifying constant integer cast $48
Simplifying constant integer cast $80
Simplifying constant integer cast $c8
Simplifying constant integer cast $28
Simplifying constant integer cast $64
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) $21
Finalized unsigned number type (char) $28
Finalized unsigned number type (char) $48
Finalized unsigned number type (char) $80
Finalized unsigned number type (char) $c8
Finalized unsigned number type (char) $28
Finalized unsigned number type (char) $64
Finalized unsigned number type (char) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias main::col#2 = main::col#3 main::c#0 
Alias main::c#2 = main::c#3 
Alias main::l#2 = main::l#3 
Alias main::col#4 = main::col#6 main::col#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values main::col#4 main::col#1
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$0 [10] if(*((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT)!=$28) goto main::@1
Simple Condition main::$1 [15] if(main::l#2<$64) goto main::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant main::col#0 = 0
Constant main::l#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero (char *)ANTIC in [1] *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DMACTL) = $21
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused constant OFFSET_STRUCT_ATARI_ANTIC_DMACTL
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings main::col#0
Inlining constant with var siblings main::l#0
Constant inlined main::col#0 = 0
Constant inlined main::l#0 = 0
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (char) $a
Finalized unsigned number type (char) $a
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 2
Successful SSA optimization PassNFinalizeNumberTypeConversions
Added new block during phi lifting main::@6(between main::@1 and main::@1)
CALL GRAPH

Created 3 initial phi equivalence classes
Coalesced [10] main::c#4 = main::col#2
Not coalescing [14] main::col#8 = main::col#1
Coalesced [19] main::l#4 = main::l#1
Coalesced [20] main::c#5 = main::c#1
Coalesced (already) [21] main::col#7 = main::col#2
Coalesced down to 3 phi equivalence classes
Culled Empty Block label main::@6

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  asm { sei  }
  [1] *((char *)ANTIC) = $21
  [2] *((char **)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST) = DISPLAY_LIST
  [3] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0) = $28
  [4] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1) = $48
  [5] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2) = $80
  [6] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3) = $c8
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@5
  [7] main::col#2 = phi( main/0, main::@1/main::col#2, main::@5/main::col#8 )
  [8] if(*((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT)!=$28) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [9] main::col#1 = ++ main::col#2
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  [10] main::c#2 = phi( main::@2/main::col#2, main::@4/main::c#1 )
  [10] main::l#2 = phi( main::@2/0, main::@4/main::l#1 )
  [11] if(main::l#2<$64) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@3
  [12] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = 0
  [13] main::col#8 = main::col#1
  to:main::@1
main::@4: scope:[main]  from main::@3
  [14] *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_WSYNC) = main::c#2
  [15] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = main::c#2
  [16] main::c#1 = ++ main::c#2
  [17] main::l#1 = ++ main::l#2
  to:main::@3


VARIABLE REGISTER WEIGHTS
void main()
char main::c
char main::c#1 // 101.0
char main::c#2 // 103.75
char main::col
char main::col#1 // 2.75
char main::col#2 // 78.33333333333334
char main::col#8 // 22.0
char main::l
char main::l#1 // 202.0
char main::l#2 // 60.599999999999994

Initial phi equivalence classes
[ main::l#2 main::l#1 ]
[ main::c#2 main::col#2 main::col#8 main::c#1 ]
Added variable main::col#1 to live range equivalence class [ main::col#1 ]
Complete equivalence classes
[ main::l#2 main::l#1 ]
[ main::c#2 main::col#2 main::col#8 main::c#1 ]
[ main::col#1 ]
Allocated zp[1]:128 [ main::c#2 main::col#2 main::col#8 main::c#1 ]
Allocated zp[1]:129 [ main::l#2 main::l#1 ]
Allocated zp[1]:130 [ main::col#1 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] *((char *)ANTIC) = $21 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] *((char **)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST) = DISPLAY_LIST [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0) = $28 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1) = $48 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2) = $80 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3) = $c8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] if(*((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT)!=$28) goto main::@1 [ main::col#2 ] (  [ main::col#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:128 [ main::c#2 main::col#2 main::col#8 main::c#1 ]
Statement [12] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = 0 [ main::col#1 ] (  [ main::col#1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:130 [ main::col#1 ]
Statement [1] *((char *)ANTIC) = $21 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] *((char **)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST) = DISPLAY_LIST [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0) = $28 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1) = $48 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2) = $80 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3) = $c8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] if(*((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT)!=$28) goto main::@1 [ main::col#2 ] (  [ main::col#2 ] { }  ) always clobbers reg byte a 
Statement [12] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = 0 [ main::col#1 ] (  [ main::col#1 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:129 [ main::l#2 main::l#1 ] : zp[1]:129 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:128 [ main::c#2 main::col#2 main::col#8 main::c#1 ] : zp[1]:128 , reg byte x , reg byte y , 
Potential registers zp[1]:130 [ main::col#1 ] : zp[1]:130 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 305.08: zp[1]:128 [ main::c#2 main::col#2 main::col#8 main::c#1 ] 262.6: zp[1]:129 [ main::l#2 main::l#1 ] 2.75: zp[1]:130 [ main::col#1 ] 
Uplift Scope [ATARI_ANTIC] 
Uplift Scope [ATARI_GTIA_READ] 
Uplift Scope [ATARI_GTIA_WRITE] 
Uplift Scope [ATARI_POKEY_READ] 
Uplift Scope [ATARI_POKEY_WRITE] 
Uplift Scope [] 

Uplifting [main] best 5134 combination reg byte y [ main::c#2 main::col#2 main::col#8 main::c#1 ] reg byte a [ main::l#2 main::l#1 ] reg byte x [ main::col#1 ] 
Uplifting [ATARI_ANTIC] best 5134 combination 
Uplifting [ATARI_GTIA_READ] best 5134 combination 
Uplifting [ATARI_GTIA_WRITE] best 5134 combination 
Uplifting [ATARI_POKEY_READ] best 5134 combination 
Uplifting [ATARI_POKEY_WRITE] best 5134 combination 
Uplifting [] best 5134 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Raster Bars for Atari XL / XE
  // Upstart
  // Atari XL/XE executable XEX file with a single segment
// https://www.atarimax.com/jindroush.atari.org/afmtexe.html
.plugin "dk.camelot64.kickass.xexplugin.AtariXex"
.file [name="atarixl-rasterbars.xex", type="bin", segments="XexFile"]
.segmentdef XexFile [segments="Program", modify="XexFormat", _RunAddr=main]
.segmentdef Program [segments="Code, Data"]
.segmentdef Code [start=$2000]
.segmentdef Data [startAfter="Code"]
  // Global Constants & labels
  /// 2: High Resolution Text Mode. 8 scanlines per char, 32/40/48 chars wide.  bit 7 controls inversion or blinking, based on modes in CHACTL.
  .const MODE2 = 2
  /// 7:  Single color text in five colors. 16 scanlines per char, 16/20/24 chars wide.  the upper two bits are used to select the foreground color used by 1 bits, with 00-11 producing PF0-PF3.
  .const MODE7 = 7
  /// Load memory scan counter (LMS operation) - Load memory scan counter with new 16-bit address. Can be combined with mode instructions by OR.
  .const LMS = $40
  /// Jump and wait for Vertical Blank - suspends the display list until vertical blank and then jumps. This is usually used to terminate the display list and restart it for the next frame.
  .const JVB = $41
  /// Blank 4 lines
  .const BLANK4 = $30
  /// Blank 8 lines
  .const BLANK8 = $70
  .const OFFSET_STRUCT_ATARI_ANTIC_DLIST = 2
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0 = $16
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1 = $17
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2 = $18
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3 = $19
  .const OFFSET_STRUCT_ATARI_ANTIC_VCOUNT = $b
  .const OFFSET_STRUCT_ATARI_ANTIC_WSYNC = $a
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK = $1a
  /// Atari GTIA write registers
  .label GTIA = $d000
  /// Atari ANTIC registers
  .label ANTIC = $d400
.segment Code
  // main
main: {
    // asm { sei  }
    // Disable IRQ
    sei
    // [1] *((char *)ANTIC) = $21 -- _deref_pbuc1=vbuc2 
    // Enable DMA, Narrow Playfield - ANTIC Direct Memory Access Control
    lda #$21
    sta ANTIC
    // [2] *((char **)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST) = DISPLAY_LIST -- _deref_qbuc1=pbuc2 
    // Set ANTIC Display List Pointer
    lda #<DISPLAY_LIST
    sta ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST
    lda #>DISPLAY_LIST
    sta ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST+1
    // [3] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0) = $28 -- _deref_pbuc1=vbuc2 
    // Set colors
    lda #$28
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0
    // [4] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1) = $48 -- _deref_pbuc1=vbuc2 
    lda #$48
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1
    // [5] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2) = $80 -- _deref_pbuc1=vbuc2 
    lda #$80
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2
    // [6] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3) = $c8 -- _deref_pbuc1=vbuc2 
    lda #$c8
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3
    // [7] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [7] phi main::col#2 = 0 [phi:main->main::@1#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b1
    // [7] phi from main::@1 main::@5 to main::@1 [phi:main::@1/main::@5->main::@1]
  __b1_from___b1:
  __b1_from___b5:
    // [7] phi main::col#2 = main::col#2 [phi:main::@1/main::@5->main::@1#0] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [8] if(*((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT)!=$28) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$28
    cmp ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT
    bne __b1_from___b1
    jmp __b2
    // main::@2
  __b2:
    // [9] main::col#1 = ++ main::col#2 -- vbuxx=_inc_vbuyy 
    tya
    tax
    inx
    // [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [10] phi main::c#2 = main::col#2 [phi:main::@2->main::@3#0] -- register_copy 
    // [10] phi main::l#2 = 0 [phi:main::@2->main::@3#1] -- vbuaa=vbuc1 
    lda #0
    jmp __b3
    // main::@3
  __b3:
    // [11] if(main::l#2<$64) goto main::@4 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$64
    bcc __b4
    jmp __b5
    // main::@5
  __b5:
    // [12] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK
    // [13] main::col#8 = main::col#1 -- vbuyy=vbuxx 
    txa
    tay
    jmp __b1_from___b5
    // main::@4
  __b4:
    // [14] *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_WSYNC) = main::c#2 -- _deref_pbuc1=vbuyy 
    sty ANTIC+OFFSET_STRUCT_ATARI_ANTIC_WSYNC
    // [15] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = main::c#2 -- _deref_pbuc1=vbuyy 
    sty GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK
    // [16] main::c#1 = ++ main::c#2 -- vbuyy=_inc_vbuyy 
    iny
    // [17] main::l#1 = ++ main::l#2 -- vbuaa=_inc_vbuaa 
    clc
    adc #1
    // [10] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [10] phi main::c#2 = main::c#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [10] phi main::l#2 = main::l#1 [phi:main::@4->main::@3#1] -- register_copy 
    jmp __b3
}
  // File Data
.segment Data
  // Message to show
.encoding "ascii"
  TEXT: .text @"\$28\$25\$2c\$2c\$2f\$00atari\$00\$18\$22\$29\$34\$24emonstrates\$00\$21\$2e\$34\$29\$23\$00display\$00list\$01"
  .byte 0
  // ANTIC Display List Program
  // https://en.wikipedia.org/wiki/ANTIC
  DISPLAY_LIST: .byte BLANK8, BLANK8, BLANK8, LMS|MODE7, <TEXT, >TEXT, BLANK4, MODE2, JVB, <DISPLAY_LIST, >DISPLAY_LIST

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b5
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b1 with __b1
Replacing label __b1_from___b5 with __b1
Removing instruction __b1_from___b1:
Removing instruction __b1_from___b5:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __b2:
Removing instruction __b3_from___b2:
Removing instruction __b5:
Removing instruction __b3_from___b4:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
__constant struct ATARI_ANTIC * const ANTIC = (struct ATARI_ANTIC *) 54272
__constant const char BLANK4 = $30
__constant const char BLANK8 = $70
__constant char DISPLAY_LIST[] = { BLANK8, BLANK8, BLANK8, LMS|MODE7, byte0 TEXT, byte1 TEXT, BLANK4, MODE2, JVB, byte0 DISPLAY_LIST, byte1 DISPLAY_LIST }
__constant struct ATARI_GTIA_WRITE * const GTIA = (struct ATARI_GTIA_WRITE *) 53248
__constant const char JVB = $41
__constant const char LMS = $40
__constant const char MODE2 = 2
__constant const char MODE7 = 7
__constant char OFFSET_STRUCT_ATARI_ANTIC_DLIST = 2
__constant char OFFSET_STRUCT_ATARI_ANTIC_VCOUNT = $b
__constant char OFFSET_STRUCT_ATARI_ANTIC_WSYNC = $a
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK = $1a
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0 = $16
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1 = $17
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2 = $18
__constant char OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3 = $19
__constant char TEXT[] = "HELLO atari 8BITDemonstrates ANTIC display list!"sa
void main()
char main::c
char main::c#1 // reg byte y 101.0
char main::c#2 // reg byte y 103.75
char main::col
char main::col#1 // reg byte x 2.75
char main::col#2 // reg byte y 78.33333333333334
char main::col#8 // reg byte y 22.0
char main::l
char main::l#1 // reg byte a 202.0
char main::l#2 // reg byte a 60.599999999999994

reg byte a [ main::l#2 main::l#1 ]
reg byte y [ main::c#2 main::col#2 main::col#8 main::c#1 ]
reg byte x [ main::col#1 ]


FINAL ASSEMBLER
Score: 3634

  // File Comments
// Raster Bars for Atari XL / XE
  // Upstart
  // Atari XL/XE executable XEX file with a single segment
// https://www.atarimax.com/jindroush.atari.org/afmtexe.html
.plugin "dk.camelot64.kickass.xexplugin.AtariXex"
.file [name="atarixl-rasterbars.xex", type="bin", segments="XexFile"]
.segmentdef XexFile [segments="Program", modify="XexFormat", _RunAddr=main]
.segmentdef Program [segments="Code, Data"]
.segmentdef Code [start=$2000]
.segmentdef Data [startAfter="Code"]
  // Global Constants & labels
  /// 2: High Resolution Text Mode. 8 scanlines per char, 32/40/48 chars wide.  bit 7 controls inversion or blinking, based on modes in CHACTL.
  .const MODE2 = 2
  /// 7:  Single color text in five colors. 16 scanlines per char, 16/20/24 chars wide.  the upper two bits are used to select the foreground color used by 1 bits, with 00-11 producing PF0-PF3.
  .const MODE7 = 7
  /// Load memory scan counter (LMS operation) - Load memory scan counter with new 16-bit address. Can be combined with mode instructions by OR.
  .const LMS = $40
  /// Jump and wait for Vertical Blank - suspends the display list until vertical blank and then jumps. This is usually used to terminate the display list and restart it for the next frame.
  .const JVB = $41
  /// Blank 4 lines
  .const BLANK4 = $30
  /// Blank 8 lines
  .const BLANK8 = $70
  .const OFFSET_STRUCT_ATARI_ANTIC_DLIST = 2
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0 = $16
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1 = $17
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2 = $18
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3 = $19
  .const OFFSET_STRUCT_ATARI_ANTIC_VCOUNT = $b
  .const OFFSET_STRUCT_ATARI_ANTIC_WSYNC = $a
  .const OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK = $1a
  /// Atari GTIA write registers
  .label GTIA = $d000
  /// Atari ANTIC registers
  .label ANTIC = $d400
.segment Code
  // main
main: {
    // asm
    // asm { sei  }
    // Disable IRQ
    sei
    // ANTIC->DMACTL = 0x21
    // [1] *((char *)ANTIC) = $21 -- _deref_pbuc1=vbuc2 
    // Enable DMA, Narrow Playfield - ANTIC Direct Memory Access Control
    lda #$21
    sta ANTIC
    // ANTIC->DLIST  = DISPLAY_LIST
    // [2] *((char **)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST) = DISPLAY_LIST -- _deref_qbuc1=pbuc2 
    // Set ANTIC Display List Pointer
    lda #<DISPLAY_LIST
    sta ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST
    lda #>DISPLAY_LIST
    sta ANTIC+OFFSET_STRUCT_ATARI_ANTIC_DLIST+1
    // GTIA->COLPF0 = 0x28
    // [3] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0) = $28 -- _deref_pbuc1=vbuc2 
    // Set colors
    lda #$28
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF0
    // GTIA->COLPF1 = 0x48
    // [4] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1) = $48 -- _deref_pbuc1=vbuc2 
    lda #$48
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF1
    // GTIA->COLPF2 = 0x80
    // [5] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2) = $80 -- _deref_pbuc1=vbuc2 
    lda #$80
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF2
    // GTIA->COLPF3 = 0xc8
    // [6] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3) = $c8 -- _deref_pbuc1=vbuc2 
    lda #$c8
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLPF3
    // [7] phi from main to main::@1 [phi:main->main::@1]
    // [7] phi main::col#2 = 0 [phi:main->main::@1#0] -- vbuyy=vbuc1 
    ldy #0
    // [7] phi from main::@1 main::@5 to main::@1 [phi:main::@1/main::@5->main::@1]
    // [7] phi main::col#2 = main::col#2 [phi:main::@1/main::@5->main::@1#0] -- register_copy 
    // main::@1
  __b1:
    // while(ANTIC->VCOUNT!=40)
    // [8] if(*((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT)!=$28) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$28
    cmp ANTIC+OFFSET_STRUCT_ATARI_ANTIC_VCOUNT
    bne __b1
    // main::@2
    // char c = col++
    // [9] main::col#1 = ++ main::col#2 -- vbuxx=_inc_vbuyy 
    tya
    tax
    inx
    // [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // [10] phi main::c#2 = main::col#2 [phi:main::@2->main::@3#0] -- register_copy 
    // [10] phi main::l#2 = 0 [phi:main::@2->main::@3#1] -- vbuaa=vbuc1 
    lda #0
    // main::@3
  __b3:
    // for( char l=0;l<100;l++)
    // [11] if(main::l#2<$64) goto main::@4 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$64
    bcc __b4
    // main::@5
    // GTIA->COLBK = 0
    // [12] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK
    // [13] main::col#8 = main::col#1 -- vbuyy=vbuxx 
    txa
    tay
    jmp __b1
    // main::@4
  __b4:
    // ANTIC->WSYNC = c
    // [14] *((char *)ANTIC+OFFSET_STRUCT_ATARI_ANTIC_WSYNC) = main::c#2 -- _deref_pbuc1=vbuyy 
    sty ANTIC+OFFSET_STRUCT_ATARI_ANTIC_WSYNC
    // GTIA->COLBK = c
    // [15] *((char *)GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK) = main::c#2 -- _deref_pbuc1=vbuyy 
    sty GTIA+OFFSET_STRUCT_ATARI_GTIA_WRITE_COLBK
    // c++;
    // [16] main::c#1 = ++ main::c#2 -- vbuyy=_inc_vbuyy 
    iny
    // for( char l=0;l<100;l++)
    // [17] main::l#1 = ++ main::l#2 -- vbuaa=_inc_vbuaa 
    clc
    adc #1
    // [10] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
    // [10] phi main::c#2 = main::c#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [10] phi main::l#2 = main::l#1 [phi:main::@4->main::@3#1] -- register_copy 
    jmp __b3
}
  // File Data
.segment Data
  // Message to show
.encoding "ascii"
  TEXT: .text @"\$28\$25\$2c\$2c\$2f\$00atari\$00\$18\$22\$29\$34\$24emonstrates\$00\$21\$2e\$34\$29\$23\$00display\$00list\$01"
  .byte 0
  // ANTIC Display List Program
  // https://en.wikipedia.org/wiki/ANTIC
  DISPLAY_LIST: .byte BLANK8, BLANK8, BLANK8, LMS|MODE7, <TEXT, >TEXT, BLANK4, MODE2, JVB, <DISPLAY_LIST, >DISPLAY_LIST

