Loading link script "mega65_banked.ld"
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference MUSIC_END to MUSIC_END
Resolved forward reference MUSIC to MUSIC
Resolved forward reference upperCodeData to upperCodeData
Resolved forward reference musicInit to musicInit
Resolved forward reference irq to interrupt(HARDWARE_STACK) void irq()
Resolved forward reference MUSIC to MUSIC
Resolved forward reference MUSIC to MUSIC
Resolved forward reference MUSIC to MUSIC
Resolved forward reference MUSIC to MUSIC
Resolved forward reference musicPlay to musicPlay
Fixing struct type size struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = >&memcpy_dma_command
Setting struct to load/store in variable affected by address-of *DMA.ADDRLSBTRIG = <&memcpy_dma_command
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = >&memcpy_dma_command4
Setting struct to load/store in variable affected by address-of *DMA.ADDRLSBTRIG = <&memcpy_dma_command4
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = >&memset_dma_command
Setting struct to load/store in variable affected by address-of *DMA.ADDRLSBTRIG = <&memset_dma_command
Inlined call vicSelectGfxBank::$0 = call toDd00 vicSelectGfxBank::gfx 
Inlined call call __init 
Eliminating unused variable with no statement memcpy_dma_command
Eliminating unused variable with no statement memset_dma_command

CONTROL FLOW GRAPH SSA

void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from irq::@3 main main::@6 memoryRemapBlock
  memoryRemap::upperPageOffset#4 = phi( irq::@3/memoryRemap::upperPageOffset#3, main/memoryRemap::upperPageOffset#1, main::@6/memoryRemap::upperPageOffset#2, memoryRemapBlock/memoryRemap::upperPageOffset#0 )
  memoryRemap::remapBlocks#4 = phi( irq::@3/memoryRemap::remapBlocks#3, main/memoryRemap::remapBlocks#1, main::@6/memoryRemap::remapBlocks#2, memoryRemapBlock/memoryRemap::remapBlocks#0 )
  memoryRemap::lowerPageOffset#4 = phi( irq::@3/memoryRemap::lowerPageOffset#3, main/memoryRemap::lowerPageOffset#1, main::@6/memoryRemap::lowerPageOffset#2, memoryRemapBlock/memoryRemap::lowerPageOffset#0 )
  memoryRemap::$0 = < memoryRemap::lowerPageOffset#4
  *memoryRemap::aVal = memoryRemap::$0
  memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4
  memoryRemap::$2 = > memoryRemap::lowerPageOffset#4
  memoryRemap::$3 = memoryRemap::$2 & $f
  memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
  *memoryRemap::xVal = memoryRemap::$4
  memoryRemap::$5 = < memoryRemap::upperPageOffset#4
  *memoryRemap::yVal = memoryRemap::$5
  memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0
  memoryRemap::$7 = > memoryRemap::upperPageOffset#4
  memoryRemap::$8 = memoryRemap::$7 & $f
  memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
  *memoryRemap::zVal = memoryRemap::$9
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  return 
  to:@return

void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
memoryRemapBlock: scope:[memoryRemapBlock]  from irq main::@5
  memoryRemapBlock::blockPage#2 = phi( irq/memoryRemapBlock::blockPage#1, main::@5/memoryRemapBlock::blockPage#0 )
  memoryRemapBlock::memoryPage#2 = phi( irq/memoryRemapBlock::memoryPage#1, main::@5/memoryRemapBlock::memoryPage#0 )
  memoryRemapBlock::$0 = memoryRemapBlock::memoryPage#2 - memoryRemapBlock::blockPage#2
  memoryRemapBlock::pageOffset#0 = memoryRemapBlock::$0
  memoryRemapBlock::$1 = memoryRemapBlock::blockPage#2 / $20
  memoryRemapBlock::block#0 = memoryRemapBlock::$1
  memoryRemapBlock::$2 = 1 << memoryRemapBlock::block#0
  memoryRemapBlock::blockBits#0 = memoryRemapBlock::$2
  memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0
  memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
  memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0
  call memoryRemap 
  to:memoryRemapBlock::@1
memoryRemapBlock::@1: scope:[memoryRemapBlock]  from memoryRemapBlock
  to:memoryRemapBlock::@return
memoryRemapBlock::@return: scope:[memoryRemapBlock]  from memoryRemapBlock::@1
  return 
  to:@return

void memcpy_dma4(byte memcpy_dma4::dest_bank , void* memcpy_dma4::dest , byte memcpy_dma4::src_bank , void* memcpy_dma4::src , word memcpy_dma4::num)
memcpy_dma4: scope:[memcpy_dma4]  from main::@4
  memcpy_dma4::dest#1 = phi( main::@4/memcpy_dma4::dest#0 )
  memcpy_dma4::dest_bank#1 = phi( main::@4/memcpy_dma4::dest_bank#0 )
  memcpy_dma4::src#1 = phi( main::@4/memcpy_dma4::src#0 )
  memcpy_dma4::src_bank#1 = phi( main::@4/memcpy_dma4::src_bank#0 )
  memcpy_dma4::num#1 = phi( main::@4/memcpy_dma4::num#0 )
  memcpy_dma4::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  *((word*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#1
  *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#1
  *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = ((byte*)) memcpy_dma4::src#1
  *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#1
  *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = ((byte*)) memcpy_dma4::dest#1
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&memcpy_dma_command4
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) = <&memcpy_dma_command4
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma4::dmaMode#0
  to:memcpy_dma4::@return
memcpy_dma4::@return: scope:[memcpy_dma4]  from memcpy_dma4
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  asm { sei  }
  memoryRemap::remapBlocks#1 = 0
  memoryRemap::lowerPageOffset#1 = 0
  memoryRemap::upperPageOffset#1 = 0
  call memoryRemap 
  to:main::@4
main::@4: scope:[main]  from main
  *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47
  *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40
  *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK
  *PROCPORT = PROCPORT_RAM_IO
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1
  main::$1 = MUSIC_END - MUSIC
  memcpy_dma4::dest_bank#0 = 1
  memcpy_dma4::dest#0 = (void*)0
  memcpy_dma4::src_bank#0 = 0
  memcpy_dma4::src#0 = (void*)upperCodeData
  memcpy_dma4::num#0 = main::$1
  call memcpy_dma4 
  to:main::@5
main::@5: scope:[main]  from main::@4
  memoryRemapBlock::blockPage#0 = $40
  memoryRemapBlock::memoryPage#0 = $100
  call memoryRemapBlock 
  to:main::@6
main::@6: scope:[main]  from main::@5
  asm { lda#0  }
  call *musicInit 
  memoryRemap::remapBlocks#2 = 0
  memoryRemap::lowerPageOffset#2 = 0
  memoryRemap::upperPageOffset#2 = 0
  call memoryRemap 
  to:main::@7
main::@7: scope:[main]  from main::@6
  *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR
  *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff
  *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f
  *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER
  *HARDWARE_IRQ = &irq
  asm { cli  }
  main::mem_destroy_i#0 = 0
  to:main::@1
main::@1: scope:[main]  from main::@2 main::@7
  main::mem_destroy_i#2 = phi( main::@2/main::mem_destroy_i#3, main::@7/main::mem_destroy_i#0 )
  MUSIC[main::mem_destroy_i#2] = ++ MUSIC[main::mem_destroy_i#2]
  main::mem_destroy_i#1 = ++ main::mem_destroy_i#2
  main::i#0 = 0
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@3
  main::mem_destroy_i#3 = phi( main::@1/main::mem_destroy_i#1, main::@3/main::mem_destroy_i#4 )
  main::i#2 = phi( main::@1/main::i#0, main::@3/main::i#1 )
  main::$7 = main::i#2 < $f0
  if(main::$7) goto main::@3
  to:main::@1
main::@3: scope:[main]  from main::@2
  main::mem_destroy_i#4 = phi( main::@2/main::mem_destroy_i#3 )
  main::i#3 = phi( main::@2/main::i#2 )
  DEFAULT_SCREEN[main::i#3] = MUSIC[main::i#3]
  main::i#1 = ++ main::i#3
  to:main::@2
main::@return: scope:[main]  from
  return 
  to:@return

interrupt(HARDWARE_STACK) void irq()
irq: scope:[irq]  from
  *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER
  *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = ++ *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR)
  memoryRemapBlock::blockPage#1 = $40
  memoryRemapBlock::memoryPage#1 = $100
  call memoryRemapBlock 
  to:irq::@3
irq::@3: scope:[irq]  from irq
  call *musicPlay 
  memoryRemap::remapBlocks#3 = 0
  memoryRemap::lowerPageOffset#3 = 0
  memoryRemap::upperPageOffset#3 = 0
  call memoryRemap 
  to:irq::@4
irq::@4: scope:[irq]  from irq::@3
  irq::raster#0 = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)
  to:irq::@1
irq::@1: scope:[irq]  from irq::@1 irq::@4
  irq::raster#1 = phi( irq::@1/irq::raster#1, irq::@4/irq::raster#0 )
  irq::$5 = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) == irq::raster#1
  if(irq::$5) goto irq::@1
  to:irq::@2
irq::@2: scope:[irq]  from irq::@1
  *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = -- *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR)
  to:irq::@return
irq::@return: scope:[irq]  from irq::@2
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
const nomodify struct MOS6526_CIA* CIA1 = (struct MOS6526_CIA*)$dc00
const nomodify byte CIA_INTERRUPT_CLEAR = $7f
const nomodify byte* DEFAULT_SCREEN = (byte*)$800
const nomodify struct F018_DMAGIC* DMA = (struct F018_DMAGIC*)$d700
const nomodify byte DMA_COMMAND_COPY = 0
const nomodify void()** HARDWARE_IRQ = (void()**)$fffe
const nomodify byte IRQ_RASTER = 1
const byte* MUSIC[]  = kickasm {{ .const music = LoadSid("Cybernoid_II_4000.sid")
    .fill music.size, music.getData(i)
 }}
const nomodify byte* MUSIC_END = (byte*)$5200
const byte OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
const byte OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
const byte OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
const byte OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
const byte OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG = 0
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
const byte OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
const byte OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
const byte OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
const byte OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
const byte OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
const byte OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
const byte OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
const byte OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
const byte OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
const byte OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
const byte OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
const nomodify byte* PROCPORT = (byte*)1
const nomodify byte* PROCPORT_DDR = (byte*)0
const nomodify byte PROCPORT_DDR_MEMORY_MASK = 7
const nomodify byte PROCPORT_RAM_IO = 5
const nomodify struct MOS6569_VICII* VICII = (struct MOS6569_VICII*)$d000
const nomodify struct MOS4569_VICIII* VICIII = (struct MOS4569_VICIII*)$d000
const nomodify struct MEGA65_VICIV* VICIV = (struct MEGA65_VICIV*)$d000
void __start()
interrupt(HARDWARE_STACK) void irq()
bool~ irq::$5
byte irq::raster
byte irq::raster#0
byte irq::raster#1
void main()
word~ main::$1
bool~ main::$7
byte main::i
byte main::i#0
byte main::i#1
byte main::i#2
byte main::i#3
byte main::mem_destroy_i
byte main::mem_destroy_i#0
byte main::mem_destroy_i#1
byte main::mem_destroy_i#2
byte main::mem_destroy_i#3
byte main::mem_destroy_i#4
void memcpy_dma4(byte memcpy_dma4::dest_bank , void* memcpy_dma4::dest , byte memcpy_dma4::src_bank , void* memcpy_dma4::src , word memcpy_dma4::num)
void* memcpy_dma4::dest
void* memcpy_dma4::dest#0
void* memcpy_dma4::dest#1
byte memcpy_dma4::dest_bank
byte memcpy_dma4::dest_bank#0
byte memcpy_dma4::dest_bank#1
byte memcpy_dma4::dmaMode
byte memcpy_dma4::dmaMode#0
word memcpy_dma4::num
word memcpy_dma4::num#0
word memcpy_dma4::num#1
void* memcpy_dma4::src
void* memcpy_dma4::src#0
void* memcpy_dma4::src#1
byte memcpy_dma4::src_bank
byte memcpy_dma4::src_bank#0
byte memcpy_dma4::src_bank#1
struct DMA_LIST_F018B memcpy_dma_command4 loadstore = { command: DMA_COMMAND_COPY, count: 0, src: (byte*)0, src_bank: 0, dest: (byte*)0, dest_bank: 0, sub_command: 0, modulo: 0 }
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
byte~ memoryRemap::$0
byte~ memoryRemap::$1
byte~ memoryRemap::$2
number~ memoryRemap::$3
number~ memoryRemap::$4
byte~ memoryRemap::$5
number~ memoryRemap::$6
byte~ memoryRemap::$7
number~ memoryRemap::$8
number~ memoryRemap::$9
const byte* memoryRemap::aVal = (byte*)$fc
word memoryRemap::lowerPageOffset
word memoryRemap::lowerPageOffset#0
word memoryRemap::lowerPageOffset#1
word memoryRemap::lowerPageOffset#2
word memoryRemap::lowerPageOffset#3
word memoryRemap::lowerPageOffset#4
byte memoryRemap::remapBlocks
byte memoryRemap::remapBlocks#0
byte memoryRemap::remapBlocks#1
byte memoryRemap::remapBlocks#2
byte memoryRemap::remapBlocks#3
byte memoryRemap::remapBlocks#4
word memoryRemap::upperPageOffset
word memoryRemap::upperPageOffset#0
word memoryRemap::upperPageOffset#1
word memoryRemap::upperPageOffset#2
word memoryRemap::upperPageOffset#3
word memoryRemap::upperPageOffset#4
const byte* memoryRemap::xVal = (byte*)$fd
const byte* memoryRemap::yVal = (byte*)$fe
const byte* memoryRemap::zVal = (byte*)$ff
void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
word~ memoryRemapBlock::$0
number~ memoryRemapBlock::$1
number~ memoryRemapBlock::$2
byte memoryRemapBlock::block
byte memoryRemapBlock::block#0
byte memoryRemapBlock::blockBits
byte memoryRemapBlock::blockBits#0
byte memoryRemapBlock::blockPage
byte memoryRemapBlock::blockPage#0
byte memoryRemapBlock::blockPage#1
byte memoryRemapBlock::blockPage#2
word memoryRemapBlock::memoryPage
word memoryRemapBlock::memoryPage#0
word memoryRemapBlock::memoryPage#1
word memoryRemapBlock::memoryPage#2
word memoryRemapBlock::pageOffset
word memoryRemapBlock::pageOffset#0
const void()* musicInit = (void()*)MUSIC
const void()* musicPlay = (void()*)MUSIC+3
const byte* upperCodeData[]  = kickasm {{ .segmentout [segments="Banked"]
 }}

Adding number conversion cast (unumber) 3 in 
Adding number conversion cast (unumber) 4 in memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4
Adding number conversion cast (unumber) $f in memoryRemap::$3 = memoryRemap::$2 & $f
Adding number conversion cast (unumber) memoryRemap::$3 in memoryRemap::$3 = memoryRemap::$2 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap::$4 in memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Adding number conversion cast (unumber) $f0 in memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0
Adding number conversion cast (unumber) memoryRemap::$6 in memoryRemap::$6 = memoryRemap::remapBlocks#4 & (unumber)$f0
Adding number conversion cast (unumber) $f in memoryRemap::$8 = memoryRemap::$7 & $f
Adding number conversion cast (unumber) memoryRemap::$8 in memoryRemap::$8 = memoryRemap::$7 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap::$9 in memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Adding number conversion cast (unumber) $20 in memoryRemapBlock::$1 = memoryRemapBlock::blockPage#2 / $20
Adding number conversion cast (unumber) memoryRemapBlock::$1 in memoryRemapBlock::$1 = memoryRemapBlock::blockPage#2 / (unumber)$20
Adding number conversion cast (unumber) 1 in memoryRemapBlock::$2 = 1 << memoryRemapBlock::block#0
Adding number conversion cast (unumber) memoryRemapBlock::$2 in memoryRemapBlock::$2 = (unumber)1 << memoryRemapBlock::block#0
Adding number conversion cast (unumber) 1 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
Adding number conversion cast (unumber) 0 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
Adding number conversion cast (unumber) 0 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
Adding number conversion cast (unumber) 0 in memoryRemap::remapBlocks#1 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::lowerPageOffset#1 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::upperPageOffset#1 = 0
Adding number conversion cast (unumber) $47 in *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47
Adding number conversion cast (unumber) $53 in *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53
Adding number conversion cast (unumber) $40 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40
Adding number conversion cast (unumber) $40 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40
Adding number conversion cast (unumber) 1 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1
Adding number conversion cast (unumber) 1 in memcpy_dma4::dest_bank#0 = 1
Adding number conversion cast (unumber) 0 in memcpy_dma4::src_bank#0 = 0
Adding number conversion cast (unumber) $40 in memoryRemapBlock::blockPage#0 = $40
Adding number conversion cast (unumber) $100 in memoryRemapBlock::memoryPage#0 = $100
Adding number conversion cast (unumber) 0 in memoryRemap::remapBlocks#2 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::lowerPageOffset#2 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::upperPageOffset#2 = 0
Adding number conversion cast (unumber) $ff in *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff
Adding number conversion cast (unumber) $7f in *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f
Adding number conversion cast (unumber) $f0 in main::$7 = main::i#2 < $f0
Adding number conversion cast (unumber) $40 in memoryRemapBlock::blockPage#1 = $40
Adding number conversion cast (unumber) $100 in memoryRemapBlock::memoryPage#1 = $100
Adding number conversion cast (unumber) 0 in memoryRemap::remapBlocks#3 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::lowerPageOffset#3 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::upperPageOffset#3 = 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memcpy_dma4::src#1
Inlining cast *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memcpy_dma4::dest#1
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = (unumber)1
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = (unumber)0
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = (unumber)0
Inlining cast memoryRemap::remapBlocks#1 = (unumber)0
Inlining cast memoryRemap::lowerPageOffset#1 = (unumber)0
Inlining cast memoryRemap::upperPageOffset#1 = (unumber)0
Inlining cast *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = (unumber)$47
Inlining cast *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = (unumber)$53
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = (unumber)1
Inlining cast memcpy_dma4::dest_bank#0 = (unumber)1
Inlining cast memcpy_dma4::src_bank#0 = (unumber)0
Inlining cast memoryRemapBlock::blockPage#0 = (unumber)$40
Inlining cast memoryRemapBlock::memoryPage#0 = (unumber)$100
Inlining cast memoryRemap::remapBlocks#2 = (unumber)0
Inlining cast memoryRemap::lowerPageOffset#2 = (unumber)0
Inlining cast memoryRemap::upperPageOffset#2 = (unumber)0
Inlining cast *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = (unumber)$ff
Inlining cast memoryRemapBlock::blockPage#1 = (unumber)$40
Inlining cast memoryRemapBlock::memoryPage#1 = (unumber)$100
Inlining cast memoryRemap::remapBlocks#3 = (unumber)0
Inlining cast memoryRemap::lowerPageOffset#3 = (unumber)0
Inlining cast memoryRemap::upperPageOffset#3 = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 252
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant pointer cast (byte*) 0
Simplifying constant pointer cast (byte*) 1
Simplifying constant pointer cast (struct MOS6569_VICII*) 53248
Simplifying constant pointer cast (struct MOS4569_VICIII*) 53248
Simplifying constant pointer cast (struct MEGA65_VICIV*) 53248
Simplifying constant pointer cast (struct F018_DMAGIC*) 55040
Simplifying constant pointer cast (byte*) 2048
Simplifying constant pointer cast (struct MOS6526_CIA*) 56320
Simplifying constant pointer cast (void()**) 65534
Simplifying constant pointer cast (byte*) 0
Simplifying constant pointer cast (byte*) 0
Simplifying constant pointer cast (byte*) 20992
Simplifying constant integer cast 3
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Simplifying constant integer cast $20
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $47
Simplifying constant integer cast $53
Simplifying constant integer cast $40
Simplifying constant integer cast $40
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant pointer cast (void*) 0
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast $100
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast $7f
Simplifying constant integer cast $f0
Simplifying constant integer cast $40
Simplifying constant integer cast $100
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type 3
Finalized unsigned number type 4
Finalized unsigned number type $f
Finalized unsigned number type $f0
Finalized unsigned number type $f
Finalized unsigned number type $20
Finalized unsigned number type 1
Finalized unsigned number type 1
Finalized unsigned number type 0
Finalized unsigned number type 0
Finalized unsigned number type 0
Finalized unsigned number type 0
Finalized unsigned number type 0
Finalized unsigned number type $47
Finalized unsigned number type $53
Finalized unsigned number type $40
Finalized unsigned number type $40
Finalized unsigned number type 1
Finalized unsigned number type 1
Finalized unsigned number type 0
Finalized unsigned number type $40
Finalized unsigned number type $100
Finalized unsigned number type 0
Finalized unsigned number type 0
Finalized unsigned number type 0
Finalized unsigned number type $ff
Finalized unsigned number type $7f
Finalized unsigned number type $f0
Finalized unsigned number type $40
Finalized unsigned number type $100
Finalized unsigned number type 0
Finalized unsigned number type 0
Finalized unsigned number type 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in memoryRemap::$3 = memoryRemap::$2 & $f
Inferred type updated to byte in memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Inferred type updated to byte in memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0
Inferred type updated to byte in memoryRemap::$8 = memoryRemap::$7 & $f
Inferred type updated to byte in memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Inferred type updated to byte in memoryRemapBlock::$1 = memoryRemapBlock::blockPage#2 / $20
Inferred type updated to byte in memoryRemapBlock::$2 = 1 << memoryRemapBlock::block#0
Alias memoryRemapBlock::pageOffset#0 = memoryRemapBlock::$0 
Alias memoryRemapBlock::block#0 = memoryRemapBlock::$1 
Alias memoryRemapBlock::blockBits#0 = memoryRemapBlock::$2 
Alias memcpy_dma4::num#0 = main::$1 
Alias main::i#2 = main::i#3 
Alias main::mem_destroy_i#3 = main::mem_destroy_i#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values memcpy_dma4::num#1 memcpy_dma4::num#0
Identical Phi Values memcpy_dma4::src_bank#1 memcpy_dma4::src_bank#0
Identical Phi Values memcpy_dma4::src#1 memcpy_dma4::src#0
Identical Phi Values memcpy_dma4::dest_bank#1 memcpy_dma4::dest_bank#0
Identical Phi Values memcpy_dma4::dest#1 memcpy_dma4::dest#0
Identical Phi Values main::mem_destroy_i#3 main::mem_destroy_i#1
Identical Phi Values irq::raster#1 irq::raster#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$7 [80] if(main::i#2<$f0) goto main::@3
Simple Condition irq::$5 [97] if(*((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)==irq::raster#0) goto irq::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [52] memcpy_dma4::num#0 = MUSIC_END - MUSIC
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap::remapBlocks#1 = 0
Constant memoryRemap::lowerPageOffset#1 = 0
Constant memoryRemap::upperPageOffset#1 = 0
Constant memcpy_dma4::num#0 = MUSIC_END-MUSIC
Constant memcpy_dma4::dest_bank#0 = 1
Constant memcpy_dma4::dest#0 = (void*) 0
Constant memcpy_dma4::src_bank#0 = 0
Constant memcpy_dma4::src#0 = (void*)upperCodeData
Constant memoryRemapBlock::blockPage#0 = $40
Constant memoryRemapBlock::memoryPage#0 = $100
Constant memoryRemap::remapBlocks#2 = 0
Constant memoryRemap::lowerPageOffset#2 = 0
Constant memoryRemap::upperPageOffset#2 = 0
Constant main::mem_destroy_i#0 = 0
Constant main::i#0 = 0
Constant memoryRemapBlock::blockPage#1 = $40
Constant memoryRemapBlock::memoryPage#1 = $100
Constant memoryRemap::remapBlocks#3 = 0
Constant memoryRemap::lowerPageOffset#3 = 0
Constant memoryRemap::upperPageOffset#3 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte*)memcpy_dma4::src#0 in [30] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memcpy_dma4::src#0
Constant value identified (byte*)memcpy_dma4::dest#0 in [32] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memcpy_dma4::dest#0
Successful SSA optimization Pass2ConstantValues
Simplifying expression containing zero (byte*)DMA in [37] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) = <&memcpy_dma_command4
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Rewriting division to use shift [19] memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 / $20
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings memoryRemap::remapBlocks#1
Inlining constant with var siblings memoryRemap::lowerPageOffset#1
Inlining constant with var siblings memoryRemap::upperPageOffset#1
Inlining constant with var siblings memoryRemap::remapBlocks#2
Inlining constant with var siblings memoryRemap::lowerPageOffset#2
Inlining constant with var siblings memoryRemap::upperPageOffset#2
Inlining constant with var siblings memoryRemap::remapBlocks#3
Inlining constant with var siblings memoryRemap::lowerPageOffset#3
Inlining constant with var siblings memoryRemap::upperPageOffset#3
Inlining constant with var siblings memoryRemapBlock::blockPage#0
Inlining constant with var siblings memoryRemapBlock::memoryPage#0
Inlining constant with var siblings memoryRemapBlock::blockPage#1
Inlining constant with var siblings memoryRemapBlock::memoryPage#1
Inlining constant with var siblings main::mem_destroy_i#0
Inlining constant with var siblings main::i#0
Constant inlined main::mem_destroy_i#0 = 0
Constant inlined memoryRemap::remapBlocks#1 = 0
Constant inlined memoryRemapBlock::blockPage#1 = $40
Constant inlined memoryRemapBlock::blockPage#0 = $40
Constant inlined memoryRemap::remapBlocks#3 = 0
Constant inlined memoryRemap::upperPageOffset#3 = 0
Constant inlined memoryRemap::remapBlocks#2 = 0
Constant inlined memoryRemap::upperPageOffset#1 = 0
Constant inlined memoryRemapBlock::memoryPage#1 = $100
Constant inlined memoryRemap::upperPageOffset#2 = 0
Constant inlined memoryRemapBlock::memoryPage#0 = $100
Constant inlined memoryRemap::lowerPageOffset#3 = 0
Constant inlined memoryRemap::lowerPageOffset#2 = 0
Constant inlined memoryRemap::lowerPageOffset#1 = 0
Constant inlined main::i#0 = 0
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values memoryRemapBlock::memoryPage#2 $100
Identical Phi Values memoryRemapBlock::blockPage#2 $40
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [18] memoryRemapBlock::pageOffset#0 = $100 - $40
Constant right-side identified [19] memoryRemapBlock::block#0 = $40 >> 5
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemapBlock::pageOffset#0 = $100-$40
Constant memoryRemapBlock::block#0 = $40>>5
Successful SSA optimization Pass2ConstantIdentification
Constant memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
Constant memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings memoryRemap::lowerPageOffset#0
Inlining constant with var siblings memoryRemap::upperPageOffset#0
Constant inlined memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
Constant inlined memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0
Successful SSA optimization Pass2ConstantInlining
Constant right-side identified [17] memoryRemapBlock::blockBits#0 = 1 << memoryRemapBlock::block#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemapBlock::blockBits#0 = 1<<memoryRemapBlock::block#0
Successful SSA optimization Pass2ConstantIdentification
Constant memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings memoryRemap::remapBlocks#0
Constant inlined memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@8(between main::@2 and main::@1)
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of memoryRemapBlock
Adding NOP phi() at start of memoryRemapBlock::@1
CALL GRAPH
Calls in [irq] to memoryRemapBlock:2 memoryRemap:4 
Calls in [main] to memoryRemap:10 memcpy_dma4:18 memoryRemapBlock:20 memoryRemap:23 
Calls in [memoryRemapBlock] to memoryRemap:40 

Created 5 initial phi equivalence classes
Coalesced [35] main::mem_destroy_i#5 = main::mem_destroy_i#1
Coalesced [38] main::i#4 = main::i#1
Coalesced down to 5 phi equivalence classes
Culled Empty Block label main::@8
Culled Empty Block label memoryRemapBlock::@1
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of memoryRemapBlock

FINAL CONTROL FLOW GRAPH

interrupt(HARDWARE_STACK) void irq()
irq: scope:[irq]  from
  [0] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER
  [1] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = ++ *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR)
  [2] call memoryRemapBlock 
  to:irq::@3
irq::@3: scope:[irq]  from irq
  [3] call *musicPlay 
  [4] call memoryRemap 
  to:irq::@4
irq::@4: scope:[irq]  from irq::@3
  [5] irq::raster#0 = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)
  to:irq::@1
irq::@1: scope:[irq]  from irq::@1 irq::@4
  [6] if(*((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)==irq::raster#0) goto irq::@1
  to:irq::@2
irq::@2: scope:[irq]  from irq::@1
  [7] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = -- *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR)
  to:irq::@return
irq::@return: scope:[irq]  from irq::@2
  [8] return 
  to:@return

void main()
main: scope:[main]  from
  asm { sei  }
  [10] call memoryRemap 
  to:main::@4
main::@4: scope:[main]  from main
  [11] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47
  [12] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53
  [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40
  [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40
  [15] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK
  [16] *PROCPORT = PROCPORT_RAM_IO
  [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1
  [18] call memcpy_dma4 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [19] phi()
  [20] call memoryRemapBlock 
  to:main::@6
main::@6: scope:[main]  from main::@5
  asm { lda#0  }
  [22] call *musicInit 
  [23] call memoryRemap 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [24] *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR
  [25] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff
  [26] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f
  [27] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER
  [28] *HARDWARE_IRQ = &irq
  asm { cli  }
  to:main::@1
main::@1: scope:[main]  from main::@2 main::@7
  [30] main::mem_destroy_i#2 = phi( main::@2/main::mem_destroy_i#1, main::@7/0 )
  [31] MUSIC[main::mem_destroy_i#2] = ++ MUSIC[main::mem_destroy_i#2]
  [32] main::mem_destroy_i#1 = ++ main::mem_destroy_i#2
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@3
  [33] main::i#2 = phi( main::@1/0, main::@3/main::i#1 )
  [34] if(main::i#2<$f0) goto main::@3
  to:main::@1
main::@3: scope:[main]  from main::@2
  [35] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2]
  [36] main::i#1 = ++ main::i#2
  to:main::@2

void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
memoryRemapBlock: scope:[memoryRemapBlock]  from irq main::@5
  [37] phi()
  [38] call memoryRemap 
  to:memoryRemapBlock::@return
memoryRemapBlock::@return: scope:[memoryRemapBlock]  from memoryRemapBlock
  [39] return 
  to:@return

void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from irq::@3 main main::@6 memoryRemapBlock
  [40] memoryRemap::upperPageOffset#4 = phi( irq::@3/0, main/0, main::@6/0, memoryRemapBlock/memoryRemapBlock::pageOffset#0 )
  [40] memoryRemap::remapBlocks#4 = phi( irq::@3/0, main/0, main::@6/0, memoryRemapBlock/memoryRemapBlock::blockBits#0 )
  [40] memoryRemap::lowerPageOffset#4 = phi( irq::@3/0, main/0, main::@6/0, memoryRemapBlock/memoryRemapBlock::pageOffset#0 )
  [41] memoryRemap::$0 = < memoryRemap::lowerPageOffset#4
  [42] *memoryRemap::aVal = memoryRemap::$0
  [43] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4
  [44] memoryRemap::$2 = > memoryRemap::lowerPageOffset#4
  [45] memoryRemap::$3 = memoryRemap::$2 & $f
  [46] memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
  [47] *memoryRemap::xVal = memoryRemap::$4
  [48] memoryRemap::$5 = < memoryRemap::upperPageOffset#4
  [49] *memoryRemap::yVal = memoryRemap::$5
  [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0
  [51] memoryRemap::$7 = > memoryRemap::upperPageOffset#4
  [52] memoryRemap::$8 = memoryRemap::$7 & $f
  [53] memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
  [54] *memoryRemap::zVal = memoryRemap::$9
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  [56] return 
  to:@return

void memcpy_dma4(byte memcpy_dma4::dest_bank , void* memcpy_dma4::dest , byte memcpy_dma4::src_bank , void* memcpy_dma4::src , word memcpy_dma4::num)
memcpy_dma4: scope:[memcpy_dma4]  from main::@4
  [57] memcpy_dma4::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  [58] *((word*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0
  [59] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0
  [60] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memcpy_dma4::src#0
  [61] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0
  [62] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memcpy_dma4::dest#0
  [63] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  [64] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&memcpy_dma_command4
  [67] *((byte*)DMA) = <&memcpy_dma_command4
  [68] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma4::dmaMode#0
  to:memcpy_dma4::@return
memcpy_dma4::@return: scope:[memcpy_dma4]  from memcpy_dma4
  [69] return 
  to:@return


VARIABLE REGISTER WEIGHTS
interrupt(HARDWARE_STACK) void irq()
byte irq::raster
byte irq::raster#0 6.5
void main()
byte main::i
byte main::i#1 202.0
byte main::i#2 168.33333333333331
byte main::mem_destroy_i
byte main::mem_destroy_i#1 22.4
byte main::mem_destroy_i#2 67.0
void memcpy_dma4(byte memcpy_dma4::dest_bank , void* memcpy_dma4::dest , byte memcpy_dma4::src_bank , void* memcpy_dma4::src , word memcpy_dma4::num)
void* memcpy_dma4::dest
byte memcpy_dma4::dest_bank
byte memcpy_dma4::dmaMode
byte memcpy_dma4::dmaMode#0 2.0
word memcpy_dma4::num
void* memcpy_dma4::src
byte memcpy_dma4::src_bank
struct DMA_LIST_F018B memcpy_dma_command4 loadstore = { command: DMA_COMMAND_COPY, count: 0, src: (byte*) 0, src_bank: 0, dest: (byte*) 0, dest_bank: 0, sub_command: 0, modulo: 0 }
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
byte~ memoryRemap::$0 202.0
byte~ memoryRemap::$1 67.33333333333333
byte~ memoryRemap::$2 202.0
byte~ memoryRemap::$3 202.0
byte~ memoryRemap::$4 202.0
byte~ memoryRemap::$5 202.0
byte~ memoryRemap::$6 67.33333333333333
byte~ memoryRemap::$7 202.0
byte~ memoryRemap::$8 202.0
byte~ memoryRemap::$9 202.0
word memoryRemap::lowerPageOffset
word memoryRemap::lowerPageOffset#4 50.5
byte memoryRemap::remapBlocks
byte memoryRemap::remapBlocks#4 20.2
word memoryRemap::upperPageOffset
word memoryRemap::upperPageOffset#4 18.363636363636363
void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
byte memoryRemapBlock::block
byte memoryRemapBlock::blockBits
byte memoryRemapBlock::blockPage
word memoryRemapBlock::memoryPage
word memoryRemapBlock::pageOffset

Initial phi equivalence classes
[ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
[ main::i#2 main::i#1 ]
[ memoryRemap::lowerPageOffset#4 ]
[ memoryRemap::remapBlocks#4 ]
[ memoryRemap::upperPageOffset#4 ]
Added variable irq::raster#0 to live range equivalence class [ irq::raster#0 ]
Added variable memoryRemap::$0 to live range equivalence class [ memoryRemap::$0 ]
Added variable memoryRemap::$1 to live range equivalence class [ memoryRemap::$1 ]
Added variable memoryRemap::$2 to live range equivalence class [ memoryRemap::$2 ]
Added variable memoryRemap::$3 to live range equivalence class [ memoryRemap::$3 ]
Added variable memoryRemap::$4 to live range equivalence class [ memoryRemap::$4 ]
Added variable memoryRemap::$5 to live range equivalence class [ memoryRemap::$5 ]
Added variable memoryRemap::$6 to live range equivalence class [ memoryRemap::$6 ]
Added variable memoryRemap::$7 to live range equivalence class [ memoryRemap::$7 ]
Added variable memoryRemap::$8 to live range equivalence class [ memoryRemap::$8 ]
Added variable memoryRemap::$9 to live range equivalence class [ memoryRemap::$9 ]
Added variable memcpy_dma4::dmaMode#0 to live range equivalence class [ memcpy_dma4::dmaMode#0 ]
Added variable memcpy_dma_command4 to live range equivalence class [ memcpy_dma_command4 ]
Complete equivalence classes
[ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
[ main::i#2 main::i#1 ]
[ memoryRemap::lowerPageOffset#4 ]
[ memoryRemap::remapBlocks#4 ]
[ memoryRemap::upperPageOffset#4 ]
[ irq::raster#0 ]
[ memoryRemap::$0 ]
[ memoryRemap::$1 ]
[ memoryRemap::$2 ]
[ memoryRemap::$3 ]
[ memoryRemap::$4 ]
[ memoryRemap::$5 ]
[ memoryRemap::$6 ]
[ memoryRemap::$7 ]
[ memoryRemap::$8 ]
[ memoryRemap::$9 ]
[ memcpy_dma4::dmaMode#0 ]
[ memcpy_dma_command4 ]
Allocated zp[1]:2 [ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
Allocated zp[1]:3 [ main::i#2 main::i#1 ]
Allocated zp[2]:4 [ memoryRemap::lowerPageOffset#4 ]
Allocated zp[1]:6 [ memoryRemap::remapBlocks#4 ]
Allocated zp[2]:7 [ memoryRemap::upperPageOffset#4 ]
Allocated zp[1]:9 [ irq::raster#0 ]
Allocated zp[1]:10 [ memoryRemap::$0 ]
Allocated zp[1]:11 [ memoryRemap::$1 ]
Allocated zp[1]:12 [ memoryRemap::$2 ]
Allocated zp[1]:13 [ memoryRemap::$3 ]
Allocated zp[1]:14 [ memoryRemap::$4 ]
Allocated zp[1]:15 [ memoryRemap::$5 ]
Allocated zp[1]:16 [ memoryRemap::$6 ]
Allocated zp[1]:17 [ memoryRemap::$7 ]
Allocated zp[1]:18 [ memoryRemap::$8 ]
Allocated zp[1]:19 [ memoryRemap::$9 ]
Allocated zp[1]:20 [ memcpy_dma4::dmaMode#0 ]
Allocated mem[12] [ memcpy_dma_command4 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] call *musicPlay  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [8] return  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [11] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [12] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [15] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [16] *PROCPORT = PROCPORT_RAM_IO [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement asm { lda#0  } always clobbers reg byte a 
Statement [22] call *musicInit  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [24] *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [25] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [26] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [27] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [28] *HARDWARE_IRQ = &irq [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [35] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2] [ main::mem_destroy_i#1 main::i#2 ] (  [ main::mem_destroy_i#1 main::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ main::i#2 main::i#1 ]
Statement [43] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] ( memoryRemap:4 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  memoryRemap:10 [ memcpy_dma_command4 memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  memoryRemap:23 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  memoryRemapBlock:2::memoryRemap:38 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  memoryRemapBlock:20::memoryRemap:38 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:6 [ memoryRemap::remapBlocks#4 ]
Statement [45] memoryRemap::$3 = memoryRemap::$2 & $f [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] ( memoryRemap:4 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemap:10 [ memcpy_dma_command4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemap:23 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:2::memoryRemap:38 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:20::memoryRemap:38 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:11 [ memoryRemap::$1 ]
Statement [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] ( memoryRemap:4 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  memoryRemap:10 [ memcpy_dma_command4 memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  memoryRemap:23 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  memoryRemapBlock:2::memoryRemap:38 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  memoryRemapBlock:20::memoryRemap:38 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  ) always clobbers reg byte a 
Statement [52] memoryRemap::$8 = memoryRemap::$7 & $f [ memoryRemap::$6 memoryRemap::$8 ] ( memoryRemap:4 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemap:10 [ memcpy_dma_command4 memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemap:23 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:2::memoryRemap:38 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:20::memoryRemap:38 [ memoryRemap::$6 memoryRemap::$8 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:16 [ memoryRemap::$6 ]
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [58] *((word*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:20 [ memcpy_dma4::dmaMode#0 ]
Statement [59] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [60] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memcpy_dma4::src#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [61] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [62] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memcpy_dma4::dest#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [63] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [64] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&memcpy_dma_command4 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [67] *((byte*)DMA) = <&memcpy_dma_command4 [ memcpy_dma4::dmaMode#0 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [0] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] call *musicPlay  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [8] return  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [11] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [12] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [15] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [16] *PROCPORT = PROCPORT_RAM_IO [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement asm { lda#0  } always clobbers reg byte a 
Statement [22] call *musicInit  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [24] *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [25] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [26] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [27] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [28] *HARDWARE_IRQ = &irq [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [35] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2] [ main::mem_destroy_i#1 main::i#2 ] (  [ main::mem_destroy_i#1 main::i#2 ] { }  ) always clobbers reg byte a 
Statement [43] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] ( memoryRemap:4 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  memoryRemap:10 [ memcpy_dma_command4 memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  memoryRemap:23 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  memoryRemapBlock:2::memoryRemap:38 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  memoryRemapBlock:20::memoryRemap:38 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 ] { }  ) always clobbers reg byte a 
Statement [45] memoryRemap::$3 = memoryRemap::$2 & $f [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] ( memoryRemap:4 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemap:10 [ memcpy_dma_command4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemap:23 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:2::memoryRemap:38 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:20::memoryRemap:38 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::$1 memoryRemap::$3 ] { }  ) always clobbers reg byte a 
Statement [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] ( memoryRemap:4 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  memoryRemap:10 [ memcpy_dma_command4 memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  memoryRemap:23 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  memoryRemapBlock:2::memoryRemap:38 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  memoryRemapBlock:20::memoryRemap:38 [ memoryRemap::upperPageOffset#4 memoryRemap::$6 ] { }  ) always clobbers reg byte a 
Statement [52] memoryRemap::$8 = memoryRemap::$7 & $f [ memoryRemap::$6 memoryRemap::$8 ] ( memoryRemap:4 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemap:10 [ memcpy_dma_command4 memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemap:23 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:2::memoryRemap:38 [ memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:20::memoryRemap:38 [ memoryRemap::$6 memoryRemap::$8 ] { }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [58] *((word*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [59] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [60] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memcpy_dma4::src#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [61] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [62] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memcpy_dma4::dest#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [63] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [64] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&memcpy_dma_command4 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [67] *((byte*)DMA) = <&memcpy_dma_command4 [ memcpy_dma4::dmaMode#0 ] ( memcpy_dma4:18 [ memcpy_dma4::dmaMode#0 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::mem_destroy_i#2 main::mem_destroy_i#1 ] : zp[1]:2 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:3 [ main::i#2 main::i#1 ] : zp[1]:3 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:4 [ memoryRemap::lowerPageOffset#4 ] : zp[2]:4 , 
Potential registers zp[1]:6 [ memoryRemap::remapBlocks#4 ] : zp[1]:6 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:7 [ memoryRemap::upperPageOffset#4 ] : zp[2]:7 , 
Potential registers zp[1]:9 [ irq::raster#0 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:10 [ memoryRemap::$0 ] : zp[1]:10 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:11 [ memoryRemap::$1 ] : zp[1]:11 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:12 [ memoryRemap::$2 ] : zp[1]:12 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:13 [ memoryRemap::$3 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:14 [ memoryRemap::$4 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:15 [ memoryRemap::$5 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:16 [ memoryRemap::$6 ] : zp[1]:16 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:17 [ memoryRemap::$7 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:18 [ memoryRemap::$8 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:19 [ memoryRemap::$9 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:20 [ memcpy_dma4::dmaMode#0 ] : zp[1]:20 , reg byte x , reg byte y , reg byte z , 
Potential registers mem[12] [ memcpy_dma_command4 ] : mem[12] , 

REGISTER UPLIFT SCOPES
Uplift Scope [memoryRemap] 202: zp[1]:10 [ memoryRemap::$0 ] 202: zp[1]:12 [ memoryRemap::$2 ] 202: zp[1]:13 [ memoryRemap::$3 ] 202: zp[1]:14 [ memoryRemap::$4 ] 202: zp[1]:15 [ memoryRemap::$5 ] 202: zp[1]:17 [ memoryRemap::$7 ] 202: zp[1]:18 [ memoryRemap::$8 ] 202: zp[1]:19 [ memoryRemap::$9 ] 67.33: zp[1]:11 [ memoryRemap::$1 ] 67.33: zp[1]:16 [ memoryRemap::$6 ] 50.5: zp[2]:4 [ memoryRemap::lowerPageOffset#4 ] 20.2: zp[1]:6 [ memoryRemap::remapBlocks#4 ] 18.36: zp[2]:7 [ memoryRemap::upperPageOffset#4 ] 
Uplift Scope [main] 370.33: zp[1]:3 [ main::i#2 main::i#1 ] 89.4: zp[1]:2 [ main::mem_destroy_i#2 main::mem_destroy_i#1 ] 
Uplift Scope [irq] 6.5: zp[1]:9 [ irq::raster#0 ] 
Uplift Scope [memcpy_dma4] 2: zp[1]:20 [ memcpy_dma4::dmaMode#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [MOS4569_VICIII] 
Uplift Scope [MEGA65_VICIV] 
Uplift Scope [memoryRemapBlock] 
Uplift Scope [F018_DMAGIC] 
Uplift Scope [DMA_LIST_F018A] 
Uplift Scope [DMA_LIST_F018B] 
Uplift Scope [] 0: mem[12] [ memcpy_dma_command4 ] 

Uplifting [memoryRemap] best 4664 combination reg byte a [ memoryRemap::$0 ] reg byte a [ memoryRemap::$2 ] reg byte a [ memoryRemap::$3 ] zp[1]:14 [ memoryRemap::$4 ] zp[1]:15 [ memoryRemap::$5 ] zp[1]:17 [ memoryRemap::$7 ] zp[1]:18 [ memoryRemap::$8 ] zp[1]:19 [ memoryRemap::$9 ] zp[1]:11 [ memoryRemap::$1 ] zp[1]:16 [ memoryRemap::$6 ] zp[2]:4 [ memoryRemap::lowerPageOffset#4 ] zp[1]:6 [ memoryRemap::remapBlocks#4 ] zp[2]:7 [ memoryRemap::upperPageOffset#4 ] 
Limited combination testing to 100 combinations of 25000000 possible.
Uplifting [main] best 3374 combination reg byte y [ main::i#2 main::i#1 ] reg byte x [ main::mem_destroy_i#2 main::mem_destroy_i#1 ] 
Uplifting [irq] best 3341 combination reg byte a [ irq::raster#0 ] 
Uplifting [memcpy_dma4] best 3335 combination reg byte x [ memcpy_dma4::dmaMode#0 ] 
Uplifting [MOS6526_CIA] best 3335 combination 
Uplifting [MOS6569_VICII] best 3335 combination 
Uplifting [MOS6581_SID] best 3335 combination 
Uplifting [MOS4569_VICIII] best 3335 combination 
Uplifting [MEGA65_VICIV] best 3335 combination 
Uplifting [memoryRemapBlock] best 3335 combination 
Uplifting [F018_DMAGIC] best 3335 combination 
Uplifting [DMA_LIST_F018A] best 3335 combination 
Uplifting [DMA_LIST_F018B] best 3335 combination 
Uplifting [] best 3335 combination mem[12] [ memcpy_dma_command4 ] 
Attempting to uplift remaining variables inzp[1]:14 [ memoryRemap::$4 ]
Uplifting [memoryRemap] best 3329 combination reg byte a [ memoryRemap::$4 ] 
Attempting to uplift remaining variables inzp[1]:15 [ memoryRemap::$5 ]
Uplifting [memoryRemap] best 3323 combination reg byte a [ memoryRemap::$5 ] 
Attempting to uplift remaining variables inzp[1]:17 [ memoryRemap::$7 ]
Uplifting [memoryRemap] best 3317 combination reg byte a [ memoryRemap::$7 ] 
Attempting to uplift remaining variables inzp[1]:18 [ memoryRemap::$8 ]
Uplifting [memoryRemap] best 3311 combination reg byte a [ memoryRemap::$8 ] 
Attempting to uplift remaining variables inzp[1]:19 [ memoryRemap::$9 ]
Uplifting [memoryRemap] best 3305 combination reg byte a [ memoryRemap::$9 ] 
Attempting to uplift remaining variables inzp[1]:11 [ memoryRemap::$1 ]
Uplifting [memoryRemap] best 3305 combination zp[1]:11 [ memoryRemap::$1 ] 
Attempting to uplift remaining variables inzp[1]:16 [ memoryRemap::$6 ]
Uplifting [memoryRemap] best 3305 combination zp[1]:16 [ memoryRemap::$6 ] 
Attempting to uplift remaining variables inzp[1]:6 [ memoryRemap::remapBlocks#4 ]
Uplifting [memoryRemap] best 3289 combination reg byte z [ memoryRemap::remapBlocks#4 ] 
Allocated (was zp[2]:4) zp[2]:2 [ memoryRemap::lowerPageOffset#4 ]
Allocated (was zp[2]:7) zp[2]:4 [ memoryRemap::upperPageOffset#4 ]
Allocated (was zp[1]:11) zp[1]:6 [ memoryRemap::$1 ]
Allocated (was zp[1]:16) zp[1]:7 [ memoryRemap::$6 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// SID music located in another bank being played in a raster IRQ using memory mapping on the MEGA65
// Music is Cybernoid II by Jeroen Tel released in 1988 by Hewson https://csdb.dk/sid/?id=28140
// SID relocated using http://www.linusakesson.net/software/sidreloc/index.php
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable with banked code and data starting in MEGA65 mode.
.file [name="banked-music.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segmentdef Banked [segments="CodeBanked, DataBanked"]
.segmentdef CodeBanked [start=$4000]
.segmentdef DataBanked [startAfter="CodeBanked"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // DMA command copy
  .const DMA_COMMAND_COPY = 0
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
  .const OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // The VIC III MOS 4567/4569
  .label VICIII = $d000
  // The VIC IV
  .label VICIV = $d000
  // DMAgic F018 Controller
  .label DMA = $d700
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Address after the end of the music
  .label MUSIC_END = $5200
  // Pointer to the music init routine
  .label musicInit = MUSIC
  // Pointer to the music play routine
  .label musicPlay = MUSIC+3
.segment Code
  // irq
// Raster IRQ routine
irq: {
    // entry interrupt(HARDWARE_STACK)
    pha
    txa
    pha
    tya
    pha
    // [0] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // [1] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = ++ *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [2] call memoryRemapBlock 
  // Remap memory to put music at $4000
    // [37] phi from irq to memoryRemapBlock [phi:irq->memoryRemapBlock]
  memoryRemapBlock_from_irq:
    jsr memoryRemapBlock
    jmp __b3
    // irq::@3
  __b3:
    // [3] call *musicPlay 
    // Play remapped SID
    jsr musicPlay
    // [4] call memoryRemap 
  // Reset memory mapping
    // [40] phi from irq::@3 to memoryRemap [phi:irq::@3->memoryRemap]
  memoryRemap_from___b3:
    // [40] phi memoryRemap::upperPageOffset#4 = 0 [phi:irq::@3->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    lda #>0
    sta.z memoryRemap.upperPageOffset+1
    // [40] phi memoryRemap::remapBlocks#4 = 0 [phi:irq::@3->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [40] phi memoryRemap::lowerPageOffset#4 = 0 [phi:irq::@3->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.lowerPageOffset
    lda #>0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __b4
    // irq::@4
  __b4:
    // [5] irq::raster#0 = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) -- vbuaa=_deref_pbuc1 
    // Wait for the next raster line
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    jmp __b1
    // irq::@1
  __b1:
    // [6] if(*((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)==irq::raster#0) goto irq::@1 -- _deref_pbuc1_eq_vbuaa_then_la1 
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    beq __b1
    jmp __b2
    // irq::@2
  __b2:
    // [7] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = -- *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    jmp __breturn
    // irq::@return
  __breturn:
    // [8] return  - exit interrupt(HARDWARE_STACK)
    pla
    tay
    pla
    tax
    pla
    rti
}
  // main
main: {
    // asm { sei  }
    // Stop IRQ's
    sei
    // [10] call memoryRemap 
  // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    // [40] phi from main to memoryRemap [phi:main->memoryRemap]
  memoryRemap_from_main:
    // [40] phi memoryRemap::upperPageOffset#4 = 0 [phi:main->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    lda #>0
    sta.z memoryRemap.upperPageOffset+1
    // [40] phi memoryRemap::remapBlocks#4 = 0 [phi:main->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [40] phi memoryRemap::lowerPageOffset#4 = 0 [phi:main->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.lowerPageOffset
    lda #>0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __b4
    // main::@4
  __b4:
    // [11] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47 -- _deref_pbuc1=vbuc2 
    // Enable MEGA65 features
    lda #$47
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // [12] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53 -- _deref_pbuc1=vbuc2 
    lda #$53
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable 48MHz fast mode
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // [15] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // no kernal or BASIC rom visible
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // [16] *PROCPORT = PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1 -- _deref_pbuc1=vbuc2 
    // open sideborder
    lda #1
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO
    // [18] call memcpy_dma4 
    // Transfer banked code/data to upper memory ($10000)
    jsr memcpy_dma4
    // [19] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    jmp __b5
    // main::@5
  __b5:
    // [20] call memoryRemapBlock 
  // Remap [$4000-$5fff] to point to [$10000-$11fff]
    // [37] phi from main::@5 to memoryRemapBlock [phi:main::@5->memoryRemapBlock]
  memoryRemapBlock_from___b5:
    jsr memoryRemapBlock
    jmp __b6
    // main::@6
  __b6:
    // asm { lda#0  }
    // Initialize SID 
    lda #0
    // [22] call *musicInit 
    jsr musicInit
    // [23] call memoryRemap 
  // Reset memory mapping
    // [40] phi from main::@6 to memoryRemap [phi:main::@6->memoryRemap]
  memoryRemap_from___b6:
    // [40] phi memoryRemap::upperPageOffset#4 = 0 [phi:main::@6->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    lda #>0
    sta.z memoryRemap.upperPageOffset+1
    // [40] phi memoryRemap::remapBlocks#4 = 0 [phi:main::@6->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [40] phi memoryRemap::lowerPageOffset#4 = 0 [phi:main::@6->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.lowerPageOffset
    lda #>0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __b7
    // main::@7
  __b7:
    // [24] *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Set up raster interrupts C64 style
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // [25] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff -- _deref_pbuc1=vbuc2 
    // Set raster line to 0xff
    lda #$ff
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [26] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // [27] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // [28] *HARDWARE_IRQ = &irq -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta HARDWARE_IRQ
    lda #>irq
    sta HARDWARE_IRQ+1
    // asm { cli  }
    // Enable IRQ
    cli
    // [30] phi from main::@7 to main::@1 [phi:main::@7->main::@1]
  __b1_from___b7:
    // [30] phi main::mem_destroy_i#2 = 0 [phi:main::@7->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // main::@1
  __b1:
    // [31] MUSIC[main::mem_destroy_i#2] = ++ MUSIC[main::mem_destroy_i#2] -- pbuc1_derefidx_vbuxx=_inc_pbuc1_derefidx_vbuxx 
    inc MUSIC,x
    // [32] main::mem_destroy_i#1 = ++ main::mem_destroy_i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [33] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    // [33] phi main::i#2 = 0 [phi:main::@1->main::@2#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b2
  // Show unmapped MUSIC memory
    // main::@2
  __b2:
    // [34] if(main::i#2<$f0) goto main::@3 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$f0
    bcc __b3
    // [30] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [30] phi main::mem_destroy_i#2 = main::mem_destroy_i#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
    // main::@3
  __b3:
    // [35] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2] -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MUSIC,y
    sta DEFAULT_SCREEN,y
    // [36] main::i#1 = ++ main::i#2 -- vbuyy=_inc_vbuyy 
    iny
    // [33] phi from main::@3 to main::@2 [phi:main::@3->main::@2]
  __b2_from___b3:
    // [33] phi main::i#2 = main::i#1 [phi:main::@3->main::@2#0] -- register_copy 
    jmp __b2
}
  // memoryRemapBlock
// Remap a single 8K memory block in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// All the other 8K memory blocks will not be mapped and will point to their own address in the lowest 64K of the MEGA65 memory.
// blockPage: Page address of the 8K memory block to remap (ie. the block that is remapped is $100 * the passed page address.)
// memoryPage: Page address of the memory that the block should point to in the 1MB memory space of the MEGA65.
// Ie. the memory that will be pointed to is $100 * the passed page address. Only the lower 12bits of the passed value is used.
memoryRemapBlock: {
    .const pageOffset = $100-$40
    .const block = $40>>5
    .const blockBits = 1<<block
    // [38] call memoryRemap 
    // [40] phi from memoryRemapBlock to memoryRemap [phi:memoryRemapBlock->memoryRemap]
  memoryRemap_from_memoryRemapBlock:
    // [40] phi memoryRemap::upperPageOffset#4 = memoryRemapBlock::pageOffset#0 [phi:memoryRemapBlock->memoryRemap#0] -- vwuz1=vwuc1 
    lda #<pageOffset
    sta.z memoryRemap.upperPageOffset
    lda #>pageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [40] phi memoryRemap::remapBlocks#4 = memoryRemapBlock::blockBits#0 [phi:memoryRemapBlock->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #blockBits
    // [40] phi memoryRemap::lowerPageOffset#4 = memoryRemapBlock::pageOffset#0 [phi:memoryRemapBlock->memoryRemap#2] -- vwuz1=vwuc1 
    lda #<pageOffset
    sta.z memoryRemap.lowerPageOffset
    lda #>pageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __breturn
    // memoryRemapBlock::@return
  __breturn:
    // [39] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// memoryRemap(byte register(Z) remapBlocks, word zp(2) lowerPageOffset, word zp(4) upperPageOffset)
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __1 = 6
    .label __6 = 7
    .label lowerPageOffset = 2
    .label upperPageOffset = 4
    // [41] memoryRemap::$0 = < memoryRemap::lowerPageOffset#4 -- vbuaa=_lo_vwuz1 
    lda.z lowerPageOffset
    // [42] *memoryRemap::aVal = memoryRemap::$0 -- _deref_pbuc1=vbuaa 
    sta aVal
    // [43] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __1
    // [44] memoryRemap::$2 = > memoryRemap::lowerPageOffset#4 -- vbuaa=_hi_vwuz1 
    lda.z lowerPageOffset+1
    // [45] memoryRemap::$3 = memoryRemap::$2 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [46] memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // [47] *memoryRemap::xVal = memoryRemap::$4 -- _deref_pbuc1=vbuaa 
    sta xVal
    // [48] memoryRemap::$5 = < memoryRemap::upperPageOffset#4 -- vbuaa=_lo_vwuz1 
    lda.z upperPageOffset
    // [49] *memoryRemap::yVal = memoryRemap::$5 -- _deref_pbuc1=vbuaa 
    sta yVal
    // [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0 -- vbuz1=vbuzz_band_vbuc1 
    tza
    and #$f0
    sta.z __6
    // [51] memoryRemap::$7 = > memoryRemap::upperPageOffset#4 -- vbuaa=_hi_vwuz1 
    lda.z upperPageOffset+1
    // [52] memoryRemap::$8 = memoryRemap::$7 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [53] memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // [54] *memoryRemap::zVal = memoryRemap::$9 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [56] return 
    rts
}
  // memcpy_dma4
// Copy a memory block anywhere in first 4MB memory space using MEGA65 DMagic DMA
// Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination.
// - dest_bank The 64KB bank for the destination (0-63)
// - dest The destination address (within the MB and bank)
// - src_bank The 64KB bank for the source (0-63)
// - src The source address (within the MB and bank)
// - num The number of bytes to copy
memcpy_dma4: {
    .const num = MUSIC_END-MUSIC
    .const dest_bank = 1
    .const src_bank = 0
    .label dest = 0
    .label src = upperCodeData
    // [57] memcpy_dma4::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [58] *((word*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0 -- _deref_pwuc1=vwuc2 
    // Set up command
    lda #<num
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // [59] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0 -- _deref_pbuc1=vbuc2 
    lda #src_bank
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK
    // [60] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memcpy_dma4::src#0 -- _deref_qbuc1=pbuc2 
    lda #<src
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>src
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // [61] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0 -- _deref_pbuc1=vbuc2 
    lda #dest_bank
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
    // [62] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memcpy_dma4::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // [63] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [64] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&memcpy_dma_command4 -- _deref_pbuc1=vbuc2 
    lda #>memcpy_dma_command4
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // [67] *((byte*)DMA) = <&memcpy_dma_command4 -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<memcpy_dma_command4
    sta DMA
    // [68] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma4::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    jmp __breturn
    // memcpy_dma4::@return
  __breturn:
    // [69] return 
    rts
}
  // File Data
.segment Data
  // Array containing the banked upper memory code/data to be transferred to upper memory before execution
upperCodeData:
.segmentout [segments="Banked"]

  // DMA list entry for copying data in the 1MB memory space
  memcpy_dma_command4: .byte DMA_COMMAND_COPY
  .word 0, 0
  .byte 0
  .word 0
  .byte 0, 0
  .word 0
.segment DataBanked
.pc = $4000 "MUSIC"
// SID tune at an absolute address
MUSIC:
.const music = LoadSid("Cybernoid_II_4000.sid")
    .fill music.size, music.getData(i)


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #>0
Removing instruction lda #<0
Removing instruction lda #>0
Removing instruction lda #>0
Removing instruction lda #<0
Removing instruction lda #>0
Removing instruction lda #>0
Removing instruction lda #<0
Removing instruction lda #>0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b5_from___b4:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction memoryRemapBlock_from_irq:
Removing instruction __b3:
Removing instruction memoryRemap_from___b3:
Removing instruction __b4:
Removing instruction __b2:
Removing instruction __breturn:
Removing instruction memoryRemap_from_main:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction memoryRemapBlock_from___b5:
Removing instruction __b6:
Removing instruction memoryRemap_from___b6:
Removing instruction __b7:
Removing instruction __b1_from___b7:
Removing instruction __b2_from___b1:
Removing instruction __b1_from___b2:
Removing instruction __b2_from___b3:
Removing instruction memoryRemap_from_memoryRemapBlock:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
const nomodify struct MOS6526_CIA* CIA1 = (struct MOS6526_CIA*) 56320
const nomodify byte CIA_INTERRUPT_CLEAR = $7f
const nomodify byte* DEFAULT_SCREEN = (byte*) 2048
const nomodify struct F018_DMAGIC* DMA = (struct F018_DMAGIC*) 55040
const nomodify byte DMA_COMMAND_COPY = 0
const nomodify void()** HARDWARE_IRQ = (void()**) 65534
const nomodify byte IRQ_RASTER = 1
const byte* MUSIC[]  = kickasm {{ .const music = LoadSid("Cybernoid_II_4000.sid")
    .fill music.size, music.getData(i)
 }}
const nomodify byte* MUSIC_END = (byte*) 20992
const byte OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
const byte OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
const byte OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
const byte OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
const byte OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
const byte OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
const byte OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
const byte OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
const byte OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
const byte OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
const byte OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
const byte OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
const byte OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
const byte OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
const byte OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
const byte OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
const byte OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
const nomodify byte* PROCPORT = (byte*) 1
const nomodify byte* PROCPORT_DDR = (byte*) 0
const nomodify byte PROCPORT_DDR_MEMORY_MASK = 7
const nomodify byte PROCPORT_RAM_IO = 5
const nomodify struct MOS6569_VICII* VICII = (struct MOS6569_VICII*) 53248
const nomodify struct MOS4569_VICIII* VICIII = (struct MOS4569_VICIII*) 53248
const nomodify struct MEGA65_VICIV* VICIV = (struct MEGA65_VICIV*) 53248
interrupt(HARDWARE_STACK) void irq()
byte irq::raster
byte irq::raster#0 reg byte a 6.5
void main()
byte main::i
byte main::i#1 reg byte y 202.0
byte main::i#2 reg byte y 168.33333333333331
byte main::mem_destroy_i
byte main::mem_destroy_i#1 reg byte x 22.4
byte main::mem_destroy_i#2 reg byte x 67.0
void memcpy_dma4(byte memcpy_dma4::dest_bank , void* memcpy_dma4::dest , byte memcpy_dma4::src_bank , void* memcpy_dma4::src , word memcpy_dma4::num)
void* memcpy_dma4::dest
const void* memcpy_dma4::dest#0 dest = (void*) 0
byte memcpy_dma4::dest_bank
const byte memcpy_dma4::dest_bank#0 dest_bank = 1
byte memcpy_dma4::dmaMode
byte memcpy_dma4::dmaMode#0 reg byte x 2.0
word memcpy_dma4::num
const word memcpy_dma4::num#0 num = MUSIC_END-MUSIC
void* memcpy_dma4::src
const void* memcpy_dma4::src#0 src = (void*)upperCodeData
byte memcpy_dma4::src_bank
const byte memcpy_dma4::src_bank#0 src_bank = 0
struct DMA_LIST_F018B memcpy_dma_command4 loadstore mem[12] = { command: DMA_COMMAND_COPY, count: 0, src: (byte*) 0, src_bank: 0, dest: (byte*) 0, dest_bank: 0, sub_command: 0, modulo: 0 }
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
byte~ memoryRemap::$0 reg byte a 202.0
byte~ memoryRemap::$1 zp[1]:6 67.33333333333333
byte~ memoryRemap::$2 reg byte a 202.0
byte~ memoryRemap::$3 reg byte a 202.0
byte~ memoryRemap::$4 reg byte a 202.0
byte~ memoryRemap::$5 reg byte a 202.0
byte~ memoryRemap::$6 zp[1]:7 67.33333333333333
byte~ memoryRemap::$7 reg byte a 202.0
byte~ memoryRemap::$8 reg byte a 202.0
byte~ memoryRemap::$9 reg byte a 202.0
const byte* memoryRemap::aVal = (byte*) 252
word memoryRemap::lowerPageOffset
word memoryRemap::lowerPageOffset#4 lowerPageOffset zp[2]:2 50.5
byte memoryRemap::remapBlocks
byte memoryRemap::remapBlocks#4 reg byte z 20.2
word memoryRemap::upperPageOffset
word memoryRemap::upperPageOffset#4 upperPageOffset zp[2]:4 18.363636363636363
const byte* memoryRemap::xVal = (byte*) 253
const byte* memoryRemap::yVal = (byte*) 254
const byte* memoryRemap::zVal = (byte*) 255
void memoryRemapBlock(byte memoryRemapBlock::blockPage , word memoryRemapBlock::memoryPage)
byte memoryRemapBlock::block
const byte memoryRemapBlock::block#0 block = $40>>5
byte memoryRemapBlock::blockBits
const byte memoryRemapBlock::blockBits#0 blockBits = 1<<memoryRemapBlock::block#0
byte memoryRemapBlock::blockPage
word memoryRemapBlock::memoryPage
word memoryRemapBlock::pageOffset
const word memoryRemapBlock::pageOffset#0 pageOffset = $100-$40
const void()* musicInit = (void()*)MUSIC
const void()* musicPlay = (void()*)MUSIC+3
const byte* upperCodeData[]  = kickasm {{ .segmentout [segments="Banked"]
 }}

reg byte x [ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
reg byte y [ main::i#2 main::i#1 ]
zp[2]:2 [ memoryRemap::lowerPageOffset#4 ]
reg byte z [ memoryRemap::remapBlocks#4 ]
zp[2]:4 [ memoryRemap::upperPageOffset#4 ]
reg byte a [ irq::raster#0 ]
reg byte a [ memoryRemap::$0 ]
zp[1]:6 [ memoryRemap::$1 ]
reg byte a [ memoryRemap::$2 ]
reg byte a [ memoryRemap::$3 ]
reg byte a [ memoryRemap::$4 ]
reg byte a [ memoryRemap::$5 ]
zp[1]:7 [ memoryRemap::$6 ]
reg byte a [ memoryRemap::$7 ]
reg byte a [ memoryRemap::$8 ]
reg byte a [ memoryRemap::$9 ]
reg byte x [ memcpy_dma4::dmaMode#0 ]
mem[12] [ memcpy_dma_command4 ]


FINAL ASSEMBLER
Score: 2876

  // File Comments
// SID music located in another bank being played in a raster IRQ using memory mapping on the MEGA65
// Music is Cybernoid II by Jeroen Tel released in 1988 by Hewson https://csdb.dk/sid/?id=28140
// SID relocated using http://www.linusakesson.net/software/sidreloc/index.php
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable with banked code and data starting in MEGA65 mode.
.file [name="banked-music.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segmentdef Banked [segments="CodeBanked, DataBanked"]
.segmentdef CodeBanked [start=$4000]
.segmentdef DataBanked [startAfter="CodeBanked"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // DMA command copy
  .const DMA_COMMAND_COPY = 0
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
  .const OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // The VIC III MOS 4567/4569
  .label VICIII = $d000
  // The VIC IV
  .label VICIV = $d000
  // DMAgic F018 Controller
  .label DMA = $d700
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Address after the end of the music
  .label MUSIC_END = $5200
  // Pointer to the music init routine
  .label musicInit = MUSIC
  // Pointer to the music play routine
  .label musicPlay = MUSIC+3
.segment Code
  // irq
// Raster IRQ routine
irq: {
    // entry interrupt(HARDWARE_STACK)
    pha
    txa
    pha
    tya
    pha
    // VICII->IRQ_STATUS = IRQ_RASTER
    // [0] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // (VICII->BORDER_COLOR)++;
    // [1] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = ++ *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // memoryRemapBlock(0x40, 0x100)
    // [2] call memoryRemapBlock 
  // Remap memory to put music at $4000
    // [37] phi from irq to memoryRemapBlock [phi:irq->memoryRemapBlock]
    jsr memoryRemapBlock
    // irq::@3
    // (*musicPlay)()
    // [3] call *musicPlay 
    // Play remapped SID
    jsr musicPlay
    // memoryRemap(0,0,0)
    // [4] call memoryRemap 
  // Reset memory mapping
    // [40] phi from irq::@3 to memoryRemap [phi:irq::@3->memoryRemap]
    // [40] phi memoryRemap::upperPageOffset#4 = 0 [phi:irq::@3->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [40] phi memoryRemap::remapBlocks#4 = 0 [phi:irq::@3->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [40] phi memoryRemap::lowerPageOffset#4 = 0 [phi:irq::@3->memoryRemap#2] -- vwuz1=vbuc1 
    sta.z memoryRemap.lowerPageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // irq::@4
    // raster = VICII->RASTER
    // [5] irq::raster#0 = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) -- vbuaa=_deref_pbuc1 
    // Wait for the next raster line
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // irq::@1
  __b1:
    // while(VICII->RASTER==raster)
    // [6] if(*((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)==irq::raster#0) goto irq::@1 -- _deref_pbuc1_eq_vbuaa_then_la1 
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    beq __b1
    // irq::@2
    // (VICII->BORDER_COLOR)--;
    // [7] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = -- *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // irq::@return
    // }
    // [8] return  - exit interrupt(HARDWARE_STACK)
    pla
    tay
    pla
    tax
    pla
    rti
}
  // main
main: {
    // asm
    // asm { sei  }
    // Stop IRQ's
    sei
    // memoryRemap(0,0,0)
    // [10] call memoryRemap 
  // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    // [40] phi from main to memoryRemap [phi:main->memoryRemap]
    // [40] phi memoryRemap::upperPageOffset#4 = 0 [phi:main->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [40] phi memoryRemap::remapBlocks#4 = 0 [phi:main->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [40] phi memoryRemap::lowerPageOffset#4 = 0 [phi:main->memoryRemap#2] -- vwuz1=vbuc1 
    sta.z memoryRemap.lowerPageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // main::@4
    // VICIII->KEY = 0x47
    // [11] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47 -- _deref_pbuc1=vbuc2 
    // Enable MEGA65 features
    lda #$47
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // VICIII->KEY = 0x53
    // [12] *((byte*)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53 -- _deref_pbuc1=vbuc2 
    lda #$53
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // VICIV->CONTROLB |= 0x40
    // [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable 48MHz fast mode
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // VICIV->CONTROLC |= 0x40
    // [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK
    // [15] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // no kernal or BASIC rom visible
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // *PROCPORT = PROCPORT_RAM_IO
    // [16] *PROCPORT = PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // VICIV->SIDBDRWD_LO = 1
    // [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1 -- _deref_pbuc1=vbuc2 
    // open sideborder
    lda #1
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO
    // memcpy_dma4(1, 0x0000, 0, upperCodeData, MUSIC_END-MUSIC)
    // [18] call memcpy_dma4 
    // Transfer banked code/data to upper memory ($10000)
    jsr memcpy_dma4
    // [19] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
    // main::@5
    // memoryRemapBlock(0x40, 0x100)
    // [20] call memoryRemapBlock 
  // Remap [$4000-$5fff] to point to [$10000-$11fff]
    // [37] phi from main::@5 to memoryRemapBlock [phi:main::@5->memoryRemapBlock]
    jsr memoryRemapBlock
    // main::@6
    // asm
    // asm { lda#0  }
    // Initialize SID 
    lda #0
    // (*musicInit)()
    // [22] call *musicInit 
    jsr musicInit
    // memoryRemap(0,0,0)
    // [23] call memoryRemap 
  // Reset memory mapping
    // [40] phi from main::@6 to memoryRemap [phi:main::@6->memoryRemap]
    // [40] phi memoryRemap::upperPageOffset#4 = 0 [phi:main::@6->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [40] phi memoryRemap::remapBlocks#4 = 0 [phi:main::@6->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [40] phi memoryRemap::lowerPageOffset#4 = 0 [phi:main::@6->memoryRemap#2] -- vwuz1=vbuc1 
    sta.z memoryRemap.lowerPageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // main::@7
    // CIA1->INTERRUPT = CIA_INTERRUPT_CLEAR
    // [24] *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Set up raster interrupts C64 style
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // VICII->RASTER = 0xff
    // [25] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff -- _deref_pbuc1=vbuc2 
    // Set raster line to 0xff
    lda #$ff
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // VICII->CONTROL1 &= 0x7f
    // [26] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // VICII->IRQ_ENABLE = IRQ_RASTER
    // [27] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // *HARDWARE_IRQ = &irq
    // [28] *HARDWARE_IRQ = &irq -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta HARDWARE_IRQ
    lda #>irq
    sta HARDWARE_IRQ+1
    // asm
    // asm { cli  }
    // Enable IRQ
    cli
    // [30] phi from main::@7 to main::@1 [phi:main::@7->main::@1]
    // [30] phi main::mem_destroy_i#2 = 0 [phi:main::@7->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // main::@1
  __b1:
    // MUSIC[mem_destroy_i++]++;
    // [31] MUSIC[main::mem_destroy_i#2] = ++ MUSIC[main::mem_destroy_i#2] -- pbuc1_derefidx_vbuxx=_inc_pbuc1_derefidx_vbuxx 
    inc MUSIC,x
    // [32] main::mem_destroy_i#1 = ++ main::mem_destroy_i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [33] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // [33] phi main::i#2 = 0 [phi:main::@1->main::@2#0] -- vbuyy=vbuc1 
    ldy #0
  // Show unmapped MUSIC memory
    // main::@2
  __b2:
    // for(char i=0;i<240;i++)
    // [34] if(main::i#2<$f0) goto main::@3 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$f0
    bcc __b3
    // [30] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [30] phi main::mem_destroy_i#2 = main::mem_destroy_i#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
    // main::@3
  __b3:
    // DEFAULT_SCREEN[i] = MUSIC[i]
    // [35] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2] -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MUSIC,y
    sta DEFAULT_SCREEN,y
    // for(char i=0;i<240;i++)
    // [36] main::i#1 = ++ main::i#2 -- vbuyy=_inc_vbuyy 
    iny
    // [33] phi from main::@3 to main::@2 [phi:main::@3->main::@2]
    // [33] phi main::i#2 = main::i#1 [phi:main::@3->main::@2#0] -- register_copy 
    jmp __b2
}
  // memoryRemapBlock
// Remap a single 8K memory block in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// All the other 8K memory blocks will not be mapped and will point to their own address in the lowest 64K of the MEGA65 memory.
// blockPage: Page address of the 8K memory block to remap (ie. the block that is remapped is $100 * the passed page address.)
// memoryPage: Page address of the memory that the block should point to in the 1MB memory space of the MEGA65.
// Ie. the memory that will be pointed to is $100 * the passed page address. Only the lower 12bits of the passed value is used.
memoryRemapBlock: {
    .const pageOffset = $100-$40
    .const block = $40>>5
    .const blockBits = 1<<block
    // memoryRemap(blockBits, pageOffset, pageOffset)
    // [38] call memoryRemap 
    // [40] phi from memoryRemapBlock to memoryRemap [phi:memoryRemapBlock->memoryRemap]
    // [40] phi memoryRemap::upperPageOffset#4 = memoryRemapBlock::pageOffset#0 [phi:memoryRemapBlock->memoryRemap#0] -- vwuz1=vwuc1 
    lda #<pageOffset
    sta.z memoryRemap.upperPageOffset
    lda #>pageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [40] phi memoryRemap::remapBlocks#4 = memoryRemapBlock::blockBits#0 [phi:memoryRemapBlock->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #blockBits
    // [40] phi memoryRemap::lowerPageOffset#4 = memoryRemapBlock::pageOffset#0 [phi:memoryRemapBlock->memoryRemap#2] -- vwuz1=vwuc1 
    lda #<pageOffset
    sta.z memoryRemap.lowerPageOffset
    lda #>pageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // memoryRemapBlock::@return
    // }
    // [39] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// memoryRemap(byte register(Z) remapBlocks, word zp(2) lowerPageOffset, word zp(4) upperPageOffset)
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    .label __1 = 6
    .label __6 = 7
    .label lowerPageOffset = 2
    .label upperPageOffset = 4
    // <lowerPageOffset
    // [41] memoryRemap::$0 = < memoryRemap::lowerPageOffset#4 -- vbuaa=_lo_vwuz1 
    lda.z lowerPageOffset
    // *aVal = <lowerPageOffset
    // [42] *memoryRemap::aVal = memoryRemap::$0 -- _deref_pbuc1=vbuaa 
    sta aVal
    // remapBlocks << 4
    // [43] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __1
    // >lowerPageOffset
    // [44] memoryRemap::$2 = > memoryRemap::lowerPageOffset#4 -- vbuaa=_hi_vwuz1 
    lda.z lowerPageOffset+1
    // >lowerPageOffset & 0xf
    // [45] memoryRemap::$3 = memoryRemap::$2 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // (remapBlocks << 4)   | (>lowerPageOffset & 0xf)
    // [46] memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __1
    // *xVal = (remapBlocks << 4)   | (>lowerPageOffset & 0xf)
    // [47] *memoryRemap::xVal = memoryRemap::$4 -- _deref_pbuc1=vbuaa 
    sta xVal
    // <upperPageOffset
    // [48] memoryRemap::$5 = < memoryRemap::upperPageOffset#4 -- vbuaa=_lo_vwuz1 
    lda.z upperPageOffset
    // *yVal = <upperPageOffset
    // [49] *memoryRemap::yVal = memoryRemap::$5 -- _deref_pbuc1=vbuaa 
    sta yVal
    // remapBlocks & 0xf0
    // [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0 -- vbuz1=vbuzz_band_vbuc1 
    tza
    and #$f0
    sta.z __6
    // >upperPageOffset
    // [51] memoryRemap::$7 = > memoryRemap::upperPageOffset#4 -- vbuaa=_hi_vwuz1 
    lda.z upperPageOffset+1
    // >upperPageOffset & 0xf
    // [52] memoryRemap::$8 = memoryRemap::$7 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // (remapBlocks & 0xf0) | (>upperPageOffset & 0xf)
    // [53] memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8 -- vbuaa=vbuz1_bor_vbuaa 
    ora.z __6
    // *zVal = (remapBlocks & 0xf0) | (>upperPageOffset & 0xf)
    // [54] *memoryRemap::zVal = memoryRemap::$9 -- _deref_pbuc1=vbuaa 
    sta zVal
    // asm
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap::@return
    // }
    // [56] return 
    rts
}
  // memcpy_dma4
// Copy a memory block anywhere in first 4MB memory space using MEGA65 DMagic DMA
// Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination.
// - dest_bank The 64KB bank for the destination (0-63)
// - dest The destination address (within the MB and bank)
// - src_bank The 64KB bank for the source (0-63)
// - src The source address (within the MB and bank)
// - num The number of bytes to copy
memcpy_dma4: {
    .const num = MUSIC_END-MUSIC
    .const dest_bank = 1
    .const src_bank = 0
    .label dest = 0
    .label src = upperCodeData
    // dmaMode = DMA->EN018B
    // [57] memcpy_dma4::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memcpy_dma_command4.count = num
    // [58] *((word*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0 -- _deref_pwuc1=vwuc2 
    // Set up command
    lda #<num
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // memcpy_dma_command4.src_bank = src_bank
    // [59] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0 -- _deref_pbuc1=vbuc2 
    lda #src_bank
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK
    // memcpy_dma_command4.src = src
    // [60] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memcpy_dma4::src#0 -- _deref_qbuc1=pbuc2 
    lda #<src
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>src
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // memcpy_dma_command4.dest_bank = dest_bank
    // [61] *((byte*)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0 -- _deref_pbuc1=vbuc2 
    lda #dest_bank
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
    // memcpy_dma_command4.dest = dest
    // [62] *((byte**)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memcpy_dma4::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // DMA->EN018B = 1
    // [63] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // DMA->ADDRMB = 0
    // [64] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // DMA->ADDRBANK = 0
    // [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // DMA-> ADDRMSB = >&memcpy_dma_command4
    // [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = >&memcpy_dma_command4 -- _deref_pbuc1=vbuc2 
    lda #>memcpy_dma_command4
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // DMA-> ADDRLSBTRIG = <&memcpy_dma_command4
    // [67] *((byte*)DMA) = <&memcpy_dma_command4 -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<memcpy_dma_command4
    sta DMA
    // DMA->EN018B = dmaMode
    // [68] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma4::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memcpy_dma4::@return
    // }
    // [69] return 
    rts
}
  // File Data
.segment Data
  // Array containing the banked upper memory code/data to be transferred to upper memory before execution
upperCodeData:
.segmentout [segments="Banked"]

  // DMA list entry for copying data in the 1MB memory space
  memcpy_dma_command4: .byte DMA_COMMAND_COPY
  .word 0, 0
  .byte 0
  .word 0
  .byte 0, 0
  .word 0
.segment DataBanked
.pc = $4000 "MUSIC"
// SID tune at an absolute address
MUSIC:
.const music = LoadSid("Cybernoid_II_4000.sid")
    .fill music.size, music.getData(i)


