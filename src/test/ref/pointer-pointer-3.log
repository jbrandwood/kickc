Setting inferred volatile on symbol affected by address-of (byte**~) main::$0 ← & (byte*) screen
Setting inferred volatile on symbol affected by address-of (byte**~) main::$2 ← & (byte*) screen
Adding pointer type conversion cast (byte*) screen in (byte*) screen ← (number) $400
Adding pointer type conversion cast (byte*) screen1 in (byte*) screen1 ← (number) $400
Adding pointer type conversion cast (byte*) screen2 in (byte*) screen2 ← (number~) $0
Identified constant variable (byte*) screen1
Culled Empty Block (label) @1

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) screen#0 ← ((byte*)) (number) $400
  (byte*) screen1#0 ← ((byte*)) (number) $400
  (number~) $0 ← (number) $400 + (number) $28
  (byte*) screen2#0 ← ((byte*)) (number~) $0
  to:@2
main: scope:[main]  from @2
  (byte*) screen2#2 ← phi( @2/(byte*) screen2#3 )
  (byte*) screen#1 ← phi( @2/(byte*) screen#4 )
  (byte**~) main::$0 ← & (byte*) screen#1
  (byte**) setscreen::screen#0 ← (byte**~) main::$0
  (byte*) setscreen::val#0 ← (byte*) screen1#0
  call setscreen 
  to:main::@1
main::@1: scope:[main]  from main
  (byte*) screen2#1 ← phi( main/(byte*) screen2#2 )
  (byte*) screen#2 ← phi( main/(byte*) screen#1 )
  *((byte*) screen#2 + (number) 0) ← (byte) 'a'
  (byte**~) main::$2 ← & (byte*) screen#2
  (byte**) setscreen::screen#1 ← (byte**~) main::$2
  (byte*) setscreen::val#1 ← (byte*) screen2#1
  call setscreen 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte*) screen#3 ← phi( main::@1/(byte*) screen#2 )
  *((byte*) screen#3 + (number) 0) ← (byte) 'a'
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
setscreen: scope:[setscreen]  from main main::@1
  (byte**) setscreen::screen#2 ← phi( main/(byte**) setscreen::screen#0 main::@1/(byte**) setscreen::screen#1 )
  (byte*) setscreen::val#2 ← phi( main/(byte*) setscreen::val#0 main::@1/(byte*) setscreen::val#1 )
  *((byte**) setscreen::screen#2) ← (byte*) setscreen::val#2
  to:setscreen::@return
setscreen::@return: scope:[setscreen]  from setscreen
  return 
  to:@return
@2: scope:[]  from @begin
  (byte*) screen2#3 ← phi( @begin/(byte*) screen2#0 )
  (byte*) screen#4 ← phi( @begin/(byte*) screen#0 )
  call main 
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(number~) $0
(label) @2
(label) @3
(label) @begin
(label) @end
(void()) main()
(byte**~) main::$0
(byte**~) main::$2
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) screen
(byte*) screen#0
(byte*) screen#1
(byte*) screen#2
(byte*) screen#3
(byte*) screen#4
(byte*) screen1
(byte*) screen1#0
(byte*) screen2
(byte*) screen2#0
(byte*) screen2#1
(byte*) screen2#2
(byte*) screen2#3
(void()) setscreen((byte**) setscreen::screen , (byte*) setscreen::val)
(label) setscreen::@return
(byte**) setscreen::screen
(byte**) setscreen::screen#0
(byte**) setscreen::screen#1
(byte**) setscreen::screen#2
(byte*) setscreen::val
(byte*) setscreen::val#0
(byte*) setscreen::val#1
(byte*) setscreen::val#2

Adding number conversion cast (unumber) 0 in *((byte*) screen#2 + (number) 0) ← (byte) 'a'
Adding number conversion cast (unumber) 0 in *((byte*) screen#3 + (number) 0) ← (byte) 'a'
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) screen#0 ← (byte*)(number) $400
Inlining cast (byte*) screen1#0 ← (byte*)(number) $400
Inlining cast (byte*) screen2#0 ← (byte*)(number~) $0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias (byte**) setscreen::screen#0 = (byte**~) main::$0 
Alias (byte*) screen#1 = (byte*) screen#2 (byte*) screen#3 
Alias (byte*) screen2#1 = (byte*) screen2#2 
Alias (byte**) setscreen::screen#1 = (byte**~) main::$2 
Alias (byte*) screen#0 = (byte*) screen#4 
Alias (byte*) screen2#0 = (byte*) screen2#3 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte*) screen#1 (byte*) screen#0
Identical Phi Values (byte*) screen2#1 (byte*) screen2#0
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [2] (number~) $0 ← (number) $400 + (number) $28
Constant right-side identified [5] (byte**) setscreen::screen#0 ← & (byte*) screen#0
Constant right-side identified [11] (byte**) setscreen::screen#1 ← & (byte*) screen#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) screen1#0 = (byte*) 1024
Constant (const number) $0 = $400+$28
Constant (const byte**) setscreen::screen#0 = &screen#0
Constant (const byte**) setscreen::screen#1 = &screen#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) setscreen::val#0 = screen1#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte*)$0 in [3] (byte*) screen2#0 ← (byte*)(const number) $0
Successful SSA optimization Pass2ConstantValues
Simplifying expression containing zero screen#0 in [10] *((byte*) screen#0 + (byte) 0) ← (byte) 'a'
Simplifying expression containing zero screen#0 in [16] *((byte*) screen#0 + (byte) 0) ← (byte) 'a'
Successful SSA optimization PassNSimplifyExpressionWithZero
Constant (const byte*) screen2#0 = (byte*)$0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) setscreen::val#1 = screen2#0
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings (const byte**) setscreen::screen#0
Inlining constant with var siblings (const byte**) setscreen::screen#1
Inlining constant with var siblings (const byte*) setscreen::val#0
Inlining constant with var siblings (const byte*) setscreen::val#1
Constant inlined setscreen::screen#0 = &(byte*) screen#0
Constant inlined $0 = (number) $400+(number) $28
Constant inlined setscreen::val#1 = (const byte*) screen2#0
Constant inlined setscreen::screen#1 = &(byte*) screen#0
Constant inlined setscreen::val#0 = (const byte*) screen1#0
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values (byte**) setscreen::screen#2 &(byte*) screen#0
Successful SSA optimization Pass2IdenticalPhiElimination
Adding NOP phi() at start of @2
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to setscreen:6 setscreen:8 

Created 1 initial phi equivalence classes
Coalesced down to 1 phi equivalence classes
Culled Empty Block (label) @3
Renumbering block @2 to @1
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] (byte*) screen#0 ← (byte*) 1024
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  [5] call setscreen 
  to:main::@1
main::@1: scope:[main]  from main
  [6] *((byte*) screen#0) ← (byte) 'a'
  [7] call setscreen 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] *((byte*) screen#0) ← (byte) 'a'
  to:main::@return
main::@return: scope:[main]  from main::@2
  [9] return 
  to:@return
setscreen: scope:[setscreen]  from main main::@1
  [10] (byte*) setscreen::val#2 ← phi( main/(const byte*) screen1#0 main::@1/(const byte*) screen2#0 )
  [11] *(&(byte*) screen#0) ← (byte*) setscreen::val#2
  to:setscreen::@return
setscreen::@return: scope:[setscreen]  from setscreen
  [12] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) main()
(byte*) screen
(byte*) screen#0 0.6666666666666666
(byte*) screen1
(byte*) screen2
(void()) setscreen((byte**) setscreen::screen , (byte*) setscreen::val)
(byte**) setscreen::screen
(byte*) setscreen::val
(byte*) setscreen::val#2 2.0

Initial phi equivalence classes
[ setscreen::val#2 ]
Complete equivalence classes
[ setscreen::val#2 ]
[ screen#0 ]
Allocated zp ZP_WORD:2 [ setscreen::val#2 ]
Allocated zp ZP_WORD:4 [ screen#0 ]

INITIAL ASM
//SEG0 File Comments
// Tests pointer to pointer in a more complex setup
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label screen1 = $400
  .label screen2 = $400+$28
  .label screen = 4
//SEG3 @begin
bbegin:
//SEG4 [0] (byte*) screen#0 ← (byte*) 1024 -- pbuz1=pbuc1 
  lda #<$400
  sta screen
  lda #>$400
  sta screen+1
//SEG5 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG6 @1
b1:
//SEG7 [2] call main 
//SEG8 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG9 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG10 @end
bend:
//SEG11 main
main: {
  //SEG12 [5] call setscreen 
  //SEG13 [10] phi from main to setscreen [phi:main->setscreen]
  setscreen_from_main:
  //SEG14 [10] phi (byte*) setscreen::val#2 = (const byte*) screen1#0 [phi:main->setscreen#0] -- pbuz1=pbuc1 
    lda #<screen1
    sta setscreen.val
    lda #>screen1
    sta setscreen.val+1
    jsr setscreen
    jmp b1
  //SEG15 main::@1
  b1:
  //SEG16 [6] *((byte*) screen#0) ← (byte) 'a' -- _deref_pbuz1=vbuc1 
    lda #'a'
    ldy #0
    sta (screen),y
  //SEG17 [7] call setscreen 
  //SEG18 [10] phi from main::@1 to setscreen [phi:main::@1->setscreen]
  setscreen_from_b1:
  //SEG19 [10] phi (byte*) setscreen::val#2 = (const byte*) screen2#0 [phi:main::@1->setscreen#0] -- pbuz1=pbuc1 
    lda #<screen2
    sta setscreen.val
    lda #>screen2
    sta setscreen.val+1
    jsr setscreen
    jmp b2
  //SEG20 main::@2
  b2:
  //SEG21 [8] *((byte*) screen#0) ← (byte) 'a' -- _deref_pbuz1=vbuc1 
    lda #'a'
    ldy #0
    sta (screen),y
    jmp breturn
  //SEG22 main::@return
  breturn:
  //SEG23 [9] return 
    rts
}
//SEG24 setscreen
// setscreen(byte* zeropage(2) val)
setscreen: {
    .label val = 2
  //SEG25 [11] *(&(byte*) screen#0) ← (byte*) setscreen::val#2 -- _deref_pptc1=pbuz1 
    lda val
    sta screen
    lda val+1
    sta screen+1
    jmp breturn
  //SEG26 setscreen::@return
  breturn:
  //SEG27 [12] return 
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] (byte*) screen#0 ← (byte*) 1024 [ screen#0 ] ( ) always clobbers reg byte a 
Statement [6] *((byte*) screen#0) ← (byte) 'a' [ screen#0 ] ( main:2 [ screen#0 ] ) always clobbers reg byte a reg byte y 
Statement [8] *((byte*) screen#0) ← (byte) 'a' [ ] ( main:2 [ ] ) always clobbers reg byte a reg byte y 
Statement [11] *(&(byte*) screen#0) ← (byte*) setscreen::val#2 [ screen#0 ] ( main:2::setscreen:5 [ screen#0 ] main:2::setscreen:7 [ screen#0 ] ) always clobbers reg byte a 
Potential registers zp ZP_WORD:2 [ setscreen::val#2 ] : zp ZP_WORD:2 , 
Potential registers zp ZP_WORD:4 [ screen#0 ] : zp ZP_WORD:4 , 

REGISTER UPLIFT SCOPES
Uplift Scope [setscreen] 2: zp ZP_WORD:2 [ setscreen::val#2 ] 
Uplift Scope [] 0.67: zp ZP_WORD:4 [ screen#0 ] 
Uplift Scope [main] 

Uplifting [setscreen] best 112 combination zp ZP_WORD:2 [ setscreen::val#2 ] 
Uplifting [] best 112 combination zp ZP_WORD:4 [ screen#0 ] 
Uplifting [main] best 112 combination 

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Tests pointer to pointer in a more complex setup
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label screen1 = $400
  .label screen2 = $400+$28
  .label screen = 4
//SEG3 @begin
bbegin:
//SEG4 [0] (byte*) screen#0 ← (byte*) 1024 -- pbuz1=pbuc1 
  lda #<$400
  sta screen
  lda #>$400
  sta screen+1
//SEG5 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG6 @1
b1:
//SEG7 [2] call main 
//SEG8 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG9 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG10 @end
bend:
//SEG11 main
main: {
  //SEG12 [5] call setscreen 
  //SEG13 [10] phi from main to setscreen [phi:main->setscreen]
  setscreen_from_main:
  //SEG14 [10] phi (byte*) setscreen::val#2 = (const byte*) screen1#0 [phi:main->setscreen#0] -- pbuz1=pbuc1 
    lda #<screen1
    sta setscreen.val
    lda #>screen1
    sta setscreen.val+1
    jsr setscreen
    jmp b1
  //SEG15 main::@1
  b1:
  //SEG16 [6] *((byte*) screen#0) ← (byte) 'a' -- _deref_pbuz1=vbuc1 
    lda #'a'
    ldy #0
    sta (screen),y
  //SEG17 [7] call setscreen 
  //SEG18 [10] phi from main::@1 to setscreen [phi:main::@1->setscreen]
  setscreen_from_b1:
  //SEG19 [10] phi (byte*) setscreen::val#2 = (const byte*) screen2#0 [phi:main::@1->setscreen#0] -- pbuz1=pbuc1 
    lda #<screen2
    sta setscreen.val
    lda #>screen2
    sta setscreen.val+1
    jsr setscreen
    jmp b2
  //SEG20 main::@2
  b2:
  //SEG21 [8] *((byte*) screen#0) ← (byte) 'a' -- _deref_pbuz1=vbuc1 
    lda #'a'
    ldy #0
    sta (screen),y
    jmp breturn
  //SEG22 main::@return
  breturn:
  //SEG23 [9] return 
    rts
}
//SEG24 setscreen
// setscreen(byte* zeropage(2) val)
setscreen: {
    .label val = 2
  //SEG25 [11] *(&(byte*) screen#0) ← (byte*) setscreen::val#2 -- _deref_pptc1=pbuz1 
    lda val
    sta screen
    lda val+1
    sta screen+1
    jmp breturn
  //SEG26 setscreen::@return
  breturn:
  //SEG27 [12] return 
    rts
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction b1_from_bbegin:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b1:
Removing instruction bend:
Removing instruction setscreen_from_main:
Removing instruction b1:
Removing instruction setscreen_from_b1:
Removing instruction b2:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) screen
(byte*) screen#0 screen zp ZP_WORD:4 0.6666666666666666
(byte*) screen1
(const byte*) screen1#0 screen1 = (byte*) 1024
(byte*) screen2
(const byte*) screen2#0 screen2 = (byte*)(number) $400+(number) $28
(void()) setscreen((byte**) setscreen::screen , (byte*) setscreen::val)
(label) setscreen::@return
(byte**) setscreen::screen
(byte*) setscreen::val
(byte*) setscreen::val#2 val zp ZP_WORD:2 2.0

zp ZP_WORD:2 [ setscreen::val#2 ]
zp ZP_WORD:4 [ screen#0 ]


FINAL ASSEMBLER
Score: 100

//SEG0 File Comments
// Tests pointer to pointer in a more complex setup
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label screen1 = $400
  .label screen2 = $400+$28
  .label screen = 4
//SEG3 @begin
bbegin:
//SEG4 [0] (byte*) screen#0 ← (byte*) 1024 -- pbuz1=pbuc1 
  lda #<$400
  sta screen
  lda #>$400
  sta screen+1
//SEG5 [1] phi from @begin to @1 [phi:@begin->@1]
//SEG6 @1
//SEG7 [2] call main 
//SEG8 [4] phi from @1 to main [phi:@1->main]
  jsr main
  rts
//SEG9 [3] phi from @1 to @end [phi:@1->@end]
//SEG10 @end
//SEG11 main
main: {
  //SEG12 [5] call setscreen 
  //SEG13 [10] phi from main to setscreen [phi:main->setscreen]
  //SEG14 [10] phi (byte*) setscreen::val#2 = (const byte*) screen1#0 [phi:main->setscreen#0] -- pbuz1=pbuc1 
    lda #<screen1
    sta setscreen.val
    lda #>screen1
    sta setscreen.val+1
    jsr setscreen
  //SEG15 main::@1
  //SEG16 [6] *((byte*) screen#0) ← (byte) 'a' -- _deref_pbuz1=vbuc1 
    lda #'a'
    ldy #0
    sta (screen),y
  //SEG17 [7] call setscreen 
  //SEG18 [10] phi from main::@1 to setscreen [phi:main::@1->setscreen]
  //SEG19 [10] phi (byte*) setscreen::val#2 = (const byte*) screen2#0 [phi:main::@1->setscreen#0] -- pbuz1=pbuc1 
    lda #<screen2
    sta setscreen.val
    lda #>screen2
    sta setscreen.val+1
    jsr setscreen
  //SEG20 main::@2
  //SEG21 [8] *((byte*) screen#0) ← (byte) 'a' -- _deref_pbuz1=vbuc1 
    lda #'a'
    ldy #0
    sta (screen),y
  //SEG22 main::@return
  //SEG23 [9] return 
    rts
}
//SEG24 setscreen
// setscreen(byte* zeropage(2) val)
setscreen: {
    .label val = 2
  //SEG25 [11] *(&(byte*) screen#0) ← (byte*) setscreen::val#2 -- _deref_pptc1=pbuz1 
    lda val
    sta screen
    lda val+1
    sta screen+1
  //SEG26 setscreen::@return
  //SEG27 [12] return 
    rts
}

