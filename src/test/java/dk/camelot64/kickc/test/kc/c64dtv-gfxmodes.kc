// Exploring C64DTV Screen Modes
import "c64dtv.kc"
import "print.kc"
import "keyboard.kc"

void main() {
    asm { sei }  // Disable normal interrupt (prevent keyboard reading glitches)
    *DTV_FEATURE = DTV_FEATURE_ENABLE;
    while(true) {
        menu();
    }
}

byte[] MENU_TEXT =
     "C64DTV Graphics Modes            CCLHBME@" +
     "                                 OHIIMCC@" +
     "                                 LUNCMMM@" +
     "----------------------------------------@" +
     "1. Standard Char             (V) 0000000@" +
     "2. Extended Color Char       (V) 0000001@" +
     "3. Multicolor Char           (V) 0000010@" +
     "4. Standard Bitmap           (V) 0000100@" +
     "5. Multicolor Bitmap         (V) 0000110@" +
     "6. High Color Standard Char  (H) 0001000@" +
     "7. High Extended Color Char  (H) 0001001@" +
     "8. High Multicolor Char      (H) 0001010@" +
     "9. High Multicolor Bitmap    (H) 0001110@" +
     "a. Sixs Fred 2               (D) 0010111@" +
     "b. Two Plane Bitmap          (D) 0011101@" +
     "c. Sixs Fred (2 Plane MC BM) (D) 0011111@" +
     "d. 8bpp Pixel Cell           (D) 0111011@" +
     "e. Chunky 8bpp Bitmap        (D) 1111011@" +
     "----------------------------------------@" +
     "    (V) vicII (H) vicII+hicol (D) c64dtv@" +
     "@" ;

void menu() {
    const byte* SCREEN = $8000;
    const byte* CHARSET = $9800; // Charset ROM
    // DTV Graphics Bank
    *DTV_GRAPHICS_VIC_BANK = (byte)((dword)CHARSET/$10000);
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <((word)(DTV_COLOR_BANK_DEFAULT/$400));
     *DTV_COLOR_BANK_HI = >((word)(DTV_COLOR_BANK_DEFAULT/$400));
    // DTV Graphics Mode
    *DTV_CONTROL = 0;
    // VIC Graphics Bank
    *CIA2_PORT_A_DDR = %00000011; // Set VIC Bank bits to output - all others to input
    *CIA2_PORT_A = %00000011 ^ (byte)((word)CHARSET/$4000); // Set VIC Bank
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_CSEL;
    // VIC Memory Pointers
    *VIC_MEMORY =  (byte)((((word)SCREEN&$3fff)/$40)|(((word)CHARSET&$3fff)/$400));
    // DTV Palette - default
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = DTV_PALETTE_DEFAULT[i];
    }
    // Char Colors
    for(byte* c=COLS;c!=COLS+1000;c++) *c=LIGHT_GREEN;
    // Screen colors
    *BGCOL = 0;
    *BORDERCOL = 0;
    // Display menu Text
    print_set_screen(SCREEN);
    print_cls();
    print_str_lines(MENU_TEXT);
    // Wait for key press
    while(true) {
        if(keyboard_key_pressed(KEY_1)!=0) {
            mode_stdchar();
            return;
        }
        if(keyboard_key_pressed(KEY_2)!=0) {
            mode_ecmchar();
            return;
        }
        if(keyboard_key_pressed(KEY_3)!=0) {
            mode_mcchar();
            return;
        }
        if(keyboard_key_pressed(KEY_6)!=0) {
            mode_hicolstdchar();
            return;
        }
        if(keyboard_key_pressed(KEY_7)!=0) {
            mode_hicolecmchar();
            return;
        }
        if(keyboard_key_pressed(KEY_8)!=0) {
            mode_hicolmcchar();
            return;
        }
        if(keyboard_key_pressed(KEY_A)!=0) {
            mode_sixsfred2();
            return;
        }
        if(keyboard_key_pressed(KEY_B)!=0) {
            mode_twoplanebitmap();
            return;
        }
        if(keyboard_key_pressed(KEY_C)!=0) {
            mode_sixsfred();
            return;
        }
        if(keyboard_key_pressed(KEY_D)!=0) {
            mode_8bpppixelcell();
            return;
        }
        if(keyboard_key_pressed(KEY_E)!=0) {
            mode_8bppchunkybmm();
            return;
        }
    }

}

// Standard Character Mode (LINEAR/HICOL/CHUNK/COLDIS/ECM/MCM/BMM = 0)
// Resolution: 320x200
// Normal VIC Adressing:
// VicGfxData[16]: ( VicBank[1:0] & CharBase[2:0] & CharData[7:0] & RowCounter[2:0] )
// Pixel Shifter (1)
// - 0: 4bpp BgColor0[3:0]
// - 1: 4bpp ColorData[3:0]
void mode_stdchar() {
    const byte* SCREEN = $8000;
    const byte* CHARSET = $9000; // Charset ROM
    const byte* COLORS = $d800;
    // DTV Graphics Bank
    *DTV_GRAPHICS_VIC_BANK = (byte)((dword)CHARSET/$10000);
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <((word)(DTV_COLOR_BANK_DEFAULT/$400));
     *DTV_COLOR_BANK_HI = >((word)(DTV_COLOR_BANK_DEFAULT/$400));
    // DTV Graphics Mode
    *DTV_CONTROL = 0;
    // VIC Graphics Bank
    *CIA2_PORT_A_DDR = %00000011; // Set VIC Bank bits to output - all others to input
    *CIA2_PORT_A = %00000011 ^ (byte)((word)CHARSET/$4000); // Set VIC Bank
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_CSEL;
    // VIC Memory Pointers
    *VIC_MEMORY =  (byte)((((word)SCREEN&$3fff)/$40)|(((word)CHARSET&$3fff)/$400));
    // DTV Palette - default
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = DTV_PALETTE_DEFAULT[i];
    }
    // Screen colors
    *BGCOL = 0;
    *BORDERCOL = 0;
    // Char Colors and screen chars
    byte* col=COLORS;
    byte* ch=SCREEN;
    for(byte cy: 0..24 ) {
        for(byte cx: 0..39) {
            *col++ = (cx+cy)&$f;
            *ch++ = (cy&$f)<<4|(cx&$f);
        }
    }
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }
}

// Extended Background Color Character Mode (LINEAR/HICOL/CHUNK/COLDIS/MCM/BMM = 0, ECM = 1)
// Resolution: 320x200
// Normal VIC Adressing:
// VicGfxData[16]: ( VicBank[1:0] & CharBase[2:0] & "00" & CharData[5:0] & RowCounter[2:0] ) 
// GfxData Pixel Shifter (1)
//  - 0: 4bpp Background Color
//    - CharData[7:6] 00: 4bpp BgColor0[3:0]
//    - CharData[7:6] 01: 4bpp BgColor1[3:0]
//    - CharData[7:6] 10: 4bpp BgColor2[3:0]
//    - CharData[7:6] 11: 4bpp BgColor3[3:0]
//  - 1: 4bpp ColorData[3:0]
void mode_ecmchar() {
    const byte* SCREEN = $8000;
    const byte* CHARSET = $9000; // Charset ROM
    const byte* COLORS = $d800;
    // DTV Graphics Bank
    *DTV_GRAPHICS_VIC_BANK = (byte)((dword)CHARSET/$10000);
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <((word)(DTV_COLOR_BANK_DEFAULT/$400));
     *DTV_COLOR_BANK_HI = >((word)(DTV_COLOR_BANK_DEFAULT/$400));
    // DTV Graphics Mode
    *DTV_CONTROL = 0;
    // VIC Graphics Bank
    *CIA2_PORT_A_DDR = %00000011; // Set VIC Bank bits to output - all others to input
    *CIA2_PORT_A = %00000011 ^ (byte)((word)CHARSET/$4000); // Set VIC Bank
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_DEN|VIC_RSEL|VIC_ECM|3;
    *VIC_CONTROL2 = VIC_CSEL;
    // VIC Memory Pointers
    *VIC_MEMORY =  (byte)((((word)SCREEN&$3fff)/$40)|(((word)CHARSET&$3fff)/$400));
    // DTV Palette - default
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = DTV_PALETTE_DEFAULT[i];
    }
    // Screen colors
    *BORDERCOL = 0;
    *BGCOL1 = 0;
    *BGCOL2 = 2;
    *BGCOL3 = 5;
    *BGCOL4 = 6;
    // Char Colors and screen chars
    byte* col=COLORS;
    byte* ch=SCREEN;
    for(byte cy: 0..24 ) {
        for(byte cx: 0..39) {
            *col++ = (cx+cy)&$f;
            *ch++ = (cy&$f)<<4|(cx&$f);
        }
    }
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }
}

// Multicolor Character Mode (LINEAR/HICOL/CHUNK/COLDIS/BMM/ECM = 0, MCM = 1)
// Resolution: 160x200 (320x200)
// Normal VIC Adressing:
// VicGfxData[16]: ( VicBank[1:0] & CharBase[2:0] & CharData[7:0] & RowCounter[2:0] )
// GfxData Pixel Shifter (1) if ColorData[3:3] = 0:
//  - 0: 4bpp BgColor0[3:0]
//  - 1: 4bpp ColorData[2:0]
// GfxData Pixel Shifter (2) if ColorData[3:3] = 1:
//  - 00: 4bpp BgColor0[3:0]
//  - 01: 4bpp BgColor1[3:0]
//  - 10: 4bpp BgColor2[3:0]
//  - 11: 4bpp ColorData[2:0]// Standard Character Mode (LINEAR/HICOL/CHUNK/COLDIS/ECM/MCM/BMM = 0)
void mode_mcchar() {
    const byte* SCREEN = $8000;
    const byte* CHARSET = $9000; // Charset ROM
    const byte* COLORS = $d800;
    // DTV Graphics Bank
    *DTV_GRAPHICS_VIC_BANK = (byte)((dword)CHARSET/$10000);
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <((word)(DTV_COLOR_BANK_DEFAULT/$400));
     *DTV_COLOR_BANK_HI = >((word)(DTV_COLOR_BANK_DEFAULT/$400));
    // DTV Graphics Mode
    *DTV_CONTROL = 0;
    // VIC Graphics Bank
    *CIA2_PORT_A_DDR = %00000011; // Set VIC Bank bits to output - all others to input
    *CIA2_PORT_A = %00000011 ^ (byte)((word)CHARSET/$4000); // Set VIC Bank
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_CSEL|VIC_MCM;
    // VIC Memory Pointers
    *VIC_MEMORY =  (byte)((((word)SCREEN&$3fff)/$40)|(((word)CHARSET&$3fff)/$400));
    // DTV Palette - default
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = DTV_PALETTE_DEFAULT[i];
    }
    // Screen colors
    *BORDERCOL = 0;
    *BGCOL1 = BLACK;
    *BGCOL2 = GREEN;
    *BGCOL3 = BLUE;
    // Char Colors and screen chars
    byte* col=COLORS;
    byte* ch=SCREEN;
    for(byte cy: 0..24 ) {
        for(byte cx: 0..39) {
            *col++ = (cx+cy)&$f;
            *ch++ = (cy&$f)<<4|(cx&$f);
        }
    }
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }
}

// High Color Standard Character Mode (LINEAR/CHUNK/COLDIS/ECM/MCM/BMM = 0, HICOL = 1)
// Resolution: 320x200
// Normal VIC Adressing:
// VicGfxData[16]: ( VicBank[1:0] & CharBase[2:0] & CharData[7:0] & RowCounter[2:0] )
// Pixel Shifter (1)
//  - 0: 8bpp BgColor0[7:0]
//  - 1: 8bpp ColorData[7:0]
void mode_hicolstdchar() {
    const byte* SCREEN = $8000;
    const byte* CHARSET = $9000; // Charset ROM
    const byte* COLORS = $8400;
    // DTV Graphics Bank
    *DTV_GRAPHICS_VIC_BANK = (byte)((dword)CHARSET/$10000);
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <((word)(COLORS/$400));
     *DTV_COLOR_BANK_HI = >((word)(COLORS/$400));
    // DTV Graphics Mode
    *DTV_CONTROL = DTV_CONTROL_HIGHCOLOR_ON;
    // VIC Graphics Bank
    *CIA2_PORT_A_DDR = %00000011; // Set VIC Bank bits to output - all others to input
    *CIA2_PORT_A = %00000011 ^ (byte)((word)CHARSET/$4000); // Set VIC Bank
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_CSEL;
    // VIC Memory Pointers
    *VIC_MEMORY =  (byte)((((word)SCREEN&$3fff)/$40)|(((word)CHARSET&$3fff)/$400));
    // DTV Palette - Grey Tones
     for(byte i : 0..$f) {
         DTV_PALETTE[i] = i;
     }
    // Screen colors
    *BGCOL = 0;
    *BORDERCOL = 0;
    // Char Colors and screen chars
    byte* col=COLORS;
    byte* ch=SCREEN;
    for(byte cy: 0..24 ) {
        for(byte cx: 0..39) {
            byte v = (cy&$f)<<4|(cx&$f);
            *col++ = v;
            *ch++ = v;
        }
    }
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }
}

// High Color Extended Background Color Character Mode (LINEAR/CHUNK/COLDIS/MCM/BMM = 0, ECM/HICOL = 1)
// Resolution: 320x200
// Normal VIC Adressing:
// VicGfxData[16]: ( VicBank[1:0] & CharBase[2:0] & "00" & CharData[5:0] & RowCounter[2:0] )
// GfxData Pixel Shifter (1)
//  - 0: 8bpp Background Color
//    - CharData[7:6] 00: 8bpp BgColor0[7:0]
//    - CharData[7:6] 01: 8bpp BgColor1[7:0]
//    - CharData[7:6] 10: 8bpp BgColor2[7:0]
//    - CharData[7:6] 11: 8bpp BgColor3[7:0]
//  - 1: 8bpp ColorData[7:0]
void mode_hicolecmchar() {
    const byte* SCREEN = $8000;
    const byte* CHARSET = $9000; // Charset ROM
    const byte* COLORS = $8400;
    // DTV Graphics Bank
    *DTV_GRAPHICS_VIC_BANK = (byte)((dword)CHARSET/$10000);
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <((word)(COLORS/$400));
     *DTV_COLOR_BANK_HI = >((word)(COLORS/$400));
    // DTV Graphics Mode
    *DTV_CONTROL = DTV_CONTROL_HIGHCOLOR_ON;
    // VIC Graphics Bank
    *CIA2_PORT_A_DDR = %00000011; // Set VIC Bank bits to output - all others to input
    *CIA2_PORT_A = %00000011 ^ (byte)((word)CHARSET/$4000); // Set VIC Bank
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_DEN|VIC_RSEL|VIC_ECM|3;
    *VIC_CONTROL2 = VIC_CSEL;
    // VIC Memory Pointers
    *VIC_MEMORY =  (byte)((((word)SCREEN&$3fff)/$40)|(((word)CHARSET&$3fff)/$400));
    // DTV Palette - Grey Tones
     for(byte i : 0..$f) {
         DTV_PALETTE[i] = i;
     }
    // Screen colors
    *BORDERCOL = 0;
    *BGCOL1 = $50;
    *BGCOL2 = $54;
    *BGCOL3 = $58;
    *BGCOL4 = $5c;
    // Char Colors and screen chars
    byte* col=COLORS;
    byte* ch=SCREEN;
    for(byte cy: 0..24 ) {
        for(byte cx: 0..39) {
            byte v = (cy&$f)<<4|(cx&$f);
            *col++ = v;
            *ch++ = v;
        }
    }
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }
}

// High Color Multicolor Character Mode (LINEAR/CHUNK/COLDIS/BMM/ECM = 0, MCM/HICOL = 1)
// Resolution: 160x200 (320x200)
// Normal VIC Adressing:
// VicGfxData[16]: ( VicBank[1:0] & CharBase[2:0] & CharData[7:0] & RowCounter[2:0] )
//GfxData Pixel Shifter (1) if ColorData[3:3] = 0:
// - 0: 8bpp BgColor0[7:0]
// - 1: 8bpp ColorData[7:4] "0" & Color[2:0]
//GfxData Pixel Shifter (2) if ColorData[3:3] = 1:
// - 00: 8bpp BgColor0[7:0]
// - 01: 8bpp BgColor1[7:0]
// - 10: 8bpp BgColor2[7:0]
// - 11: 8bpp ColorData[7:4] "0" & Color[2:0]
void mode_hicolmcchar() {
    const byte* SCREEN = $8000;
    const byte* CHARSET = $9000; // Charset ROM
    const byte* COLORS = $8400;
    // DTV Graphics Bank
    *DTV_GRAPHICS_VIC_BANK = (byte)((dword)CHARSET/$10000);
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <((word)(COLORS/$400));
     *DTV_COLOR_BANK_HI = >((word)(COLORS/$400));
    // DTV Graphics Mode
    *DTV_CONTROL = DTV_CONTROL_HIGHCOLOR_ON;
    // VIC Graphics Bank
    *CIA2_PORT_A_DDR = %00000011; // Set VIC Bank bits to output - all others to input
    *CIA2_PORT_A = %00000011 ^ (byte)((word)CHARSET/$4000); // Set VIC Bank
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_CSEL|VIC_MCM;
    // VIC Memory Pointers
    *VIC_MEMORY =  (byte)((((word)SCREEN&$3fff)/$40)|(((word)CHARSET&$3fff)/$400));
    // DTV Palette - Grey Tones
     for(byte i : 0..$f) {
         DTV_PALETTE[i] = i;
     }
    // Screen colors
    *BORDERCOL = 0;
    *BGCOL1 = $50;
    *BGCOL2 = $54;
    *BGCOL3 = $58;
    // Char Colors and screen chars
    byte* col=COLORS;
    byte* ch=SCREEN;
    for(byte cy: 0..24 ) {
        for(byte cx: 0..39) {
            byte v = (cy&$f)<<4|(cx&$f);
            *col++ = v;
            *ch++ = v;
        }
    }
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }
}

// Two Plane Bitmap - generated from the two DTV linear graphics plane counters
// Two Plane Bitmap Mode (CHUNK/COLDIS/MCM = 0, ECM/BMM/HICOL/LINEAR = 1)
// Resolution: 320x200
// Linear Adressing
// GfxData/PlaneA Pixel Shifter (1), CharData/PlaneB Pixel Shifter (1):
// - Plane A = 0 Plane B = 0: 8bpp BgColor0[7:0]
// - Plane A = 0 Plane B = 1: 8bpp "0000" & ColorData[7:4]
// - Plane A = 1 Plane B = 0: 8bpp "0000" & ColorData[3:0]
// - Plane A = 1 Plane B = 1: 8bpp BgColor1[7:0]
void mode_twoplanebitmap() {
    const byte* PLANEA = $4000;
    const byte* PLANEB = $6000;
    const byte* COLORS = $8000;
    // DTV Graphics Mode
    *DTV_CONTROL = DTV_CONTROL_HIGHCOLOR_ON | DTV_CONTROL_LINEAR_ADDRESSING_ON;
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_ECM|VIC_BMM|VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_CSEL;
    // Linear Graphics Plane A Counter
    *DTV_PLANEA_START_LO = <PLANEA;
    *DTV_PLANEA_START_MI = >PLANEA;
    *DTV_PLANEA_START_HI = 0;
    *DTV_PLANEA_STEP = 1;
    *DTV_PLANEA_MODULO_LO = 0;
    *DTV_PLANEA_MODULO_HI = 0;
    // Linear Graphics Plane B Counter
    *DTV_PLANEB_START_LO = <PLANEB;
    *DTV_PLANEB_START_MI = >PLANEB;
    *DTV_PLANEB_START_HI = 0;
    *DTV_PLANEB_STEP = 1;
    *DTV_PLANEB_MODULO_LO = 0;
    *DTV_PLANEB_MODULO_HI = 0;
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <(COLORS/$400);
     *DTV_COLOR_BANK_HI = >(COLORS/$400);
    // DTV Palette - Grey Tones
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = i;
    }
    // Screen colors
    *BORDERCOL = $00;
    *BGCOL1 = $70; // Color for bits 00
    *BGCOL2 = $d4; // Color for bits 11
    // Colors for bits 01 / 10
    byte* col=COLORS;
    for(byte cy: 0..24 ) {
        for(byte cx: 0..39) {
            *col++ = (cy & $f)<<4 | (cx &$f);
        }
    }
    // Graphics for Plane A - horizontal stripes
    byte* gfxa = PLANEA;
    for(byte ay : 0..199) {
        for (byte ax : 0..39) {
            if((ay&4)==0) {
                *gfxa++ = %00000000;
            } else {
                *gfxa++ = %11111111;
            }
        }
    }
    // Graphics for Plane B - vertical stripes
    byte* gfxb = PLANEB;
    for(byte by : 0..199) {
        for ( byte bx : 0..39) {
            *gfxb++ = %00001111;
        }
    }
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }

}

// Sixs Fred Mode - 8bpp Packed Bitmap - Generated from the two DTV linear graphics plane counters
// Two Plane MultiColor Bitmap - 8bpp Packed Bitmap (CHUNK/COLDIS = 0, ECM/BMM/MCM/HICOL/LINEAR = 1)
// Resolution: 160x200
// Linear Adressing
// GfxData/PlaneA Pixel Shifter (2), CharData/PlaneB Pixel Shifter (2):
// - 8bpp color (ColorData[3:0],CharData/PlaneB[1:0], GfxData/PlaneA[1:0])
void mode_sixsfred() {
    const byte* PLANEA = $4000;
    const byte* PLANEB = $6000;
    const byte* COLORS = $8000;
    // DTV Graphics Mode
    *DTV_CONTROL = DTV_CONTROL_HIGHCOLOR_ON | DTV_CONTROL_LINEAR_ADDRESSING_ON;
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_ECM|VIC_BMM|VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_MCM|VIC_CSEL;
    // Linear Graphics Plane A Counter
    *DTV_PLANEA_START_LO = <PLANEA;
    *DTV_PLANEA_START_MI = >PLANEA;
    *DTV_PLANEA_START_HI = 0;
    *DTV_PLANEA_STEP = 1;
    *DTV_PLANEA_MODULO_LO = 0;
    *DTV_PLANEA_MODULO_HI = 0;
    // Linear Graphics Plane B Counter
    *DTV_PLANEB_START_LO = <PLANEB;
    *DTV_PLANEB_START_MI = >PLANEB;
    *DTV_PLANEB_START_HI = 0;
    *DTV_PLANEB_STEP = 1;
    *DTV_PLANEB_MODULO_LO = 0;
    *DTV_PLANEB_MODULO_HI = 0;
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <(COLORS/$400);
     *DTV_COLOR_BANK_HI = >(COLORS/$400);
    // DTV Palette - Grey Tones
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = i;
    }
    // Screen colors
    *BORDERCOL = $00;
    // Colors for high 4 bits of 8bpp
    byte* col=COLORS;
    for(byte cy: 0..24 ) {
        for(byte cx: 0..39) {
            *col++ = (cx+cy) & $f;
        }
    }
    // Graphics for Plane A () - horizontal stripes every 2 pixels
    byte* gfxa = PLANEA;
    byte[] row_bitmask = { %00000000, %01010101, %10101010, %11111111 };
    for(byte ay : 0..199) {
        for (byte ax : 0..39) {
            byte row = (ay>>1) & 3;
            *gfxa++ = row_bitmask[row];
        }
    }
    // Graphics for Plane B - vertical stripes every 2 pixels
    byte* gfxb = PLANEB;
    for(byte by : 0..199) {
        for ( byte bx : 0..39) {
                *gfxb++ = %00011011;
        }
    }
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }

}

// Sixs Fred Mode 2 - 8bpp Packed Bitmap - Generated from the two DTV linear graphics plane counters
// Two Plane MultiColor Bitmap - 8bpp Packed Bitmap (CHUNK/COLDIS/HICOL = 0, ECM/BMM/MCM/LINEAR = 1)
// Resolution: 160x200
// Linear Adressing
// PlaneA Pixel Shifter (2), PlaneB Pixel Shifter (2):
// - 8bpp color (PlaneB[1:0],ColorData[5:4],PlaneA[1:0],ColorData[1:0])
void mode_sixsfred2() {
    const byte* PLANEA = $4000;
    const byte* PLANEB = $6000;
    const byte* COLORS = $8000;
    // DTV Graphics Mode
    *DTV_CONTROL = DTV_CONTROL_LINEAR_ADDRESSING_ON;
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_ECM|VIC_BMM|VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_MCM|VIC_CSEL;
    // Linear Graphics Plane A Counter
    *DTV_PLANEA_START_LO = <PLANEA;
    *DTV_PLANEA_START_MI = >PLANEA;
    *DTV_PLANEA_START_HI = 0;
    *DTV_PLANEA_STEP = 1;
    *DTV_PLANEA_MODULO_LO = 0;
    *DTV_PLANEA_MODULO_HI = 0;
    // Linear Graphics Plane B Counter
    *DTV_PLANEB_START_LO = <PLANEB;
    *DTV_PLANEB_START_MI = >PLANEB;
    *DTV_PLANEB_START_HI = 0;
    *DTV_PLANEB_STEP = 1;
    *DTV_PLANEB_MODULO_LO = 0;
    *DTV_PLANEB_MODULO_HI = 0;
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <(COLORS/$400);
     *DTV_COLOR_BANK_HI = >(COLORS/$400);
    // DTV Palette - Grey Tones
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = i;
    }
    // Screen colors
    *BORDERCOL = $00;
    // Colors for high 4 bits of 8bpp
    byte* col=COLORS;
    for(byte cy: 0..24 ) {
        for(byte cx: 0..39) {
            *col++ = (cx&3)<<4|(cy&3);
        }
    }
    // Graphics for Plane A () - horizontal stripes every 2 pixels
    byte* gfxa = PLANEA;
    byte[] row_bitmask = { %00000000, %01010101, %10101010, %11111111 };
    for(byte ay : 0..199) {
        for (byte ax : 0..39) {
            byte row = (ay>>1) & 3;
            *gfxa++ = row_bitmask[row];
        }
    }
    // Graphics for Plane B - vertical stripes every 2 pixels
    byte* gfxb = PLANEB;
    for(byte by : 0..199) {
        for ( byte bx : 0..39) {
                *gfxb++ = %00011011;
        }
    }
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }

}


//8bpp Pixel Cell Mode (BMM/COLDIS = 0, ECM/MCM/HICOL/LINEAR/CHUNK = 1)
//Pixel Cell Adressing
//CharData[8]: (PlaneA[21:0])
//GfxData[8]: (PlaneB[21:14] & CharData[7:0] & RowCounter[3:0] & PixelCounter[7:0] )
//GfxData Pixel Shifter (8):
//- 8bpp color GfxData[7:0]
//Pixel cell mode can be thought of as a text mode that uses a 8x8 pixel 8bpp font (64 bytes/char).
//The characters come from counter A and the font (or "cells") from counter B.
//Counter B step and modulo should be set to 0, counter A modulo to 0 and counter A step to 1 for normal operation.
void mode_8bpppixelcell() {
    // 8BPP Pixel Cell Screen (contains 40x25=1000 chars)
    const byte* PLANEA = $3c00;
    // 8BPP Pixel Cell Charset (contains 256 64 byte chars)
    const byte* PLANEB = $4000;
    // DTV Graphics Mode
    *DTV_CONTROL = DTV_CONTROL_HIGHCOLOR_ON | DTV_CONTROL_LINEAR_ADDRESSING_ON|DTV_CONTROL_CHUNKY_ON;
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_ECM|VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_MCM|VIC_CSEL;
    // Linear Graphics Plane A Counter
    *DTV_PLANEA_START_LO = <PLANEA;
    *DTV_PLANEA_START_MI = >PLANEA;
    *DTV_PLANEA_START_HI = 0;
    *DTV_PLANEA_STEP = 1;
    *DTV_PLANEA_MODULO_LO = 0;
    *DTV_PLANEA_MODULO_HI = 0;
    // Linear Graphics Plane B Counter
    *DTV_PLANEB_START_LO = <PLANEB;
    *DTV_PLANEB_START_MI = >PLANEB;
    *DTV_PLANEB_START_HI = 0;
    *DTV_PLANEB_STEP = 0;
    *DTV_PLANEB_MODULO_LO = 0;
    *DTV_PLANEB_MODULO_HI = 0;
    // Border color
    *BORDERCOL = $00;
    // DTV Palette - Grey Tones
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = i;
    }
    // Screen Chars for Plane A (screen) - 16x16 repeating
    byte* gfxa = PLANEA;
    for(byte ay : 0..24) {
        for (byte ax : 0..39) {
            *gfxa++ = (ay & $f)<<4 | (ax & $f);
        }
    }
    // 8bpp cells for Plane B (charset) - ROM charset with 256 colors
    *PROCPORT = $32;
    byte* CHARGEN = $d000;
    byte* gfxb = PLANEB;
    byte* chargen = CHARGEN;
    byte col = 0;
    for(byte ch : $00..$ff) {
        for ( byte cr : 0..7) {
            byte bits = *chargen++;
            for ( byte cp : 0..7) {
                byte c = 0;
                if((bits & $80) != 0) {
                    c = col;
                }
                *gfxb++ = c;
                bits = bits<<1;
                col++;
            }
        }
    }
    *PROCPORT = $37;
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }
}


//Chunky 8bpp Bitmap Mode (BMM = 0, ECM/MCM/HICOL/LINEAR/CHUNK/COLDIS = 1)
// Resolution: 320x200
// Linear Adressing
// CharData/PlaneB Pixel Shifter (8):
// - 8bpp color PlaneB[7:0]
// To set up a linear video frame buffer the step size must be set to 8.
void mode_8bppchunkybmm() {
    // 8BPP Chunky Bitmap (contains 8bpp pixels)
    const dword PLANEB = $20000;
    // DTV Graphics Mode
    *DTV_CONTROL = DTV_CONTROL_HIGHCOLOR_ON | DTV_CONTROL_LINEAR_ADDRESSING_ON | DTV_CONTROL_CHUNKY_ON | DTV_CONTROL_COLORRAM_OFF;
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_ECM | VIC_DEN | VIC_RSEL | 3;
    *VIC_CONTROL2 = VIC_MCM | VIC_CSEL;
    // Linear Graphics Plane B Counter
    *DTV_PLANEB_START_LO = < < PLANEB;
    *DTV_PLANEB_START_MI = > < PLANEB;
    *DTV_PLANEB_START_HI = < > PLANEB;
    *DTV_PLANEB_STEP = 8;
    *DTV_PLANEB_MODULO_LO = 0;
    *DTV_PLANEB_MODULO_HI = 0;
    // Border color
    *BORDERCOL = $00;
    // DTV Palette - Grey Tones
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = i;
    }

    // 320x200 8bpp pixels for Plane B
    byte gfxbCpuBank = (byte)(PLANEB/$4000);
    dtvSetCpuBankSegment1(gfxbCpuBank++);
    byte* gfxb = $4000;
    for(byte y : 0..199) {
        for (word x : 0..319) {
            // If we have crossed to $8000 increase the CPU BANK segment and reset to $4000
            if(gfxb==$8000) {
                dtvSetCpuBankSegment1(gfxbCpuBank++);
                gfxb = $4000;
            }
            byte c = (byte)(x+y);
            *gfxb++ = c;
        }
    }
    // Reset CPU BANK segment to $4000
    dtvSetCpuBankSegment1((byte)($4000/$4000));
    // Wait for keypress
    while(true) {
        if(keyboard_key_pressed(KEY_SPACE)!=0) {
            return;
        }
    }
}
