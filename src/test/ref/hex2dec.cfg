@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  asm { sei  }
  [5] call cls 
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@3
  [6] (byte~) main::$1 ← *((const byte*) control) & (byte) $80
  [7] (byte~) main::$2 ← *((const byte*) raster) >> (byte) 1
  [8] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2
  [9] if((byte) main::rst#0!=(byte) $30) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [10] *((const byte*) bordercol) ← (byte) 1
  [11] (byte) main::time_start#0 ← *((const byte*) raster)
  [12] (byte*) utoa16w::dst#0 ← (byte*) 1024
  [13] call utoa16w 
  to:main::@5
main::@5: scope:[main]  from main::@2
  [14] *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  [15] (byte*) utoa16w::dst#1 ← (byte*) 1024+(byte) $28
  [16] call utoa16w 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [17] *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  [18] (byte*) utoa16w::dst#2 ← (byte*) 1024+(byte) $28+(byte) $28
  [19] call utoa16w 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [20] *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  [21] (byte*) utoa16w::dst#3 ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28
  [22] call utoa16w 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [23] *((const byte*) bordercol) ← ++ *((const byte*) bordercol)
  [24] (byte*) utoa16w::dst#4 ← (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28
  [25] call utoa16w 
  to:main::@9
main::@9: scope:[main]  from main::@8
  [26] (byte) main::time_end#0 ← *((const byte*) raster)
  [27] *((const byte*) bordercol) ← (byte) 0
  [28] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0
  [29] (word) utoa10w::value#0 ← (word)(byte) main::time#0
  [30] call utoa10w 
  to:main::@3
main::@3: scope:[main]  from main::@4 main::@9
  [31] (byte) main::i#2 ← phi( main::@9/(byte) 0 main::@4/(byte) main::i#1 )
  [32] if(*((const byte[]) main::msg#0 + (byte) main::i#2)!=(byte) 0) goto main::@4
  to:main::@1
main::@4: scope:[main]  from main::@3
  [33] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte[]) main::msg#0 + (byte) main::i#2)
  [34] (byte) main::i#1 ← ++ (byte) main::i#2
  to:main::@3

(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
utoa10w: scope:[utoa10w]  from main::@9
  [35] phi()
  to:utoa10w::@1
utoa10w::@1: scope:[utoa10w]  from utoa10w utoa10w::@2 utoa10w::@6
  [36] (byte*) utoa10w::dst#11 ← phi( utoa10w/(byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 utoa10w::@6/(byte*) utoa10w::dst#4 utoa10w::@2/(byte*) utoa10w::dst#11 )
  [36] (byte) utoa10w::bStarted#2 ← phi( utoa10w/(byte) 0 utoa10w::@6/(byte) utoa10w::bStarted#2 utoa10w::@2/(byte) 1 )
  [36] (byte) utoa10w::digit#3 ← phi( utoa10w/(byte) 0 utoa10w::@6/(byte) utoa10w::digit#7 utoa10w::@2/(byte) utoa10w::digit#1 )
  [36] (word) utoa10w::value#10 ← phi( utoa10w/(word) utoa10w::value#0 utoa10w::@6/(word) utoa10w::value#10 utoa10w::@2/(word) utoa10w::value#1 )
  [36] (byte) utoa10w::i#2 ← phi( utoa10w/(byte) 0 utoa10w::@6/(byte) utoa10w::i#1 utoa10w::@2/(byte) utoa10w::i#2 )
  [37] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1
  [38] if((word) utoa10w::value#10>=*((const word[]) UTOA10_SUB + (byte~) utoa10w::$8)) goto utoa10w::@2
  to:utoa10w::@3
utoa10w::@3: scope:[utoa10w]  from utoa10w::@1
  [39] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1
  [40] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@6
  to:utoa10w::@4
utoa10w::@4: scope:[utoa10w]  from utoa10w::@3
  [41] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7
  to:utoa10w::@5
utoa10w::@5: scope:[utoa10w]  from utoa10w::@4
  [42] *((byte*) utoa10w::dst#11) ← *((const byte[]) DIGITS + (byte) utoa10w::digit#3)
  [43] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11
  to:utoa10w::@7
utoa10w::@7: scope:[utoa10w]  from utoa10w::@4 utoa10w::@5
  [44] (byte*) utoa10w::dst#7 ← phi( utoa10w::@4/(byte*) utoa10w::dst#11 utoa10w::@5/(byte*) utoa10w::dst#1 )
  to:utoa10w::@6
utoa10w::@6: scope:[utoa10w]  from utoa10w::@3 utoa10w::@7
  [45] (byte) utoa10w::digit#7 ← phi( utoa10w::@7/(byte) 0 utoa10w::@3/(byte) utoa10w::digit#3 )
  [45] (byte*) utoa10w::dst#4 ← phi( utoa10w::@7/(byte*) utoa10w::dst#7 utoa10w::@3/(byte*) utoa10w::dst#11 )
  [46] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2
  [47] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1
  to:utoa10w::@8
utoa10w::@8: scope:[utoa10w]  from utoa10w::@6
  [48] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10
  [49] *((byte*) utoa10w::dst#4) ← *((const byte[]) DIGITS + (byte~) utoa10w::$0)
  [50] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4
  [51] *((byte*) utoa10w::dst#2) ← (byte) 0
  to:utoa10w::@return
utoa10w::@return: scope:[utoa10w]  from utoa10w::@8
  [52] return 
  to:@return
utoa10w::@2: scope:[utoa10w]  from utoa10w::@1
  [53] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte[]) UTOA10_VAL + (byte) utoa10w::i#2)
  [54] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1
  [55] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word[]) UTOA10_SUB + (byte~) utoa10w::$9)
  to:utoa10w::@1

(void()) utoa16w((word) utoa16w::value , (byte*) utoa16w::dst)
utoa16w: scope:[utoa16w]  from main::@2 main::@5 main::@6 main::@7 main::@8
  [56] (byte*) utoa16w::dst#5 ← phi( main::@5/(byte*) utoa16w::dst#1 main::@6/(byte*) utoa16w::dst#2 main::@7/(byte*) utoa16w::dst#3 main::@8/(byte*) utoa16w::dst#4 main::@2/(byte*) utoa16w::dst#0 )
  [56] (word) utoa16w::value#5 ← phi( main::@5/(word) $4d2 main::@6/(word) $162e main::@7/(word) $270f main::@8/(word) $e608 main::@2/(byte) 0 )
  [57] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5
  [58] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4
  [59] call utoa16n 
  [60] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  [61] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
  [62] (byte~) utoa16w::$4 ← > (word) utoa16w::value#5
  [63] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$4 & (byte) $f
  [64] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  [65] call utoa16n 
  [66] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  [67] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
  [68] (byte~) utoa16w::$8 ← < (word) utoa16w::value#5
  [69] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$8 >> (byte) 4
  [70] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  [71] call utoa16n 
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  [72] (byte~) utoa16w::$12 ← < (word) utoa16w::value#5
  [73] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$12 & (byte) $f
  [74] call utoa16n 
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  [75] *((byte*) utoa16w::dst#5) ← (byte) 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  [76] return 
  to:@return

(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  [77] (byte) utoa16n::started#7 ← phi( utoa16w/(byte) 0 utoa16w::@1/(byte) utoa16n::started#1 utoa16w::@2/(byte) utoa16n::started#2 utoa16w::@3/(byte) 1 )
  [77] (byte) utoa16n::nybble#4 ← phi( utoa16w/(byte) utoa16n::nybble#0 utoa16w::@1/(byte) utoa16n::nybble#1 utoa16w::@2/(byte) utoa16n::nybble#2 utoa16w::@3/(byte) utoa16n::nybble#3 )
  [78] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3
  to:utoa16n::@1
utoa16n::@3: scope:[utoa16n]  from utoa16n
  [79] phi()
  to:utoa16n::@1
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  [80] (byte) utoa16n::return#4 ← phi( utoa16n::@3/(byte) utoa16n::started#7 utoa16n/(byte) 1 )
  [81] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return
  to:utoa16n::@2
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1
  [82] *(*(&(byte*) utoa16w::dst#5)) ← *((const byte[]) DIGITS + (byte) utoa16n::nybble#4)
  [83] *(&(byte*) utoa16w::dst#5) ← ++ *(&(byte*) utoa16w::dst#5)
  to:utoa16n::@return
utoa16n::@return: scope:[utoa16n]  from utoa16n::@1 utoa16n::@2
  [84] return 
  to:@return

(void()) cls()
cls: scope:[cls]  from main
  [85] phi()
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  [86] (byte*) cls::sc#2 ← phi( cls/(const byte*) cls::screen#0 cls::@1/(byte*) cls::sc#1 )
  [87] *((byte*) cls::sc#2) ← (byte) ' '
  [88] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2
  [89] if((byte*) cls::sc#1!=(const byte*) cls::screen#0+(word) $3e7+(byte) 1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  [90] return 
  to:@return
