Identified constant variable (byte*) main::SCREEN
Culled Empty Block (label) @1
Culled Empty Block (label) inci::@1

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) i#0 ← (number) 0
  to:@2
main: scope:[main]  from @2
  (byte) i#13 ← phi( @2/(byte) i#14 )
  (byte) main::a#0 ← (number) 4
  call inci 
  (byte) inci::return#0 ← (byte) inci::return#3
  to:main::@1
main::@1: scope:[main]  from main
  (byte) main::a#3 ← phi( main/(byte) main::a#0 )
  (byte) i#7 ← phi( main/(byte) i#5 )
  (byte) inci::return#4 ← phi( main/(byte) inci::return#0 )
  (byte~) main::$0 ← (byte) inci::return#4
  (byte) i#1 ← (byte) i#7
  (byte~) main::$1 ← (byte) main::a#3 + (byte~) main::$0
  (byte) main::a#1 ← (byte~) main::$1
  call inci 
  (byte) inci::return#1 ← (byte) inci::return#3
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) main::a#4 ← phi( main::@1/(byte) main::a#1 )
  (byte) i#8 ← phi( main::@1/(byte) i#5 )
  (byte) inci::return#5 ← phi( main::@1/(byte) inci::return#1 )
  (byte~) main::$2 ← (byte) inci::return#5
  (byte) i#2 ← (byte) i#8
  (byte~) main::$3 ← (byte) main::a#4 + (byte~) main::$2
  (byte) main::a#2 ← (byte~) main::$3
  (byte*) main::SCREEN#0 ← ((byte*)) (number) $400
  *((byte*) main::SCREEN#0) ← (byte) i#2
  (byte*~) main::$4 ← (byte*) main::SCREEN#0 + (number) 1
  *((byte*~) main::$4) ← (byte) main::a#2
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) i#9 ← phi( main::@2/(byte) i#2 )
  (byte) i#3 ← (byte) i#9
  return 
  to:@return
inci: scope:[inci]  from main main::@1
  (byte) i#10 ← phi( main/(byte) i#13 main::@1/(byte) i#1 )
  (number~) inci::$0 ← (byte) i#10 + (number) 7
  (byte) i#4 ← (number~) inci::$0
  (byte) inci::return#2 ← (byte) i#4
  to:inci::@return
inci::@return: scope:[inci]  from inci
  (byte) i#11 ← phi( inci/(byte) i#4 )
  (byte) inci::return#6 ← phi( inci/(byte) inci::return#2 )
  (byte) inci::return#3 ← (byte) inci::return#6
  (byte) i#5 ← (byte) i#11
  return 
  to:@return
@2: scope:[]  from @begin
  (byte) i#14 ← phi( @begin/(byte) i#0 )
  call main 
  to:@3
@3: scope:[]  from @2
  (byte) i#12 ← phi( @2/(byte) i#3 )
  (byte) i#6 ← (byte) i#12
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(label) @2
(label) @3
(label) @begin
(label) @end
(byte) i
(byte) i#0
(byte) i#1
(byte) i#10
(byte) i#11
(byte) i#12
(byte) i#13
(byte) i#14
(byte) i#2
(byte) i#3
(byte) i#4
(byte) i#5
(byte) i#6
(byte) i#7
(byte) i#8
(byte) i#9
(byte()) inci()
(number~) inci::$0
(label) inci::@return
(byte) inci::return
(byte) inci::return#0
(byte) inci::return#1
(byte) inci::return#2
(byte) inci::return#3
(byte) inci::return#4
(byte) inci::return#5
(byte) inci::return#6
(void()) main()
(byte~) main::$0
(byte~) main::$1
(byte~) main::$2
(byte~) main::$3
(byte*~) main::$4
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) main::SCREEN
(byte*) main::SCREEN#0
(byte) main::a
(byte) main::a#0
(byte) main::a#1
(byte) main::a#2
(byte) main::a#3
(byte) main::a#4

Adding number conversion cast (unumber) 0 in (byte) i#0 ← (number) 0
Adding number conversion cast (unumber) 4 in (byte) main::a#0 ← (number) 4
Adding number conversion cast (unumber) 1 in (byte*~) main::$4 ← (byte*) main::SCREEN#0 + (number) 1
Adding number conversion cast (unumber) 7 in (number~) inci::$0 ← (byte) i#10 + (number) 7
Adding number conversion cast (unumber) inci::$0 in (number~) inci::$0 ← (byte) i#10 + (unumber)(number) 7
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte) i#0 ← (unumber)(number) 0
Inlining cast (byte) main::a#0 ← (unumber)(number) 4
Inlining cast (byte*) main::SCREEN#0 ← (byte*)(number) $400
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) inci::$0 ← (byte) i#10 + (byte) 7
Alias (byte) inci::return#0 = (byte) inci::return#4 
Alias (byte) main::a#0 = (byte) main::a#3 
Alias (byte) i#1 = (byte) i#7 
Alias (byte) main::a#1 = (byte~) main::$1 (byte) main::a#4 
Alias (byte) inci::return#1 = (byte) inci::return#5 
Alias (byte) i#2 = (byte) i#8 (byte) i#9 (byte) i#3 
Alias (byte) main::a#2 = (byte~) main::$3 
Alias (byte) i#11 = (byte) i#4 (byte~) inci::$0 (byte) i#5 
Alias (byte) inci::return#2 = (byte) inci::return#6 (byte) inci::return#3 
Alias (byte) i#0 = (byte) i#14 
Alias (byte) i#12 = (byte) i#6 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) i#13 (byte) i#0
Identical Phi Values (byte) i#1 (byte) i#11
Identical Phi Values (byte) i#2 (byte) i#11
Identical Phi Values (byte) i#12 (byte) i#2
Successful SSA optimization Pass2IdenticalPhiElimination
Constant (const byte) i#0 = 0
Constant (const byte) main::a#0 = 4
Constant (const byte*) main::SCREEN#0 = (byte*) 1024
Successful SSA optimization Pass2ConstantIdentification
Converting *(pointer+n) to pointer[n] [20] *((byte*~) main::$4) ← (byte) main::a#2  -- *(main::SCREEN#0 + 1)
Successful SSA optimization Pass2InlineDerefIdx
Eliminating unused variable (byte*~) main::$4 and assignment [9] (byte*~) main::$4 ← (const byte*) main::SCREEN#0 + (byte) 1
Successful SSA optimization PassNEliminateUnusedVars
Inlining constant with var siblings (const byte) main::a#0
Inlining constant with var siblings (const byte) i#0
Constant inlined main::a#0 = (byte) 4
Constant inlined i#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(main::SCREEN#0+1)
Successful SSA optimization Pass2ConstantAdditionElimination
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to inci:6 inci:11 

Created 1 initial phi equivalence classes
Coalesced [10] i#15 ← i#11
Coalesced down to 1 phi equivalence classes
Culled Empty Block (label) @3
Renumbering block @2 to @1
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  [5] call inci 
  [6] (byte) inci::return#0 ← (byte) inci::return#2
  to:main::@1
main::@1: scope:[main]  from main
  [7] (byte~) main::$0 ← (byte) inci::return#0
  [8] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0
  [9] call inci 
  [10] (byte) inci::return#1 ← (byte) inci::return#2
  to:main::@2
main::@2: scope:[main]  from main::@1
  [11] (byte~) main::$2 ← (byte) inci::return#1
  [12] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2
  [13] *((const byte*) main::SCREEN#0) ← (byte) i#11
  [14] *((const byte*) main::SCREEN#0+(byte) 1) ← (byte) main::a#2
  to:main::@return
main::@return: scope:[main]  from main::@2
  [15] return 
  to:@return
inci: scope:[inci]  from main main::@1
  [16] (byte) i#10 ← phi( main/(byte) 0 main::@1/(byte) i#11 )
  [17] (byte) i#11 ← (byte) i#10 + (byte) 7
  [18] (byte) inci::return#2 ← (byte) i#11
  to:inci::@return
inci::@return: scope:[inci]  from inci
  [19] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) i
(byte) i#10 4.0
(byte) i#11 0.7272727272727273
(byte()) inci()
(byte) inci::return
(byte) inci::return#0 4.0
(byte) inci::return#1 4.0
(byte) inci::return#2 1.5
(void()) main()
(byte~) main::$0 4.0
(byte~) main::$2 4.0
(byte*) main::SCREEN
(byte) main::a
(byte) main::a#1 1.0
(byte) main::a#2 2.0

Initial phi equivalence classes
[ i#10 i#11 ]
Added variable inci::return#0 to zero page equivalence class [ inci::return#0 ]
Added variable main::$0 to zero page equivalence class [ main::$0 ]
Added variable main::a#1 to zero page equivalence class [ main::a#1 ]
Added variable inci::return#1 to zero page equivalence class [ inci::return#1 ]
Added variable main::$2 to zero page equivalence class [ main::$2 ]
Added variable main::a#2 to zero page equivalence class [ main::a#2 ]
Added variable inci::return#2 to zero page equivalence class [ inci::return#2 ]
Complete equivalence classes
[ i#10 i#11 ]
[ inci::return#0 ]
[ main::$0 ]
[ main::a#1 ]
[ inci::return#1 ]
[ main::$2 ]
[ main::a#2 ]
[ inci::return#2 ]
Allocated zp ZP_BYTE:2 [ i#10 i#11 ]
Allocated zp ZP_BYTE:3 [ inci::return#0 ]
Allocated zp ZP_BYTE:4 [ main::$0 ]
Allocated zp ZP_BYTE:5 [ main::a#1 ]
Allocated zp ZP_BYTE:6 [ inci::return#1 ]
Allocated zp ZP_BYTE:7 [ main::$2 ]
Allocated zp ZP_BYTE:8 [ main::a#2 ]
Allocated zp ZP_BYTE:9 [ inci::return#2 ]

INITIAL ASM
Target platform is c64basic / 6502X
  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label i = 2
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label SCREEN = $400
    .label _0 = 4
    .label _2 = 7
    .label a = 5
    .label a_2 = 8
    // [5] call inci 
    // [16] phi from main to inci [phi:main->inci]
  inci_from_main:
    // [16] phi (byte) i#10 = (byte) 0 [phi:main->inci#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jsr inci
    // [6] (byte) inci::return#0 ← (byte) inci::return#2 -- vbuz1=vbuz2 
    lda.z inci.return_2
    sta.z inci.return
    jmp b1
    // main::@1
  b1:
    // [7] (byte~) main::$0 ← (byte) inci::return#0 -- vbuz1=vbuz2 
    lda.z inci.return
    sta.z _0
    // [8] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 -- vbuz1=vbuc1_plus_vbuz2 
    lax.z _0
    axs #-[4]
    stx.z a
    // [9] call inci 
    // [16] phi from main::@1 to inci [phi:main::@1->inci]
  inci_from_b1:
    // [16] phi (byte) i#10 = (byte) i#11 [phi:main::@1->inci#0] -- register_copy 
    jsr inci
    // [10] (byte) inci::return#1 ← (byte) inci::return#2 -- vbuz1=vbuz2 
    lda.z inci.return_2
    sta.z inci.return_1
    jmp b2
    // main::@2
  b2:
    // [11] (byte~) main::$2 ← (byte) inci::return#1 -- vbuz1=vbuz2 
    lda.z inci.return_1
    sta.z _2
    // [12] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z a
    clc
    adc.z _2
    sta.z a_2
    // [13] *((const byte*) main::SCREEN#0) ← (byte) i#11 -- _deref_pbuc1=vbuz1 
    lda.z i
    sta SCREEN
    // [14] *((const byte*) main::SCREEN#0+(byte) 1) ← (byte) main::a#2 -- _deref_pbuc1=vbuz1 
    lda.z a_2
    sta SCREEN+1
    jmp breturn
    // main::@return
  breturn:
    // [15] return 
    rts
}
  // inci
inci: {
    .label return = 3
    .label return_1 = 6
    .label return_2 = 9
    // [17] (byte) i#11 ← (byte) i#10 + (byte) 7 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z i
    axs #-[7]
    stx.z i
    // [18] (byte) inci::return#2 ← (byte) i#11 -- vbuz1=vbuz2 
    lda.z i
    sta.z return_2
    jmp breturn
    // inci::@return
  breturn:
    // [19] return 
    rts
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [12] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ main::a#2 i#11 ] ( main:2 [ main::a#2 i#11 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ i#10 i#11 ]
Statement [17] (byte) i#11 ← (byte) i#10 + (byte) 7 [ i#11 ] ( main:2::inci:5 [ i#11 ] main:2::inci:9 [ main::a#1 i#11 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ main::a#1 ]
Statement [12] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ main::a#2 i#11 ] ( main:2 [ main::a#2 i#11 ] ) always clobbers reg byte a 
Statement [17] (byte) i#11 ← (byte) i#10 + (byte) 7 [ i#11 ] ( main:2::inci:5 [ i#11 ] main:2::inci:9 [ main::a#1 i#11 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ i#10 i#11 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ inci::return#0 ] : zp ZP_BYTE:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ main::$0 ] : zp ZP_BYTE:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ main::a#1 ] : zp ZP_BYTE:5 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ inci::return#1 ] : zp ZP_BYTE:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ main::$2 ] : zp ZP_BYTE:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ main::a#2 ] : zp ZP_BYTE:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:9 [ inci::return#2 ] : zp ZP_BYTE:9 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 4: zp ZP_BYTE:4 [ main::$0 ] 4: zp ZP_BYTE:7 [ main::$2 ] 2: zp ZP_BYTE:8 [ main::a#2 ] 1: zp ZP_BYTE:5 [ main::a#1 ] 
Uplift Scope [inci] 4: zp ZP_BYTE:3 [ inci::return#0 ] 4: zp ZP_BYTE:6 [ inci::return#1 ] 1.5: zp ZP_BYTE:9 [ inci::return#2 ] 
Uplift Scope [] 4.73: zp ZP_BYTE:2 [ i#10 i#11 ] 

Uplifting [main] best 110 combination reg byte a [ main::$0 ] reg byte a [ main::$2 ] reg byte x [ main::a#2 ] zp ZP_BYTE:5 [ main::a#1 ] 
Limited combination testing to 100 combinations of 192 possible.
Uplifting [inci] best 89 combination reg byte a [ inci::return#0 ] reg byte a [ inci::return#1 ] reg byte a [ inci::return#2 ] 
Uplifting [] best 82 combination reg byte y [ i#10 i#11 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:5 [ main::a#1 ]
Uplifting [main] best 82 combination zp ZP_BYTE:5 [ main::a#1 ] 
Allocated (was zp ZP_BYTE:5) zp ZP_BYTE:2 [ main::a#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label SCREEN = $400
    .label a = 2
    // [5] call inci 
    // [16] phi from main to inci [phi:main->inci]
  inci_from_main:
    // [16] phi (byte) i#10 = (byte) 0 [phi:main->inci#0] -- vbuyy=vbuc1 
    ldy #0
    jsr inci
    // [6] (byte) inci::return#0 ← (byte) inci::return#2
    jmp b1
    // main::@1
  b1:
    // [7] (byte~) main::$0 ← (byte) inci::return#0
    // [8] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 -- vbuz1=vbuc1_plus_vbuaa 
    clc
    adc #4
    sta.z a
    // [9] call inci 
    // [16] phi from main::@1 to inci [phi:main::@1->inci]
  inci_from_b1:
    // [16] phi (byte) i#10 = (byte) i#11 [phi:main::@1->inci#0] -- register_copy 
    jsr inci
    // [10] (byte) inci::return#1 ← (byte) inci::return#2
    jmp b2
    // main::@2
  b2:
    // [11] (byte~) main::$2 ← (byte) inci::return#1
    // [12] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 -- vbuxx=vbuz1_plus_vbuaa 
    clc
    adc.z a
    tax
    // [13] *((const byte*) main::SCREEN#0) ← (byte) i#11 -- _deref_pbuc1=vbuyy 
    sty SCREEN
    // [14] *((const byte*) main::SCREEN#0+(byte) 1) ← (byte) main::a#2 -- _deref_pbuc1=vbuxx 
    stx SCREEN+1
    jmp breturn
    // main::@return
  breturn:
    // [15] return 
    rts
}
  // inci
inci: {
    // [17] (byte) i#11 ← (byte) i#10 + (byte) 7 -- vbuyy=vbuyy_plus_vbuc1 
    tya
    clc
    adc #7
    tay
    // [18] (byte) inci::return#2 ← (byte) i#11 -- vbuaa=vbuyy 
    tya
    jmp breturn
    // inci::@return
  breturn:
    // [19] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction inci_from_main:
Removing instruction b1:
Removing instruction inci_from_b1:
Removing instruction b2:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte) i
(byte) i#10 reg byte y 4.0
(byte) i#11 reg byte y 0.7272727272727273
(byte()) inci()
(label) inci::@return
(byte) inci::return
(byte) inci::return#0 reg byte a 4.0
(byte) inci::return#1 reg byte a 4.0
(byte) inci::return#2 reg byte a 1.5
(void()) main()
(byte~) main::$0 reg byte a 4.0
(byte~) main::$2 reg byte a 4.0
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) main::SCREEN
(const byte*) main::SCREEN#0 SCREEN = (byte*) 1024
(byte) main::a
(byte) main::a#1 a zp ZP_BYTE:2 1.0
(byte) main::a#2 reg byte x 2.0

reg byte y [ i#10 i#11 ]
reg byte a [ inci::return#0 ]
reg byte a [ main::$0 ]
zp ZP_BYTE:2 [ main::a#1 ]
reg byte a [ inci::return#1 ]
reg byte a [ main::$2 ]
reg byte x [ main::a#2 ]
reg byte a [ inci::return#2 ]


FINAL ASSEMBLER
Score: 58

  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label SCREEN = $400
    .label a = 2
    // inci()
    // [5] call inci 
    // [16] phi from main to inci [phi:main->inci]
    // [16] phi (byte) i#10 = (byte) 0 [phi:main->inci#0] -- vbuyy=vbuc1 
    ldy #0
    jsr inci
    // inci()
    // [6] (byte) inci::return#0 ← (byte) inci::return#2
    // main::@1
    // [7] (byte~) main::$0 ← (byte) inci::return#0
    // a=a+inci()
    // [8] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 -- vbuz1=vbuc1_plus_vbuaa 
    clc
    adc #4
    sta.z a
    // inci()
    // [9] call inci 
    // [16] phi from main::@1 to inci [phi:main::@1->inci]
    // [16] phi (byte) i#10 = (byte) i#11 [phi:main::@1->inci#0] -- register_copy 
    jsr inci
    // inci()
    // [10] (byte) inci::return#1 ← (byte) inci::return#2
    // main::@2
    // [11] (byte~) main::$2 ← (byte) inci::return#1
    // a=a+inci()
    // [12] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 -- vbuxx=vbuz1_plus_vbuaa 
    clc
    adc.z a
    tax
    // *SCREEN = i
    // [13] *((const byte*) main::SCREEN#0) ← (byte) i#11 -- _deref_pbuc1=vbuyy 
    sty SCREEN
    // *(SCREEN+1) = a
    // [14] *((const byte*) main::SCREEN#0+(byte) 1) ← (byte) main::a#2 -- _deref_pbuc1=vbuxx 
    stx SCREEN+1
    // main::@return
    // }
    // [15] return 
    rts
}
  // inci
inci: {
    // i+7
    // [17] (byte) i#11 ← (byte) i#10 + (byte) 7 -- vbuyy=vbuyy_plus_vbuc1 
    tya
    clc
    adc #7
    tay
    // return i;
    // [18] (byte) inci::return#2 ← (byte) i#11 -- vbuaa=vbuyy 
    tya
    // inci::@return
    // }
    // [19] return 
    rts
}
  // File Data

