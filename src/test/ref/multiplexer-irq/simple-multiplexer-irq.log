Resolved forward reference plex_irq to interrupt(KERNEL_MIN)(void()) plex_irq()
Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) SPRITE
Identified constant variable (byte*) YSIN
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call plexSetScreen (byte*) plexInit::screen 
Inlined call call plexFreePrepare 
Inlined call call plexFreeAdd (byte) plexShowSprite::ypos 
Inlined call (byte~) plex_irq::$2 ← call plexFreeNextYpos 

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) PROCPORT_DDR#0 ← ((byte*)) (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) PROCPORT_DDR_MEMORY_MASK#0 ← (byte/signed byte/word/signed word/dword/signed dword) 7
  (byte*) PROCPORT#0 ← ((byte*)) (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) PROCPORT_RAM_ALL#0 ← (byte/signed byte/word/signed word/dword/signed dword) $30
  (byte) PROCPORT_RAM_IO#0 ← (byte/signed byte/word/signed word/dword/signed dword) $35
  (byte) PROCPORT_RAM_CHARROM#0 ← (byte/signed byte/word/signed word/dword/signed dword) $31
  (byte) PROCPORT_KERNEL_IO#0 ← (byte/signed byte/word/signed word/dword/signed dword) $36
  (byte) PROCPORT_BASIC_KERNEL_IO#0 ← (byte/signed byte/word/signed word/dword/signed dword) $37
  (byte*) CHARGEN#0 ← ((byte*)) (word/dword/signed dword) $d000
  (word) SPRITE_PTRS#0 ← (word/signed word/dword/signed dword) $3f8
  (byte*) SPRITES_XPOS#0 ← ((byte*)) (word/dword/signed dword) $d000
  (byte*) SPRITES_YPOS#0 ← ((byte*)) (word/dword/signed dword) $d001
  (byte*) SPRITES_XMSB#0 ← ((byte*)) (word/dword/signed dword) $d010
  (byte*) RASTER#0 ← ((byte*)) (word/dword/signed dword) $d012
  (byte*) SPRITES_ENABLE#0 ← ((byte*)) (word/dword/signed dword) $d015
  (byte*) SPRITES_EXPAND_Y#0 ← ((byte*)) (word/dword/signed dword) $d017
  (byte*) SPRITES_PRIORITY#0 ← ((byte*)) (word/dword/signed dword) $d01b
  (byte*) SPRITES_MC#0 ← ((byte*)) (word/dword/signed dword) $d01c
  (byte*) SPRITES_EXPAND_X#0 ← ((byte*)) (word/dword/signed dword) $d01d
  (byte*) BORDERCOL#0 ← ((byte*)) (word/dword/signed dword) $d020
  (byte*) BGCOL#0 ← ((byte*)) (word/dword/signed dword) $d021
  (byte*) BGCOL1#0 ← ((byte*)) (word/dword/signed dword) $d021
  (byte*) BGCOL2#0 ← ((byte*)) (word/dword/signed dword) $d022
  (byte*) BGCOL3#0 ← ((byte*)) (word/dword/signed dword) $d023
  (byte*) BGCOL4#0 ← ((byte*)) (word/dword/signed dword) $d024
  (byte*) SPRITES_MC1#0 ← ((byte*)) (word/dword/signed dword) $d025
  (byte*) SPRITES_MC2#0 ← ((byte*)) (word/dword/signed dword) $d026
  (byte*) SPRITES_COLS#0 ← ((byte*)) (word/dword/signed dword) $d027
  (byte*) VIC_CONTROL#0 ← ((byte*)) (word/dword/signed dword) $d011
  (byte*) D011#0 ← ((byte*)) (word/dword/signed dword) $d011
  (byte) VIC_RST8#0 ← (byte/word/signed word/dword/signed dword) $80
  (byte) VIC_ECM#0 ← (byte/signed byte/word/signed word/dword/signed dword) $40
  (byte) VIC_BMM#0 ← (byte/signed byte/word/signed word/dword/signed dword) $20
  (byte) VIC_DEN#0 ← (byte/signed byte/word/signed word/dword/signed dword) $10
  (byte) VIC_RSEL#0 ← (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte*) VIC_CONTROL2#0 ← ((byte*)) (word/dword/signed dword) $d016
  (byte*) D016#0 ← ((byte*)) (word/dword/signed dword) $d016
  (byte) VIC_MCM#0 ← (byte/signed byte/word/signed word/dword/signed dword) $10
  (byte) VIC_CSEL#0 ← (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte*) D018#0 ← ((byte*)) (word/dword/signed dword) $d018
  (byte*) VIC_MEMORY#0 ← ((byte*)) (word/dword/signed dword) $d018
  (byte*) LIGHTPEN_X#0 ← ((byte*)) (word/dword/signed dword) $d013
  (byte*) LIGHTPEN_Y#0 ← ((byte*)) (word/dword/signed dword) $d014
  (byte*) IRQ_STATUS#0 ← ((byte*)) (word/dword/signed dword) $d019
  (byte*) IRQ_ENABLE#0 ← ((byte*)) (word/dword/signed dword) $d01a
  (byte) IRQ_RASTER#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) IRQ_COLLISION_BG#0 ← (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte) IRQ_COLLISION_SPRITE#0 ← (byte/signed byte/word/signed word/dword/signed dword) 4
  (byte) IRQ_LIGHTPEN#0 ← (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte*) COLS#0 ← ((byte*)) (word/dword/signed dword) $d800
  (byte*) CIA1_PORT_A#0 ← ((byte*)) (word/dword/signed dword) $dc00
  (byte*) CIA1_PORT_B#0 ← ((byte*)) (word/dword/signed dword) $dc01
  (byte*) CIA1_PORT_A_DDR#0 ← ((byte*)) (word/dword/signed dword) $dc02
  (byte*) CIA1_PORT_B_DDR#0 ← ((byte*)) (word/dword/signed dword) $dc03
  (byte*) CIA1_INTERRUPT#0 ← ((byte*)) (word/dword/signed dword) $dc0d
  (byte) CIA_INTERRUPT_CLEAR#0 ← (byte/signed byte/word/signed word/dword/signed dword) $7f
  (byte*) CIA2_PORT_A#0 ← ((byte*)) (word/dword/signed dword) $dd00
  (byte*) CIA2_PORT_B#0 ← ((byte*)) (word/dword/signed dword) $dd01
  (byte*) CIA2_PORT_A_DDR#0 ← ((byte*)) (word/dword/signed dword) $dd02
  (byte*) CIA2_PORT_B_DDR#0 ← ((byte*)) (word/dword/signed dword) $dd03
  (byte*) CIA2_INTERRUPT#0 ← ((byte*)) (word/dword/signed dword) $dd0d
  (void()**) KERNEL_IRQ#0 ← ((void()**)) (word/signed word/dword/signed dword) $314
  (void()**) HARDWARE_IRQ#0 ← ((void()**)) (word/dword/signed dword) $fffe
  (byte) BLACK#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) WHITE#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) RED#0 ← (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte) CYAN#0 ← (byte/signed byte/word/signed word/dword/signed dword) 3
  (byte) PURPLE#0 ← (byte/signed byte/word/signed word/dword/signed dword) 4
  (byte) GREEN#0 ← (byte/signed byte/word/signed word/dword/signed dword) 5
  (byte) BLUE#0 ← (byte/signed byte/word/signed word/dword/signed dword) 6
  (byte) YELLOW#0 ← (byte/signed byte/word/signed word/dword/signed dword) 7
  (byte) ORANGE#0 ← (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte) BROWN#0 ← (byte/signed byte/word/signed word/dword/signed dword) 9
  (byte) PINK#0 ← (byte/signed byte/word/signed word/dword/signed dword) $a
  (byte) DARK_GREY#0 ← (byte/signed byte/word/signed word/dword/signed dword) $b
  (byte) GREY#0 ← (byte/signed byte/word/signed word/dword/signed dword) $c
  (byte) LIGHT_GREEN#0 ← (byte/signed byte/word/signed word/dword/signed dword) $d
  (byte) LIGHT_BLUE#0 ← (byte/signed byte/word/signed word/dword/signed dword) $e
  (byte) LIGHT_GREY#0 ← (byte/signed byte/word/signed word/dword/signed dword) $f
  to:@4
@4: scope:[]  from @begin
  (byte) PLEX_COUNT#0 ← (byte/signed byte/word/signed word/dword/signed dword) $20
  (word[PLEX_COUNT#0]) PLEX_XPOS#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte[PLEX_COUNT#0]) PLEX_YPOS#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte[PLEX_COUNT#0]) PLEX_PTR#0 ← { fill( PLEX_COUNT#0, 0) }
  (word/signed word/dword/signed dword~) $0 ← (word/signed word/dword/signed dword) $400 + (word/signed word/dword/signed dword) $3f8
  (byte*) PLEX_SCREEN_PTR#0 ← ((byte*)) (word/signed word/dword/signed dword~) $0
  (byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte) plex_show_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) plex_sprite_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) plex_sprite_msb#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  to:@9
plexInit: scope:[plexInit]  from init
  (byte*) plexInit::screen#1 ← phi( init/(byte*) plexInit::screen#0 )
  (byte*) plexInit::plexSetScreen1_screen#0 ← (byte*) plexInit::screen#1
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  (byte*) plexInit::plexSetScreen1_screen#1 ← phi( plexInit/(byte*) plexInit::plexSetScreen1_screen#0 )
  (byte*) plexInit::plexSetScreen1_$0#0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (word/signed word/dword/signed dword) $3f8
  (byte*) PLEX_SCREEN_PTR#1 ← (byte*) plexInit::plexSetScreen1_$0#0
  to:plexInit::@3
plexInit::@3: scope:[plexInit]  from plexInit::plexSetScreen1
  (byte*) PLEX_SCREEN_PTR#22 ← phi( plexInit::plexSetScreen1/(byte*) PLEX_SCREEN_PTR#1 )
  (byte/signed word/word/dword/signed dword~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) plexInit::i#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::@3
  (byte*) PLEX_SCREEN_PTR#15 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 plexInit::@3/(byte*) PLEX_SCREEN_PTR#22 )
  (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::@3/(byte) plexInit::i#0 )
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  (byte) plexInit::i#1 ← (byte) plexInit::i#2 + rangenext(0,plexInit::$1)
  (bool~) plexInit::$2 ← (byte) plexInit::i#1 != rangelast(0,plexInit::$1)
  if((bool~) plexInit::$2) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  (byte*) PLEX_SCREEN_PTR#8 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 )
  (byte*) PLEX_SCREEN_PTR#2 ← (byte*) PLEX_SCREEN_PTR#8
  return 
  to:@return
plexSort: scope:[plexSort]  from loop::@11
  (byte/signed word/word/dword/signed dword~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte) plexSort::m#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  (byte) plexSort::m#2 ← phi( plexSort/(byte) plexSort::m#0 plexSort::@2/(byte) plexSort::m#1 )
  (byte/signed word/word/dword/signed dword~) plexSort::$2 ← (byte) plexSort::m#2 + (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) plexSort::nxt_idx#0 ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte/signed word/word/dword/signed dword~) plexSort::$2)
  (byte) plexSort::nxt_y#0 ← *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0)
  (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))
  (bool~) plexSort::$4 ← ! (bool~) plexSort::$3
  if((bool~) plexSort::$4) goto plexSort::@2
  to:plexSort::@5
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  (byte) plexSort::m#3 ← phi( plexSort::@1/(byte) plexSort::m#2 plexSort::@4/(byte) plexSort::m#5 )
  (byte) plexSort::m#1 ← (byte) plexSort::m#3 + rangenext(0,plexSort::$1)
  (bool~) plexSort::$9 ← (byte) plexSort::m#1 != rangelast(0,plexSort::$1)
  if((bool~) plexSort::$9) goto plexSort::@1
  to:plexSort::@6
plexSort::@5: scope:[plexSort]  from plexSort::@1
  (byte) plexSort::nxt_idx#3 ← phi( plexSort::@1/(byte) plexSort::nxt_idx#0 )
  (byte) plexSort::nxt_y#2 ← phi( plexSort::@1/(byte) plexSort::nxt_y#0 )
  (byte) plexSort::m#4 ← phi( plexSort::@1/(byte) plexSort::m#2 )
  (byte) plexSort::s#0 ← (byte) plexSort::m#4
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@3 plexSort::@5
  (byte) plexSort::m#6 ← phi( plexSort::@3/(byte) plexSort::m#6 plexSort::@5/(byte) plexSort::m#4 )
  (byte) plexSort::nxt_idx#2 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 plexSort::@5/(byte) plexSort::nxt_idx#3 )
  (byte) plexSort::nxt_y#1 ← phi( plexSort::@3/(byte) plexSort::nxt_y#1 plexSort::@5/(byte) plexSort::nxt_y#2 )
  (byte) plexSort::s#3 ← phi( plexSort::@3/(byte) plexSort::s#1 plexSort::@5/(byte) plexSort::s#0 )
  (byte/signed word/word/dword/signed dword~) plexSort::$5 ← (byte) plexSort::s#3 + (byte/signed byte/word/signed word/dword/signed dword) 1
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte/signed word/word/dword/signed dword~) plexSort::$5) ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3)
  (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  (bool~) plexSort::$6 ← (byte) plexSort::s#1 != (byte/word/signed word/dword/signed dword) $ff
  (bool~) plexSort::$7 ← (byte) plexSort::nxt_y#1 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))
  (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
  if((bool~) plexSort::$8) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3
  (byte) plexSort::m#5 ← phi( plexSort::@3/(byte) plexSort::m#6 )
  (byte) plexSort::nxt_idx#1 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 )
  (byte) plexSort::s#4 ← phi( plexSort::@3/(byte) plexSort::s#1 )
  (byte) plexSort::s#2 ← ++ (byte) plexSort::s#4
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#1
  to:plexSort::@2
plexSort::@6: scope:[plexSort]  from plexSort::@2
  (byte) plex_show_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) plex_sprite_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) plex_sprite_msb#1 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  (byte) plex_sprite_msb#44 ← phi( plexSort::@6/(byte) plex_sprite_msb#1 )
  (byte) plex_sprite_idx#45 ← phi( plexSort::@6/(byte) plex_sprite_idx#1 )
  (byte) plex_show_idx#48 ← phi( plexSort::@6/(byte) plex_show_idx#1 )
  (byte) plexSort::plexFreePrepare1_s#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#34 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_msb#44 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#34 )
  (byte) plex_sprite_idx#36 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_idx#45 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#36 )
  (byte) plex_show_idx#39 ← phi( plexSort::plexFreePrepare1/(byte) plex_show_idx#48 plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#39 )
  (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) plexSort::plexFreePrepare1_s#0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) plexSort::plexFreePrepare1_s#1 ← (byte) plexSort::plexFreePrepare1_s#2 + rangenext(0,7)
  (bool) plexSort::plexFreePrepare1_$0#0 ← (byte) plexSort::plexFreePrepare1_s#1 != rangelast(0,7)
  if((bool) plexSort::plexFreePrepare1_$0#0) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#25 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#34 )
  (byte) plex_sprite_idx#24 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#36 )
  (byte) plex_show_idx#26 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#39 )
  (byte) plex_free_next#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  (byte) plex_free_next#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_free_next#0 )
  (byte) plex_sprite_msb#13 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_msb#25 )
  (byte) plex_sprite_idx#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_idx#24 )
  (byte) plex_show_idx#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_show_idx#26 )
  (byte) plex_show_idx#2 ← (byte) plex_show_idx#12
  (byte) plex_sprite_idx#2 ← (byte) plex_sprite_idx#12
  (byte) plex_sprite_msb#2 ← (byte) plex_sprite_msb#13
  (byte) plex_free_next#1 ← (byte) plex_free_next#12
  return 
  to:@return
plexShowSprite: scope:[plexShowSprite]  from plex_irq::@3
  (byte) plex_sprite_msb#45 ← phi( plex_irq::@3/(byte) plex_sprite_msb#29 )
  (byte*) PLEX_SCREEN_PTR#23 ← phi( plex_irq::@3/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) plex_free_next#23 ← phi( plex_irq::@3/(byte) plex_free_next#27 )
  (byte) plex_show_idx#13 ← phi( plex_irq::@3/(byte) plex_show_idx#27 )
  (byte) plex_sprite_idx#13 ← phi( plex_irq::@3/(byte) plex_sprite_idx#25 )
  (byte~) plexShowSprite::$0 ← (byte) plex_sprite_idx#13 << (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte~) plexShowSprite::$0
  (byte) plexShowSprite::ypos#0 ← *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#13))
  *((byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::ypos#0
  (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← (byte) plexShowSprite::ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  (byte) plex_sprite_msb#35 ← phi( plexShowSprite/(byte) plex_sprite_msb#45 )
  (byte) plexShowSprite::plex_sprite_idx2#2 ← phi( plexShowSprite/(byte) plexShowSprite::plex_sprite_idx2#0 )
  (byte) plex_sprite_idx#26 ← phi( plexShowSprite/(byte) plex_sprite_idx#13 )
  (byte*) PLEX_SCREEN_PTR#16 ← phi( plexShowSprite/(byte*) PLEX_SCREEN_PTR#23 )
  (byte) plex_show_idx#28 ← phi( plexShowSprite/(byte) plex_show_idx#13 )
  (byte) plex_free_next#13 ← phi( plexShowSprite/(byte) plex_free_next#23 )
  (byte) plexShowSprite::plexFreeAdd1_ypos#1 ← phi( plexShowSprite/(byte) plexShowSprite::plexFreeAdd1_ypos#0 )
  (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (byte/signed byte/word/signed word/dword/signed dword) $15
  *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#13) ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0
  (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#13 + (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 & (byte/signed byte/word/signed word/dword/signed dword) 7
  (byte) plex_free_next#2 ← (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0
  to:plexShowSprite::@7
plexShowSprite::@7: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  (byte) plex_free_next#47 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_free_next#2 )
  (byte) plex_sprite_msb#26 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_msb#35 )
  (byte) plexShowSprite::plex_sprite_idx2#1 ← phi( plexShowSprite::plexFreeAdd1/(byte) plexShowSprite::plex_sprite_idx2#2 )
  (byte) plex_sprite_idx#14 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_idx#26 )
  (byte*) PLEX_SCREEN_PTR#9 ← phi( plexShowSprite::plexFreeAdd1/(byte*) PLEX_SCREEN_PTR#16 )
  (byte) plex_show_idx#14 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_show_idx#28 )
  *((byte*) PLEX_SCREEN_PTR#9 + (byte) plex_sprite_idx#14) ← *((byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#14))
  (byte~) plexShowSprite::$2 ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#14) << (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) plexShowSprite::xpos_idx#0 ← (byte~) plexShowSprite::$2
  (byte~) plexShowSprite::$3 ← < *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0)
  *((byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#1) ← (byte~) plexShowSprite::$3
  (byte~) plexShowSprite::$4 ← > *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0)
  (bool~) plexShowSprite::$5 ← (byte~) plexShowSprite::$4 != (byte/signed byte/word/signed word/dword/signed dword) 0
  if((bool~) plexShowSprite::$5) goto plexShowSprite::@1
  to:plexShowSprite::@4
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#41 ← phi( plexShowSprite::@7/(byte) plex_free_next#47 )
  (byte) plex_show_idx#29 ← phi( plexShowSprite::@7/(byte) plex_show_idx#14 )
  (byte) plex_sprite_idx#27 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#14 )
  (byte) plex_sprite_msb#14 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#26 )
  *((byte*) SPRITES_XMSB#0) ← *((byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#14
  to:plexShowSprite::@2
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#42 ← phi( plexShowSprite::@7/(byte) plex_free_next#47 )
  (byte) plex_show_idx#30 ← phi( plexShowSprite::@7/(byte) plex_show_idx#14 )
  (byte) plex_sprite_idx#28 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#14 )
  (byte) plex_sprite_msb#15 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#26 )
  (byte/word/dword~) plexShowSprite::$10 ← (byte/word/signed word/dword/signed dword) $ff ^ (byte) plex_sprite_msb#15
  *((byte*) SPRITES_XMSB#0) ← *((byte*) SPRITES_XMSB#0) & (byte/word/dword~) plexShowSprite::$10
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@4
  (byte) plex_free_next#32 ← phi( plexShowSprite::@1/(byte) plex_free_next#41 plexShowSprite::@4/(byte) plex_free_next#42 )
  (byte) plex_sprite_msb#16 ← phi( plexShowSprite::@1/(byte) plex_sprite_msb#14 plexShowSprite::@4/(byte) plex_sprite_msb#15 )
  (byte) plex_show_idx#15 ← phi( plexShowSprite::@1/(byte) plex_show_idx#29 plexShowSprite::@4/(byte) plex_show_idx#30 )
  (byte) plex_sprite_idx#15 ← phi( plexShowSprite::@1/(byte) plex_sprite_idx#27 plexShowSprite::@4/(byte) plex_sprite_idx#28 )
  (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 ← (byte) plex_sprite_idx#15 + (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte/word/dword~) plexShowSprite::$7 ← (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 & (byte/signed byte/word/signed word/dword/signed dword) 7
  (byte) plex_sprite_idx#3 ← (byte/word/dword~) plexShowSprite::$7
  (byte) plex_show_idx#3 ← ++ (byte) plex_show_idx#15
  (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#16 << (byte/signed byte/word/signed word/dword/signed dword) 1
  (bool~) plexShowSprite::$8 ← (byte) plex_sprite_msb#3 == (byte/signed byte/word/signed word/dword/signed dword) 0
  (bool~) plexShowSprite::$9 ← ! (bool~) plexShowSprite::$8
  if((bool~) plexShowSprite::$9) goto plexShowSprite::@3
  to:plexShowSprite::@6
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@2
  (byte) plex_sprite_msb#27 ← phi( plexShowSprite::@2/(byte) plex_sprite_msb#3 )
  (byte) plex_show_idx#31 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 )
  (byte) plex_sprite_idx#29 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 )
  (byte) plex_free_next#24 ← phi( plexShowSprite::@2/(byte) plex_free_next#32 )
  to:plexShowSprite::@return
plexShowSprite::@6: scope:[plexShowSprite]  from plexShowSprite::@2
  (byte) plex_show_idx#32 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 )
  (byte) plex_sprite_idx#30 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 )
  (byte) plex_free_next#25 ← phi( plexShowSprite::@2/(byte) plex_free_next#32 )
  (byte) plex_sprite_msb#4 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@3 plexShowSprite::@6
  (byte) plex_sprite_msb#17 ← phi( plexShowSprite::@3/(byte) plex_sprite_msb#27 plexShowSprite::@6/(byte) plex_sprite_msb#4 )
  (byte) plex_show_idx#16 ← phi( plexShowSprite::@3/(byte) plex_show_idx#31 plexShowSprite::@6/(byte) plex_show_idx#32 )
  (byte) plex_sprite_idx#16 ← phi( plexShowSprite::@3/(byte) plex_sprite_idx#29 plexShowSprite::@6/(byte) plex_sprite_idx#30 )
  (byte) plex_free_next#14 ← phi( plexShowSprite::@3/(byte) plex_free_next#24 plexShowSprite::@6/(byte) plex_free_next#25 )
  (byte) plex_free_next#3 ← (byte) plex_free_next#14
  (byte) plex_sprite_idx#4 ← (byte) plex_sprite_idx#16
  (byte) plex_show_idx#4 ← (byte) plex_show_idx#16
  (byte) plex_sprite_msb#5 ← (byte) plex_sprite_msb#17
  return 
  to:@return
@9: scope:[]  from @4
  (byte) plex_sprite_msb#50 ← phi( @4/(byte) plex_sprite_msb#0 )
  (byte) plex_sprite_idx#50 ← phi( @4/(byte) plex_sprite_idx#0 )
  (byte) plex_show_idx#51 ← phi( @4/(byte) plex_show_idx#0 )
  (byte*) PLEX_SCREEN_PTR#29 ← phi( @4/(byte*) PLEX_SCREEN_PTR#0 )
  (byte[8]) PLEX_FREE_YPOS#0 ← { fill( 8, 0) }
  (byte) plex_free_next#4 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:@12
@12: scope:[]  from @9
  (byte) plex_free_next#43 ← phi( @9/(byte) plex_free_next#4 )
  (byte) plex_sprite_msb#46 ← phi( @9/(byte) plex_sprite_msb#50 )
  (byte) plex_sprite_idx#46 ← phi( @9/(byte) plex_sprite_idx#50 )
  (byte) plex_show_idx#49 ← phi( @9/(byte) plex_show_idx#51 )
  (byte*) PLEX_SCREEN_PTR#28 ← phi( @9/(byte*) PLEX_SCREEN_PTR#29 )
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word/dword/signed dword) $400
  (byte*) SPRITE#0 ← ((byte*)) (word/signed word/dword/signed dword) $2000
  (byte*) YSIN#0 ← ((byte*)) (word/signed word/dword/signed dword) $2100
  kickasm(location (byte*) YSIN#0) {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
  kickasm(location (byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  to:@14
main: scope:[main]  from @16
  (bool) framedone#20 ← phi( @16/(bool) framedone#19 )
  (byte) plex_free_next#33 ← phi( @16/(byte) plex_free_next#31 )
  (byte) plex_sprite_msb#36 ← phi( @16/(byte) plex_sprite_msb#33 )
  (byte) plex_sprite_idx#37 ← phi( @16/(byte) plex_sprite_idx#35 )
  (byte) plex_show_idx#40 ← phi( @16/(byte) plex_show_idx#38 )
  (byte*) PLEX_SCREEN_PTR#17 ← phi( @16/(byte*) PLEX_SCREEN_PTR#21 )
  asm { sei  }
  call init 
  to:main::@1
main::@1: scope:[main]  from main
  (bool) framedone#14 ← phi( main/(bool) framedone#20 )
  (byte) plex_free_next#26 ← phi( main/(byte) plex_free_next#33 )
  (byte) plex_sprite_msb#28 ← phi( main/(byte) plex_sprite_msb#36 )
  (byte) plex_sprite_idx#31 ← phi( main/(byte) plex_sprite_idx#37 )
  (byte) plex_show_idx#33 ← phi( main/(byte) plex_show_idx#40 )
  (byte*) PLEX_SCREEN_PTR#10 ← phi( main/(byte*) PLEX_SCREEN_PTR#6 )
  (byte*) PLEX_SCREEN_PTR#3 ← (byte*) PLEX_SCREEN_PTR#10
  call loop 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte*) PLEX_SCREEN_PTR#18 ← phi( main::@1/(byte*) PLEX_SCREEN_PTR#3 )
  (bool) framedone#8 ← phi( main::@1/(bool) framedone#6 )
  (byte) plex_free_next#15 ← phi( main::@1/(byte) plex_free_next#10 )
  (byte) plex_sprite_msb#18 ← phi( main::@1/(byte) plex_sprite_msb#11 )
  (byte) plex_sprite_idx#17 ← phi( main::@1/(byte) plex_sprite_idx#10 )
  (byte) plex_show_idx#17 ← phi( main::@1/(byte) plex_show_idx#10 )
  (byte) plex_show_idx#5 ← (byte) plex_show_idx#17
  (byte) plex_sprite_idx#5 ← (byte) plex_sprite_idx#17
  (byte) plex_sprite_msb#6 ← (byte) plex_sprite_msb#18
  (byte) plex_free_next#5 ← (byte) plex_free_next#15
  (bool) framedone#0 ← (bool) framedone#8
  to:main::@return
main::@return: scope:[main]  from main::@2
  (bool) framedone#9 ← phi( main::@2/(bool) framedone#0 )
  (byte) plex_free_next#16 ← phi( main::@2/(byte) plex_free_next#5 )
  (byte) plex_sprite_msb#19 ← phi( main::@2/(byte) plex_sprite_msb#6 )
  (byte) plex_sprite_idx#18 ← phi( main::@2/(byte) plex_sprite_idx#5 )
  (byte) plex_show_idx#18 ← phi( main::@2/(byte) plex_show_idx#5 )
  (byte*) PLEX_SCREEN_PTR#11 ← phi( main::@2/(byte*) PLEX_SCREEN_PTR#18 )
  (byte*) PLEX_SCREEN_PTR#4 ← (byte*) PLEX_SCREEN_PTR#11
  (byte) plex_show_idx#6 ← (byte) plex_show_idx#18
  (byte) plex_sprite_idx#6 ← (byte) plex_sprite_idx#18
  (byte) plex_sprite_msb#7 ← (byte) plex_sprite_msb#19
  (byte) plex_free_next#6 ← (byte) plex_free_next#16
  (bool) framedone#1 ← (bool) framedone#9
  return 
  to:@return
init: scope:[init]  from main
  (byte*) PLEX_SCREEN_PTR#19 ← phi( main/(byte*) PLEX_SCREEN_PTR#17 )
  (byte~) init::$0 ← (byte) VIC_DEN#0 | (byte) VIC_RSEL#0
  (byte/word/dword~) init::$1 ← (byte~) init::$0 | (byte/signed byte/word/signed word/dword/signed dword) 3
  *((byte*) D011#0) ← (byte/word/dword~) init::$1
  (byte*) plexInit::screen#0 ← (byte*) SCREEN#0
  call plexInit 
  to:init::@5
init::@5: scope:[init]  from init
  (byte*) PLEX_SCREEN_PTR#12 ← phi( init/(byte*) PLEX_SCREEN_PTR#2 )
  (byte*) PLEX_SCREEN_PTR#5 ← (byte*) PLEX_SCREEN_PTR#12
  (word) init::xp#0 ← (byte/signed byte/word/signed word/dword/signed dword) $20
  (byte/signed word/word/dword/signed dword~) init::$4 ← (byte) PLEX_COUNT#0 - (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) init::sx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@5
  (byte*) PLEX_SCREEN_PTR#30 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#30 init::@5/(byte*) PLEX_SCREEN_PTR#5 )
  (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init::@5/(word) init::xp#0 )
  (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init::@5/(byte) init::sx#0 )
  (byte*~) init::$5 ← (byte*) SPRITE#0 / (byte/signed byte/word/signed word/dword/signed dword) $40
  (byte~) init::$6 ← ((byte)) (byte*~) init::$5
  *((byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte~) init::$6
  (byte~) init::$7 ← (byte) init::sx#2 << (byte/signed byte/word/signed word/dword/signed dword) 1
  *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$7) ← (word) init::xp#2
  (word) init::xp#1 ← (word) init::xp#2 + (byte/signed byte/word/signed word/dword/signed dword) 9
  (byte) init::sx#1 ← (byte) init::sx#2 + rangenext(0,init::$4)
  (bool~) init::$8 ← (byte) init::sx#1 != rangelast(0,init::$4)
  if((bool~) init::$8) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  (byte*) PLEX_SCREEN_PTR#27 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#30 )
  *((byte*) SPRITES_ENABLE#0) ← (byte/word/signed word/dword/signed dword) $ff
  (byte) init::ss#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  (byte*) PLEX_SCREEN_PTR#24 ← phi( init::@2/(byte*) PLEX_SCREEN_PTR#27 init::@3/(byte*) PLEX_SCREEN_PTR#24 )
  (byte) init::ss#2 ← phi( init::@2/(byte) init::ss#0 init::@3/(byte) init::ss#1 )
  *((byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (byte) GREEN#0
  (byte) init::ss#1 ← (byte) init::ss#2 + rangenext(0,7)
  (bool~) init::$9 ← (byte) init::ss#1 != rangelast(0,7)
  if((bool~) init::$9) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  (byte*) PLEX_SCREEN_PTR#20 ← phi( init::@3/(byte*) PLEX_SCREEN_PTR#24 )
  asm { sei  }
  *((byte*) CIA1_INTERRUPT#0) ← (byte) CIA_INTERRUPT_CLEAR#0
  *((byte*) IRQ_ENABLE#0) ← (byte) IRQ_RASTER#0
  *((byte*) IRQ_STATUS#0) ← (byte) IRQ_RASTER#0
  (void()*~) init::$3 ← & interrupt(KERNEL_MIN)(void()) plex_irq()
  *((void()**) KERNEL_IRQ#0) ← (void()*~) init::$3
  asm { cli  }
  to:init::@return
init::@return: scope:[init]  from init::@4
  (byte*) PLEX_SCREEN_PTR#13 ← phi( init::@4/(byte*) PLEX_SCREEN_PTR#20 )
  (byte*) PLEX_SCREEN_PTR#6 ← (byte*) PLEX_SCREEN_PTR#13
  return 
  to:@return
@14: scope:[]  from @12
  (byte) plex_free_next#40 ← phi( @12/(byte) plex_free_next#43 )
  (byte) plex_sprite_msb#43 ← phi( @12/(byte) plex_sprite_msb#46 )
  (byte) plex_sprite_idx#44 ← phi( @12/(byte) plex_sprite_idx#46 )
  (byte) plex_show_idx#47 ← phi( @12/(byte) plex_show_idx#49 )
  (byte*) PLEX_SCREEN_PTR#25 ← phi( @12/(byte*) PLEX_SCREEN_PTR#28 )
  (bool) framedone#2 ← true
  to:@16
plex_irq: scope:[plex_irq]  from
  (bool) framedone#29 ← phi( @16/(bool) framedone#19 )
  (byte*) PLEX_SCREEN_PTR#31 ← phi( @16/(byte*) PLEX_SCREEN_PTR#21 )
  (byte) plex_sprite_msb#37 ← phi( @16/(byte) plex_sprite_msb#33 )
  (byte) plex_free_next#34 ← phi( @16/(byte) plex_free_next#31 )
  (byte) plex_show_idx#41 ← phi( @16/(byte) plex_show_idx#38 )
  (byte) plex_sprite_idx#38 ← phi( @16/(byte) plex_sprite_idx#35 )
  (byte) plex_irq::rasterY#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  *((byte*) BORDERCOL#0) ← (byte) WHITE#0
  to:plex_irq::@3
plex_irq::@3: scope:[plex_irq]  from plex_irq plex_irq::@7
  (bool) framedone#28 ← phi( plex_irq/(bool) framedone#29 plex_irq::@7/(bool) framedone#24 )
  (byte*) PLEX_SCREEN_PTR#26 ← phi( plex_irq/(byte*) PLEX_SCREEN_PTR#31 plex_irq::@7/(byte*) PLEX_SCREEN_PTR#32 )
  (byte) plex_sprite_msb#29 ← phi( plex_irq/(byte) plex_sprite_msb#37 plex_irq::@7/(byte) plex_sprite_msb#38 )
  (byte) plex_free_next#27 ← phi( plex_irq/(byte) plex_free_next#34 plex_irq::@7/(byte) plex_free_next#35 )
  (byte) plex_show_idx#27 ← phi( plex_irq/(byte) plex_show_idx#41 plex_irq::@7/(byte) plex_show_idx#20 )
  (byte) plex_sprite_idx#25 ← phi( plex_irq/(byte) plex_sprite_idx#38 plex_irq::@7/(byte) plex_sprite_idx#39 )
  call plexShowSprite 
  to:plex_irq::@8
plex_irq::@8: scope:[plex_irq]  from plex_irq::@3
  (bool) framedone#27 ← phi( plex_irq::@3/(bool) framedone#28 )
  (byte*) PLEX_SCREEN_PTR#35 ← phi( plex_irq::@3/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) plex_sprite_msb#20 ← phi( plex_irq::@3/(byte) plex_sprite_msb#5 )
  (byte) plex_show_idx#19 ← phi( plex_irq::@3/(byte) plex_show_idx#4 )
  (byte) plex_sprite_idx#19 ← phi( plex_irq::@3/(byte) plex_sprite_idx#4 )
  (byte) plex_free_next#17 ← phi( plex_irq::@3/(byte) plex_free_next#3 )
  (byte) plex_free_next#7 ← (byte) plex_free_next#17
  (byte) plex_sprite_idx#7 ← (byte) plex_sprite_idx#19
  (byte) plex_show_idx#7 ← (byte) plex_show_idx#19
  (byte) plex_sprite_msb#8 ← (byte) plex_sprite_msb#20
  to:plex_irq::plexFreeNextYpos1
plex_irq::plexFreeNextYpos1: scope:[plex_irq]  from plex_irq::@8
  (bool) framedone#26 ← phi( plex_irq::@8/(bool) framedone#27 )
  (byte*) PLEX_SCREEN_PTR#34 ← phi( plex_irq::@8/(byte*) PLEX_SCREEN_PTR#35 )
  (byte) plex_sprite_msb#51 ← phi( plex_irq::@8/(byte) plex_sprite_msb#8 )
  (byte) plex_sprite_idx#51 ← phi( plex_irq::@8/(byte) plex_sprite_idx#7 )
  (byte) plex_show_idx#42 ← phi( plex_irq::@8/(byte) plex_show_idx#7 )
  (byte) plex_free_next#18 ← phi( plex_irq::@8/(byte) plex_free_next#7 )
  (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#18)
  to:plex_irq::plexFreeNextYpos1_@return
plex_irq::plexFreeNextYpos1_@return: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1
  (bool) framedone#25 ← phi( plex_irq::plexFreeNextYpos1/(bool) framedone#26 )
  (byte*) PLEX_SCREEN_PTR#33 ← phi( plex_irq::plexFreeNextYpos1/(byte*) PLEX_SCREEN_PTR#34 )
  (byte) plex_sprite_msb#47 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_sprite_msb#51 )
  (byte) plex_free_next#44 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_free_next#18 )
  (byte) plex_sprite_idx#47 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_sprite_idx#51 )
  (byte) plex_show_idx#34 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_show_idx#42 )
  (byte) plex_irq::plexFreeNextYpos1_return#2 ← phi( plex_irq::plexFreeNextYpos1/(byte) plex_irq::plexFreeNextYpos1_return#0 )
  (byte) plex_irq::plexFreeNextYpos1_return#1 ← (byte) plex_irq::plexFreeNextYpos1_return#2
  to:plex_irq::@7
plex_irq::@7: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1_@return
  (bool) framedone#24 ← phi( plex_irq::plexFreeNextYpos1_@return/(bool) framedone#25 )
  (byte*) PLEX_SCREEN_PTR#32 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte*) PLEX_SCREEN_PTR#33 )
  (byte) plex_sprite_msb#38 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_sprite_msb#47 )
  (byte) plex_free_next#35 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_free_next#44 )
  (byte) plex_sprite_idx#39 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_sprite_idx#47 )
  (byte) plex_show_idx#20 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_show_idx#34 )
  (byte) plex_irq::plexFreeNextYpos1_return#3 ← phi( plex_irq::plexFreeNextYpos1_@return/(byte) plex_irq::plexFreeNextYpos1_return#1 )
  (byte~) plex_irq::$2 ← (byte) plex_irq::plexFreeNextYpos1_return#3
  (byte) plex_irq::rasterY#1 ← (byte~) plex_irq::$2
  (bool~) plex_irq::$3 ← (byte) plex_show_idx#20 < (byte) PLEX_COUNT#0
  (byte/signed word/word/dword/signed dword~) plex_irq::$4 ← *((byte*) RASTER#0) + (byte/signed byte/word/signed word/dword/signed dword) 2
  (bool~) plex_irq::$5 ← (byte) plex_irq::rasterY#1 < (byte/signed word/word/dword/signed dword~) plex_irq::$4
  (bool~) plex_irq::$6 ← (bool~) plex_irq::$3 && (bool~) plex_irq::$5
  if((bool~) plex_irq::$6) goto plex_irq::@3
  to:plex_irq::@4
plex_irq::@4: scope:[plex_irq]  from plex_irq::@7
  (bool) framedone#23 ← phi( plex_irq::@7/(bool) framedone#24 )
  (byte) plex_sprite_msb#48 ← phi( plex_irq::@7/(byte) plex_sprite_msb#38 )
  (byte) plex_sprite_idx#48 ← phi( plex_irq::@7/(byte) plex_sprite_idx#39 )
  (byte) plex_free_next#45 ← phi( plex_irq::@7/(byte) plex_free_next#35 )
  (byte) plex_irq::rasterY#3 ← phi( plex_irq::@7/(byte) plex_irq::rasterY#1 )
  (byte) plex_show_idx#21 ← phi( plex_irq::@7/(byte) plex_show_idx#20 )
  *((byte*) IRQ_STATUS#0) ← (byte) IRQ_RASTER#0
  (bool~) plex_irq::$0 ← (byte) plex_show_idx#21 < (byte) PLEX_COUNT#0
  if((bool~) plex_irq::$0) goto plex_irq::@1
  to:plex_irq::@5
plex_irq::@1: scope:[plex_irq]  from plex_irq::@4
  (bool) framedone#21 ← phi( plex_irq::@4/(bool) framedone#23 )
  (byte) plex_sprite_msb#39 ← phi( plex_irq::@4/(byte) plex_sprite_msb#48 )
  (byte) plex_show_idx#43 ← phi( plex_irq::@4/(byte) plex_show_idx#21 )
  (byte) plex_sprite_idx#40 ← phi( plex_irq::@4/(byte) plex_sprite_idx#48 )
  (byte) plex_free_next#36 ← phi( plex_irq::@4/(byte) plex_free_next#45 )
  (byte) plex_irq::rasterY#2 ← phi( plex_irq::@4/(byte) plex_irq::rasterY#3 )
  *((byte*) RASTER#0) ← (byte) plex_irq::rasterY#2
  to:plex_irq::@2
plex_irq::@5: scope:[plex_irq]  from plex_irq::@4
  (byte) plex_sprite_msb#40 ← phi( plex_irq::@4/(byte) plex_sprite_msb#48 )
  (byte) plex_show_idx#44 ← phi( plex_irq::@4/(byte) plex_show_idx#21 )
  (byte) plex_sprite_idx#41 ← phi( plex_irq::@4/(byte) plex_sprite_idx#48 )
  (byte) plex_free_next#37 ← phi( plex_irq::@4/(byte) plex_free_next#45 )
  (bool) framedone#3 ← true
  to:plex_irq::@2
plex_irq::@2: scope:[plex_irq]  from plex_irq::@1 plex_irq::@5
  (bool) framedone#15 ← phi( plex_irq::@1/(bool) framedone#21 plex_irq::@5/(bool) framedone#3 )
  (byte) plex_sprite_msb#30 ← phi( plex_irq::@1/(byte) plex_sprite_msb#39 plex_irq::@5/(byte) plex_sprite_msb#40 )
  (byte) plex_show_idx#35 ← phi( plex_irq::@1/(byte) plex_show_idx#43 plex_irq::@5/(byte) plex_show_idx#44 )
  (byte) plex_sprite_idx#32 ← phi( plex_irq::@1/(byte) plex_sprite_idx#40 plex_irq::@5/(byte) plex_sprite_idx#41 )
  (byte) plex_free_next#28 ← phi( plex_irq::@1/(byte) plex_free_next#36 plex_irq::@5/(byte) plex_free_next#37 )
  *((byte*) BORDERCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:plex_irq::@return
plex_irq::@return: scope:[plex_irq]  from plex_irq::@2
  (bool) framedone#10 ← phi( plex_irq::@2/(bool) framedone#15 )
  (byte) plex_sprite_msb#21 ← phi( plex_irq::@2/(byte) plex_sprite_msb#30 )
  (byte) plex_show_idx#22 ← phi( plex_irq::@2/(byte) plex_show_idx#35 )
  (byte) plex_sprite_idx#20 ← phi( plex_irq::@2/(byte) plex_sprite_idx#32 )
  (byte) plex_free_next#19 ← phi( plex_irq::@2/(byte) plex_free_next#28 )
  (byte) plex_free_next#8 ← (byte) plex_free_next#19
  (byte) plex_sprite_idx#8 ← (byte) plex_sprite_idx#20
  (byte) plex_show_idx#8 ← (byte) plex_show_idx#22
  (byte) plex_sprite_msb#9 ← (byte) plex_sprite_msb#21
  (bool) framedone#4 ← (bool) framedone#10
  return 
  to:@return
loop: scope:[loop]  from main::@1
  (bool) framedone#22 ← phi( main::@1/(bool) framedone#14 )
  (byte) plex_free_next#38 ← phi( main::@1/(byte) plex_free_next#26 )
  (byte) plex_sprite_msb#41 ← phi( main::@1/(byte) plex_sprite_msb#28 )
  (byte) plex_sprite_idx#42 ← phi( main::@1/(byte) plex_sprite_idx#31 )
  (byte) plex_show_idx#45 ← phi( main::@1/(byte) plex_show_idx#33 )
  (byte) loop::sin_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@15
  (byte) loop::sin_idx#8 ← phi( loop/(byte) loop::sin_idx#0 loop::@15/(byte) loop::sin_idx#9 )
  (bool) framedone#18 ← phi( loop/(bool) framedone#22 loop::@15/(bool) framedone#5 )
  (byte) plex_free_next#30 ← phi( loop/(byte) plex_free_next#38 loop::@15/(byte) plex_free_next#9 )
  (byte) plex_sprite_msb#32 ← phi( loop/(byte) plex_sprite_msb#41 loop::@15/(byte) plex_sprite_msb#10 )
  (byte) plex_sprite_idx#34 ← phi( loop/(byte) plex_sprite_idx#42 loop::@15/(byte) plex_sprite_idx#9 )
  (byte) plex_show_idx#37 ← phi( loop/(byte) plex_show_idx#45 loop::@15/(byte) plex_show_idx#9 )
  if(true) goto loop::@2
  to:loop::@return
loop::@2: scope:[loop]  from loop::@1
  (byte) plex_free_next#49 ← phi( loop::@1/(byte) plex_free_next#30 )
  (byte) plex_sprite_msb#53 ← phi( loop::@1/(byte) plex_sprite_msb#32 )
  (byte) plex_sprite_idx#53 ← phi( loop::@1/(byte) plex_sprite_idx#34 )
  (byte) plex_show_idx#53 ← phi( loop::@1/(byte) plex_show_idx#37 )
  (byte) loop::sin_idx#6 ← phi( loop::@1/(byte) loop::sin_idx#8 )
  (bool) framedone#16 ← phi( loop::@1/(bool) framedone#18 )
  to:loop::@4
loop::@4: scope:[loop]  from loop::@2 loop::@5
  (byte) plex_free_next#48 ← phi( loop::@2/(byte) plex_free_next#49 loop::@5/(byte) plex_free_next#50 )
  (byte) plex_sprite_msb#52 ← phi( loop::@2/(byte) plex_sprite_msb#53 loop::@5/(byte) plex_sprite_msb#54 )
  (byte) plex_sprite_idx#52 ← phi( loop::@2/(byte) plex_sprite_idx#53 loop::@5/(byte) plex_sprite_idx#54 )
  (byte) plex_show_idx#52 ← phi( loop::@2/(byte) plex_show_idx#53 loop::@5/(byte) plex_show_idx#54 )
  (byte) loop::sin_idx#4 ← phi( loop::@2/(byte) loop::sin_idx#6 loop::@5/(byte) loop::sin_idx#7 )
  (bool) framedone#11 ← phi( loop::@2/(bool) framedone#16 loop::@5/(bool) framedone#17 )
  (bool~) loop::$0 ← ! (bool) framedone#11
  if((bool~) loop::$0) goto loop::@5
  to:loop::@6
loop::@5: scope:[loop]  from loop::@4
  (byte) plex_free_next#50 ← phi( loop::@4/(byte) plex_free_next#48 )
  (byte) plex_sprite_msb#54 ← phi( loop::@4/(byte) plex_sprite_msb#52 )
  (byte) plex_sprite_idx#54 ← phi( loop::@4/(byte) plex_sprite_idx#52 )
  (byte) plex_show_idx#54 ← phi( loop::@4/(byte) plex_show_idx#52 )
  (byte) loop::sin_idx#7 ← phi( loop::@4/(byte) loop::sin_idx#4 )
  (bool) framedone#17 ← phi( loop::@4/(bool) framedone#11 )
  to:loop::@4
loop::@6: scope:[loop]  from loop::@4
  (byte) plex_free_next#46 ← phi( loop::@4/(byte) plex_free_next#48 )
  (byte) plex_sprite_msb#49 ← phi( loop::@4/(byte) plex_sprite_msb#52 )
  (byte) plex_sprite_idx#49 ← phi( loop::@4/(byte) plex_sprite_idx#52 )
  (byte) plex_show_idx#50 ← phi( loop::@4/(byte) plex_show_idx#52 )
  (byte) loop::sin_idx#2 ← phi( loop::@4/(byte) loop::sin_idx#4 )
  *((byte*) BORDERCOL#0) ← (byte) RED#0
  (byte) loop::y_idx#0 ← (byte) loop::sin_idx#2
  (byte/signed word/word/dword/signed dword~) loop::$1 ← (byte) PLEX_COUNT#0 - (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) loop::sy#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:loop::@10
loop::@10: scope:[loop]  from loop::@10 loop::@6
  (byte) plex_free_next#39 ← phi( loop::@10/(byte) plex_free_next#39 loop::@6/(byte) plex_free_next#46 )
  (byte) plex_sprite_msb#42 ← phi( loop::@10/(byte) plex_sprite_msb#42 loop::@6/(byte) plex_sprite_msb#49 )
  (byte) plex_sprite_idx#43 ← phi( loop::@10/(byte) plex_sprite_idx#43 loop::@6/(byte) plex_sprite_idx#49 )
  (byte) plex_show_idx#46 ← phi( loop::@10/(byte) plex_show_idx#46 loop::@6/(byte) plex_show_idx#50 )
  (byte) loop::sin_idx#5 ← phi( loop::@10/(byte) loop::sin_idx#5 loop::@6/(byte) loop::sin_idx#2 )
  (byte) loop::sy#2 ← phi( loop::@10/(byte) loop::sy#1 loop::@6/(byte) loop::sy#0 )
  (byte) loop::y_idx#2 ← phi( loop::@10/(byte) loop::y_idx#1 loop::@6/(byte) loop::y_idx#0 )
  *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((byte*) YSIN#0 + (byte) loop::y_idx#2)
  (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte/signed byte/word/signed word/dword/signed dword) 8
  (byte) loop::sy#1 ← (byte) loop::sy#2 + rangenext(0,loop::$1)
  (bool~) loop::$2 ← (byte) loop::sy#1 != rangelast(0,loop::$1)
  if((bool~) loop::$2) goto loop::@10
  to:loop::@11
loop::@11: scope:[loop]  from loop::@10
  (byte) plex_free_next#29 ← phi( loop::@10/(byte) plex_free_next#39 )
  (byte) plex_sprite_msb#31 ← phi( loop::@10/(byte) plex_sprite_msb#42 )
  (byte) plex_sprite_idx#33 ← phi( loop::@10/(byte) plex_sprite_idx#43 )
  (byte) plex_show_idx#36 ← phi( loop::@10/(byte) plex_show_idx#46 )
  (byte) loop::sin_idx#3 ← phi( loop::@10/(byte) loop::sin_idx#5 )
  (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#3 + (byte/signed byte/word/signed word/dword/signed dword) 1
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  call plexSort 
  to:loop::@15
loop::@15: scope:[loop]  from loop::@11
  (byte) loop::sin_idx#9 ← phi( loop::@11/(byte) loop::sin_idx#1 )
  (byte) plex_free_next#20 ← phi( loop::@11/(byte) plex_free_next#1 )
  (byte) plex_sprite_msb#22 ← phi( loop::@11/(byte) plex_sprite_msb#2 )
  (byte) plex_sprite_idx#21 ← phi( loop::@11/(byte) plex_sprite_idx#2 )
  (byte) plex_show_idx#23 ← phi( loop::@11/(byte) plex_show_idx#2 )
  (byte) plex_show_idx#9 ← (byte) plex_show_idx#23
  (byte) plex_sprite_idx#9 ← (byte) plex_sprite_idx#21
  (byte) plex_sprite_msb#10 ← (byte) plex_sprite_msb#22
  (byte) plex_free_next#9 ← (byte) plex_free_next#20
  *((byte*) BORDERCOL#0) ← (byte) GREEN#0
  (bool) framedone#5 ← false
  *((byte*) VIC_CONTROL#0) ← *((byte*) VIC_CONTROL#0) & (byte/signed byte/word/signed word/dword/signed dword) $7f
  *((byte*) RASTER#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:loop::@1
loop::@return: scope:[loop]  from loop::@1
  (bool) framedone#12 ← phi( loop::@1/(bool) framedone#18 )
  (byte) plex_free_next#21 ← phi( loop::@1/(byte) plex_free_next#30 )
  (byte) plex_sprite_msb#23 ← phi( loop::@1/(byte) plex_sprite_msb#32 )
  (byte) plex_sprite_idx#22 ← phi( loop::@1/(byte) plex_sprite_idx#34 )
  (byte) plex_show_idx#24 ← phi( loop::@1/(byte) plex_show_idx#37 )
  (byte) plex_show_idx#10 ← (byte) plex_show_idx#24
  (byte) plex_sprite_idx#10 ← (byte) plex_sprite_idx#22
  (byte) plex_sprite_msb#11 ← (byte) plex_sprite_msb#23
  (byte) plex_free_next#10 ← (byte) plex_free_next#21
  (bool) framedone#6 ← (bool) framedone#12
  return 
  to:@return
@16: scope:[]  from @14
  (bool) framedone#19 ← phi( @14/(bool) framedone#2 )
  (byte) plex_free_next#31 ← phi( @14/(byte) plex_free_next#40 )
  (byte) plex_sprite_msb#33 ← phi( @14/(byte) plex_sprite_msb#43 )
  (byte) plex_sprite_idx#35 ← phi( @14/(byte) plex_sprite_idx#44 )
  (byte) plex_show_idx#38 ← phi( @14/(byte) plex_show_idx#47 )
  (byte*) PLEX_SCREEN_PTR#21 ← phi( @14/(byte*) PLEX_SCREEN_PTR#25 )
  call main 
  to:@17
@17: scope:[]  from @16
  (bool) framedone#13 ← phi( @16/(bool) framedone#1 )
  (byte) plex_free_next#22 ← phi( @16/(byte) plex_free_next#6 )
  (byte) plex_sprite_msb#24 ← phi( @16/(byte) plex_sprite_msb#7 )
  (byte) plex_sprite_idx#23 ← phi( @16/(byte) plex_sprite_idx#6 )
  (byte) plex_show_idx#25 ← phi( @16/(byte) plex_show_idx#6 )
  (byte*) PLEX_SCREEN_PTR#14 ← phi( @16/(byte*) PLEX_SCREEN_PTR#4 )
  (byte*) PLEX_SCREEN_PTR#7 ← (byte*) PLEX_SCREEN_PTR#14
  (byte) plex_show_idx#11 ← (byte) plex_show_idx#25
  (byte) plex_sprite_idx#11 ← (byte) plex_sprite_idx#23
  (byte) plex_sprite_msb#12 ← (byte) plex_sprite_msb#24
  (byte) plex_free_next#11 ← (byte) plex_free_next#22
  (bool) framedone#7 ← (bool) framedone#13
  to:@end
@end: scope:[]  from @17

SYMBOL TABLE SSA
(word/signed word/dword/signed dword~) $0
(label) @12
(label) @14
(label) @16
(label) @17
(label) @4
(label) @9
(label) @begin
(label) @end
(byte*) BGCOL
(byte*) BGCOL#0
(byte*) BGCOL1
(byte*) BGCOL1#0
(byte*) BGCOL2
(byte*) BGCOL2#0
(byte*) BGCOL3
(byte*) BGCOL3#0
(byte*) BGCOL4
(byte*) BGCOL4#0
(byte) BLACK
(byte) BLACK#0
(byte) BLUE
(byte) BLUE#0
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte) BROWN
(byte) BROWN#0
(byte*) CHARGEN
(byte*) CHARGEN#0
(byte*) CIA1_INTERRUPT
(byte*) CIA1_INTERRUPT#0
(byte*) CIA1_PORT_A
(byte*) CIA1_PORT_A#0
(byte*) CIA1_PORT_A_DDR
(byte*) CIA1_PORT_A_DDR#0
(byte*) CIA1_PORT_B
(byte*) CIA1_PORT_B#0
(byte*) CIA1_PORT_B_DDR
(byte*) CIA1_PORT_B_DDR#0
(byte*) CIA2_INTERRUPT
(byte*) CIA2_INTERRUPT#0
(byte*) CIA2_PORT_A
(byte*) CIA2_PORT_A#0
(byte*) CIA2_PORT_A_DDR
(byte*) CIA2_PORT_A_DDR#0
(byte*) CIA2_PORT_B
(byte*) CIA2_PORT_B#0
(byte*) CIA2_PORT_B_DDR
(byte*) CIA2_PORT_B_DDR#0
(byte) CIA_INTERRUPT_CLEAR
(byte) CIA_INTERRUPT_CLEAR#0
(byte*) COLS
(byte*) COLS#0
(byte) CYAN
(byte) CYAN#0
(byte*) D011
(byte*) D011#0
(byte*) D016
(byte*) D016#0
(byte*) D018
(byte*) D018#0
(byte) DARK_GREY
(byte) DARK_GREY#0
(byte) GREEN
(byte) GREEN#0
(byte) GREY
(byte) GREY#0
(void()**) HARDWARE_IRQ
(void()**) HARDWARE_IRQ#0
(byte) IRQ_COLLISION_BG
(byte) IRQ_COLLISION_BG#0
(byte) IRQ_COLLISION_SPRITE
(byte) IRQ_COLLISION_SPRITE#0
(byte*) IRQ_ENABLE
(byte*) IRQ_ENABLE#0
(byte) IRQ_LIGHTPEN
(byte) IRQ_LIGHTPEN#0
(byte) IRQ_RASTER
(byte) IRQ_RASTER#0
(byte*) IRQ_STATUS
(byte*) IRQ_STATUS#0
(void()**) KERNEL_IRQ
(void()**) KERNEL_IRQ#0
(byte*) LIGHTPEN_X
(byte*) LIGHTPEN_X#0
(byte*) LIGHTPEN_Y
(byte*) LIGHTPEN_Y#0
(byte) LIGHT_BLUE
(byte) LIGHT_BLUE#0
(byte) LIGHT_GREEN
(byte) LIGHT_GREEN#0
(byte) LIGHT_GREY
(byte) LIGHT_GREY#0
(byte) ORANGE
(byte) ORANGE#0
(byte) PINK
(byte) PINK#0
(byte) PLEX_COUNT
(byte) PLEX_COUNT#0
(byte[8]) PLEX_FREE_YPOS
(byte[8]) PLEX_FREE_YPOS#0
(byte[PLEX_COUNT#0]) PLEX_PTR
(byte[PLEX_COUNT#0]) PLEX_PTR#0
(byte*) PLEX_SCREEN_PTR
(byte*) PLEX_SCREEN_PTR#0
(byte*) PLEX_SCREEN_PTR#1
(byte*) PLEX_SCREEN_PTR#10
(byte*) PLEX_SCREEN_PTR#11
(byte*) PLEX_SCREEN_PTR#12
(byte*) PLEX_SCREEN_PTR#13
(byte*) PLEX_SCREEN_PTR#14
(byte*) PLEX_SCREEN_PTR#15
(byte*) PLEX_SCREEN_PTR#16
(byte*) PLEX_SCREEN_PTR#17
(byte*) PLEX_SCREEN_PTR#18
(byte*) PLEX_SCREEN_PTR#19
(byte*) PLEX_SCREEN_PTR#2
(byte*) PLEX_SCREEN_PTR#20
(byte*) PLEX_SCREEN_PTR#21
(byte*) PLEX_SCREEN_PTR#22
(byte*) PLEX_SCREEN_PTR#23
(byte*) PLEX_SCREEN_PTR#24
(byte*) PLEX_SCREEN_PTR#25
(byte*) PLEX_SCREEN_PTR#26
(byte*) PLEX_SCREEN_PTR#27
(byte*) PLEX_SCREEN_PTR#28
(byte*) PLEX_SCREEN_PTR#29
(byte*) PLEX_SCREEN_PTR#3
(byte*) PLEX_SCREEN_PTR#30
(byte*) PLEX_SCREEN_PTR#31
(byte*) PLEX_SCREEN_PTR#32
(byte*) PLEX_SCREEN_PTR#33
(byte*) PLEX_SCREEN_PTR#34
(byte*) PLEX_SCREEN_PTR#35
(byte*) PLEX_SCREEN_PTR#4
(byte*) PLEX_SCREEN_PTR#5
(byte*) PLEX_SCREEN_PTR#6
(byte*) PLEX_SCREEN_PTR#7
(byte*) PLEX_SCREEN_PTR#8
(byte*) PLEX_SCREEN_PTR#9
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0
(word[PLEX_COUNT#0]) PLEX_XPOS
(word[PLEX_COUNT#0]) PLEX_XPOS#0
(byte[PLEX_COUNT#0]) PLEX_YPOS
(byte[PLEX_COUNT#0]) PLEX_YPOS#0
(byte*) PROCPORT
(byte*) PROCPORT#0
(byte) PROCPORT_BASIC_KERNEL_IO
(byte) PROCPORT_BASIC_KERNEL_IO#0
(byte*) PROCPORT_DDR
(byte*) PROCPORT_DDR#0
(byte) PROCPORT_DDR_MEMORY_MASK
(byte) PROCPORT_DDR_MEMORY_MASK#0
(byte) PROCPORT_KERNEL_IO
(byte) PROCPORT_KERNEL_IO#0
(byte) PROCPORT_RAM_ALL
(byte) PROCPORT_RAM_ALL#0
(byte) PROCPORT_RAM_CHARROM
(byte) PROCPORT_RAM_CHARROM#0
(byte) PROCPORT_RAM_IO
(byte) PROCPORT_RAM_IO#0
(byte) PURPLE
(byte) PURPLE#0
(byte*) RASTER
(byte*) RASTER#0
(byte) RED
(byte) RED#0
(byte*) SCREEN
(byte*) SCREEN#0
(byte*) SPRITE
(byte*) SPRITE#0
(byte*) SPRITES_COLS
(byte*) SPRITES_COLS#0
(byte*) SPRITES_ENABLE
(byte*) SPRITES_ENABLE#0
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_X#0
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_EXPAND_Y#0
(byte*) SPRITES_MC
(byte*) SPRITES_MC#0
(byte*) SPRITES_MC1
(byte*) SPRITES_MC1#0
(byte*) SPRITES_MC2
(byte*) SPRITES_MC2#0
(byte*) SPRITES_PRIORITY
(byte*) SPRITES_PRIORITY#0
(byte*) SPRITES_XMSB
(byte*) SPRITES_XMSB#0
(byte*) SPRITES_XPOS
(byte*) SPRITES_XPOS#0
(byte*) SPRITES_YPOS
(byte*) SPRITES_YPOS#0
(word) SPRITE_PTRS
(word) SPRITE_PTRS#0
(byte) VIC_BMM
(byte) VIC_BMM#0
(byte*) VIC_CONTROL
(byte*) VIC_CONTROL#0
(byte*) VIC_CONTROL2
(byte*) VIC_CONTROL2#0
(byte) VIC_CSEL
(byte) VIC_CSEL#0
(byte) VIC_DEN
(byte) VIC_DEN#0
(byte) VIC_ECM
(byte) VIC_ECM#0
(byte) VIC_MCM
(byte) VIC_MCM#0
(byte*) VIC_MEMORY
(byte*) VIC_MEMORY#0
(byte) VIC_RSEL
(byte) VIC_RSEL#0
(byte) VIC_RST8
(byte) VIC_RST8#0
(byte) WHITE
(byte) WHITE#0
(byte) YELLOW
(byte) YELLOW#0
(byte*) YSIN
(byte*) YSIN#0
(bool) framedone
(bool) framedone#0
(bool) framedone#1
(bool) framedone#10
(bool) framedone#11
(bool) framedone#12
(bool) framedone#13
(bool) framedone#14
(bool) framedone#15
(bool) framedone#16
(bool) framedone#17
(bool) framedone#18
(bool) framedone#19
(bool) framedone#2
(bool) framedone#20
(bool) framedone#21
(bool) framedone#22
(bool) framedone#23
(bool) framedone#24
(bool) framedone#25
(bool) framedone#26
(bool) framedone#27
(bool) framedone#28
(bool) framedone#29
(bool) framedone#3
(bool) framedone#4
(bool) framedone#5
(bool) framedone#6
(bool) framedone#7
(bool) framedone#8
(bool) framedone#9
(void()) init()
(byte~) init::$0
(byte/word/dword~) init::$1
(void()*~) init::$3
(byte/signed word/word/dword/signed dword~) init::$4
(byte*~) init::$5
(byte~) init::$6
(byte~) init::$7
(bool~) init::$8
(bool~) init::$9
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@5
(label) init::@return
(byte) init::ss
(byte) init::ss#0
(byte) init::ss#1
(byte) init::ss#2
(byte) init::sx
(byte) init::sx#0
(byte) init::sx#1
(byte) init::sx#2
(word) init::xp
(word) init::xp#0
(word) init::xp#1
(word) init::xp#2
(void()) loop()
(bool~) loop::$0
(byte/signed word/word/dword/signed dword~) loop::$1
(bool~) loop::$2
(label) loop::@1
(label) loop::@10
(label) loop::@11
(label) loop::@15
(label) loop::@2
(label) loop::@4
(label) loop::@5
(label) loop::@6
(label) loop::@return
(byte) loop::sin_idx
(byte) loop::sin_idx#0
(byte) loop::sin_idx#1
(byte) loop::sin_idx#2
(byte) loop::sin_idx#3
(byte) loop::sin_idx#4
(byte) loop::sin_idx#5
(byte) loop::sin_idx#6
(byte) loop::sin_idx#7
(byte) loop::sin_idx#8
(byte) loop::sin_idx#9
(byte) loop::sy
(byte) loop::sy#0
(byte) loop::sy#1
(byte) loop::sy#2
(byte) loop::y_idx
(byte) loop::y_idx#0
(byte) loop::y_idx#1
(byte) loop::y_idx#2
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(byte/signed word/word/dword/signed dword~) plexInit::$1
(bool~) plexInit::$2
(label) plexInit::@1
(label) plexInit::@3
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#0
(byte) plexInit::i#1
(byte) plexInit::i#2
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_$0#0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::plexSetScreen1_screen#0
(byte*) plexInit::plexSetScreen1_screen#1
(byte*) plexInit::screen
(byte*) plexInit::screen#0
(byte*) plexInit::screen#1
(void()) plexShowSprite()
(byte~) plexShowSprite::$0
(byte/word/dword~) plexShowSprite::$10
(byte~) plexShowSprite::$2
(byte~) plexShowSprite::$3
(byte~) plexShowSprite::$4
(bool~) plexShowSprite::$5
(byte/signed word/word/dword/signed dword~) plexShowSprite::$6
(byte/word/dword~) plexShowSprite::$7
(bool~) plexShowSprite::$8
(bool~) plexShowSprite::$9
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@3
(label) plexShowSprite::@4
(label) plexShowSprite::@6
(label) plexShowSprite::@7
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(byte/signed word/word/dword/signed dword~) plexShowSprite::plexFreeAdd1_$0
(byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0
(byte/signed word/word/dword/signed dword~) plexShowSprite::plexFreeAdd1_$1
(byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0
(byte/word/dword~) plexShowSprite::plexFreeAdd1_$2
(byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0
(byte) plexShowSprite::plexFreeAdd1_ypos#1
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0
(byte) plexShowSprite::plex_sprite_idx2#1
(byte) plexShowSprite::plex_sprite_idx2#2
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0
(byte) plexShowSprite::ypos
(byte) plexShowSprite::ypos#0
(void()) plexSort()
(byte/signed word/word/dword/signed dword~) plexSort::$1
(byte/signed word/word/dword/signed dword~) plexSort::$2
(bool~) plexSort::$3
(bool~) plexSort::$4
(byte/signed word/word/dword/signed dword~) plexSort::$5
(bool~) plexSort::$6
(bool~) plexSort::$7
(bool~) plexSort::$8
(bool~) plexSort::$9
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#0
(byte) plexSort::m#1
(byte) plexSort::m#2
(byte) plexSort::m#3
(byte) plexSort::m#4
(byte) plexSort::m#5
(byte) plexSort::m#6
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0
(byte) plexSort::nxt_idx#1
(byte) plexSort::nxt_idx#2
(byte) plexSort::nxt_idx#3
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0
(byte) plexSort::nxt_y#1
(byte) plexSort::nxt_y#2
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(bool) plexSort::plexFreePrepare1_$0#0
(label) plexSort::plexFreePrepare1_@1
(label) plexSort::plexFreePrepare1_@2
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#0
(byte) plexSort::plexFreePrepare1_s#1
(byte) plexSort::plexFreePrepare1_s#2
(byte) plexSort::s
(byte) plexSort::s#0
(byte) plexSort::s#1
(byte) plexSort::s#2
(byte) plexSort::s#3
(byte) plexSort::s#4
(byte) plex_free_next
(byte) plex_free_next#0
(byte) plex_free_next#1
(byte) plex_free_next#10
(byte) plex_free_next#11
(byte) plex_free_next#12
(byte) plex_free_next#13
(byte) plex_free_next#14
(byte) plex_free_next#15
(byte) plex_free_next#16
(byte) plex_free_next#17
(byte) plex_free_next#18
(byte) plex_free_next#19
(byte) plex_free_next#2
(byte) plex_free_next#20
(byte) plex_free_next#21
(byte) plex_free_next#22
(byte) plex_free_next#23
(byte) plex_free_next#24
(byte) plex_free_next#25
(byte) plex_free_next#26
(byte) plex_free_next#27
(byte) plex_free_next#28
(byte) plex_free_next#29
(byte) plex_free_next#3
(byte) plex_free_next#30
(byte) plex_free_next#31
(byte) plex_free_next#32
(byte) plex_free_next#33
(byte) plex_free_next#34
(byte) plex_free_next#35
(byte) plex_free_next#36
(byte) plex_free_next#37
(byte) plex_free_next#38
(byte) plex_free_next#39
(byte) plex_free_next#4
(byte) plex_free_next#40
(byte) plex_free_next#41
(byte) plex_free_next#42
(byte) plex_free_next#43
(byte) plex_free_next#44
(byte) plex_free_next#45
(byte) plex_free_next#46
(byte) plex_free_next#47
(byte) plex_free_next#48
(byte) plex_free_next#49
(byte) plex_free_next#5
(byte) plex_free_next#50
(byte) plex_free_next#6
(byte) plex_free_next#7
(byte) plex_free_next#8
(byte) plex_free_next#9
interrupt(KERNEL_MIN)(void()) plex_irq()
(bool~) plex_irq::$0
(byte~) plex_irq::$2
(bool~) plex_irq::$3
(byte/signed word/word/dword/signed dword~) plex_irq::$4
(bool~) plex_irq::$5
(bool~) plex_irq::$6
(label) plex_irq::@1
(label) plex_irq::@2
(label) plex_irq::@3
(label) plex_irq::@4
(label) plex_irq::@5
(label) plex_irq::@7
(label) plex_irq::@8
(label) plex_irq::@return
(label) plex_irq::plexFreeNextYpos1
(label) plex_irq::plexFreeNextYpos1_@return
(byte) plex_irq::plexFreeNextYpos1_return
(byte) plex_irq::plexFreeNextYpos1_return#0
(byte) plex_irq::plexFreeNextYpos1_return#1
(byte) plex_irq::plexFreeNextYpos1_return#2
(byte) plex_irq::plexFreeNextYpos1_return#3
(byte) plex_irq::rasterY
(byte) plex_irq::rasterY#0
(byte) plex_irq::rasterY#1
(byte) plex_irq::rasterY#2
(byte) plex_irq::rasterY#3
(byte) plex_show_idx
(byte) plex_show_idx#0
(byte) plex_show_idx#1
(byte) plex_show_idx#10
(byte) plex_show_idx#11
(byte) plex_show_idx#12
(byte) plex_show_idx#13
(byte) plex_show_idx#14
(byte) plex_show_idx#15
(byte) plex_show_idx#16
(byte) plex_show_idx#17
(byte) plex_show_idx#18
(byte) plex_show_idx#19
(byte) plex_show_idx#2
(byte) plex_show_idx#20
(byte) plex_show_idx#21
(byte) plex_show_idx#22
(byte) plex_show_idx#23
(byte) plex_show_idx#24
(byte) plex_show_idx#25
(byte) plex_show_idx#26
(byte) plex_show_idx#27
(byte) plex_show_idx#28
(byte) plex_show_idx#29
(byte) plex_show_idx#3
(byte) plex_show_idx#30
(byte) plex_show_idx#31
(byte) plex_show_idx#32
(byte) plex_show_idx#33
(byte) plex_show_idx#34
(byte) plex_show_idx#35
(byte) plex_show_idx#36
(byte) plex_show_idx#37
(byte) plex_show_idx#38
(byte) plex_show_idx#39
(byte) plex_show_idx#4
(byte) plex_show_idx#40
(byte) plex_show_idx#41
(byte) plex_show_idx#42
(byte) plex_show_idx#43
(byte) plex_show_idx#44
(byte) plex_show_idx#45
(byte) plex_show_idx#46
(byte) plex_show_idx#47
(byte) plex_show_idx#48
(byte) plex_show_idx#49
(byte) plex_show_idx#5
(byte) plex_show_idx#50
(byte) plex_show_idx#51
(byte) plex_show_idx#52
(byte) plex_show_idx#53
(byte) plex_show_idx#54
(byte) plex_show_idx#6
(byte) plex_show_idx#7
(byte) plex_show_idx#8
(byte) plex_show_idx#9
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0
(byte) plex_sprite_idx#1
(byte) plex_sprite_idx#10
(byte) plex_sprite_idx#11
(byte) plex_sprite_idx#12
(byte) plex_sprite_idx#13
(byte) plex_sprite_idx#14
(byte) plex_sprite_idx#15
(byte) plex_sprite_idx#16
(byte) plex_sprite_idx#17
(byte) plex_sprite_idx#18
(byte) plex_sprite_idx#19
(byte) plex_sprite_idx#2
(byte) plex_sprite_idx#20
(byte) plex_sprite_idx#21
(byte) plex_sprite_idx#22
(byte) plex_sprite_idx#23
(byte) plex_sprite_idx#24
(byte) plex_sprite_idx#25
(byte) plex_sprite_idx#26
(byte) plex_sprite_idx#27
(byte) plex_sprite_idx#28
(byte) plex_sprite_idx#29
(byte) plex_sprite_idx#3
(byte) plex_sprite_idx#30
(byte) plex_sprite_idx#31
(byte) plex_sprite_idx#32
(byte) plex_sprite_idx#33
(byte) plex_sprite_idx#34
(byte) plex_sprite_idx#35
(byte) plex_sprite_idx#36
(byte) plex_sprite_idx#37
(byte) plex_sprite_idx#38
(byte) plex_sprite_idx#39
(byte) plex_sprite_idx#4
(byte) plex_sprite_idx#40
(byte) plex_sprite_idx#41
(byte) plex_sprite_idx#42
(byte) plex_sprite_idx#43
(byte) plex_sprite_idx#44
(byte) plex_sprite_idx#45
(byte) plex_sprite_idx#46
(byte) plex_sprite_idx#47
(byte) plex_sprite_idx#48
(byte) plex_sprite_idx#49
(byte) plex_sprite_idx#5
(byte) plex_sprite_idx#50
(byte) plex_sprite_idx#51
(byte) plex_sprite_idx#52
(byte) plex_sprite_idx#53
(byte) plex_sprite_idx#54
(byte) plex_sprite_idx#6
(byte) plex_sprite_idx#7
(byte) plex_sprite_idx#8
(byte) plex_sprite_idx#9
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0
(byte) plex_sprite_msb#1
(byte) plex_sprite_msb#10
(byte) plex_sprite_msb#11
(byte) plex_sprite_msb#12
(byte) plex_sprite_msb#13
(byte) plex_sprite_msb#14
(byte) plex_sprite_msb#15
(byte) plex_sprite_msb#16
(byte) plex_sprite_msb#17
(byte) plex_sprite_msb#18
(byte) plex_sprite_msb#19
(byte) plex_sprite_msb#2
(byte) plex_sprite_msb#20
(byte) plex_sprite_msb#21
(byte) plex_sprite_msb#22
(byte) plex_sprite_msb#23
(byte) plex_sprite_msb#24
(byte) plex_sprite_msb#25
(byte) plex_sprite_msb#26
(byte) plex_sprite_msb#27
(byte) plex_sprite_msb#28
(byte) plex_sprite_msb#29
(byte) plex_sprite_msb#3
(byte) plex_sprite_msb#30
(byte) plex_sprite_msb#31
(byte) plex_sprite_msb#32
(byte) plex_sprite_msb#33
(byte) plex_sprite_msb#34
(byte) plex_sprite_msb#35
(byte) plex_sprite_msb#36
(byte) plex_sprite_msb#37
(byte) plex_sprite_msb#38
(byte) plex_sprite_msb#39
(byte) plex_sprite_msb#4
(byte) plex_sprite_msb#40
(byte) plex_sprite_msb#41
(byte) plex_sprite_msb#42
(byte) plex_sprite_msb#43
(byte) plex_sprite_msb#44
(byte) plex_sprite_msb#45
(byte) plex_sprite_msb#46
(byte) plex_sprite_msb#47
(byte) plex_sprite_msb#48
(byte) plex_sprite_msb#49
(byte) plex_sprite_msb#5
(byte) plex_sprite_msb#50
(byte) plex_sprite_msb#51
(byte) plex_sprite_msb#52
(byte) plex_sprite_msb#53
(byte) plex_sprite_msb#54
(byte) plex_sprite_msb#6
(byte) plex_sprite_msb#7
(byte) plex_sprite_msb#8
(byte) plex_sprite_msb#9

Inversing boolean not [112] (bool~) plexSort::$4 ← (byte) plexSort::nxt_y#0 >= *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2)) from [111] (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))
Inversing boolean not [182] (bool~) plexShowSprite::$9 ← (byte) plex_sprite_msb#3 != (byte/signed byte/word/signed word/dword/signed dword) 0 from [181] (bool~) plexShowSprite::$8 ← (byte) plex_sprite_msb#3 == (byte/signed byte/word/signed word/dword/signed dword) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 (byte) plex_free_next#47 (byte) plex_free_next#41 (byte) plex_free_next#42 
Alias candidate removed (volatile)(byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#3 (byte/word/dword~) plexShowSprite::$7 (byte) plex_sprite_idx#30 
Alias (byte*) plexInit::plexSetScreen1_screen#0 = (byte*) plexInit::screen#1 (byte*) plexInit::plexSetScreen1_screen#1 
Alias (byte*) PLEX_SCREEN_PTR#1 = (byte*) plexInit::plexSetScreen1_$0#0 (byte*) PLEX_SCREEN_PTR#22 
Alias (byte*) PLEX_SCREEN_PTR#15 = (byte*) PLEX_SCREEN_PTR#8 (byte*) PLEX_SCREEN_PTR#2 
Alias (byte) plexSort::m#2 = (byte) plexSort::m#4 (byte) plexSort::s#0 
Alias (byte) plexSort::nxt_y#0 = (byte) plexSort::nxt_y#2 
Alias (byte) plexSort::nxt_idx#0 = (byte) plexSort::nxt_idx#3 
Alias (byte) plexSort::s#1 = (byte) plexSort::s#4 
Alias (byte) plexSort::nxt_idx#1 = (byte) plexSort::nxt_idx#2 
Alias (byte) plexSort::m#5 = (byte) plexSort::m#6 
Alias (byte) plex_show_idx#1 = (byte) plex_show_idx#48 
Alias (byte) plex_sprite_idx#1 = (byte) plex_sprite_idx#45 
Alias (byte) plex_sprite_msb#1 = (byte) plex_sprite_msb#44 
Alias (byte) plex_show_idx#12 = (byte) plex_show_idx#26 (byte) plex_show_idx#39 (byte) plex_show_idx#2 
Alias (byte) plex_sprite_idx#12 = (byte) plex_sprite_idx#24 (byte) plex_sprite_idx#36 (byte) plex_sprite_idx#2 
Alias (byte) plex_sprite_msb#13 = (byte) plex_sprite_msb#25 (byte) plex_sprite_msb#34 (byte) plex_sprite_msb#2 
Alias (byte) plex_free_next#0 = (byte) plex_free_next#12 (byte) plex_free_next#1 
Alias (byte) plexShowSprite::plex_sprite_idx2#0 = (byte~) plexShowSprite::$0 (byte) plexShowSprite::plex_sprite_idx2#2 (byte) plexShowSprite::plex_sprite_idx2#1 
Alias (byte) plexShowSprite::plexFreeAdd1_ypos#0 = (byte) plexShowSprite::ypos#0 (byte) plexShowSprite::plexFreeAdd1_ypos#1 
Alias (byte) plex_free_next#13 = (byte) plex_free_next#23 
Alias (byte) plex_show_idx#13 = (byte) plex_show_idx#28 (byte) plex_show_idx#14 (byte) plex_show_idx#29 (byte) plex_show_idx#30 
Alias (byte*) PLEX_SCREEN_PTR#16 = (byte*) PLEX_SCREEN_PTR#23 (byte*) PLEX_SCREEN_PTR#9 
Alias (byte) plex_sprite_idx#13 = (byte) plex_sprite_idx#26 (byte) plex_sprite_idx#14 (byte) plex_sprite_idx#27 (byte) plex_sprite_idx#28 
Alias (byte) plex_sprite_msb#14 = (byte) plex_sprite_msb#35 (byte) plex_sprite_msb#45 (byte) plex_sprite_msb#26 (byte) plex_sprite_msb#15 
Alias (byte) plexShowSprite::xpos_idx#0 = (byte~) plexShowSprite::$2 
Alias (byte) plex_free_next#24 = (byte) plex_free_next#32 (byte) plex_free_next#25 
Alias (byte) plex_show_idx#3 = (byte) plex_show_idx#31 (byte) plex_show_idx#32 
Alias (byte) plex_sprite_msb#27 = (byte) plex_sprite_msb#3 
Alias (byte) plex_free_next#14 = (byte) plex_free_next#3 
Alias (byte) plex_sprite_idx#16 = (byte) plex_sprite_idx#4 
Alias (byte) plex_show_idx#16 = (byte) plex_show_idx#4 
Alias (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#5 
Alias (byte*) PLEX_SCREEN_PTR#0 = (byte*) PLEX_SCREEN_PTR#29 (byte*) PLEX_SCREEN_PTR#28 (byte*) PLEX_SCREEN_PTR#25 (byte*) PLEX_SCREEN_PTR#21 
Alias (byte) plex_show_idx#0 = (byte) plex_show_idx#51 (byte) plex_show_idx#49 (byte) plex_show_idx#47 (byte) plex_show_idx#38 
Alias (byte) plex_sprite_idx#0 = (byte) plex_sprite_idx#50 (byte) plex_sprite_idx#46 (byte) plex_sprite_idx#44 (byte) plex_sprite_idx#35 
Alias (byte) plex_sprite_msb#0 = (byte) plex_sprite_msb#50 (byte) plex_sprite_msb#46 (byte) plex_sprite_msb#43 (byte) plex_sprite_msb#33 
Alias (byte) plex_free_next#31 = (byte) plex_free_next#43 (byte) plex_free_next#4 (byte) plex_free_next#40 
Alias (byte) plex_show_idx#33 = (byte) plex_show_idx#40 
Alias (byte) plex_sprite_idx#31 = (byte) plex_sprite_idx#37 
Alias (byte) plex_sprite_msb#28 = (byte) plex_sprite_msb#36 
Alias (byte) plex_free_next#26 = (byte) plex_free_next#33 
Alias (bool) framedone#14 = (bool) framedone#20 
Alias (byte*) PLEX_SCREEN_PTR#10 = (byte*) PLEX_SCREEN_PTR#3 (byte*) PLEX_SCREEN_PTR#18 (byte*) PLEX_SCREEN_PTR#11 (byte*) PLEX_SCREEN_PTR#4 
Alias (byte) plex_show_idx#17 = (byte) plex_show_idx#5 (byte) plex_show_idx#18 (byte) plex_show_idx#6 
Alias (byte) plex_sprite_idx#17 = (byte) plex_sprite_idx#5 (byte) plex_sprite_idx#18 (byte) plex_sprite_idx#6 
Alias (byte) plex_sprite_msb#18 = (byte) plex_sprite_msb#6 (byte) plex_sprite_msb#19 (byte) plex_sprite_msb#7 
Alias (byte) plex_free_next#15 = (byte) plex_free_next#5 (byte) plex_free_next#16 (byte) plex_free_next#6 
Alias (bool) framedone#0 = (bool) framedone#8 (bool) framedone#9 (bool) framedone#1 
Alias (byte*) PLEX_SCREEN_PTR#12 = (byte*) PLEX_SCREEN_PTR#5 
Alias (byte*) PLEX_SCREEN_PTR#27 = (byte*) PLEX_SCREEN_PTR#30 
Alias (byte*) PLEX_SCREEN_PTR#13 = (byte*) PLEX_SCREEN_PTR#20 (byte*) PLEX_SCREEN_PTR#24 (byte*) PLEX_SCREEN_PTR#6 
Alias (byte*) PLEX_SCREEN_PTR#26 = (byte*) PLEX_SCREEN_PTR#35 (byte*) PLEX_SCREEN_PTR#34 (byte*) PLEX_SCREEN_PTR#33 (byte*) PLEX_SCREEN_PTR#32 
Alias (bool) framedone#21 = (bool) framedone#27 (bool) framedone#28 (bool) framedone#26 (bool) framedone#25 (bool) framedone#24 (bool) framedone#23 
Alias (byte) plex_free_next#17 = (byte) plex_free_next#7 (byte) plex_free_next#18 (byte) plex_free_next#44 (byte) plex_free_next#35 (byte) plex_free_next#45 (byte) plex_free_next#36 (byte) plex_free_next#37 
Alias (byte) plex_sprite_idx#19 = (byte) plex_sprite_idx#7 (byte) plex_sprite_idx#51 (byte) plex_sprite_idx#47 (byte) plex_sprite_idx#39 (byte) plex_sprite_idx#48 (byte) plex_sprite_idx#40 (byte) plex_sprite_idx#41 
Alias (byte) plex_show_idx#19 = (byte) plex_show_idx#7 (byte) plex_show_idx#42 (byte) plex_show_idx#34 (byte) plex_show_idx#20 (byte) plex_show_idx#21 (byte) plex_show_idx#43 (byte) plex_show_idx#44 
Alias (byte) plex_sprite_msb#20 = (byte) plex_sprite_msb#8 (byte) plex_sprite_msb#51 (byte) plex_sprite_msb#47 (byte) plex_sprite_msb#38 (byte) plex_sprite_msb#48 (byte) plex_sprite_msb#39 (byte) plex_sprite_msb#40 
Alias (byte) plex_irq::plexFreeNextYpos1_return#0 = (byte) plex_irq::plexFreeNextYpos1_return#2 (byte) plex_irq::plexFreeNextYpos1_return#1 (byte) plex_irq::plexFreeNextYpos1_return#3 (byte~) plex_irq::$2 (byte) plex_irq::rasterY#1 (byte) plex_irq::rasterY#3 (byte) plex_irq::rasterY#2 
Alias (byte) plex_free_next#19 = (byte) plex_free_next#28 (byte) plex_free_next#8 
Alias (byte) plex_sprite_idx#20 = (byte) plex_sprite_idx#32 (byte) plex_sprite_idx#8 
Alias (byte) plex_show_idx#22 = (byte) plex_show_idx#35 (byte) plex_show_idx#8 
Alias (byte) plex_sprite_msb#21 = (byte) plex_sprite_msb#30 (byte) plex_sprite_msb#9 
Alias (bool) framedone#10 = (bool) framedone#15 (bool) framedone#4 
Alias (bool) framedone#12 = (bool) framedone#16 (bool) framedone#18 (bool) framedone#6 
Alias (byte) loop::sin_idx#6 = (byte) loop::sin_idx#8 
Alias (byte) plex_show_idx#10 = (byte) plex_show_idx#53 (byte) plex_show_idx#37 (byte) plex_show_idx#24 
Alias (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#53 (byte) plex_sprite_idx#34 (byte) plex_sprite_idx#22 
Alias (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#53 (byte) plex_sprite_msb#32 (byte) plex_sprite_msb#23 
Alias (byte) plex_free_next#10 = (byte) plex_free_next#49 (byte) plex_free_next#30 (byte) plex_free_next#21 
Alias (bool) framedone#11 = (bool) framedone#17 
Alias (byte) loop::sin_idx#2 = (byte) loop::sin_idx#7 (byte) loop::sin_idx#4 (byte) loop::y_idx#0 
Alias (byte) plex_show_idx#50 = (byte) plex_show_idx#54 (byte) plex_show_idx#52 
Alias (byte) plex_sprite_idx#49 = (byte) plex_sprite_idx#54 (byte) plex_sprite_idx#52 
Alias (byte) plex_sprite_msb#49 = (byte) plex_sprite_msb#54 (byte) plex_sprite_msb#52 
Alias (byte) plex_free_next#46 = (byte) plex_free_next#50 (byte) plex_free_next#48 
Alias (byte) loop::sin_idx#3 = (byte) loop::sin_idx#5 
Alias (byte) plex_show_idx#36 = (byte) plex_show_idx#46 
Alias (byte) plex_sprite_idx#33 = (byte) plex_sprite_idx#43 
Alias (byte) plex_sprite_msb#31 = (byte) plex_sprite_msb#42 
Alias (byte) plex_free_next#29 = (byte) plex_free_next#39 
Alias (byte) loop::sin_idx#1 = (byte) loop::sin_idx#9 
Alias (byte) plex_show_idx#23 = (byte) plex_show_idx#9 
Alias (byte) plex_sprite_idx#21 = (byte) plex_sprite_idx#9 
Alias (byte) plex_sprite_msb#10 = (byte) plex_sprite_msb#22 
Alias (byte) plex_free_next#20 = (byte) plex_free_next#9 
Alias (bool) framedone#19 = (bool) framedone#2 
Alias (byte*) PLEX_SCREEN_PTR#14 = (byte*) PLEX_SCREEN_PTR#7 
Alias (byte) plex_show_idx#11 = (byte) plex_show_idx#25 
Alias (byte) plex_sprite_idx#11 = (byte) plex_sprite_idx#23 
Alias (byte) plex_sprite_msb#12 = (byte) plex_sprite_msb#24 
Alias (byte) plex_free_next#11 = (byte) plex_free_next#22 
Alias (bool) framedone#13 = (bool) framedone#7 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 (byte) plex_free_next#47 (byte) plex_free_next#41 (byte) plex_free_next#42 
Alias candidate removed (volatile)(byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#3 (byte/word/dword~) plexShowSprite::$7 (byte) plex_sprite_idx#30 
Alias (byte) plex_sprite_idx#13 = (byte) plex_sprite_idx#15 
Alias (byte) plex_show_idx#13 = (byte) plex_show_idx#15 
Alias (byte) plex_sprite_msb#14 = (byte) plex_sprite_msb#16 
Alias (byte) plex_free_next#14 = (byte) plex_free_next#24 
Alias (byte) plex_show_idx#16 = (byte) plex_show_idx#3 
Alias (byte) plex_free_next#17 = (byte) plex_free_next#19 
Alias (byte) plex_sprite_idx#19 = (byte) plex_sprite_idx#20 
Alias (byte) plex_show_idx#19 = (byte) plex_show_idx#22 
Alias (byte) plex_sprite_msb#20 = (byte) plex_sprite_msb#21 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 (byte) plex_free_next#47 (byte) plex_free_next#41 (byte) plex_free_next#42 
Alias candidate removed (volatile)(byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#3 (byte/word/dword~) plexShowSprite::$7 (byte) plex_sprite_idx#30 
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#15
Self Phi Eliminated (byte) plexSort::nxt_y#1
Self Phi Eliminated (byte) plexSort::nxt_idx#1
Self Phi Eliminated (byte) plexSort::m#5
Self Phi Eliminated (byte) plex_show_idx#12
Self Phi Eliminated (byte) plex_sprite_idx#12
Self Phi Eliminated (byte) plex_sprite_msb#13
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#27
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#13
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#26
Self Phi Eliminated (bool) framedone#21
Self Phi Eliminated (bool) framedone#11
Self Phi Eliminated (byte) loop::sin_idx#2
Self Phi Eliminated (byte) plex_show_idx#50
Self Phi Eliminated (byte) plex_sprite_idx#49
Self Phi Eliminated (byte) plex_sprite_msb#49
Self Phi Eliminated (byte) plex_free_next#46
Self Phi Eliminated (byte) loop::sin_idx#3
Self Phi Eliminated (byte) plex_show_idx#36
Self Phi Eliminated (byte) plex_sprite_idx#33
Self Phi Eliminated (byte) plex_sprite_msb#31
Self Phi Eliminated (byte) plex_free_next#29
Successful SSA optimization Pass2SelfPhiElimination
Redundant Phi (byte*) plexInit::plexSetScreen1_screen#0 (byte*) plexInit::screen#0
Redundant Phi (byte*) PLEX_SCREEN_PTR#15 (byte*) PLEX_SCREEN_PTR#1
Redundant Phi (byte) plexSort::nxt_y#1 (byte) plexSort::nxt_y#0
Redundant Phi (byte) plexSort::nxt_idx#1 (byte) plexSort::nxt_idx#0
Redundant Phi (byte) plexSort::m#5 (byte) plexSort::m#2
Redundant Phi (byte) plex_show_idx#12 (byte) plex_show_idx#1
Redundant Phi (byte) plex_sprite_idx#12 (byte) plex_sprite_idx#1
Redundant Phi (byte) plex_sprite_msb#13 (byte) plex_sprite_msb#1
Redundant Phi (byte) plex_sprite_idx#13 (byte) plex_sprite_idx#25
Redundant Phi (byte) plex_show_idx#13 (byte) plex_show_idx#27
Redundant Phi (byte) plex_free_next#13 (byte) plex_free_next#27
Redundant Phi (byte*) PLEX_SCREEN_PTR#16 (byte*) PLEX_SCREEN_PTR#26
Redundant Phi (byte) plex_sprite_msb#14 (byte) plex_sprite_msb#29
Redundant Phi (byte) plex_free_next#47 (byte) plex_free_next#2
Redundant Phi (byte) plex_free_next#41 (byte) plex_free_next#47
Redundant Phi (byte) plex_free_next#42 (byte) plex_free_next#47
Redundant Phi (byte) plex_sprite_idx#29 (byte) plex_sprite_idx#3
Redundant Phi (byte) plex_sprite_idx#30 (byte) plex_sprite_idx#3
Redundant Phi (byte*) PLEX_SCREEN_PTR#17 (byte*) PLEX_SCREEN_PTR#0
Redundant Phi (byte) plex_show_idx#33 (byte) plex_show_idx#0
Redundant Phi (byte) plex_sprite_idx#31 (byte) plex_sprite_idx#0
Redundant Phi (byte) plex_sprite_msb#28 (byte) plex_sprite_msb#0
Redundant Phi (byte) plex_free_next#26 (byte) plex_free_next#31
Redundant Phi (bool) framedone#14 (bool) framedone#19
Redundant Phi (byte*) PLEX_SCREEN_PTR#10 (byte*) PLEX_SCREEN_PTR#13
Redundant Phi (byte) plex_show_idx#17 (byte) plex_show_idx#10
Redundant Phi (byte) plex_sprite_idx#17 (byte) plex_sprite_idx#10
Redundant Phi (byte) plex_sprite_msb#18 (byte) plex_sprite_msb#11
Redundant Phi (byte) plex_free_next#15 (byte) plex_free_next#10
Redundant Phi (bool) framedone#0 (bool) framedone#12
Redundant Phi (byte*) PLEX_SCREEN_PTR#19 (byte*) PLEX_SCREEN_PTR#17
Redundant Phi (byte*) PLEX_SCREEN_PTR#12 (byte*) PLEX_SCREEN_PTR#15
Redundant Phi (byte*) PLEX_SCREEN_PTR#27 (byte*) PLEX_SCREEN_PTR#12
Redundant Phi (byte*) PLEX_SCREEN_PTR#13 (byte*) PLEX_SCREEN_PTR#27
Redundant Phi (byte) plex_sprite_idx#38 (byte) plex_sprite_idx#0
Redundant Phi (byte) plex_show_idx#41 (byte) plex_show_idx#0
Redundant Phi (byte) plex_free_next#34 (byte) plex_free_next#31
Redundant Phi (byte) plex_sprite_msb#37 (byte) plex_sprite_msb#0
Redundant Phi (byte*) PLEX_SCREEN_PTR#31 (byte*) PLEX_SCREEN_PTR#0
Redundant Phi (bool) framedone#29 (bool) framedone#19
Redundant Phi (byte*) PLEX_SCREEN_PTR#26 (byte*) PLEX_SCREEN_PTR#31
Redundant Phi (bool) framedone#21 (bool) framedone#29
Redundant Phi (byte) plex_free_next#17 (byte) plex_free_next#14
Redundant Phi (byte) plex_sprite_idx#19 (byte) plex_sprite_idx#16
Redundant Phi (byte) plex_show_idx#19 (byte) plex_show_idx#16
Redundant Phi (byte) plex_sprite_msb#20 (byte) plex_sprite_msb#17
Redundant Phi (byte) plex_show_idx#45 (byte) plex_show_idx#33
Redundant Phi (byte) plex_sprite_idx#42 (byte) plex_sprite_idx#31
Redundant Phi (byte) plex_sprite_msb#41 (byte) plex_sprite_msb#28
Redundant Phi (byte) plex_free_next#38 (byte) plex_free_next#26
Redundant Phi (bool) framedone#22 (bool) framedone#14
Redundant Phi (bool) framedone#11 (bool) framedone#12
Redundant Phi (byte) loop::sin_idx#2 (byte) loop::sin_idx#6
Redundant Phi (byte) plex_show_idx#50 (byte) plex_show_idx#10
Redundant Phi (byte) plex_sprite_idx#49 (byte) plex_sprite_idx#10
Redundant Phi (byte) plex_sprite_msb#49 (byte) plex_sprite_msb#11
Redundant Phi (byte) plex_free_next#46 (byte) plex_free_next#10
Redundant Phi (byte) loop::sin_idx#3 (byte) loop::sin_idx#2
Redundant Phi (byte) plex_show_idx#36 (byte) plex_show_idx#50
Redundant Phi (byte) plex_sprite_idx#33 (byte) plex_sprite_idx#49
Redundant Phi (byte) plex_sprite_msb#31 (byte) plex_sprite_msb#49
Redundant Phi (byte) plex_free_next#29 (byte) plex_free_next#46
Redundant Phi (byte) plex_show_idx#23 (byte) plex_show_idx#12
Redundant Phi (byte) plex_sprite_idx#21 (byte) plex_sprite_idx#12
Redundant Phi (byte) plex_sprite_msb#10 (byte) plex_sprite_msb#13
Redundant Phi (byte) plex_free_next#20 (byte) plex_free_next#0
Redundant Phi (byte*) PLEX_SCREEN_PTR#14 (byte*) PLEX_SCREEN_PTR#10
Redundant Phi (byte) plex_show_idx#11 (byte) plex_show_idx#17
Redundant Phi (byte) plex_sprite_idx#11 (byte) plex_sprite_idx#17
Redundant Phi (byte) plex_sprite_msb#12 (byte) plex_sprite_msb#18
Redundant Phi (byte) plex_free_next#11 (byte) plex_free_next#15
Redundant Phi (bool) framedone#13 (bool) framedone#0
Successful SSA optimization Pass2RedundantPhiElimination
Redundant Phi (byte) plexSort::m#3 (byte) plexSort::m#2
Redundant Phi (byte) plex_free_next#14 (byte) plex_free_next#2
Redundant Phi (byte) plex_sprite_idx#16 (byte) plex_sprite_idx#3
Successful SSA optimization Pass2RedundantPhiElimination
Simple Condition (bool~) plexInit::$2 [101] if((byte) plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1
Simple Condition (bool~) plexSort::$4 [113] if((byte) plexSort::nxt_y#0>=*((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2
Simple Condition (bool~) plexSort::$9 [117] if((byte) plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1
Simple Condition (bool) plexSort::plexFreePrepare1_$0#0 [140] if((byte) plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1
Simple Condition (bool~) plexShowSprite::$5 [169] if((byte~) plexShowSprite::$4!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@1
Simple Condition (bool~) plexShowSprite::$9 [183] if((byte) plex_sprite_msb#27!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@3
Simple Condition (bool~) init::$8 [242] if((byte) init::sx#1!=rangelast(0,init::$4)) goto init::@1
Simple Condition (bool~) init::$9 [250] if((byte) init::ss#1!=rangelast(0,7)) goto init::@3
Simple Condition (bool~) plex_irq::$0 [289] if((byte) plex_show_idx#16<(byte) PLEX_COUNT#0) goto plex_irq::@1
Simple Condition (bool~) loop::$2 [322] if((byte) loop::sy#1!=rangelast(0,loop::$1)) goto loop::@10
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [126] (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
Successful SSA optimization Pass2ConditionalAndOrRewriting
Rewriting && if()-condition to two if()s [284] (bool~) plex_irq::$6 ← (bool~) plex_irq::$3 && (bool~) plex_irq::$5
Successful SSA optimization Pass2ConditionalAndOrRewriting
Rewriting ! if()-condition to reversed if() [309] (bool~) loop::$0 ← ! (bool) framedone#12
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant (const byte*) PROCPORT_DDR#0 = ((byte*))0
Constant (const byte) PROCPORT_DDR_MEMORY_MASK#0 = 7
Constant (const byte*) PROCPORT#0 = ((byte*))1
Constant (const byte) PROCPORT_RAM_ALL#0 = $30
Constant (const byte) PROCPORT_RAM_IO#0 = $35
Constant (const byte) PROCPORT_RAM_CHARROM#0 = $31
Constant (const byte) PROCPORT_KERNEL_IO#0 = $36
Constant (const byte) PROCPORT_BASIC_KERNEL_IO#0 = $37
Constant (const byte*) CHARGEN#0 = ((byte*))$d000
Constant (const word) SPRITE_PTRS#0 = $3f8
Constant (const byte*) SPRITES_XPOS#0 = ((byte*))$d000
Constant (const byte*) SPRITES_YPOS#0 = ((byte*))$d001
Constant (const byte*) SPRITES_XMSB#0 = ((byte*))$d010
Constant (const byte*) RASTER#0 = ((byte*))$d012
Constant (const byte*) SPRITES_ENABLE#0 = ((byte*))$d015
Constant (const byte*) SPRITES_EXPAND_Y#0 = ((byte*))$d017
Constant (const byte*) SPRITES_PRIORITY#0 = ((byte*))$d01b
Constant (const byte*) SPRITES_MC#0 = ((byte*))$d01c
Constant (const byte*) SPRITES_EXPAND_X#0 = ((byte*))$d01d
Constant (const byte*) BORDERCOL#0 = ((byte*))$d020
Constant (const byte*) BGCOL#0 = ((byte*))$d021
Constant (const byte*) BGCOL1#0 = ((byte*))$d021
Constant (const byte*) BGCOL2#0 = ((byte*))$d022
Constant (const byte*) BGCOL3#0 = ((byte*))$d023
Constant (const byte*) BGCOL4#0 = ((byte*))$d024
Constant (const byte*) SPRITES_MC1#0 = ((byte*))$d025
Constant (const byte*) SPRITES_MC2#0 = ((byte*))$d026
Constant (const byte*) SPRITES_COLS#0 = ((byte*))$d027
Constant (const byte*) VIC_CONTROL#0 = ((byte*))$d011
Constant (const byte*) D011#0 = ((byte*))$d011
Constant (const byte) VIC_RST8#0 = $80
Constant (const byte) VIC_ECM#0 = $40
Constant (const byte) VIC_BMM#0 = $20
Constant (const byte) VIC_DEN#0 = $10
Constant (const byte) VIC_RSEL#0 = 8
Constant (const byte*) VIC_CONTROL2#0 = ((byte*))$d016
Constant (const byte*) D016#0 = ((byte*))$d016
Constant (const byte) VIC_MCM#0 = $10
Constant (const byte) VIC_CSEL#0 = 8
Constant (const byte*) D018#0 = ((byte*))$d018
Constant (const byte*) VIC_MEMORY#0 = ((byte*))$d018
Constant (const byte*) LIGHTPEN_X#0 = ((byte*))$d013
Constant (const byte*) LIGHTPEN_Y#0 = ((byte*))$d014
Constant (const byte*) IRQ_STATUS#0 = ((byte*))$d019
Constant (const byte*) IRQ_ENABLE#0 = ((byte*))$d01a
Constant (const byte) IRQ_RASTER#0 = 1
Constant (const byte) IRQ_COLLISION_BG#0 = 2
Constant (const byte) IRQ_COLLISION_SPRITE#0 = 4
Constant (const byte) IRQ_LIGHTPEN#0 = 8
Constant (const byte*) COLS#0 = ((byte*))$d800
Constant (const byte*) CIA1_PORT_A#0 = ((byte*))$dc00
Constant (const byte*) CIA1_PORT_B#0 = ((byte*))$dc01
Constant (const byte*) CIA1_PORT_A_DDR#0 = ((byte*))$dc02
Constant (const byte*) CIA1_PORT_B_DDR#0 = ((byte*))$dc03
Constant (const byte*) CIA1_INTERRUPT#0 = ((byte*))$dc0d
Constant (const byte) CIA_INTERRUPT_CLEAR#0 = $7f
Constant (const byte*) CIA2_PORT_A#0 = ((byte*))$dd00
Constant (const byte*) CIA2_PORT_B#0 = ((byte*))$dd01
Constant (const byte*) CIA2_PORT_A_DDR#0 = ((byte*))$dd02
Constant (const byte*) CIA2_PORT_B_DDR#0 = ((byte*))$dd03
Constant (const byte*) CIA2_INTERRUPT#0 = ((byte*))$dd0d
Constant (const void()**) KERNEL_IRQ#0 = ((void()**))$314
Constant (const void()**) HARDWARE_IRQ#0 = ((void()**))$fffe
Constant (const byte) BLACK#0 = 0
Constant (const byte) WHITE#0 = 1
Constant (const byte) RED#0 = 2
Constant (const byte) CYAN#0 = 3
Constant (const byte) PURPLE#0 = 4
Constant (const byte) GREEN#0 = 5
Constant (const byte) BLUE#0 = 6
Constant (const byte) YELLOW#0 = 7
Constant (const byte) ORANGE#0 = 8
Constant (const byte) BROWN#0 = 9
Constant (const byte) PINK#0 = $a
Constant (const byte) DARK_GREY#0 = $b
Constant (const byte) GREY#0 = $c
Constant (const byte) LIGHT_GREEN#0 = $d
Constant (const byte) LIGHT_BLUE#0 = $e
Constant (const byte) LIGHT_GREY#0 = $f
Constant (const byte) PLEX_COUNT#0 = $20
Constant (const word/signed word/dword/signed dword) $0 = $400+$3f8
Constant (const byte) plexInit::i#0 = 0
Constant (const byte) plexSort::m#0 = 0
Constant (const byte) plexSort::plexFreePrepare1_s#0 = 0
Constant (const byte[8]) PLEX_FREE_YPOS#0 = { fill( 8, 0) }
Constant (const byte*) SCREEN#0 = ((byte*))$400
Constant (const byte*) SPRITE#0 = ((byte*))$2000
Constant (const byte*) YSIN#0 = ((byte*))$2100
Constant (const word) init::xp#0 = $20
Constant (const byte) init::sx#0 = 0
Constant (const byte) init::ss#0 = 0
Constant (const void()*) init::$3 = &plex_irq
Constant (const byte) plex_irq::rasterY#0 = 0
Constant (const byte) loop::sin_idx#0 = 0
Constant (const byte) loop::sy#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const word[PLEX_COUNT#0]) PLEX_XPOS#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_YPOS#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_PTR#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte*) PLEX_SCREEN_PTR#0 = ((byte*))$0
Constant (const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte/signed word/word/dword/signed dword) plexInit::$1 = PLEX_COUNT#0-1
Constant (const byte/signed word/word/dword/signed dword) plexSort::$1 = PLEX_COUNT#0-2
Constant (const byte) init::$0 = VIC_DEN#0|VIC_RSEL#0
Constant (const byte*) plexInit::screen#0 = SCREEN#0
Constant (const byte/signed word/word/dword/signed dword) init::$4 = PLEX_COUNT#0-1
Constant (const byte*) init::$5 = SPRITE#0/$40
Constant (const byte/signed word/word/dword/signed dword) loop::$1 = PLEX_COUNT#0-1
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) PLEX_SCREEN_PTR#1 = plexInit::screen#0+$3f8
Constant (const byte/word/dword) init::$1 = init::$0|3
Constant (const byte) init::$6 = ((byte))init::$5
Successful SSA optimization Pass2ConstantIdentification
Consolidated array index constant in assignment *(PLEX_SORTED_IDX#0+1 + plexSort::$2)
Consolidated array index constant in assignment *(PLEX_SORTED_IDX#0+1 + plexSort::$5)
Successful SSA optimization Pass2ConstantAdditionElimination
if() condition always true - replacing block destination [104] if(true) goto loop::@2
Successful SSA optimization Pass2ConstantIfs
Inferred type updated to byte in [9] (byte/signed word/word/dword/signed dword~) plexSort::$2 ← (byte) plexSort::m#2
Inferred type updated to byte in [16] (byte/signed word/word/dword/signed dword~) plexSort::$5 ← (byte) plexSort::s#3
Successful SSA optimization PassNEliminateUnusedVars
Successful SSA optimization PassNEliminateUnusedVars
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block loop::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Resolved ranged next value plexInit::i#1 ← ++ plexInit::i#2 to ++
Resolved ranged comparison value if(plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1 to (const byte/signed word/word/dword/signed dword) plexInit::$1+(byte/signed byte/word/signed word/dword/signed dword) 1
Resolved ranged next value plexSort::m#1 ← ++ plexSort::m#2 to ++
Resolved ranged comparison value if(plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1 to (const byte/signed word/word/dword/signed dword) plexSort::$1+(byte/signed byte/word/signed word/dword/signed dword) 1
Resolved ranged next value plexSort::plexFreePrepare1_s#1 ← ++ plexSort::plexFreePrepare1_s#2 to ++
Resolved ranged comparison value if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1 to (byte/signed byte/word/signed word/dword/signed dword) 8
Resolved ranged next value init::sx#1 ← ++ init::sx#2 to ++
Resolved ranged comparison value if(init::sx#1!=rangelast(0,init::$4)) goto init::@1 to (const byte/signed word/word/dword/signed dword) init::$4+(byte/signed byte/word/signed word/dword/signed dword) 1
Resolved ranged next value init::ss#1 ← ++ init::ss#2 to ++
Resolved ranged comparison value if(init::ss#1!=rangelast(0,7)) goto init::@3 to (byte/signed byte/word/signed word/dword/signed dword) 8
Resolved ranged next value loop::sy#1 ← ++ loop::sy#2 to ++
Resolved ranged comparison value if(loop::sy#1!=rangelast(0,loop::$1)) goto loop::@10 to (const byte/signed word/word/dword/signed dword) loop::$1+(byte/signed byte/word/signed word/dword/signed dword) 1
Culled Empty Block (label) plexInit::@3
Culled Empty Block (label) plexSort::@5
Culled Empty Block (label) plexShowSprite::@3
Culled Empty Block (label) main::@2
Culled Empty Block (label) init::@5
Culled Empty Block (label) plex_irq::@8
Culled Empty Block (label) plex_irq::plexFreeNextYpos1_@return
Culled Empty Block (label) loop::@2
Culled Empty Block (label) loop::@5
Culled Empty Block (label) @17
Successful SSA optimization Pass2CullEmptyBlocks
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte/word/dword~) plexShowSprite::$7 
Alias (byte) plexSort::m#2 = (byte~) plexSort::$2 
Alias (byte) plexSort::s#3 = (byte~) plexSort::$5 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte/word/dword~) plexShowSprite::$7 
Simple Condition (bool~) plexSort::$6 [21] if((byte) plexSort::s#1!=(byte/word/signed word/dword/signed dword) $ff) goto plexSort::@8
Simple Condition (bool~) plex_irq::$3 [95] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@9
Simple Condition (bool~) plexSort::$7 [119] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3
Simple Condition (bool~) plex_irq::$5 [120] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte/signed word/word/dword/signed dword~) plex_irq::$4) goto plex_irq::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Alias candidate removed (volatile)(byte) plex_free_next#2 = (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 
Alias candidate removed (volatile)(byte) plex_sprite_idx#3 = (byte/word/dword~) plexShowSprite::$7 
Inlining constant with var siblings (const byte) plexInit::i#0
Inlining constant with var siblings (const byte) plexSort::m#0
Inlining constant with var siblings (const byte) plexSort::plexFreePrepare1_s#0
Inlining constant with var siblings (const word) init::xp#0
Inlining constant with var siblings (const byte) init::sx#0
Inlining constant with var siblings (const byte) init::ss#0
Inlining constant with var siblings (const byte) loop::sin_idx#0
Inlining constant with var siblings (const byte) loop::sy#0
Constant inlined init::xp#0 = (byte/signed byte/word/signed word/dword/signed dword) $20
Constant inlined plexInit::$1 = (const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1
Constant inlined plexSort::$1 = (const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 2
Constant inlined plexSort::plexFreePrepare1_s#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined init::ss#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined plexInit::i#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined plexSort::m#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined init::$3 = &interrupt(KERNEL_MIN)(void()) plex_irq()
Constant inlined $0 = (word/signed word/dword/signed dword) $400+(word/signed word/dword/signed dword) $3f8
Constant inlined init::$1 = (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte/signed byte/word/signed word/dword/signed dword) 3
Constant inlined loop::sin_idx#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined init::$0 = (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0
Constant inlined init::$6 = ((byte))(const byte*) SPRITE#0/(byte/signed byte/word/signed word/dword/signed dword) $40
Constant inlined init::$5 = (const byte*) SPRITE#0/(byte/signed byte/word/signed word/dword/signed dword) $40
Constant inlined init::$4 = (const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1
Constant inlined loop::$1 = (const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1
Constant inlined loop::sy#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined init::sx#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting loop::@16(between loop::@10 and loop::@10)
Added new block during phi lifting plexSort::@9(between plexSort::@2 and plexSort::@1)
Added new block during phi lifting plexSort::@10(between plexSort::@8 and plexSort::@3)
Added new block during phi lifting plexSort::@11(between plexSort::@1 and plexSort::@3)
Added new block during phi lifting plexSort::@12(between plexSort::plexFreePrepare1_@1 and plexSort::plexFreePrepare1_@1)
Added new block during phi lifting init::@6(between init::@1 and init::@1)
Added new block during phi lifting init::@7(between init::@3 and init::@3)
Added new block during phi lifting plexInit::@4(between plexInit::@1 and plexInit::@1)
Added new block during phi lifting plex_irq::@10(between plex_irq::@9 and plex_irq::@3)
Added new block during phi lifting plexShowSprite::@8(between plexShowSprite::@2 and plexShowSprite::@return)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @16
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1
CALL GRAPH
Calls in [] to main:9 
Calls in [main] to init:12 loop:14 
Calls in [loop] to plexSort:28 
Calls in [init] to plexInit:66 
Calls in [plex_irq] to plexShowSprite:103 

Created 16 initial phi equivalence classes
Coalesced [16] framedone#30 ← framedone#19
Not coalescing [20] loop::y_idx#4 ← loop::sin_idx#6
Coalesced [33] framedone#31 ← framedone#5
Coalesced [34] loop::sin_idx#10 ← loop::sin_idx#1
Coalesced [35] loop::y_idx#3 ← loop::y_idx#1
Coalesced [36] loop::sy#3 ← loop::sy#1
Not coalescing [42] plexSort::s#6 ← plexSort::m#2
Coalesced [61] plexSort::plexFreePrepare1_s#3 ← plexSort::plexFreePrepare1_s#1
Coalesced [62] plexSort::m#7 ← plexSort::m#1
Coalesced [64] plexSort::s#5 ← plexSort::s#1
Coalesced [86] init::ss#3 ← init::ss#1
Coalesced [87] init::sx#3 ← init::sx#1
Coalesced [88] init::xp#3 ← init::xp#1
Coalesced [96] plexInit::i#3 ← plexInit::i#1
Coalesced [98] plex_sprite_idx#55 ← plex_sprite_idx#0
Coalesced [99] plex_show_idx#55 ← plex_show_idx#0
Coalesced [100] plex_free_next#51 ← plex_free_next#31
Coalesced [101] plex_sprite_msb#55 ← plex_sprite_msb#0
Coalesced [114] plex_sprite_idx#56 ← plex_sprite_idx#3
Coalesced [115] plex_show_idx#56 ← plex_show_idx#16
Coalesced [116] plex_free_next#52 ← plex_free_next#2
Coalesced [117] plex_sprite_msb#56 ← plex_sprite_msb#17
Coalesced [125] plex_free_next#2 ← plexShowSprite::plexFreeAdd1_$2#0
Coalesced [136] plex_sprite_idx#3 ← plexShowSprite::$7
Coalesced [141] plex_sprite_msb#58 ← plex_sprite_msb#4
Coalesced [144] plex_sprite_msb#57 ← plex_sprite_msb#27
Coalesced down to 15 phi equivalence classes
Culled Empty Block (label) loop::@16
Culled Empty Block (label) plexSort::@12
Culled Empty Block (label) plexSort::@9
Culled Empty Block (label) plexSort::@10
Culled Empty Block (label) init::@7
Culled Empty Block (label) init::@6
Culled Empty Block (label) plexInit::@4
Culled Empty Block (label) plex_irq::@10
Culled Empty Block (label) plexShowSprite::@8
Renumbering block @4 to @1
Renumbering block @9 to @2
Renumbering block @12 to @3
Renumbering block @14 to @4
Renumbering block @16 to @5
Renumbering block plexSort::@6 to plexSort::@5
Renumbering block plexSort::@8 to plexSort::@6
Renumbering block plexSort::@11 to plexSort::@7
Renumbering block plexShowSprite::@4 to plexShowSprite::@3
Renumbering block plexShowSprite::@6 to plexShowSprite::@4
Renumbering block plexShowSprite::@7 to plexShowSprite::@5
Renumbering block plex_irq::@7 to plex_irq::@6
Renumbering block plex_irq::@9 to plex_irq::@7
Renumbering block loop::@4 to loop::@2
Renumbering block loop::@6 to loop::@3
Renumbering block loop::@10 to loop::@4
Renumbering block loop::@11 to loop::@5
Renumbering block loop::@15 to loop::@6
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @5
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of loop
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] (byte) plex_show_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  [2] (byte) plex_sprite_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  [3] (byte) plex_sprite_msb#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  to:@2
@2: scope:[]  from @1
  [4] (byte) plex_free_next#31 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:@3
@3: scope:[]  from @2
  kickasm(location (const byte*) YSIN#0) {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
  kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  to:@4
@4: scope:[]  from @3
  [7] (bool) framedone#19 ← true
  to:@5
@5: scope:[]  from @4
  [8] phi()
  [9] call main 
  to:@end
@end: scope:[]  from @5
  [10] phi()
main: scope:[main]  from @5
  asm { sei  }
  [12] call init 
  to:main::@1
main::@1: scope:[main]  from main
  [13] phi()
  [14] call loop 
  to:main::@return
main::@return: scope:[main]  from main::@1
  [15] return 
  to:@return
loop: scope:[loop]  from main::@1
  [16] phi()
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@6
  [17] (byte) loop::sin_idx#6 ← phi( loop/(byte/signed byte/word/signed word/dword/signed dword) 0 loop::@6/(byte) loop::sin_idx#1 )
  [17] (bool) framedone#12 ← phi( loop/(bool) framedone#19 loop::@6/(bool) framedone#5 )
  to:loop::@2
loop::@2: scope:[loop]  from loop::@1 loop::@2
  [18] if((bool) framedone#12) goto loop::@3
  to:loop::@2
loop::@3: scope:[loop]  from loop::@2
  [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0
  [20] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6
  to:loop::@4
loop::@4: scope:[loop]  from loop::@3 loop::@4
  [21] (byte) loop::sy#2 ← phi( loop::@4/(byte) loop::sy#1 loop::@3/(byte/signed byte/word/signed word/dword/signed dword) 0 )
  [21] (byte) loop::y_idx#2 ← phi( loop::@4/(byte) loop::y_idx#1 loop::@3/(byte~) loop::y_idx#4 )
  [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2)
  [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte/signed byte/word/signed word/dword/signed dword) 8
  [24] (byte) loop::sy#1 ← ++ (byte) loop::sy#2
  [25] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  [26] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte/signed byte/word/signed word/dword/signed dword) 1
  [27] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  [28] call plexSort 
  to:loop::@6
loop::@6: scope:[loop]  from loop::@5
  [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0
  [30] (bool) framedone#5 ← false
  [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte/signed byte/word/signed word/dword/signed dword) $7f
  [32] *((const byte*) RASTER#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:loop::@1
plexSort: scope:[plexSort]  from loop::@5
  [33] phi()
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  [34] (byte) plexSort::m#2 ← phi( plexSort/(byte/signed byte/word/signed word/dword/signed dword) 0 plexSort::@2/(byte) plexSort::m#1 )
  [35] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::m#2)
  [36] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0)
  [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2
  to:plexSort::@7
plexSort::@7: scope:[plexSort]  from plexSort::@1
  [38] (byte~) plexSort::s#6 ← (byte) plexSort::m#2
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@6 plexSort::@7
  [39] (byte) plexSort::s#3 ← phi( plexSort::@6/(byte) plexSort::s#1 plexSort::@7/(byte~) plexSort::s#6 )
  [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3)
  [41] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  [42] if((byte) plexSort::s#1!=(byte/word/signed word/dword/signed dword) $ff) goto plexSort::@6
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3 plexSort::@6
  [43] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1
  [44] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0
  to:plexSort::@2
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  [45] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2
  [46] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 2+(byte/signed byte/word/signed word/dword/signed dword) 1) goto plexSort::@1
  to:plexSort::@5
plexSort::@5: scope:[plexSort]  from plexSort::@2
  [47] (byte) plex_show_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  [48] (byte) plex_sprite_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  [49] (byte) plex_sprite_msb#1 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@5
  [50] phi()
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  [51] (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte/signed byte/word/signed word/dword/signed dword) 0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  [52] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  [53] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2
  [54] if((byte) plexSort::plexFreePrepare1_s#1!=(byte/signed byte/word/signed word/dword/signed dword) 8) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  [55] (byte) plex_free_next#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  [56] return 
  to:@return
plexSort::@6: scope:[plexSort]  from plexSort::@3
  [57] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3
  to:plexSort::@4
init: scope:[init]  from main
  [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte/signed byte/word/signed word/dword/signed dword) 3
  [59] call plexInit 
  to:init::@1
init::@1: scope:[init]  from init init::@1
  [60] (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init/(byte/signed byte/word/signed word/dword/signed dword) $20 )
  [60] (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init/(byte/signed byte/word/signed word/dword/signed dword) 0 )
  [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← ((byte))(const byte*) SPRITE#0/(byte/signed byte/word/signed word/dword/signed dword) $40
  [62] (byte~) init::$7 ← (byte) init::sx#2 << (byte/signed byte/word/signed word/dword/signed dword) 1
  [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$7) ← (word) init::xp#2
  [64] (word) init::xp#1 ← (word) init::xp#2 + (byte/signed byte/word/signed word/dword/signed dword) 9
  [65] (byte) init::sx#1 ← ++ (byte) init::sx#2
  [66] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  [67] *((const byte*) SPRITES_ENABLE#0) ← (byte/word/signed word/dword/signed dword) $ff
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  [68] (byte) init::ss#2 ← phi( init::@2/(byte/signed byte/word/signed word/dword/signed dword) 0 init::@3/(byte) init::ss#1 )
  [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0
  [70] (byte) init::ss#1 ← ++ (byte) init::ss#2
  [71] if((byte) init::ss#1!=(byte/signed byte/word/signed word/dword/signed dword) 8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  asm { sei  }
  [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0
  [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0
  [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0
  [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq()
  asm { cli  }
  to:init::@return
init::@return: scope:[init]  from init::@4
  [78] return 
  to:@return
plexInit: scope:[plexInit]  from init
  [79] phi()
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  [80] phi()
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::plexSetScreen1
  [81] (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::plexSetScreen1/(byte/signed byte/word/signed word/dword/signed dword) 0 )
  [82] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  [83] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2
  [84] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  [85] return 
  to:@return
plex_irq: scope:[plex_irq]  from
  [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0
  to:plex_irq::@3
plex_irq::@3: scope:[plex_irq]  from plex_irq plex_irq::@7
  [87] (byte) plex_sprite_msb#29 ← phi( plex_irq/(byte) plex_sprite_msb#0 plex_irq::@7/(byte) plex_sprite_msb#17 )
  [87] (byte) plex_free_next#27 ← phi( plex_irq/(byte) plex_free_next#31 plex_irq::@7/(byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 )
  [87] (byte) plex_show_idx#27 ← phi( plex_irq/(byte) plex_show_idx#0 plex_irq::@7/(byte) plex_show_idx#16 )
  [87] (byte) plex_sprite_idx#25 ← phi( plex_irq/(byte) plex_sprite_idx#0 plex_irq::@7/(byte/word/dword~) plexShowSprite::$7 )
  [88] call plexShowSprite 
  to:plex_irq::plexFreeNextYpos1
plex_irq::plexFreeNextYpos1: scope:[plex_irq]  from plex_irq::@3
  [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0)
  to:plex_irq::@6
plex_irq::@6: scope:[plex_irq]  from plex_irq::plexFreeNextYpos1
  [90] (byte/signed word/word/dword/signed dword~) plex_irq::$4 ← *((const byte*) RASTER#0) + (byte/signed byte/word/signed word/dword/signed dword) 2
  [91] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@7
  to:plex_irq::@4
plex_irq::@4: scope:[plex_irq]  from plex_irq::@6 plex_irq::@7
  [92] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0
  [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1
  to:plex_irq::@5
plex_irq::@5: scope:[plex_irq]  from plex_irq::@4
  [94] (bool) framedone#3 ← true
  to:plex_irq::@2
plex_irq::@2: scope:[plex_irq]  from plex_irq::@1 plex_irq::@5
  [95] *((const byte*) BORDERCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:plex_irq::@return
plex_irq::@return: scope:[plex_irq]  from plex_irq::@2
  [96] return 
  to:@return
plex_irq::@1: scope:[plex_irq]  from plex_irq::@4
  [97] *((const byte*) RASTER#0) ← (byte) plex_irq::plexFreeNextYpos1_return#0
  to:plex_irq::@2
plex_irq::@7: scope:[plex_irq]  from plex_irq::@6
  [98] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte/signed word/word/dword/signed dword~) plex_irq::$4) goto plex_irq::@3
  to:plex_irq::@4
plexShowSprite: scope:[plexShowSprite]  from plex_irq::@3
  [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte/signed byte/word/signed word/dword/signed dword) 1
  [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27))
  [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  [102] (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte/signed byte/word/signed word/dword/signed dword) $15
  [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0
  [104] (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#27 + (byte/signed byte/word/signed word/dword/signed dword) 1
  [105] (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 & (byte/signed byte/word/signed word/dword/signed dword) 7
  to:plexShowSprite::@5
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27))
  [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) << (byte/signed byte/word/signed word/dword/signed dword) 1
  [108] (byte~) plexShowSprite::$3 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0)
  [109] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$3
  [110] (byte~) plexShowSprite::$4 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0)
  [111] if((byte~) plexShowSprite::$4!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@5
  [112] (byte/word/dword~) plexShowSprite::$10 ← (byte/word/signed word/dword/signed dword) $ff ^ (byte) plex_sprite_msb#29
  [113] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte/word/dword~) plexShowSprite::$10
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  [114] (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 ← (byte) plex_sprite_idx#25 + (byte/signed byte/word/signed word/dword/signed dword) 1
  [115] (byte/word/dword~) plexShowSprite::$7 ← (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 & (byte/signed byte/word/signed word/dword/signed dword) 7
  [116] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27
  [117] (byte) plex_sprite_msb#27 ← (byte) plex_sprite_msb#29 << (byte/signed byte/word/signed word/dword/signed dword) 1
  [118] if((byte) plex_sprite_msb#27!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@return
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@2
  [119] (byte) plex_sprite_msb#4 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@4
  [120] (byte) plex_sprite_msb#17 ← phi( plexShowSprite::@2/(byte) plex_sprite_msb#27 plexShowSprite::@4/(byte) plex_sprite_msb#4 )
  [121] return 
  to:@return
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@5
  [122] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#29
  to:plexShowSprite::@2


VARIABLE REGISTER WEIGHTS
(byte*) BGCOL
(byte*) BGCOL1
(byte*) BGCOL2
(byte*) BGCOL3
(byte*) BGCOL4
(byte) BLACK
(byte) BLUE
(byte*) BORDERCOL
(byte) BROWN
(byte*) CHARGEN
(byte*) CIA1_INTERRUPT
(byte*) CIA1_PORT_A
(byte*) CIA1_PORT_A_DDR
(byte*) CIA1_PORT_B
(byte*) CIA1_PORT_B_DDR
(byte*) CIA2_INTERRUPT
(byte*) CIA2_PORT_A
(byte*) CIA2_PORT_A_DDR
(byte*) CIA2_PORT_B
(byte*) CIA2_PORT_B_DDR
(byte) CIA_INTERRUPT_CLEAR
(byte*) COLS
(byte) CYAN
(byte*) D011
(byte*) D016
(byte*) D018
(byte) DARK_GREY
(byte) GREEN
(byte) GREY
(void()**) HARDWARE_IRQ
(byte) IRQ_COLLISION_BG
(byte) IRQ_COLLISION_SPRITE
(byte*) IRQ_ENABLE
(byte) IRQ_LIGHTPEN
(byte) IRQ_RASTER
(byte*) IRQ_STATUS
(void()**) KERNEL_IRQ
(byte*) LIGHTPEN_X
(byte*) LIGHTPEN_Y
(byte) LIGHT_BLUE
(byte) LIGHT_GREEN
(byte) LIGHT_GREY
(byte) ORANGE
(byte) PINK
(byte) PLEX_COUNT
(byte[8]) PLEX_FREE_YPOS
(byte[PLEX_COUNT#0]) PLEX_PTR
(byte*) PLEX_SCREEN_PTR
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(word[PLEX_COUNT#0]) PLEX_XPOS
(byte[PLEX_COUNT#0]) PLEX_YPOS
(byte*) PROCPORT
(byte) PROCPORT_BASIC_KERNEL_IO
(byte*) PROCPORT_DDR
(byte) PROCPORT_DDR_MEMORY_MASK
(byte) PROCPORT_KERNEL_IO
(byte) PROCPORT_RAM_ALL
(byte) PROCPORT_RAM_CHARROM
(byte) PROCPORT_RAM_IO
(byte) PURPLE
(byte*) RASTER
(byte) RED
(byte*) SCREEN
(byte*) SPRITE
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_MC
(byte*) SPRITES_MC1
(byte*) SPRITES_MC2
(byte*) SPRITES_PRIORITY
(byte*) SPRITES_XMSB
(byte*) SPRITES_XPOS
(byte*) SPRITES_YPOS
(word) SPRITE_PTRS
(byte) VIC_BMM
(byte*) VIC_CONTROL
(byte*) VIC_CONTROL2
(byte) VIC_CSEL
(byte) VIC_DEN
(byte) VIC_ECM
(byte) VIC_MCM
(byte*) VIC_MEMORY
(byte) VIC_RSEL
(byte) VIC_RST8
(byte) WHITE
(byte) YELLOW
(byte*) YSIN
(bool) framedone
(bool) framedone#12 57.0
(bool) framedone#19 0.6666666666666666
(bool) framedone#3 20.0
(bool) framedone#5 7.333333333333333
(void()) init()
(byte~) init::$7 22.0
(byte) init::ss
(byte) init::ss#1 16.5
(byte) init::ss#2 16.5
(byte) init::sx
(byte) init::sx#1 16.5
(byte) init::sx#2 8.8
(word) init::xp
(word) init::xp#1 7.333333333333333
(word) init::xp#2 8.25
(void()) loop()
(byte) loop::sin_idx
(byte) loop::sin_idx#1 3.142857142857143
(byte) loop::sin_idx#6 3.666666666666667
(byte) loop::sy
(byte) loop::sy#1 151.5
(byte) loop::sy#2 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 67.33333333333333
(byte) loop::y_idx#2 157.0
(byte~) loop::y_idx#4 22.0
(void()) main()
(void()) plexInit((byte*) plexInit::screen)
(byte) plexInit::i
(byte) plexInit::i#1 16.5
(byte) plexInit::i#2 22.0
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte/word/dword~) plexShowSprite::$10 4.0
(byte~) plexShowSprite::$3 4.0
(byte~) plexShowSprite::$4 4.0
(byte/signed word/word/dword/signed dword~) plexShowSprite::$6 4.0
(byte/word/dword~) plexShowSprite::$7 1.0833333333333333
(byte/signed word/word/dword/signed dword~) plexShowSprite::plexFreeAdd1_$0
(byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 4.0
(byte/signed word/word/dword/signed dword~) plexShowSprite::plexFreeAdd1_$1
(byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 4.0
(byte/word/dword~) plexShowSprite::plexFreeAdd1_$2
(byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 1.0434782608695652
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 0.6000000000000001
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 2.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(byte) plexSort::m
(byte) plexSort::m#1 151.5
(byte) plexSort::m#2 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 150.375
(bool~) plexSort::plexFreePrepare1_$0
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 151.5
(byte) plexSort::plexFreePrepare1_s#2 151.5
(byte) plexSort::s
(byte) plexSort::s#1 1368.3333333333335
(byte) plexSort::s#2 202.0
(byte) plexSort::s#3 2052.5
(byte~) plexSort::s#6 202.0
(byte) plex_free_next
(byte) plex_free_next#0 20.0
(byte) plex_free_next#27 2.8333333333333335
(byte) plex_free_next#31 4.0
interrupt(KERNEL_MIN)(void()) plex_irq()
(byte/signed word/word/dword/signed dword~) plex_irq::$4 11.0
(byte) plex_irq::plexFreeNextYpos1_return
(byte) plex_irq::plexFreeNextYpos1_return#0 4.0
(byte) plex_irq::rasterY
(byte) plex_show_idx
(byte) plex_show_idx#0 4.0
(byte) plex_show_idx#1 20.0
(byte) plex_show_idx#16 2.1666666666666665
(byte) plex_show_idx#27 1.1052631578947367
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0 4.0
(byte) plex_sprite_idx#1 20.0
(byte) plex_sprite_idx#25 1.1176470588235294
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0 4.0
(byte) plex_sprite_msb#1 20.0
(byte) plex_sprite_msb#17 2.142857142857143
(byte) plex_sprite_msb#27 3.0
(byte) plex_sprite_msb#29 0.95
(byte) plex_sprite_msb#4 4.0

Initial phi equivalence classes
[ framedone#12 framedone#19 framedone#5 ]
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ]
[ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ]
[ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
[ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 ]
Added variable plexSort::nxt_idx#0 to zero page equivalence class [ plexSort::nxt_idx#0 ]
Added variable plexSort::nxt_y#0 to zero page equivalence class [ plexSort::nxt_y#0 ]
Added variable plexSort::s#2 to zero page equivalence class [ plexSort::s#2 ]
Added variable plex_show_idx#1 to zero page equivalence class [ plex_show_idx#1 ]
Added variable plex_sprite_idx#1 to zero page equivalence class [ plex_sprite_idx#1 ]
Added variable plex_sprite_msb#1 to zero page equivalence class [ plex_sprite_msb#1 ]
Added variable plex_free_next#0 to zero page equivalence class [ plex_free_next#0 ]
Added variable init::$7 to zero page equivalence class [ init::$7 ]
Added variable plex_irq::plexFreeNextYpos1_return#0 to zero page equivalence class [ plex_irq::plexFreeNextYpos1_return#0 ]
Added variable plex_irq::$4 to zero page equivalence class [ plex_irq::$4 ]
Added variable framedone#3 to zero page equivalence class [ framedone#3 ]
Added variable plexShowSprite::plex_sprite_idx2#0 to zero page equivalence class [ plexShowSprite::plex_sprite_idx2#0 ]
Added variable plexShowSprite::plexFreeAdd1_ypos#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Added variable plexShowSprite::plexFreeAdd1_$0#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$0#0 ]
Added variable plexShowSprite::plexFreeAdd1_$1#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$1#0 ]
Added variable plexShowSprite::xpos_idx#0 to zero page equivalence class [ plexShowSprite::xpos_idx#0 ]
Added variable plexShowSprite::$3 to zero page equivalence class [ plexShowSprite::$3 ]
Added variable plexShowSprite::$4 to zero page equivalence class [ plexShowSprite::$4 ]
Added variable plexShowSprite::$10 to zero page equivalence class [ plexShowSprite::$10 ]
Added variable plexShowSprite::$6 to zero page equivalence class [ plexShowSprite::$6 ]
Complete equivalence classes
[ framedone#12 framedone#19 framedone#5 ]
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ]
[ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ]
[ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
[ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 ]
[ plexSort::nxt_idx#0 ]
[ plexSort::nxt_y#0 ]
[ plexSort::s#2 ]
[ plex_show_idx#1 ]
[ plex_sprite_idx#1 ]
[ plex_sprite_msb#1 ]
[ plex_free_next#0 ]
[ init::$7 ]
[ plex_irq::plexFreeNextYpos1_return#0 ]
[ plex_irq::$4 ]
[ framedone#3 ]
[ plexShowSprite::plex_sprite_idx2#0 ]
[ plexShowSprite::plexFreeAdd1_ypos#0 ]
[ plexShowSprite::plexFreeAdd1_$0#0 ]
[ plexShowSprite::plexFreeAdd1_$1#0 ]
[ plexShowSprite::xpos_idx#0 ]
[ plexShowSprite::$3 ]
[ plexShowSprite::$4 ]
[ plexShowSprite::$10 ]
[ plexShowSprite::$6 ]
Allocated zp ZP_BOOL:2 [ framedone#12 framedone#19 framedone#5 ]
Allocated zp ZP_BYTE:3 [ loop::sin_idx#6 loop::sin_idx#1 ]
Allocated zp ZP_BYTE:4 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Allocated zp ZP_BYTE:5 [ loop::sy#2 loop::sy#1 ]
Allocated zp ZP_BYTE:6 [ plexSort::m#2 plexSort::m#1 ]
Allocated zp ZP_BYTE:7 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Allocated zp ZP_BYTE:8 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Allocated zp ZP_BYTE:9 [ init::sx#2 init::sx#1 ]
Allocated zp ZP_WORD:10 [ init::xp#2 init::xp#1 ]
Allocated zp ZP_BYTE:12 [ init::ss#2 init::ss#1 ]
Allocated zp ZP_BYTE:13 [ plexInit::i#2 plexInit::i#1 ]
Allocated zp ZP_BYTE:14 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ]
Allocated zp ZP_BYTE:15 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ]
Allocated zp ZP_BYTE:16 [ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
Allocated zp ZP_BYTE:17 [ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 ]
Allocated zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ]
Allocated zp ZP_BYTE:19 [ plexSort::nxt_y#0 ]
Allocated zp ZP_BYTE:20 [ plexSort::s#2 ]
Allocated zp ZP_BYTE:21 [ plex_show_idx#1 ]
Allocated zp ZP_BYTE:22 [ plex_sprite_idx#1 ]
Allocated zp ZP_BYTE:23 [ plex_sprite_msb#1 ]
Allocated zp ZP_BYTE:24 [ plex_free_next#0 ]
Allocated zp ZP_BYTE:25 [ init::$7 ]
Allocated zp ZP_BYTE:26 [ plex_irq::plexFreeNextYpos1_return#0 ]
Allocated zp ZP_BYTE:27 [ plex_irq::$4 ]
Allocated zp ZP_BOOL:28 [ framedone#3 ]
Allocated zp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated zp ZP_BYTE:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Allocated zp ZP_BYTE:31 [ plexShowSprite::plexFreeAdd1_$0#0 ]
Allocated zp ZP_BYTE:32 [ plexShowSprite::plexFreeAdd1_$1#0 ]
Allocated zp ZP_BYTE:33 [ plexShowSprite::xpos_idx#0 ]
Allocated zp ZP_BYTE:34 [ plexShowSprite::$3 ]
Allocated zp ZP_BYTE:35 [ plexShowSprite::$4 ]
Allocated zp ZP_BYTE:36 [ plexShowSprite::$10 ]
Allocated zp ZP_BYTE:37 [ plexShowSprite::$6 ]

INITIAL ASM
//SEG0 File Comments
// A simple usage of the flexible sprite multiplexer routine
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label VIC_CONTROL = $d011
  .label D011 = $d011
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Bits for the IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // CIA#1 Interrupt Status & Control Register
  .label CIA1_INTERRUPT = $dc0d
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .label SPRITE = $2000
  .label YSIN = $2100
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = $400+$3f8
  .label plex_show_idx = $f
  .label plex_sprite_idx = $e
  .label plex_sprite_msb = $11
  .label plex_show_idx_1 = $15
  .label plex_sprite_idx_1 = $16
  .label plex_sprite_msb_1 = $17
  .label plex_free_next = $18
  .label framedone = $1c
  .label framedone_5 = 2
  .label framedone_12 = 2
  .label plex_free_next_27 = $10
  .label plex_free_next_31 = $10
  .label framedone_19 = 2
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 [1] (byte) plex_show_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  // The index in the PLEX tables of the next sprite to show
  lda #0
  sta plex_show_idx
//SEG6 [2] (byte) plex_sprite_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  // The index the next sprite to use for showing (sprites are used round-robin)
  lda #0
  sta plex_sprite_idx
//SEG7 [3] (byte) plex_sprite_msb#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuc1 
  // The MSB bit of the next sprite to use for showing
  lda #1
  sta plex_sprite_msb
  jmp b2
//SEG8 @2
b2:
//SEG9 [4] (byte) plex_free_next#31 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  lda #0
  sta plex_free_next_31
  jmp b3
//SEG10 @3
b3:
//SEG11 kickasm(location (const byte*) YSIN#0) {{ .var min = 50     .var max = 250-21     .var ampl = max-min;     .for(var i=0;i<256;i++)         .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))  }}
//SEG12 kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  jmp b4
//SEG13 @4
b4:
//SEG14 [7] (bool) framedone#19 ← true -- vboz1=vboc1 
  lda #1
  sta framedone_19
//SEG15 [8] phi from @4 to @5 [phi:@4->@5]
b5_from_b4:
  jmp b5
//SEG16 @5
b5:
//SEG17 [9] call main 
  jsr main
//SEG18 [10] phi from @5 to @end [phi:@5->@end]
bend_from_b5:
  jmp bend
//SEG19 @end
bend:
//SEG20 main
main: {
  //SEG21 asm { sei  }
    sei
  //SEG22 [12] call init 
    jsr init
  //SEG23 [13] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG24 main::@1
  b1:
  //SEG25 [14] call loop 
  //SEG26 [16] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from_b1:
    jsr loop
    jmp breturn
  //SEG27 main::@return
  breturn:
  //SEG28 [15] return 
    rts
}
//SEG29 loop
// The raster loop
loop: {
    .label y_idx = 4
    .label sy = 5
    .label sin_idx = 3
  //SEG30 [17] phi from loop to loop::@1 [phi:loop->loop::@1]
  b1_from_loop:
  //SEG31 [17] phi (byte) loop::sin_idx#6 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta sin_idx
  //SEG32 [17] phi (bool) framedone#12 = (bool) framedone#19 [phi:loop->loop::@1#1] -- register_copy 
    jmp b1
  //SEG33 loop::@1
  b1:
    jmp b2
  //SEG34 loop::@2
  b2:
  //SEG35 [18] if((bool) framedone#12) goto loop::@3 -- vboz1_then_la1 
    lda framedone_12
    cmp #0
    bne b3
    jmp b2
  //SEG36 loop::@3
  b3:
  //SEG37 [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
  //SEG38 [20] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuz1=vbuz2 
    lda sin_idx
    sta y_idx
  //SEG39 [21] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  b4_from_b3:
  //SEG40 [21] phi (byte) loop::sy#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta sy
  //SEG41 [21] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp b4
  //SEG42 [21] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  b4_from_b4:
  //SEG43 [21] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
  //SEG44 [21] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp b4
  //SEG45 loop::@4
  b4:
  //SEG46 [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz2 
    ldy y_idx
    lda YSIN,y
    ldy sy
    sta PLEX_YPOS,y
  //SEG47 [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte/signed byte/word/signed word/dword/signed dword) 8 -- vbuz1=vbuz1_plus_vbuc1 
    lax y_idx
    axs #-[8]
    stx y_idx
  //SEG48 [24] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuz1=_inc_vbuz1 
    inc sy
  //SEG49 [25] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp sy
    bne b4_from_b4
    jmp b5
  //SEG50 loop::@5
  b5:
  //SEG51 [26] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz1_plus_1 
    inc sin_idx
  //SEG52 [27] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG53 [28] call plexSort 
  //SEG54 [33] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from_b5:
    jsr plexSort
    jmp b6
  //SEG55 loop::@6
  b6:
  //SEG56 [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
  //SEG57 [30] (bool) framedone#5 ← false -- vboz1=vboc1 
    lda #0
    sta framedone_5
  //SEG58 [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte/signed byte/word/signed word/dword/signed dword) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
  //SEG59 [32] *((const byte*) RASTER#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
  //SEG60 [17] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
  b1_from_b6:
  //SEG61 [17] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
  //SEG62 [17] phi (bool) framedone#12 = (bool) framedone#5 [phi:loop::@6->loop::@1#1] -- register_copy 
    jmp b1
}
//SEG63 plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $12
    .label nxt_y = $13
    .label m = 6
    .label s = 7
    .label s_2 = $14
    .label plexFreePrepare1_s = 8
  //SEG64 [34] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  b1_from_plexSort:
  //SEG65 [34] phi (byte) plexSort::m#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta m
    jmp b1
  //SEG66 [34] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  b1_from_b2:
  //SEG67 [34] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp b1
  //SEG68 plexSort::@1
  b1:
  //SEG69 [35] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy m
    lda PLEX_SORTED_IDX+1,y
    sta nxt_idx
  //SEG70 [36] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy nxt_idx
    lda PLEX_YPOS,y
    sta nxt_y
  //SEG71 [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    lda nxt_y
    ldx m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
    jmp b7
  //SEG72 plexSort::@7
  b7:
  //SEG73 [38] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuz1=vbuz2 
    lda m
    sta s
  //SEG74 [39] phi from plexSort::@6 plexSort::@7 to plexSort::@3 [phi:plexSort::@6/plexSort::@7->plexSort::@3]
  b3_from_b6:
  b3_from_b7:
  //SEG75 [39] phi (byte) plexSort::s#3 = (byte) plexSort::s#1 [phi:plexSort::@6/plexSort::@7->plexSort::@3#0] -- register_copy 
    jmp b3
  //SEG76 plexSort::@3
  b3:
  //SEG77 [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy s
    lda PLEX_SORTED_IDX,y
    sta PLEX_SORTED_IDX+1,y
  //SEG78 [41] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuz1=_dec_vbuz1 
    dec s
  //SEG79 [42] if((byte) plexSort::s#1!=(byte/word/signed word/dword/signed dword) $ff) goto plexSort::@6 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp s
    bne b6
    jmp b4
  //SEG80 plexSort::@4
  b4:
  //SEG81 [43] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuz1=_inc_vbuz2 
    ldy s
    iny
    sty s_2
  //SEG82 [44] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda nxt_idx
    ldy s_2
    sta PLEX_SORTED_IDX,y
    jmp b2
  //SEG83 plexSort::@2
  b2:
  //SEG84 [45] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG85 [46] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 2+(byte/signed byte/word/signed word/dword/signed dword) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp m
    bne b1_from_b2
    jmp b5
  //SEG86 plexSort::@5
  b5:
  //SEG87 [47] (byte) plex_show_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta plex_show_idx_1
  //SEG88 [48] (byte) plex_sprite_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
    lda #0
    sta plex_sprite_idx_1
  //SEG89 [49] (byte) plex_sprite_msb#1 ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb_1
  //SEG90 [50] phi from plexSort::@5 to plexSort::plexFreePrepare1 [phi:plexSort::@5->plexSort::plexFreePrepare1]
  plexFreePrepare1_from_b5:
    jmp plexFreePrepare1
  //SEG91 plexSort::plexFreePrepare1
  plexFreePrepare1:
  //SEG92 [51] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1:
  //SEG93 [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuz1=vbuc1 
    lda #0
    sta plexFreePrepare1_s
    jmp plexFreePrepare1_b1
  //SEG94 [51] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1_b1:
  //SEG95 [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1_b1
  //SEG96 plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
  //SEG97 [52] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #0
    ldy plexFreePrepare1_s
    sta PLEX_FREE_YPOS,y
  //SEG98 [53] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuz1=_inc_vbuz1 
    inc plexFreePrepare1_s
  //SEG99 [54] if((byte) plexSort::plexFreePrepare1_s#1!=(byte/signed byte/word/signed word/dword/signed dword) 8) goto plexSort::plexFreePrepare1_@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp plexFreePrepare1_s
    bne plexFreePrepare1_b1_from_plexFreePrepare1_b1
    jmp plexFreePrepare1_b2
  //SEG100 plexSort::plexFreePrepare1_@2
  plexFreePrepare1_b2:
  //SEG101 [55] (byte) plex_free_next#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
    lda #0
    sta plex_free_next
    jmp breturn
  //SEG102 plexSort::@return
  breturn:
  //SEG103 [56] return 
    rts
  //SEG104 plexSort::@6
  b6:
  //SEG105 [57] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    lda nxt_y
    ldx s
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3_from_b6
    jmp b4
}
//SEG106 init
// Initialize the program
init: {
    .label _7 = $19
    .label xp = $a
    .label sx = 9
    .label ss = $c
  //SEG107 [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte/signed byte/word/signed word/dword/signed dword) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
  //SEG108 [59] call plexInit 
  //SEG109 [79] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
  //SEG110 [60] phi from init to init::@1 [phi:init->init::@1]
  b1_from_init:
  //SEG111 [60] phi (word) init::xp#2 = (byte/signed byte/word/signed word/dword/signed dword) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #$20
    sta xp
    lda #0
    sta xp+1
  //SEG112 [60] phi (byte) init::sx#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:init->init::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta sx
    jmp b1
  //SEG113 [60] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
  //SEG114 [60] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
  //SEG115 [60] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp b1
  //SEG116 init::@1
  b1:
  //SEG117 [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← ((byte))(const byte*) SPRITE#0/(byte/signed byte/word/signed word/dword/signed dword) $40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #$ff&SPRITE/$40
    ldy sx
    sta PLEX_PTR,y
  //SEG118 [62] (byte~) init::$7 ← (byte) init::sx#2 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz2_rol_1 
    lda sx
    asl
    sta _7
  //SEG119 [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$7) ← (word) init::xp#2 -- pwuc1_derefidx_vbuz1=vwuz2 
    ldy _7
    lda xp
    sta PLEX_XPOS,y
    lda xp+1
    sta PLEX_XPOS+1,y
  //SEG120 [64] (word) init::xp#1 ← (word) init::xp#2 + (byte/signed byte/word/signed word/dword/signed dword) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc xp
    sta xp
    bcc !+
    inc xp+1
  !:
  //SEG121 [65] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuz1=_inc_vbuz1 
    inc sx
  //SEG122 [66] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp sx
    bne b1_from_b1
    jmp b2
  //SEG123 init::@2
  b2:
  //SEG124 [67] *((const byte*) SPRITES_ENABLE#0) ← (byte/word/signed word/dword/signed dword) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
  //SEG125 [68] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
  //SEG126 [68] phi (byte) init::ss#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:init::@2->init::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta ss
    jmp b3
  //SEG127 [68] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  b3_from_b3:
  //SEG128 [68] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp b3
  //SEG129 init::@3
  b3:
  //SEG130 [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy ss
    sta SPRITES_COLS,y
  //SEG131 [70] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuz1=_inc_vbuz1 
    inc ss
  //SEG132 [71] if((byte) init::ss#1!=(byte/signed byte/word/signed word/dword/signed dword) 8) goto init::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp ss
    bne b3_from_b3
    jmp b4
  //SEG133 init::@4
  b4:
  //SEG134 asm { sei  }
    // enable the interrupt
    sei
  //SEG135 [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
  //SEG136 [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
  //SEG137 [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG138 [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() -- _deref_pptc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
  //SEG139 asm { cli  }
    cli
    jmp breturn
  //SEG140 init::@return
  breturn:
  //SEG141 [78] return 
    rts
}
//SEG142 plexInit
// Initialize the multiplexer data structures
plexInit: {
    .label i = $d
  //SEG143 [80] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
  //SEG144 plexInit::plexSetScreen1
  plexSetScreen1:
  //SEG145 [81] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  b1_from_plexSetScreen1:
  //SEG146 [81] phi (byte) plexInit::i#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b1
  //SEG147 [81] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  b1_from_b1:
  //SEG148 [81] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp b1
  //SEG149 plexInit::@1
  b1:
  //SEG150 [82] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuz1=vbuz1 
    ldy i
    tya
    sta PLEX_SORTED_IDX,y
  //SEG151 [83] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG152 [84] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto plexInit::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp i
    bne b1_from_b1
    jmp breturn
  //SEG153 plexInit::@return
  breturn:
  //SEG154 [85] return 
    rts
}
//SEG155 plex_irq
plex_irq: {
    .label _4 = $1b
    .label plexFreeNextYpos1_return = $1a
  //SEG156 entry interrupt(KERNEL_MIN)
  //SEG157 [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
  //SEG158 [87] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
  b3_from_plex_irq:
  b3_from_b7:
  //SEG159 [87] phi (byte) plex_sprite_msb#29 = (byte) plex_sprite_msb#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#0] -- register_copy 
  //SEG160 [87] phi (byte) plex_free_next#27 = (byte) plex_free_next#31 [phi:plex_irq/plex_irq::@7->plex_irq::@3#1] -- register_copy 
  //SEG161 [87] phi (byte) plex_show_idx#27 = (byte) plex_show_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#2] -- register_copy 
  //SEG162 [87] phi (byte) plex_sprite_idx#25 = (byte) plex_sprite_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#3] -- register_copy 
    jmp b3
  //SEG163 plex_irq::@3
  b3:
  //SEG164 [88] call plexShowSprite 
    jsr plexShowSprite
    jmp plexFreeNextYpos1
  //SEG165 plex_irq::plexFreeNextYpos1
  plexFreeNextYpos1:
  //SEG166 [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy plexShowSprite.plexFreeAdd1__2
    lda PLEX_FREE_YPOS,y
    sta plexFreeNextYpos1_return
    jmp b6
  //SEG167 plex_irq::@6
  b6:
  //SEG168 [90] (byte/signed word/word/dword/signed dword~) plex_irq::$4 ← *((const byte*) RASTER#0) + (byte/signed byte/word/signed word/dword/signed dword) 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta _4
  //SEG169 [91] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@7 -- vbuz1_lt_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcc b7
    jmp b4
  //SEG170 plex_irq::@4
  b4:
  //SEG171 [92] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG172 [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcc b1
    jmp b5
  //SEG173 plex_irq::@5
  b5:
  //SEG174 [94] (bool) framedone#3 ← true -- vboz1=vboc1 
    lda #1
    sta framedone
    jmp b2
  //SEG175 plex_irq::@2
  b2:
  //SEG176 [95] *((const byte*) BORDERCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDERCOL
    jmp breturn
  //SEG177 plex_irq::@return
  breturn:
  //SEG178 [96] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
  //SEG179 plex_irq::@1
  b1:
  //SEG180 [97] *((const byte*) RASTER#0) ← (byte) plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuz1 
    lda plexFreeNextYpos1_return
    sta RASTER
    jmp b2
  //SEG181 plex_irq::@7
  b7:
  //SEG182 [98] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte/signed word/word/dword/signed dword~) plex_irq::$4) goto plex_irq::@3 -- vbuz1_lt_vbuz2_then_la1 
    lda plexFreeNextYpos1_return
    cmp _4
    bcc b3_from_b7
    jmp b4
}
//SEG183 plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label _3 = $22
    .label _4 = $23
    .label _6 = $25
    .label _7 = $e
    .label _10 = $24
    .label plex_sprite_idx2 = $1d
    .label plexFreeAdd1_ypos = $1e
    .label plexFreeAdd1__0 = $1f
    .label plexFreeAdd1__1 = $20
    .label plexFreeAdd1__2 = $10
    .label xpos_idx = $21
  //SEG184 [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz2_rol_1 
    lda plex_sprite_idx
    asl
    sta plex_sprite_idx2
  //SEG185 [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- vbuz1=pbuc1_derefidx_pbuc2_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    ldx PLEX_YPOS,y
    stx plexFreeAdd1_ypos
  //SEG186 [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda plexFreeAdd1_ypos
    ldy plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
  //SEG187 plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
  //SEG188 [102] (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte/signed byte/word/signed word/dword/signed dword) $15 -- vbuz1=vbuz2_plus_vbuc1 
    lax plexFreeAdd1_ypos
    axs #-[$15]
    stx plexFreeAdd1__0
  //SEG189 [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda plexFreeAdd1__0
    ldy plex_free_next_27
    sta PLEX_FREE_YPOS,y
  //SEG190 [104] (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#27 + (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz2_plus_1 
    ldy plex_free_next_27
    iny
    sty plexFreeAdd1__1
  //SEG191 [105] (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 & (byte/signed byte/word/signed word/dword/signed dword) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and plexFreeAdd1__1
    sta plexFreeAdd1__2
    jmp b5
  //SEG192 plexShowSprite::@5
  b5:
  //SEG193 [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_pbuc3_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
  //SEG194 [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=pbuc1_derefidx_vbuz2_rol_1 
    ldy plex_show_idx
    lda PLEX_SORTED_IDX,y
    asl
    sta xpos_idx
  //SEG195 [108] (byte~) plexShowSprite::$3 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) -- vbuz1=_lo_pwuc1_derefidx_vbuz2 
    ldy xpos_idx
    lda PLEX_XPOS,y
    sta _3
  //SEG196 [109] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$3 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _3
    ldy plex_sprite_idx2
    sta SPRITES_XPOS,y
  //SEG197 [110] (byte~) plexShowSprite::$4 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) -- vbuz1=_hi_pwuc1_derefidx_vbuz2 
    ldy xpos_idx
    lda PLEX_XPOS+1,y
    sta _4
  //SEG198 [111] if((byte~) plexShowSprite::$4!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@1 -- vbuz1_neq_0_then_la1 
    lda _4
    cmp #0
    bne b1
    jmp b3
  //SEG199 plexShowSprite::@3
  b3:
  //SEG200 [112] (byte/word/dword~) plexShowSprite::$10 ← (byte/word/signed word/dword/signed dword) $ff ^ (byte) plex_sprite_msb#29 -- vbuz1=vbuc1_bxor_vbuz2 
    lda plex_sprite_msb
    eor #$ff
    sta _10
  //SEG201 [113] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte/word/dword~) plexShowSprite::$10 -- _deref_pbuc1=_deref_pbuc1_band_vbuz1 
    lda SPRITES_XMSB
    and _10
    sta SPRITES_XMSB
    jmp b2
  //SEG202 plexShowSprite::@2
  b2:
  //SEG203 [114] (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 ← (byte) plex_sprite_idx#25 + (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz2_plus_1 
    ldy plex_sprite_idx
    iny
    sty _6
  //SEG204 [115] (byte/word/dword~) plexShowSprite::$7 ← (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 & (byte/signed byte/word/signed word/dword/signed dword) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and _6
    sta _7
  //SEG205 [116] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27 -- vbuz1=_inc_vbuz1 
    inc plex_show_idx
  //SEG206 [117] (byte) plex_sprite_msb#27 ← (byte) plex_sprite_msb#29 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz1_rol_1 
    asl plex_sprite_msb
  //SEG207 [118] if((byte) plex_sprite_msb#27!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda plex_sprite_msb
    cmp #0
    bne breturn_from_b2
    jmp b4
  //SEG208 plexShowSprite::@4
  b4:
  //SEG209 [119] (byte) plex_sprite_msb#4 ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG210 [120] phi from plexShowSprite::@2 plexShowSprite::@4 to plexShowSprite::@return [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return]
  breturn_from_b2:
  breturn_from_b4:
  //SEG211 [120] phi (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#27 [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return#0] -- register_copy 
    jmp breturn
  //SEG212 plexShowSprite::@return
  breturn:
  //SEG213 [121] return 
    rts
  //SEG214 plexShowSprite::@1
  b1:
  //SEG215 [122] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#29 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = YSIN "YSIN"
  .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] (byte) plex_show_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [2] (byte) plex_sprite_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [3] (byte) plex_sprite_msb#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ ] ( ) always clobbers reg byte a 
Statement [4] (byte) plex_free_next#31 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [7] (bool) framedone#19 ← true [ framedone#19 ] ( ) always clobbers reg byte a 
Statement [18] if((bool) framedone#12) goto loop::@3 [ framedone#12 loop::sin_idx#6 ] ( main:9::loop:14 [ framedone#12 loop::sin_idx#6 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ loop::sin_idx#6 loop::sin_idx#1 ]
Statement [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 [ loop::sin_idx#6 ] ( main:9::loop:14 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ loop::sy#2 loop::sy#1 ]
Statement [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte/signed byte/word/signed word/dword/signed dword) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ loop::sin_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [30] (bool) framedone#5 ← false [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte/signed byte/word/signed word/dword/signed dword) $7f [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [32] *((const byte*) RASTER#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ plexSort::m#2 plexSort::m#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:19 [ plexSort::nxt_y#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Statement [44] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [47] (byte) plex_show_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [48] (byte) plex_sprite_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [49] (byte) plex_sprite_msb#1 ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [52] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:8 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Statement [55] (byte) plex_free_next#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [57] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte/signed byte/word/signed word/dword/signed dword) 3 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← ((byte))(const byte*) SPRITE#0/(byte/signed byte/word/signed word/dword/signed dword) $40 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ init::sx#2 init::sx#1 ]
Statement [62] (byte~) init::$7 ← (byte) init::sx#2 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ init::sx#2 init::xp#2 init::$7 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#2 init::$7 ] ) always clobbers reg byte a 
Statement [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$7) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [64] (word) init::xp#1 ← (word) init::xp#2 + (byte/signed byte/word/signed word/dword/signed dword) 9 [ init::sx#2 init::xp#1 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [67] *((const byte*) SPRITES_ENABLE#0) ← (byte/word/signed word/dword/signed dword) $ff [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:9::init:12 [ framedone#19 init::ss#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:12 [ init::ss#2 init::ss#1 ]
Statement [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] ) always clobbers reg byte a 
Statement [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0) [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte y 
Statement [91] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@7 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:26 [ plex_irq::plexFreeNextYpos1_return#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:27 [ plex_irq::$4 ]
Statement [92] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 [ plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [94] (bool) framedone#3 ← true [ ] (  [ ] ) always clobbers reg byte a 
Statement [95] *((const byte*) BORDERCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] (  [ ] ) always clobbers reg byte a 
Statement [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte x reg byte y 
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte y 
Statement [105] (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 & (byte/signed byte/word/signed word/dword/signed dword) 7 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) << (byte/signed byte/word/signed word/dword/signed dword) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte a 
Statement [108] (byte~) plexShowSprite::$3 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 plexShowSprite::$3 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 plexShowSprite::$3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:33 [ plexShowSprite::xpos_idx#0 ]
Statement [109] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$3 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:33 [ plexShowSprite::xpos_idx#0 ]
Statement [110] (byte~) plexShowSprite::$4 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$4 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$4 ] ) always clobbers reg byte a 
Statement [112] (byte/word/dword~) plexShowSprite::$10 ← (byte/word/signed word/dword/signed dword) $ff ^ (byte) plex_sprite_msb#29 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$10 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$10 ] ) always clobbers reg byte a 
Statement [113] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte/word/dword~) plexShowSprite::$10 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [115] (byte/word/dword~) plexShowSprite::$7 ← (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 & (byte/signed byte/word/signed word/dword/signed dword) 7 [ plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::$7 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::$7 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [118] if((byte) plex_sprite_msb#27!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@return [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#27 ] ( plexShowSprite:88 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#27 ] ) always clobbers reg byte a 
Statement [119] (byte) plex_sprite_msb#4 ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ( plexShowSprite:88 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ) always clobbers reg byte a 
Statement [122] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#29 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [1] (byte) plex_show_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [2] (byte) plex_sprite_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [3] (byte) plex_sprite_msb#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ ] ( ) always clobbers reg byte a 
Statement [4] (byte) plex_free_next#31 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [7] (bool) framedone#19 ← true [ framedone#19 ] ( ) always clobbers reg byte a 
Statement [18] if((bool) framedone#12) goto loop::@3 [ framedone#12 loop::sin_idx#6 ] ( main:9::loop:14 [ framedone#12 loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 [ loop::sin_idx#6 ] ( main:9::loop:14 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Statement [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte/signed byte/word/signed word/dword/signed dword) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ loop::sin_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [30] (bool) framedone#5 ← false [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte/signed byte/word/signed word/dword/signed dword) $7f [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [32] *((const byte*) RASTER#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ) always clobbers reg byte a 
Statement [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Statement [44] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [47] (byte) plex_show_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [48] (byte) plex_sprite_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [49] (byte) plex_sprite_msb#1 ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [52] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Statement [55] (byte) plex_free_next#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [57] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte/signed byte/word/signed word/dword/signed dword) 3 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← ((byte))(const byte*) SPRITE#0/(byte/signed byte/word/signed word/dword/signed dword) $40 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [62] (byte~) init::$7 ← (byte) init::sx#2 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ init::sx#2 init::xp#2 init::$7 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#2 init::$7 ] ) always clobbers reg byte a 
Statement [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$7) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [64] (word) init::xp#1 ← (word) init::xp#2 + (byte/signed byte/word/signed word/dword/signed dword) 9 [ init::sx#2 init::xp#1 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [67] *((const byte*) SPRITES_ENABLE#0) ← (byte/word/signed word/dword/signed dword) $ff [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:9::init:12 [ framedone#19 init::ss#2 ] ) always clobbers reg byte a 
Statement [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] ) always clobbers reg byte a 
Statement [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0) [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte y 
Statement [91] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@7 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] ) always clobbers reg byte a 
Statement [92] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 [ plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [94] (bool) framedone#3 ← true [ ] (  [ ] ) always clobbers reg byte a 
Statement [95] *((const byte*) BORDERCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] (  [ ] ) always clobbers reg byte a 
Statement [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte x reg byte y 
Statement [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Statement [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte y 
Statement [105] (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 & (byte/signed byte/word/signed word/dword/signed dword) 7 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) << (byte/signed byte/word/signed word/dword/signed dword) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte a 
Statement [108] (byte~) plexShowSprite::$3 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 plexShowSprite::$3 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [109] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$3 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte y 
Statement [110] (byte~) plexShowSprite::$4 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$4 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$4 ] ) always clobbers reg byte a 
Statement [112] (byte/word/dword~) plexShowSprite::$10 ← (byte/word/signed word/dword/signed dword) $ff ^ (byte) plex_sprite_msb#29 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$10 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$10 ] ) always clobbers reg byte a 
Statement [113] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte/word/dword~) plexShowSprite::$10 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [115] (byte/word/dword~) plexShowSprite::$7 ← (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 & (byte/signed byte/word/signed word/dword/signed dword) 7 [ plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::$7 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::$7 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [118] if((byte) plex_sprite_msb#27!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@return [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#27 ] ( plexShowSprite:88 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#27 ] ) always clobbers reg byte a 
Statement [119] (byte) plex_sprite_msb#4 ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ( plexShowSprite:88 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ) always clobbers reg byte a 
Statement [122] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#29 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [1] (byte) plex_show_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [2] (byte) plex_sprite_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [3] (byte) plex_sprite_msb#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ ] ( ) always clobbers reg byte a 
Statement [4] (byte) plex_free_next#31 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( ) always clobbers reg byte a 
Statement [7] (bool) framedone#19 ← true [ framedone#19 ] ( ) always clobbers reg byte a 
Statement [18] if((bool) framedone#12) goto loop::@3 [ framedone#12 loop::sin_idx#6 ] ( main:9::loop:14 [ framedone#12 loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 [ loop::sin_idx#6 ] ( main:9::loop:14 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Statement [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte/signed byte/word/signed word/dword/signed dword) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 [ loop::sin_idx#1 ] ( main:9::loop:14 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [30] (bool) framedone#5 ← false [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte/signed byte/word/signed word/dword/signed dword) $7f [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [32] *((const byte*) RASTER#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ framedone#5 loop::sin_idx#1 ] ( main:9::loop:14 [ framedone#5 loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ) always clobbers reg byte a 
Statement [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Statement [44] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [47] (byte) plex_show_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [48] (byte) plex_sprite_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [49] (byte) plex_sprite_msb#1 ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [52] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Statement [55] (byte) plex_free_next#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [57] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:9::loop:14::plexSort:28 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte/signed byte/word/signed word/dword/signed dword) 3 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← ((byte))(const byte*) SPRITE#0/(byte/signed byte/word/signed word/dword/signed dword) $40 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [62] (byte~) init::$7 ← (byte) init::sx#2 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ init::sx#2 init::xp#2 init::$7 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#2 init::$7 ] ) always clobbers reg byte a 
Statement [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$7) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [64] (word) init::xp#1 ← (word) init::xp#2 + (byte/signed byte/word/signed word/dword/signed dword) 9 [ init::sx#2 init::xp#1 ] ( main:9::init:12 [ framedone#19 init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [67] *((const byte*) SPRITES_ENABLE#0) ← (byte/word/signed word/dword/signed dword) $ff [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:9::init:12 [ framedone#19 init::ss#2 ] ) always clobbers reg byte a 
Statement [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() [ ] ( main:9::init:12 [ framedone#19 ] ) always clobbers reg byte a 
Statement [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] (  [ plex_show_idx#0 plex_sprite_idx#0 plex_sprite_msb#0 plex_free_next#31 ] ) always clobbers reg byte a 
Statement [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0) [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte y 
Statement [91] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@7 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] (  [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#17 plex_irq::plexFreeNextYpos1_return#0 plex_irq::$4 ] ) always clobbers reg byte a 
Statement [92] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_show_idx#16 plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 [ plex_irq::plexFreeNextYpos1_return#0 ] (  [ plex_irq::plexFreeNextYpos1_return#0 ] ) always clobbers reg byte a 
Statement [94] (bool) framedone#3 ← true [ ] (  [ ] ) always clobbers reg byte a 
Statement [95] *((const byte*) BORDERCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] (  [ ] ) always clobbers reg byte a 
Statement [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte x reg byte y 
Statement [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ) always clobbers reg byte y 
Statement [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_free_next#27 plex_sprite_msb#29 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte y 
Statement [105] (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 & (byte/signed byte/word/signed word/dword/signed dword) 7 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) << (byte/signed byte/word/signed word/dword/signed dword) 1 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte a 
Statement [108] (byte~) plexShowSprite::$3 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 plexShowSprite::$3 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [109] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$3 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::xpos_idx#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::xpos_idx#0 ] ) always clobbers reg byte y 
Statement [110] (byte~) plexShowSprite::$4 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$4 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$4 ] ) always clobbers reg byte a 
Statement [112] (byte/word/dword~) plexShowSprite::$10 ← (byte/word/signed word/dword/signed dword) $ff ^ (byte) plex_sprite_msb#29 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$10 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 plexShowSprite::$10 ] ) always clobbers reg byte a 
Statement [113] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte/word/dword~) plexShowSprite::$10 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [115] (byte/word/dword~) plexShowSprite::$7 ← (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 & (byte/signed byte/word/signed word/dword/signed dword) 7 [ plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::$7 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::$7 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Statement [118] if((byte) plex_sprite_msb#27!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@return [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#27 ] ( plexShowSprite:88 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#27 ] ) always clobbers reg byte a 
Statement [119] (byte) plex_sprite_msb#4 ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ( plexShowSprite:88 [ plexShowSprite::$7 plex_show_idx#16 plexShowSprite::plexFreeAdd1_$2#0 plex_sprite_msb#4 ] ) always clobbers reg byte a 
Statement [122] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#29 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ( plexShowSprite:88 [ plex_sprite_idx#25 plex_show_idx#27 plex_sprite_msb#29 plexShowSprite::plexFreeAdd1_$2#0 ] ) always clobbers reg byte a 
Potential registers zp ZP_BOOL:2 [ framedone#12 framedone#19 framedone#5 ] : zp ZP_BOOL:2 , 
Potential registers zp ZP_BYTE:3 [ loop::sin_idx#6 loop::sin_idx#1 ] : zp ZP_BYTE:3 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ loop::sy#2 loop::sy#1 ] : zp ZP_BYTE:5 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ plexSort::m#2 plexSort::m#1 ] : zp ZP_BYTE:6 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] : zp ZP_BYTE:7 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] : zp ZP_BYTE:8 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:9 [ init::sx#2 init::sx#1 ] : zp ZP_BYTE:9 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:10 [ init::xp#2 init::xp#1 ] : zp ZP_WORD:10 , 
Potential registers zp ZP_BYTE:12 [ init::ss#2 init::ss#1 ] : zp ZP_BYTE:12 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ plexInit::i#2 plexInit::i#1 ] : zp ZP_BYTE:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:14 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ] : zp ZP_BYTE:14 , 
Potential registers zp ZP_BYTE:15 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ] : zp ZP_BYTE:15 , 
Potential registers zp ZP_BYTE:16 [ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ] : zp ZP_BYTE:16 , 
Potential registers zp ZP_BYTE:17 [ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 ] : zp ZP_BYTE:17 , 
Potential registers zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] : zp ZP_BYTE:18 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] : zp ZP_BYTE:19 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:20 [ plexSort::s#2 ] : zp ZP_BYTE:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:21 [ plex_show_idx#1 ] : zp ZP_BYTE:21 , 
Potential registers zp ZP_BYTE:22 [ plex_sprite_idx#1 ] : zp ZP_BYTE:22 , 
Potential registers zp ZP_BYTE:23 [ plex_sprite_msb#1 ] : zp ZP_BYTE:23 , 
Potential registers zp ZP_BYTE:24 [ plex_free_next#0 ] : zp ZP_BYTE:24 , 
Potential registers zp ZP_BYTE:25 [ init::$7 ] : zp ZP_BYTE:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:26 [ plex_irq::plexFreeNextYpos1_return#0 ] : zp ZP_BYTE:26 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:27 [ plex_irq::$4 ] : zp ZP_BYTE:27 , reg byte x , reg byte y , 
Potential registers zp ZP_BOOL:28 [ framedone#3 ] : zp ZP_BOOL:28 , 
Potential registers zp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ] : zp ZP_BYTE:29 , 
Potential registers zp ZP_BYTE:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ] : zp ZP_BYTE:30 , reg byte a , reg byte x , 
Potential registers zp ZP_BYTE:31 [ plexShowSprite::plexFreeAdd1_$0#0 ] : zp ZP_BYTE:31 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:32 [ plexShowSprite::plexFreeAdd1_$1#0 ] : zp ZP_BYTE:32 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:33 [ plexShowSprite::xpos_idx#0 ] : zp ZP_BYTE:33 , reg byte x , 
Potential registers zp ZP_BYTE:34 [ plexShowSprite::$3 ] : zp ZP_BYTE:34 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:35 [ plexShowSprite::$4 ] : zp ZP_BYTE:35 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:36 [ plexShowSprite::$10 ] : zp ZP_BYTE:36 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:37 [ plexShowSprite::$6 ] : zp ZP_BYTE:37 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [plexSort] 3,622.83: zp ZP_BYTE:7 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] 303: zp ZP_BYTE:8 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] 202: zp ZP_BYTE:20 [ plexSort::s#2 ] 193.58: zp ZP_BYTE:6 [ plexSort::m#2 plexSort::m#1 ] 150.38: zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] 30.3: zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] 
Uplift Scope [loop] 252.5: zp ZP_BYTE:5 [ loop::sy#2 loop::sy#1 ] 246.33: zp ZP_BYTE:4 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] 6.81: zp ZP_BYTE:3 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Uplift Scope [] 65: zp ZP_BOOL:2 [ framedone#12 framedone#19 framedone#5 ] 20: zp ZP_BYTE:21 [ plex_show_idx#1 ] 20: zp ZP_BYTE:22 [ plex_sprite_idx#1 ] 20: zp ZP_BYTE:23 [ plex_sprite_msb#1 ] 20: zp ZP_BYTE:24 [ plex_free_next#0 ] 20: zp ZP_BOOL:28 [ framedone#3 ] 14.09: zp ZP_BYTE:17 [ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 ] 7.88: zp ZP_BYTE:16 [ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ] 7.27: zp ZP_BYTE:15 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ] 6.2: zp ZP_BYTE:14 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ] 
Uplift Scope [init] 33: zp ZP_BYTE:12 [ init::ss#2 init::ss#1 ] 25.3: zp ZP_BYTE:9 [ init::sx#2 init::sx#1 ] 22: zp ZP_BYTE:25 [ init::$7 ] 15.58: zp ZP_WORD:10 [ init::xp#2 init::xp#1 ] 
Uplift Scope [plexInit] 38.5: zp ZP_BYTE:13 [ plexInit::i#2 plexInit::i#1 ] 
Uplift Scope [plexShowSprite] 4: zp ZP_BYTE:31 [ plexShowSprite::plexFreeAdd1_$0#0 ] 4: zp ZP_BYTE:32 [ plexShowSprite::plexFreeAdd1_$1#0 ] 4: zp ZP_BYTE:34 [ plexShowSprite::$3 ] 4: zp ZP_BYTE:35 [ plexShowSprite::$4 ] 4: zp ZP_BYTE:36 [ plexShowSprite::$10 ] 4: zp ZP_BYTE:37 [ plexShowSprite::$6 ] 3: zp ZP_BYTE:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ] 2: zp ZP_BYTE:33 [ plexShowSprite::xpos_idx#0 ] 0.6: zp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ] 
Uplift Scope [plex_irq] 11: zp ZP_BYTE:27 [ plex_irq::$4 ] 4: zp ZP_BYTE:26 [ plex_irq::plexFreeNextYpos1_return#0 ] 
Uplift Scope [main] 

Uplifting [plexSort] best 60876 combination reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] zp ZP_BYTE:20 [ plexSort::s#2 ] zp ZP_BYTE:6 [ plexSort::m#2 plexSort::m#1 ] zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] 
Limited combination testing to 10 combinations of 972 possible.
Uplifting [loop] best 58946 combination reg byte y [ loop::sy#2 loop::sy#1 ] reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] zp ZP_BYTE:3 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Limited combination testing to 10 combinations of 27 possible.
Uplifting [] best 58946 combination zp ZP_BOOL:2 [ framedone#12 framedone#19 framedone#5 ] zp ZP_BYTE:21 [ plex_show_idx#1 ] zp ZP_BYTE:22 [ plex_sprite_idx#1 ] zp ZP_BYTE:23 [ plex_sprite_msb#1 ] zp ZP_BYTE:24 [ plex_free_next#0 ] zp ZP_BOOL:28 [ framedone#3 ] zp ZP_BYTE:17 [ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 ] zp ZP_BYTE:16 [ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ] zp ZP_BYTE:15 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ] zp ZP_BYTE:14 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ] 
Uplifting [init] best 58696 combination reg byte x [ init::ss#2 init::ss#1 ] reg byte x [ init::sx#2 init::sx#1 ] zp ZP_BYTE:25 [ init::$7 ] zp ZP_WORD:10 [ init::xp#2 init::xp#1 ] 
Limited combination testing to 10 combinations of 36 possible.
Uplifting [plexInit] best 58576 combination reg byte x [ plexInit::i#2 plexInit::i#1 ] 
Uplifting [plexShowSprite] best 58566 combination reg byte a [ plexShowSprite::plexFreeAdd1_$0#0 ] reg byte x [ plexShowSprite::plexFreeAdd1_$1#0 ] zp ZP_BYTE:34 [ plexShowSprite::$3 ] zp ZP_BYTE:35 [ plexShowSprite::$4 ] zp ZP_BYTE:36 [ plexShowSprite::$10 ] zp ZP_BYTE:37 [ plexShowSprite::$6 ] zp ZP_BYTE:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ] zp ZP_BYTE:33 [ plexShowSprite::xpos_idx#0 ] zp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ] 
Limited combination testing to 10 combinations of 24576 possible.
Uplifting [plex_irq] best 58503 combination zp ZP_BYTE:27 [ plex_irq::$4 ] reg byte x [ plex_irq::plexFreeNextYpos1_return#0 ] 
Uplifting [main] best 58503 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:20 [ plexSort::s#2 ]
Uplifting [plexSort] best 57903 combination reg byte x [ plexSort::s#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:6 [ plexSort::m#2 plexSort::m#1 ]
Uplifting [plexSort] best 57903 combination zp ZP_BYTE:6 [ plexSort::m#2 plexSort::m#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:19 [ plexSort::nxt_y#0 ]
Uplifting [plexSort] best 57903 combination zp ZP_BYTE:19 [ plexSort::nxt_y#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:18 [ plexSort::nxt_idx#0 ]
Uplifting [plexSort] best 57903 combination zp ZP_BYTE:18 [ plexSort::nxt_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:25 [ init::$7 ]
Uplifting [init] best 57863 combination reg byte a [ init::$7 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:21 [ plex_show_idx#1 ]
Uplifting [] best 57863 combination zp ZP_BYTE:21 [ plex_show_idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:22 [ plex_sprite_idx#1 ]
Uplifting [] best 57863 combination zp ZP_BYTE:22 [ plex_sprite_idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:23 [ plex_sprite_msb#1 ]
Uplifting [] best 57863 combination zp ZP_BYTE:23 [ plex_sprite_msb#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:24 [ plex_free_next#0 ]
Uplifting [] best 57863 combination zp ZP_BYTE:24 [ plex_free_next#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:17 [ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 ]
Uplifting [] best 57863 combination zp ZP_BYTE:17 [ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:27 [ plex_irq::$4 ]
Uplifting [plex_irq] best 57863 combination zp ZP_BYTE:27 [ plex_irq::$4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:16 [ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
Uplifting [] best 57863 combination zp ZP_BYTE:16 [ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:15 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ]
Uplifting [] best 57863 combination zp ZP_BYTE:15 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ loop::sin_idx#6 loop::sin_idx#1 ]
Uplifting [loop] best 57863 combination zp ZP_BYTE:3 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:14 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ]
Uplifting [] best 57863 combination zp ZP_BYTE:14 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:34 [ plexShowSprite::$3 ]
Uplifting [plexShowSprite] best 57857 combination reg byte a [ plexShowSprite::$3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:35 [ plexShowSprite::$4 ]
Uplifting [plexShowSprite] best 57851 combination reg byte a [ plexShowSprite::$4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:36 [ plexShowSprite::$10 ]
Uplifting [plexShowSprite] best 57845 combination reg byte a [ plexShowSprite::$10 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:37 [ plexShowSprite::$6 ]
Uplifting [plexShowSprite] best 57839 combination reg byte x [ plexShowSprite::$6 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:30 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Uplifting [plexShowSprite] best 57830 combination reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:33 [ plexShowSprite::xpos_idx#0 ]
Uplifting [plexShowSprite] best 57823 combination reg byte x [ plexShowSprite::xpos_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ]
Uplifting [plexShowSprite] best 57823 combination zp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ] 
Coalescing zero page register [ zp ZP_BOOL:2 [ framedone#12 framedone#19 framedone#5 ] ] with [ zp ZP_BOOL:28 [ framedone#3 ] ]
Coalescing zero page register [ zp ZP_BYTE:15 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 ] ] with [ zp ZP_BYTE:21 [ plex_show_idx#1 ] ]
Coalescing zero page register [ zp ZP_BYTE:17 [ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 ] ] with [ zp ZP_BYTE:23 [ plex_sprite_msb#1 ] ]
Coalescing zero page register [ zp ZP_BYTE:27 [ plex_irq::$4 ] ] with [ zp ZP_BYTE:29 [ plexShowSprite::plex_sprite_idx2#0 ] ]
Allocated (was zp ZP_BYTE:6) zp ZP_BYTE:4 [ plexSort::m#2 plexSort::m#1 ]
Allocated (was zp ZP_WORD:10) zp ZP_WORD:5 [ init::xp#2 init::xp#1 ]
Allocated (was zp ZP_BYTE:14) zp ZP_BYTE:7 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ]
Allocated (was zp ZP_BYTE:15) zp ZP_BYTE:8 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ]
Allocated (was zp ZP_BYTE:16) zp ZP_BYTE:9 [ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
Allocated (was zp ZP_BYTE:17) zp ZP_BYTE:10 [ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 plex_sprite_msb#1 ]
Allocated (was zp ZP_BYTE:18) zp ZP_BYTE:11 [ plexSort::nxt_idx#0 ]
Allocated (was zp ZP_BYTE:19) zp ZP_BYTE:12 [ plexSort::nxt_y#0 ]
Allocated (was zp ZP_BYTE:22) zp ZP_BYTE:13 [ plex_sprite_idx#1 ]
Allocated (was zp ZP_BYTE:24) zp ZP_BYTE:14 [ plex_free_next#0 ]
Allocated (was zp ZP_BYTE:27) zp ZP_BYTE:15 [ plex_irq::$4 plexShowSprite::plex_sprite_idx2#0 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// A simple usage of the flexible sprite multiplexer routine
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label VIC_CONTROL = $d011
  .label D011 = $d011
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Bits for the IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // CIA#1 Interrupt Status & Control Register
  .label CIA1_INTERRUPT = $dc0d
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .label SPRITE = $2000
  .label YSIN = $2100
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = $400+$3f8
  .label plex_show_idx = 8
  .label plex_sprite_idx = 7
  .label plex_sprite_msb = $a
  .label plex_sprite_idx_1 = $d
  .label plex_free_next = $e
  .label framedone = 2
  .label plex_free_next_27 = 9
  .label plex_free_next_31 = 9
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 [1] (byte) plex_show_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  // The index in the PLEX tables of the next sprite to show
  lda #0
  sta plex_show_idx
//SEG6 [2] (byte) plex_sprite_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  // The index the next sprite to use for showing (sprites are used round-robin)
  lda #0
  sta plex_sprite_idx
//SEG7 [3] (byte) plex_sprite_msb#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuc1 
  // The MSB bit of the next sprite to use for showing
  lda #1
  sta plex_sprite_msb
  jmp b2
//SEG8 @2
b2:
//SEG9 [4] (byte) plex_free_next#31 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  lda #0
  sta plex_free_next_31
  jmp b3
//SEG10 @3
b3:
//SEG11 kickasm(location (const byte*) YSIN#0) {{ .var min = 50     .var max = 250-21     .var ampl = max-min;     .for(var i=0;i<256;i++)         .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))  }}
//SEG12 kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  jmp b4
//SEG13 @4
b4:
//SEG14 [7] (bool) framedone#19 ← true -- vboz1=vboc1 
  lda #1
  sta framedone
//SEG15 [8] phi from @4 to @5 [phi:@4->@5]
b5_from_b4:
  jmp b5
//SEG16 @5
b5:
//SEG17 [9] call main 
  jsr main
//SEG18 [10] phi from @5 to @end [phi:@5->@end]
bend_from_b5:
  jmp bend
//SEG19 @end
bend:
//SEG20 main
main: {
  //SEG21 asm { sei  }
    sei
  //SEG22 [12] call init 
    jsr init
  //SEG23 [13] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG24 main::@1
  b1:
  //SEG25 [14] call loop 
  //SEG26 [16] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from_b1:
    jsr loop
    jmp breturn
  //SEG27 main::@return
  breturn:
  //SEG28 [15] return 
    rts
}
//SEG29 loop
// The raster loop
loop: {
    .label sin_idx = 3
  //SEG30 [17] phi from loop to loop::@1 [phi:loop->loop::@1]
  b1_from_loop:
  //SEG31 [17] phi (byte) loop::sin_idx#6 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta sin_idx
  //SEG32 [17] phi (bool) framedone#12 = (bool) framedone#19 [phi:loop->loop::@1#1] -- register_copy 
    jmp b1
  //SEG33 loop::@1
  b1:
    jmp b2
  //SEG34 loop::@2
  b2:
  //SEG35 [18] if((bool) framedone#12) goto loop::@3 -- vboz1_then_la1 
    lda framedone
    cmp #0
    bne b3
    jmp b2
  //SEG36 loop::@3
  b3:
  //SEG37 [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
  //SEG38 [20] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx sin_idx
  //SEG39 [21] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  b4_from_b3:
  //SEG40 [21] phi (byte) loop::sy#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
  //SEG41 [21] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp b4
  //SEG42 [21] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  b4_from_b4:
  //SEG43 [21] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
  //SEG44 [21] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp b4
  //SEG45 loop::@4
  b4:
  //SEG46 [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
  //SEG47 [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte/signed byte/word/signed word/dword/signed dword) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
  //SEG48 [24] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG49 [25] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne b4_from_b4
    jmp b5
  //SEG50 loop::@5
  b5:
  //SEG51 [26] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz1_plus_1 
    inc sin_idx
  //SEG52 [27] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG53 [28] call plexSort 
  //SEG54 [33] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from_b5:
    jsr plexSort
    jmp b6
  //SEG55 loop::@6
  b6:
  //SEG56 [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
  //SEG57 [30] (bool) framedone#5 ← false -- vboz1=vboc1 
    lda #0
    sta framedone
  //SEG58 [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte/signed byte/word/signed word/dword/signed dword) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
  //SEG59 [32] *((const byte*) RASTER#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
  //SEG60 [17] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
  b1_from_b6:
  //SEG61 [17] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
  //SEG62 [17] phi (bool) framedone#12 = (bool) framedone#5 [phi:loop::@6->loop::@1#1] -- register_copy 
    jmp b1
}
//SEG63 plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $b
    .label nxt_y = $c
    .label m = 4
  //SEG64 [34] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  b1_from_plexSort:
  //SEG65 [34] phi (byte) plexSort::m#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta m
    jmp b1
  //SEG66 [34] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  b1_from_b2:
  //SEG67 [34] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp b1
  //SEG68 plexSort::@1
  b1:
  //SEG69 [35] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy m
    lda PLEX_SORTED_IDX+1,y
    sta nxt_idx
  //SEG70 [36] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy nxt_idx
    lda PLEX_YPOS,y
    sta nxt_y
  //SEG71 [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    lda nxt_y
    ldx m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
    jmp b7
  //SEG72 plexSort::@7
  b7:
  //SEG73 [38] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
    ldx m
  //SEG74 [39] phi from plexSort::@6 plexSort::@7 to plexSort::@3 [phi:plexSort::@6/plexSort::@7->plexSort::@3]
  b3_from_b6:
  b3_from_b7:
  //SEG75 [39] phi (byte) plexSort::s#3 = (byte) plexSort::s#1 [phi:plexSort::@6/plexSort::@7->plexSort::@3#0] -- register_copy 
    jmp b3
  //SEG76 plexSort::@3
  b3:
  //SEG77 [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
  //SEG78 [41] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
  //SEG79 [42] if((byte) plexSort::s#1!=(byte/word/signed word/dword/signed dword) $ff) goto plexSort::@6 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne b6
    jmp b4
  //SEG80 plexSort::@4
  b4:
  //SEG81 [43] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
  //SEG82 [44] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda nxt_idx
    sta PLEX_SORTED_IDX,x
    jmp b2
  //SEG83 plexSort::@2
  b2:
  //SEG84 [45] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG85 [46] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 2+(byte/signed byte/word/signed word/dword/signed dword) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp m
    bne b1_from_b2
    jmp b5
  //SEG86 plexSort::@5
  b5:
  //SEG87 [47] (byte) plex_show_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta plex_show_idx
  //SEG88 [48] (byte) plex_sprite_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
    lda #0
    sta plex_sprite_idx_1
  //SEG89 [49] (byte) plex_sprite_msb#1 ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG90 [50] phi from plexSort::@5 to plexSort::plexFreePrepare1 [phi:plexSort::@5->plexSort::plexFreePrepare1]
  plexFreePrepare1_from_b5:
    jmp plexFreePrepare1
  //SEG91 plexSort::plexFreePrepare1
  plexFreePrepare1:
  //SEG92 [51] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1:
  //SEG93 [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp plexFreePrepare1_b1
  //SEG94 [51] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1_b1:
  //SEG95 [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1_b1
  //SEG96 plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
  //SEG97 [52] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
  //SEG98 [53] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG99 [54] if((byte) plexSort::plexFreePrepare1_s#1!=(byte/signed byte/word/signed word/dword/signed dword) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1_b1_from_plexFreePrepare1_b1
    jmp plexFreePrepare1_b2
  //SEG100 plexSort::plexFreePrepare1_@2
  plexFreePrepare1_b2:
  //SEG101 [55] (byte) plex_free_next#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
    lda #0
    sta plex_free_next
    jmp breturn
  //SEG102 plexSort::@return
  breturn:
  //SEG103 [56] return 
    rts
  //SEG104 plexSort::@6
  b6:
  //SEG105 [57] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_pbuc2_derefidx_vbuxx_then_la1 
    lda nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3_from_b6
    jmp b4
}
//SEG106 init
// Initialize the program
init: {
    .label xp = 5
  //SEG107 [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte/signed byte/word/signed word/dword/signed dword) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
  //SEG108 [59] call plexInit 
  //SEG109 [79] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
  //SEG110 [60] phi from init to init::@1 [phi:init->init::@1]
  b1_from_init:
  //SEG111 [60] phi (word) init::xp#2 = (byte/signed byte/word/signed word/dword/signed dword) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #$20
    sta xp
    lda #0
    sta xp+1
  //SEG112 [60] phi (byte) init::sx#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG113 [60] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
  //SEG114 [60] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
  //SEG115 [60] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp b1
  //SEG116 init::@1
  b1:
  //SEG117 [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← ((byte))(const byte*) SPRITE#0/(byte/signed byte/word/signed word/dword/signed dword) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #$ff&SPRITE/$40
    sta PLEX_PTR,x
  //SEG118 [62] (byte~) init::$7 ← (byte) init::sx#2 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG119 [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$7) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda xp
    sta PLEX_XPOS,y
    lda xp+1
    sta PLEX_XPOS+1,y
  //SEG120 [64] (word) init::xp#1 ← (word) init::xp#2 + (byte/signed byte/word/signed word/dword/signed dword) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc xp
    sta xp
    bcc !+
    inc xp+1
  !:
  //SEG121 [65] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG122 [66] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1_from_b1
    jmp b2
  //SEG123 init::@2
  b2:
  //SEG124 [67] *((const byte*) SPRITES_ENABLE#0) ← (byte/word/signed word/dword/signed dword) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
  //SEG125 [68] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
  //SEG126 [68] phi (byte) init::ss#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b3
  //SEG127 [68] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  b3_from_b3:
  //SEG128 [68] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp b3
  //SEG129 init::@3
  b3:
  //SEG130 [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
  //SEG131 [70] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG132 [71] if((byte) init::ss#1!=(byte/signed byte/word/signed word/dword/signed dword) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b3_from_b3
    jmp b4
  //SEG133 init::@4
  b4:
  //SEG134 asm { sei  }
    // enable the interrupt
    sei
  //SEG135 [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
  //SEG136 [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
  //SEG137 [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG138 [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() -- _deref_pptc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
  //SEG139 asm { cli  }
    cli
    jmp breturn
  //SEG140 init::@return
  breturn:
  //SEG141 [78] return 
    rts
}
//SEG142 plexInit
// Initialize the multiplexer data structures
plexInit: {
  //SEG143 [80] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
  //SEG144 plexInit::plexSetScreen1
  plexSetScreen1:
  //SEG145 [81] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  b1_from_plexSetScreen1:
  //SEG146 [81] phi (byte) plexInit::i#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG147 [81] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  b1_from_b1:
  //SEG148 [81] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp b1
  //SEG149 plexInit::@1
  b1:
  //SEG150 [82] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
  //SEG151 [83] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG152 [84] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1_from_b1
    jmp breturn
  //SEG153 plexInit::@return
  breturn:
  //SEG154 [85] return 
    rts
}
//SEG155 plex_irq
plex_irq: {
    .label _4 = $f
  //SEG156 entry interrupt(KERNEL_MIN)
  //SEG157 [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
  //SEG158 [87] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
  b3_from_plex_irq:
  b3_from_b7:
  //SEG159 [87] phi (byte) plex_sprite_msb#29 = (byte) plex_sprite_msb#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#0] -- register_copy 
  //SEG160 [87] phi (byte) plex_free_next#27 = (byte) plex_free_next#31 [phi:plex_irq/plex_irq::@7->plex_irq::@3#1] -- register_copy 
  //SEG161 [87] phi (byte) plex_show_idx#27 = (byte) plex_show_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#2] -- register_copy 
  //SEG162 [87] phi (byte) plex_sprite_idx#25 = (byte) plex_sprite_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#3] -- register_copy 
    jmp b3
  //SEG163 plex_irq::@3
  b3:
  //SEG164 [88] call plexShowSprite 
    jsr plexShowSprite
    jmp plexFreeNextYpos1
  //SEG165 plex_irq::plexFreeNextYpos1
  plexFreeNextYpos1:
  //SEG166 [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy plexShowSprite.plexFreeAdd1__2
    ldx PLEX_FREE_YPOS,y
    jmp b6
  //SEG167 plex_irq::@6
  b6:
  //SEG168 [90] (byte/signed word/word/dword/signed dword~) plex_irq::$4 ← *((const byte*) RASTER#0) + (byte/signed byte/word/signed word/dword/signed dword) 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta _4
  //SEG169 [91] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@7 -- vbuz1_lt_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcc b7
    jmp b4
  //SEG170 plex_irq::@4
  b4:
  //SEG171 [92] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG172 [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcc b1
    jmp b5
  //SEG173 plex_irq::@5
  b5:
  //SEG174 [94] (bool) framedone#3 ← true -- vboz1=vboc1 
    lda #1
    sta framedone
    jmp b2
  //SEG175 plex_irq::@2
  b2:
  //SEG176 [95] *((const byte*) BORDERCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDERCOL
    jmp breturn
  //SEG177 plex_irq::@return
  breturn:
  //SEG178 [96] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
  //SEG179 plex_irq::@1
  b1:
  //SEG180 [97] *((const byte*) RASTER#0) ← (byte) plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuxx 
    stx RASTER
    jmp b2
  //SEG181 plex_irq::@7
  b7:
  //SEG182 [98] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte/signed word/word/dword/signed dword~) plex_irq::$4) goto plex_irq::@3 -- vbuxx_lt_vbuz1_then_la1 
    cpx _4
    bcc b3_from_b7
    jmp b4
}
//SEG183 plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label _7 = 7
    .label plex_sprite_idx2 = $f
    .label plexFreeAdd1__2 = 9
  //SEG184 [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz2_rol_1 
    lda plex_sprite_idx
    asl
    sta plex_sprite_idx2
  //SEG185 [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- vbuaa=pbuc1_derefidx_pbuc2_derefidx_vbuz1 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
  //SEG186 [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
  //SEG187 plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
  //SEG188 [102] (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte/signed byte/word/signed word/dword/signed dword) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
  //SEG189 [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_free_next_27
    sta PLEX_FREE_YPOS,y
  //SEG190 [104] (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#27 + (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_free_next_27
    inx
  //SEG191 [105] (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 & (byte/signed byte/word/signed word/dword/signed dword) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax plexFreeAdd1__2
    jmp b5
  //SEG192 plexShowSprite::@5
  b5:
  //SEG193 [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_pbuc3_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
  //SEG194 [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuxx=pbuc1_derefidx_vbuz1_rol_1 
    ldx plex_show_idx
    lda PLEX_SORTED_IDX,x
    asl
    tax
  //SEG195 [108] (byte~) plexShowSprite::$3 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
  //SEG196 [109] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$3 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_XPOS,y
  //SEG197 [110] (byte~) plexShowSprite::$4 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
  //SEG198 [111] if((byte~) plexShowSprite::$4!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b1
    jmp b3
  //SEG199 plexShowSprite::@3
  b3:
  //SEG200 [112] (byte/word/dword~) plexShowSprite::$10 ← (byte/word/signed word/dword/signed dword) $ff ^ (byte) plex_sprite_msb#29 -- vbuaa=vbuc1_bxor_vbuz1 
    lda plex_sprite_msb
    eor #$ff
  //SEG201 [113] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte/word/dword~) plexShowSprite::$10 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    jmp b2
  //SEG202 plexShowSprite::@2
  b2:
  //SEG203 [114] (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 ← (byte) plex_sprite_idx#25 + (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_sprite_idx
    inx
  //SEG204 [115] (byte/word/dword~) plexShowSprite::$7 ← (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 & (byte/signed byte/word/signed word/dword/signed dword) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax _7
  //SEG205 [116] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27 -- vbuz1=_inc_vbuz1 
    inc plex_show_idx
  //SEG206 [117] (byte) plex_sprite_msb#27 ← (byte) plex_sprite_msb#29 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz1_rol_1 
    asl plex_sprite_msb
  //SEG207 [118] if((byte) plex_sprite_msb#27!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda plex_sprite_msb
    cmp #0
    bne breturn_from_b2
    jmp b4
  //SEG208 plexShowSprite::@4
  b4:
  //SEG209 [119] (byte) plex_sprite_msb#4 ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG210 [120] phi from plexShowSprite::@2 plexShowSprite::@4 to plexShowSprite::@return [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return]
  breturn_from_b2:
  breturn_from_b4:
  //SEG211 [120] phi (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#27 [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return#0] -- register_copy 
    jmp breturn
  //SEG212 plexShowSprite::@return
  breturn:
  //SEG213 [121] return 
    rts
  //SEG214 plexShowSprite::@1
  b1:
  //SEG215 [122] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#29 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = YSIN "YSIN"
  .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b6
Removing instruction jmp b1
Removing instruction jmp b7
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b2
Removing instruction jmp b5
Removing instruction jmp plexFreePrepare1
Removing instruction jmp plexFreePrepare1_b1
Removing instruction jmp plexFreePrepare1_b2
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp plexSetScreen1
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b3
Removing instruction jmp plexFreeNextYpos1
Removing instruction jmp b6
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp plexFreeAdd1
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Replacing instruction ldy nxt_idx with TAY
Removing instruction lda nxt_y
Removing instruction lda #0
Replacing instruction ldx #0 with TAX
Removing instruction lda #IRQ_RASTER
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b4_from_b4 with b4
Replacing label b1 with b2
Replacing label b1_from_b2 with b1
Replacing label plexFreePrepare1_b1_from_plexFreePrepare1_b1 with plexFreePrepare1_b1
Replacing label b3_from_b6 with b3
Replacing label b1_from_b1 with b1
Replacing label b3_from_b3 with b3
Replacing label b1_from_b1 with b1
Replacing label b3_from_b7 with b3
Replacing label breturn_from_b2 with breturn
Removing instruction b1:
Removing instruction b3:
Removing instruction b5_from_b4:
Removing instruction bend_from_b5:
Removing instruction b1_from_main:
Removing instruction loop_from_b1:
Removing instruction b1:
Removing instruction b4_from_b4:
Removing instruction b1_from_b2:
Removing instruction b3_from_b6:
Removing instruction b3_from_b7:
Removing instruction plexFreePrepare1_from_b5:
Removing instruction plexFreePrepare1_b1_from_plexFreePrepare1:
Removing instruction plexFreePrepare1_b1_from_plexFreePrepare1_b1:
Removing instruction b1_from_b1:
Removing instruction b3_from_b3:
Removing instruction plexSetScreen1_from_plexInit:
Removing instruction b1_from_plexSetScreen1:
Removing instruction b1_from_b1:
Removing instruction b3_from_plex_irq:
Removing instruction b3_from_b7:
Removing instruction breturn_from_b2:
Removing instruction breturn_from_b4:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b2:
Removing instruction b4:
Removing instruction b5:
Removing instruction bend:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_loop:
Removing instruction b4_from_b3:
Removing instruction b5:
Removing instruction plexSort_from_b5:
Removing instruction b6:
Removing instruction b1_from_b6:
Removing instruction b1_from_plexSort:
Removing instruction b7:
Removing instruction b5:
Removing instruction plexFreePrepare1:
Removing instruction plexFreePrepare1_b2:
Removing instruction breturn:
Removing instruction plexInit_from_init:
Removing instruction b1_from_init:
Removing instruction b2:
Removing instruction b3_from_b2:
Removing instruction b4:
Removing instruction breturn:
Removing instruction plexSetScreen1:
Removing instruction breturn:
Removing instruction plexFreeNextYpos1:
Removing instruction b6:
Removing instruction b5:
Removing instruction breturn:
Removing instruction plexFreeAdd1:
Removing instruction b5:
Removing instruction b3:
Removing instruction b4:
Succesful ASM optimization Pass5UnusedLabelElimination
Adding RTS to root block 
Succesful ASM optimization Pass5AddMainRts
Removing instruction jmp b4
Removing instruction jmp b1
Removing instruction jmp plexFreePrepare1_b1
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldx m
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination

FINAL SYMBOL TABLE
(label) @1
(label) @2
(label) @3
(label) @4
(label) @5
(label) @begin
(label) @end
(byte*) BGCOL
(byte*) BGCOL1
(byte*) BGCOL2
(byte*) BGCOL3
(byte*) BGCOL4
(byte) BLACK
(byte) BLUE
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = ((byte*))(word/dword/signed dword) $d020
(byte) BROWN
(byte*) CHARGEN
(byte*) CIA1_INTERRUPT
(const byte*) CIA1_INTERRUPT#0 CIA1_INTERRUPT = ((byte*))(word/dword/signed dword) $dc0d
(byte*) CIA1_PORT_A
(byte*) CIA1_PORT_A_DDR
(byte*) CIA1_PORT_B
(byte*) CIA1_PORT_B_DDR
(byte*) CIA2_INTERRUPT
(byte*) CIA2_PORT_A
(byte*) CIA2_PORT_A_DDR
(byte*) CIA2_PORT_B
(byte*) CIA2_PORT_B_DDR
(byte) CIA_INTERRUPT_CLEAR
(const byte) CIA_INTERRUPT_CLEAR#0 CIA_INTERRUPT_CLEAR = (byte/signed byte/word/signed word/dword/signed dword) $7f
(byte*) COLS
(byte) CYAN
(byte*) D011
(const byte*) D011#0 D011 = ((byte*))(word/dword/signed dword) $d011
(byte*) D016
(byte*) D018
(byte) DARK_GREY
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte/signed byte/word/signed word/dword/signed dword) 5
(byte) GREY
(void()**) HARDWARE_IRQ
(byte) IRQ_COLLISION_BG
(byte) IRQ_COLLISION_SPRITE
(byte*) IRQ_ENABLE
(const byte*) IRQ_ENABLE#0 IRQ_ENABLE = ((byte*))(word/dword/signed dword) $d01a
(byte) IRQ_LIGHTPEN
(byte) IRQ_RASTER
(const byte) IRQ_RASTER#0 IRQ_RASTER = (byte/signed byte/word/signed word/dword/signed dword) 1
(byte*) IRQ_STATUS
(const byte*) IRQ_STATUS#0 IRQ_STATUS = ((byte*))(word/dword/signed dword) $d019
(void()**) KERNEL_IRQ
(const void()**) KERNEL_IRQ#0 KERNEL_IRQ = ((void()**))(word/signed word/dword/signed dword) $314
(byte*) LIGHTPEN_X
(byte*) LIGHTPEN_Y
(byte) LIGHT_BLUE
(byte) LIGHT_GREEN
(byte) LIGHT_GREY
(byte) ORANGE
(byte) PINK
(byte) PLEX_COUNT
(const byte) PLEX_COUNT#0 PLEX_COUNT = (byte/signed byte/word/signed word/dword/signed dword) $20
(byte[8]) PLEX_FREE_YPOS
(const byte[8]) PLEX_FREE_YPOS#0 PLEX_FREE_YPOS = { fill( 8, 0) }
(byte[PLEX_COUNT#0]) PLEX_PTR
(const byte[PLEX_COUNT#0]) PLEX_PTR#0 PLEX_PTR = { fill( PLEX_COUNT#0, 0) }
(byte*) PLEX_SCREEN_PTR
(const byte*) PLEX_SCREEN_PTR#0 PLEX_SCREEN_PTR = ((byte*))(word/signed word/dword/signed dword) $400+(word/signed word/dword/signed dword) $3f8
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 PLEX_SORTED_IDX = { fill( PLEX_COUNT#0, 0) }
(word[PLEX_COUNT#0]) PLEX_XPOS
(const word[PLEX_COUNT#0]) PLEX_XPOS#0 PLEX_XPOS = { fill( PLEX_COUNT#0, 0) }
(byte[PLEX_COUNT#0]) PLEX_YPOS
(const byte[PLEX_COUNT#0]) PLEX_YPOS#0 PLEX_YPOS = { fill( PLEX_COUNT#0, 0) }
(byte*) PROCPORT
(byte) PROCPORT_BASIC_KERNEL_IO
(byte*) PROCPORT_DDR
(byte) PROCPORT_DDR_MEMORY_MASK
(byte) PROCPORT_KERNEL_IO
(byte) PROCPORT_RAM_ALL
(byte) PROCPORT_RAM_CHARROM
(byte) PROCPORT_RAM_IO
(byte) PURPLE
(byte*) RASTER
(const byte*) RASTER#0 RASTER = ((byte*))(word/dword/signed dword) $d012
(byte) RED
(const byte) RED#0 RED = (byte/signed byte/word/signed word/dword/signed dword) 2
(byte*) SCREEN
(byte*) SPRITE
(const byte*) SPRITE#0 SPRITE = ((byte*))(word/signed word/dword/signed dword) $2000
(byte*) SPRITES_COLS
(const byte*) SPRITES_COLS#0 SPRITES_COLS = ((byte*))(word/dword/signed dword) $d027
(byte*) SPRITES_ENABLE
(const byte*) SPRITES_ENABLE#0 SPRITES_ENABLE = ((byte*))(word/dword/signed dword) $d015
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_MC
(byte*) SPRITES_MC1
(byte*) SPRITES_MC2
(byte*) SPRITES_PRIORITY
(byte*) SPRITES_XMSB
(const byte*) SPRITES_XMSB#0 SPRITES_XMSB = ((byte*))(word/dword/signed dword) $d010
(byte*) SPRITES_XPOS
(const byte*) SPRITES_XPOS#0 SPRITES_XPOS = ((byte*))(word/dword/signed dword) $d000
(byte*) SPRITES_YPOS
(const byte*) SPRITES_YPOS#0 SPRITES_YPOS = ((byte*))(word/dword/signed dword) $d001
(word) SPRITE_PTRS
(byte) VIC_BMM
(byte*) VIC_CONTROL
(const byte*) VIC_CONTROL#0 VIC_CONTROL = ((byte*))(word/dword/signed dword) $d011
(byte*) VIC_CONTROL2
(byte) VIC_CSEL
(byte) VIC_DEN
(const byte) VIC_DEN#0 VIC_DEN = (byte/signed byte/word/signed word/dword/signed dword) $10
(byte) VIC_ECM
(byte) VIC_MCM
(byte*) VIC_MEMORY
(byte) VIC_RSEL
(const byte) VIC_RSEL#0 VIC_RSEL = (byte/signed byte/word/signed word/dword/signed dword) 8
(byte) VIC_RST8
(byte) WHITE
(const byte) WHITE#0 WHITE = (byte/signed byte/word/signed word/dword/signed dword) 1
(byte) YELLOW
(byte*) YSIN
(const byte*) YSIN#0 YSIN = ((byte*))(word/signed word/dword/signed dword) $2100
(bool) framedone
(bool) framedone#12 framedone zp ZP_BOOL:2 57.0
(bool) framedone#19 framedone zp ZP_BOOL:2 0.6666666666666666
(bool) framedone#3 framedone zp ZP_BOOL:2 20.0
(bool) framedone#5 framedone zp ZP_BOOL:2 7.333333333333333
(void()) init()
(byte~) init::$7 reg byte a 22.0
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@return
(byte) init::ss
(byte) init::ss#1 reg byte x 16.5
(byte) init::ss#2 reg byte x 16.5
(byte) init::sx
(byte) init::sx#1 reg byte x 16.5
(byte) init::sx#2 reg byte x 8.8
(word) init::xp
(word) init::xp#1 xp zp ZP_WORD:5 7.333333333333333
(word) init::xp#2 xp zp ZP_WORD:5 8.25
(void()) loop()
(label) loop::@1
(label) loop::@2
(label) loop::@3
(label) loop::@4
(label) loop::@5
(label) loop::@6
(byte) loop::sin_idx
(byte) loop::sin_idx#1 sin_idx zp ZP_BYTE:3 3.142857142857143
(byte) loop::sin_idx#6 sin_idx zp ZP_BYTE:3 3.666666666666667
(byte) loop::sy
(byte) loop::sy#1 reg byte y 151.5
(byte) loop::sy#2 reg byte y 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 reg byte x 67.33333333333333
(byte) loop::y_idx#2 reg byte x 157.0
(byte~) loop::y_idx#4 reg byte x 22.0
(void()) main()
(label) main::@1
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(label) plexInit::@1
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#1 reg byte x 16.5
(byte) plexInit::i#2 reg byte x 22.0
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte/word/dword~) plexShowSprite::$10 reg byte a 4.0
(byte~) plexShowSprite::$3 reg byte a 4.0
(byte~) plexShowSprite::$4 reg byte a 4.0
(byte/signed word/word/dword/signed dword~) plexShowSprite::$6 reg byte x 4.0
(byte/word/dword~) plexShowSprite::$7 $7 zp ZP_BYTE:7 1.0833333333333333
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@3
(label) plexShowSprite::@4
(label) plexShowSprite::@5
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(byte/signed word/word/dword/signed dword~) plexShowSprite::plexFreeAdd1_$0
(byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 reg byte a 4.0
(byte/signed word/word/dword/signed dword~) plexShowSprite::plexFreeAdd1_$1
(byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 reg byte x 4.0
(byte/word/dword~) plexShowSprite::plexFreeAdd1_$2
(byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 plexFreeAdd1_$2 zp ZP_BYTE:9 1.0434782608695652
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 reg byte a 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 plex_sprite_idx2 zp ZP_BYTE:15 0.6000000000000001
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 reg byte x 2.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@7
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#1 m zp ZP_BYTE:4 151.5
(byte) plexSort::m#2 m zp ZP_BYTE:4 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 nxt_idx zp ZP_BYTE:11 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 nxt_y zp ZP_BYTE:12 150.375
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(label) plexSort::plexFreePrepare1_@1
(label) plexSort::plexFreePrepare1_@2
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 reg byte x 151.5
(byte) plexSort::plexFreePrepare1_s#2 reg byte x 151.5
(byte) plexSort::s
(byte) plexSort::s#1 reg byte x 1368.3333333333335
(byte) plexSort::s#2 reg byte x 202.0
(byte) plexSort::s#3 reg byte x 2052.5
(byte~) plexSort::s#6 reg byte x 202.0
(byte) plex_free_next
(byte) plex_free_next#0 plex_free_next zp ZP_BYTE:14 20.0
(byte) plex_free_next#27 plex_free_next#27 zp ZP_BYTE:9 2.8333333333333335
(byte) plex_free_next#31 plex_free_next#31 zp ZP_BYTE:9 4.0
interrupt(KERNEL_MIN)(void()) plex_irq()
(byte/signed word/word/dword/signed dword~) plex_irq::$4 $4 zp ZP_BYTE:15 11.0
(label) plex_irq::@1
(label) plex_irq::@2
(label) plex_irq::@3
(label) plex_irq::@4
(label) plex_irq::@5
(label) plex_irq::@6
(label) plex_irq::@7
(label) plex_irq::@return
(label) plex_irq::plexFreeNextYpos1
(byte) plex_irq::plexFreeNextYpos1_return
(byte) plex_irq::plexFreeNextYpos1_return#0 reg byte x 4.0
(byte) plex_irq::rasterY
(byte) plex_show_idx
(byte) plex_show_idx#0 plex_show_idx zp ZP_BYTE:8 4.0
(byte) plex_show_idx#1 plex_show_idx zp ZP_BYTE:8 20.0
(byte) plex_show_idx#16 plex_show_idx zp ZP_BYTE:8 2.1666666666666665
(byte) plex_show_idx#27 plex_show_idx zp ZP_BYTE:8 1.1052631578947367
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0 plex_sprite_idx zp ZP_BYTE:7 4.0
(byte) plex_sprite_idx#1 plex_sprite_idx#1 zp ZP_BYTE:13 20.0
(byte) plex_sprite_idx#25 plex_sprite_idx zp ZP_BYTE:7 1.1176470588235294
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0 plex_sprite_msb zp ZP_BYTE:10 4.0
(byte) plex_sprite_msb#1 plex_sprite_msb zp ZP_BYTE:10 20.0
(byte) plex_sprite_msb#17 plex_sprite_msb zp ZP_BYTE:10 2.142857142857143
(byte) plex_sprite_msb#27 plex_sprite_msb zp ZP_BYTE:10 3.0
(byte) plex_sprite_msb#29 plex_sprite_msb zp ZP_BYTE:10 0.95
(byte) plex_sprite_msb#4 plex_sprite_msb zp ZP_BYTE:10 4.0

zp ZP_BOOL:2 [ framedone#12 framedone#19 framedone#5 framedone#3 ]
zp ZP_BYTE:3 [ loop::sin_idx#6 loop::sin_idx#1 ]
reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
reg byte y [ loop::sy#2 loop::sy#1 ]
zp ZP_BYTE:4 [ plexSort::m#2 plexSort::m#1 ]
reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
reg byte x [ init::sx#2 init::sx#1 ]
zp ZP_WORD:5 [ init::xp#2 init::xp#1 ]
reg byte x [ init::ss#2 init::ss#1 ]
reg byte x [ plexInit::i#2 plexInit::i#1 ]
zp ZP_BYTE:7 [ plex_sprite_idx#25 plex_sprite_idx#0 plexShowSprite::$7 ]
zp ZP_BYTE:8 [ plex_show_idx#27 plex_show_idx#0 plex_show_idx#16 plex_show_idx#1 ]
zp ZP_BYTE:9 [ plex_free_next#27 plex_free_next#31 plexShowSprite::plexFreeAdd1_$2#0 ]
zp ZP_BYTE:10 [ plex_sprite_msb#29 plex_sprite_msb#0 plex_sprite_msb#17 plex_sprite_msb#27 plex_sprite_msb#4 plex_sprite_msb#1 ]
zp ZP_BYTE:11 [ plexSort::nxt_idx#0 ]
zp ZP_BYTE:12 [ plexSort::nxt_y#0 ]
reg byte x [ plexSort::s#2 ]
zp ZP_BYTE:13 [ plex_sprite_idx#1 ]
zp ZP_BYTE:14 [ plex_free_next#0 ]
reg byte a [ init::$7 ]
reg byte x [ plex_irq::plexFreeNextYpos1_return#0 ]
zp ZP_BYTE:15 [ plex_irq::$4 plexShowSprite::plex_sprite_idx2#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$0#0 ]
reg byte x [ plexShowSprite::plexFreeAdd1_$1#0 ]
reg byte x [ plexShowSprite::xpos_idx#0 ]
reg byte a [ plexShowSprite::$3 ]
reg byte a [ plexShowSprite::$4 ]
reg byte a [ plexShowSprite::$10 ]
reg byte x [ plexShowSprite::$6 ]


FINAL ASSEMBLER
Score: 47278

//SEG0 File Comments
// A simple usage of the flexible sprite multiplexer routine
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label VIC_CONTROL = $d011
  .label D011 = $d011
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // VIC II IRQ Status Register
  .label IRQ_STATUS = $d019
  // VIC II IRQ Enable Register
  .label IRQ_ENABLE = $d01a
  // Bits for the IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // CIA#1 Interrupt Status & Control Register
  .label CIA1_INTERRUPT = $dc0d
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .label SPRITE = $2000
  .label YSIN = $2100
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = $400+$3f8
  .label plex_show_idx = 8
  .label plex_sprite_idx = 7
  .label plex_sprite_msb = $a
  .label plex_sprite_idx_1 = $d
  .label plex_free_next = $e
  .label framedone = 2
  .label plex_free_next_27 = 9
  .label plex_free_next_31 = 9
//SEG3 @begin
bbegin:
//SEG4 @1
//SEG5 [1] (byte) plex_show_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  // The index in the PLEX tables of the next sprite to show
  lda #0
  sta plex_show_idx
//SEG6 [2] (byte) plex_sprite_idx#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  // The index the next sprite to use for showing (sprites are used round-robin)
  sta plex_sprite_idx
//SEG7 [3] (byte) plex_sprite_msb#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuc1 
  // The MSB bit of the next sprite to use for showing
  lda #1
  sta plex_sprite_msb
//SEG8 @2
//SEG9 [4] (byte) plex_free_next#31 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  lda #0
  sta plex_free_next_31
//SEG10 @3
//SEG11 kickasm(location (const byte*) YSIN#0) {{ .var min = 50     .var max = 250-21     .var ampl = max-min;     .for(var i=0;i<256;i++)         .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))  }}
//SEG12 kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
//SEG13 @4
//SEG14 [7] (bool) framedone#19 ← true -- vboz1=vboc1 
  lda #1
  sta framedone
//SEG15 [8] phi from @4 to @5 [phi:@4->@5]
//SEG16 @5
//SEG17 [9] call main 
  jsr main
  rts
//SEG18 [10] phi from @5 to @end [phi:@5->@end]
//SEG19 @end
//SEG20 main
main: {
  //SEG21 asm { sei  }
    sei
  //SEG22 [12] call init 
    jsr init
  //SEG23 [13] phi from main to main::@1 [phi:main->main::@1]
  //SEG24 main::@1
  //SEG25 [14] call loop 
  //SEG26 [16] phi from main::@1 to loop [phi:main::@1->loop]
    jsr loop
  //SEG27 main::@return
  //SEG28 [15] return 
    rts
}
//SEG29 loop
// The raster loop
loop: {
    .label sin_idx = 3
  //SEG30 [17] phi from loop to loop::@1 [phi:loop->loop::@1]
  //SEG31 [17] phi (byte) loop::sin_idx#6 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta sin_idx
  //SEG32 [17] phi (bool) framedone#12 = (bool) framedone#19 [phi:loop->loop::@1#1] -- register_copy 
  //SEG33 loop::@1
  //SEG34 loop::@2
  b2:
  //SEG35 [18] if((bool) framedone#12) goto loop::@3 -- vboz1_then_la1 
    lda framedone
    cmp #0
    bne b3
    jmp b2
  //SEG36 loop::@3
  b3:
  //SEG37 [19] *((const byte*) BORDERCOL#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BORDERCOL
  //SEG38 [20] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx sin_idx
  //SEG39 [21] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  //SEG40 [21] phi (byte) loop::sy#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
  //SEG41 [21] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
  //SEG42 [21] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  //SEG43 [21] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
  //SEG44 [21] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
  //SEG45 loop::@4
  b4:
  //SEG46 [22] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
  //SEG47 [23] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte/signed byte/word/signed word/dword/signed dword) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
  //SEG48 [24] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG49 [25] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne b4
  //SEG50 loop::@5
  //SEG51 [26] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz1_plus_1 
    inc sin_idx
  //SEG52 [27] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG53 [28] call plexSort 
  //SEG54 [33] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
    jsr plexSort
  //SEG55 loop::@6
  //SEG56 [29] *((const byte*) BORDERCOL#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BORDERCOL
  //SEG57 [30] (bool) framedone#5 ← false -- vboz1=vboc1 
    lda #0
    sta framedone
  //SEG58 [31] *((const byte*) VIC_CONTROL#0) ← *((const byte*) VIC_CONTROL#0) & (byte/signed byte/word/signed word/dword/signed dword) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VIC_CONTROL
    sta VIC_CONTROL
  //SEG59 [32] *((const byte*) RASTER#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta RASTER
  //SEG60 [17] phi from loop::@6 to loop::@1 [phi:loop::@6->loop::@1]
  //SEG61 [17] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@6->loop::@1#0] -- register_copy 
  //SEG62 [17] phi (bool) framedone#12 = (bool) framedone#5 [phi:loop::@6->loop::@1#1] -- register_copy 
    jmp b2
}
//SEG63 plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $b
    .label nxt_y = $c
    .label m = 4
  //SEG64 [34] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  //SEG65 [34] phi (byte) plexSort::m#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta m
  //SEG66 [34] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  //SEG67 [34] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
  //SEG68 plexSort::@1
  b1:
  //SEG69 [35] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy m
    lda PLEX_SORTED_IDX+1,y
    sta nxt_idx
  //SEG70 [36] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    tay
    lda PLEX_YPOS,y
    sta nxt_y
  //SEG71 [37] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    ldx m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
  //SEG72 plexSort::@7
  //SEG73 [38] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
  //SEG74 [39] phi from plexSort::@6 plexSort::@7 to plexSort::@3 [phi:plexSort::@6/plexSort::@7->plexSort::@3]
  //SEG75 [39] phi (byte) plexSort::s#3 = (byte) plexSort::s#1 [phi:plexSort::@6/plexSort::@7->plexSort::@3#0] -- register_copy 
  //SEG76 plexSort::@3
  b3:
  //SEG77 [40] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
  //SEG78 [41] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
  //SEG79 [42] if((byte) plexSort::s#1!=(byte/word/signed word/dword/signed dword) $ff) goto plexSort::@6 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne b6
  //SEG80 plexSort::@4
  b4:
  //SEG81 [43] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
  //SEG82 [44] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda nxt_idx
    sta PLEX_SORTED_IDX,x
  //SEG83 plexSort::@2
  b2:
  //SEG84 [45] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG85 [46] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 2+(byte/signed byte/word/signed word/dword/signed dword) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp m
    bne b1
  //SEG86 plexSort::@5
  //SEG87 [47] (byte) plex_show_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta plex_show_idx
  //SEG88 [48] (byte) plex_sprite_idx#1 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
    sta plex_sprite_idx_1
  //SEG89 [49] (byte) plex_sprite_msb#1 ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG90 [50] phi from plexSort::@5 to plexSort::plexFreePrepare1 [phi:plexSort::@5->plexSort::plexFreePrepare1]
  //SEG91 plexSort::plexFreePrepare1
  //SEG92 [51] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  //SEG93 [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG94 [51] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  //SEG95 [51] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
  //SEG96 plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
  //SEG97 [52] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
  //SEG98 [53] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG99 [54] if((byte) plexSort::plexFreePrepare1_s#1!=(byte/signed byte/word/signed word/dword/signed dword) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1_b1
  //SEG100 plexSort::plexFreePrepare1_@2
  //SEG101 [55] (byte) plex_free_next#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- vbuz1=vbuc1 
    sta plex_free_next
  //SEG102 plexSort::@return
  //SEG103 [56] return 
    rts
  //SEG104 plexSort::@6
  b6:
  //SEG105 [57] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_pbuc2_derefidx_vbuxx_then_la1 
    lda nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3
    jmp b4
}
//SEG106 init
// Initialize the program
init: {
    .label xp = 5
  //SEG107 [58] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte/signed byte/word/signed word/dword/signed dword) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
  //SEG108 [59] call plexInit 
  //SEG109 [79] phi from init to plexInit [phi:init->plexInit]
    jsr plexInit
  //SEG110 [60] phi from init to init::@1 [phi:init->init::@1]
  //SEG111 [60] phi (word) init::xp#2 = (byte/signed byte/word/signed word/dword/signed dword) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #$20
    sta xp
    lda #0
    sta xp+1
  //SEG112 [60] phi (byte) init::sx#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    tax
  //SEG113 [60] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  //SEG114 [60] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
  //SEG115 [60] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
  //SEG116 init::@1
  b1:
  //SEG117 [61] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← ((byte))(const byte*) SPRITE#0/(byte/signed byte/word/signed word/dword/signed dword) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #$ff&SPRITE/$40
    sta PLEX_PTR,x
  //SEG118 [62] (byte~) init::$7 ← (byte) init::sx#2 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG119 [63] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$7) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda xp
    sta PLEX_XPOS,y
    lda xp+1
    sta PLEX_XPOS+1,y
  //SEG120 [64] (word) init::xp#1 ← (word) init::xp#2 + (byte/signed byte/word/signed word/dword/signed dword) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc xp
    sta xp
    bcc !+
    inc xp+1
  !:
  //SEG121 [65] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG122 [66] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1
  //SEG123 init::@2
  //SEG124 [67] *((const byte*) SPRITES_ENABLE#0) ← (byte/word/signed word/dword/signed dword) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
  //SEG125 [68] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  //SEG126 [68] phi (byte) init::ss#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG127 [68] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  //SEG128 [68] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
  //SEG129 init::@3
  b3:
  //SEG130 [69] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
  //SEG131 [70] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG132 [71] if((byte) init::ss#1!=(byte/signed byte/word/signed word/dword/signed dword) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b3
  //SEG133 init::@4
  //SEG134 asm { sei  }
    // enable the interrupt
    sei
  //SEG135 [73] *((const byte*) CIA1_INTERRUPT#0) ← (const byte) CIA_INTERRUPT_CLEAR#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1_INTERRUPT
  //SEG136 [74] *((const byte*) IRQ_ENABLE#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_ENABLE
  //SEG137 [75] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    sta IRQ_STATUS
  //SEG138 [76] *((const void()**) KERNEL_IRQ#0) ← &interrupt(KERNEL_MIN)(void()) plex_irq() -- _deref_pptc1=pprc2 
    lda #<plex_irq
    sta KERNEL_IRQ
    lda #>plex_irq
    sta KERNEL_IRQ+1
  //SEG139 asm { cli  }
    cli
  //SEG140 init::@return
  //SEG141 [78] return 
    rts
}
//SEG142 plexInit
// Initialize the multiplexer data structures
plexInit: {
  //SEG143 [80] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  //SEG144 plexInit::plexSetScreen1
  //SEG145 [81] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  //SEG146 [81] phi (byte) plexInit::i#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG147 [81] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  //SEG148 [81] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
  //SEG149 plexInit::@1
  b1:
  //SEG150 [82] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
  //SEG151 [83] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG152 [84] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte/signed byte/word/signed word/dword/signed dword) 1+(byte/signed byte/word/signed word/dword/signed dword) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1
  //SEG153 plexInit::@return
  //SEG154 [85] return 
    rts
}
//SEG155 plex_irq
plex_irq: {
    .label _4 = $f
  //SEG156 entry interrupt(KERNEL_MIN)
  //SEG157 [86] *((const byte*) BORDERCOL#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta BORDERCOL
  //SEG158 [87] phi from plex_irq plex_irq::@7 to plex_irq::@3 [phi:plex_irq/plex_irq::@7->plex_irq::@3]
  //SEG159 [87] phi (byte) plex_sprite_msb#29 = (byte) plex_sprite_msb#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#0] -- register_copy 
  //SEG160 [87] phi (byte) plex_free_next#27 = (byte) plex_free_next#31 [phi:plex_irq/plex_irq::@7->plex_irq::@3#1] -- register_copy 
  //SEG161 [87] phi (byte) plex_show_idx#27 = (byte) plex_show_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#2] -- register_copy 
  //SEG162 [87] phi (byte) plex_sprite_idx#25 = (byte) plex_sprite_idx#0 [phi:plex_irq/plex_irq::@7->plex_irq::@3#3] -- register_copy 
  //SEG163 plex_irq::@3
  b3:
  //SEG164 [88] call plexShowSprite 
    jsr plexShowSprite
  //SEG165 plex_irq::plexFreeNextYpos1
  //SEG166 [89] (byte) plex_irq::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy plexShowSprite.plexFreeAdd1__2
    ldx PLEX_FREE_YPOS,y
  //SEG167 plex_irq::@6
  //SEG168 [90] (byte/signed word/word/dword/signed dword~) plex_irq::$4 ← *((const byte*) RASTER#0) + (byte/signed byte/word/signed word/dword/signed dword) 2 -- vbuz1=_deref_pbuc1_plus_2 
    lda RASTER
    clc
    adc #2
    sta _4
  //SEG169 [91] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@7 -- vbuz1_lt_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcc b7
  //SEG170 plex_irq::@4
  b4:
  //SEG171 [92] *((const byte*) IRQ_STATUS#0) ← (const byte) IRQ_RASTER#0 -- _deref_pbuc1=vbuc2 
    lda #IRQ_RASTER
    sta IRQ_STATUS
  //SEG172 [93] if((byte) plex_show_idx#16<(const byte) PLEX_COUNT#0) goto plex_irq::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda plex_show_idx
    cmp #PLEX_COUNT
    bcc b1
  //SEG173 plex_irq::@5
  //SEG174 [94] (bool) framedone#3 ← true -- vboz1=vboc1 
    lda #1
    sta framedone
  //SEG175 plex_irq::@2
  b2:
  //SEG176 [95] *((const byte*) BORDERCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta BORDERCOL
  //SEG177 plex_irq::@return
  //SEG178 [96] return  - exit interrupt(KERNEL_MIN)
    jmp $ea81
  //SEG179 plex_irq::@1
  b1:
  //SEG180 [97] *((const byte*) RASTER#0) ← (byte) plex_irq::plexFreeNextYpos1_return#0 -- _deref_pbuc1=vbuxx 
    stx RASTER
    jmp b2
  //SEG181 plex_irq::@7
  b7:
  //SEG182 [98] if((byte) plex_irq::plexFreeNextYpos1_return#0<(byte/signed word/word/dword/signed dword~) plex_irq::$4) goto plex_irq::@3 -- vbuxx_lt_vbuz1_then_la1 
    cpx _4
    bcc b3
    jmp b4
}
//SEG183 plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label _7 = 7
    .label plex_sprite_idx2 = $f
    .label plexFreeAdd1__2 = 9
  //SEG184 [99] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#25 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz2_rol_1 
    lda plex_sprite_idx
    asl
    sta plex_sprite_idx2
  //SEG185 [100] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- vbuaa=pbuc1_derefidx_pbuc2_derefidx_vbuz1 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
  //SEG186 [101] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_YPOS,y
  //SEG187 plexShowSprite::plexFreeAdd1
  //SEG188 [102] (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte/signed byte/word/signed word/dword/signed dword) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
  //SEG189 [103] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#27) ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_free_next_27
    sta PLEX_FREE_YPOS,y
  //SEG190 [104] (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#27 + (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_free_next_27
    inx
  //SEG191 [105] (byte/word/dword) plexShowSprite::plexFreeAdd1_$2#0 ← (byte/signed word/word/dword/signed dword) plexShowSprite::plexFreeAdd1_$1#0 & (byte/signed byte/word/signed word/dword/signed dword) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax plexFreeAdd1__2
  //SEG192 plexShowSprite::@5
  //SEG193 [106] *((const byte*) PLEX_SCREEN_PTR#0 + (byte) plex_sprite_idx#25) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_pbuc3_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
  //SEG194 [107] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#27) << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuxx=pbuc1_derefidx_vbuz1_rol_1 
    ldx plex_show_idx
    lda PLEX_SORTED_IDX,x
    asl
    tax
  //SEG195 [108] (byte~) plexShowSprite::$3 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
  //SEG196 [109] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$3 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_XPOS,y
  //SEG197 [110] (byte~) plexShowSprite::$4 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte) plexShowSprite::xpos_idx#0) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
  //SEG198 [111] if((byte~) plexShowSprite::$4!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b1
  //SEG199 plexShowSprite::@3
  //SEG200 [112] (byte/word/dword~) plexShowSprite::$10 ← (byte/word/signed word/dword/signed dword) $ff ^ (byte) plex_sprite_msb#29 -- vbuaa=vbuc1_bxor_vbuz1 
    lda plex_sprite_msb
    eor #$ff
  //SEG201 [113] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte/word/dword~) plexShowSprite::$10 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
  //SEG202 plexShowSprite::@2
  b2:
  //SEG203 [114] (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 ← (byte) plex_sprite_idx#25 + (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_sprite_idx
    inx
  //SEG204 [115] (byte/word/dword~) plexShowSprite::$7 ← (byte/signed word/word/dword/signed dword~) plexShowSprite::$6 & (byte/signed byte/word/signed word/dword/signed dword) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax _7
  //SEG205 [116] (byte) plex_show_idx#16 ← ++ (byte) plex_show_idx#27 -- vbuz1=_inc_vbuz1 
    inc plex_show_idx
  //SEG206 [117] (byte) plex_sprite_msb#27 ← (byte) plex_sprite_msb#29 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz1_rol_1 
    asl plex_sprite_msb
  //SEG207 [118] if((byte) plex_sprite_msb#27!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda plex_sprite_msb
    cmp #0
    bne breturn
  //SEG208 plexShowSprite::@4
  //SEG209 [119] (byte) plex_sprite_msb#4 ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG210 [120] phi from plexShowSprite::@2 plexShowSprite::@4 to plexShowSprite::@return [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return]
  //SEG211 [120] phi (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#27 [phi:plexShowSprite::@2/plexShowSprite::@4->plexShowSprite::@return#0] -- register_copy 
  //SEG212 plexShowSprite::@return
  breturn:
  //SEG213 [121] return 
    rts
  //SEG214 plexShowSprite::@1
  b1:
  //SEG215 [122] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#29 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = YSIN "YSIN"
  .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


