ASMish - Assembler Like Language that is Optimizable for 6502

Design Goals:
- Ability to generate optimized 6502 assembler code.
- Very close to assembler allowing direct translation.
- Optimizing register allocation (registers, zeropage, stack, memory, self-modifying code)
- Optimizing parameter parsing to sub routines (via register, stack, zeropage, memory, modifying routine, fetching from caller, sw stack, ...)
- Optimizing by inlining sub soutines
- MAYBE: Optimizing by knowledge of runtime usage (#calls, actual value space of variables/parameters, ...)
- MAYBE: Optimize by swapping or modifying operations. (moving code out of loops or subroutines, precalculating constants)
- MAYBE/TODO: Graph of statements/operations - specifying what *must* be executed in sequence. All else can be swapped around freely during optimization.


- Existing Method: Single Static Assignment Form - Compiler Optimization



Language Features
- Variables 
- Subroutines (non-recursive)
- Operations (mov, add, sub, ...)
- Adressing modes (variable, indirect, indirect sum, lo/hi-variable)

literals
--------
12 - decimal
$12 - hexadecimal - ASM-style
$d020 - hexadecimal word - ASM-style
0x12 - hexadecimal - C-style
%010101 - binary - ASM-style

8/16-bit variable declarations (local/global)
---------------------------------------------
byte a  // 8 bit variable usable for  operations or memory access (zeropage).
word b 	// 16bit variable usable for operations or for accessing memory.
del b 	// delete b (only local variables)

TODO: should delete be explicit or implicit?

operations
----------
mov a, b  // b = a
add a, b  // b += a
sub a, b  // b -= a
inc a     // a++  
dec a     // a--
and a, b  // b &= a
or a, b   // b |= a
xor a, b  // b ^= a
not a     // a ~= a
rol a     // a<< 
ror a     // a>>
mul2 a    // a *= 2 - short for rol a / a<<
div2 a    // a /= 2 - short for ror a / a>>

TODO: w/wo carry for 8/16-bit add/sub/rol/ror/inc/...

memory-access (indirect adressing)
-------------
mov a, [b]   // Indirect on b. b can be byte or word. bytes point to zeropage.
mov a, [b+c] // Indirect on b+c. 

lo/hi-access og 16bit variables (lo/hi-adressing)
-------------------------------
mov a, <b  	// moves a to low part of b. a must be a byte, b must be a word.
mov <a, >b  // moves low part of a to high part of b. a must be a word, b must be a word.

subroutine declaration with return
----------------------
sub byte fill(word a, word b, byte c) {
	...
	ret d
}

subroutine call with/without return value
---------------
mov d, call fill(a, b, c)	// d = fill(a,b,c) - with return
call fill(a, b, c)  		// fill(a,b,c) - without return



TODO: Conditionals / comparisions
TODO: Branching
TODO: Looping
TODO: Jumping
TODO: Tables in memory
TODO: Strings
TODO: Annotations that guide / show register allocations
TODO: Stack operations
MAYBE: Recursive sub routines
