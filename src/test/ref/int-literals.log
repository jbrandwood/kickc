Resolving typeid() testSimpleTypes::$0 = typeid  $c
Resolving typeid() testSimpleTypes::$2 = typeid  $c
Resolving typeid() testSimpleTypes::$4 = typeid  $c
Resolving typeid() testSimpleTypes::$6 = typeid  $c
Resolving typeid() testSimpleTypes::$8 = typeid  $c
Resolving typeid() testSimpleTypes::$10 = typeid  $c
Resolving typeid() testSimpleTypes::$12 = typeid  $c
Resolving typeid() testSimpleTypes::$14 = typeid  $c
Resolving typeid() testSimpleTypes::$16 = typeid  $c
Resolving typeid() testSimpleTypes::$18 = typeid  $c
Resolving typeid() testSimpleTypes::$20 = typeid  $c
Resolving typeid() testSimpleTypes::$22 = typeid  $c
Resolving typeid() testSimpleTypes::$24 = typeid  $c
Resolving typeid() testSimpleTypes::$26 = typeid  $c
Resolving typeid() testSimpleTypes::$28 = typeid  $c
Resolving typeid() testSimpleTypes::$30 = typeid  $c
Inlined call call __init

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  idx#54 = phi( __start::@1/idx#52 )
  main::s#0 = SCREEN
  to:main::@1
main::@1: scope:[main]  from main main::@2
  idx#53 = phi( main/idx#54, main::@2/idx#55 )
  main::s#2 = phi( main/main::s#0, main::@2/main::s#1 )
  main::$1 = main::s#2 < SCREEN+$3e8
  if(main::$1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  idx#55 = phi( main::@1/idx#53 )
  main::s#3 = phi( main::@1/main::s#2 )
  *main::s#3 = ' '
  main::s#1 = ++ main::s#3
  to:main::@1
main::@3: scope:[main]  from main::@1
  idx#50 = phi( main::@1/idx#53 )
  call testSimpleTypes
  to:main::@4
main::@4: scope:[main]  from main::@3
  idx#25 = phi( main::@3/idx#19 )
  idx#0 = idx#25
  to:main::@return
main::@return: scope:[main]  from main::@4
  idx#26 = phi( main::@4/idx#0 )
  idx#1 = idx#26
  return 
  to:@return

void testSimpleTypes()
testSimpleTypes: scope:[testSimpleTypes]  from main::@3
  idx#2 = 0
  testSimpleTypes::$0 = TYPEID_CHAR
  assertType::t1#0 = testSimpleTypes::$0
  assertType::t2#0 = TYPEID_CHAR
  call assertType
  to:testSimpleTypes::@1
testSimpleTypes::@1: scope:[testSimpleTypes]  from testSimpleTypes
  idx#27 = phi( testSimpleTypes/idx#21 )
  idx#3 = idx#27
  testSimpleTypes::$2 = TYPEID_CHAR
  assertType::t1#1 = testSimpleTypes::$2
  assertType::t2#1 = TYPEID_CHAR
  call assertType
  to:testSimpleTypes::@2
testSimpleTypes::@2: scope:[testSimpleTypes]  from testSimpleTypes::@1
  idx#28 = phi( testSimpleTypes::@1/idx#21 )
  idx#4 = idx#28
  testSimpleTypes::$4 = TYPEID_SIGNED_CHAR
  assertType::t1#2 = testSimpleTypes::$4
  assertType::t2#2 = TYPEID_SIGNED_CHAR
  call assertType
  to:testSimpleTypes::@3
testSimpleTypes::@3: scope:[testSimpleTypes]  from testSimpleTypes::@2
  idx#29 = phi( testSimpleTypes::@2/idx#21 )
  idx#5 = idx#29
  testSimpleTypes::$6 = TYPEID_SIGNED_CHAR
  assertType::t1#3 = testSimpleTypes::$6
  assertType::t2#3 = TYPEID_SIGNED_CHAR
  call assertType
  to:testSimpleTypes::@4
testSimpleTypes::@4: scope:[testSimpleTypes]  from testSimpleTypes::@3
  idx#30 = phi( testSimpleTypes::@3/idx#21 )
  idx#6 = idx#30
  testSimpleTypes::$8 = TYPEID_UNSIGNED_INT
  assertType::t1#4 = testSimpleTypes::$8
  assertType::t2#4 = TYPEID_UNSIGNED_INT
  call assertType
  to:testSimpleTypes::@5
testSimpleTypes::@5: scope:[testSimpleTypes]  from testSimpleTypes::@4
  idx#31 = phi( testSimpleTypes::@4/idx#21 )
  idx#7 = idx#31
  testSimpleTypes::$10 = TYPEID_UNSIGNED_INT
  assertType::t1#5 = testSimpleTypes::$10
  assertType::t2#5 = TYPEID_UNSIGNED_INT
  call assertType
  to:testSimpleTypes::@6
testSimpleTypes::@6: scope:[testSimpleTypes]  from testSimpleTypes::@5
  idx#32 = phi( testSimpleTypes::@5/idx#21 )
  idx#8 = idx#32
  testSimpleTypes::$12 = TYPEID_UNSIGNED_INT
  assertType::t1#6 = testSimpleTypes::$12
  assertType::t2#6 = TYPEID_UNSIGNED_INT
  call assertType
  to:testSimpleTypes::@7
testSimpleTypes::@7: scope:[testSimpleTypes]  from testSimpleTypes::@6
  idx#33 = phi( testSimpleTypes::@6/idx#21 )
  idx#9 = idx#33
  testSimpleTypes::$14 = TYPEID_INT
  assertType::t1#7 = testSimpleTypes::$14
  assertType::t2#7 = TYPEID_INT
  call assertType
  to:testSimpleTypes::@8
testSimpleTypes::@8: scope:[testSimpleTypes]  from testSimpleTypes::@7
  idx#34 = phi( testSimpleTypes::@7/idx#21 )
  idx#10 = idx#34
  testSimpleTypes::$16 = TYPEID_INT
  assertType::t1#8 = testSimpleTypes::$16
  assertType::t2#8 = TYPEID_INT
  call assertType
  to:testSimpleTypes::@9
testSimpleTypes::@9: scope:[testSimpleTypes]  from testSimpleTypes::@8
  idx#35 = phi( testSimpleTypes::@8/idx#21 )
  idx#11 = idx#35
  testSimpleTypes::$18 = TYPEID_INT
  assertType::t1#9 = testSimpleTypes::$18
  assertType::t2#9 = TYPEID_INT
  call assertType
  to:testSimpleTypes::@10
testSimpleTypes::@10: scope:[testSimpleTypes]  from testSimpleTypes::@9
  idx#36 = phi( testSimpleTypes::@9/idx#21 )
  idx#12 = idx#36
  testSimpleTypes::$20 = TYPEID_UNSIGNED_LONG
  assertType::t1#10 = testSimpleTypes::$20
  assertType::t2#10 = TYPEID_UNSIGNED_LONG
  call assertType
  to:testSimpleTypes::@11
testSimpleTypes::@11: scope:[testSimpleTypes]  from testSimpleTypes::@10
  idx#37 = phi( testSimpleTypes::@10/idx#21 )
  idx#13 = idx#37
  testSimpleTypes::$22 = TYPEID_UNSIGNED_LONG
  assertType::t1#11 = testSimpleTypes::$22
  assertType::t2#11 = TYPEID_UNSIGNED_LONG
  call assertType
  to:testSimpleTypes::@12
testSimpleTypes::@12: scope:[testSimpleTypes]  from testSimpleTypes::@11
  idx#38 = phi( testSimpleTypes::@11/idx#21 )
  idx#14 = idx#38
  testSimpleTypes::$24 = TYPEID_LONG
  assertType::t1#12 = testSimpleTypes::$24
  assertType::t2#12 = TYPEID_LONG
  call assertType
  to:testSimpleTypes::@13
testSimpleTypes::@13: scope:[testSimpleTypes]  from testSimpleTypes::@12
  idx#39 = phi( testSimpleTypes::@12/idx#21 )
  idx#15 = idx#39
  testSimpleTypes::$26 = TYPEID_LONG
  assertType::t1#13 = testSimpleTypes::$26
  assertType::t2#13 = TYPEID_LONG
  call assertType
  to:testSimpleTypes::@14
testSimpleTypes::@14: scope:[testSimpleTypes]  from testSimpleTypes::@13
  idx#40 = phi( testSimpleTypes::@13/idx#21 )
  idx#16 = idx#40
  testSimpleTypes::$28 = TYPEID_LONG
  assertType::t1#14 = testSimpleTypes::$28
  assertType::t2#14 = TYPEID_LONG
  call assertType
  to:testSimpleTypes::@15
testSimpleTypes::@15: scope:[testSimpleTypes]  from testSimpleTypes::@14
  idx#41 = phi( testSimpleTypes::@14/idx#21 )
  idx#17 = idx#41
  testSimpleTypes::$30 = TYPEID_UNSIGNED_INT
  assertType::t1#15 = testSimpleTypes::$30
  assertType::t2#15 = TYPEID_UNSIGNED_INT
  call assertType
  to:testSimpleTypes::@16
testSimpleTypes::@16: scope:[testSimpleTypes]  from testSimpleTypes::@15
  idx#42 = phi( testSimpleTypes::@15/idx#21 )
  idx#18 = idx#42
  to:testSimpleTypes::@return
testSimpleTypes::@return: scope:[testSimpleTypes]  from testSimpleTypes::@16
  idx#43 = phi( testSimpleTypes::@16/idx#18 )
  idx#19 = idx#43
  return 
  to:@return

void assertType(char t1 , char t2)
assertType: scope:[assertType]  from testSimpleTypes testSimpleTypes::@1 testSimpleTypes::@10 testSimpleTypes::@11 testSimpleTypes::@12 testSimpleTypes::@13 testSimpleTypes::@14 testSimpleTypes::@15 testSimpleTypes::@2 testSimpleTypes::@3 testSimpleTypes::@4 testSimpleTypes::@5 testSimpleTypes::@6 testSimpleTypes::@7 testSimpleTypes::@8 testSimpleTypes::@9
  idx#51 = phi( testSimpleTypes/idx#2, testSimpleTypes::@1/idx#3, testSimpleTypes::@10/idx#12, testSimpleTypes::@11/idx#13, testSimpleTypes::@12/idx#14, testSimpleTypes::@13/idx#15, testSimpleTypes::@14/idx#16, testSimpleTypes::@15/idx#17, testSimpleTypes::@2/idx#4, testSimpleTypes::@3/idx#5, testSimpleTypes::@4/idx#6, testSimpleTypes::@5/idx#7, testSimpleTypes::@6/idx#8, testSimpleTypes::@7/idx#9, testSimpleTypes::@8/idx#10, testSimpleTypes::@9/idx#11 )
  assertType::t2#16 = phi( testSimpleTypes/assertType::t2#0, testSimpleTypes::@1/assertType::t2#1, testSimpleTypes::@10/assertType::t2#10, testSimpleTypes::@11/assertType::t2#11, testSimpleTypes::@12/assertType::t2#12, testSimpleTypes::@13/assertType::t2#13, testSimpleTypes::@14/assertType::t2#14, testSimpleTypes::@15/assertType::t2#15, testSimpleTypes::@2/assertType::t2#2, testSimpleTypes::@3/assertType::t2#3, testSimpleTypes::@4/assertType::t2#4, testSimpleTypes::@5/assertType::t2#5, testSimpleTypes::@6/assertType::t2#6, testSimpleTypes::@7/assertType::t2#7, testSimpleTypes::@8/assertType::t2#8, testSimpleTypes::@9/assertType::t2#9 )
  assertType::t1#16 = phi( testSimpleTypes/assertType::t1#0, testSimpleTypes::@1/assertType::t1#1, testSimpleTypes::@10/assertType::t1#10, testSimpleTypes::@11/assertType::t1#11, testSimpleTypes::@12/assertType::t1#12, testSimpleTypes::@13/assertType::t1#13, testSimpleTypes::@14/assertType::t1#14, testSimpleTypes::@15/assertType::t1#15, testSimpleTypes::@2/assertType::t1#2, testSimpleTypes::@3/assertType::t1#3, testSimpleTypes::@4/assertType::t1#4, testSimpleTypes::@5/assertType::t1#5, testSimpleTypes::@6/assertType::t1#6, testSimpleTypes::@7/assertType::t1#7, testSimpleTypes::@8/assertType::t1#8, testSimpleTypes::@9/assertType::t1#9 )
  assertType::$0 = assertType::t1#16 == assertType::t2#16
  if(assertType::$0) goto assertType::@1
  to:assertType::@3
assertType::@1: scope:[assertType]  from assertType
  assertType::t1#18 = phi( assertType/assertType::t1#16 )
  idx#44 = phi( assertType/idx#51 )
  COLS[idx#44] = GREEN
  to:assertType::@2
assertType::@3: scope:[assertType]  from assertType
  assertType::t1#19 = phi( assertType/assertType::t1#16 )
  idx#45 = phi( assertType/idx#51 )
  COLS[idx#45] = RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  idx#46 = phi( assertType::@1/idx#44, assertType::@3/idx#45 )
  assertType::t1#17 = phi( assertType::@1/assertType::t1#18, assertType::@3/assertType::t1#19 )
  SCREEN[idx#46] = assertType::t1#17
  idx#20 = ++ idx#46
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  idx#47 = phi( assertType::@2/idx#20 )
  idx#21 = idx#47
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  idx#22 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  idx#52 = phi( __start::__init1/idx#22 )
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  idx#48 = phi( __start::@1/idx#1 )
  idx#23 = idx#48
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  idx#49 = phi( __start::@2/idx#23 )
  idx#24 = idx#49
  return 
  to:@return

SYMBOL TABLE SSA
__constant char * const COLS = (char *)$d800
__constant const char GREEN = 5
__constant const char RED = 2
__constant char * const SCREEN = (char *)$400
__constant char TYPEID_CHAR = 1
__constant char TYPEID_INT = 4
__constant char TYPEID_LONG = 6
__constant char TYPEID_SIGNED_CHAR = 2
__constant char TYPEID_UNSIGNED_INT = 3
__constant char TYPEID_UNSIGNED_LONG = 5
void __start()
void assertType(char t1 , char t2)
bool assertType::$0
char assertType::t1
char assertType::t1#0
char assertType::t1#1
char assertType::t1#10
char assertType::t1#11
char assertType::t1#12
char assertType::t1#13
char assertType::t1#14
char assertType::t1#15
char assertType::t1#16
char assertType::t1#17
char assertType::t1#18
char assertType::t1#19
char assertType::t1#2
char assertType::t1#3
char assertType::t1#4
char assertType::t1#5
char assertType::t1#6
char assertType::t1#7
char assertType::t1#8
char assertType::t1#9
char assertType::t2
char assertType::t2#0
char assertType::t2#1
char assertType::t2#10
char assertType::t2#11
char assertType::t2#12
char assertType::t2#13
char assertType::t2#14
char assertType::t2#15
char assertType::t2#16
char assertType::t2#2
char assertType::t2#3
char assertType::t2#4
char assertType::t2#5
char assertType::t2#6
char assertType::t2#7
char assertType::t2#8
char assertType::t2#9
char idx
char idx#0
char idx#1
char idx#10
char idx#11
char idx#12
char idx#13
char idx#14
char idx#15
char idx#16
char idx#17
char idx#18
char idx#19
char idx#2
char idx#20
char idx#21
char idx#22
char idx#23
char idx#24
char idx#25
char idx#26
char idx#27
char idx#28
char idx#29
char idx#3
char idx#30
char idx#31
char idx#32
char idx#33
char idx#34
char idx#35
char idx#36
char idx#37
char idx#38
char idx#39
char idx#4
char idx#40
char idx#41
char idx#42
char idx#43
char idx#44
char idx#45
char idx#46
char idx#47
char idx#48
char idx#49
char idx#5
char idx#50
char idx#51
char idx#52
char idx#53
char idx#54
char idx#55
char idx#6
char idx#7
char idx#8
char idx#9
void main()
bool main::$1
char *main::s
char *main::s#0
char *main::s#1
char *main::s#2
char *main::s#3
void testSimpleTypes()
char testSimpleTypes::$0
char testSimpleTypes::$10
char testSimpleTypes::$12
char testSimpleTypes::$14
char testSimpleTypes::$16
char testSimpleTypes::$18
char testSimpleTypes::$2
char testSimpleTypes::$20
char testSimpleTypes::$22
char testSimpleTypes::$24
char testSimpleTypes::$26
char testSimpleTypes::$28
char testSimpleTypes::$30
char testSimpleTypes::$4
char testSimpleTypes::$6
char testSimpleTypes::$8

Alias main::s#2 = main::s#3 
Alias idx#50 = idx#55 idx#53 
Alias idx#0 = idx#25 idx#26 idx#1 
Alias assertType::t1#0 = testSimpleTypes::$0 
Alias idx#27 = idx#3 
Alias assertType::t1#1 = testSimpleTypes::$2 
Alias idx#28 = idx#4 
Alias assertType::t1#2 = testSimpleTypes::$4 
Alias idx#29 = idx#5 
Alias assertType::t1#3 = testSimpleTypes::$6 
Alias idx#30 = idx#6 
Alias assertType::t1#4 = testSimpleTypes::$8 
Alias idx#31 = idx#7 
Alias assertType::t1#5 = testSimpleTypes::$10 
Alias idx#32 = idx#8 
Alias assertType::t1#6 = testSimpleTypes::$12 
Alias idx#33 = idx#9 
Alias assertType::t1#7 = testSimpleTypes::$14 
Alias idx#10 = idx#34 
Alias assertType::t1#8 = testSimpleTypes::$16 
Alias idx#11 = idx#35 
Alias assertType::t1#9 = testSimpleTypes::$18 
Alias idx#12 = idx#36 
Alias assertType::t1#10 = testSimpleTypes::$20 
Alias idx#13 = idx#37 
Alias assertType::t1#11 = testSimpleTypes::$22 
Alias idx#14 = idx#38 
Alias assertType::t1#12 = testSimpleTypes::$24 
Alias idx#15 = idx#39 
Alias assertType::t1#13 = testSimpleTypes::$26 
Alias idx#16 = idx#40 
Alias assertType::t1#14 = testSimpleTypes::$28 
Alias idx#17 = idx#41 
Alias assertType::t1#15 = testSimpleTypes::$30 
Alias idx#18 = idx#42 idx#43 idx#19 
Alias idx#44 = idx#51 idx#45 
Alias assertType::t1#16 = assertType::t1#18 assertType::t1#19 
Alias idx#20 = idx#47 idx#21 
Alias idx#22 = idx#52 
Alias idx#23 = idx#48 idx#49 idx#24 
Successful SSA optimization Pass2AliasElimination
Alias assertType::t1#16 = assertType::t1#17 
Alias idx#44 = idx#46 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values idx#54 idx#22
Identical Phi Values idx#50 idx#54
Identical Phi Values idx#0 idx#18
Identical Phi Values idx#27 idx#20
Identical Phi Values idx#28 idx#20
Identical Phi Values idx#29 idx#20
Identical Phi Values idx#30 idx#20
Identical Phi Values idx#31 idx#20
Identical Phi Values idx#32 idx#20
Identical Phi Values idx#33 idx#20
Identical Phi Values idx#10 idx#20
Identical Phi Values idx#11 idx#20
Identical Phi Values idx#12 idx#20
Identical Phi Values idx#13 idx#20
Identical Phi Values idx#14 idx#20
Identical Phi Values idx#15 idx#20
Identical Phi Values idx#16 idx#20
Identical Phi Values idx#17 idx#20
Identical Phi Values idx#18 idx#20
Identical Phi Values idx#23 idx#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$1 [4] if(main::s#2<SCREEN+$3e8) goto main::@2
Simple Condition assertType::$0 [78] if(assertType::t1#16==assertType::t2#16) goto assertType::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant main::s#0 = SCREEN
Constant idx#2 = 0
Constant assertType::t1#0 = TYPEID_CHAR
Constant assertType::t2#0 = TYPEID_CHAR
Constant assertType::t1#1 = TYPEID_CHAR
Constant assertType::t2#1 = TYPEID_CHAR
Constant assertType::t1#2 = TYPEID_SIGNED_CHAR
Constant assertType::t2#2 = TYPEID_SIGNED_CHAR
Constant assertType::t1#3 = TYPEID_SIGNED_CHAR
Constant assertType::t2#3 = TYPEID_SIGNED_CHAR
Constant assertType::t1#4 = TYPEID_UNSIGNED_INT
Constant assertType::t2#4 = TYPEID_UNSIGNED_INT
Constant assertType::t1#5 = TYPEID_UNSIGNED_INT
Constant assertType::t2#5 = TYPEID_UNSIGNED_INT
Constant assertType::t1#6 = TYPEID_UNSIGNED_INT
Constant assertType::t2#6 = TYPEID_UNSIGNED_INT
Constant assertType::t1#7 = TYPEID_INT
Constant assertType::t2#7 = TYPEID_INT
Constant assertType::t1#8 = TYPEID_INT
Constant assertType::t2#8 = TYPEID_INT
Constant assertType::t1#9 = TYPEID_INT
Constant assertType::t2#9 = TYPEID_INT
Constant assertType::t1#10 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#10 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#11 = TYPEID_UNSIGNED_LONG
Constant assertType::t2#11 = TYPEID_UNSIGNED_LONG
Constant assertType::t1#12 = TYPEID_LONG
Constant assertType::t2#12 = TYPEID_LONG
Constant assertType::t1#13 = TYPEID_LONG
Constant assertType::t2#13 = TYPEID_LONG
Constant assertType::t1#14 = TYPEID_LONG
Constant assertType::t2#14 = TYPEID_LONG
Constant assertType::t1#15 = TYPEID_UNSIGNED_INT
Constant assertType::t2#15 = TYPEID_UNSIGNED_INT
Constant idx#22 = 0
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant idx#22
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings main::s#0
Inlining constant with var siblings assertType::t1#0
Inlining constant with var siblings assertType::t2#0
Inlining constant with var siblings assertType::t1#1
Inlining constant with var siblings assertType::t2#1
Inlining constant with var siblings assertType::t1#2
Inlining constant with var siblings assertType::t2#2
Inlining constant with var siblings assertType::t1#3
Inlining constant with var siblings assertType::t2#3
Inlining constant with var siblings assertType::t1#4
Inlining constant with var siblings assertType::t2#4
Inlining constant with var siblings assertType::t1#5
Inlining constant with var siblings assertType::t2#5
Inlining constant with var siblings assertType::t1#6
Inlining constant with var siblings assertType::t2#6
Inlining constant with var siblings assertType::t1#7
Inlining constant with var siblings assertType::t2#7
Inlining constant with var siblings assertType::t1#8
Inlining constant with var siblings assertType::t2#8
Inlining constant with var siblings assertType::t1#9
Inlining constant with var siblings assertType::t2#9
Inlining constant with var siblings assertType::t1#10
Inlining constant with var siblings assertType::t2#10
Inlining constant with var siblings assertType::t1#11
Inlining constant with var siblings assertType::t2#11
Inlining constant with var siblings assertType::t1#12
Inlining constant with var siblings assertType::t2#12
Inlining constant with var siblings assertType::t1#13
Inlining constant with var siblings assertType::t2#13
Inlining constant with var siblings assertType::t1#14
Inlining constant with var siblings assertType::t2#14
Inlining constant with var siblings assertType::t1#15
Inlining constant with var siblings assertType::t2#15
Inlining constant with var siblings idx#2
Constant inlined assertType::t2#5 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#6 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#6 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#7 = TYPEID_INT
Constant inlined assertType::t2#7 = TYPEID_INT
Constant inlined assertType::t1#8 = TYPEID_INT
Constant inlined assertType::t2#8 = TYPEID_INT
Constant inlined assertType::t1#9 = TYPEID_INT
Constant inlined assertType::t2#9 = TYPEID_INT
Constant inlined assertType::t2#11 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t2#10 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t2#13 = TYPEID_LONG
Constant inlined assertType::t2#12 = TYPEID_LONG
Constant inlined assertType::t2#15 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#14 = TYPEID_LONG
Constant inlined assertType::t1#0 = TYPEID_CHAR
Constant inlined idx#2 = 0
Constant inlined assertType::t2#0 = TYPEID_CHAR
Constant inlined assertType::t1#1 = TYPEID_CHAR
Constant inlined assertType::t2#1 = TYPEID_CHAR
Constant inlined assertType::t1#2 = TYPEID_SIGNED_CHAR
Constant inlined assertType::t2#2 = TYPEID_SIGNED_CHAR
Constant inlined assertType::t1#3 = TYPEID_SIGNED_CHAR
Constant inlined assertType::t2#3 = TYPEID_SIGNED_CHAR
Constant inlined assertType::t1#4 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t2#4 = TYPEID_UNSIGNED_INT
Constant inlined assertType::t1#5 = TYPEID_UNSIGNED_INT
Constant inlined main::s#0 = SCREEN
Constant inlined assertType::t1#10 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#12 = TYPEID_LONG
Constant inlined assertType::t1#11 = TYPEID_UNSIGNED_LONG
Constant inlined assertType::t1#14 = TYPEID_LONG
Constant inlined assertType::t1#13 = TYPEID_LONG
Constant inlined assertType::t1#15 = TYPEID_UNSIGNED_INT
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 3
Finalized unsigned number type (char) 4
Finalized unsigned number type (char) 5
Finalized unsigned number type (char) 6
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of testSimpleTypes
Adding NOP phi() at start of testSimpleTypes::@16
CALL GRAPH
Calls in [main] to testSimpleTypes:4 
Calls in [testSimpleTypes] to assertType:11 assertType:13 assertType:15 assertType:17 assertType:19 assertType:21 assertType:23 assertType:25 assertType:27 assertType:29 assertType:31 assertType:33 assertType:35 assertType:37 assertType:39 assertType:41 

Created 4 initial phi equivalence classes
Coalesced [9] main::s#4 = main::s#1
Coalesced [12] idx#56 = idx#20
Coalesced (already) [14] idx#63 = idx#20
Coalesced (already) [16] idx#64 = idx#20
Coalesced (already) [18] idx#65 = idx#20
Coalesced (already) [20] idx#66 = idx#20
Coalesced (already) [22] idx#67 = idx#20
Coalesced (already) [24] idx#68 = idx#20
Coalesced (already) [26] idx#69 = idx#20
Coalesced (already) [28] idx#70 = idx#20
Coalesced (already) [30] idx#57 = idx#20
Coalesced (already) [32] idx#58 = idx#20
Coalesced (already) [34] idx#59 = idx#20
Coalesced (already) [36] idx#60 = idx#20
Coalesced (already) [38] idx#61 = idx#20
Coalesced (already) [40] idx#62 = idx#20
Coalesced down to 4 phi equivalence classes
Culled Empty Block label main::@4
Culled Empty Block label testSimpleTypes::@16
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of testSimpleTypes
Adding NOP phi() at start of testSimpleTypes::@1
Adding NOP phi() at start of testSimpleTypes::@2
Adding NOP phi() at start of testSimpleTypes::@3
Adding NOP phi() at start of testSimpleTypes::@4
Adding NOP phi() at start of testSimpleTypes::@5
Adding NOP phi() at start of testSimpleTypes::@6
Adding NOP phi() at start of testSimpleTypes::@7
Adding NOP phi() at start of testSimpleTypes::@8
Adding NOP phi() at start of testSimpleTypes::@9
Adding NOP phi() at start of testSimpleTypes::@10
Adding NOP phi() at start of testSimpleTypes::@11
Adding NOP phi() at start of testSimpleTypes::@12
Adding NOP phi() at start of testSimpleTypes::@13
Adding NOP phi() at start of testSimpleTypes::@14
Adding NOP phi() at start of testSimpleTypes::@15

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [1] main::s#2 = phi( main/SCREEN, main::@2/main::s#1 )
  [2] if(main::s#2<SCREEN+$3e8) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [3] phi()
  [4] call testSimpleTypes
  to:main::@return
main::@return: scope:[main]  from main::@3
  [5] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [6] *main::s#2 = ' '
  [7] main::s#1 = ++ main::s#2
  to:main::@1

void testSimpleTypes()
testSimpleTypes: scope:[testSimpleTypes]  from main::@3
  [8] phi()
  [9] call assertType
  to:testSimpleTypes::@1
testSimpleTypes::@1: scope:[testSimpleTypes]  from testSimpleTypes
  [10] phi()
  [11] call assertType
  to:testSimpleTypes::@2
testSimpleTypes::@2: scope:[testSimpleTypes]  from testSimpleTypes::@1
  [12] phi()
  [13] call assertType
  to:testSimpleTypes::@3
testSimpleTypes::@3: scope:[testSimpleTypes]  from testSimpleTypes::@2
  [14] phi()
  [15] call assertType
  to:testSimpleTypes::@4
testSimpleTypes::@4: scope:[testSimpleTypes]  from testSimpleTypes::@3
  [16] phi()
  [17] call assertType
  to:testSimpleTypes::@5
testSimpleTypes::@5: scope:[testSimpleTypes]  from testSimpleTypes::@4
  [18] phi()
  [19] call assertType
  to:testSimpleTypes::@6
testSimpleTypes::@6: scope:[testSimpleTypes]  from testSimpleTypes::@5
  [20] phi()
  [21] call assertType
  to:testSimpleTypes::@7
testSimpleTypes::@7: scope:[testSimpleTypes]  from testSimpleTypes::@6
  [22] phi()
  [23] call assertType
  to:testSimpleTypes::@8
testSimpleTypes::@8: scope:[testSimpleTypes]  from testSimpleTypes::@7
  [24] phi()
  [25] call assertType
  to:testSimpleTypes::@9
testSimpleTypes::@9: scope:[testSimpleTypes]  from testSimpleTypes::@8
  [26] phi()
  [27] call assertType
  to:testSimpleTypes::@10
testSimpleTypes::@10: scope:[testSimpleTypes]  from testSimpleTypes::@9
  [28] phi()
  [29] call assertType
  to:testSimpleTypes::@11
testSimpleTypes::@11: scope:[testSimpleTypes]  from testSimpleTypes::@10
  [30] phi()
  [31] call assertType
  to:testSimpleTypes::@12
testSimpleTypes::@12: scope:[testSimpleTypes]  from testSimpleTypes::@11
  [32] phi()
  [33] call assertType
  to:testSimpleTypes::@13
testSimpleTypes::@13: scope:[testSimpleTypes]  from testSimpleTypes::@12
  [34] phi()
  [35] call assertType
  to:testSimpleTypes::@14
testSimpleTypes::@14: scope:[testSimpleTypes]  from testSimpleTypes::@13
  [36] phi()
  [37] call assertType
  to:testSimpleTypes::@15
testSimpleTypes::@15: scope:[testSimpleTypes]  from testSimpleTypes::@14
  [38] phi()
  [39] call assertType
  to:testSimpleTypes::@return
testSimpleTypes::@return: scope:[testSimpleTypes]  from testSimpleTypes::@15
  [40] return 
  to:@return

void assertType(char t1 , char t2)
assertType: scope:[assertType]  from testSimpleTypes testSimpleTypes::@1 testSimpleTypes::@10 testSimpleTypes::@11 testSimpleTypes::@12 testSimpleTypes::@13 testSimpleTypes::@14 testSimpleTypes::@15 testSimpleTypes::@2 testSimpleTypes::@3 testSimpleTypes::@4 testSimpleTypes::@5 testSimpleTypes::@6 testSimpleTypes::@7 testSimpleTypes::@8 testSimpleTypes::@9
  [41] idx#44 = phi( testSimpleTypes/0, testSimpleTypes::@1/idx#20, testSimpleTypes::@10/idx#20, testSimpleTypes::@11/idx#20, testSimpleTypes::@12/idx#20, testSimpleTypes::@13/idx#20, testSimpleTypes::@14/idx#20, testSimpleTypes::@15/idx#20, testSimpleTypes::@2/idx#20, testSimpleTypes::@3/idx#20, testSimpleTypes::@4/idx#20, testSimpleTypes::@5/idx#20, testSimpleTypes::@6/idx#20, testSimpleTypes::@7/idx#20, testSimpleTypes::@8/idx#20, testSimpleTypes::@9/idx#20 )
  [41] assertType::t2#16 = phi( testSimpleTypes/TYPEID_CHAR, testSimpleTypes::@1/TYPEID_CHAR, testSimpleTypes::@10/TYPEID_UNSIGNED_LONG, testSimpleTypes::@11/TYPEID_UNSIGNED_LONG, testSimpleTypes::@12/TYPEID_LONG, testSimpleTypes::@13/TYPEID_LONG, testSimpleTypes::@14/TYPEID_LONG, testSimpleTypes::@15/TYPEID_UNSIGNED_INT, testSimpleTypes::@2/TYPEID_SIGNED_CHAR, testSimpleTypes::@3/TYPEID_SIGNED_CHAR, testSimpleTypes::@4/TYPEID_UNSIGNED_INT, testSimpleTypes::@5/TYPEID_UNSIGNED_INT, testSimpleTypes::@6/TYPEID_UNSIGNED_INT, testSimpleTypes::@7/TYPEID_INT, testSimpleTypes::@8/TYPEID_INT, testSimpleTypes::@9/TYPEID_INT )
  [41] assertType::t1#16 = phi( testSimpleTypes/TYPEID_CHAR, testSimpleTypes::@1/TYPEID_CHAR, testSimpleTypes::@10/TYPEID_UNSIGNED_LONG, testSimpleTypes::@11/TYPEID_UNSIGNED_LONG, testSimpleTypes::@12/TYPEID_LONG, testSimpleTypes::@13/TYPEID_LONG, testSimpleTypes::@14/TYPEID_LONG, testSimpleTypes::@15/TYPEID_UNSIGNED_INT, testSimpleTypes::@2/TYPEID_SIGNED_CHAR, testSimpleTypes::@3/TYPEID_SIGNED_CHAR, testSimpleTypes::@4/TYPEID_UNSIGNED_INT, testSimpleTypes::@5/TYPEID_UNSIGNED_INT, testSimpleTypes::@6/TYPEID_UNSIGNED_INT, testSimpleTypes::@7/TYPEID_INT, testSimpleTypes::@8/TYPEID_INT, testSimpleTypes::@9/TYPEID_INT )
  [42] if(assertType::t1#16==assertType::t2#16) goto assertType::@1
  to:assertType::@3
assertType::@3: scope:[assertType]  from assertType
  [43] COLS[idx#44] = RED
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  [44] SCREEN[idx#44] = assertType::t1#16
  [45] idx#20 = ++ idx#44
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  [46] return 
  to:@return
assertType::@1: scope:[assertType]  from assertType
  [47] COLS[idx#44] = GREEN
  to:assertType::@2


VARIABLE REGISTER WEIGHTS
void assertType(char t1 , char t2)
char assertType::t1
char assertType::t1#16 // 50.5
char assertType::t2
char assertType::t2#16 // 101.0
char idx
char idx#20 // 8.3125
char idx#44 // 113.8
void main()
char *main::s
char *main::s#1 // 22.0
char *main::s#2 // 14.666666666666666
void testSimpleTypes()

Initial phi equivalence classes
[ main::s#2 main::s#1 ]
[ assertType::t1#16 ]
[ assertType::t2#16 ]
[ idx#44 idx#20 ]
Complete equivalence classes
[ main::s#2 main::s#1 ]
[ assertType::t1#16 ]
[ assertType::t2#16 ]
[ idx#44 idx#20 ]
Allocated zp[2]:2 [ main::s#2 main::s#1 ]
Allocated zp[1]:4 [ assertType::t1#16 ]
Allocated zp[1]:5 [ assertType::t2#16 ]
Allocated zp[1]:6 [ idx#44 idx#20 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] if(main::s#2<SCREEN+$3e8) goto main::@2 [ main::s#2 ] (  [ main::s#2 ] { }  ) always clobbers reg byte a 
Statement [6] *main::s#2 = ' ' [ main::s#2 ] (  [ main::s#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [43] COLS[idx#44] = RED [ assertType::t1#16 idx#44 ] ( testSimpleTypes:4::assertType:9 [ assertType::t1#16 idx#44 ] { }  testSimpleTypes:4::assertType:11 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:13 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:15 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:17 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:19 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:21 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:23 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:25 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:27 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:29 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:31 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:33 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:35 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:37 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:39 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ assertType::t1#16 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ idx#44 idx#20 ]
Statement [44] SCREEN[idx#44] = assertType::t1#16 [ idx#44 ] ( testSimpleTypes:4::assertType:9 [ idx#44 ] { }  testSimpleTypes:4::assertType:11 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:13 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:15 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:17 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:19 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:21 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:23 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:25 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:27 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:29 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:31 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:33 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:35 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:37 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:39 [ idx#44 ] { { idx#20 = idx#44 } }  ) always clobbers reg byte a 
Statement [47] COLS[idx#44] = GREEN [ assertType::t1#16 idx#44 ] ( testSimpleTypes:4::assertType:9 [ assertType::t1#16 idx#44 ] { }  testSimpleTypes:4::assertType:11 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:13 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:15 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:17 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:19 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:21 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:23 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:25 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:27 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:29 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:31 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:33 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:35 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:37 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:39 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  ) always clobbers reg byte a 
Statement [2] if(main::s#2<SCREEN+$3e8) goto main::@2 [ main::s#2 ] (  [ main::s#2 ] { }  ) always clobbers reg byte a 
Statement [6] *main::s#2 = ' ' [ main::s#2 ] (  [ main::s#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [43] COLS[idx#44] = RED [ assertType::t1#16 idx#44 ] ( testSimpleTypes:4::assertType:9 [ assertType::t1#16 idx#44 ] { }  testSimpleTypes:4::assertType:11 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:13 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:15 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:17 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:19 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:21 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:23 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:25 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:27 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:29 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:31 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:33 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:35 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:37 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:39 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  ) always clobbers reg byte a 
Statement [44] SCREEN[idx#44] = assertType::t1#16 [ idx#44 ] ( testSimpleTypes:4::assertType:9 [ idx#44 ] { }  testSimpleTypes:4::assertType:11 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:13 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:15 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:17 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:19 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:21 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:23 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:25 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:27 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:29 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:31 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:33 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:35 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:37 [ idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:39 [ idx#44 ] { { idx#20 = idx#44 } }  ) always clobbers reg byte a 
Statement [47] COLS[idx#44] = GREEN [ assertType::t1#16 idx#44 ] ( testSimpleTypes:4::assertType:9 [ assertType::t1#16 idx#44 ] { }  testSimpleTypes:4::assertType:11 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:13 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:15 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:17 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:19 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:21 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:23 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:25 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:27 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:29 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:31 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:33 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:35 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:37 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  testSimpleTypes:4::assertType:39 [ assertType::t1#16 idx#44 ] { { idx#20 = idx#44 } }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ main::s#2 main::s#1 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ assertType::t1#16 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ assertType::t2#16 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ idx#44 idx#20 ] : zp[1]:6 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [assertType] 101: zp[1]:5 [ assertType::t2#16 ] 50.5: zp[1]:4 [ assertType::t1#16 ] 
Uplift Scope [] 122.11: zp[1]:6 [ idx#44 idx#20 ] 
Uplift Scope [main] 36.67: zp[2]:2 [ main::s#2 main::s#1 ] 
Uplift Scope [testSimpleTypes] 

Uplifting [assertType] best 858 combination reg byte y [ assertType::t2#16 ] reg byte x [ assertType::t1#16 ] 
Uplifting [] best 858 combination zp[1]:6 [ idx#44 idx#20 ] 
Uplifting [main] best 858 combination zp[2]:2 [ main::s#2 main::s#1 ] 
Uplifting [testSimpleTypes] best 858 combination 
Attempting to uplift remaining variables inzp[1]:6 [ idx#44 idx#20 ]
Uplifting [] best 858 combination zp[1]:6 [ idx#44 idx#20 ] 
Allocated (was zp[1]:6) zp[1]:4 [ idx#44 idx#20 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests different integer literal types
  // Upstart
  // Commodore 64 PRG executable file
.file [name="int-literals.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const RED = 2
  .const GREEN = 5
  .const TYPEID_CHAR = 1
  .const TYPEID_SIGNED_CHAR = 2
  .const TYPEID_UNSIGNED_INT = 3
  .const TYPEID_INT = 4
  .const TYPEID_UNSIGNED_LONG = 5
  .const TYPEID_LONG = 6
  .label SCREEN = $400
  .label COLS = $d800
  .label idx = 4
.segment Code
  // main
main: {
    .label s = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi main::s#2 = SCREEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z s
    lda #>SCREEN
    sta.z s+1
    jmp __b1
    // main::@1
  __b1:
    // [2] if(main::s#2<SCREEN+$3e8) goto main::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z s+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z s
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // [3] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [4] call testSimpleTypes
    // [8] phi from main::@3 to testSimpleTypes [phi:main::@3->testSimpleTypes]
  testSimpleTypes_from___b3:
    jsr testSimpleTypes
    jmp __breturn
    // main::@return
  __breturn:
    // [5] return 
    rts
    // main::@2
  __b2:
    // [6] *main::s#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
    // [7] main::s#1 = ++ main::s#2 -- pbuz1=_inc_pbuz1 
    inc.z s
    bne !+
    inc.z s+1
  !:
    // [1] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [1] phi main::s#2 = main::s#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // testSimpleTypes
testSimpleTypes: {
    // [9] call assertType
  // Simple types
    // [41] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
  assertType_from_testSimpleTypes:
    // [41] phi idx#44 = 0 [phi:testSimpleTypes->assertType#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [41] phi assertType::t2#16 = TYPEID_CHAR [phi:testSimpleTypes->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_CHAR
    // [41] phi assertType::t1#16 = TYPEID_CHAR [phi:testSimpleTypes->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_CHAR
    jsr assertType
    // [10] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
  __b1_from_testSimpleTypes:
    jmp __b1
    // testSimpleTypes::@1
  __b1:
    // [11] call assertType
    // [41] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
  assertType_from___b1:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_CHAR [phi:testSimpleTypes::@1->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_CHAR
    // [41] phi assertType::t1#16 = TYPEID_CHAR [phi:testSimpleTypes::@1->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_CHAR
    jsr assertType
    // [12] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
  __b2_from___b1:
    jmp __b2
    // testSimpleTypes::@2
  __b2:
    // [13] call assertType
    // [41] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
  assertType_from___b2:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_SIGNED_CHAR [phi:testSimpleTypes::@2->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_CHAR
    // [41] phi assertType::t1#16 = TYPEID_SIGNED_CHAR [phi:testSimpleTypes::@2->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_CHAR
    jsr assertType
    // [14] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
  __b3_from___b2:
    jmp __b3
    // testSimpleTypes::@3
  __b3:
    // [15] call assertType
    // [41] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
  assertType_from___b3:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_SIGNED_CHAR [phi:testSimpleTypes::@3->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_CHAR
    // [41] phi assertType::t1#16 = TYPEID_SIGNED_CHAR [phi:testSimpleTypes::@3->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_CHAR
    jsr assertType
    // [16] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
  __b4_from___b3:
    jmp __b4
    // testSimpleTypes::@4
  __b4:
    // [17] call assertType
    // [41] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
  assertType_from___b4:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@4->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_INT
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@4->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_INT
    jsr assertType
    // [18] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
  __b5_from___b4:
    jmp __b5
    // testSimpleTypes::@5
  __b5:
    // [19] call assertType
    // [41] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
  assertType_from___b5:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@5->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_INT
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@5->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_INT
    jsr assertType
    // [20] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
  __b6_from___b5:
    jmp __b6
    // testSimpleTypes::@6
  __b6:
    // [21] call assertType
    // [41] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
  assertType_from___b6:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@6->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_INT
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@6->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_INT
    jsr assertType
    // [22] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
  __b7_from___b6:
    jmp __b7
    // testSimpleTypes::@7
  __b7:
    // [23] call assertType
    // [41] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
  assertType_from___b7:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_INT [phi:testSimpleTypes::@7->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_INT
    // [41] phi assertType::t1#16 = TYPEID_INT [phi:testSimpleTypes::@7->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_INT
    jsr assertType
    // [24] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
  __b8_from___b7:
    jmp __b8
    // testSimpleTypes::@8
  __b8:
    // [25] call assertType
    // [41] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
  assertType_from___b8:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_INT [phi:testSimpleTypes::@8->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_INT
    // [41] phi assertType::t1#16 = TYPEID_INT [phi:testSimpleTypes::@8->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_INT
    jsr assertType
    // [26] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
  __b9_from___b8:
    jmp __b9
    // testSimpleTypes::@9
  __b9:
    // [27] call assertType
    // [41] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
  assertType_from___b9:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_INT [phi:testSimpleTypes::@9->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_INT
    // [41] phi assertType::t1#16 = TYPEID_INT [phi:testSimpleTypes::@9->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_INT
    jsr assertType
    // [28] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
  __b10_from___b9:
    jmp __b10
    // testSimpleTypes::@10
  __b10:
    // [29] call assertType
    // [41] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
  assertType_from___b10:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_LONG [phi:testSimpleTypes::@10->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_LONG
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_LONG [phi:testSimpleTypes::@10->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [30] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
  __b11_from___b10:
    jmp __b11
    // testSimpleTypes::@11
  __b11:
    // [31] call assertType
    // [41] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
  assertType_from___b11:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_LONG [phi:testSimpleTypes::@11->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_LONG
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_LONG [phi:testSimpleTypes::@11->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [32] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
  __b12_from___b11:
    jmp __b12
    // testSimpleTypes::@12
  __b12:
    // [33] call assertType
    // [41] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
  assertType_from___b12:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_LONG [phi:testSimpleTypes::@12->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_LONG
    // [41] phi assertType::t1#16 = TYPEID_LONG [phi:testSimpleTypes::@12->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_LONG
    jsr assertType
    // [34] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
  __b13_from___b12:
    jmp __b13
    // testSimpleTypes::@13
  __b13:
    // [35] call assertType
    // [41] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
  assertType_from___b13:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_LONG [phi:testSimpleTypes::@13->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_LONG
    // [41] phi assertType::t1#16 = TYPEID_LONG [phi:testSimpleTypes::@13->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_LONG
    jsr assertType
    // [36] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
  __b14_from___b13:
    jmp __b14
    // testSimpleTypes::@14
  __b14:
    // [37] call assertType
    // [41] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
  assertType_from___b14:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_LONG [phi:testSimpleTypes::@14->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_LONG
    // [41] phi assertType::t1#16 = TYPEID_LONG [phi:testSimpleTypes::@14->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_LONG
    jsr assertType
    // [38] phi from testSimpleTypes::@14 to testSimpleTypes::@15 [phi:testSimpleTypes::@14->testSimpleTypes::@15]
  __b15_from___b14:
    jmp __b15
    // testSimpleTypes::@15
  __b15:
    // [39] call assertType
    // [41] phi from testSimpleTypes::@15 to assertType [phi:testSimpleTypes::@15->assertType]
  assertType_from___b15:
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@15->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@15->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_INT
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@15->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_INT
    jsr assertType
    jmp __breturn
    // testSimpleTypes::@return
  __breturn:
    // [40] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// void assertType(__register(X) char t1, __register(Y) char t2)
assertType: {
    // [42] if(assertType::t1#16==assertType::t2#16) goto assertType::@1 -- vbuxx_eq_vbuyy_then_la1 
    sty.z $ff
    cpx.z $ff
    beq __b1
    jmp __b3
    // assertType::@3
  __b3:
    // [43] COLS[idx#44] = RED -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #RED
    ldy.z idx
    sta COLS,y
    jmp __b2
    // assertType::@2
  __b2:
    // [44] SCREEN[idx#44] = assertType::t1#16 -- pbuc1_derefidx_vbuz1=vbuxx 
    ldy.z idx
    txa
    sta SCREEN,y
    // [45] idx#20 = ++ idx#44 -- vbuz1=_inc_vbuz1 
    inc.z idx
    jmp __breturn
    // assertType::@return
  __breturn:
    // [46] return 
    rts
    // assertType::@1
  __b1:
    // [47] COLS[idx#44] = GREEN -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy.z idx
    sta COLS,y
    jmp __b2
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b13
Removing instruction jmp __b14
Removing instruction jmp __b15
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b3_from___b1:
Removing instruction testSimpleTypes_from___b3:
Removing instruction __b1_from_testSimpleTypes:
Removing instruction assertType_from___b1:
Removing instruction __b2_from___b1:
Removing instruction assertType_from___b2:
Removing instruction __b3_from___b2:
Removing instruction assertType_from___b3:
Removing instruction __b4_from___b3:
Removing instruction assertType_from___b4:
Removing instruction __b5_from___b4:
Removing instruction assertType_from___b5:
Removing instruction __b6_from___b5:
Removing instruction assertType_from___b6:
Removing instruction __b7_from___b6:
Removing instruction assertType_from___b7:
Removing instruction __b8_from___b7:
Removing instruction assertType_from___b8:
Removing instruction __b9_from___b8:
Removing instruction assertType_from___b9:
Removing instruction __b10_from___b9:
Removing instruction assertType_from___b10:
Removing instruction __b11_from___b10:
Removing instruction assertType_from___b11:
Removing instruction __b12_from___b11:
Removing instruction assertType_from___b12:
Removing instruction __b13_from___b12:
Removing instruction assertType_from___b13:
Removing instruction __b14_from___b13:
Removing instruction assertType_from___b14:
Removing instruction __b15_from___b14:
Removing instruction assertType_from___b15:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction assertType_from_testSimpleTypes:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b13:
Removing instruction __b14:
Removing instruction __b15:
Removing instruction __breturn:
Removing instruction __b3:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
__constant char * const COLS = (char *)$d800
__constant const char GREEN = 5
__constant const char RED = 2
__constant char * const SCREEN = (char *)$400
__constant char TYPEID_CHAR = 1
__constant char TYPEID_INT = 4
__constant char TYPEID_LONG = 6
__constant char TYPEID_SIGNED_CHAR = 2
__constant char TYPEID_UNSIGNED_INT = 3
__constant char TYPEID_UNSIGNED_LONG = 5
void assertType(char t1 , char t2)
char assertType::t1
char assertType::t1#16 // reg byte x 50.5
char assertType::t2
char assertType::t2#16 // reg byte y 101.0
char idx
char idx#20 // idx zp[1]:4 8.3125
char idx#44 // idx zp[1]:4 113.8
void main()
char *main::s
char *main::s#1 // s zp[2]:2 22.0
char *main::s#2 // s zp[2]:2 14.666666666666666
void testSimpleTypes()

zp[2]:2 [ main::s#2 main::s#1 ]
reg byte x [ assertType::t1#16 ]
reg byte y [ assertType::t2#16 ]
zp[1]:4 [ idx#44 idx#20 ]


FINAL ASSEMBLER
Score: 765

  // File Comments
// Tests different integer literal types
  // Upstart
  // Commodore 64 PRG executable file
.file [name="int-literals.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const RED = 2
  .const GREEN = 5
  .const TYPEID_CHAR = 1
  .const TYPEID_SIGNED_CHAR = 2
  .const TYPEID_UNSIGNED_INT = 3
  .const TYPEID_INT = 4
  .const TYPEID_UNSIGNED_LONG = 5
  .const TYPEID_LONG = 6
  .label SCREEN = $400
  .label COLS = $d800
  .label idx = 4
.segment Code
  // main
main: {
    .label s = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi main::s#2 = SCREEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z s
    lda #>SCREEN
    sta.z s+1
    // main::@1
  __b1:
    // for(byte* s=SCREEN;s<SCREEN+1000uw;s++)
    // [2] if(main::s#2<SCREEN+$3e8) goto main::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z s+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z s
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // [3] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // main::@3
    // testSimpleTypes()
    // [4] call testSimpleTypes
    // [8] phi from main::@3 to testSimpleTypes [phi:main::@3->testSimpleTypes]
    jsr testSimpleTypes
    // main::@return
    // }
    // [5] return 
    rts
    // main::@2
  __b2:
    // *s = ' '
    // [6] *main::s#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
    // for(byte* s=SCREEN;s<SCREEN+1000uw;s++)
    // [7] main::s#1 = ++ main::s#2 -- pbuz1=_inc_pbuz1 
    inc.z s
    bne !+
    inc.z s+1
  !:
    // [1] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [1] phi main::s#2 = main::s#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // testSimpleTypes
testSimpleTypes: {
    // assertType(typeid(12ub), typeid(unsigned byte))
    // [9] call assertType
  // Simple types
    // [41] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
    // [41] phi idx#44 = 0 [phi:testSimpleTypes->assertType#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [41] phi assertType::t2#16 = TYPEID_CHAR [phi:testSimpleTypes->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_CHAR
    // [41] phi assertType::t1#16 = TYPEID_CHAR [phi:testSimpleTypes->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_CHAR
    jsr assertType
    // [10] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
    // testSimpleTypes::@1
    // assertType(typeid(12uc), typeid(unsigned byte))
    // [11] call assertType
    // [41] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_CHAR [phi:testSimpleTypes::@1->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_CHAR
    // [41] phi assertType::t1#16 = TYPEID_CHAR [phi:testSimpleTypes::@1->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_CHAR
    jsr assertType
    // [12] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
    // testSimpleTypes::@2
    // assertType(typeid(12sb), typeid(signed byte))
    // [13] call assertType
    // [41] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_SIGNED_CHAR [phi:testSimpleTypes::@2->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_CHAR
    // [41] phi assertType::t1#16 = TYPEID_SIGNED_CHAR [phi:testSimpleTypes::@2->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_CHAR
    jsr assertType
    // [14] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
    // testSimpleTypes::@3
    // assertType(typeid(12sc), typeid(signed byte))
    // [15] call assertType
    // [41] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_SIGNED_CHAR [phi:testSimpleTypes::@3->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_CHAR
    // [41] phi assertType::t1#16 = TYPEID_SIGNED_CHAR [phi:testSimpleTypes::@3->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_SIGNED_CHAR
    jsr assertType
    // [16] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
    // testSimpleTypes::@4
    // assertType(typeid(12uw), typeid(unsigned word))
    // [17] call assertType
    // [41] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@4->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_INT
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@4->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_INT
    jsr assertType
    // [18] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
    // testSimpleTypes::@5
    // assertType(typeid(12ui), typeid(unsigned word))
    // [19] call assertType
    // [41] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@5->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_INT
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@5->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_INT
    jsr assertType
    // [20] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
    // testSimpleTypes::@6
    // assertType(typeid(12us), typeid(unsigned word))
    // [21] call assertType
    // [41] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@6->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_INT
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@6->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_INT
    jsr assertType
    // [22] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
    // testSimpleTypes::@7
    // assertType(typeid(12sw), typeid(signed word))
    // [23] call assertType
    // [41] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_INT [phi:testSimpleTypes::@7->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_INT
    // [41] phi assertType::t1#16 = TYPEID_INT [phi:testSimpleTypes::@7->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_INT
    jsr assertType
    // [24] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
    // testSimpleTypes::@8
    // assertType(typeid(12si), typeid(signed word))
    // [25] call assertType
    // [41] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_INT [phi:testSimpleTypes::@8->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_INT
    // [41] phi assertType::t1#16 = TYPEID_INT [phi:testSimpleTypes::@8->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_INT
    jsr assertType
    // [26] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
    // testSimpleTypes::@9
    // assertType(typeid(12ss), typeid(signed word))
    // [27] call assertType
    // [41] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_INT [phi:testSimpleTypes::@9->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_INT
    // [41] phi assertType::t1#16 = TYPEID_INT [phi:testSimpleTypes::@9->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_INT
    jsr assertType
    // [28] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
    // testSimpleTypes::@10
    // assertType(typeid(12ud), typeid(unsigned dword))
    // [29] call assertType
    // [41] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_LONG [phi:testSimpleTypes::@10->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_LONG
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_LONG [phi:testSimpleTypes::@10->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [30] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
    // testSimpleTypes::@11
    // assertType(typeid(12ul), typeid(unsigned dword))
    // [31] call assertType
    // [41] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_LONG [phi:testSimpleTypes::@11->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_LONG
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_LONG [phi:testSimpleTypes::@11->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_LONG
    jsr assertType
    // [32] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
    // testSimpleTypes::@12
    // assertType(typeid(12sd), typeid(signed dword))
    // [33] call assertType
    // [41] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_LONG [phi:testSimpleTypes::@12->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_LONG
    // [41] phi assertType::t1#16 = TYPEID_LONG [phi:testSimpleTypes::@12->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_LONG
    jsr assertType
    // [34] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
    // testSimpleTypes::@13
    // assertType(typeid(12sl), typeid(signed dword))
    // [35] call assertType
    // [41] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_LONG [phi:testSimpleTypes::@13->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_LONG
    // [41] phi assertType::t1#16 = TYPEID_LONG [phi:testSimpleTypes::@13->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_LONG
    jsr assertType
    // [36] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
    // testSimpleTypes::@14
    // assertType(typeid(12l), typeid(signed dword))
    // [37] call assertType
    // [41] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_LONG [phi:testSimpleTypes::@14->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_LONG
    // [41] phi assertType::t1#16 = TYPEID_LONG [phi:testSimpleTypes::@14->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_LONG
    jsr assertType
    // [38] phi from testSimpleTypes::@14 to testSimpleTypes::@15 [phi:testSimpleTypes::@14->testSimpleTypes::@15]
    // testSimpleTypes::@15
    // assertType(typeid(12u), typeid(unsigned word))
    // [39] call assertType
    // [41] phi from testSimpleTypes::@15 to assertType [phi:testSimpleTypes::@15->assertType]
    // [41] phi idx#44 = idx#20 [phi:testSimpleTypes::@15->assertType#0] -- register_copy 
    // [41] phi assertType::t2#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@15->assertType#1] -- vbuyy=vbuc1 
    ldy #TYPEID_UNSIGNED_INT
    // [41] phi assertType::t1#16 = TYPEID_UNSIGNED_INT [phi:testSimpleTypes::@15->assertType#2] -- vbuxx=vbuc1 
    ldx #TYPEID_UNSIGNED_INT
    jsr assertType
    // testSimpleTypes::@return
    // }
    // [40] return 
    rts
}
  // assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// void assertType(__register(X) char t1, __register(Y) char t2)
assertType: {
    // if(t1==t2)
    // [42] if(assertType::t1#16==assertType::t2#16) goto assertType::@1 -- vbuxx_eq_vbuyy_then_la1 
    sty.z $ff
    cpx.z $ff
    beq __b1
    // assertType::@3
    // COLS[idx] = RED
    // [43] COLS[idx#44] = RED -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #RED
    ldy.z idx
    sta COLS,y
    // assertType::@2
  __b2:
    // SCREEN[idx++] = t1
    // [44] SCREEN[idx#44] = assertType::t1#16 -- pbuc1_derefidx_vbuz1=vbuxx 
    ldy.z idx
    txa
    sta SCREEN,y
    // SCREEN[idx++] = t1;
    // [45] idx#20 = ++ idx#44 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // assertType::@return
    // }
    // [46] return 
    rts
    // assertType::@1
  __b1:
    // COLS[idx] = GREEN
    // [47] COLS[idx#44] = GREEN -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy.z idx
    sta COLS,y
    jmp __b2
}
  // File Data

