byte i=0;

void main() {
   byte a=4;
   a=a+inc();
   a=a+inc();
}

byte inc() {
  i = i+7;
  return i;
}
PROGRAM
  (byte) i ← (byte) 0
proc (void()) main()
  (byte) main::a ← (byte) 4
  (byte~) main::$0 ← call inc 
  (byte~) main::$1 ← (byte) main::a + (byte~) main::$0
  (byte) main::a ← (byte~) main::$1
  (byte~) main::$2 ← call inc 
  (byte~) main::$3 ← (byte) main::a + (byte~) main::$2
  (byte) main::a ← (byte~) main::$3
main::@return:
  return 
endproc // main()
proc (byte()) inc()
  (byte~) inc::$0 ← (byte) i + (byte) 7
  (byte) i ← (byte~) inc::$0
  (byte) inc::return ← (byte) i
  goto inc::@return
inc::@return:
  (byte) inc::return ← (byte) inc::return
  return (byte) inc::return
endproc // inc()
  call main 

SYMBOLS
(byte) i
(byte()) inc()
(byte~) inc::$0
(label) inc::@return
(byte) inc::return
(void()) main()
(byte~) main::$0
(byte~) main::$1
(byte~) main::$2
(byte~) main::$3
(label) main::@return
(byte) main::a

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) i ← (byte) 0
  to:@1
main: scope:[main]  from
  (byte) main::a ← (byte) 4
  (byte~) main::$0 ← call inc 
  (byte~) main::$1 ← (byte) main::a + (byte~) main::$0
  (byte) main::a ← (byte~) main::$1
  (byte~) main::$2 ← call inc 
  (byte~) main::$3 ← (byte) main::a + (byte~) main::$2
  (byte) main::a ← (byte~) main::$3
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
@1: scope:[]  from @begin
  to:@2
inc: scope:[inc]  from
  (byte~) inc::$0 ← (byte) i + (byte) 7
  (byte) i ← (byte~) inc::$0
  (byte) inc::return ← (byte) i
  to:inc::@return
inc::@return: scope:[inc]  from inc inc::@1
  (byte) inc::return ← (byte) inc::return
  return (byte) inc::return
  to:@return
inc::@1: scope:[inc]  from
  to:inc::@return
@2: scope:[]  from @1
  call main 
  to:@end
@end: scope:[]  from @2

Removing empty block @1
Removing empty block inc::@1
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) i ← (byte) 0
  to:@2
main: scope:[main]  from
  (byte) main::a ← (byte) 4
  (byte~) main::$0 ← call inc 
  (byte~) main::$1 ← (byte) main::a + (byte~) main::$0
  (byte) main::a ← (byte~) main::$1
  (byte~) main::$2 ← call inc 
  (byte~) main::$3 ← (byte) main::a + (byte~) main::$2
  (byte) main::a ← (byte~) main::$3
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
inc: scope:[inc]  from
  (byte~) inc::$0 ← (byte) i + (byte) 7
  (byte) i ← (byte~) inc::$0
  (byte) inc::return ← (byte) i
  to:inc::@return
inc::@return: scope:[inc]  from inc
  (byte) inc::return ← (byte) inc::return
  return (byte) inc::return
  to:@return
@2: scope:[]  from @begin
  call main 
  to:@end
@end: scope:[]  from @2

PROCEDURE MODIFY VARIABLE ANALYSIS
main modifies i
inc modifies i

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  (byte) i ← (byte) 0
  to:@2
main: scope:[main]  from @2
  (byte) main::a ← (byte) 4
  (byte) inc::return ← call inc param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inc::return
  (byte) i ← (byte) i
  (byte~) main::$1 ← (byte) main::a + (byte~) main::$0
  (byte) main::a ← (byte~) main::$1
  (byte) inc::return ← call inc param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$2 ← (byte) inc::return
  (byte) i ← (byte) i
  (byte~) main::$3 ← (byte) main::a + (byte~) main::$2
  (byte) main::a ← (byte~) main::$3
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) i ← (byte) i
  return 
  to:@return
inc: scope:[inc]  from main main::@1
  (byte~) inc::$0 ← (byte) i + (byte) 7
  (byte) i ← (byte~) inc::$0
  (byte) inc::return ← (byte) i
  to:inc::@return
inc::@return: scope:[inc]  from inc
  (byte) inc::return ← (byte) inc::return
  (byte) i ← (byte) i
  return (byte) inc::return
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) i ← (byte) i
  to:@end
@end: scope:[]  from @3

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) i#0 ← (byte) 0
  to:@2
main: scope:[main]  from @2
  (byte) i#13 ← phi( @2/(byte) i#14 )
  (byte) main::a#0 ← (byte) 4
  (byte) inc::return#0 ← call inc param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) main::a#3 ← phi( main/(byte) main::a#0 )
  (byte) i#7 ← phi( main/(byte) i#13 )
  (byte) inc::return#4 ← phi( main/(byte) inc::return#0 )
  (byte~) main::$0 ← (byte) inc::return#4
  (byte) i#1 ← (byte) i#7
  (byte~) main::$1 ← (byte) main::a#3 + (byte~) main::$0
  (byte) main::a#1 ← (byte~) main::$1
  (byte) inc::return#1 ← call inc param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) main::a#4 ← phi( main::@1/(byte) main::a#1 )
  (byte) i#8 ← phi( main::@1/(byte) i#1 )
  (byte) inc::return#5 ← phi( main::@1/(byte) inc::return#1 )
  (byte~) main::$2 ← (byte) inc::return#5
  (byte) i#2 ← (byte) i#8
  (byte~) main::$3 ← (byte) main::a#4 + (byte~) main::$2
  (byte) main::a#2 ← (byte~) main::$3
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) i#9 ← phi( main::@2/(byte) i#2 )
  (byte) i#3 ← (byte) i#9
  return 
  to:@return
inc: scope:[inc]  from main main::@1
  (byte) i#10 ← phi( main/(byte) i#13 main::@1/(byte) i#1 )
  (byte~) inc::$0 ← (byte) i#10 + (byte) 7
  (byte) i#4 ← (byte~) inc::$0
  (byte) inc::return#2 ← (byte) i#4
  to:inc::@return
inc::@return: scope:[inc]  from inc
  (byte) i#11 ← phi( inc/(byte) i#4 )
  (byte) inc::return#6 ← phi( inc/(byte) inc::return#2 )
  (byte) inc::return#3 ← (byte) inc::return#6
  (byte) i#5 ← (byte) i#11
  return (byte) inc::return#3
  to:@return
@2: scope:[]  from @begin
  (byte) i#14 ← phi( @begin/(byte) i#0 )
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) i#12 ← phi( @2/(byte) i#14 )
  (byte) i#6 ← (byte) i#12
  to:@end
@end: scope:[]  from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (byte) i#0 ← (byte) 0
  to:@2
main: scope:[main]  from @2
  (byte) i#13 ← phi( @2/(byte) i#14 )
  (byte) main::a#0 ← (byte) 4
  call inc param-assignment
  (byte) inc::return#0 ← (byte) inc::return#3
  to:main::@1
main::@1: scope:[main]  from main
  (byte) main::a#3 ← phi( main/(byte) main::a#0 )
  (byte) i#7 ← phi( main/(byte) i#5 )
  (byte) inc::return#4 ← phi( main/(byte) inc::return#0 )
  (byte~) main::$0 ← (byte) inc::return#4
  (byte) i#1 ← (byte) i#7
  (byte~) main::$1 ← (byte) main::a#3 + (byte~) main::$0
  (byte) main::a#1 ← (byte~) main::$1
  call inc param-assignment
  (byte) inc::return#1 ← (byte) inc::return#3
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) main::a#4 ← phi( main::@1/(byte) main::a#1 )
  (byte) i#8 ← phi( main::@1/(byte) i#5 )
  (byte) inc::return#5 ← phi( main::@1/(byte) inc::return#1 )
  (byte~) main::$2 ← (byte) inc::return#5
  (byte) i#2 ← (byte) i#8
  (byte~) main::$3 ← (byte) main::a#4 + (byte~) main::$2
  (byte) main::a#2 ← (byte~) main::$3
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) i#9 ← phi( main::@2/(byte) i#2 )
  (byte) i#3 ← (byte) i#9
  return 
  to:@return
inc: scope:[inc]  from main main::@1
  (byte) i#10 ← phi( main/(byte) i#13 main::@1/(byte) i#1 )
  (byte~) inc::$0 ← (byte) i#10 + (byte) 7
  (byte) i#4 ← (byte~) inc::$0
  (byte) inc::return#2 ← (byte) i#4
  to:inc::@return
inc::@return: scope:[inc]  from inc
  (byte) i#11 ← phi( inc/(byte) i#4 )
  (byte) inc::return#6 ← phi( inc/(byte) inc::return#2 )
  (byte) inc::return#3 ← (byte) inc::return#6
  (byte) i#5 ← (byte) i#11
  return 
  to:@return
@2: scope:[]  from @begin
  (byte) i#14 ← phi( @begin/(byte) i#0 )
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) i#12 ← phi( @2/(byte) i#3 )
  (byte) i#6 ← (byte) i#12
  to:@end
@end: scope:[]  from @3

INITIAL SSA SYMBOL TABLE
(label) @2
(label) @3
(label) @begin
(label) @end
(byte) i
(byte) i#0
(byte) i#1
(byte) i#10
(byte) i#11
(byte) i#12
(byte) i#13
(byte) i#14
(byte) i#2
(byte) i#3
(byte) i#4
(byte) i#5
(byte) i#6
(byte) i#7
(byte) i#8
(byte) i#9
(byte()) inc()
(byte~) inc::$0
(label) inc::@return
(byte) inc::return
(byte) inc::return#0
(byte) inc::return#1
(byte) inc::return#2
(byte) inc::return#3
(byte) inc::return#4
(byte) inc::return#5
(byte) inc::return#6
(void()) main()
(byte~) main::$0
(byte~) main::$1
(byte~) main::$2
(byte~) main::$3
(label) main::@1
(label) main::@2
(label) main::@return
(byte) main::a
(byte) main::a#0
(byte) main::a#1
(byte) main::a#2
(byte) main::a#3
(byte) main::a#4

Not aliassing across scopes: main::$0 inc::return#4
Not aliassing across scopes: main::$2 inc::return#5
Not aliassing across scopes: i#4 inc::$0
Not aliassing across scopes: inc::return#2 i#4
Alias (byte) i#0 = (byte) i#13 (byte) i#14 
Alias (byte) inc::return#0 = (byte) inc::return#3 (byte) inc::return#4 (byte) inc::return#1 (byte) inc::return#5 (byte) inc::return#6 (byte) inc::return#2 
Alias (byte) i#1 = (byte) i#7 (byte) i#5 (byte) i#8 (byte) i#2 (byte) i#9 (byte) i#3 (byte) i#11 (byte) i#4 (byte) i#12 (byte) i#6 
Alias (byte) main::a#0 = (byte) main::a#3 
Alias (byte) main::a#1 = (byte~) main::$1 (byte) main::a#4 
Alias (byte) main::a#2 = (byte~) main::$3 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) i#0 ← (byte) 0
  to:@2
main: scope:[main]  from @2
  (byte) main::a#0 ← (byte) 4
  call inc param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inc::return#0
  (byte) main::a#1 ← (byte) main::a#0 + (byte~) main::$0
  call inc param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$2 ← (byte) inc::return#0
  (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inc: scope:[inc]  from main main::@1
  (byte) i#10 ← phi( main/(byte) i#0 main::@1/(byte) i#1 )
  (byte~) inc::$0 ← (byte) i#10 + (byte) 7
  (byte) i#1 ← (byte~) inc::$0
  (byte) inc::return#0 ← (byte) i#1
  to:inc::@return
inc::@return: scope:[inc]  from inc
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Not aliassing across scopes: main::$0 inc::return#0
Not aliassing across scopes: main::$2 inc::return#0
Not aliassing across scopes: i#1 inc::$0
Not aliassing across scopes: inc::return#0 i#1
Constant (const byte) i#0 = 0
Constant (const byte) main::a#0 = 4
Succesful SSA optimization Pass2ConstantIdentification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call inc param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inc::return#0
  (byte) main::a#1 ← (const byte) main::a#0 + (byte~) main::$0
  call inc param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$2 ← (byte) inc::return#0
  (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inc: scope:[inc]  from main main::@1
  (byte) i#10 ← phi( main/(const byte) i#0 main::@1/(byte) i#1 )
  (byte~) inc::$0 ← (byte) i#10 + (byte) 7
  (byte) i#1 ← (byte~) inc::$0
  (byte) inc::return#0 ← (byte) i#1
  to:inc::@return
inc::@return: scope:[inc]  from inc
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Culled Empty Block (label) @3
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call inc param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inc::return#0
  (byte) main::a#1 ← (const byte) main::a#0 + (byte~) main::$0
  call inc param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$2 ← (byte) inc::return#0
  (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inc: scope:[inc]  from main main::@1
  (byte) i#10 ← phi( main/(const byte) i#0 main::@1/(byte) i#1 )
  (byte~) inc::$0 ← (byte) i#10 + (byte) 7
  (byte) i#1 ← (byte~) inc::$0
  (byte) inc::return#0 ← (byte) i#1
  to:inc::@return
inc::@return: scope:[inc]  from inc
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @2

Not aliassing across scopes: main::$0 inc::return#0
Not aliassing across scopes: main::$2 inc::return#0
Not aliassing across scopes: i#1 inc::$0
Not aliassing across scopes: inc::return#0 i#1
Not aliassing across scopes: main::$0 inc::return#0
Not aliassing across scopes: main::$2 inc::return#0
Not aliassing across scopes: i#1 inc::$0
Not aliassing across scopes: inc::return#0 i#1
Inlining constant with var siblings (const byte) main::a#0
Inlining constant with var siblings (const byte) main::a#0
Inlining constant with var siblings (const byte) i#0
Inlining constant with var siblings (const byte) i#0
Constant inlined main::a#0 = (byte) 4
Constant inlined i#0 = (byte) 0
Succesful SSA optimization Pass2ConstantInlining
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call inc param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inc::return#0
  (byte) main::a#1 ← (byte) 4 + (byte~) main::$0
  call inc param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$2 ← (byte) inc::return#0
  (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inc: scope:[inc]  from main main::@1
  (byte) i#10 ← phi( main/(byte) 0 main::@1/(byte) i#1 )
  (byte~) inc::$0 ← (byte) i#10 + (byte) 7
  (byte) i#1 ← (byte~) inc::$0
  (byte) inc::return#0 ← (byte) i#1
  to:inc::@return
inc::@return: scope:[inc]  from inc
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @2

FINAL SYMBOL TABLE
(label) @2
(label) @begin
(label) @end
(byte) i
(byte) i#1
(byte) i#10
(byte()) inc()
(byte~) inc::$0
(label) inc::@return
(byte) inc::return
(byte) inc::return#0
(void()) main()
(byte~) main::$0
(byte~) main::$2
(label) main::@1
(label) main::@2
(label) main::@return
(byte) main::a
(byte) main::a#1
(byte) main::a#2

Block Sequence Planned @begin @2 @end main main::@1 main::@2 main::@return inc inc::@return 
Block Sequence Planned @begin @2 @end main main::@1 main::@2 main::@return inc inc::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  to:@2
@2: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @2
main: scope:[main]  from @2
  call inc param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte~) main::$0 ← (byte) inc::return#0
  (byte) main::a#1 ← (byte) 4 + (byte~) main::$0
  (byte~) i#15 ← (byte) i#1
  call inc param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte~) main::$2 ← (byte) inc::return#0
  (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inc: scope:[inc]  from main main::@1
  (byte) i#10 ← phi( main/(byte) 0 main::@1/(byte~) i#15 )
  (byte~) inc::$0 ← (byte) i#10 + (byte) 7
  (byte) i#1 ← (byte~) inc::$0
  (byte) inc::return#0 ← (byte) i#1
  to:inc::@return
inc::@return: scope:[inc]  from inc
  return 
  to:@return

Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to 0:main 
Calls in [main] to 2:inc 6:inc 

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES FOUND
@begin: scope:[]  from
  to:@2
@2: scope:[]  from @begin
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @2
main: scope:[main]  from @2
  [1] phi() [ ]
  [2] call inc param-assignment [ inc::return#0 i#1 ]
  to:main::@1
main::@1: scope:[main]  from main
  [3] (byte~) main::$0 ← (byte) inc::return#0 [ main::$0 i#1 ]
  [4] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 [ main::a#1 i#1 ]
  [5] (byte~) i#15 ← (byte) i#1 [ main::a#1 i#15 ]
  [6] call inc param-assignment [ inc::return#0 main::a#1 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [7] (byte~) main::$2 ← (byte) inc::return#0 [ main::a#1 main::$2 ]
  [8] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [9] return  [ ]
  to:@return
inc: scope:[inc]  from main main::@1
  [10] (byte) i#10 ← phi( main/(byte) 0 main::@1/(byte~) i#15 ) [ i#10 ]
  [11] (byte~) inc::$0 ← (byte) i#10 + (byte) 7 [ inc::$0 ]
  [12] (byte) i#1 ← (byte~) inc::$0 [ i#1 ]
  [13] (byte) inc::return#0 ← (byte) i#1 [ inc::return#0 i#1 ]
  to:inc::@return
inc::@return: scope:[inc]  from inc
  [14] return  [ inc::return#0 i#1 ]
  to:@return

Created 1 initial phi equivalence classes
Coalesced [5] i#15 ← i#1
Coalesced [12] i#1 ← inc::$0
Coalesced down to 1 phi equivalence classes
Block Sequence Planned @begin @2 @end main main::@1 main::@2 main::@return inc inc::@return 
Adding NOP phi() at start of main
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  to:@2
@2: scope:[]  from @begin
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @2
main: scope:[main]  from @2
  [1] phi() [ ]
  [2] call inc param-assignment [ inc::return#0 inc::$0 ]
  to:main::@1
main::@1: scope:[main]  from main
  [3] (byte~) main::$0 ← (byte) inc::return#0 [ main::$0 inc::$0 ]
  [4] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 [ main::a#1 inc::$0 ]
  [5] call inc param-assignment [ inc::return#0 main::a#1 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [6] (byte~) main::$2 ← (byte) inc::return#0 [ main::a#1 main::$2 ]
  [7] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [8] return  [ ]
  to:@return
inc: scope:[inc]  from main main::@1
  [9] (byte) i#10 ← phi( main/(byte) 0 main::@1/(byte~) inc::$0 ) [ i#10 ]
  [10] (byte~) inc::$0 ← (byte) i#10 + (byte) 7 [ inc::$0 ]
  [11] (byte) inc::return#0 ← (byte~) inc::$0 [ inc::return#0 inc::$0 ]
  to:inc::@return
inc::@return: scope:[inc]  from inc
  [12] return  [ inc::return#0 inc::$0 ]
  to:@return

DOMINATORS
@begin dominated by  @begin 
@2 dominated by  @2 @begin 
@end dominated by  @2 @end @begin 
main dominated by  @2 @begin main 
main::@1 dominated by  @2 @begin main::@1 main 
main::@2 dominated by  @2 @begin main::@2 main::@1 main 
main::@return dominated by  @2 main::@return @begin main::@2 main::@1 main 
inc dominated by  @2 inc @begin main 
inc::@return dominated by  @2 inc @begin inc::@return main 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [main]
Found 0 loops in scope [inc]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(byte) i
(byte) i#10 4.0
(byte()) inc()
(byte~) inc::$0 1.0
(byte) inc::return
(byte) inc::return#0 1.5
(void()) main()
(byte~) main::$0 4.0
(byte~) main::$2 4.0
(byte) main::a
(byte) main::a#1 1.3333333333333333
(byte) main::a#2 20.0

Initial phi equivalence classes
[ i#10 inc::$0 ]
Added variable main::$0 to zero page equivalence class [ main::$0 ]
Added variable main::a#1 to zero page equivalence class [ main::a#1 ]
Added variable main::$2 to zero page equivalence class [ main::$2 ]
Added variable main::a#2 to zero page equivalence class [ main::a#2 ]
Added variable inc::return#0 to zero page equivalence class [ inc::return#0 ]
Complete equivalence classes
[ i#10 inc::$0 ]
[ main::$0 ]
[ main::a#1 ]
[ main::$2 ]
[ main::a#2 ]
[ inc::return#0 ]
Allocated zp ZP_BYTE:2 [ i#10 inc::$0 ]
Allocated zp ZP_BYTE:3 [ main::$0 ]
Allocated zp ZP_BYTE:4 [ main::a#1 ]
Allocated zp ZP_BYTE:5 [ main::$2 ]
Allocated zp ZP_BYTE:6 [ main::a#2 ]
Allocated zp ZP_BYTE:7 [ inc::return#0 ]
INITIAL ASM
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label i = 2
//SEG2 @begin
bbegin:
  jmp b2
//SEG3 @2
b2:
//SEG4 [0] call main param-assignment [ ]
//SEG5 [1] phi from @2 to main [phi:@2->main]
main_from_b2:
  jsr main
  jmp bend
//SEG6 @end
bend:
//SEG7 main
main: {
    .label _0 = 3
    .label _2 = 5
    .label a = 4
    .label a_2 = 6
  //SEG8 [2] call inc param-assignment [ inc::return#0 inc::$0 ]
  //SEG9 [9] phi from main to inc [phi:main->inc]
  inc_from_main:
  //SEG10 [9] phi (byte) i#10 = (byte) 0 [phi:main->inc#0] -- zpby1=coby1 
    lda #0
    sta i
    jsr inc
    jmp b1
  //SEG11 main::@1
  b1:
  //SEG12 [3] (byte~) main::$0 ← (byte) inc::return#0 [ main::$0 inc::$0 ] -- zpby1=zpby2 
    lda inc.return
    sta _0
  //SEG13 [4] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 [ main::a#1 inc::$0 ] -- zpby1=coby1_plus_zpby2 
    lda _0
    clc
    adc #4
    sta a
  //SEG14 [5] call inc param-assignment [ inc::return#0 main::a#1 ]
  //SEG15 [9] phi from main::@1 to inc [phi:main::@1->inc]
  inc_from_b1:
  //SEG16 [9] phi (byte) i#10 = (byte~) inc::$0 [phi:main::@1->inc#0] -- register_copy 
    jsr inc
    jmp b2
  //SEG17 main::@2
  b2:
  //SEG18 [6] (byte~) main::$2 ← (byte) inc::return#0 [ main::a#1 main::$2 ] -- zpby1=zpby2 
    lda inc.return
    sta _2
  //SEG19 [7] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ ] -- zpby1=zpby2_plus_zpby3 
    lda a
    clc
    adc _2
    sta a_2
    jmp breturn
  //SEG20 main::@return
  breturn:
  //SEG21 [8] return  [ ]
    rts
}
//SEG22 inc
inc: {
    .label _0 = 2
    .label return = 7
  //SEG23 [10] (byte~) inc::$0 ← (byte) i#10 + (byte) 7 [ inc::$0 ] -- zpby1=zpby1_plus_coby1 
    lda _0
    clc
    adc #7
    sta _0
  //SEG24 [11] (byte) inc::return#0 ← (byte~) inc::$0 [ inc::return#0 inc::$0 ] -- zpby1=zpby2 
    lda _0
    sta return
    jmp breturn
  //SEG25 inc::@return
  breturn:
  //SEG26 [12] return  [ inc::return#0 inc::$0 ]
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [4] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 [ main::a#1 inc::$0 ] always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ i#10 inc::$0 ]
Statement [10] (byte~) inc::$0 ← (byte) i#10 + (byte) 7 [ inc::$0 ] always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ main::a#1 ]
Statement [4] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 [ main::a#1 inc::$0 ] always clobbers reg byte a 
Statement [7] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ ] always clobbers reg byte a 
Statement [10] (byte~) inc::$0 ← (byte) i#10 + (byte) 7 [ inc::$0 ] always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ i#10 inc::$0 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ main::$0 ] : zp ZP_BYTE:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ main::a#1 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ main::$2 ] : zp ZP_BYTE:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ main::a#2 ] : zp ZP_BYTE:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ inc::return#0 ] : zp ZP_BYTE:7 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 20: zp ZP_BYTE:6 [ main::a#2 ] 4: zp ZP_BYTE:3 [ main::$0 ] 4: zp ZP_BYTE:5 [ main::$2 ] 1.33: zp ZP_BYTE:4 [ main::a#1 ] 
Uplift Scope [] 5: zp ZP_BYTE:2 [ i#10 inc::$0 ] 
Uplift Scope [inc] 1.5: zp ZP_BYTE:7 [ inc::return#0 ] 

Uplifting [main] best 114 combination reg byte a [ main::a#2 ] reg byte a [ main::$0 ] reg byte a [ main::$2 ] zp ZP_BYTE:4 [ main::a#1 ] 
Uplifting [] best 106 combination reg byte x [ i#10 inc::$0 ] 
Uplifting [inc] best 99 combination reg byte a [ inc::return#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:4 [ main::a#1 ]
Uplifting [main] best 99 combination zp ZP_BYTE:4 [ main::a#1 ] 
Allocated (was zp ZP_BYTE:4) zp ZP_BYTE:2 [ main::a#1 ]
Removing instruction jmp b2
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
//SEG2 @begin
bbegin:
//SEG3 @2
b2:
//SEG4 [0] call main param-assignment [ ]
//SEG5 [1] phi from @2 to main [phi:@2->main]
main_from_b2:
  jsr main
//SEG6 @end
bend:
//SEG7 main
main: {
    .label a = 2
  //SEG8 [2] call inc param-assignment [ inc::return#0 inc::$0 ]
  //SEG9 [9] phi from main to inc [phi:main->inc]
  inc_from_main:
  //SEG10 [9] phi (byte) i#10 = (byte) 0 [phi:main->inc#0] -- xby=coby1 
    ldx #0
    jsr inc
  //SEG11 main::@1
  b1:
  //SEG12 [3] (byte~) main::$0 ← (byte) inc::return#0 [ main::$0 inc::$0 ]
    // (byte~) main::$0 = (byte) inc::return#0  // register copy reg byte a
  //SEG13 [4] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 [ main::a#1 inc::$0 ] -- zpby1=coby1_plus_aby 
    clc
    adc #4
    sta a
  //SEG14 [5] call inc param-assignment [ inc::return#0 main::a#1 ]
  //SEG15 [9] phi from main::@1 to inc [phi:main::@1->inc]
  inc_from_b1:
  //SEG16 [9] phi (byte) i#10 = (byte~) inc::$0 [phi:main::@1->inc#0] -- register_copy 
    jsr inc
  //SEG17 main::@2
  b2:
  //SEG18 [6] (byte~) main::$2 ← (byte) inc::return#0 [ main::a#1 main::$2 ]
    // (byte~) main::$2 = (byte) inc::return#0  // register copy reg byte a
  //SEG19 [7] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ ] -- aby=zpby1_plus_aby 
    clc
    adc a
  //SEG20 main::@return
  breturn:
  //SEG21 [8] return  [ ]
    rts
}
//SEG22 inc
inc: {
  //SEG23 [10] (byte~) inc::$0 ← (byte) i#10 + (byte) 7 [ inc::$0 ] -- xby=xby_plus_coby1 
    txa
    clc
    adc #7
    tax
  //SEG24 [11] (byte) inc::return#0 ← (byte~) inc::$0 [ inc::return#0 inc::$0 ] -- aby=xby 
    txa
  //SEG25 inc::@return
  breturn:
  //SEG26 [12] return  [ inc::return#0 inc::$0 ]
    rts
}

Removing instruction bbegin:
Removing instruction main_from_b2:
Succesful ASM optimization Pass5RedundantLabelElimination
ASSEMBLER
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
//SEG2 @begin
//SEG3 @2
b2:
//SEG4 [0] call main param-assignment [ ]
//SEG5 [1] phi from @2 to main [phi:@2->main]
  jsr main
//SEG6 @end
bend:
//SEG7 main
main: {
    .label a = 2
  //SEG8 [2] call inc param-assignment [ inc::return#0 inc::$0 ]
  //SEG9 [9] phi from main to inc [phi:main->inc]
  inc_from_main:
  //SEG10 [9] phi (byte) i#10 = (byte) 0 [phi:main->inc#0] -- xby=coby1 
    ldx #0
    jsr inc
  //SEG11 main::@1
  b1:
  //SEG12 [3] (byte~) main::$0 ← (byte) inc::return#0 [ main::$0 inc::$0 ]
    // (byte~) main::$0 = (byte) inc::return#0  // register copy reg byte a
  //SEG13 [4] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 [ main::a#1 inc::$0 ] -- zpby1=coby1_plus_aby 
    clc
    adc #4
    sta a
  //SEG14 [5] call inc param-assignment [ inc::return#0 main::a#1 ]
  //SEG15 [9] phi from main::@1 to inc [phi:main::@1->inc]
  inc_from_b1:
  //SEG16 [9] phi (byte) i#10 = (byte~) inc::$0 [phi:main::@1->inc#0] -- register_copy 
    jsr inc
  //SEG17 main::@2
  b2:
  //SEG18 [6] (byte~) main::$2 ← (byte) inc::return#0 [ main::a#1 main::$2 ]
    // (byte~) main::$2 = (byte) inc::return#0  // register copy reg byte a
  //SEG19 [7] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ ] -- aby=zpby1_plus_aby 
    clc
    adc a
  //SEG20 main::@return
  breturn:
  //SEG21 [8] return  [ ]
    rts
}
//SEG22 inc
inc: {
  //SEG23 [10] (byte~) inc::$0 ← (byte) i#10 + (byte) 7 [ inc::$0 ] -- xby=xby_plus_coby1 
    txa
    clc
    adc #7
    tax
  //SEG24 [11] (byte) inc::return#0 ← (byte~) inc::$0 [ inc::return#0 inc::$0 ] -- aby=xby 
    txa
  //SEG25 inc::@return
  breturn:
  //SEG26 [12] return  [ inc::return#0 inc::$0 ]
    rts
}

Removing instruction b2:
Removing instruction bend:
Removing instruction inc_from_main:
Removing instruction b1:
Removing instruction inc_from_b1:
Removing instruction b2:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
ASSEMBLER
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
//SEG2 @begin
//SEG3 @2
//SEG4 [0] call main param-assignment [ ]
//SEG5 [1] phi from @2 to main [phi:@2->main]
  jsr main
//SEG6 @end
//SEG7 main
main: {
    .label a = 2
  //SEG8 [2] call inc param-assignment [ inc::return#0 inc::$0 ]
  //SEG9 [9] phi from main to inc [phi:main->inc]
  //SEG10 [9] phi (byte) i#10 = (byte) 0 [phi:main->inc#0] -- xby=coby1 
    ldx #0
    jsr inc
  //SEG11 main::@1
  //SEG12 [3] (byte~) main::$0 ← (byte) inc::return#0 [ main::$0 inc::$0 ]
    // (byte~) main::$0 = (byte) inc::return#0  // register copy reg byte a
  //SEG13 [4] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 [ main::a#1 inc::$0 ] -- zpby1=coby1_plus_aby 
    clc
    adc #4
    sta a
  //SEG14 [5] call inc param-assignment [ inc::return#0 main::a#1 ]
  //SEG15 [9] phi from main::@1 to inc [phi:main::@1->inc]
  //SEG16 [9] phi (byte) i#10 = (byte~) inc::$0 [phi:main::@1->inc#0] -- register_copy 
    jsr inc
  //SEG17 main::@2
  //SEG18 [6] (byte~) main::$2 ← (byte) inc::return#0 [ main::a#1 main::$2 ]
    // (byte~) main::$2 = (byte) inc::return#0  // register copy reg byte a
  //SEG19 [7] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ ] -- aby=zpby1_plus_aby 
    clc
    adc a
  //SEG20 main::@return
  //SEG21 [8] return  [ ]
    rts
}
//SEG22 inc
inc: {
  //SEG23 [10] (byte~) inc::$0 ← (byte) i#10 + (byte) 7 [ inc::$0 ] -- xby=xby_plus_coby1 
    txa
    clc
    adc #7
    tax
  //SEG24 [11] (byte) inc::return#0 ← (byte~) inc::$0 [ inc::return#0 inc::$0 ] -- aby=xby 
    txa
  //SEG25 inc::@return
  //SEG26 [12] return  [ inc::return#0 inc::$0 ]
    rts
}

FINAL SYMBOL TABLE
(label) @2
(label) @begin
(label) @end
(byte) i
(byte) i#10 reg byte x 4.0
(byte()) inc()
(byte~) inc::$0 reg byte x 1.0
(label) inc::@return
(byte) inc::return
(byte) inc::return#0 reg byte a 1.5
(void()) main()
(byte~) main::$0 reg byte a 4.0
(byte~) main::$2 reg byte a 4.0
(label) main::@1
(label) main::@2
(label) main::@return
(byte) main::a
(byte) main::a#1 a zp ZP_BYTE:2 1.3333333333333333
(byte) main::a#2 reg byte a 20.0

reg byte x [ i#10 inc::$0 ]
reg byte a [ main::$0 ]
zp ZP_BYTE:2 [ main::a#1 ]
reg byte a [ main::$2 ]
reg byte a [ main::a#2 ]
reg byte a [ inc::return#0 ]

FINAL CODE
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
//SEG2 @begin
//SEG3 @2
//SEG4 [0] call main param-assignment [ ]
//SEG5 [1] phi from @2 to main [phi:@2->main]
  jsr main
//SEG6 @end
//SEG7 main
main: {
    .label a = 2
  //SEG8 [2] call inc param-assignment [ inc::return#0 inc::$0 ]
  //SEG9 [9] phi from main to inc [phi:main->inc]
  //SEG10 [9] phi (byte) i#10 = (byte) 0 [phi:main->inc#0] -- xby=coby1 
    ldx #0
    jsr inc
  //SEG11 main::@1
  //SEG12 [3] (byte~) main::$0 ← (byte) inc::return#0 [ main::$0 inc::$0 ]
    // (byte~) main::$0 = (byte) inc::return#0  // register copy reg byte a
  //SEG13 [4] (byte) main::a#1 ← (byte) 4 + (byte~) main::$0 [ main::a#1 inc::$0 ] -- zpby1=coby1_plus_aby 
    clc
    adc #4
    sta a
  //SEG14 [5] call inc param-assignment [ inc::return#0 main::a#1 ]
  //SEG15 [9] phi from main::@1 to inc [phi:main::@1->inc]
  //SEG16 [9] phi (byte) i#10 = (byte~) inc::$0 [phi:main::@1->inc#0] -- register_copy 
    jsr inc
  //SEG17 main::@2
  //SEG18 [6] (byte~) main::$2 ← (byte) inc::return#0 [ main::a#1 main::$2 ]
    // (byte~) main::$2 = (byte) inc::return#0  // register copy reg byte a
  //SEG19 [7] (byte) main::a#2 ← (byte) main::a#1 + (byte~) main::$2 [ ] -- aby=zpby1_plus_aby 
    clc
    adc a
  //SEG20 main::@return
  //SEG21 [8] return  [ ]
    rts
}
//SEG22 inc
inc: {
  //SEG23 [10] (byte~) inc::$0 ← (byte) i#10 + (byte) 7 [ inc::$0 ] -- xby=xby_plus_coby1 
    txa
    clc
    adc #7
    tax
  //SEG24 [11] (byte) inc::return#0 ← (byte~) inc::$0 [ inc::return#0 inc::$0 ] -- aby=xby 
    txa
  //SEG25 inc::@return
  //SEG26 [12] return  [ inc::return#0 inc::$0 ]
    rts
}

