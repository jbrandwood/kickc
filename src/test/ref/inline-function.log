Identified constant variable (byte*) RASTER
Identified constant variable (byte*) D018
Identified constant variable (byte*) BGCOL
Identified constant variable (byte*) screen
Identified constant variable (byte*) charset1
Identified constant variable (byte*) charset2
Inlined call (byte~) main::$1 ← call toD018 (byte*) screen (byte*) charset1 
Inlined call (byte~) main::$3 ← call toD018 (byte*) screen (byte*) charset2 

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) RASTER#0 ← ((byte*)) (word/dword/signed dword) $d012
  (byte*) D018#0 ← ((byte*)) (word/dword/signed dword) $d018
  (byte*) BGCOL#0 ← ((byte*)) (word/dword/signed dword) $d021
  (byte*) screen#0 ← ((byte*)) (word/signed word/dword/signed dword) $400
  (byte*) charset1#0 ← ((byte*)) (word/signed word/dword/signed dword) $1000
  (byte*) charset2#0 ← ((byte*)) (word/signed word/dword/signed dword) $1800
  to:@2
main: scope:[main]  from @2
  asm { sei  }
  to:main::@1
main::@1: scope:[main]  from main main::@20
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  to:main::@6
main::@6: scope:[main]  from main::@2 main::@7
  (bool~) main::$0 ← *((byte*) RASTER#0) != (byte/word/signed word/dword/signed dword) $ff
  if((bool~) main::$0) goto main::@7
  to:main::@8
main::@7: scope:[main]  from main::@6
  to:main::@6
main::@8: scope:[main]  from main::@6
  (byte*) main::toD0181_screen#0 ← (byte*) screen#0
  (byte*) main::toD0181_charset#0 ← (byte*) charset1#0
  to:main::toD0181
main::toD0181: scope:[main]  from main::@8
  (byte*) main::toD0181_charset#1 ← phi( main::@8/(byte*) main::toD0181_charset#0 )
  (byte*) main::toD0181_screen#1 ← phi( main::@8/(byte*) main::toD0181_screen#0 )
  (word) main::toD0181_$0#0 ← ((word)) (byte*) main::toD0181_screen#1
  (word/signed dword/dword) main::toD0181_$1#0 ← (word) main::toD0181_$0#0 / (byte/signed byte/word/signed word/dword/signed dword) $40
  (word) main::toD0181_$2#0 ← ((word)) (byte*) main::toD0181_charset#1
  (word/signed dword/dword) main::toD0181_$3#0 ← (word) main::toD0181_$2#0 / (word/signed word/dword/signed dword) $400
  (word/dword) main::toD0181_$4#0 ← (word/signed dword/dword) main::toD0181_$1#0 | (word/signed dword/dword) main::toD0181_$3#0
  (byte) main::toD0181_$5#0 ← ((byte)) (word/dword) main::toD0181_$4#0
  (byte) main::toD0181_return#0 ← (byte) main::toD0181_$5#0
  to:main::toD0181_@return
main::toD0181_@return: scope:[main]  from main::toD0181
  (byte) main::toD0181_return#2 ← phi( main::toD0181/(byte) main::toD0181_return#0 )
  (byte) main::toD0181_return#1 ← (byte) main::toD0181_return#2
  to:main::@19
main::@19: scope:[main]  from main::toD0181_@return
  (byte) main::toD0181_return#3 ← phi( main::toD0181_@return/(byte) main::toD0181_return#1 )
  (byte~) main::$1 ← (byte) main::toD0181_return#3
  *((byte*) D018#0) ← (byte~) main::$1
  *((byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 6
  to:main::@9
main::@9: scope:[main]  from main::@10 main::@19
  (bool~) main::$2 ← *((byte*) RASTER#0) != (byte/signed byte/word/signed word/dword/signed dword) $62
  if((bool~) main::$2) goto main::@10
  to:main::@11
main::@10: scope:[main]  from main::@9
  to:main::@9
main::@11: scope:[main]  from main::@9
  (byte*) main::toD0182_screen#0 ← (byte*) screen#0
  (byte*) main::toD0182_charset#0 ← (byte*) charset2#0
  to:main::toD0182
main::toD0182: scope:[main]  from main::@11
  (byte*) main::toD0182_charset#1 ← phi( main::@11/(byte*) main::toD0182_charset#0 )
  (byte*) main::toD0182_screen#1 ← phi( main::@11/(byte*) main::toD0182_screen#0 )
  (word) main::toD0182_$0#0 ← ((word)) (byte*) main::toD0182_screen#1
  (word/signed dword/dword) main::toD0182_$1#0 ← (word) main::toD0182_$0#0 / (byte/signed byte/word/signed word/dword/signed dword) $40
  (word) main::toD0182_$2#0 ← ((word)) (byte*) main::toD0182_charset#1
  (word/signed dword/dword) main::toD0182_$3#0 ← (word) main::toD0182_$2#0 / (word/signed word/dword/signed dword) $400
  (word/dword) main::toD0182_$4#0 ← (word/signed dword/dword) main::toD0182_$1#0 | (word/signed dword/dword) main::toD0182_$3#0
  (byte) main::toD0182_$5#0 ← ((byte)) (word/dword) main::toD0182_$4#0
  (byte) main::toD0182_return#0 ← (byte) main::toD0182_$5#0
  to:main::toD0182_@return
main::toD0182_@return: scope:[main]  from main::toD0182
  (byte) main::toD0182_return#2 ← phi( main::toD0182/(byte) main::toD0182_return#0 )
  (byte) main::toD0182_return#1 ← (byte) main::toD0182_return#2
  to:main::@20
main::@20: scope:[main]  from main::toD0182_@return
  (byte) main::toD0182_return#3 ← phi( main::toD0182_@return/(byte) main::toD0182_return#1 )
  (byte~) main::$3 ← (byte) main::toD0182_return#3
  *((byte*) D018#0) ← (byte~) main::$3
  *((byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) $b
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return
@2: scope:[]  from @begin
  call main 
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(label) @2
(label) @3
(label) @begin
(label) @end
(byte*) BGCOL
(byte*) BGCOL#0
(byte*) D018
(byte*) D018#0
(byte*) RASTER
(byte*) RASTER#0
(byte*) charset1
(byte*) charset1#0
(byte*) charset2
(byte*) charset2#0
(void()) main()
(bool~) main::$0
(byte~) main::$1
(bool~) main::$2
(byte~) main::$3
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return
(label) main::toD0181
(word~) main::toD0181_$0
(word) main::toD0181_$0#0
(word/signed dword/dword~) main::toD0181_$1
(word/signed dword/dword) main::toD0181_$1#0
(word~) main::toD0181_$2
(word) main::toD0181_$2#0
(word/signed dword/dword~) main::toD0181_$3
(word/signed dword/dword) main::toD0181_$3#0
(word/dword~) main::toD0181_$4
(word/dword) main::toD0181_$4#0
(byte~) main::toD0181_$5
(byte) main::toD0181_$5#0
(label) main::toD0181_@return
(byte*) main::toD0181_charset
(byte*) main::toD0181_charset#0
(byte*) main::toD0181_charset#1
(byte) main::toD0181_return
(byte) main::toD0181_return#0
(byte) main::toD0181_return#1
(byte) main::toD0181_return#2
(byte) main::toD0181_return#3
(byte*) main::toD0181_screen
(byte*) main::toD0181_screen#0
(byte*) main::toD0181_screen#1
(label) main::toD0182
(word~) main::toD0182_$0
(word) main::toD0182_$0#0
(word/signed dword/dword~) main::toD0182_$1
(word/signed dword/dword) main::toD0182_$1#0
(word~) main::toD0182_$2
(word) main::toD0182_$2#0
(word/signed dword/dword~) main::toD0182_$3
(word/signed dword/dword) main::toD0182_$3#0
(word/dword~) main::toD0182_$4
(word/dword) main::toD0182_$4#0
(byte~) main::toD0182_$5
(byte) main::toD0182_$5#0
(label) main::toD0182_@return
(byte*) main::toD0182_charset
(byte*) main::toD0182_charset#0
(byte*) main::toD0182_charset#1
(byte) main::toD0182_return
(byte) main::toD0182_return#0
(byte) main::toD0182_return#1
(byte) main::toD0182_return#2
(byte) main::toD0182_return#3
(byte*) main::toD0182_screen
(byte*) main::toD0182_screen#0
(byte*) main::toD0182_screen#1
(byte*) screen
(byte*) screen#0

Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@10
Culled Empty Block (label) @3
Successful SSA optimization Pass2CullEmptyBlocks
Alias (byte*) main::toD0181_screen#0 = (byte*) main::toD0181_screen#1 
Alias (byte*) main::toD0181_charset#0 = (byte*) main::toD0181_charset#1 
Alias (byte) main::toD0181_return#0 = (byte) main::toD0181_$5#0 (byte) main::toD0181_return#2 (byte) main::toD0181_return#1 (byte) main::toD0181_return#3 (byte~) main::$1 
Alias (byte*) main::toD0182_screen#0 = (byte*) main::toD0182_screen#1 
Alias (byte*) main::toD0182_charset#0 = (byte*) main::toD0182_charset#1 
Alias (byte) main::toD0182_return#0 = (byte) main::toD0182_$5#0 (byte) main::toD0182_return#2 (byte) main::toD0182_return#1 (byte) main::toD0182_return#3 (byte~) main::$3 
Successful SSA optimization Pass2AliasElimination
Simple Condition (bool~) main::$0 [9] if(*((byte*) RASTER#0)!=(byte/word/signed word/dword/signed dword) $ff) goto main::@6
Simple Condition (bool~) main::$2 [27] if(*((byte*) RASTER#0)!=(byte/signed byte/word/signed word/dword/signed dword) $62) goto main::@9
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) RASTER#0 = ((byte*))$d012
Constant (const byte*) D018#0 = ((byte*))$d018
Constant (const byte*) BGCOL#0 = ((byte*))$d021
Constant (const byte*) screen#0 = ((byte*))$400
Constant (const byte*) charset1#0 = ((byte*))$1000
Constant (const byte*) charset2#0 = ((byte*))$1800
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) main::toD0181_screen#0 = screen#0
Constant (const byte*) main::toD0181_charset#0 = charset1#0
Constant (const byte*) main::toD0182_screen#0 = screen#0
Constant (const byte*) main::toD0182_charset#0 = charset2#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const word) main::toD0181_$0#0 = ((word))main::toD0181_screen#0
Constant (const word) main::toD0181_$2#0 = ((word))main::toD0181_charset#0
Constant (const word) main::toD0182_$0#0 = ((word))main::toD0182_screen#0
Constant (const word) main::toD0182_$2#0 = ((word))main::toD0182_charset#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const word/signed dword/dword) main::toD0181_$1#0 = main::toD0181_$0#0/$40
Constant (const word/signed dword/dword) main::toD0181_$3#0 = main::toD0181_$2#0/$400
Constant (const word/signed dword/dword) main::toD0182_$1#0 = main::toD0182_$0#0/$40
Constant (const word/signed dword/dword) main::toD0182_$3#0 = main::toD0182_$2#0/$400
Successful SSA optimization Pass2ConstantIdentification
Constant (const word/dword) main::toD0181_$4#0 = main::toD0181_$1#0|main::toD0181_$3#0
Constant (const word/dword) main::toD0182_$4#0 = main::toD0182_$1#0|main::toD0182_$3#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) main::toD0181_return#0 = ((byte))main::toD0181_$4#0
Constant (const byte) main::toD0182_return#0 = ((byte))main::toD0182_$4#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [1] if(true) goto main::@6
Successful SSA optimization Pass2ConstantIfs
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Culled Empty Block (label) main::@1
Culled Empty Block (label) main::@8
Culled Empty Block (label) main::toD0181_@return
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::toD0182_@return
Successful SSA optimization Pass2CullEmptyBlocks
Constant inlined main::toD0181_screen#0 = (const byte*) screen#0
Constant inlined main::toD0182_charset#0 = (const byte*) charset2#0
Constant inlined main::toD0182_$4#0 = ((word))(const byte*) screen#0/(byte/signed byte/word/signed word/dword/signed dword) $40|((word))(const byte*) charset2#0/(word/signed word/dword/signed dword) $400
Constant inlined main::toD0182_$3#0 = ((word))(const byte*) charset2#0/(word/signed word/dword/signed dword) $400
Constant inlined main::toD0181_$0#0 = ((word))(const byte*) screen#0
Constant inlined main::toD0181_$1#0 = ((word))(const byte*) screen#0/(byte/signed byte/word/signed word/dword/signed dword) $40
Constant inlined main::toD0181_$2#0 = ((word))(const byte*) charset1#0
Constant inlined main::toD0182_$0#0 = ((word))(const byte*) screen#0
Constant inlined main::toD0181_$3#0 = ((word))(const byte*) charset1#0/(word/signed word/dword/signed dword) $400
Constant inlined main::toD0182_screen#0 = (const byte*) screen#0
Constant inlined main::toD0182_$2#0 = ((word))(const byte*) charset2#0
Constant inlined main::toD0181_$4#0 = ((word))(const byte*) screen#0/(byte/signed byte/word/signed word/dword/signed dword) $40|((word))(const byte*) charset1#0/(word/signed word/dword/signed dword) $400
Constant inlined main::toD0182_$1#0 = ((word))(const byte*) screen#0/(byte/signed byte/word/signed word/dword/signed dword) $40
Constant inlined main::toD0181_charset#0 = (const byte*) charset1#0
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0182
CALL GRAPH
Calls in [] to main:2 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Renumbering block @2 to @1
Renumbering block main::@6 to main::@1
Renumbering block main::@9 to main::@2
Renumbering block main::@19 to main::@3
Renumbering block main::@20 to main::@4
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0182

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  asm { sei  }
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@4
  [5] if(*((const byte*) RASTER#0)!=(byte/word/signed word/dword/signed dword) $ff) goto main::@1
  to:main::toD0181
main::toD0181: scope:[main]  from main::@1
  [6] phi()
  to:main::@3
main::@3: scope:[main]  from main::toD0181
  [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0
  [8] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 6
  to:main::@2
main::@2: scope:[main]  from main::@2 main::@3
  [9] if(*((const byte*) RASTER#0)!=(byte/signed byte/word/signed word/dword/signed dword) $62) goto main::@2
  to:main::toD0182
main::toD0182: scope:[main]  from main::@2
  [10] phi()
  to:main::@4
main::@4: scope:[main]  from main::toD0182
  [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0
  [12] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) $b
  to:main::@1


VARIABLE REGISTER WEIGHTS
(byte*) BGCOL
(byte*) D018
(byte*) RASTER
(byte*) charset1
(byte*) charset2
(void()) main()
(word~) main::toD0181_$0
(word/signed dword/dword~) main::toD0181_$1
(word~) main::toD0181_$2
(word/signed dword/dword~) main::toD0181_$3
(word/dword~) main::toD0181_$4
(byte~) main::toD0181_$5
(byte*) main::toD0181_charset
(byte) main::toD0181_return
(byte*) main::toD0181_screen
(word~) main::toD0182_$0
(word/signed dword/dword~) main::toD0182_$1
(word~) main::toD0182_$2
(word/signed dword/dword~) main::toD0182_$3
(word/dword~) main::toD0182_$4
(byte~) main::toD0182_$5
(byte*) main::toD0182_charset
(byte) main::toD0182_return
(byte*) main::toD0182_screen
(byte*) screen

Initial phi equivalence classes
Complete equivalence classes

INITIAL ASM
//SEG0 File Comments
// Test inline function
// Splits screen so upper half is lower case and lower half lower case
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label RASTER = $d012
  .label D018 = $d018
  .label BGCOL = $d021
  .label screen = $400
  .label charset1 = $1000
  .label charset2 = $1800
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
  jsr main
//SEG7 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
    .const toD0181_return = screen/$40|charset1/$400
    .const toD0182_return = screen/$40|charset2/$400
  //SEG10 asm { sei  }
    sei
    jmp b1
  //SEG11 main::@1
  b1:
  //SEG12 [5] if(*((const byte*) RASTER#0)!=(byte/word/signed word/dword/signed dword) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b1
  //SEG13 [6] phi from main::@1 to main::toD0181 [phi:main::@1->main::toD0181]
  toD0181_from_b1:
    jmp toD0181
  //SEG14 main::toD0181
  toD0181:
    jmp b3
  //SEG15 main::@3
  b3:
  //SEG16 [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG17 [8] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 6 -- _deref_pbuc1=vbuc2 
    lda #6
    sta BGCOL
    jmp b2
  //SEG18 main::@2
  b2:
  //SEG19 [9] if(*((const byte*) RASTER#0)!=(byte/signed byte/word/signed word/dword/signed dword) $62) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$62
    cmp RASTER
    bne b2
  //SEG20 [10] phi from main::@2 to main::toD0182 [phi:main::@2->main::toD0182]
  toD0182_from_b2:
    jmp toD0182
  //SEG21 main::toD0182
  toD0182:
    jmp b4
  //SEG22 main::@4
  b4:
  //SEG23 [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0182_return
    sta D018
  //SEG24 [12] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) $b -- _deref_pbuc1=vbuc2 
    lda #$b
    sta BGCOL
    jmp b1
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [5] if(*((const byte*) RASTER#0)!=(byte/word/signed word/dword/signed dword) $ff) goto main::@1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [8] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 6 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [9] if(*((const byte*) RASTER#0)!=(byte/signed byte/word/signed word/dword/signed dword) $62) goto main::@2 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) $b [ ] ( main:2 [ ] ) always clobbers reg byte a 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [main] best 2137 combination 
Uplifting [] best 2137 combination 

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Test inline function
// Splits screen so upper half is lower case and lower half lower case
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label RASTER = $d012
  .label D018 = $d018
  .label BGCOL = $d021
  .label screen = $400
  .label charset1 = $1000
  .label charset2 = $1800
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
  jsr main
//SEG7 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
    .const toD0181_return = screen/$40|charset1/$400
    .const toD0182_return = screen/$40|charset2/$400
  //SEG10 asm { sei  }
    sei
    jmp b1
  //SEG11 main::@1
  b1:
  //SEG12 [5] if(*((const byte*) RASTER#0)!=(byte/word/signed word/dword/signed dword) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b1
  //SEG13 [6] phi from main::@1 to main::toD0181 [phi:main::@1->main::toD0181]
  toD0181_from_b1:
    jmp toD0181
  //SEG14 main::toD0181
  toD0181:
    jmp b3
  //SEG15 main::@3
  b3:
  //SEG16 [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG17 [8] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 6 -- _deref_pbuc1=vbuc2 
    lda #6
    sta BGCOL
    jmp b2
  //SEG18 main::@2
  b2:
  //SEG19 [9] if(*((const byte*) RASTER#0)!=(byte/signed byte/word/signed word/dword/signed dword) $62) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$62
    cmp RASTER
    bne b2
  //SEG20 [10] phi from main::@2 to main::toD0182 [phi:main::@2->main::toD0182]
  toD0182_from_b2:
    jmp toD0182
  //SEG21 main::toD0182
  toD0182:
    jmp b4
  //SEG22 main::@4
  b4:
  //SEG23 [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0182_return
    sta D018
  //SEG24 [12] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) $b -- _deref_pbuc1=vbuc2 
    lda #$b
    sta BGCOL
    jmp b1
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp toD0181
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp toD0182
Removing instruction jmp b4
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction bend_from_b1:
Removing instruction toD0181_from_b1:
Removing instruction toD0181:
Removing instruction toD0182_from_b2:
Removing instruction toD0182:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b3:
Removing instruction b4:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) BGCOL
(const byte*) BGCOL#0 BGCOL = ((byte*))(word/dword/signed dword) $d021
(byte*) D018
(const byte*) D018#0 D018 = ((byte*))(word/dword/signed dword) $d018
(byte*) RASTER
(const byte*) RASTER#0 RASTER = ((byte*))(word/dword/signed dword) $d012
(byte*) charset1
(const byte*) charset1#0 charset1 = ((byte*))(word/signed word/dword/signed dword) $1000
(byte*) charset2
(const byte*) charset2#0 charset2 = ((byte*))(word/signed word/dword/signed dword) $1800
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::toD0181
(word~) main::toD0181_$0
(word/signed dword/dword~) main::toD0181_$1
(word~) main::toD0181_$2
(word/signed dword/dword~) main::toD0181_$3
(word/dword~) main::toD0181_$4
(byte~) main::toD0181_$5
(byte*) main::toD0181_charset
(byte) main::toD0181_return
(const byte) main::toD0181_return#0 toD0181_return = ((byte))((word))(const byte*) screen#0/(byte/signed byte/word/signed word/dword/signed dword) $40|((word))(const byte*) charset1#0/(word/signed word/dword/signed dword) $400
(byte*) main::toD0181_screen
(label) main::toD0182
(word~) main::toD0182_$0
(word/signed dword/dword~) main::toD0182_$1
(word~) main::toD0182_$2
(word/signed dword/dword~) main::toD0182_$3
(word/dword~) main::toD0182_$4
(byte~) main::toD0182_$5
(byte*) main::toD0182_charset
(byte) main::toD0182_return
(const byte) main::toD0182_return#0 toD0182_return = ((byte))((word))(const byte*) screen#0/(byte/signed byte/word/signed word/dword/signed dword) $40|((word))(const byte*) charset2#0/(word/signed word/dword/signed dword) $400
(byte*) main::toD0182_screen
(byte*) screen
(const byte*) screen#0 screen = ((byte*))(word/signed word/dword/signed dword) $400



FINAL ASSEMBLER
Score: 1972

//SEG0 File Comments
// Test inline function
// Splits screen so upper half is lower case and lower half lower case
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label RASTER = $d012
  .label D018 = $d018
  .label BGCOL = $d021
  .label screen = $400
  .label charset1 = $1000
  .label charset2 = $1800
//SEG3 @begin
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
//SEG5 @1
//SEG6 [2] call main 
//SEG7 [3] phi from @1 to @end [phi:@1->@end]
//SEG8 @end
//SEG9 main
main: {
    .const toD0181_return = screen/$40|charset1/$400
    .const toD0182_return = screen/$40|charset2/$400
  //SEG10 asm { sei  }
    sei
  //SEG11 main::@1
  b1:
  //SEG12 [5] if(*((const byte*) RASTER#0)!=(byte/word/signed word/dword/signed dword) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b1
  //SEG13 [6] phi from main::@1 to main::toD0181 [phi:main::@1->main::toD0181]
  //SEG14 main::toD0181
  //SEG15 main::@3
  //SEG16 [7] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG17 [8] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) 6 -- _deref_pbuc1=vbuc2 
    lda #6
    sta BGCOL
  //SEG18 main::@2
  b2:
  //SEG19 [9] if(*((const byte*) RASTER#0)!=(byte/signed byte/word/signed word/dword/signed dword) $62) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$62
    cmp RASTER
    bne b2
  //SEG20 [10] phi from main::@2 to main::toD0182 [phi:main::@2->main::toD0182]
  //SEG21 main::toD0182
  //SEG22 main::@4
  //SEG23 [11] *((const byte*) D018#0) ← (const byte) main::toD0182_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0182_return
    sta D018
  //SEG24 [12] *((const byte*) BGCOL#0) ← (byte/signed byte/word/signed word/dword/signed dword) $b -- _deref_pbuc1=vbuc2 
    lda #$b
    sta BGCOL
    jmp b1
}

