Fixing struct type size struct MOS7360_TED to 63
Fixing struct type SIZE_OF struct MOS7360_TED to 63
Fixing struct type SIZE_OF struct MOS7360_TED to 63
Inlined call call __init
Eliminating unused variable with no statement memset::$2
Eliminating unused variable with no statement main::$4
Eliminating unused variable with no statement main::$11

CONTROL FLOW GRAPH SSA

void * memset(void *str , char c , unsigned int num)
memset: scope:[memset]  from main main::@14 main::@15
  memset::c#6 = phi( main/memset::c#0, main::@14/memset::c#1, main::@15/memset::c#2 )
  memset::str#5 = phi( main/memset::str#0, main::@14/memset::str#1, main::@15/memset::str#2 )
  memset::num#3 = phi( main/memset::num#0, main::@14/memset::num#1, main::@15/memset::num#2 )
  memset::$0 = memset::num#3 > 0
  memset::$1 = ! memset::$0
  if(memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@3
  memset::str#3 = phi( memset/memset::str#5, memset::@3/memset::str#6 )
  memset::return#0 = memset::str#3
  to:memset::@return
memset::@2: scope:[memset]  from memset
  memset::c#5 = phi( memset/memset::c#6 )
  memset::num#4 = phi( memset/memset::num#3 )
  memset::str#4 = phi( memset/memset::str#5 )
  memset::$4 = (char *)memset::str#4
  memset::end#0 = memset::$4 + memset::num#4
  memset::dst#0 = ((char *)) memset::str#4
  to:memset::@3
memset::@3: scope:[memset]  from memset::@2 memset::@4
  memset::c#4 = phi( memset::@2/memset::c#5, memset::@4/memset::c#3 )
  memset::str#6 = phi( memset::@2/memset::str#4, memset::@4/memset::str#7 )
  memset::end#1 = phi( memset::@2/memset::end#0, memset::@4/memset::end#2 )
  memset::dst#2 = phi( memset::@2/memset::dst#0, memset::@4/memset::dst#1 )
  memset::$3 = memset::dst#2 != memset::end#1
  if(memset::$3) goto memset::@4
  to:memset::@1
memset::@4: scope:[memset]  from memset::@3
  memset::str#7 = phi( memset::@3/memset::str#6 )
  memset::end#2 = phi( memset::@3/memset::end#1 )
  memset::dst#3 = phi( memset::@3/memset::dst#2 )
  memset::c#3 = phi( memset::@3/memset::c#4 )
  *memset::dst#3 = memset::c#3
  memset::dst#1 = ++ memset::dst#3
  to:memset::@3
memset::@return: scope:[memset]  from memset::@1
  memset::return#5 = phi( memset::@1/memset::return#0 )
  memset::return#1 = memset::return#5
  return 
  to:@return

unsigned int rand()
rand: scope:[rand]  from main::@2
  rand::$0 = rand_state << 7
  rand_state = rand_state ^ rand::$0
  rand::$1 = rand_state >> 9
  rand_state = rand_state ^ rand::$1
  rand::$2 = rand_state << 8
  rand_state = rand_state ^ rand::$2
  rand::return#0 = rand_state
  to:rand::@return
rand::@return: scope:[rand]  from rand
  rand::return#3 = phi( rand/rand::return#0 )
  rand::return#1 = rand::return#3
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  memset::str#0 = (void *)DEFAULT_SCREEN
  memset::c#0 = $a0
  memset::num#0 = $3e8
  call memset
  memset::return#2 = memset::return#1
  to:main::@14
main::@14: scope:[main]  from main
  memset::str#1 = (void *)DEFAULT_COLORRAM
  memset::c#1 = 0
  memset::num#1 = $3e8
  call memset
  memset::return#3 = memset::return#1
  to:main::@15
main::@15: scope:[main]  from main::@14
  memset::str#2 = (void *)VISITS
  memset::c#2 = 0
  memset::num#2 = $3e8
  call memset
  memset::return#4 = memset::return#1
  to:main::@16
main::@16: scope:[main]  from main::@15
  *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0
  *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0
  main::x#0 = $14
  main::y#0 = $c
  to:main::@1
main::@1: scope:[main]  from main::@16 main::@8
  main::x#8 = phi( main::@16/main::x#0, main::@8/main::x#10 )
  main::y#8 = phi( main::@16/main::y#0, main::@8/main::y#10 )
  main::$25 = 0 != 1
  if(main::$25) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  main::x#5 = phi( main::@1/main::x#8 )
  main::y#5 = phi( main::@1/main::y#8 )
  main::$24 = (unsigned int)main::y#5
  main::$3 = main::$24 * $28
  main::offset#0 = main::$3 + main::x#5
  main::$5 = VISITS + main::offset#0
  *main::$5 = ++ *main::$5
  main::$6 = VISITS + main::offset#0
  main::cnt#0 = *main::$6
  main::$8 = DEFAULT_COLORRAM + main::offset#0
  main::$9 = main::cnt#0 & $f
  *main::$8 = FADE[main::$9]
  call rand
  rand::return#2 = rand::return#1
  to:main::@17
main::@17: scope:[main]  from main::@2
  main::y#11 = phi( main::@2/main::y#5 )
  main::x#11 = phi( main::@2/main::x#5 )
  rand::return#4 = phi( main::@2/rand::return#2 )
  main::$10 = rand::return#4
  main::rnd#0 = byte1  main::$10
  main::$12 = main::rnd#0 & $80
  main::$26 = 0 != main::$12
  if(main::$26) goto main::@3
  to:main::@9
main::@3: scope:[main]  from main::@17
  main::y#16 = phi( main::@17/main::y#11 )
  main::x#9 = phi( main::@17/main::x#11 )
  main::rnd#1 = phi( main::@17/main::rnd#0 )
  main::$18 = main::rnd#1 & $40
  main::$27 = 0 != main::$18
  if(main::$27) goto main::@6
  to:main::@12
main::@9: scope:[main]  from main::@17
  main::x#16 = phi( main::@17/main::x#11 )
  main::y#9 = phi( main::@17/main::y#11 )
  main::rnd#2 = phi( main::@17/main::rnd#0 )
  main::$13 = main::rnd#2 & $40
  main::$28 = 0 != main::$13
  if(main::$28) goto main::@4
  to:main::@10
main::@4: scope:[main]  from main::@9
  main::x#14 = phi( main::@9/main::x#16 )
  main::y#6 = phi( main::@9/main::y#9 )
  main::y#1 = ++ main::y#6
  main::$16 = main::y#1 == $19
  main::$17 = ! main::$16
  if(main::$17) goto main::@8
  to:main::@5
main::@10: scope:[main]  from main::@9
  main::x#12 = phi( main::@9/main::x#16 )
  main::y#7 = phi( main::@9/main::y#9 )
  main::y#2 = -- main::y#7
  main::$14 = main::y#2 == $ff
  main::$15 = ! main::$14
  if(main::$15) goto main::@8
  to:main::@11
main::@11: scope:[main]  from main::@10
  main::x#13 = phi( main::@10/main::x#12 )
  main::y#3 = 0
  to:main::@8
main::@5: scope:[main]  from main::@4
  main::x#15 = phi( main::@4/main::x#14 )
  main::y#4 = $18
  to:main::@8
main::@6: scope:[main]  from main::@3
  main::y#14 = phi( main::@3/main::y#16 )
  main::x#6 = phi( main::@3/main::x#9 )
  main::x#1 = ++ main::x#6
  main::$21 = main::x#1 == $28
  main::$22 = ! main::$21
  if(main::$22) goto main::@8
  to:main::@7
main::@12: scope:[main]  from main::@3
  main::y#12 = phi( main::@3/main::y#16 )
  main::x#7 = phi( main::@3/main::x#9 )
  main::x#2 = -- main::x#7
  main::$19 = main::x#2 == $ff
  main::$20 = ! main::$19
  if(main::$20) goto main::@8
  to:main::@13
main::@13: scope:[main]  from main::@12
  main::y#13 = phi( main::@12/main::y#12 )
  main::x#3 = 0
  to:main::@8
main::@7: scope:[main]  from main::@6
  main::y#15 = phi( main::@6/main::y#14 )
  main::x#4 = $27
  to:main::@8
main::@8: scope:[main]  from main::@10 main::@11 main::@12 main::@13 main::@4 main::@5 main::@6 main::@7 main::@8
  main::x#10 = phi( main::@10/main::x#12, main::@11/main::x#13, main::@12/main::x#2, main::@13/main::x#3, main::@4/main::x#14, main::@5/main::x#15, main::@6/main::x#1, main::@7/main::x#4, main::@8/main::x#10 )
  main::y#10 = phi( main::@10/main::y#2, main::@11/main::y#3, main::@12/main::y#12, main::@13/main::y#13, main::@4/main::y#1, main::@5/main::y#4, main::@6/main::y#14, main::@7/main::y#15, main::@8/main::y#10 )
  main::$23 = *((char *)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO) != $ff
  if(main::$23) goto main::@8
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  rand_state = 1
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
__constant char * const DEFAULT_COLORRAM = (char *)$800
__constant char * const DEFAULT_SCREEN = (char *)$c00
__constant char FADE[$10] = { 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6 }
__constant char OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
__constant char OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
__constant char OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
__constant char RADIX::BINARY = 2
__constant char RADIX::DECIMAL = $a
__constant char RADIX::HEXADECIMAL = $10
__constant char RADIX::OCTAL = 8
__constant struct MOS7360_TED * const TED = (struct MOS7360_TED *)$ff00
__constant char VISITS[$3e8] = { fill( $3e8, 0) }
void __start()
void main()
unsigned int main::$10
number main::$12
number main::$13
bool main::$14
bool main::$15
bool main::$16
bool main::$17
number main::$18
bool main::$19
bool main::$20
bool main::$21
bool main::$22
bool main::$23
unsigned int main::$24
bool main::$25
bool main::$26
bool main::$27
bool main::$28
number main::$3
char *main::$5
char *main::$6
char *main::$8
number main::$9
char main::cnt
char main::cnt#0
unsigned int main::offset
unsigned int main::offset#0
char main::rnd
char main::rnd#0
char main::rnd#1
char main::rnd#2
char main::x
char main::x#0
char main::x#1
char main::x#10
char main::x#11
char main::x#12
char main::x#13
char main::x#14
char main::x#15
char main::x#16
char main::x#2
char main::x#3
char main::x#4
char main::x#5
char main::x#6
char main::x#7
char main::x#8
char main::x#9
char main::y
char main::y#0
char main::y#1
char main::y#10
char main::y#11
char main::y#12
char main::y#13
char main::y#14
char main::y#15
char main::y#16
char main::y#2
char main::y#3
char main::y#4
char main::y#5
char main::y#6
char main::y#7
char main::y#8
char main::y#9
void * memset(void *str , char c , unsigned int num)
bool memset::$0
bool memset::$1
bool memset::$3
char *memset::$4
char memset::c
char memset::c#0
char memset::c#1
char memset::c#2
char memset::c#3
char memset::c#4
char memset::c#5
char memset::c#6
char *memset::dst
char *memset::dst#0
char *memset::dst#1
char *memset::dst#2
char *memset::dst#3
char *memset::end
char *memset::end#0
char *memset::end#1
char *memset::end#2
unsigned int memset::num
unsigned int memset::num#0
unsigned int memset::num#1
unsigned int memset::num#2
unsigned int memset::num#3
unsigned int memset::num#4
void *memset::return
void *memset::return#0
void *memset::return#1
void *memset::return#2
void *memset::return#3
void *memset::return#4
void *memset::return#5
void *memset::str
void *memset::str#0
void *memset::str#1
void *memset::str#2
void *memset::str#3
void *memset::str#4
void *memset::str#5
void *memset::str#6
void *memset::str#7
unsigned int rand()
unsigned int rand::$0
unsigned int rand::$1
unsigned int rand::$2
unsigned int rand::return
unsigned int rand::return#0
unsigned int rand::return#1
unsigned int rand::return#2
unsigned int rand::return#3
unsigned int rand::return#4
__loadstore volatile unsigned int rand_state

Adding number conversion cast (unumber) 0 in memset::$0 = memset::num#3 > 0
Adding number conversion cast (unumber) 7 in rand::$0 = rand_state << 7
Adding number conversion cast (unumber) 9 in rand::$1 = rand_state >> 9
Adding number conversion cast (unumber) 8 in rand::$2 = rand_state << 8
Adding number conversion cast (unumber) $a0 in memset::c#0 = $a0
Adding number conversion cast (unumber) $3e8 in memset::num#0 = $3e8
Adding number conversion cast (unumber) 0 in memset::c#1 = 0
Adding number conversion cast (unumber) $3e8 in memset::num#1 = $3e8
Adding number conversion cast (unumber) 0 in memset::c#2 = 0
Adding number conversion cast (unumber) $3e8 in memset::num#2 = $3e8
Adding number conversion cast (unumber) 0 in *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0
Adding number conversion cast (unumber) 0 in *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0
Adding number conversion cast (unumber) $28 in main::$3 = main::$24 * $28
Adding number conversion cast (unumber) main::$3 in main::$3 = main::$24 * (unumber)$28
Adding number conversion cast (unumber) $f in main::$9 = main::cnt#0 & $f
Adding number conversion cast (unumber) main::$9 in main::$9 = main::cnt#0 & (unumber)$f
Adding number conversion cast (unumber) $80 in main::$12 = main::rnd#0 & $80
Adding number conversion cast (unumber) main::$12 in main::$12 = main::rnd#0 & (unumber)$80
Adding number conversion cast (unumber) 0 in main::$26 = 0 != main::$12
Adding number conversion cast (unumber) $40 in main::$18 = main::rnd#1 & $40
Adding number conversion cast (unumber) main::$18 in main::$18 = main::rnd#1 & (unumber)$40
Adding number conversion cast (unumber) 0 in main::$27 = 0 != main::$18
Adding number conversion cast (unumber) $40 in main::$13 = main::rnd#2 & $40
Adding number conversion cast (unumber) main::$13 in main::$13 = main::rnd#2 & (unumber)$40
Adding number conversion cast (unumber) 0 in main::$28 = 0 != main::$13
Adding number conversion cast (unumber) $19 in main::$16 = main::y#1 == $19
Adding number conversion cast (unumber) $ff in main::$14 = main::y#2 == $ff
Adding number conversion cast (unumber) 0 in main::y#3 = 0
Adding number conversion cast (unumber) $18 in main::y#4 = $18
Adding number conversion cast (unumber) $28 in main::$21 = main::x#1 == $28
Adding number conversion cast (unumber) $ff in main::$19 = main::x#2 == $ff
Adding number conversion cast (unumber) 0 in main::x#3 = 0
Adding number conversion cast (unumber) $27 in main::x#4 = $27
Adding number conversion cast (unumber) $ff in main::$23 = *((char *)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO) != $ff
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast memset::dst#0 = (char *)memset::str#4
Inlining cast memset::c#0 = (unumber)$a0
Inlining cast memset::num#0 = (unumber)$3e8
Inlining cast memset::c#1 = (unumber)0
Inlining cast memset::num#1 = (unumber)$3e8
Inlining cast memset::c#2 = (unumber)0
Inlining cast memset::num#2 = (unumber)$3e8
Inlining cast *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = (unumber)0
Inlining cast *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = (unumber)0
Inlining cast main::y#3 = (unumber)0
Inlining cast main::y#4 = (unumber)$18
Inlining cast main::x#3 = (unumber)0
Inlining cast main::x#4 = (unumber)$27
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (char *) 2048
Simplifying constant pointer cast (char *) 3072
Simplifying constant pointer cast (struct MOS7360_TED *) 65280
Simplifying constant integer cast 0
Simplifying constant integer cast 7
Simplifying constant integer cast 9
Simplifying constant integer cast 8
Simplifying constant integer cast $a0
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast $f
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast 0
Simplifying constant integer cast $19
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $18
Simplifying constant integer cast $28
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $27
Simplifying constant integer cast $ff
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 7
Finalized unsigned number type (char) 9
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) $a0
Finalized unsigned number type (unsigned int) $3e8
Finalized unsigned number type (char) 0
Finalized unsigned number type (unsigned int) $3e8
Finalized unsigned number type (char) 0
Finalized unsigned number type (unsigned int) $3e8
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $28
Finalized unsigned number type (char) $f
Finalized unsigned number type (char) $80
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $40
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $40
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $19
Finalized unsigned number type (char) $ff
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $18
Finalized unsigned number type (char) $28
Finalized unsigned number type (char) $ff
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $27
Finalized unsigned number type (char) $ff
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to unsigned int in main::$3 = main::$24 * $28
Inferred type updated to char in main::$9 = main::cnt#0 & $f
Inferred type updated to char in main::$12 = main::rnd#0 & $80
Inferred type updated to char in main::$18 = main::rnd#1 & $40
Inferred type updated to char in main::$13 = main::rnd#2 & $40
Inversing boolean not [2] memset::$1 = memset::num#3 <= 0 from [1] memset::$0 = memset::num#3 > 0
Inversing boolean not [81] main::$17 = main::y#1 != $19 from [80] main::$16 = main::y#1 == $19
Inversing boolean not [86] main::$15 = main::y#2 != $ff from [85] main::$14 = main::y#2 == $ff
Inversing boolean not [95] main::$22 = main::x#1 != $28 from [94] main::$21 = main::x#1 == $28
Inversing boolean not [100] main::$20 = main::x#2 != $ff from [99] main::$19 = main::x#2 == $ff
Successful SSA optimization Pass2UnaryNotSimplification
Alias memset::return#0 = memset::str#3 memset::return#5 memset::return#1 
Alias memset::str#4 = memset::str#5 
Alias memset::num#3 = memset::num#4 
Alias memset::c#5 = memset::c#6 
Alias memset::c#3 = memset::c#4 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#6 = memset::str#7 
Alias rand::return#0 = rand::return#3 rand::return#1 
Alias main::y#11 = main::y#5 main::y#8 main::y#16 main::y#9 main::y#6 main::y#7 main::y#14 main::y#12 main::y#13 main::y#15 
Alias main::x#11 = main::x#5 main::x#8 main::x#9 main::x#16 main::x#14 main::x#12 main::x#13 main::x#15 main::x#6 main::x#7 
Alias rand::return#2 = rand::return#4 
Alias main::rnd#0 = main::rnd#1 main::rnd#2 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values memset::end#1 memset::end#0
Identical Phi Values memset::str#6 memset::str#4
Identical Phi Values memset::c#3 memset::c#5
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values memset::return#0 memset::str#4
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [57] main::$6 = VISITS + main::offset#0
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition memset::$1 [2] if(memset::num#3<=0) goto memset::@1
Simple Condition memset::$3 [9] if(memset::dst#2!=memset::end#0) goto memset::@4
Simple Condition main::$25 [42] if(0!=1) goto main::@2
Simple Condition main::$26 [59] if(0!=main::$12) goto main::@3
Simple Condition main::$27 [62] if(0!=main::$18) goto main::@6
Simple Condition main::$28 [65] if(0!=main::$13) goto main::@4
Simple Condition main::$17 [68] if(main::y#1!=$19) goto main::@8
Simple Condition main::$15 [71] if(main::y#2!=$ff) goto main::@8
Simple Condition main::$22 [76] if(main::x#1!=$28) goto main::@8
Simple Condition main::$20 [79] if(main::x#2!=$ff) goto main::@8
Simple Condition main::$23 [84] if(*((char *)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@8
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant memset::str#0 = (void *)DEFAULT_SCREEN
Constant memset::c#0 = $a0
Constant memset::num#0 = $3e8
Constant memset::str#1 = (void *)DEFAULT_COLORRAM
Constant memset::c#1 = 0
Constant memset::num#1 = $3e8
Constant memset::str#2 = (void *)VISITS
Constant memset::c#2 = 0
Constant memset::num#2 = $3e8
Constant main::x#0 = $14
Constant main::y#0 = $c
Constant main::y#3 = 0
Constant main::y#4 = $18
Constant main::x#3 = 0
Constant main::x#4 = $27
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [42] if(0!=1) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused variable memset::return#2 and assignment [19] memset::return#2 = memset::str#4
Eliminating unused variable memset::return#3 and assignment [21] memset::return#3 = memset::str#4
Eliminating unused variable memset::return#4 and assignment [23] memset::return#4 = memset::str#4
Successful SSA optimization PassNEliminateUnusedVars
Alias main::$6 = main::$5 
Successful SSA optimization Pass2AliasElimination
Inlining Noop Cast [2] memset::$4 = (char *)memset::str#4 keeping memset::str#4
Inlining Noop Cast [4] memset::dst#0 = (char *)memset::str#4 keeping memset::str#4
Successful SSA optimization Pass2NopCastInlining
Rewriting multiplication to use shift and addition[25] main::$3 = main::$24 * $28
Inlining constant with var siblings memset::str#0
Inlining constant with var siblings memset::c#0
Inlining constant with var siblings memset::num#0
Inlining constant with var siblings memset::str#1
Inlining constant with var siblings memset::c#1
Inlining constant with var siblings memset::num#1
Inlining constant with var siblings memset::str#2
Inlining constant with var siblings memset::c#2
Inlining constant with var siblings memset::num#2
Inlining constant with var siblings main::x#0
Inlining constant with var siblings main::y#0
Inlining constant with var siblings main::y#3
Inlining constant with var siblings main::y#4
Inlining constant with var siblings main::x#3
Inlining constant with var siblings main::x#4
Constant inlined memset::str#2 = (void *)VISITS
Constant inlined memset::str#1 = (void *)DEFAULT_COLORRAM
Constant inlined memset::str#0 = (void *)DEFAULT_SCREEN
Constant inlined memset::num#2 = $3e8
Constant inlined main::x#3 = 0
Constant inlined memset::num#1 = $3e8
Constant inlined main::x#0 = $14
Constant inlined memset::num#0 = $3e8
Constant inlined main::y#0 = $c
Constant inlined main::y#3 = 0
Constant inlined main::x#4 = $27
Constant inlined main::y#4 = $18
Constant inlined memset::c#0 = $a0
Constant inlined memset::c#1 = 0
Constant inlined memset::c#2 = 0
Successful SSA optimization Pass2ConstantInlining
Alias main::$3 = main::$31 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values memset::num#3 $3e8
Successful SSA optimization Pass2IdenticalPhiElimination
if() condition always false - eliminating [1] if($3e8<=0) goto memset::@1
Successful SSA optimization Pass2ConstantIfs
Finalized unsigned number type (char) $1d
Finalized unsigned number type (char) $1d
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) $a
Finalized unsigned number type (char) $10
Finalized unsigned number type (char) $10
Finalized unsigned number type (unsigned int) $3e8
Finalized unsigned number type (unsigned int) $3e8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Added new block during phi lifting main::@18(between main::@8 and main::@1)
Added new block during phi lifting main::@19(between main::@10 and main::@8)
Added new block during phi lifting main::@20(between main::@12 and main::@8)
Added new block during phi lifting main::@21(between main::@4 and main::@8)
Added new block during phi lifting main::@22(between main::@6 and main::@8)
Added new block during phi lifting main::@23(between main::@8 and main::@8)
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of __start::@2
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of memset::@1
CALL GRAPH
Calls in [__start] to main:3 
Calls in [main] to memset:7 memset:9 memset:11 rand:26 

Created 7 initial phi equivalence classes
Coalesced [36] main::x#19 = main::x#11
Coalesced [39] main::y#17 = main::y#10
Coalesced (already) [40] main::x#17 = main::x#10
Coalesced (already) [41] main::y#24 = main::y#10
Coalesced (already) [42] main::x#24 = main::x#10
Coalesced [43] main::y#18 = main::y#2
Coalesced (already) [44] main::x#18 = main::x#11
Coalesced (already) [47] main::x#22 = main::x#11
Coalesced [48] main::y#21 = main::y#1
Coalesced (already) [49] main::x#21 = main::x#11
Coalesced (already) [54] main::y#20 = main::y#11
Coalesced (already) [55] main::y#19 = main::y#11
Coalesced [56] main::x#20 = main::x#2
Coalesced (already) [59] main::y#23 = main::y#11
Coalesced (already) [60] main::y#22 = main::y#11
Coalesced [61] main::x#23 = main::x#1
Coalesced [71] memset::dst#5 = memset::dst#1
Coalesced down to 5 phi equivalence classes
Culled Empty Block label __start::@2
Culled Empty Block label main::@11
Culled Empty Block label main::@18
Culled Empty Block label main::@23
Culled Empty Block label main::@5
Culled Empty Block label main::@13
Culled Empty Block label main::@7
Culled Empty Block label memset::@1
Renumbering block memset::@2 to memset::@1
Renumbering block memset::@3 to memset::@2
Renumbering block memset::@4 to memset::@3
Renumbering block main::@6 to main::@5
Renumbering block main::@8 to main::@6
Renumbering block main::@9 to main::@7
Renumbering block main::@10 to main::@8
Renumbering block main::@12 to main::@9
Renumbering block main::@14 to main::@10
Renumbering block main::@15 to main::@11
Renumbering block main::@16 to main::@12
Renumbering block main::@17 to main::@13
Renumbering block main::@19 to main::@14
Renumbering block main::@20 to main::@15
Renumbering block main::@21 to main::@16
Renumbering block main::@22 to main::@17
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@16
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@17

FINAL CONTROL FLOW GRAPH

void __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] rand_state = 1
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [2] phi()
  [3] call main
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [4] return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  [5] phi()
  [6] call memset
  to:main::@10
main::@10: scope:[main]  from main
  [7] phi()
  [8] call memset
  to:main::@11
main::@11: scope:[main]  from main::@10
  [9] phi()
  [10] call memset
  to:main::@12
main::@12: scope:[main]  from main::@11
  [11] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0
  [12] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0
  to:main::@1
main::@1: scope:[main]  from main::@12 main::@6
  [13] main::x#11 = phi( main::@12/$14, main::@6/main::x#10 )
  [13] main::y#11 = phi( main::@12/$c, main::@6/main::y#10 )
  to:main::@2
main::@2: scope:[main]  from main::@1
  [14] main::$24 = (unsigned int)main::y#11
  [15] main::$29 = main::$24 << 2
  [16] main::$30 = main::$29 + main::$24
  [17] main::$3 = main::$30 << 3
  [18] main::offset#0 = main::$3 + main::x#11
  [19] main::$6 = VISITS + main::offset#0
  [20] *main::$6 = ++ *main::$6
  [21] main::cnt#0 = *main::$6
  [22] main::$8 = DEFAULT_COLORRAM + main::offset#0
  [23] main::$9 = main::cnt#0 & $f
  [24] *main::$8 = FADE[main::$9]
  [25] call rand
  [26] rand::return#2 = rand::return#0
  to:main::@13
main::@13: scope:[main]  from main::@2
  [27] main::$10 = rand::return#2
  [28] main::rnd#0 = byte1  main::$10
  [29] main::$12 = main::rnd#0 & $80
  [30] if(0!=main::$12) goto main::@3
  to:main::@7
main::@7: scope:[main]  from main::@13
  [31] main::$13 = main::rnd#0 & $40
  [32] if(0!=main::$13) goto main::@4
  to:main::@8
main::@8: scope:[main]  from main::@7
  [33] main::y#2 = -- main::y#11
  [34] if(main::y#2!=$ff) goto main::@14
  to:main::@6
main::@14: scope:[main]  from main::@8
  [35] phi()
  to:main::@6
main::@6: scope:[main]  from main::@14 main::@15 main::@16 main::@17 main::@4 main::@5 main::@6 main::@8 main::@9
  [36] main::x#10 = phi( main::@14/main::x#11, main::@8/main::x#11, main::@15/main::x#2, main::@9/0, main::@16/main::x#11, main::@4/main::x#11, main::@17/main::x#1, main::@5/$27, main::@6/main::x#10 )
  [36] main::y#10 = phi( main::@14/main::y#2, main::@8/0, main::@15/main::y#11, main::@9/main::y#11, main::@16/main::y#1, main::@4/$18, main::@17/main::y#11, main::@5/main::y#11, main::@6/main::y#10 )
  [37] if(*((char *)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6
  to:main::@1
main::@4: scope:[main]  from main::@7
  [38] main::y#1 = ++ main::y#11
  [39] if(main::y#1!=$19) goto main::@16
  to:main::@6
main::@16: scope:[main]  from main::@4
  [40] phi()
  to:main::@6
main::@3: scope:[main]  from main::@13
  [41] main::$18 = main::rnd#0 & $40
  [42] if(0!=main::$18) goto main::@5
  to:main::@9
main::@9: scope:[main]  from main::@3
  [43] main::x#2 = -- main::x#11
  [44] if(main::x#2!=$ff) goto main::@15
  to:main::@6
main::@15: scope:[main]  from main::@9
  [45] phi()
  to:main::@6
main::@5: scope:[main]  from main::@3
  [46] main::x#1 = ++ main::x#11
  [47] if(main::x#1!=$28) goto main::@17
  to:main::@6
main::@17: scope:[main]  from main::@5
  [48] phi()
  to:main::@6

void * memset(void *str , char c , unsigned int num)
memset: scope:[memset]  from main main::@10 main::@11
  [49] memset::c#5 = phi( main/$a0, main::@10/0, main::@11/0 )
  [49] memset::str#4 = phi( main/(void *)DEFAULT_SCREEN, main::@10/(void *)DEFAULT_COLORRAM, main::@11/(void *)VISITS )
  to:memset::@1
memset::@1: scope:[memset]  from memset
  [50] memset::end#0 = (char *)memset::str#4 + $3e8
  [51] memset::dst#4 = (char *)memset::str#4
  to:memset::@2
memset::@2: scope:[memset]  from memset::@1 memset::@3
  [52] memset::dst#2 = phi( memset::@1/memset::dst#4, memset::@3/memset::dst#1 )
  [53] if(memset::dst#2!=memset::end#0) goto memset::@3
  to:memset::@return
memset::@return: scope:[memset]  from memset::@2
  [54] return 
  to:@return
memset::@3: scope:[memset]  from memset::@2
  [55] *memset::dst#2 = memset::c#5
  [56] memset::dst#1 = ++ memset::dst#2
  to:memset::@2

unsigned int rand()
rand: scope:[rand]  from main::@2
  [57] rand::$0 = rand_state << 7
  [58] rand_state = rand_state ^ rand::$0
  [59] rand::$1 = rand_state >> 9
  [60] rand_state = rand_state ^ rand::$1
  [61] rand::$2 = rand_state << 8
  [62] rand_state = rand_state ^ rand::$2
  [63] rand::return#0 = rand_state
  to:rand::@return
rand::@return: scope:[rand]  from rand
  [64] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void __start()
void main()
unsigned int main::$10 // 202.0
char main::$12 // 202.0
char main::$13 // 202.0
char main::$18 // 202.0
unsigned int main::$24 // 151.5
unsigned int main::$29 // 202.0
unsigned int main::$3 // 202.0
unsigned int main::$30 // 202.0
char *main::$6 // 202.0
char *main::$8 // 101.0
char main::$9 // 202.0
char main::cnt
char main::cnt#0 // 101.0
unsigned int main::offset
unsigned int main::offset#0 // 75.75
char main::rnd
char main::rnd#0 // 134.66666666666666
char main::x
char main::x#1 // 101.0
char main::x#10 // 1804.5
char main::x#11 // 60.99999999999998
char main::x#2 // 101.0
char main::y
char main::y#1 // 101.0
char main::y#10 // 1804.5
char main::y#11 // 57.392857142857125
char main::y#2 // 101.0
void * memset(void *str , char c , unsigned int num)
char memset::c
char memset::c#5 // 143.0
char *memset::dst
char *memset::dst#1 // 2002.0
char *memset::dst#2 // 1368.3333333333335
char *memset::dst#4 // 202.0
char *memset::end
char *memset::end#0 // 183.66666666666669
unsigned int memset::num
void *memset::return
void *memset::str
void *memset::str#4
unsigned int rand()
unsigned int rand::$0 // 2002.0
unsigned int rand::$1 // 2002.0
unsigned int rand::$2 // 2002.0
unsigned int rand::return
unsigned int rand::return#0 // 367.33333333333337
unsigned int rand::return#2 // 202.0
__loadstore volatile unsigned int rand_state // 185.40740740740742

Initial phi equivalence classes
[ main::y#11 main::y#10 main::y#2 main::y#1 ]
[ main::x#11 main::x#10 main::x#2 main::x#1 ]
[ memset::str#4 ]
[ memset::c#5 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
Added variable rand_state to live range equivalence class [ rand_state ]
Added variable main::$24 to live range equivalence class [ main::$24 ]
Added variable main::$29 to live range equivalence class [ main::$29 ]
Added variable main::$30 to live range equivalence class [ main::$30 ]
Added variable main::$3 to live range equivalence class [ main::$3 ]
Added variable main::offset#0 to live range equivalence class [ main::offset#0 ]
Added variable main::$6 to live range equivalence class [ main::$6 ]
Added variable main::cnt#0 to live range equivalence class [ main::cnt#0 ]
Added variable main::$8 to live range equivalence class [ main::$8 ]
Added variable main::$9 to live range equivalence class [ main::$9 ]
Added variable rand::return#2 to live range equivalence class [ rand::return#2 ]
Added variable main::$10 to live range equivalence class [ main::$10 ]
Added variable main::rnd#0 to live range equivalence class [ main::rnd#0 ]
Added variable main::$12 to live range equivalence class [ main::$12 ]
Added variable main::$13 to live range equivalence class [ main::$13 ]
Added variable main::$18 to live range equivalence class [ main::$18 ]
Added variable memset::end#0 to live range equivalence class [ memset::end#0 ]
Added variable rand::$0 to live range equivalence class [ rand::$0 ]
Added variable rand::$1 to live range equivalence class [ rand::$1 ]
Added variable rand::$2 to live range equivalence class [ rand::$2 ]
Added variable rand::return#0 to live range equivalence class [ rand::return#0 ]
Complete equivalence classes
[ main::y#11 main::y#10 main::y#2 main::y#1 ]
[ main::x#11 main::x#10 main::x#2 main::x#1 ]
[ memset::str#4 ]
[ memset::c#5 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
[ rand_state ]
[ main::$24 ]
[ main::$29 ]
[ main::$30 ]
[ main::$3 ]
[ main::offset#0 ]
[ main::$6 ]
[ main::cnt#0 ]
[ main::$8 ]
[ main::$9 ]
[ rand::return#2 ]
[ main::$10 ]
[ main::rnd#0 ]
[ main::$12 ]
[ main::$13 ]
[ main::$18 ]
[ memset::end#0 ]
[ rand::$0 ]
[ rand::$1 ]
[ rand::$2 ]
[ rand::return#0 ]
Allocated zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ]
Allocated zp[1]:4 [ main::x#11 main::x#10 main::x#2 main::x#1 ]
Allocated zp[1]:5 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Allocated zp[2]:6 [ rand::$0 ]
Allocated zp[2]:8 [ rand::$1 ]
Allocated zp[2]:10 [ rand::$2 ]
Allocated zp[2]:12 [ rand::return#0 ]
Allocated zp[2]:14 [ main::$29 ]
Allocated zp[2]:16 [ main::$30 ]
Allocated zp[2]:18 [ main::$3 ]
Allocated zp[2]:20 [ main::$6 ]
Allocated zp[1]:22 [ main::$9 ]
Allocated zp[2]:23 [ rand::return#2 ]
Allocated zp[2]:25 [ main::$10 ]
Allocated zp[1]:27 [ main::$12 ]
Allocated zp[1]:28 [ main::$13 ]
Allocated zp[1]:29 [ main::$18 ]
Allocated zp[2]:30 [ rand_state ]
Allocated zp[2]:32 [ memset::end#0 ]
Allocated zp[2]:34 [ main::$24 ]
Allocated zp[1]:36 [ memset::c#5 ]
Allocated zp[1]:37 [ main::rnd#0 ]
Allocated zp[1]:38 [ main::cnt#0 ]
Allocated zp[2]:39 [ main::$8 ]
Allocated zp[2]:41 [ main::offset#0 ]
Allocated zp[2]:43 [ memset::str#4 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] rand_state = 1 [ rand_state ] (  [ rand_state ] { }  ) always clobbers reg byte a 
Statement [11] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0 [ rand_state ] ( main:3 [ rand_state ] { }  ) always clobbers reg byte a 
Statement [12] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0 [ rand_state ] ( main:3 [ rand_state ] { }  ) always clobbers reg byte a 
Statement [14] main::$24 = (unsigned int)main::y#11 [ rand_state main::y#11 main::x#11 main::$24 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$24 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:4 [ main::x#11 main::x#10 main::x#2 main::x#1 ]
Statement [15] main::$29 = main::$24 << 2 [ rand_state main::y#11 main::x#11 main::$24 main::$29 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$24 main::$29 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [16] main::$30 = main::$29 + main::$24 [ rand_state main::y#11 main::x#11 main::$30 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$30 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [17] main::$3 = main::$30 << 3 [ rand_state main::y#11 main::x#11 main::$3 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$3 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [18] main::offset#0 = main::$3 + main::x#11 [ rand_state main::y#11 main::x#11 main::offset#0 ] ( main:3 [ rand_state main::y#11 main::x#11 main::offset#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [19] main::$6 = VISITS + main::offset#0 [ rand_state main::y#11 main::x#11 main::offset#0 main::$6 ] ( main:3 [ rand_state main::y#11 main::x#11 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [20] *main::$6 = ++ *main::$6 [ rand_state main::y#11 main::x#11 main::offset#0 main::$6 ] ( main:3 [ rand_state main::y#11 main::x#11 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:5 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:4 [ main::x#11 main::x#10 main::x#2 main::x#1 ]
Statement [21] main::cnt#0 = *main::$6 [ rand_state main::y#11 main::x#11 main::offset#0 main::cnt#0 ] ( main:3 [ rand_state main::y#11 main::x#11 main::offset#0 main::cnt#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [22] main::$8 = DEFAULT_COLORRAM + main::offset#0 [ rand_state main::y#11 main::x#11 main::cnt#0 main::$8 ] ( main:3 [ rand_state main::y#11 main::x#11 main::cnt#0 main::$8 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:38 [ main::cnt#0 ]
Statement [23] main::$9 = main::cnt#0 & $f [ rand_state main::y#11 main::x#11 main::$8 main::$9 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$8 main::$9 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [24] *main::$8 = FADE[main::$9] [ rand_state main::y#11 main::x#11 ] ( main:3 [ rand_state main::y#11 main::x#11 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [26] rand::return#2 = rand::return#0 [ rand_state main::y#11 main::x#11 rand::return#2 ] ( main:3 [ rand_state main::y#11 main::x#11 rand::return#2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [27] main::$10 = rand::return#2 [ rand_state main::y#11 main::x#11 main::$10 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$10 ] { }  ) always clobbers reg byte a 
Statement [37] if(*((char *)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6 [ rand_state main::y#10 main::x#10 ] ( main:3 [ rand_state main::y#10 main::x#10 ] { }  ) always clobbers reg byte a 
Statement [50] memset::end#0 = (char *)memset::str#4 + $3e8 [ memset::str#4 memset::c#5 memset::end#0 ] ( main:3::memset:6 [ rand_state memset::str#4 memset::c#5 memset::end#0 ] { }  main:3::memset:8 [ rand_state memset::str#4 memset::c#5 memset::end#0 ] { }  main:3::memset:10 [ rand_state memset::str#4 memset::c#5 memset::end#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:36 [ memset::c#5 ]
Statement [51] memset::dst#4 = (char *)memset::str#4 [ memset::c#5 memset::end#0 memset::dst#4 ] ( main:3::memset:6 [ rand_state memset::c#5 memset::end#0 memset::dst#4 ] { }  main:3::memset:8 [ rand_state memset::c#5 memset::end#0 memset::dst#4 ] { }  main:3::memset:10 [ rand_state memset::c#5 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [53] if(memset::dst#2!=memset::end#0) goto memset::@3 [ memset::c#5 memset::end#0 memset::dst#2 ] ( main:3::memset:6 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  main:3::memset:8 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  main:3::memset:10 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [55] *memset::dst#2 = memset::c#5 [ memset::c#5 memset::end#0 memset::dst#2 ] ( main:3::memset:6 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  main:3::memset:8 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  main:3::memset:10 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:36 [ memset::c#5 ]
Statement [57] rand::$0 = rand_state << 7 [ rand_state rand::$0 ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state rand::$0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [58] rand_state = rand_state ^ rand::$0 [ rand_state ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [59] rand::$1 = rand_state >> 9 [ rand_state rand::$1 ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state rand::$1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [60] rand_state = rand_state ^ rand::$1 [ rand_state ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [61] rand::$2 = rand_state << 8 [ rand_state rand::$2 ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state rand::$2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [62] rand_state = rand_state ^ rand::$2 [ rand_state ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [63] rand::return#0 = rand_state [ rand_state rand::return#0 ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state rand::return#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [1] rand_state = 1 [ rand_state ] (  [ rand_state ] { }  ) always clobbers reg byte a 
Statement [11] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0 [ rand_state ] ( main:3 [ rand_state ] { }  ) always clobbers reg byte a 
Statement [12] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0 [ rand_state ] ( main:3 [ rand_state ] { }  ) always clobbers reg byte a 
Statement [14] main::$24 = (unsigned int)main::y#11 [ rand_state main::y#11 main::x#11 main::$24 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$24 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [15] main::$29 = main::$24 << 2 [ rand_state main::y#11 main::x#11 main::$24 main::$29 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$24 main::$29 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [16] main::$30 = main::$29 + main::$24 [ rand_state main::y#11 main::x#11 main::$30 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$30 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [17] main::$3 = main::$30 << 3 [ rand_state main::y#11 main::x#11 main::$3 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$3 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [18] main::offset#0 = main::$3 + main::x#11 [ rand_state main::y#11 main::x#11 main::offset#0 ] ( main:3 [ rand_state main::y#11 main::x#11 main::offset#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [19] main::$6 = VISITS + main::offset#0 [ rand_state main::y#11 main::x#11 main::offset#0 main::$6 ] ( main:3 [ rand_state main::y#11 main::x#11 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [20] *main::$6 = ++ *main::$6 [ rand_state main::y#11 main::x#11 main::offset#0 main::$6 ] ( main:3 [ rand_state main::y#11 main::x#11 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [21] main::cnt#0 = *main::$6 [ rand_state main::y#11 main::x#11 main::offset#0 main::cnt#0 ] ( main:3 [ rand_state main::y#11 main::x#11 main::offset#0 main::cnt#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [22] main::$8 = DEFAULT_COLORRAM + main::offset#0 [ rand_state main::y#11 main::x#11 main::cnt#0 main::$8 ] ( main:3 [ rand_state main::y#11 main::x#11 main::cnt#0 main::$8 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [23] main::$9 = main::cnt#0 & $f [ rand_state main::y#11 main::x#11 main::$8 main::$9 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$8 main::$9 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [24] *main::$8 = FADE[main::$9] [ rand_state main::y#11 main::x#11 ] ( main:3 [ rand_state main::y#11 main::x#11 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [26] rand::return#2 = rand::return#0 [ rand_state main::y#11 main::x#11 rand::return#2 ] ( main:3 [ rand_state main::y#11 main::x#11 rand::return#2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [27] main::$10 = rand::return#2 [ rand_state main::y#11 main::x#11 main::$10 ] ( main:3 [ rand_state main::y#11 main::x#11 main::$10 ] { }  ) always clobbers reg byte a 
Statement [37] if(*((char *)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6 [ rand_state main::y#10 main::x#10 ] ( main:3 [ rand_state main::y#10 main::x#10 ] { }  ) always clobbers reg byte a 
Statement [50] memset::end#0 = (char *)memset::str#4 + $3e8 [ memset::str#4 memset::c#5 memset::end#0 ] ( main:3::memset:6 [ rand_state memset::str#4 memset::c#5 memset::end#0 ] { }  main:3::memset:8 [ rand_state memset::str#4 memset::c#5 memset::end#0 ] { }  main:3::memset:10 [ rand_state memset::str#4 memset::c#5 memset::end#0 ] { }  ) always clobbers reg byte a 
Statement [51] memset::dst#4 = (char *)memset::str#4 [ memset::c#5 memset::end#0 memset::dst#4 ] ( main:3::memset:6 [ rand_state memset::c#5 memset::end#0 memset::dst#4 ] { }  main:3::memset:8 [ rand_state memset::c#5 memset::end#0 memset::dst#4 ] { }  main:3::memset:10 [ rand_state memset::c#5 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [53] if(memset::dst#2!=memset::end#0) goto memset::@3 [ memset::c#5 memset::end#0 memset::dst#2 ] ( main:3::memset:6 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  main:3::memset:8 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  main:3::memset:10 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [55] *memset::dst#2 = memset::c#5 [ memset::c#5 memset::end#0 memset::dst#2 ] ( main:3::memset:6 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  main:3::memset:8 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  main:3::memset:10 [ rand_state memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [57] rand::$0 = rand_state << 7 [ rand_state rand::$0 ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state rand::$0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [58] rand_state = rand_state ^ rand::$0 [ rand_state ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [59] rand::$1 = rand_state >> 9 [ rand_state rand::$1 ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state rand::$1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [60] rand_state = rand_state ^ rand::$1 [ rand_state ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [61] rand::$2 = rand_state << 8 [ rand_state rand::$2 ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state rand::$2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [62] rand_state = rand_state ^ rand::$2 [ rand_state ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [63] rand::return#0 = rand_state [ rand_state rand::return#0 ] ( main:3::rand:25 [ main::y#11 main::x#11 rand_state rand::return#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Potential registers zp[1]:5 [ main::y#11 main::y#10 main::y#2 main::y#1 ] : zp[1]:5 , reg byte x , 
Potential registers zp[1]:4 [ main::x#11 main::x#10 main::x#2 main::x#1 ] : zp[1]:4 , reg byte x , 
Potential registers zp[2]:43 [ memset::str#4 ] : zp[2]:43 , 
Potential registers zp[1]:36 [ memset::c#5 ] : zp[1]:36 , reg byte x , 
Potential registers zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ] : zp[2]:2 , 
Potential registers zp[2]:30 [ rand_state ] : zp[2]:30 , 
Potential registers zp[2]:34 [ main::$24 ] : zp[2]:34 , 
Potential registers zp[2]:14 [ main::$29 ] : zp[2]:14 , 
Potential registers zp[2]:16 [ main::$30 ] : zp[2]:16 , 
Potential registers zp[2]:18 [ main::$3 ] : zp[2]:18 , 
Potential registers zp[2]:41 [ main::offset#0 ] : zp[2]:41 , 
Potential registers zp[2]:20 [ main::$6 ] : zp[2]:20 , 
Potential registers zp[1]:38 [ main::cnt#0 ] : zp[1]:38 , reg byte x , reg byte y , 
Potential registers zp[2]:39 [ main::$8 ] : zp[2]:39 , 
Potential registers zp[1]:22 [ main::$9 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:23 [ rand::return#2 ] : zp[2]:23 , 
Potential registers zp[2]:25 [ main::$10 ] : zp[2]:25 , 
Potential registers zp[1]:37 [ main::rnd#0 ] : zp[1]:37 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:27 [ main::$12 ] : zp[1]:27 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:28 [ main::$13 ] : zp[1]:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:29 [ main::$18 ] : zp[1]:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:32 [ memset::end#0 ] : zp[2]:32 , 
Potential registers zp[2]:6 [ rand::$0 ] : zp[2]:6 , 
Potential registers zp[2]:8 [ rand::$1 ] : zp[2]:8 , 
Potential registers zp[2]:10 [ rand::$2 ] : zp[2]:10 , 
Potential registers zp[2]:12 [ rand::return#0 ] : zp[2]:12 , 

REGISTER UPLIFT SCOPES
Uplift Scope [rand] 2,002: zp[2]:6 [ rand::$0 ] 2,002: zp[2]:8 [ rand::$1 ] 2,002: zp[2]:10 [ rand::$2 ] 367.33: zp[2]:12 [ rand::return#0 ] 202: zp[2]:23 [ rand::return#2 ] 
Uplift Scope [main] 2,067.5: zp[1]:4 [ main::x#11 main::x#10 main::x#2 main::x#1 ] 2,063.89: zp[1]:5 [ main::y#11 main::y#10 main::y#2 main::y#1 ] 202: zp[2]:14 [ main::$29 ] 202: zp[2]:16 [ main::$30 ] 202: zp[2]:18 [ main::$3 ] 202: zp[2]:20 [ main::$6 ] 202: zp[1]:22 [ main::$9 ] 202: zp[2]:25 [ main::$10 ] 202: zp[1]:27 [ main::$12 ] 202: zp[1]:28 [ main::$13 ] 202: zp[1]:29 [ main::$18 ] 151.5: zp[2]:34 [ main::$24 ] 134.67: zp[1]:37 [ main::rnd#0 ] 101: zp[1]:38 [ main::cnt#0 ] 101: zp[2]:39 [ main::$8 ] 75.75: zp[2]:41 [ main::offset#0 ] 
Uplift Scope [memset] 3,572.33: zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ] 183.67: zp[2]:32 [ memset::end#0 ] 143: zp[1]:36 [ memset::c#5 ] 0: zp[2]:43 [ memset::str#4 ] 
Uplift Scope [] 185.41: zp[2]:30 [ rand_state ] 
Uplift Scope [MOS7360_TED] 
Uplift Scope [MOS6551_ACIA] 
Uplift Scope [MOS6529_PIO] 
Uplift Scope [MOS7501_PORT] 
Uplift Scope [PLUS4_ROM_BANKING] 
Uplift Scope [RADIX] 
Uplift Scope [__start] 

Uplifting [rand] best 8972 combination zp[2]:6 [ rand::$0 ] zp[2]:8 [ rand::$1 ] zp[2]:10 [ rand::$2 ] zp[2]:12 [ rand::return#0 ] zp[2]:23 [ rand::return#2 ] 
Uplifting [main] best 8092 combination reg byte x [ main::x#11 main::x#10 main::x#2 main::x#1 ] zp[1]:5 [ main::y#11 main::y#10 main::y#2 main::y#1 ] zp[2]:14 [ main::$29 ] zp[2]:16 [ main::$30 ] zp[2]:18 [ main::$3 ] zp[2]:20 [ main::$6 ] reg byte a [ main::$9 ] zp[2]:25 [ main::$10 ] reg byte a [ main::$12 ] reg byte a [ main::$13 ] zp[1]:29 [ main::$18 ] zp[2]:34 [ main::$24 ] zp[1]:37 [ main::rnd#0 ] zp[1]:38 [ main::cnt#0 ] zp[2]:39 [ main::$8 ] zp[2]:41 [ main::offset#0 ] 
Limited combination testing to 100 combinations of 12288 possible.
Uplifting [memset] best 8073 combination zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ] zp[2]:32 [ memset::end#0 ] reg byte x [ memset::c#5 ] zp[2]:43 [ memset::str#4 ] 
Uplifting [] best 8073 combination zp[2]:30 [ rand_state ] 
Uplifting [MOS7360_TED] best 8073 combination 
Uplifting [MOS6551_ACIA] best 8073 combination 
Uplifting [MOS6529_PIO] best 8073 combination 
Uplifting [MOS7501_PORT] best 8073 combination 
Uplifting [PLUS4_ROM_BANKING] best 8073 combination 
Uplifting [RADIX] best 8073 combination 
Uplifting [__start] best 8073 combination 
Attempting to uplift remaining variables inzp[1]:5 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Uplifting [main] best 8073 combination zp[1]:5 [ main::y#11 main::y#10 main::y#2 main::y#1 ] 
Attempting to uplift remaining variables inzp[1]:29 [ main::$18 ]
Uplifting [main] best 8033 combination reg byte a [ main::$18 ] 
Attempting to uplift remaining variables inzp[1]:37 [ main::rnd#0 ]
Uplifting [main] best 7973 combination reg byte y [ main::rnd#0 ] 
Attempting to uplift remaining variables inzp[1]:38 [ main::cnt#0 ]
Uplifting [main] best 7953 combination reg byte y [ main::cnt#0 ] 
Coalescing zero page register [ zp[2]:43 [ memset::str#4 ] ] with [ zp[2]:2 [ memset::dst#2 memset::dst#4 memset::dst#1 ] ] - score: 1
Coalescing zero page register [ zp[2]:34 [ main::$24 ] ] with [ zp[2]:16 [ main::$30 ] ] - score: 1
Coalescing zero page register [ zp[2]:18 [ main::$3 ] ] with [ zp[2]:41 [ main::offset#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:23 [ rand::return#2 ] ] with [ zp[2]:25 [ main::$10 ] ] - score: 1
Coalescing zero page register [ zp[2]:23 [ rand::return#2 main::$10 ] ] with [ zp[2]:12 [ rand::return#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:34 [ main::$24 main::$30 ] ] with [ zp[2]:18 [ main::$3 main::offset#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:34 [ main::$24 main::$30 main::$3 main::offset#0 ] ] with [ zp[2]:39 [ main::$8 ] ] - score: 1
Coalescing zero page register [ zp[2]:34 [ main::$24 main::$30 main::$3 main::offset#0 main::$8 ] ] with [ zp[2]:43 [ memset::str#4 memset::dst#2 memset::dst#4 memset::dst#1 ] ]
Coalescing zero page register [ zp[2]:6 [ rand::$0 ] ] with [ zp[2]:32 [ memset::end#0 ] ]
Allocated (was zp[2]:34) zp[2]:2 [ main::$24 main::$30 main::$3 main::offset#0 main::$8 memset::str#4 memset::dst#2 memset::dst#4 memset::dst#1 ]
Allocated (was zp[2]:6) zp[2]:4 [ rand::$0 memset::end#0 ]
Allocated (was zp[1]:5) zp[1]:6 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Allocated (was zp[2]:8) zp[2]:7 [ rand::$1 ]
Allocated (was zp[2]:10) zp[2]:9 [ rand::$2 ]
Allocated (was zp[2]:23) zp[2]:11 [ rand::return#2 main::$10 rand::return#0 ]
Allocated (was zp[2]:14) zp[2]:13 [ main::$29 ]
Allocated (was zp[2]:20) zp[2]:15 [ main::$6 ]
Allocated (was zp[2]:30) zp[2]:17 [ rand_state ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Random walk with color fading for Commodore Plus/4 / C16
/// @file
/// Plus/4 / Commodore 16 registers and memory layout
///
/// http://zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/264_Hardware_Spec.pdf
/// http://www.zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/Plus_4_Technical_Docs.pdf
/// http://personalpages.tds.net/~rcarlsen/cbm/c16/C16_Service_Manual_314001-03_(1984_Oct).pdf
/// https://www.floodgap.com/retrobits/ckb/secret/264memory.txt
/// @file
/// The MOS 7360/8360 TED chip used for graphics and sound in Plus/4 and Commodore 16
///
/// https://www.karlstechnology.com/commodore/TED7360-datasheet.pdf
/// http://mclauchlan.site.net.au/scott/C=Hacking/C-Hacking12/gfx.html
  // Upstart
  // Commodore 16 / Plus/4 executable PRG file
.file [name="plus4-randomwalk.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$1001]
.segmentdef Code [start=$100d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
  // Global Constants & labels
  .const OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
  .const OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
  .const OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
  /// Default address of screen luminance/color matrix
  .label DEFAULT_COLORRAM = $800
  /// Default address of screen character matrix
  .label DEFAULT_SCREEN = $c00
  /// The TED chip controlling video and sound on the Plus/4 and Commodore 16
  .label TED = $ff00
  // The random state variable
  .label rand_state = $11
.segment Code
  // __start
__start: {
    jmp __init1
    // __start::__init1
  __init1:
    // [1] rand_state = 1 -- vwuz1=vwuc1 
    lda #<1
    sta.z rand_state
    lda #>1
    sta.z rand_state+1
    // [2] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
  __b1_from___init1:
    jmp __b1
    // __start::@1
  __b1:
    // [3] call main
    // [5] phi from __start::@1 to main [phi:__start::@1->main]
  main_from___b1:
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [4] return 
    rts
}
  // main
main: {
    .label __3 = 2
    .label __6 = $f
    .label __8 = 2
    .label __10 = $b
    .label __24 = 2
    .label offset = 2
    .label y = 6
    .label __29 = $d
    .label __30 = 2
    // [6] call memset
    // [49] phi from main to memset [phi:main->memset]
  memset_from_main:
    // [49] phi memset::c#5 = $a0 [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #$a0
    // [49] phi memset::str#4 = (void *)DEFAULT_SCREEN [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_SCREEN
    sta.z memset.str
    lda #>DEFAULT_SCREEN
    sta.z memset.str+1
    jsr memset
    // [7] phi from main to main::@10 [phi:main->main::@10]
  __b10_from_main:
    jmp __b10
    // main::@10
  __b10:
    // [8] call memset
    // [49] phi from main::@10 to memset [phi:main::@10->memset]
  memset_from___b10:
    // [49] phi memset::c#5 = 0 [phi:main::@10->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [49] phi memset::str#4 = (void *)DEFAULT_COLORRAM [phi:main::@10->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_COLORRAM
    sta.z memset.str
    lda #>DEFAULT_COLORRAM
    sta.z memset.str+1
    jsr memset
    // [9] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  __b11_from___b10:
    jmp __b11
    // main::@11
  __b11:
    // [10] call memset
    // [49] phi from main::@11 to memset [phi:main::@11->memset]
  memset_from___b11:
    // [49] phi memset::c#5 = 0 [phi:main::@11->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [49] phi memset::str#4 = (void *)VISITS [phi:main::@11->memset#1] -- pvoz1=pvoc1 
    lda #<VISITS
    sta.z memset.str
    lda #>VISITS
    sta.z memset.str+1
    jsr memset
    jmp __b12
    // main::@12
  __b12:
    // [11] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR
    // [12] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR
    // [13] phi from main::@12 to main::@1 [phi:main::@12->main::@1]
  __b1_from___b12:
    // [13] phi main::x#11 = $14 [phi:main::@12->main::@1#0] -- vbuxx=vbuc1 
    ldx #$14
    // [13] phi main::y#11 = $c [phi:main::@12->main::@1#1] -- vbuz1=vbuc1 
    lda #$c
    sta.z y
    jmp __b1
    // main::@1
  __b1:
    jmp __b2
    // main::@2
  __b2:
    // [14] main::$24 = (unsigned int)main::y#11 -- vwuz1=_word_vbuz2 
    lda.z y
    sta.z __24
    lda #0
    sta.z __24+1
    // [15] main::$29 = main::$24 << 2 -- vwuz1=vwuz2_rol_2 
    lda.z __24
    asl
    sta.z __29
    lda.z __24+1
    rol
    sta.z __29+1
    asl.z __29
    rol.z __29+1
    // [16] main::$30 = main::$29 + main::$24 -- vwuz1=vwuz2_plus_vwuz1 
    clc
    lda.z __30
    adc.z __29
    sta.z __30
    lda.z __30+1
    adc.z __29+1
    sta.z __30+1
    // [17] main::$3 = main::$30 << 3 -- vwuz1=vwuz1_rol_3 
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    // [18] main::offset#0 = main::$3 + main::x#11 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z offset
    sta.z offset
    bcc !+
    inc.z offset+1
  !:
    // [19] main::$6 = VISITS + main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z offset
    clc
    adc #<VISITS
    sta.z __6
    lda.z offset+1
    adc #>VISITS
    sta.z __6+1
    // [20] *main::$6 = ++ *main::$6 -- _deref_pbuz1=_inc__deref_pbuz1 
    ldy #0
    lda (__6),y
    clc
    adc #1
    ldy #0
    sta (__6),y
    // [21] main::cnt#0 = *main::$6 -- vbuyy=_deref_pbuz1 
    ldy #0
    lda (__6),y
    tay
    // [22] main::$8 = DEFAULT_COLORRAM + main::offset#0 -- pbuz1=pbuc1_plus_vwuz1 
    lda.z __8
    clc
    adc #<DEFAULT_COLORRAM
    sta.z __8
    lda.z __8+1
    adc #>DEFAULT_COLORRAM
    sta.z __8+1
    // [23] main::$9 = main::cnt#0 & $f -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$f
    // [24] *main::$8 = FADE[main::$9] -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda FADE,y
    ldy #0
    sta (__8),y
    // [25] call rand
    jsr rand
    // [26] rand::return#2 = rand::return#0
    jmp __b13
    // main::@13
  __b13:
    // [27] main::$10 = rand::return#2
    // [28] main::rnd#0 = byte1  main::$10 -- vbuyy=_byte1_vwuz1 
    ldy.z __10+1
    // [29] main::$12 = main::rnd#0 & $80 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$80
    // [30] if(0!=main::$12) goto main::@3 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b3
    jmp __b7
    // main::@7
  __b7:
    // [31] main::$13 = main::rnd#0 & $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // [32] if(0!=main::$13) goto main::@4 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b4
    jmp __b8
    // main::@8
  __b8:
    // [33] main::y#2 = -- main::y#11 -- vbuz1=_dec_vbuz1 
    dec.z y
    // [34] if(main::y#2!=$ff) goto main::@14 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z y
    bne __b14_from___b8
    // [36] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
  __b6_from___b8:
    // [36] phi main::x#10 = main::x#11 [phi:main::@8->main::@6#0] -- register_copy 
    // [36] phi main::y#10 = 0 [phi:main::@8->main::@6#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp __b6
    // [35] phi from main::@8 to main::@14 [phi:main::@8->main::@14]
  __b14_from___b8:
    jmp __b14
    // main::@14
  __b14:
    // [36] phi from main::@14 main::@15 main::@16 main::@17 main::@6 to main::@6 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6]
  __b6_from___b14:
  __b6_from___b15:
  __b6_from___b16:
  __b6_from___b17:
  __b6_from___b6:
    // [36] phi main::x#10 = main::x#11 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#0] -- register_copy 
    // [36] phi main::y#10 = main::y#2 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#1] -- register_copy 
    jmp __b6
    // main::@6
  __b6:
    // [37] if(*((char *)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO
    bne __b6_from___b6
    // [13] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
  __b1_from___b6:
    // [13] phi main::x#11 = main::x#10 [phi:main::@6->main::@1#0] -- register_copy 
    // [13] phi main::y#11 = main::y#10 [phi:main::@6->main::@1#1] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // [38] main::y#1 = ++ main::y#11 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [39] if(main::y#1!=$19) goto main::@16 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b16_from___b4
    // [36] phi from main::@4 to main::@6 [phi:main::@4->main::@6]
  __b6_from___b4:
    // [36] phi main::x#10 = main::x#11 [phi:main::@4->main::@6#0] -- register_copy 
    // [36] phi main::y#10 = $18 [phi:main::@4->main::@6#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z y
    jmp __b6
    // [40] phi from main::@4 to main::@16 [phi:main::@4->main::@16]
  __b16_from___b4:
    jmp __b16
    // main::@16
  __b16:
    jmp __b6_from___b16
    // main::@3
  __b3:
    // [41] main::$18 = main::rnd#0 & $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // [42] if(0!=main::$18) goto main::@5 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b5
    jmp __b9
    // main::@9
  __b9:
    // [43] main::x#2 = -- main::x#11 -- vbuxx=_dec_vbuxx 
    dex
    // [44] if(main::x#2!=$ff) goto main::@15 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b15_from___b9
    // [36] phi from main::@9 to main::@6 [phi:main::@9->main::@6]
  __b6_from___b9:
    // [36] phi main::x#10 = 0 [phi:main::@9->main::@6#0] -- vbuxx=vbuc1 
    ldx #0
    // [36] phi main::y#10 = main::y#11 [phi:main::@9->main::@6#1] -- register_copy 
    jmp __b6
    // [45] phi from main::@9 to main::@15 [phi:main::@9->main::@15]
  __b15_from___b9:
    jmp __b15
    // main::@15
  __b15:
    jmp __b6_from___b15
    // main::@5
  __b5:
    // [46] main::x#1 = ++ main::x#11 -- vbuxx=_inc_vbuxx 
    inx
    // [47] if(main::x#1!=$28) goto main::@17 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne __b17_from___b5
    // [36] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    // [36] phi main::x#10 = $27 [phi:main::@5->main::@6#0] -- vbuxx=vbuc1 
    ldx #$27
    // [36] phi main::y#10 = main::y#11 [phi:main::@5->main::@6#1] -- register_copy 
    jmp __b6
    // [48] phi from main::@5 to main::@17 [phi:main::@5->main::@17]
  __b17_from___b5:
    jmp __b17
    // main::@17
  __b17:
    jmp __b6_from___b17
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// void * memset(__zp(2) void *str, __register(X) char c, unsigned int num)
memset: {
    .label end = 4
    .label dst = 2
    .label str = 2
    jmp __b1
    // memset::@1
  __b1:
    // [50] memset::end#0 = (char *)memset::str#4 + $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [51] memset::dst#4 = (char *)memset::str#4
    // [52] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  __b2_from___b1:
  __b2_from___b3:
    // [52] phi memset::dst#2 = memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp __b2
    // memset::@2
  __b2:
    // [53] if(memset::dst#2!=memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    jmp __breturn
    // memset::@return
  __breturn:
    // [54] return 
    rts
    // memset::@3
  __b3:
    // [55] *memset::dst#2 = memset::c#5 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // [56] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2_from___b3
}
  // rand
// Returns a pseudo-random number in the range of 0 to RAND_MAX (65535)
// Uses an xorshift pseudorandom number generator that hits all different values
// Information https://en.wikipedia.org/wiki/Xorshift
// Source http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html
rand: {
    .label __0 = 4
    .label __1 = 7
    .label __2 = 9
    .label return = $b
    // [57] rand::$0 = rand_state << 7 -- vwuz1=vwuz2_rol_7 
    lda.z rand_state+1
    lsr
    lda.z rand_state
    ror
    sta.z __0+1
    lda #0
    ror
    sta.z __0
    // [58] rand_state = rand_state ^ rand::$0 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __0
    sta.z rand_state
    lda.z rand_state+1
    eor.z __0+1
    sta.z rand_state+1
    // [59] rand::$1 = rand_state >> 9 -- vwuz1=vwuz2_ror_9 
    lda.z rand_state+1
    lsr
    sta.z __1
    lda #0
    sta.z __1+1
    // [60] rand_state = rand_state ^ rand::$1 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __1
    sta.z rand_state
    lda.z rand_state+1
    eor.z __1+1
    sta.z rand_state+1
    // [61] rand::$2 = rand_state << 8 -- vwuz1=vwuz2_rol_8 
    lda.z rand_state
    sta.z __2+1
    lda #0
    sta.z __2
    // [62] rand_state = rand_state ^ rand::$2 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __2
    sta.z rand_state
    lda.z rand_state+1
    eor.z __2+1
    sta.z rand_state+1
    // [63] rand::return#0 = rand_state -- vwuz1=vwuz2 
    lda.z rand_state
    sta.z return
    lda.z rand_state+1
    sta.z return+1
    jmp __breturn
    // rand::@return
  __breturn:
    // [64] return 
    rts
}
  // File Data
.segment Data
  // Colors to fade up/down when visiting a char multiple times
  FADE: .byte 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6
  // The number of times each character has been visited
  VISITS: .fill $3e8, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __init1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b13
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b14
Removing instruction jmp __b6
Removing instruction jmp __b16
Removing instruction jmp __b9
Removing instruction jmp __b15
Removing instruction jmp __b17
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction lda.z rand_state+1
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b14_from___b8 with __b6
Replacing label __b6_from___b6 with __b6
Replacing label __b1 with __b2
Replacing label __b16_from___b4 with __b16
Replacing label __b6_from___b16 with __b6
Replacing label __b15_from___b9 with __b15
Replacing label __b6_from___b15 with __b6
Replacing label __b17_from___b5 with __b17
Replacing label __b6_from___b17 with __b6
Replacing label __b2_from___b3 with __b2
Removing instruction __b1_from___init1:
Removing instruction main_from___b1:
Removing instruction __b10_from_main:
Removing instruction memset_from___b10:
Removing instruction __b11_from___b10:
Removing instruction memset_from___b11:
Removing instruction __b1:
Removing instruction __b14_from___b8:
Removing instruction __b14:
Removing instruction __b6_from___b14:
Removing instruction __b6_from___b15:
Removing instruction __b6_from___b16:
Removing instruction __b6_from___b17:
Removing instruction __b6_from___b6:
Removing instruction __b16_from___b4:
Removing instruction __b15_from___b9:
Removing instruction __b17_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __init1:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction memset_from_main:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b1_from___b12:
Removing instruction __b13:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b6_from___b8:
Removing instruction __b1_from___b6:
Removing instruction __b6_from___b4:
Removing instruction __b9:
Removing instruction __b6_from___b9:
Removing instruction __b6_from___b5:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Skipping double jump to __b6 in bne __b16
Skipping double jump to __b6 in bne __b15
Skipping double jump to __b6 in bne __b17
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction jmp __b6
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b16:
Removing instruction __b15:
Removing instruction __b17:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing unreachable instruction jmp __b6
Removing unreachable instruction jmp __b6
Removing unreachable instruction jmp __b6
Succesful ASM optimization Pass5UnreachableCodeElimination

FINAL SYMBOL TABLE
__constant char * const DEFAULT_COLORRAM = (char *) 2048
__constant char * const DEFAULT_SCREEN = (char *) 3072
__constant char FADE[$10] = { 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6 }
__constant char OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
__constant char OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
__constant char OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
__constant char RADIX::BINARY = 2
__constant char RADIX::DECIMAL = $a
__constant char RADIX::HEXADECIMAL = $10
__constant char RADIX::OCTAL = 8
__constant struct MOS7360_TED * const TED = (struct MOS7360_TED *) 65280
__constant char VISITS[$3e8] = { fill( $3e8, 0) }
void __start()
void main()
unsigned int main::$10 // zp[2]:11 202.0
char main::$12 // reg byte a 202.0
char main::$13 // reg byte a 202.0
char main::$18 // reg byte a 202.0
unsigned int main::$24 // zp[2]:2 151.5
unsigned int main::$29 // zp[2]:13 202.0
unsigned int main::$3 // zp[2]:2 202.0
unsigned int main::$30 // zp[2]:2 202.0
char *main::$6 // zp[2]:15 202.0
char *main::$8 // zp[2]:2 101.0
char main::$9 // reg byte a 202.0
char main::cnt
char main::cnt#0 // reg byte y 101.0
unsigned int main::offset
unsigned int main::offset#0 // offset zp[2]:2 75.75
char main::rnd
char main::rnd#0 // reg byte y 134.66666666666666
char main::x
char main::x#1 // reg byte x 101.0
char main::x#10 // reg byte x 1804.5
char main::x#11 // reg byte x 60.99999999999998
char main::x#2 // reg byte x 101.0
char main::y
char main::y#1 // y zp[1]:6 101.0
char main::y#10 // y zp[1]:6 1804.5
char main::y#11 // y zp[1]:6 57.392857142857125
char main::y#2 // y zp[1]:6 101.0
void * memset(void *str , char c , unsigned int num)
char memset::c
char memset::c#5 // reg byte x 143.0
char *memset::dst
char *memset::dst#1 // dst zp[2]:2 2002.0
char *memset::dst#2 // dst zp[2]:2 1368.3333333333335
char *memset::dst#4 // dst zp[2]:2 202.0
char *memset::end
char *memset::end#0 // end zp[2]:4 183.66666666666669
unsigned int memset::num
void *memset::return
void *memset::str
void *memset::str#4 // str zp[2]:2
unsigned int rand()
unsigned int rand::$0 // zp[2]:4 2002.0
unsigned int rand::$1 // zp[2]:7 2002.0
unsigned int rand::$2 // zp[2]:9 2002.0
unsigned int rand::return
unsigned int rand::return#0 // return zp[2]:11 367.33333333333337
unsigned int rand::return#2 // return zp[2]:11 202.0
__loadstore volatile unsigned int rand_state // zp[2]:17 185.40740740740742

zp[1]:6 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
reg byte x [ main::x#11 main::x#10 main::x#2 main::x#1 ]
reg byte x [ memset::c#5 ]
zp[2]:17 [ rand_state ]
zp[2]:2 [ main::$24 main::$30 main::$3 main::offset#0 main::$8 memset::str#4 memset::dst#2 memset::dst#4 memset::dst#1 ]
zp[2]:13 [ main::$29 ]
zp[2]:15 [ main::$6 ]
reg byte y [ main::cnt#0 ]
reg byte a [ main::$9 ]
zp[2]:11 [ rand::return#2 main::$10 rand::return#0 ]
reg byte y [ main::rnd#0 ]
reg byte a [ main::$12 ]
reg byte a [ main::$13 ]
reg byte a [ main::$18 ]
zp[2]:4 [ rand::$0 memset::end#0 ]
zp[2]:7 [ rand::$1 ]
zp[2]:9 [ rand::$2 ]


FINAL ASSEMBLER
Score: 6463

  // File Comments
// Random walk with color fading for Commodore Plus/4 / C16
/// @file
/// Plus/4 / Commodore 16 registers and memory layout
///
/// http://zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/264_Hardware_Spec.pdf
/// http://www.zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/Plus_4_Technical_Docs.pdf
/// http://personalpages.tds.net/~rcarlsen/cbm/c16/C16_Service_Manual_314001-03_(1984_Oct).pdf
/// https://www.floodgap.com/retrobits/ckb/secret/264memory.txt
/// @file
/// The MOS 7360/8360 TED chip used for graphics and sound in Plus/4 and Commodore 16
///
/// https://www.karlstechnology.com/commodore/TED7360-datasheet.pdf
/// http://mclauchlan.site.net.au/scott/C=Hacking/C-Hacking12/gfx.html
  // Upstart
  // Commodore 16 / Plus/4 executable PRG file
.file [name="plus4-randomwalk.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$1001]
.segmentdef Code [start=$100d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
  // Global Constants & labels
  .const OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
  .const OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
  .const OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
  /// Default address of screen luminance/color matrix
  .label DEFAULT_COLORRAM = $800
  /// Default address of screen character matrix
  .label DEFAULT_SCREEN = $c00
  /// The TED chip controlling video and sound on the Plus/4 and Commodore 16
  .label TED = $ff00
  // The random state variable
  .label rand_state = $11
.segment Code
  // __start
__start: {
    // __start::__init1
    // volatile unsigned int rand_state = 1
    // [1] rand_state = 1 -- vwuz1=vwuc1 
    lda #<1
    sta.z rand_state
    lda #>1
    sta.z rand_state+1
    // [2] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
    // __start::@1
    // [3] call main
    // [5] phi from __start::@1 to main [phi:__start::@1->main]
    jsr main
    // __start::@return
    // [4] return 
    rts
}
  // main
main: {
    .label __3 = 2
    .label __6 = $f
    .label __8 = 2
    .label __10 = $b
    .label __24 = 2
    .label offset = 2
    .label y = 6
    .label __29 = $d
    .label __30 = 2
    // memset(DEFAULT_SCREEN, 0xa0, 1000)
    // [6] call memset
    // [49] phi from main to memset [phi:main->memset]
    // [49] phi memset::c#5 = $a0 [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #$a0
    // [49] phi memset::str#4 = (void *)DEFAULT_SCREEN [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_SCREEN
    sta.z memset.str
    lda #>DEFAULT_SCREEN
    sta.z memset.str+1
    jsr memset
    // [7] phi from main to main::@10 [phi:main->main::@10]
    // main::@10
    // memset(DEFAULT_COLORRAM, 0, 1000)
    // [8] call memset
    // [49] phi from main::@10 to memset [phi:main::@10->memset]
    // [49] phi memset::c#5 = 0 [phi:main::@10->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [49] phi memset::str#4 = (void *)DEFAULT_COLORRAM [phi:main::@10->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_COLORRAM
    sta.z memset.str
    lda #>DEFAULT_COLORRAM
    sta.z memset.str+1
    jsr memset
    // [9] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
    // main::@11
    // memset(VISITS, 0, 1000)
    // [10] call memset
    // [49] phi from main::@11 to memset [phi:main::@11->memset]
    // [49] phi memset::c#5 = 0 [phi:main::@11->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [49] phi memset::str#4 = (void *)VISITS [phi:main::@11->memset#1] -- pvoz1=pvoc1 
    lda #<VISITS
    sta.z memset.str
    lda #>VISITS
    sta.z memset.str+1
    jsr memset
    // main::@12
    // TED->BG_COLOR = 0
    // [11] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR
    // TED->BORDER_COLOR = 0
    // [12] *((char *)TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) = 0 -- _deref_pbuc1=vbuc2 
    sta TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR
    // [13] phi from main::@12 to main::@1 [phi:main::@12->main::@1]
    // [13] phi main::x#11 = $14 [phi:main::@12->main::@1#0] -- vbuxx=vbuc1 
    ldx #$14
    // [13] phi main::y#11 = $c [phi:main::@12->main::@1#1] -- vbuz1=vbuc1 
    lda #$c
    sta.z y
    // main::@1
    // main::@2
  __b2:
    // (unsigned int)y*40
    // [14] main::$24 = (unsigned int)main::y#11 -- vwuz1=_word_vbuz2 
    lda.z y
    sta.z __24
    lda #0
    sta.z __24+1
    // [15] main::$29 = main::$24 << 2 -- vwuz1=vwuz2_rol_2 
    lda.z __24
    asl
    sta.z __29
    lda.z __24+1
    rol
    sta.z __29+1
    asl.z __29
    rol.z __29+1
    // [16] main::$30 = main::$29 + main::$24 -- vwuz1=vwuz2_plus_vwuz1 
    clc
    lda.z __30
    adc.z __29
    sta.z __30
    lda.z __30+1
    adc.z __29+1
    sta.z __30+1
    // [17] main::$3 = main::$30 << 3 -- vwuz1=vwuz1_rol_3 
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    // unsigned int offset = (unsigned int)y*40+x
    // [18] main::offset#0 = main::$3 + main::x#11 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z offset
    sta.z offset
    bcc !+
    inc.z offset+1
  !:
    // VISITS+offset
    // [19] main::$6 = VISITS + main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z offset
    clc
    adc #<VISITS
    sta.z __6
    lda.z offset+1
    adc #>VISITS
    sta.z __6+1
    // char cnt = ++*(VISITS+offset)
    // [20] *main::$6 = ++ *main::$6 -- _deref_pbuz1=_inc__deref_pbuz1 
    ldy #0
    lda (__6),y
    clc
    adc #1
    sta (__6),y
    // [21] main::cnt#0 = *main::$6 -- vbuyy=_deref_pbuz1 
    lda (__6),y
    tay
    // DEFAULT_COLORRAM+offset
    // [22] main::$8 = DEFAULT_COLORRAM + main::offset#0 -- pbuz1=pbuc1_plus_vwuz1 
    lda.z __8
    clc
    adc #<DEFAULT_COLORRAM
    sta.z __8
    lda.z __8+1
    adc #>DEFAULT_COLORRAM
    sta.z __8+1
    // cnt&0xf
    // [23] main::$9 = main::cnt#0 & $f -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$f
    // *(DEFAULT_COLORRAM+offset) = FADE[cnt&0xf]
    // [24] *main::$8 = FADE[main::$9] -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda FADE,y
    ldy #0
    sta (__8),y
    // rand()
    // [25] call rand
    jsr rand
    // [26] rand::return#2 = rand::return#0
    // main::@13
    // [27] main::$10 = rand::return#2
    // char rnd = BYTE1(rand())
    // [28] main::rnd#0 = byte1  main::$10 -- vbuyy=_byte1_vwuz1 
    ldy.z __10+1
    // rnd & 0x80
    // [29] main::$12 = main::rnd#0 & $80 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$80
    // if(rnd & 0x80)
    // [30] if(0!=main::$12) goto main::@3 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b3
    // main::@7
    // rnd & 0x40
    // [31] main::$13 = main::rnd#0 & $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // if(rnd & 0x40)
    // [32] if(0!=main::$13) goto main::@4 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b4
    // main::@8
    // y--;
    // [33] main::y#2 = -- main::y#11 -- vbuz1=_dec_vbuz1 
    dec.z y
    // if(y==0xff)
    // [34] if(main::y#2!=$ff) goto main::@14 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z y
    bne __b6
    // [36] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
    // [36] phi main::x#10 = main::x#11 [phi:main::@8->main::@6#0] -- register_copy 
    // [36] phi main::y#10 = 0 [phi:main::@8->main::@6#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [35] phi from main::@8 to main::@14 [phi:main::@8->main::@14]
    // main::@14
    // [36] phi from main::@14 main::@15 main::@16 main::@17 main::@6 to main::@6 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6]
    // [36] phi main::x#10 = main::x#11 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#0] -- register_copy 
    // [36] phi main::y#10 = main::y#2 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#1] -- register_copy 
    // main::@6
  __b6:
    // while(TED->RASTER_LO!=0xff)
    // [37] if(*((char *)TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=$ff) goto main::@6 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO
    bne __b6
    // [13] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
    // [13] phi main::x#11 = main::x#10 [phi:main::@6->main::@1#0] -- register_copy 
    // [13] phi main::y#11 = main::y#10 [phi:main::@6->main::@1#1] -- register_copy 
    jmp __b2
    // main::@4
  __b4:
    // y++;
    // [38] main::y#1 = ++ main::y#11 -- vbuz1=_inc_vbuz1 
    inc.z y
    // if(y==25)
    // [39] if(main::y#1!=$19) goto main::@16 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b6
    // [36] phi from main::@4 to main::@6 [phi:main::@4->main::@6]
    // [36] phi main::x#10 = main::x#11 [phi:main::@4->main::@6#0] -- register_copy 
    // [36] phi main::y#10 = $18 [phi:main::@4->main::@6#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z y
    jmp __b6
    // [40] phi from main::@4 to main::@16 [phi:main::@4->main::@16]
    // main::@16
    // main::@3
  __b3:
    // rnd& 0x40
    // [41] main::$18 = main::rnd#0 & $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // if(rnd& 0x40)
    // [42] if(0!=main::$18) goto main::@5 -- 0_neq_vbuaa_then_la1 
    cmp #0
    bne __b5
    // main::@9
    // x--;
    // [43] main::x#2 = -- main::x#11 -- vbuxx=_dec_vbuxx 
    dex
    // if(x==0xff)
    // [44] if(main::x#2!=$ff) goto main::@15 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b6
    // [36] phi from main::@9 to main::@6 [phi:main::@9->main::@6]
    // [36] phi main::x#10 = 0 [phi:main::@9->main::@6#0] -- vbuxx=vbuc1 
    ldx #0
    // [36] phi main::y#10 = main::y#11 [phi:main::@9->main::@6#1] -- register_copy 
    jmp __b6
    // [45] phi from main::@9 to main::@15 [phi:main::@9->main::@15]
    // main::@15
    // main::@5
  __b5:
    // x++;
    // [46] main::x#1 = ++ main::x#11 -- vbuxx=_inc_vbuxx 
    inx
    // if(x==40)
    // [47] if(main::x#1!=$28) goto main::@17 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne __b6
    // [36] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // [36] phi main::x#10 = $27 [phi:main::@5->main::@6#0] -- vbuxx=vbuc1 
    ldx #$27
    // [36] phi main::y#10 = main::y#11 [phi:main::@5->main::@6#1] -- register_copy 
    jmp __b6
    // [48] phi from main::@5 to main::@17 [phi:main::@5->main::@17]
    // main::@17
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// void * memset(__zp(2) void *str, __register(X) char c, unsigned int num)
memset: {
    .label end = 4
    .label dst = 2
    .label str = 2
    // memset::@1
    // char* end = (char*)str + num
    // [50] memset::end#0 = (char *)memset::str#4 + $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [51] memset::dst#4 = (char *)memset::str#4
    // [52] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
    // [52] phi memset::dst#2 = memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    // memset::@2
  __b2:
    // for(char* dst = str; dst!=end; dst++)
    // [53] if(memset::dst#2!=memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    // memset::@return
    // }
    // [54] return 
    rts
    // memset::@3
  __b3:
    // *dst = c
    // [55] *memset::dst#2 = memset::c#5 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [56] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2
}
  // rand
// Returns a pseudo-random number in the range of 0 to RAND_MAX (65535)
// Uses an xorshift pseudorandom number generator that hits all different values
// Information https://en.wikipedia.org/wiki/Xorshift
// Source http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html
rand: {
    .label __0 = 4
    .label __1 = 7
    .label __2 = 9
    .label return = $b
    // rand_state << 7
    // [57] rand::$0 = rand_state << 7 -- vwuz1=vwuz2_rol_7 
    lda.z rand_state+1
    lsr
    lda.z rand_state
    ror
    sta.z __0+1
    lda #0
    ror
    sta.z __0
    // rand_state ^= rand_state << 7
    // [58] rand_state = rand_state ^ rand::$0 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __0
    sta.z rand_state
    lda.z rand_state+1
    eor.z __0+1
    sta.z rand_state+1
    // rand_state >> 9
    // [59] rand::$1 = rand_state >> 9 -- vwuz1=vwuz2_ror_9 
    lsr
    sta.z __1
    lda #0
    sta.z __1+1
    // rand_state ^= rand_state >> 9
    // [60] rand_state = rand_state ^ rand::$1 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __1
    sta.z rand_state
    lda.z rand_state+1
    eor.z __1+1
    sta.z rand_state+1
    // rand_state << 8
    // [61] rand::$2 = rand_state << 8 -- vwuz1=vwuz2_rol_8 
    lda.z rand_state
    sta.z __2+1
    lda #0
    sta.z __2
    // rand_state ^= rand_state << 8
    // [62] rand_state = rand_state ^ rand::$2 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __2
    sta.z rand_state
    lda.z rand_state+1
    eor.z __2+1
    sta.z rand_state+1
    // return rand_state;
    // [63] rand::return#0 = rand_state -- vwuz1=vwuz2 
    lda.z rand_state
    sta.z return
    lda.z rand_state+1
    sta.z return+1
    // rand::@return
    // }
    // [64] return 
    rts
}
  // File Data
.segment Data
  // Colors to fade up/down when visiting a char multiple times
  FADE: .byte 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6
  // The number of times each character has been visited
  VISITS: .fill $3e8, 0

