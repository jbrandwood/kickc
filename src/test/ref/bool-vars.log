Eliminating unused variable with no statement bool_and::$0
Eliminating unused variable with no statement bool_and::$2
Eliminating unused variable with no statement bool_and::$3
Eliminating unused variable with no statement bool_or::$0
Eliminating unused variable with no statement bool_or::$2
Eliminating unused variable with no statement bool_or::$3
Eliminating unused variable with no statement bool_not::$0
Eliminating unused variable with no statement bool_not::$2
Eliminating unused variable with no statement bool_not::$4
Eliminating unused variable with no statement bool_complex::$0
Eliminating unused variable with no statement bool_complex::$2
Eliminating unused variable with no statement bool_complex::$3
Eliminating unused variable with no statement bool_complex::$5
Eliminating unused variable with no statement bool_complex::$6

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start
  call bool_and
  to:main::@1
main::@1: scope:[main]  from main
  call bool_or
  to:main::@2
main::@2: scope:[main]  from main::@1
  call bool_not
  to:main::@3
main::@3: scope:[main]  from main::@2
  call bool_complex
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return

void bool_and()
bool_and: scope:[bool_and]  from main
  bool_and::i#0 = 0
  to:bool_and::@1
bool_and::@1: scope:[bool_and]  from bool_and bool_and::@3
  bool_and::i#2 = phi( bool_and/bool_and::i#0, bool_and::@3/bool_and::i#1 )
  bool_and::o1#0 = bool_and::i#2 < $a
  bool_and::$1 = bool_and::i#2 & 1
  bool_and::o2#0 = bool_and::$1 == 0
  bool_and::o3#0 = bool_and::o1#0 && bool_and::o2#0
  if(bool_and::o3#0) goto bool_and::@2
  to:bool_and::@4
bool_and::@2: scope:[bool_and]  from bool_and::@1
  bool_and::i#3 = phi( bool_and::@1/bool_and::i#2 )
  bool_and::screen[bool_and::i#3] = '*'
  to:bool_and::@3
bool_and::@4: scope:[bool_and]  from bool_and::@1
  bool_and::i#4 = phi( bool_and::@1/bool_and::i#2 )
  bool_and::screen[bool_and::i#4] = ' '
  to:bool_and::@3
bool_and::@3: scope:[bool_and]  from bool_and::@2 bool_and::@4
  bool_and::i#5 = phi( bool_and::@2/bool_and::i#3, bool_and::@4/bool_and::i#4 )
  bool_and::i#1 = bool_and::i#5 + rangenext(0,$14)
  bool_and::$4 = bool_and::i#1 != rangelast(0,$14)
  if(bool_and::$4) goto bool_and::@1
  to:bool_and::@return
bool_and::@return: scope:[bool_and]  from bool_and::@3
  return 
  to:@return

void bool_or()
bool_or: scope:[bool_or]  from main::@1
  bool_or::i#0 = 0
  to:bool_or::@1
bool_or::@1: scope:[bool_or]  from bool_or bool_or::@3
  bool_or::i#2 = phi( bool_or/bool_or::i#0, bool_or::@3/bool_or::i#1 )
  bool_or::o1#0 = bool_or::i#2 < $a
  bool_or::$1 = bool_or::i#2 & 1
  bool_or::o2#0 = bool_or::$1 == 0
  bool_or::o3#0 = bool_or::o1#0 || bool_or::o2#0
  if(bool_or::o3#0) goto bool_or::@2
  to:bool_or::@4
bool_or::@2: scope:[bool_or]  from bool_or::@1
  bool_or::i#3 = phi( bool_or::@1/bool_or::i#2 )
  bool_or::screen[bool_or::i#3] = '*'
  to:bool_or::@3
bool_or::@4: scope:[bool_or]  from bool_or::@1
  bool_or::i#4 = phi( bool_or::@1/bool_or::i#2 )
  bool_or::screen[bool_or::i#4] = ' '
  to:bool_or::@3
bool_or::@3: scope:[bool_or]  from bool_or::@2 bool_or::@4
  bool_or::i#5 = phi( bool_or::@2/bool_or::i#3, bool_or::@4/bool_or::i#4 )
  bool_or::i#1 = bool_or::i#5 + rangenext(0,$14)
  bool_or::$4 = bool_or::i#1 != rangelast(0,$14)
  if(bool_or::$4) goto bool_or::@1
  to:bool_or::@return
bool_or::@return: scope:[bool_or]  from bool_or::@3
  return 
  to:@return

void bool_not()
bool_not: scope:[bool_not]  from main::@2
  bool_not::i#0 = 0
  to:bool_not::@1
bool_not::@1: scope:[bool_not]  from bool_not bool_not::@3
  bool_not::i#2 = phi( bool_not/bool_not::i#0, bool_not::@3/bool_not::i#1 )
  bool_not::o1#0 = bool_not::i#2 < $a
  bool_not::$1 = bool_not::i#2 & 1
  bool_not::o2#0 = bool_not::$1 == 0
  bool_not::$3 = bool_not::o1#0 || bool_not::o2#0
  bool_not::o3#0 = ! bool_not::$3
  if(bool_not::o3#0) goto bool_not::@2
  to:bool_not::@4
bool_not::@2: scope:[bool_not]  from bool_not::@1
  bool_not::i#3 = phi( bool_not::@1/bool_not::i#2 )
  bool_not::screen[bool_not::i#3] = '*'
  to:bool_not::@3
bool_not::@4: scope:[bool_not]  from bool_not::@1
  bool_not::i#4 = phi( bool_not::@1/bool_not::i#2 )
  bool_not::screen[bool_not::i#4] = ' '
  to:bool_not::@3
bool_not::@3: scope:[bool_not]  from bool_not::@2 bool_not::@4
  bool_not::i#5 = phi( bool_not::@2/bool_not::i#3, bool_not::@4/bool_not::i#4 )
  bool_not::i#1 = bool_not::i#5 + rangenext(0,$14)
  bool_not::$5 = bool_not::i#1 != rangelast(0,$14)
  if(bool_not::$5) goto bool_not::@1
  to:bool_not::@return
bool_not::@return: scope:[bool_not]  from bool_not::@3
  return 
  to:@return

void bool_complex()
bool_complex: scope:[bool_complex]  from main::@3
  bool_complex::i#0 = 0
  to:bool_complex::@1
bool_complex::@1: scope:[bool_complex]  from bool_complex bool_complex::@3
  bool_complex::i#2 = phi( bool_complex/bool_complex::i#0, bool_complex::@3/bool_complex::i#1 )
  bool_complex::o1#0 = bool_complex::i#2 < $a
  bool_complex::$1 = bool_complex::i#2 & 1
  bool_complex::o2#0 = bool_complex::$1 == 0
  bool_complex::o3#0 = bool_complex::o1#0 && bool_complex::o2#0
  bool_complex::$4 = bool_complex::o1#0 || bool_complex::o2#0
  bool_complex::o4#0 = ! bool_complex::$4
  bool_complex::o5#0 = bool_complex::o3#0 || bool_complex::o4#0
  if(bool_complex::o5#0) goto bool_complex::@2
  to:bool_complex::@4
bool_complex::@2: scope:[bool_complex]  from bool_complex::@1
  bool_complex::i#3 = phi( bool_complex::@1/bool_complex::i#2 )
  bool_complex::screen[bool_complex::i#3] = '*'
  to:bool_complex::@3
bool_complex::@4: scope:[bool_complex]  from bool_complex::@1
  bool_complex::i#4 = phi( bool_complex::@1/bool_complex::i#2 )
  bool_complex::screen[bool_complex::i#4] = ' '
  to:bool_complex::@3
bool_complex::@3: scope:[bool_complex]  from bool_complex::@2 bool_complex::@4
  bool_complex::i#5 = phi( bool_complex::@2/bool_complex::i#3, bool_complex::@4/bool_complex::i#4 )
  bool_complex::i#1 = bool_complex::i#5 + rangenext(0,$14)
  bool_complex::$7 = bool_complex::i#1 != rangelast(0,$14)
  if(bool_complex::$7) goto bool_complex::@1
  to:bool_complex::@return
bool_complex::@return: scope:[bool_complex]  from bool_complex::@3
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
void __start()
void bool_and()
number bool_and::$1
bool bool_and::$4
char bool_and::i
char bool_and::i#0
char bool_and::i#1
char bool_and::i#2
char bool_and::i#3
char bool_and::i#4
char bool_and::i#5
bool bool_and::o1
bool bool_and::o1#0
bool bool_and::o2
bool bool_and::o2#0
bool bool_and::o3
bool bool_and::o3#0
__constant char * const bool_and::screen = (char *)$400
void bool_complex()
number bool_complex::$1
bool bool_complex::$4
bool bool_complex::$7
char bool_complex::i
char bool_complex::i#0
char bool_complex::i#1
char bool_complex::i#2
char bool_complex::i#3
char bool_complex::i#4
char bool_complex::i#5
bool bool_complex::o1
bool bool_complex::o1#0
bool bool_complex::o2
bool bool_complex::o2#0
bool bool_complex::o3
bool bool_complex::o3#0
bool bool_complex::o4
bool bool_complex::o4#0
bool bool_complex::o5
bool bool_complex::o5#0
__constant char * const bool_complex::screen = (char *)$478
void bool_not()
number bool_not::$1
bool bool_not::$3
bool bool_not::$5
char bool_not::i
char bool_not::i#0
char bool_not::i#1
char bool_not::i#2
char bool_not::i#3
char bool_not::i#4
char bool_not::i#5
bool bool_not::o1
bool bool_not::o1#0
bool bool_not::o2
bool bool_not::o2#0
bool bool_not::o3
bool bool_not::o3#0
__constant char * const bool_not::screen = (char *)$450
void bool_or()
number bool_or::$1
bool bool_or::$4
char bool_or::i
char bool_or::i#0
char bool_or::i#1
char bool_or::i#2
char bool_or::i#3
char bool_or::i#4
char bool_or::i#5
bool bool_or::o1
bool bool_or::o1#0
bool bool_or::o2
bool bool_or::o2#0
bool bool_or::o3
bool bool_or::o3#0
__constant char * const bool_or::screen = (char *)$428
void main()

Adding number conversion cast (unumber) $a in bool_and::o1#0 = bool_and::i#2 < $a
Adding number conversion cast (unumber) 1 in bool_and::$1 = bool_and::i#2 & 1
Adding number conversion cast (unumber) bool_and::$1 in bool_and::$1 = bool_and::i#2 & (unumber)1
Adding number conversion cast (unumber) 0 in bool_and::o2#0 = bool_and::$1 == 0
Adding number conversion cast (unumber) $a in bool_or::o1#0 = bool_or::i#2 < $a
Adding number conversion cast (unumber) 1 in bool_or::$1 = bool_or::i#2 & 1
Adding number conversion cast (unumber) bool_or::$1 in bool_or::$1 = bool_or::i#2 & (unumber)1
Adding number conversion cast (unumber) 0 in bool_or::o2#0 = bool_or::$1 == 0
Adding number conversion cast (unumber) $a in bool_not::o1#0 = bool_not::i#2 < $a
Adding number conversion cast (unumber) 1 in bool_not::$1 = bool_not::i#2 & 1
Adding number conversion cast (unumber) bool_not::$1 in bool_not::$1 = bool_not::i#2 & (unumber)1
Adding number conversion cast (unumber) 0 in bool_not::o2#0 = bool_not::$1 == 0
Adding number conversion cast (unumber) $a in bool_complex::o1#0 = bool_complex::i#2 < $a
Adding number conversion cast (unumber) 1 in bool_complex::$1 = bool_complex::i#2 & 1
Adding number conversion cast (unumber) bool_complex::$1 in bool_complex::$1 = bool_complex::i#2 & (unumber)1
Adding number conversion cast (unumber) 0 in bool_complex::o2#0 = bool_complex::$1 == 0
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (char *) 1024
Simplifying constant pointer cast (char *) 1064
Simplifying constant pointer cast (char *) 1104
Simplifying constant pointer cast (char *) 1144
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $a
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) $a
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $a
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $a
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $a
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to char in bool_and::$1 = bool_and::i#2 & 1
Inferred type updated to char in bool_or::$1 = bool_or::i#2 & 1
Inferred type updated to char in bool_not::$1 = bool_not::i#2 & 1
Inferred type updated to char in bool_complex::$1 = bool_complex::i#2 & 1
Alias bool_and::i#2 = bool_and::i#3 bool_and::i#4 
Alias bool_or::i#2 = bool_or::i#3 bool_or::i#4 
Alias bool_not::i#2 = bool_not::i#3 bool_not::i#4 
Alias bool_complex::i#2 = bool_complex::i#3 bool_complex::i#4 
Successful SSA optimization Pass2AliasElimination
Alias bool_and::i#2 = bool_and::i#5 
Alias bool_or::i#2 = bool_or::i#5 
Alias bool_not::i#2 = bool_not::i#5 
Alias bool_complex::i#2 = bool_complex::i#5 
Successful SSA optimization Pass2AliasElimination
Simple Condition bool_and::$4 [16] if(bool_and::i#1!=rangelast(0,$14)) goto bool_and::@1
Simple Condition bool_or::$4 [29] if(bool_or::i#1!=rangelast(0,$14)) goto bool_or::@1
Simple Condition bool_not::$5 [43] if(bool_not::i#1!=rangelast(0,$14)) goto bool_not::@1
Simple Condition bool_complex::$7 [59] if(bool_complex::i#1!=rangelast(0,$14)) goto bool_complex::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [10] bool_and::o3#0 = bool_and::o1#0 && bool_and::o2#0
Rewriting || if()-condition to two if()s [23] bool_or::o3#0 = bool_or::o1#0 || bool_or::o2#0
Rewriting ! if()-condition to reversed if() [37] bool_not::o3#0 = ! bool_not::$3
Rewriting || if()-condition to two if()s [36] bool_not::$3 = bool_not::o1#0 || bool_not::o2#0
Rewriting || if()-condition to two if()s [53] bool_complex::o5#0 = bool_complex::o3#0 || bool_complex::o4#0
Rewriting && if()-condition to two if()s [50] bool_complex::o3#0 = bool_complex::o1#0 && bool_complex::o2#0
Rewriting ! if()-condition to reversed if() [52] bool_complex::o4#0 = ! bool_complex::$4
Rewriting || if()-condition to two if()s [51] bool_complex::$4 = bool_complex::o1#0 || bool_complex::o2#0
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant bool_and::i#0 = 0
Constant bool_or::i#0 = 0
Constant bool_not::i#0 = 0
Constant bool_complex::i#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [14] bool_and::i#1 = ++ bool_and::i#2 to ++
Resolved ranged comparison value [16] if(bool_and::i#1!=rangelast(0,$14)) goto bool_and::@1 to $15
Resolved ranged next value [27] bool_or::i#1 = ++ bool_or::i#2 to ++
Resolved ranged comparison value [29] if(bool_or::i#1!=rangelast(0,$14)) goto bool_or::@1 to $15
Resolved ranged next value [41] bool_not::i#1 = ++ bool_not::i#2 to ++
Resolved ranged comparison value [43] if(bool_not::i#1!=rangelast(0,$14)) goto bool_not::@1 to $15
Resolved ranged next value [57] bool_complex::i#1 = ++ bool_complex::i#2 to ++
Resolved ranged comparison value [59] if(bool_complex::i#1!=rangelast(0,$14)) goto bool_complex::@1 to $15
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) $15 in [13] if(bool_and::i#1!=$15) goto bool_and::@1
Adding number conversion cast (unumber) $15 in [23] if(bool_or::i#1!=$15) goto bool_or::@1
Adding number conversion cast (unumber) $15 in [33] if(bool_not::i#1!=$15) goto bool_not::@1
Adding number conversion cast (unumber) $15 in [43] if(bool_complex::i#1!=$15) goto bool_complex::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $15
Simplifying constant integer cast $15
Simplifying constant integer cast $15
Simplifying constant integer cast $15
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) $15
Finalized unsigned number type (char) $15
Finalized unsigned number type (char) $15
Finalized unsigned number type (char) $15
Successful SSA optimization PassNFinalizeNumberTypeConversions
Simple Condition bool_and::o1#0 [9] if(bool_and::i#2<$a) goto bool_and::@5
Simple Condition bool_or::o1#0 [19] if(bool_or::i#2<$a) goto bool_or::@2
Simple Condition bool_not::o1#0 [29] if(bool_not::i#2<$a) goto bool_not::@4
Simple Condition bool_and::o2#0 [45] if(bool_and::$1==0) goto bool_and::@2
Simple Condition bool_or::o2#0 [46] if(bool_or::$1==0) goto bool_or::@2
Simple Condition bool_not::o2#0 [47] if(bool_not::$1==0) goto bool_not::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [9] if(bool_and::i#2>=$a) goto bool_and::@4
Inlining constant with var siblings bool_and::i#0
Inlining constant with var siblings bool_or::i#0
Inlining constant with var siblings bool_not::i#0
Inlining constant with var siblings bool_complex::i#0
Constant inlined bool_complex::i#0 = 0
Constant inlined bool_or::i#0 = 0
Constant inlined bool_not::i#0 = 0
Constant inlined bool_and::i#0 = 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting bool_and::@6(between bool_and::@3 and bool_and::@1)
Added new block during phi lifting bool_or::@6(between bool_or::@3 and bool_or::@1)
Added new block during phi lifting bool_not::@6(between bool_not::@3 and bool_not::@1)
Added new block during phi lifting bool_complex::@8(between bool_complex::@3 and bool_complex::@1)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of bool_and
Adding NOP phi() at start of bool_or
Adding NOP phi() at start of bool_not
Adding NOP phi() at start of bool_complex
CALL GRAPH
Calls in [main] to bool_and:1 bool_or:3 bool_not:5 bool_complex:7 

Created 4 initial phi equivalence classes
Coalesced [19] bool_and::i#6 = bool_and::i#1
Coalesced [30] bool_or::i#6 = bool_or::i#1
Coalesced [41] bool_not::i#6 = bool_not::i#1
Coalesced [56] bool_complex::i#6 = bool_complex::i#1
Coalesced down to 4 phi equivalence classes
Culled Empty Block label main::@4
Culled Empty Block label bool_and::@6
Culled Empty Block label bool_or::@6
Culled Empty Block label bool_not::@6
Culled Empty Block label bool_complex::@8
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of bool_and
Adding NOP phi() at start of bool_or
Adding NOP phi() at start of bool_not
Adding NOP phi() at start of bool_complex

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call bool_and
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call bool_or
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] phi()
  [5] call bool_not
  to:main::@3
main::@3: scope:[main]  from main::@2
  [6] phi()
  [7] call bool_complex
  to:main::@return
main::@return: scope:[main]  from main::@3
  [8] return 
  to:@return

void bool_and()
bool_and: scope:[bool_and]  from main
  [9] phi()
  to:bool_and::@1
bool_and::@1: scope:[bool_and]  from bool_and bool_and::@3
  [10] bool_and::i#2 = phi( bool_and/0, bool_and::@3/bool_and::i#1 )
  [11] bool_and::$1 = bool_and::i#2 & 1
  [12] if(bool_and::i#2>=$a) goto bool_and::@4
  to:bool_and::@5
bool_and::@5: scope:[bool_and]  from bool_and::@1
  [13] if(bool_and::$1==0) goto bool_and::@2
  to:bool_and::@4
bool_and::@4: scope:[bool_and]  from bool_and::@1 bool_and::@5
  [14] bool_and::screen[bool_and::i#2] = ' '
  to:bool_and::@3
bool_and::@3: scope:[bool_and]  from bool_and::@2 bool_and::@4
  [15] bool_and::i#1 = ++ bool_and::i#2
  [16] if(bool_and::i#1!=$15) goto bool_and::@1
  to:bool_and::@return
bool_and::@return: scope:[bool_and]  from bool_and::@3
  [17] return 
  to:@return
bool_and::@2: scope:[bool_and]  from bool_and::@5
  [18] bool_and::screen[bool_and::i#2] = '*'
  to:bool_and::@3

void bool_or()
bool_or: scope:[bool_or]  from main::@1
  [19] phi()
  to:bool_or::@1
bool_or::@1: scope:[bool_or]  from bool_or bool_or::@3
  [20] bool_or::i#2 = phi( bool_or/0, bool_or::@3/bool_or::i#1 )
  [21] bool_or::$1 = bool_or::i#2 & 1
  [22] if(bool_or::i#2<$a) goto bool_or::@2
  to:bool_or::@5
bool_or::@5: scope:[bool_or]  from bool_or::@1
  [23] if(bool_or::$1==0) goto bool_or::@2
  to:bool_or::@4
bool_or::@4: scope:[bool_or]  from bool_or::@5
  [24] bool_or::screen[bool_or::i#2] = ' '
  to:bool_or::@3
bool_or::@3: scope:[bool_or]  from bool_or::@2 bool_or::@4
  [25] bool_or::i#1 = ++ bool_or::i#2
  [26] if(bool_or::i#1!=$15) goto bool_or::@1
  to:bool_or::@return
bool_or::@return: scope:[bool_or]  from bool_or::@3
  [27] return 
  to:@return
bool_or::@2: scope:[bool_or]  from bool_or::@1 bool_or::@5
  [28] bool_or::screen[bool_or::i#2] = '*'
  to:bool_or::@3

void bool_not()
bool_not: scope:[bool_not]  from main::@2
  [29] phi()
  to:bool_not::@1
bool_not::@1: scope:[bool_not]  from bool_not bool_not::@3
  [30] bool_not::i#2 = phi( bool_not/0, bool_not::@3/bool_not::i#1 )
  [31] bool_not::$1 = bool_not::i#2 & 1
  [32] if(bool_not::i#2<$a) goto bool_not::@4
  to:bool_not::@5
bool_not::@5: scope:[bool_not]  from bool_not::@1
  [33] if(bool_not::$1==0) goto bool_not::@4
  to:bool_not::@2
bool_not::@2: scope:[bool_not]  from bool_not::@5
  [34] bool_not::screen[bool_not::i#2] = '*'
  to:bool_not::@3
bool_not::@3: scope:[bool_not]  from bool_not::@2 bool_not::@4
  [35] bool_not::i#1 = ++ bool_not::i#2
  [36] if(bool_not::i#1!=$15) goto bool_not::@1
  to:bool_not::@return
bool_not::@return: scope:[bool_not]  from bool_not::@3
  [37] return 
  to:@return
bool_not::@4: scope:[bool_not]  from bool_not::@1 bool_not::@5
  [38] bool_not::screen[bool_not::i#2] = ' '
  to:bool_not::@3

void bool_complex()
bool_complex: scope:[bool_complex]  from main::@3
  [39] phi()
  to:bool_complex::@1
bool_complex::@1: scope:[bool_complex]  from bool_complex bool_complex::@3
  [40] bool_complex::i#2 = phi( bool_complex/0, bool_complex::@3/bool_complex::i#1 )
  [41] bool_complex::o1#0 = bool_complex::i#2 < $a
  [42] bool_complex::$1 = bool_complex::i#2 & 1
  [43] bool_complex::o2#0 = bool_complex::$1 == 0
  [44] if(bool_complex::o1#0) goto bool_complex::@6
  to:bool_complex::@5
bool_complex::@6: scope:[bool_complex]  from bool_complex::@1
  [45] if(bool_complex::o2#0) goto bool_complex::@2
  to:bool_complex::@5
bool_complex::@5: scope:[bool_complex]  from bool_complex::@1 bool_complex::@6
  [46] if(bool_complex::o1#0) goto bool_complex::@4
  to:bool_complex::@7
bool_complex::@7: scope:[bool_complex]  from bool_complex::@5
  [47] if(bool_complex::o2#0) goto bool_complex::@4
  to:bool_complex::@2
bool_complex::@2: scope:[bool_complex]  from bool_complex::@6 bool_complex::@7
  [48] bool_complex::screen[bool_complex::i#2] = '*'
  to:bool_complex::@3
bool_complex::@3: scope:[bool_complex]  from bool_complex::@2 bool_complex::@4
  [49] bool_complex::i#1 = ++ bool_complex::i#2
  [50] if(bool_complex::i#1!=$15) goto bool_complex::@1
  to:bool_complex::@return
bool_complex::@return: scope:[bool_complex]  from bool_complex::@3
  [51] return 
  to:@return
bool_complex::@4: scope:[bool_complex]  from bool_complex::@5 bool_complex::@7
  [52] bool_complex::screen[bool_complex::i#2] = ' '
  to:bool_complex::@3


VARIABLE REGISTER WEIGHTS
void bool_and()
char bool_and::$1 // 101.0
char bool_and::i
char bool_and::i#1 // 151.5
char bool_and::i#2 // 100.99999999999999
bool bool_and::o1
bool bool_and::o2
bool bool_and::o3
void bool_complex()
char bool_complex::$1 // 202.0
char bool_complex::i
char bool_complex::i#1 // 151.5
char bool_complex::i#2 // 60.6
bool bool_complex::o1
bool bool_complex::o1#0 // 60.599999999999994
bool bool_complex::o2
bool bool_complex::o2#0 // 75.75
bool bool_complex::o3
bool bool_complex::o4
bool bool_complex::o5
void bool_not()
char bool_not::$1 // 101.0
char bool_not::i
char bool_not::i#1 // 151.5
char bool_not::i#2 // 100.99999999999999
bool bool_not::o1
bool bool_not::o2
bool bool_not::o3
void bool_or()
char bool_or::$1 // 101.0
char bool_or::i
char bool_or::i#1 // 151.5
char bool_or::i#2 // 100.99999999999999
bool bool_or::o1
bool bool_or::o2
bool bool_or::o3
void main()

Initial phi equivalence classes
[ bool_and::i#2 bool_and::i#1 ]
[ bool_or::i#2 bool_or::i#1 ]
[ bool_not::i#2 bool_not::i#1 ]
[ bool_complex::i#2 bool_complex::i#1 ]
Added variable bool_and::$1 to live range equivalence class [ bool_and::$1 ]
Added variable bool_or::$1 to live range equivalence class [ bool_or::$1 ]
Added variable bool_not::$1 to live range equivalence class [ bool_not::$1 ]
Added variable bool_complex::o1#0 to live range equivalence class [ bool_complex::o1#0 ]
Added variable bool_complex::$1 to live range equivalence class [ bool_complex::$1 ]
Added variable bool_complex::o2#0 to live range equivalence class [ bool_complex::o2#0 ]
Complete equivalence classes
[ bool_and::i#2 bool_and::i#1 ]
[ bool_or::i#2 bool_or::i#1 ]
[ bool_not::i#2 bool_not::i#1 ]
[ bool_complex::i#2 bool_complex::i#1 ]
[ bool_and::$1 ]
[ bool_or::$1 ]
[ bool_not::$1 ]
[ bool_complex::o1#0 ]
[ bool_complex::$1 ]
[ bool_complex::o2#0 ]
Allocated zp[1]:2 [ bool_and::i#2 bool_and::i#1 ]
Allocated zp[1]:3 [ bool_or::i#2 bool_or::i#1 ]
Allocated zp[1]:4 [ bool_not::i#2 bool_not::i#1 ]
Allocated zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ]
Allocated zp[1]:6 [ bool_complex::$1 ]
Allocated zp[1]:7 [ bool_and::$1 ]
Allocated zp[1]:8 [ bool_or::$1 ]
Allocated zp[1]:9 [ bool_not::$1 ]
Allocated zp[1]:10 [ bool_complex::o2#0 ]
Allocated zp[1]:11 [ bool_complex::o1#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [14] bool_and::screen[bool_and::i#2] = ' ' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ bool_and::i#2 bool_and::i#1 ]
Statement [18] bool_and::screen[bool_and::i#2] = '*' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Statement [24] bool_or::screen[bool_or::i#2] = ' ' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:3 [ bool_or::i#2 bool_or::i#1 ]
Statement [28] bool_or::screen[bool_or::i#2] = '*' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Statement [34] bool_not::screen[bool_not::i#2] = '*' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ bool_not::i#2 bool_not::i#1 ]
Statement [38] bool_not::screen[bool_not::i#2] = ' ' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Statement [41] bool_complex::o1#0 = bool_complex::i#2 < $a [ bool_complex::i#2 bool_complex::o1#0 ] ( bool_complex:7 [ bool_complex::i#2 bool_complex::o1#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ]
Statement [42] bool_complex::$1 = bool_complex::i#2 & 1 [ bool_complex::i#2 bool_complex::o1#0 bool_complex::$1 ] ( bool_complex:7 [ bool_complex::i#2 bool_complex::o1#0 bool_complex::$1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:11 [ bool_complex::o1#0 ]
Statement [43] bool_complex::o2#0 = bool_complex::$1 == 0 [ bool_complex::i#2 bool_complex::o1#0 bool_complex::o2#0 ] ( bool_complex:7 [ bool_complex::i#2 bool_complex::o1#0 bool_complex::o2#0 ] { }  ) always clobbers reg byte a 
Statement [48] bool_complex::screen[bool_complex::i#2] = '*' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Statement [52] bool_complex::screen[bool_complex::i#2] = ' ' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Statement [11] bool_and::$1 = bool_and::i#2 & 1 [ bool_and::i#2 bool_and::$1 ] ( bool_and:1 [ bool_and::i#2 bool_and::$1 ] { }  ) always clobbers reg byte a 
Statement [14] bool_and::screen[bool_and::i#2] = ' ' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Statement [18] bool_and::screen[bool_and::i#2] = '*' [ bool_and::i#2 ] ( bool_and:1 [ bool_and::i#2 ] { }  ) always clobbers reg byte a 
Statement [21] bool_or::$1 = bool_or::i#2 & 1 [ bool_or::i#2 bool_or::$1 ] ( bool_or:3 [ bool_or::i#2 bool_or::$1 ] { }  ) always clobbers reg byte a 
Statement [24] bool_or::screen[bool_or::i#2] = ' ' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Statement [28] bool_or::screen[bool_or::i#2] = '*' [ bool_or::i#2 ] ( bool_or:3 [ bool_or::i#2 ] { }  ) always clobbers reg byte a 
Statement [31] bool_not::$1 = bool_not::i#2 & 1 [ bool_not::i#2 bool_not::$1 ] ( bool_not:5 [ bool_not::i#2 bool_not::$1 ] { }  ) always clobbers reg byte a 
Statement [34] bool_not::screen[bool_not::i#2] = '*' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Statement [38] bool_not::screen[bool_not::i#2] = ' ' [ bool_not::i#2 ] ( bool_not:5 [ bool_not::i#2 ] { }  ) always clobbers reg byte a 
Statement [41] bool_complex::o1#0 = bool_complex::i#2 < $a [ bool_complex::i#2 bool_complex::o1#0 ] ( bool_complex:7 [ bool_complex::i#2 bool_complex::o1#0 ] { }  ) always clobbers reg byte a 
Statement [42] bool_complex::$1 = bool_complex::i#2 & 1 [ bool_complex::i#2 bool_complex::o1#0 bool_complex::$1 ] ( bool_complex:7 [ bool_complex::i#2 bool_complex::o1#0 bool_complex::$1 ] { }  ) always clobbers reg byte a 
Statement [43] bool_complex::o2#0 = bool_complex::$1 == 0 [ bool_complex::i#2 bool_complex::o1#0 bool_complex::o2#0 ] ( bool_complex:7 [ bool_complex::i#2 bool_complex::o1#0 bool_complex::o2#0 ] { }  ) always clobbers reg byte a 
Statement [48] bool_complex::screen[bool_complex::i#2] = '*' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Statement [52] bool_complex::screen[bool_complex::i#2] = ' ' [ bool_complex::i#2 ] ( bool_complex:7 [ bool_complex::i#2 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ bool_and::i#2 bool_and::i#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ bool_or::i#2 bool_or::i#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ bool_not::i#2 bool_not::i#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ bool_and::$1 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ bool_or::$1 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ bool_not::$1 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ bool_complex::o1#0 ] : zp[1]:11 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ bool_complex::$1 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ bool_complex::o2#0 ] : zp[1]:10 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [bool_complex] 212.1: zp[1]:5 [ bool_complex::i#2 bool_complex::i#1 ] 202: zp[1]:6 [ bool_complex::$1 ] 75.75: zp[1]:10 [ bool_complex::o2#0 ] 60.6: zp[1]:11 [ bool_complex::o1#0 ] 
Uplift Scope [bool_and] 252.5: zp[1]:2 [ bool_and::i#2 bool_and::i#1 ] 101: zp[1]:7 [ bool_and::$1 ] 
Uplift Scope [bool_or] 252.5: zp[1]:3 [ bool_or::i#2 bool_or::i#1 ] 101: zp[1]:8 [ bool_or::$1 ] 
Uplift Scope [bool_not] 252.5: zp[1]:4 [ bool_not::i#2 bool_not::i#1 ] 101: zp[1]:9 [ bool_not::$1 ] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [bool_complex] best 3351 combination reg byte y [ bool_complex::i#2 bool_complex::i#1 ] reg byte a [ bool_complex::$1 ] reg byte a [ bool_complex::o2#0 ] reg byte x [ bool_complex::o1#0 ] 
Limited combination testing to 100 combinations of 144 possible.
Uplifting [bool_and] best 3121 combination reg byte x [ bool_and::i#2 bool_and::i#1 ] reg byte a [ bool_and::$1 ] 
Uplifting [bool_or] best 2891 combination reg byte x [ bool_or::i#2 bool_or::i#1 ] reg byte a [ bool_or::$1 ] 
Uplifting [bool_not] best 2661 combination reg byte x [ bool_not::i#2 bool_not::i#1 ] reg byte a [ bool_not::$1 ] 
Uplifting [main] best 2661 combination 
Uplifting [] best 2661 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// A test of boolean conditions using && || and !
  // Upstart
  // Commodore 64 PRG executable file
.file [name="bool-vars.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    // [1] call bool_and
    // [9] phi from main to bool_and [phi:main->bool_and] -- call_phi_near 
  bool_and_from_main:
    jsr bool_and
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call bool_or
    // [19] phi from main::@1 to bool_or [phi:main::@1->bool_or] -- call_phi_near 
  bool_or_from___b1:
    jsr bool_or
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [5] call bool_not
    // [29] phi from main::@2 to bool_not [phi:main::@2->bool_not] -- call_phi_near 
  bool_not_from___b2:
    jsr bool_not
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    jmp __b3
    // main::@3
  __b3:
    // [7] call bool_complex
    // [39] phi from main::@3 to bool_complex [phi:main::@3->bool_complex] -- call_phi_near 
  bool_complex_from___b3:
    jsr bool_complex
    jmp __breturn
    // main::@return
  __breturn:
    // [8] return 
    rts
}
  // bool_and
bool_and: {
    .label screen = $400
    // [10] phi from bool_and to bool_and::@1 [phi:bool_and->bool_and::@1]
  __b1_from_bool_and:
    // [10] phi bool_and::i#2 = 0 [phi:bool_and->bool_and::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [10] phi from bool_and::@3 to bool_and::@1 [phi:bool_and::@3->bool_and::@1]
  __b1_from___b3:
    // [10] phi bool_and::i#2 = bool_and::i#1 [phi:bool_and::@3->bool_and::@1#0] -- register_copy 
    jmp __b1
    // bool_and::@1
  __b1:
    // [11] bool_and::$1 = bool_and::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [12] if(bool_and::i#2>=$a) goto bool_and::@4 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b4
    jmp __b5
    // bool_and::@5
  __b5:
    // [13] if(bool_and::$1==0) goto bool_and::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    jmp __b4
    // bool_and::@4
  __b4:
    // [14] bool_and::screen[bool_and::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
    // bool_and::@3
  __b3:
    // [15] bool_and::i#1 = ++ bool_and::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [16] if(bool_and::i#1!=$15) goto bool_and::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_and::@return
  __breturn:
    // [17] return 
    rts
    // bool_and::@2
  __b2:
    // [18] bool_and::screen[bool_and::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_or
bool_or: {
    .label screen = $428
    // [20] phi from bool_or to bool_or::@1 [phi:bool_or->bool_or::@1]
  __b1_from_bool_or:
    // [20] phi bool_or::i#2 = 0 [phi:bool_or->bool_or::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [20] phi from bool_or::@3 to bool_or::@1 [phi:bool_or::@3->bool_or::@1]
  __b1_from___b3:
    // [20] phi bool_or::i#2 = bool_or::i#1 [phi:bool_or::@3->bool_or::@1#0] -- register_copy 
    jmp __b1
    // bool_or::@1
  __b1:
    // [21] bool_or::$1 = bool_or::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [22] if(bool_or::i#2<$a) goto bool_or::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b2
    jmp __b5
    // bool_or::@5
  __b5:
    // [23] if(bool_or::$1==0) goto bool_or::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    jmp __b4
    // bool_or::@4
  __b4:
    // [24] bool_or::screen[bool_or::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
    // bool_or::@3
  __b3:
    // [25] bool_or::i#1 = ++ bool_or::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [26] if(bool_or::i#1!=$15) goto bool_or::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_or::@return
  __breturn:
    // [27] return 
    rts
    // bool_or::@2
  __b2:
    // [28] bool_or::screen[bool_or::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_not
bool_not: {
    .label screen = $450
    // [30] phi from bool_not to bool_not::@1 [phi:bool_not->bool_not::@1]
  __b1_from_bool_not:
    // [30] phi bool_not::i#2 = 0 [phi:bool_not->bool_not::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [30] phi from bool_not::@3 to bool_not::@1 [phi:bool_not::@3->bool_not::@1]
  __b1_from___b3:
    // [30] phi bool_not::i#2 = bool_not::i#1 [phi:bool_not::@3->bool_not::@1#0] -- register_copy 
    jmp __b1
    // bool_not::@1
  __b1:
    // [31] bool_not::$1 = bool_not::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // [32] if(bool_not::i#2<$a) goto bool_not::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    jmp __b5
    // bool_not::@5
  __b5:
    // [33] if(bool_not::$1==0) goto bool_not::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    jmp __b2
    // bool_not::@2
  __b2:
    // [34] bool_not::screen[bool_not::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
    // bool_not::@3
  __b3:
    // [35] bool_not::i#1 = ++ bool_not::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] if(bool_not::i#1!=$15) goto bool_not::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_not::@return
  __breturn:
    // [37] return 
    rts
    // bool_not::@4
  __b4:
    // [38] bool_not::screen[bool_not::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // bool_complex
bool_complex: {
    .label screen = $478
    // [40] phi from bool_complex to bool_complex::@1 [phi:bool_complex->bool_complex::@1]
  __b1_from_bool_complex:
    // [40] phi bool_complex::i#2 = 0 [phi:bool_complex->bool_complex::@1#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b1
    // [40] phi from bool_complex::@3 to bool_complex::@1 [phi:bool_complex::@3->bool_complex::@1]
  __b1_from___b3:
    // [40] phi bool_complex::i#2 = bool_complex::i#1 [phi:bool_complex::@3->bool_complex::@1#0] -- register_copy 
    jmp __b1
    // bool_complex::@1
  __b1:
    // [41] bool_complex::o1#0 = bool_complex::i#2 < $a -- vboxx=vbuyy_lt_vbuc1 
    cpy #$a
    lda #0
    rol
    eor #1
    tax
    // [42] bool_complex::$1 = bool_complex::i#2 & 1 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #1
    // [43] bool_complex::o2#0 = bool_complex::$1 == 0 -- vboaa=vbuaa_eq_vbuc1 
    eor #0
    beq !+
    lda #1
  !:
    eor #1
    // [44] if(bool_complex::o1#0) goto bool_complex::@6 -- vboxx_then_la1 
    cpx #0
    bne __b6
    jmp __b5
    // bool_complex::@6
  __b6:
    // [45] if(bool_complex::o2#0) goto bool_complex::@2 -- vboaa_then_la1 
    cmp #0
    bne __b2
    jmp __b5
    // bool_complex::@5
  __b5:
    // [46] if(bool_complex::o1#0) goto bool_complex::@4 -- vboxx_then_la1 
    cpx #0
    bne __b4
    jmp __b7
    // bool_complex::@7
  __b7:
    // [47] if(bool_complex::o2#0) goto bool_complex::@4 -- vboaa_then_la1 
    cmp #0
    bne __b4
    jmp __b2
    // bool_complex::@2
  __b2:
    // [48] bool_complex::screen[bool_complex::i#2] = '*' -- pbuc1_derefidx_vbuyy=vbuc2 
    lda #'*'
    sta screen,y
    jmp __b3
    // bool_complex::@3
  __b3:
    // [49] bool_complex::i#1 = ++ bool_complex::i#2 -- vbuyy=_inc_vbuyy 
    iny
    // [50] if(bool_complex::i#1!=$15) goto bool_complex::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$15
    bne __b1_from___b3
    jmp __breturn
    // bool_complex::@return
  __breturn:
    // [51] return 
    rts
    // bool_complex::@4
  __b4:
    // [52] bool_complex::screen[bool_complex::i#2] = ' ' -- pbuc1_derefidx_vbuyy=vbuc2 
    lda #' '
    sta screen,y
    jmp __b3
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b3 with __b1
Removing instruction __b1_from_main:
Removing instruction bool_or_from___b1:
Removing instruction __b2_from___b1:
Removing instruction bool_not_from___b2:
Removing instruction __b3_from___b2:
Removing instruction bool_complex_from___b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bool_and_from_main:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from_bool_and:
Removing instruction __b5:
Removing instruction __breturn:
Removing instruction __b1_from_bool_or:
Removing instruction __b5:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __b1_from_bool_not:
Removing instruction __b5:
Removing instruction __b2:
Removing instruction __breturn:
Removing instruction __b1_from_bool_complex:
Removing instruction __b7:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
void bool_and()
char bool_and::$1 // reg byte a 101.0
char bool_and::i
char bool_and::i#1 // reg byte x 151.5
char bool_and::i#2 // reg byte x 100.99999999999999
bool bool_and::o1
bool bool_and::o2
bool bool_and::o3
__constant char * const bool_and::screen = (char *) 1024
void bool_complex()
char bool_complex::$1 // reg byte a 202.0
char bool_complex::i
char bool_complex::i#1 // reg byte y 151.5
char bool_complex::i#2 // reg byte y 60.6
bool bool_complex::o1
bool bool_complex::o1#0 // reg byte x 60.599999999999994
bool bool_complex::o2
bool bool_complex::o2#0 // reg byte a 75.75
bool bool_complex::o3
bool bool_complex::o4
bool bool_complex::o5
__constant char * const bool_complex::screen = (char *) 1144
void bool_not()
char bool_not::$1 // reg byte a 101.0
char bool_not::i
char bool_not::i#1 // reg byte x 151.5
char bool_not::i#2 // reg byte x 100.99999999999999
bool bool_not::o1
bool bool_not::o2
bool bool_not::o3
__constant char * const bool_not::screen = (char *) 1104
void bool_or()
char bool_or::$1 // reg byte a 101.0
char bool_or::i
char bool_or::i#1 // reg byte x 151.5
char bool_or::i#2 // reg byte x 100.99999999999999
bool bool_or::o1
bool bool_or::o2
bool bool_or::o3
__constant char * const bool_or::screen = (char *) 1064
void main()

reg byte x [ bool_and::i#2 bool_and::i#1 ]
reg byte x [ bool_or::i#2 bool_or::i#1 ]
reg byte x [ bool_not::i#2 bool_not::i#1 ]
reg byte y [ bool_complex::i#2 bool_complex::i#1 ]
reg byte a [ bool_and::$1 ]
reg byte a [ bool_or::$1 ]
reg byte a [ bool_not::$1 ]
reg byte x [ bool_complex::o1#0 ]
reg byte a [ bool_complex::$1 ]
reg byte a [ bool_complex::o2#0 ]


FINAL ASSEMBLER
Score: 1899

  // File Comments
// A test of boolean conditions using && || and !
  // Upstart
  // Commodore 64 PRG executable file
.file [name="bool-vars.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    // bool_and()
    // [1] call bool_and
    // [9] phi from main to bool_and [phi:main->bool_and] -- call_phi_near 
    jsr bool_and
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // bool_or()
    // [3] call bool_or
    // [19] phi from main::@1 to bool_or [phi:main::@1->bool_or] -- call_phi_near 
    jsr bool_or
    // [4] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // bool_not()
    // [5] call bool_not
    // [29] phi from main::@2 to bool_not [phi:main::@2->bool_not] -- call_phi_near 
    jsr bool_not
    // [6] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // main::@3
    // bool_complex()
    // [7] call bool_complex
    // [39] phi from main::@3 to bool_complex [phi:main::@3->bool_complex] -- call_phi_near 
    jsr bool_complex
    // main::@return
    // }
    // [8] return 
    rts
}
  // bool_and
bool_and: {
    .label screen = $400
    // [10] phi from bool_and to bool_and::@1 [phi:bool_and->bool_and::@1]
    // [10] phi bool_and::i#2 = 0 [phi:bool_and->bool_and::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [10] phi from bool_and::@3 to bool_and::@1 [phi:bool_and::@3->bool_and::@1]
    // [10] phi bool_and::i#2 = bool_and::i#1 [phi:bool_and::@3->bool_and::@1#0] -- register_copy 
    // bool_and::@1
  __b1:
    // i&1
    // [11] bool_and::$1 = bool_and::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if(o3)
    // [12] if(bool_and::i#2>=$a) goto bool_and::@4 -- vbuxx_ge_vbuc1_then_la1 
    cpx #$a
    bcs __b4
    // bool_and::@5
    // [13] if(bool_and::$1==0) goto bool_and::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // bool_and::@4
  __b4:
    // screen[i] = ' '
    // [14] bool_and::screen[bool_and::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    // bool_and::@3
  __b3:
    // for( byte i : 0..20)
    // [15] bool_and::i#1 = ++ bool_and::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [16] if(bool_and::i#1!=$15) goto bool_and::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_and::@return
    // }
    // [17] return 
    rts
    // bool_and::@2
  __b2:
    // screen[i] = '*'
    // [18] bool_and::screen[bool_and::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_or
bool_or: {
    .label screen = $428
    // [20] phi from bool_or to bool_or::@1 [phi:bool_or->bool_or::@1]
    // [20] phi bool_or::i#2 = 0 [phi:bool_or->bool_or::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [20] phi from bool_or::@3 to bool_or::@1 [phi:bool_or::@3->bool_or::@1]
    // [20] phi bool_or::i#2 = bool_or::i#1 [phi:bool_or::@3->bool_or::@1#0] -- register_copy 
    // bool_or::@1
  __b1:
    // i&1
    // [21] bool_or::$1 = bool_or::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if(o3)
    // [22] if(bool_or::i#2<$a) goto bool_or::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b2
    // bool_or::@5
    // [23] if(bool_or::$1==0) goto bool_or::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // bool_or::@4
    // screen[i] = ' '
    // [24] bool_or::screen[bool_or::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    // bool_or::@3
  __b3:
    // for( byte i : 0..20)
    // [25] bool_or::i#1 = ++ bool_or::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [26] if(bool_or::i#1!=$15) goto bool_or::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_or::@return
    // }
    // [27] return 
    rts
    // bool_or::@2
  __b2:
    // screen[i] = '*'
    // [28] bool_or::screen[bool_or::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    jmp __b3
}
  // bool_not
bool_not: {
    .label screen = $450
    // [30] phi from bool_not to bool_not::@1 [phi:bool_not->bool_not::@1]
    // [30] phi bool_not::i#2 = 0 [phi:bool_not->bool_not::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [30] phi from bool_not::@3 to bool_not::@1 [phi:bool_not::@3->bool_not::@1]
    // [30] phi bool_not::i#2 = bool_not::i#1 [phi:bool_not::@3->bool_not::@1#0] -- register_copy 
    // bool_not::@1
  __b1:
    // i&1
    // [31] bool_not::$1 = bool_not::i#2 & 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
    // if(o3)
    // [32] if(bool_not::i#2<$a) goto bool_not::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$a
    bcc __b4
    // bool_not::@5
    // [33] if(bool_not::$1==0) goto bool_not::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4
    // bool_not::@2
    // screen[i] = '*'
    // [34] bool_not::screen[bool_not::i#2] = '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta screen,x
    // bool_not::@3
  __b3:
    // for( byte i : 0..20)
    // [35] bool_not::i#1 = ++ bool_not::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] if(bool_not::i#1!=$15) goto bool_not::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$15
    bne __b1
    // bool_not::@return
    // }
    // [37] return 
    rts
    // bool_not::@4
  __b4:
    // screen[i] = ' '
    // [38] bool_not::screen[bool_not::i#2] = ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta screen,x
    jmp __b3
}
  // bool_complex
bool_complex: {
    .label screen = $478
    // [40] phi from bool_complex to bool_complex::@1 [phi:bool_complex->bool_complex::@1]
    // [40] phi bool_complex::i#2 = 0 [phi:bool_complex->bool_complex::@1#0] -- vbuyy=vbuc1 
    ldy #0
    // [40] phi from bool_complex::@3 to bool_complex::@1 [phi:bool_complex::@3->bool_complex::@1]
    // [40] phi bool_complex::i#2 = bool_complex::i#1 [phi:bool_complex::@3->bool_complex::@1#0] -- register_copy 
    // bool_complex::@1
  __b1:
    // bool o1 = (i<10)
    // [41] bool_complex::o1#0 = bool_complex::i#2 < $a -- vboxx=vbuyy_lt_vbuc1 
    cpy #$a
    lda #0
    rol
    eor #1
    tax
    // i&1
    // [42] bool_complex::$1 = bool_complex::i#2 & 1 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #1
    // bool o2 = (i&1)==0
    // [43] bool_complex::o2#0 = bool_complex::$1 == 0 -- vboaa=vbuaa_eq_vbuc1 
    eor #0
    beq !+
    lda #1
  !:
    eor #1
    // if( o5 )
    // [44] if(bool_complex::o1#0) goto bool_complex::@6 -- vboxx_then_la1 
    cpx #0
    bne __b6
    jmp __b5
    // bool_complex::@6
  __b6:
    // [45] if(bool_complex::o2#0) goto bool_complex::@2 -- vboaa_then_la1 
    cmp #0
    bne __b2
    // bool_complex::@5
  __b5:
    // [46] if(bool_complex::o1#0) goto bool_complex::@4 -- vboxx_then_la1 
    cpx #0
    bne __b4
    // bool_complex::@7
    // [47] if(bool_complex::o2#0) goto bool_complex::@4 -- vboaa_then_la1 
    cmp #0
    bne __b4
    // bool_complex::@2
  __b2:
    // screen[i] = '*'
    // [48] bool_complex::screen[bool_complex::i#2] = '*' -- pbuc1_derefidx_vbuyy=vbuc2 
    lda #'*'
    sta screen,y
    // bool_complex::@3
  __b3:
    // for( byte i : 0..20)
    // [49] bool_complex::i#1 = ++ bool_complex::i#2 -- vbuyy=_inc_vbuyy 
    iny
    // [50] if(bool_complex::i#1!=$15) goto bool_complex::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$15
    bne __b1
    // bool_complex::@return
    // }
    // [51] return 
    rts
    // bool_complex::@4
  __b4:
    // screen[i] = ' '
    // [52] bool_complex::screen[bool_complex::i#2] = ' ' -- pbuc1_derefidx_vbuyy=vbuc2 
    lda #' '
    sta screen,y
    jmp __b3
}
  // File Data

