import "tetris-data"

kickasm(pc PLAYFIELD_CHARSET, resource "playfield-screen.imap") {{
    .fill 8,$00 // Place a filled char at the start of the charset
    .import binary "playfield-screen.imap"
}}

const byte PLAYFIELD_SCREEN_ORIGINAL_WIDTH=32;
kickasm(pc PLAYFIELD_SCREEN_ORIGINAL, resource "playfield-screen.iscr", resource "playfield-extended.col" ) {{
   // Load chars for the screen
  .var screen = LoadBinary("playfield-screen.iscr")
   // Load extended colors for the screen
  .var extended = LoadBinary("playfield-extended.col")
  // screen.get(i)+1 because the charset is loaded into PLAYFIELD_CHARSET+8
  // extended.get(i)-1 because the extended colors are 1-based (1/2/3/4)
  // <<6 to move extended colors to the upper 2 bits
  .fill screen.getSize(), ( (screen.get(i)+1) | (extended.get(i)-1)<<6 )
}}

// Original Color Data
kickasm(pc PLAYFIELD_COLORS_ORIGINAL, resource "playfield-screen.col") {{
  .import binary "playfield-screen.col"
}}

// Pointers to the screen address for rendering each playfield line
// The lines for screen 1 is aligned with $80 and screen 2 with $40 - so XOR'ing with $40 gives screen 2 lines.
align($80) byte*[PLAYFIELD_LINES] screen_lines_1;
align($40) byte*[PLAYFIELD_LINES] screen_lines_2;

// Initialize rendering
void render_init() {
	vicSelectGfxBank(PLAYFIELD_CHARSET);
	// Enable Extended Background Color Mode
	*D011 = VIC_ECM | VIC_DEN | VIC_RSEL | 3;
	*BORDERCOL = BLACK;
	*BGCOL1 = BLACK;
	*BGCOL2 = BLUE;
	*BGCOL3 = CYAN;
	*BGCOL4 = GREY;

    // Setup chars on the screens
	render_screen_original(PLAYFIELD_SCREEN_1);
	render_screen_original(PLAYFIELD_SCREEN_2);

	// Initialize the screen line pointers;
	byte* li_1 = PLAYFIELD_SCREEN_1 + 2*40 + 16;
	byte* li_2 = PLAYFIELD_SCREEN_2 + 2*40 + 16;
	for(byte i:0..PLAYFIELD_LINES-1) {
		screen_lines_1[i<<1] = li_1;
		screen_lines_2[i<<1] = li_2;
		li_1 += 40;
		li_2 += 40;
	}

    // Show showing screen 1 and rendering to screen 2
    render_screen_show = 0;
    render_screen_render = $40;
}

// Update $D018 to show the current screen (used for double buffering)
void render_show() {
    byte d018val = 0;
    if(render_screen_show==0) {
        d018val = toD018(PLAYFIELD_SCREEN_1, PLAYFIELD_CHARSET);
    } else {
        d018val = toD018(PLAYFIELD_SCREEN_2, PLAYFIELD_CHARSET);
    }
	*D018 = d018val;
	render_screen_showing = render_screen_show;
}

// Swap rendering to the other screen (used for double buffering)
void render_screen_swap() {
    render_screen_render ^= $40;
    render_screen_show ^= $40;
}

// Show the current score
void render_score() {
    const byte ZERO_CHAR = 51;
    byte SCREEN_SCORE_ROW = $05;
    byte SCREEN_SCORE_COL = $1d;
    byte* screen_score_pos;
    if(render_screen_render==0) {
        screen_score_pos = PLAYFIELD_SCREEN_1 + 40*SCREEN_SCORE_ROW + SCREEN_SCORE_COL;
    } else {
        screen_score_pos = PLAYFIELD_SCREEN_2 + 40*SCREEN_SCORE_ROW + SCREEN_SCORE_COL;
    }
    byte* score_bytes = (byte*)(&score_bcd);
    for (byte b:0..2) {
        byte score_byte = score_bytes[b];
        *screen_score_pos-- = ZERO_CHAR + (score_byte & $0f);
        *screen_score_pos-- = ZERO_CHAR + (score_byte>>4);
    }
}

// Copy the original screen data to the passed screen
// Also copies colors to $d800
void render_screen_original(byte* screen) {
    byte SPACE = 0;
	byte* oscr = PLAYFIELD_SCREEN_ORIGINAL+32*2;
	byte* ocols = PLAYFIELD_COLORS_ORIGINAL+32*2;
	byte* cols = COLS;
	for(byte y:0..24) {
	    byte x=0;
	    do {
	        *screen++ = SPACE;
	        *cols++ = BLACK;
	    } while(++x!=4);
	    do {
	        *screen++ = *oscr++;
	        *cols++ = *ocols++;
	    } while(++x!=36);
	    do {
	        *screen++ = SPACE;
	        *cols++ = BLACK;
	    } while(++x!=40);
	}
}

// Render the static playfield on the screen
void render_playfield() {
	// Do not render the top 2 lines.
	byte i = PLAYFIELD_COLS*2;
	for(byte l:2..PLAYFIELD_LINES-1) {
		byte* screen_line = screen_lines_1[render_screen_render+l<<1];
		for(byte c:0..PLAYFIELD_COLS-1) {
			*(screen_line++) = playfield[i++];
		}
	}
}

// Render the current moving piece at position (current_xpos, current_ypos)
void render_current() {
	byte i = 0;
	byte ypos2 = current_ypos<<1;
	for(byte l:0..3) {
		if(ypos2>2 && ypos2<2*PLAYFIELD_LINES) {
			byte* screen_line = screen_lines_1[render_screen_render+ypos2];
			byte xpos = current_xpos;
			for(byte c:0..3) {
				byte current_cell = current_piece_gfx[i++];
				if(current_cell!=0) {
					if(xpos<PLAYFIELD_COLS) {
						screen_line[xpos] = current_piece_char;
					}
				}
				xpos++;
			}
		} else {
		    i += 4;
		}
		ypos2 += 2;
	}
}

