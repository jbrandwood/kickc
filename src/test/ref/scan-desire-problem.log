Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call (byte~) init::$3 ← call toD018 (byte*) screen (byte*) charset 

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) SPRITES_XMSB#0 ← ((byte*)) (word/dword/signed dword) $d010
  (byte*) SPRITES_ENABLE#0 ← ((byte*)) (word/dword/signed dword) $d015
  (byte*) SPRITES_EXPAND_Y#0 ← ((byte*)) (word/dword/signed dword) $d017
  (byte*) SPRITES_MC#0 ← ((byte*)) (word/dword/signed dword) $d01c
  (byte*) SPRITES_EXPAND_X#0 ← ((byte*)) (word/dword/signed dword) $d01d
  (byte*) BORDERCOL#0 ← ((byte*)) (word/dword/signed dword) $d020
  (byte*) BGCOL1#0 ← ((byte*)) (word/dword/signed dword) $d021
  (byte*) BGCOL2#0 ← ((byte*)) (word/dword/signed dword) $d022
  (byte*) BGCOL3#0 ← ((byte*)) (word/dword/signed dword) $d023
  (byte*) BGCOL4#0 ← ((byte*)) (word/dword/signed dword) $d024
  (byte*) SPRITES_COLS#0 ← ((byte*)) (word/dword/signed dword) $d027
  (byte*) D018#0 ← ((byte*)) (word/dword/signed dword) $d018
  (byte) BLACK#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (byte) WHITE#0 ← (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) RED#0 ← (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte) GREEN#0 ← (byte/signed byte/word/signed word/dword/signed dword) 5
  (byte) BLUE#0 ← (byte/signed byte/word/signed word/dword/signed dword) 6
  (byte) YELLOW#0 ← (byte/signed byte/word/signed word/dword/signed dword) 7
  to:@17
fill: scope:[fill]  from init::@2 init::@3
  (byte) fill::val#3 ← phi( init::@2/(byte) fill::val#0 init::@3/(byte) fill::val#1 )
  (word) fill::size#2 ← phi( init::@2/(word) fill::size#0 init::@3/(word) fill::size#1 )
  (byte*) fill::start#2 ← phi( init::@2/(byte*) fill::start#0 init::@3/(byte*) fill::start#1 )
  (byte*~) fill::$0 ← (byte*) fill::start#2 + (word) fill::size#2
  (byte*) fill::end#0 ← (byte*~) fill::$0
  (byte*) fill::addr#0 ← (byte*) fill::start#2
  to:fill::@1
fill::@1: scope:[fill]  from fill fill::@1
  (byte*) fill::end#1 ← phi( fill/(byte*) fill::end#0 fill::@1/(byte*) fill::end#1 )
  (byte*) fill::addr#2 ← phi( fill/(byte*) fill::addr#0 fill::@1/(byte*) fill::addr#1 )
  (byte) fill::val#2 ← phi( fill/(byte) fill::val#3 fill::@1/(byte) fill::val#2 )
  *((byte*) fill::addr#2) ← (byte) fill::val#2
  (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2
  (bool~) fill::$1 ← (byte*) fill::addr#1 != (byte*) fill::end#1
  if((bool~) fill::$1) goto fill::@1
  to:fill::@return
fill::@return: scope:[fill]  from fill::@1
  return 
  to:@return
mul8u: scope:[mul8u]  from draw_block
  (byte) mul8u::a#5 ← phi( draw_block/(byte) mul8u::a#1 )
  (byte) mul8u::b#1 ← phi( draw_block/(byte) mul8u::b#0 )
  (word) mul8u::res#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (word) mul8u::mb#0 ← ((word)) (byte) mul8u::b#1
  to:mul8u::@1
mul8u::@1: scope:[mul8u]  from mul8u mul8u::@4
  (word) mul8u::mb#5 ← phi( mul8u/(word) mul8u::mb#0 mul8u::@4/(word) mul8u::mb#1 )
  (word) mul8u::res#4 ← phi( mul8u/(word) mul8u::res#0 mul8u::@4/(word) mul8u::res#6 )
  (byte) mul8u::a#2 ← phi( mul8u/(byte) mul8u::a#5 mul8u::@4/(byte) mul8u::a#0 )
  (bool~) mul8u::$0 ← (byte) mul8u::a#2 != (byte/signed byte/word/signed word/dword/signed dword) 0
  if((bool~) mul8u::$0) goto mul8u::@2
  to:mul8u::@3
mul8u::@2: scope:[mul8u]  from mul8u::@1
  (word) mul8u::res#5 ← phi( mul8u::@1/(word) mul8u::res#4 )
  (word) mul8u::mb#4 ← phi( mul8u::@1/(word) mul8u::mb#5 )
  (byte) mul8u::a#3 ← phi( mul8u::@1/(byte) mul8u::a#2 )
  (byte~) mul8u::$1 ← (byte) mul8u::a#3 & (byte/signed byte/word/signed word/dword/signed dword) 1
  (bool~) mul8u::$2 ← (byte~) mul8u::$1 != (byte/signed byte/word/signed word/dword/signed dword) 0
  (bool~) mul8u::$3 ← ! (bool~) mul8u::$2
  if((bool~) mul8u::$3) goto mul8u::@4
  to:mul8u::@7
mul8u::@3: scope:[mul8u]  from mul8u::@1
  (word) mul8u::res#2 ← phi( mul8u::@1/(word) mul8u::res#4 )
  (word) mul8u::return#0 ← (word) mul8u::res#2
  to:mul8u::@return
mul8u::@4: scope:[mul8u]  from mul8u::@2 mul8u::@7
  (word) mul8u::res#6 ← phi( mul8u::@2/(word) mul8u::res#5 mul8u::@7/(word) mul8u::res#1 )
  (word) mul8u::mb#2 ← phi( mul8u::@2/(word) mul8u::mb#4 mul8u::@7/(word) mul8u::mb#3 )
  (byte) mul8u::a#4 ← phi( mul8u::@2/(byte) mul8u::a#3 mul8u::@7/(byte) mul8u::a#6 )
  (byte~) mul8u::$5 ← (byte) mul8u::a#4 >> (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) mul8u::a#0 ← (byte~) mul8u::$5
  (word~) mul8u::$6 ← (word) mul8u::mb#2 << (byte/signed byte/word/signed word/dword/signed dword) 1
  (word) mul8u::mb#1 ← (word~) mul8u::$6
  to:mul8u::@1
mul8u::@7: scope:[mul8u]  from mul8u::@2
  (byte) mul8u::a#6 ← phi( mul8u::@2/(byte) mul8u::a#3 )
  (word) mul8u::mb#3 ← phi( mul8u::@2/(word) mul8u::mb#4 )
  (word) mul8u::res#3 ← phi( mul8u::@2/(word) mul8u::res#5 )
  (word~) mul8u::$4 ← (word) mul8u::res#3 + (word) mul8u::mb#3
  (word) mul8u::res#1 ← (word~) mul8u::$4
  to:mul8u::@4
mul8u::@return: scope:[mul8u]  from mul8u::@3
  (word) mul8u::return#3 ← phi( mul8u::@3/(word) mul8u::return#0 )
  (word) mul8u::return#1 ← (word) mul8u::return#3
  return 
  to:@return
@17: scope:[]  from @begin
  (byte*) screen#0 ← ((byte*)) (word/signed word/dword/signed dword) $400
  (byte*) charset#0 ← ((byte*)) (word/signed word/dword/signed dword) $2000
  (byte*) tileset#0 ← ((byte*)) (word/signed word/dword/signed dword) $2800
  (byte*) colors#0 ← ((byte*)) (word/dword/signed dword) $d800
  (byte*) level_address#0 ← ((byte*)) (word/signed word/dword/signed dword) $3000
  to:@21
main: scope:[main]  from @21
  call init 
  to:main::@7
main::@7: scope:[main]  from main
  (byte) main::x#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:main::@1
main::@1: scope:[main]  from main::@3 main::@7
  (byte) main::x#4 ← phi( main::@3/(byte) main::x#1 main::@7/(byte) main::x#0 )
  (byte) main::y#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@8
  (byte) main::y#2 ← phi( main::@1/(byte) main::y#0 main::@8/(byte) main::y#1 )
  (byte) main::x#2 ← phi( main::@1/(byte) main::x#4 main::@8/(byte) main::x#5 )
  (byte~) main::$1 ← (byte) main::x#2 + (byte) main::y#2
  (byte) main::z#0 ← (byte~) main::$1
  (byte) main::tile#0 ← *((byte*) level_address#0 + (byte) main::z#0)
  (byte) draw_block::tileno#0 ← (byte) main::tile#0
  (byte) draw_block::x#0 ← (byte) main::x#2
  (byte) draw_block::y#0 ← (byte) main::y#2
  (byte) draw_block::color#0 ← (byte) YELLOW#0
  call draw_block 
  to:main::@8
main::@8: scope:[main]  from main::@2
  (byte) main::x#5 ← phi( main::@2/(byte) main::x#2 )
  (byte) main::y#3 ← phi( main::@2/(byte) main::y#2 )
  (byte) main::y#1 ← ++ (byte) main::y#3
  (bool~) main::$3 ← (byte) main::y#1 < (byte/signed byte/word/signed word/dword/signed dword) 9
  if((bool~) main::$3) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@8
  (byte) main::x#3 ← phi( main::@8/(byte) main::x#5 )
  (byte) main::x#1 ← ++ (byte) main::x#3
  (bool~) main::$4 ← (byte) main::x#1 < (byte/signed byte/word/signed word/dword/signed dword) $10
  if((bool~) main::$4) goto main::@1
  to:main::@5
main::@5: scope:[main]  from main::@3 main::@5
  if(true) goto main::@5
  to:main::@return
main::@return: scope:[main]  from main::@5
  return 
  to:@return
init: scope:[init]  from main
  call init_sprites 
  to:init::@2
init::@2: scope:[init]  from init
  (byte*) fill::start#0 ← (byte*) screen#0
  (word) fill::size#0 ← (word/signed word/dword/signed dword) $3e8
  (byte) fill::val#0 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  call fill 
  to:init::@3
init::@3: scope:[init]  from init::@2
  (byte*) fill::start#1 ← (byte*) colors#0
  (word) fill::size#1 ← (word/signed word/dword/signed dword) $3e8
  (byte) fill::val#1 ← (byte) BLACK#0
  call fill 
  to:init::@4
init::@4: scope:[init]  from init::@3
  (byte*) init::toD0181_screen#0 ← (byte*) screen#0
  (byte*) init::toD0181_gfx#0 ← (byte*) charset#0
  to:init::toD0181
init::toD0181: scope:[init]  from init::@4
  (byte*) init::toD0181_gfx#1 ← phi( init::@4/(byte*) init::toD0181_gfx#0 )
  (byte*) init::toD0181_screen#1 ← phi( init::@4/(byte*) init::toD0181_screen#0 )
  (word) init::toD0181_$0#0 ← ((word)) (byte*) init::toD0181_screen#1
  (word) init::toD0181_$1#0 ← (word) init::toD0181_$0#0 & (word/signed word/dword/signed dword) $3fff
  (word/signed dword/dword) init::toD0181_$2#0 ← (word) init::toD0181_$1#0 * (byte/signed byte/word/signed word/dword/signed dword) 4
  (byte/word) init::toD0181_$3#0 ← > (word/signed dword/dword) init::toD0181_$2#0
  (word) init::toD0181_$4#0 ← ((word)) (byte*) init::toD0181_gfx#1
  (byte) init::toD0181_$5#0 ← > (word) init::toD0181_$4#0
  (byte/signed word/word/dword/signed dword) init::toD0181_$6#0 ← (byte) init::toD0181_$5#0 / (byte/signed byte/word/signed word/dword/signed dword) 4
  (byte/word/dword) init::toD0181_$7#0 ← (byte/signed word/word/dword/signed dword) init::toD0181_$6#0 & (byte/signed byte/word/signed word/dword/signed dword) $f
  (byte/word/dword) init::toD0181_$8#0 ← (byte/word) init::toD0181_$3#0 | (byte/word/dword) init::toD0181_$7#0
  (byte) init::toD0181_return#0 ← (byte/word/dword) init::toD0181_$8#0
  to:init::toD0181_@return
init::toD0181_@return: scope:[init]  from init::toD0181
  (byte) init::toD0181_return#2 ← phi( init::toD0181/(byte) init::toD0181_return#0 )
  (byte) init::toD0181_return#1 ← (byte) init::toD0181_return#2
  to:init::@1
init::@1: scope:[init]  from init::toD0181_@return
  (byte) init::toD0181_return#3 ← phi( init::toD0181_@return/(byte) init::toD0181_return#1 )
  (byte~) init::$3 ← (byte) init::toD0181_return#3
  *((byte*) D018#0) ← (byte~) init::$3
  asm { lda#$5b sta$d011  }
  *((byte*) BORDERCOL#0) ← (byte) BLACK#0
  *((byte*) BGCOL1#0) ← (byte) BLACK#0
  *((byte*) BGCOL2#0) ← (byte) RED#0
  *((byte*) BGCOL3#0) ← (byte) BLUE#0
  *((byte*) BGCOL4#0) ← (byte) GREEN#0
  to:init::@return
init::@return: scope:[init]  from init::@1
  return 
  to:@return
init_sprites: scope:[init_sprites]  from init
  *((byte*) SPRITES_ENABLE#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1
  *((byte*) SPRITES_EXPAND_X#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  *((byte*) SPRITES_EXPAND_Y#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  *((byte*) SPRITES_XMSB#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  *((byte*) SPRITES_COLS#0) ← (byte) WHITE#0
  *((byte*) SPRITES_MC#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:init_sprites::@return
init_sprites::@return: scope:[init_sprites]  from init_sprites
  return 
  to:@return
draw_block: scope:[draw_block]  from main::@2
  (byte) draw_block::y#2 ← phi( main::@2/(byte) draw_block::y#0 )
  (byte) draw_block::x#1 ← phi( main::@2/(byte) draw_block::x#0 )
  (byte) draw_block::tileno#2 ← phi( main::@2/(byte) draw_block::tileno#0 )
  (byte~) draw_block::$0 ← (byte) draw_block::tileno#2 << (byte/signed byte/word/signed word/dword/signed dword) 2
  (byte) draw_block::tileno#1 ← (byte~) draw_block::$0
  (byte~) draw_block::$1 ← (byte) draw_block::x#1 << (byte/signed byte/word/signed word/dword/signed dword) 1
  (word) draw_block::x1#0 ← ((word)) (byte~) draw_block::$1
  (byte~) draw_block::$2 ← (byte) draw_block::y#2 << (byte/signed byte/word/signed word/dword/signed dword) 1
  (byte) draw_block::y#1 ← (byte~) draw_block::$2
  (byte) mul8u::a#1 ← (byte) draw_block::y#1
  (byte) mul8u::b#0 ← (byte/signed byte/word/signed word/dword/signed dword) $28
  call mul8u 
  (word) mul8u::return#2 ← (word) mul8u::return#1
  to:draw_block::@1
draw_block::@1: scope:[draw_block]  from draw_block
  (byte) draw_block::tileno#3 ← phi( draw_block/(byte) draw_block::tileno#1 )
  (word) draw_block::x1#1 ← phi( draw_block/(word) draw_block::x1#0 )
  (word) mul8u::return#4 ← phi( draw_block/(word) mul8u::return#2 )
  (word~) draw_block::$3 ← (word) mul8u::return#4
  (word) draw_block::z#0 ← (word~) draw_block::$3
  (word~) draw_block::$4 ← (word) draw_block::z#0 + (word) draw_block::x1#1
  (word) draw_block::z#1 ← (word~) draw_block::$4
  (byte) draw_block::drawtile#0 ← *((byte*) tileset#0 + (byte) draw_block::tileno#3)
  *((byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0
  *((byte*) colors#0 + (word) draw_block::z#1) ← (byte) YELLOW#0
  (word/signed dword/dword~) draw_block::$5 ← (word) draw_block::z#1 + (byte/signed byte/word/signed word/dword/signed dword) 1
  *((byte*) screen#0 + (word/signed dword/dword~) draw_block::$5) ← (byte/signed byte/word/signed word/dword/signed dword) 1
  (word/signed dword/dword~) draw_block::$6 ← (word) draw_block::z#1 + (byte/signed byte/word/signed word/dword/signed dword) 1
  *((byte*) colors#0 + (word/signed dword/dword~) draw_block::$6) ← (byte) YELLOW#0
  (word/signed dword/dword~) draw_block::$7 ← (word) draw_block::z#1 + (byte/signed byte/word/signed word/dword/signed dword) $28
  *((byte*) screen#0 + (word/signed dword/dword~) draw_block::$7) ← (byte/signed byte/word/signed word/dword/signed dword) 2
  (word/signed dword/dword~) draw_block::$8 ← (word) draw_block::z#1 + (byte/signed byte/word/signed word/dword/signed dword) $28
  *((byte*) colors#0 + (word/signed dword/dword~) draw_block::$8) ← (byte) YELLOW#0
  (word/signed dword/dword~) draw_block::$9 ← (word) draw_block::z#1 + (byte/signed byte/word/signed word/dword/signed dword) $29
  *((byte*) screen#0 + (word/signed dword/dword~) draw_block::$9) ← (byte/signed byte/word/signed word/dword/signed dword) 3
  (word/signed dword/dword~) draw_block::$10 ← (word) draw_block::z#1 + (byte/signed byte/word/signed word/dword/signed dword) $29
  *((byte*) colors#0 + (word/signed dword/dword~) draw_block::$10) ← (byte) YELLOW#0
  to:draw_block::@return
draw_block::@return: scope:[draw_block]  from draw_block::@1
  return 
  to:@return
@21: scope:[]  from @17
  call main 
  to:@22
@22: scope:[]  from @21
  to:@end
@end: scope:[]  from @22

SYMBOL TABLE SSA
(label) @17
(label) @21
(label) @22
(label) @begin
(label) @end
(byte*) BGCOL1
(byte*) BGCOL1#0
(byte*) BGCOL2
(byte*) BGCOL2#0
(byte*) BGCOL3
(byte*) BGCOL3#0
(byte*) BGCOL4
(byte*) BGCOL4#0
(byte) BLACK
(byte) BLACK#0
(byte) BLUE
(byte) BLUE#0
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte*) D018
(byte*) D018#0
(byte) GREEN
(byte) GREEN#0
(byte) RED
(byte) RED#0
(byte*) SPRITES_COLS
(byte*) SPRITES_COLS#0
(byte*) SPRITES_ENABLE
(byte*) SPRITES_ENABLE#0
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_X#0
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_EXPAND_Y#0
(byte*) SPRITES_MC
(byte*) SPRITES_MC#0
(byte*) SPRITES_XMSB
(byte*) SPRITES_XMSB#0
(byte) WHITE
(byte) WHITE#0
(byte) YELLOW
(byte) YELLOW#0
(byte*) charset
(byte*) charset#0
(byte*) colors
(byte*) colors#0
(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
(byte~) draw_block::$0
(byte~) draw_block::$1
(word/signed dword/dword~) draw_block::$10
(byte~) draw_block::$2
(word~) draw_block::$3
(word~) draw_block::$4
(word/signed dword/dword~) draw_block::$5
(word/signed dword/dword~) draw_block::$6
(word/signed dword/dword~) draw_block::$7
(word/signed dword/dword~) draw_block::$8
(word/signed dword/dword~) draw_block::$9
(label) draw_block::@1
(label) draw_block::@return
(byte) draw_block::color
(byte) draw_block::color#0
(byte) draw_block::drawtile
(byte) draw_block::drawtile#0
(byte) draw_block::tileno
(byte) draw_block::tileno#0
(byte) draw_block::tileno#1
(byte) draw_block::tileno#2
(byte) draw_block::tileno#3
(byte) draw_block::x
(byte) draw_block::x#0
(byte) draw_block::x#1
(word) draw_block::x1
(word) draw_block::x1#0
(word) draw_block::x1#1
(byte) draw_block::y
(byte) draw_block::y#0
(byte) draw_block::y#1
(byte) draw_block::y#2
(word) draw_block::z
(word) draw_block::z#0
(word) draw_block::z#1
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(byte*~) fill::$0
(bool~) fill::$1
(label) fill::@1
(label) fill::@return
(byte*) fill::addr
(byte*) fill::addr#0
(byte*) fill::addr#1
(byte*) fill::addr#2
(byte*) fill::end
(byte*) fill::end#0
(byte*) fill::end#1
(word) fill::size
(word) fill::size#0
(word) fill::size#1
(word) fill::size#2
(byte*) fill::start
(byte*) fill::start#0
(byte*) fill::start#1
(byte*) fill::start#2
(byte) fill::val
(byte) fill::val#0
(byte) fill::val#1
(byte) fill::val#2
(byte) fill::val#3
(void()) init()
(byte~) init::$3
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@return
(label) init::toD0181
(word~) init::toD0181_$0
(word) init::toD0181_$0#0
(word~) init::toD0181_$1
(word) init::toD0181_$1#0
(word/signed dword/dword~) init::toD0181_$2
(word/signed dword/dword) init::toD0181_$2#0
(byte/word~) init::toD0181_$3
(byte/word) init::toD0181_$3#0
(word~) init::toD0181_$4
(word) init::toD0181_$4#0
(byte~) init::toD0181_$5
(byte) init::toD0181_$5#0
(byte/signed word/word/dword/signed dword~) init::toD0181_$6
(byte/signed word/word/dword/signed dword) init::toD0181_$6#0
(byte/word/dword~) init::toD0181_$7
(byte/word/dword) init::toD0181_$7#0
(byte/word/dword~) init::toD0181_$8
(byte/word/dword) init::toD0181_$8#0
(label) init::toD0181_@return
(byte*) init::toD0181_gfx
(byte*) init::toD0181_gfx#0
(byte*) init::toD0181_gfx#1
(byte) init::toD0181_return
(byte) init::toD0181_return#0
(byte) init::toD0181_return#1
(byte) init::toD0181_return#2
(byte) init::toD0181_return#3
(byte*) init::toD0181_screen
(byte*) init::toD0181_screen#0
(byte*) init::toD0181_screen#1
(void()) init_sprites()
(label) init_sprites::@return
(byte*) level_address
(byte*) level_address#0
(void()) main()
(byte~) main::$1
(bool~) main::$3
(bool~) main::$4
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@5
(label) main::@7
(label) main::@8
(label) main::@return
(byte) main::tile
(byte) main::tile#0
(byte) main::x
(byte) main::x#0
(byte) main::x#1
(byte) main::x#2
(byte) main::x#3
(byte) main::x#4
(byte) main::x#5
(byte) main::y
(byte) main::y#0
(byte) main::y#1
(byte) main::y#2
(byte) main::y#3
(byte) main::z
(byte) main::z#0
(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
(bool~) mul8u::$0
(byte~) mul8u::$1
(bool~) mul8u::$2
(bool~) mul8u::$3
(word~) mul8u::$4
(byte~) mul8u::$5
(word~) mul8u::$6
(label) mul8u::@1
(label) mul8u::@2
(label) mul8u::@3
(label) mul8u::@4
(label) mul8u::@7
(label) mul8u::@return
(byte) mul8u::a
(byte) mul8u::a#0
(byte) mul8u::a#1
(byte) mul8u::a#2
(byte) mul8u::a#3
(byte) mul8u::a#4
(byte) mul8u::a#5
(byte) mul8u::a#6
(byte) mul8u::b
(byte) mul8u::b#0
(byte) mul8u::b#1
(word) mul8u::mb
(word) mul8u::mb#0
(word) mul8u::mb#1
(word) mul8u::mb#2
(word) mul8u::mb#3
(word) mul8u::mb#4
(word) mul8u::mb#5
(word) mul8u::res
(word) mul8u::res#0
(word) mul8u::res#1
(word) mul8u::res#2
(word) mul8u::res#3
(word) mul8u::res#4
(word) mul8u::res#5
(word) mul8u::res#6
(word) mul8u::return
(word) mul8u::return#0
(word) mul8u::return#1
(word) mul8u::return#2
(word) mul8u::return#3
(word) mul8u::return#4
(byte*) screen
(byte*) screen#0
(byte*) tileset
(byte*) tileset#0

Culled Empty Block (label) @22
Successful SSA optimization Pass2CullEmptyBlocks
Inversing boolean not [37] (bool~) mul8u::$3 ← (byte~) mul8u::$1 == (byte/signed byte/word/signed word/dword/signed dword) 0 from [36] (bool~) mul8u::$2 ← (byte~) mul8u::$1 != (byte/signed byte/word/signed word/dword/signed dword) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte*) fill::end#0 = (byte*~) fill::$0 
Alias (byte*) fill::addr#0 = (byte*) fill::start#2 
Alias (byte) mul8u::a#2 = (byte) mul8u::a#3 (byte) mul8u::a#6 
Alias (word) mul8u::mb#3 = (word) mul8u::mb#4 (word) mul8u::mb#5 
Alias (word) mul8u::res#2 = (word) mul8u::res#5 (word) mul8u::res#4 (word) mul8u::return#0 (word) mul8u::res#3 (word) mul8u::return#3 (word) mul8u::return#1 
Alias (byte) mul8u::a#0 = (byte~) mul8u::$5 
Alias (word) mul8u::mb#1 = (word~) mul8u::$6 
Alias (word) mul8u::res#1 = (word~) mul8u::$4 
Alias (byte) main::z#0 = (byte~) main::$1 
Alias (byte) main::y#2 = (byte) main::y#3 
Alias (byte) main::x#2 = (byte) main::x#5 (byte) main::x#3 
Alias (byte*) init::toD0181_screen#0 = (byte*) init::toD0181_screen#1 
Alias (byte*) init::toD0181_gfx#0 = (byte*) init::toD0181_gfx#1 
Alias (byte) init::toD0181_return#0 = (byte/word/dword) init::toD0181_$8#0 (byte) init::toD0181_return#2 (byte) init::toD0181_return#1 (byte) init::toD0181_return#3 (byte~) init::$3 
Alias (byte) draw_block::tileno#1 = (byte~) draw_block::$0 (byte) draw_block::tileno#3 
Alias (byte) draw_block::y#1 = (byte~) draw_block::$2 
Alias (word) mul8u::return#2 = (word) mul8u::return#4 
Alias (word) draw_block::x1#0 = (word) draw_block::x1#1 
Alias (word) draw_block::z#0 = (word~) draw_block::$3 
Alias (word) draw_block::z#1 = (word~) draw_block::$4 
Successful SSA optimization Pass2AliasElimination
Alias (byte) mul8u::a#2 = (byte) mul8u::a#4 
Alias (word) mul8u::mb#2 = (word) mul8u::mb#3 
Successful SSA optimization Pass2AliasElimination
Self Phi Eliminated (byte) fill::val#2
Self Phi Eliminated (byte*) fill::end#1
Self Phi Eliminated (byte) main::x#2
Successful SSA optimization Pass2SelfPhiElimination
Redundant Phi (byte) fill::val#2 (byte) fill::val#3
Redundant Phi (byte*) fill::end#1 (byte*) fill::end#0
Redundant Phi (byte) mul8u::b#1 (byte) mul8u::b#0
Redundant Phi (byte) mul8u::a#5 (byte) mul8u::a#1
Redundant Phi (byte) main::x#2 (byte) main::x#4
Redundant Phi (byte) draw_block::tileno#2 (byte) draw_block::tileno#0
Redundant Phi (byte) draw_block::x#1 (byte) draw_block::x#0
Redundant Phi (byte) draw_block::y#2 (byte) draw_block::y#0
Successful SSA optimization Pass2RedundantPhiElimination
Simple Condition (bool~) fill::$1 [26] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1
Simple Condition (bool~) mul8u::$0 [33] if((byte) mul8u::a#2!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@2
Simple Condition (bool~) mul8u::$3 [38] if((byte~) mul8u::$1==(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@4
Simple Condition (bool~) main::$3 [73] if((byte) main::y#1<(byte/signed byte/word/signed word/dword/signed dword) 9) goto main::@2
Simple Condition (bool~) main::$4 [77] if((byte) main::x#1<(byte/signed byte/word/signed word/dword/signed dword) $10) goto main::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) SPRITES_XMSB#0 = ((byte*))$d010
Constant (const byte*) SPRITES_ENABLE#0 = ((byte*))$d015
Constant (const byte*) SPRITES_EXPAND_Y#0 = ((byte*))$d017
Constant (const byte*) SPRITES_MC#0 = ((byte*))$d01c
Constant (const byte*) SPRITES_EXPAND_X#0 = ((byte*))$d01d
Constant (const byte*) BORDERCOL#0 = ((byte*))$d020
Constant (const byte*) BGCOL1#0 = ((byte*))$d021
Constant (const byte*) BGCOL2#0 = ((byte*))$d022
Constant (const byte*) BGCOL3#0 = ((byte*))$d023
Constant (const byte*) BGCOL4#0 = ((byte*))$d024
Constant (const byte*) SPRITES_COLS#0 = ((byte*))$d027
Constant (const byte*) D018#0 = ((byte*))$d018
Constant (const byte) BLACK#0 = 0
Constant (const byte) WHITE#0 = 1
Constant (const byte) RED#0 = 2
Constant (const byte) GREEN#0 = 5
Constant (const byte) BLUE#0 = 6
Constant (const byte) YELLOW#0 = 7
Constant (const word) mul8u::res#0 = 0
Constant (const byte*) screen#0 = ((byte*))$400
Constant (const byte*) charset#0 = ((byte*))$2000
Constant (const byte*) tileset#0 = ((byte*))$2800
Constant (const byte*) colors#0 = ((byte*))$d800
Constant (const byte*) level_address#0 = ((byte*))$3000
Constant (const byte) main::x#0 = 0
Constant (const byte) main::y#0 = 0
Constant (const word) fill::size#0 = $3e8
Constant (const byte) fill::val#0 = 0
Constant (const word) fill::size#1 = $3e8
Constant (const byte) mul8u::b#0 = $28
Successful SSA optimization Pass2ConstantIdentification
Constant (const word) mul8u::mb#0 = ((word))mul8u::b#0
Constant (const byte) draw_block::color#0 = YELLOW#0
Constant (const byte*) fill::start#0 = screen#0
Constant (const byte*) fill::start#1 = colors#0
Constant (const byte) fill::val#1 = BLACK#0
Constant (const byte*) init::toD0181_screen#0 = screen#0
Constant (const byte*) init::toD0181_gfx#0 = charset#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const word) init::toD0181_$0#0 = ((word))init::toD0181_screen#0
Constant (const word) init::toD0181_$4#0 = ((word))init::toD0181_gfx#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const word) init::toD0181_$1#0 = init::toD0181_$0#0&$3fff
Constant (const byte) init::toD0181_$5#0 = >init::toD0181_$4#0
Successful SSA optimization Pass2ConstantIdentification
Constant (const word/signed dword/dword) init::toD0181_$2#0 = init::toD0181_$1#0*4
Constant (const byte/signed word/word/dword/signed dword) init::toD0181_$6#0 = init::toD0181_$5#0/4
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte/word) init::toD0181_$3#0 = >init::toD0181_$2#0
Constant (const byte/word/dword) init::toD0181_$7#0 = init::toD0181_$6#0&$f
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) init::toD0181_return#0 = init::toD0181_$3#0|init::toD0181_$7#0
Successful SSA optimization Pass2ConstantIdentification
Consolidated array index constant in assignment *(screen#0+1 + draw_block::$5)
Consolidated array index constant in assignment *(colors#0+1 + draw_block::$6)
Consolidated array index constant in assignment *(screen#0+$28 + draw_block::$7)
Consolidated array index constant in assignment *(colors#0+$28 + draw_block::$8)
Consolidated array index constant in assignment *(screen#0+$29 + draw_block::$9)
Consolidated array index constant in assignment *(colors#0+$29 + draw_block::$10)
Successful SSA optimization Pass2ConstantAdditionElimination
if() condition always true - replacing block destination [29] if(true) goto main::@5
Successful SSA optimization Pass2ConstantIfs
Inferred type updated to word in [61] (word/signed dword/dword~) draw_block::$5 ← (word) draw_block::z#1
Inferred type updated to word in [63] (word/signed dword/dword~) draw_block::$6 ← (word) draw_block::z#1
Inferred type updated to word in [65] (word/signed dword/dword~) draw_block::$7 ← (word) draw_block::z#1
Inferred type updated to word in [67] (word/signed dword/dword~) draw_block::$8 ← (word) draw_block::z#1
Inferred type updated to word in [69] (word/signed dword/dword~) draw_block::$9 ← (word) draw_block::z#1
Inferred type updated to word in [71] (word/signed dword/dword~) draw_block::$10 ← (word) draw_block::z#1
Eliminating unused constant (const byte) draw_block::color#0
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Culled Empty Block (label) mul8u::@3
Culled Empty Block (label) @17
Culled Empty Block (label) main::@7
Culled Empty Block (label) init::@4
Culled Empty Block (label) init::toD0181_@return
Successful SSA optimization Pass2CullEmptyBlocks
Alias (word) draw_block::z#1 = (word~) draw_block::$5 (word~) draw_block::$6 (word~) draw_block::$7 (word~) draw_block::$8 (word~) draw_block::$9 (word~) draw_block::$10 
Successful SSA optimization Pass2AliasElimination
Inlining constant with var siblings (const word) fill::size#0
Inlining constant with var siblings (const byte) fill::val#0
Inlining constant with var siblings (const word) fill::size#1
Inlining constant with var siblings (const byte) fill::val#1
Inlining constant with var siblings (const word) mul8u::res#0
Inlining constant with var siblings (const word) mul8u::mb#0
Inlining constant with var siblings (const byte) main::x#0
Inlining constant with var siblings (const byte) main::y#0
Constant inlined init::toD0181_gfx#0 = (const byte*) charset#0
Constant inlined fill::val#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined init::toD0181_$0#0 = ((word))(const byte*) screen#0
Constant inlined mul8u::mb#0 = ((word))(const byte) mul8u::b#0
Constant inlined init::toD0181_$2#0 = ((word))(const byte*) screen#0&(word/signed word/dword/signed dword) $3fff*(byte/signed byte/word/signed word/dword/signed dword) 4
Constant inlined init::toD0181_$1#0 = ((word))(const byte*) screen#0&(word/signed word/dword/signed dword) $3fff
Constant inlined fill::val#1 = (const byte) BLACK#0
Constant inlined init::toD0181_$4#0 = ((word))(const byte*) charset#0
Constant inlined init::toD0181_$3#0 = >((word))(const byte*) screen#0&(word/signed word/dword/signed dword) $3fff*(byte/signed byte/word/signed word/dword/signed dword) 4
Constant inlined fill::size#1 = (word/signed word/dword/signed dword) $3e8
Constant inlined init::toD0181_$6#0 = >((word))(const byte*) charset#0/(byte/signed byte/word/signed word/dword/signed dword) 4
Constant inlined fill::size#0 = (word/signed word/dword/signed dword) $3e8
Constant inlined main::x#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined init::toD0181_$5#0 = >((word))(const byte*) charset#0
Constant inlined main::y#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined init::toD0181_$7#0 = >((word))(const byte*) charset#0/(byte/signed byte/word/signed word/dword/signed dword) 4&(byte/signed byte/word/signed word/dword/signed dword) $f
Constant inlined mul8u::res#0 = (byte/signed byte/word/signed word/dword/signed dword) 0
Constant inlined fill::start#1 = (const byte*) colors#0
Constant inlined fill::start#0 = (const byte*) screen#0
Constant inlined init::toD0181_screen#0 = (const byte*) screen#0
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values (word) fill::size#2 (word/signed word/dword/signed dword) $3e8
Successful SSA optimization Pass2IdenticalPhiElimination
Added new block during phi lifting main::@9(between main::@3 and main::@1)
Added new block during phi lifting main::@10(between main::@8 and main::@2)
Added new block during phi lifting mul8u::@10(between mul8u::@2 and mul8u::@4)
Added new block during phi lifting fill::@3(between fill::@1 and fill::@1)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @21
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of init
Adding NOP phi() at start of init::@2
Adding NOP phi() at start of init::@3
Adding NOP phi() at start of init::toD0181
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to init:5 draw_block:13 
Calls in [draw_block] to mul8u:26 
Calls in [init] to init_sprites:56 fill:58 fill:60 

Created 9 initial phi equivalence classes
Coalesced [19] main::x#6 ← main::x#1
Coalesced [20] main::y#4 ← main::y#1
Coalesced [40] mul8u::a#7 ← mul8u::a#1
Coalesced [47] mul8u::res#9 ← mul8u::res#1
Coalesced [51] mul8u::a#8 ← mul8u::a#0
Coalesced [52] mul8u::res#7 ← mul8u::res#6
Coalesced [53] mul8u::mb#6 ← mul8u::mb#1
Coalesced (already) [54] mul8u::res#8 ← mul8u::res#2
Coalesced [72] fill::addr#3 ← fill::addr#0
Coalesced [78] fill::addr#4 ← fill::addr#1
Coalesced down to 7 phi equivalence classes
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@10
Culled Empty Block (label) mul8u::@10
Culled Empty Block (label) fill::@3
Renumbering block @21 to @1
Renumbering block mul8u::@4 to mul8u::@3
Renumbering block mul8u::@7 to mul8u::@4
Renumbering block main::@5 to main::@4
Renumbering block main::@8 to main::@5
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of mul8u
Adding NOP phi() at start of init
Adding NOP phi() at start of init::@2
Adding NOP phi() at start of init::@3
Adding NOP phi() at start of init::toD0181

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  [5] call init 
  to:main::@1
main::@1: scope:[main]  from main main::@3
  [6] (byte) main::x#4 ← phi( main::@3/(byte) main::x#1 main/(byte/signed byte/word/signed word/dword/signed dword) 0 )
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@5
  [7] (byte) main::y#2 ← phi( main::@1/(byte/signed byte/word/signed word/dword/signed dword) 0 main::@5/(byte) main::y#1 )
  [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2
  [9] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0)
  [10] (byte) draw_block::tileno#0 ← (byte) main::tile#0
  [11] (byte) draw_block::x#0 ← (byte) main::x#4
  [12] (byte) draw_block::y#0 ← (byte) main::y#2
  [13] call draw_block 
  to:main::@5
main::@5: scope:[main]  from main::@2
  [14] (byte) main::y#1 ← ++ (byte) main::y#2
  [15] if((byte) main::y#1<(byte/signed byte/word/signed word/dword/signed dword) 9) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@5
  [16] (byte) main::x#1 ← ++ (byte) main::x#4
  [17] if((byte) main::x#1<(byte/signed byte/word/signed word/dword/signed dword) $10) goto main::@1
  to:main::@4
main::@4: scope:[main]  from main::@3 main::@4
  [18] phi()
  to:main::@4
draw_block: scope:[draw_block]  from main::@2
  [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte/signed byte/word/signed word/dword/signed dword) 2
  [20] (byte~) draw_block::$1 ← (byte) draw_block::x#0 << (byte/signed byte/word/signed word/dword/signed dword) 1
  [21] (word) draw_block::x1#0 ← ((word)) (byte~) draw_block::$1
  [22] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte/signed byte/word/signed word/dword/signed dword) 1
  [23] (byte) mul8u::a#1 ← (byte) draw_block::y#1
  [24] call mul8u 
  [25] (word) mul8u::return#2 ← (word) mul8u::res#2
  to:draw_block::@1
draw_block::@1: scope:[draw_block]  from draw_block
  [26] (word) draw_block::z#0 ← (word) mul8u::return#2
  [27] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0
  [28] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1)
  [29] *((const byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0
  [30] *((const byte*) colors#0 + (word) draw_block::z#1) ← (const byte) YELLOW#0
  [31] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 1
  [32] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (const byte) YELLOW#0
  [33] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 2
  [34] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (const byte) YELLOW#0
  [35] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 3
  [36] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (const byte) YELLOW#0
  to:draw_block::@return
draw_block::@return: scope:[draw_block]  from draw_block::@1
  [37] return 
  to:@return
mul8u: scope:[mul8u]  from draw_block
  [38] phi()
  to:mul8u::@1
mul8u::@1: scope:[mul8u]  from mul8u mul8u::@3
  [39] (word) mul8u::mb#2 ← phi( mul8u/((word))(const byte) mul8u::b#0 mul8u::@3/(word) mul8u::mb#1 )
  [39] (word) mul8u::res#2 ← phi( mul8u/(byte/signed byte/word/signed word/dword/signed dword) 0 mul8u::@3/(word) mul8u::res#6 )
  [39] (byte) mul8u::a#2 ← phi( mul8u/(byte) mul8u::a#1 mul8u::@3/(byte) mul8u::a#0 )
  [40] if((byte) mul8u::a#2!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@2
  to:mul8u::@return
mul8u::@return: scope:[mul8u]  from mul8u::@1
  [41] return 
  to:@return
mul8u::@2: scope:[mul8u]  from mul8u::@1
  [42] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte/signed byte/word/signed word/dword/signed dword) 1
  [43] if((byte~) mul8u::$1==(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@3
  to:mul8u::@4
mul8u::@4: scope:[mul8u]  from mul8u::@2
  [44] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2
  to:mul8u::@3
mul8u::@3: scope:[mul8u]  from mul8u::@2 mul8u::@4
  [45] (word) mul8u::res#6 ← phi( mul8u::@2/(word) mul8u::res#2 mul8u::@4/(word) mul8u::res#1 )
  [46] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte/signed byte/word/signed word/dword/signed dword) 1
  [47] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte/signed byte/word/signed word/dword/signed dword) 1
  to:mul8u::@1
init: scope:[init]  from main
  [48] phi()
  [49] call init_sprites 
  to:init::@2
init::@2: scope:[init]  from init
  [50] phi()
  [51] call fill 
  to:init::@3
init::@3: scope:[init]  from init::@2
  [52] phi()
  [53] call fill 
  to:init::toD0181
init::toD0181: scope:[init]  from init::@3
  [54] phi()
  to:init::@1
init::@1: scope:[init]  from init::toD0181
  [55] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0
  asm { lda#$5b sta$d011  }
  [57] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0
  [58] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0
  [59] *((const byte*) BGCOL2#0) ← (const byte) RED#0
  [60] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0
  [61] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0
  to:init::@return
init::@return: scope:[init]  from init::@1
  [62] return 
  to:@return
fill: scope:[fill]  from init::@2 init::@3
  [63] (byte) fill::val#3 ← phi( init::@2/(byte/signed byte/word/signed word/dword/signed dword) 0 init::@3/(const byte) BLACK#0 )
  [63] (byte*) fill::addr#0 ← phi( init::@2/(const byte*) screen#0 init::@3/(const byte*) colors#0 )
  [64] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word/signed word/dword/signed dword) $3e8
  to:fill::@1
fill::@1: scope:[fill]  from fill fill::@1
  [65] (byte*) fill::addr#2 ← phi( fill/(byte*) fill::addr#0 fill::@1/(byte*) fill::addr#1 )
  [66] *((byte*) fill::addr#2) ← (byte) fill::val#3
  [67] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2
  [68] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1
  to:fill::@return
fill::@return: scope:[fill]  from fill::@1
  [69] return 
  to:@return
init_sprites: scope:[init_sprites]  from init
  [70] *((const byte*) SPRITES_ENABLE#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1
  [71] *((const byte*) SPRITES_EXPAND_X#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  [72] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  [73] *((const byte*) SPRITES_XMSB#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  [74] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0
  [75] *((const byte*) SPRITES_MC#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:init_sprites::@return
init_sprites::@return: scope:[init_sprites]  from init_sprites
  [76] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte*) BGCOL1
(byte*) BGCOL2
(byte*) BGCOL3
(byte*) BGCOL4
(byte) BLACK
(byte) BLUE
(byte*) BORDERCOL
(byte*) D018
(byte) GREEN
(byte) RED
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_MC
(byte*) SPRITES_XMSB
(byte) WHITE
(byte) YELLOW
(byte*) charset
(byte*) colors
(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
(byte~) draw_block::$1 4.0
(byte) draw_block::color
(byte) draw_block::drawtile
(byte) draw_block::drawtile#0 4.0
(byte) draw_block::tileno
(byte) draw_block::tileno#0 34.33333333333333
(byte) draw_block::tileno#1 0.4444444444444444
(byte) draw_block::x
(byte) draw_block::x#0 34.33333333333333
(word) draw_block::x1
(word) draw_block::x1#0 0.6666666666666666
(byte) draw_block::y
(byte) draw_block::y#0 25.75
(byte) draw_block::y#1 4.0
(word) draw_block::z
(word) draw_block::z#0 4.0
(word) draw_block::z#1 2.0000000000000004
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(byte*) fill::addr
(byte*) fill::addr#0 2.0
(byte*) fill::addr#1 16.5
(byte*) fill::addr#2 17.5
(byte*) fill::end
(byte*) fill::end#0 2.6
(word) fill::size
(byte*) fill::start
(byte) fill::val
(byte) fill::val#3 1.8333333333333333
(void()) init()
(word~) init::toD0181_$0
(word~) init::toD0181_$1
(word/signed dword/dword~) init::toD0181_$2
(byte/word~) init::toD0181_$3
(word~) init::toD0181_$4
(byte~) init::toD0181_$5
(byte/signed word/word/dword/signed dword~) init::toD0181_$6
(byte/word/dword~) init::toD0181_$7
(byte/word/dword~) init::toD0181_$8
(byte*) init::toD0181_gfx
(byte) init::toD0181_return
(byte*) init::toD0181_screen
(void()) init_sprites()
(byte*) level_address
(void()) main()
(byte) main::tile
(byte) main::tile#0 202.0
(byte) main::x
(byte) main::x#1 16.5
(byte) main::x#4 22.4
(byte) main::y
(byte) main::y#1 151.5
(byte) main::y#2 57.714285714285715
(byte) main::z
(byte) main::z#0 202.0
(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
(byte~) mul8u::$1 2002.0
(byte) mul8u::a
(byte) mul8u::a#0 1001.0
(byte) mul8u::a#1 2.0
(byte) mul8u::a#2 667.6666666666667
(byte) mul8u::b
(word) mul8u::mb
(word) mul8u::mb#1 2002.0
(word) mul8u::mb#2 429.0
(word) mul8u::res
(word) mul8u::res#1 2002.0
(word) mul8u::res#2 500.83333333333337
(word) mul8u::res#6 1001.0
(word) mul8u::return
(word) mul8u::return#2 4.0
(byte*) screen
(byte*) tileset

Initial phi equivalence classes
[ main::x#4 main::x#1 ]
[ main::y#2 main::y#1 ]
[ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
[ mul8u::res#2 mul8u::res#6 mul8u::res#1 ]
[ mul8u::mb#2 mul8u::mb#1 ]
[ fill::val#3 ]
[ fill::addr#2 fill::addr#0 fill::addr#1 ]
Added variable main::z#0 to zero page equivalence class [ main::z#0 ]
Added variable main::tile#0 to zero page equivalence class [ main::tile#0 ]
Added variable draw_block::tileno#0 to zero page equivalence class [ draw_block::tileno#0 ]
Added variable draw_block::x#0 to zero page equivalence class [ draw_block::x#0 ]
Added variable draw_block::y#0 to zero page equivalence class [ draw_block::y#0 ]
Added variable draw_block::tileno#1 to zero page equivalence class [ draw_block::tileno#1 ]
Added variable draw_block::$1 to zero page equivalence class [ draw_block::$1 ]
Added variable draw_block::x1#0 to zero page equivalence class [ draw_block::x1#0 ]
Added variable draw_block::y#1 to zero page equivalence class [ draw_block::y#1 ]
Added variable mul8u::return#2 to zero page equivalence class [ mul8u::return#2 ]
Added variable draw_block::z#0 to zero page equivalence class [ draw_block::z#0 ]
Added variable draw_block::z#1 to zero page equivalence class [ draw_block::z#1 ]
Added variable draw_block::drawtile#0 to zero page equivalence class [ draw_block::drawtile#0 ]
Added variable mul8u::$1 to zero page equivalence class [ mul8u::$1 ]
Added variable fill::end#0 to zero page equivalence class [ fill::end#0 ]
Complete equivalence classes
[ main::x#4 main::x#1 ]
[ main::y#2 main::y#1 ]
[ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
[ mul8u::res#2 mul8u::res#6 mul8u::res#1 ]
[ mul8u::mb#2 mul8u::mb#1 ]
[ fill::val#3 ]
[ fill::addr#2 fill::addr#0 fill::addr#1 ]
[ main::z#0 ]
[ main::tile#0 ]
[ draw_block::tileno#0 ]
[ draw_block::x#0 ]
[ draw_block::y#0 ]
[ draw_block::tileno#1 ]
[ draw_block::$1 ]
[ draw_block::x1#0 ]
[ draw_block::y#1 ]
[ mul8u::return#2 ]
[ draw_block::z#0 ]
[ draw_block::z#1 ]
[ draw_block::drawtile#0 ]
[ mul8u::$1 ]
[ fill::end#0 ]
Allocated zp ZP_BYTE:2 [ main::x#4 main::x#1 ]
Allocated zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Allocated zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
Allocated zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ]
Allocated zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ]
Allocated zp ZP_BYTE:9 [ fill::val#3 ]
Allocated zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ]
Allocated zp ZP_BYTE:12 [ main::z#0 ]
Allocated zp ZP_BYTE:13 [ main::tile#0 ]
Allocated zp ZP_BYTE:14 [ draw_block::tileno#0 ]
Allocated zp ZP_BYTE:15 [ draw_block::x#0 ]
Allocated zp ZP_BYTE:16 [ draw_block::y#0 ]
Allocated zp ZP_BYTE:17 [ draw_block::tileno#1 ]
Allocated zp ZP_BYTE:18 [ draw_block::$1 ]
Allocated zp ZP_WORD:19 [ draw_block::x1#0 ]
Allocated zp ZP_BYTE:21 [ draw_block::y#1 ]
Allocated zp ZP_WORD:22 [ mul8u::return#2 ]
Allocated zp ZP_WORD:24 [ draw_block::z#0 ]
Allocated zp ZP_WORD:26 [ draw_block::z#1 ]
Allocated zp ZP_BYTE:28 [ draw_block::drawtile#0 ]
Allocated zp ZP_BYTE:29 [ mul8u::$1 ]
Allocated zp ZP_WORD:30 [ fill::end#0 ]

INITIAL ASM
//SEG0 File Comments
// Illustrates a problem with a missing fragment - pbuc1_derefidx_vwuz1=vbuz2
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XMSB = $d010
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label BORDERCOL = $d020
  .label BGCOL1 = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label BGCOL4 = $d024
  .label SPRITES_COLS = $d027
  .label D018 = $d018
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  .const BLUE = 6
  .const YELLOW = 7
  .label screen = $400
  .label charset = $2000
  .label tileset = $2800
  .label colors = $d800
  .label level_address = $3000
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
    .label z = $c
    .label tile = $d
    .label y = 3
    .label x = 2
  //SEG11 [5] call init 
  //SEG12 [48] phi from main to init [phi:main->init]
  init_from_main:
    jsr init
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG14 [6] phi (byte) main::x#4 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x
    jmp b1
  //SEG15 [6] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  b1_from_b3:
  //SEG16 [6] phi (byte) main::x#4 = (byte) main::x#1 [phi:main::@3->main::@1#0] -- register_copy 
    jmp b1
  //SEG17 main::@1
  b1:
  //SEG18 [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
  //SEG19 [7] phi (byte) main::y#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    jmp b2
  //SEG20 [7] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  b2_from_b5:
  //SEG21 [7] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@5->main::@2#0] -- register_copy 
    jmp b2
  //SEG22 main::@2
  b2:
  //SEG23 [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 -- vbuz1=vbuz2_plus_vbuz3 
    lda x
    clc
    adc y
    sta z
  //SEG24 [9] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy z
    lda level_address,y
    sta tile
  //SEG25 [10] (byte) draw_block::tileno#0 ← (byte) main::tile#0 -- vbuz1=vbuz2 
    lda tile
    sta draw_block.tileno
  //SEG26 [11] (byte) draw_block::x#0 ← (byte) main::x#4 -- vbuz1=vbuz2 
    lda x
    sta draw_block.x
  //SEG27 [12] (byte) draw_block::y#0 ← (byte) main::y#2 -- vbuz1=vbuz2 
    lda y
    sta draw_block.y
  //SEG28 [13] call draw_block 
    jsr draw_block
    jmp b5
  //SEG29 main::@5
  b5:
  //SEG30 [14] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc y
  //SEG31 [15] if((byte) main::y#1<(byte/signed byte/word/signed word/dword/signed dword) 9) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda y
    cmp #9
    bcc b2_from_b5
    jmp b3
  //SEG32 main::@3
  b3:
  //SEG33 [16] (byte) main::x#1 ← ++ (byte) main::x#4 -- vbuz1=_inc_vbuz1 
    inc x
  //SEG34 [17] if((byte) main::x#1<(byte/signed byte/word/signed word/dword/signed dword) $10) goto main::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda x
    cmp #$10
    bcc b1_from_b3
  //SEG35 [18] phi from main::@3 main::@4 to main::@4 [phi:main::@3/main::@4->main::@4]
  b4_from_b3:
  b4_from_b4:
    jmp b4
  //SEG36 main::@4
  b4:
    jmp b4_from_b4
}
//SEG37 draw_block
// draw_block(byte zeropage($e) tileno, byte zeropage($f) x, byte zeropage($10) y)
draw_block: {
    .label _1 = $12
    .label tileno = $e
    .label x = $f
    .label y = $10
    .label tileno_1 = $11
    .label x1 = $13
    .label y_1 = $15
    .label z = $18
    .label z_1 = $1a
    .label drawtile = $1c
  //SEG38 [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte/signed byte/word/signed word/dword/signed dword) 2 -- vbuz1=vbuz2_rol_2 
    lda tileno
    asl
    asl
    sta tileno_1
  //SEG39 [20] (byte~) draw_block::$1 ← (byte) draw_block::x#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz2_rol_1 
    lda x
    asl
    sta _1
  //SEG40 [21] (word) draw_block::x1#0 ← ((word)) (byte~) draw_block::$1 -- vwuz1=_word_vbuz2 
    lda _1
    sta x1
    lda #0
    sta x1+1
  //SEG41 [22] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz2_rol_1 
    lda y
    asl
    sta y_1
  //SEG42 [23] (byte) mul8u::a#1 ← (byte) draw_block::y#1 -- vbuz1=vbuz2 
    lda y_1
    sta mul8u.a
  //SEG43 [24] call mul8u 
  //SEG44 [38] phi from draw_block to mul8u [phi:draw_block->mul8u]
  mul8u_from_draw_block:
    jsr mul8u
  //SEG45 [25] (word) mul8u::return#2 ← (word) mul8u::res#2 -- vwuz1=vwuz2 
    lda mul8u.res
    sta mul8u.return
    lda mul8u.res+1
    sta mul8u.return+1
    jmp b1
  //SEG46 draw_block::@1
  b1:
  //SEG47 [26] (word) draw_block::z#0 ← (word) mul8u::return#2 -- vwuz1=vwuz2 
    lda mul8u.return
    sta z
    lda mul8u.return+1
    sta z+1
  //SEG48 [27] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 -- vwuz1=vwuz2_plus_vwuz3 
    lda z
    clc
    adc x1
    sta z_1
    lda z+1
    adc x1+1
    sta z_1+1
  //SEG49 [28] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy tileno_1
    lda tileset,y
    sta drawtile
  //SEG50 [29] *((const byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0 -- pbuc1_derefidx_vwuz1=vbuz2 
    lda drawtile
    sta !v++1
    lda #<screen
    clc
    adc z_1
    sta !a++1
    lda #>screen
    adc z_1+1
    sta !a++2
  !v:
    lda #0
  !a:
    sta screen
  //SEG51 [30] *((const byte*) colors#0 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors
    clc
    adc z_1
    sta !++1
    lda #>colors
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors
  //SEG52 [31] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<screen+1
    clc
    adc z_1
    sta !++1
    lda #>screen+1
    adc z_1+1
    sta !++2
    lda #1
  !:
    sta screen+1
  //SEG53 [32] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors+1
    clc
    adc z_1
    sta !++1
    lda #>colors+1
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors+1
  //SEG54 [33] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 2 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<screen+$28
    clc
    adc z_1
    sta !++1
    lda #>screen+$28
    adc z_1+1
    sta !++2
    lda #2
  !:
    sta screen+$28
  //SEG55 [34] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors+$28
    clc
    adc z_1
    sta !++1
    lda #>colors+$28
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors+$28
  //SEG56 [35] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 3 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<screen+$29
    clc
    adc z_1
    sta !++1
    lda #>screen+$29
    adc z_1+1
    sta !++2
    lda #3
  !:
    sta screen+$29
  //SEG57 [36] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors+$29
    clc
    adc z_1
    sta !++1
    lda #>colors+$29
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors+$29
    jmp breturn
  //SEG58 draw_block::@return
  breturn:
  //SEG59 [37] return 
    rts
}
//SEG60 mul8u
// Perform binary multiplication of two unsigned 8-bit bytes into a 16-bit unsigned word
// mul8u(byte zeropage(4) a)
mul8u: {
    .const b = $28
    .label _1 = $1d
    .label a = 4
    .label mb = 7
    .label res = 5
    .label return = $16
  //SEG61 [39] phi from mul8u to mul8u::@1 [phi:mul8u->mul8u::@1]
  b1_from_mul8u:
  //SEG62 [39] phi (word) mul8u::mb#2 = ((word))(const byte) mul8u::b#0 [phi:mul8u->mul8u::@1#0] -- vwuz1=vbuc1 
    lda #b
    sta mb
    lda #0
    sta mb+1
  //SEG63 [39] phi (word) mul8u::res#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:mul8u->mul8u::@1#1] -- vwuz1=vbuc1 
    lda #0
    sta res
    lda #0
    sta res+1
  //SEG64 [39] phi (byte) mul8u::a#2 = (byte) mul8u::a#1 [phi:mul8u->mul8u::@1#2] -- register_copy 
    jmp b1
  //SEG65 mul8u::@1
  b1:
  //SEG66 [40] if((byte) mul8u::a#2!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@2 -- vbuz1_neq_0_then_la1 
    lda a
    cmp #0
    bne b2
    jmp breturn
  //SEG67 mul8u::@return
  breturn:
  //SEG68 [41] return 
    rts
  //SEG69 mul8u::@2
  b2:
  //SEG70 [42] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and a
    sta _1
  //SEG71 [43] if((byte~) mul8u::$1==(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@3 -- vbuz1_eq_0_then_la1 
    lda _1
    cmp #0
    beq b3_from_b2
    jmp b4
  //SEG72 mul8u::@4
  b4:
  //SEG73 [44] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 -- vwuz1=vwuz1_plus_vwuz2 
    lda res
    clc
    adc mb
    sta res
    lda res+1
    adc mb+1
    sta res+1
  //SEG74 [45] phi from mul8u::@2 mul8u::@4 to mul8u::@3 [phi:mul8u::@2/mul8u::@4->mul8u::@3]
  b3_from_b2:
  b3_from_b4:
  //SEG75 [45] phi (word) mul8u::res#6 = (word) mul8u::res#2 [phi:mul8u::@2/mul8u::@4->mul8u::@3#0] -- register_copy 
    jmp b3
  //SEG76 mul8u::@3
  b3:
  //SEG77 [46] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuz1=vbuz1_ror_1 
    lsr a
  //SEG78 [47] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vwuz1=vwuz1_rol_1 
    asl mb
    rol mb+1
  //SEG79 [39] phi from mul8u::@3 to mul8u::@1 [phi:mul8u::@3->mul8u::@1]
  b1_from_b3:
  //SEG80 [39] phi (word) mul8u::mb#2 = (word) mul8u::mb#1 [phi:mul8u::@3->mul8u::@1#0] -- register_copy 
  //SEG81 [39] phi (word) mul8u::res#2 = (word) mul8u::res#6 [phi:mul8u::@3->mul8u::@1#1] -- register_copy 
  //SEG82 [39] phi (byte) mul8u::a#2 = (byte) mul8u::a#0 [phi:mul8u::@3->mul8u::@1#2] -- register_copy 
    jmp b1
}
//SEG83 init
init: {
    .const toD0181_return = (>(screen&$3fff)*4)|(>charset)/4&$f
  //SEG84 [49] call init_sprites 
    jsr init_sprites
  //SEG85 [50] phi from init to init::@2 [phi:init->init::@2]
  b2_from_init:
    jmp b2
  //SEG86 init::@2
  b2:
  //SEG87 [51] call fill 
  //SEG88 [63] phi from init::@2 to fill [phi:init::@2->fill]
  fill_from_b2:
  //SEG89 [63] phi (byte) fill::val#3 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:init::@2->fill#0] -- vbuz1=vbuc1 
    lda #0
    sta fill.val
  //SEG90 [63] phi (byte*) fill::addr#0 = (const byte*) screen#0 [phi:init::@2->fill#1] -- pbuz1=pbuc1 
    lda #<screen
    sta fill.addr
    lda #>screen
    sta fill.addr+1
    jsr fill
  //SEG91 [52] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
    jmp b3
  //SEG92 init::@3
  b3:
  //SEG93 [53] call fill 
  //SEG94 [63] phi from init::@3 to fill [phi:init::@3->fill]
  fill_from_b3:
  //SEG95 [63] phi (byte) fill::val#3 = (const byte) BLACK#0 [phi:init::@3->fill#0] -- vbuz1=vbuc1 
    lda #BLACK
    sta fill.val
  //SEG96 [63] phi (byte*) fill::addr#0 = (const byte*) colors#0 [phi:init::@3->fill#1] -- pbuz1=pbuc1 
    lda #<colors
    sta fill.addr
    lda #>colors
    sta fill.addr+1
    jsr fill
  //SEG97 [54] phi from init::@3 to init::toD0181 [phi:init::@3->init::toD0181]
  toD0181_from_b3:
    jmp toD0181
  //SEG98 init::toD0181
  toD0181:
    jmp b1
  //SEG99 init::@1
  b1:
  //SEG100 [55] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG101 asm { lda#$5b sta$d011  }
    lda #$5b
    sta $d011
  //SEG102 [57] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG103 [58] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BGCOL1
  //SEG104 [59] *((const byte*) BGCOL2#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BGCOL2
  //SEG105 [60] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL3
  //SEG106 [61] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL4
    jmp breturn
  //SEG107 init::@return
  breturn:
  //SEG108 [62] return 
    rts
}
//SEG109 fill
// Fill some memory with a value
// fill(byte zeropage(9) val)
fill: {
    .label end = $1e
    .label addr = $a
    .label val = 9
  //SEG110 [64] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word/signed word/dword/signed dword) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda addr
    clc
    adc #<$3e8
    sta end
    lda addr+1
    adc #>$3e8
    sta end+1
  //SEG111 [65] phi from fill fill::@1 to fill::@1 [phi:fill/fill::@1->fill::@1]
  b1_from_fill:
  b1_from_b1:
  //SEG112 [65] phi (byte*) fill::addr#2 = (byte*) fill::addr#0 [phi:fill/fill::@1->fill::@1#0] -- register_copy 
    jmp b1
  //SEG113 fill::@1
  b1:
  //SEG114 [66] *((byte*) fill::addr#2) ← (byte) fill::val#3 -- _deref_pbuz1=vbuz2 
    lda val
    ldy #0
    sta (addr),y
  //SEG115 [67] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 -- pbuz1=_inc_pbuz1 
    inc addr
    bne !+
    inc addr+1
  !:
  //SEG116 [68] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 -- pbuz1_neq_pbuz2_then_la1 
    lda addr+1
    cmp end+1
    bne b1_from_b1
    lda addr
    cmp end
    bne b1_from_b1
    jmp breturn
  //SEG117 fill::@return
  breturn:
  //SEG118 [69] return 
    rts
}
//SEG119 init_sprites
init_sprites: {
  //SEG120 [70] *((const byte*) SPRITES_ENABLE#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta SPRITES_ENABLE
  //SEG121 [71] *((const byte*) SPRITES_EXPAND_X#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    // one sprite enabled
    lda #0
    sta SPRITES_EXPAND_X
  //SEG122 [72] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_EXPAND_Y
  //SEG123 [73] *((const byte*) SPRITES_XMSB#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_XMSB
  //SEG124 [74] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta SPRITES_COLS
  //SEG125 [75] *((const byte*) SPRITES_MC#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    jmp breturn
  //SEG126 init_sprites::@return
  breturn:
  //SEG127 [76] return 
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 [ main::x#4 main::y#2 main::z#0 ] ( main:2 [ main::x#4 main::y#2 main::z#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::x#4 main::x#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Statement [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte/signed byte/word/signed word/dword/signed dword) 2 [ draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:15 [ draw_block::x#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:16 [ draw_block::y#0 ]
Statement [20] (byte~) draw_block::$1 ← (byte) draw_block::x#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ draw_block::y#0 draw_block::tileno#1 draw_block::$1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::y#0 draw_block::tileno#1 draw_block::$1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:17 [ draw_block::tileno#1 ]
Statement [21] (word) draw_block::x1#0 ← ((word)) (byte~) draw_block::$1 [ draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ) always clobbers reg byte a 
Statement [22] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ) always clobbers reg byte a 
Statement [25] (word) mul8u::return#2 ← (word) mul8u::res#2 [ draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ) always clobbers reg byte a 
Statement [26] (word) draw_block::z#0 ← (word) mul8u::return#2 [ draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ) always clobbers reg byte a 
Statement [27] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 [ draw_block::tileno#1 draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [29] *((const byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [30] *((const byte*) colors#0 + (word) draw_block::z#1) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [32] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [33] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 2 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [34] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [35] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 3 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [36] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (const byte) YELLOW#0 [ ] ( main:2::draw_block:13 [ main::x#4 main::y#2 ] ) always clobbers reg byte a 
Statement [44] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 [ mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ( main:2::draw_block:13::mul8u:24 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
Statement [55] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement asm { lda#$5b sta$d011  } always clobbers reg byte a 
Statement [57] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [58] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [59] *((const byte*) BGCOL2#0) ← (const byte) RED#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [60] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [61] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [64] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word/signed word/dword/signed dword) $3e8 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::init:5::fill:51 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::init:5::fill:53 [ fill::addr#0 fill::val#3 fill::end#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ fill::val#3 ]
Statement [66] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::init:5::fill:51 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::init:5::fill:53 [ fill::val#3 fill::end#0 fill::addr#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:9 [ fill::val#3 ]
Statement [68] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::init:5::fill:51 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::init:5::fill:53 [ fill::val#3 fill::end#0 fill::addr#1 ] ) always clobbers reg byte a 
Statement [70] *((const byte*) SPRITES_ENABLE#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [71] *((const byte*) SPRITES_EXPAND_X#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [72] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [73] *((const byte*) SPRITES_XMSB#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [74] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [75] *((const byte*) SPRITES_MC#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 [ main::x#4 main::y#2 main::z#0 ] ( main:2 [ main::x#4 main::y#2 main::z#0 ] ) always clobbers reg byte a 
Statement [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte/signed byte/word/signed word/dword/signed dword) 2 [ draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ) always clobbers reg byte a 
Statement [20] (byte~) draw_block::$1 ← (byte) draw_block::x#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ draw_block::y#0 draw_block::tileno#1 draw_block::$1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::y#0 draw_block::tileno#1 draw_block::$1 ] ) always clobbers reg byte a 
Statement [21] (word) draw_block::x1#0 ← ((word)) (byte~) draw_block::$1 [ draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ) always clobbers reg byte a 
Statement [22] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 [ draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ) always clobbers reg byte a 
Statement [25] (word) mul8u::return#2 ← (word) mul8u::res#2 [ draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ) always clobbers reg byte a 
Statement [26] (word) draw_block::z#0 ← (word) mul8u::return#2 [ draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ) always clobbers reg byte a 
Statement [27] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 [ draw_block::tileno#1 draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [29] *((const byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [30] *((const byte*) colors#0 + (word) draw_block::z#1) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [31] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [32] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [33] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 2 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [34] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [35] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 3 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [36] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (const byte) YELLOW#0 [ ] ( main:2::draw_block:13 [ main::x#4 main::y#2 ] ) always clobbers reg byte a 
Statement [42] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte/signed byte/word/signed word/dword/signed dword) 1 [ mul8u::res#2 mul8u::a#2 mul8u::mb#2 mul8u::$1 ] ( main:2::draw_block:13::mul8u:24 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::res#2 mul8u::a#2 mul8u::mb#2 mul8u::$1 ] ) always clobbers reg byte a 
Statement [44] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 [ mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ( main:2::draw_block:13::mul8u:24 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ) always clobbers reg byte a 
Statement [55] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement asm { lda#$5b sta$d011  } always clobbers reg byte a 
Statement [57] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [58] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [59] *((const byte*) BGCOL2#0) ← (const byte) RED#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [60] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [61] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [64] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word/signed word/dword/signed dword) $3e8 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::init:5::fill:51 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::init:5::fill:53 [ fill::addr#0 fill::val#3 fill::end#0 ] ) always clobbers reg byte a 
Statement [66] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::init:5::fill:51 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::init:5::fill:53 [ fill::val#3 fill::end#0 fill::addr#2 ] ) always clobbers reg byte a reg byte y 
Statement [68] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::init:5::fill:51 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::init:5::fill:53 [ fill::val#3 fill::end#0 fill::addr#1 ] ) always clobbers reg byte a 
Statement [70] *((const byte*) SPRITES_ENABLE#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [71] *((const byte*) SPRITES_EXPAND_X#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [72] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [73] *((const byte*) SPRITES_XMSB#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [74] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Statement [75] *((const byte*) SPRITES_MC#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 [ ] ( main:2::init:5::init_sprites:49 [ ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::x#4 main::x#1 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ main::y#2 main::y#1 ] : zp ZP_BYTE:3 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] : zp ZP_WORD:5 , 
Potential registers zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] : zp ZP_WORD:7 , 
Potential registers zp ZP_BYTE:9 [ fill::val#3 ] : zp ZP_BYTE:9 , reg byte x , 
Potential registers zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ] : zp ZP_WORD:10 , 
Potential registers zp ZP_BYTE:12 [ main::z#0 ] : zp ZP_BYTE:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ main::tile#0 ] : zp ZP_BYTE:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:14 [ draw_block::tileno#0 ] : zp ZP_BYTE:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:15 [ draw_block::x#0 ] : zp ZP_BYTE:15 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:16 [ draw_block::y#0 ] : zp ZP_BYTE:16 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:17 [ draw_block::tileno#1 ] : zp ZP_BYTE:17 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:18 [ draw_block::$1 ] : zp ZP_BYTE:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:19 [ draw_block::x1#0 ] : zp ZP_WORD:19 , 
Potential registers zp ZP_BYTE:21 [ draw_block::y#1 ] : zp ZP_BYTE:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:22 [ mul8u::return#2 ] : zp ZP_WORD:22 , 
Potential registers zp ZP_WORD:24 [ draw_block::z#0 ] : zp ZP_WORD:24 , 
Potential registers zp ZP_WORD:26 [ draw_block::z#1 ] : zp ZP_WORD:26 , 
Potential registers zp ZP_BYTE:28 [ draw_block::drawtile#0 ] : zp ZP_BYTE:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:29 [ mul8u::$1 ] : zp ZP_BYTE:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:30 [ fill::end#0 ] : zp ZP_WORD:30 , 

REGISTER UPLIFT SCOPES
Uplift Scope [mul8u] 3,503.83: zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] 2,431: zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] 2,002: zp ZP_BYTE:29 [ mul8u::$1 ] 1,670.67: zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ] 4: zp ZP_WORD:22 [ mul8u::return#2 ] 
Uplift Scope [main] 209.21: zp ZP_BYTE:3 [ main::y#2 main::y#1 ] 202: zp ZP_BYTE:12 [ main::z#0 ] 202: zp ZP_BYTE:13 [ main::tile#0 ] 38.9: zp ZP_BYTE:2 [ main::x#4 main::x#1 ] 
Uplift Scope [draw_block] 34.33: zp ZP_BYTE:14 [ draw_block::tileno#0 ] 34.33: zp ZP_BYTE:15 [ draw_block::x#0 ] 25.75: zp ZP_BYTE:16 [ draw_block::y#0 ] 4: zp ZP_BYTE:18 [ draw_block::$1 ] 4: zp ZP_BYTE:21 [ draw_block::y#1 ] 4: zp ZP_WORD:24 [ draw_block::z#0 ] 4: zp ZP_BYTE:28 [ draw_block::drawtile#0 ] 2: zp ZP_WORD:26 [ draw_block::z#1 ] 0.67: zp ZP_WORD:19 [ draw_block::x1#0 ] 0.44: zp ZP_BYTE:17 [ draw_block::tileno#1 ] 
Uplift Scope [fill] 36: zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ] 2.6: zp ZP_WORD:30 [ fill::end#0 ] 1.83: zp ZP_BYTE:9 [ fill::val#3 ] 
Uplift Scope [init] 
Uplift Scope [init_sprites] 
Uplift Scope [] 

Uplifting [mul8u] best 92818 combination zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] reg byte a [ mul8u::$1 ] reg byte x [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ] zp ZP_WORD:22 [ mul8u::return#2 ] 
Uplifting [main] best 91818 combination zp ZP_BYTE:3 [ main::y#2 main::y#1 ] reg byte a [ main::z#0 ] reg byte a [ main::tile#0 ] zp ZP_BYTE:2 [ main::x#4 main::x#1 ] 
Limited combination testing to 100 combinations of 144 possible.
Uplifting [draw_block] best 90907 combination reg byte a [ draw_block::tileno#0 ] reg byte y [ draw_block::x#0 ] reg byte x [ draw_block::y#0 ] reg byte a [ draw_block::$1 ] zp ZP_BYTE:21 [ draw_block::y#1 ] zp ZP_WORD:24 [ draw_block::z#0 ] zp ZP_BYTE:28 [ draw_block::drawtile#0 ] zp ZP_WORD:26 [ draw_block::z#1 ] zp ZP_WORD:19 [ draw_block::x1#0 ] zp ZP_BYTE:17 [ draw_block::tileno#1 ] 
Limited combination testing to 100 combinations of 6912 possible.
Uplifting [fill] best 90891 combination zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ] zp ZP_WORD:30 [ fill::end#0 ] reg byte x [ fill::val#3 ] 
Uplifting [init] best 90891 combination 
Uplifting [init_sprites] best 90891 combination 
Uplifting [] best 90891 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Uplifting [main] best 90891 combination zp ZP_BYTE:3 [ main::y#2 main::y#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ main::x#4 main::x#1 ]
Uplifting [main] best 90891 combination zp ZP_BYTE:2 [ main::x#4 main::x#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:21 [ draw_block::y#1 ]
Uplifting [draw_block] best 90887 combination reg byte a [ draw_block::y#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:28 [ draw_block::drawtile#0 ]
Uplifting [draw_block] best 90881 combination reg byte a [ draw_block::drawtile#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:17 [ draw_block::tileno#1 ]
Uplifting [draw_block] best 90881 combination zp ZP_BYTE:17 [ draw_block::tileno#1 ] 
Coalescing zero page register with common assignment [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] ] with [ zp ZP_WORD:22 [ mul8u::return#2 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:19 [ draw_block::x1#0 ] ] with [ zp ZP_WORD:26 [ draw_block::z#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 ] ] with [ zp ZP_WORD:24 [ draw_block::z#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 ] ] with [ zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ] ]
Coalescing zero page register [ zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] ] with [ zp ZP_WORD:30 [ fill::end#0 ] ]
Allocated (was zp ZP_WORD:5) zp ZP_WORD:4 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 ]
Allocated (was zp ZP_WORD:7) zp ZP_WORD:6 [ mul8u::mb#2 mul8u::mb#1 fill::end#0 ]
Allocated (was zp ZP_BYTE:17) zp ZP_BYTE:8 [ draw_block::tileno#1 ]
Allocated (was zp ZP_WORD:19) zp ZP_WORD:9 [ draw_block::x1#0 draw_block::z#1 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Illustrates a problem with a missing fragment - pbuc1_derefidx_vwuz1=vbuz2
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XMSB = $d010
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label BORDERCOL = $d020
  .label BGCOL1 = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label BGCOL4 = $d024
  .label SPRITES_COLS = $d027
  .label D018 = $d018
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  .const BLUE = 6
  .const YELLOW = 7
  .label screen = $400
  .label charset = $2000
  .label tileset = $2800
  .label colors = $d800
  .label level_address = $3000
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
    .label y = 3
    .label x = 2
  //SEG11 [5] call init 
  //SEG12 [48] phi from main to init [phi:main->init]
  init_from_main:
    jsr init
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG14 [6] phi (byte) main::x#4 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x
    jmp b1
  //SEG15 [6] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  b1_from_b3:
  //SEG16 [6] phi (byte) main::x#4 = (byte) main::x#1 [phi:main::@3->main::@1#0] -- register_copy 
    jmp b1
  //SEG17 main::@1
  b1:
  //SEG18 [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
  //SEG19 [7] phi (byte) main::y#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    jmp b2
  //SEG20 [7] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  b2_from_b5:
  //SEG21 [7] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@5->main::@2#0] -- register_copy 
    jmp b2
  //SEG22 main::@2
  b2:
  //SEG23 [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 -- vbuaa=vbuz1_plus_vbuz2 
    lda x
    clc
    adc y
  //SEG24 [9] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0) -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda level_address,y
  //SEG25 [10] (byte) draw_block::tileno#0 ← (byte) main::tile#0
  //SEG26 [11] (byte) draw_block::x#0 ← (byte) main::x#4 -- vbuyy=vbuz1 
    ldy x
  //SEG27 [12] (byte) draw_block::y#0 ← (byte) main::y#2 -- vbuxx=vbuz1 
    ldx y
  //SEG28 [13] call draw_block 
    jsr draw_block
    jmp b5
  //SEG29 main::@5
  b5:
  //SEG30 [14] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc y
  //SEG31 [15] if((byte) main::y#1<(byte/signed byte/word/signed word/dword/signed dword) 9) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda y
    cmp #9
    bcc b2_from_b5
    jmp b3
  //SEG32 main::@3
  b3:
  //SEG33 [16] (byte) main::x#1 ← ++ (byte) main::x#4 -- vbuz1=_inc_vbuz1 
    inc x
  //SEG34 [17] if((byte) main::x#1<(byte/signed byte/word/signed word/dword/signed dword) $10) goto main::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda x
    cmp #$10
    bcc b1_from_b3
  //SEG35 [18] phi from main::@3 main::@4 to main::@4 [phi:main::@3/main::@4->main::@4]
  b4_from_b3:
  b4_from_b4:
    jmp b4
  //SEG36 main::@4
  b4:
    jmp b4_from_b4
}
//SEG37 draw_block
// draw_block(byte register(A) tileno, byte register(Y) x, byte register(X) y)
draw_block: {
    .label tileno = 8
    .label x1 = 9
    .label z = 4
    .label z_1 = 9
  //SEG38 [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte/signed byte/word/signed word/dword/signed dword) 2 -- vbuz1=vbuaa_rol_2 
    asl
    asl
    sta tileno
  //SEG39 [20] (byte~) draw_block::$1 ← (byte) draw_block::x#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuaa=vbuyy_rol_1 
    tya
    asl
  //SEG40 [21] (word) draw_block::x1#0 ← ((word)) (byte~) draw_block::$1 -- vwuz1=_word_vbuaa 
    sta x1
    lda #0
    sta x1+1
  //SEG41 [22] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG42 [23] (byte) mul8u::a#1 ← (byte) draw_block::y#1 -- vbuxx=vbuaa 
    tax
  //SEG43 [24] call mul8u 
  //SEG44 [38] phi from draw_block to mul8u [phi:draw_block->mul8u]
  mul8u_from_draw_block:
    jsr mul8u
  //SEG45 [25] (word) mul8u::return#2 ← (word) mul8u::res#2
    jmp b1
  //SEG46 draw_block::@1
  b1:
  //SEG47 [26] (word) draw_block::z#0 ← (word) mul8u::return#2
  //SEG48 [27] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 -- vwuz1=vwuz2_plus_vwuz1 
    lda z_1
    clc
    adc z
    sta z_1
    lda z_1+1
    adc z+1
    sta z_1+1
  //SEG49 [28] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy tileno
    lda tileset,y
  //SEG50 [29] *((const byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0 -- pbuc1_derefidx_vwuz1=vbuaa 
    sta !v++1
    lda #<screen
    clc
    adc z_1
    sta !a++1
    lda #>screen
    adc z_1+1
    sta !a++2
  !v:
    lda #0
  !a:
    sta screen
  //SEG51 [30] *((const byte*) colors#0 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors
    clc
    adc z_1
    sta !++1
    lda #>colors
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors
  //SEG52 [31] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<screen+1
    clc
    adc z_1
    sta !++1
    lda #>screen+1
    adc z_1+1
    sta !++2
    lda #1
  !:
    sta screen+1
  //SEG53 [32] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors+1
    clc
    adc z_1
    sta !++1
    lda #>colors+1
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors+1
  //SEG54 [33] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 2 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<screen+$28
    clc
    adc z_1
    sta !++1
    lda #>screen+$28
    adc z_1+1
    sta !++2
    lda #2
  !:
    sta screen+$28
  //SEG55 [34] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors+$28
    clc
    adc z_1
    sta !++1
    lda #>colors+$28
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors+$28
  //SEG56 [35] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 3 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<screen+$29
    clc
    adc z_1
    sta !++1
    lda #>screen+$29
    adc z_1+1
    sta !++2
    lda #3
  !:
    sta screen+$29
  //SEG57 [36] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors+$29
    clc
    adc z_1
    sta !++1
    lda #>colors+$29
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors+$29
    jmp breturn
  //SEG58 draw_block::@return
  breturn:
  //SEG59 [37] return 
    rts
}
//SEG60 mul8u
// Perform binary multiplication of two unsigned 8-bit bytes into a 16-bit unsigned word
// mul8u(byte register(X) a)
mul8u: {
    .const b = $28
    .label mb = 6
    .label res = 4
    .label return = 4
  //SEG61 [39] phi from mul8u to mul8u::@1 [phi:mul8u->mul8u::@1]
  b1_from_mul8u:
  //SEG62 [39] phi (word) mul8u::mb#2 = ((word))(const byte) mul8u::b#0 [phi:mul8u->mul8u::@1#0] -- vwuz1=vbuc1 
    lda #b
    sta mb
    lda #0
    sta mb+1
  //SEG63 [39] phi (word) mul8u::res#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:mul8u->mul8u::@1#1] -- vwuz1=vbuc1 
    lda #0
    sta res
    lda #0
    sta res+1
  //SEG64 [39] phi (byte) mul8u::a#2 = (byte) mul8u::a#1 [phi:mul8u->mul8u::@1#2] -- register_copy 
    jmp b1
  //SEG65 mul8u::@1
  b1:
  //SEG66 [40] if((byte) mul8u::a#2!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@2 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b2
    jmp breturn
  //SEG67 mul8u::@return
  breturn:
  //SEG68 [41] return 
    rts
  //SEG69 mul8u::@2
  b2:
  //SEG70 [42] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
  //SEG71 [43] if((byte~) mul8u::$1==(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b3_from_b2
    jmp b4
  //SEG72 mul8u::@4
  b4:
  //SEG73 [44] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 -- vwuz1=vwuz1_plus_vwuz2 
    lda res
    clc
    adc mb
    sta res
    lda res+1
    adc mb+1
    sta res+1
  //SEG74 [45] phi from mul8u::@2 mul8u::@4 to mul8u::@3 [phi:mul8u::@2/mul8u::@4->mul8u::@3]
  b3_from_b2:
  b3_from_b4:
  //SEG75 [45] phi (word) mul8u::res#6 = (word) mul8u::res#2 [phi:mul8u::@2/mul8u::@4->mul8u::@3#0] -- register_copy 
    jmp b3
  //SEG76 mul8u::@3
  b3:
  //SEG77 [46] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuxx=vbuxx_ror_1 
    txa
    lsr
    tax
  //SEG78 [47] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vwuz1=vwuz1_rol_1 
    asl mb
    rol mb+1
  //SEG79 [39] phi from mul8u::@3 to mul8u::@1 [phi:mul8u::@3->mul8u::@1]
  b1_from_b3:
  //SEG80 [39] phi (word) mul8u::mb#2 = (word) mul8u::mb#1 [phi:mul8u::@3->mul8u::@1#0] -- register_copy 
  //SEG81 [39] phi (word) mul8u::res#2 = (word) mul8u::res#6 [phi:mul8u::@3->mul8u::@1#1] -- register_copy 
  //SEG82 [39] phi (byte) mul8u::a#2 = (byte) mul8u::a#0 [phi:mul8u::@3->mul8u::@1#2] -- register_copy 
    jmp b1
}
//SEG83 init
init: {
    .const toD0181_return = (>(screen&$3fff)*4)|(>charset)/4&$f
  //SEG84 [49] call init_sprites 
    jsr init_sprites
  //SEG85 [50] phi from init to init::@2 [phi:init->init::@2]
  b2_from_init:
    jmp b2
  //SEG86 init::@2
  b2:
  //SEG87 [51] call fill 
  //SEG88 [63] phi from init::@2 to fill [phi:init::@2->fill]
  fill_from_b2:
  //SEG89 [63] phi (byte) fill::val#3 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:init::@2->fill#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG90 [63] phi (byte*) fill::addr#0 = (const byte*) screen#0 [phi:init::@2->fill#1] -- pbuz1=pbuc1 
    lda #<screen
    sta fill.addr
    lda #>screen
    sta fill.addr+1
    jsr fill
  //SEG91 [52] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
    jmp b3
  //SEG92 init::@3
  b3:
  //SEG93 [53] call fill 
  //SEG94 [63] phi from init::@3 to fill [phi:init::@3->fill]
  fill_from_b3:
  //SEG95 [63] phi (byte) fill::val#3 = (const byte) BLACK#0 [phi:init::@3->fill#0] -- vbuxx=vbuc1 
    ldx #BLACK
  //SEG96 [63] phi (byte*) fill::addr#0 = (const byte*) colors#0 [phi:init::@3->fill#1] -- pbuz1=pbuc1 
    lda #<colors
    sta fill.addr
    lda #>colors
    sta fill.addr+1
    jsr fill
  //SEG97 [54] phi from init::@3 to init::toD0181 [phi:init::@3->init::toD0181]
  toD0181_from_b3:
    jmp toD0181
  //SEG98 init::toD0181
  toD0181:
    jmp b1
  //SEG99 init::@1
  b1:
  //SEG100 [55] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG101 asm { lda#$5b sta$d011  }
    lda #$5b
    sta $d011
  //SEG102 [57] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG103 [58] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BGCOL1
  //SEG104 [59] *((const byte*) BGCOL2#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BGCOL2
  //SEG105 [60] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL3
  //SEG106 [61] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL4
    jmp breturn
  //SEG107 init::@return
  breturn:
  //SEG108 [62] return 
    rts
}
//SEG109 fill
// Fill some memory with a value
// fill(byte register(X) val)
fill: {
    .label end = 6
    .label addr = 4
  //SEG110 [64] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word/signed word/dword/signed dword) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda addr
    clc
    adc #<$3e8
    sta end
    lda addr+1
    adc #>$3e8
    sta end+1
  //SEG111 [65] phi from fill fill::@1 to fill::@1 [phi:fill/fill::@1->fill::@1]
  b1_from_fill:
  b1_from_b1:
  //SEG112 [65] phi (byte*) fill::addr#2 = (byte*) fill::addr#0 [phi:fill/fill::@1->fill::@1#0] -- register_copy 
    jmp b1
  //SEG113 fill::@1
  b1:
  //SEG114 [66] *((byte*) fill::addr#2) ← (byte) fill::val#3 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (addr),y
  //SEG115 [67] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 -- pbuz1=_inc_pbuz1 
    inc addr
    bne !+
    inc addr+1
  !:
  //SEG116 [68] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 -- pbuz1_neq_pbuz2_then_la1 
    lda addr+1
    cmp end+1
    bne b1_from_b1
    lda addr
    cmp end
    bne b1_from_b1
    jmp breturn
  //SEG117 fill::@return
  breturn:
  //SEG118 [69] return 
    rts
}
//SEG119 init_sprites
init_sprites: {
  //SEG120 [70] *((const byte*) SPRITES_ENABLE#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta SPRITES_ENABLE
  //SEG121 [71] *((const byte*) SPRITES_EXPAND_X#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    // one sprite enabled
    lda #0
    sta SPRITES_EXPAND_X
  //SEG122 [72] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_EXPAND_Y
  //SEG123 [73] *((const byte*) SPRITES_XMSB#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_XMSB
  //SEG124 [74] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta SPRITES_COLS
  //SEG125 [75] *((const byte*) SPRITES_MC#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    jmp breturn
  //SEG126 init_sprites::@return
  breturn:
  //SEG127 [76] return 
    rts
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b4
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp toD0181
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #BLACK
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b2_from_b5 with b2
Replacing label b1_from_b3 with b1
Replacing label b4_from_b4 with b4
Replacing label b3_from_b2 with b3
Replacing label b1_from_b1 with b1
Replacing label b1_from_b1 with b1
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_b3:
Removing instruction b2_from_b1:
Removing instruction b2_from_b5:
Removing instruction b4_from_b3:
Removing instruction b4_from_b4:
Removing instruction b3_from_b2:
Removing instruction b3_from_b4:
Removing instruction b2_from_init:
Removing instruction fill_from_b2:
Removing instruction b3_from_b2:
Removing instruction fill_from_b3:
Removing instruction toD0181_from_b3:
Removing instruction toD0181:
Removing instruction b1_from_fill:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction init_from_main:
Removing instruction b1_from_main:
Removing instruction b5:
Removing instruction b3:
Removing instruction mul8u_from_draw_block:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_mul8u:
Removing instruction breturn:
Removing instruction b4:
Removing instruction b1_from_b3:
Removing instruction b2:
Removing instruction b3:
Removing instruction b1:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Removing instruction jmp b2
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) BGCOL1
(const byte*) BGCOL1#0 BGCOL1 = ((byte*))(word/dword/signed dword) $d021
(byte*) BGCOL2
(const byte*) BGCOL2#0 BGCOL2 = ((byte*))(word/dword/signed dword) $d022
(byte*) BGCOL3
(const byte*) BGCOL3#0 BGCOL3 = ((byte*))(word/dword/signed dword) $d023
(byte*) BGCOL4
(const byte*) BGCOL4#0 BGCOL4 = ((byte*))(word/dword/signed dword) $d024
(byte) BLACK
(const byte) BLACK#0 BLACK = (byte/signed byte/word/signed word/dword/signed dword) 0
(byte) BLUE
(const byte) BLUE#0 BLUE = (byte/signed byte/word/signed word/dword/signed dword) 6
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = ((byte*))(word/dword/signed dword) $d020
(byte*) D018
(const byte*) D018#0 D018 = ((byte*))(word/dword/signed dword) $d018
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte/signed byte/word/signed word/dword/signed dword) 5
(byte) RED
(const byte) RED#0 RED = (byte/signed byte/word/signed word/dword/signed dword) 2
(byte*) SPRITES_COLS
(const byte*) SPRITES_COLS#0 SPRITES_COLS = ((byte*))(word/dword/signed dword) $d027
(byte*) SPRITES_ENABLE
(const byte*) SPRITES_ENABLE#0 SPRITES_ENABLE = ((byte*))(word/dword/signed dword) $d015
(byte*) SPRITES_EXPAND_X
(const byte*) SPRITES_EXPAND_X#0 SPRITES_EXPAND_X = ((byte*))(word/dword/signed dword) $d01d
(byte*) SPRITES_EXPAND_Y
(const byte*) SPRITES_EXPAND_Y#0 SPRITES_EXPAND_Y = ((byte*))(word/dword/signed dword) $d017
(byte*) SPRITES_MC
(const byte*) SPRITES_MC#0 SPRITES_MC = ((byte*))(word/dword/signed dword) $d01c
(byte*) SPRITES_XMSB
(const byte*) SPRITES_XMSB#0 SPRITES_XMSB = ((byte*))(word/dword/signed dword) $d010
(byte) WHITE
(const byte) WHITE#0 WHITE = (byte/signed byte/word/signed word/dword/signed dword) 1
(byte) YELLOW
(const byte) YELLOW#0 YELLOW = (byte/signed byte/word/signed word/dword/signed dword) 7
(byte*) charset
(const byte*) charset#0 charset = ((byte*))(word/signed word/dword/signed dword) $2000
(byte*) colors
(const byte*) colors#0 colors = ((byte*))(word/dword/signed dword) $d800
(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
(byte~) draw_block::$1 reg byte a 4.0
(label) draw_block::@1
(label) draw_block::@return
(byte) draw_block::color
(byte) draw_block::drawtile
(byte) draw_block::drawtile#0 reg byte a 4.0
(byte) draw_block::tileno
(byte) draw_block::tileno#0 reg byte a 34.33333333333333
(byte) draw_block::tileno#1 tileno zp ZP_BYTE:8 0.4444444444444444
(byte) draw_block::x
(byte) draw_block::x#0 reg byte y 34.33333333333333
(word) draw_block::x1
(word) draw_block::x1#0 x1 zp ZP_WORD:9 0.6666666666666666
(byte) draw_block::y
(byte) draw_block::y#0 reg byte x 25.75
(byte) draw_block::y#1 reg byte a 4.0
(word) draw_block::z
(word) draw_block::z#0 z zp ZP_WORD:4 4.0
(word) draw_block::z#1 z#1 zp ZP_WORD:9 2.0000000000000004
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(label) fill::@1
(label) fill::@return
(byte*) fill::addr
(byte*) fill::addr#0 addr zp ZP_WORD:4 2.0
(byte*) fill::addr#1 addr zp ZP_WORD:4 16.5
(byte*) fill::addr#2 addr zp ZP_WORD:4 17.5
(byte*) fill::end
(byte*) fill::end#0 end zp ZP_WORD:6 2.6
(word) fill::size
(byte*) fill::start
(byte) fill::val
(byte) fill::val#3 reg byte x 1.8333333333333333
(void()) init()
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@return
(label) init::toD0181
(word~) init::toD0181_$0
(word~) init::toD0181_$1
(word/signed dword/dword~) init::toD0181_$2
(byte/word~) init::toD0181_$3
(word~) init::toD0181_$4
(byte~) init::toD0181_$5
(byte/signed word/word/dword/signed dword~) init::toD0181_$6
(byte/word/dword~) init::toD0181_$7
(byte/word/dword~) init::toD0181_$8
(byte*) init::toD0181_gfx
(byte) init::toD0181_return
(const byte) init::toD0181_return#0 toD0181_return = >((word))(const byte*) screen#0&(word/signed word/dword/signed dword) $3fff*(byte/signed byte/word/signed word/dword/signed dword) 4|>((word))(const byte*) charset#0/(byte/signed byte/word/signed word/dword/signed dword) 4&(byte/signed byte/word/signed word/dword/signed dword) $f
(byte*) init::toD0181_screen
(void()) init_sprites()
(label) init_sprites::@return
(byte*) level_address
(const byte*) level_address#0 level_address = ((byte*))(word/signed word/dword/signed dword) $3000
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(byte) main::tile
(byte) main::tile#0 reg byte a 202.0
(byte) main::x
(byte) main::x#1 x zp ZP_BYTE:2 16.5
(byte) main::x#4 x zp ZP_BYTE:2 22.4
(byte) main::y
(byte) main::y#1 y zp ZP_BYTE:3 151.5
(byte) main::y#2 y zp ZP_BYTE:3 57.714285714285715
(byte) main::z
(byte) main::z#0 reg byte a 202.0
(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
(byte~) mul8u::$1 reg byte a 2002.0
(label) mul8u::@1
(label) mul8u::@2
(label) mul8u::@3
(label) mul8u::@4
(label) mul8u::@return
(byte) mul8u::a
(byte) mul8u::a#0 reg byte x 1001.0
(byte) mul8u::a#1 reg byte x 2.0
(byte) mul8u::a#2 reg byte x 667.6666666666667
(byte) mul8u::b
(const byte) mul8u::b#0 b = (byte/signed byte/word/signed word/dword/signed dword) $28
(word) mul8u::mb
(word) mul8u::mb#1 mb zp ZP_WORD:6 2002.0
(word) mul8u::mb#2 mb zp ZP_WORD:6 429.0
(word) mul8u::res
(word) mul8u::res#1 res zp ZP_WORD:4 2002.0
(word) mul8u::res#2 res zp ZP_WORD:4 500.83333333333337
(word) mul8u::res#6 res zp ZP_WORD:4 1001.0
(word) mul8u::return
(word) mul8u::return#2 return zp ZP_WORD:4 4.0
(byte*) screen
(const byte*) screen#0 screen = ((byte*))(word/signed word/dword/signed dword) $400
(byte*) tileset
(const byte*) tileset#0 tileset = ((byte*))(word/signed word/dword/signed dword) $2800

zp ZP_BYTE:2 [ main::x#4 main::x#1 ]
zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
reg byte x [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
zp ZP_WORD:4 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 ]
zp ZP_WORD:6 [ mul8u::mb#2 mul8u::mb#1 fill::end#0 ]
reg byte x [ fill::val#3 ]
reg byte a [ main::z#0 ]
reg byte a [ main::tile#0 ]
reg byte a [ draw_block::tileno#0 ]
reg byte y [ draw_block::x#0 ]
reg byte x [ draw_block::y#0 ]
zp ZP_BYTE:8 [ draw_block::tileno#1 ]
reg byte a [ draw_block::$1 ]
zp ZP_WORD:9 [ draw_block::x1#0 draw_block::z#1 ]
reg byte a [ draw_block::y#1 ]
reg byte a [ draw_block::drawtile#0 ]
reg byte a [ mul8u::$1 ]


FINAL ASSEMBLER
Score: 73438

//SEG0 File Comments
// Illustrates a problem with a missing fragment - pbuc1_derefidx_vwuz1=vbuz2
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XMSB = $d010
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label BORDERCOL = $d020
  .label BGCOL1 = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label BGCOL4 = $d024
  .label SPRITES_COLS = $d027
  .label D018 = $d018
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  .const BLUE = 6
  .const YELLOW = 7
  .label screen = $400
  .label charset = $2000
  .label tileset = $2800
  .label colors = $d800
  .label level_address = $3000
//SEG3 @begin
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
//SEG5 @1
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
//SEG9 @end
//SEG10 main
main: {
    .label y = 3
    .label x = 2
  //SEG11 [5] call init 
  //SEG12 [48] phi from main to init [phi:main->init]
    jsr init
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  //SEG14 [6] phi (byte) main::x#4 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x
  //SEG15 [6] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  //SEG16 [6] phi (byte) main::x#4 = (byte) main::x#1 [phi:main::@3->main::@1#0] -- register_copy 
  //SEG17 main::@1
  b1:
  //SEG18 [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  //SEG19 [7] phi (byte) main::y#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta y
  //SEG20 [7] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  //SEG21 [7] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@5->main::@2#0] -- register_copy 
  //SEG22 main::@2
  b2:
  //SEG23 [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 -- vbuaa=vbuz1_plus_vbuz2 
    lda x
    clc
    adc y
  //SEG24 [9] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0) -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda level_address,y
  //SEG25 [10] (byte) draw_block::tileno#0 ← (byte) main::tile#0
  //SEG26 [11] (byte) draw_block::x#0 ← (byte) main::x#4 -- vbuyy=vbuz1 
    ldy x
  //SEG27 [12] (byte) draw_block::y#0 ← (byte) main::y#2 -- vbuxx=vbuz1 
    ldx y
  //SEG28 [13] call draw_block 
    jsr draw_block
  //SEG29 main::@5
  //SEG30 [14] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc y
  //SEG31 [15] if((byte) main::y#1<(byte/signed byte/word/signed word/dword/signed dword) 9) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda y
    cmp #9
    bcc b2
  //SEG32 main::@3
  //SEG33 [16] (byte) main::x#1 ← ++ (byte) main::x#4 -- vbuz1=_inc_vbuz1 
    inc x
  //SEG34 [17] if((byte) main::x#1<(byte/signed byte/word/signed word/dword/signed dword) $10) goto main::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda x
    cmp #$10
    bcc b1
  //SEG35 [18] phi from main::@3 main::@4 to main::@4 [phi:main::@3/main::@4->main::@4]
  //SEG36 main::@4
  b4:
    jmp b4
}
//SEG37 draw_block
// draw_block(byte register(A) tileno, byte register(Y) x, byte register(X) y)
draw_block: {
    .label tileno = 8
    .label x1 = 9
    .label z = 4
    .label z_1 = 9
  //SEG38 [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte/signed byte/word/signed word/dword/signed dword) 2 -- vbuz1=vbuaa_rol_2 
    asl
    asl
    sta tileno
  //SEG39 [20] (byte~) draw_block::$1 ← (byte) draw_block::x#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuaa=vbuyy_rol_1 
    tya
    asl
  //SEG40 [21] (word) draw_block::x1#0 ← ((word)) (byte~) draw_block::$1 -- vwuz1=_word_vbuaa 
    sta x1
    lda #0
    sta x1+1
  //SEG41 [22] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG42 [23] (byte) mul8u::a#1 ← (byte) draw_block::y#1 -- vbuxx=vbuaa 
    tax
  //SEG43 [24] call mul8u 
  //SEG44 [38] phi from draw_block to mul8u [phi:draw_block->mul8u]
    jsr mul8u
  //SEG45 [25] (word) mul8u::return#2 ← (word) mul8u::res#2
  //SEG46 draw_block::@1
  //SEG47 [26] (word) draw_block::z#0 ← (word) mul8u::return#2
  //SEG48 [27] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 -- vwuz1=vwuz2_plus_vwuz1 
    lda z_1
    clc
    adc z
    sta z_1
    lda z_1+1
    adc z+1
    sta z_1+1
  //SEG49 [28] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy tileno
    lda tileset,y
  //SEG50 [29] *((const byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0 -- pbuc1_derefidx_vwuz1=vbuaa 
    sta !v++1
    lda #<screen
    clc
    adc z_1
    sta !a++1
    lda #>screen
    adc z_1+1
    sta !a++2
  !v:
    lda #0
  !a:
    sta screen
  //SEG51 [30] *((const byte*) colors#0 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors
    clc
    adc z_1
    sta !++1
    lda #>colors
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors
  //SEG52 [31] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<screen+1
    clc
    adc z_1
    sta !++1
    lda #>screen+1
    adc z_1+1
    sta !++2
    lda #1
  !:
    sta screen+1
  //SEG53 [32] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) 1 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors+1
    clc
    adc z_1
    sta !++1
    lda #>colors+1
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors+1
  //SEG54 [33] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 2 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<screen+$28
    clc
    adc z_1
    sta !++1
    lda #>screen+$28
    adc z_1+1
    sta !++2
    lda #2
  !:
    sta screen+$28
  //SEG55 [34] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $28 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors+$28
    clc
    adc z_1
    sta !++1
    lda #>colors+$28
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors+$28
  //SEG56 [35] *((const byte*) screen#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (byte/signed byte/word/signed word/dword/signed dword) 3 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<screen+$29
    clc
    adc z_1
    sta !++1
    lda #>screen+$29
    adc z_1+1
    sta !++2
    lda #3
  !:
    sta screen+$29
  //SEG57 [36] *((const byte*) colors#0+(byte/signed byte/word/signed word/dword/signed dword) $29 + (word) draw_block::z#1) ← (const byte) YELLOW#0 -- pbuc1_derefidx_vwuz1=vbuc2 
    lda #<colors+$29
    clc
    adc z_1
    sta !++1
    lda #>colors+$29
    adc z_1+1
    sta !++2
    lda #YELLOW
  !:
    sta colors+$29
  //SEG58 draw_block::@return
  //SEG59 [37] return 
    rts
}
//SEG60 mul8u
// Perform binary multiplication of two unsigned 8-bit bytes into a 16-bit unsigned word
// mul8u(byte register(X) a)
mul8u: {
    .const b = $28
    .label mb = 6
    .label res = 4
    .label return = 4
  //SEG61 [39] phi from mul8u to mul8u::@1 [phi:mul8u->mul8u::@1]
  //SEG62 [39] phi (word) mul8u::mb#2 = ((word))(const byte) mul8u::b#0 [phi:mul8u->mul8u::@1#0] -- vwuz1=vbuc1 
    lda #b
    sta mb
    lda #0
    sta mb+1
  //SEG63 [39] phi (word) mul8u::res#2 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:mul8u->mul8u::@1#1] -- vwuz1=vbuc1 
    sta res
    sta res+1
  //SEG64 [39] phi (byte) mul8u::a#2 = (byte) mul8u::a#1 [phi:mul8u->mul8u::@1#2] -- register_copy 
  //SEG65 mul8u::@1
  b1:
  //SEG66 [40] if((byte) mul8u::a#2!=(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@2 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b2
  //SEG67 mul8u::@return
  //SEG68 [41] return 
    rts
  //SEG69 mul8u::@2
  b2:
  //SEG70 [42] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
  //SEG71 [43] if((byte~) mul8u::$1==(byte/signed byte/word/signed word/dword/signed dword) 0) goto mul8u::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b3
  //SEG72 mul8u::@4
  //SEG73 [44] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 -- vwuz1=vwuz1_plus_vwuz2 
    lda res
    clc
    adc mb
    sta res
    lda res+1
    adc mb+1
    sta res+1
  //SEG74 [45] phi from mul8u::@2 mul8u::@4 to mul8u::@3 [phi:mul8u::@2/mul8u::@4->mul8u::@3]
  //SEG75 [45] phi (word) mul8u::res#6 = (word) mul8u::res#2 [phi:mul8u::@2/mul8u::@4->mul8u::@3#0] -- register_copy 
  //SEG76 mul8u::@3
  b3:
  //SEG77 [46] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte/signed byte/word/signed word/dword/signed dword) 1 -- vbuxx=vbuxx_ror_1 
    txa
    lsr
    tax
  //SEG78 [47] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte/signed byte/word/signed word/dword/signed dword) 1 -- vwuz1=vwuz1_rol_1 
    asl mb
    rol mb+1
  //SEG79 [39] phi from mul8u::@3 to mul8u::@1 [phi:mul8u::@3->mul8u::@1]
  //SEG80 [39] phi (word) mul8u::mb#2 = (word) mul8u::mb#1 [phi:mul8u::@3->mul8u::@1#0] -- register_copy 
  //SEG81 [39] phi (word) mul8u::res#2 = (word) mul8u::res#6 [phi:mul8u::@3->mul8u::@1#1] -- register_copy 
  //SEG82 [39] phi (byte) mul8u::a#2 = (byte) mul8u::a#0 [phi:mul8u::@3->mul8u::@1#2] -- register_copy 
    jmp b1
}
//SEG83 init
init: {
    .const toD0181_return = (>(screen&$3fff)*4)|(>charset)/4&$f
  //SEG84 [49] call init_sprites 
    jsr init_sprites
  //SEG85 [50] phi from init to init::@2 [phi:init->init::@2]
  //SEG86 init::@2
  //SEG87 [51] call fill 
  //SEG88 [63] phi from init::@2 to fill [phi:init::@2->fill]
  //SEG89 [63] phi (byte) fill::val#3 = (byte/signed byte/word/signed word/dword/signed dword) 0 [phi:init::@2->fill#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG90 [63] phi (byte*) fill::addr#0 = (const byte*) screen#0 [phi:init::@2->fill#1] -- pbuz1=pbuc1 
    lda #<screen
    sta fill.addr
    lda #>screen
    sta fill.addr+1
    jsr fill
  //SEG91 [52] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  //SEG92 init::@3
  //SEG93 [53] call fill 
  //SEG94 [63] phi from init::@3 to fill [phi:init::@3->fill]
  //SEG95 [63] phi (byte) fill::val#3 = (const byte) BLACK#0 [phi:init::@3->fill#0] -- vbuxx=vbuc1 
    ldx #BLACK
  //SEG96 [63] phi (byte*) fill::addr#0 = (const byte*) colors#0 [phi:init::@3->fill#1] -- pbuz1=pbuc1 
    lda #<colors
    sta fill.addr
    lda #>colors
    sta fill.addr+1
    jsr fill
  //SEG97 [54] phi from init::@3 to init::toD0181 [phi:init::@3->init::toD0181]
  //SEG98 init::toD0181
  //SEG99 init::@1
  //SEG100 [55] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG101 asm { lda#$5b sta$d011  }
    lda #$5b
    sta $d011
  //SEG102 [57] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG103 [58] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    sta BGCOL1
  //SEG104 [59] *((const byte*) BGCOL2#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BGCOL2
  //SEG105 [60] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL3
  //SEG106 [61] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL4
  //SEG107 init::@return
  //SEG108 [62] return 
    rts
}
//SEG109 fill
// Fill some memory with a value
// fill(byte register(X) val)
fill: {
    .label end = 6
    .label addr = 4
  //SEG110 [64] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word/signed word/dword/signed dword) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda addr
    clc
    adc #<$3e8
    sta end
    lda addr+1
    adc #>$3e8
    sta end+1
  //SEG111 [65] phi from fill fill::@1 to fill::@1 [phi:fill/fill::@1->fill::@1]
  //SEG112 [65] phi (byte*) fill::addr#2 = (byte*) fill::addr#0 [phi:fill/fill::@1->fill::@1#0] -- register_copy 
  //SEG113 fill::@1
  b1:
  //SEG114 [66] *((byte*) fill::addr#2) ← (byte) fill::val#3 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (addr),y
  //SEG115 [67] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 -- pbuz1=_inc_pbuz1 
    inc addr
    bne !+
    inc addr+1
  !:
  //SEG116 [68] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 -- pbuz1_neq_pbuz2_then_la1 
    lda addr+1
    cmp end+1
    bne b1
    lda addr
    cmp end
    bne b1
  //SEG117 fill::@return
  //SEG118 [69] return 
    rts
}
//SEG119 init_sprites
init_sprites: {
  //SEG120 [70] *((const byte*) SPRITES_ENABLE#0) ← (byte/signed byte/word/signed word/dword/signed dword) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta SPRITES_ENABLE
  //SEG121 [71] *((const byte*) SPRITES_EXPAND_X#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    // one sprite enabled
    lda #0
    sta SPRITES_EXPAND_X
  //SEG122 [72] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    sta SPRITES_EXPAND_Y
  //SEG123 [73] *((const byte*) SPRITES_XMSB#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    sta SPRITES_XMSB
  //SEG124 [74] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta SPRITES_COLS
  //SEG125 [75] *((const byte*) SPRITES_MC#0) ← (byte/signed byte/word/signed word/dword/signed dword) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
  //SEG126 init_sprites::@return
  //SEG127 [76] return 
    rts
}

