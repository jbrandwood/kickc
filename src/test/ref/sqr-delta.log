Inlined call call _init 

CONTROL FLOW GRAPH SSA

(dword()) ifunc((dword) ifunc::a)
ifunc: scope:[ifunc]  from main
  (dword) ifunc::a#2 ← phi( main/(dword) ifunc::a#0 )
  (dword) ifunc::x#0 ← (dword) 1
  (dword) ifunc::xsqr#0 ← (dword) 1
  (dword) ifunc::delta#0 ← (dword) 3
  to:ifunc::@1
ifunc::@1: scope:[ifunc]  from ifunc ifunc::@2
  (dword) ifunc::delta#3 ← phi( ifunc/(dword) ifunc::delta#0 ifunc::@2/(dword) ifunc::delta#1 )
  (dword) ifunc::x#5 ← phi( ifunc/(dword) ifunc::x#0 ifunc::@2/(dword) ifunc::x#1 )
  (dword) ifunc::a#1 ← phi( ifunc/(dword) ifunc::a#2 ifunc::@2/(dword) ifunc::a#3 )
  (dword) ifunc::xsqr#2 ← phi( ifunc/(dword) ifunc::xsqr#0 ifunc::@2/(dword) ifunc::xsqr#1 )
  (bool~) ifunc::$0 ← (dword) ifunc::xsqr#2 <= (dword) ifunc::a#1
  if((bool~) ifunc::$0) goto ifunc::@2
  to:ifunc::@3
ifunc::@2: scope:[ifunc]  from ifunc::@1
  (dword) ifunc::a#3 ← phi( ifunc::@1/(dword) ifunc::a#1 )
  (dword) ifunc::delta#2 ← phi( ifunc::@1/(dword) ifunc::delta#3 )
  (dword) ifunc::xsqr#3 ← phi( ifunc::@1/(dword) ifunc::xsqr#2 )
  (dword) ifunc::x#3 ← phi( ifunc::@1/(dword) ifunc::x#5 )
  (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3
  (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#3 + (dword) ifunc::delta#2
  (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (number) 2
  to:ifunc::@1
ifunc::@3: scope:[ifunc]  from ifunc::@1
  (dword) ifunc::x#4 ← phi( ifunc::@1/(dword) ifunc::x#5 )
  (dword) ifunc::x#2 ← -- (dword) ifunc::x#4
  (dword) ifunc::return#0 ← (dword) ifunc::x#2
  to:ifunc::@return
ifunc::@return: scope:[ifunc]  from ifunc::@3
  (dword) ifunc::return#3 ← phi( ifunc::@3/(dword) ifunc::return#0 )
  (dword) ifunc::return#1 ← (dword) ifunc::return#3
  return 
  to:@return

(void()) main()
main: scope:[main]  from _start::@1
  (dword) ifunc::a#0 ← (number) 8
  call ifunc 
  (dword) ifunc::return#2 ← (dword) ifunc::return#1
  to:main::@1
main::@1: scope:[main]  from main
  (dword) ifunc::return#4 ← phi( main/(dword) ifunc::return#2 )
  (dword~) main::$0 ← (dword) ifunc::return#4
  (number~) main::$1 ← (number) 0 * (const byte) SIZEOF_DWORD
  *((const dword*) SCREEN + (number~) main::$1) ← (dword~) main::$0
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return

(void()) _start()
_start: scope:[_start]  from
  to:_start::_init1
_start::_init1: scope:[_start]  from _start
  to:_start::@1
_start::@1: scope:[_start]  from _start::_init1
  call main 
  to:_start::@2
_start::@2: scope:[_start]  from _start::@1
  to:_start::@return
_start::@return: scope:[_start]  from _start::@2
  return 
  to:@return

SYMBOL TABLE SSA
(const dword*) SCREEN = (dword*)(number) $400
(const byte) SIZEOF_DWORD = (byte) 4
(void()) _start()
(label) _start::@1
(label) _start::@2
(label) _start::@return
(label) _start::_init1
(dword()) ifunc((dword) ifunc::a)
(bool~) ifunc::$0
(label) ifunc::@1
(label) ifunc::@2
(label) ifunc::@3
(label) ifunc::@return
(dword) ifunc::a
(dword) ifunc::a#0
(dword) ifunc::a#1
(dword) ifunc::a#2
(dword) ifunc::a#3
(dword) ifunc::delta
(dword) ifunc::delta#0
(dword) ifunc::delta#1
(dword) ifunc::delta#2
(dword) ifunc::delta#3
(dword) ifunc::return
(dword) ifunc::return#0
(dword) ifunc::return#1
(dword) ifunc::return#2
(dword) ifunc::return#3
(dword) ifunc::return#4
(dword) ifunc::x
(dword) ifunc::x#0
(dword) ifunc::x#1
(dword) ifunc::x#2
(dword) ifunc::x#3
(dword) ifunc::x#4
(dword) ifunc::x#5
(dword) ifunc::xsqr
(dword) ifunc::xsqr#0
(dword) ifunc::xsqr#1
(dword) ifunc::xsqr#2
(dword) ifunc::xsqr#3
(void()) main()
(dword~) main::$0
(number~) main::$1
(label) main::@1
(label) main::@return

Adding number conversion cast (unumber) 2 in (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (number) 2
Adding number conversion cast (unumber) 8 in (dword) ifunc::a#0 ← (number) 8
Adding number conversion cast (unumber) 0 in (number~) main::$1 ← (number) 0 * (const byte) SIZEOF_DWORD
Adding number conversion cast (unumber) main::$1 in (number~) main::$1 ← (unumber)(number) 0 * (const byte) SIZEOF_DWORD
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (dword) ifunc::a#0 ← (unumber)(number) 8
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (dword*) 1024
Simplifying constant integer cast 2
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) main::$1 ← (byte) 0 * (const byte) SIZEOF_DWORD
Alias ifunc::x#3 = ifunc::x#5 ifunc::x#4 
Alias ifunc::xsqr#2 = ifunc::xsqr#3 
Alias ifunc::delta#2 = ifunc::delta#3 
Alias ifunc::a#1 = ifunc::a#3 
Alias ifunc::return#0 = ifunc::x#2 ifunc::return#3 ifunc::return#1 
Alias ifunc::return#2 = ifunc::return#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (dword) ifunc::a#2 (dword) ifunc::a#0
Identical Phi Values (dword) ifunc::a#1 (dword) ifunc::a#2
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) ifunc::$0 [6] if((dword) ifunc::xsqr#2<=(dword) ifunc::a#0) goto ifunc::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [16] (byte~) main::$1 ← (byte) 0 * (const byte) SIZEOF_DWORD
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const dword) ifunc::x#0 = 1
Constant (const dword) ifunc::xsqr#0 = 1
Constant (const dword) ifunc::delta#0 = 3
Constant (const dword) ifunc::a#0 = 8
Constant (const byte) main::$1 = 0*SIZEOF_DWORD
Successful SSA optimization Pass2ConstantIdentification
Rewriting conditional comparison [6] if((dword) ifunc::xsqr#2<=(const dword) ifunc::a#0) goto ifunc::@2
Simplifying constant evaluating to zero (byte) 0*(const byte) SIZEOF_DWORD in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero SCREEN in [17] *((const dword*) SCREEN + (const byte) main::$1) ← (dword~) main::$0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) main::$1
Eliminating unused constant (const byte) SIZEOF_DWORD
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure _start
Removing unused procedure block _start
Removing unused procedure block _start::_init1
Removing unused procedure block _start::@1
Removing unused procedure block _start::@2
Removing unused procedure block _start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) ifunc::a#0+1 in [1] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(number) 1) goto ifunc::@2
Adding number conversion cast (unumber) 1 in [1] if((dword) ifunc::xsqr#2<(unumber)(const dword) ifunc::a#0+(number) 1) goto ifunc::@2
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const dword) ifunc::a#0+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings (const dword) ifunc::x#0
Inlining constant with var siblings (const dword) ifunc::xsqr#0
Inlining constant with var siblings (const dword) ifunc::delta#0
Constant inlined ifunc::xsqr#0 = (dword) 1
Constant inlined ifunc::delta#0 = (dword) 3
Constant inlined ifunc::x#0 = (dword) 1
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of main
Adding NOP phi() at start of ifunc
CALL GRAPH
Calls in [main] to ifunc:1 

Created 3 initial phi equivalence classes
Coalesced [14] ifunc::xsqr#4 ← ifunc::xsqr#1
Coalesced [15] ifunc::x#6 ← ifunc::x#1
Coalesced [16] ifunc::delta#4 ← ifunc::delta#1
Coalesced down to 3 phi equivalence classes
Adding NOP phi() at start of main
Adding NOP phi() at start of ifunc

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call ifunc 
  [2] (dword) ifunc::return#2 ← (dword) ifunc::return#0
  to:main::@1
main::@1: scope:[main]  from main
  [3] (dword~) main::$0 ← (dword) ifunc::return#2
  [4] *((const dword*) SCREEN) ← (dword~) main::$0
  to:main::@return
main::@return: scope:[main]  from main::@1
  [5] return 
  to:@return

(dword()) ifunc((dword) ifunc::a)
ifunc: scope:[ifunc]  from main
  [6] phi()
  to:ifunc::@1
ifunc::@1: scope:[ifunc]  from ifunc ifunc::@2
  [7] (dword) ifunc::delta#2 ← phi( ifunc/(dword) 3 ifunc::@2/(dword) ifunc::delta#1 )
  [7] (dword) ifunc::x#3 ← phi( ifunc/(dword) 1 ifunc::@2/(dword) ifunc::x#1 )
  [7] (dword) ifunc::xsqr#2 ← phi( ifunc/(dword) 1 ifunc::@2/(dword) ifunc::xsqr#1 )
  [8] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2
  to:ifunc::@3
ifunc::@3: scope:[ifunc]  from ifunc::@1
  [9] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3
  to:ifunc::@return
ifunc::@return: scope:[ifunc]  from ifunc::@3
  [10] return 
  to:@return
ifunc::@2: scope:[ifunc]  from ifunc::@1
  [11] (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3
  [12] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2
  [13] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2
  to:ifunc::@1


VARIABLE REGISTER WEIGHTS
(dword()) ifunc((dword) ifunc::a)
(dword) ifunc::a
(dword) ifunc::delta
(dword) ifunc::delta#1 202.0
(dword) ifunc::delta#2 75.75
(dword) ifunc::return
(dword) ifunc::return#0 4.333333333333333
(dword) ifunc::return#2 4.0
(dword) ifunc::x
(dword) ifunc::x#1 67.33333333333333
(dword) ifunc::x#3 106.5
(dword) ifunc::xsqr
(dword) ifunc::xsqr#1 101.0
(dword) ifunc::xsqr#2 101.0
(void()) main()
(dword~) main::$0 4.0

Initial phi equivalence classes
[ ifunc::xsqr#2 ifunc::xsqr#1 ]
[ ifunc::x#3 ifunc::x#1 ]
[ ifunc::delta#2 ifunc::delta#1 ]
Added variable ifunc::return#2 to live range equivalence class [ ifunc::return#2 ]
Added variable main::$0 to live range equivalence class [ main::$0 ]
Added variable ifunc::return#0 to live range equivalence class [ ifunc::return#0 ]
Complete equivalence classes
[ ifunc::xsqr#2 ifunc::xsqr#1 ]
[ ifunc::x#3 ifunc::x#1 ]
[ ifunc::delta#2 ifunc::delta#1 ]
[ ifunc::return#2 ]
[ main::$0 ]
[ ifunc::return#0 ]
Allocated zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ]
Allocated zp[4]:6 [ ifunc::x#3 ifunc::x#1 ]
Allocated zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ]
Allocated zp[4]:14 [ ifunc::return#2 ]
Allocated zp[4]:18 [ main::$0 ]
Allocated zp[4]:22 [ ifunc::return#0 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // main
main: {
    .label __0 = $12
    // [1] call ifunc 
    // [6] phi from main to ifunc [phi:main->ifunc]
  ifunc_from_main:
    jsr ifunc
    // [2] (dword) ifunc::return#2 ← (dword) ifunc::return#0 -- vduz1=vduz2 
    lda.z ifunc.return
    sta.z ifunc.return_1
    lda.z ifunc.return+1
    sta.z ifunc.return_1+1
    lda.z ifunc.return+2
    sta.z ifunc.return_1+2
    lda.z ifunc.return+3
    sta.z ifunc.return_1+3
    jmp __b1
    // main::@1
  __b1:
    // [3] (dword~) main::$0 ← (dword) ifunc::return#2 -- vduz1=vduz2 
    lda.z ifunc.return_1
    sta.z __0
    lda.z ifunc.return_1+1
    sta.z __0+1
    lda.z ifunc.return_1+2
    sta.z __0+2
    lda.z ifunc.return_1+3
    sta.z __0+3
    // [4] *((const dword*) SCREEN) ← (dword~) main::$0 -- _deref_pduc1=vduz1 
    lda.z __0
    sta SCREEN
    lda.z __0+1
    sta SCREEN+1
    lda.z __0+2
    sta SCREEN+2
    lda.z __0+3
    sta SCREEN+3
    jmp __breturn
    // main::@return
  __breturn:
    // [5] return 
    rts
}
  // ifunc
ifunc: {
    .const a = 8
    .label x = 6
    .label xsqr = 2
    .label delta = $a
    .label return = $16
    .label return_1 = $e
    // [7] phi from ifunc to ifunc::@1 [phi:ifunc->ifunc::@1]
  __b1_from_ifunc:
    // [7] phi (dword) ifunc::delta#2 = (dword) 3 [phi:ifunc->ifunc::@1#0] -- vduz1=vduc1 
    lda #<3
    sta.z delta
    lda #>3
    sta.z delta+1
    lda #<3>>$10
    sta.z delta+2
    lda #>3>>$10
    sta.z delta+3
    // [7] phi (dword) ifunc::x#3 = (dword) 1 [phi:ifunc->ifunc::@1#1] -- vduz1=vduc1 
    lda #<1
    sta.z x
    lda #>1
    sta.z x+1
    lda #<1>>$10
    sta.z x+2
    lda #>1>>$10
    sta.z x+3
    // [7] phi (dword) ifunc::xsqr#2 = (dword) 1 [phi:ifunc->ifunc::@1#2] -- vduz1=vduc1 
    lda #<1
    sta.z xsqr
    lda #>1
    sta.z xsqr+1
    lda #<1>>$10
    sta.z xsqr+2
    lda #>1>>$10
    sta.z xsqr+3
    jmp __b1
    // ifunc::@1
  __b1:
    // [8] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2 -- vduz1_lt_vduc1_then_la1 
    lda.z xsqr+3
    cmp #>a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+2
    cmp #<a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+1
    cmp #>a+1
    bcc __b2
    bne !+
    lda.z xsqr
    cmp #<a+1
    bcc __b2
  !:
    jmp __b3
    // ifunc::@3
  __b3:
    // [9] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3 -- vduz1=_dec_vduz2 
    lda.z x
    sec
    sbc #1
    sta.z return
    lda.z x+1
    sbc #0
    sta.z return+1
    lda.z x+2
    sbc #0
    sta.z return+2
    lda.z x+3
    sbc #0
    sta.z return+3
    jmp __breturn
    // ifunc::@return
  __breturn:
    // [10] return 
    rts
    // ifunc::@2
  __b2:
    // [11] (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3 -- vduz1=_inc_vduz1 
    inc.z x
    bne !+
    inc.z x+1
    bne !+
    inc.z x+2
    bne !+
    inc.z x+3
  !:
    // [12] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2 -- vduz1=vduz1_plus_vduz2 
    lda.z xsqr
    clc
    adc.z delta
    sta.z xsqr
    lda.z xsqr+1
    adc.z delta+1
    sta.z xsqr+1
    lda.z xsqr+2
    adc.z delta+2
    sta.z xsqr+2
    lda.z xsqr+3
    adc.z delta+3
    sta.z xsqr+3
    // [13] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2 -- vduz1=vduz1_plus_vbuc1 
    lda.z delta
    clc
    adc #2
    sta.z delta
    bcc !+
    inc.z delta+1
    bne !+
    inc.z delta+2
    bne !+
    inc.z delta+3
  !:
    // [7] phi from ifunc::@2 to ifunc::@1 [phi:ifunc::@2->ifunc::@1]
  __b1_from___b2:
    // [7] phi (dword) ifunc::delta#2 = (dword) ifunc::delta#1 [phi:ifunc::@2->ifunc::@1#0] -- register_copy 
    // [7] phi (dword) ifunc::x#3 = (dword) ifunc::x#1 [phi:ifunc::@2->ifunc::@1#1] -- register_copy 
    // [7] phi (dword) ifunc::xsqr#2 = (dword) ifunc::xsqr#1 [phi:ifunc::@2->ifunc::@1#2] -- register_copy 
    jmp __b1
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] (dword) ifunc::return#2 ← (dword) ifunc::return#0 [ ifunc::return#2 ] (  [ ifunc::return#2 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Statement [3] (dword~) main::$0 ← (dword) ifunc::return#2 [ main::$0 ] (  [ main::$0 ] { }  ) always clobbers reg byte a 
Statement [4] *((const dword*) SCREEN) ← (dword~) main::$0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [8] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2 [ ifunc::xsqr#2 ifunc::x#3 ifunc::delta#2 ] ( ifunc:1 [ ifunc::xsqr#2 ifunc::x#3 ifunc::delta#2 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Statement [9] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3 [ ifunc::return#0 ] ( ifunc:1 [ ifunc::return#0 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Statement [12] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2 [ ifunc::delta#2 ifunc::xsqr#1 ifunc::x#1 ] ( ifunc:1 [ ifunc::delta#2 ifunc::xsqr#1 ifunc::x#1 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Statement [13] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2 [ ifunc::xsqr#1 ifunc::x#1 ifunc::delta#1 ] ( ifunc:1 [ ifunc::xsqr#1 ifunc::x#1 ifunc::delta#1 ] { { ifunc::return#0 = ifunc::return#2 } }  ) always clobbers reg byte a 
Potential registers zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ] : zp[4]:2 , 
Potential registers zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] : zp[4]:6 , 
Potential registers zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ] : zp[4]:10 , 
Potential registers zp[4]:14 [ ifunc::return#2 ] : zp[4]:14 , 
Potential registers zp[4]:18 [ main::$0 ] : zp[4]:18 , 
Potential registers zp[4]:22 [ ifunc::return#0 ] : zp[4]:22 , 

REGISTER UPLIFT SCOPES
Uplift Scope [ifunc] 277.75: zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ] 202: zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ] 173.83: zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] 4.33: zp[4]:22 [ ifunc::return#0 ] 4: zp[4]:14 [ ifunc::return#2 ] 
Uplift Scope [main] 4: zp[4]:18 [ main::$0 ] 
Uplift Scope [] 

Uplifting [ifunc] best 2182 combination zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ] zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ] zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] zp[4]:22 [ ifunc::return#0 ] zp[4]:14 [ ifunc::return#2 ] 
Uplifting [main] best 2182 combination zp[4]:18 [ main::$0 ] 
Uplifting [] best 2182 combination 
Coalescing zero page register [ zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] ] with [ zp[4]:22 [ ifunc::return#0 ] ] - score: 1
Coalescing zero page register [ zp[4]:14 [ ifunc::return#2 ] ] with [ zp[4]:18 [ main::$0 ] ] - score: 1
Coalescing zero page register [ zp[4]:6 [ ifunc::x#3 ifunc::x#1 ifunc::return#0 ] ] with [ zp[4]:14 [ ifunc::return#2 main::$0 ] ] - score: 1

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // main
main: {
    .label __0 = 6
    // [1] call ifunc 
    // [6] phi from main to ifunc [phi:main->ifunc]
  ifunc_from_main:
    jsr ifunc
    // [2] (dword) ifunc::return#2 ← (dword) ifunc::return#0
    jmp __b1
    // main::@1
  __b1:
    // [3] (dword~) main::$0 ← (dword) ifunc::return#2
    // [4] *((const dword*) SCREEN) ← (dword~) main::$0 -- _deref_pduc1=vduz1 
    lda.z __0
    sta SCREEN
    lda.z __0+1
    sta SCREEN+1
    lda.z __0+2
    sta SCREEN+2
    lda.z __0+3
    sta SCREEN+3
    jmp __breturn
    // main::@return
  __breturn:
    // [5] return 
    rts
}
  // ifunc
ifunc: {
    .const a = 8
    .label x = 6
    .label xsqr = 2
    .label delta = $a
    .label return = 6
    // [7] phi from ifunc to ifunc::@1 [phi:ifunc->ifunc::@1]
  __b1_from_ifunc:
    // [7] phi (dword) ifunc::delta#2 = (dword) 3 [phi:ifunc->ifunc::@1#0] -- vduz1=vduc1 
    lda #<3
    sta.z delta
    lda #>3
    sta.z delta+1
    lda #<3>>$10
    sta.z delta+2
    lda #>3>>$10
    sta.z delta+3
    // [7] phi (dword) ifunc::x#3 = (dword) 1 [phi:ifunc->ifunc::@1#1] -- vduz1=vduc1 
    lda #<1
    sta.z x
    lda #>1
    sta.z x+1
    lda #<1>>$10
    sta.z x+2
    lda #>1>>$10
    sta.z x+3
    // [7] phi (dword) ifunc::xsqr#2 = (dword) 1 [phi:ifunc->ifunc::@1#2] -- vduz1=vduc1 
    lda #<1
    sta.z xsqr
    lda #>1
    sta.z xsqr+1
    lda #<1>>$10
    sta.z xsqr+2
    lda #>1>>$10
    sta.z xsqr+3
    jmp __b1
    // ifunc::@1
  __b1:
    // [8] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2 -- vduz1_lt_vduc1_then_la1 
    lda.z xsqr+3
    cmp #>a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+2
    cmp #<a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+1
    cmp #>a+1
    bcc __b2
    bne !+
    lda.z xsqr
    cmp #<a+1
    bcc __b2
  !:
    jmp __b3
    // ifunc::@3
  __b3:
    // [9] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3 -- vduz1=_dec_vduz1 
    lda.z return
    sec
    sbc #1
    sta.z return
    lda.z return+1
    sbc #0
    sta.z return+1
    lda.z return+2
    sbc #0
    sta.z return+2
    lda.z return+3
    sbc #0
    sta.z return+3
    jmp __breturn
    // ifunc::@return
  __breturn:
    // [10] return 
    rts
    // ifunc::@2
  __b2:
    // [11] (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3 -- vduz1=_inc_vduz1 
    inc.z x
    bne !+
    inc.z x+1
    bne !+
    inc.z x+2
    bne !+
    inc.z x+3
  !:
    // [12] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2 -- vduz1=vduz1_plus_vduz2 
    lda.z xsqr
    clc
    adc.z delta
    sta.z xsqr
    lda.z xsqr+1
    adc.z delta+1
    sta.z xsqr+1
    lda.z xsqr+2
    adc.z delta+2
    sta.z xsqr+2
    lda.z xsqr+3
    adc.z delta+3
    sta.z xsqr+3
    // [13] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2 -- vduz1=vduz1_plus_vbuc1 
    lda.z delta
    clc
    adc #2
    sta.z delta
    bcc !+
    inc.z delta+1
    bne !+
    inc.z delta+2
    bne !+
    inc.z delta+3
  !:
    // [7] phi from ifunc::@2 to ifunc::@1 [phi:ifunc::@2->ifunc::@1]
  __b1_from___b2:
    // [7] phi (dword) ifunc::delta#2 = (dword) ifunc::delta#1 [phi:ifunc::@2->ifunc::@1#0] -- register_copy 
    // [7] phi (dword) ifunc::x#3 = (dword) ifunc::x#1 [phi:ifunc::@2->ifunc::@1#1] -- register_copy 
    // [7] phi (dword) ifunc::xsqr#2 = (dword) ifunc::xsqr#1 [phi:ifunc::@2->ifunc::@1#2] -- register_copy 
    jmp __b1
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ifunc_from_main:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b1_from_ifunc:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(const dword*) SCREEN = (dword*) 1024
(dword()) ifunc((dword) ifunc::a)
(label) ifunc::@1
(label) ifunc::@2
(label) ifunc::@3
(label) ifunc::@return
(dword) ifunc::a
(const dword) ifunc::a#0 a = (byte) 8
(dword) ifunc::delta
(dword) ifunc::delta#1 delta zp[4]:10 202.0
(dword) ifunc::delta#2 delta zp[4]:10 75.75
(dword) ifunc::return
(dword) ifunc::return#0 return zp[4]:6 4.333333333333333
(dword) ifunc::return#2 return zp[4]:6 4.0
(dword) ifunc::x
(dword) ifunc::x#1 x zp[4]:6 67.33333333333333
(dword) ifunc::x#3 x zp[4]:6 106.5
(dword) ifunc::xsqr
(dword) ifunc::xsqr#1 xsqr zp[4]:2 101.0
(dword) ifunc::xsqr#2 xsqr zp[4]:2 101.0
(void()) main()
(dword~) main::$0 zp[4]:6 4.0
(label) main::@1
(label) main::@return

zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ]
zp[4]:6 [ ifunc::x#3 ifunc::x#1 ifunc::return#0 ifunc::return#2 main::$0 ]
zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ]


FINAL ASSEMBLER
Score: 2065

  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // main
main: {
    .label __0 = 6
    // ifunc(8)
    // [1] call ifunc 
    // [6] phi from main to ifunc [phi:main->ifunc]
    jsr ifunc
    // ifunc(8)
    // [2] (dword) ifunc::return#2 ← (dword) ifunc::return#0
    // main::@1
    // [3] (dword~) main::$0 ← (dword) ifunc::return#2
    // SCREEN[0] = ifunc(8)
    // [4] *((const dword*) SCREEN) ← (dword~) main::$0 -- _deref_pduc1=vduz1 
    lda.z __0
    sta SCREEN
    lda.z __0+1
    sta SCREEN+1
    lda.z __0+2
    sta SCREEN+2
    lda.z __0+3
    sta SCREEN+3
    // main::@return
    // }
    // [5] return 
    rts
}
  // ifunc
ifunc: {
    .const a = 8
    .label x = 6
    .label xsqr = 2
    .label delta = $a
    .label return = 6
    // [7] phi from ifunc to ifunc::@1 [phi:ifunc->ifunc::@1]
    // [7] phi (dword) ifunc::delta#2 = (dword) 3 [phi:ifunc->ifunc::@1#0] -- vduz1=vduc1 
    lda #<3
    sta.z delta
    lda #>3
    sta.z delta+1
    lda #<3>>$10
    sta.z delta+2
    lda #>3>>$10
    sta.z delta+3
    // [7] phi (dword) ifunc::x#3 = (dword) 1 [phi:ifunc->ifunc::@1#1] -- vduz1=vduc1 
    lda #<1
    sta.z x
    lda #>1
    sta.z x+1
    lda #<1>>$10
    sta.z x+2
    lda #>1>>$10
    sta.z x+3
    // [7] phi (dword) ifunc::xsqr#2 = (dword) 1 [phi:ifunc->ifunc::@1#2] -- vduz1=vduc1 
    lda #<1
    sta.z xsqr
    lda #>1
    sta.z xsqr+1
    lda #<1>>$10
    sta.z xsqr+2
    lda #>1>>$10
    sta.z xsqr+3
    // ifunc::@1
  __b1:
    // while(xsqr <=a)
    // [8] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2 -- vduz1_lt_vduc1_then_la1 
    lda.z xsqr+3
    cmp #>a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+2
    cmp #<a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+1
    cmp #>a+1
    bcc __b2
    bne !+
    lda.z xsqr
    cmp #<a+1
    bcc __b2
  !:
    // ifunc::@3
    // return --x;
    // [9] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3 -- vduz1=_dec_vduz1 
    lda.z return
    sec
    sbc #1
    sta.z return
    lda.z return+1
    sbc #0
    sta.z return+1
    lda.z return+2
    sbc #0
    sta.z return+2
    lda.z return+3
    sbc #0
    sta.z return+3
    // ifunc::@return
    // }
    // [10] return 
    rts
    // ifunc::@2
  __b2:
    // ++x;
    // [11] (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3 -- vduz1=_inc_vduz1 
    inc.z x
    bne !+
    inc.z x+1
    bne !+
    inc.z x+2
    bne !+
    inc.z x+3
  !:
    // xsqr += delta
    // [12] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2 -- vduz1=vduz1_plus_vduz2 
    lda.z xsqr
    clc
    adc.z delta
    sta.z xsqr
    lda.z xsqr+1
    adc.z delta+1
    sta.z xsqr+1
    lda.z xsqr+2
    adc.z delta+2
    sta.z xsqr+2
    lda.z xsqr+3
    adc.z delta+3
    sta.z xsqr+3
    // delta += 2
    // [13] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2 -- vduz1=vduz1_plus_vbuc1 
    lda.z delta
    clc
    adc #2
    sta.z delta
    bcc !+
    inc.z delta+1
    bne !+
    inc.z delta+2
    bne !+
    inc.z delta+3
  !:
    // [7] phi from ifunc::@2 to ifunc::@1 [phi:ifunc::@2->ifunc::@1]
    // [7] phi (dword) ifunc::delta#2 = (dword) ifunc::delta#1 [phi:ifunc::@2->ifunc::@1#0] -- register_copy 
    // [7] phi (dword) ifunc::x#3 = (dword) ifunc::x#1 [phi:ifunc::@2->ifunc::@1#1] -- register_copy 
    // [7] phi (dword) ifunc::xsqr#2 = (dword) ifunc::xsqr#1 [phi:ifunc::@2->ifunc::@1#2] -- register_copy 
    jmp __b1
}
  // File Data

