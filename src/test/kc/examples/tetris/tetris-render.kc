import "tetris-data"

kickasm(pc PLAYFIELD_CHARSET, resource "nes-charset.png") {{
  .var charset = LoadPicture("nes-charset.png", List().add($000000, $ffffff))
    .for (var c=0; c<32; c++)
        .for (var y=0;y<8; y++)
            .byte charset.getSinglecolorByte(c,y)
}}

// Pointers to the screen address for rendering each playfield line
byte*[PLAYFIELD_LINES+3] screen_lines;

// Initialize rendering
void render_init() {
	*BGCOL = BLACK;
	// Clear the screen
	fill(PLAYFIELD_SCREEN,1000,$d0);
	fill(COLS,1000,BLACK);
	// Initialize the screen line pointers;
	byte* li = COLS + 40 + 15;
	for(byte i:0..PLAYFIELD_LINES+2) {
		screen_lines[i<<1] = li;
		li += 40;
	}
	// Prepare the playfield frame
	byte* line = COLS + 14;
	for(byte l:0..PLAYFIELD_LINES+1) {
		for(byte c:0..PLAYFIELD_COLS+1) {
			*(line+c) = DARK_GREY;
		}
		line +=40;
	}

}

// Render the static playfield on the screen
void render_playfield() {
	byte i = 0;
	for(byte l:0..PLAYFIELD_LINES-1) {
		byte* line = screen_lines[l<<1];
		for(byte c:0..PLAYFIELD_COLS-1) {
			*(line++) = playfield[i++];
		}
	}
}

// Render the current moving piece at position (current_xpos, current_ypos)
void render_current() {
	byte i = 0;
	byte ypos2 = current_ypos<<1;
	for(byte l:0..3) {
		if(ypos2<2*PLAYFIELD_LINES) {
			byte* screen_line = screen_lines[ypos2];
			byte xpos = current_xpos;
			for(byte c:0..3) {
				byte current_cell = current_piece_gfx[i++];
				if(current_cell!=0) {
					if(xpos<PLAYFIELD_COLS) {
						screen_line[xpos] = current_piece_color;
					}
				}
				xpos++;
			}
		}
		ypos2 += 2;
	}
}