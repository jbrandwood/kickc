PARSING src/test/java/dk/camelot64/kickc/test/kc/liverange-call-problem.kc
// Live ranges were not functioning properly, when multiple method calls were chained - each modifying different vars.
// w1 and w2 ended up having the same zero-page register as their live range was not propagated properly

word w1 = 0;
word w2 = 0;

void main() {
    incw1();
    incw2();
    incw1();
    incw2();
}

void incw1() {
    w1++;
}

void incw2() {
    w2++;
}

Adding pre/post-modifier (word) w1 ← ++ (word) w1
Adding pre/post-modifier (word) w2 ← ++ (word) w2
SYMBOLS
(label) @1
(label) @2
(label) @3
(label) @begin
(label) @end
(void()) incw1()
(label) incw1::@return
(void()) incw2()
(label) incw2::@return
(void()) main()
(void~) main::$0
(void~) main::$1
(void~) main::$2
(void~) main::$3
(label) main::@return
(word) w1
(word) w2

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (word) w1 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  (word) w2 ← (byte/signed byte/word/signed word/dword/signed dword) 0
  to:@1
main: scope:[main]  from
  (void~) main::$0 ← call incw1 
  (void~) main::$1 ← call incw2 
  (void~) main::$2 ← call incw1 
  (void~) main::$3 ← call incw2 
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
@1: scope:[]  from @begin
  to:@2
incw1: scope:[incw1]  from
  (word) w1 ← ++ (word) w1
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return
@2: scope:[]  from @1
  to:@3
incw2: scope:[incw2]  from
  (word) w2 ← ++ (word) w2
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
@3: scope:[]  from @2
  call main 
  to:@end
@end: scope:[]  from @3

Eliminating unused variable (word) w1 and assignment [0] (word) w1 ← (byte/signed byte/word/signed word/dword/signed dword) 0
Eliminating unused variable (word) w2 and assignment [1] (word) w2 ← (byte/signed byte/word/signed word/dword/signed dword) 0
Eliminating unused variable - keeping the call (void~) main::$0
Eliminating unused variable - keeping the call (void~) main::$1
Eliminating unused variable - keeping the call (void~) main::$2
Eliminating unused variable - keeping the call (void~) main::$3
Eliminating unused variable w1(null) and assignment [7] w1(null) ← ++ w1(null)
Eliminating unused variable w2(null) and assignment [9] w2(null) ← ++ w2(null)
Removing empty block @1
Removing empty block @2
PROCEDURE MODIFY VARIABLE ANALYSIS

Completing Phi functions...

CONTROL FLOW GRAPH SSA WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  to:@3
main: scope:[main]  from @3
  call incw1 
  to:main::@1
main::@1: scope:[main]  from main
  call incw2 
  to:main::@2
main::@2: scope:[main]  from main::@1
  call incw1 
  to:main::@3
main::@3: scope:[main]  from main::@2
  call incw2 
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
@3: scope:[]  from @begin
  call main 
  to:@4
@4: scope:[]  from @3
  to:@end
@end: scope:[]  from @4

SYMBOL TABLE SSA
(label) @3
(label) @4
(label) @begin
(label) @end
(void()) incw1()
(label) incw1::@return
(void()) incw2()
(label) incw2::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return

OPTIMIZING CONTROL FLOW GRAPH
Culled Empty Block (label) main::@4
Culled Empty Block (label) @4
Successful SSA optimization Pass2CullEmptyBlocks
OPTIMIZING CONTROL FLOW GRAPH
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of incw2
Adding NOP phi() at start of incw1
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to incw1:5 incw2:7 incw1:9 incw2:11 

Propagating live ranges...
Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of incw2
Adding NOP phi() at start of incw1
Propagating live ranges...

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi() [ ] ( )
  to:@3
@3: scope:[]  from @begin
  [1] phi() [ ] ( )
  [2] call main  [ ] ( )
  to:@end
@end: scope:[]  from @3
  [3] phi() [ ] ( )
main: scope:[main]  from @3
  [4] phi() [ ] ( main:2 [ ] )
  [5] call incw1  [ ] ( main:2 [ ] )
  to:main::@1
main::@1: scope:[main]  from main
  [6] phi() [ ] ( main:2 [ ] )
  [7] call incw2  [ ] ( main:2 [ ] )
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] phi() [ ] ( main:2 [ ] )
  [9] call incw1  [ ] ( main:2 [ ] )
  to:main::@3
main::@3: scope:[main]  from main::@2
  [10] phi() [ ] ( main:2 [ ] )
  [11] call incw2  [ ] ( main:2 [ ] )
  to:main::@return
main::@return: scope:[main]  from main::@3
  [12] return  [ ] ( main:2 [ ] )
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  [13] phi() [ ] ( main:2::incw2:7 [ ] main:2::incw2:11 [ ] )
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  [14] return  [ ] ( main:2::incw2:7 [ ] main:2::incw2:11 [ ] )
  to:@return
incw1: scope:[incw1]  from main main::@2
  [15] phi() [ ] ( main:2::incw1:5 [ ] main:2::incw1:9 [ ] )
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  [16] return  [ ] ( main:2::incw1:5 [ ] main:2::incw1:9 [ ] )
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) incw1()
(void()) incw2()
(void()) main()

Initial phi equivalence classes
Complete equivalence classes

INITIAL ASM
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
//SEG2 @begin
bbegin:
//SEG3 [1] phi from @begin to @3 [phi:@begin->@3]
b3_from_bbegin:
  jmp b3
//SEG4 @3
b3:
//SEG5 [2] call main  [ ] ( )
//SEG6 [4] phi from @3 to main [phi:@3->main]
main_from_b3:
  jsr main
//SEG7 [3] phi from @3 to @end [phi:@3->@end]
bend_from_b3:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
  //SEG10 [5] call incw1  [ ] ( main:2 [ ] )
  //SEG11 [15] phi from main to incw1 [phi:main->incw1]
  incw1_from_main:
    jsr incw1
  //SEG12 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG13 main::@1
  b1:
  //SEG14 [7] call incw2  [ ] ( main:2 [ ] )
  //SEG15 [13] phi from main::@1 to incw2 [phi:main::@1->incw2]
  incw2_from_b1:
    jsr incw2
  //SEG16 [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    jmp b2
  //SEG17 main::@2
  b2:
  //SEG18 [9] call incw1  [ ] ( main:2 [ ] )
  //SEG19 [15] phi from main::@2 to incw1 [phi:main::@2->incw1]
  incw1_from_b2:
    jsr incw1
  //SEG20 [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  b3_from_b2:
    jmp b3
  //SEG21 main::@3
  b3:
  //SEG22 [11] call incw2  [ ] ( main:2 [ ] )
  //SEG23 [13] phi from main::@3 to incw2 [phi:main::@3->incw2]
  incw2_from_b3:
    jsr incw2
    jmp breturn
  //SEG24 main::@return
  breturn:
  //SEG25 [12] return  [ ] ( main:2 [ ] )
    rts
}
//SEG26 incw2
incw2: {
    jmp breturn
  //SEG27 incw2::@return
  breturn:
  //SEG28 [14] return  [ ] ( main:2::incw2:7 [ ] main:2::incw2:11 [ ] )
    rts
}
//SEG29 incw1
incw1: {
    jmp breturn
  //SEG30 incw1::@return
  breturn:
  //SEG31 [16] return  [ ] ( main:2::incw1:5 [ ] main:2::incw1:9 [ ] )
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS

REGISTER UPLIFT SCOPES
Uplift Scope [main] 
Uplift Scope [incw1] 
Uplift Scope [incw2] 
Uplift Scope [] 

Uplifting [main] best 126 combination 
Uplifting [incw1] best 126 combination 
Uplifting [incw2] best 126 combination 
Uplifting [] best 126 combination 

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
//SEG2 @begin
bbegin:
//SEG3 [1] phi from @begin to @3 [phi:@begin->@3]
b3_from_bbegin:
  jmp b3
//SEG4 @3
b3:
//SEG5 [2] call main  [ ] ( )
//SEG6 [4] phi from @3 to main [phi:@3->main]
main_from_b3:
  jsr main
//SEG7 [3] phi from @3 to @end [phi:@3->@end]
bend_from_b3:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
  //SEG10 [5] call incw1  [ ] ( main:2 [ ] )
  //SEG11 [15] phi from main to incw1 [phi:main->incw1]
  incw1_from_main:
    jsr incw1
  //SEG12 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG13 main::@1
  b1:
  //SEG14 [7] call incw2  [ ] ( main:2 [ ] )
  //SEG15 [13] phi from main::@1 to incw2 [phi:main::@1->incw2]
  incw2_from_b1:
    jsr incw2
  //SEG16 [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    jmp b2
  //SEG17 main::@2
  b2:
  //SEG18 [9] call incw1  [ ] ( main:2 [ ] )
  //SEG19 [15] phi from main::@2 to incw1 [phi:main::@2->incw1]
  incw1_from_b2:
    jsr incw1
  //SEG20 [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  b3_from_b2:
    jmp b3
  //SEG21 main::@3
  b3:
  //SEG22 [11] call incw2  [ ] ( main:2 [ ] )
  //SEG23 [13] phi from main::@3 to incw2 [phi:main::@3->incw2]
  incw2_from_b3:
    jsr incw2
    jmp breturn
  //SEG24 main::@return
  breturn:
  //SEG25 [12] return  [ ] ( main:2 [ ] )
    rts
}
//SEG26 incw2
incw2: {
    jmp breturn
  //SEG27 incw2::@return
  breturn:
  //SEG28 [14] return  [ ] ( main:2::incw2:7 [ ] main:2::incw2:11 [ ] )
    rts
}
//SEG29 incw1
incw1: {
    jmp breturn
  //SEG30 incw1::@return
  breturn:
  //SEG31 [16] return  [ ] ( main:2::incw1:5 [ ] main:2::incw1:9 [ ] )
    rts
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b3
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Removing instruction b3_from_bbegin:
Removing instruction main_from_b3:
Removing instruction bend_from_b3:
Removing instruction b1_from_main:
Removing instruction incw2_from_b1:
Removing instruction b2_from_b1:
Removing instruction incw1_from_b2:
Removing instruction b3_from_b2:
Removing instruction incw2_from_b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b3:
Removing instruction bend:
Removing instruction incw1_from_main:
Removing instruction b1:
Removing instruction b2:
Removing instruction b3:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @3
(label) @begin
(label) @end
(void()) incw1()
(label) incw1::@return
(void()) incw2()
(label) incw2::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return



FINAL ASSEMBLER
Score: 48

//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
//SEG2 @begin
//SEG3 [1] phi from @begin to @3 [phi:@begin->@3]
//SEG4 @3
//SEG5 [2] call main  [ ] ( )
//SEG6 [4] phi from @3 to main [phi:@3->main]
  jsr main
//SEG7 [3] phi from @3 to @end [phi:@3->@end]
//SEG8 @end
//SEG9 main
main: {
  //SEG10 [5] call incw1  [ ] ( main:2 [ ] )
  //SEG11 [15] phi from main to incw1 [phi:main->incw1]
    jsr incw1
  //SEG12 [6] phi from main to main::@1 [phi:main->main::@1]
  //SEG13 main::@1
  //SEG14 [7] call incw2  [ ] ( main:2 [ ] )
  //SEG15 [13] phi from main::@1 to incw2 [phi:main::@1->incw2]
    jsr incw2
  //SEG16 [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  //SEG17 main::@2
  //SEG18 [9] call incw1  [ ] ( main:2 [ ] )
  //SEG19 [15] phi from main::@2 to incw1 [phi:main::@2->incw1]
    jsr incw1
  //SEG20 [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  //SEG21 main::@3
  //SEG22 [11] call incw2  [ ] ( main:2 [ ] )
  //SEG23 [13] phi from main::@3 to incw2 [phi:main::@3->incw2]
    jsr incw2
  //SEG24 main::@return
  //SEG25 [12] return  [ ] ( main:2 [ ] )
    rts
}
//SEG26 incw2
incw2: {
  //SEG27 incw2::@return
  //SEG28 [14] return  [ ] ( main:2::incw2:7 [ ] main:2::incw2:11 [ ] )
    rts
}
//SEG29 incw1
incw1: {
  //SEG30 incw1::@return
  //SEG31 [16] return  [ ] ( main:2::incw1:5 [ ] main:2::incw1:9 [ ] )
    rts
}

