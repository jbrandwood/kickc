Resolved forward reference mulf_sqr1 to (byte*) mulf_sqr1
Resolved forward reference mulf_sqr2 to (byte*) mulf_sqr2
Adding pointer type conversion cast (byte*) print_screen in (byte*) print_screen ← (number) $400
Adding pointer type conversion cast (byte*) main::at_line in (byte*) main::at_line ← (number) $400
Adding pointer type conversion cast (byte*) init_screen::COLS in (byte*) init_screen::COLS ← (number) $d800
Adding pointer type conversion cast (signed byte*) ap in (signed byte*) ap ← (number) $fd
Adding pointer type conversion cast (signed byte*) bp in (signed byte*) bp ← (number) $fe
Adding pointer type conversion cast (signed byte*) cp in (signed byte*) cp ← (number) $ff
Adding pointer type conversion cast (byte*) mulf_sqr1 in (byte*) mulf_sqr1 ← (number) $2000
Adding pointer type conversion cast (byte*) mulf_sqr2 in (byte*) mulf_sqr2 ← (number) $2200
Identified constant variable (byte) init_screen::WHITE
Identified constant variable (signed byte*) ap
Identified constant variable (signed byte*) bp
Identified constant variable (signed byte*) cp
Identified constant variable (byte*) mulf_sqr1
Identified constant variable (byte*) mulf_sqr2
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) @7
Culled Empty Block (label) @8
Culled Empty Block (label) print_sbyte_at::@4
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) @13
Culled Empty Block (label) @14
Culled Empty Block (label) @15
Culled Empty Block (label) @16
Culled Empty Block (label) @17
Culled Empty Block (label) print_cls::@2
Culled Empty Block (label) @18
Culled Empty Block (label) main::@6
Culled Empty Block (label) @20
Culled Empty Block (label) init_screen::@4
Culled Empty Block (label) fmul8::@1

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) print_screen#0 ← ((byte*)) (number) $400
  to:@12
print_sbyte_at: scope:[print_sbyte_at]  from main::@1 main::@10 main::@3
  (byte*) print_sbyte_at::at#6 ← phi( main::@1/(byte*) print_sbyte_at::at#0 main::@10/(byte*) print_sbyte_at::at#2 main::@3/(byte*) print_sbyte_at::at#1 )
  (signed byte) print_sbyte_at::b#4 ← phi( main::@1/(signed byte) print_sbyte_at::b#1 main::@10/(signed byte) print_sbyte_at::b#3 main::@3/(signed byte) print_sbyte_at::b#2 )
  (bool~) print_sbyte_at::$0 ← (signed byte) print_sbyte_at::b#4 < (number) 0
  if((bool~) print_sbyte_at::$0) goto print_sbyte_at::@1
  to:print_sbyte_at::@3
print_sbyte_at::@1: scope:[print_sbyte_at]  from print_sbyte_at
  (signed byte) print_sbyte_at::b#7 ← phi( print_sbyte_at/(signed byte) print_sbyte_at::b#4 )
  (byte*) print_sbyte_at::at#3 ← phi( print_sbyte_at/(byte*) print_sbyte_at::at#6 )
  (byte) print_char_at::ch#0 ← (byte) '-'
  (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3
  call print_char_at 
  to:print_sbyte_at::@5
print_sbyte_at::@5: scope:[print_sbyte_at]  from print_sbyte_at::@1
  (byte*) print_sbyte_at::at#7 ← phi( print_sbyte_at::@1/(byte*) print_sbyte_at::at#3 )
  (signed byte) print_sbyte_at::b#5 ← phi( print_sbyte_at::@1/(signed byte) print_sbyte_at::b#7 )
  (signed byte~) print_sbyte_at::$6 ← - (signed byte) print_sbyte_at::b#5
  (signed byte) print_sbyte_at::b#0 ← (signed byte~) print_sbyte_at::$6
  to:print_sbyte_at::@2
print_sbyte_at::@3: scope:[print_sbyte_at]  from print_sbyte_at
  (signed byte) print_sbyte_at::b#9 ← phi( print_sbyte_at/(signed byte) print_sbyte_at::b#4 )
  (byte*) print_sbyte_at::at#4 ← phi( print_sbyte_at/(byte*) print_sbyte_at::at#6 )
  (byte) print_char_at::ch#1 ← (byte) ' '
  (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#4
  call print_char_at 
  to:print_sbyte_at::@6
print_sbyte_at::@6: scope:[print_sbyte_at]  from print_sbyte_at::@3
  (byte*) print_sbyte_at::at#8 ← phi( print_sbyte_at::@3/(byte*) print_sbyte_at::at#4 )
  (signed byte) print_sbyte_at::b#8 ← phi( print_sbyte_at::@3/(signed byte) print_sbyte_at::b#9 )
  to:print_sbyte_at::@2
print_sbyte_at::@2: scope:[print_sbyte_at]  from print_sbyte_at::@5 print_sbyte_at::@6
  (byte*) print_sbyte_at::at#5 ← phi( print_sbyte_at::@5/(byte*) print_sbyte_at::at#7 print_sbyte_at::@6/(byte*) print_sbyte_at::at#8 )
  (signed byte) print_sbyte_at::b#6 ← phi( print_sbyte_at::@5/(signed byte) print_sbyte_at::b#0 print_sbyte_at::@6/(signed byte) print_sbyte_at::b#8 )
  (byte~) print_sbyte_at::$1 ← ((byte)) (signed byte) print_sbyte_at::b#6
  (byte*~) print_sbyte_at::$2 ← (byte*) print_sbyte_at::at#5 + (number) 1
  (byte) print_byte_at::b#0 ← (byte~) print_sbyte_at::$1
  (byte*) print_byte_at::at#0 ← (byte*~) print_sbyte_at::$2
  call print_byte_at 
  to:print_sbyte_at::@7
print_sbyte_at::@7: scope:[print_sbyte_at]  from print_sbyte_at::@2
  to:print_sbyte_at::@return
print_sbyte_at::@return: scope:[print_sbyte_at]  from print_sbyte_at::@7
  return 
  to:@return
@12: scope:[]  from @begin
  (byte*) print_screen#8 ← phi( @begin/(byte*) print_screen#0 )
  (byte[]) print_hextab#0 ← (const string) $0
  to:@19
print_byte_at: scope:[print_byte_at]  from print_sbyte_at::@2
  (byte*) print_byte_at::at#1 ← phi( print_sbyte_at::@2/(byte*) print_byte_at::at#0 )
  (byte) print_byte_at::b#1 ← phi( print_sbyte_at::@2/(byte) print_byte_at::b#0 )
  (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#1 >> (number) 4
  (byte) print_char_at::ch#2 ← *((byte[]) print_hextab#0 + (byte~) print_byte_at::$0)
  (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#1
  call print_char_at 
  to:print_byte_at::@1
print_byte_at::@1: scope:[print_byte_at]  from print_byte_at
  (byte*) print_byte_at::at#2 ← phi( print_byte_at/(byte*) print_byte_at::at#1 )
  (byte) print_byte_at::b#2 ← phi( print_byte_at/(byte) print_byte_at::b#1 )
  (number~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (number) $f
  (byte*~) print_byte_at::$3 ← (byte*) print_byte_at::at#2 + (number) 1
  (byte) print_char_at::ch#3 ← *((byte[]) print_hextab#0 + (number~) print_byte_at::$2)
  (byte*) print_char_at::at#3 ← (byte*~) print_byte_at::$3
  call print_char_at 
  to:print_byte_at::@2
print_byte_at::@2: scope:[print_byte_at]  from print_byte_at::@1
  to:print_byte_at::@return
print_byte_at::@return: scope:[print_byte_at]  from print_byte_at::@2
  return 
  to:@return
print_char_at: scope:[print_char_at]  from print_byte_at print_byte_at::@1 print_sbyte_at::@1 print_sbyte_at::@3
  (byte*) print_char_at::at#4 ← phi( print_byte_at/(byte*) print_char_at::at#2 print_byte_at::@1/(byte*) print_char_at::at#3 print_sbyte_at::@1/(byte*) print_char_at::at#0 print_sbyte_at::@3/(byte*) print_char_at::at#1 )
  (byte) print_char_at::ch#4 ← phi( print_byte_at/(byte) print_char_at::ch#2 print_byte_at::@1/(byte) print_char_at::ch#3 print_sbyte_at::@1/(byte) print_char_at::ch#0 print_sbyte_at::@3/(byte) print_char_at::ch#1 )
  *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  return 
  to:@return
print_cls: scope:[print_cls]  from init_screen
  (byte*) print_screen#1 ← phi( init_screen/(byte*) print_screen#3 )
  (byte*) print_cls::sc#0 ← (byte*) print_screen#1
  to:print_cls::@1
print_cls::@1: scope:[print_cls]  from print_cls print_cls::@1
  (byte*) print_screen#2 ← phi( print_cls/(byte*) print_screen#1 print_cls::@1/(byte*) print_screen#2 )
  (byte*) print_cls::sc#2 ← phi( print_cls/(byte*) print_cls::sc#0 print_cls::@1/(byte*) print_cls::sc#1 )
  *((byte*) print_cls::sc#2) ← (byte) ' '
  (byte*) print_cls::sc#1 ← ++ (byte*) print_cls::sc#2
  (byte*~) print_cls::$0 ← (byte*) print_screen#2 + (number) $3e8
  (bool~) print_cls::$1 ← (byte*) print_cls::sc#1 != (byte*~) print_cls::$0
  if((bool~) print_cls::$1) goto print_cls::@1
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls::@1
  return 
  to:@return
@19: scope:[]  from @12
  (byte*) print_screen#7 ← phi( @12/(byte*) print_screen#8 )
  (signed byte[]) vals#0 ← { (number) -$5f, (number) -$40, (number) -$20, (number) -$10, (number) 0, (number) $10, (number) $20, (number) $40, (number) $5f }
  to:@21
main: scope:[main]  from @22
  (byte*) print_screen#4 ← phi( @22/(byte*) print_screen#5 )
  call init_screen 
  to:main::@7
main::@7: scope:[main]  from main
  (byte*) main::at_line#0 ← ((byte*)) (number) $400
  (byte*~) main::$1 ← (byte*) main::at_line#0 + (number) 4
  (byte*) main::at#0 ← (byte*~) main::$1
  (byte) main::k#0 ← (number) 0
  to:main::@1
main::@1: scope:[main]  from main::@7 main::@8
  (byte*) main::at_line#7 ← phi( main::@7/(byte*) main::at_line#0 main::@8/(byte*) main::at_line#5 )
  (byte*) main::at#4 ← phi( main::@7/(byte*) main::at#0 main::@8/(byte*) main::at#1 )
  (byte) main::k#2 ← phi( main::@7/(byte) main::k#0 main::@8/(byte) main::k#1 )
  (signed byte) print_sbyte_at::b#1 ← *((signed byte[]) vals#0 + (byte) main::k#2)
  (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4
  call print_sbyte_at 
  to:main::@8
main::@8: scope:[main]  from main::@1
  (byte*) main::at_line#5 ← phi( main::@1/(byte*) main::at_line#7 )
  (byte) main::k#3 ← phi( main::@1/(byte) main::k#2 )
  (byte*) main::at#5 ← phi( main::@1/(byte*) main::at#4 )
  (byte*) main::at#1 ← (byte*) main::at#5 + (number) 4
  (byte) main::k#1 ← (byte) main::k#3 + rangenext(0,8)
  (bool~) main::$3 ← (byte) main::k#1 != rangelast(0,8)
  if((bool~) main::$3) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@8
  (byte*) main::at_line#3 ← phi( main::@8/(byte*) main::at_line#5 )
  (byte) main::i#0 ← (number) 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@5
  (byte) main::i#2 ← phi( main::@2/(byte) main::i#0 main::@5/(byte) main::i#1 )
  (byte*) main::at_line#2 ← phi( main::@2/(byte*) main::at_line#3 main::@5/(byte*) main::at_line#4 )
  (byte*) main::at_line#1 ← (byte*) main::at_line#2 + (number) $28
  (byte*) main::at#2 ← (byte*) main::at_line#1
  (signed byte) print_sbyte_at::b#2 ← *((signed byte[]) vals#0 + (byte) main::i#2)
  (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2
  call print_sbyte_at 
  to:main::@9
main::@9: scope:[main]  from main::@3
  (byte*) main::at_line#10 ← phi( main::@3/(byte*) main::at_line#1 )
  (byte) main::i#6 ← phi( main::@3/(byte) main::i#2 )
  (byte*) main::at#9 ← phi( main::@3/(byte*) main::at#2 )
  (byte) main::j#0 ← (number) 0
  to:main::@4
main::@4: scope:[main]  from main::@11 main::@9
  (byte*) main::at_line#9 ← phi( main::@11/(byte*) main::at_line#6 main::@9/(byte*) main::at_line#10 )
  (byte) main::j#2 ← phi( main::@11/(byte) main::j#1 main::@9/(byte) main::j#0 )
  (byte) main::i#3 ← phi( main::@11/(byte) main::i#5 main::@9/(byte) main::i#6 )
  (byte*) main::at#6 ← phi( main::@11/(byte*) main::at#8 main::@9/(byte*) main::at#9 )
  (byte*) main::at#3 ← (byte*) main::at#6 + (number) 4
  (signed byte) fmul8::a#0 ← *((signed byte[]) vals#0 + (byte) main::i#3)
  (signed byte) fmul8::b#0 ← *((signed byte[]) vals#0 + (byte) main::j#2)
  call fmul8 
  (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#2
  to:main::@10
main::@10: scope:[main]  from main::@4
  (byte*) main::at_line#8 ← phi( main::@4/(byte*) main::at_line#9 )
  (byte) main::i#7 ← phi( main::@4/(byte) main::i#3 )
  (byte) main::j#4 ← phi( main::@4/(byte) main::j#2 )
  (byte*) main::at#7 ← phi( main::@4/(byte*) main::at#3 )
  (signed byte) fmul8::return#3 ← phi( main::@4/(signed byte) fmul8::return#0 )
  (signed byte~) main::$5 ← (signed byte) fmul8::return#3
  (signed byte) main::r#0 ← (signed byte~) main::$5
  (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0
  (byte*) print_sbyte_at::at#2 ← (byte*) main::at#7
  call print_sbyte_at 
  to:main::@11
main::@11: scope:[main]  from main::@10
  (byte*) main::at_line#6 ← phi( main::@10/(byte*) main::at_line#8 )
  (byte) main::i#5 ← phi( main::@10/(byte) main::i#7 )
  (byte*) main::at#8 ← phi( main::@10/(byte*) main::at#7 )
  (byte) main::j#3 ← phi( main::@10/(byte) main::j#4 )
  (byte) main::j#1 ← (byte) main::j#3 + rangenext(0,8)
  (bool~) main::$7 ← (byte) main::j#1 != rangelast(0,8)
  if((bool~) main::$7) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@11
  (byte*) main::at_line#4 ← phi( main::@11/(byte*) main::at_line#6 )
  (byte) main::i#4 ← phi( main::@11/(byte) main::i#5 )
  (byte) main::i#1 ← (byte) main::i#4 + rangenext(0,8)
  (bool~) main::$8 ← (byte) main::i#1 != rangelast(0,8)
  if((bool~) main::$8) goto main::@3
  to:main::@return
main::@return: scope:[main]  from main::@5
  return 
  to:@return
init_screen: scope:[init_screen]  from main
  (byte*) print_screen#3 ← phi( main/(byte*) print_screen#4 )
  call print_cls 
  to:init_screen::@5
init_screen::@5: scope:[init_screen]  from init_screen
  (byte*) init_screen::COLS#0 ← ((byte*)) (number) $d800
  (byte) init_screen::WHITE#0 ← (number) 1
  (byte) init_screen::l#0 ← (number) 0
  to:init_screen::@1
init_screen::@1: scope:[init_screen]  from init_screen::@1 init_screen::@5
  (byte) init_screen::l#2 ← phi( init_screen::@1/(byte) init_screen::l#1 init_screen::@5/(byte) init_screen::l#0 )
  (byte*) init_screen::COLS#2 ← phi( init_screen::@1/(byte*) init_screen::COLS#2 init_screen::@5/(byte*) init_screen::COLS#0 )
  *((byte*) init_screen::COLS#2 + (byte) init_screen::l#2) ← (byte) init_screen::WHITE#0
  (byte) init_screen::l#1 ← (byte) init_screen::l#2 + rangenext(0,$27)
  (bool~) init_screen::$1 ← (byte) init_screen::l#1 != rangelast(0,$27)
  if((bool~) init_screen::$1) goto init_screen::@1
  to:init_screen::@2
init_screen::@2: scope:[init_screen]  from init_screen::@1
  (byte*) init_screen::COLS#4 ← phi( init_screen::@1/(byte*) init_screen::COLS#2 )
  (byte) init_screen::m#0 ← (number) 0
  to:init_screen::@3
init_screen::@3: scope:[init_screen]  from init_screen::@2 init_screen::@3
  (byte) init_screen::m#2 ← phi( init_screen::@2/(byte) init_screen::m#0 init_screen::@3/(byte) init_screen::m#1 )
  (byte*) init_screen::COLS#3 ← phi( init_screen::@2/(byte*) init_screen::COLS#4 init_screen::@3/(byte*) init_screen::COLS#1 )
  *((byte*) init_screen::COLS#3 + (number) 0) ← (byte) init_screen::WHITE#0
  *((byte*) init_screen::COLS#3 + (number) 1) ← (byte) init_screen::WHITE#0
  *((byte*) init_screen::COLS#3 + (number) 2) ← (byte) init_screen::WHITE#0
  *((byte*) init_screen::COLS#3 + (number) 3) ← (byte) init_screen::WHITE#0
  (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (number) $28
  (byte) init_screen::m#1 ← (byte) init_screen::m#2 + rangenext(0,$18)
  (bool~) init_screen::$2 ← (byte) init_screen::m#1 != rangelast(0,$18)
  if((bool~) init_screen::$2) goto init_screen::@3
  to:init_screen::@return
init_screen::@return: scope:[init_screen]  from init_screen::@3
  return 
  to:@return
@21: scope:[]  from @19
  (byte*) print_screen#6 ← phi( @19/(byte*) print_screen#7 )
  (signed byte*) ap#0 ← ((signed byte*)) (number) $fd
  (signed byte*) bp#0 ← ((signed byte*)) (number) $fe
  (signed byte*) cp#0 ← ((signed byte*)) (number) $ff
  to:@22
fmul8: scope:[fmul8]  from main::@4
  (signed byte) fmul8::b#1 ← phi( main::@4/(signed byte) fmul8::b#0 )
  (signed byte) fmul8::a#1 ← phi( main::@4/(signed byte) fmul8::a#0 )
  *((signed byte*) ap#0) ← (signed byte) fmul8::a#1
  *((signed byte*) bp#0) ← (signed byte) fmul8::b#1
  asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
  (signed byte) fmul8::return#1 ← *((signed byte*) cp#0)
  to:fmul8::@return
fmul8::@return: scope:[fmul8]  from fmul8
  (signed byte) fmul8::return#4 ← phi( fmul8/(signed byte) fmul8::return#1 )
  (signed byte) fmul8::return#2 ← (signed byte) fmul8::return#4
  return 
  to:@return
@22: scope:[]  from @21
  (byte*) print_screen#5 ← phi( @21/(byte*) print_screen#6 )
  (byte*) mulf_sqr1#0 ← ((byte*)) (number) $2000
  (byte*) mulf_sqr2#0 ← ((byte*)) (number) $2200
  kickasm(location (byte*) mulf_sqr1#0) {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }
 }}
  kickasm(location (byte*) mulf_sqr2#0) {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }
 }}
  call main 
  to:@23
@23: scope:[]  from @22
  to:@end
@end: scope:[]  from @23

SYMBOL TABLE SSA
(const string) $0 = (string) "0123456789abcdef"
(label) @12
(label) @19
(label) @21
(label) @22
(label) @23
(label) @begin
(label) @end
(signed byte*) ap
(signed byte*) ap#0
(signed byte*) bp
(signed byte*) bp#0
(signed byte*) cp
(signed byte*) cp#0
(signed byte()) fmul8((signed byte) fmul8::a , (signed byte) fmul8::b)
(label) fmul8::@return
(signed byte) fmul8::a
(signed byte) fmul8::a#0
(signed byte) fmul8::a#1
(signed byte) fmul8::b
(signed byte) fmul8::b#0
(signed byte) fmul8::b#1
(signed byte) fmul8::return
(signed byte) fmul8::return#0
(signed byte) fmul8::return#1
(signed byte) fmul8::return#2
(signed byte) fmul8::return#3
(signed byte) fmul8::return#4
(void()) init_screen()
(bool~) init_screen::$1
(bool~) init_screen::$2
(label) init_screen::@1
(label) init_screen::@2
(label) init_screen::@3
(label) init_screen::@5
(label) init_screen::@return
(byte*) init_screen::COLS
(byte*) init_screen::COLS#0
(byte*) init_screen::COLS#1
(byte*) init_screen::COLS#2
(byte*) init_screen::COLS#3
(byte*) init_screen::COLS#4
(byte) init_screen::WHITE
(byte) init_screen::WHITE#0
(byte) init_screen::l
(byte) init_screen::l#0
(byte) init_screen::l#1
(byte) init_screen::l#2
(byte) init_screen::m
(byte) init_screen::m#0
(byte) init_screen::m#1
(byte) init_screen::m#2
(void()) main()
(byte*~) main::$1
(bool~) main::$3
(signed byte~) main::$5
(bool~) main::$7
(bool~) main::$8
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return
(byte*) main::at
(byte*) main::at#0
(byte*) main::at#1
(byte*) main::at#2
(byte*) main::at#3
(byte*) main::at#4
(byte*) main::at#5
(byte*) main::at#6
(byte*) main::at#7
(byte*) main::at#8
(byte*) main::at#9
(byte*) main::at_line
(byte*) main::at_line#0
(byte*) main::at_line#1
(byte*) main::at_line#10
(byte*) main::at_line#2
(byte*) main::at_line#3
(byte*) main::at_line#4
(byte*) main::at_line#5
(byte*) main::at_line#6
(byte*) main::at_line#7
(byte*) main::at_line#8
(byte*) main::at_line#9
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte) main::i#3
(byte) main::i#4
(byte) main::i#5
(byte) main::i#6
(byte) main::i#7
(byte) main::j
(byte) main::j#0
(byte) main::j#1
(byte) main::j#2
(byte) main::j#3
(byte) main::j#4
(byte) main::k
(byte) main::k#0
(byte) main::k#1
(byte) main::k#2
(byte) main::k#3
(signed byte) main::r
(signed byte) main::r#0
(byte*) mulf_sqr1
(byte*) mulf_sqr1#0
(byte*) mulf_sqr2
(byte*) mulf_sqr2#0
(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
(byte~) print_byte_at::$0
(number~) print_byte_at::$2
(byte*~) print_byte_at::$3
(label) print_byte_at::@1
(label) print_byte_at::@2
(label) print_byte_at::@return
(byte*) print_byte_at::at
(byte*) print_byte_at::at#0
(byte*) print_byte_at::at#1
(byte*) print_byte_at::at#2
(byte) print_byte_at::b
(byte) print_byte_at::b#0
(byte) print_byte_at::b#1
(byte) print_byte_at::b#2
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(label) print_char_at::@return
(byte*) print_char_at::at
(byte*) print_char_at::at#0
(byte*) print_char_at::at#1
(byte*) print_char_at::at#2
(byte*) print_char_at::at#3
(byte*) print_char_at::at#4
(byte) print_char_at::ch
(byte) print_char_at::ch#0
(byte) print_char_at::ch#1
(byte) print_char_at::ch#2
(byte) print_char_at::ch#3
(byte) print_char_at::ch#4
(void()) print_cls()
(byte*~) print_cls::$0
(bool~) print_cls::$1
(label) print_cls::@1
(label) print_cls::@return
(byte*) print_cls::sc
(byte*) print_cls::sc#0
(byte*) print_cls::sc#1
(byte*) print_cls::sc#2
(byte[]) print_hextab
(byte[]) print_hextab#0
(void()) print_sbyte_at((signed byte) print_sbyte_at::b , (byte*) print_sbyte_at::at)
(bool~) print_sbyte_at::$0
(byte~) print_sbyte_at::$1
(byte*~) print_sbyte_at::$2
(signed byte~) print_sbyte_at::$6
(label) print_sbyte_at::@1
(label) print_sbyte_at::@2
(label) print_sbyte_at::@3
(label) print_sbyte_at::@5
(label) print_sbyte_at::@6
(label) print_sbyte_at::@7
(label) print_sbyte_at::@return
(byte*) print_sbyte_at::at
(byte*) print_sbyte_at::at#0
(byte*) print_sbyte_at::at#1
(byte*) print_sbyte_at::at#2
(byte*) print_sbyte_at::at#3
(byte*) print_sbyte_at::at#4
(byte*) print_sbyte_at::at#5
(byte*) print_sbyte_at::at#6
(byte*) print_sbyte_at::at#7
(byte*) print_sbyte_at::at#8
(signed byte) print_sbyte_at::b
(signed byte) print_sbyte_at::b#0
(signed byte) print_sbyte_at::b#1
(signed byte) print_sbyte_at::b#2
(signed byte) print_sbyte_at::b#3
(signed byte) print_sbyte_at::b#4
(signed byte) print_sbyte_at::b#5
(signed byte) print_sbyte_at::b#6
(signed byte) print_sbyte_at::b#7
(signed byte) print_sbyte_at::b#8
(signed byte) print_sbyte_at::b#9
(byte*) print_screen
(byte*) print_screen#0
(byte*) print_screen#1
(byte*) print_screen#2
(byte*) print_screen#3
(byte*) print_screen#4
(byte*) print_screen#5
(byte*) print_screen#6
(byte*) print_screen#7
(byte*) print_screen#8
(signed byte[]) vals
(signed byte[]) vals#0

Adding number conversion cast (snumber) 0 in (bool~) print_sbyte_at::$0 ← (signed byte) print_sbyte_at::b#4 < (number) 0
Adding number conversion cast (unumber) 1 in (byte*~) print_sbyte_at::$2 ← (byte*) print_sbyte_at::at#5 + (number) 1
Adding number conversion cast (unumber) 4 in (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#1 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (number) $f
Adding number conversion cast (unumber) print_byte_at::$2 in (number~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (unumber)(number) $f
Adding number conversion cast (unumber) 1 in (byte*~) print_byte_at::$3 ← (byte*) print_byte_at::at#2 + (number) 1
Adding number conversion cast (unumber) $3e8 in (byte*~) print_cls::$0 ← (byte*) print_screen#2 + (number) $3e8
Adding number conversion cast (unumber) 4 in (byte*~) main::$1 ← (byte*) main::at_line#0 + (number) 4
Adding number conversion cast (unumber) 0 in (byte) main::k#0 ← (number) 0
Adding number conversion cast (unumber) 4 in (byte*) main::at#1 ← (byte*) main::at#5 + (number) 4
Adding number conversion cast (unumber) 0 in (byte) main::i#0 ← (number) 0
Adding number conversion cast (unumber) $28 in (byte*) main::at_line#1 ← (byte*) main::at_line#2 + (number) $28
Adding number conversion cast (unumber) 0 in (byte) main::j#0 ← (number) 0
Adding number conversion cast (unumber) 4 in (byte*) main::at#3 ← (byte*) main::at#6 + (number) 4
Adding number conversion cast (unumber) 1 in (byte) init_screen::WHITE#0 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) init_screen::l#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) init_screen::m#0 ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*) init_screen::COLS#3 + (number) 0) ← (byte) init_screen::WHITE#0
Adding number conversion cast (unumber) 1 in *((byte*) init_screen::COLS#3 + (number) 1) ← (byte) init_screen::WHITE#0
Adding number conversion cast (unumber) 2 in *((byte*) init_screen::COLS#3 + (number) 2) ← (byte) init_screen::WHITE#0
Adding number conversion cast (unumber) 3 in *((byte*) init_screen::COLS#3 + (number) 3) ← (byte) init_screen::WHITE#0
Adding number conversion cast (unumber) $28 in (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (number) $28
Successful SSA optimization PassNAddNumberTypeConversions
Adding number conversion cast (signed byte) to elements in (signed byte[]) vals#0 ← { (signed byte)(number) -$5f, (signed byte)(number) -$40, (signed byte)(number) -$20, (signed byte)(number) -$10, (signed byte)(number) 0, (signed byte)(number) $10, (signed byte)(number) $20, (signed byte)(number) $40, (signed byte)(number) $5f }
Successful SSA optimization PassNAddArrayNumberTypeConversions
Inlining cast (byte*) print_screen#0 ← (byte*)(number) $400
Inlining cast (byte~) print_sbyte_at::$1 ← (byte)(signed byte) print_sbyte_at::b#6
Inlining cast (byte*) main::at_line#0 ← (byte*)(number) $400
Inlining cast (byte) main::k#0 ← (unumber)(number) 0
Inlining cast (byte) main::i#0 ← (unumber)(number) 0
Inlining cast (byte) main::j#0 ← (unumber)(number) 0
Inlining cast (byte*) init_screen::COLS#0 ← (byte*)(number) $d800
Inlining cast (byte) init_screen::WHITE#0 ← (unumber)(number) 1
Inlining cast (byte) init_screen::l#0 ← (unumber)(number) 0
Inlining cast (byte) init_screen::m#0 ← (unumber)(number) 0
Inlining cast (signed byte*) ap#0 ← (signed byte*)(number) $fd
Inlining cast (signed byte*) bp#0 ← (signed byte*)(number) $fe
Inlining cast (signed byte*) cp#0 ← (signed byte*)(number) $ff
Inlining cast (byte*) mulf_sqr1#0 ← (byte*)(number) $2000
Inlining cast (byte*) mulf_sqr2#0 ← (byte*)(number) $2200
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast $3e8
Simplifying constant integer cast -$5f
Simplifying constant integer cast -$40
Simplifying constant integer cast -$20
Simplifying constant integer cast -$10
Simplifying constant integer cast 0
Simplifying constant integer cast $10
Simplifying constant integer cast $20
Simplifying constant integer cast $40
Simplifying constant integer cast $5f
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 4
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant pointer cast (byte*) 55296
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 3
Simplifying constant integer cast $28
Simplifying constant pointer cast (signed byte*) 253
Simplifying constant pointer cast (signed byte*) 254
Simplifying constant pointer cast (signed byte*) 255
Simplifying constant pointer cast (byte*) 8192
Simplifying constant pointer cast (byte*) 8704
Successful SSA optimization PassNCastSimplification
Finalized signed number type (signed byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (byte) $f
Alias (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#6 (byte*) print_sbyte_at::at#7 (byte*) print_sbyte_at::at#4 (byte*) print_sbyte_at::at#8 
Alias (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#7 (signed byte) print_sbyte_at::b#5 (signed byte) print_sbyte_at::b#9 (signed byte) print_sbyte_at::b#8 
Alias (signed byte) print_sbyte_at::b#0 = (signed byte~) print_sbyte_at::$6 
Alias (byte) print_byte_at::b#0 = (byte~) print_sbyte_at::$1 
Alias (byte*) print_byte_at::at#0 = (byte*~) print_sbyte_at::$2 
Alias (byte*) print_screen#0 = (byte*) print_screen#8 (byte*) print_screen#7 (byte*) print_screen#6 (byte*) print_screen#5 
Alias (byte) print_byte_at::b#1 = (byte) print_byte_at::b#2 
Alias (byte*) print_byte_at::at#1 = (byte*) print_byte_at::at#2 
Alias (byte*) print_char_at::at#3 = (byte*~) print_byte_at::$3 
Alias (byte*) main::at#0 = (byte*~) main::$1 
Alias (byte*) main::at#4 = (byte*) main::at#5 
Alias (byte) main::k#2 = (byte) main::k#3 
Alias (byte*) main::at_line#3 = (byte*) main::at_line#5 (byte*) main::at_line#7 
Alias (byte*) main::at#2 = (byte*) main::at_line#1 (byte*) main::at#9 (byte*) main::at_line#10 
Alias (byte) main::i#2 = (byte) main::i#6 
Alias (signed byte) fmul8::return#0 = (signed byte) fmul8::return#3 
Alias (byte*) main::at#3 = (byte*) main::at#7 (byte*) main::at#8 
Alias (byte) main::j#2 = (byte) main::j#4 (byte) main::j#3 
Alias (byte) main::i#3 = (byte) main::i#7 (byte) main::i#5 (byte) main::i#4 
Alias (byte*) main::at_line#4 = (byte*) main::at_line#8 (byte*) main::at_line#9 (byte*) main::at_line#6 
Alias (signed byte) main::r#0 = (signed byte~) main::$5 
Alias (byte*) init_screen::COLS#2 = (byte*) init_screen::COLS#4 
Alias (signed byte) fmul8::return#1 = (signed byte) fmul8::return#4 (signed byte) fmul8::return#2 
Successful SSA optimization Pass2AliasElimination
Alias (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#5 
Successful SSA optimization Pass2AliasElimination
Self Phi Eliminated (byte*) print_screen#2
Self Phi Eliminated (byte*) main::at_line#3
Self Phi Eliminated (byte) main::i#3
Self Phi Eliminated (byte*) main::at_line#4
Self Phi Eliminated (byte*) init_screen::COLS#2
Successful SSA optimization Pass2SelfPhiElimination
Identical Phi Values (byte) print_byte_at::b#1 (byte) print_byte_at::b#0
Identical Phi Values (byte*) print_byte_at::at#1 (byte*) print_byte_at::at#0
Identical Phi Values (byte*) print_screen#1 (byte*) print_screen#3
Identical Phi Values (byte*) print_screen#2 (byte*) print_screen#1
Identical Phi Values (byte*) print_screen#4 (byte*) print_screen#0
Identical Phi Values (byte*) main::at_line#3 (byte*) main::at_line#0
Identical Phi Values (byte) main::i#3 (byte) main::i#2
Identical Phi Values (byte*) main::at_line#4 (byte*) main::at#2
Identical Phi Values (byte*) print_screen#3 (byte*) print_screen#4
Identical Phi Values (byte*) init_screen::COLS#2 (byte*) init_screen::COLS#0
Identical Phi Values (signed byte) fmul8::a#1 (signed byte) fmul8::a#0
Identical Phi Values (signed byte) fmul8::b#1 (signed byte) fmul8::b#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) print_sbyte_at::$0 [3] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1
Simple Condition (bool~) print_cls::$1 [47] if((byte*) print_cls::sc#1!=(byte*~) print_cls::$0) goto print_cls::@1
Simple Condition (bool~) main::$3 [65] if((byte) main::k#1!=rangelast(0,8)) goto main::@1
Simple Condition (bool~) main::$7 [91] if((byte) main::j#1!=rangelast(0,8)) goto main::@4
Simple Condition (bool~) main::$8 [95] if((byte) main::i#1!=rangelast(0,8)) goto main::@3
Simple Condition (bool~) init_screen::$1 [106] if((byte) init_screen::l#1!=rangelast(0,$27)) goto init_screen::@1
Simple Condition (bool~) init_screen::$2 [117] if((byte) init_screen::m#1!=rangelast(0,$18)) goto init_screen::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [50] (signed byte[]) vals#0 ← { (signed byte) -$5f, (signed byte) -$40, (signed byte) -$20, (signed byte) -$10, (signed byte) 0, (signed byte) $10, (signed byte) $20, (signed byte) $40, (signed byte) $5f }
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) print_screen#0 = (byte*) 1024
Constant (const byte) print_char_at::ch#0 = '-'
Constant (const byte) print_char_at::ch#1 = ' '
Constant (const byte[]) print_hextab#0 = $0
Constant (const signed byte[]) vals#0 = { -$5f, -$40, -$20, -$10, 0, $10, $20, $40, $5f }
Constant (const byte*) main::at_line#0 = (byte*) 1024
Constant (const byte) main::k#0 = 0
Constant (const byte) main::i#0 = 0
Constant (const byte) main::j#0 = 0
Constant (const byte*) init_screen::COLS#0 = (byte*) 55296
Constant (const byte) init_screen::WHITE#0 = 1
Constant (const byte) init_screen::l#0 = 0
Constant (const byte) init_screen::m#0 = 0
Constant (const signed byte*) ap#0 = (signed byte*) 253
Constant (const signed byte*) bp#0 = (signed byte*) 254
Constant (const signed byte*) cp#0 = (signed byte*) 255
Constant (const byte*) mulf_sqr1#0 = (byte*) 8192
Constant (const byte*) mulf_sqr2#0 = (byte*) 8704
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) print_cls::sc#0 = print_screen#0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [63] main::k#1 ← ++ main::k#2 to ++
Resolved ranged comparison value [65] if(main::k#1!=rangelast(0,8)) goto main::@1 to (number) 9
Resolved ranged next value [89] main::j#1 ← ++ main::j#2 to ++
Resolved ranged comparison value [91] if(main::j#1!=rangelast(0,8)) goto main::@4 to (number) 9
Resolved ranged next value [93] main::i#1 ← ++ main::i#2 to ++
Resolved ranged comparison value [95] if(main::i#1!=rangelast(0,8)) goto main::@3 to (number) 9
Resolved ranged next value [104] init_screen::l#1 ← ++ init_screen::l#2 to ++
Resolved ranged comparison value [106] if(init_screen::l#1!=rangelast(0,$27)) goto init_screen::@1 to (number) $28
Resolved ranged next value [115] init_screen::m#1 ← ++ init_screen::m#2 to ++
Resolved ranged comparison value [117] if(init_screen::m#1!=rangelast(0,$18)) goto init_screen::@3 to (number) $19
Simplifying expression containing zero init_screen::COLS#3 in [110] *((byte*) init_screen::COLS#3 + (byte) 0) ← (const byte) init_screen::WHITE#0
Successful SSA optimization PassNSimplifyExpressionWithZero
Adding number conversion cast (unumber) 9 in if((byte) main::k#1!=(number) 9) goto main::@1
Adding number conversion cast (unumber) 9 in if((byte) main::j#1!=(number) 9) goto main::@4
Adding number conversion cast (unumber) 9 in if((byte) main::i#1!=(number) 9) goto main::@3
Adding number conversion cast (unumber) $28 in if((byte) init_screen::l#1!=(number) $28) goto init_screen::@1
Adding number conversion cast (unumber) $19 in if((byte) init_screen::m#1!=(number) $19) goto init_screen::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 9
Simplifying constant integer cast 9
Simplifying constant integer cast 9
Simplifying constant integer cast $28
Simplifying constant integer cast $19
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $19
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [27] (byte*~) print_cls::$0 ← (const byte*) print_screen#0 + (word) $3e8
Constant right-side identified [31] (byte*) main::at#0 ← (const byte*) main::at_line#0 + (byte) 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) print_cls::$0 = print_screen#0+$3e8
Constant (const byte*) main::at#0 = main::at_line#0+4
Successful SSA optimization Pass2ConstantIdentification
Inlining Noop Cast [8] (byte) print_byte_at::b#0 ← (byte)(signed byte) print_sbyte_at::b#6 keeping print_sbyte_at::b#6
Successful SSA optimization Pass2NopCastInlining
Inlining constant with var siblings (const byte) print_char_at::ch#0
Inlining constant with var siblings (const byte) print_char_at::ch#1
Inlining constant with var siblings (const byte*) print_cls::sc#0
Inlining constant with var siblings (const byte*) main::at_line#0
Inlining constant with var siblings (const byte) main::k#0
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with var siblings (const byte) main::j#0
Inlining constant with var siblings (const byte*) main::at#0
Inlining constant with var siblings (const byte*) init_screen::COLS#0
Inlining constant with var siblings (const byte) init_screen::l#0
Inlining constant with var siblings (const byte) init_screen::m#0
Constant inlined print_cls::$0 = (const byte*) print_screen#0+(word) $3e8
Constant inlined print_cls::sc#0 = (const byte*) print_screen#0
Constant inlined $0 = (const byte[]) print_hextab#0
Constant inlined main::at#0 = (byte*) 1024+(byte) 4
Constant inlined print_char_at::ch#0 = (byte) '-'
Constant inlined init_screen::m#0 = (byte) 0
Constant inlined print_char_at::ch#1 = (byte) ' '
Constant inlined init_screen::l#0 = (byte) 0
Constant inlined main::i#0 = (byte) 0
Constant inlined main::k#0 = (byte) 0
Constant inlined main::j#0 = (byte) 0
Constant inlined main::at_line#0 = (byte*) 1024
Constant inlined init_screen::COLS#0 = (byte*) 55296
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting print_cls::@3(between print_cls::@1 and print_cls::@1)
Added new block during phi lifting main::@12(between main::@8 and main::@1)
Added new block during phi lifting main::@13(between main::@5 and main::@3)
Added new block during phi lifting main::@14(between main::@11 and main::@4)
Added new block during phi lifting init_screen::@6(between init_screen::@1 and init_screen::@1)
Added new block during phi lifting init_screen::@7(between init_screen::@3 and init_screen::@3)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @12
Adding NOP phi() at start of @19
Adding NOP phi() at start of @21
Adding NOP phi() at start of @23
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of print_sbyte_at::@7
Adding NOP phi() at start of print_byte_at::@2
Adding NOP phi() at start of init_screen
Adding NOP phi() at start of init_screen::@5
Adding NOP phi() at start of init_screen::@2
Adding NOP phi() at start of print_cls
CALL GRAPH
Calls in [] to main:6 
Calls in [main] to init_screen:10 print_sbyte_at:17 print_sbyte_at:28 fmul8:34 print_sbyte_at:41 
Calls in [print_sbyte_at] to print_char_at:57 print_byte_at:61 print_char_at:66 
Calls in [print_byte_at] to print_char_at:77 print_char_at:83 
Calls in [init_screen] to print_cls:92 

Created 15 initial phi equivalence classes
Coalesced [15] print_sbyte_at::b#10 ← print_sbyte_at::b#1
Coalesced [16] print_sbyte_at::at#9 ← print_sbyte_at::at#0
Coalesced [26] print_sbyte_at::b#12 ← print_sbyte_at::b#2
Coalesced [27] print_sbyte_at::at#11 ← print_sbyte_at::at#1
Not coalescing [29] main::at#12 ← main::at#2
Coalesced [39] print_sbyte_at::b#11 ← print_sbyte_at::b#3
Coalesced [40] print_sbyte_at::at#10 ← print_sbyte_at::at#2
Coalesced [47] main::at_line#11 ← main::at#2
Coalesced [48] main::i#8 ← main::i#1
Coalesced [49] main::at#11 ← main::at#3
Coalesced [50] main::j#5 ← main::j#1
Coalesced [51] main::k#4 ← main::k#1
Coalesced [52] main::at#10 ← main::at#1
Coalesced [56] print_char_at::at#8 ← print_char_at::at#1
Coalesced [58] print_sbyte_at::b#14 ← print_sbyte_at::b#4
Coalesced [65] print_char_at::at#7 ← print_char_at::at#0
Coalesced [68] print_sbyte_at::b#13 ← print_sbyte_at::b#0
Coalesced [75] print_char_at::ch#5 ← print_char_at::ch#2
Coalesced [76] print_char_at::at#5 ← print_char_at::at#2
Coalesced [81] print_char_at::ch#6 ← print_char_at::ch#3
Coalesced [82] print_char_at::at#6 ← print_char_at::at#3
Coalesced [108] init_screen::COLS#5 ← init_screen::COLS#1
Coalesced [109] init_screen::m#3 ← init_screen::m#1
Coalesced [110] init_screen::l#3 ← init_screen::l#1
Coalesced [117] print_cls::sc#3 ← print_cls::sc#1
Coalesced down to 14 phi equivalence classes
Culled Empty Block (label) @12
Culled Empty Block (label) @19
Culled Empty Block (label) @21
Culled Empty Block (label) @23
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@13
Culled Empty Block (label) main::@14
Culled Empty Block (label) main::@12
Culled Empty Block (label) print_sbyte_at::@6
Culled Empty Block (label) print_sbyte_at::@7
Culled Empty Block (label) print_byte_at::@2
Culled Empty Block (label) init_screen::@5
Culled Empty Block (label) init_screen::@2
Culled Empty Block (label) init_screen::@7
Culled Empty Block (label) init_screen::@6
Culled Empty Block (label) print_cls::@3
Renumbering block @22 to @1
Renumbering block print_sbyte_at::@5 to print_sbyte_at::@4
Renumbering block main::@3 to main::@2
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block main::@8 to main::@5
Renumbering block main::@9 to main::@6
Renumbering block main::@10 to main::@7
Renumbering block main::@11 to main::@8
Renumbering block init_screen::@3 to init_screen::@2
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of init_screen
Adding NOP phi() at start of print_cls

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  kickasm(location (const byte*) mulf_sqr1#0) {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }
 }}
  kickasm(location (const byte*) mulf_sqr2#0) {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }
 }}
  [3] call main 
  to:@end
@end: scope:[]  from @1
  [4] phi()
main: scope:[main]  from @1
  [5] phi()
  [6] call init_screen 
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [7] (byte*) main::at#4 ← phi( main/(byte*) 1024+(byte) 4 main::@5/(byte*) main::at#1 )
  [7] (byte) main::k#2 ← phi( main/(byte) 0 main::@5/(byte) main::k#1 )
  [8] (signed byte) print_sbyte_at::b#1 ← *((const signed byte[]) vals#0 + (byte) main::k#2)
  [9] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4
  [10] call print_sbyte_at 
  to:main::@5
main::@5: scope:[main]  from main::@1
  [11] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4
  [12] (byte) main::k#1 ← ++ (byte) main::k#2
  [13] if((byte) main::k#1!=(byte) 9) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@4 main::@5
  [14] (byte) main::i#2 ← phi( main::@5/(byte) 0 main::@4/(byte) main::i#1 )
  [14] (byte*) main::at_line#2 ← phi( main::@5/(byte*) 1024 main::@4/(byte*) main::at#2 )
  [15] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28
  [16] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2)
  [17] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2
  [18] call print_sbyte_at 
  to:main::@6
main::@6: scope:[main]  from main::@2
  [19] (byte*~) main::at#12 ← (byte*) main::at#2
  to:main::@3
main::@3: scope:[main]  from main::@6 main::@8
  [20] (byte) main::j#2 ← phi( main::@8/(byte) main::j#1 main::@6/(byte) 0 )
  [20] (byte*) main::at#6 ← phi( main::@8/(byte*) main::at#3 main::@6/(byte*~) main::at#12 )
  [21] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4
  [22] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2)
  [23] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2)
  [24] call fmul8 
  [25] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1
  to:main::@7
main::@7: scope:[main]  from main::@3
  [26] (signed byte) main::r#0 ← (signed byte) fmul8::return#0
  [27] (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0
  [28] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3
  [29] call print_sbyte_at 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [30] (byte) main::j#1 ← ++ (byte) main::j#2
  [31] if((byte) main::j#1!=(byte) 9) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@8
  [32] (byte) main::i#1 ← ++ (byte) main::i#2
  [33] if((byte) main::i#1!=(byte) 9) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@4
  [34] return 
  to:@return
print_sbyte_at: scope:[print_sbyte_at]  from main::@1 main::@2 main::@7
  [35] (byte*) print_sbyte_at::at#3 ← phi( main::@1/(byte*) print_sbyte_at::at#0 main::@7/(byte*) print_sbyte_at::at#2 main::@2/(byte*) print_sbyte_at::at#1 )
  [35] (signed byte) print_sbyte_at::b#4 ← phi( main::@1/(signed byte) print_sbyte_at::b#1 main::@7/(signed byte) print_sbyte_at::b#3 main::@2/(signed byte) print_sbyte_at::b#2 )
  [36] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1
  to:print_sbyte_at::@3
print_sbyte_at::@3: scope:[print_sbyte_at]  from print_sbyte_at
  [37] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3
  [38] call print_char_at 
  to:print_sbyte_at::@2
print_sbyte_at::@2: scope:[print_sbyte_at]  from print_sbyte_at::@3 print_sbyte_at::@4
  [39] (signed byte) print_sbyte_at::b#6 ← phi( print_sbyte_at::@4/(signed byte) print_sbyte_at::b#0 print_sbyte_at::@3/(signed byte) print_sbyte_at::b#4 )
  [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1
  [41] call print_byte_at 
  to:print_sbyte_at::@return
print_sbyte_at::@return: scope:[print_sbyte_at]  from print_sbyte_at::@2
  [42] return 
  to:@return
print_sbyte_at::@1: scope:[print_sbyte_at]  from print_sbyte_at
  [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3
  [44] call print_char_at 
  to:print_sbyte_at::@4
print_sbyte_at::@4: scope:[print_sbyte_at]  from print_sbyte_at::@1
  [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4
  to:print_sbyte_at::@2
print_char_at: scope:[print_char_at]  from print_byte_at print_byte_at::@1 print_sbyte_at::@1 print_sbyte_at::@3
  [46] (byte*) print_char_at::at#4 ← phi( print_byte_at/(byte*) print_char_at::at#2 print_byte_at::@1/(byte*) print_char_at::at#3 print_sbyte_at::@1/(byte*) print_char_at::at#0 print_sbyte_at::@3/(byte*) print_char_at::at#1 )
  [46] (byte) print_char_at::ch#4 ← phi( print_byte_at/(byte) print_char_at::ch#2 print_byte_at::@1/(byte) print_char_at::ch#3 print_sbyte_at::@1/(byte) '-' print_sbyte_at::@3/(byte) ' ' )
  [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  [48] return 
  to:@return
print_byte_at: scope:[print_byte_at]  from print_sbyte_at::@2
  [49] (byte~) print_byte_at::$0 ← (byte)(signed byte) print_sbyte_at::b#6 >> (byte) 4
  [50] (byte) print_char_at::ch#2 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0)
  [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0
  [52] call print_char_at 
  to:print_byte_at::@1
print_byte_at::@1: scope:[print_byte_at]  from print_byte_at
  [53] (byte~) print_byte_at::$2 ← (byte)(signed byte) print_sbyte_at::b#6 & (byte) $f
  [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1
  [55] (byte) print_char_at::ch#3 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2)
  [56] call print_char_at 
  to:print_byte_at::@return
print_byte_at::@return: scope:[print_byte_at]  from print_byte_at::@1
  [57] return 
  to:@return
fmul8: scope:[fmul8]  from main::@3
  [58] *((const signed byte*) ap#0) ← (signed byte) fmul8::a#0
  [59] *((const signed byte*) bp#0) ← (signed byte) fmul8::b#0
  asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
  [61] (signed byte) fmul8::return#1 ← *((const signed byte*) cp#0)
  to:fmul8::@return
fmul8::@return: scope:[fmul8]  from fmul8
  [62] return 
  to:@return
init_screen: scope:[init_screen]  from main
  [63] phi()
  [64] call print_cls 
  to:init_screen::@1
init_screen::@1: scope:[init_screen]  from init_screen init_screen::@1
  [65] (byte) init_screen::l#2 ← phi( init_screen::@1/(byte) init_screen::l#1 init_screen/(byte) 0 )
  [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0
  [67] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2
  [68] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1
  to:init_screen::@2
init_screen::@2: scope:[init_screen]  from init_screen::@1 init_screen::@2
  [69] (byte) init_screen::m#2 ← phi( init_screen::@1/(byte) 0 init_screen::@2/(byte) init_screen::m#1 )
  [69] (byte*) init_screen::COLS#3 ← phi( init_screen::@1/(byte*) 55296 init_screen::@2/(byte*) init_screen::COLS#1 )
  [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0
  [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0
  [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0
  [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0
  [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28
  [75] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2
  [76] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2
  to:init_screen::@return
init_screen::@return: scope:[init_screen]  from init_screen::@2
  [77] return 
  to:@return
print_cls: scope:[print_cls]  from init_screen
  [78] phi()
  to:print_cls::@1
print_cls::@1: scope:[print_cls]  from print_cls print_cls::@1
  [79] (byte*) print_cls::sc#2 ← phi( print_cls/(const byte*) print_screen#0 print_cls::@1/(byte*) print_cls::sc#1 )
  [80] *((byte*) print_cls::sc#2) ← (byte) ' '
  [81] (byte*) print_cls::sc#1 ← ++ (byte*) print_cls::sc#2
  [82] if((byte*) print_cls::sc#1!=(const byte*) print_screen#0+(word) $3e8) goto print_cls::@1
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls::@1
  [83] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(signed byte*) ap
(signed byte*) bp
(signed byte*) cp
(signed byte()) fmul8((signed byte) fmul8::a , (signed byte) fmul8::b)
(signed byte) fmul8::a
(signed byte) fmul8::a#0 51.5
(signed byte) fmul8::b
(signed byte) fmul8::b#0 51.5
(signed byte) fmul8::return
(signed byte) fmul8::return#0 202.0
(signed byte) fmul8::return#1 34.33333333333333
(void()) init_screen()
(byte*) init_screen::COLS
(byte*) init_screen::COLS#1 7.333333333333333
(byte*) init_screen::COLS#3 13.2
(byte) init_screen::WHITE
(byte) init_screen::l
(byte) init_screen::l#1 16.5
(byte) init_screen::l#2 16.5
(byte) init_screen::m
(byte) init_screen::m#1 16.5
(byte) init_screen::m#2 3.6666666666666665
(void()) main()
(byte*) main::at
(byte*) main::at#1 7.333333333333333
(byte*~) main::at#12 22.0
(byte*) main::at#2 2.3157894736842106
(byte*) main::at#3 27.545454545454547
(byte*) main::at#4 8.25
(byte*) main::at#6 213.0
(byte*) main::at_line
(byte*) main::at_line#2 22.0
(byte) main::i
(byte) main::i#1 16.5
(byte) main::i#2 7.444444444444445
(byte) main::j
(byte) main::j#1 151.5
(byte) main::j#2 30.299999999999997
(byte) main::k
(byte) main::k#1 16.5
(byte) main::k#2 6.6000000000000005
(signed byte) main::r
(signed byte) main::r#0 202.0
(byte*) mulf_sqr1
(byte*) mulf_sqr2
(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
(byte~) print_byte_at::$0 4.0
(byte~) print_byte_at::$2 2.0
(byte*) print_byte_at::at
(byte*) print_byte_at::at#0 1.0
(byte) print_byte_at::b
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(byte*) print_char_at::at
(byte*) print_char_at::at#0 4.0
(byte*) print_char_at::at#1 4.0
(byte*) print_char_at::at#2 4.0
(byte*) print_char_at::at#3 2.0
(byte*) print_char_at::at#4 10.0
(byte) print_char_at::ch
(byte) print_char_at::ch#2 2.0
(byte) print_char_at::ch#3 4.0
(byte) print_char_at::ch#4 6.0
(void()) print_cls()
(byte*) print_cls::sc
(byte*) print_cls::sc#1 16.5
(byte*) print_cls::sc#2 16.5
(byte[]) print_hextab
(void()) print_sbyte_at((signed byte) print_sbyte_at::b , (byte*) print_sbyte_at::at)
(byte*) print_sbyte_at::at
(byte*) print_sbyte_at::at#0 22.0
(byte*) print_sbyte_at::at#1 22.0
(byte*) print_sbyte_at::at#2 202.0
(byte*) print_sbyte_at::at#3 16.125
(signed byte) print_sbyte_at::b
(signed byte) print_sbyte_at::b#0 4.0
(signed byte) print_sbyte_at::b#1 11.0
(signed byte) print_sbyte_at::b#2 11.0
(signed byte) print_sbyte_at::b#3 101.0
(signed byte) print_sbyte_at::b#4 21.499999999999993
(signed byte) print_sbyte_at::b#6 0.6666666666666666
(byte*) print_screen
(signed byte[]) vals

Initial phi equivalence classes
[ main::k#2 main::k#1 ]
[ main::at#4 main::at#1 ]
[ main::at_line#2 main::at#2 ]
[ main::i#2 main::i#1 ]
[ main::at#6 main::at#3 main::at#12 ]
[ main::j#2 main::j#1 ]
[ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ]
[ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
[ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
[ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ]
[ init_screen::l#2 init_screen::l#1 ]
[ init_screen::COLS#3 init_screen::COLS#1 ]
[ init_screen::m#2 init_screen::m#1 ]
[ print_cls::sc#2 print_cls::sc#1 ]
Added variable fmul8::a#0 to zero page equivalence class [ fmul8::a#0 ]
Added variable fmul8::b#0 to zero page equivalence class [ fmul8::b#0 ]
Added variable fmul8::return#0 to zero page equivalence class [ fmul8::return#0 ]
Added variable main::r#0 to zero page equivalence class [ main::r#0 ]
Added variable print_byte_at::at#0 to zero page equivalence class [ print_byte_at::at#0 ]
Added variable print_byte_at::$0 to zero page equivalence class [ print_byte_at::$0 ]
Added variable print_byte_at::$2 to zero page equivalence class [ print_byte_at::$2 ]
Added variable fmul8::return#1 to zero page equivalence class [ fmul8::return#1 ]
Complete equivalence classes
[ main::k#2 main::k#1 ]
[ main::at#4 main::at#1 ]
[ main::at_line#2 main::at#2 ]
[ main::i#2 main::i#1 ]
[ main::at#6 main::at#3 main::at#12 ]
[ main::j#2 main::j#1 ]
[ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ]
[ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
[ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
[ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ]
[ init_screen::l#2 init_screen::l#1 ]
[ init_screen::COLS#3 init_screen::COLS#1 ]
[ init_screen::m#2 init_screen::m#1 ]
[ print_cls::sc#2 print_cls::sc#1 ]
[ fmul8::a#0 ]
[ fmul8::b#0 ]
[ fmul8::return#0 ]
[ main::r#0 ]
[ print_byte_at::at#0 ]
[ print_byte_at::$0 ]
[ print_byte_at::$2 ]
[ fmul8::return#1 ]
Allocated zp ZP_BYTE:2 [ main::k#2 main::k#1 ]
Allocated zp ZP_WORD:3 [ main::at#4 main::at#1 ]
Allocated zp ZP_WORD:5 [ main::at_line#2 main::at#2 ]
Allocated zp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Allocated zp ZP_WORD:8 [ main::at#6 main::at#3 main::at#12 ]
Allocated zp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Allocated zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ]
Allocated zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
Allocated zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
Allocated zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ]
Allocated zp ZP_BYTE:17 [ init_screen::l#2 init_screen::l#1 ]
Allocated zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ]
Allocated zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ]
Allocated zp ZP_WORD:21 [ print_cls::sc#2 print_cls::sc#1 ]
Allocated zp ZP_BYTE:23 [ fmul8::a#0 ]
Allocated zp ZP_BYTE:24 [ fmul8::b#0 ]
Allocated zp ZP_BYTE:25 [ fmul8::return#0 ]
Allocated zp ZP_BYTE:26 [ main::r#0 ]
Allocated zp ZP_WORD:27 [ print_byte_at::at#0 ]
Allocated zp ZP_BYTE:29 [ print_byte_at::$0 ]
Allocated zp ZP_BYTE:30 [ print_byte_at::$2 ]
Allocated zp ZP_BYTE:31 [ fmul8::return#1 ]

INITIAL ASM
//SEG0 File Comments
// Seriously fast multiply 8-bit version (8bit*8bit=8bit)
// Multiplies two signed 8-bit numbers and results in an 8-bit number
// C=A*B, A in [-64;64], B in [-96;95], C in [-96;95] - 64 acts a 1 (X*64=X)
// Uses the formula a*b = (a+b)^2/4 - (a-b)^2/4
// See the following for information about the method
// - http://codebase64.org/doku.php?id=base:seriously_fast_multiplication 
// - http://codebase64.org/doku.php?id=magazines:chacking16
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label print_screen = $400
  // Pointers to a, b and c=a*b
  .label ap = $fd
  .label bp = $fe
  .label cp = $ff
  // mulf_sqr tables will contain f(x)=int(x*x) and g(x) = f(1-x).
  // f(x) = >(( x * x ))
  .label mulf_sqr1 = $2000
  // g(x) =  >((( 1 - x ) * ( 1 - x )))
  .label mulf_sqr2 = $2200
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 kickasm(location (const byte*) mulf_sqr1#0) {{ .for(var i=0;i<$200;i++) {     	.if(i<=159) { .byte round((i*i)/256) }     	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }     	.if(i>351) { .byte round(((512-i)*(512-i))/256) }     }  }}
//SEG6 kickasm(location (const byte*) mulf_sqr2#0) {{ .for(var i=0;i<$200;i++) {     	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }     	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }     	.if(i>351) { .byte round(((i-511)*(i-511))/256) }       }  }}
//SEG7 [3] call main 
//SEG8 [5] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG9 [4] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG10 @end
bend:
//SEG11 main
main: {
    .label at = 3
    .label k = 2
    .label at_2 = 5
    .label at_3 = 8
    .label r = $1a
    .label j = $a
    .label i = 7
    .label at_line = 5
    .label at_6 = 8
    .label at_12 = 8
  //SEG12 [6] call init_screen 
  //SEG13 [63] phi from main to init_screen [phi:main->init_screen]
  init_screen_from_main:
    jsr init_screen
  //SEG14 [7] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG15 [7] phi (byte*) main::at#4 = (byte*) 1024+(byte) 4 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400+4
    sta at
    lda #>$400+4
    sta at+1
  //SEG16 [7] phi (byte) main::k#2 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta k
    jmp b1
  //SEG17 [7] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  b1_from_b5:
  //SEG18 [7] phi (byte*) main::at#4 = (byte*) main::at#1 [phi:main::@5->main::@1#0] -- register_copy 
  //SEG19 [7] phi (byte) main::k#2 = (byte) main::k#1 [phi:main::@5->main::@1#1] -- register_copy 
    jmp b1
  //SEG20 main::@1
  b1:
  //SEG21 [8] (signed byte) print_sbyte_at::b#1 ← *((const signed byte[]) vals#0 + (byte) main::k#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy k
    lda vals,y
    sta print_sbyte_at.b
  //SEG22 [9] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 -- pbuz1=pbuz2 
    lda at
    sta print_sbyte_at.at
    lda at+1
    sta print_sbyte_at.at+1
  //SEG23 [10] call print_sbyte_at 
  //SEG24 [35] phi from main::@1 to print_sbyte_at [phi:main::@1->print_sbyte_at]
  print_sbyte_at_from_b1:
  //SEG25 [35] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#0 [phi:main::@1->print_sbyte_at#0] -- register_copy 
  //SEG26 [35] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#1 [phi:main::@1->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b5
  //SEG27 main::@5
  b5:
  //SEG28 [11] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at
    sta at
    bcc !+
    inc at+1
  !:
  //SEG29 [12] (byte) main::k#1 ← ++ (byte) main::k#2 -- vbuz1=_inc_vbuz1 
    inc k
  //SEG30 [13] if((byte) main::k#1!=(byte) 9) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp k
    bne b1_from_b5
  //SEG31 [14] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  b2_from_b5:
  //SEG32 [14] phi (byte) main::i#2 = (byte) 0 [phi:main::@5->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta i
  //SEG33 [14] phi (byte*) main::at_line#2 = (byte*) 1024 [phi:main::@5->main::@2#1] -- pbuz1=pbuc1 
    lda #<$400
    sta at_line
    lda #>$400
    sta at_line+1
    jmp b2
  //SEG34 [14] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  b2_from_b4:
  //SEG35 [14] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@4->main::@2#0] -- register_copy 
  //SEG36 [14] phi (byte*) main::at_line#2 = (byte*) main::at#2 [phi:main::@4->main::@2#1] -- register_copy 
    jmp b2
  //SEG37 main::@2
  b2:
  //SEG38 [15] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc at_2
    sta at_2
    bcc !+
    inc at_2+1
  !:
  //SEG39 [16] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda vals,y
    sta print_sbyte_at.b
  //SEG40 [17] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at_2
    sta print_sbyte_at.at
    lda at_2+1
    sta print_sbyte_at.at+1
  //SEG41 [18] call print_sbyte_at 
  //SEG42 [35] phi from main::@2 to print_sbyte_at [phi:main::@2->print_sbyte_at]
  print_sbyte_at_from_b2:
  //SEG43 [35] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#1 [phi:main::@2->print_sbyte_at#0] -- register_copy 
  //SEG44 [35] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#2 [phi:main::@2->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b6
  //SEG45 main::@6
  b6:
  //SEG46 [19] (byte*~) main::at#12 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at_2
    sta at_12
    lda at_2+1
    sta at_12+1
  //SEG47 [20] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  b3_from_b6:
  //SEG48 [20] phi (byte) main::j#2 = (byte) 0 [phi:main::@6->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta j
  //SEG49 [20] phi (byte*) main::at#6 = (byte*~) main::at#12 [phi:main::@6->main::@3#1] -- register_copy 
    jmp b3
  //SEG50 [20] phi from main::@8 to main::@3 [phi:main::@8->main::@3]
  b3_from_b8:
  //SEG51 [20] phi (byte) main::j#2 = (byte) main::j#1 [phi:main::@8->main::@3#0] -- register_copy 
  //SEG52 [20] phi (byte*) main::at#6 = (byte*) main::at#3 [phi:main::@8->main::@3#1] -- register_copy 
    jmp b3
  //SEG53 main::@3
  b3:
  //SEG54 [21] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at_3
    sta at_3
    bcc !+
    inc at_3+1
  !:
  //SEG55 [22] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda vals,y
    sta fmul8.a
  //SEG56 [23] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy j
    lda vals,y
    sta fmul8.b
  //SEG57 [24] call fmul8 
    jsr fmul8
  //SEG58 [25] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1 -- vbsz1=vbsz2 
    lda fmul8.return_1
    sta fmul8.return
    jmp b7
  //SEG59 main::@7
  b7:
  //SEG60 [26] (signed byte) main::r#0 ← (signed byte) fmul8::return#0 -- vbsz1=vbsz2 
    lda fmul8.return
    sta r
  //SEG61 [27] (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0 -- vbsz1=vbsz2 
    lda r
    sta print_sbyte_at.b
  //SEG62 [28] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 -- pbuz1=pbuz2 
    lda at_3
    sta print_sbyte_at.at
    lda at_3+1
    sta print_sbyte_at.at+1
  //SEG63 [29] call print_sbyte_at 
  //SEG64 [35] phi from main::@7 to print_sbyte_at [phi:main::@7->print_sbyte_at]
  print_sbyte_at_from_b7:
  //SEG65 [35] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#2 [phi:main::@7->print_sbyte_at#0] -- register_copy 
  //SEG66 [35] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#3 [phi:main::@7->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b8
  //SEG67 main::@8
  b8:
  //SEG68 [30] (byte) main::j#1 ← ++ (byte) main::j#2 -- vbuz1=_inc_vbuz1 
    inc j
  //SEG69 [31] if((byte) main::j#1!=(byte) 9) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp j
    bne b3_from_b8
    jmp b4
  //SEG70 main::@4
  b4:
  //SEG71 [32] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG72 [33] if((byte) main::i#1!=(byte) 9) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp i
    bne b2_from_b4
    jmp breturn
  //SEG73 main::@return
  breturn:
  //SEG74 [34] return 
    rts
}
//SEG75 print_sbyte_at
// Print a signed byte as hex at a specific screen position
// print_sbyte_at(signed byte zeropage($d) b, byte* zeropage($b) at)
print_sbyte_at: {
    .label b = $d
    .label at = $b
  //SEG76 [36] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1 -- vbsz1_lt_0_then_la1 
    lda b
    bmi b1
    jmp b3
  //SEG77 print_sbyte_at::@3
  b3:
  //SEG78 [37] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3 -- pbuz1=pbuz2 
    lda at
    sta print_char_at.at
    lda at+1
    sta print_char_at.at+1
  //SEG79 [38] call print_char_at 
  //SEG80 [46] phi from print_sbyte_at::@3 to print_char_at [phi:print_sbyte_at::@3->print_char_at]
  print_char_at_from_b3:
  //SEG81 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#1 [phi:print_sbyte_at::@3->print_char_at#0] -- register_copy 
  //SEG82 [46] phi (byte) print_char_at::ch#4 = (byte) ' ' [phi:print_sbyte_at::@3->print_char_at#1] -- vbuz1=vbuc1 
    lda #' '
    sta print_char_at.ch
    jsr print_char_at
  //SEG83 [39] phi from print_sbyte_at::@3 print_sbyte_at::@4 to print_sbyte_at::@2 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2]
  b2_from_b3:
  b2_from_b4:
  //SEG84 [39] phi (signed byte) print_sbyte_at::b#6 = (signed byte) print_sbyte_at::b#4 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2#0] -- register_copy 
    jmp b2
  //SEG85 print_sbyte_at::@2
  b2:
  //SEG86 [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda at
    clc
    adc #1
    sta print_byte_at.at
    lda at+1
    adc #0
    sta print_byte_at.at+1
  //SEG87 [41] call print_byte_at 
    jsr print_byte_at
    jmp breturn
  //SEG88 print_sbyte_at::@return
  breturn:
  //SEG89 [42] return 
    rts
  //SEG90 print_sbyte_at::@1
  b1:
  //SEG91 [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3 -- pbuz1=pbuz2 
    lda at
    sta print_char_at.at
    lda at+1
    sta print_char_at.at+1
  //SEG92 [44] call print_char_at 
  //SEG93 [46] phi from print_sbyte_at::@1 to print_char_at [phi:print_sbyte_at::@1->print_char_at]
  print_char_at_from_b1:
  //SEG94 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#0 [phi:print_sbyte_at::@1->print_char_at#0] -- register_copy 
  //SEG95 [46] phi (byte) print_char_at::ch#4 = (byte) '-' [phi:print_sbyte_at::@1->print_char_at#1] -- vbuz1=vbuc1 
    lda #'-'
    sta print_char_at.ch
    jsr print_char_at
    jmp b4
  //SEG96 print_sbyte_at::@4
  b4:
  //SEG97 [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 -- vbsz1=_neg_vbsz1 
    lda b
    eor #$ff
    clc
    adc #1
    sta b
    jmp b2_from_b4
}
//SEG98 print_char_at
// Print a single char
// print_char_at(byte zeropage($e) ch, byte* zeropage($f) at)
print_char_at: {
    .label at = $f
    .label ch = $e
  //SEG99 [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 -- _deref_pbuz1=vbuz2 
    lda ch
    ldy #0
    sta (at),y
    jmp breturn
  //SEG100 print_char_at::@return
  breturn:
  //SEG101 [48] return 
    rts
}
//SEG102 print_byte_at
// Print a byte as HEX at a specific position
// print_byte_at(byte* zeropage($1b) at)
print_byte_at: {
    .label _0 = $1d
    .label _2 = $1e
    .label at = $1b
  //SEG103 [49] (byte~) print_byte_at::$0 ← (byte)(signed byte) print_sbyte_at::b#6 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda print_sbyte_at.b
    lsr
    lsr
    lsr
    lsr
    sta _0
  //SEG104 [50] (byte) print_char_at::ch#2 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy _0
    lda print_hextab,y
    sta print_char_at.ch
  //SEG105 [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0 -- pbuz1=pbuz2 
    lda at
    sta print_char_at.at
    lda at+1
    sta print_char_at.at+1
  //SEG106 [52] call print_char_at 
  //SEG107 [46] phi from print_byte_at to print_char_at [phi:print_byte_at->print_char_at]
  print_char_at_from_print_byte_at:
  //SEG108 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#2 [phi:print_byte_at->print_char_at#0] -- register_copy 
  //SEG109 [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#2 [phi:print_byte_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp b1
  //SEG110 print_byte_at::@1
  b1:
  //SEG111 [53] (byte~) print_byte_at::$2 ← (byte)(signed byte) print_sbyte_at::b#6 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and print_sbyte_at.b
    sta _2
  //SEG112 [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda at
    clc
    adc #1
    sta print_char_at.at
    lda at+1
    adc #0
    sta print_char_at.at+1
  //SEG113 [55] (byte) print_char_at::ch#3 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy _2
    lda print_hextab,y
    sta print_char_at.ch
  //SEG114 [56] call print_char_at 
  //SEG115 [46] phi from print_byte_at::@1 to print_char_at [phi:print_byte_at::@1->print_char_at]
  print_char_at_from_b1:
  //SEG116 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#3 [phi:print_byte_at::@1->print_char_at#0] -- register_copy 
  //SEG117 [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#3 [phi:print_byte_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp breturn
  //SEG118 print_byte_at::@return
  breturn:
  //SEG119 [57] return 
    rts
}
//SEG120 fmul8
// fmul8(signed byte zeropage($17) a, signed byte zeropage($18) b)
fmul8: {
    .label a = $17
    .label b = $18
    .label return = $19
    .label return_1 = $1f
  //SEG121 [58] *((const signed byte*) ap#0) ← (signed byte) fmul8::a#0 -- _deref_pbsc1=vbsz1 
    lda a
    sta ap
  //SEG122 [59] *((const signed byte*) bp#0) ← (signed byte) fmul8::b#0 -- _deref_pbsc1=vbsz1 
    lda b
    sta bp
  //SEG123 asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
    lda ap
    sta A1+1
    eor #$ff
    sta A2+1
    ldx bp
    sec
  A1:
    lda mulf_sqr1,x
  A2:
    sbc mulf_sqr2,x
    sta cp
  //SEG124 [61] (signed byte) fmul8::return#1 ← *((const signed byte*) cp#0) -- vbsz1=_deref_pbsc1 
    lda cp
    sta return_1
    jmp breturn
  //SEG125 fmul8::@return
  breturn:
  //SEG126 [62] return 
    rts
}
//SEG127 init_screen
init_screen: {
    .const WHITE = 1
    .label l = $11
    .label COLS = $12
    .label m = $14
  //SEG128 [64] call print_cls 
  //SEG129 [78] phi from init_screen to print_cls [phi:init_screen->print_cls]
  print_cls_from_init_screen:
    jsr print_cls
  //SEG130 [65] phi from init_screen to init_screen::@1 [phi:init_screen->init_screen::@1]
  b1_from_init_screen:
  //SEG131 [65] phi (byte) init_screen::l#2 = (byte) 0 [phi:init_screen->init_screen::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta l
    jmp b1
  //SEG132 [65] phi from init_screen::@1 to init_screen::@1 [phi:init_screen::@1->init_screen::@1]
  b1_from_b1:
  //SEG133 [65] phi (byte) init_screen::l#2 = (byte) init_screen::l#1 [phi:init_screen::@1->init_screen::@1#0] -- register_copy 
    jmp b1
  //SEG134 init_screen::@1
  b1:
  //SEG135 [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #WHITE
    ldy l
    sta $d800,y
  //SEG136 [67] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2 -- vbuz1=_inc_vbuz1 
    inc l
  //SEG137 [68] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp l
    bne b1_from_b1
  //SEG138 [69] phi from init_screen::@1 to init_screen::@2 [phi:init_screen::@1->init_screen::@2]
  b2_from_b1:
  //SEG139 [69] phi (byte) init_screen::m#2 = (byte) 0 [phi:init_screen::@1->init_screen::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta m
  //SEG140 [69] phi (byte*) init_screen::COLS#3 = (byte*) 55296 [phi:init_screen::@1->init_screen::@2#1] -- pbuz1=pbuc1 
    lda #<$d800
    sta COLS
    lda #>$d800
    sta COLS+1
    jmp b2
  //SEG141 [69] phi from init_screen::@2 to init_screen::@2 [phi:init_screen::@2->init_screen::@2]
  b2_from_b2:
  //SEG142 [69] phi (byte) init_screen::m#2 = (byte) init_screen::m#1 [phi:init_screen::@2->init_screen::@2#0] -- register_copy 
  //SEG143 [69] phi (byte*) init_screen::COLS#3 = (byte*) init_screen::COLS#1 [phi:init_screen::@2->init_screen::@2#1] -- register_copy 
    jmp b2
  //SEG144 init_screen::@2
  b2:
  //SEG145 [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 -- _deref_pbuz1=vbuc1 
    lda #WHITE
    ldy #0
    sta (COLS),y
  //SEG146 [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #1
    sta (COLS),y
  //SEG147 [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #2
    sta (COLS),y
  //SEG148 [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #3
    sta (COLS),y
  //SEG149 [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc COLS
    sta COLS
    bcc !+
    inc COLS+1
  !:
  //SEG150 [75] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG151 [76] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp m
    bne b2_from_b2
    jmp breturn
  //SEG152 init_screen::@return
  breturn:
  //SEG153 [77] return 
    rts
}
//SEG154 print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    .label sc = $15
  //SEG155 [79] phi from print_cls to print_cls::@1 [phi:print_cls->print_cls::@1]
  b1_from_print_cls:
  //SEG156 [79] phi (byte*) print_cls::sc#2 = (const byte*) print_screen#0 [phi:print_cls->print_cls::@1#0] -- pbuz1=pbuc1 
    lda #<print_screen
    sta sc
    lda #>print_screen
    sta sc+1
    jmp b1
  //SEG157 [79] phi from print_cls::@1 to print_cls::@1 [phi:print_cls::@1->print_cls::@1]
  b1_from_b1:
  //SEG158 [79] phi (byte*) print_cls::sc#2 = (byte*) print_cls::sc#1 [phi:print_cls::@1->print_cls::@1#0] -- register_copy 
    jmp b1
  //SEG159 print_cls::@1
  b1:
  //SEG160 [80] *((byte*) print_cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
  //SEG161 [81] (byte*) print_cls::sc#1 ← ++ (byte*) print_cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc sc
    bne !+
    inc sc+1
  !:
  //SEG162 [82] if((byte*) print_cls::sc#1!=(const byte*) print_screen#0+(word) $3e8) goto print_cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda sc+1
    cmp #>print_screen+$3e8
    bne b1_from_b1
    lda sc
    cmp #<print_screen+$3e8
    bne b1_from_b1
    jmp breturn
  //SEG163 print_cls::@return
  breturn:
  //SEG164 [83] return 
    rts
}
  print_hextab: .text "0123456789abcdef"
  vals: .byte -$5f, -$40, -$20, -$10, 0, $10, $20, $40, $5f
.pc = mulf_sqr1 "mulf_sqr1"
  .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }

.pc = mulf_sqr2 "mulf_sqr2"
  .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [9] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ( main:3 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::k#2 main::k#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
Statement [11] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 [ main::k#2 main::at#1 ] ( main:3 [ main::k#2 main::at#1 ] ) always clobbers reg byte a 
Statement [15] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 [ main::i#2 main::at#2 ] ( main:3 [ main::i#2 main::at#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Statement [17] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ( main:3 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ) always clobbers reg byte a 
Statement [19] (byte*~) main::at#12 ← (byte*) main::at#2 [ main::i#2 main::at#2 main::at#12 ] ( main:3 [ main::i#2 main::at#2 main::at#12 ] ) always clobbers reg byte a 
Statement [21] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Statement [28] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ) always clobbers reg byte a 
Statement [37] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ) always clobbers reg byte a 
Statement [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 [ print_sbyte_at::b#6 print_byte_at::at#0 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 ] ) always clobbers reg byte a 
Statement [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ) always clobbers reg byte a 
Statement [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 [ print_sbyte_at::at#3 print_sbyte_at::b#0 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::at#3 print_sbyte_at::b#0 ] ) always clobbers reg byte a 
Statement [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 [ ] ( main:3::print_sbyte_at:10::print_char_at:38 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:18::print_char_at:38 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:29::print_char_at:38 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:10::print_char_at:44 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:18::print_char_at:44 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:29::print_char_at:44 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:10::print_byte_at:41::print_char_at:52 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:18::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:29::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:10::print_byte_at:41::print_char_at:56 [ main::k#2 main::at#4 ] main:3::print_sbyte_at:18::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 ] main:3::print_sbyte_at:29::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:2 [ main::k#2 main::k#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Statement [49] (byte~) print_byte_at::$0 ← (byte)(signed byte) print_sbyte_at::b#6 >> (byte) 4 [ print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] ) always clobbers reg byte a 
Statement [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0 [ print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
Statement [53] (byte~) print_byte_at::$2 ← (byte)(signed byte) print_sbyte_at::b#6 & (byte) $f [ print_byte_at::at#0 print_byte_at::$2 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::at#0 print_byte_at::$2 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::at#0 print_byte_at::$2 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::at#0 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 [ print_char_at::at#3 print_byte_at::$2 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_char_at::at#3 print_byte_at::$2 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_char_at::at#3 print_byte_at::$2 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_char_at::at#3 print_byte_at::$2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:30 [ print_byte_at::$2 ]
Statement asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  } always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Statement [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 [ init_screen::l#2 ] ( main:3::init_screen:6 [ init_screen::l#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:17 [ init_screen::l#2 init_screen::l#1 ]
Statement [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ]
Statement [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 [ init_screen::m#2 init_screen::COLS#1 ] ( main:3::init_screen:6 [ init_screen::m#2 init_screen::COLS#1 ] ) always clobbers reg byte a 
Statement [80] *((byte*) print_cls::sc#2) ← (byte) ' ' [ print_cls::sc#2 ] ( main:3::init_screen:6::print_cls:64 [ print_cls::sc#2 ] ) always clobbers reg byte a reg byte y 
Statement [82] if((byte*) print_cls::sc#1!=(const byte*) print_screen#0+(word) $3e8) goto print_cls::@1 [ print_cls::sc#1 ] ( main:3::init_screen:6::print_cls:64 [ print_cls::sc#1 ] ) always clobbers reg byte a 
Statement [9] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ( main:3 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ) always clobbers reg byte a 
Statement [11] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 [ main::k#2 main::at#1 ] ( main:3 [ main::k#2 main::at#1 ] ) always clobbers reg byte a 
Statement [15] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 [ main::i#2 main::at#2 ] ( main:3 [ main::i#2 main::at#2 ] ) always clobbers reg byte a 
Statement [16] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) [ main::i#2 main::at#2 print_sbyte_at::b#2 ] ( main:3 [ main::i#2 main::at#2 print_sbyte_at::b#2 ] ) always clobbers reg byte y 
Statement [17] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ( main:3 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ) always clobbers reg byte a 
Statement [19] (byte*~) main::at#12 ← (byte*) main::at#2 [ main::i#2 main::at#2 main::at#12 ] ( main:3 [ main::i#2 main::at#2 main::at#12 ] ) always clobbers reg byte a 
Statement [21] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a 
Statement [22] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 ] ) always clobbers reg byte y 
Statement [23] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 fmul8::b#0 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 fmul8::b#0 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:23 [ fmul8::a#0 ]
Statement [28] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ) always clobbers reg byte a 
Statement [31] if((byte) main::j#1!=(byte) 9) goto main::@3 [ main::i#2 main::at#2 main::at#3 main::j#1 ] ( main:3 [ main::i#2 main::at#2 main::at#3 main::j#1 ] ) always clobbers reg byte a 
Statement [33] if((byte) main::i#1!=(byte) 9) goto main::@2 [ main::at#2 main::i#1 ] ( main:3 [ main::at#2 main::i#1 ] ) always clobbers reg byte a 
Statement [37] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ) always clobbers reg byte a 
Statement [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 [ print_sbyte_at::b#6 print_byte_at::at#0 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 ] ) always clobbers reg byte a 
Statement [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ) always clobbers reg byte a 
Statement [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 [ print_sbyte_at::at#3 print_sbyte_at::b#0 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::at#3 print_sbyte_at::b#0 ] ) always clobbers reg byte a 
Statement [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 [ ] ( main:3::print_sbyte_at:10::print_char_at:38 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:18::print_char_at:38 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:29::print_char_at:38 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:10::print_char_at:44 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:18::print_char_at:44 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:29::print_char_at:44 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:10::print_byte_at:41::print_char_at:52 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:18::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:29::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:10::print_byte_at:41::print_char_at:56 [ main::k#2 main::at#4 ] main:3::print_sbyte_at:18::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 ] main:3::print_sbyte_at:29::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a reg byte y 
Statement [49] (byte~) print_byte_at::$0 ← (byte)(signed byte) print_sbyte_at::b#6 >> (byte) 4 [ print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] ) always clobbers reg byte a 
Statement [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0 [ print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ) always clobbers reg byte a 
Statement [53] (byte~) print_byte_at::$2 ← (byte)(signed byte) print_sbyte_at::b#6 & (byte) $f [ print_byte_at::at#0 print_byte_at::$2 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::at#0 print_byte_at::$2 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::at#0 print_byte_at::$2 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::at#0 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 [ print_char_at::at#3 print_byte_at::$2 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_char_at::at#3 print_byte_at::$2 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_char_at::at#3 print_byte_at::$2 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_char_at::at#3 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  } always clobbers reg byte a reg byte x 
Statement [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 [ init_screen::l#2 ] ( main:3::init_screen:6 [ init_screen::l#2 ] ) always clobbers reg byte a 
Statement [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 [ init_screen::m#2 init_screen::COLS#1 ] ( main:3::init_screen:6 [ init_screen::m#2 init_screen::COLS#1 ] ) always clobbers reg byte a 
Statement [80] *((byte*) print_cls::sc#2) ← (byte) ' ' [ print_cls::sc#2 ] ( main:3::init_screen:6::print_cls:64 [ print_cls::sc#2 ] ) always clobbers reg byte a reg byte y 
Statement [82] if((byte*) print_cls::sc#1!=(const byte*) print_screen#0+(word) $3e8) goto print_cls::@1 [ print_cls::sc#1 ] ( main:3::init_screen:6::print_cls:64 [ print_cls::sc#1 ] ) always clobbers reg byte a 
Statement [9] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ( main:3 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ) always clobbers reg byte a 
Statement [11] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 [ main::k#2 main::at#1 ] ( main:3 [ main::k#2 main::at#1 ] ) always clobbers reg byte a 
Statement [15] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 [ main::i#2 main::at#2 ] ( main:3 [ main::i#2 main::at#2 ] ) always clobbers reg byte a 
Statement [16] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) [ main::i#2 main::at#2 print_sbyte_at::b#2 ] ( main:3 [ main::i#2 main::at#2 print_sbyte_at::b#2 ] ) always clobbers reg byte y 
Statement [17] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ( main:3 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ) always clobbers reg byte a 
Statement [19] (byte*~) main::at#12 ← (byte*) main::at#2 [ main::i#2 main::at#2 main::at#12 ] ( main:3 [ main::i#2 main::at#2 main::at#12 ] ) always clobbers reg byte a 
Statement [21] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a 
Statement [22] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 ] ) always clobbers reg byte y 
Statement [23] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 fmul8::b#0 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 fmul8::b#0 ] ) always clobbers reg byte y 
Statement [28] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ( main:3 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ) always clobbers reg byte a 
Statement [31] if((byte) main::j#1!=(byte) 9) goto main::@3 [ main::i#2 main::at#2 main::at#3 main::j#1 ] ( main:3 [ main::i#2 main::at#2 main::at#3 main::j#1 ] ) always clobbers reg byte a 
Statement [33] if((byte) main::i#1!=(byte) 9) goto main::@2 [ main::at#2 main::i#1 ] ( main:3 [ main::at#2 main::i#1 ] ) always clobbers reg byte a 
Statement [37] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ) always clobbers reg byte a 
Statement [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 [ print_sbyte_at::b#6 print_byte_at::at#0 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 ] ) always clobbers reg byte a 
Statement [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ) always clobbers reg byte a 
Statement [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 [ print_sbyte_at::at#3 print_sbyte_at::b#0 ] ( main:3::print_sbyte_at:10 [ main::k#2 main::at#4 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:3::print_sbyte_at:18 [ main::i#2 main::at#2 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:3::print_sbyte_at:29 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::at#3 print_sbyte_at::b#0 ] ) always clobbers reg byte a 
Statement [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 [ ] ( main:3::print_sbyte_at:10::print_char_at:38 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:18::print_char_at:38 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:29::print_char_at:38 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:10::print_char_at:44 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:18::print_char_at:44 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:29::print_char_at:44 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:3::print_sbyte_at:10::print_byte_at:41::print_char_at:52 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:18::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:29::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 ] main:3::print_sbyte_at:10::print_byte_at:41::print_char_at:56 [ main::k#2 main::at#4 ] main:3::print_sbyte_at:18::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 ] main:3::print_sbyte_at:29::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a reg byte y 
Statement [49] (byte~) print_byte_at::$0 ← (byte)(signed byte) print_sbyte_at::b#6 >> (byte) 4 [ print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 print_byte_at::$0 ] ) always clobbers reg byte a 
Statement [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0 [ print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#6 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ) always clobbers reg byte a 
Statement [53] (byte~) print_byte_at::$2 ← (byte)(signed byte) print_sbyte_at::b#6 & (byte) $f [ print_byte_at::at#0 print_byte_at::$2 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::at#0 print_byte_at::$2 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::at#0 print_byte_at::$2 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::at#0 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 [ print_char_at::at#3 print_byte_at::$2 ] ( main:3::print_sbyte_at:10::print_byte_at:41 [ main::k#2 main::at#4 print_char_at::at#3 print_byte_at::$2 ] main:3::print_sbyte_at:18::print_byte_at:41 [ main::i#2 main::at#2 print_char_at::at#3 print_byte_at::$2 ] main:3::print_sbyte_at:29::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_char_at::at#3 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  } always clobbers reg byte a reg byte x 
Statement [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 [ init_screen::l#2 ] ( main:3::init_screen:6 [ init_screen::l#2 ] ) always clobbers reg byte a 
Statement [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:3::init_screen:6 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 [ init_screen::m#2 init_screen::COLS#1 ] ( main:3::init_screen:6 [ init_screen::m#2 init_screen::COLS#1 ] ) always clobbers reg byte a 
Statement [80] *((byte*) print_cls::sc#2) ← (byte) ' ' [ print_cls::sc#2 ] ( main:3::init_screen:6::print_cls:64 [ print_cls::sc#2 ] ) always clobbers reg byte a reg byte y 
Statement [82] if((byte*) print_cls::sc#1!=(const byte*) print_screen#0+(word) $3e8) goto print_cls::@1 [ print_cls::sc#1 ] ( main:3::init_screen:6::print_cls:64 [ print_cls::sc#1 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::k#2 main::k#1 ] : zp ZP_BYTE:2 , reg byte x , 
Potential registers zp ZP_WORD:3 [ main::at#4 main::at#1 ] : zp ZP_WORD:3 , 
Potential registers zp ZP_WORD:5 [ main::at_line#2 main::at#2 ] : zp ZP_WORD:5 , 
Potential registers zp ZP_BYTE:7 [ main::i#2 main::i#1 ] : zp ZP_BYTE:7 , 
Potential registers zp ZP_WORD:8 [ main::at#6 main::at#3 main::at#12 ] : zp ZP_WORD:8 , 
Potential registers zp ZP_BYTE:10 [ main::j#2 main::j#1 ] : zp ZP_BYTE:10 , 
Potential registers zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ] : zp ZP_WORD:11 , 
Potential registers zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ] : zp ZP_BYTE:13 , reg byte x , 
Potential registers zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ] : zp ZP_BYTE:14 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] : zp ZP_WORD:15 , 
Potential registers zp ZP_BYTE:17 [ init_screen::l#2 init_screen::l#1 ] : zp ZP_BYTE:17 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ] : zp ZP_WORD:18 , 
Potential registers zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ] : zp ZP_BYTE:20 , reg byte x , 
Potential registers zp ZP_WORD:21 [ print_cls::sc#2 print_cls::sc#1 ] : zp ZP_WORD:21 , 
Potential registers zp ZP_BYTE:23 [ fmul8::a#0 ] : zp ZP_BYTE:23 , reg byte a , reg byte x , 
Potential registers zp ZP_BYTE:24 [ fmul8::b#0 ] : zp ZP_BYTE:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:25 [ fmul8::return#0 ] : zp ZP_BYTE:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:26 [ main::r#0 ] : zp ZP_BYTE:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:27 [ print_byte_at::at#0 ] : zp ZP_WORD:27 , 
Potential registers zp ZP_BYTE:29 [ print_byte_at::$0 ] : zp ZP_BYTE:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:30 [ print_byte_at::$2 ] : zp ZP_BYTE:30 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:31 [ fmul8::return#1 ] : zp ZP_BYTE:31 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 262.55: zp ZP_WORD:8 [ main::at#6 main::at#3 main::at#12 ] 202: zp ZP_BYTE:26 [ main::r#0 ] 181.8: zp ZP_BYTE:10 [ main::j#2 main::j#1 ] 24.32: zp ZP_WORD:5 [ main::at_line#2 main::at#2 ] 23.94: zp ZP_BYTE:7 [ main::i#2 main::i#1 ] 23.1: zp ZP_BYTE:2 [ main::k#2 main::k#1 ] 15.58: zp ZP_WORD:3 [ main::at#4 main::at#1 ] 
Uplift Scope [print_sbyte_at] 262.12: zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ] 149.17: zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ] 
Uplift Scope [fmul8] 202: zp ZP_BYTE:25 [ fmul8::return#0 ] 51.5: zp ZP_BYTE:23 [ fmul8::a#0 ] 51.5: zp ZP_BYTE:24 [ fmul8::b#0 ] 34.33: zp ZP_BYTE:31 [ fmul8::return#1 ] 
Uplift Scope [init_screen] 33: zp ZP_BYTE:17 [ init_screen::l#2 init_screen::l#1 ] 20.53: zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ] 20.17: zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ] 
Uplift Scope [print_char_at] 24: zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] 12: zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ] 
Uplift Scope [print_cls] 33: zp ZP_WORD:21 [ print_cls::sc#2 print_cls::sc#1 ] 
Uplift Scope [print_byte_at] 4: zp ZP_BYTE:29 [ print_byte_at::$0 ] 2: zp ZP_BYTE:30 [ print_byte_at::$2 ] 1: zp ZP_WORD:27 [ print_byte_at::at#0 ] 
Uplift Scope [] 

Uplifting [main] best 14035 combination zp ZP_WORD:8 [ main::at#6 main::at#3 main::at#12 ] reg byte a [ main::r#0 ] zp ZP_BYTE:10 [ main::j#2 main::j#1 ] zp ZP_WORD:5 [ main::at_line#2 main::at#2 ] zp ZP_BYTE:7 [ main::i#2 main::i#1 ] reg byte x [ main::k#2 main::k#1 ] zp ZP_WORD:3 [ main::at#4 main::at#1 ] 
Uplifting [print_sbyte_at] best 14035 combination zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ] zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ] 
Uplifting [fmul8] best 12528 combination reg byte a [ fmul8::return#0 ] reg byte a [ fmul8::a#0 ] reg byte x [ fmul8::b#0 ] reg byte a [ fmul8::return#1 ] 
Limited combination testing to 100 combinations of 192 possible.
Uplifting [init_screen] best 12318 combination reg byte x [ init_screen::l#2 init_screen::l#1 ] zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ] reg byte x [ init_screen::m#2 init_screen::m#1 ] 
Uplifting [print_char_at] best 12318 combination zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ] 
Uplifting [print_cls] best 12318 combination zp ZP_WORD:21 [ print_cls::sc#2 print_cls::sc#1 ] 
Uplifting [print_byte_at] best 12310 combination reg byte a [ print_byte_at::$0 ] reg byte y [ print_byte_at::$2 ] zp ZP_WORD:27 [ print_byte_at::at#0 ] 
Uplifting [] best 12310 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Uplifting [main] best 12310 combination zp ZP_BYTE:10 [ main::j#2 main::j#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
Uplifting [print_sbyte_at] best 12310 combination zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Uplifting [main] best 12310 combination zp ZP_BYTE:7 [ main::i#2 main::i#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
Uplifting [print_char_at] best 12310 combination zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ] 
Coalescing zero page register with common assignment [ zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ] ] with [ zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] ] - score: 2
Coalescing zero page register with common assignment [ zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] ] with [ zp ZP_WORD:27 [ print_byte_at::at#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:3 [ main::at#4 main::at#1 ] ] with [ zp ZP_WORD:5 [ main::at_line#2 main::at#2 ] ]
Coalescing zero page register [ zp ZP_WORD:3 [ main::at#4 main::at#1 main::at_line#2 main::at#2 ] ] with [ zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ] ]
Coalescing zero page register [ zp ZP_WORD:3 [ main::at#4 main::at#1 main::at_line#2 main::at#2 init_screen::COLS#3 init_screen::COLS#1 ] ] with [ zp ZP_WORD:21 [ print_cls::sc#2 print_cls::sc#1 ] ]
Allocated (was zp ZP_WORD:3) zp ZP_WORD:2 [ main::at#4 main::at#1 main::at_line#2 main::at#2 init_screen::COLS#3 init_screen::COLS#1 print_cls::sc#2 print_cls::sc#1 ]
Allocated (was zp ZP_BYTE:7) zp ZP_BYTE:4 [ main::i#2 main::i#1 ]
Allocated (was zp ZP_WORD:8) zp ZP_WORD:5 [ main::at#6 main::at#3 main::at#12 ]
Allocated (was zp ZP_BYTE:10) zp ZP_BYTE:7 [ main::j#2 main::j#1 ]
Allocated (was zp ZP_WORD:11) zp ZP_WORD:8 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 print_byte_at::at#0 ]
Allocated (was zp ZP_BYTE:13) zp ZP_BYTE:10 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
Allocated (was zp ZP_BYTE:14) zp ZP_BYTE:11 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Seriously fast multiply 8-bit version (8bit*8bit=8bit)
// Multiplies two signed 8-bit numbers and results in an 8-bit number
// C=A*B, A in [-64;64], B in [-96;95], C in [-96;95] - 64 acts a 1 (X*64=X)
// Uses the formula a*b = (a+b)^2/4 - (a-b)^2/4
// See the following for information about the method
// - http://codebase64.org/doku.php?id=base:seriously_fast_multiplication 
// - http://codebase64.org/doku.php?id=magazines:chacking16
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label print_screen = $400
  // Pointers to a, b and c=a*b
  .label ap = $fd
  .label bp = $fe
  .label cp = $ff
  // mulf_sqr tables will contain f(x)=int(x*x) and g(x) = f(1-x).
  // f(x) = >(( x * x ))
  .label mulf_sqr1 = $2000
  // g(x) =  >((( 1 - x ) * ( 1 - x )))
  .label mulf_sqr2 = $2200
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 kickasm(location (const byte*) mulf_sqr1#0) {{ .for(var i=0;i<$200;i++) {     	.if(i<=159) { .byte round((i*i)/256) }     	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }     	.if(i>351) { .byte round(((512-i)*(512-i))/256) }     }  }}
//SEG6 kickasm(location (const byte*) mulf_sqr2#0) {{ .for(var i=0;i<$200;i++) {     	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }     	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }     	.if(i>351) { .byte round(((i-511)*(i-511))/256) }       }  }}
//SEG7 [3] call main 
//SEG8 [5] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG9 [4] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG10 @end
bend:
//SEG11 main
main: {
    .label at = 2
    .label at_3 = 5
    .label j = 7
    .label i = 4
    .label at_line = 2
    .label at_6 = 5
    .label at_12 = 5
  //SEG12 [6] call init_screen 
  //SEG13 [63] phi from main to init_screen [phi:main->init_screen]
  init_screen_from_main:
    jsr init_screen
  //SEG14 [7] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG15 [7] phi (byte*) main::at#4 = (byte*) 1024+(byte) 4 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400+4
    sta at
    lda #>$400+4
    sta at+1
  //SEG16 [7] phi (byte) main::k#2 = (byte) 0 [phi:main->main::@1#1] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG17 [7] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  b1_from_b5:
  //SEG18 [7] phi (byte*) main::at#4 = (byte*) main::at#1 [phi:main::@5->main::@1#0] -- register_copy 
  //SEG19 [7] phi (byte) main::k#2 = (byte) main::k#1 [phi:main::@5->main::@1#1] -- register_copy 
    jmp b1
  //SEG20 main::@1
  b1:
  //SEG21 [8] (signed byte) print_sbyte_at::b#1 ← *((const signed byte[]) vals#0 + (byte) main::k#2) -- vbsz1=pbsc1_derefidx_vbuxx 
    lda vals,x
    sta print_sbyte_at.b
  //SEG22 [9] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 -- pbuz1=pbuz2 
    lda at
    sta print_sbyte_at.at
    lda at+1
    sta print_sbyte_at.at+1
  //SEG23 [10] call print_sbyte_at 
  //SEG24 [35] phi from main::@1 to print_sbyte_at [phi:main::@1->print_sbyte_at]
  print_sbyte_at_from_b1:
  //SEG25 [35] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#0 [phi:main::@1->print_sbyte_at#0] -- register_copy 
  //SEG26 [35] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#1 [phi:main::@1->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b5
  //SEG27 main::@5
  b5:
  //SEG28 [11] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at
    sta at
    bcc !+
    inc at+1
  !:
  //SEG29 [12] (byte) main::k#1 ← ++ (byte) main::k#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG30 [13] if((byte) main::k#1!=(byte) 9) goto main::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #9
    bne b1_from_b5
  //SEG31 [14] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  b2_from_b5:
  //SEG32 [14] phi (byte) main::i#2 = (byte) 0 [phi:main::@5->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta i
  //SEG33 [14] phi (byte*) main::at_line#2 = (byte*) 1024 [phi:main::@5->main::@2#1] -- pbuz1=pbuc1 
    lda #<$400
    sta at_line
    lda #>$400
    sta at_line+1
    jmp b2
  //SEG34 [14] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  b2_from_b4:
  //SEG35 [14] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@4->main::@2#0] -- register_copy 
  //SEG36 [14] phi (byte*) main::at_line#2 = (byte*) main::at#2 [phi:main::@4->main::@2#1] -- register_copy 
    jmp b2
  //SEG37 main::@2
  b2:
  //SEG38 [15] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc at
    sta at
    bcc !+
    inc at+1
  !:
  //SEG39 [16] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda vals,y
    sta print_sbyte_at.b
  //SEG40 [17] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at
    sta print_sbyte_at.at
    lda at+1
    sta print_sbyte_at.at+1
  //SEG41 [18] call print_sbyte_at 
  //SEG42 [35] phi from main::@2 to print_sbyte_at [phi:main::@2->print_sbyte_at]
  print_sbyte_at_from_b2:
  //SEG43 [35] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#1 [phi:main::@2->print_sbyte_at#0] -- register_copy 
  //SEG44 [35] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#2 [phi:main::@2->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b6
  //SEG45 main::@6
  b6:
  //SEG46 [19] (byte*~) main::at#12 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at
    sta at_12
    lda at+1
    sta at_12+1
  //SEG47 [20] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  b3_from_b6:
  //SEG48 [20] phi (byte) main::j#2 = (byte) 0 [phi:main::@6->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta j
  //SEG49 [20] phi (byte*) main::at#6 = (byte*~) main::at#12 [phi:main::@6->main::@3#1] -- register_copy 
    jmp b3
  //SEG50 [20] phi from main::@8 to main::@3 [phi:main::@8->main::@3]
  b3_from_b8:
  //SEG51 [20] phi (byte) main::j#2 = (byte) main::j#1 [phi:main::@8->main::@3#0] -- register_copy 
  //SEG52 [20] phi (byte*) main::at#6 = (byte*) main::at#3 [phi:main::@8->main::@3#1] -- register_copy 
    jmp b3
  //SEG53 main::@3
  b3:
  //SEG54 [21] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at_3
    sta at_3
    bcc !+
    inc at_3+1
  !:
  //SEG55 [22] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsaa=pbsc1_derefidx_vbuz1 
    ldy i
    lda vals,y
  //SEG56 [23] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy j
    ldx vals,y
  //SEG57 [24] call fmul8 
    jsr fmul8
  //SEG58 [25] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1
    jmp b7
  //SEG59 main::@7
  b7:
  //SEG60 [26] (signed byte) main::r#0 ← (signed byte) fmul8::return#0
  //SEG61 [27] (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0 -- vbsz1=vbsaa 
    sta print_sbyte_at.b
  //SEG62 [28] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 -- pbuz1=pbuz2 
    lda at_3
    sta print_sbyte_at.at
    lda at_3+1
    sta print_sbyte_at.at+1
  //SEG63 [29] call print_sbyte_at 
  //SEG64 [35] phi from main::@7 to print_sbyte_at [phi:main::@7->print_sbyte_at]
  print_sbyte_at_from_b7:
  //SEG65 [35] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#2 [phi:main::@7->print_sbyte_at#0] -- register_copy 
  //SEG66 [35] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#3 [phi:main::@7->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b8
  //SEG67 main::@8
  b8:
  //SEG68 [30] (byte) main::j#1 ← ++ (byte) main::j#2 -- vbuz1=_inc_vbuz1 
    inc j
  //SEG69 [31] if((byte) main::j#1!=(byte) 9) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp j
    bne b3_from_b8
    jmp b4
  //SEG70 main::@4
  b4:
  //SEG71 [32] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG72 [33] if((byte) main::i#1!=(byte) 9) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp i
    bne b2_from_b4
    jmp breturn
  //SEG73 main::@return
  breturn:
  //SEG74 [34] return 
    rts
}
//SEG75 print_sbyte_at
// Print a signed byte as hex at a specific screen position
// print_sbyte_at(signed byte zeropage($a) b, byte* zeropage(8) at)
print_sbyte_at: {
    .label b = $a
    .label at = 8
  //SEG76 [36] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1 -- vbsz1_lt_0_then_la1 
    lda b
    bmi b1
    jmp b3
  //SEG77 print_sbyte_at::@3
  b3:
  //SEG78 [37] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3
  //SEG79 [38] call print_char_at 
  //SEG80 [46] phi from print_sbyte_at::@3 to print_char_at [phi:print_sbyte_at::@3->print_char_at]
  print_char_at_from_b3:
  //SEG81 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#1 [phi:print_sbyte_at::@3->print_char_at#0] -- register_copy 
  //SEG82 [46] phi (byte) print_char_at::ch#4 = (byte) ' ' [phi:print_sbyte_at::@3->print_char_at#1] -- vbuz1=vbuc1 
    lda #' '
    sta print_char_at.ch
    jsr print_char_at
  //SEG83 [39] phi from print_sbyte_at::@3 print_sbyte_at::@4 to print_sbyte_at::@2 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2]
  b2_from_b3:
  b2_from_b4:
  //SEG84 [39] phi (signed byte) print_sbyte_at::b#6 = (signed byte) print_sbyte_at::b#4 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2#0] -- register_copy 
    jmp b2
  //SEG85 print_sbyte_at::@2
  b2:
  //SEG86 [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 -- pbuz1=pbuz1_plus_1 
    inc print_byte_at.at
    bne !+
    inc print_byte_at.at+1
  !:
  //SEG87 [41] call print_byte_at 
    jsr print_byte_at
    jmp breturn
  //SEG88 print_sbyte_at::@return
  breturn:
  //SEG89 [42] return 
    rts
  //SEG90 print_sbyte_at::@1
  b1:
  //SEG91 [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3
  //SEG92 [44] call print_char_at 
  //SEG93 [46] phi from print_sbyte_at::@1 to print_char_at [phi:print_sbyte_at::@1->print_char_at]
  print_char_at_from_b1:
  //SEG94 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#0 [phi:print_sbyte_at::@1->print_char_at#0] -- register_copy 
  //SEG95 [46] phi (byte) print_char_at::ch#4 = (byte) '-' [phi:print_sbyte_at::@1->print_char_at#1] -- vbuz1=vbuc1 
    lda #'-'
    sta print_char_at.ch
    jsr print_char_at
    jmp b4
  //SEG96 print_sbyte_at::@4
  b4:
  //SEG97 [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 -- vbsz1=_neg_vbsz1 
    lda b
    eor #$ff
    clc
    adc #1
    sta b
    jmp b2_from_b4
}
//SEG98 print_char_at
// Print a single char
// print_char_at(byte zeropage($b) ch, byte* zeropage(8) at)
print_char_at: {
    .label at = 8
    .label ch = $b
  //SEG99 [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 -- _deref_pbuz1=vbuz2 
    lda ch
    ldy #0
    sta (at),y
    jmp breturn
  //SEG100 print_char_at::@return
  breturn:
  //SEG101 [48] return 
    rts
}
//SEG102 print_byte_at
// Print a byte as HEX at a specific position
// print_byte_at(byte* zeropage(8) at)
print_byte_at: {
    .label at = 8
  //SEG103 [49] (byte~) print_byte_at::$0 ← (byte)(signed byte) print_sbyte_at::b#6 >> (byte) 4 -- vbuaa=vbuz1_ror_4 
    lda print_sbyte_at.b
    lsr
    lsr
    lsr
    lsr
  //SEG104 [50] (byte) print_char_at::ch#2 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0) -- vbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda print_hextab,y
    sta print_char_at.ch
  //SEG105 [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0
  //SEG106 [52] call print_char_at 
  //SEG107 [46] phi from print_byte_at to print_char_at [phi:print_byte_at->print_char_at]
  print_char_at_from_print_byte_at:
  //SEG108 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#2 [phi:print_byte_at->print_char_at#0] -- register_copy 
  //SEG109 [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#2 [phi:print_byte_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp b1
  //SEG110 print_byte_at::@1
  b1:
  //SEG111 [53] (byte~) print_byte_at::$2 ← (byte)(signed byte) print_sbyte_at::b#6 & (byte) $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and print_sbyte_at.b
    tay
  //SEG112 [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 -- pbuz1=pbuz1_plus_1 
    inc print_char_at.at
    bne !+
    inc print_char_at.at+1
  !:
  //SEG113 [55] (byte) print_char_at::ch#3 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2) -- vbuz1=pbuc1_derefidx_vbuyy 
    lda print_hextab,y
    sta print_char_at.ch
  //SEG114 [56] call print_char_at 
  //SEG115 [46] phi from print_byte_at::@1 to print_char_at [phi:print_byte_at::@1->print_char_at]
  print_char_at_from_b1:
  //SEG116 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#3 [phi:print_byte_at::@1->print_char_at#0] -- register_copy 
  //SEG117 [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#3 [phi:print_byte_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp breturn
  //SEG118 print_byte_at::@return
  breturn:
  //SEG119 [57] return 
    rts
}
//SEG120 fmul8
// fmul8(signed byte register(A) a, signed byte register(X) b)
fmul8: {
  //SEG121 [58] *((const signed byte*) ap#0) ← (signed byte) fmul8::a#0 -- _deref_pbsc1=vbsaa 
    sta ap
  //SEG122 [59] *((const signed byte*) bp#0) ← (signed byte) fmul8::b#0 -- _deref_pbsc1=vbsxx 
    txa
    sta bp
  //SEG123 asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
    lda ap
    sta A1+1
    eor #$ff
    sta A2+1
    ldx bp
    sec
  A1:
    lda mulf_sqr1,x
  A2:
    sbc mulf_sqr2,x
    sta cp
  //SEG124 [61] (signed byte) fmul8::return#1 ← *((const signed byte*) cp#0) -- vbsaa=_deref_pbsc1 
    lda cp
    jmp breturn
  //SEG125 fmul8::@return
  breturn:
  //SEG126 [62] return 
    rts
}
//SEG127 init_screen
init_screen: {
    .const WHITE = 1
    .label COLS = 2
  //SEG128 [64] call print_cls 
  //SEG129 [78] phi from init_screen to print_cls [phi:init_screen->print_cls]
  print_cls_from_init_screen:
    jsr print_cls
  //SEG130 [65] phi from init_screen to init_screen::@1 [phi:init_screen->init_screen::@1]
  b1_from_init_screen:
  //SEG131 [65] phi (byte) init_screen::l#2 = (byte) 0 [phi:init_screen->init_screen::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG132 [65] phi from init_screen::@1 to init_screen::@1 [phi:init_screen::@1->init_screen::@1]
  b1_from_b1:
  //SEG133 [65] phi (byte) init_screen::l#2 = (byte) init_screen::l#1 [phi:init_screen::@1->init_screen::@1#0] -- register_copy 
    jmp b1
  //SEG134 init_screen::@1
  b1:
  //SEG135 [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #WHITE
    sta $d800,x
  //SEG136 [67] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG137 [68] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne b1_from_b1
  //SEG138 [69] phi from init_screen::@1 to init_screen::@2 [phi:init_screen::@1->init_screen::@2]
  b2_from_b1:
  //SEG139 [69] phi (byte) init_screen::m#2 = (byte) 0 [phi:init_screen::@1->init_screen::@2#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG140 [69] phi (byte*) init_screen::COLS#3 = (byte*) 55296 [phi:init_screen::@1->init_screen::@2#1] -- pbuz1=pbuc1 
    lda #<$d800
    sta COLS
    lda #>$d800
    sta COLS+1
    jmp b2
  //SEG141 [69] phi from init_screen::@2 to init_screen::@2 [phi:init_screen::@2->init_screen::@2]
  b2_from_b2:
  //SEG142 [69] phi (byte) init_screen::m#2 = (byte) init_screen::m#1 [phi:init_screen::@2->init_screen::@2#0] -- register_copy 
  //SEG143 [69] phi (byte*) init_screen::COLS#3 = (byte*) init_screen::COLS#1 [phi:init_screen::@2->init_screen::@2#1] -- register_copy 
    jmp b2
  //SEG144 init_screen::@2
  b2:
  //SEG145 [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 -- _deref_pbuz1=vbuc1 
    lda #WHITE
    ldy #0
    sta (COLS),y
  //SEG146 [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #1
    sta (COLS),y
  //SEG147 [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #2
    sta (COLS),y
  //SEG148 [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #3
    sta (COLS),y
  //SEG149 [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc COLS
    sta COLS
    bcc !+
    inc COLS+1
  !:
  //SEG150 [75] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG151 [76] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$19
    bne b2_from_b2
    jmp breturn
  //SEG152 init_screen::@return
  breturn:
  //SEG153 [77] return 
    rts
}
//SEG154 print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    .label sc = 2
  //SEG155 [79] phi from print_cls to print_cls::@1 [phi:print_cls->print_cls::@1]
  b1_from_print_cls:
  //SEG156 [79] phi (byte*) print_cls::sc#2 = (const byte*) print_screen#0 [phi:print_cls->print_cls::@1#0] -- pbuz1=pbuc1 
    lda #<print_screen
    sta sc
    lda #>print_screen
    sta sc+1
    jmp b1
  //SEG157 [79] phi from print_cls::@1 to print_cls::@1 [phi:print_cls::@1->print_cls::@1]
  b1_from_b1:
  //SEG158 [79] phi (byte*) print_cls::sc#2 = (byte*) print_cls::sc#1 [phi:print_cls::@1->print_cls::@1#0] -- register_copy 
    jmp b1
  //SEG159 print_cls::@1
  b1:
  //SEG160 [80] *((byte*) print_cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
  //SEG161 [81] (byte*) print_cls::sc#1 ← ++ (byte*) print_cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc sc
    bne !+
    inc sc+1
  !:
  //SEG162 [82] if((byte*) print_cls::sc#1!=(const byte*) print_screen#0+(word) $3e8) goto print_cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda sc+1
    cmp #>print_screen+$3e8
    bne b1_from_b1
    lda sc
    cmp #<print_screen+$3e8
    bne b1_from_b1
    jmp breturn
  //SEG163 print_cls::@return
  breturn:
  //SEG164 [83] return 
    rts
}
  print_hextab: .text "0123456789abcdef"
  vals: .byte -$5f, -$40, -$20, -$10, 0, $10, $20, $40, $5f
.pc = mulf_sqr1 "mulf_sqr1"
  .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }

.pc = mulf_sqr2 "mulf_sqr2"
  .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b5
Removing instruction jmp b2
Removing instruction jmp b6
Removing instruction jmp b3
Removing instruction jmp b7
Removing instruction jmp b8
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda cp
Removing instruction lda #WHITE
Removing instruction lda #WHITE
Removing instruction lda #WHITE
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b1_from_b5 with b1
Replacing label b3_from_b8 with b3
Replacing label b2_from_b4 with b2
Replacing label b2_from_b4 with b2
Replacing label b1_from_b1 with b1
Replacing label b2_from_b2 with b2
Replacing label b1_from_b1 with b1
Replacing label b1_from_b1 with b1
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_b5:
Removing instruction b2_from_b4:
Removing instruction b3_from_b8:
Removing instruction print_char_at_from_b3:
Removing instruction b2_from_b3:
Removing instruction b2_from_b4:
Removing instruction print_char_at_from_b1:
Removing instruction b1_from_b1:
Removing instruction b2_from_b2:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction init_screen_from_main:
Removing instruction b1_from_main:
Removing instruction print_sbyte_at_from_b1:
Removing instruction b5:
Removing instruction b2_from_b5:
Removing instruction print_sbyte_at_from_b2:
Removing instruction b6:
Removing instruction b3_from_b6:
Removing instruction b7:
Removing instruction print_sbyte_at_from_b7:
Removing instruction b8:
Removing instruction b4:
Removing instruction breturn:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b4:
Removing instruction breturn:
Removing instruction print_char_at_from_print_byte_at:
Removing instruction b1:
Removing instruction print_char_at_from_b1:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction print_cls_from_init_screen:
Removing instruction b1_from_init_screen:
Removing instruction b2_from_b1:
Removing instruction breturn:
Removing instruction b1_from_print_cls:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #9
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(signed byte*) ap
(const signed byte*) ap#0 ap = (signed byte*) 253
(signed byte*) bp
(const signed byte*) bp#0 bp = (signed byte*) 254
(signed byte*) cp
(const signed byte*) cp#0 cp = (signed byte*) 255
(signed byte()) fmul8((signed byte) fmul8::a , (signed byte) fmul8::b)
(label) fmul8::@return
(signed byte) fmul8::a
(signed byte) fmul8::a#0 reg byte a 51.5
(signed byte) fmul8::b
(signed byte) fmul8::b#0 reg byte x 51.5
(signed byte) fmul8::return
(signed byte) fmul8::return#0 reg byte a 202.0
(signed byte) fmul8::return#1 reg byte a 34.33333333333333
(void()) init_screen()
(label) init_screen::@1
(label) init_screen::@2
(label) init_screen::@return
(byte*) init_screen::COLS
(byte*) init_screen::COLS#1 COLS zp ZP_WORD:2 7.333333333333333
(byte*) init_screen::COLS#3 COLS zp ZP_WORD:2 13.2
(byte) init_screen::WHITE
(const byte) init_screen::WHITE#0 WHITE = (byte) 1
(byte) init_screen::l
(byte) init_screen::l#1 reg byte x 16.5
(byte) init_screen::l#2 reg byte x 16.5
(byte) init_screen::m
(byte) init_screen::m#1 reg byte x 16.5
(byte) init_screen::m#2 reg byte x 3.6666666666666665
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@return
(byte*) main::at
(byte*) main::at#1 at zp ZP_WORD:2 7.333333333333333
(byte*~) main::at#12 at#12 zp ZP_WORD:5 22.0
(byte*) main::at#2 at zp ZP_WORD:2 2.3157894736842106
(byte*) main::at#3 at#3 zp ZP_WORD:5 27.545454545454547
(byte*) main::at#4 at zp ZP_WORD:2 8.25
(byte*) main::at#6 at#6 zp ZP_WORD:5 213.0
(byte*) main::at_line
(byte*) main::at_line#2 at_line zp ZP_WORD:2 22.0
(byte) main::i
(byte) main::i#1 i zp ZP_BYTE:4 16.5
(byte) main::i#2 i zp ZP_BYTE:4 7.444444444444445
(byte) main::j
(byte) main::j#1 j zp ZP_BYTE:7 151.5
(byte) main::j#2 j zp ZP_BYTE:7 30.299999999999997
(byte) main::k
(byte) main::k#1 reg byte x 16.5
(byte) main::k#2 reg byte x 6.6000000000000005
(signed byte) main::r
(signed byte) main::r#0 reg byte a 202.0
(byte*) mulf_sqr1
(const byte*) mulf_sqr1#0 mulf_sqr1 = (byte*) 8192
(byte*) mulf_sqr2
(const byte*) mulf_sqr2#0 mulf_sqr2 = (byte*) 8704
(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
(byte~) print_byte_at::$0 reg byte a 4.0
(byte~) print_byte_at::$2 reg byte y 2.0
(label) print_byte_at::@1
(label) print_byte_at::@return
(byte*) print_byte_at::at
(byte*) print_byte_at::at#0 at zp ZP_WORD:8 1.0
(byte) print_byte_at::b
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(label) print_char_at::@return
(byte*) print_char_at::at
(byte*) print_char_at::at#0 at zp ZP_WORD:8 4.0
(byte*) print_char_at::at#1 at zp ZP_WORD:8 4.0
(byte*) print_char_at::at#2 at zp ZP_WORD:8 4.0
(byte*) print_char_at::at#3 at zp ZP_WORD:8 2.0
(byte*) print_char_at::at#4 at zp ZP_WORD:8 10.0
(byte) print_char_at::ch
(byte) print_char_at::ch#2 ch zp ZP_BYTE:11 2.0
(byte) print_char_at::ch#3 ch zp ZP_BYTE:11 4.0
(byte) print_char_at::ch#4 ch zp ZP_BYTE:11 6.0
(void()) print_cls()
(label) print_cls::@1
(label) print_cls::@return
(byte*) print_cls::sc
(byte*) print_cls::sc#1 sc zp ZP_WORD:2 16.5
(byte*) print_cls::sc#2 sc zp ZP_WORD:2 16.5
(byte[]) print_hextab
(const byte[]) print_hextab#0 print_hextab = (string) "0123456789abcdef"
(void()) print_sbyte_at((signed byte) print_sbyte_at::b , (byte*) print_sbyte_at::at)
(label) print_sbyte_at::@1
(label) print_sbyte_at::@2
(label) print_sbyte_at::@3
(label) print_sbyte_at::@4
(label) print_sbyte_at::@return
(byte*) print_sbyte_at::at
(byte*) print_sbyte_at::at#0 at zp ZP_WORD:8 22.0
(byte*) print_sbyte_at::at#1 at zp ZP_WORD:8 22.0
(byte*) print_sbyte_at::at#2 at zp ZP_WORD:8 202.0
(byte*) print_sbyte_at::at#3 at zp ZP_WORD:8 16.125
(signed byte) print_sbyte_at::b
(signed byte) print_sbyte_at::b#0 b zp ZP_BYTE:10 4.0
(signed byte) print_sbyte_at::b#1 b zp ZP_BYTE:10 11.0
(signed byte) print_sbyte_at::b#2 b zp ZP_BYTE:10 11.0
(signed byte) print_sbyte_at::b#3 b zp ZP_BYTE:10 101.0
(signed byte) print_sbyte_at::b#4 b zp ZP_BYTE:10 21.499999999999993
(signed byte) print_sbyte_at::b#6 b zp ZP_BYTE:10 0.6666666666666666
(byte*) print_screen
(const byte*) print_screen#0 print_screen = (byte*) 1024
(signed byte[]) vals
(const signed byte[]) vals#0 vals = { (signed byte) -$5f, (signed byte) -$40, (signed byte) -$20, (signed byte) -$10, (signed byte) 0, (signed byte) $10, (signed byte) $20, (signed byte) $40, (signed byte) $5f }

reg byte x [ main::k#2 main::k#1 ]
zp ZP_WORD:2 [ main::at#4 main::at#1 main::at_line#2 main::at#2 init_screen::COLS#3 init_screen::COLS#1 print_cls::sc#2 print_cls::sc#1 ]
zp ZP_BYTE:4 [ main::i#2 main::i#1 ]
zp ZP_WORD:5 [ main::at#6 main::at#3 main::at#12 ]
zp ZP_BYTE:7 [ main::j#2 main::j#1 ]
zp ZP_WORD:8 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 print_byte_at::at#0 ]
zp ZP_BYTE:10 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
zp ZP_BYTE:11 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
reg byte x [ init_screen::l#2 init_screen::l#1 ]
reg byte x [ init_screen::m#2 init_screen::m#1 ]
reg byte a [ fmul8::a#0 ]
reg byte x [ fmul8::b#0 ]
reg byte a [ fmul8::return#0 ]
reg byte a [ main::r#0 ]
reg byte a [ print_byte_at::$0 ]
reg byte y [ print_byte_at::$2 ]
reg byte a [ fmul8::return#1 ]


FINAL ASSEMBLER
Score: 10516

//SEG0 File Comments
// Seriously fast multiply 8-bit version (8bit*8bit=8bit)
// Multiplies two signed 8-bit numbers and results in an 8-bit number
// C=A*B, A in [-64;64], B in [-96;95], C in [-96;95] - 64 acts a 1 (X*64=X)
// Uses the formula a*b = (a+b)^2/4 - (a-b)^2/4
// See the following for information about the method
// - http://codebase64.org/doku.php?id=base:seriously_fast_multiplication 
// - http://codebase64.org/doku.php?id=magazines:chacking16
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label print_screen = $400
  // Pointers to a, b and c=a*b
  .label ap = $fd
  .label bp = $fe
  .label cp = $ff
  // mulf_sqr tables will contain f(x)=int(x*x) and g(x) = f(1-x).
  // f(x) = >(( x * x ))
  .label mulf_sqr1 = $2000
  // g(x) =  >((( 1 - x ) * ( 1 - x )))
  .label mulf_sqr2 = $2200
//SEG3 @begin
//SEG4 @1
//SEG5 kickasm(location (const byte*) mulf_sqr1#0) {{ .for(var i=0;i<$200;i++) {     	.if(i<=159) { .byte round((i*i)/256) }     	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }     	.if(i>351) { .byte round(((512-i)*(512-i))/256) }     }  }}
//SEG6 kickasm(location (const byte*) mulf_sqr2#0) {{ .for(var i=0;i<$200;i++) {     	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }     	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }     	.if(i>351) { .byte round(((i-511)*(i-511))/256) }       }  }}
//SEG7 [3] call main 
//SEG8 [5] phi from @1 to main [phi:@1->main]
//SEG9 [4] phi from @1 to @end [phi:@1->@end]
//SEG10 @end
//SEG11 main
main: {
    .label at = 2
    .label at_3 = 5
    .label j = 7
    .label i = 4
    .label at_line = 2
    .label at_6 = 5
    .label at_12 = 5
  //SEG12 [6] call init_screen 
  //SEG13 [63] phi from main to init_screen [phi:main->init_screen]
    jsr init_screen
  //SEG14 [7] phi from main to main::@1 [phi:main->main::@1]
  //SEG15 [7] phi (byte*) main::at#4 = (byte*) 1024+(byte) 4 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400+4
    sta at
    lda #>$400+4
    sta at+1
  //SEG16 [7] phi (byte) main::k#2 = (byte) 0 [phi:main->main::@1#1] -- vbuxx=vbuc1 
    ldx #0
  //SEG17 [7] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  //SEG18 [7] phi (byte*) main::at#4 = (byte*) main::at#1 [phi:main::@5->main::@1#0] -- register_copy 
  //SEG19 [7] phi (byte) main::k#2 = (byte) main::k#1 [phi:main::@5->main::@1#1] -- register_copy 
  //SEG20 main::@1
  b1:
  //SEG21 [8] (signed byte) print_sbyte_at::b#1 ← *((const signed byte[]) vals#0 + (byte) main::k#2) -- vbsz1=pbsc1_derefidx_vbuxx 
    lda vals,x
    sta print_sbyte_at.b
  //SEG22 [9] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 -- pbuz1=pbuz2 
    lda at
    sta print_sbyte_at.at
    lda at+1
    sta print_sbyte_at.at+1
  //SEG23 [10] call print_sbyte_at 
  //SEG24 [35] phi from main::@1 to print_sbyte_at [phi:main::@1->print_sbyte_at]
  //SEG25 [35] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#0 [phi:main::@1->print_sbyte_at#0] -- register_copy 
  //SEG26 [35] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#1 [phi:main::@1->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
  //SEG27 main::@5
  //SEG28 [11] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at
    sta at
    bcc !+
    inc at+1
  !:
  //SEG29 [12] (byte) main::k#1 ← ++ (byte) main::k#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG30 [13] if((byte) main::k#1!=(byte) 9) goto main::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #9
    bne b1
  //SEG31 [14] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  //SEG32 [14] phi (byte) main::i#2 = (byte) 0 [phi:main::@5->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta i
  //SEG33 [14] phi (byte*) main::at_line#2 = (byte*) 1024 [phi:main::@5->main::@2#1] -- pbuz1=pbuc1 
    lda #<$400
    sta at_line
    lda #>$400
    sta at_line+1
  //SEG34 [14] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  //SEG35 [14] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@4->main::@2#0] -- register_copy 
  //SEG36 [14] phi (byte*) main::at_line#2 = (byte*) main::at#2 [phi:main::@4->main::@2#1] -- register_copy 
  //SEG37 main::@2
  b2:
  //SEG38 [15] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc at
    sta at
    bcc !+
    inc at+1
  !:
  //SEG39 [16] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda vals,y
    sta print_sbyte_at.b
  //SEG40 [17] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at
    sta print_sbyte_at.at
    lda at+1
    sta print_sbyte_at.at+1
  //SEG41 [18] call print_sbyte_at 
  //SEG42 [35] phi from main::@2 to print_sbyte_at [phi:main::@2->print_sbyte_at]
  //SEG43 [35] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#1 [phi:main::@2->print_sbyte_at#0] -- register_copy 
  //SEG44 [35] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#2 [phi:main::@2->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
  //SEG45 main::@6
  //SEG46 [19] (byte*~) main::at#12 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at
    sta at_12
    lda at+1
    sta at_12+1
  //SEG47 [20] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  //SEG48 [20] phi (byte) main::j#2 = (byte) 0 [phi:main::@6->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta j
  //SEG49 [20] phi (byte*) main::at#6 = (byte*~) main::at#12 [phi:main::@6->main::@3#1] -- register_copy 
  //SEG50 [20] phi from main::@8 to main::@3 [phi:main::@8->main::@3]
  //SEG51 [20] phi (byte) main::j#2 = (byte) main::j#1 [phi:main::@8->main::@3#0] -- register_copy 
  //SEG52 [20] phi (byte*) main::at#6 = (byte*) main::at#3 [phi:main::@8->main::@3#1] -- register_copy 
  //SEG53 main::@3
  b3:
  //SEG54 [21] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at_3
    sta at_3
    bcc !+
    inc at_3+1
  !:
  //SEG55 [22] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsaa=pbsc1_derefidx_vbuz1 
    ldy i
    lda vals,y
  //SEG56 [23] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy j
    ldx vals,y
  //SEG57 [24] call fmul8 
    jsr fmul8
  //SEG58 [25] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1
  //SEG59 main::@7
  //SEG60 [26] (signed byte) main::r#0 ← (signed byte) fmul8::return#0
  //SEG61 [27] (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0 -- vbsz1=vbsaa 
    sta print_sbyte_at.b
  //SEG62 [28] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 -- pbuz1=pbuz2 
    lda at_3
    sta print_sbyte_at.at
    lda at_3+1
    sta print_sbyte_at.at+1
  //SEG63 [29] call print_sbyte_at 
  //SEG64 [35] phi from main::@7 to print_sbyte_at [phi:main::@7->print_sbyte_at]
  //SEG65 [35] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#2 [phi:main::@7->print_sbyte_at#0] -- register_copy 
  //SEG66 [35] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#3 [phi:main::@7->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
  //SEG67 main::@8
  //SEG68 [30] (byte) main::j#1 ← ++ (byte) main::j#2 -- vbuz1=_inc_vbuz1 
    inc j
  //SEG69 [31] if((byte) main::j#1!=(byte) 9) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp j
    bne b3
  //SEG70 main::@4
  //SEG71 [32] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG72 [33] if((byte) main::i#1!=(byte) 9) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    cmp i
    bne b2
  //SEG73 main::@return
  //SEG74 [34] return 
    rts
}
//SEG75 print_sbyte_at
// Print a signed byte as hex at a specific screen position
// print_sbyte_at(signed byte zeropage($a) b, byte* zeropage(8) at)
print_sbyte_at: {
    .label b = $a
    .label at = 8
  //SEG76 [36] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1 -- vbsz1_lt_0_then_la1 
    lda b
    bmi b1
  //SEG77 print_sbyte_at::@3
  //SEG78 [37] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3
  //SEG79 [38] call print_char_at 
  //SEG80 [46] phi from print_sbyte_at::@3 to print_char_at [phi:print_sbyte_at::@3->print_char_at]
  //SEG81 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#1 [phi:print_sbyte_at::@3->print_char_at#0] -- register_copy 
  //SEG82 [46] phi (byte) print_char_at::ch#4 = (byte) ' ' [phi:print_sbyte_at::@3->print_char_at#1] -- vbuz1=vbuc1 
    lda #' '
    sta print_char_at.ch
    jsr print_char_at
  //SEG83 [39] phi from print_sbyte_at::@3 print_sbyte_at::@4 to print_sbyte_at::@2 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2]
  //SEG84 [39] phi (signed byte) print_sbyte_at::b#6 = (signed byte) print_sbyte_at::b#4 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2#0] -- register_copy 
  //SEG85 print_sbyte_at::@2
  b2:
  //SEG86 [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 -- pbuz1=pbuz1_plus_1 
    inc print_byte_at.at
    bne !+
    inc print_byte_at.at+1
  !:
  //SEG87 [41] call print_byte_at 
    jsr print_byte_at
  //SEG88 print_sbyte_at::@return
  //SEG89 [42] return 
    rts
  //SEG90 print_sbyte_at::@1
  b1:
  //SEG91 [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3
  //SEG92 [44] call print_char_at 
  //SEG93 [46] phi from print_sbyte_at::@1 to print_char_at [phi:print_sbyte_at::@1->print_char_at]
  //SEG94 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#0 [phi:print_sbyte_at::@1->print_char_at#0] -- register_copy 
  //SEG95 [46] phi (byte) print_char_at::ch#4 = (byte) '-' [phi:print_sbyte_at::@1->print_char_at#1] -- vbuz1=vbuc1 
    lda #'-'
    sta print_char_at.ch
    jsr print_char_at
  //SEG96 print_sbyte_at::@4
  //SEG97 [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 -- vbsz1=_neg_vbsz1 
    lda b
    eor #$ff
    clc
    adc #1
    sta b
    jmp b2
}
//SEG98 print_char_at
// Print a single char
// print_char_at(byte zeropage($b) ch, byte* zeropage(8) at)
print_char_at: {
    .label at = 8
    .label ch = $b
  //SEG99 [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 -- _deref_pbuz1=vbuz2 
    lda ch
    ldy #0
    sta (at),y
  //SEG100 print_char_at::@return
  //SEG101 [48] return 
    rts
}
//SEG102 print_byte_at
// Print a byte as HEX at a specific position
// print_byte_at(byte* zeropage(8) at)
print_byte_at: {
    .label at = 8
  //SEG103 [49] (byte~) print_byte_at::$0 ← (byte)(signed byte) print_sbyte_at::b#6 >> (byte) 4 -- vbuaa=vbuz1_ror_4 
    lda print_sbyte_at.b
    lsr
    lsr
    lsr
    lsr
  //SEG104 [50] (byte) print_char_at::ch#2 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0) -- vbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda print_hextab,y
    sta print_char_at.ch
  //SEG105 [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0
  //SEG106 [52] call print_char_at 
  //SEG107 [46] phi from print_byte_at to print_char_at [phi:print_byte_at->print_char_at]
  //SEG108 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#2 [phi:print_byte_at->print_char_at#0] -- register_copy 
  //SEG109 [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#2 [phi:print_byte_at->print_char_at#1] -- register_copy 
    jsr print_char_at
  //SEG110 print_byte_at::@1
  //SEG111 [53] (byte~) print_byte_at::$2 ← (byte)(signed byte) print_sbyte_at::b#6 & (byte) $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and print_sbyte_at.b
    tay
  //SEG112 [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 -- pbuz1=pbuz1_plus_1 
    inc print_char_at.at
    bne !+
    inc print_char_at.at+1
  !:
  //SEG113 [55] (byte) print_char_at::ch#3 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2) -- vbuz1=pbuc1_derefidx_vbuyy 
    lda print_hextab,y
    sta print_char_at.ch
  //SEG114 [56] call print_char_at 
  //SEG115 [46] phi from print_byte_at::@1 to print_char_at [phi:print_byte_at::@1->print_char_at]
  //SEG116 [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#3 [phi:print_byte_at::@1->print_char_at#0] -- register_copy 
  //SEG117 [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#3 [phi:print_byte_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
  //SEG118 print_byte_at::@return
  //SEG119 [57] return 
    rts
}
//SEG120 fmul8
// fmul8(signed byte register(A) a, signed byte register(X) b)
fmul8: {
  //SEG121 [58] *((const signed byte*) ap#0) ← (signed byte) fmul8::a#0 -- _deref_pbsc1=vbsaa 
    sta ap
  //SEG122 [59] *((const signed byte*) bp#0) ← (signed byte) fmul8::b#0 -- _deref_pbsc1=vbsxx 
    txa
    sta bp
  //SEG123 asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
    lda ap
    sta A1+1
    eor #$ff
    sta A2+1
    ldx bp
    sec
  A1:
    lda mulf_sqr1,x
  A2:
    sbc mulf_sqr2,x
    sta cp
  //SEG124 [61] (signed byte) fmul8::return#1 ← *((const signed byte*) cp#0) -- vbsaa=_deref_pbsc1 
  //SEG125 fmul8::@return
  //SEG126 [62] return 
    rts
}
//SEG127 init_screen
init_screen: {
    .const WHITE = 1
    .label COLS = 2
  //SEG128 [64] call print_cls 
  //SEG129 [78] phi from init_screen to print_cls [phi:init_screen->print_cls]
    jsr print_cls
  //SEG130 [65] phi from init_screen to init_screen::@1 [phi:init_screen->init_screen::@1]
  //SEG131 [65] phi (byte) init_screen::l#2 = (byte) 0 [phi:init_screen->init_screen::@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG132 [65] phi from init_screen::@1 to init_screen::@1 [phi:init_screen::@1->init_screen::@1]
  //SEG133 [65] phi (byte) init_screen::l#2 = (byte) init_screen::l#1 [phi:init_screen::@1->init_screen::@1#0] -- register_copy 
  //SEG134 init_screen::@1
  b1:
  //SEG135 [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #WHITE
    sta $d800,x
  //SEG136 [67] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG137 [68] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne b1
  //SEG138 [69] phi from init_screen::@1 to init_screen::@2 [phi:init_screen::@1->init_screen::@2]
  //SEG139 [69] phi (byte) init_screen::m#2 = (byte) 0 [phi:init_screen::@1->init_screen::@2#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG140 [69] phi (byte*) init_screen::COLS#3 = (byte*) 55296 [phi:init_screen::@1->init_screen::@2#1] -- pbuz1=pbuc1 
    lda #<$d800
    sta COLS
    lda #>$d800
    sta COLS+1
  //SEG141 [69] phi from init_screen::@2 to init_screen::@2 [phi:init_screen::@2->init_screen::@2]
  //SEG142 [69] phi (byte) init_screen::m#2 = (byte) init_screen::m#1 [phi:init_screen::@2->init_screen::@2#0] -- register_copy 
  //SEG143 [69] phi (byte*) init_screen::COLS#3 = (byte*) init_screen::COLS#1 [phi:init_screen::@2->init_screen::@2#1] -- register_copy 
  //SEG144 init_screen::@2
  b2:
  //SEG145 [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 -- _deref_pbuz1=vbuc1 
    lda #WHITE
    ldy #0
    sta (COLS),y
  //SEG146 [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    ldy #1
    sta (COLS),y
  //SEG147 [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    ldy #2
    sta (COLS),y
  //SEG148 [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    ldy #3
    sta (COLS),y
  //SEG149 [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc COLS
    sta COLS
    bcc !+
    inc COLS+1
  !:
  //SEG150 [75] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG151 [76] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$19
    bne b2
  //SEG152 init_screen::@return
  //SEG153 [77] return 
    rts
}
//SEG154 print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    .label sc = 2
  //SEG155 [79] phi from print_cls to print_cls::@1 [phi:print_cls->print_cls::@1]
  //SEG156 [79] phi (byte*) print_cls::sc#2 = (const byte*) print_screen#0 [phi:print_cls->print_cls::@1#0] -- pbuz1=pbuc1 
    lda #<print_screen
    sta sc
    lda #>print_screen
    sta sc+1
  //SEG157 [79] phi from print_cls::@1 to print_cls::@1 [phi:print_cls::@1->print_cls::@1]
  //SEG158 [79] phi (byte*) print_cls::sc#2 = (byte*) print_cls::sc#1 [phi:print_cls::@1->print_cls::@1#0] -- register_copy 
  //SEG159 print_cls::@1
  b1:
  //SEG160 [80] *((byte*) print_cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
  //SEG161 [81] (byte*) print_cls::sc#1 ← ++ (byte*) print_cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc sc
    bne !+
    inc sc+1
  !:
  //SEG162 [82] if((byte*) print_cls::sc#1!=(const byte*) print_screen#0+(word) $3e8) goto print_cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda sc+1
    cmp #>print_screen+$3e8
    bne b1
    lda sc
    cmp #<print_screen+$3e8
    bne b1
  //SEG163 print_cls::@return
  //SEG164 [83] return 
    rts
}
  print_hextab: .text "0123456789abcdef"
  vals: .byte -$5f, -$40, -$20, -$10, 0, $10, $20, $40, $5f
.pc = mulf_sqr1 "mulf_sqr1"
  .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }

.pc = mulf_sqr2 "mulf_sqr2"
  .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }


