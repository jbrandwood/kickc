Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Fixing struct type size struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = byte1 &memcpy_dma_command
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = byte1 &memcpy_dma_command4
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = byte1 &memset_dma_command
Setting inferred volatile on symbol affected by address-of: memoryRemap::aVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap::xVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap::yVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap::zVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::lMb in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::uMb in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::aVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::xVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::yVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::zVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Inlined call vicSelectGfxBank::$0 = call toDd00 vicSelectGfxBank::gfx 
Inlined call call SEI 
Eliminating unused variable with no statement memcpy_dma_command
Eliminating unused variable with no statement memcpy_dma_command4

CONTROL FLOW GRAPH SSA

void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main::@13
  memoryRemap::upperPageOffset#1 = phi( main::@13/memoryRemap::upperPageOffset#0 )
  memoryRemap::remapBlocks#1 = phi( main::@13/memoryRemap::remapBlocks#0 )
  memoryRemap::lowerPageOffset#1 = phi( main::@13/memoryRemap::lowerPageOffset#0 )
  memoryRemap::$0 = byte0  memoryRemap::lowerPageOffset#1
  memoryRemap::aVal = memoryRemap::$0
  memoryRemap::$1 = memoryRemap::remapBlocks#1 << 4
  memoryRemap::$2 = byte1  memoryRemap::lowerPageOffset#1
  memoryRemap::$3 = memoryRemap::$2 & $f
  memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
  memoryRemap::xVal = memoryRemap::$4
  memoryRemap::$5 = byte0  memoryRemap::upperPageOffset#1
  memoryRemap::yVal = memoryRemap::$5
  memoryRemap::$6 = memoryRemap::remapBlocks#1 & $f0
  memoryRemap::$7 = byte1  memoryRemap::upperPageOffset#1
  memoryRemap::$8 = memoryRemap::$7 & $f
  memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
  memoryRemap::zVal = memoryRemap::$9
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  return 
  to:@return

void memset_dma(void* memset_dma::dest , byte memset_dma::fill , word memset_dma::num)
memset_dma: scope:[memset_dma]  from main::@14 main::@16
  memset_dma::dest#2 = phi( main::@14/memset_dma::dest#0, main::@16/memset_dma::dest#1 )
  memset_dma::fill#2 = phi( main::@14/memset_dma::fill#0, main::@16/memset_dma::fill#1 )
  memset_dma::num#2 = phi( main::@14/memset_dma::num#0, main::@16/memset_dma::num#1 )
  memset_dma::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  *((word*)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma::num#2
  *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memset_dma::fill#2
  *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = ((byte*)) memset_dma::dest#2
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memset_dma_command
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) = byte0 &memset_dma_command
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memset_dma::dmaMode#0
  to:memset_dma::@return
memset_dma::@return: scope:[memset_dma]  from memset_dma
  return 
  to:@return

void memset_dma256(byte memset_dma256::dest_mb , byte memset_dma256::dest_bank , void* memset_dma256::dest , byte memset_dma256::fill , word memset_dma256::num)
memset_dma256: scope:[memset_dma256]  from main::@15
  memset_dma256::fill#1 = phi( main::@15/memset_dma256::fill#0 )
  memset_dma256::dest#1 = phi( main::@15/memset_dma256::dest#0 )
  memset_dma256::dest_bank#1 = phi( main::@15/memset_dma256::dest_bank#0 )
  memset_dma256::num#1 = phi( main::@15/memset_dma256::num#0 )
  memset_dma256::dest_mb#1 = phi( main::@15/memset_dma256::dest_mb#0 )
  memset_dma256::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  memset_dma_command256[1] = memset_dma256::dest_mb#1
  memset_dma256::$0 = & memset_dma_command256[4]
  memset_dma256::f018b#0 = (struct DMA_LIST_F018B*)memset_dma256::$0
  memset_dma256::$7 = (word*)memset_dma256::f018b#0
  memset_dma256::$3 = memset_dma256::$7 + OFFSET_STRUCT_DMA_LIST_F018B_COUNT
  *memset_dma256::$3 = memset_dma256::num#1
  memset_dma256::$8 = (byte*)memset_dma256::f018b#0
  memset_dma256::$4 = memset_dma256::$8 + OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
  *memset_dma256::$4 = memset_dma256::dest_bank#1
  memset_dma256::$9 = (byte**)memset_dma256::f018b#0
  memset_dma256::$5 = memset_dma256::$9 + OFFSET_STRUCT_DMA_LIST_F018B_DEST
  *memset_dma256::$5 = ((byte*)) memset_dma256::dest#1
  memset_dma256::$10 = (byte**)memset_dma256::f018b#0
  memset_dma256::$6 = memset_dma256::$10 + OFFSET_STRUCT_DMA_LIST_F018B_SRC
  *memset_dma256::$6 = (byte*)memset_dma256::fill#1
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  memset_dma256::$1 = byte1  memset_dma_command256
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = memset_dma256::$1
  memset_dma256::$2 = byte0  memset_dma_command256
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = memset_dma256::$2
  *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memset_dma256::dmaMode#0
  to:memset_dma256::@return
memset_dma256::@return: scope:[memset_dma256]  from memset_dma256
  return 
  to:@return

void main()
main: scope:[main]  from __start
  to:main::SEI1
main::SEI1: scope:[main]  from main
  asm { sei  }
  to:main::@13
main::@13: scope:[main]  from main::SEI1
  memoryRemap::remapBlocks#0 = 0
  memoryRemap::lowerPageOffset#0 = 0
  memoryRemap::upperPageOffset#0 = 0
  call memoryRemap 
  to:main::@14
main::@14: scope:[main]  from main::@13
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $47
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $53
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 0
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI) = 0
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO) = 0
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI) = 0
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO) = 0
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI) = 2
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | 1
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) & $7f
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO) = $5a
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI) = 0
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) = $28
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI) = 0
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT) = $2d
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO) = byte0 SCREEN
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI) = byte1 SCREEN
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO) = 0
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI) = 0
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO) = byte0 CHARSET
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI) = byte1 CHARSET
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO) = 0
  memset_dma::dest#0 = (void*)SCREEN
  memset_dma::fill#0 = 0
  memset_dma::num#0 = $2d*$19*2
  call memset_dma 
  to:main::@15
main::@15: scope:[main]  from main::@14
  memset_dma256::dest_mb#0 = $ff
  memset_dma256::dest_bank#0 = 8
  memset_dma256::dest#0 = (void*)0
  memset_dma256::fill#0 = WHITE
  memset_dma256::num#0 = $2d*$19*2
  call memset_dma256 
  to:main::@16
main::@16: scope:[main]  from main::@15
  memset_dma::dest#1 = (void*)CHARSET
  memset_dma::fill#1 = $55
  memset_dma::num#1 = $2d*$20*8
  call memset_dma 
  to:main::@17
main::@17: scope:[main]  from main::@16
  main::erow#0 = main::ESCREEN
  main::r#0 = 0
  to:main::@1
main::@1: scope:[main]  from main::@17 main::@6
  main::erow#6 = phi( main::@17/main::erow#0, main::@6/main::erow#1 )
  main::r#2 = phi( main::@17/main::r#0, main::@6/main::r#1 )
  main::$5 = main::r#2 < $19
  if(main::$5) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  main::erow#5 = phi( main::@1/main::erow#6 )
  main::r#3 = phi( main::@1/main::r#2 )
  main::c#0 = (word)main::r#3
  main::i#0 = 0
  to:main::@4
main::@3: scope:[main]  from main::@1
  main::logo_dest#0 = CHARSET
  main::logo_src#0 = LOGO
  main::col#0 = 0
  to:main::@7
main::@4: scope:[main]  from main::@2 main::@5
  main::r#5 = phi( main::@2/main::r#3, main::@5/main::r#6 )
  main::erow#4 = phi( main::@2/main::erow#5, main::@5/main::erow#2 )
  main::c#3 = phi( main::@2/main::c#0, main::@5/main::c#1 )
  main::i#2 = phi( main::@2/main::i#0, main::@5/main::i#1 )
  main::$6 = main::i#2 < $2d
  if(main::$6) goto main::@5
  to:main::@6
main::@5: scope:[main]  from main::@4
  main::r#6 = phi( main::@4/main::r#5 )
  main::erow#2 = phi( main::@4/main::erow#4 )
  main::c#2 = phi( main::@4/main::c#3 )
  main::i#3 = phi( main::@4/main::i#2 )
  main::$10 = main::i#3 * SIZEOF_WORD
  main::erow#2[main::$10] = main::c#2
  main::c#1 = main::c#2 + $20
  main::i#1 = ++ main::i#3
  to:main::@4
main::@6: scope:[main]  from main::@4
  main::r#4 = phi( main::@4/main::r#5 )
  main::erow#3 = phi( main::@4/main::erow#4 )
  main::$9 = $2d * SIZEOF_WORD
  main::erow#1 = main::erow#3 + main::$9
  main::r#1 = ++ main::r#4
  to:main::@1
main::@7: scope:[main]  from main::@11 main::@3
  main::logo_dest#6 = phi( main::@11/main::logo_dest#1, main::@3/main::logo_dest#0 )
  main::logo_src#6 = phi( main::@11/main::logo_src#1, main::@3/main::logo_src#0 )
  main::col#2 = phi( main::@11/main::col#1, main::@3/main::col#0 )
  main::$7 = main::col#2 < $2d
  if(main::$7) goto main::@8
  to:main::@12
main::@8: scope:[main]  from main::@7
  main::col#6 = phi( main::@7/main::col#2 )
  main::logo_dest#5 = phi( main::@7/main::logo_dest#6 )
  main::logo_src#5 = phi( main::@7/main::logo_src#6 )
  main::y#0 = 0
  to:main::@9
main::@9: scope:[main]  from main::@10 main::@8
  main::col#4 = phi( main::@10/main::col#5, main::@8/main::col#6 )
  main::logo_dest#4 = phi( main::@10/main::logo_dest#2, main::@8/main::logo_dest#5 )
  main::logo_src#4 = phi( main::@10/main::logo_src#2, main::@8/main::logo_src#5 )
  main::y#2 = phi( main::@10/main::y#1, main::@8/main::y#0 )
  main::$8 = main::y#2 < $19*8
  if(main::$8) goto main::@10
  to:main::@11
main::@10: scope:[main]  from main::@9
  main::col#5 = phi( main::@9/main::col#4 )
  main::logo_dest#2 = phi( main::@9/main::logo_dest#4 )
  main::y#3 = phi( main::@9/main::y#2 )
  main::logo_src#2 = phi( main::@9/main::logo_src#4 )
  main::logo_dest#2[main::y#3] = main::logo_src#2[main::y#3]
  main::y#1 = ++ main::y#3
  to:main::@9
main::@11: scope:[main]  from main::@9
  main::col#3 = phi( main::@9/main::col#4 )
  main::logo_src#3 = phi( main::@9/main::logo_src#4 )
  main::logo_dest#3 = phi( main::@9/main::logo_dest#4 )
  main::logo_dest#1 = main::logo_dest#3 + $20*8
  main::logo_src#1 = main::logo_src#3 + $19*8
  main::col#1 = ++ main::col#3
  to:main::@7
main::@12: scope:[main]  from main::@12 main::@7
  *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)
  to:main::@12
main::@return: scope:[main]  from
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* const CHARSET = (byte*)$6000
constant struct F018_DMAGIC* const DMA = (struct F018_DMAGIC*)$d700
constant const byte DMA_COMMAND_FILL = 3
constant const byte DMA_OPTION_DEST_MB = $81
constant const byte DMA_OPTION_END = 0
constant const byte DMA_OPTION_FORMAT_F018B = $a
constant byte* LOGO[$2d*$19*8]  = kickasm {{ .var pic = LoadPicture("camelot.png", List().add($ffffff, $000000))
	.for (var x=0;x<45; x++)
    	.for (var y=0; y<25*8; y++)
            .byte pic.getSinglecolorByte(x,y)
 }}
constant byte OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
constant byte OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
constant byte OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
constant byte OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
constant byte OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
constant byte OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG = 0
constant byte OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
constant byte OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
constant byte OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
constant byte OFFSET_STRUCT_F018_DMAGIC_ETRIG = 5
constant byte OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI = $4b
constant byte OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO = $4a
constant byte OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR = $21
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO = $6a
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI = $69
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO = $68
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI = $59
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO = $58
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT = $5e
constant byte OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
constant byte OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
constant byte OFFSET_STRUCT_MEGA65_VICIV_KEY = $2f
constant byte OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI = $63
constant byte OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO = $62
constant byte OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI = $61
constant byte OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO = $60
constant byte OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI = $5d
constant byte OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
constant byte OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI = $49
constant byte OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO = $48
constant byte OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI = $4d
constant byte OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO = $4c
constant byte OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
constant byte* const SCREEN = (byte*)$5000
constant byte SIZEOF_WORD = 2
constant struct MOS6569_VICII* const VICII = (struct MOS6569_VICII*)$d000
constant struct MEGA65_VICIV* const VICIV = (struct MEGA65_VICIV*)$d000
constant const byte WHITE = 1
void __start()
void main()
byte~ main::$10
bool~ main::$5
bool~ main::$6
bool~ main::$7
bool~ main::$8
number~ main::$9
constant word* main::ESCREEN = SCREEN
word main::c
word main::c#0
word main::c#1
word main::c#2
word main::c#3
byte main::col
byte main::col#0
byte main::col#1
byte main::col#2
byte main::col#3
byte main::col#4
byte main::col#5
byte main::col#6
word* main::erow
word* main::erow#0
word* main::erow#1
word* main::erow#2
word* main::erow#3
word* main::erow#4
word* main::erow#5
word* main::erow#6
byte main::i
byte main::i#0
byte main::i#1
byte main::i#2
byte main::i#3
byte* main::logo_dest
byte* main::logo_dest#0
byte* main::logo_dest#1
byte* main::logo_dest#2
byte* main::logo_dest#3
byte* main::logo_dest#4
byte* main::logo_dest#5
byte* main::logo_dest#6
byte* main::logo_src
byte* main::logo_src#0
byte* main::logo_src#1
byte* main::logo_src#2
byte* main::logo_src#3
byte* main::logo_src#4
byte* main::logo_src#5
byte* main::logo_src#6
byte main::r
byte main::r#0
byte main::r#1
byte main::r#2
byte main::r#3
byte main::r#4
byte main::r#5
byte main::r#6
byte main::y
byte main::y#0
byte main::y#1
byte main::y#2
byte main::y#3
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
byte~ memoryRemap::$0
byte~ memoryRemap::$1
byte~ memoryRemap::$2
number~ memoryRemap::$3
number~ memoryRemap::$4
byte~ memoryRemap::$5
number~ memoryRemap::$6
byte~ memoryRemap::$7
number~ memoryRemap::$8
number~ memoryRemap::$9
volatile byte memoryRemap::aVal loadstore
word memoryRemap::lowerPageOffset
word memoryRemap::lowerPageOffset#0
word memoryRemap::lowerPageOffset#1
byte memoryRemap::remapBlocks
byte memoryRemap::remapBlocks#0
byte memoryRemap::remapBlocks#1
word memoryRemap::upperPageOffset
word memoryRemap::upperPageOffset#0
word memoryRemap::upperPageOffset#1
volatile byte memoryRemap::xVal loadstore
volatile byte memoryRemap::yVal loadstore
volatile byte memoryRemap::zVal loadstore
void memset_dma(void* memset_dma::dest , byte memset_dma::fill , word memset_dma::num)
void* memset_dma::dest
void* memset_dma::dest#0
void* memset_dma::dest#1
void* memset_dma::dest#2
byte memset_dma::dmaMode
byte memset_dma::dmaMode#0
byte memset_dma::fill
byte memset_dma::fill#0
byte memset_dma::fill#1
byte memset_dma::fill#2
word memset_dma::num
word memset_dma::num#0
word memset_dma::num#1
word memset_dma::num#2
void memset_dma256(byte memset_dma256::dest_mb , byte memset_dma256::dest_bank , void* memset_dma256::dest , byte memset_dma256::fill , word memset_dma256::num)
byte*~ memset_dma256::$0
byte~ memset_dma256::$1
byte**~ memset_dma256::$10
byte~ memset_dma256::$2
word*~ memset_dma256::$3
byte*~ memset_dma256::$4
byte**~ memset_dma256::$5
byte**~ memset_dma256::$6
word*~ memset_dma256::$7
byte*~ memset_dma256::$8
byte**~ memset_dma256::$9
void* memset_dma256::dest
void* memset_dma256::dest#0
void* memset_dma256::dest#1
byte memset_dma256::dest_bank
byte memset_dma256::dest_bank#0
byte memset_dma256::dest_bank#1
byte memset_dma256::dest_mb
byte memset_dma256::dest_mb#0
byte memset_dma256::dest_mb#1
byte memset_dma256::dmaMode
byte memset_dma256::dmaMode#0
struct DMA_LIST_F018B* memset_dma256::f018b
struct DMA_LIST_F018B* memset_dma256::f018b#0
byte memset_dma256::fill
byte memset_dma256::fill#0
byte memset_dma256::fill#1
word memset_dma256::num
word memset_dma256::num#0
word memset_dma256::num#1
volatile struct DMA_LIST_F018B memset_dma_command loadstore = { command: DMA_COMMAND_FILL, count: 0, src: 0, src_bank: 0, dest: 0, dest_bank: 0, sub_command: 0, modulo: 0 }
constant byte* memset_dma_command256[]  = { DMA_OPTION_DEST_MB, 0, DMA_OPTION_FORMAT_F018B, DMA_OPTION_END, DMA_COMMAND_FILL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

Adding number conversion cast (unumber) 4 in memoryRemap::$1 = memoryRemap::remapBlocks#1 << 4
Adding number conversion cast (unumber) $f in memoryRemap::$3 = memoryRemap::$2 & $f
Adding number conversion cast (unumber) memoryRemap::$3 in memoryRemap::$3 = memoryRemap::$2 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap::$4 in memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Adding number conversion cast (unumber) $f0 in memoryRemap::$6 = memoryRemap::remapBlocks#1 & $f0
Adding number conversion cast (unumber) memoryRemap::$6 in memoryRemap::$6 = memoryRemap::remapBlocks#1 & (unumber)$f0
Adding number conversion cast (unumber) $f in memoryRemap::$8 = memoryRemap::$7 & $f
Adding number conversion cast (unumber) memoryRemap::$8 in memoryRemap::$8 = memoryRemap::$7 & (unumber)$f
Adding number conversion cast (unumber) memoryRemap::$9 in memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Adding number conversion cast (unumber) 1 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
Adding number conversion cast (unumber) 0 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
Adding number conversion cast (unumber) 0 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
Adding number conversion cast (unumber) 1 in memset_dma_command256[1] = memset_dma256::dest_mb#1
Adding number conversion cast (unumber) 4 in memset_dma256::$0 = & memset_dma_command256[4]
Adding number conversion cast (unumber) 1 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
Adding number conversion cast (unumber) 0 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
Adding number conversion cast (unumber) 0 in *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
Adding number conversion cast (unumber) 0 in memoryRemap::remapBlocks#0 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::lowerPageOffset#0 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::upperPageOffset#0 = 0
Adding number conversion cast (unumber) $40 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40
Adding number conversion cast (unumber) $40 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40
Adding number conversion cast (unumber) $47 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $47
Adding number conversion cast (unumber) $53 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $53
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 0
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI) = 0
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO) = 0
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI) = 0
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO) = 0
Adding number conversion cast (unumber) 2 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI) = 2
Adding number conversion cast (unumber) 1 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | 1
Adding number conversion cast (unumber) $7f in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) & $7f
Adding number conversion cast (unumber) $5a in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO) = $5a
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI) = 0
Adding number conversion cast (unumber) $28 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) = $28
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI) = 0
Adding number conversion cast (unumber) $2d in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT) = $2d
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO) = 0
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI) = 0
Adding number conversion cast (unumber) 0 in *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO) = 0
Adding number conversion cast (unumber) 0 in memset_dma::fill#0 = 0
Adding number conversion cast (unumber) $2d*$19*2 in memset_dma::num#0 = $2d*$19*2
Adding number conversion cast (unumber) $ff in memset_dma256::dest_mb#0 = $ff
Adding number conversion cast (unumber) 8 in memset_dma256::dest_bank#0 = 8
Adding number conversion cast (unumber) $2d*$19*2 in memset_dma256::num#0 = $2d*$19*2
Adding number conversion cast (unumber) $55 in memset_dma::fill#1 = $55
Adding number conversion cast (unumber) $2d*$20*8 in memset_dma::num#1 = $2d*$20*8
Adding number conversion cast (unumber) $19 in main::$5 = main::r#2 < $19
Adding number conversion cast (unumber) $2d in main::$6 = main::i#2 < $2d
Adding number conversion cast (unumber) $20 in main::c#1 = main::c#2 + $20
Adding number conversion cast (unumber) $2d in main::$9 = $2d * SIZEOF_WORD
Adding number conversion cast (unumber) main::$9 in main::$9 = (unumber)$2d * SIZEOF_WORD
Adding number conversion cast (unumber) $2d in main::$7 = main::col#2 < $2d
Adding number conversion cast (unumber) $19*8 in main::$8 = main::y#2 < $19*8
Adding number conversion cast (unumber) $20*8 in main::logo_dest#1 = main::logo_dest#3 + $20*8
Adding number conversion cast (unumber) $19*8 in main::logo_src#1 = main::logo_src#3 + $19*8
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma::dest#2
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = (unumber)1
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = (unumber)0
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = (unumber)0
Inlining cast *memset_dma256::$5 = (byte*)memset_dma256::dest#1
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = (unumber)1
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = (unumber)0
Inlining cast *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = (unumber)0
Inlining cast memoryRemap::remapBlocks#0 = (unumber)0
Inlining cast memoryRemap::lowerPageOffset#0 = (unumber)0
Inlining cast memoryRemap::upperPageOffset#0 = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = (unumber)$47
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = (unumber)$53
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI) = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO) = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI) = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO) = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI) = (unumber)2
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO) = (unumber)$5a
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI) = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) = (unumber)$28
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI) = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT) = (unumber)$2d
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO) = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI) = (unumber)0
Inlining cast *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO) = (unumber)0
Inlining cast memset_dma::fill#0 = (unumber)0
Inlining cast memset_dma::num#0 = (unumber)$2d*$19*2
Inlining cast memset_dma256::dest_mb#0 = (unumber)$ff
Inlining cast memset_dma256::dest_bank#0 = (unumber)8
Inlining cast memset_dma256::num#0 = (unumber)$2d*$19*2
Inlining cast memset_dma::fill#1 = (unumber)$55
Inlining cast memset_dma::num#1 = (unumber)$2d*$20*8
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (struct MOS6569_VICII*) 53248
Simplifying constant pointer cast (struct MEGA65_VICIV*) 53248
Simplifying constant pointer cast (struct F018_DMAGIC*) 55040
Simplifying constant pointer cast (byte*) 20480
Simplifying constant pointer cast (byte*) 24576
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 4
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast $40
Simplifying constant integer cast $47
Simplifying constant integer cast $53
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast $7f
Simplifying constant integer cast $5a
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast $2d
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 8
Simplifying constant pointer cast (void*) 0
Simplifying constant integer cast $55
Simplifying constant integer cast $19
Simplifying constant integer cast $2d
Simplifying constant integer cast $20
Simplifying constant integer cast $2d
Simplifying constant integer cast $2d
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $f0
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) $47
Finalized unsigned number type (byte) $53
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) $5a
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $2d
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $55
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) $2d
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) $2d
Finalized unsigned number type (byte) $2d
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in memoryRemap::$3 = memoryRemap::$2 & $f
Inferred type updated to byte in memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Inferred type updated to byte in memoryRemap::$6 = memoryRemap::remapBlocks#1 & $f0
Inferred type updated to byte in memoryRemap::$8 = memoryRemap::$7 & $f
Inferred type updated to byte in memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Inferred type updated to byte in main::$9 = $2d * SIZEOF_WORD
Alias candidate removed (volatile)memoryRemap::aVal = memoryRemap::$0 
Alias candidate removed (volatile)memoryRemap::xVal = memoryRemap::$4 
Alias candidate removed (volatile)memoryRemap::yVal = memoryRemap::$5 
Alias candidate removed (volatile)memoryRemap::zVal = memoryRemap::$9 
Alias main::r#2 = main::r#3 
Alias main::erow#5 = main::erow#6 
Alias main::i#2 = main::i#3 
Alias main::c#2 = main::c#3 
Alias main::erow#2 = main::erow#4 main::erow#3 
Alias main::r#4 = main::r#6 main::r#5 
Alias main::logo_src#5 = main::logo_src#6 
Alias main::logo_dest#5 = main::logo_dest#6 
Alias main::col#2 = main::col#6 
Alias main::logo_src#2 = main::logo_src#4 main::logo_src#3 
Alias main::y#2 = main::y#3 
Alias main::logo_dest#2 = main::logo_dest#4 main::logo_dest#3 
Alias main::col#3 = main::col#5 main::col#4 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)memoryRemap::aVal = memoryRemap::$0 
Alias candidate removed (volatile)memoryRemap::xVal = memoryRemap::$4 
Alias candidate removed (volatile)memoryRemap::yVal = memoryRemap::$5 
Alias candidate removed (volatile)memoryRemap::zVal = memoryRemap::$9 
Identical Phi Values memoryRemap::lowerPageOffset#1 memoryRemap::lowerPageOffset#0
Identical Phi Values memoryRemap::remapBlocks#1 memoryRemap::remapBlocks#0
Identical Phi Values memoryRemap::upperPageOffset#1 memoryRemap::upperPageOffset#0
Identical Phi Values memset_dma256::dest_mb#1 memset_dma256::dest_mb#0
Identical Phi Values memset_dma256::num#1 memset_dma256::num#0
Identical Phi Values memset_dma256::dest_bank#1 memset_dma256::dest_bank#0
Identical Phi Values memset_dma256::dest#1 memset_dma256::dest#0
Identical Phi Values memset_dma256::fill#1 memset_dma256::fill#0
Identical Phi Values main::erow#2 main::erow#5
Identical Phi Values main::r#4 main::r#2
Identical Phi Values main::logo_src#2 main::logo_src#5
Identical Phi Values main::logo_dest#2 main::logo_dest#5
Identical Phi Values main::col#3 main::col#2
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$5 [102] if(main::r#2<$19) goto main::@2
Simple Condition main::$6 [110] if(main::i#2<$2d) goto main::@5
Simple Condition main::$7 [120] if(main::col#2<$2d) goto main::@8
Simple Condition main::$8 [124] if(main::y#2<(byte)$19*8) goto main::@10
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting array member address-of to pointer addition [32] memset_dma256::$0 = memset_dma_command256 + 4
Successful SSA optimization PassNArrayElementAddressOfRewriting
Constant right-side identified [32] memset_dma256::$0 = memset_dma_command256 + 4
Constant right-side identified [49] memset_dma256::$1 = byte1  memset_dma_command256
Constant right-side identified [51] memset_dma256::$2 = byte0  memset_dma_command256
Constant right-side identified [86] memset_dma::num#0 = (unumber)$2d*$19*2
Constant right-side identified [92] memset_dma256::num#0 = (unumber)$2d*$19*2
Constant right-side identified [96] memset_dma::num#1 = (unumber)$2d*$20*8
Constant right-side identified [115] main::$9 = $2d * SIZEOF_WORD
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memset_dma256::$0 = memset_dma_command256+4
Constant memset_dma256::$1 = byte1 memset_dma_command256
Constant memset_dma256::$2 = byte0 memset_dma_command256
Constant memoryRemap::remapBlocks#0 = 0
Constant memoryRemap::lowerPageOffset#0 = 0
Constant memoryRemap::upperPageOffset#0 = 0
Constant memset_dma::dest#0 = (void*)SCREEN
Constant memset_dma::fill#0 = 0
Constant memset_dma::num#0 = (unumber)$2d*$19*2
Constant memset_dma256::dest_mb#0 = $ff
Constant memset_dma256::dest_bank#0 = 8
Constant memset_dma256::dest#0 = (void*) 0
Constant memset_dma256::fill#0 = WHITE
Constant memset_dma256::num#0 = (unumber)$2d*$19*2
Constant memset_dma::dest#1 = (void*)CHARSET
Constant memset_dma::fill#1 = $55
Constant memset_dma::num#1 = (unumber)$2d*$20*8
Constant main::erow#0 = main::ESCREEN
Constant main::r#0 = 0
Constant main::i#0 = 0
Constant main::logo_dest#0 = CHARSET
Constant main::logo_src#0 = LOGO
Constant main::col#0 = 0
Constant main::$9 = $2d*SIZEOF_WORD
Constant main::y#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant memset_dma256::f018b#0 = (struct DMA_LIST_F018B*)memset_dma256::$0
Successful SSA optimization Pass2ConstantIdentification
Constant memset_dma256::$7 = (word*)memset_dma256::f018b#0
Constant memset_dma256::$8 = (byte*)memset_dma256::f018b#0
Constant memset_dma256::$9 = (byte**)memset_dma256::f018b#0
Constant memset_dma256::$10 = (byte**)memset_dma256::f018b#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte*)memset_dma256::dest#0 in [42] *memset_dma256::$5 = (byte*)memset_dma256::dest#0
Constant value identified (byte*)memset_dma256::fill#0 in [45] *memset_dma256::$6 = (byte*)memset_dma256::fill#0
Successful SSA optimization Pass2ConstantValues
Converting *(pointer+n) to pointer[n] [36] *memset_dma256::$3 = memset_dma256::num#0  -- memset_dma256::$7[OFFSET_STRUCT_DMA_LIST_F018B_COUNT]
Converting *(pointer+n) to pointer[n] [39] *memset_dma256::$4 = memset_dma256::dest_bank#0  -- memset_dma256::$8[OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK]
Converting *(pointer+n) to pointer[n] [42] *memset_dma256::$5 = (byte*)memset_dma256::dest#0  -- memset_dma256::$9[OFFSET_STRUCT_DMA_LIST_F018B_DEST]
Converting *(pointer+n) to pointer[n] [45] *memset_dma256::$6 = (byte*)memset_dma256::fill#0  -- memset_dma256::$10[OFFSET_STRUCT_DMA_LIST_F018B_SRC]
Successful SSA optimization Pass2InlineDerefIdx
Simplifying constant evaluating to zero byte0 SCREEN in [77] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO) = byte0 SCREEN
Simplifying constant evaluating to zero byte0 CHARSET in [81] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO) = byte0 CHARSET
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero (byte*)DMA in [26] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) = byte0 &memset_dma_command
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused variable memset_dma256::$3 and assignment [30] memset_dma256::$3 = memset_dma256::$7 + OFFSET_STRUCT_DMA_LIST_F018B_COUNT
Eliminating unused variable memset_dma256::$4 and assignment [32] memset_dma256::$4 = memset_dma256::$8 + OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
Eliminating unused variable memset_dma256::$5 and assignment [34] memset_dma256::$5 = memset_dma256::$9 + OFFSET_STRUCT_DMA_LIST_F018B_DEST
Eliminating unused variable memset_dma256::$6 and assignment [36] memset_dma256::$6 = memset_dma256::$10 + OFFSET_STRUCT_DMA_LIST_F018B_SRC
Eliminating unused constant OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Alias candidate removed (volatile)memoryRemap::aVal = memoryRemap::$0 
Alias candidate removed (volatile)memoryRemap::xVal = memoryRemap::$4 
Alias candidate removed (volatile)memoryRemap::yVal = memoryRemap::$5 
Alias candidate removed (volatile)memoryRemap::zVal = memoryRemap::$9 
Constant right-side identified [0] memoryRemap::$0 = byte0  memoryRemap::lowerPageOffset#0
Constant right-side identified [2] memoryRemap::$1 = memoryRemap::remapBlocks#0 << 4
Constant right-side identified [3] memoryRemap::$2 = byte1  memoryRemap::lowerPageOffset#0
Constant right-side identified [7] memoryRemap::$5 = byte0  memoryRemap::upperPageOffset#0
Constant right-side identified [9] memoryRemap::$6 = memoryRemap::remapBlocks#0 & $f0
Constant right-side identified [10] memoryRemap::$7 = byte1  memoryRemap::upperPageOffset#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap::$0 = byte0 memoryRemap::lowerPageOffset#0
Constant memoryRemap::$1 = memoryRemap::remapBlocks#0<<4
Constant memoryRemap::$2 = byte1 memoryRemap::lowerPageOffset#0
Constant memoryRemap::$5 = byte0 memoryRemap::upperPageOffset#0
Constant memoryRemap::$6 = memoryRemap::remapBlocks#0&$f0
Constant memoryRemap::$7 = byte1 memoryRemap::upperPageOffset#0
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero byte0 memoryRemap::lowerPageOffset#0 in 
Simplifying constant evaluating to zero memoryRemap::remapBlocks#0<<4 in 
Simplifying constant evaluating to zero byte1 memoryRemap::lowerPageOffset#0 in 
Simplifying constant evaluating to zero byte0 memoryRemap::upperPageOffset#0 in 
Simplifying constant evaluating to zero memoryRemap::remapBlocks#0&$f0 in 
Simplifying constant evaluating to zero byte1 memoryRemap::upperPageOffset#0 in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero memoryRemap::$3 in [5] memoryRemap::$4 = memoryRemap::$1 | memoryRemap::$3
Simplifying expression containing zero memoryRemap::$8 in [12] memoryRemap::$9 = memoryRemap::$6 | memoryRemap::$8
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant memoryRemap::remapBlocks#0
Eliminating unused constant memoryRemap::lowerPageOffset#0
Eliminating unused constant memoryRemap::upperPageOffset#0
Eliminating unused constant memoryRemap::$1
Eliminating unused constant memoryRemap::$6
Successful SSA optimization PassNEliminateUnusedVars
Alias candidate removed (volatile)memoryRemap::$4 = memoryRemap::$3 memoryRemap::xVal 
Alias candidate removed (volatile)memoryRemap::$9 = memoryRemap::$8 memoryRemap::zVal 
Constant right-side identified [1] memoryRemap::$3 = memoryRemap::$2 & $f
Constant right-side identified [5] memoryRemap::$8 = memoryRemap::$7 & $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap::$3 = memoryRemap::$2&$f
Constant memoryRemap::$8 = memoryRemap::$7&$f
Successful SSA optimization Pass2ConstantIdentification
Constant memoryRemap::$4 = memoryRemap::$3
Constant memoryRemap::$9 = memoryRemap::$8
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero memoryRemap::$2&$f in 
Simplifying constant evaluating to zero memoryRemap::$7&$f in 
Successful SSA optimization PassNSimplifyConstantZero
Eliminating unused constant memoryRemap::$2
Eliminating unused constant memoryRemap::$7
Successful SSA optimization PassNEliminateUnusedVars
Rewriting multiplication to use shift [65] main::$10 = main::i#2 * SIZEOF_WORD
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings memset_dma::dest#0
Inlining constant with var siblings memset_dma::fill#0
Inlining constant with var siblings memset_dma::num#0
Inlining constant with var siblings memset_dma::dest#1
Inlining constant with var siblings memset_dma::fill#1
Inlining constant with var siblings memset_dma::num#1
Inlining constant with var siblings main::erow#0
Inlining constant with var siblings main::r#0
Inlining constant with var siblings main::i#0
Inlining constant with var siblings main::logo_dest#0
Inlining constant with var siblings main::logo_src#0
Inlining constant with var siblings main::col#0
Inlining constant with var siblings main::y#0
Constant inlined memset_dma256::fill#0 = WHITE
Constant inlined memset_dma::num#0 = (word)$2d*$19*2
Constant inlined main::col#0 = 0
Constant inlined memset_dma::num#1 = (word)$2d*$20*8
Constant inlined memset_dma::dest#1 = (void*)CHARSET
Constant inlined memset_dma::fill#1 = $55
Constant inlined memset_dma256::$10 = (byte**)memset_dma256::f018b#0
Constant inlined memset_dma::dest#0 = (void*)SCREEN
Constant inlined memset_dma::fill#0 = 0
Constant inlined main::i#0 = 0
Constant inlined main::ESCREEN = SCREEN
Constant inlined memset_dma256::$9 = (byte**)memset_dma256::f018b#0
Constant inlined memset_dma256::$7 = (word*)memset_dma256::f018b#0
Constant inlined memset_dma256::$8 = (byte*)memset_dma256::f018b#0
Constant inlined main::r#0 = 0
Constant inlined main::logo_dest#0 = CHARSET
Constant inlined memset_dma256::$1 = byte1 memset_dma_command256
Constant inlined memset_dma256::$2 = byte0 memset_dma_command256
Constant inlined memset_dma256::$0 = memset_dma_command256+4
Constant inlined main::erow#0 = SCREEN
Constant inlined main::y#0 = 0
Constant inlined memoryRemap::$0 = 0
Constant inlined memoryRemap::$3 = 0
Constant inlined main::logo_src#0 = LOGO
Constant inlined memoryRemap::$4 = 0
Constant inlined memoryRemap::$5 = 0
Constant inlined memoryRemap::$8 = 0
Constant inlined main::$9 = $2d*SIZEOF_WORD
Constant inlined memoryRemap::$9 = 0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(memset_dma_command256+1)
Consolidated array index constant in *((word*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT)
Consolidated array index constant in *((byte*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK)
Consolidated array index constant in *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST)
Consolidated array index constant in *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC)
Successful SSA optimization Pass2ConstantAdditionElimination
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $2d
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $2d
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $2d
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $2d
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Simplifying constant integer cast $19*8
Simplifying constant integer cast $19*8
Successful SSA optimization PassNCastSimplification
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@16
Adding NOP phi() at start of main::@17
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@8
CALL GRAPH
Calls in [main] to memoryRemap:3 memset_dma:28 memset_dma256:30 memset_dma:32 

Created 11 initial phi equivalence classes
Coalesced [46] main::col#7 = main::col#1
Coalesced [47] main::logo_src#7 = main::logo_src#1
Coalesced [48] main::logo_dest#7 = main::logo_dest#1
Coalesced [51] main::y#4 = main::y#1
Coalesced [53] main::c#4 = main::c#0
Coalesced [58] main::r#7 = main::r#1
Coalesced [59] main::erow#7 = main::erow#1
Coalesced [64] main::i#4 = main::i#1
Coalesced [65] main::c#5 = main::c#1
Coalesced down to 11 phi equivalence classes
Culled Empty Block label main::@17
Culled Empty Block label main::@3
Culled Empty Block label main::@8
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block main::@6 to main::@5
Renumbering block main::@7 to main::@6
Renumbering block main::@9 to main::@7
Renumbering block main::@10 to main::@8
Renumbering block main::@11 to main::@9
Renumbering block main::@12 to main::@10
Renumbering block main::@13 to main::@11
Renumbering block main::@14 to main::@12
Renumbering block main::@15 to main::@13
Renumbering block main::@16 to main::@14
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@13
Adding NOP phi() at start of main::@14

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::SEI1
main::SEI1: scope:[main]  from main
  asm { sei  }
  to:main::@11
main::@11: scope:[main]  from main::SEI1
  [2] phi()
  [3] call memoryRemap 
  to:main::@12
main::@12: scope:[main]  from main::@11
  [4] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40
  [5] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40
  [6] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $47
  [7] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $53
  [8] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 0
  [9] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI) = 0
  [10] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO) = 0
  [11] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI) = 0
  [12] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO) = 0
  [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI) = 2
  [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | 1
  [15] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) & $7f
  [16] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO) = $5a
  [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI) = 0
  [18] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) = $28
  [19] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI) = 0
  [20] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT) = $2d
  [21] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO) = 0
  [22] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI) = byte1 SCREEN
  [23] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO) = 0
  [24] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI) = 0
  [25] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO) = 0
  [26] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI) = byte1 CHARSET
  [27] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO) = 0
  [28] call memset_dma 
  to:main::@13
main::@13: scope:[main]  from main::@12
  [29] phi()
  [30] call memset_dma256 
  to:main::@14
main::@14: scope:[main]  from main::@13
  [31] phi()
  [32] call memset_dma 
  to:main::@1
main::@1: scope:[main]  from main::@14 main::@5
  [33] main::erow#5 = phi( main::@14/SCREEN, main::@5/main::erow#1 )
  [33] main::r#2 = phi( main::@14/0, main::@5/main::r#1 )
  [34] if(main::r#2<$19) goto main::@2
  to:main::@6
main::@6: scope:[main]  from main::@1 main::@9
  [35] main::logo_dest#5 = phi( main::@9/main::logo_dest#1, main::@1/CHARSET )
  [35] main::logo_src#5 = phi( main::@9/main::logo_src#1, main::@1/LOGO )
  [35] main::col#2 = phi( main::@9/main::col#1, main::@1/0 )
  [36] if(main::col#2<$2d) goto main::@7
  to:main::@10
main::@10: scope:[main]  from main::@10 main::@6
  [37] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)
  to:main::@10
main::@7: scope:[main]  from main::@6 main::@8
  [38] main::y#2 = phi( main::@8/main::y#1, main::@6/0 )
  [39] if(main::y#2<$19*8) goto main::@8
  to:main::@9
main::@9: scope:[main]  from main::@7
  [40] main::logo_dest#1 = main::logo_dest#5 + (word)$20*8
  [41] main::logo_src#1 = main::logo_src#5 + $19*8
  [42] main::col#1 = ++ main::col#2
  to:main::@6
main::@8: scope:[main]  from main::@7
  [43] main::logo_dest#5[main::y#2] = main::logo_src#5[main::y#2]
  [44] main::y#1 = ++ main::y#2
  to:main::@7
main::@2: scope:[main]  from main::@1
  [45] main::c#0 = (word)main::r#2
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  [46] main::c#2 = phi( main::@2/main::c#0, main::@4/main::c#1 )
  [46] main::i#2 = phi( main::@2/0, main::@4/main::i#1 )
  [47] if(main::i#2<$2d) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@3
  [48] main::erow#1 = main::erow#5 + $2d*SIZEOF_WORD
  [49] main::r#1 = ++ main::r#2
  to:main::@1
main::@4: scope:[main]  from main::@3
  [50] main::$10 = main::i#2 << 1
  [51] main::erow#5[main::$10] = main::c#2
  [52] main::c#1 = main::c#2 + $20
  [53] main::i#1 = ++ main::i#2
  to:main::@3

void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main::@11
  [54] memoryRemap::aVal = 0
  [55] memoryRemap::xVal = 0
  [56] memoryRemap::yVal = 0
  [57] memoryRemap::zVal = 0
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  [59] return 
  to:@return

void memset_dma(void* memset_dma::dest , byte memset_dma::fill , word memset_dma::num)
memset_dma: scope:[memset_dma]  from main::@12 main::@14
  [60] memset_dma::dest#2 = phi( main::@12/(void*)SCREEN, main::@14/(void*)CHARSET )
  [60] memset_dma::fill#2 = phi( main::@12/0, main::@14/$55 )
  [60] memset_dma::num#2 = phi( main::@12/(word)$2d*$19*2, main::@14/(word)$2d*$20*8 )
  [61] memset_dma::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  [62] *((word*)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma::num#2
  [63] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memset_dma::fill#2
  [64] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma::dest#2
  [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  [67] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  [68] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memset_dma_command
  [69] *((byte*)DMA) = byte0 &memset_dma_command
  [70] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memset_dma::dmaMode#0
  to:memset_dma::@return
memset_dma::@return: scope:[memset_dma]  from memset_dma
  [71] return 
  to:@return

void memset_dma256(byte memset_dma256::dest_mb , byte memset_dma256::dest_bank , void* memset_dma256::dest , byte memset_dma256::fill , word memset_dma256::num)
memset_dma256: scope:[memset_dma256]  from main::@13
  [72] memset_dma256::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  [73] *(memset_dma_command256+1) = memset_dma256::dest_mb#0
  [74] *((word*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma256::num#0
  [75] *((byte*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memset_dma256::dest_bank#0
  [76] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma256::dest#0
  [77] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)WHITE
  [78] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  [79] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  [80] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  [81] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memset_dma_command256
  [82] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memset_dma_command256
  [83] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memset_dma256::dmaMode#0
  to:memset_dma256::@return
memset_dma256::@return: scope:[memset_dma256]  from memset_dma256
  [84] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void main()
byte~ main::$10 202.0
word main::c
word main::c#0 22.0
word main::c#1 101.0
word main::c#2 78.5
byte main::col
byte main::col#1 22.0
byte main::col#2 4.125
word* main::erow
word* main::erow#1 11.0
word* main::erow#5 13.666666666666666
byte main::i
byte main::i#1 202.0
byte main::i#2 80.8
byte* main::logo_dest
byte* main::logo_dest#1 7.333333333333333
byte* main::logo_dest#5 20.5
byte* main::logo_src
byte* main::logo_src#1 11.0
byte* main::logo_src#5 17.571428571428573
byte main::r
byte main::r#1 22.0
byte main::r#2 3.3000000000000003
byte main::y
byte main::y#1 202.0
byte main::y#2 168.33333333333331
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
volatile byte memoryRemap::aVal loadstore 2.75
word memoryRemap::lowerPageOffset
byte memoryRemap::remapBlocks
word memoryRemap::upperPageOffset
volatile byte memoryRemap::xVal loadstore 3.6666666666666665
volatile byte memoryRemap::yVal loadstore 5.5
volatile byte memoryRemap::zVal loadstore 11.0
void memset_dma(void* memset_dma::dest , byte memset_dma::fill , word memset_dma::num)
void* memset_dma::dest
void* memset_dma::dest#2
byte memset_dma::dmaMode
byte memset_dma::dmaMode#0 2.4444444444444446
byte memset_dma::fill
byte memset_dma::fill#2
word memset_dma::num
word memset_dma::num#2 5.5
void memset_dma256(byte memset_dma256::dest_mb , byte memset_dma256::dest_bank , void* memset_dma256::dest , byte memset_dma256::fill , word memset_dma256::num)
void* memset_dma256::dest
byte memset_dma256::dest_bank
byte memset_dma256::dest_mb
byte memset_dma256::dmaMode
byte memset_dma256::dmaMode#0 2.0
struct DMA_LIST_F018B* memset_dma256::f018b
byte memset_dma256::fill
word memset_dma256::num
volatile struct DMA_LIST_F018B memset_dma_command loadstore = { command: DMA_COMMAND_FILL, count: 0, src: 0, src_bank: 0, dest: 0, dest_bank: 0, sub_command: 0, modulo: 0 }

Initial phi equivalence classes
[ main::r#2 main::r#1 ]
[ main::erow#5 main::erow#1 ]
[ main::col#2 main::col#1 ]
[ main::logo_src#5 main::logo_src#1 ]
[ main::logo_dest#5 main::logo_dest#1 ]
[ main::y#2 main::y#1 ]
[ main::i#2 main::i#1 ]
[ main::c#2 main::c#0 main::c#1 ]
[ memset_dma::num#2 ]
[ memset_dma::fill#2 ]
[ memset_dma::dest#2 ]
Added variable main::$10 to live range equivalence class [ main::$10 ]
Added variable memoryRemap::aVal to live range equivalence class [ memoryRemap::aVal ]
Added variable memoryRemap::xVal to live range equivalence class [ memoryRemap::xVal ]
Added variable memoryRemap::yVal to live range equivalence class [ memoryRemap::yVal ]
Added variable memoryRemap::zVal to live range equivalence class [ memoryRemap::zVal ]
Added variable memset_dma::dmaMode#0 to live range equivalence class [ memset_dma::dmaMode#0 ]
Added variable memset_dma256::dmaMode#0 to live range equivalence class [ memset_dma256::dmaMode#0 ]
Added variable memset_dma_command to live range equivalence class [ memset_dma_command ]
Complete equivalence classes
[ main::r#2 main::r#1 ]
[ main::erow#5 main::erow#1 ]
[ main::col#2 main::col#1 ]
[ main::logo_src#5 main::logo_src#1 ]
[ main::logo_dest#5 main::logo_dest#1 ]
[ main::y#2 main::y#1 ]
[ main::i#2 main::i#1 ]
[ main::c#2 main::c#0 main::c#1 ]
[ memset_dma::num#2 ]
[ memset_dma::fill#2 ]
[ memset_dma::dest#2 ]
[ main::$10 ]
[ memoryRemap::aVal ]
[ memoryRemap::xVal ]
[ memoryRemap::yVal ]
[ memoryRemap::zVal ]
[ memset_dma::dmaMode#0 ]
[ memset_dma256::dmaMode#0 ]
[ memset_dma_command ]
Allocated zp[1]:2 [ main::r#2 main::r#1 ]
Allocated zp[2]:3 [ main::erow#5 main::erow#1 ]
Allocated zp[1]:5 [ main::col#2 main::col#1 ]
Allocated zp[2]:6 [ main::logo_src#5 main::logo_src#1 ]
Allocated zp[2]:8 [ main::logo_dest#5 main::logo_dest#1 ]
Allocated zp[1]:10 [ main::y#2 main::y#1 ]
Allocated zp[1]:11 [ main::i#2 main::i#1 ]
Allocated zp[2]:12 [ main::c#2 main::c#0 main::c#1 ]
Allocated zp[2]:14 [ memset_dma::num#2 ]
Allocated zp[1]:16 [ memset_dma::fill#2 ]
Allocated zp[2]:17 [ memset_dma::dest#2 ]
Allocated zp[1]:19 [ main::$10 ]
Allocated zp[1]:20 [ memoryRemap::aVal ]
Allocated zp[1]:21 [ memoryRemap::xVal ]
Allocated zp[1]:22 [ memoryRemap::yVal ]
Allocated zp[1]:23 [ memoryRemap::zVal ]
Allocated zp[1]:24 [ memset_dma::dmaMode#0 ]
Allocated zp[1]:25 [ memset_dma256::dmaMode#0 ]
Allocated mem[12] [ memset_dma_command ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [4] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [5] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [6] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $47 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [7] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $53 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [8] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [9] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [10] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [11] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [12] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI) = 2 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | 1 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [15] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) & $7f [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [16] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO) = $5a [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [18] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) = $28 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [19] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [20] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT) = $2d [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [21] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [22] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI) = byte1 SCREEN [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [23] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [24] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [25] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [26] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI) = byte1 CHARSET [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [27] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [37] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [40] main::logo_dest#1 = main::logo_dest#5 + (word)$20*8 [ main::col#2 main::logo_src#5 main::logo_dest#1 ] (  [ main::col#2 main::logo_src#5 main::logo_dest#1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ main::col#2 main::col#1 ]
Statement [41] main::logo_src#1 = main::logo_src#5 + $19*8 [ main::col#2 main::logo_src#1 main::logo_dest#1 ] (  [ main::col#2 main::logo_src#1 main::logo_dest#1 ] { }  ) always clobbers reg byte a 
Statement [43] main::logo_dest#5[main::y#2] = main::logo_src#5[main::y#2] [ main::col#2 main::logo_src#5 main::logo_dest#5 main::y#2 ] (  [ main::col#2 main::logo_src#5 main::logo_dest#5 main::y#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ main::y#2 main::y#1 ]
Statement [45] main::c#0 = (word)main::r#2 [ main::r#2 main::erow#5 main::c#0 ] (  [ main::r#2 main::erow#5 main::c#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::r#2 main::r#1 ]
Statement [48] main::erow#1 = main::erow#5 + $2d*SIZEOF_WORD [ main::r#2 main::erow#1 ] (  [ main::r#2 main::erow#1 ] { }  ) always clobbers reg byte a 
Statement [50] main::$10 = main::i#2 << 1 [ main::r#2 main::erow#5 main::i#2 main::c#2 main::$10 ] (  [ main::r#2 main::erow#5 main::i#2 main::c#2 main::$10 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:11 [ main::i#2 main::i#1 ]
Statement [51] main::erow#5[main::$10] = main::c#2 [ main::r#2 main::erow#5 main::i#2 main::c#2 ] (  [ main::r#2 main::erow#5 main::i#2 main::c#2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:2 [ main::r#2 main::r#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:11 [ main::i#2 main::i#1 ]
Statement [52] main::c#1 = main::c#2 + $20 [ main::r#2 main::erow#5 main::i#2 main::c#1 ] (  [ main::r#2 main::erow#5 main::i#2 main::c#1 ] { }  ) always clobbers reg byte a 
Statement [54] memoryRemap::aVal = 0 [ memoryRemap::aVal ] ( memoryRemap:3 [ memset_dma_command memoryRemap::aVal ] { }  ) always clobbers reg byte a 
Statement [55] memoryRemap::xVal = 0 [ memoryRemap::aVal memoryRemap::xVal ] ( memoryRemap:3 [ memset_dma_command memoryRemap::aVal memoryRemap::xVal ] { }  ) always clobbers reg byte a 
Statement [56] memoryRemap::yVal = 0 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] ( memoryRemap:3 [ memset_dma_command memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  ) always clobbers reg byte a 
Statement [57] memoryRemap::zVal = 0 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::zVal ] ( memoryRemap:3 [ memset_dma_command memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::zVal ] { }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [62] *((word*)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma::num#2 [ memset_dma::fill#2 memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::fill#2 memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::fill#2 memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:16 [ memset_dma::fill#2 ]
Removing always clobbered register reg byte a as potential for zp[1]:24 [ memset_dma::dmaMode#0 ]
Statement [63] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memset_dma::fill#2 [ memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [64] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma::dest#2 [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [67] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [68] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memset_dma_command [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [69] *((byte*)DMA) = byte0 &memset_dma_command [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [73] *(memset_dma_command256+1) = memset_dma256::dest_mb#0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:25 [ memset_dma256::dmaMode#0 ]
Statement [74] *((word*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma256::num#0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [75] *((byte*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memset_dma256::dest_bank#0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [76] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma256::dest#0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [77] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)WHITE [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [78] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [79] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [80] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [81] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memset_dma_command256 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [82] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memset_dma_command256 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [4] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [5] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [6] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $47 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [7] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $53 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [8] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [9] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [10] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [11] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [12] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI) = 2 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | 1 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [15] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) & $7f [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [16] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO) = $5a [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [18] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) = $28 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [19] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [20] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT) = $2d [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [21] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [22] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI) = byte1 SCREEN [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [23] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [24] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [25] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [26] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI) = byte1 CHARSET [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [27] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO) = 0 [ memset_dma_command ] (  [ memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [37] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [40] main::logo_dest#1 = main::logo_dest#5 + (word)$20*8 [ main::col#2 main::logo_src#5 main::logo_dest#1 ] (  [ main::col#2 main::logo_src#5 main::logo_dest#1 ] { }  ) always clobbers reg byte a 
Statement [41] main::logo_src#1 = main::logo_src#5 + $19*8 [ main::col#2 main::logo_src#1 main::logo_dest#1 ] (  [ main::col#2 main::logo_src#1 main::logo_dest#1 ] { }  ) always clobbers reg byte a 
Statement [43] main::logo_dest#5[main::y#2] = main::logo_src#5[main::y#2] [ main::col#2 main::logo_src#5 main::logo_dest#5 main::y#2 ] (  [ main::col#2 main::logo_src#5 main::logo_dest#5 main::y#2 ] { }  ) always clobbers reg byte a 
Statement [45] main::c#0 = (word)main::r#2 [ main::r#2 main::erow#5 main::c#0 ] (  [ main::r#2 main::erow#5 main::c#0 ] { }  ) always clobbers reg byte a 
Statement [48] main::erow#1 = main::erow#5 + $2d*SIZEOF_WORD [ main::r#2 main::erow#1 ] (  [ main::r#2 main::erow#1 ] { }  ) always clobbers reg byte a 
Statement [50] main::$10 = main::i#2 << 1 [ main::r#2 main::erow#5 main::i#2 main::c#2 main::$10 ] (  [ main::r#2 main::erow#5 main::i#2 main::c#2 main::$10 ] { }  ) always clobbers reg byte a 
Statement [51] main::erow#5[main::$10] = main::c#2 [ main::r#2 main::erow#5 main::i#2 main::c#2 ] (  [ main::r#2 main::erow#5 main::i#2 main::c#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [52] main::c#1 = main::c#2 + $20 [ main::r#2 main::erow#5 main::i#2 main::c#1 ] (  [ main::r#2 main::erow#5 main::i#2 main::c#1 ] { }  ) always clobbers reg byte a 
Statement [54] memoryRemap::aVal = 0 [ memoryRemap::aVal ] ( memoryRemap:3 [ memset_dma_command memoryRemap::aVal ] { }  ) always clobbers reg byte a 
Statement [55] memoryRemap::xVal = 0 [ memoryRemap::aVal memoryRemap::xVal ] ( memoryRemap:3 [ memset_dma_command memoryRemap::aVal memoryRemap::xVal ] { }  ) always clobbers reg byte a 
Statement [56] memoryRemap::yVal = 0 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] ( memoryRemap:3 [ memset_dma_command memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  ) always clobbers reg byte a 
Statement [57] memoryRemap::zVal = 0 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::zVal ] ( memoryRemap:3 [ memset_dma_command memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::zVal ] { }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [62] *((word*)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma::num#2 [ memset_dma::fill#2 memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::fill#2 memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::fill#2 memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [63] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memset_dma::fill#2 [ memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dest#2 memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [64] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma::dest#2 [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [67] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [68] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memset_dma_command [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [69] *((byte*)DMA) = byte0 &memset_dma_command [ memset_dma::dmaMode#0 memset_dma_command ] ( memset_dma:28 [ memset_dma::dmaMode#0 memset_dma_command ] { }  memset_dma:32 [ memset_dma::dmaMode#0 memset_dma_command ] { }  ) always clobbers reg byte a 
Statement [73] *(memset_dma_command256+1) = memset_dma256::dest_mb#0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [74] *((word*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma256::num#0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [75] *((byte*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memset_dma256::dest_bank#0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [76] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma256::dest#0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [77] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)WHITE [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [78] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [79] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [80] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [81] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memset_dma_command256 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [82] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memset_dma_command256 [ memset_dma256::dmaMode#0 ] ( memset_dma256:30 [ memset_dma_command memset_dma256::dmaMode#0 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::r#2 main::r#1 ] : zp[1]:2 , reg byte x , reg byte z , 
Potential registers zp[2]:3 [ main::erow#5 main::erow#1 ] : zp[2]:3 , 
Potential registers zp[1]:5 [ main::col#2 main::col#1 ] : zp[1]:5 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:6 [ main::logo_src#5 main::logo_src#1 ] : zp[2]:6 , 
Potential registers zp[2]:8 [ main::logo_dest#5 main::logo_dest#1 ] : zp[2]:8 , 
Potential registers zp[1]:10 [ main::y#2 main::y#1 ] : zp[1]:10 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:11 [ main::i#2 main::i#1 ] : zp[1]:11 , reg byte x , reg byte z , 
Potential registers zp[2]:12 [ main::c#2 main::c#0 main::c#1 ] : zp[2]:12 , 
Potential registers zp[2]:14 [ memset_dma::num#2 ] : zp[2]:14 , 
Potential registers zp[1]:16 [ memset_dma::fill#2 ] : zp[1]:16 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:17 [ memset_dma::dest#2 ] : zp[2]:17 , 
Potential registers zp[1]:19 [ main::$10 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:20 [ memoryRemap::aVal ] : zp[1]:20 , 
Potential registers zp[1]:21 [ memoryRemap::xVal ] : zp[1]:21 , 
Potential registers zp[1]:22 [ memoryRemap::yVal ] : zp[1]:22 , 
Potential registers zp[1]:23 [ memoryRemap::zVal ] : zp[1]:23 , 
Potential registers zp[1]:24 [ memset_dma::dmaMode#0 ] : zp[1]:24 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:25 [ memset_dma256::dmaMode#0 ] : zp[1]:25 , reg byte x , reg byte y , reg byte z , 
Potential registers mem[12] [ memset_dma_command ] : mem[12] , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 370.33: zp[1]:10 [ main::y#2 main::y#1 ] 282.8: zp[1]:11 [ main::i#2 main::i#1 ] 202: zp[1]:19 [ main::$10 ] 201.5: zp[2]:12 [ main::c#2 main::c#0 main::c#1 ] 28.57: zp[2]:6 [ main::logo_src#5 main::logo_src#1 ] 27.83: zp[2]:8 [ main::logo_dest#5 main::logo_dest#1 ] 26.12: zp[1]:5 [ main::col#2 main::col#1 ] 25.3: zp[1]:2 [ main::r#2 main::r#1 ] 24.67: zp[2]:3 [ main::erow#5 main::erow#1 ] 
Uplift Scope [memoryRemap] 11: zp[1]:23 [ memoryRemap::zVal ] 5.5: zp[1]:22 [ memoryRemap::yVal ] 3.67: zp[1]:21 [ memoryRemap::xVal ] 2.75: zp[1]:20 [ memoryRemap::aVal ] 
Uplift Scope [memset_dma] 5.5: zp[2]:14 [ memset_dma::num#2 ] 2.44: zp[1]:24 [ memset_dma::dmaMode#0 ] 0: zp[1]:16 [ memset_dma::fill#2 ] 0: zp[2]:17 [ memset_dma::dest#2 ] 
Uplift Scope [memset_dma256] 2: zp[1]:25 [ memset_dma256::dmaMode#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [MOS4569_VICIII] 
Uplift Scope [MEGA65_VICIV] 
Uplift Scope [F018_DMAGIC] 
Uplift Scope [DMA_LIST_F018A] 
Uplift Scope [DMA_LIST_F018B] 
Uplift Scope [] 0: mem[12] [ memset_dma_command ] 

Uplifting [main] best 10781 combination reg byte y [ main::y#2 main::y#1 ] reg byte z [ main::i#2 main::i#1 ] reg byte a [ main::$10 ] zp[2]:12 [ main::c#2 main::c#0 main::c#1 ] zp[2]:6 [ main::logo_src#5 main::logo_src#1 ] zp[2]:8 [ main::logo_dest#5 main::logo_dest#1 ] reg byte x [ main::col#2 main::col#1 ] zp[1]:2 [ main::r#2 main::r#1 ] zp[2]:3 [ main::erow#5 main::erow#1 ] 
Limited combination testing to 100 combinations of 720 possible.
Uplifting [memoryRemap] best 10781 combination zp[1]:23 [ memoryRemap::zVal ] zp[1]:22 [ memoryRemap::yVal ] zp[1]:21 [ memoryRemap::xVal ] zp[1]:20 [ memoryRemap::aVal ] 
Uplifting [memset_dma] best 10767 combination zp[2]:14 [ memset_dma::num#2 ] reg byte x [ memset_dma::dmaMode#0 ] reg byte z [ memset_dma::fill#2 ] zp[2]:17 [ memset_dma::dest#2 ] 
Uplifting [memset_dma256] best 10761 combination reg byte x [ memset_dma256::dmaMode#0 ] 
Uplifting [MOS6526_CIA] best 10761 combination 
Uplifting [MOS6569_VICII] best 10761 combination 
Uplifting [MOS6581_SID] best 10761 combination 
Uplifting [MOS4569_VICIII] best 10761 combination 
Uplifting [MEGA65_VICIV] best 10761 combination 
Uplifting [F018_DMAGIC] best 10761 combination 
Uplifting [DMA_LIST_F018A] best 10761 combination 
Uplifting [DMA_LIST_F018B] best 10761 combination 
Uplifting [] best 10761 combination mem[12] [ memset_dma_command ] 
Attempting to uplift remaining variables inzp[1]:2 [ main::r#2 main::r#1 ]
Uplifting [main] best 10661 combination reg byte x [ main::r#2 main::r#1 ] 
Attempting to uplift remaining variables inzp[1]:23 [ memoryRemap::zVal ]
Uplifting [memoryRemap] best 10661 combination zp[1]:23 [ memoryRemap::zVal ] 
Attempting to uplift remaining variables inzp[1]:22 [ memoryRemap::yVal ]
Uplifting [memoryRemap] best 10661 combination zp[1]:22 [ memoryRemap::yVal ] 
Attempting to uplift remaining variables inzp[1]:21 [ memoryRemap::xVal ]
Uplifting [memoryRemap] best 10661 combination zp[1]:21 [ memoryRemap::xVal ] 
Attempting to uplift remaining variables inzp[1]:20 [ memoryRemap::aVal ]
Uplifting [memoryRemap] best 10661 combination zp[1]:20 [ memoryRemap::aVal ] 
Allocated (was zp[2]:3) zp[2]:2 [ main::erow#5 main::erow#1 ]
Allocated (was zp[2]:6) zp[2]:4 [ main::logo_src#5 main::logo_src#1 ]
Allocated (was zp[2]:8) zp[2]:6 [ main::logo_dest#5 main::logo_dest#1 ]
Allocated (was zp[2]:12) zp[2]:8 [ main::c#2 main::c#0 main::c#1 ]
Allocated (was zp[2]:14) zp[2]:10 [ memset_dma::num#2 ]
Allocated (was zp[2]:17) zp[2]:12 [ memset_dma::dest#2 ]
Allocated (was zp[1]:20) zp[1]:14 [ memoryRemap::aVal ]
Allocated (was zp[1]:21) zp[1]:15 [ memoryRemap::xVal ]
Allocated (was zp[1]:22) zp[1]:16 [ memoryRemap::yVal ]
Allocated (was zp[1]:23) zp[1]:17 [ memoryRemap::zVal ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// DYPP (Different Y Pixel Position) LOGO created using DMA
// Graphics mode is 45x25 full-colour super extended attribute mode text-mode
// Character layout is column-wise giving linear addressing of the graphics (one byte per pixel)
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="dypp65.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // DMA command fill
  .const DMA_COMMAND_FILL = 3
  // $00 = End of options
  .const DMA_OPTION_END = 0
  // $0B = Use F018B list format
  .const DMA_OPTION_FORMAT_F018B = $a
  // $81 $xx = Set MB of destination address
  .const DMA_OPTION_DEST_MB = $81
  .const WHITE = 1
  .const SIZEOF_WORD = 2
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
  .const OFFSET_STRUCT_F018_DMAGIC_ETRIG = 5
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
  .const OFFSET_STRUCT_MEGA65_VICIV_KEY = $2f
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI = $5d
  .const OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO = $48
  .const OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI = $49
  .const OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO = $4a
  .const OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI = $4b
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO = $58
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI = $59
  .const OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO = $4c
  .const OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI = $4d
  .const OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT = $5e
  .const OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO = $60
  .const OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI = $61
  .const OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO = $62
  .const OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI = $63
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO = $68
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI = $69
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO = $6a
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR = $21
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // The VIC IV
  .label VICIV = $d000
  // DMAgic F018 Controller
  .label DMA = $d700
  // The screen address (45*25*2=0x08ca bytes)
  .label SCREEN = $5000
  // The charset address (45*32*8=0x2d00 bytes)
  .label CHARSET = $6000
.segment Code
  // main
main: {
    .label c = 8
    // Fill extended screen to achieve column-wise linear addressing
    .label erow = 2
    //  Copy the LOGO to the CHARSET
    .label logo_dest = 6
    .label logo_src = 4
    jmp SEI1
    // main::SEI1
  SEI1:
    // asm { sei  }
    sei
    // [2] phi from main::SEI1 to main::@11 [phi:main::SEI1->main::@11]
  __b11_from_SEI1:
    jmp __b11
    // main::@11
  __b11:
    // [3] call memoryRemap 
    // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    jsr memoryRemap
    jmp __b12
    // main::@12
  __b12:
    // [4] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable 48MHz fast mode
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // [5] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // [6] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $47 -- _deref_pbuc1=vbuc2 
    // Enable the VIC 4
    lda #$47
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY
    // [7] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $53 -- _deref_pbuc1=vbuc2 
    lda #$53
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY
    // [8] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 0 -- _deref_pbuc1=vbuc2 
    // Set sideborder width=0, disable raster delay and hot registers
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO
    // [9] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI
    // [10] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO) = 0 -- _deref_pbuc1=vbuc2 
    // Disable top/bottom borders
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO
    // [11] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI
    // [12] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO
    // [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI) = 2 -- _deref_pbuc1=vbuc2 
    lda #2
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI
    // [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | 1 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable Super Extended Attribute Mode
    lda #1
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // [15] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Mode 40x25 chars - will be 45*25 when utilizing the borders
    lda #$7f
    and VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // [16] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO) = $5a -- _deref_pbuc1=vbuc2 
    lda #$5a
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO
    // [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI
    // [18] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) = $28 -- _deref_pbuc1=vbuc2 
    // Start text in the left border
    lda #$28
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // [19] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI
    // [20] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT) = $2d -- _deref_pbuc1=vbuc2 
    // Set number of characters to display per row
    lda #$2d
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT
    // [21] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO) = 0 -- _deref_pbuc1=vbuc2 
    // Set exact screen address
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO
    // [22] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI) = byte1 SCREEN -- _deref_pbuc1=vbuc2 
    lda #>SCREEN
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI
    // [23] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO
    // [24] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI
    // [25] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO) = 0 -- _deref_pbuc1=vbuc2 
    // Set exact charset address
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO
    // [26] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI) = byte1 CHARSET -- _deref_pbuc1=vbuc2 
    lda #>CHARSET
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI
    // [27] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO
    // [28] call memset_dma 
  // Fill the screen with 0
    // [60] phi from main::@12 to memset_dma [phi:main::@12->memset_dma]
  memset_dma_from___b12:
    // [60] phi memset_dma::dest#2 = (void*)SCREEN [phi:main::@12->memset_dma#0] -- pvoz1=pvoc1 
    lda #<SCREEN
    sta.z memset_dma.dest
    lda #>SCREEN
    sta.z memset_dma.dest+1
    // [60] phi memset_dma::fill#2 = 0 [phi:main::@12->memset_dma#1] -- vbuzz=vbuc1 
    ldz #0
    // [60] phi memset_dma::num#2 = (word)$2d*$19*2 [phi:main::@12->memset_dma#2] -- vwuz1=vwuc1 
    lda #<$2d*$19*2
    sta.z memset_dma.num
    lda #>$2d*$19*2
    sta.z memset_dma.num+1
    jsr memset_dma
    // [29] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
  __b13_from___b12:
    jmp __b13
    // main::@13
  __b13:
    // [30] call memset_dma256 
    // Fill the colours with WHITE - directly into $ff80000
    jsr memset_dma256
    // [31] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
  __b14_from___b13:
    jmp __b14
    // main::@14
  __b14:
    // [32] call memset_dma 
  // Fill the charset with 0x55
    // [60] phi from main::@14 to memset_dma [phi:main::@14->memset_dma]
  memset_dma_from___b14:
    // [60] phi memset_dma::dest#2 = (void*)CHARSET [phi:main::@14->memset_dma#0] -- pvoz1=pvoc1 
    lda #<CHARSET
    sta.z memset_dma.dest
    lda #>CHARSET
    sta.z memset_dma.dest+1
    // [60] phi memset_dma::fill#2 = $55 [phi:main::@14->memset_dma#1] -- vbuzz=vbuc1 
    ldz #$55
    // [60] phi memset_dma::num#2 = (word)$2d*$20*8 [phi:main::@14->memset_dma#2] -- vwuz1=vwuc1 
    lda #<$2d*$20*8
    sta.z memset_dma.num
    lda #>$2d*$20*8
    sta.z memset_dma.num+1
    jsr memset_dma
    // [33] phi from main::@14 to main::@1 [phi:main::@14->main::@1]
  __b1_from___b14:
    // [33] phi main::erow#5 = SCREEN [phi:main::@14->main::@1#0] -- pwuz1=pbuc1 
    lda #<SCREEN
    sta.z erow
    lda #>SCREEN
    sta.z erow+1
    // [33] phi main::r#2 = 0 [phi:main::@14->main::@1#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // main::@1
  __b1:
    // [34] if(main::r#2<$19) goto main::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$19
    bcc __b2
    // [35] phi from main::@1 to main::@6 [phi:main::@1->main::@6]
  __b6_from___b1:
    // [35] phi main::logo_dest#5 = CHARSET [phi:main::@1->main::@6#0] -- pbuz1=pbuc1 
    lda #<CHARSET
    sta.z logo_dest
    lda #>CHARSET
    sta.z logo_dest+1
    // [35] phi main::logo_src#5 = LOGO [phi:main::@1->main::@6#1] -- pbuz1=pbuc1 
    lda #<LOGO
    sta.z logo_src
    lda #>LOGO
    sta.z logo_src+1
    // [35] phi main::col#2 = 0 [phi:main::@1->main::@6#2] -- vbuxx=vbuc1 
    ldx #0
    jmp __b6
    // main::@6
  __b6:
    // [36] if(main::col#2<$2d) goto main::@7 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$2d
    bcc __b7_from___b6
    jmp __b10
    // main::@10
  __b10:
    // [37] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) -- _deref_pbuc1=_deref_pbuc2 
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR
    jmp __b10
    // [38] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  __b7_from___b6:
    // [38] phi main::y#2 = 0 [phi:main::@6->main::@7#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b7
    // main::@7
  __b7:
    // [39] if(main::y#2<$19*8) goto main::@8 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$19*8
    bcc __b8
    jmp __b9
    // main::@9
  __b9:
    // [40] main::logo_dest#1 = main::logo_dest#5 + (word)$20*8 -- pbuz1=pbuz1_plus_vwuc1 
    clc
    lda.z logo_dest
    adc #<$20*8
    sta.z logo_dest
    lda.z logo_dest+1
    adc #>$20*8
    sta.z logo_dest+1
    // [41] main::logo_src#1 = main::logo_src#5 + $19*8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$19*8
    clc
    adc.z logo_src
    sta.z logo_src
    bcc !+
    inc.z logo_src+1
  !:
    // [42] main::col#1 = ++ main::col#2 -- vbuxx=_inc_vbuxx 
    inx
    // [35] phi from main::@9 to main::@6 [phi:main::@9->main::@6]
  __b6_from___b9:
    // [35] phi main::logo_dest#5 = main::logo_dest#1 [phi:main::@9->main::@6#0] -- register_copy 
    // [35] phi main::logo_src#5 = main::logo_src#1 [phi:main::@9->main::@6#1] -- register_copy 
    // [35] phi main::col#2 = main::col#1 [phi:main::@9->main::@6#2] -- register_copy 
    jmp __b6
    // main::@8
  __b8:
    // [43] main::logo_dest#5[main::y#2] = main::logo_src#5[main::y#2] -- pbuz1_derefidx_vbuyy=pbuz2_derefidx_vbuyy 
    lda (logo_src),y
    sta (logo_dest),y
    // [44] main::y#1 = ++ main::y#2 -- vbuyy=_inc_vbuyy 
    iny
    // [38] phi from main::@8 to main::@7 [phi:main::@8->main::@7]
  __b7_from___b8:
    // [38] phi main::y#2 = main::y#1 [phi:main::@8->main::@7#0] -- register_copy 
    jmp __b7
    // main::@2
  __b2:
    // [45] main::c#0 = (word)main::r#2 -- vwuz1=_word_vbuxx 
    txa
    sta.z c
    lda #0
    sta.z c+1
    // [46] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [46] phi main::c#2 = main::c#0 [phi:main::@2->main::@3#0] -- register_copy 
    // [46] phi main::i#2 = 0 [phi:main::@2->main::@3#1] -- vbuzz=vbuc1 
    ldz #0
    jmp __b3
    // main::@3
  __b3:
    // [47] if(main::i#2<$2d) goto main::@4 -- vbuzz_lt_vbuc1_then_la1 
    cpz #$2d
    bcc __b4
    jmp __b5
    // main::@5
  __b5:
    // [48] main::erow#1 = main::erow#5 + $2d*SIZEOF_WORD -- pwuz1=pwuz1_plus_vbuc1 
    lda #$2d*SIZEOF_WORD
    clc
    adc.z erow
    sta.z erow
    bcc !+
    inc.z erow+1
  !:
    // [49] main::r#1 = ++ main::r#2 -- vbuxx=_inc_vbuxx 
    inx
    // [33] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  __b1_from___b5:
    // [33] phi main::erow#5 = main::erow#1 [phi:main::@5->main::@1#0] -- register_copy 
    // [33] phi main::r#2 = main::r#1 [phi:main::@5->main::@1#1] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // [50] main::$10 = main::i#2 << 1 -- vbuaa=vbuzz_rol_1 
    tza
    asl
    // [51] main::erow#5[main::$10] = main::c#2 -- pwuz1_derefidx_vbuaa=vwuz2 
    tay
    lda.z c
    sta (erow),y
    iny
    lda.z c+1
    sta (erow),y
    // [52] main::c#1 = main::c#2 + $20 -- vwuz1=vwuz1_plus_vbuc1 
    lda #$20
    clc
    adc.z c
    sta.z c
    bcc !+
    inc.z c+1
  !:
    // [53] main::i#1 = ++ main::i#2 -- vbuzz=_inc_vbuzz 
    inz
    // [46] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [46] phi main::c#2 = main::c#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [46] phi main::i#2 = main::i#1 [phi:main::@4->main::@3#1] -- register_copy 
    jmp __b3
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
memoryRemap: {
    .label aVal = $e
    .label xVal = $f
    .label yVal = $10
    .label zVal = $11
    // [54] memoryRemap::aVal = 0 -- vbuz1=vbuc1 
    // lower blocks offset page low
    lda #0
    sta.z aVal
    // [55] memoryRemap::xVal = 0 -- vbuz1=vbuc1 
    // lower blocks to map + lower blocks offset high nibble
    lda #0
    sta.z xVal
    // [56] memoryRemap::yVal = 0 -- vbuz1=vbuc1 
    // upper blocks offset page
    lda #0
    sta.z yVal
    // [57] memoryRemap::zVal = 0 -- vbuz1=vbuc1 
    // upper blocks to map + upper blocks offset page high nibble
    lda #0
    sta.z zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [59] return 
    rts
}
  // memset_dma
// Fill a memory block within the first 64K memory space using MEGA65 DMagic DMA
// Fills the values of num bytes at the destination with a single byte value.
// - dest The destination address (within the MB and bank)
// - fill The char to fill with
// - num The number of bytes to copy
// memset_dma(void* zp($c) dest, byte register(Z) fill, word zp($a) num)
memset_dma: {
    .label num = $a
    .label dest = $c
    // [61] memset_dma::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [62] *((word*)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma::num#2 -- _deref_pwuc1=vwuz1 
    // Set up command
    lda.z num
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda.z num+1
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // [63] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memset_dma::fill#2 -- _deref_qbuc1=_ptr_vbuzz 
    tza
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #0
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // [64] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma::dest#2 -- _deref_qbuc1=pbuz1 
    lda.z dest
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda.z dest+1
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // [67] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // [68] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memset_dma_command -- _deref_pbuc1=vbuc2 
    lda #>memset_dma_command
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // [69] *((byte*)DMA) = byte0 &memset_dma_command -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<memset_dma_command
    sta DMA
    // [70] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memset_dma::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    jmp __breturn
    // memset_dma::@return
  __breturn:
    // [71] return 
    rts
}
  // memset_dma256
// Set a memory block anywhere in the entire 256MB memory space using MEGA65 DMagic DMA
// Sets the values of num bytes to the memory block pointed to by destination.
// - dest_mb The MB value for the destination (0-255)
// - dest_bank The 64KB bank for the destination (0-15)
// - dest The destination address (within the MB and bank)
// - num The number of bytes to copy
memset_dma256: {
    .const dest_mb = $ff
    .const dest_bank = 8
    .const num = $2d*$19*2
    .label dest = 0
    .label f018b = memset_dma_command256+4
    // [72] memset_dma256::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [73] *(memset_dma_command256+1) = memset_dma256::dest_mb#0 -- _deref_pbuc1=vbuc2 
    // Set up command
    lda #dest_mb
    sta memset_dma_command256+1
    // [74] *((word*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma256::num#0 -- _deref_pwuc1=vwuc2 
    lda #<num
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // [75] *((byte*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memset_dma256::dest_bank#0 -- _deref_pbuc1=vbuc2 
    lda #dest_bank
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
    // [76] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma256::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // [77] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)WHITE -- _deref_qbuc1=pbuc2 
    // Set fill byte
    lda #<WHITE
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>WHITE
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // [78] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [79] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // [80] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // [81] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memset_dma_command256 -- _deref_pbuc1=vbuc2 
    lda #>memset_dma_command256
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // [82] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memset_dma_command256 -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (with option lists)
    lda #<memset_dma_command256
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG
    // [83] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memset_dma256::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    jmp __breturn
    // memset_dma256::@return
  __breturn:
    // [84] return 
    rts
}
  // File Data
.segment Data
  // DMA list entry with options for setting data in the 256MB memory space
  // Contains DMA options options for setting MB followed by DMA_LIST_F018B struct.
  memset_dma_command256: .byte DMA_OPTION_DEST_MB, 0, DMA_OPTION_FORMAT_F018B, DMA_OPTION_END, DMA_COMMAND_FILL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  // A logo in column-wide linear single-color memory layout
LOGO:
.var pic = LoadPicture("camelot.png", List().add($ffffff, $000000))
	.for (var x=0;x<45; x++)
    	.for (var y=0; y<25*8; y++)
            .byte pic.getSinglecolorByte(x,y)

  // DMA list entry for filling data
  memset_dma_command: .byte DMA_COMMAND_FILL
  .word 0, 0
  .byte 0
  .word 0
  .byte 0, 0
  .word 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp SEI1
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b13
Removing instruction jmp __b14
Removing instruction jmp __b1
Removing instruction jmp __b6
Removing instruction jmp __b10
Removing instruction jmp __b7
Removing instruction jmp __b9
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b11_from_SEI1:
Removing instruction __b13_from___b12:
Removing instruction __b14_from___b13:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction SEI1:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction memset_dma_from___b12:
Removing instruction __b13:
Removing instruction __b14:
Removing instruction memset_dma_from___b14:
Removing instruction __b1_from___b14:
Removing instruction __b6_from___b1:
Removing instruction __b9:
Removing instruction __b6_from___b9:
Removing instruction __b7_from___b8:
Removing instruction __b3_from___b2:
Removing instruction __b5:
Removing instruction __b1_from___b5:
Removing instruction __b3_from___b4:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Relabelling long label __b7_from___b6 to __b5
Succesful ASM optimization Pass5RelabelLongLabels

FINAL SYMBOL TABLE
constant byte* const CHARSET = (byte*) 24576
constant struct F018_DMAGIC* const DMA = (struct F018_DMAGIC*) 55040
constant const byte DMA_COMMAND_FILL = 3
constant const byte DMA_OPTION_DEST_MB = $81
constant const byte DMA_OPTION_END = 0
constant const byte DMA_OPTION_FORMAT_F018B = $a
constant byte* LOGO[$2d*$19*8]  = kickasm {{ .var pic = LoadPicture("camelot.png", List().add($ffffff, $000000))
	.for (var x=0;x<45; x++)
    	.for (var y=0; y<25*8; y++)
            .byte pic.getSinglecolorByte(x,y)
 }}
constant byte OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
constant byte OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
constant byte OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
constant byte OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
constant byte OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
constant byte OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
constant byte OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
constant byte OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
constant byte OFFSET_STRUCT_F018_DMAGIC_ETRIG = 5
constant byte OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI = $4b
constant byte OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO = $4a
constant byte OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR = $21
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO = $6a
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI = $69
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO = $68
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI = $59
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO = $58
constant byte OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT = $5e
constant byte OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
constant byte OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
constant byte OFFSET_STRUCT_MEGA65_VICIV_KEY = $2f
constant byte OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI = $63
constant byte OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO = $62
constant byte OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI = $61
constant byte OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO = $60
constant byte OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI = $5d
constant byte OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
constant byte OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI = $49
constant byte OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO = $48
constant byte OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI = $4d
constant byte OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO = $4c
constant byte OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
constant byte* const SCREEN = (byte*) 20480
constant byte SIZEOF_WORD = 2
constant struct MOS6569_VICII* const VICII = (struct MOS6569_VICII*) 53248
constant struct MEGA65_VICIV* const VICIV = (struct MEGA65_VICIV*) 53248
constant const byte WHITE = 1
void main()
byte~ main::$10 reg byte a 202.0
word main::c
word main::c#0 c zp[2]:8 22.0
word main::c#1 c zp[2]:8 101.0
word main::c#2 c zp[2]:8 78.5
byte main::col
byte main::col#1 reg byte x 22.0
byte main::col#2 reg byte x 4.125
word* main::erow
word* main::erow#1 erow zp[2]:2 11.0
word* main::erow#5 erow zp[2]:2 13.666666666666666
byte main::i
byte main::i#1 reg byte z 202.0
byte main::i#2 reg byte z 80.8
byte* main::logo_dest
byte* main::logo_dest#1 logo_dest zp[2]:6 7.333333333333333
byte* main::logo_dest#5 logo_dest zp[2]:6 20.5
byte* main::logo_src
byte* main::logo_src#1 logo_src zp[2]:4 11.0
byte* main::logo_src#5 logo_src zp[2]:4 17.571428571428573
byte main::r
byte main::r#1 reg byte x 22.0
byte main::r#2 reg byte x 3.3000000000000003
byte main::y
byte main::y#1 reg byte y 202.0
byte main::y#2 reg byte y 168.33333333333331
void memoryRemap(byte memoryRemap::remapBlocks , word memoryRemap::lowerPageOffset , word memoryRemap::upperPageOffset)
volatile byte memoryRemap::aVal loadstore zp[1]:14 2.75
word memoryRemap::lowerPageOffset
byte memoryRemap::remapBlocks
word memoryRemap::upperPageOffset
volatile byte memoryRemap::xVal loadstore zp[1]:15 3.6666666666666665
volatile byte memoryRemap::yVal loadstore zp[1]:16 5.5
volatile byte memoryRemap::zVal loadstore zp[1]:17 11.0
void memset_dma(void* memset_dma::dest , byte memset_dma::fill , word memset_dma::num)
void* memset_dma::dest
void* memset_dma::dest#2 dest zp[2]:12
byte memset_dma::dmaMode
byte memset_dma::dmaMode#0 reg byte x 2.4444444444444446
byte memset_dma::fill
byte memset_dma::fill#2 reg byte z
word memset_dma::num
word memset_dma::num#2 num zp[2]:10 5.5
void memset_dma256(byte memset_dma256::dest_mb , byte memset_dma256::dest_bank , void* memset_dma256::dest , byte memset_dma256::fill , word memset_dma256::num)
void* memset_dma256::dest
constant void* memset_dma256::dest#0 dest = (void*) 0
byte memset_dma256::dest_bank
constant byte memset_dma256::dest_bank#0 dest_bank = 8
byte memset_dma256::dest_mb
constant byte memset_dma256::dest_mb#0 dest_mb = $ff
byte memset_dma256::dmaMode
byte memset_dma256::dmaMode#0 reg byte x 2.0
struct DMA_LIST_F018B* memset_dma256::f018b
constant struct DMA_LIST_F018B* memset_dma256::f018b#0 f018b = (struct DMA_LIST_F018B*)memset_dma_command256+4
byte memset_dma256::fill
word memset_dma256::num
constant word memset_dma256::num#0 num = (word)$2d*$19*2
volatile struct DMA_LIST_F018B memset_dma_command loadstore mem[12] = { command: DMA_COMMAND_FILL, count: 0, src: 0, src_bank: 0, dest: 0, dest_bank: 0, sub_command: 0, modulo: 0 }
constant byte* memset_dma_command256[]  = { DMA_OPTION_DEST_MB, 0, DMA_OPTION_FORMAT_F018B, DMA_OPTION_END, DMA_COMMAND_FILL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

reg byte x [ main::r#2 main::r#1 ]
zp[2]:2 [ main::erow#5 main::erow#1 ]
reg byte x [ main::col#2 main::col#1 ]
zp[2]:4 [ main::logo_src#5 main::logo_src#1 ]
zp[2]:6 [ main::logo_dest#5 main::logo_dest#1 ]
reg byte y [ main::y#2 main::y#1 ]
reg byte z [ main::i#2 main::i#1 ]
zp[2]:8 [ main::c#2 main::c#0 main::c#1 ]
zp[2]:10 [ memset_dma::num#2 ]
reg byte z [ memset_dma::fill#2 ]
zp[2]:12 [ memset_dma::dest#2 ]
reg byte a [ main::$10 ]
zp[1]:14 [ memoryRemap::aVal ]
zp[1]:15 [ memoryRemap::xVal ]
zp[1]:16 [ memoryRemap::yVal ]
zp[1]:17 [ memoryRemap::zVal ]
reg byte x [ memset_dma::dmaMode#0 ]
reg byte x [ memset_dma256::dmaMode#0 ]
mem[12] [ memset_dma_command ]


FINAL ASSEMBLER
Score: 9298

  // File Comments
// DYPP (Different Y Pixel Position) LOGO created using DMA
// Graphics mode is 45x25 full-colour super extended attribute mode text-mode
// Character layout is column-wise giving linear addressing of the graphics (one byte per pixel)
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="dypp65.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // DMA command fill
  .const DMA_COMMAND_FILL = 3
  // $00 = End of options
  .const DMA_OPTION_END = 0
  // $0B = Use F018B list format
  .const DMA_OPTION_FORMAT_F018B = $a
  // $81 $xx = Set MB of destination address
  .const DMA_OPTION_DEST_MB = $81
  .const WHITE = 1
  .const SIZEOF_WORD = 2
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
  .const OFFSET_STRUCT_F018_DMAGIC_ETRIG = 5
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
  .const OFFSET_STRUCT_MEGA65_VICIV_KEY = $2f
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI = $5d
  .const OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO = $48
  .const OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI = $49
  .const OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO = $4a
  .const OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI = $4b
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO = $58
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI = $59
  .const OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO = $4c
  .const OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI = $4d
  .const OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT = $5e
  .const OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO = $60
  .const OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI = $61
  .const OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO = $62
  .const OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI = $63
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO = $68
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI = $69
  .const OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO = $6a
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR = $21
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // The VIC IV
  .label VICIV = $d000
  // DMAgic F018 Controller
  .label DMA = $d700
  // The screen address (45*25*2=0x08ca bytes)
  .label SCREEN = $5000
  // The charset address (45*32*8=0x2d00 bytes)
  .label CHARSET = $6000
.segment Code
  // main
main: {
    .label c = 8
    // Fill extended screen to achieve column-wise linear addressing
    .label erow = 2
    //  Copy the LOGO to the CHARSET
    .label logo_dest = 6
    .label logo_src = 4
    // main::SEI1
    // asm
    // asm { sei  }
    sei
    // [2] phi from main::SEI1 to main::@11 [phi:main::SEI1->main::@11]
    // main::@11
    // memoryRemap(0,0,0)
    // [3] call memoryRemap 
    // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    jsr memoryRemap
    // main::@12
    // VICIV->CONTROLB |= 0x40
    // [4] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable 48MHz fast mode
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // VICIV->CONTROLC |= 0x40
    // [5] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // VICIV->KEY = 0x47
    // [6] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $47 -- _deref_pbuc1=vbuc2 
    // Enable the VIC 4
    lda #$47
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY
    // VICIV->KEY = 0x53
    // [7] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY) = $53 -- _deref_pbuc1=vbuc2 
    lda #$53
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_KEY
    // VICIV->SIDBDRWD_LO = 0
    // [8] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 0 -- _deref_pbuc1=vbuc2 
    // Set sideborder width=0, disable raster delay and hot registers
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO
    // VICIV->SIDBDRWD_HI = 0
    // [9] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI) = 0 -- _deref_pbuc1=vbuc2 
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_HI
    // VICIV->TBDRPOS_LO = 0
    // [10] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO) = 0 -- _deref_pbuc1=vbuc2 
    // Disable top/bottom borders
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_LO
    // VICIV->TBDRPOS_HI = 0
    // [11] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI) = 0 -- _deref_pbuc1=vbuc2 
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TBDRPOS_HI
    // VICIV->BBDRPOS_LO = 0
    // [12] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO) = 0 -- _deref_pbuc1=vbuc2 
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_LO
    // VICIV->BBDRPOS_HI = 2
    // [13] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI) = 2 -- _deref_pbuc1=vbuc2 
    lda #2
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_BBDRPOS_HI
    // VICIV->CONTROLC |= 1
    // [14] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | 1 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable Super Extended Attribute Mode
    lda #1
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // VICIV->CONTROLB &= 0x7f
    // [15] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Mode 40x25 chars - will be 45*25 when utilizing the borders
    lda #$7f
    and VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // VICIV->CHARSTEP_LO = 90
    // [16] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO) = $5a -- _deref_pbuc1=vbuc2 
    lda #$5a
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_LO
    // VICIV->CHARSTEP_HI = 0
    // [17] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARSTEP_HI
    // VICIV->TEXTXPOS_LO = 40
    // [18] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) = $28 -- _deref_pbuc1=vbuc2 
    // Start text in the left border
    lda #$28
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // VICIV->TEXTXPOS_HI = 0
    // [19] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_HI
    // VICIV->CHRCOUNT = 45
    // [20] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT) = $2d -- _deref_pbuc1=vbuc2 
    // Set number of characters to display per row
    lda #$2d
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRCOUNT
    // VICIV->SCRNPTR_LOLO = BYTE0(SCREEN)
    // [21] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO) = 0 -- _deref_pbuc1=vbuc2 
    // Set exact screen address
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOLO
    // VICIV->SCRNPTR_LOHI = BYTE1(SCREEN)
    // [22] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI) = byte1 SCREEN -- _deref_pbuc1=vbuc2 
    lda #>SCREEN
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_LOHI
    // VICIV->SCRNPTR_HILO = 0
    // [23] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HILO
    // VICIV->SCRNPTR_HIHI = 0
    // [24] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI) = 0 -- _deref_pbuc1=vbuc2 
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SCRNPTR_HIHI
    // VICIV->CHARPTR_LOLO = BYTE0(CHARSET)
    // [25] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO) = 0 -- _deref_pbuc1=vbuc2 
    // Set exact charset address
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOLO
    // VICIV->CHARPTR_LOHI = BYTE1(CHARSET)
    // [26] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI) = byte1 CHARSET -- _deref_pbuc1=vbuc2 
    lda #>CHARSET
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_LOHI
    // VICIV->CHARPTR_HILO = 0
    // [27] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHARPTR_HILO
    // memset_dma(SCREEN, 0, 45*25*2)
    // [28] call memset_dma 
  // Fill the screen with 0
    // [60] phi from main::@12 to memset_dma [phi:main::@12->memset_dma]
    // [60] phi memset_dma::dest#2 = (void*)SCREEN [phi:main::@12->memset_dma#0] -- pvoz1=pvoc1 
    lda #<SCREEN
    sta.z memset_dma.dest
    lda #>SCREEN
    sta.z memset_dma.dest+1
    // [60] phi memset_dma::fill#2 = 0 [phi:main::@12->memset_dma#1] -- vbuzz=vbuc1 
    ldz #0
    // [60] phi memset_dma::num#2 = (word)$2d*$19*2 [phi:main::@12->memset_dma#2] -- vwuz1=vwuc1 
    lda #<$2d*$19*2
    sta.z memset_dma.num
    lda #>$2d*$19*2
    sta.z memset_dma.num+1
    jsr memset_dma
    // [29] phi from main::@12 to main::@13 [phi:main::@12->main::@13]
    // main::@13
    // memset_dma256(0xff,0x08,(void*)0x0000, WHITE, 45*25*2)
    // [30] call memset_dma256 
    // Fill the colours with WHITE - directly into $ff80000
    jsr memset_dma256
    // [31] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
    // main::@14
    // memset_dma(CHARSET, 0x55, 45*32*8)
    // [32] call memset_dma 
  // Fill the charset with 0x55
    // [60] phi from main::@14 to memset_dma [phi:main::@14->memset_dma]
    // [60] phi memset_dma::dest#2 = (void*)CHARSET [phi:main::@14->memset_dma#0] -- pvoz1=pvoc1 
    lda #<CHARSET
    sta.z memset_dma.dest
    lda #>CHARSET
    sta.z memset_dma.dest+1
    // [60] phi memset_dma::fill#2 = $55 [phi:main::@14->memset_dma#1] -- vbuzz=vbuc1 
    ldz #$55
    // [60] phi memset_dma::num#2 = (word)$2d*$20*8 [phi:main::@14->memset_dma#2] -- vwuz1=vwuc1 
    lda #<$2d*$20*8
    sta.z memset_dma.num
    lda #>$2d*$20*8
    sta.z memset_dma.num+1
    jsr memset_dma
    // [33] phi from main::@14 to main::@1 [phi:main::@14->main::@1]
    // [33] phi main::erow#5 = SCREEN [phi:main::@14->main::@1#0] -- pwuz1=pbuc1 
    lda #<SCREEN
    sta.z erow
    lda #>SCREEN
    sta.z erow+1
    // [33] phi main::r#2 = 0 [phi:main::@14->main::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // main::@1
  __b1:
    // for(char r=0; r<25; r++)
    // [34] if(main::r#2<$19) goto main::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$19
    bcc __b2
    // [35] phi from main::@1 to main::@6 [phi:main::@1->main::@6]
    // [35] phi main::logo_dest#5 = CHARSET [phi:main::@1->main::@6#0] -- pbuz1=pbuc1 
    lda #<CHARSET
    sta.z logo_dest
    lda #>CHARSET
    sta.z logo_dest+1
    // [35] phi main::logo_src#5 = LOGO [phi:main::@1->main::@6#1] -- pbuz1=pbuc1 
    lda #<LOGO
    sta.z logo_src
    lda #>LOGO
    sta.z logo_src+1
    // [35] phi main::col#2 = 0 [phi:main::@1->main::@6#2] -- vbuxx=vbuc1 
    ldx #0
    // main::@6
  __b6:
    // for(char col=0;col<45;col++)
    // [36] if(main::col#2<$2d) goto main::@7 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$2d
    bcc __b5
    // main::@10
  __b10:
    // VICIV->BG_COLOR = VICII->RASTER
    // [37] *((byte*)VICIV+OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR) = *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) -- _deref_pbuc1=_deref_pbuc2 
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_BG_COLOR
    jmp __b10
    // [38] phi from main::@6 to main::@7 [phi:main::@6->main::@7]
  __b5:
    // [38] phi main::y#2 = 0 [phi:main::@6->main::@7#0] -- vbuyy=vbuc1 
    ldy #0
    // main::@7
  __b7:
    // for(char y=0;y<25*8;y++)
    // [39] if(main::y#2<$19*8) goto main::@8 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$19*8
    bcc __b8
    // main::@9
    // logo_dest += 32*8
    // [40] main::logo_dest#1 = main::logo_dest#5 + (word)$20*8 -- pbuz1=pbuz1_plus_vwuc1 
    clc
    lda.z logo_dest
    adc #<$20*8
    sta.z logo_dest
    lda.z logo_dest+1
    adc #>$20*8
    sta.z logo_dest+1
    // logo_src += 25*8
    // [41] main::logo_src#1 = main::logo_src#5 + $19*8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$19*8
    clc
    adc.z logo_src
    sta.z logo_src
    bcc !+
    inc.z logo_src+1
  !:
    // for(char col=0;col<45;col++)
    // [42] main::col#1 = ++ main::col#2 -- vbuxx=_inc_vbuxx 
    inx
    // [35] phi from main::@9 to main::@6 [phi:main::@9->main::@6]
    // [35] phi main::logo_dest#5 = main::logo_dest#1 [phi:main::@9->main::@6#0] -- register_copy 
    // [35] phi main::logo_src#5 = main::logo_src#1 [phi:main::@9->main::@6#1] -- register_copy 
    // [35] phi main::col#2 = main::col#1 [phi:main::@9->main::@6#2] -- register_copy 
    jmp __b6
    // main::@8
  __b8:
    // logo_dest[y] = logo_src[y]
    // [43] main::logo_dest#5[main::y#2] = main::logo_src#5[main::y#2] -- pbuz1_derefidx_vbuyy=pbuz2_derefidx_vbuyy 
    lda (logo_src),y
    sta (logo_dest),y
    // for(char y=0;y<25*8;y++)
    // [44] main::y#1 = ++ main::y#2 -- vbuyy=_inc_vbuyy 
    iny
    // [38] phi from main::@8 to main::@7 [phi:main::@8->main::@7]
    // [38] phi main::y#2 = main::y#1 [phi:main::@8->main::@7#0] -- register_copy 
    jmp __b7
    // main::@2
  __b2:
    // unsigned int c = r
    // [45] main::c#0 = (word)main::r#2 -- vwuz1=_word_vbuxx 
    txa
    sta.z c
    lda #0
    sta.z c+1
    // [46] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // [46] phi main::c#2 = main::c#0 [phi:main::@2->main::@3#0] -- register_copy 
    // [46] phi main::i#2 = 0 [phi:main::@2->main::@3#1] -- vbuzz=vbuc1 
    ldz #0
    // main::@3
  __b3:
    // for(char i=0; i<45; i++)
    // [47] if(main::i#2<$2d) goto main::@4 -- vbuzz_lt_vbuc1_then_la1 
    cpz #$2d
    bcc __b4
    // main::@5
    // erow += 45
    // [48] main::erow#1 = main::erow#5 + $2d*SIZEOF_WORD -- pwuz1=pwuz1_plus_vbuc1 
    lda #$2d*SIZEOF_WORD
    clc
    adc.z erow
    sta.z erow
    bcc !+
    inc.z erow+1
  !:
    // for(char r=0; r<25; r++)
    // [49] main::r#1 = ++ main::r#2 -- vbuxx=_inc_vbuxx 
    inx
    // [33] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
    // [33] phi main::erow#5 = main::erow#1 [phi:main::@5->main::@1#0] -- register_copy 
    // [33] phi main::r#2 = main::r#1 [phi:main::@5->main::@1#1] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // erow[i] = c
    // [50] main::$10 = main::i#2 << 1 -- vbuaa=vbuzz_rol_1 
    tza
    asl
    // [51] main::erow#5[main::$10] = main::c#2 -- pwuz1_derefidx_vbuaa=vwuz2 
    tay
    lda.z c
    sta (erow),y
    iny
    lda.z c+1
    sta (erow),y
    // c += 32
    // [52] main::c#1 = main::c#2 + $20 -- vwuz1=vwuz1_plus_vbuc1 
    lda #$20
    clc
    adc.z c
    sta.z c
    bcc !+
    inc.z c+1
  !:
    // for(char i=0; i<45; i++)
    // [53] main::i#1 = ++ main::i#2 -- vbuzz=_inc_vbuzz 
    inz
    // [46] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
    // [46] phi main::c#2 = main::c#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [46] phi main::i#2 = main::i#1 [phi:main::@4->main::@3#1] -- register_copy 
    jmp __b3
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
memoryRemap: {
    .label aVal = $e
    .label xVal = $f
    .label yVal = $10
    .label zVal = $11
    // char aVal = BYTE0(lowerPageOffset)
    // [54] memoryRemap::aVal = 0 -- vbuz1=vbuc1 
    // lower blocks offset page low
    lda #0
    sta.z aVal
    // char xVal = (remapBlocks << 4)   | (BYTE1(lowerPageOffset) & 0xf)
    // [55] memoryRemap::xVal = 0 -- vbuz1=vbuc1 
    // lower blocks to map + lower blocks offset high nibble
    sta.z xVal
    // char yVal = BYTE0(upperPageOffset)
    // [56] memoryRemap::yVal = 0 -- vbuz1=vbuc1 
    // upper blocks offset page
    sta.z yVal
    // char zVal = (remapBlocks & 0xf0) | (BYTE1(upperPageOffset) & 0xf)
    // [57] memoryRemap::zVal = 0 -- vbuz1=vbuc1 
    // upper blocks to map + upper blocks offset page high nibble
    sta.z zVal
    // asm
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap::@return
    // }
    // [59] return 
    rts
}
  // memset_dma
// Fill a memory block within the first 64K memory space using MEGA65 DMagic DMA
// Fills the values of num bytes at the destination with a single byte value.
// - dest The destination address (within the MB and bank)
// - fill The char to fill with
// - num The number of bytes to copy
// memset_dma(void* zp($c) dest, byte register(Z) fill, word zp($a) num)
memset_dma: {
    .label num = $a
    .label dest = $c
    // char dmaMode = DMA->EN018B
    // [61] memset_dma::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memset_dma_command.count = num
    // [62] *((word*)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma::num#2 -- _deref_pwuc1=vwuz1 
    // Set up command
    lda.z num
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda.z num+1
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // memset_dma_command.src = (char*)fill
    // [63] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)memset_dma::fill#2 -- _deref_qbuc1=_ptr_vbuzz 
    tza
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #0
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // memset_dma_command.dest = dest
    // [64] *((byte**)&memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma::dest#2 -- _deref_qbuc1=pbuz1 
    lda.z dest
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda.z dest+1
    sta memset_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // DMA->EN018B = 1
    // [65] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // DMA->ADDRMB = 0
    // [66] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // DMA->ADDRBANK = 0
    // [67] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // DMA-> ADDRMSB = BYTE1(&memset_dma_command)
    // [68] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memset_dma_command -- _deref_pbuc1=vbuc2 
    lda #>memset_dma_command
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // DMA-> ADDRLSBTRIG = BYTE0(&memset_dma_command)
    // [69] *((byte*)DMA) = byte0 &memset_dma_command -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<memset_dma_command
    sta DMA
    // DMA->EN018B = dmaMode
    // [70] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memset_dma::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memset_dma::@return
    // }
    // [71] return 
    rts
}
  // memset_dma256
// Set a memory block anywhere in the entire 256MB memory space using MEGA65 DMagic DMA
// Sets the values of num bytes to the memory block pointed to by destination.
// - dest_mb The MB value for the destination (0-255)
// - dest_bank The 64KB bank for the destination (0-15)
// - dest The destination address (within the MB and bank)
// - num The number of bytes to copy
memset_dma256: {
    .const dest_mb = $ff
    .const dest_bank = 8
    .const num = $2d*$19*2
    .label dest = 0
    .label f018b = memset_dma_command256+4
    // char dmaMode = DMA->EN018B
    // [72] memset_dma256::dmaMode#0 = *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memset_dma_command256[1] = dest_mb
    // [73] *(memset_dma_command256+1) = memset_dma256::dest_mb#0 -- _deref_pbuc1=vbuc2 
    // Set up command
    lda #dest_mb
    sta memset_dma_command256+1
    // f018b->count = num
    // [74] *((word*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memset_dma256::num#0 -- _deref_pwuc1=vwuc2 
    lda #<num
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // f018b->dest_bank = dest_bank
    // [75] *((byte*)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memset_dma256::dest_bank#0 -- _deref_pbuc1=vbuc2 
    lda #dest_bank
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
    // f018b->dest = dest
    // [76] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (byte*)memset_dma256::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // f018b->src = (char*)fill
    // [77] *((byte**)memset_dma256::f018b#0+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (byte*)WHITE -- _deref_qbuc1=pbuc2 
    // Set fill byte
    lda #<WHITE
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>WHITE
    sta f018b+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // DMA->EN018B = 1
    // [78] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // DMA->ADDRMB = 0
    // [79] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // DMA->ADDRBANK = 0
    // [80] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // DMA-> ADDRMSB = BYTE1(memset_dma_command256)
    // [81] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 memset_dma_command256 -- _deref_pbuc1=vbuc2 
    lda #>memset_dma_command256
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // DMA-> ETRIG = BYTE0(memset_dma_command256)
    // [82] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG) = byte0 memset_dma_command256 -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (with option lists)
    lda #<memset_dma_command256
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ETRIG
    // DMA->EN018B = dmaMode
    // [83] *((byte*)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memset_dma256::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memset_dma256::@return
    // }
    // [84] return 
    rts
}
  // File Data
.segment Data
  // DMA list entry with options for setting data in the 256MB memory space
  // Contains DMA options options for setting MB followed by DMA_LIST_F018B struct.
  memset_dma_command256: .byte DMA_OPTION_DEST_MB, 0, DMA_OPTION_FORMAT_F018B, DMA_OPTION_END, DMA_COMMAND_FILL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  // A logo in column-wide linear single-color memory layout
LOGO:
.var pic = LoadPicture("camelot.png", List().add($ffffff, $000000))
	.for (var x=0;x<45; x++)
    	.for (var y=0; y<25*8; y++)
            .byte pic.getSinglecolorByte(x,y)

  // DMA list entry for filling data
  memset_dma_command: .byte DMA_COMMAND_FILL
  .word 0, 0
  .byte 0
  .word 0
  .byte 0, 0
  .word 0

