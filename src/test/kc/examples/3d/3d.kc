// 3D Rotation using a Rotation Matrix
// Based on: 
// - C= Hacking Magazine Issue 8. http://www.ffd2.com/fridge/chacking/c=hacking8.txt
// - Codebase64 Article http://codebase64.org/doku.php?id=base:3d_rotation  
import "c64"

// The rotated point - updated by calling rotate_matrix()
signed byte* xr = $f0;
signed byte* yr = $f1;
signed byte* zr = $f2;

// The rotated point with perspective
signed byte* xp = $f3;
signed byte* yp = $f4;

// Pointers used to multiply perspective (d/z0-z) onto x- & y-coordinates. Points into mulf_sqr1 / mulf_sqr2  
word* psp1 = $f5;
word* psp2 = $f7;

void main() {
	asm { sei }
	sprites_init();
	mulf_init();
	*psp1 = (word)mulf_sqr1;
	*psp2 = (word)mulf_sqr2;
	anim();
}

// Positions to rotate (a cube)
signed byte[8] xs = { -63, -63, -63, -63,  63,  63,  63,  63};
signed byte[8] ys = { -63, -63,  63,  63, -63, -63,  63,  63};
signed byte[8] zs = { -63,  63, -63,  63, -63,  63, -63,  63};

void anim() {
	signed byte sx = 0;
	signed byte sy = 0;
	signed byte sz = 0;
	//signed byte xmin = 0;
	//signed byte xmax = 0;
	while(true) {
		while(*RASTER!=$ff) {}
        (*BORDERCOL)++; 
    	calculate_matrix(sx,sy,sz);
    	store_matrix();
        for(byte i: 0..7) {
            (*BORDERCOL)++;
            rotate_matrix(xs[i], ys[i], zs[i]);
            //if(*xr<xmin) xmin = *xr;
            //if(*xr>xmax) xmax = *xr;
            byte i2 = i<<1;
       	    SPRITES_XPOS[i2] = $80+(byte)(*xp);
       	    SPRITES_YPOS[i2] = $80+(byte)(*yp);
    	}
        // Increment angles
    	sz++;
    	sy--;
    	if((sy&1)==0) sx++;
        *BORDERCOL = LIGHT_BLUE;
	}	
}

// Initialize sprites
void sprites_init() {
	byte* SCREEN = $400;
    *SPRITES_ENABLE = %11111111;
    byte* sprites_ptr = SCREEN+$3f8;
    for(byte i: 0..7) {
    	sprites_ptr[i] = (byte)(SPRITE/$40);
        SPRITES_COLS[i] = GREEN;
    }
}

// The rotation matrix
signed byte[9] rotation_matrix;

// Prepare the 3x3 rotation matrix into rotation_matrix[]
// Angles sx, sy, sz are based on 2*PI=$100 
// Method described in C= Hacking Magazine Issue 8. http://www.ffd2.com/fridge/chacking/c=hacking8.txt
void calculate_matrix(signed byte sx, signed byte sy, signed byte sz) {
	signed byte t1 = sy-sz;
	signed byte t2 = sy+sz;
	signed byte t3 = sx+sz;
	signed byte t4 = sx-sz;
	signed byte t5 = sx+t2; // = sx+sy+sz
	signed byte t6 = sx-t1; // = sx-sy+sz
	signed byte t7 = sx+t1; // = sx+sy-sz
	signed byte t8 = t2-sx; //  = sy+sz-sx
	signed byte t9 = sy-sx;
	signed byte t10 = sy+sx;
	rotation_matrix[0] = COSH[t1]+COSH[t2];
	rotation_matrix[1] = SINH[t1]-SINH[t2];
	rotation_matrix[2] = SINH[sy]+SINH[sy];
	rotation_matrix[3] = SINH[t3]-SINH[t4] + COSQ[t6]-COSQ[t5]+COSQ[t8]-COSQ[t7];
	rotation_matrix[4] = COSH[t3]+COSH[t4] + SINQ[t5]-SINQ[t6]-SINQ[t7]-SINQ[t8];
	rotation_matrix[5] = SINH[t9]-SINH[t10];
	rotation_matrix[6] = COSH[t4]-COSH[t3] + SINQ[t6]-SINQ[t5]-SINQ[t8]-SINQ[t7];
	rotation_matrix[7] = SINH[t3]+SINH[t4] + COSQ[t6]-COSQ[t5]+COSQ[t7]-COSQ[t8];
	rotation_matrix[8] = COSH[t9]+COSH[t10];
}

// Store the rotation matrix into the rotation routine rotate()
// After this each call to rotate() will rotate a point with the matrix
// Implemented in assembler to utilize seriously fast multiplication 
void store_matrix() {
	asm {
		lda rotation_matrix+0
		sta rotate_matrix.A1+1
		eor #$ff
		sta rotate_matrix.A2+1
		lda rotation_matrix+1
		sta rotate_matrix.B1+1
		eor #$ff
		sta rotate_matrix.B2+1
		lda rotation_matrix+2
		sta rotate_matrix.C1+1
		eor #$ff
		sta rotate_matrix.C2+1
		lda rotation_matrix+3
		sta rotate_matrix.D1+1
		eor #$ff
		sta rotate_matrix.D2+1
		lda rotation_matrix+4
		sta rotate_matrix.E1+1
		eor #$ff
		sta rotate_matrix.E2+1
		lda rotation_matrix+5
		sta rotate_matrix.F1+1
		eor #$ff
		sta rotate_matrix.F2+1
		lda rotation_matrix+6
		sta rotate_matrix.G1+1
		eor #$ff
		sta rotate_matrix.G2+1
		lda rotation_matrix+7
		sta rotate_matrix.H1+1
		eor #$ff
		sta rotate_matrix.H2+1
		lda rotation_matrix+8
		sta rotate_matrix.I1+1
		eor #$ff
		sta rotate_matrix.I2+1
	}	
}

// Rotate a 3D point (x,y,z) using the rotation matrix
// The rotation matrix is prepared by calling prepare_matrix() 
// The passed points must be in the interval [-$3f;$3f].
// Implemented in assembler to utilize seriously fast multiplication 
void rotate_matrix(signed byte x, signed byte y, signed byte z) {
	*xr = x;
	*yr = y;
	*zr = z;
	asm {
			clc
			ldx zr //z
			// C*z 
		C1:	lda mulf_sqr1,x
		C2: sbc mulf_sqr2,x
			sta C3+1
			// F*z 
		F1:	lda mulf_sqr1,x
		F2: sbc mulf_sqr2,x
			sta F3+1
			// I*z 
		I1:	lda mulf_sqr1,x
		I2: sbc mulf_sqr2,x
			sta I3+1

			ldx xr //x
			ldy yr //y

		I3: lda #0 // I*z
		G1:	adc mulf_sqr1,x
		G2: sbc mulf_sqr2,x
		H1:	adc mulf_sqr1,y
		H2: sbc mulf_sqr2,y
			sta zr

			sta PP+1
		PP: lda PERSP_Z
			sta psp1
			eor #$ff
			sta psp2 			

		C3: lda #0 // C*z
		A1:	adc mulf_sqr1,x
		A2: sbc mulf_sqr2,x
		B1:	adc mulf_sqr1,y
		B2: sbc mulf_sqr2,y
			sta xr
			// divide x by 2 to get x below $3f for multiplication
			cmp #$80
			ror
			sta XX+1
			clc

		F3: lda #0 // F*z
		D1:	adc mulf_sqr1,x
		D2: sbc mulf_sqr2,x
		E1:	adc mulf_sqr1,y
		E2: sbc mulf_sqr2,y
			sta yr


			// Calculate perspective for Y-position
			// divide y by 2 to get x below $3f for multiplication
			cmp #$80
			ror
			clc
			tay
			lda (psp1),y
			sbc (psp2),y
			sta yp

			// Calculate perspective for X-position
		XX:	ldy #0
			lda (psp1),y
			sbc (psp2),y
			sta xp
	}
}

// Multiplication tables for seriously fast multiplication. 
// This version is optimized for speed over accuracy
// - It can multiply signed numbers with no extra code - but only for numbers in [-$3f;$3f]  
// - It throws away the low part of the 32-bit result
// - It return >a*b*4 to maximize precision (when passed maximal input values $3f*$3f the result is $3e) 
// See the following for information about the method
// - http://codebase64.org/doku.php?id=base:seriously_fast_multiplication 
// - http://codebase64.org/doku.php?id=magazines:chacking16
// mulf_sqr tables will contain f(x)=int(x*x) and g(x) = f(1-x).
// f(x) = >(( x * x ))
byte[512] align($100) mulf_sqr1;
// g(x) =  >((( 1 - x ) * ( 1 - x )))
byte[512] align($100) mulf_sqr2;

// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x) and g(x) = f(1-x) 
void mulf_init() {
	signed word sqr = 0;	
	signed word add = 1;
	for( byte i:0..128) {
		byte val = >sqr;
		mulf_sqr1[i] = val;
		(mulf_sqr1+$100)[i] = val;
		mulf_sqr1[-i] = val;
		(mulf_sqr1+$100)[-i] = val;
		mulf_sqr2[i+1] = val;
		(mulf_sqr2+$100)[i+1] = val;
		mulf_sqr2[1-i] = val;
		(mulf_sqr2+$100)[1-i] = val;
		sqr += add;
		add +=2;
	}
}


// A single sprite
byte* SPRITE = $3000;
kickasm(pc SPRITE, resource "balloon.png") {{
    .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
}}

// Perspective multiplication table containing (d/(z0-z)[z] for each z-value   
signed byte* PERSP_Z = $2400;

kickasm(pc PERSP_Z) {{
    {
    .var d = 256.0	
    .var z0 = 6.0	
    // These values of d/z0 result in table values from $20 to $40 (effectively max is $3f)
    .for(var z=0;z<$100;z++) {
    	.if(z>127) {
    		.byte round(d / (z0 - ((z - 256) / 64.0)));
    	} else {
    		.byte round(d / (z0 - (z / 64.0)));
    	}
    }
	}
}}

// Sine and Cosine Tables   
// Angles: $00=0, $80=PI,$100=2*PI
// Half Sine/Cosine: signed fixed [-$1f,$1f]
signed byte* COSH = $2000;
signed byte* SINH = COSH+$40; // sin(x) = cos(x+PI/2)
// Quarter Sine/Cosine: signed fixed [-$0f,$0f]
signed byte* COSQ = $2200;
signed byte* SINQ = COSQ+$40; // sin(x) = cos(x+PI/2)
kickasm(pc COSH) {{
    {
    .var min = -$1fff
    .var max = $1fff
    .var ampl = max-min;
    .for(var i=0;i<$140;i++) {
        .var rad = i*2*PI/256;
        .byte >round(min+(ampl/2)+(ampl/2)*cos(rad))
    }
    }
}}
kickasm(pc COSQ) {{
    {
    .var min = -$0fff
    .var max = $0fff
    .var ampl = max-min;
    .for(var i=0;i<$140;i++) {
        .var rad = i*2*PI/256;
        .byte >round(min+(ampl/2)+(ampl/2)*cos(rad))
    }
    }
}}

