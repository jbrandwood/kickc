Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@1

(void()) keyboard_init()
keyboard_init: scope:[keyboard_init]  from main::@3
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (number) $ff
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR) ← (number) 0
  to:keyboard_init::@return
keyboard_init::@return: scope:[keyboard_init]  from keyboard_init
  return 
  to:@return

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed main::@7
  (byte) keyboard_matrix_read::rowid#2 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::rowid#0 main::@7/(byte) keyboard_matrix_read::rowid#1 )
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2)
  (byte~) keyboard_matrix_read::$0 ← ~ *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B)
  (byte) keyboard_matrix_read::row_pressed_bits#0 ← (byte~) keyboard_matrix_read::$0
  (byte) keyboard_matrix_read::return#0 ← (byte) keyboard_matrix_read::row_pressed_bits#0
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  (byte) keyboard_matrix_read::return#4 ← phi( keyboard_matrix_read/(byte) keyboard_matrix_read::return#0 )
  (byte) keyboard_matrix_read::return#1 ← (byte) keyboard_matrix_read::return#4
  return 
  to:@return

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from main::@16
  (byte) keyboard_key_pressed::key#1 ← phi( main::@16/(byte) keyboard_key_pressed::key#0 )
  (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (number) 7
  (byte) keyboard_key_pressed::colidx#0 ← (number~) keyboard_key_pressed::$0
  (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#1 >> (number) 3
  (byte) keyboard_key_pressed::rowidx#0 ← (byte~) keyboard_key_pressed::$1
  (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  call keyboard_matrix_read 
  (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#1
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  (byte) keyboard_key_pressed::colidx#1 ← phi( keyboard_key_pressed/(byte) keyboard_key_pressed::colidx#0 )
  (byte) keyboard_matrix_read::return#5 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::return#2 )
  (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#5
  (byte~) keyboard_key_pressed::$3 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#1)
  (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$3
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  (byte) keyboard_key_pressed::return#3 ← phi( keyboard_key_pressed::@1/(byte) keyboard_key_pressed::return#0 )
  (byte) keyboard_key_pressed::return#1 ← (byte) keyboard_key_pressed::return#3
  return 
  to:@return

(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
keyboard_get_keycode: scope:[keyboard_get_keycode]  from main::@14
  (byte) keyboard_get_keycode::ch#1 ← phi( main::@14/(byte) keyboard_get_keycode::ch#0 )
  (byte) keyboard_get_keycode::return#0 ← *((const to_nomodify byte*) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#1)
  to:keyboard_get_keycode::@return
keyboard_get_keycode::@return: scope:[keyboard_get_keycode]  from keyboard_get_keycode
  (byte) keyboard_get_keycode::return#3 ← phi( keyboard_get_keycode/(byte) keyboard_get_keycode::return#0 )
  (byte) keyboard_get_keycode::return#1 ← (byte) keyboard_get_keycode::return#3
  return 
  to:@return

(void()) main()
main: scope:[main]  from @1
  (byte*) main::sc#0 ← (byte*)(number) $400
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte*) main::sc#2 ← phi( main/(byte*) main::sc#0 main::@2/(byte*) main::sc#1 )
  (bool~) main::$1 ← (byte*) main::sc#2 < (number) $400+(number) $3e8
  if((bool~) main::$1) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  (byte*) main::sc#3 ← phi( main::@1/(byte*) main::sc#2 )
  *((byte*) main::sc#3) ← (byte) ' '
  (byte*) main::sc#1 ← ++ (byte*) main::sc#3
  to:main::@1
main::@3: scope:[main]  from main::@1
  call keyboard_init 
  to:main::@19
main::@19: scope:[main]  from main::@3
  to:main::@4
main::@4: scope:[main]  from main::@18 main::@19
  if(true) goto main::@5
  to:main::@return
main::@5: scope:[main]  from main::@4 main::@5
  (bool~) main::$2 ← *((const nomodify byte*) RASTER) != (number) $ff
  if((bool~) main::$2) goto main::@5
  to:main::@6
main::@6: scope:[main]  from main::@5
  (byte*) main::screen#0 ← (byte*)(number) $400
  (byte) main::row#0 ← (byte) 0
  to:main::@7
main::@7: scope:[main]  from main::@12 main::@6
  (byte*) main::screen#16 ← phi( main::@12/(byte*) main::screen#1 main::@6/(byte*) main::screen#0 )
  (byte) main::row#2 ← phi( main::@12/(byte) main::row#1 main::@6/(byte) main::row#0 )
  (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2
  call keyboard_matrix_read 
  (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#1
  to:main::@20
main::@20: scope:[main]  from main::@7
  (byte) main::row#8 ← phi( main::@7/(byte) main::row#2 )
  (byte*) main::screen#13 ← phi( main::@7/(byte*) main::screen#16 )
  (byte) keyboard_matrix_read::return#6 ← phi( main::@7/(byte) keyboard_matrix_read::return#3 )
  (byte~) main::$3 ← (byte) keyboard_matrix_read::return#6
  (byte) main::row_pressed_bits#0 ← (byte~) main::$3
  (byte) main::col#0 ← (byte) 0
  to:main::@8
main::@8: scope:[main]  from main::@10 main::@20
  (byte) main::row#7 ← phi( main::@10/(byte) main::row#4 main::@20/(byte) main::row#8 )
  (byte) main::col#5 ← phi( main::@10/(byte) main::col#1 main::@20/(byte) main::col#0 )
  (byte*) main::screen#9 ← phi( main::@10/(byte*) main::screen#10 main::@20/(byte*) main::screen#13 )
  (byte) main::row_pressed_bits#2 ← phi( main::@10/(byte) main::row_pressed_bits#1 main::@20/(byte) main::row_pressed_bits#0 )
  (number~) main::$4 ← (byte) main::row_pressed_bits#2 & (number) $80
  (bool~) main::$5 ← (number~) main::$4 != (number) 0
  if((bool~) main::$5) goto main::@9
  to:main::@11
main::@9: scope:[main]  from main::@8
  (byte) main::row#6 ← phi( main::@8/(byte) main::row#7 )
  (byte) main::row_pressed_bits#5 ← phi( main::@8/(byte) main::row_pressed_bits#2 )
  (byte) main::col#2 ← phi( main::@8/(byte) main::col#5 )
  (byte*) main::screen#3 ← phi( main::@8/(byte*) main::screen#9 )
  *((byte*) main::screen#3 + (byte) main::col#2) ← (byte) '1'
  to:main::@10
main::@11: scope:[main]  from main::@8
  (byte) main::row#5 ← phi( main::@8/(byte) main::row#7 )
  (byte) main::row_pressed_bits#4 ← phi( main::@8/(byte) main::row_pressed_bits#2 )
  (byte) main::col#3 ← phi( main::@8/(byte) main::col#5 )
  (byte*) main::screen#4 ← phi( main::@8/(byte*) main::screen#9 )
  *((byte*) main::screen#4 + (byte) main::col#3) ← (byte) '0'
  to:main::@10
main::@10: scope:[main]  from main::@11 main::@9
  (byte) main::row#4 ← phi( main::@11/(byte) main::row#5 main::@9/(byte) main::row#6 )
  (byte*) main::screen#10 ← phi( main::@11/(byte*) main::screen#4 main::@9/(byte*) main::screen#3 )
  (byte) main::col#4 ← phi( main::@11/(byte) main::col#3 main::@9/(byte) main::col#2 )
  (byte) main::row_pressed_bits#3 ← phi( main::@11/(byte) main::row_pressed_bits#4 main::@9/(byte) main::row_pressed_bits#5 )
  (number~) main::$6 ← (byte) main::row_pressed_bits#3 * (number) 2
  (byte) main::row_pressed_bits#1 ← (number~) main::$6
  (byte) main::col#1 ← (byte) main::col#4 + rangenext(0,7)
  (bool~) main::$7 ← (byte) main::col#1 != rangelast(0,7)
  if((bool~) main::$7) goto main::@8
  to:main::@12
main::@12: scope:[main]  from main::@10
  (byte) main::row#3 ← phi( main::@10/(byte) main::row#4 )
  (byte*) main::screen#5 ← phi( main::@10/(byte*) main::screen#10 )
  (byte*~) main::$8 ← (byte*) main::screen#5 + (number) $28
  (byte*) main::screen#1 ← (byte*~) main::$8
  (byte) main::row#1 ← (byte) main::row#3 + rangenext(0,7)
  (bool~) main::$9 ← (byte) main::row#1 != rangelast(0,7)
  if((bool~) main::$9) goto main::@7
  to:main::@13
main::@13: scope:[main]  from main::@12
  (byte*) main::screen#6 ← phi( main::@12/(byte*) main::screen#1 )
  (byte*~) main::$10 ← (byte*) main::screen#6 + (number) $28
  (byte*) main::screen#2 ← (byte*~) main::$10
  (byte) main::i#0 ← (byte) 0
  (byte) main::ch#0 ← (byte) 0
  to:main::@14
main::@14: scope:[main]  from main::@13 main::@15
  (byte) main::i#9 ← phi( main::@13/(byte) main::i#0 main::@15/(byte) main::i#6 )
  (byte*) main::screen#17 ← phi( main::@13/(byte*) main::screen#2 main::@15/(byte*) main::screen#12 )
  (byte) main::ch#2 ← phi( main::@13/(byte) main::ch#0 main::@15/(byte) main::ch#1 )
  (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2
  call keyboard_get_keycode 
  (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#1
  to:main::@21
main::@21: scope:[main]  from main::@14
  (byte) main::i#7 ← phi( main::@14/(byte) main::i#9 )
  (byte*) main::screen#14 ← phi( main::@14/(byte*) main::screen#17 )
  (byte) main::ch#5 ← phi( main::@14/(byte) main::ch#2 )
  (byte) keyboard_get_keycode::return#4 ← phi( main::@14/(byte) keyboard_get_keycode::return#2 )
  (byte~) main::$11 ← (byte) keyboard_get_keycode::return#4
  (byte) main::key#0 ← (byte~) main::$11
  (bool~) main::$12 ← (byte) main::key#0 != (number) $3f
  (bool~) main::$13 ← ! (bool~) main::$12
  if((bool~) main::$13) goto main::@15
  to:main::@16
main::@15: scope:[main]  from main::@17 main::@21 main::@22
  (byte) main::i#6 ← phi( main::@17/(byte) main::i#1 main::@21/(byte) main::i#7 main::@22/(byte) main::i#5 )
  (byte*) main::screen#12 ← phi( main::@17/(byte*) main::screen#7 main::@21/(byte*) main::screen#14 main::@22/(byte*) main::screen#11 )
  (byte) main::ch#3 ← phi( main::@17/(byte) main::ch#4 main::@21/(byte) main::ch#5 main::@22/(byte) main::ch#6 )
  (byte) main::ch#1 ← (byte) main::ch#3 + rangenext(0,$3f)
  (bool~) main::$17 ← (byte) main::ch#1 != rangelast(0,$3f)
  if((bool~) main::$17) goto main::@14
  to:main::@18
main::@16: scope:[main]  from main::@21
  (byte) main::i#8 ← phi( main::@21/(byte) main::i#7 )
  (byte*) main::screen#15 ← phi( main::@21/(byte*) main::screen#14 )
  (byte) main::ch#7 ← phi( main::@21/(byte) main::ch#5 )
  (byte) main::key#1 ← phi( main::@21/(byte) main::key#0 )
  (byte) keyboard_key_pressed::key#0 ← (byte) main::key#1
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#1
  to:main::@22
main::@22: scope:[main]  from main::@16
  (byte) main::i#5 ← phi( main::@16/(byte) main::i#8 )
  (byte*) main::screen#11 ← phi( main::@16/(byte*) main::screen#15 )
  (byte) main::ch#6 ← phi( main::@16/(byte) main::ch#7 )
  (byte) keyboard_key_pressed::return#4 ← phi( main::@16/(byte) keyboard_key_pressed::return#2 )
  (byte~) main::$14 ← (byte) keyboard_key_pressed::return#4
  (bool~) main::$15 ← (byte~) main::$14 != (number) 0
  (bool~) main::$16 ← ! (bool~) main::$15
  if((bool~) main::$16) goto main::@15
  to:main::@17
main::@17: scope:[main]  from main::@22
  (byte) main::i#3 ← phi( main::@22/(byte) main::i#5 )
  (byte*) main::screen#7 ← phi( main::@22/(byte*) main::screen#11 )
  (byte) main::ch#4 ← phi( main::@22/(byte) main::ch#6 )
  *((byte*) main::screen#7 + (byte) main::i#3) ← (byte) main::ch#4
  (byte) main::i#1 ← ++ (byte) main::i#3
  to:main::@15
main::@18: scope:[main]  from main::@15 main::@18
  (byte) main::i#4 ← phi( main::@15/(byte) main::i#6 main::@18/(byte) main::i#2 )
  (byte*) main::screen#8 ← phi( main::@15/(byte*) main::screen#12 main::@18/(byte*) main::screen#8 )
  *((byte*) main::screen#8 + (byte) main::i#4) ← (byte) ' '
  (byte) main::i#2 ← ++ (byte) main::i#4
  (bool~) main::$18 ← (byte) main::i#2 < (number) 5
  if((bool~) main::$18) goto main::@18
  to:main::@4
main::@return: scope:[main]  from main::@4
  return 
  to:@return
@1: scope:[]  from @begin
  call main 
  to:@2
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

SYMBOL TABLE SSA
(label) @1
(label) @2
(label) @begin
(label) @end
(const nomodify struct MOS6526_CIA*) CIA1 = (struct MOS6526_CIA*)(number) $dc00
(const nomodify byte) KEY_0 = (byte) $23
(const nomodify byte) KEY_1 = (byte) $38
(const nomodify byte) KEY_2 = (byte) $3b
(const nomodify byte) KEY_3 = (byte) 8
(const nomodify byte) KEY_4 = (byte) $b
(const nomodify byte) KEY_5 = (byte) $10
(const nomodify byte) KEY_6 = (byte) $13
(const nomodify byte) KEY_7 = (byte) $18
(const nomodify byte) KEY_8 = (byte) $1b
(const nomodify byte) KEY_9 = (byte) $20
(const nomodify byte) KEY_A = (byte) $a
(const nomodify byte) KEY_ARROW_LEFT = (byte) $39
(const nomodify byte) KEY_ARROW_UP = (byte) $36
(const nomodify byte) KEY_ASTERISK = (byte) $31
(const nomodify byte) KEY_AT = (byte) $2e
(const nomodify byte) KEY_B = (byte) $1c
(const nomodify byte) KEY_C = (byte) $14
(const nomodify byte) KEY_COLON = (byte) $2d
(const nomodify byte) KEY_COMMA = (byte) $2f
(const nomodify byte) KEY_D = (byte) $12
(const nomodify byte) KEY_DOT = (byte) $2c
(const nomodify byte) KEY_E = (byte) $e
(const nomodify byte) KEY_EQUALS = (byte) $35
(const nomodify byte) KEY_F = (byte) $15
(const nomodify byte) KEY_G = (byte) $1a
(const nomodify byte) KEY_H = (byte) $1d
(const nomodify byte) KEY_I = (byte) $21
(const nomodify byte) KEY_J = (byte) $22
(const nomodify byte) KEY_K = (byte) $25
(const nomodify byte) KEY_L = (byte) $2a
(const nomodify byte) KEY_M = (byte) $24
(const nomodify byte) KEY_MINUS = (byte) $2b
(const nomodify byte) KEY_N = (byte) $27
(const nomodify byte) KEY_O = (byte) $26
(const nomodify byte) KEY_P = (byte) $29
(const nomodify byte) KEY_PLUS = (byte) $28
(const nomodify byte) KEY_POUND = (byte) $30
(const nomodify byte) KEY_Q = (byte) $3e
(const nomodify byte) KEY_R = (byte) $11
(const nomodify byte) KEY_S = (byte) $d
(const nomodify byte) KEY_SEMICOLON = (byte) $32
(const nomodify byte) KEY_SLASH = (byte) $37
(const nomodify byte) KEY_SPACE = (byte) $3c
(const nomodify byte) KEY_T = (byte) $16
(const nomodify byte) KEY_U = (byte) $1e
(const nomodify byte) KEY_V = (byte) $1f
(const nomodify byte) KEY_W = (byte) 9
(const nomodify byte) KEY_X = (byte) $17
(const nomodify byte) KEY_Y = (byte) $19
(const nomodify byte) KEY_Z = (byte) $c
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A = (byte) 0
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = (byte) 2
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B = (byte) 1
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR = (byte) 3
(const nomodify byte*) RASTER = (byte*)(number) $d012
(const to_nomodify byte*) keyboard_char_keycodes[]  = { (const nomodify byte) KEY_AT, (const nomodify byte) KEY_A, (const nomodify byte) KEY_B, (const nomodify byte) KEY_C, (const nomodify byte) KEY_D, (const nomodify byte) KEY_E, (const nomodify byte) KEY_F, (const nomodify byte) KEY_G, (const nomodify byte) KEY_H, (const nomodify byte) KEY_I, (const nomodify byte) KEY_J, (const nomodify byte) KEY_K, (const nomodify byte) KEY_L, (const nomodify byte) KEY_M, (const nomodify byte) KEY_N, (const nomodify byte) KEY_O, (const nomodify byte) KEY_P, (const nomodify byte) KEY_Q, (const nomodify byte) KEY_R, (const nomodify byte) KEY_S, (const nomodify byte) KEY_T, (const nomodify byte) KEY_U, (const nomodify byte) KEY_V, (const nomodify byte) KEY_W, (const nomodify byte) KEY_X, (const nomodify byte) KEY_Y, (const nomodify byte) KEY_Z, (byte) $3f, (const nomodify byte) KEY_POUND, (byte) $3f, (const nomodify byte) KEY_ARROW_UP, (const nomodify byte) KEY_ARROW_LEFT, (const nomodify byte) KEY_SPACE, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (const nomodify byte) KEY_ASTERISK, (const nomodify byte) KEY_PLUS, (const nomodify byte) KEY_COMMA, (const nomodify byte) KEY_MINUS, (const nomodify byte) KEY_DOT, (const nomodify byte) KEY_SLASH, (const nomodify byte) KEY_0, (const nomodify byte) KEY_1, (const nomodify byte) KEY_2, (const nomodify byte) KEY_3, (const nomodify byte) KEY_4, (const nomodify byte) KEY_5, (const nomodify byte) KEY_6, (const nomodify byte) KEY_7, (const nomodify byte) KEY_8, (const nomodify byte) KEY_9, (const nomodify byte) KEY_COLON, (const nomodify byte) KEY_SEMICOLON, (byte) $3f, (const nomodify byte) KEY_EQUALS, (byte) $3f, (byte) $3f }
(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
(label) keyboard_get_keycode::@return
(byte) keyboard_get_keycode::ch
(byte) keyboard_get_keycode::ch#0
(byte) keyboard_get_keycode::ch#1
(byte) keyboard_get_keycode::return
(byte) keyboard_get_keycode::return#0
(byte) keyboard_get_keycode::return#1
(byte) keyboard_get_keycode::return#2
(byte) keyboard_get_keycode::return#3
(byte) keyboard_get_keycode::return#4
(void()) keyboard_init()
(label) keyboard_init::@return
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(number~) keyboard_key_pressed::$0
(byte~) keyboard_key_pressed::$1
(byte~) keyboard_key_pressed::$2
(byte~) keyboard_key_pressed::$3
(label) keyboard_key_pressed::@1
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0
(byte) keyboard_key_pressed::colidx#1
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0
(byte) keyboard_key_pressed::key#1
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0
(byte) keyboard_key_pressed::return#1
(byte) keyboard_key_pressed::return#2
(byte) keyboard_key_pressed::return#3
(byte) keyboard_key_pressed::return#4
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0
(const byte*) keyboard_matrix_col_bitmask[(number) 8]  = { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte~) keyboard_matrix_read::$0
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0
(byte) keyboard_matrix_read::return#1
(byte) keyboard_matrix_read::return#2
(byte) keyboard_matrix_read::return#3
(byte) keyboard_matrix_read::return#4
(byte) keyboard_matrix_read::return#5
(byte) keyboard_matrix_read::return#6
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::row_pressed_bits#0
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0
(byte) keyboard_matrix_read::rowid#1
(byte) keyboard_matrix_read::rowid#2
(const byte*) keyboard_matrix_row_bitmask[(number) 8]  = { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
(void()) main()
(bool~) main::$1
(byte*~) main::$10
(byte~) main::$11
(bool~) main::$12
(bool~) main::$13
(byte~) main::$14
(bool~) main::$15
(bool~) main::$16
(bool~) main::$17
(bool~) main::$18
(bool~) main::$2
(byte~) main::$3
(number~) main::$4
(bool~) main::$5
(number~) main::$6
(bool~) main::$7
(byte*~) main::$8
(bool~) main::$9
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@22
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return
(byte) main::ch
(byte) main::ch#0
(byte) main::ch#1
(byte) main::ch#2
(byte) main::ch#3
(byte) main::ch#4
(byte) main::ch#5
(byte) main::ch#6
(byte) main::ch#7
(byte) main::col
(byte) main::col#0
(byte) main::col#1
(byte) main::col#2
(byte) main::col#3
(byte) main::col#4
(byte) main::col#5
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte) main::i#3
(byte) main::i#4
(byte) main::i#5
(byte) main::i#6
(byte) main::i#7
(byte) main::i#8
(byte) main::i#9
(byte) main::key
(byte) main::key#0
(byte) main::key#1
(byte) main::row
(byte) main::row#0
(byte) main::row#1
(byte) main::row#2
(byte) main::row#3
(byte) main::row#4
(byte) main::row#5
(byte) main::row#6
(byte) main::row#7
(byte) main::row#8
(byte) main::row_pressed_bits
(byte) main::row_pressed_bits#0
(byte) main::row_pressed_bits#1
(byte) main::row_pressed_bits#2
(byte) main::row_pressed_bits#3
(byte) main::row_pressed_bits#4
(byte) main::row_pressed_bits#5
(byte*) main::sc
(byte*) main::sc#0
(byte*) main::sc#1
(byte*) main::sc#2
(byte*) main::sc#3
(byte*) main::screen
(byte*) main::screen#0
(byte*) main::screen#1
(byte*) main::screen#10
(byte*) main::screen#11
(byte*) main::screen#12
(byte*) main::screen#13
(byte*) main::screen#14
(byte*) main::screen#15
(byte*) main::screen#16
(byte*) main::screen#17
(byte*) main::screen#2
(byte*) main::screen#3
(byte*) main::screen#4
(byte*) main::screen#5
(byte*) main::screen#6
(byte*) main::screen#7
(byte*) main::screen#8
(byte*) main::screen#9

Adding number conversion cast (unumber) $ff in *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (number) $ff
Adding number conversion cast (unumber) 0 in *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR) ← (number) 0
Adding number conversion cast (unumber) 7 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (number) 7
Adding number conversion cast (unumber) keyboard_key_pressed::$0 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (unumber)(number) 7
Adding number conversion cast (unumber) 3 in (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#1 >> (number) 3
Adding number conversion cast (unumber) $400+$3e8 in (bool~) main::$1 ← (byte*) main::sc#2 < (number) $400+(number) $3e8
Adding number conversion cast (unumber) $ff in (bool~) main::$2 ← *((const nomodify byte*) RASTER) != (number) $ff
Adding number conversion cast (unumber) $80 in (number~) main::$4 ← (byte) main::row_pressed_bits#2 & (number) $80
Adding number conversion cast (unumber) main::$4 in (number~) main::$4 ← (byte) main::row_pressed_bits#2 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) main::$5 ← (unumber~) main::$4 != (number) 0
Adding number conversion cast (unumber) 2 in (number~) main::$6 ← (byte) main::row_pressed_bits#3 * (number) 2
Adding number conversion cast (unumber) main::$6 in (number~) main::$6 ← (byte) main::row_pressed_bits#3 * (unumber)(number) 2
Adding number conversion cast (unumber) $28 in (byte*~) main::$8 ← (byte*) main::screen#5 + (number) $28
Adding number conversion cast (unumber) $28 in (byte*~) main::$10 ← (byte*) main::screen#6 + (number) $28
Adding number conversion cast (unumber) $3f in (bool~) main::$12 ← (byte) main::key#0 != (number) $3f
Adding number conversion cast (unumber) 0 in (bool~) main::$15 ← (byte~) main::$14 != (number) 0
Adding number conversion cast (unumber) 5 in (bool~) main::$18 ← (byte) main::i#2 < (number) 5
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (unumber)(number) $ff
Inlining cast *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR) ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (struct MOS6526_CIA*) 56320
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 7
Simplifying constant integer cast 3
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $ff
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $28
Simplifying constant integer cast $28
Simplifying constant integer cast $3f
Simplifying constant integer cast 0
Simplifying constant integer cast 5
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $3f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 5
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#1 & (byte) 7
Inferred type updated to byte in (unumber~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80
Inferred type updated to byte in (unumber~) main::$6 ← (byte) main::row_pressed_bits#3 * (byte) 2
Inversing boolean not [85] (bool~) main::$13 ← (byte) main::key#0 == (byte) $3f from [84] (bool~) main::$12 ← (byte) main::key#0 != (byte) $3f
Inversing boolean not [98] (bool~) main::$16 ← (byte~) main::$14 == (byte) 0 from [97] (bool~) main::$15 ← (byte~) main::$14 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias keyboard_matrix_read::return#0 = keyboard_matrix_read::row_pressed_bits#0 keyboard_matrix_read::$0 keyboard_matrix_read::return#4 keyboard_matrix_read::return#1 
Alias keyboard_key_pressed::colidx#0 = keyboard_key_pressed::$0 keyboard_key_pressed::colidx#1 
Alias keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::$1 
Alias keyboard_matrix_read::return#2 = keyboard_matrix_read::return#5 
Alias keyboard_key_pressed::return#0 = keyboard_key_pressed::$3 keyboard_key_pressed::return#3 keyboard_key_pressed::return#1 
Alias keyboard_get_keycode::return#0 = keyboard_get_keycode::return#3 keyboard_get_keycode::return#1 
Alias main::sc#2 = main::sc#3 
Alias keyboard_matrix_read::return#3 = keyboard_matrix_read::return#6 
Alias main::screen#13 = main::screen#16 
Alias main::row#2 = main::row#8 
Alias main::row_pressed_bits#0 = main::$3 
Alias main::screen#3 = main::screen#9 main::screen#4 
Alias main::col#2 = main::col#5 main::col#3 
Alias main::row_pressed_bits#2 = main::row_pressed_bits#5 main::row_pressed_bits#4 
Alias main::row#5 = main::row#6 main::row#7 
Alias main::row_pressed_bits#1 = main::$6 
Alias main::screen#10 = main::screen#5 
Alias main::row#3 = main::row#4 
Alias main::screen#1 = main::$8 main::screen#6 
Alias main::screen#2 = main::$10 
Alias keyboard_get_keycode::return#2 = keyboard_get_keycode::return#4 
Alias main::ch#2 = main::ch#5 main::ch#7 main::ch#6 main::ch#4 
Alias main::screen#11 = main::screen#14 main::screen#17 main::screen#15 main::screen#7 
Alias main::i#3 = main::i#7 main::i#9 main::i#8 main::i#5 
Alias main::key#0 = main::$11 main::key#1 
Alias keyboard_key_pressed::return#2 = keyboard_key_pressed::return#4 
Successful SSA optimization Pass2AliasElimination
Alias main::row_pressed_bits#2 = main::row_pressed_bits#3 
Alias main::col#2 = main::col#4 
Alias main::screen#10 = main::screen#3 
Alias main::row#3 = main::row#5 
Alias main::ch#2 = main::ch#3 
Alias main::screen#11 = main::screen#12 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) keyboard_key_pressed::key#1 (byte) keyboard_key_pressed::key#0
Identical Phi Values (byte) keyboard_get_keycode::ch#1 (byte) keyboard_get_keycode::ch#0
Identical Phi Values (byte*) main::screen#10 (byte*) main::screen#13
Identical Phi Values (byte) main::row#3 (byte) main::row#2
Identical Phi Values (byte*) main::screen#11 (byte*) main::screen#2
Identical Phi Values (byte*) main::screen#8 (byte*) main::screen#11
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$1 [22] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2
Simple Condition (bool~) main::$2 [28] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto main::@5
Simple Condition (bool~) main::$5 [40] if((byte~) main::$4!=(byte) 0) goto main::@9
Simple Condition (bool~) main::$7 [46] if((byte) main::col#1!=rangelast(0,7)) goto main::@8
Simple Condition (bool~) main::$9 [50] if((byte) main::row#1!=rangelast(0,7)) goto main::@7
Simple Condition (bool~) main::$13 [60] if((byte) main::key#0==(byte) $3f) goto main::@15
Simple Condition (bool~) main::$17 [64] if((byte) main::ch#1!=rangelast(0,$3f)) goto main::@14
Simple Condition (bool~) main::$16 [70] if((byte~) main::$14==(byte) 0) goto main::@15
Simple Condition (bool~) main::$18 [77] if((byte) main::i#2<(byte) 5) goto main::@18
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) main::sc#0 = (byte*) 1024
Constant (const byte*) main::screen#0 = (byte*) 1024
Constant (const byte) main::row#0 = 0
Constant (const byte) main::col#0 = 0
Constant (const byte) main::i#0 = 0
Constant (const byte) main::ch#0 = 0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [26] if(true) goto main::@5
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [44] main::col#1 ← ++ main::col#2 to ++
Resolved ranged comparison value [46] if(main::col#1!=rangelast(0,7)) goto main::@8 to (number) 8
Resolved ranged next value [48] main::row#1 ← ++ main::row#2 to ++
Resolved ranged comparison value [50] if(main::row#1!=rangelast(0,7)) goto main::@7 to (number) 8
Resolved ranged next value [62] main::ch#1 ← ++ main::ch#2 to ++
Resolved ranged comparison value [64] if(main::ch#1!=rangelast(0,$3f)) goto main::@14 to (number) $40
Simplifying expression containing zero (byte*)CIA1 in [4] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2)
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 8 in if((byte) main::col#1!=(number) 8) goto main::@8
Adding number conversion cast (unumber) 8 in if((byte) main::row#1!=(number) 8) goto main::@7
Adding number conversion cast (unumber) $40 in if((byte) main::ch#1!=(number) $40) goto main::@14
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Simplifying constant integer cast 8
Simplifying constant integer cast $40
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $40
Successful SSA optimization PassNFinalizeNumberTypeConversions
Rewriting multiplication to use shift [33] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 * (byte) 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte*) main::sc#0
Inlining constant with var siblings (const byte*) main::screen#0
Inlining constant with var siblings (const byte) main::row#0
Inlining constant with var siblings (const byte) main::col#0
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with var siblings (const byte) main::ch#0
Constant inlined main::screen#0 = (byte*) 1024
Constant inlined main::col#0 = (byte) 0
Constant inlined main::i#0 = (byte) 0
Constant inlined main::sc#0 = (byte*) 1024
Constant inlined main::row#0 = (byte) 0
Constant inlined main::ch#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@23(between main::@12 and main::@7)
Added new block during phi lifting main::@24(between main::@10 and main::@8)
Added new block during phi lifting main::@25(between main::@15 and main::@14)
Added new block during phi lifting main::@26(between main::@21 and main::@15)
Added new block during phi lifting main::@27(between main::@22 and main::@15)
Added new block during phi lifting main::@28(between main::@15 and main::@18)
Added new block during phi lifting main::@29(between main::@18 and main::@18)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@19
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of main::@6
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to keyboard_init:9 keyboard_matrix_read:17 keyboard_get_keycode:34 keyboard_key_pressed:39 
Calls in [keyboard_key_pressed] to keyboard_matrix_read:71 

Created 10 initial phi equivalence classes
Coalesced [16] keyboard_matrix_read::rowid#4 ← keyboard_matrix_read::rowid#1
Coalesced [20] main::row_pressed_bits#7 ← main::row_pressed_bits#0
Coalesced [45] main::i#11 ← main::i#1
Coalesced [49] main::i#14 ← main::i#6
Coalesced [54] main::i#15 ← main::i#2
Coalesced [55] main::ch#8 ← main::ch#1
Coalesced [56] main::i#10 ← main::i#6
Coalesced (already) [57] main::i#13 ← main::i#3
Coalesced (already) [58] main::i#12 ← main::i#3
Coalesced [59] main::row#9 ← main::row#1
Coalesced [60] main::screen#18 ← main::screen#1
Coalesced [61] main::row_pressed_bits#6 ← main::row_pressed_bits#1
Coalesced [62] main::col#6 ← main::col#1
Coalesced [66] main::sc#4 ← main::sc#1
Coalesced [70] keyboard_matrix_read::rowid#3 ← keyboard_matrix_read::rowid#0
Coalesced down to 8 phi equivalence classes
Culled Empty Block (label) @2
Culled Empty Block (label) main::@19
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@6
Culled Empty Block (label) main::@28
Culled Empty Block (label) main::@29
Culled Empty Block (label) main::@25
Culled Empty Block (label) main::@27
Culled Empty Block (label) main::@26
Culled Empty Block (label) main::@23
Culled Empty Block (label) main::@24
Renumbering block main::@5 to main::@4
Renumbering block main::@7 to main::@5
Renumbering block main::@8 to main::@6
Renumbering block main::@9 to main::@7
Renumbering block main::@10 to main::@8
Renumbering block main::@11 to main::@9
Renumbering block main::@12 to main::@10
Renumbering block main::@13 to main::@11
Renumbering block main::@14 to main::@12
Renumbering block main::@15 to main::@13
Renumbering block main::@16 to main::@14
Renumbering block main::@17 to main::@15
Renumbering block main::@18 to main::@16
Renumbering block main::@20 to main::@17
Renumbering block main::@21 to main::@18
Renumbering block main::@22 to main::@19
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@3

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [5] (byte*) main::sc#2 ← phi( main/(byte*) 1024 main::@2/(byte*) main::sc#1 )
  [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [7] phi()
  [8] call keyboard_init 
  to:main::@4
main::@4: scope:[main]  from main::@16 main::@3 main::@4
  [9] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@10 main::@4
  [10] (byte*) main::screen#13 ← phi( main::@10/(byte*) main::screen#1 main::@4/(byte*) 1024 )
  [10] (byte) main::row#2 ← phi( main::@10/(byte) main::row#1 main::@4/(byte) 0 )
  [11] (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2
  [12] call keyboard_matrix_read 
  [13] (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#0
  to:main::@17
main::@17: scope:[main]  from main::@5
  [14] (byte) main::row_pressed_bits#0 ← (byte) keyboard_matrix_read::return#3
  to:main::@6
main::@6: scope:[main]  from main::@17 main::@8
  [15] (byte) main::col#2 ← phi( main::@8/(byte) main::col#1 main::@17/(byte) 0 )
  [15] (byte) main::row_pressed_bits#2 ← phi( main::@8/(byte) main::row_pressed_bits#1 main::@17/(byte) main::row_pressed_bits#0 )
  [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80
  [17] if((byte~) main::$4!=(byte) 0) goto main::@7
  to:main::@9
main::@9: scope:[main]  from main::@6
  [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0'
  to:main::@8
main::@8: scope:[main]  from main::@7 main::@9
  [19] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 << (byte) 1
  [20] (byte) main::col#1 ← ++ (byte) main::col#2
  [21] if((byte) main::col#1!=(byte) 8) goto main::@6
  to:main::@10
main::@10: scope:[main]  from main::@8
  [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28
  [23] (byte) main::row#1 ← ++ (byte) main::row#2
  [24] if((byte) main::row#1!=(byte) 8) goto main::@5
  to:main::@11
main::@11: scope:[main]  from main::@10
  [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28
  to:main::@12
main::@12: scope:[main]  from main::@11 main::@13
  [26] (byte) main::i#3 ← phi( main::@11/(byte) 0 main::@13/(byte) main::i#6 )
  [26] (byte) main::ch#2 ← phi( main::@11/(byte) 0 main::@13/(byte) main::ch#1 )
  [27] (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2
  [28] call keyboard_get_keycode 
  [29] (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#0
  to:main::@18
main::@18: scope:[main]  from main::@12
  [30] (byte) main::key#0 ← (byte) keyboard_get_keycode::return#2
  [31] if((byte) main::key#0==(byte) $3f) goto main::@13
  to:main::@14
main::@14: scope:[main]  from main::@18
  [32] (byte) keyboard_key_pressed::key#0 ← (byte) main::key#0
  [33] call keyboard_key_pressed 
  [34] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
  to:main::@19
main::@19: scope:[main]  from main::@14
  [35] (byte~) main::$14 ← (byte) keyboard_key_pressed::return#2
  [36] if((byte~) main::$14==(byte) 0) goto main::@13
  to:main::@15
main::@15: scope:[main]  from main::@19
  [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2
  [38] (byte) main::i#1 ← ++ (byte) main::i#3
  to:main::@13
main::@13: scope:[main]  from main::@15 main::@18 main::@19
  [39] (byte) main::i#6 ← phi( main::@15/(byte) main::i#1 main::@18/(byte) main::i#3 main::@19/(byte) main::i#3 )
  [40] (byte) main::ch#1 ← ++ (byte) main::ch#2
  [41] if((byte) main::ch#1!=(byte) $40) goto main::@12
  to:main::@16
main::@16: scope:[main]  from main::@13 main::@16
  [42] (byte) main::i#4 ← phi( main::@13/(byte) main::i#6 main::@16/(byte) main::i#2 )
  [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' '
  [44] (byte) main::i#2 ← ++ (byte) main::i#4
  [45] if((byte) main::i#2<(byte) 5) goto main::@16
  to:main::@4
main::@7: scope:[main]  from main::@6
  [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1'
  to:main::@8
main::@2: scope:[main]  from main::@1
  [47] *((byte*) main::sc#2) ← (byte) ' '
  [48] (byte*) main::sc#1 ← ++ (byte*) main::sc#2
  to:main::@1

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from main::@14
  [49] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#0 & (byte) 7
  [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3
  [51] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  [52] call keyboard_matrix_read 
  [53] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  [54] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
  [55] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0)
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  [56] return 
  to:@return

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed main::@5
  [57] (byte) keyboard_matrix_read::rowid#2 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::rowid#0 main::@5/(byte) keyboard_matrix_read::rowid#1 )
  [58] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2)
  [59] (byte) keyboard_matrix_read::return#0 ← ~ *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B)
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  [60] return 
  to:@return

(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
keyboard_get_keycode: scope:[keyboard_get_keycode]  from main::@12
  [61] (byte) keyboard_get_keycode::return#0 ← *((const to_nomodify byte*) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#0)
  to:keyboard_get_keycode::@return
keyboard_get_keycode::@return: scope:[keyboard_get_keycode]  from keyboard_get_keycode
  [62] return 
  to:@return

(void()) keyboard_init()
keyboard_init: scope:[keyboard_init]  from main::@3
  [63] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) $ff
  [64] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR) ← (byte) 0
  to:keyboard_init::@return
keyboard_init::@return: scope:[keyboard_init]  from keyboard_init
  [65] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
(byte) keyboard_get_keycode::ch
(byte) keyboard_get_keycode::ch#0 11002.0
(byte) keyboard_get_keycode::return
(byte) keyboard_get_keycode::return#0 3667.333333333333
(byte) keyboard_get_keycode::return#2 2002.0
(void()) keyboard_init()
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 20002.0
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0 3333.6666666666665
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0 10501.5
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 3667.333333333333
(byte) keyboard_key_pressed::return#2 2002.0
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0 20002.0
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 27750.75
(byte) keyboard_matrix_read::return#2 20002.0
(byte) keyboard_matrix_read::return#3 2002.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0 20002.0
(byte) keyboard_matrix_read::rowid#1 2002.0
(byte) keyboard_matrix_read::rowid#2 111003.0
(void()) main()
(byte~) main::$14 2002.0
(byte~) main::$4 20002.0
(byte) main::ch
(byte) main::ch#1 1501.5
(byte) main::ch#2 286.0
(byte) main::col
(byte) main::col#1 15001.5
(byte) main::col#2 6667.333333333333
(byte) main::i
(byte) main::i#1 2002.0
(byte) main::i#2 1501.5
(byte) main::i#3 417.08333333333337
(byte) main::i#4 2002.0
(byte) main::i#6 1668.3333333333335
(byte) main::key
(byte) main::key#0 1501.5
(byte) main::row
(byte) main::row#1 1501.5
(byte) main::row#2 214.5
(byte) main::row_pressed_bits
(byte) main::row_pressed_bits#0 2002.0
(byte) main::row_pressed_bits#1 6667.333333333333
(byte) main::row_pressed_bits#2 6200.8
(byte*) main::sc
(byte*) main::sc#1 202.0
(byte*) main::sc#2 134.66666666666666
(byte*) main::screen
(byte*) main::screen#1 701.0
(byte*) main::screen#13 1692.6153846153845
(byte*) main::screen#2 100.14285714285714

Initial phi equivalence classes
[ main::sc#2 main::sc#1 ]
[ main::row#2 main::row#1 ]
[ main::screen#13 main::screen#1 ]
[ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
[ main::col#2 main::col#1 ]
[ main::ch#2 main::ch#1 ]
[ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
[ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ]
Added variable keyboard_matrix_read::return#3 to live range equivalence class [ keyboard_matrix_read::return#3 ]
Added variable main::$4 to live range equivalence class [ main::$4 ]
Added variable main::screen#2 to live range equivalence class [ main::screen#2 ]
Added variable keyboard_get_keycode::ch#0 to live range equivalence class [ keyboard_get_keycode::ch#0 ]
Added variable keyboard_get_keycode::return#2 to live range equivalence class [ keyboard_get_keycode::return#2 ]
Added variable main::key#0 to live range equivalence class [ main::key#0 ]
Added variable keyboard_key_pressed::key#0 to live range equivalence class [ keyboard_key_pressed::key#0 ]
Added variable keyboard_key_pressed::return#2 to live range equivalence class [ keyboard_key_pressed::return#2 ]
Added variable main::$14 to live range equivalence class [ main::$14 ]
Added variable keyboard_key_pressed::colidx#0 to live range equivalence class [ keyboard_key_pressed::colidx#0 ]
Added variable keyboard_key_pressed::rowidx#0 to live range equivalence class [ keyboard_key_pressed::rowidx#0 ]
Added variable keyboard_matrix_read::return#2 to live range equivalence class [ keyboard_matrix_read::return#2 ]
Added variable keyboard_key_pressed::$2 to live range equivalence class [ keyboard_key_pressed::$2 ]
Added variable keyboard_key_pressed::return#0 to live range equivalence class [ keyboard_key_pressed::return#0 ]
Added variable keyboard_matrix_read::return#0 to live range equivalence class [ keyboard_matrix_read::return#0 ]
Added variable keyboard_get_keycode::return#0 to live range equivalence class [ keyboard_get_keycode::return#0 ]
Complete equivalence classes
[ main::sc#2 main::sc#1 ]
[ main::row#2 main::row#1 ]
[ main::screen#13 main::screen#1 ]
[ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
[ main::col#2 main::col#1 ]
[ main::ch#2 main::ch#1 ]
[ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
[ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ]
[ keyboard_matrix_read::return#3 ]
[ main::$4 ]
[ main::screen#2 ]
[ keyboard_get_keycode::ch#0 ]
[ keyboard_get_keycode::return#2 ]
[ main::key#0 ]
[ keyboard_key_pressed::key#0 ]
[ keyboard_key_pressed::return#2 ]
[ main::$14 ]
[ keyboard_key_pressed::colidx#0 ]
[ keyboard_key_pressed::rowidx#0 ]
[ keyboard_matrix_read::return#2 ]
[ keyboard_key_pressed::$2 ]
[ keyboard_key_pressed::return#0 ]
[ keyboard_matrix_read::return#0 ]
[ keyboard_get_keycode::return#0 ]
Allocated zp[2]:2 [ main::sc#2 main::sc#1 ]
Allocated zp[1]:4 [ main::row#2 main::row#1 ]
Allocated zp[2]:5 [ main::screen#13 main::screen#1 ]
Allocated zp[1]:7 [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
Allocated zp[1]:8 [ main::col#2 main::col#1 ]
Allocated zp[1]:9 [ main::ch#2 main::ch#1 ]
Allocated zp[1]:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
Allocated zp[1]:11 [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ]
Allocated zp[1]:12 [ keyboard_matrix_read::return#3 ]
Allocated zp[1]:13 [ main::$4 ]
Allocated zp[2]:14 [ main::screen#2 ]
Allocated zp[1]:16 [ keyboard_get_keycode::ch#0 ]
Allocated zp[1]:17 [ keyboard_get_keycode::return#2 ]
Allocated zp[1]:18 [ main::key#0 ]
Allocated zp[1]:19 [ keyboard_key_pressed::key#0 ]
Allocated zp[1]:20 [ keyboard_key_pressed::return#2 ]
Allocated zp[1]:21 [ main::$14 ]
Allocated zp[1]:22 [ keyboard_key_pressed::colidx#0 ]
Allocated zp[1]:23 [ keyboard_key_pressed::rowidx#0 ]
Allocated zp[1]:24 [ keyboard_matrix_read::return#2 ]
Allocated zp[1]:25 [ keyboard_key_pressed::$2 ]
Allocated zp[1]:26 [ keyboard_key_pressed::return#0 ]
Allocated zp[1]:27 [ keyboard_matrix_read::return#0 ]
Allocated zp[1]:28 [ keyboard_get_keycode::return#0 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Test keyboard input - in the keyboard matrix and mapping screen codes to key codes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const KEY_3 = 8
  .const KEY_W = 9
  .const KEY_A = $a
  .const KEY_4 = $b
  .const KEY_Z = $c
  .const KEY_S = $d
  .const KEY_E = $e
  .const KEY_5 = $10
  .const KEY_R = $11
  .const KEY_D = $12
  .const KEY_6 = $13
  .const KEY_C = $14
  .const KEY_F = $15
  .const KEY_T = $16
  .const KEY_X = $17
  .const KEY_7 = $18
  .const KEY_Y = $19
  .const KEY_G = $1a
  .const KEY_8 = $1b
  .const KEY_B = $1c
  .const KEY_H = $1d
  .const KEY_U = $1e
  .const KEY_V = $1f
  .const KEY_9 = $20
  .const KEY_I = $21
  .const KEY_J = $22
  .const KEY_0 = $23
  .const KEY_M = $24
  .const KEY_K = $25
  .const KEY_O = $26
  .const KEY_N = $27
  .const KEY_PLUS = $28
  .const KEY_P = $29
  .const KEY_L = $2a
  .const KEY_MINUS = $2b
  .const KEY_DOT = $2c
  .const KEY_COLON = $2d
  .const KEY_AT = $2e
  .const KEY_COMMA = $2f
  .const KEY_POUND = $30
  .const KEY_ASTERISK = $31
  .const KEY_SEMICOLON = $32
  .const KEY_EQUALS = $35
  .const KEY_ARROW_UP = $36
  .const KEY_SLASH = $37
  .const KEY_1 = $38
  .const KEY_ARROW_LEFT = $39
  .const KEY_2 = $3b
  .const KEY_SPACE = $3c
  .const KEY_Q = $3e
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = 2
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR = 3
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
  .label RASTER = $d012
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label __4 = $d
    .label __14 = $15
    .label sc = 2
    .label row_pressed_bits = 7
    .label col = 8
    .label screen = 5
    .label row = 4
    .label screen_1 = $e
    .label key = $12
    .label ch = 9
    // Checks all specific chars $00-$3f
    .label i = $a
    // [5] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [5] phi (byte*) main::sc#2 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z sc
    lda #>$400
    sta.z sc+1
    jmp __b1
  // Clear screen
    // main::@1
  __b1:
    // [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 -- pbuz1_lt_vwuc1_then_la1 
    lda.z sc+1
    cmp #>$400+$3e8
    bcc __b2
    bne !+
    lda.z sc
    cmp #<$400+$3e8
    bcc __b2
  !:
    // [7] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [8] call keyboard_init 
    // Init keyboard
    jsr keyboard_init
    jmp __b4
    // main::@4
  __b4:
    // [9] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto main::@4 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b4
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    // [10] phi (byte*) main::screen#13 = (byte*) 1024 [phi:main::@4->main::@5#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z screen
    lda #>$400
    sta.z screen+1
    // [10] phi (byte) main::row#2 = (byte) 0 [phi:main::@4->main::@5#1] -- vbuz1=vbuc1 
    lda #0
    sta.z row
    jmp __b5
  // Read & print keyboard matrix
    // [10] phi from main::@10 to main::@5 [phi:main::@10->main::@5]
  __b5_from___b10:
    // [10] phi (byte*) main::screen#13 = (byte*) main::screen#1 [phi:main::@10->main::@5#0] -- register_copy 
    // [10] phi (byte) main::row#2 = (byte) main::row#1 [phi:main::@10->main::@5#1] -- register_copy 
    jmp __b5
    // main::@5
  __b5:
    // [11] (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2 -- vbuz1=vbuz2 
    lda.z row
    sta.z keyboard_matrix_read.rowid
    // [12] call keyboard_matrix_read 
    // [57] phi from main::@5 to keyboard_matrix_read [phi:main::@5->keyboard_matrix_read]
  keyboard_matrix_read_from___b5:
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#1 [phi:main::@5->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // [13] (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return
    sta.z keyboard_matrix_read.return_2
    jmp __b17
    // main::@17
  __b17:
    // [14] (byte) main::row_pressed_bits#0 ← (byte) keyboard_matrix_read::return#3 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return_2
    sta.z row_pressed_bits
    // [15] phi from main::@17 to main::@6 [phi:main::@17->main::@6]
  __b6_from___b17:
    // [15] phi (byte) main::col#2 = (byte) 0 [phi:main::@17->main::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta.z col
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#0 [phi:main::@17->main::@6#1] -- register_copy 
    jmp __b6
    // [15] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
  __b6_from___b8:
    // [15] phi (byte) main::col#2 = (byte) main::col#1 [phi:main::@8->main::@6#0] -- register_copy 
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#1 [phi:main::@8->main::@6#1] -- register_copy 
    jmp __b6
    // main::@6
  __b6:
    // [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and.z row_pressed_bits
    sta.z __4
    // [17] if((byte~) main::$4!=(byte) 0) goto main::@7 -- vbuz1_neq_0_then_la1 
    lda.z __4
    cmp #0
    bne __b7
    jmp __b9
    // main::@9
  __b9:
    // [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' -- pbuz1_derefidx_vbuz2=vbuc1 
    lda #'0'
    ldy.z col
    sta (screen),y
    jmp __b8
    // main::@8
  __b8:
    // [19] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z row_pressed_bits
    // [20] (byte) main::col#1 ← ++ (byte) main::col#2 -- vbuz1=_inc_vbuz1 
    inc.z col
    // [21] if((byte) main::col#1!=(byte) 8) goto main::@6 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z col
    bne __b6_from___b8
    jmp __b10
    // main::@10
  __b10:
    // [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [23] (byte) main::row#1 ← ++ (byte) main::row#2 -- vbuz1=_inc_vbuz1 
    inc.z row
    // [24] if((byte) main::row#1!=(byte) 8) goto main::@5 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z row
    bne __b5_from___b10
    jmp __b11
    // main::@11
  __b11:
    // [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 -- pbuz1=pbuz2_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen_1
    lda #0
    adc.z screen+1
    sta.z screen_1+1
    // [26] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  __b12_from___b11:
    // [26] phi (byte) main::i#3 = (byte) 0 [phi:main::@11->main::@12#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [26] phi (byte) main::ch#2 = (byte) 0 [phi:main::@11->main::@12#1] -- vbuz1=vbuc1 
    lda #0
    sta.z ch
    jmp __b12
    // [26] phi from main::@13 to main::@12 [phi:main::@13->main::@12]
  __b12_from___b13:
    // [26] phi (byte) main::i#3 = (byte) main::i#6 [phi:main::@13->main::@12#0] -- register_copy 
    // [26] phi (byte) main::ch#2 = (byte) main::ch#1 [phi:main::@13->main::@12#1] -- register_copy 
    jmp __b12
    // main::@12
  __b12:
    // [27] (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2 -- vbuz1=vbuz2 
    lda.z ch
    sta.z keyboard_get_keycode.ch
    // [28] call keyboard_get_keycode 
    jsr keyboard_get_keycode
    // [29] (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_get_keycode.return
    sta.z keyboard_get_keycode.return_1
    jmp __b18
    // main::@18
  __b18:
    // [30] (byte) main::key#0 ← (byte) keyboard_get_keycode::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_get_keycode.return_1
    sta.z key
    // [31] if((byte) main::key#0==(byte) $3f) goto main::@13 -- vbuz1_eq_vbuc1_then_la1 
    lda #$3f
    cmp.z key
    beq __b13_from___b18
    jmp __b14
    // main::@14
  __b14:
    // [32] (byte) keyboard_key_pressed::key#0 ← (byte) main::key#0 -- vbuz1=vbuz2 
    lda.z key
    sta.z keyboard_key_pressed.key
    // [33] call keyboard_key_pressed 
    jsr keyboard_key_pressed
    // [34] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_1
    jmp __b19
    // main::@19
  __b19:
    // [35] (byte~) main::$14 ← (byte) keyboard_key_pressed::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_1
    sta.z __14
    // [36] if((byte~) main::$14==(byte) 0) goto main::@13 -- vbuz1_eq_0_then_la1 
    lda.z __14
    cmp #0
    beq __b13_from___b19
    jmp __b15
    // main::@15
  __b15:
    // [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2 -- pbuz1_derefidx_vbuz2=vbuz3 
    lda.z ch
    ldy.z i
    sta (screen_1),y
    // [38] (byte) main::i#1 ← ++ (byte) main::i#3 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [39] phi from main::@15 main::@18 main::@19 to main::@13 [phi:main::@15/main::@18/main::@19->main::@13]
  __b13_from___b15:
  __b13_from___b18:
  __b13_from___b19:
    // [39] phi (byte) main::i#6 = (byte) main::i#1 [phi:main::@15/main::@18/main::@19->main::@13#0] -- register_copy 
    jmp __b13
    // main::@13
  __b13:
    // [40] (byte) main::ch#1 ← ++ (byte) main::ch#2 -- vbuz1=_inc_vbuz1 
    inc.z ch
    // [41] if((byte) main::ch#1!=(byte) $40) goto main::@12 -- vbuz1_neq_vbuc1_then_la1 
    lda #$40
    cmp.z ch
    bne __b12_from___b13
    // [42] phi from main::@13 main::@16 to main::@16 [phi:main::@13/main::@16->main::@16]
  __b16_from___b13:
  __b16_from___b16:
    // [42] phi (byte) main::i#4 = (byte) main::i#6 [phi:main::@13/main::@16->main::@16#0] -- register_copy 
    jmp __b16
  // Add some spaces
    // main::@16
  __b16:
    // [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' -- pbuz1_derefidx_vbuz2=vbuc1 
    lda #' '
    ldy.z i
    sta (screen_1),y
    // [44] (byte) main::i#2 ← ++ (byte) main::i#4 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [45] if((byte) main::i#2<(byte) 5) goto main::@16 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #5
    bcc __b16_from___b16
    jmp __b4
    // main::@7
  __b7:
    // [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' -- pbuz1_derefidx_vbuz2=vbuc1 
    lda #'1'
    ldy.z col
    sta (screen),y
    jmp __b8
    // main::@2
  __b2:
    // [47] *((byte*) main::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [48] (byte*) main::sc#1 ← ++ (byte*) main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [5] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [5] phi (byte*) main::sc#2 = (byte*) main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte zp($13) key)
keyboard_key_pressed: {
    .label __2 = $19
    .label colidx = $16
    .label rowidx = $17
    .label return = $1a
    .label key = $13
    .label return_1 = $14
    // [49] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#0 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z key
    sta.z colidx
    // [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 -- vbuz1=vbuz2_ror_3 
    lda.z key
    lsr
    lsr
    lsr
    sta.z rowidx
    // [51] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuz1=vbuz2 
    lda.z rowidx
    sta.z keyboard_matrix_read.rowid
    // [52] call keyboard_matrix_read 
    // [57] phi from keyboard_key_pressed to keyboard_matrix_read [phi:keyboard_key_pressed->keyboard_matrix_read]
  keyboard_matrix_read_from_keyboard_key_pressed:
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#0 [phi:keyboard_key_pressed->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // [53] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return
    sta.z keyboard_matrix_read.return_1
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [54] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return_1
    sta.z __2
    // [55] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0) -- vbuz1=vbuz2_band_pbuc1_derefidx_vbuz3 
    lda.z __2
    ldy.z colidx
    and keyboard_matrix_col_bitmask,y
    sta.z return
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [56] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte zp($b) rowid)
keyboard_matrix_read: {
    .label return = $1b
    .label rowid = $b
    .label return_1 = $18
    .label return_2 = $c
    // [58] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) -- _deref_pbuc1=pbuc2_derefidx_vbuz1 
    ldy.z rowid
    lda keyboard_matrix_row_bitmask,y
    sta CIA1
    // [59] (byte) keyboard_matrix_read::return#0 ← ~ *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B) -- vbuz1=_bnot__deref_pbuc1 
    lda CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B
    eor #$ff
    sta.z return
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [60] return 
    rts
}
  // keyboard_get_keycode
// Get the keycode corresponding to a specific screen code character
// ch is the character to get the key code for ($00-$3f)
// Returns the key code corresponding to the passed character. Only characters with a non-shifted key are handled.
// If there is no non-shifted key representing the char $3f is returned (representing RUN/STOP) .
// keyboard_get_keycode(byte zp($10) ch)
keyboard_get_keycode: {
    .label return = $1c
    .label ch = $10
    .label return_1 = $11
    // [61] (byte) keyboard_get_keycode::return#0 ← *((const to_nomodify byte*) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z ch
    lda keyboard_char_keycodes,y
    sta.z return
    jmp __breturn
    // keyboard_get_keycode::@return
  __breturn:
    // [62] return 
    rts
}
  // keyboard_init
// Initialize keyboard reading by setting CIA#$ Data Direction Registers
keyboard_init: {
    // [63] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Write Mode
    lda #$ff
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR
    // [64] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Read Mode
    lda #0
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR
    jmp __breturn
    // keyboard_init::@return
  __breturn:
    // [65] return 
    rts
}
  // File Data
  // Keycodes for each screen code character from $00-$3f.
  // Chars that do not have an unmodified keycode return $3f (representing RUN/STOP).
  keyboard_char_keycodes: .byte KEY_AT, KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, $3f, KEY_POUND, $3f, KEY_ARROW_UP, KEY_ARROW_LEFT, KEY_SPACE, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, KEY_ASTERISK, KEY_PLUS, KEY_COMMA, KEY_MINUS, KEY_DOT, KEY_SLASH, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_COLON, KEY_SEMICOLON, $3f, KEY_EQUALS, $3f, $3f
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 [ main::sc#2 ] ( main:2 [ main::sc#2 ] { }  ) always clobbers reg byte a 
Statement [9] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto main::@4 [ ] ( main:2 [ ] { }  ) always clobbers reg byte a 
Statement [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ main::row#2 main::row#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:8 [ main::col#2 main::col#1 ]
Statement [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 [ main::row#2 main::screen#1 ] ( main:2 [ main::row#2 main::screen#1 ] { }  ) always clobbers reg byte a 
Statement [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 [ main::screen#2 ] ( main:2 [ main::screen#2 ] { }  ) always clobbers reg byte a 
Statement [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' [ main::screen#2 main::i#4 ] ( main:2 [ main::screen#2 main::i#4 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
Statement [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] { }  ) always clobbers reg byte a 
Statement [47] *((byte*) main::sc#2) ← (byte) ' ' [ main::sc#2 ] ( main:2 [ main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( main:2::keyboard_key_pressed:33 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::key#0 = main::key#0 } { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_matrix_read::rowid#2 keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:9 [ main::ch#2 main::ch#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:22 [ keyboard_key_pressed::colidx#0 ]
Statement [58] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) [ ] ( main:2::keyboard_matrix_read:12 [ main::row#2 main::screen#13 ] { { keyboard_matrix_read::rowid#1 = keyboard_matrix_read::rowid#2 main::row#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#3 } }  main:2::keyboard_key_pressed:33::keyboard_matrix_read:52 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::key#0 = main::key#0 } { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_matrix_read::rowid#2 keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [59] (byte) keyboard_matrix_read::return#0 ← ~ *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:2::keyboard_matrix_read:12 [ main::row#2 main::screen#13 keyboard_matrix_read::return#0 ] { { keyboard_matrix_read::rowid#1 = keyboard_matrix_read::rowid#2 main::row#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#3 } }  main:2::keyboard_key_pressed:33::keyboard_matrix_read:52 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::key#0 = main::key#0 } { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_matrix_read::rowid#2 keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [63] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) $ff [ ] ( main:2::keyboard_init:8 [ ] { }  ) always clobbers reg byte a 
Statement [64] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR) ← (byte) 0 [ ] ( main:2::keyboard_init:8 [ ] { }  ) always clobbers reg byte a 
Statement [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 [ main::sc#2 ] ( main:2 [ main::sc#2 ] { }  ) always clobbers reg byte a 
Statement [9] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto main::@4 [ ] ( main:2 [ ] { }  ) always clobbers reg byte a 
Statement [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 main::$4 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 main::$4 ] { }  ) always clobbers reg byte a 
Statement [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] { }  ) always clobbers reg byte a 
Statement [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 [ main::row#2 main::screen#1 ] ( main:2 [ main::row#2 main::screen#1 ] { }  ) always clobbers reg byte a 
Statement [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 [ main::screen#2 ] ( main:2 [ main::screen#2 ] { }  ) always clobbers reg byte a 
Statement [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2 [ main::screen#2 main::ch#2 main::i#3 ] ( main:2 [ main::screen#2 main::ch#2 main::i#3 ] { }  ) always clobbers reg byte a 
Statement [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' [ main::screen#2 main::i#4 ] ( main:2 [ main::screen#2 main::i#4 ] { }  ) always clobbers reg byte a 
Statement [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] ( main:2 [ main::row#2 main::screen#13 main::row_pressed_bits#2 main::col#2 ] { }  ) always clobbers reg byte a 
Statement [47] *((byte*) main::sc#2) ← (byte) ' ' [ main::sc#2 ] ( main:2 [ main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 [ keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] ( main:2::keyboard_key_pressed:33 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 keyboard_key_pressed::rowidx#0 ] { { keyboard_key_pressed::key#0 = main::key#0 } { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_matrix_read::rowid#2 keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [58] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) [ ] ( main:2::keyboard_matrix_read:12 [ main::row#2 main::screen#13 ] { { keyboard_matrix_read::rowid#1 = keyboard_matrix_read::rowid#2 main::row#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#3 } }  main:2::keyboard_key_pressed:33::keyboard_matrix_read:52 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 ] { { keyboard_key_pressed::key#0 = main::key#0 } { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_matrix_read::rowid#2 keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [59] (byte) keyboard_matrix_read::return#0 ← ~ *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:2::keyboard_matrix_read:12 [ main::row#2 main::screen#13 keyboard_matrix_read::return#0 ] { { keyboard_matrix_read::rowid#1 = keyboard_matrix_read::rowid#2 main::row#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#3 } }  main:2::keyboard_key_pressed:33::keyboard_matrix_read:52 [ main::screen#2 main::ch#2 main::i#3 keyboard_key_pressed::colidx#0 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::key#0 = main::key#0 } { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::rowid#0 = keyboard_matrix_read::rowid#2 keyboard_key_pressed::rowidx#0 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [63] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) $ff [ ] ( main:2::keyboard_init:8 [ ] { }  ) always clobbers reg byte a 
Statement [64] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR) ← (byte) 0 [ ] ( main:2::keyboard_init:8 [ ] { }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ main::sc#2 main::sc#1 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ main::row#2 main::row#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[2]:5 [ main::screen#13 main::screen#1 ] : zp[2]:5 , 
Potential registers zp[1]:7 [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ] : zp[1]:7 , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ main::col#2 main::col#1 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ main::ch#2 main::ch#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ] : zp[1]:11 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:12 [ keyboard_matrix_read::return#3 ] : zp[1]:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ main::$4 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:14 [ main::screen#2 ] : zp[2]:14 , 
Potential registers zp[1]:16 [ keyboard_get_keycode::ch#0 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ keyboard_get_keycode::return#2 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:18 [ main::key#0 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:19 [ keyboard_key_pressed::key#0 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:20 [ keyboard_key_pressed::return#2 ] : zp[1]:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:21 [ main::$14 ] : zp[1]:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:22 [ keyboard_key_pressed::colidx#0 ] : zp[1]:22 , reg byte x , reg byte y , 
Potential registers zp[1]:23 [ keyboard_key_pressed::rowidx#0 ] : zp[1]:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:24 [ keyboard_matrix_read::return#2 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:25 [ keyboard_key_pressed::$2 ] : zp[1]:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:26 [ keyboard_key_pressed::return#0 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:27 [ keyboard_matrix_read::return#0 ] : zp[1]:27 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:28 [ keyboard_get_keycode::return#0 ] : zp[1]:28 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [keyboard_matrix_read] 133,007: zp[1]:11 [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ] 27,750.75: zp[1]:27 [ keyboard_matrix_read::return#0 ] 20,002: zp[1]:24 [ keyboard_matrix_read::return#2 ] 2,002: zp[1]:12 [ keyboard_matrix_read::return#3 ] 
Uplift Scope [main] 21,668.83: zp[1]:8 [ main::col#2 main::col#1 ] 20,002: zp[1]:13 [ main::$4 ] 14,870.13: zp[1]:7 [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ] 7,590.92: zp[1]:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ] 2,393.62: zp[2]:5 [ main::screen#13 main::screen#1 ] 2,002: zp[1]:21 [ main::$14 ] 1,787.5: zp[1]:9 [ main::ch#2 main::ch#1 ] 1,716: zp[1]:4 [ main::row#2 main::row#1 ] 1,501.5: zp[1]:18 [ main::key#0 ] 336.67: zp[2]:2 [ main::sc#2 main::sc#1 ] 100.14: zp[2]:14 [ main::screen#2 ] 
Uplift Scope [keyboard_key_pressed] 20,002: zp[1]:23 [ keyboard_key_pressed::rowidx#0 ] 20,002: zp[1]:25 [ keyboard_key_pressed::$2 ] 10,501.5: zp[1]:19 [ keyboard_key_pressed::key#0 ] 3,667.33: zp[1]:26 [ keyboard_key_pressed::return#0 ] 3,333.67: zp[1]:22 [ keyboard_key_pressed::colidx#0 ] 2,002: zp[1]:20 [ keyboard_key_pressed::return#2 ] 
Uplift Scope [keyboard_get_keycode] 11,002: zp[1]:16 [ keyboard_get_keycode::ch#0 ] 3,667.33: zp[1]:28 [ keyboard_get_keycode::return#0 ] 2,002: zp[1]:17 [ keyboard_get_keycode::return#2 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [keyboard_init] 
Uplift Scope [] 

Uplifting [keyboard_matrix_read] best 101340 combination reg byte x [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ] reg byte a [ keyboard_matrix_read::return#0 ] reg byte a [ keyboard_matrix_read::return#2 ] reg byte a [ keyboard_matrix_read::return#3 ] 
Limited combination testing to 100 combinations of 256 possible.
Uplifting [main] best 80240 combination reg byte y [ main::col#2 main::col#1 ] reg byte a [ main::$4 ] reg byte x [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ] zp[1]:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ] zp[2]:5 [ main::screen#13 main::screen#1 ] zp[1]:21 [ main::$14 ] zp[1]:9 [ main::ch#2 main::ch#1 ] zp[1]:4 [ main::row#2 main::row#1 ] zp[1]:18 [ main::key#0 ] zp[2]:2 [ main::sc#2 main::sc#1 ] zp[2]:14 [ main::screen#2 ] 
Limited combination testing to 100 combinations of 15552 possible.
Uplifting [keyboard_key_pressed] best 79629 combination reg byte a [ keyboard_key_pressed::rowidx#0 ] zp[1]:25 [ keyboard_key_pressed::$2 ] reg byte x [ keyboard_key_pressed::key#0 ] reg byte a [ keyboard_key_pressed::return#0 ] zp[1]:22 [ keyboard_key_pressed::colidx#0 ] zp[1]:20 [ keyboard_key_pressed::return#2 ] 
Limited combination testing to 100 combinations of 3072 possible.
Uplifting [keyboard_get_keycode] best 78423 combination reg byte x [ keyboard_get_keycode::ch#0 ] reg byte a [ keyboard_get_keycode::return#0 ] reg byte a [ keyboard_get_keycode::return#2 ] 
Uplifting [MOS6526_CIA] best 78423 combination 
Uplifting [MOS6569_VICII] best 78423 combination 
Uplifting [MOS6581_SID] best 78423 combination 
Uplifting [keyboard_init] best 78423 combination 
Uplifting [] best 78423 combination 
Attempting to uplift remaining variables inzp[1]:25 [ keyboard_key_pressed::$2 ]
Uplifting [keyboard_key_pressed] best 78417 combination reg byte a [ keyboard_key_pressed::$2 ] 
Attempting to uplift remaining variables inzp[1]:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
Uplifting [main] best 78417 combination zp[1]:10 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ] 
Attempting to uplift remaining variables inzp[1]:22 [ keyboard_key_pressed::colidx#0 ]
Uplifting [keyboard_key_pressed] best 78415 combination reg byte y [ keyboard_key_pressed::colidx#0 ] 
Attempting to uplift remaining variables inzp[1]:20 [ keyboard_key_pressed::return#2 ]
Uplifting [keyboard_key_pressed] best 77815 combination reg byte a [ keyboard_key_pressed::return#2 ] 
Attempting to uplift remaining variables inzp[1]:21 [ main::$14 ]
Uplifting [main] best 77215 combination reg byte a [ main::$14 ] 
Attempting to uplift remaining variables inzp[1]:9 [ main::ch#2 main::ch#1 ]
Uplifting [main] best 77215 combination zp[1]:9 [ main::ch#2 main::ch#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ main::row#2 main::row#1 ]
Uplifting [main] best 77215 combination zp[1]:4 [ main::row#2 main::row#1 ] 
Attempting to uplift remaining variables inzp[1]:18 [ main::key#0 ]
Uplifting [main] best 76515 combination reg byte a [ main::key#0 ] 
Coalescing zero page register [ zp[2]:5 [ main::screen#13 main::screen#1 ] ] with [ zp[2]:14 [ main::screen#2 ] ] - score: 1
Allocated (was zp[1]:9) zp[1]:7 [ main::ch#2 main::ch#1 ]
Allocated (was zp[1]:10) zp[1]:8 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test keyboard input - in the keyboard matrix and mapping screen codes to key codes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const KEY_3 = 8
  .const KEY_W = 9
  .const KEY_A = $a
  .const KEY_4 = $b
  .const KEY_Z = $c
  .const KEY_S = $d
  .const KEY_E = $e
  .const KEY_5 = $10
  .const KEY_R = $11
  .const KEY_D = $12
  .const KEY_6 = $13
  .const KEY_C = $14
  .const KEY_F = $15
  .const KEY_T = $16
  .const KEY_X = $17
  .const KEY_7 = $18
  .const KEY_Y = $19
  .const KEY_G = $1a
  .const KEY_8 = $1b
  .const KEY_B = $1c
  .const KEY_H = $1d
  .const KEY_U = $1e
  .const KEY_V = $1f
  .const KEY_9 = $20
  .const KEY_I = $21
  .const KEY_J = $22
  .const KEY_0 = $23
  .const KEY_M = $24
  .const KEY_K = $25
  .const KEY_O = $26
  .const KEY_N = $27
  .const KEY_PLUS = $28
  .const KEY_P = $29
  .const KEY_L = $2a
  .const KEY_MINUS = $2b
  .const KEY_DOT = $2c
  .const KEY_COLON = $2d
  .const KEY_AT = $2e
  .const KEY_COMMA = $2f
  .const KEY_POUND = $30
  .const KEY_ASTERISK = $31
  .const KEY_SEMICOLON = $32
  .const KEY_EQUALS = $35
  .const KEY_ARROW_UP = $36
  .const KEY_SLASH = $37
  .const KEY_1 = $38
  .const KEY_ARROW_LEFT = $39
  .const KEY_2 = $3b
  .const KEY_SPACE = $3c
  .const KEY_Q = $3e
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = 2
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR = 3
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
  .label RASTER = $d012
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label sc = 2
    .label screen = 5
    .label row = 4
    .label ch = 7
    // Checks all specific chars $00-$3f
    .label i = 8
    // [5] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [5] phi (byte*) main::sc#2 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z sc
    lda #>$400
    sta.z sc+1
    jmp __b1
  // Clear screen
    // main::@1
  __b1:
    // [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 -- pbuz1_lt_vwuc1_then_la1 
    lda.z sc+1
    cmp #>$400+$3e8
    bcc __b2
    bne !+
    lda.z sc
    cmp #<$400+$3e8
    bcc __b2
  !:
    // [7] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    jmp __b3
    // main::@3
  __b3:
    // [8] call keyboard_init 
    // Init keyboard
    jsr keyboard_init
    jmp __b4
    // main::@4
  __b4:
    // [9] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto main::@4 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b4
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    // [10] phi (byte*) main::screen#13 = (byte*) 1024 [phi:main::@4->main::@5#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z screen
    lda #>$400
    sta.z screen+1
    // [10] phi (byte) main::row#2 = (byte) 0 [phi:main::@4->main::@5#1] -- vbuz1=vbuc1 
    lda #0
    sta.z row
    jmp __b5
  // Read & print keyboard matrix
    // [10] phi from main::@10 to main::@5 [phi:main::@10->main::@5]
  __b5_from___b10:
    // [10] phi (byte*) main::screen#13 = (byte*) main::screen#1 [phi:main::@10->main::@5#0] -- register_copy 
    // [10] phi (byte) main::row#2 = (byte) main::row#1 [phi:main::@10->main::@5#1] -- register_copy 
    jmp __b5
    // main::@5
  __b5:
    // [11] (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2 -- vbuxx=vbuz1 
    ldx.z row
    // [12] call keyboard_matrix_read 
    // [57] phi from main::@5 to keyboard_matrix_read [phi:main::@5->keyboard_matrix_read]
  keyboard_matrix_read_from___b5:
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#1 [phi:main::@5->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // [13] (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#0
    jmp __b17
    // main::@17
  __b17:
    // [14] (byte) main::row_pressed_bits#0 ← (byte) keyboard_matrix_read::return#3 -- vbuxx=vbuaa 
    tax
    // [15] phi from main::@17 to main::@6 [phi:main::@17->main::@6]
  __b6_from___b17:
    // [15] phi (byte) main::col#2 = (byte) 0 [phi:main::@17->main::@6#0] -- vbuyy=vbuc1 
    ldy #0
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#0 [phi:main::@17->main::@6#1] -- register_copy 
    jmp __b6
    // [15] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
  __b6_from___b8:
    // [15] phi (byte) main::col#2 = (byte) main::col#1 [phi:main::@8->main::@6#0] -- register_copy 
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#1 [phi:main::@8->main::@6#1] -- register_copy 
    jmp __b6
    // main::@6
  __b6:
    // [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #$80
    // [17] if((byte~) main::$4!=(byte) 0) goto main::@7 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b7
    jmp __b9
    // main::@9
  __b9:
    // [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #'0'
    sta (screen),y
    jmp __b8
    // main::@8
  __b8:
    // [19] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 << (byte) 1 -- vbuxx=vbuxx_rol_1 
    txa
    asl
    tax
    // [20] (byte) main::col#1 ← ++ (byte) main::col#2 -- vbuyy=_inc_vbuyy 
    iny
    // [21] if((byte) main::col#1!=(byte) 8) goto main::@6 -- vbuyy_neq_vbuc1_then_la1 
    cpy #8
    bne __b6_from___b8
    jmp __b10
    // main::@10
  __b10:
    // [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [23] (byte) main::row#1 ← ++ (byte) main::row#2 -- vbuz1=_inc_vbuz1 
    inc.z row
    // [24] if((byte) main::row#1!=(byte) 8) goto main::@5 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z row
    bne __b5_from___b10
    jmp __b11
    // main::@11
  __b11:
    // [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [26] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
  __b12_from___b11:
    // [26] phi (byte) main::i#3 = (byte) 0 [phi:main::@11->main::@12#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [26] phi (byte) main::ch#2 = (byte) 0 [phi:main::@11->main::@12#1] -- vbuz1=vbuc1 
    lda #0
    sta.z ch
    jmp __b12
    // [26] phi from main::@13 to main::@12 [phi:main::@13->main::@12]
  __b12_from___b13:
    // [26] phi (byte) main::i#3 = (byte) main::i#6 [phi:main::@13->main::@12#0] -- register_copy 
    // [26] phi (byte) main::ch#2 = (byte) main::ch#1 [phi:main::@13->main::@12#1] -- register_copy 
    jmp __b12
    // main::@12
  __b12:
    // [27] (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2 -- vbuxx=vbuz1 
    ldx.z ch
    // [28] call keyboard_get_keycode 
    jsr keyboard_get_keycode
    // [29] (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#0
    jmp __b18
    // main::@18
  __b18:
    // [30] (byte) main::key#0 ← (byte) keyboard_get_keycode::return#2
    // [31] if((byte) main::key#0==(byte) $3f) goto main::@13 -- vbuaa_eq_vbuc1_then_la1 
    cmp #$3f
    beq __b13_from___b18
    jmp __b14
    // main::@14
  __b14:
    // [32] (byte) keyboard_key_pressed::key#0 ← (byte) main::key#0 -- vbuxx=vbuaa 
    tax
    // [33] call keyboard_key_pressed 
    jsr keyboard_key_pressed
    // [34] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    jmp __b19
    // main::@19
  __b19:
    // [35] (byte~) main::$14 ← (byte) keyboard_key_pressed::return#2
    // [36] if((byte~) main::$14==(byte) 0) goto main::@13 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b13_from___b19
    jmp __b15
    // main::@15
  __b15:
    // [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2 -- pbuz1_derefidx_vbuz2=vbuz3 
    lda.z ch
    ldy.z i
    sta (screen),y
    // [38] (byte) main::i#1 ← ++ (byte) main::i#3 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [39] phi from main::@15 main::@18 main::@19 to main::@13 [phi:main::@15/main::@18/main::@19->main::@13]
  __b13_from___b15:
  __b13_from___b18:
  __b13_from___b19:
    // [39] phi (byte) main::i#6 = (byte) main::i#1 [phi:main::@15/main::@18/main::@19->main::@13#0] -- register_copy 
    jmp __b13
    // main::@13
  __b13:
    // [40] (byte) main::ch#1 ← ++ (byte) main::ch#2 -- vbuz1=_inc_vbuz1 
    inc.z ch
    // [41] if((byte) main::ch#1!=(byte) $40) goto main::@12 -- vbuz1_neq_vbuc1_then_la1 
    lda #$40
    cmp.z ch
    bne __b12_from___b13
    // [42] phi from main::@13 main::@16 to main::@16 [phi:main::@13/main::@16->main::@16]
  __b16_from___b13:
  __b16_from___b16:
    // [42] phi (byte) main::i#4 = (byte) main::i#6 [phi:main::@13/main::@16->main::@16#0] -- register_copy 
    jmp __b16
  // Add some spaces
    // main::@16
  __b16:
    // [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' -- pbuz1_derefidx_vbuz2=vbuc1 
    lda #' '
    ldy.z i
    sta (screen),y
    // [44] (byte) main::i#2 ← ++ (byte) main::i#4 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [45] if((byte) main::i#2<(byte) 5) goto main::@16 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #5
    bcc __b16_from___b16
    jmp __b4
    // main::@7
  __b7:
    // [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #'1'
    sta (screen),y
    jmp __b8
    // main::@2
  __b2:
    // [47] *((byte*) main::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [48] (byte*) main::sc#1 ← ++ (byte*) main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [5] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [5] phi (byte*) main::sc#2 = (byte*) main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(X) key)
keyboard_key_pressed: {
    // [49] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#0 & (byte) 7 -- vbuyy=vbuxx_band_vbuc1 
    txa
    and #7
    tay
    // [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 -- vbuaa=vbuxx_ror_3 
    txa
    lsr
    lsr
    lsr
    // [51] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuxx=vbuaa 
    tax
    // [52] call keyboard_matrix_read 
    // [57] phi from keyboard_key_pressed to keyboard_matrix_read [phi:keyboard_key_pressed->keyboard_matrix_read]
  keyboard_matrix_read_from_keyboard_key_pressed:
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#0 [phi:keyboard_key_pressed->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // [53] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [54] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // [55] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuyy 
    and keyboard_matrix_col_bitmask,y
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [56] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(X) rowid)
keyboard_matrix_read: {
    // [58] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda keyboard_matrix_row_bitmask,x
    sta CIA1
    // [59] (byte) keyboard_matrix_read::return#0 ← ~ *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B
    eor #$ff
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [60] return 
    rts
}
  // keyboard_get_keycode
// Get the keycode corresponding to a specific screen code character
// ch is the character to get the key code for ($00-$3f)
// Returns the key code corresponding to the passed character. Only characters with a non-shifted key are handled.
// If there is no non-shifted key representing the char $3f is returned (representing RUN/STOP) .
// keyboard_get_keycode(byte register(X) ch)
keyboard_get_keycode: {
    // [61] (byte) keyboard_get_keycode::return#0 ← *((const to_nomodify byte*) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#0) -- vbuaa=pbuc1_derefidx_vbuxx 
    lda keyboard_char_keycodes,x
    jmp __breturn
    // keyboard_get_keycode::@return
  __breturn:
    // [62] return 
    rts
}
  // keyboard_init
// Initialize keyboard reading by setting CIA#$ Data Direction Registers
keyboard_init: {
    // [63] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Write Mode
    lda #$ff
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR
    // [64] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Read Mode
    lda #0
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR
    jmp __breturn
    // keyboard_init::@return
  __breturn:
    // [65] return 
    rts
}
  // File Data
  // Keycodes for each screen code character from $00-$3f.
  // Chars that do not have an unmodified keycode return $3f (representing RUN/STOP).
  keyboard_char_keycodes: .byte KEY_AT, KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, $3f, KEY_POUND, $3f, KEY_ARROW_UP, KEY_ARROW_LEFT, KEY_SPACE, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, KEY_ASTERISK, KEY_PLUS, KEY_COMMA, KEY_MINUS, KEY_DOT, KEY_SLASH, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_COLON, KEY_SEMICOLON, $3f, KEY_EQUALS, $3f, $3f
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b17
Removing instruction jmp __b6
Removing instruction jmp __b9
Removing instruction jmp __b8
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b18
Removing instruction jmp __b14
Removing instruction jmp __b19
Removing instruction jmp __b15
Removing instruction jmp __b13
Removing instruction jmp __b16
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b6_from___b8 with __b6
Replacing label __b5_from___b10 with __b5
Replacing label __b13_from___b18 with __b13
Replacing label __b13_from___b19 with __b13
Replacing label __b12_from___b13 with __b12
Removing instruction __b1_from___bbegin:
Removing instruction __b1:
Removing instruction main_from___b1:
Removing instruction __bend_from___b1:
Removing instruction __b3_from___b1:
Removing instruction __b5_from___b10:
Removing instruction __b6_from___b8:
Removing instruction __b12_from___b13:
Removing instruction __b13_from___b15:
Removing instruction __b13_from___b18:
Removing instruction __b13_from___b19:
Removing instruction __b16_from___b13:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bbegin:
Removing instruction __bend:
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __b5_from___b4:
Removing instruction keyboard_matrix_read_from___b5:
Removing instruction __b17:
Removing instruction __b6_from___b17:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12_from___b11:
Removing instruction __b18:
Removing instruction __b14:
Removing instruction __b19:
Removing instruction __b15:
Removing instruction __b16:
Removing instruction __b1_from___b2:
Removing instruction keyboard_matrix_read_from_keyboard_key_pressed:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Relabelling long label __b16_from___b16 to __b3
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b12
Succesful ASM optimization Pass5NextJumpElimination
Fixing long branch [75] bcc __b2 to bcs
Fixing long branch [81] bcc __b2 to bcs

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const nomodify struct MOS6526_CIA*) CIA1 = (struct MOS6526_CIA*) 56320
(const nomodify byte) KEY_0 = (byte) $23
(const nomodify byte) KEY_1 = (byte) $38
(const nomodify byte) KEY_2 = (byte) $3b
(const nomodify byte) KEY_3 = (byte) 8
(const nomodify byte) KEY_4 = (byte) $b
(const nomodify byte) KEY_5 = (byte) $10
(const nomodify byte) KEY_6 = (byte) $13
(const nomodify byte) KEY_7 = (byte) $18
(const nomodify byte) KEY_8 = (byte) $1b
(const nomodify byte) KEY_9 = (byte) $20
(const nomodify byte) KEY_A = (byte) $a
(const nomodify byte) KEY_ARROW_LEFT = (byte) $39
(const nomodify byte) KEY_ARROW_UP = (byte) $36
(const nomodify byte) KEY_ASTERISK = (byte) $31
(const nomodify byte) KEY_AT = (byte) $2e
(const nomodify byte) KEY_B = (byte) $1c
(const nomodify byte) KEY_C = (byte) $14
(const nomodify byte) KEY_COLON = (byte) $2d
(const nomodify byte) KEY_COMMA = (byte) $2f
(const nomodify byte) KEY_D = (byte) $12
(const nomodify byte) KEY_DOT = (byte) $2c
(const nomodify byte) KEY_E = (byte) $e
(const nomodify byte) KEY_EQUALS = (byte) $35
(const nomodify byte) KEY_F = (byte) $15
(const nomodify byte) KEY_G = (byte) $1a
(const nomodify byte) KEY_H = (byte) $1d
(const nomodify byte) KEY_I = (byte) $21
(const nomodify byte) KEY_J = (byte) $22
(const nomodify byte) KEY_K = (byte) $25
(const nomodify byte) KEY_L = (byte) $2a
(const nomodify byte) KEY_M = (byte) $24
(const nomodify byte) KEY_MINUS = (byte) $2b
(const nomodify byte) KEY_N = (byte) $27
(const nomodify byte) KEY_O = (byte) $26
(const nomodify byte) KEY_P = (byte) $29
(const nomodify byte) KEY_PLUS = (byte) $28
(const nomodify byte) KEY_POUND = (byte) $30
(const nomodify byte) KEY_Q = (byte) $3e
(const nomodify byte) KEY_R = (byte) $11
(const nomodify byte) KEY_S = (byte) $d
(const nomodify byte) KEY_SEMICOLON = (byte) $32
(const nomodify byte) KEY_SLASH = (byte) $37
(const nomodify byte) KEY_SPACE = (byte) $3c
(const nomodify byte) KEY_T = (byte) $16
(const nomodify byte) KEY_U = (byte) $1e
(const nomodify byte) KEY_V = (byte) $1f
(const nomodify byte) KEY_W = (byte) 9
(const nomodify byte) KEY_X = (byte) $17
(const nomodify byte) KEY_Y = (byte) $19
(const nomodify byte) KEY_Z = (byte) $c
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = (byte) 2
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B = (byte) 1
(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR = (byte) 3
(const nomodify byte*) RASTER = (byte*) 53266
(const to_nomodify byte*) keyboard_char_keycodes[]  = { (const nomodify byte) KEY_AT, (const nomodify byte) KEY_A, (const nomodify byte) KEY_B, (const nomodify byte) KEY_C, (const nomodify byte) KEY_D, (const nomodify byte) KEY_E, (const nomodify byte) KEY_F, (const nomodify byte) KEY_G, (const nomodify byte) KEY_H, (const nomodify byte) KEY_I, (const nomodify byte) KEY_J, (const nomodify byte) KEY_K, (const nomodify byte) KEY_L, (const nomodify byte) KEY_M, (const nomodify byte) KEY_N, (const nomodify byte) KEY_O, (const nomodify byte) KEY_P, (const nomodify byte) KEY_Q, (const nomodify byte) KEY_R, (const nomodify byte) KEY_S, (const nomodify byte) KEY_T, (const nomodify byte) KEY_U, (const nomodify byte) KEY_V, (const nomodify byte) KEY_W, (const nomodify byte) KEY_X, (const nomodify byte) KEY_Y, (const nomodify byte) KEY_Z, (byte) $3f, (const nomodify byte) KEY_POUND, (byte) $3f, (const nomodify byte) KEY_ARROW_UP, (const nomodify byte) KEY_ARROW_LEFT, (const nomodify byte) KEY_SPACE, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (byte) $3f, (const nomodify byte) KEY_ASTERISK, (const nomodify byte) KEY_PLUS, (const nomodify byte) KEY_COMMA, (const nomodify byte) KEY_MINUS, (const nomodify byte) KEY_DOT, (const nomodify byte) KEY_SLASH, (const nomodify byte) KEY_0, (const nomodify byte) KEY_1, (const nomodify byte) KEY_2, (const nomodify byte) KEY_3, (const nomodify byte) KEY_4, (const nomodify byte) KEY_5, (const nomodify byte) KEY_6, (const nomodify byte) KEY_7, (const nomodify byte) KEY_8, (const nomodify byte) KEY_9, (const nomodify byte) KEY_COLON, (const nomodify byte) KEY_SEMICOLON, (byte) $3f, (const nomodify byte) KEY_EQUALS, (byte) $3f, (byte) $3f }
(byte()) keyboard_get_keycode((byte) keyboard_get_keycode::ch)
(label) keyboard_get_keycode::@return
(byte) keyboard_get_keycode::ch
(byte) keyboard_get_keycode::ch#0 reg byte x 11002.0
(byte) keyboard_get_keycode::return
(byte) keyboard_get_keycode::return#0 reg byte a 3667.333333333333
(byte) keyboard_get_keycode::return#2 reg byte a 2002.0
(void()) keyboard_init()
(label) keyboard_init::@return
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 reg byte a 20002.0
(label) keyboard_key_pressed::@1
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0 reg byte y 3333.6666666666665
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0 reg byte x 10501.5
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 reg byte a 3667.333333333333
(byte) keyboard_key_pressed::return#2 reg byte a 2002.0
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0 reg byte a 20002.0
(const byte*) keyboard_matrix_col_bitmask[(number) 8]  = { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 reg byte a 27750.75
(byte) keyboard_matrix_read::return#2 reg byte a 20002.0
(byte) keyboard_matrix_read::return#3 reg byte a 2002.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0 reg byte x 20002.0
(byte) keyboard_matrix_read::rowid#1 reg byte x 2002.0
(byte) keyboard_matrix_read::rowid#2 reg byte x 111003.0
(const byte*) keyboard_matrix_row_bitmask[(number) 8]  = { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
(void()) main()
(byte~) main::$14 reg byte a 2002.0
(byte~) main::$4 reg byte a 20002.0
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(byte) main::ch
(byte) main::ch#1 ch zp[1]:7 1501.5
(byte) main::ch#2 ch zp[1]:7 286.0
(byte) main::col
(byte) main::col#1 reg byte y 15001.5
(byte) main::col#2 reg byte y 6667.333333333333
(byte) main::i
(byte) main::i#1 i zp[1]:8 2002.0
(byte) main::i#2 i zp[1]:8 1501.5
(byte) main::i#3 i zp[1]:8 417.08333333333337
(byte) main::i#4 i zp[1]:8 2002.0
(byte) main::i#6 i zp[1]:8 1668.3333333333335
(byte) main::key
(byte) main::key#0 reg byte a 1501.5
(byte) main::row
(byte) main::row#1 row zp[1]:4 1501.5
(byte) main::row#2 row zp[1]:4 214.5
(byte) main::row_pressed_bits
(byte) main::row_pressed_bits#0 reg byte x 2002.0
(byte) main::row_pressed_bits#1 reg byte x 6667.333333333333
(byte) main::row_pressed_bits#2 reg byte x 6200.8
(byte*) main::sc
(byte*) main::sc#1 sc zp[2]:2 202.0
(byte*) main::sc#2 sc zp[2]:2 134.66666666666666
(byte*) main::screen
(byte*) main::screen#1 screen zp[2]:5 701.0
(byte*) main::screen#13 screen zp[2]:5 1692.6153846153845
(byte*) main::screen#2 screen zp[2]:5 100.14285714285714

zp[2]:2 [ main::sc#2 main::sc#1 ]
zp[1]:4 [ main::row#2 main::row#1 ]
zp[2]:5 [ main::screen#13 main::screen#1 main::screen#2 ]
reg byte x [ main::row_pressed_bits#2 main::row_pressed_bits#1 main::row_pressed_bits#0 ]
reg byte y [ main::col#2 main::col#1 ]
zp[1]:7 [ main::ch#2 main::ch#1 ]
zp[1]:8 [ main::i#4 main::i#3 main::i#6 main::i#1 main::i#2 ]
reg byte x [ keyboard_matrix_read::rowid#2 keyboard_matrix_read::rowid#0 keyboard_matrix_read::rowid#1 ]
reg byte a [ keyboard_matrix_read::return#3 ]
reg byte a [ main::$4 ]
reg byte x [ keyboard_get_keycode::ch#0 ]
reg byte a [ keyboard_get_keycode::return#2 ]
reg byte a [ main::key#0 ]
reg byte x [ keyboard_key_pressed::key#0 ]
reg byte a [ keyboard_key_pressed::return#2 ]
reg byte a [ main::$14 ]
reg byte y [ keyboard_key_pressed::colidx#0 ]
reg byte a [ keyboard_key_pressed::rowidx#0 ]
reg byte a [ keyboard_matrix_read::return#2 ]
reg byte a [ keyboard_key_pressed::$2 ]
reg byte a [ keyboard_key_pressed::return#0 ]
reg byte a [ keyboard_matrix_read::return#0 ]
reg byte a [ keyboard_get_keycode::return#0 ]


FINAL ASSEMBLER
Score: 57707

  // File Comments
// Test keyboard input - in the keyboard matrix and mapping screen codes to key codes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const KEY_3 = 8
  .const KEY_W = 9
  .const KEY_A = $a
  .const KEY_4 = $b
  .const KEY_Z = $c
  .const KEY_S = $d
  .const KEY_E = $e
  .const KEY_5 = $10
  .const KEY_R = $11
  .const KEY_D = $12
  .const KEY_6 = $13
  .const KEY_C = $14
  .const KEY_F = $15
  .const KEY_T = $16
  .const KEY_X = $17
  .const KEY_7 = $18
  .const KEY_Y = $19
  .const KEY_G = $1a
  .const KEY_8 = $1b
  .const KEY_B = $1c
  .const KEY_H = $1d
  .const KEY_U = $1e
  .const KEY_V = $1f
  .const KEY_9 = $20
  .const KEY_I = $21
  .const KEY_J = $22
  .const KEY_0 = $23
  .const KEY_M = $24
  .const KEY_K = $25
  .const KEY_O = $26
  .const KEY_N = $27
  .const KEY_PLUS = $28
  .const KEY_P = $29
  .const KEY_L = $2a
  .const KEY_MINUS = $2b
  .const KEY_DOT = $2c
  .const KEY_COLON = $2d
  .const KEY_AT = $2e
  .const KEY_COMMA = $2f
  .const KEY_POUND = $30
  .const KEY_ASTERISK = $31
  .const KEY_SEMICOLON = $32
  .const KEY_EQUALS = $35
  .const KEY_ARROW_UP = $36
  .const KEY_SLASH = $37
  .const KEY_1 = $38
  .const KEY_ARROW_LEFT = $39
  .const KEY_2 = $3b
  .const KEY_SPACE = $3c
  .const KEY_Q = $3e
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR = 2
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR = 3
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
  .label RASTER = $d012
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label sc = 2
    .label screen = 5
    .label row = 4
    .label ch = 7
    // Checks all specific chars $00-$3f
    .label i = 8
    // [5] phi from main to main::@1 [phi:main->main::@1]
    // [5] phi (byte*) main::sc#2 = (byte*) 1024 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z sc
    lda #>$400
    sta.z sc+1
  // Clear screen
    // main::@1
  __b1:
    // for(byte* sc = $400; sc<$400+1000;sc++)
    // [6] if((byte*) main::sc#2<(word)(number) $400+(number) $3e8) goto main::@2 -- pbuz1_lt_vwuc1_then_la1 
    lda.z sc+1
    cmp #>$400+$3e8
    bcs !__b2+
    jmp __b2
  !__b2:
    bne !+
    lda.z sc
    cmp #<$400+$3e8
    bcs !__b2+
    jmp __b2
  !__b2:
  !:
    // [7] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // main::@3
    // keyboard_init()
    // [8] call keyboard_init 
    // Init keyboard
    jsr keyboard_init
    // main::@4
  __b4:
    // while (*RASTER!=$ff)
    // [9] if(*((const nomodify byte*) RASTER)!=(byte) $ff) goto main::@4 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b4
    // [10] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
    // [10] phi (byte*) main::screen#13 = (byte*) 1024 [phi:main::@4->main::@5#0] -- pbuz1=pbuc1 
    lda #<$400
    sta.z screen
    lda #>$400
    sta.z screen+1
    // [10] phi (byte) main::row#2 = (byte) 0 [phi:main::@4->main::@5#1] -- vbuz1=vbuc1 
    lda #0
    sta.z row
  // Read & print keyboard matrix
    // [10] phi from main::@10 to main::@5 [phi:main::@10->main::@5]
    // [10] phi (byte*) main::screen#13 = (byte*) main::screen#1 [phi:main::@10->main::@5#0] -- register_copy 
    // [10] phi (byte) main::row#2 = (byte) main::row#1 [phi:main::@10->main::@5#1] -- register_copy 
    // main::@5
  __b5:
    // keyboard_matrix_read(row)
    // [11] (byte) keyboard_matrix_read::rowid#1 ← (byte) main::row#2 -- vbuxx=vbuz1 
    ldx.z row
    // [12] call keyboard_matrix_read 
    // [57] phi from main::@5 to keyboard_matrix_read [phi:main::@5->keyboard_matrix_read]
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#1 [phi:main::@5->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // keyboard_matrix_read(row)
    // [13] (byte) keyboard_matrix_read::return#3 ← (byte) keyboard_matrix_read::return#0
    // main::@17
    // row_pressed_bits = keyboard_matrix_read(row)
    // [14] (byte) main::row_pressed_bits#0 ← (byte) keyboard_matrix_read::return#3 -- vbuxx=vbuaa 
    tax
    // [15] phi from main::@17 to main::@6 [phi:main::@17->main::@6]
    // [15] phi (byte) main::col#2 = (byte) 0 [phi:main::@17->main::@6#0] -- vbuyy=vbuc1 
    ldy #0
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#0 [phi:main::@17->main::@6#1] -- register_copy 
    // [15] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
    // [15] phi (byte) main::col#2 = (byte) main::col#1 [phi:main::@8->main::@6#0] -- register_copy 
    // [15] phi (byte) main::row_pressed_bits#2 = (byte) main::row_pressed_bits#1 [phi:main::@8->main::@6#1] -- register_copy 
    // main::@6
  __b6:
    // row_pressed_bits & $80
    // [16] (byte~) main::$4 ← (byte) main::row_pressed_bits#2 & (byte) $80 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #$80
    // if( (row_pressed_bits & $80) != 0)
    // [17] if((byte~) main::$4!=(byte) 0) goto main::@7 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b7
    // main::@9
    // screen[col] = '0'
    // [18] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '0' -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #'0'
    sta (screen),y
    // main::@8
  __b8:
    // row_pressed_bits = row_pressed_bits * 2
    // [19] (byte) main::row_pressed_bits#1 ← (byte) main::row_pressed_bits#2 << (byte) 1 -- vbuxx=vbuxx_rol_1 
    txa
    asl
    tax
    // for(byte col : 0..7)
    // [20] (byte) main::col#1 ← ++ (byte) main::col#2 -- vbuyy=_inc_vbuyy 
    iny
    // [21] if((byte) main::col#1!=(byte) 8) goto main::@6 -- vbuyy_neq_vbuc1_then_la1 
    cpy #8
    bne __b6
    // main::@10
    // screen = screen + 40
    // [22] (byte*) main::screen#1 ← (byte*) main::screen#13 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // for(byte row : 0..7)
    // [23] (byte) main::row#1 ← ++ (byte) main::row#2 -- vbuz1=_inc_vbuz1 
    inc.z row
    // [24] if((byte) main::row#1!=(byte) 8) goto main::@5 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z row
    bne __b5
    // main::@11
    // screen = screen + 40
    // [25] (byte*) main::screen#2 ← (byte*) main::screen#1 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [26] phi from main::@11 to main::@12 [phi:main::@11->main::@12]
    // [26] phi (byte) main::i#3 = (byte) 0 [phi:main::@11->main::@12#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [26] phi (byte) main::ch#2 = (byte) 0 [phi:main::@11->main::@12#1] -- vbuz1=vbuc1 
    sta.z ch
    // [26] phi from main::@13 to main::@12 [phi:main::@13->main::@12]
    // [26] phi (byte) main::i#3 = (byte) main::i#6 [phi:main::@13->main::@12#0] -- register_copy 
    // [26] phi (byte) main::ch#2 = (byte) main::ch#1 [phi:main::@13->main::@12#1] -- register_copy 
    // main::@12
  __b12:
    // keyboard_get_keycode(ch)
    // [27] (byte) keyboard_get_keycode::ch#0 ← (byte) main::ch#2 -- vbuxx=vbuz1 
    ldx.z ch
    // [28] call keyboard_get_keycode 
    jsr keyboard_get_keycode
    // [29] (byte) keyboard_get_keycode::return#2 ← (byte) keyboard_get_keycode::return#0
    // main::@18
    // key = keyboard_get_keycode(ch)
    // [30] (byte) main::key#0 ← (byte) keyboard_get_keycode::return#2
    // if(key!=$3f)
    // [31] if((byte) main::key#0==(byte) $3f) goto main::@13 -- vbuaa_eq_vbuc1_then_la1 
    cmp #$3f
    beq __b13
    // main::@14
    // keyboard_key_pressed(key)
    // [32] (byte) keyboard_key_pressed::key#0 ← (byte) main::key#0 -- vbuxx=vbuaa 
    tax
    // [33] call keyboard_key_pressed 
    jsr keyboard_key_pressed
    // [34] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    // main::@19
    // [35] (byte~) main::$14 ← (byte) keyboard_key_pressed::return#2
    // if(keyboard_key_pressed(key)!=0)
    // [36] if((byte~) main::$14==(byte) 0) goto main::@13 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b13
    // main::@15
    // screen[i++] = ch
    // [37] *((byte*) main::screen#2 + (byte) main::i#3) ← (byte) main::ch#2 -- pbuz1_derefidx_vbuz2=vbuz3 
    lda.z ch
    ldy.z i
    sta (screen),y
    // screen[i++] = ch;
    // [38] (byte) main::i#1 ← ++ (byte) main::i#3 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [39] phi from main::@15 main::@18 main::@19 to main::@13 [phi:main::@15/main::@18/main::@19->main::@13]
    // [39] phi (byte) main::i#6 = (byte) main::i#1 [phi:main::@15/main::@18/main::@19->main::@13#0] -- register_copy 
    // main::@13
  __b13:
    // for( byte ch : 0..$3f )
    // [40] (byte) main::ch#1 ← ++ (byte) main::ch#2 -- vbuz1=_inc_vbuz1 
    inc.z ch
    // [41] if((byte) main::ch#1!=(byte) $40) goto main::@12 -- vbuz1_neq_vbuc1_then_la1 
    lda #$40
    cmp.z ch
    bne __b12
    // [42] phi from main::@13 main::@16 to main::@16 [phi:main::@13/main::@16->main::@16]
  __b3:
    // [42] phi (byte) main::i#4 = (byte) main::i#6 [phi:main::@13/main::@16->main::@16#0] -- register_copy 
  // Add some spaces
    // main::@16
    // screen[i++] = ' '
    // [43] *((byte*) main::screen#2 + (byte) main::i#4) ← (byte) ' ' -- pbuz1_derefidx_vbuz2=vbuc1 
    lda #' '
    ldy.z i
    sta (screen),y
    // screen[i++] = ' ';
    // [44] (byte) main::i#2 ← ++ (byte) main::i#4 -- vbuz1=_inc_vbuz1 
    inc.z i
    // while (i<5)
    // [45] if((byte) main::i#2<(byte) 5) goto main::@16 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #5
    bcc __b3
    jmp __b4
    // main::@7
  __b7:
    // screen[col] = '1'
    // [46] *((byte*) main::screen#13 + (byte) main::col#2) ← (byte) '1' -- pbuz1_derefidx_vbuyy=vbuc1 
    lda #'1'
    sta (screen),y
    jmp __b8
    // main::@2
  __b2:
    // *sc = ' '
    // [47] *((byte*) main::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // for(byte* sc = $400; sc<$400+1000;sc++)
    // [48] (byte*) main::sc#1 ← ++ (byte*) main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [5] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [5] phi (byte*) main::sc#2 = (byte*) main::sc#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
// keyboard_key_pressed(byte register(X) key)
keyboard_key_pressed: {
    // colidx = key&7
    // [49] (byte) keyboard_key_pressed::colidx#0 ← (byte) keyboard_key_pressed::key#0 & (byte) 7 -- vbuyy=vbuxx_band_vbuc1 
    txa
    and #7
    tay
    // rowidx = key>>3
    // [50] (byte) keyboard_key_pressed::rowidx#0 ← (byte) keyboard_key_pressed::key#0 >> (byte) 3 -- vbuaa=vbuxx_ror_3 
    txa
    lsr
    lsr
    lsr
    // keyboard_matrix_read(rowidx)
    // [51] (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0 -- vbuxx=vbuaa 
    tax
    // [52] call keyboard_matrix_read 
    // [57] phi from keyboard_key_pressed to keyboard_matrix_read [phi:keyboard_key_pressed->keyboard_matrix_read]
    // [57] phi (byte) keyboard_matrix_read::rowid#2 = (byte) keyboard_matrix_read::rowid#0 [phi:keyboard_key_pressed->keyboard_matrix_read#0] -- register_copy 
    jsr keyboard_matrix_read
    // keyboard_matrix_read(rowidx)
    // [53] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    // keyboard_key_pressed::@1
    // [54] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // keyboard_matrix_read(rowidx) & keyboard_matrix_col_bitmask[colidx]
    // [55] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band_pbuc1_derefidx_vbuyy 
    and keyboard_matrix_col_bitmask,y
    // keyboard_key_pressed::@return
    // }
    // [56] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
// keyboard_matrix_read(byte register(X) rowid)
keyboard_matrix_read: {
    // CIA1->PORT_A = keyboard_matrix_row_bitmask[rowid]
    // [58] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#2) -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda keyboard_matrix_row_bitmask,x
    sta CIA1
    // ~CIA1->PORT_B
    // [59] (byte) keyboard_matrix_read::return#0 ← ~ *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B
    eor #$ff
    // keyboard_matrix_read::@return
    // }
    // [60] return 
    rts
}
  // keyboard_get_keycode
// Get the keycode corresponding to a specific screen code character
// ch is the character to get the key code for ($00-$3f)
// Returns the key code corresponding to the passed character. Only characters with a non-shifted key are handled.
// If there is no non-shifted key representing the char $3f is returned (representing RUN/STOP) .
// keyboard_get_keycode(byte register(X) ch)
keyboard_get_keycode: {
    // return keyboard_char_keycodes[ch];
    // [61] (byte) keyboard_get_keycode::return#0 ← *((const to_nomodify byte*) keyboard_char_keycodes + (byte) keyboard_get_keycode::ch#0) -- vbuaa=pbuc1_derefidx_vbuxx 
    lda keyboard_char_keycodes,x
    // keyboard_get_keycode::@return
    // }
    // [62] return 
    rts
}
  // keyboard_init
// Initialize keyboard reading by setting CIA#$ Data Direction Registers
keyboard_init: {
    // CIA1->PORT_A_DDR = $ff
    // [63] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Write Mode
    lda #$ff
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_A_DDR
    // CIA1->PORT_B_DDR = $00
    // [64] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Keyboard Matrix Columns Read Mode
    lda #0
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B_DDR
    // keyboard_init::@return
    // }
    // [65] return 
    rts
}
  // File Data
  // Keycodes for each screen code character from $00-$3f.
  // Chars that do not have an unmodified keycode return $3f (representing RUN/STOP).
  keyboard_char_keycodes: .byte KEY_AT, KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, $3f, KEY_POUND, $3f, KEY_ARROW_UP, KEY_ARROW_LEFT, KEY_SPACE, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, KEY_ASTERISK, KEY_PLUS, KEY_COMMA, KEY_MINUS, KEY_DOT, KEY_SLASH, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_COLON, KEY_SEMICOLON, $3f, KEY_EQUALS, $3f, $3f
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80

