Inlined call vicSelectGfxBank::$0 = call toDd00 vicSelectGfxBank::gfx 
Inlined call call plexSetScreen plexInit::screen 
Inlined call call plexFreePrepare 
Inlined call call plexFreeAdd plexShowSprite::ypos 
Inlined call call mulf8s_prepare mulf8s::a 
Inlined call loop::$13 = call plexFreeNextYpos 
Inlined call call __init 

CONTROL FLOW GRAPH SSA

void plexInit(byte* plexInit::screen)
plexInit: scope:[plexInit]  from init
  plexInit::screen#1 = phi( init/plexInit::screen#0 )
  plexInit::plexSetScreen1_screen#0 = plexInit::screen#1
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  plexInit::plexSetScreen1_screen#1 = phi( plexInit/plexInit::plexSetScreen1_screen#0 )
  plexInit::plexSetScreen1_$0 = plexInit::plexSetScreen1_screen#1 + $3f8
  PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0
  to:plexInit::@2
plexInit::@2: scope:[plexInit]  from plexInit::plexSetScreen1
  plexInit::i#0 = 0
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::@2
  plexInit::i#2 = phi( plexInit::@1/plexInit::i#1, plexInit::@2/plexInit::i#0 )
  PLEX_SORTED_IDX[plexInit::i#2] = plexInit::i#2
  plexInit::i#1 = plexInit::i#2 + rangenext(0,PLEX_COUNT-1)
  plexInit::$1 = plexInit::i#1 != rangelast(0,PLEX_COUNT-1)
  if(plexInit::$1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  return 
  to:@return

void plexSort()
plexSort: scope:[plexSort]  from loop::@5
  plexSort::m#0 = 0
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  plexSort::m#2 = phi( plexSort/plexSort::m#0, plexSort::@2/plexSort::m#1 )
  plexSort::$1 = plexSort::m#2 + 1
  plexSort::nxt_idx#0 = PLEX_SORTED_IDX[plexSort::$1]
  plexSort::nxt_y#0 = PLEX_YPOS[plexSort::nxt_idx#0]
  plexSort::$2 = plexSort::nxt_y#0 < PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]
  plexSort::$3 = ! plexSort::$2
  if(plexSort::$3) goto plexSort::@2
  to:plexSort::@5
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  plexSort::m#3 = phi( plexSort::@1/plexSort::m#2, plexSort::@4/plexSort::m#5 )
  plexSort::m#1 = plexSort::m#3 + rangenext(0,PLEX_COUNT-2)
  plexSort::$8 = plexSort::m#1 != rangelast(0,PLEX_COUNT-2)
  if(plexSort::$8) goto plexSort::@1
  to:plexSort::@6
plexSort::@5: scope:[plexSort]  from plexSort::@1
  plexSort::nxt_idx#3 = phi( plexSort::@1/plexSort::nxt_idx#0 )
  plexSort::nxt_y#2 = phi( plexSort::@1/plexSort::nxt_y#0 )
  plexSort::m#4 = phi( plexSort::@1/plexSort::m#2 )
  plexSort::s#0 = plexSort::m#4
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@3 plexSort::@5
  plexSort::m#6 = phi( plexSort::@3/plexSort::m#6, plexSort::@5/plexSort::m#4 )
  plexSort::nxt_idx#2 = phi( plexSort::@3/plexSort::nxt_idx#2, plexSort::@5/plexSort::nxt_idx#3 )
  plexSort::nxt_y#1 = phi( plexSort::@3/plexSort::nxt_y#1, plexSort::@5/plexSort::nxt_y#2 )
  plexSort::s#3 = phi( plexSort::@3/plexSort::s#1, plexSort::@5/plexSort::s#0 )
  plexSort::$4 = plexSort::s#3 + 1
  PLEX_SORTED_IDX[plexSort::$4] = PLEX_SORTED_IDX[plexSort::s#3]
  plexSort::s#1 = -- plexSort::s#3
  plexSort::$5 = plexSort::s#1 != $ff
  plexSort::$6 = plexSort::nxt_y#1 < PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]
  plexSort::$7 = plexSort::$5 && plexSort::$6
  if(plexSort::$7) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3
  plexSort::m#5 = phi( plexSort::@3/plexSort::m#6 )
  plexSort::nxt_idx#1 = phi( plexSort::@3/plexSort::nxt_idx#2 )
  plexSort::s#4 = phi( plexSort::@3/plexSort::s#1 )
  plexSort::s#2 = ++ plexSort::s#4
  PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#1
  to:plexSort::@2
plexSort::@6: scope:[plexSort]  from plexSort::@2
  plex_show_idx = 0
  plex_sprite_idx = 0
  plex_sprite_msb = 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  plexSort::plexFreePrepare1_s#0 = 0
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  plexSort::plexFreePrepare1_s#2 = phi( plexSort::plexFreePrepare1/plexSort::plexFreePrepare1_s#0, plexSort::plexFreePrepare1_@1/plexSort::plexFreePrepare1_s#1 )
  PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0
  plexSort::plexFreePrepare1_s#1 = plexSort::plexFreePrepare1_s#2 + rangenext(0,7)
  plexSort::plexFreePrepare1_$0 = plexSort::plexFreePrepare1_s#1 != rangelast(0,7)
  if(plexSort::plexFreePrepare1_$0) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  plex_free_next = 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  return 
  to:@return

void plexShowSprite()
plexShowSprite: scope:[plexShowSprite]  from loop::@10
  plexShowSprite::$0 = plex_sprite_idx * 2
  plexShowSprite::plex_sprite_idx2#0 = plexShowSprite::$0
  plexShowSprite::ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]]
  SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::ypos#0
  plexShowSprite::plexFreeAdd1_ypos#0 = plexShowSprite::ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  plexShowSprite::plex_sprite_idx2#2 = phi( plexShowSprite/plexShowSprite::plex_sprite_idx2#0 )
  plexShowSprite::plexFreeAdd1_ypos#1 = phi( plexShowSprite/plexShowSprite::plexFreeAdd1_ypos#0 )
  plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#1 + $15
  PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0
  plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1
  plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7
  plex_free_next = plexShowSprite::plexFreeAdd1_$2
  to:plexShowSprite::@5
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  plexShowSprite::plex_sprite_idx2#1 = phi( plexShowSprite::plexFreeAdd1/plexShowSprite::plex_sprite_idx2#2 )
  PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]]
  plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx]
  plexShowSprite::$10 = plexShowSprite::xpos_idx#0 * SIZEOF_WORD
  plexShowSprite::$2 = < PLEX_XPOS[plexShowSprite::$10]
  SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#1] = plexShowSprite::$2
  plexShowSprite::$11 = plexShowSprite::xpos_idx#0 * SIZEOF_WORD
  plexShowSprite::$3 = > PLEX_XPOS[plexShowSprite::$11]
  plexShowSprite::$4 = plexShowSprite::$3 != 0
  if(plexShowSprite::$4) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@5
  *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb
  to:plexShowSprite::@2
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@5
  plexShowSprite::$9 = $ff ^ plex_sprite_msb
  *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  plexShowSprite::$5 = plex_sprite_idx + 1
  plexShowSprite::$6 = plexShowSprite::$5 & 7
  plex_sprite_idx = plexShowSprite::$6
  plex_show_idx = ++ plex_show_idx
  plex_sprite_msb = plex_sprite_msb << 1
  plexShowSprite::$7 = plex_sprite_msb == 0
  plexShowSprite::$8 = ! plexShowSprite::$7
  if(plexShowSprite::$8) goto plexShowSprite::@return
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@2
  plex_sprite_msb = 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@4
  return 
  to:@return

void mulf_init()
mulf_init: scope:[mulf_init]  from init::@4
  mulf_init::sqr#0 = 0
  mulf_init::x_2#0 = 0
  mulf_init::c#0 = 0
  mulf_init::sqr1_hi#0 = mulf_sqr1_hi+1
  mulf_init::sqr1_lo#0 = mulf_sqr1_lo+1
  to:mulf_init::@1
mulf_init::@1: scope:[mulf_init]  from mulf_init mulf_init::@4
  mulf_init::x_2#5 = phi( mulf_init/mulf_init::x_2#0, mulf_init::@4/mulf_init::x_2#2 )
  mulf_init::sqr1_hi#5 = phi( mulf_init/mulf_init::sqr1_hi#0, mulf_init::@4/mulf_init::sqr1_hi#1 )
  mulf_init::sqr#6 = phi( mulf_init/mulf_init::sqr#0, mulf_init::@4/mulf_init::sqr#1 )
  mulf_init::c#3 = phi( mulf_init/mulf_init::c#0, mulf_init::@4/mulf_init::c#4 )
  mulf_init::sqr1_lo#2 = phi( mulf_init/mulf_init::sqr1_lo#0, mulf_init::@4/mulf_init::sqr1_lo#1 )
  mulf_init::$0 = mulf_init::sqr1_lo#2 != mulf_sqr1_lo+$200
  if(mulf_init::$0) goto mulf_init::@2
  to:mulf_init::@3
mulf_init::@2: scope:[mulf_init]  from mulf_init::@1
  mulf_init::x_2#4 = phi( mulf_init::@1/mulf_init::x_2#5 )
  mulf_init::sqr1_hi#3 = phi( mulf_init::@1/mulf_init::sqr1_hi#5 )
  mulf_init::sqr1_lo#4 = phi( mulf_init::@1/mulf_init::sqr1_lo#2 )
  mulf_init::sqr#5 = phi( mulf_init::@1/mulf_init::sqr#6 )
  mulf_init::c#2 = phi( mulf_init::@1/mulf_init::c#3 )
  mulf_init::c#1 = ++ mulf_init::c#2
  mulf_init::$1 = mulf_init::c#1 & 1
  mulf_init::$2 = mulf_init::$1 == 0
  mulf_init::$3 = ! mulf_init::$2
  if(mulf_init::$3) goto mulf_init::@4
  to:mulf_init::@5
mulf_init::@3: scope:[mulf_init]  from mulf_init::@1
  mulf_init::x_255#0 = (byte)-1
  mulf_init::dir#0 = $ff
  mulf_init::sqr2_hi#0 = mulf_sqr2_hi
  mulf_init::sqr2_lo#0 = mulf_sqr2_lo
  to:mulf_init::@6
mulf_init::@4: scope:[mulf_init]  from mulf_init::@2 mulf_init::@5
  mulf_init::c#4 = phi( mulf_init::@2/mulf_init::c#1, mulf_init::@5/mulf_init::c#5 )
  mulf_init::x_2#2 = phi( mulf_init::@2/mulf_init::x_2#4, mulf_init::@5/mulf_init::x_2#1 )
  mulf_init::sqr1_hi#2 = phi( mulf_init::@2/mulf_init::sqr1_hi#3, mulf_init::@5/mulf_init::sqr1_hi#4 )
  mulf_init::sqr1_lo#3 = phi( mulf_init::@2/mulf_init::sqr1_lo#4, mulf_init::@5/mulf_init::sqr1_lo#5 )
  mulf_init::sqr#3 = phi( mulf_init::@2/mulf_init::sqr#5, mulf_init::@5/mulf_init::sqr#2 )
  mulf_init::$4 = < mulf_init::sqr#3
  *mulf_init::sqr1_lo#3 = mulf_init::$4
  mulf_init::$5 = > mulf_init::sqr#3
  *mulf_init::sqr1_hi#2 = mulf_init::$5
  mulf_init::sqr1_hi#1 = ++ mulf_init::sqr1_hi#2
  mulf_init::$6 = mulf_init::sqr#3 + mulf_init::x_2#2
  mulf_init::sqr#1 = mulf_init::$6
  mulf_init::sqr1_lo#1 = ++ mulf_init::sqr1_lo#3
  to:mulf_init::@1
mulf_init::@5: scope:[mulf_init]  from mulf_init::@2
  mulf_init::c#5 = phi( mulf_init::@2/mulf_init::c#1 )
  mulf_init::sqr1_hi#4 = phi( mulf_init::@2/mulf_init::sqr1_hi#3 )
  mulf_init::sqr1_lo#5 = phi( mulf_init::@2/mulf_init::sqr1_lo#4 )
  mulf_init::sqr#4 = phi( mulf_init::@2/mulf_init::sqr#5 )
  mulf_init::x_2#3 = phi( mulf_init::@2/mulf_init::x_2#4 )
  mulf_init::x_2#1 = ++ mulf_init::x_2#3
  mulf_init::sqr#2 = ++ mulf_init::sqr#4
  to:mulf_init::@4
mulf_init::@6: scope:[mulf_init]  from mulf_init::@3 mulf_init::@9
  mulf_init::dir#3 = phi( mulf_init::@3/mulf_init::dir#0, mulf_init::@9/mulf_init::dir#4 )
  mulf_init::sqr2_hi#3 = phi( mulf_init::@3/mulf_init::sqr2_hi#0, mulf_init::@9/mulf_init::sqr2_hi#4 )
  mulf_init::x_255#3 = phi( mulf_init::@3/mulf_init::x_255#0, mulf_init::@9/mulf_init::x_255#4 )
  mulf_init::sqr2_lo#2 = phi( mulf_init::@3/mulf_init::sqr2_lo#0, mulf_init::@9/mulf_init::sqr2_lo#1 )
  mulf_init::$7 = mulf_init::sqr2_lo#2 != mulf_sqr2_lo+$1ff
  if(mulf_init::$7) goto mulf_init::@7
  to:mulf_init::@8
mulf_init::@7: scope:[mulf_init]  from mulf_init::@6
  mulf_init::dir#2 = phi( mulf_init::@6/mulf_init::dir#3 )
  mulf_init::sqr2_hi#2 = phi( mulf_init::@6/mulf_init::sqr2_hi#3 )
  mulf_init::sqr2_lo#3 = phi( mulf_init::@6/mulf_init::sqr2_lo#2 )
  mulf_init::x_255#2 = phi( mulf_init::@6/mulf_init::x_255#3 )
  *mulf_init::sqr2_lo#3 = mulf_sqr1_lo[mulf_init::x_255#2]
  *mulf_init::sqr2_hi#2 = mulf_sqr1_hi[mulf_init::x_255#2]
  mulf_init::sqr2_hi#1 = ++ mulf_init::sqr2_hi#2
  mulf_init::$8 = mulf_init::x_255#2 + mulf_init::dir#2
  mulf_init::x_255#1 = mulf_init::$8
  mulf_init::$9 = mulf_init::x_255#1 == 0
  mulf_init::$10 = ! mulf_init::$9
  if(mulf_init::$10) goto mulf_init::@9
  to:mulf_init::@10
mulf_init::@8: scope:[mulf_init]  from mulf_init::@6
  *(mulf_sqr2_lo+$1ff) = *(mulf_sqr1_lo+$100)
  *(mulf_sqr2_hi+$1ff) = *(mulf_sqr1_hi+$100)
  to:mulf_init::@return
mulf_init::@9: scope:[mulf_init]  from mulf_init::@10 mulf_init::@7
  mulf_init::dir#4 = phi( mulf_init::@10/mulf_init::dir#1, mulf_init::@7/mulf_init::dir#2 )
  mulf_init::sqr2_hi#4 = phi( mulf_init::@10/mulf_init::sqr2_hi#5, mulf_init::@7/mulf_init::sqr2_hi#1 )
  mulf_init::x_255#4 = phi( mulf_init::@10/mulf_init::x_255#5, mulf_init::@7/mulf_init::x_255#1 )
  mulf_init::sqr2_lo#4 = phi( mulf_init::@10/mulf_init::sqr2_lo#5, mulf_init::@7/mulf_init::sqr2_lo#3 )
  mulf_init::sqr2_lo#1 = ++ mulf_init::sqr2_lo#4
  to:mulf_init::@6
mulf_init::@10: scope:[mulf_init]  from mulf_init::@7
  mulf_init::sqr2_hi#5 = phi( mulf_init::@7/mulf_init::sqr2_hi#1 )
  mulf_init::x_255#5 = phi( mulf_init::@7/mulf_init::x_255#1 )
  mulf_init::sqr2_lo#5 = phi( mulf_init::@7/mulf_init::sqr2_lo#3 )
  mulf_init::dir#1 = 1
  to:mulf_init::@9
mulf_init::@return: scope:[mulf_init]  from mulf_init::@8
  return 
  to:@return

void mulf8u_prepare(byte mulf8u_prepare::a)
mulf8u_prepare: scope:[mulf8u_prepare]  from mulf8s::mulf8s_prepare1
  mulf8u_prepare::a#1 = phi( mulf8s::mulf8s_prepare1/mulf8u_prepare::a#0 )
  *mulf8u_prepare::memA = mulf8u_prepare::a#1
  asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
  to:mulf8u_prepare::@return
mulf8u_prepare::@return: scope:[mulf8u_prepare]  from mulf8u_prepare
  return 
  to:@return

word mulf8u_prepared(byte mulf8u_prepared::b)
mulf8u_prepared: scope:[mulf8u_prepared]  from mulf8s_prepared
  mulf8u_prepared::b#1 = phi( mulf8s_prepared/mulf8u_prepared::b#0 )
  *mulf8u_prepared::memB = mulf8u_prepared::b#1
  asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
  mulf8u_prepared::return#0 = ((word)) { *mulf8u_prepared::memB, *mulf8u_prepared::resL }
  to:mulf8u_prepared::@return
mulf8u_prepared::@return: scope:[mulf8u_prepared]  from mulf8u_prepared
  mulf8u_prepared::return#3 = phi( mulf8u_prepared/mulf8u_prepared::return#0 )
  mulf8u_prepared::return#1 = mulf8u_prepared::return#3
  return 
  to:@return

signed word mulf8s_prepared(signed byte mulf8s_prepared::b)
mulf8s_prepared: scope:[mulf8s_prepared]  from mulf8s::@1
  mulf8s_prepared::b#1 = phi( mulf8s::@1/mulf8s_prepared::b#0 )
  mulf8u_prepared::b#0 = (byte)mulf8s_prepared::b#1
  call mulf8u_prepared 
  mulf8u_prepared::return#2 = mulf8u_prepared::return#1
  to:mulf8s_prepared::@5
mulf8s_prepared::@5: scope:[mulf8s_prepared]  from mulf8s_prepared
  mulf8s_prepared::b#4 = phi( mulf8s_prepared/mulf8s_prepared::b#1 )
  mulf8u_prepared::return#4 = phi( mulf8s_prepared/mulf8u_prepared::return#2 )
  mulf8s_prepared::$0 = mulf8u_prepared::return#4
  mulf8s_prepared::m#0 = mulf8s_prepared::$0
  mulf8s_prepared::$1 = *mulf8s_prepared::memA < 0
  mulf8s_prepared::$2 = ! mulf8s_prepared::$1
  if(mulf8s_prepared::$2) goto mulf8s_prepared::@1
  to:mulf8s_prepared::@3
mulf8s_prepared::@1: scope:[mulf8s_prepared]  from mulf8s_prepared::@3 mulf8s_prepared::@5
  mulf8s_prepared::m#6 = phi( mulf8s_prepared::@3/mulf8s_prepared::m#1, mulf8s_prepared::@5/mulf8s_prepared::m#0 )
  mulf8s_prepared::b#2 = phi( mulf8s_prepared::@3/mulf8s_prepared::b#3, mulf8s_prepared::@5/mulf8s_prepared::b#4 )
  mulf8s_prepared::$3 = mulf8s_prepared::b#2 < 0
  mulf8s_prepared::$4 = ! mulf8s_prepared::$3
  if(mulf8s_prepared::$4) goto mulf8s_prepared::@2
  to:mulf8s_prepared::@4
mulf8s_prepared::@3: scope:[mulf8s_prepared]  from mulf8s_prepared::@5
  mulf8s_prepared::b#3 = phi( mulf8s_prepared::@5/mulf8s_prepared::b#4 )
  mulf8s_prepared::m#3 = phi( mulf8s_prepared::@5/mulf8s_prepared::m#0 )
  mulf8s_prepared::$6 = > mulf8s_prepared::m#3
  mulf8s_prepared::$13 = (byte)mulf8s_prepared::b#3
  mulf8s_prepared::$7 = mulf8s_prepared::$6 - mulf8s_prepared::$13
  mulf8s_prepared::$11 = mulf8s_prepared::$7
  mulf8s_prepared::m#1 = mulf8s_prepared::m#3 hi= mulf8s_prepared::$11
  to:mulf8s_prepared::@1
mulf8s_prepared::@2: scope:[mulf8s_prepared]  from mulf8s_prepared::@1 mulf8s_prepared::@4
  mulf8s_prepared::m#4 = phi( mulf8s_prepared::@1/mulf8s_prepared::m#6, mulf8s_prepared::@4/mulf8s_prepared::m#2 )
  mulf8s_prepared::return#0 = (signed word)mulf8s_prepared::m#4
  to:mulf8s_prepared::@return
mulf8s_prepared::@4: scope:[mulf8s_prepared]  from mulf8s_prepared::@1
  mulf8s_prepared::m#5 = phi( mulf8s_prepared::@1/mulf8s_prepared::m#6 )
  mulf8s_prepared::$9 = > mulf8s_prepared::m#5
  mulf8s_prepared::$14 = (byte)*mulf8s_prepared::memA
  mulf8s_prepared::$10 = mulf8s_prepared::$9 - mulf8s_prepared::$14
  mulf8s_prepared::$12 = mulf8s_prepared::$10
  mulf8s_prepared::m#2 = mulf8s_prepared::m#5 hi= mulf8s_prepared::$12
  to:mulf8s_prepared::@2
mulf8s_prepared::@return: scope:[mulf8s_prepared]  from mulf8s_prepared::@2
  mulf8s_prepared::return#3 = phi( mulf8s_prepared::@2/mulf8s_prepared::return#0 )
  mulf8s_prepared::return#1 = mulf8s_prepared::return#3
  return 
  to:@return

signed word mulf8s(signed byte mulf8s::a , signed byte mulf8s::b)
mulf8s: scope:[mulf8s]  from loop::@13 loop::@4
  mulf8s::b#5 = phi( loop::@13/mulf8s::b#1, loop::@4/mulf8s::b#0 )
  mulf8s::a#2 = phi( loop::@13/mulf8s::a#1, loop::@4/mulf8s::a#0 )
  mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#2
  to:mulf8s::mulf8s_prepare1
mulf8s::mulf8s_prepare1: scope:[mulf8s]  from mulf8s
  mulf8s::b#4 = phi( mulf8s/mulf8s::b#5 )
  mulf8s::mulf8s_prepare1_a#1 = phi( mulf8s/mulf8s::mulf8s_prepare1_a#0 )
  mulf8u_prepare::a#0 = (byte)mulf8s::mulf8s_prepare1_a#1
  call mulf8u_prepare 
  to:mulf8s::@2
mulf8s::@2: scope:[mulf8s]  from mulf8s::mulf8s_prepare1
  mulf8s::b#3 = phi( mulf8s::mulf8s_prepare1/mulf8s::b#4 )
  to:mulf8s::@1
mulf8s::@1: scope:[mulf8s]  from mulf8s::@2
  mulf8s::b#2 = phi( mulf8s::@2/mulf8s::b#3 )
  mulf8s_prepared::b#0 = mulf8s::b#2
  call mulf8s_prepared 
  mulf8s_prepared::return#2 = mulf8s_prepared::return#1
  to:mulf8s::@3
mulf8s::@3: scope:[mulf8s]  from mulf8s::@1
  mulf8s_prepared::return#4 = phi( mulf8s::@1/mulf8s_prepared::return#2 )
  mulf8s::$1 = mulf8s_prepared::return#4
  mulf8s::return#0 = mulf8s::$1
  to:mulf8s::@return
mulf8s::@return: scope:[mulf8s]  from mulf8s::@3
  mulf8s::return#4 = phi( mulf8s::@3/mulf8s::return#0 )
  mulf8s::return#1 = mulf8s::return#4
  return 
  to:@return

void* memset(void* memset::str , byte memset::c , word memset::num)
memset: scope:[memset]  from init::@6
  memset::c#4 = phi( init::@6/memset::c#0 )
  memset::str#3 = phi( init::@6/memset::str#0 )
  memset::num#1 = phi( init::@6/memset::num#0 )
  memset::$0 = memset::num#1 > 0
  memset::$1 = ! memset::$0
  if(memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@3
  memset::str#1 = phi( memset/memset::str#3, memset::@3/memset::str#4 )
  memset::return#0 = memset::str#1
  to:memset::@return
memset::@2: scope:[memset]  from memset
  memset::c#3 = phi( memset/memset::c#4 )
  memset::num#2 = phi( memset/memset::num#1 )
  memset::str#2 = phi( memset/memset::str#3 )
  memset::$4 = (byte*)memset::str#2
  memset::$2 = memset::$4 + memset::num#2
  memset::end#0 = memset::$2
  memset::dst#0 = ((byte*)) memset::str#2
  to:memset::@3
memset::@3: scope:[memset]  from memset::@2 memset::@4
  memset::c#2 = phi( memset::@2/memset::c#3, memset::@4/memset::c#1 )
  memset::str#4 = phi( memset::@2/memset::str#2, memset::@4/memset::str#5 )
  memset::end#1 = phi( memset::@2/memset::end#0, memset::@4/memset::end#2 )
  memset::dst#2 = phi( memset::@2/memset::dst#0, memset::@4/memset::dst#1 )
  memset::$3 = memset::dst#2 != memset::end#1
  if(memset::$3) goto memset::@4
  to:memset::@1
memset::@4: scope:[memset]  from memset::@3
  memset::str#5 = phi( memset::@3/memset::str#4 )
  memset::end#2 = phi( memset::@3/memset::end#1 )
  memset::dst#3 = phi( memset::@3/memset::dst#2 )
  memset::c#1 = phi( memset::@3/memset::c#2 )
  *memset::dst#3 = memset::c#1
  memset::dst#1 = ++ memset::dst#3
  to:memset::@3
memset::@return: scope:[memset]  from memset::@1
  memset::return#3 = phi( memset::@1/memset::return#0 )
  memset::return#1 = memset::return#3
  return 
  to:@return

byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  keyboard_matrix_read::rowid#1 = phi( keyboard_key_pressed/keyboard_matrix_read::rowid#0 )
  *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_A) = keyboard_matrix_row_bitmask[keyboard_matrix_read::rowid#1]
  keyboard_matrix_read::$0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B)
  keyboard_matrix_read::row_pressed_bits#0 = keyboard_matrix_read::$0
  keyboard_matrix_read::return#0 = keyboard_matrix_read::row_pressed_bits#0
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  keyboard_matrix_read::return#3 = phi( keyboard_matrix_read/keyboard_matrix_read::return#0 )
  keyboard_matrix_read::return#1 = keyboard_matrix_read::return#3
  return 
  to:@return

byte keyboard_key_pressed(byte keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from exit::@1 loop::@11
  keyboard_key_pressed::key#2 = phi( exit::@1/keyboard_key_pressed::key#0, loop::@11/keyboard_key_pressed::key#1 )
  keyboard_key_pressed::$0 = keyboard_key_pressed::key#2 & 7
  keyboard_key_pressed::colidx#0 = keyboard_key_pressed::$0
  keyboard_key_pressed::$1 = keyboard_key_pressed::key#2 >> 3
  keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::$1
  keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0
  call keyboard_matrix_read 
  keyboard_matrix_read::return#2 = keyboard_matrix_read::return#1
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  keyboard_key_pressed::colidx#1 = phi( keyboard_key_pressed/keyboard_key_pressed::colidx#0 )
  keyboard_matrix_read::return#4 = phi( keyboard_key_pressed/keyboard_matrix_read::return#2 )
  keyboard_key_pressed::$2 = keyboard_matrix_read::return#4
  keyboard_key_pressed::$3 = keyboard_key_pressed::$2 & keyboard_matrix_col_bitmask[keyboard_key_pressed::colidx#1]
  keyboard_key_pressed::return#0 = keyboard_key_pressed::$3
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  keyboard_key_pressed::return#4 = phi( keyboard_key_pressed::@1/keyboard_key_pressed::return#0 )
  keyboard_key_pressed::return#1 = keyboard_key_pressed::return#4
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  asm { sei  }
  call init 
  to:main::@1
main::@1: scope:[main]  from main
  call loop 
  to:main::@2
main::@2: scope:[main]  from main::@1
  call exit 
  to:main::@3
main::@3: scope:[main]  from main::@2
  asm { cli  }
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return

void init()
init: scope:[init]  from main
  *D011 = VIC_DEN|VIC_RSEL|3
  plexInit::screen#0 = SCREEN
  call plexInit 
  to:init::@5
init::@5: scope:[init]  from init
  init::i#0 = 0
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@5
  init::i#2 = phi( init::@1/init::i#1, init::@5/init::i#0 )
  PLEX_PTR[init::i#2] = (byte)SPRITE/$40
  init::$3 = init::i#2 * 5
  init::$4 = $18 + init::$3
  init::$9 = init::i#2 * SIZEOF_WORD
  PLEX_XPOS[init::$9] = init::$4
  init::$5 = init::i#2 * 8
  init::$6 = $32 + init::$5
  PLEX_YPOS[init::i#2] = init::$6
  init::i#1 = init::i#2 + rangenext(0,PLEX_COUNT-1)
  init::$7 = init::i#1 != rangelast(0,PLEX_COUNT-1)
  if(init::$7) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  *SPRITES_ENABLE = $ff
  init::i1#0 = 0
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  init::i1#2 = phi( init::@2/init::i1#0, init::@3/init::i1#1 )
  SPRITES_COLOR[init::i1#2] = GREEN
  init::i1#1 = init::i1#2 + rangenext(0,7)
  init::$8 = init::i1#1 != rangelast(0,7)
  if(init::$8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  call mulf_init 
  to:init::@6
init::@6: scope:[init]  from init::@4
  memset::str#0 = (void*)SCREEN
  memset::c#0 = ' '
  memset::num#0 = $3e8
  call memset 
  memset::return#2 = memset::return#1
  to:init::@7
init::@7: scope:[init]  from init::@6
  to:init::@return
init::@return: scope:[init]  from init::@7
  return 
  to:@return

void exit()
exit: scope:[exit]  from main::@2
  to:exit::@1
exit::@1: scope:[exit]  from exit exit::@2
  keyboard_key_pressed::key#0 = KEY_SPACE
  call keyboard_key_pressed 
  keyboard_key_pressed::return#2 = keyboard_key_pressed::return#1
  to:exit::@2
exit::@2: scope:[exit]  from exit::@1
  keyboard_key_pressed::return#5 = phi( exit::@1/keyboard_key_pressed::return#2 )
  exit::$0 = keyboard_key_pressed::return#5
  exit::$1 = 0 != exit::$0
  if(exit::$1) goto exit::@1
  to:exit::@return
exit::@return: scope:[exit]  from exit::@2
  return 
  to:@return

void loop()
loop: scope:[loop]  from main::@1
  loop::angle#0 = 0
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@17
  loop::angle#6 = phi( loop/loop::angle#0, loop::@17/loop::angle#8 )
  if(true) goto loop::@2
  to:loop::@return
loop::@2: scope:[loop]  from loop::@1 loop::@2
  loop::angle#4 = phi( loop::@1/loop::angle#6, loop::@2/loop::angle#4 )
  loop::$0 = *RASTER < $d8
  if(loop::$0) goto loop::@2
  to:loop::@3
loop::@3: scope:[loop]  from loop::@2
  loop::angle#2 = phi( loop::@2/loop::angle#4 )
  *BORDER_COLOR = $f
  loop::r#0 = $1e
  loop::a#0 = loop::angle#2
  loop::i#0 = 0
  to:loop::@4
loop::@4: scope:[loop]  from loop::@14 loop::@3
  loop::angle#10 = phi( loop::@14/loop::angle#7, loop::@3/loop::angle#2 )
  loop::i#4 = phi( loop::@14/loop::i#1, loop::@3/loop::i#0 )
  loop::a#2 = phi( loop::@14/loop::a#1, loop::@3/loop::a#0 )
  loop::r#2 = phi( loop::@14/loop::r#1, loop::@3/loop::r#0 )
  *BORDER_COLOR = 6
  mulf8s::a#0 = loop::r#2
  mulf8s::b#0 = COS[loop::a#2]
  call mulf8s 
  mulf8s::return#2 = mulf8s::return#1
  to:loop::@13
loop::@13: scope:[loop]  from loop::@4
  loop::angle#9 = phi( loop::@4/loop::angle#10 )
  loop::a#3 = phi( loop::@4/loop::a#2 )
  loop::r#3 = phi( loop::@4/loop::r#2 )
  loop::i#2 = phi( loop::@4/loop::i#4 )
  mulf8s::return#5 = phi( loop::@4/mulf8s::return#2 )
  loop::$1 = mulf8s::return#5
  loop::$2 = loop::$1 * 2
  loop::$3 = loop::$2 + $7d*$100
  loop::x#0 = loop::$3
  loop::$4 = > loop::x#0
  loop::$20 = loop::i#2 * SIZEOF_WORD
  PLEX_XPOS[loop::$20] = loop::$4
  mulf8s::a#1 = loop::r#3
  mulf8s::b#1 = SIN[loop::a#3]
  call mulf8s 
  mulf8s::return#3 = mulf8s::return#1
  to:loop::@14
loop::@14: scope:[loop]  from loop::@13
  loop::angle#7 = phi( loop::@13/loop::angle#9 )
  loop::r#4 = phi( loop::@13/loop::r#3 )
  loop::a#4 = phi( loop::@13/loop::a#3 )
  loop::i#3 = phi( loop::@13/loop::i#2 )
  mulf8s::return#6 = phi( loop::@13/mulf8s::return#3 )
  loop::$5 = mulf8s::return#6
  loop::$6 = loop::$5 * 2
  loop::$7 = loop::$6 + $7d*$100
  loop::y#0 = loop::$7
  loop::$8 = > loop::y#0
  PLEX_YPOS[loop::i#3] = loop::$8
  loop::a#1 = loop::a#4 + $62
  loop::r#1 = loop::r#4 + 3
  loop::i#1 = loop::i#3 + rangenext(0,NUM_BOBS-1)
  loop::$9 = loop::i#1 != rangelast(0,NUM_BOBS-1)
  if(loop::$9) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@14
  loop::angle#5 = phi( loop::@14/loop::angle#7 )
  *BORDER_COLOR = 3
  call plexSort 
  to:loop::@15
loop::@15: scope:[loop]  from loop::@5
  loop::angle#3 = phi( loop::@5/loop::angle#5 )
  loop::angle#1 = loop::angle#3 + 3
  *BORDER_COLOR = BLACK
  to:loop::@6
loop::@6: scope:[loop]  from loop::@15 loop::@6
  loop::angle#20 = phi( loop::@15/loop::angle#1, loop::@6/loop::angle#20 )
  loop::$11 = *D011 & VIC_RST8
  loop::$12 = loop::$11 != 0
  if(loop::$12) goto loop::@6
  to:loop::@7
loop::@7: scope:[loop]  from loop::@6
  loop::angle#19 = phi( loop::@6/loop::angle#20 )
  loop::i1#0 = 0
  to:loop::@8
loop::@8: scope:[loop]  from loop::@16 loop::@7
  loop::angle#18 = phi( loop::@16/loop::angle#12, loop::@7/loop::angle#19 )
  loop::i1#8 = phi( loop::@16/loop::i1#1, loop::@7/loop::i1#0 )
  *BORDER_COLOR = BLACK
  to:loop::plexFreeNextYpos1
loop::plexFreeNextYpos1: scope:[loop]  from loop::@8
  loop::angle#17 = phi( loop::@8/loop::angle#18 )
  loop::i1#7 = phi( loop::@8/loop::i1#8 )
  loop::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next]
  to:loop::plexFreeNextYpos1_@return
loop::plexFreeNextYpos1_@return: scope:[loop]  from loop::plexFreeNextYpos1
  loop::angle#16 = phi( loop::plexFreeNextYpos1/loop::angle#17 )
  loop::i1#6 = phi( loop::plexFreeNextYpos1/loop::i1#7 )
  loop::plexFreeNextYpos1_return#2 = phi( loop::plexFreeNextYpos1/loop::plexFreeNextYpos1_return#0 )
  loop::plexFreeNextYpos1_return#1 = loop::plexFreeNextYpos1_return#2
  to:loop::@12
loop::@12: scope:[loop]  from loop::plexFreeNextYpos1_@return
  loop::angle#15 = phi( loop::plexFreeNextYpos1_@return/loop::angle#16 )
  loop::i1#5 = phi( loop::plexFreeNextYpos1_@return/loop::i1#6 )
  loop::plexFreeNextYpos1_return#3 = phi( loop::plexFreeNextYpos1_@return/loop::plexFreeNextYpos1_return#1 )
  loop::$13 = loop::plexFreeNextYpos1_return#3
  loop::rasterY#0 = loop::$13
  to:loop::@9
loop::@9: scope:[loop]  from loop::@12 loop::@9
  loop::angle#14 = phi( loop::@12/loop::angle#15, loop::@9/loop::angle#14 )
  loop::i1#4 = phi( loop::@12/loop::i1#5, loop::@9/loop::i1#4 )
  loop::rasterY#1 = phi( loop::@12/loop::rasterY#0, loop::@9/loop::rasterY#1 )
  loop::$14 = *RASTER < loop::rasterY#1
  if(loop::$14) goto loop::@9
  to:loop::@10
loop::@10: scope:[loop]  from loop::@9
  loop::angle#13 = phi( loop::@9/loop::angle#14 )
  loop::i1#3 = phi( loop::@9/loop::i1#4 )
  *BORDER_COLOR = ++ *BORDER_COLOR
  call plexShowSprite 
  to:loop::@16
loop::@16: scope:[loop]  from loop::@10
  loop::angle#12 = phi( loop::@10/loop::angle#13 )
  loop::i1#2 = phi( loop::@10/loop::i1#3 )
  loop::i1#1 = loop::i1#2 + rangenext(0,PLEX_COUNT-1)
  loop::$17 = loop::i1#1 != rangelast(0,PLEX_COUNT-1)
  if(loop::$17) goto loop::@8
  to:loop::@11
loop::@11: scope:[loop]  from loop::@16
  loop::angle#11 = phi( loop::@16/loop::angle#12 )
  *BORDER_COLOR = BLACK
  keyboard_key_pressed::key#1 = KEY_SPACE
  call keyboard_key_pressed 
  keyboard_key_pressed::return#3 = keyboard_key_pressed::return#1
  to:loop::@17
loop::@17: scope:[loop]  from loop::@11
  loop::angle#8 = phi( loop::@11/loop::angle#11 )
  keyboard_key_pressed::return#6 = phi( loop::@11/keyboard_key_pressed::return#3 )
  loop::$18 = keyboard_key_pressed::return#6
  loop::$21 = 0 != loop::$18
  loop::$19 = ! loop::$21
  if(loop::$19) goto loop::@1
  to:loop::@return
loop::@return: scope:[loop]  from loop::@1 loop::@17
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  PLEX_SCREEN_PTR = (byte*)$400+$3f8
  plex_show_idx = 0
  plex_sprite_idx = 0
  plex_sprite_msb = 1
  plex_free_next = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
const nomodify byte BLACK = 0
const nomodify byte* BORDER_COLOR = (byte*)$d020
const nomodify struct MOS6526_CIA* CIA1 = (struct MOS6526_CIA*)$dc00
const signed byte* COS = SIN+$40
const nomodify byte* D011 = (byte*)$d011
const nomodify byte GREEN = 5
const nomodify byte KEY_SPACE = $3c
const nomodify byte NUM_BOBS = $10
const byte OFFSET_STRUCT_MOS6526_CIA_PORT_A = 0
const byte OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
const nomodify byte PLEX_COUNT = $20
const byte* PLEX_FREE_YPOS[8]  = { fill( 8, 0) }
const byte* PLEX_PTR[PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
volatile byte* PLEX_SCREEN_PTR loadstore
const byte* PLEX_SORTED_IDX[PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
const word* PLEX_XPOS[PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
const byte* PLEX_YPOS[PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
const nomodify byte* RASTER = (byte*)$d012
const nomodify byte* SCREEN = (byte*)$400
const signed byte* SIN[$140]  = kickasm {{ .for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))
 }}
const byte SIZEOF_WORD = 2
const byte* SPRITE[]  = kickasm {{ .var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
const nomodify byte* SPRITES_COLOR = (byte*)$d027
const nomodify byte* SPRITES_ENABLE = (byte*)$d015
const nomodify byte* SPRITES_XMSB = (byte*)$d010
const nomodify byte* SPRITES_XPOS = (byte*)$d000
const nomodify byte* SPRITES_YPOS = (byte*)$d001
const nomodify byte VIC_DEN = $10
const nomodify byte VIC_RSEL = 8
const nomodify byte VIC_RST8 = $80
void __start()
void exit()
byte~ exit::$0
bool~ exit::$1
void init()
number~ init::$3
number~ init::$4
number~ init::$5
number~ init::$6
bool~ init::$7
bool~ init::$8
byte~ init::$9
byte init::i
byte init::i#0
byte init::i#1
byte init::i#2
byte init::i1
byte init::i1#0
byte init::i1#1
byte init::i1#2
byte keyboard_key_pressed(byte keyboard_key_pressed::key)
number~ keyboard_key_pressed::$0
byte~ keyboard_key_pressed::$1
byte~ keyboard_key_pressed::$2
byte~ keyboard_key_pressed::$3
byte keyboard_key_pressed::colidx
byte keyboard_key_pressed::colidx#0
byte keyboard_key_pressed::colidx#1
byte keyboard_key_pressed::key
byte keyboard_key_pressed::key#0
byte keyboard_key_pressed::key#1
byte keyboard_key_pressed::key#2
byte keyboard_key_pressed::return
byte keyboard_key_pressed::return#0
byte keyboard_key_pressed::return#1
byte keyboard_key_pressed::return#2
byte keyboard_key_pressed::return#3
byte keyboard_key_pressed::return#4
byte keyboard_key_pressed::return#5
byte keyboard_key_pressed::return#6
byte keyboard_key_pressed::rowidx
byte keyboard_key_pressed::rowidx#0
const byte* keyboard_matrix_col_bitmask[8]  = { 1, 2, 4, 8, $10, $20, $40, $80 }
byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
byte~ keyboard_matrix_read::$0
byte keyboard_matrix_read::return
byte keyboard_matrix_read::return#0
byte keyboard_matrix_read::return#1
byte keyboard_matrix_read::return#2
byte keyboard_matrix_read::return#3
byte keyboard_matrix_read::return#4
byte keyboard_matrix_read::row_pressed_bits
byte keyboard_matrix_read::row_pressed_bits#0
byte keyboard_matrix_read::rowid
byte keyboard_matrix_read::rowid#0
byte keyboard_matrix_read::rowid#1
const byte* keyboard_matrix_row_bitmask[8]  = { $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f }
void loop()
bool~ loop::$0
signed word~ loop::$1
byte~ loop::$11
bool~ loop::$12
byte~ loop::$13
bool~ loop::$14
bool~ loop::$17
byte~ loop::$18
bool~ loop::$19
number~ loop::$2
byte~ loop::$20
bool~ loop::$21
number~ loop::$3
byte~ loop::$4
signed word~ loop::$5
number~ loop::$6
number~ loop::$7
byte~ loop::$8
bool~ loop::$9
byte loop::a
byte loop::a#0
byte loop::a#1
byte loop::a#2
byte loop::a#3
byte loop::a#4
byte loop::angle
byte loop::angle#0
byte loop::angle#1
byte loop::angle#10
byte loop::angle#11
byte loop::angle#12
byte loop::angle#13
byte loop::angle#14
byte loop::angle#15
byte loop::angle#16
byte loop::angle#17
byte loop::angle#18
byte loop::angle#19
byte loop::angle#2
byte loop::angle#20
byte loop::angle#3
byte loop::angle#4
byte loop::angle#5
byte loop::angle#6
byte loop::angle#7
byte loop::angle#8
byte loop::angle#9
byte loop::i
byte loop::i#0
byte loop::i#1
byte loop::i#2
byte loop::i#3
byte loop::i#4
byte loop::i1
byte loop::i1#0
byte loop::i1#1
byte loop::i1#2
byte loop::i1#3
byte loop::i1#4
byte loop::i1#5
byte loop::i1#6
byte loop::i1#7
byte loop::i1#8
byte loop::plexFreeNextYpos1_return
byte loop::plexFreeNextYpos1_return#0
byte loop::plexFreeNextYpos1_return#1
byte loop::plexFreeNextYpos1_return#2
byte loop::plexFreeNextYpos1_return#3
signed byte loop::r
signed byte loop::r#0
signed byte loop::r#1
signed byte loop::r#2
signed byte loop::r#3
signed byte loop::r#4
byte loop::rasterY
byte loop::rasterY#0
byte loop::rasterY#1
signed word loop::x
signed word loop::x#0
signed word loop::y
signed word loop::y#0
void main()
void* memset(void* memset::str , byte memset::c , word memset::num)
bool~ memset::$0
bool~ memset::$1
byte*~ memset::$2
bool~ memset::$3
byte*~ memset::$4
byte memset::c
byte memset::c#0
byte memset::c#1
byte memset::c#2
byte memset::c#3
byte memset::c#4
byte* memset::dst
byte* memset::dst#0
byte* memset::dst#1
byte* memset::dst#2
byte* memset::dst#3
byte* memset::end
byte* memset::end#0
byte* memset::end#1
byte* memset::end#2
word memset::num
word memset::num#0
word memset::num#1
word memset::num#2
void* memset::return
void* memset::return#0
void* memset::return#1
void* memset::return#2
void* memset::return#3
void* memset::str
void* memset::str#0
void* memset::str#1
void* memset::str#2
void* memset::str#3
void* memset::str#4
void* memset::str#5
signed word mulf8s(signed byte mulf8s::a , signed byte mulf8s::b)
signed word~ mulf8s::$1
signed byte mulf8s::a
signed byte mulf8s::a#0
signed byte mulf8s::a#1
signed byte mulf8s::a#2
signed byte mulf8s::b
signed byte mulf8s::b#0
signed byte mulf8s::b#1
signed byte mulf8s::b#2
signed byte mulf8s::b#3
signed byte mulf8s::b#4
signed byte mulf8s::b#5
signed byte mulf8s::mulf8s_prepare1_a
signed byte mulf8s::mulf8s_prepare1_a#0
signed byte mulf8s::mulf8s_prepare1_a#1
signed word mulf8s::return
signed word mulf8s::return#0
signed word mulf8s::return#1
signed word mulf8s::return#2
signed word mulf8s::return#3
signed word mulf8s::return#4
signed word mulf8s::return#5
signed word mulf8s::return#6
signed word mulf8s_prepared(signed byte mulf8s_prepared::b)
word~ mulf8s_prepared::$0
bool~ mulf8s_prepared::$1
byte~ mulf8s_prepared::$10
byte~ mulf8s_prepared::$11
byte~ mulf8s_prepared::$12
byte~ mulf8s_prepared::$13
byte~ mulf8s_prepared::$14
bool~ mulf8s_prepared::$2
bool~ mulf8s_prepared::$3
bool~ mulf8s_prepared::$4
byte~ mulf8s_prepared::$6
byte~ mulf8s_prepared::$7
byte~ mulf8s_prepared::$9
signed byte mulf8s_prepared::b
signed byte mulf8s_prepared::b#0
signed byte mulf8s_prepared::b#1
signed byte mulf8s_prepared::b#2
signed byte mulf8s_prepared::b#3
signed byte mulf8s_prepared::b#4
word mulf8s_prepared::m
word mulf8s_prepared::m#0
word mulf8s_prepared::m#1
word mulf8s_prepared::m#2
word mulf8s_prepared::m#3
word mulf8s_prepared::m#4
word mulf8s_prepared::m#5
word mulf8s_prepared::m#6
const nomodify signed byte* mulf8s_prepared::memA = (signed byte*)$fd
signed word mulf8s_prepared::return
signed word mulf8s_prepared::return#0
signed word mulf8s_prepared::return#1
signed word mulf8s_prepared::return#2
signed word mulf8s_prepared::return#3
signed word mulf8s_prepared::return#4
void mulf8u_prepare(byte mulf8u_prepare::a)
byte mulf8u_prepare::a
byte mulf8u_prepare::a#0
byte mulf8u_prepare::a#1
const nomodify byte* mulf8u_prepare::memA = (byte*)$fd
word mulf8u_prepared(byte mulf8u_prepared::b)
byte mulf8u_prepared::b
byte mulf8u_prepared::b#0
byte mulf8u_prepared::b#1
const nomodify byte* mulf8u_prepared::memB = (byte*)$ff
const nomodify byte* mulf8u_prepared::resL = (byte*)$fe
word mulf8u_prepared::return
word mulf8u_prepared::return#0
word mulf8u_prepared::return#1
word mulf8u_prepared::return#2
word mulf8u_prepared::return#3
word mulf8u_prepared::return#4
void mulf_init()
bool~ mulf_init::$0
number~ mulf_init::$1
bool~ mulf_init::$10
bool~ mulf_init::$2
bool~ mulf_init::$3
byte~ mulf_init::$4
byte~ mulf_init::$5
word~ mulf_init::$6
bool~ mulf_init::$7
byte~ mulf_init::$8
bool~ mulf_init::$9
byte mulf_init::c
byte mulf_init::c#0
byte mulf_init::c#1
byte mulf_init::c#2
byte mulf_init::c#3
byte mulf_init::c#4
byte mulf_init::c#5
byte mulf_init::dir
byte mulf_init::dir#0
byte mulf_init::dir#1
byte mulf_init::dir#2
byte mulf_init::dir#3
byte mulf_init::dir#4
word mulf_init::sqr
word mulf_init::sqr#0
word mulf_init::sqr#1
word mulf_init::sqr#2
word mulf_init::sqr#3
word mulf_init::sqr#4
word mulf_init::sqr#5
word mulf_init::sqr#6
byte* mulf_init::sqr1_hi
byte* mulf_init::sqr1_hi#0
byte* mulf_init::sqr1_hi#1
byte* mulf_init::sqr1_hi#2
byte* mulf_init::sqr1_hi#3
byte* mulf_init::sqr1_hi#4
byte* mulf_init::sqr1_hi#5
byte* mulf_init::sqr1_lo
byte* mulf_init::sqr1_lo#0
byte* mulf_init::sqr1_lo#1
byte* mulf_init::sqr1_lo#2
byte* mulf_init::sqr1_lo#3
byte* mulf_init::sqr1_lo#4
byte* mulf_init::sqr1_lo#5
byte* mulf_init::sqr2_hi
byte* mulf_init::sqr2_hi#0
byte* mulf_init::sqr2_hi#1
byte* mulf_init::sqr2_hi#2
byte* mulf_init::sqr2_hi#3
byte* mulf_init::sqr2_hi#4
byte* mulf_init::sqr2_hi#5
byte* mulf_init::sqr2_lo
byte* mulf_init::sqr2_lo#0
byte* mulf_init::sqr2_lo#1
byte* mulf_init::sqr2_lo#2
byte* mulf_init::sqr2_lo#3
byte* mulf_init::sqr2_lo#4
byte* mulf_init::sqr2_lo#5
byte mulf_init::x_2
byte mulf_init::x_2#0
byte mulf_init::x_2#1
byte mulf_init::x_2#2
byte mulf_init::x_2#3
byte mulf_init::x_2#4
byte mulf_init::x_2#5
byte mulf_init::x_255
byte mulf_init::x_255#0
byte mulf_init::x_255#1
byte mulf_init::x_255#2
byte mulf_init::x_255#3
byte mulf_init::x_255#4
byte mulf_init::x_255#5
const byte* mulf_sqr1_hi[$200]  = { fill( $200, 0) }
const byte* mulf_sqr1_lo[$200]  = { fill( $200, 0) }
const byte* mulf_sqr2_hi[$200]  = { fill( $200, 0) }
const byte* mulf_sqr2_lo[$200]  = { fill( $200, 0) }
void plexInit(byte* plexInit::screen)
bool~ plexInit::$1
byte plexInit::i
byte plexInit::i#0
byte plexInit::i#1
byte plexInit::i#2
byte*~ plexInit::plexSetScreen1_$0
byte* plexInit::plexSetScreen1_screen
byte* plexInit::plexSetScreen1_screen#0
byte* plexInit::plexSetScreen1_screen#1
byte* plexInit::screen
byte* plexInit::screen#0
byte* plexInit::screen#1
void plexShowSprite()
number~ plexShowSprite::$0
byte~ plexShowSprite::$10
byte~ plexShowSprite::$11
byte~ plexShowSprite::$2
byte~ plexShowSprite::$3
bool~ plexShowSprite::$4
number~ plexShowSprite::$5
number~ plexShowSprite::$6
bool~ plexShowSprite::$7
bool~ plexShowSprite::$8
number~ plexShowSprite::$9
number~ plexShowSprite::plexFreeAdd1_$0
number~ plexShowSprite::plexFreeAdd1_$1
number~ plexShowSprite::plexFreeAdd1_$2
byte plexShowSprite::plexFreeAdd1_ypos
byte plexShowSprite::plexFreeAdd1_ypos#0
byte plexShowSprite::plexFreeAdd1_ypos#1
byte plexShowSprite::plex_sprite_idx2
byte plexShowSprite::plex_sprite_idx2#0
byte plexShowSprite::plex_sprite_idx2#1
byte plexShowSprite::plex_sprite_idx2#2
byte plexShowSprite::xpos_idx
byte plexShowSprite::xpos_idx#0
byte plexShowSprite::ypos
byte plexShowSprite::ypos#0
void plexSort()
number~ plexSort::$1
bool~ plexSort::$2
bool~ plexSort::$3
number~ plexSort::$4
bool~ plexSort::$5
bool~ plexSort::$6
bool~ plexSort::$7
bool~ plexSort::$8
byte plexSort::m
byte plexSort::m#0
byte plexSort::m#1
byte plexSort::m#2
byte plexSort::m#3
byte plexSort::m#4
byte plexSort::m#5
byte plexSort::m#6
byte plexSort::nxt_idx
byte plexSort::nxt_idx#0
byte plexSort::nxt_idx#1
byte plexSort::nxt_idx#2
byte plexSort::nxt_idx#3
byte plexSort::nxt_y
byte plexSort::nxt_y#0
byte plexSort::nxt_y#1
byte plexSort::nxt_y#2
bool~ plexSort::plexFreePrepare1_$0
byte plexSort::plexFreePrepare1_s
byte plexSort::plexFreePrepare1_s#0
byte plexSort::plexFreePrepare1_s#1
byte plexSort::plexFreePrepare1_s#2
byte plexSort::s
byte plexSort::s#0
byte plexSort::s#1
byte plexSort::s#2
byte plexSort::s#3
byte plexSort::s#4
volatile byte plex_free_next loadstore
volatile byte plex_show_idx loadstore
volatile byte plex_sprite_idx loadstore
volatile byte plex_sprite_msb loadstore

Fixing inline constructor with mulf8u_prepared::$0 = (byte)*mulf8u_prepared::memB w= (byte)*mulf8u_prepared::resL
Successful SSA optimization Pass2FixInlineConstructors
Adding number conversion cast (unumber) $40 in 
Adding number conversion cast (unumber) $3f8 in plexInit::plexSetScreen1_$0 = plexInit::plexSetScreen1_screen#1 + $3f8
Adding number conversion cast (unumber) 1 in plexInit::i#1 = plexInit::i#2 + rangenext(0,PLEX_COUNT-1)
Adding number conversion cast (unumber) 1 in plexSort::$1 = plexSort::m#2 + 1
Adding number conversion cast (unumber) plexSort::$1 in plexSort::$1 = plexSort::m#2 + (unumber)1
Adding number conversion cast (unumber) 2 in plexSort::m#1 = plexSort::m#3 + rangenext(0,PLEX_COUNT-2)
Adding number conversion cast (unumber) 1 in plexSort::$4 = plexSort::s#3 + 1
Adding number conversion cast (unumber) plexSort::$4 in plexSort::$4 = plexSort::s#3 + (unumber)1
Adding number conversion cast (unumber) $ff in plexSort::$5 = plexSort::s#1 != $ff
Adding number conversion cast (unumber) 0 in plex_show_idx = 0
Adding number conversion cast (unumber) 0 in plex_sprite_idx = 0
Adding number conversion cast (unumber) 1 in plex_sprite_msb = 1
Adding number conversion cast (unumber) 0 in PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0
Adding number conversion cast (unumber) 0 in plex_free_next = 0
Adding number conversion cast (unumber) 2 in plexShowSprite::$0 = plex_sprite_idx * 2
Adding number conversion cast (unumber) plexShowSprite::$0 in plexShowSprite::$0 = plex_sprite_idx * (unumber)2
Adding number conversion cast (unumber) $15 in plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#1 + $15
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$0 in plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#1 + (unumber)$15
Adding number conversion cast (unumber) 1 in plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$1 in plexShowSprite::plexFreeAdd1_$1 = plex_free_next + (unumber)1
Adding number conversion cast (unumber) 7 in plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$2 in plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & (unumber)7
Adding number conversion cast (unumber) 0 in plexShowSprite::$4 = plexShowSprite::$3 != 0
Adding number conversion cast (unumber) $ff in plexShowSprite::$9 = $ff ^ plex_sprite_msb
Adding number conversion cast (unumber) plexShowSprite::$9 in plexShowSprite::$9 = (unumber)$ff ^ plex_sprite_msb
Adding number conversion cast (unumber) 1 in plexShowSprite::$5 = plex_sprite_idx + 1
Adding number conversion cast (unumber) plexShowSprite::$5 in plexShowSprite::$5 = plex_sprite_idx + (unumber)1
Adding number conversion cast (unumber) 7 in plexShowSprite::$6 = plexShowSprite::$5 & 7
Adding number conversion cast (unumber) plexShowSprite::$6 in plexShowSprite::$6 = plexShowSprite::$5 & (unumber)7
Adding number conversion cast (unumber) 1 in plex_sprite_msb = plex_sprite_msb << 1
Adding number conversion cast (unumber) 0 in plexShowSprite::$7 = plex_sprite_msb == 0
Adding number conversion cast (unumber) 1 in plex_sprite_msb = 1
Adding number conversion cast (unumber) 1 in mulf_init::sqr1_hi#0 = mulf_sqr1_hi+1
Adding number conversion cast (unumber) 1 in mulf_init::sqr1_lo#0 = mulf_sqr1_lo+1
Adding number conversion cast (unumber) $200 in mulf_init::$0 = mulf_init::sqr1_lo#2 != mulf_sqr1_lo+$200
Adding number conversion cast (unumber) 1 in mulf_init::$1 = mulf_init::c#1 & 1
Adding number conversion cast (unumber) mulf_init::$1 in mulf_init::$1 = mulf_init::c#1 & (unumber)1
Adding number conversion cast (unumber) 0 in mulf_init::$2 = mulf_init::$1 == 0
Adding number conversion cast (unumber) $1ff in mulf_init::$7 = mulf_init::sqr2_lo#2 != mulf_sqr2_lo+$1ff
Adding number conversion cast (unumber) 0 in mulf_init::$9 = mulf_init::x_255#1 == 0
Adding number conversion cast (unumber) $100 in *(mulf_sqr2_lo+$1ff) = *(mulf_sqr1_lo+$100)
Adding number conversion cast (unumber) $1ff in *(mulf_sqr2_lo+$1ff) = *(mulf_sqr1_lo+(unumber)$100)
Adding number conversion cast (unumber) $100 in *(mulf_sqr2_hi+$1ff) = *(mulf_sqr1_hi+$100)
Adding number conversion cast (unumber) $1ff in *(mulf_sqr2_hi+$1ff) = *(mulf_sqr1_hi+(unumber)$100)
Adding number conversion cast (unumber) 1 in mulf_init::dir#1 = 1
Adding number conversion cast (snumber) 0 in mulf8s_prepared::$1 = *mulf8s_prepared::memA < 0
Adding number conversion cast (snumber) 0 in mulf8s_prepared::$3 = mulf8s_prepared::b#2 < 0
Adding number conversion cast (unumber) 0 in memset::$0 = memset::num#1 > 0
Adding number conversion cast (unumber) 7 in keyboard_key_pressed::$0 = keyboard_key_pressed::key#2 & 7
Adding number conversion cast (unumber) keyboard_key_pressed::$0 in keyboard_key_pressed::$0 = keyboard_key_pressed::key#2 & (unumber)7
Adding number conversion cast (unumber) 3 in keyboard_key_pressed::$1 = keyboard_key_pressed::key#2 >> 3
Adding number conversion cast (unumber) VIC_DEN|VIC_RSEL|3 in *D011 = VIC_DEN|VIC_RSEL|3
Adding number conversion cast (unumber) 3 in *D011 = ((unumber)) VIC_DEN|VIC_RSEL|3
Adding number conversion cast (unumber) $40 in PLEX_PTR[init::i#2] = (byte)SPRITE/$40
Adding number conversion cast (unumber) 5 in init::$3 = init::i#2 * 5
Adding number conversion cast (unumber) init::$3 in init::$3 = init::i#2 * (unumber)5
Adding number conversion cast (unumber) $18 in init::$4 = $18 + init::$3
Adding number conversion cast (unumber) init::$4 in init::$4 = (unumber)$18 + init::$3
Adding number conversion cast (unumber) 8 in init::$5 = init::i#2 * 8
Adding number conversion cast (unumber) init::$5 in init::$5 = init::i#2 * (unumber)8
Adding number conversion cast (unumber) $32 in init::$6 = $32 + init::$5
Adding number conversion cast (unumber) init::$6 in init::$6 = (unumber)$32 + init::$5
Adding number conversion cast (unumber) 1 in init::i#1 = init::i#2 + rangenext(0,PLEX_COUNT-1)
Adding number conversion cast (unumber) $ff in *SPRITES_ENABLE = $ff
Adding number conversion cast (unumber) $3e8 in memset::num#0 = $3e8
Adding number conversion cast (unumber) 0 in exit::$1 = 0 != exit::$0
Adding number conversion cast (unumber) $d8 in loop::$0 = *RASTER < $d8
Adding number conversion cast (unumber) $f in *BORDER_COLOR = $f
Adding number conversion cast (unumber) 6 in *BORDER_COLOR = 6
Adding number conversion cast (snumber) 2 in loop::$2 = loop::$1 * 2
Adding number conversion cast (snumber) loop::$2 in loop::$2 = loop::$1 * (snumber)2
Adding number conversion cast (snumber) $7d*$100 in loop::$3 = loop::$2 + $7d*$100
Adding number conversion cast (snumber) loop::$3 in loop::$3 = loop::$2 + (snumber)$7d*$100
Adding number conversion cast (snumber) 2 in loop::$6 = loop::$5 * 2
Adding number conversion cast (snumber) loop::$6 in loop::$6 = loop::$5 * (snumber)2
Adding number conversion cast (snumber) $7d*$100 in loop::$7 = loop::$6 + $7d*$100
Adding number conversion cast (snumber) loop::$7 in loop::$7 = loop::$6 + (snumber)$7d*$100
Adding number conversion cast (unumber) $62 in loop::a#1 = loop::a#4 + $62
Adding number conversion cast (snumber) 3 in loop::r#1 = loop::r#4 + 3
Adding number conversion cast (unumber) 1 in loop::i#1 = loop::i#3 + rangenext(0,NUM_BOBS-1)
Adding number conversion cast (unumber) 3 in *BORDER_COLOR = 3
Adding number conversion cast (unumber) 3 in loop::angle#1 = loop::angle#3 + 3
Adding number conversion cast (unumber) 0 in loop::$12 = loop::$11 != 0
Adding number conversion cast (unumber) 1 in loop::i1#1 = loop::i1#2 + rangenext(0,PLEX_COUNT-1)
Adding number conversion cast (unumber) 0 in loop::$21 = 0 != loop::$18
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast plex_show_idx = (unumber)0
Inlining cast plex_sprite_idx = (unumber)0
Inlining cast plex_sprite_msb = (unumber)1
Inlining cast PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = (unumber)0
Inlining cast plex_free_next = (unumber)0
Inlining cast plex_sprite_msb = (unumber)1
Inlining cast mulf_init::dir#1 = (unumber)1
Inlining cast memset::dst#0 = (byte*)memset::str#2
Inlining cast *D011 = (unumber)VIC_DEN|VIC_RSEL|(unumber)3
Inlining cast *SPRITES_ENABLE = (unumber)$ff
Inlining cast memset::num#0 = (unumber)$3e8
Inlining cast *BORDER_COLOR = (unumber)$f
Inlining cast *BORDER_COLOR = (unumber)6
Inlining cast *BORDER_COLOR = (unumber)3
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 53249
Simplifying constant pointer cast (byte*) 53264
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (struct MOS6526_CIA*) 56320
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant pointer cast (signed byte*) 253
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $40
Simplifying constant integer cast $3f8
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $15
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $200
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast -1
Simplifying constant integer cast $1ff
Simplifying constant integer cast 0
Simplifying constant integer cast $100
Simplifying constant integer cast $1ff
Simplifying constant integer cast $100
Simplifying constant integer cast $1ff
Simplifying constant integer cast 1
Simplifying constant integer cast *mulf8u_prepared::memB
Simplifying constant integer cast *mulf8u_prepared::resL
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 7
Simplifying constant integer cast 3
Simplifying constant integer cast VIC_DEN|VIC_RSEL|(unumber)3
Simplifying constant integer cast 3
Simplifying constant integer cast $40
Simplifying constant integer cast 5
Simplifying constant integer cast $18
Simplifying constant integer cast 8
Simplifying constant integer cast $32
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast $d8
Simplifying constant integer cast $f
Simplifying constant integer cast 6
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast $62
Simplifying constant integer cast 3
Simplifying constant integer cast 1
Simplifying constant integer cast 3
Simplifying constant integer cast 3
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $3f8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $200
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $1ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $100
Finalized unsigned number type (word) $1ff
Finalized unsigned number type (word) $100
Finalized unsigned number type (word) $1ff
Finalized unsigned number type (byte) 1
Finalized signed number type (signed byte) 0
Finalized signed number type (signed byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $32
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $d8
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 6
Finalized signed number type (signed byte) 2
Finalized signed number type (signed byte) 2
Finalized unsigned number type (byte) $62
Finalized signed number type (signed byte) 3
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in plexSort::$1 = plexSort::m#2 + 1
Inferred type updated to byte in plexSort::$4 = plexSort::s#3 + 1
Inferred type updated to byte in plexShowSprite::$0 = plex_sprite_idx * 2
Inferred type updated to byte in plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#1 + $15
Inferred type updated to byte in plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1
Inferred type updated to byte in plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7
Inferred type updated to byte in plexShowSprite::$9 = $ff ^ plex_sprite_msb
Inferred type updated to byte in plexShowSprite::$5 = plex_sprite_idx + 1
Inferred type updated to byte in plexShowSprite::$6 = plexShowSprite::$5 & 7
Inferred type updated to byte in mulf_init::$1 = mulf_init::c#1 & 1
Inferred type updated to byte in keyboard_key_pressed::$0 = keyboard_key_pressed::key#2 & 7
Inferred type updated to byte in init::$3 = init::i#2 * 5
Inferred type updated to byte in init::$4 = $18 + init::$3
Inferred type updated to byte in init::$5 = init::i#2 * 8
Inferred type updated to byte in init::$6 = $32 + init::$5
Inferred type updated to signed word in loop::$2 = loop::$1 * 2
Inferred type updated to signed word in loop::$3 = loop::$2 + (signed word)$7d*$100
Inferred type updated to signed word in loop::$6 = loop::$5 * 2
Inferred type updated to signed word in loop::$7 = loop::$6 + (signed word)$7d*$100
Inversing boolean not [18] plexSort::$3 = plexSort::nxt_y#0 >= PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]] from [17] plexSort::$2 = plexSort::nxt_y#0 < PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]
Inversing boolean not [78] plexShowSprite::$8 = plex_sprite_msb != 0 from [77] plexShowSprite::$7 = plex_sprite_msb == 0
Inversing boolean not [94] mulf_init::$3 = mulf_init::$1 != 0 from [93] mulf_init::$2 = mulf_init::$1 == 0
Inversing boolean not [122] mulf_init::$10 = mulf_init::x_255#1 != 0 from [121] mulf_init::$9 = mulf_init::x_255#1 == 0
Inversing boolean not [151] mulf8s_prepared::$2 = *mulf8s_prepared::memA >= 0 from [150] mulf8s_prepared::$1 = *mulf8s_prepared::memA < 0
Inversing boolean not [155] mulf8s_prepared::$4 = mulf8s_prepared::b#2 >= 0 from [154] mulf8s_prepared::$3 = mulf8s_prepared::b#2 < 0
Inversing boolean not [192] memset::$1 = memset::num#1 <= 0 from [191] memset::$0 = memset::num#1 > 0
Inversing boolean not [357] loop::$19 = 0 == loop::$18 from [356] loop::$21 = 0 != loop::$18
Successful SSA optimization Pass2UnaryNotSimplification
Alias candidate removed (volatile)PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Alias plexInit::plexSetScreen1_screen#0 = plexInit::screen#1 plexInit::plexSetScreen1_screen#1 
Alias plexSort::m#2 = plexSort::m#4 plexSort::s#0 
Alias plexSort::nxt_y#0 = plexSort::nxt_y#2 
Alias plexSort::nxt_idx#0 = plexSort::nxt_idx#3 
Alias plexSort::s#1 = plexSort::s#4 
Alias plexSort::nxt_idx#1 = plexSort::nxt_idx#2 
Alias plexSort::m#5 = plexSort::m#6 
Alias plexShowSprite::plex_sprite_idx2#0 = plexShowSprite::$0 plexShowSprite::plex_sprite_idx2#2 plexShowSprite::plex_sprite_idx2#1 
Alias plexShowSprite::plexFreeAdd1_ypos#0 = plexShowSprite::ypos#0 plexShowSprite::plexFreeAdd1_ypos#1 
Alias mulf_init::c#2 = mulf_init::c#3 
Alias mulf_init::sqr#4 = mulf_init::sqr#5 mulf_init::sqr#6 
Alias mulf_init::sqr1_lo#2 = mulf_init::sqr1_lo#4 mulf_init::sqr1_lo#5 
Alias mulf_init::sqr1_hi#3 = mulf_init::sqr1_hi#5 mulf_init::sqr1_hi#4 
Alias mulf_init::x_2#3 = mulf_init::x_2#4 mulf_init::x_2#5 
Alias mulf_init::sqr#1 = mulf_init::$6 
Alias mulf_init::c#1 = mulf_init::c#5 
Alias mulf_init::x_255#2 = mulf_init::x_255#3 
Alias mulf_init::sqr2_lo#2 = mulf_init::sqr2_lo#3 mulf_init::sqr2_lo#5 
Alias mulf_init::sqr2_hi#2 = mulf_init::sqr2_hi#3 
Alias mulf_init::dir#2 = mulf_init::dir#3 
Alias mulf_init::x_255#1 = mulf_init::$8 mulf_init::x_255#5 
Alias mulf_init::sqr2_hi#1 = mulf_init::sqr2_hi#5 
Alias mulf8u_prepared::return#0 = mulf8u_prepared::$0 mulf8u_prepared::return#3 mulf8u_prepared::return#1 
Alias mulf8u_prepared::return#2 = mulf8u_prepared::return#4 
Alias mulf8s_prepared::b#1 = mulf8s_prepared::b#4 mulf8s_prepared::b#3 
Alias mulf8s_prepared::m#0 = mulf8s_prepared::$0 mulf8s_prepared::m#3 
Alias mulf8s_prepared::$11 = mulf8s_prepared::$7 
Alias mulf8s_prepared::m#5 = mulf8s_prepared::m#6 
Alias mulf8s_prepared::$12 = mulf8s_prepared::$10 
Alias mulf8s_prepared::return#0 = mulf8s_prepared::return#3 mulf8s_prepared::return#1 
Alias mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#2 mulf8s::mulf8s_prepare1_a#1 
Alias mulf8s::b#2 = mulf8s::b#4 mulf8s::b#5 mulf8s::b#3 
Alias mulf8s_prepared::return#2 = mulf8s_prepared::return#4 
Alias mulf8s::return#0 = mulf8s::$1 mulf8s::return#4 mulf8s::return#1 
Alias memset::return#0 = memset::str#1 memset::return#3 memset::return#1 
Alias memset::str#2 = memset::str#3 
Alias memset::num#1 = memset::num#2 
Alias memset::c#3 = memset::c#4 
Alias memset::end#0 = memset::$2 
Alias memset::c#1 = memset::c#2 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#4 = memset::str#5 
Alias keyboard_matrix_read::return#0 = keyboard_matrix_read::row_pressed_bits#0 keyboard_matrix_read::$0 keyboard_matrix_read::return#3 keyboard_matrix_read::return#1 
Alias keyboard_key_pressed::colidx#0 = keyboard_key_pressed::$0 keyboard_key_pressed::colidx#1 
Alias keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::$1 
Alias keyboard_matrix_read::return#2 = keyboard_matrix_read::return#4 
Alias keyboard_key_pressed::return#0 = keyboard_key_pressed::$3 keyboard_key_pressed::return#4 keyboard_key_pressed::return#1 
Alias keyboard_key_pressed::return#2 = keyboard_key_pressed::return#5 
Alias loop::angle#2 = loop::angle#4 loop::a#0 
Alias mulf8s::return#2 = mulf8s::return#5 
Alias loop::i#2 = loop::i#4 loop::i#3 
Alias loop::r#2 = loop::r#3 loop::r#4 
Alias loop::a#2 = loop::a#3 loop::a#4 
Alias loop::angle#10 = loop::angle#9 loop::angle#7 loop::angle#5 loop::angle#3 
Alias loop::x#0 = loop::$3 
Alias mulf8s::return#3 = mulf8s::return#6 
Alias loop::y#0 = loop::$7 
Alias loop::angle#19 = loop::angle#20 
Alias loop::i1#5 = loop::i1#7 loop::i1#8 loop::i1#6 
Alias loop::angle#15 = loop::angle#17 loop::angle#18 loop::angle#16 
Alias loop::plexFreeNextYpos1_return#0 = loop::plexFreeNextYpos1_return#2 loop::plexFreeNextYpos1_return#1 loop::plexFreeNextYpos1_return#3 loop::$13 loop::rasterY#0 
Alias loop::i1#2 = loop::i1#3 loop::i1#4 
Alias loop::angle#11 = loop::angle#13 loop::angle#14 loop::angle#12 loop::angle#8 
Alias keyboard_key_pressed::return#3 = keyboard_key_pressed::return#6 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Alias mulf_init::sqr1_lo#2 = mulf_init::sqr1_lo#3 
Alias mulf_init::sqr1_hi#2 = mulf_init::sqr1_hi#3 
Alias mulf_init::c#1 = mulf_init::c#4 
Alias mulf_init::sqr2_lo#2 = mulf_init::sqr2_lo#4 
Alias mulf_init::x_255#1 = mulf_init::x_255#4 
Alias mulf_init::sqr2_hi#1 = mulf_init::sqr2_hi#4 
Alias mulf8s_prepared::b#1 = mulf8s_prepared::b#2 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Identical Phi Values plexInit::plexSetScreen1_screen#0 plexInit::screen#0
Identical Phi Values plexSort::nxt_y#1 plexSort::nxt_y#0
Identical Phi Values plexSort::nxt_idx#1 plexSort::nxt_idx#0
Identical Phi Values plexSort::m#5 plexSort::m#2
Identical Phi Values mulf8u_prepare::a#1 mulf8u_prepare::a#0
Identical Phi Values mulf8u_prepared::b#1 mulf8u_prepared::b#0
Identical Phi Values mulf8s_prepared::b#1 mulf8s_prepared::b#0
Identical Phi Values memset::num#1 memset::num#0
Identical Phi Values memset::str#2 memset::str#0
Identical Phi Values memset::c#3 memset::c#0
Identical Phi Values memset::end#1 memset::end#0
Identical Phi Values memset::str#4 memset::str#2
Identical Phi Values memset::c#1 memset::c#3
Identical Phi Values keyboard_matrix_read::rowid#1 keyboard_matrix_read::rowid#0
Identical Phi Values loop::angle#2 loop::angle#6
Identical Phi Values loop::angle#10 loop::angle#2
Identical Phi Values loop::angle#19 loop::angle#1
Identical Phi Values loop::rasterY#1 loop::plexFreeNextYpos1_return#0
Identical Phi Values loop::i1#2 loop::i1#5
Identical Phi Values loop::angle#11 loop::angle#15
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values plexSort::m#3 plexSort::m#2
Identical Phi Values memset::return#0 memset::str#0
Identical Phi Values loop::angle#15 loop::angle#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [65] plexShowSprite::$11 = plexShowSprite::xpos_idx#0 * SIZEOF_WORD
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition plexInit::$1 [8] if(plexInit::i#1!=rangelast(0,PLEX_COUNT-1)) goto plexInit::@1
Simple Condition plexSort::$3 [16] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2
Simple Condition plexSort::$8 [20] if(plexSort::m#1!=rangelast(0,PLEX_COUNT-2)) goto plexSort::@1
Simple Condition plexSort::plexFreePrepare1_$0 [39] if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1
Simple Condition plexShowSprite::$4 [58] if(plexShowSprite::$3!=0) goto plexShowSprite::@1
Simple Condition plexShowSprite::$8 [68] if(plex_sprite_msb!=0) goto plexShowSprite::@return
Simple Condition mulf_init::$0 [78] if(mulf_init::sqr1_lo#2!=mulf_sqr1_lo+$200) goto mulf_init::@2
Simple Condition mulf_init::$3 [82] if(mulf_init::$1!=0) goto mulf_init::@4
Simple Condition mulf_init::$7 [99] if(mulf_init::sqr2_lo#2!=mulf_sqr2_lo+$1ff) goto mulf_init::@7
Simple Condition mulf_init::$10 [105] if(mulf_init::x_255#1!=0) goto mulf_init::@9
Simple Condition mulf8s_prepared::$2 [127] if(*mulf8s_prepared::memA>=0) goto mulf8s_prepared::@1
Simple Condition mulf8s_prepared::$4 [130] if(mulf8s_prepared::b#0>=0) goto mulf8s_prepared::@2
Simple Condition memset::$1 [152] if(memset::num#0<=0) goto memset::@1
Simple Condition memset::$3 [159] if(memset::dst#2!=memset::end#0) goto memset::@4
Simple Condition init::$7 [197] if(init::i#1!=rangelast(0,PLEX_COUNT-1)) goto init::@1
Simple Condition init::$8 [204] if(init::i1#1!=rangelast(0,7)) goto init::@3
Simple Condition exit::$1 [217] if(0!=exit::$0) goto exit::@1
Simple Condition loop::$0 [224] if(*RASTER<$d8) goto loop::@2
Simple Condition loop::$9 [253] if(loop::i#1!=rangelast(0,NUM_BOBS-1)) goto loop::@4
Simple Condition loop::$12 [261] if(loop::$11!=0) goto loop::@6
Simple Condition loop::$14 [268] if(*RASTER<loop::plexFreeNextYpos1_return#0) goto loop::@9
Simple Condition loop::$17 [273] if(loop::i1#1!=rangelast(0,PLEX_COUNT-1)) goto loop::@8
Simple Condition loop::$19 [280] if(0==loop::$18) goto loop::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [27] plexSort::$7 = plexSort::$5 && plexSort::$6
Successful SSA optimization Pass2ConditionalAndOrRewriting
Negating conditional jump and destination [280] if(0!=loop::$18) goto loop::@return
Constant plexInit::i#0 = 0
Constant plexSort::m#0 = 0
Constant plexSort::plexFreePrepare1_s#0 = 0
Constant mulf_init::sqr#0 = 0
Constant mulf_init::x_2#0 = 0
Constant mulf_init::c#0 = 0
Constant mulf_init::sqr1_hi#0 = mulf_sqr1_hi+1
Constant mulf_init::sqr1_lo#0 = mulf_sqr1_lo+1
Constant mulf_init::x_255#0 = -1
Constant mulf_init::dir#0 = $ff
Constant mulf_init::sqr2_hi#0 = mulf_sqr2_hi
Constant mulf_init::sqr2_lo#0 = mulf_sqr2_lo
Constant mulf_init::dir#1 = 1
Constant plexInit::screen#0 = SCREEN
Constant init::i#0 = 0
Constant init::i1#0 = 0
Constant memset::str#0 = (void*)SCREEN
Constant memset::c#0 = ' '
Constant memset::num#0 = $3e8
Constant keyboard_key_pressed::key#0 = KEY_SPACE
Constant loop::angle#0 = 0
Constant loop::r#0 = $1e
Constant loop::i#0 = 0
Constant loop::i1#0 = 0
Constant keyboard_key_pressed::key#1 = KEY_SPACE
Successful SSA optimization Pass2ConstantIdentification
Constant memset::$4 = (byte*)memset::str#0
Constant memset::dst#0 = (byte*)memset::str#0
Constant memset::return#2 = memset::str#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always false - eliminating [152] if(memset::num#0<=0) goto memset::@1
if() condition always true - replacing block destination [221] if(true) goto loop::@2
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [6] plexInit::i#1 = ++ plexInit::i#2 to ++
Resolved ranged comparison value [8] if(plexInit::i#1!=rangelast(0,PLEX_COUNT-1)) goto plexInit::@1 to PLEX_COUNT-1+1
Resolved ranged next value [18] plexSort::m#1 = ++ plexSort::m#2 to ++
Resolved ranged comparison value [20] if(plexSort::m#1!=rangelast(0,PLEX_COUNT-2)) goto plexSort::@1 to PLEX_COUNT-2+1
Resolved ranged next value [37] plexSort::plexFreePrepare1_s#1 = ++ plexSort::plexFreePrepare1_s#2 to ++
Resolved ranged comparison value [39] if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1 to 8
Resolved ranged next value [195] init::i#1 = ++ init::i#2 to ++
Resolved ranged comparison value [197] if(init::i#1!=rangelast(0,PLEX_COUNT-1)) goto init::@1 to PLEX_COUNT-1+1
Resolved ranged next value [202] init::i1#1 = ++ init::i1#2 to ++
Resolved ranged comparison value [204] if(init::i1#1!=rangelast(0,7)) goto init::@3 to 8
Resolved ranged next value [251] loop::i#1 = ++ loop::i#2 to ++
Resolved ranged comparison value [253] if(loop::i#1!=rangelast(0,NUM_BOBS-1)) goto loop::@4 to NUM_BOBS-1+1
Resolved ranged next value [271] loop::i1#1 = ++ loop::i1#5 to ++
Resolved ranged comparison value [273] if(loop::i1#1!=rangelast(0,PLEX_COUNT-1)) goto loop::@8 to PLEX_COUNT-1+1
Simplifying expression containing zero (byte*)CIA1 in [164] *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_A) = keyboard_matrix_row_bitmask[keyboard_matrix_read::rowid#0]
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant memset::return#2
Eliminating unused constant OFFSET_STRUCT_MOS6526_CIA_PORT_A
Successful SSA optimization PassNEliminateUnusedVars
Adding number conversion cast (unumber) PLEX_COUNT-1+1 in if(plexInit::i#1!=PLEX_COUNT-1+1) goto plexInit::@1
Adding number conversion cast (unumber) 1 in if(plexInit::i#1!=(unumber)PLEX_COUNT-1+1) goto plexInit::@1
Adding number conversion cast (unumber) PLEX_COUNT-2+1 in if(plexSort::m#1!=PLEX_COUNT-2+1) goto plexSort::@1
Adding number conversion cast (unumber) 1 in if(plexSort::m#1!=(unumber)PLEX_COUNT-2+1) goto plexSort::@1
Adding number conversion cast (unumber) 8 in if(plexSort::plexFreePrepare1_s#1!=8) goto plexSort::plexFreePrepare1_@1
Adding number conversion cast (unumber) PLEX_COUNT-1+1 in if(init::i#1!=PLEX_COUNT-1+1) goto init::@1
Adding number conversion cast (unumber) 1 in if(init::i#1!=(unumber)PLEX_COUNT-1+1) goto init::@1
Adding number conversion cast (unumber) 8 in if(init::i1#1!=8) goto init::@3
Adding number conversion cast (unumber) NUM_BOBS-1+1 in if(loop::i#1!=NUM_BOBS-1+1) goto loop::@4
Adding number conversion cast (unumber) 1 in if(loop::i#1!=(unumber)NUM_BOBS-1+1) goto loop::@4
Adding number conversion cast (unumber) PLEX_COUNT-1+1 in if(loop::i1#1!=PLEX_COUNT-1+1) goto loop::@8
Adding number conversion cast (unumber) 1 in if(loop::i1#1!=(unumber)PLEX_COUNT-1+1) goto loop::@8
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast PLEX_COUNT-1+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast PLEX_COUNT-2+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Simplifying constant integer cast PLEX_COUNT-1+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Simplifying constant integer cast NUM_BOBS-1+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast PLEX_COUNT-1+(unumber)1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Alias plexShowSprite::$11 = plexShowSprite::$10 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)PLEX_SCREEN_PTR = plexInit::plexSetScreen1_$0 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Simple Condition plexSort::$5 [20] if(plexSort::s#1!=$ff) goto plexSort::@7
Simple Condition plexSort::$6 [223] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [20] if(plexSort::s#1==$ff) goto plexSort::@4
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [0] plexInit::plexSetScreen1_$0 = plexInit::screen#0 + $3f8
Constant right-side identified [118] memset::end#0 = memset::$4 + memset::num#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant plexInit::plexSetScreen1_$0 = plexInit::screen#0+$3f8
Constant memset::end#0 = memset::$4+memset::num#0
Successful SSA optimization Pass2ConstantIdentification
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Inlining Noop Cast [97] mulf8s_prepared::$13 = (byte)mulf8s_prepared::b#0 keeping mulf8s_prepared::b#0
Inlining Noop Cast [101] mulf8s_prepared::return#0 = (signed word)mulf8s_prepared::m#4 keeping mulf8s_prepared::m#4
Inlining Noop Cast [103] mulf8s_prepared::$14 = (byte)*mulf8s_prepared::memA keeping *mulf8s_prepared::memA
Successful SSA optimization Pass2NopCastInlining
Inlining Noop Cast [112] mulf8s_prepared::return#2 = (signed word)mulf8s_prepared::m#4 keeping mulf8s_prepared::m#4
Successful SSA optimization Pass2NopCastInlining
Rewriting multiplication to use shift [29] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx * 2
Rewriting multiplication to use shift [39] plexShowSprite::$11 = plexShowSprite::xpos_idx#0 * SIZEOF_WORD
Rewriting multiplication to use shift and addition[142] init::$3 = init::i#2 * 5
Rewriting multiplication to use shift [144] init::$9 = init::i#2 * SIZEOF_WORD
Rewriting multiplication to use shift [146] init::$5 = init::i#2 * 8
Rewriting multiplication to use shift [174] loop::$2 = loop::$1 * 2
Rewriting multiplication to use shift [177] loop::$20 = loop::i#2 * SIZEOF_WORD
Rewriting multiplication to use shift [184] loop::$6 = loop::$5 * 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings plexInit::i#0
Inlining constant with var siblings plexSort::m#0
Inlining constant with var siblings plexSort::plexFreePrepare1_s#0
Inlining constant with var siblings mulf_init::sqr#0
Inlining constant with var siblings mulf_init::x_2#0
Inlining constant with var siblings mulf_init::c#0
Inlining constant with var siblings mulf_init::sqr1_hi#0
Inlining constant with var siblings mulf_init::sqr1_lo#0
Inlining constant with var siblings mulf_init::x_255#0
Inlining constant with var siblings mulf_init::dir#0
Inlining constant with var siblings mulf_init::sqr2_hi#0
Inlining constant with var siblings mulf_init::sqr2_lo#0
Inlining constant with var siblings mulf_init::dir#1
Inlining constant with var siblings memset::dst#0
Inlining constant with var siblings keyboard_key_pressed::key#0
Inlining constant with var siblings keyboard_key_pressed::key#1
Inlining constant with var siblings init::i#0
Inlining constant with var siblings init::i1#0
Inlining constant with var siblings loop::angle#0
Inlining constant with var siblings loop::r#0
Inlining constant with var siblings loop::i#0
Inlining constant with var siblings loop::i1#0
Constant inlined mulf_init::c#0 = 0
Constant inlined mulf_init::sqr2_lo#0 = mulf_sqr2_lo
Constant inlined init::i#0 = 0
Constant inlined mulf_init::sqr2_hi#0 = mulf_sqr2_hi
Constant inlined plexSort::plexFreePrepare1_s#0 = 0
Constant inlined plexInit::i#0 = 0
Constant inlined plexSort::m#0 = 0
Constant inlined mulf_init::dir#1 = 1
Constant inlined mulf_init::dir#0 = $ff
Constant inlined memset::$4 = (byte*)memset::str#0
Constant inlined mulf_init::x_255#0 = -1
Constant inlined mulf_init::x_2#0 = 0
Constant inlined keyboard_key_pressed::key#0 = KEY_SPACE
Constant inlined keyboard_key_pressed::key#1 = KEY_SPACE
Constant inlined mulf_init::sqr#0 = 0
Constant inlined plexInit::plexSetScreen1_$0 = SCREEN+$3f8
Constant inlined loop::i1#0 = 0
Constant inlined plexInit::screen#0 = SCREEN
Constant inlined loop::angle#0 = 0
Constant inlined loop::i#0 = 0
Constant inlined mulf_init::sqr1_hi#0 = mulf_sqr1_hi+1
Constant inlined init::i1#0 = 0
Constant inlined mulf_init::sqr1_lo#0 = mulf_sqr1_lo+1
Constant inlined memset::dst#0 = (byte*)memset::str#0
Constant inlined loop::r#0 = $1e
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment (PLEX_SORTED_IDX+1)[plexSort::$1]
Consolidated array index constant in assignment (PLEX_SORTED_IDX+1)[plexSort::$4]
Successful SSA optimization Pass2ConstantAdditionElimination
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Alias plexSort::m#2 = plexSort::$1 
Alias plexSort::s#3 = plexSort::$4 
Alias init::$3 = init::$11 
Successful SSA optimization Pass2AliasElimination
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Identical Phi Values keyboard_key_pressed::key#2 KEY_SPACE
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [118] keyboard_key_pressed::colidx#0 = KEY_SPACE & 7
Constant right-side identified [119] keyboard_key_pressed::rowidx#0 = KEY_SPACE >> 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant keyboard_key_pressed::colidx#0 = KEY_SPACE&7
Constant keyboard_key_pressed::rowidx#0 = KEY_SPACE>>3
Successful SSA optimization Pass2ConstantIdentification
Constant keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Constant inlined keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(keyboard_matrix_row_bitmask+keyboard_key_pressed::rowidx#0)
Consolidated array index constant in *(keyboard_matrix_col_bitmask+keyboard_key_pressed::colidx#0)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Finalized unsigned number type (word) $200
Finalized unsigned number type (word) $200
Finalized unsigned number type (word) $200
Finalized unsigned number type (word) $200
Finalized unsigned number type (word) $200
Finalized unsigned number type (word) $200
Finalized unsigned number type (word) $200
Finalized unsigned number type (word) $200
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Finalized unsigned number type (word) $140
Finalized unsigned number type (byte) $7d
Finalized unsigned number type (word) $100
Finalized unsigned number type (byte) $7d
Finalized unsigned number type (word) $100
Finalized unsigned number type (word) $400
Finalized unsigned number type (word) $3f8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Alias candidate removed (volatile)plex_free_next = plexShowSprite::plexFreeAdd1_$2 
Alias candidate removed (volatile)plex_sprite_idx = plexShowSprite::$6 
Added new block during phi lifting plexInit::@3(between plexInit::@1 and plexInit::@1)
Added new block during phi lifting plexSort::@8(between plexSort::@2 and plexSort::@1)
Added new block during phi lifting plexSort::@9(between plexSort::@7 and plexSort::@3)
Added new block during phi lifting plexSort::@10(between plexSort::plexFreePrepare1_@1 and plexSort::plexFreePrepare1_@1)
Added new block during phi lifting mulf_init::@11(between mulf_init::@2 and mulf_init::@4)
Added new block during phi lifting mulf_init::@12(between mulf_init::@7 and mulf_init::@9)
Added new block during phi lifting mulf8s_prepared::@6(between mulf8s_prepared::@5 and mulf8s_prepared::@1)
Added new block during phi lifting mulf8s_prepared::@7(between mulf8s_prepared::@1 and mulf8s_prepared::@2)
Added new block during phi lifting init::@8(between init::@1 and init::@1)
Added new block during phi lifting init::@9(between init::@3 and init::@3)
Added new block during phi lifting loop::@18(between loop::@17 and loop::@1)
Added new block during phi lifting loop::@19(between loop::@14 and loop::@4)
Added new block during phi lifting loop::@20(between loop::@16 and loop::@8)
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of __start::@2
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of init::@5
Adding NOP phi() at start of init::@4
Adding NOP phi() at start of init::@6
Adding NOP phi() at start of init::@7
Adding NOP phi() at start of loop
Adding NOP phi() at start of loop::@7
Adding NOP phi() at start of loop::plexFreeNextYpos1_@return
Adding NOP phi() at start of loop::@12
Adding NOP phi() at start of exit
Adding NOP phi() at start of exit::@1
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::@2
Adding NOP phi() at start of mulf_init
Adding NOP phi() at start of mulf_init::@3
Adding NOP phi() at start of mulf_init::@10
Adding NOP phi() at start of memset
Adding NOP phi() at start of memset::@2
Adding NOP phi() at start of memset::@1
Adding NOP phi() at start of mulf8s::@2
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of keyboard_key_pressed
CALL GRAPH
Calls in [__start] to main:7 
Calls in [main] to init:11 loop:13 exit:15 
Calls in [init] to plexInit:19 mulf_init:39 memset:41 
Calls in [loop] to mulf8s:57 mulf8s:69 plexSort:81 plexShowSprite:94 keyboard_key_pressed:98 
Calls in [exit] to keyboard_key_pressed:110 
Calls in [mulf8s] to mulf8u_prepare:179 mulf8s_prepared:182 
Calls in [keyboard_key_pressed] to keyboard_matrix_read:240 
Calls in [mulf8s_prepared] to mulf8u_prepared:249 

Created 28 initial phi equivalence classes
Coalesced [44] init::i1#3 = init::i1#1
Coalesced [45] init::i#3 = init::i#1
Not coalescing [50] loop::a#6 = loop::angle#6
Coalesced [55] mulf8s::mulf8s_prepare1_a#3 = mulf8s::a#0
Coalesced [56] mulf8s::b#7 = mulf8s::b#0
Coalesced [67] mulf8s::mulf8s_prepare1_a#2 = mulf8s::a#1
Coalesced [68] mulf8s::b#6 = mulf8s::b#1
Coalesced [102] loop::angle#21 = loop::angle#1
Coalesced [104] loop::i1#9 = loop::i1#1
Coalesced [105] loop::r#5 = loop::r#1
Coalesced [106] loop::a#5 = loop::a#1
Coalesced [107] loop::i#5 = loop::i#1
Coalesced [123] plexInit::i#3 = plexInit::i#1
Coalesced [141] mulf_init::sqr2_lo#6 = mulf_init::sqr2_lo#1
Coalesced [142] mulf_init::x_255#6 = mulf_init::x_255#1
Coalesced [143] mulf_init::sqr2_hi#6 = mulf_init::sqr2_hi#1
Coalesced [144] mulf_init::dir#5 = mulf_init::dir#4
Coalesced (already) [145] mulf_init::dir#6 = mulf_init::dir#2
Coalesced [151] mulf_init::sqr#9 = mulf_init::sqr#2
Coalesced [152] mulf_init::x_2#8 = mulf_init::x_2#1
Coalesced [161] mulf_init::sqr1_lo#6 = mulf_init::sqr1_lo#1
Coalesced [162] mulf_init::c#6 = mulf_init::c#1
Coalesced [163] mulf_init::sqr#7 = mulf_init::sqr#1
Coalesced [164] mulf_init::sqr1_hi#6 = mulf_init::sqr1_hi#1
Coalesced [165] mulf_init::x_2#6 = mulf_init::x_2#2
Coalesced [166] mulf_init::sqr#8 = mulf_init::sqr#4
Coalesced (already) [167] mulf_init::x_2#7 = mulf_init::x_2#3
Coalesced [176] memset::dst#4 = memset::dst#1
Not coalescing [190] plexSort::s#6 = plexSort::m#2
Coalesced [210] plexSort::plexFreePrepare1_s#3 = plexSort::plexFreePrepare1_s#1
Coalesced [211] plexSort::m#7 = plexSort::m#1
Coalesced [212] plexSort::s#5 = plexSort::s#1
Coalesced [256] mulf8s_prepared::m#7 = mulf8s_prepared::m#1
Coalesced [262] mulf8s_prepared::m#10 = mulf8s_prepared::m#2
Coalesced [265] mulf8s_prepared::m#9 = mulf8s_prepared::m#5
Coalesced [266] mulf8s_prepared::m#8 = mulf8s_prepared::m#0
Coalesced down to 24 phi equivalence classes
Culled Empty Block label __start::@2
Culled Empty Block label init::@5
Culled Empty Block label init::@7
Culled Empty Block label init::@9
Culled Empty Block label init::@8
Culled Empty Block label loop::@7
Culled Empty Block label loop::plexFreeNextYpos1_@return
Culled Empty Block label loop::@12
Culled Empty Block label loop::@18
Culled Empty Block label loop::@20
Culled Empty Block label loop::@19
Culled Empty Block label plexInit::@2
Culled Empty Block label plexInit::@3
Culled Empty Block label mulf_init::@3
Culled Empty Block label mulf_init::@10
Culled Empty Block label mulf_init::@11
Culled Empty Block label memset::@2
Culled Empty Block label memset::@1
Culled Empty Block label mulf8s::@2
Culled Empty Block label plexSort::@10
Culled Empty Block label plexSort::@8
Culled Empty Block label plexSort::@9
Culled Empty Block label mulf8s_prepared::@7
Culled Empty Block label mulf8s_prepared::@6
Renumbering block mulf_init::@4 to mulf_init::@3
Renumbering block mulf_init::@5 to mulf_init::@4
Renumbering block mulf_init::@6 to mulf_init::@5
Renumbering block mulf_init::@7 to mulf_init::@6
Renumbering block mulf_init::@8 to mulf_init::@7
Renumbering block mulf_init::@9 to mulf_init::@8
Renumbering block mulf_init::@12 to mulf_init::@9
Renumbering block mulf8s::@3 to mulf8s::@2
Renumbering block memset::@3 to memset::@1
Renumbering block memset::@4 to memset::@2
Renumbering block init::@6 to init::@5
Renumbering block loop::@8 to loop::@7
Renumbering block loop::@9 to loop::@8
Renumbering block loop::@10 to loop::@9
Renumbering block loop::@11 to loop::@10
Renumbering block loop::@13 to loop::@11
Renumbering block loop::@14 to loop::@12
Renumbering block loop::@15 to loop::@13
Renumbering block loop::@16 to loop::@14
Renumbering block loop::@17 to loop::@15
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of init::@4
Adding NOP phi() at start of init::@5
Adding NOP phi() at start of loop
Adding NOP phi() at start of exit
Adding NOP phi() at start of exit::@1
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of mulf_init
Adding NOP phi() at start of mulf_init::@9
Adding NOP phi() at start of memset
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of keyboard_key_pressed

FINAL CONTROL FLOW GRAPH

void __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] PLEX_SCREEN_PTR = (byte*)$400+$3f8
  [2] plex_show_idx = 0
  [3] plex_sprite_idx = 0
  [4] plex_sprite_msb = 1
  [5] plex_free_next = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [6] phi()
  [7] call main 
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [8] return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  asm { sei  }
  [10] call init 
  to:main::@1
main::@1: scope:[main]  from main
  [11] phi()
  [12] call loop 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [13] phi()
  [14] call exit 
  to:main::@3
main::@3: scope:[main]  from main::@2
  asm { cli  }
  to:main::@return
main::@return: scope:[main]  from main::@3
  [16] return 
  to:@return

void init()
init: scope:[init]  from main
  [17] *D011 = VIC_DEN|VIC_RSEL|3
  [18] call plexInit 
  to:init::@1
init::@1: scope:[init]  from init init::@1
  [19] init::i#2 = phi( init::@1/init::i#1, init/0 )
  [20] PLEX_PTR[init::i#2] = (byte)SPRITE/$40
  [21] init::$10 = init::i#2 << 2
  [22] init::$3 = init::$10 + init::i#2
  [23] init::$4 = $18 + init::$3
  [24] init::$9 = init::i#2 << 1
  [25] PLEX_XPOS[init::$9] = init::$4
  [26] init::$5 = init::i#2 << 3
  [27] init::$6 = $32 + init::$5
  [28] PLEX_YPOS[init::i#2] = init::$6
  [29] init::i#1 = ++ init::i#2
  [30] if(init::i#1!=PLEX_COUNT-1+1) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  [31] *SPRITES_ENABLE = $ff
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  [32] init::i1#2 = phi( init::@2/0, init::@3/init::i1#1 )
  [33] SPRITES_COLOR[init::i1#2] = GREEN
  [34] init::i1#1 = ++ init::i1#2
  [35] if(init::i1#1!=8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  [36] phi()
  [37] call mulf_init 
  to:init::@5
init::@5: scope:[init]  from init::@4
  [38] phi()
  [39] call memset 
  to:init::@return
init::@return: scope:[init]  from init::@5
  [40] return 
  to:@return

void loop()
loop: scope:[loop]  from main::@1
  [41] phi()
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@15
  [42] loop::angle#6 = phi( loop/0, loop::@15/loop::angle#1 )
  to:loop::@2
loop::@2: scope:[loop]  from loop::@1 loop::@2
  [43] if(*RASTER<$d8) goto loop::@2
  to:loop::@3
loop::@3: scope:[loop]  from loop::@2
  [44] *BORDER_COLOR = $f
  [45] loop::a#6 = loop::angle#6
  to:loop::@4
loop::@4: scope:[loop]  from loop::@12 loop::@3
  [46] loop::i#2 = phi( loop::@12/loop::i#1, loop::@3/0 )
  [46] loop::a#2 = phi( loop::@12/loop::a#1, loop::@3/loop::a#6 )
  [46] loop::r#2 = phi( loop::@12/loop::r#1, loop::@3/$1e )
  [47] *BORDER_COLOR = 6
  [48] mulf8s::a#0 = loop::r#2
  [49] mulf8s::b#0 = COS[loop::a#2]
  [50] call mulf8s 
  [51] mulf8s::return#2 = mulf8s::return#0
  to:loop::@11
loop::@11: scope:[loop]  from loop::@4
  [52] loop::$1 = mulf8s::return#2
  [53] loop::$2 = loop::$1 << 1
  [54] loop::x#0 = loop::$2 + (signed word)$7d*$100
  [55] loop::$4 = > loop::x#0
  [56] loop::$20 = loop::i#2 << 1
  [57] PLEX_XPOS[loop::$20] = loop::$4
  [58] mulf8s::a#1 = loop::r#2
  [59] mulf8s::b#1 = SIN[loop::a#2]
  [60] call mulf8s 
  [61] mulf8s::return#3 = mulf8s::return#0
  to:loop::@12
loop::@12: scope:[loop]  from loop::@11
  [62] loop::$5 = mulf8s::return#3
  [63] loop::$6 = loop::$5 << 1
  [64] loop::y#0 = loop::$6 + (signed word)$7d*$100
  [65] loop::$8 = > loop::y#0
  [66] PLEX_YPOS[loop::i#2] = loop::$8
  [67] loop::a#1 = loop::a#2 + $62
  [68] loop::r#1 = loop::r#2 + 3
  [69] loop::i#1 = ++ loop::i#2
  [70] if(loop::i#1!=NUM_BOBS-1+1) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@12
  [71] *BORDER_COLOR = 3
  [72] call plexSort 
  to:loop::@13
loop::@13: scope:[loop]  from loop::@5
  [73] loop::angle#1 = loop::angle#6 + 3
  [74] *BORDER_COLOR = BLACK
  to:loop::@6
loop::@6: scope:[loop]  from loop::@13 loop::@6
  [75] loop::$11 = *D011 & VIC_RST8
  [76] if(loop::$11!=0) goto loop::@6
  to:loop::@7
loop::@7: scope:[loop]  from loop::@14 loop::@6
  [77] loop::i1#5 = phi( loop::@14/loop::i1#1, loop::@6/0 )
  [78] *BORDER_COLOR = BLACK
  to:loop::plexFreeNextYpos1
loop::plexFreeNextYpos1: scope:[loop]  from loop::@7
  [79] loop::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next]
  to:loop::@8
loop::@8: scope:[loop]  from loop::@8 loop::plexFreeNextYpos1
  [80] if(*RASTER<loop::plexFreeNextYpos1_return#0) goto loop::@8
  to:loop::@9
loop::@9: scope:[loop]  from loop::@8
  [81] *BORDER_COLOR = ++ *BORDER_COLOR
  [82] call plexShowSprite 
  to:loop::@14
loop::@14: scope:[loop]  from loop::@9
  [83] loop::i1#1 = ++ loop::i1#5
  [84] if(loop::i1#1!=PLEX_COUNT-1+1) goto loop::@7
  to:loop::@10
loop::@10: scope:[loop]  from loop::@14
  [85] *BORDER_COLOR = BLACK
  [86] call keyboard_key_pressed 
  [87] keyboard_key_pressed::return#3 = keyboard_key_pressed::return#0
  to:loop::@15
loop::@15: scope:[loop]  from loop::@10
  [88] loop::$18 = keyboard_key_pressed::return#3
  [89] if(0!=loop::$18) goto loop::@return
  to:loop::@1
loop::@return: scope:[loop]  from loop::@15
  [90] return 
  to:@return

void exit()
exit: scope:[exit]  from main::@2
  [91] phi()
  to:exit::@1
exit::@1: scope:[exit]  from exit exit::@2
  [92] phi()
  [93] call keyboard_key_pressed 
  [94] keyboard_key_pressed::return#2 = keyboard_key_pressed::return#0
  to:exit::@2
exit::@2: scope:[exit]  from exit::@1
  [95] exit::$0 = keyboard_key_pressed::return#2
  [96] if(0!=exit::$0) goto exit::@1
  to:exit::@return
exit::@return: scope:[exit]  from exit::@2
  [97] return 
  to:@return

void plexInit(byte* plexInit::screen)
plexInit: scope:[plexInit]  from init
  [98] phi()
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  [99] PLEX_SCREEN_PTR = SCREEN+$3f8
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::plexSetScreen1
  [100] plexInit::i#2 = phi( plexInit::@1/plexInit::i#1, plexInit::plexSetScreen1/0 )
  [101] PLEX_SORTED_IDX[plexInit::i#2] = plexInit::i#2
  [102] plexInit::i#1 = ++ plexInit::i#2
  [103] if(plexInit::i#1!=PLEX_COUNT-1+1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  [104] return 
  to:@return

void mulf_init()
mulf_init: scope:[mulf_init]  from init::@4
  [105] phi()
  to:mulf_init::@1
mulf_init::@1: scope:[mulf_init]  from mulf_init mulf_init::@3
  [106] mulf_init::x_2#3 = phi( mulf_init/0, mulf_init::@3/mulf_init::x_2#2 )
  [106] mulf_init::sqr1_hi#2 = phi( mulf_init/mulf_sqr1_hi+1, mulf_init::@3/mulf_init::sqr1_hi#1 )
  [106] mulf_init::sqr#4 = phi( mulf_init/0, mulf_init::@3/mulf_init::sqr#1 )
  [106] mulf_init::c#2 = phi( mulf_init/0, mulf_init::@3/mulf_init::c#1 )
  [106] mulf_init::sqr1_lo#2 = phi( mulf_init/mulf_sqr1_lo+1, mulf_init::@3/mulf_init::sqr1_lo#1 )
  [107] if(mulf_init::sqr1_lo#2!=mulf_sqr1_lo+$200) goto mulf_init::@2
  to:mulf_init::@5
mulf_init::@5: scope:[mulf_init]  from mulf_init::@1 mulf_init::@8
  [108] mulf_init::dir#2 = phi( mulf_init::@1/$ff, mulf_init::@8/mulf_init::dir#4 )
  [108] mulf_init::sqr2_hi#2 = phi( mulf_init::@1/mulf_sqr2_hi, mulf_init::@8/mulf_init::sqr2_hi#1 )
  [108] mulf_init::x_255#2 = phi( mulf_init::@1/-1, mulf_init::@8/mulf_init::x_255#1 )
  [108] mulf_init::sqr2_lo#2 = phi( mulf_init::@1/mulf_sqr2_lo, mulf_init::@8/mulf_init::sqr2_lo#1 )
  [109] if(mulf_init::sqr2_lo#2!=mulf_sqr2_lo+$1ff) goto mulf_init::@6
  to:mulf_init::@7
mulf_init::@7: scope:[mulf_init]  from mulf_init::@5
  [110] *(mulf_sqr2_lo+$1ff) = *(mulf_sqr1_lo+$100)
  [111] *(mulf_sqr2_hi+$1ff) = *(mulf_sqr1_hi+$100)
  to:mulf_init::@return
mulf_init::@return: scope:[mulf_init]  from mulf_init::@7
  [112] return 
  to:@return
mulf_init::@6: scope:[mulf_init]  from mulf_init::@5
  [113] *mulf_init::sqr2_lo#2 = mulf_sqr1_lo[mulf_init::x_255#2]
  [114] *mulf_init::sqr2_hi#2 = mulf_sqr1_hi[mulf_init::x_255#2]
  [115] mulf_init::sqr2_hi#1 = ++ mulf_init::sqr2_hi#2
  [116] mulf_init::x_255#1 = mulf_init::x_255#2 + mulf_init::dir#2
  [117] if(mulf_init::x_255#1!=0) goto mulf_init::@9
  to:mulf_init::@8
mulf_init::@9: scope:[mulf_init]  from mulf_init::@6
  [118] phi()
  to:mulf_init::@8
mulf_init::@8: scope:[mulf_init]  from mulf_init::@6 mulf_init::@9
  [119] mulf_init::dir#4 = phi( mulf_init::@6/1, mulf_init::@9/mulf_init::dir#2 )
  [120] mulf_init::sqr2_lo#1 = ++ mulf_init::sqr2_lo#2
  to:mulf_init::@5
mulf_init::@2: scope:[mulf_init]  from mulf_init::@1
  [121] mulf_init::c#1 = ++ mulf_init::c#2
  [122] mulf_init::$1 = mulf_init::c#1 & 1
  [123] if(mulf_init::$1!=0) goto mulf_init::@3
  to:mulf_init::@4
mulf_init::@4: scope:[mulf_init]  from mulf_init::@2
  [124] mulf_init::x_2#1 = ++ mulf_init::x_2#3
  [125] mulf_init::sqr#2 = ++ mulf_init::sqr#4
  to:mulf_init::@3
mulf_init::@3: scope:[mulf_init]  from mulf_init::@2 mulf_init::@4
  [126] mulf_init::x_2#2 = phi( mulf_init::@2/mulf_init::x_2#3, mulf_init::@4/mulf_init::x_2#1 )
  [126] mulf_init::sqr#3 = phi( mulf_init::@2/mulf_init::sqr#4, mulf_init::@4/mulf_init::sqr#2 )
  [127] mulf_init::$4 = < mulf_init::sqr#3
  [128] *mulf_init::sqr1_lo#2 = mulf_init::$4
  [129] mulf_init::$5 = > mulf_init::sqr#3
  [130] *mulf_init::sqr1_hi#2 = mulf_init::$5
  [131] mulf_init::sqr1_hi#1 = ++ mulf_init::sqr1_hi#2
  [132] mulf_init::sqr#1 = mulf_init::sqr#3 + mulf_init::x_2#2
  [133] mulf_init::sqr1_lo#1 = ++ mulf_init::sqr1_lo#2
  to:mulf_init::@1

void* memset(void* memset::str , byte memset::c , word memset::num)
memset: scope:[memset]  from init::@5
  [134] phi()
  to:memset::@1
memset::@1: scope:[memset]  from memset memset::@2
  [135] memset::dst#2 = phi( memset/(byte*)memset::str#0, memset::@2/memset::dst#1 )
  [136] if(memset::dst#2!=memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset::@1
  [137] return 
  to:@return
memset::@2: scope:[memset]  from memset::@1
  [138] *memset::dst#2 = memset::c#0
  [139] memset::dst#1 = ++ memset::dst#2
  to:memset::@1

signed word mulf8s(signed byte mulf8s::a , signed byte mulf8s::b)
mulf8s: scope:[mulf8s]  from loop::@11 loop::@4
  [140] mulf8s::b#2 = phi( loop::@11/mulf8s::b#1, loop::@4/mulf8s::b#0 )
  [140] mulf8s::mulf8s_prepare1_a#0 = phi( loop::@11/mulf8s::a#1, loop::@4/mulf8s::a#0 )
  to:mulf8s::mulf8s_prepare1
mulf8s::mulf8s_prepare1: scope:[mulf8s]  from mulf8s
  [141] mulf8u_prepare::a#0 = (byte)mulf8s::mulf8s_prepare1_a#0
  [142] call mulf8u_prepare 
  to:mulf8s::@1
mulf8s::@1: scope:[mulf8s]  from mulf8s::mulf8s_prepare1
  [143] mulf8s_prepared::b#0 = mulf8s::b#2
  [144] call mulf8s_prepared 
  to:mulf8s::@2
mulf8s::@2: scope:[mulf8s]  from mulf8s::@1
  [145] mulf8s::return#0 = (signed word)mulf8s_prepared::m#4
  to:mulf8s::@return
mulf8s::@return: scope:[mulf8s]  from mulf8s::@2
  [146] return 
  to:@return

void plexSort()
plexSort: scope:[plexSort]  from loop::@5
  [147] phi()
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  [148] plexSort::m#2 = phi( plexSort/0, plexSort::@2/plexSort::m#1 )
  [149] plexSort::nxt_idx#0 = (PLEX_SORTED_IDX+1)[plexSort::m#2]
  [150] plexSort::nxt_y#0 = PLEX_YPOS[plexSort::nxt_idx#0]
  [151] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2
  to:plexSort::@5
plexSort::@5: scope:[plexSort]  from plexSort::@1
  [152] plexSort::s#6 = plexSort::m#2
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@5 plexSort::@7
  [153] plexSort::s#3 = phi( plexSort::@7/plexSort::s#1, plexSort::@5/plexSort::s#6 )
  [154] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3]
  [155] plexSort::s#1 = -- plexSort::s#3
  [156] if(plexSort::s#1==$ff) goto plexSort::@4
  to:plexSort::@7
plexSort::@7: scope:[plexSort]  from plexSort::@3
  [157] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3 plexSort::@7
  [158] plexSort::s#2 = ++ plexSort::s#1
  [159] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0
  to:plexSort::@2
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  [160] plexSort::m#1 = ++ plexSort::m#2
  [161] if(plexSort::m#1!=PLEX_COUNT-2+1) goto plexSort::@1
  to:plexSort::@6
plexSort::@6: scope:[plexSort]  from plexSort::@2
  [162] plex_show_idx = 0
  [163] plex_sprite_idx = 0
  [164] plex_sprite_msb = 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  [165] phi()
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  [166] plexSort::plexFreePrepare1_s#2 = phi( plexSort::plexFreePrepare1/0, plexSort::plexFreePrepare1_@1/plexSort::plexFreePrepare1_s#1 )
  [167] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0
  [168] plexSort::plexFreePrepare1_s#1 = ++ plexSort::plexFreePrepare1_s#2
  [169] if(plexSort::plexFreePrepare1_s#1!=8) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  [170] plex_free_next = 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  [171] return 
  to:@return

void plexShowSprite()
plexShowSprite: scope:[plexShowSprite]  from loop::@9
  [172] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1
  [173] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]]
  [174] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  [175] plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#0 + $15
  [176] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0
  [177] plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1
  [178] plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7
  [179] plex_free_next = plexShowSprite::plexFreeAdd1_$2
  to:plexShowSprite::@5
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  [180] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]]
  [181] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx]
  [182] plexShowSprite::$11 = plexShowSprite::xpos_idx#0 << 1
  [183] plexShowSprite::$2 = < PLEX_XPOS[plexShowSprite::$11]
  [184] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::$2
  [185] plexShowSprite::$3 = > PLEX_XPOS[plexShowSprite::$11]
  [186] if(plexShowSprite::$3!=0) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@5
  [187] plexShowSprite::$9 = $ff ^ plex_sprite_msb
  [188] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  [189] plexShowSprite::$5 = plex_sprite_idx + 1
  [190] plexShowSprite::$6 = plexShowSprite::$5 & 7
  [191] plex_sprite_idx = plexShowSprite::$6
  [192] plex_show_idx = ++ plex_show_idx
  [193] plex_sprite_msb = plex_sprite_msb << 1
  [194] if(plex_sprite_msb!=0) goto plexShowSprite::@return
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@2
  [195] plex_sprite_msb = 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@4
  [196] return 
  to:@return
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@5
  [197] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb
  to:plexShowSprite::@2

byte keyboard_key_pressed(byte keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from exit::@1 loop::@10
  [198] phi()
  [199] call keyboard_matrix_read 
  [200] keyboard_matrix_read::return#2 = keyboard_matrix_read::return#0
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  [201] keyboard_key_pressed::$2 = keyboard_matrix_read::return#2
  [202] keyboard_key_pressed::return#0 = keyboard_key_pressed::$2 & *(keyboard_matrix_col_bitmask+keyboard_key_pressed::colidx#0)
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  [203] return 
  to:@return

void mulf8u_prepare(byte mulf8u_prepare::a)
mulf8u_prepare: scope:[mulf8u_prepare]  from mulf8s::mulf8s_prepare1
  [204] *mulf8u_prepare::memA = mulf8u_prepare::a#0
  asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
  to:mulf8u_prepare::@return
mulf8u_prepare::@return: scope:[mulf8u_prepare]  from mulf8u_prepare
  [206] return 
  to:@return

signed word mulf8s_prepared(signed byte mulf8s_prepared::b)
mulf8s_prepared: scope:[mulf8s_prepared]  from mulf8s::@1
  [207] mulf8u_prepared::b#0 = (byte)mulf8s_prepared::b#0
  [208] call mulf8u_prepared 
  [209] mulf8u_prepared::return#2 = mulf8u_prepared::return#0
  to:mulf8s_prepared::@5
mulf8s_prepared::@5: scope:[mulf8s_prepared]  from mulf8s_prepared
  [210] mulf8s_prepared::m#0 = mulf8u_prepared::return#2
  [211] if(*mulf8s_prepared::memA>=0) goto mulf8s_prepared::@1
  to:mulf8s_prepared::@3
mulf8s_prepared::@3: scope:[mulf8s_prepared]  from mulf8s_prepared::@5
  [212] mulf8s_prepared::$6 = > mulf8s_prepared::m#0
  [213] mulf8s_prepared::$11 = mulf8s_prepared::$6 - (byte)mulf8s_prepared::b#0
  [214] mulf8s_prepared::m#1 = mulf8s_prepared::m#0 hi= mulf8s_prepared::$11
  to:mulf8s_prepared::@1
mulf8s_prepared::@1: scope:[mulf8s_prepared]  from mulf8s_prepared::@3 mulf8s_prepared::@5
  [215] mulf8s_prepared::m#5 = phi( mulf8s_prepared::@3/mulf8s_prepared::m#1, mulf8s_prepared::@5/mulf8s_prepared::m#0 )
  [216] if(mulf8s_prepared::b#0>=0) goto mulf8s_prepared::@2
  to:mulf8s_prepared::@4
mulf8s_prepared::@4: scope:[mulf8s_prepared]  from mulf8s_prepared::@1
  [217] mulf8s_prepared::$9 = > mulf8s_prepared::m#5
  [218] mulf8s_prepared::$12 = mulf8s_prepared::$9 - (byte)*mulf8s_prepared::memA
  [219] mulf8s_prepared::m#2 = mulf8s_prepared::m#5 hi= mulf8s_prepared::$12
  to:mulf8s_prepared::@2
mulf8s_prepared::@2: scope:[mulf8s_prepared]  from mulf8s_prepared::@1 mulf8s_prepared::@4
  [220] mulf8s_prepared::m#4 = phi( mulf8s_prepared::@1/mulf8s_prepared::m#5, mulf8s_prepared::@4/mulf8s_prepared::m#2 )
  to:mulf8s_prepared::@return
mulf8s_prepared::@return: scope:[mulf8s_prepared]  from mulf8s_prepared::@2
  [221] return 
  to:@return

byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  [222] *((byte*)CIA1) = *(keyboard_matrix_row_bitmask+keyboard_key_pressed::rowidx#0)
  [223] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B)
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  [224] return 
  to:@return

word mulf8u_prepared(byte mulf8u_prepared::b)
mulf8u_prepared: scope:[mulf8u_prepared]  from mulf8s_prepared
  [225] *mulf8u_prepared::memB = mulf8u_prepared::b#0
  asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
  [227] mulf8u_prepared::return#0 = *mulf8u_prepared::memB w= *mulf8u_prepared::resL
  to:mulf8u_prepared::@return
mulf8u_prepared::@return: scope:[mulf8u_prepared]  from mulf8u_prepared
  [228] return 
  to:@return


VARIABLE REGISTER WEIGHTS
volatile byte* PLEX_SCREEN_PTR loadstore 952.8679245283018
void __start()
void exit()
byte~ exit::$0 2002.0
void init()
byte~ init::$10 2002.0
byte~ init::$3 2002.0
byte~ init::$4 1001.0
byte~ init::$5 2002.0
byte~ init::$6 2002.0
byte~ init::$9 2002.0
byte init::i
byte init::i#1 1501.5
byte init::i#2 800.8000000000001
byte init::i1
byte init::i1#1 1501.5
byte init::i1#2 1501.5
byte keyboard_key_pressed(byte keyboard_key_pressed::key)
byte~ keyboard_key_pressed::$2 20002.0
byte keyboard_key_pressed::colidx
byte keyboard_key_pressed::key
byte keyboard_key_pressed::return
byte keyboard_key_pressed::return#0 3000.75
byte keyboard_key_pressed::return#2 2002.0
byte keyboard_key_pressed::return#3 2002.0
byte keyboard_key_pressed::rowidx
byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
byte keyboard_matrix_read::return
byte keyboard_matrix_read::return#0 36667.33333333333
byte keyboard_matrix_read::return#2 20002.0
byte keyboard_matrix_read::row_pressed_bits
byte keyboard_matrix_read::rowid
void loop()
signed word~ loop::$1 20002.0
byte~ loop::$11 20002.0
byte~ loop::$18 2002.0
signed word~ loop::$2 20002.0
byte~ loop::$20 20002.0
byte~ loop::$4 10001.0
signed word~ loop::$5 20002.0
signed word~ loop::$6 20002.0
byte~ loop::$8 20002.0
byte loop::a
byte loop::a#1 5000.5
byte loop::a#2 1952.6190476190475
byte loop::a#6 2002.0
byte loop::angle
byte loop::angle#1 117.76470588235294
byte loop::angle#6 96.87096774193549
byte loop::i
byte loop::i#1 15001.5
byte loop::i#2 1739.304347826087
byte loop::i1
byte loop::i1#1 15001.5
byte loop::i1#5 3333.6666666666665
byte loop::plexFreeNextYpos1_return
byte loop::plexFreeNextYpos1_return#0 55001.0
signed byte loop::r
signed byte loop::r#1 6667.333333333333
signed byte loop::r#2 1818.3636363636363
byte loop::rasterY
signed word loop::x
signed word loop::x#0 20002.0
signed word loop::y
signed word loop::y#0 20002.0
void main()
void* memset(void* memset::str , byte memset::c , word memset::num)
byte memset::c
byte* memset::dst
byte* memset::dst#1 20002.0
byte* memset::dst#2 13334.666666666666
byte* memset::end
word memset::num
void* memset::return
void* memset::str
signed word mulf8s(signed byte mulf8s::a , signed byte mulf8s::b)
signed byte mulf8s::a
signed byte mulf8s::a#0 10001.0
signed byte mulf8s::a#1 10001.0
signed byte mulf8s::b
signed byte mulf8s::b#0 20002.0
signed byte mulf8s::b#1 20002.0
signed byte mulf8s::b#2 40001.0
signed byte mulf8s::mulf8s_prepare1_a
signed byte mulf8s::mulf8s_prepare1_a#0 20002.0
signed word mulf8s::return
signed word mulf8s::return#0 30000.75
signed word mulf8s::return#2 20002.0
signed word mulf8s::return#3 20002.0
signed word mulf8s_prepared(signed byte mulf8s_prepared::b)
byte~ mulf8s_prepared::$11 2000002.0
byte~ mulf8s_prepared::$12 2000002.0
byte~ mulf8s_prepared::$6 2000002.0
byte~ mulf8s_prepared::$9 2000002.0
signed byte mulf8s_prepared::b
signed byte mulf8s_prepared::b#0 110000.20000000001
word mulf8s_prepared::m
word mulf8s_prepared::m#0 1000001.0
word mulf8s_prepared::m#1 2000002.0
word mulf8s_prepared::m#2 2000002.0
word mulf8s_prepared::m#4 666667.3333333334
word mulf8s_prepared::m#5 1250001.25
signed word mulf8s_prepared::return
void mulf8u_prepare(byte mulf8u_prepare::a)
byte mulf8u_prepare::a
byte mulf8u_prepare::a#0 1100002.0
word mulf8u_prepared(byte mulf8u_prepared::b)
byte mulf8u_prepared::b
byte mulf8u_prepared::b#0 1.1000002E7
word mulf8u_prepared::return
word mulf8u_prepared::return#0 3666667.333333333
word mulf8u_prepared::return#2 2000002.0
void mulf_init()
byte~ mulf_init::$1 20002.0
byte~ mulf_init::$4 20002.0
byte~ mulf_init::$5 20002.0
byte mulf_init::c
byte mulf_init::c#1 2307.9230769230767
byte mulf_init::c#2 10001.0
byte mulf_init::dir
byte mulf_init::dir#2 3750.375
byte mulf_init::dir#4 10001.0
word mulf_init::sqr
word mulf_init::sqr#1 10001.0
word mulf_init::sqr#2 20002.0
word mulf_init::sqr#3 8334.166666666666
word mulf_init::sqr#4 5000.5
byte* mulf_init::sqr1_hi
byte* mulf_init::sqr1_hi#1 6667.333333333333
byte* mulf_init::sqr1_hi#2 2500.25
byte* mulf_init::sqr1_lo
byte* mulf_init::sqr1_lo#1 20002.0
byte* mulf_init::sqr1_lo#2 2857.4285714285716
byte* mulf_init::sqr2_hi
byte* mulf_init::sqr2_hi#1 3333.6666666666665
byte* mulf_init::sqr2_hi#2 7500.75
byte* mulf_init::sqr2_lo
byte* mulf_init::sqr2_lo#1 20002.0
byte* mulf_init::sqr2_lo#2 4444.888888888889
byte mulf_init::x_2
byte mulf_init::x_2#1 10001.0
byte mulf_init::x_2#2 5000.5
byte mulf_init::x_2#3 6000.6
byte mulf_init::x_255
byte mulf_init::x_255#1 6000.6
byte mulf_init::x_255#2 8000.8
void plexInit(byte* plexInit::screen)
byte plexInit::i
byte plexInit::i#1 15001.5
byte plexInit::i#2 20002.0
byte* plexInit::plexSetScreen1_screen
byte* plexInit::screen
void plexShowSprite()
byte~ plexShowSprite::$11 100001.0
byte~ plexShowSprite::$2 200002.0
byte~ plexShowSprite::$3 200002.0
byte~ plexShowSprite::$5 200002.0
byte~ plexShowSprite::$6 200002.0
byte~ plexShowSprite::$9 200002.0
byte~ plexShowSprite::plexFreeAdd1_$0 200002.0
byte~ plexShowSprite::plexFreeAdd1_$1 200002.0
byte~ plexShowSprite::plexFreeAdd1_$2 200002.0
byte plexShowSprite::plexFreeAdd1_ypos
byte plexShowSprite::plexFreeAdd1_ypos#0 150001.5
byte plexShowSprite::plex_sprite_idx2
byte plexShowSprite::plex_sprite_idx2#0 25000.25
byte plexShowSprite::xpos_idx
byte plexShowSprite::xpos_idx#0 200002.0
byte plexShowSprite::ypos
void plexSort()
byte plexSort::m
byte plexSort::m#1 1500001.5
byte plexSort::m#2 416667.0833333334
byte plexSort::nxt_idx
byte plexSort::nxt_idx#0 300000.30000000005
byte plexSort::nxt_y
byte plexSort::nxt_y#0 1500000.375
byte plexSort::plexFreePrepare1_s
byte plexSort::plexFreePrepare1_s#1 1500001.5
byte plexSort::plexFreePrepare1_s#2 1500001.5
byte plexSort::s
byte plexSort::s#1 1.3666668333333332E7
byte plexSort::s#2 2000002.0
byte plexSort::s#3 2.05000025E7
byte plexSort::s#6 2000002.0
volatile byte plex_free_next loadstore 8205.307692307691
volatile byte plex_show_idx loadstore 10408.326530612245
volatile byte plex_sprite_idx loadstore 8913.195652173914
volatile byte plex_sprite_msb loadstore 12978.91489361702

Initial phi equivalence classes
[ init::i#2 init::i#1 ]
[ init::i1#2 init::i1#1 ]
[ loop::angle#6 loop::angle#1 ]
[ loop::r#2 loop::r#1 ]
[ loop::a#2 loop::a#1 loop::a#6 ]
[ loop::i#2 loop::i#1 ]
[ loop::i1#5 loop::i1#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
[ mulf_init::c#2 mulf_init::c#1 ]
[ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
[ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
[ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
[ mulf_init::x_255#2 mulf_init::x_255#1 ]
[ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
[ mulf_init::dir#2 mulf_init::dir#4 ]
[ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
[ memset::dst#2 memset::dst#1 ]
[ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ]
[ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ]
Added variable PLEX_SCREEN_PTR to live range equivalence class [ PLEX_SCREEN_PTR ]
Added variable plex_show_idx to live range equivalence class [ plex_show_idx ]
Added variable plex_sprite_idx to live range equivalence class [ plex_sprite_idx ]
Added variable plex_sprite_msb to live range equivalence class [ plex_sprite_msb ]
Added variable plex_free_next to live range equivalence class [ plex_free_next ]
Added variable init::$10 to live range equivalence class [ init::$10 ]
Added variable init::$3 to live range equivalence class [ init::$3 ]
Added variable init::$4 to live range equivalence class [ init::$4 ]
Added variable init::$9 to live range equivalence class [ init::$9 ]
Added variable init::$5 to live range equivalence class [ init::$5 ]
Added variable init::$6 to live range equivalence class [ init::$6 ]
Added variable mulf8s::return#2 to live range equivalence class [ mulf8s::return#2 ]
Added variable loop::$1 to live range equivalence class [ loop::$1 ]
Added variable loop::$2 to live range equivalence class [ loop::$2 ]
Added variable loop::x#0 to live range equivalence class [ loop::x#0 ]
Added variable loop::$4 to live range equivalence class [ loop::$4 ]
Added variable loop::$20 to live range equivalence class [ loop::$20 ]
Added variable mulf8s::return#3 to live range equivalence class [ mulf8s::return#3 ]
Added variable loop::$5 to live range equivalence class [ loop::$5 ]
Added variable loop::$6 to live range equivalence class [ loop::$6 ]
Added variable loop::y#0 to live range equivalence class [ loop::y#0 ]
Added variable loop::$8 to live range equivalence class [ loop::$8 ]
Added variable loop::$11 to live range equivalence class [ loop::$11 ]
Added variable loop::plexFreeNextYpos1_return#0 to live range equivalence class [ loop::plexFreeNextYpos1_return#0 ]
Added variable keyboard_key_pressed::return#3 to live range equivalence class [ keyboard_key_pressed::return#3 ]
Added variable loop::$18 to live range equivalence class [ loop::$18 ]
Added variable keyboard_key_pressed::return#2 to live range equivalence class [ keyboard_key_pressed::return#2 ]
Added variable exit::$0 to live range equivalence class [ exit::$0 ]
Added variable mulf_init::$1 to live range equivalence class [ mulf_init::$1 ]
Added variable mulf_init::$4 to live range equivalence class [ mulf_init::$4 ]
Added variable mulf_init::$5 to live range equivalence class [ mulf_init::$5 ]
Added variable mulf8u_prepare::a#0 to live range equivalence class [ mulf8u_prepare::a#0 ]
Added variable mulf8s_prepared::b#0 to live range equivalence class [ mulf8s_prepared::b#0 ]
Added variable mulf8s::return#0 to live range equivalence class [ mulf8s::return#0 ]
Added variable plexSort::nxt_idx#0 to live range equivalence class [ plexSort::nxt_idx#0 ]
Added variable plexSort::nxt_y#0 to live range equivalence class [ plexSort::nxt_y#0 ]
Added variable plexSort::s#2 to live range equivalence class [ plexSort::s#2 ]
Added variable plexShowSprite::plex_sprite_idx2#0 to live range equivalence class [ plexShowSprite::plex_sprite_idx2#0 ]
Added variable plexShowSprite::plexFreeAdd1_ypos#0 to live range equivalence class [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Added variable plexShowSprite::plexFreeAdd1_$0 to live range equivalence class [ plexShowSprite::plexFreeAdd1_$0 ]
Added variable plexShowSprite::plexFreeAdd1_$1 to live range equivalence class [ plexShowSprite::plexFreeAdd1_$1 ]
Added variable plexShowSprite::plexFreeAdd1_$2 to live range equivalence class [ plexShowSprite::plexFreeAdd1_$2 ]
Added variable plexShowSprite::xpos_idx#0 to live range equivalence class [ plexShowSprite::xpos_idx#0 ]
Added variable plexShowSprite::$11 to live range equivalence class [ plexShowSprite::$11 ]
Added variable plexShowSprite::$2 to live range equivalence class [ plexShowSprite::$2 ]
Added variable plexShowSprite::$3 to live range equivalence class [ plexShowSprite::$3 ]
Added variable plexShowSprite::$9 to live range equivalence class [ plexShowSprite::$9 ]
Added variable plexShowSprite::$5 to live range equivalence class [ plexShowSprite::$5 ]
Added variable plexShowSprite::$6 to live range equivalence class [ plexShowSprite::$6 ]
Added variable keyboard_matrix_read::return#2 to live range equivalence class [ keyboard_matrix_read::return#2 ]
Added variable keyboard_key_pressed::$2 to live range equivalence class [ keyboard_key_pressed::$2 ]
Added variable keyboard_key_pressed::return#0 to live range equivalence class [ keyboard_key_pressed::return#0 ]
Added variable mulf8u_prepared::b#0 to live range equivalence class [ mulf8u_prepared::b#0 ]
Added variable mulf8u_prepared::return#2 to live range equivalence class [ mulf8u_prepared::return#2 ]
Added variable mulf8s_prepared::$6 to live range equivalence class [ mulf8s_prepared::$6 ]
Added variable mulf8s_prepared::$11 to live range equivalence class [ mulf8s_prepared::$11 ]
Added variable mulf8s_prepared::$9 to live range equivalence class [ mulf8s_prepared::$9 ]
Added variable mulf8s_prepared::$12 to live range equivalence class [ mulf8s_prepared::$12 ]
Added variable keyboard_matrix_read::return#0 to live range equivalence class [ keyboard_matrix_read::return#0 ]
Added variable mulf8u_prepared::return#0 to live range equivalence class [ mulf8u_prepared::return#0 ]
Complete equivalence classes
[ init::i#2 init::i#1 ]
[ init::i1#2 init::i1#1 ]
[ loop::angle#6 loop::angle#1 ]
[ loop::r#2 loop::r#1 ]
[ loop::a#2 loop::a#1 loop::a#6 ]
[ loop::i#2 loop::i#1 ]
[ loop::i1#5 loop::i1#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
[ mulf_init::c#2 mulf_init::c#1 ]
[ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
[ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
[ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
[ mulf_init::x_255#2 mulf_init::x_255#1 ]
[ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
[ mulf_init::dir#2 mulf_init::dir#4 ]
[ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
[ memset::dst#2 memset::dst#1 ]
[ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ]
[ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ]
[ PLEX_SCREEN_PTR ]
[ plex_show_idx ]
[ plex_sprite_idx ]
[ plex_sprite_msb ]
[ plex_free_next ]
[ init::$10 ]
[ init::$3 ]
[ init::$4 ]
[ init::$9 ]
[ init::$5 ]
[ init::$6 ]
[ mulf8s::return#2 ]
[ loop::$1 ]
[ loop::$2 ]
[ loop::x#0 ]
[ loop::$4 ]
[ loop::$20 ]
[ mulf8s::return#3 ]
[ loop::$5 ]
[ loop::$6 ]
[ loop::y#0 ]
[ loop::$8 ]
[ loop::$11 ]
[ loop::plexFreeNextYpos1_return#0 ]
[ keyboard_key_pressed::return#3 ]
[ loop::$18 ]
[ keyboard_key_pressed::return#2 ]
[ exit::$0 ]
[ mulf_init::$1 ]
[ mulf_init::$4 ]
[ mulf_init::$5 ]
[ mulf8u_prepare::a#0 ]
[ mulf8s_prepared::b#0 ]
[ mulf8s::return#0 ]
[ plexSort::nxt_idx#0 ]
[ plexSort::nxt_y#0 ]
[ plexSort::s#2 ]
[ plexShowSprite::plex_sprite_idx2#0 ]
[ plexShowSprite::plexFreeAdd1_ypos#0 ]
[ plexShowSprite::plexFreeAdd1_$0 ]
[ plexShowSprite::plexFreeAdd1_$1 ]
[ plexShowSprite::plexFreeAdd1_$2 ]
[ plexShowSprite::xpos_idx#0 ]
[ plexShowSprite::$11 ]
[ plexShowSprite::$2 ]
[ plexShowSprite::$3 ]
[ plexShowSprite::$9 ]
[ plexShowSprite::$5 ]
[ plexShowSprite::$6 ]
[ keyboard_matrix_read::return#2 ]
[ keyboard_key_pressed::$2 ]
[ keyboard_key_pressed::return#0 ]
[ mulf8u_prepared::b#0 ]
[ mulf8u_prepared::return#2 ]
[ mulf8s_prepared::$6 ]
[ mulf8s_prepared::$11 ]
[ mulf8s_prepared::$9 ]
[ mulf8s_prepared::$12 ]
[ keyboard_matrix_read::return#0 ]
[ mulf8u_prepared::return#0 ]
Allocated zp[1]:2 [ init::i#2 init::i#1 ]
Allocated zp[1]:3 [ init::i1#2 init::i1#1 ]
Allocated zp[1]:4 [ loop::angle#6 loop::angle#1 ]
Allocated zp[1]:5 [ loop::r#2 loop::r#1 ]
Allocated zp[1]:6 [ loop::a#2 loop::a#1 loop::a#6 ]
Allocated zp[1]:7 [ loop::i#2 loop::i#1 ]
Allocated zp[1]:8 [ loop::i1#5 loop::i1#1 ]
Allocated zp[1]:9 [ plexInit::i#2 plexInit::i#1 ]
Allocated zp[2]:10 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
Allocated zp[1]:12 [ mulf_init::c#2 mulf_init::c#1 ]
Allocated zp[2]:13 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
Allocated zp[1]:15 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Allocated zp[2]:16 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
Allocated zp[1]:18 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Allocated zp[2]:19 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
Allocated zp[1]:21 [ mulf_init::dir#2 mulf_init::dir#4 ]
Allocated zp[2]:22 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
Allocated zp[2]:24 [ memset::dst#2 memset::dst#1 ]
Allocated zp[1]:26 [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ]
Allocated zp[1]:27 [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
Allocated zp[1]:28 [ plexSort::m#2 plexSort::m#1 ]
Allocated zp[1]:29 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Allocated zp[1]:30 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Allocated zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ]
Allocated zp[2]:33 [ PLEX_SCREEN_PTR ]
Allocated zp[1]:35 [ plex_show_idx ]
Allocated zp[1]:36 [ plex_sprite_idx ]
Allocated zp[1]:37 [ plex_sprite_msb ]
Allocated zp[1]:38 [ plex_free_next ]
Allocated zp[1]:39 [ init::$10 ]
Allocated zp[1]:40 [ init::$3 ]
Allocated zp[1]:41 [ init::$4 ]
Allocated zp[1]:42 [ init::$9 ]
Allocated zp[1]:43 [ init::$5 ]
Allocated zp[1]:44 [ init::$6 ]
Allocated zp[2]:45 [ mulf8s::return#2 ]
Allocated zp[2]:47 [ loop::$1 ]
Allocated zp[2]:49 [ loop::$2 ]
Allocated zp[2]:51 [ loop::x#0 ]
Allocated zp[1]:53 [ loop::$4 ]
Allocated zp[1]:54 [ loop::$20 ]
Allocated zp[2]:55 [ mulf8s::return#3 ]
Allocated zp[2]:57 [ loop::$5 ]
Allocated zp[2]:59 [ loop::$6 ]
Allocated zp[2]:61 [ loop::y#0 ]
Allocated zp[1]:63 [ loop::$8 ]
Allocated zp[1]:64 [ loop::$11 ]
Allocated zp[1]:65 [ loop::plexFreeNextYpos1_return#0 ]
Allocated zp[1]:66 [ keyboard_key_pressed::return#3 ]
Allocated zp[1]:67 [ loop::$18 ]
Allocated zp[1]:68 [ keyboard_key_pressed::return#2 ]
Allocated zp[1]:69 [ exit::$0 ]
Allocated zp[1]:70 [ mulf_init::$1 ]
Allocated zp[1]:71 [ mulf_init::$4 ]
Allocated zp[1]:72 [ mulf_init::$5 ]
Allocated zp[1]:73 [ mulf8u_prepare::a#0 ]
Allocated zp[1]:74 [ mulf8s_prepared::b#0 ]
Allocated zp[2]:75 [ mulf8s::return#0 ]
Allocated zp[1]:77 [ plexSort::nxt_idx#0 ]
Allocated zp[1]:78 [ plexSort::nxt_y#0 ]
Allocated zp[1]:79 [ plexSort::s#2 ]
Allocated zp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated zp[1]:81 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Allocated zp[1]:82 [ plexShowSprite::plexFreeAdd1_$0 ]
Allocated zp[1]:83 [ plexShowSprite::plexFreeAdd1_$1 ]
Allocated zp[1]:84 [ plexShowSprite::plexFreeAdd1_$2 ]
Allocated zp[1]:85 [ plexShowSprite::xpos_idx#0 ]
Allocated zp[1]:86 [ plexShowSprite::$11 ]
Allocated zp[1]:87 [ plexShowSprite::$2 ]
Allocated zp[1]:88 [ plexShowSprite::$3 ]
Allocated zp[1]:89 [ plexShowSprite::$9 ]
Allocated zp[1]:90 [ plexShowSprite::$5 ]
Allocated zp[1]:91 [ plexShowSprite::$6 ]
Allocated zp[1]:92 [ keyboard_matrix_read::return#2 ]
Allocated zp[1]:93 [ keyboard_key_pressed::$2 ]
Allocated zp[1]:94 [ keyboard_key_pressed::return#0 ]
Allocated zp[1]:95 [ mulf8u_prepared::b#0 ]
Allocated zp[2]:96 [ mulf8u_prepared::return#2 ]
Allocated zp[1]:98 [ mulf8s_prepared::$6 ]
Allocated zp[1]:99 [ mulf8s_prepared::$11 ]
Allocated zp[1]:100 [ mulf8s_prepared::$9 ]
Allocated zp[1]:101 [ mulf8s_prepared::$12 ]
Allocated zp[1]:102 [ keyboard_matrix_read::return#0 ]
Allocated zp[2]:103 [ mulf8u_prepared::return#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] PLEX_SCREEN_PTR = (byte*)$400+$3f8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] plex_show_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] plex_sprite_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] plex_sprite_msb = 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] plex_free_next = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [17] *D011 = VIC_DEN|VIC_RSEL|3 [ ] ( main:7::init:10 [ ] { }  ) always clobbers reg byte a 
Statement [20] PLEX_PTR[init::i#2] = (byte)SPRITE/$40 [ PLEX_SCREEN_PTR init::i#2 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ init::i#2 init::i#1 ]
Statement [21] init::$10 = init::i#2 << 2 [ PLEX_SCREEN_PTR init::i#2 init::$10 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$10 ] { }  ) always clobbers reg byte a 
Statement [22] init::$3 = init::$10 + init::i#2 [ PLEX_SCREEN_PTR init::i#2 init::$3 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$3 ] { }  ) always clobbers reg byte a 
Statement [24] init::$9 = init::i#2 << 1 [ PLEX_SCREEN_PTR init::i#2 init::$4 init::$9 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$4 init::$9 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:41 [ init::$4 ]
Statement [25] PLEX_XPOS[init::$9] = init::$4 [ PLEX_SCREEN_PTR init::i#2 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 ] { }  ) always clobbers reg byte a 
Statement [26] init::$5 = init::i#2 << 3 [ PLEX_SCREEN_PTR init::i#2 init::$5 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$5 ] { }  ) always clobbers reg byte a 
Statement [31] *SPRITES_ENABLE = $ff [ PLEX_SCREEN_PTR ] ( main:7::init:10 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [33] SPRITES_COLOR[init::i1#2] = GREEN [ PLEX_SCREEN_PTR init::i1#2 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i1#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:3 [ init::i1#2 init::i1#1 ]
Statement [43] if(*RASTER<$d8) goto loop::@2 [ PLEX_SCREEN_PTR loop::angle#6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ loop::angle#6 loop::angle#1 ]
Statement [44] *BORDER_COLOR = $f [ PLEX_SCREEN_PTR loop::angle#6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [47] *BORDER_COLOR = 6 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ loop::r#2 loop::r#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ loop::a#2 loop::a#1 loop::a#6 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ loop::i#2 loop::i#1 ]
Statement [51] mulf8s::return#2 = mulf8s::return#0 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Statement [52] loop::$1 = mulf8s::return#2 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [53] loop::$2 = loop::$1 << 1 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [54] loop::x#0 = loop::$2 + (signed word)$7d*$100 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [56] loop::$20 = loop::i#2 << 1 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:53 [ loop::$4 ]
Statement [57] PLEX_XPOS[loop::$20] = loop::$4 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [61] mulf8s::return#3 = mulf8s::return#0 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [62] loop::$5 = mulf8s::return#3 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] { }  ) always clobbers reg byte a 
Statement [63] loop::$6 = loop::$5 << 1 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] { }  ) always clobbers reg byte a 
Statement [64] loop::y#0 = loop::$6 + (signed word)$7d*$100 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] { }  ) always clobbers reg byte a 
Statement [67] loop::a#1 = loop::a#2 + $62 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [68] loop::r#1 = loop::r#2 + 3 [ PLEX_SCREEN_PTR loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [71] *BORDER_COLOR = 3 [ PLEX_SCREEN_PTR loop::angle#6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [73] loop::angle#1 = loop::angle#6 + 3 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] { }  ) always clobbers reg byte a 
Statement [74] *BORDER_COLOR = BLACK [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] { }  ) always clobbers reg byte a 
Statement [75] loop::$11 = *D011 & VIC_RST8 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::$11 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::$11 ] { }  ) always clobbers reg byte a 
Statement [78] *BORDER_COLOR = BLACK [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:8 [ loop::i1#5 loop::i1#1 ]
Statement [79] loop::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 loop::plexFreeNextYpos1_return#0 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 loop::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:4 [ loop::angle#6 loop::angle#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:8 [ loop::i1#5 loop::i1#1 ]
Statement [85] *BORDER_COLOR = BLACK [ PLEX_SCREEN_PTR loop::angle#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } }  ) always clobbers reg byte a 
Statement [99] PLEX_SCREEN_PTR = SCREEN+$3f8 [ PLEX_SCREEN_PTR ] ( main:7::init:10::plexInit:18 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [107] if(mulf_init::sqr1_lo#2!=mulf_sqr1_lo+$200) goto mulf_init::@2 [ mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:12 [ mulf_init::c#2 mulf_init::c#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:15 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Statement [109] if(mulf_init::sqr2_lo#2!=mulf_sqr2_lo+$1ff) goto mulf_init::@6 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:18 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:21 [ mulf_init::dir#2 mulf_init::dir#4 ]
Statement [110] *(mulf_sqr2_lo+$1ff) = *(mulf_sqr1_lo+$100) [ ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [111] *(mulf_sqr2_hi+$1ff) = *(mulf_sqr1_hi+$100) [ ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [113] *mulf_init::sqr2_lo#2 = mulf_sqr1_lo[mulf_init::x_255#2] [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:18 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:21 [ mulf_init::dir#2 mulf_init::dir#4 ]
Statement [114] *mulf_init::sqr2_hi#2 = mulf_sqr1_hi[mulf_init::x_255#2] [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [116] mulf_init::x_255#1 = mulf_init::x_255#2 + mulf_init::dir#2 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] { }  ) always clobbers reg byte a 
Statement [122] mulf_init::$1 = mulf_init::c#1 & 1 [ mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] { }  ) always clobbers reg byte a 
Statement [128] *mulf_init::sqr1_lo#2 = mulf_init::$4 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:12 [ mulf_init::c#2 mulf_init::c#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:15 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Statement [130] *mulf_init::sqr1_hi#2 = mulf_init::$5 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Statement [132] mulf_init::sqr#1 = mulf_init::sqr#3 + mulf_init::x_2#2 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] { }  ) always clobbers reg byte a 
Statement [136] if(memset::dst#2!=memset::end#0) goto memset::@2 [ memset::dst#2 ] ( main:7::init:10::memset:39 [ PLEX_SCREEN_PTR memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [138] *memset::dst#2 = memset::c#0 [ memset::dst#2 ] ( main:7::init:10::memset:39 [ PLEX_SCREEN_PTR memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [145] mulf8s::return#0 = (signed word)mulf8s_prepared::m#4 [ mulf8s::return#0 ] ( main:7::loop:12::mulf8s:50 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [154] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:28 [ plexSort::m#2 plexSort::m#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:77 [ plexSort::nxt_idx#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:78 [ plexSort::nxt_y#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:29 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Statement [157] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] { }  ) always clobbers reg byte a 
Statement [159] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 ] { }  ) always clobbers reg byte a 
Statement [162] plex_show_idx = 0 [ plex_show_idx ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx ] { }  ) always clobbers reg byte a 
Statement [163] plex_sprite_idx = 0 [ plex_show_idx plex_sprite_idx ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx ] { }  ) always clobbers reg byte a 
Statement [164] plex_sprite_msb = 1 [ plex_show_idx plex_sprite_idx plex_sprite_msb ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx plex_sprite_msb ] { }  ) always clobbers reg byte a 
Statement [167] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 [ plex_show_idx plex_sprite_idx plex_sprite_msb plexSort::plexFreePrepare1_s#2 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx plex_sprite_msb plexSort::plexFreePrepare1_s#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:30 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Statement [170] plex_free_next = 0 [ plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [172] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Statement [173] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte x reg byte y 
Removing always clobbered register reg byte x as potential for zp[1]:4 [ loop::angle#6 loop::angle#1 ]
Removing always clobbered register reg byte x as potential for zp[1]:8 [ loop::i1#5 loop::i1#1 ]
Removing always clobbered register reg byte x as potential for zp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ]
Removing always clobbered register reg byte y as potential for zp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [176] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte y 
Statement [180] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Removing always clobbered register reg byte a as potential for zp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [181] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] { }  ) always clobbers reg byte y 
Statement [182] plexShowSprite::$11 = plexShowSprite::xpos_idx#0 << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] { }  ) always clobbers reg byte a 
Statement [183] plexShowSprite::$2 = < PLEX_XPOS[plexShowSprite::$11] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:86 [ plexShowSprite::$11 ]
Statement [184] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::$2 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$11 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$11 ] { }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:86 [ plexShowSprite::$11 ]
Statement [185] plexShowSprite::$3 = > PLEX_XPOS[plexShowSprite::$11] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$3 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$3 ] { }  ) always clobbers reg byte a 
Statement [187] plexShowSprite::$9 = $ff ^ plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$9 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$9 ] { }  ) always clobbers reg byte a 
Statement [188] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$9 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [194] if(plex_sprite_msb!=0) goto plexShowSprite::@return [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [195] plex_sprite_msb = 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [197] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  } always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:27 [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
Statement [209] mulf8u_prepared::return#2 = mulf8u_prepared::return#0 [ mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:74 [ mulf8s_prepared::b#0 ]
Statement [210] mulf8s_prepared::m#0 = mulf8u_prepared::return#2 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [211] if(*mulf8s_prepared::memA>=0) goto mulf8s_prepared::@1 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [213] mulf8s_prepared::$11 = mulf8s_prepared::$6 - (byte)mulf8s_prepared::b#0 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$11 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$11 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$11 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [218] mulf8s_prepared::$12 = mulf8s_prepared::$9 - (byte)*mulf8s_prepared::memA [ mulf8s_prepared::m#5 mulf8s_prepared::$12 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [222] *((byte*)CIA1) = *(keyboard_matrix_row_bitmask+keyboard_key_pressed::rowidx#0) [ ] ( main:7::loop:12::keyboard_key_pressed:86::keyboard_matrix_read:199 [ PLEX_SCREEN_PTR loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:7::exit:14::keyboard_key_pressed:93::keyboard_matrix_read:199 [ ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [223] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:7::loop:12::keyboard_key_pressed:86::keyboard_matrix_read:199 [ PLEX_SCREEN_PTR loop::angle#1 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:7::exit:14::keyboard_key_pressed:93::keyboard_matrix_read:199 [ keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  } always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte x as potential for zp[1]:5 [ loop::r#2 loop::r#1 ]
Removing always clobbered register reg byte x as potential for zp[1]:6 [ loop::a#2 loop::a#1 loop::a#6 ]
Removing always clobbered register reg byte x as potential for zp[1]:7 [ loop::i#2 loop::i#1 ]
Removing always clobbered register reg byte x as potential for zp[1]:74 [ mulf8s_prepared::b#0 ]
Statement [227] mulf8u_prepared::return#0 = *mulf8u_prepared::memB w= *mulf8u_prepared::resL [ mulf8u_prepared::return#0 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144::mulf8u_prepared:208 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144::mulf8u_prepared:208 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Statement [1] PLEX_SCREEN_PTR = (byte*)$400+$3f8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] plex_show_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] plex_sprite_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] plex_sprite_msb = 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] plex_free_next = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [17] *D011 = VIC_DEN|VIC_RSEL|3 [ ] ( main:7::init:10 [ ] { }  ) always clobbers reg byte a 
Statement [20] PLEX_PTR[init::i#2] = (byte)SPRITE/$40 [ PLEX_SCREEN_PTR init::i#2 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 ] { }  ) always clobbers reg byte a 
Statement [21] init::$10 = init::i#2 << 2 [ PLEX_SCREEN_PTR init::i#2 init::$10 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$10 ] { }  ) always clobbers reg byte a 
Statement [22] init::$3 = init::$10 + init::i#2 [ PLEX_SCREEN_PTR init::i#2 init::$3 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$3 ] { }  ) always clobbers reg byte a 
Statement [24] init::$9 = init::i#2 << 1 [ PLEX_SCREEN_PTR init::i#2 init::$4 init::$9 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$4 init::$9 ] { }  ) always clobbers reg byte a 
Statement [25] PLEX_XPOS[init::$9] = init::$4 [ PLEX_SCREEN_PTR init::i#2 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 ] { }  ) always clobbers reg byte a 
Statement [26] init::$5 = init::i#2 << 3 [ PLEX_SCREEN_PTR init::i#2 init::$5 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$5 ] { }  ) always clobbers reg byte a 
Statement [31] *SPRITES_ENABLE = $ff [ PLEX_SCREEN_PTR ] ( main:7::init:10 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [33] SPRITES_COLOR[init::i1#2] = GREEN [ PLEX_SCREEN_PTR init::i1#2 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i1#2 ] { }  ) always clobbers reg byte a 
Statement [43] if(*RASTER<$d8) goto loop::@2 [ PLEX_SCREEN_PTR loop::angle#6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [44] *BORDER_COLOR = $f [ PLEX_SCREEN_PTR loop::angle#6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [47] *BORDER_COLOR = 6 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Statement [51] mulf8s::return#2 = mulf8s::return#0 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Statement [52] loop::$1 = mulf8s::return#2 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [53] loop::$2 = loop::$1 << 1 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [54] loop::x#0 = loop::$2 + (signed word)$7d*$100 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [56] loop::$20 = loop::i#2 << 1 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [57] PLEX_XPOS[loop::$20] = loop::$4 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [61] mulf8s::return#3 = mulf8s::return#0 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [62] loop::$5 = mulf8s::return#3 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] { }  ) always clobbers reg byte a 
Statement [63] loop::$6 = loop::$5 << 1 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] { }  ) always clobbers reg byte a 
Statement [64] loop::y#0 = loop::$6 + (signed word)$7d*$100 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] { }  ) always clobbers reg byte a 
Statement [67] loop::a#1 = loop::a#2 + $62 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [68] loop::r#1 = loop::r#2 + 3 [ PLEX_SCREEN_PTR loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [71] *BORDER_COLOR = 3 [ PLEX_SCREEN_PTR loop::angle#6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [73] loop::angle#1 = loop::angle#6 + 3 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] { }  ) always clobbers reg byte a reg byte x 
Statement [74] *BORDER_COLOR = BLACK [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] { }  ) always clobbers reg byte a 
Statement [75] loop::$11 = *D011 & VIC_RST8 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::$11 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::$11 ] { }  ) always clobbers reg byte a 
Statement [78] *BORDER_COLOR = BLACK [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 ] { }  ) always clobbers reg byte a 
Statement [79] loop::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 loop::plexFreeNextYpos1_return#0 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 loop::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte y 
Statement [84] if(loop::i1#1!=PLEX_COUNT-1+1) goto loop::@7 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#1 ] { }  ) always clobbers reg byte a 
Statement [85] *BORDER_COLOR = BLACK [ PLEX_SCREEN_PTR loop::angle#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } }  ) always clobbers reg byte a 
Statement [99] PLEX_SCREEN_PTR = SCREEN+$3f8 [ PLEX_SCREEN_PTR ] ( main:7::init:10::plexInit:18 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [107] if(mulf_init::sqr1_lo#2!=mulf_sqr1_lo+$200) goto mulf_init::@2 [ mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] { }  ) always clobbers reg byte a 
Statement [109] if(mulf_init::sqr2_lo#2!=mulf_sqr2_lo+$1ff) goto mulf_init::@6 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a 
Statement [110] *(mulf_sqr2_lo+$1ff) = *(mulf_sqr1_lo+$100) [ ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [111] *(mulf_sqr2_hi+$1ff) = *(mulf_sqr1_hi+$100) [ ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [113] *mulf_init::sqr2_lo#2 = mulf_sqr1_lo[mulf_init::x_255#2] [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [114] *mulf_init::sqr2_hi#2 = mulf_sqr1_hi[mulf_init::x_255#2] [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [116] mulf_init::x_255#1 = mulf_init::x_255#2 + mulf_init::dir#2 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] { }  ) always clobbers reg byte a 
Statement [122] mulf_init::$1 = mulf_init::c#1 & 1 [ mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] { }  ) always clobbers reg byte a 
Statement [128] *mulf_init::sqr1_lo#2 = mulf_init::$4 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Statement [130] *mulf_init::sqr1_hi#2 = mulf_init::$5 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Statement [132] mulf_init::sqr#1 = mulf_init::sqr#3 + mulf_init::x_2#2 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] { }  ) always clobbers reg byte a 
Statement [136] if(memset::dst#2!=memset::end#0) goto memset::@2 [ memset::dst#2 ] ( main:7::init:10::memset:39 [ PLEX_SCREEN_PTR memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [138] *memset::dst#2 = memset::c#0 [ memset::dst#2 ] ( main:7::init:10::memset:39 [ PLEX_SCREEN_PTR memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [145] mulf8s::return#0 = (signed word)mulf8s_prepared::m#4 [ mulf8s::return#0 ] ( main:7::loop:12::mulf8s:50 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [151] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] { }  ) always clobbers reg byte a 
Statement [154] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] { }  ) always clobbers reg byte a 
Statement [157] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] { }  ) always clobbers reg byte a 
Statement [159] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 ] { }  ) always clobbers reg byte a 
Statement [162] plex_show_idx = 0 [ plex_show_idx ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx ] { }  ) always clobbers reg byte a 
Statement [163] plex_sprite_idx = 0 [ plex_show_idx plex_sprite_idx ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx ] { }  ) always clobbers reg byte a 
Statement [164] plex_sprite_msb = 1 [ plex_show_idx plex_sprite_idx plex_sprite_msb ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx plex_sprite_msb ] { }  ) always clobbers reg byte a 
Statement [167] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 [ plex_show_idx plex_sprite_idx plex_sprite_msb plexSort::plexFreePrepare1_s#2 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx plex_sprite_msb plexSort::plexFreePrepare1_s#2 ] { }  ) always clobbers reg byte a 
Statement [170] plex_free_next = 0 [ plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [172] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Statement [173] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte x reg byte y 
Statement [174] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:81 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Statement [176] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte y 
Statement [180] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [181] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] { }  ) always clobbers reg byte y 
Statement [182] plexShowSprite::$11 = plexShowSprite::xpos_idx#0 << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] { }  ) always clobbers reg byte a 
Statement [183] plexShowSprite::$2 = < PLEX_XPOS[plexShowSprite::$11] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] { }  ) always clobbers reg byte a 
Statement [184] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::$2 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$11 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$11 ] { }  ) always clobbers reg byte y 
Statement [185] plexShowSprite::$3 = > PLEX_XPOS[plexShowSprite::$11] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$3 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$3 ] { }  ) always clobbers reg byte a 
Statement [187] plexShowSprite::$9 = $ff ^ plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$9 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$9 ] { }  ) always clobbers reg byte a 
Statement [188] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$9 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [194] if(plex_sprite_msb!=0) goto plexShowSprite::@return [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [195] plex_sprite_msb = 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [197] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  } always clobbers reg byte a 
Statement [209] mulf8u_prepared::return#2 = mulf8u_prepared::return#0 [ mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Statement [210] mulf8s_prepared::m#0 = mulf8u_prepared::return#2 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [211] if(*mulf8s_prepared::memA>=0) goto mulf8s_prepared::@1 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [213] mulf8s_prepared::$11 = mulf8s_prepared::$6 - (byte)mulf8s_prepared::b#0 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$11 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$11 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$11 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [218] mulf8s_prepared::$12 = mulf8s_prepared::$9 - (byte)*mulf8s_prepared::memA [ mulf8s_prepared::m#5 mulf8s_prepared::$12 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [222] *((byte*)CIA1) = *(keyboard_matrix_row_bitmask+keyboard_key_pressed::rowidx#0) [ ] ( main:7::loop:12::keyboard_key_pressed:86::keyboard_matrix_read:199 [ PLEX_SCREEN_PTR loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:7::exit:14::keyboard_key_pressed:93::keyboard_matrix_read:199 [ ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [223] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:7::loop:12::keyboard_key_pressed:86::keyboard_matrix_read:199 [ PLEX_SCREEN_PTR loop::angle#1 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:7::exit:14::keyboard_key_pressed:93::keyboard_matrix_read:199 [ keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  } always clobbers reg byte a reg byte x 
Statement [227] mulf8u_prepared::return#0 = *mulf8u_prepared::memB w= *mulf8u_prepared::resL [ mulf8u_prepared::return#0 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144::mulf8u_prepared:208 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144::mulf8u_prepared:208 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Statement [1] PLEX_SCREEN_PTR = (byte*)$400+$3f8 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] plex_show_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] plex_sprite_idx = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] plex_sprite_msb = 1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] plex_free_next = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [17] *D011 = VIC_DEN|VIC_RSEL|3 [ ] ( main:7::init:10 [ ] { }  ) always clobbers reg byte a 
Statement [20] PLEX_PTR[init::i#2] = (byte)SPRITE/$40 [ PLEX_SCREEN_PTR init::i#2 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 ] { }  ) always clobbers reg byte a 
Statement [21] init::$10 = init::i#2 << 2 [ PLEX_SCREEN_PTR init::i#2 init::$10 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$10 ] { }  ) always clobbers reg byte a 
Statement [22] init::$3 = init::$10 + init::i#2 [ PLEX_SCREEN_PTR init::i#2 init::$3 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$3 ] { }  ) always clobbers reg byte a 
Statement [24] init::$9 = init::i#2 << 1 [ PLEX_SCREEN_PTR init::i#2 init::$4 init::$9 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$4 init::$9 ] { }  ) always clobbers reg byte a 
Statement [25] PLEX_XPOS[init::$9] = init::$4 [ PLEX_SCREEN_PTR init::i#2 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 ] { }  ) always clobbers reg byte a 
Statement [26] init::$5 = init::i#2 << 3 [ PLEX_SCREEN_PTR init::i#2 init::$5 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i#2 init::$5 ] { }  ) always clobbers reg byte a 
Statement [31] *SPRITES_ENABLE = $ff [ PLEX_SCREEN_PTR ] ( main:7::init:10 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [33] SPRITES_COLOR[init::i1#2] = GREEN [ PLEX_SCREEN_PTR init::i1#2 ] ( main:7::init:10 [ PLEX_SCREEN_PTR init::i1#2 ] { }  ) always clobbers reg byte a 
Statement [43] if(*RASTER<$d8) goto loop::@2 [ PLEX_SCREEN_PTR loop::angle#6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [44] *BORDER_COLOR = $f [ PLEX_SCREEN_PTR loop::angle#6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [47] *BORDER_COLOR = 6 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Statement [51] mulf8s::return#2 = mulf8s::return#0 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Statement [52] loop::$1 = mulf8s::return#2 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [53] loop::$2 = loop::$1 << 1 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [54] loop::x#0 = loop::$2 + (signed word)$7d*$100 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [56] loop::$20 = loop::i#2 << 1 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [57] PLEX_XPOS[loop::$20] = loop::$4 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [61] mulf8s::return#3 = mulf8s::return#0 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [62] loop::$5 = mulf8s::return#3 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] { }  ) always clobbers reg byte a 
Statement [63] loop::$6 = loop::$5 << 1 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] { }  ) always clobbers reg byte a 
Statement [64] loop::y#0 = loop::$6 + (signed word)$7d*$100 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] { }  ) always clobbers reg byte a 
Statement [67] loop::a#1 = loop::a#2 + $62 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [68] loop::r#1 = loop::r#2 + 3 [ PLEX_SCREEN_PTR loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [71] *BORDER_COLOR = 3 [ PLEX_SCREEN_PTR loop::angle#6 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [73] loop::angle#1 = loop::angle#6 + 3 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] { }  ) always clobbers reg byte a reg byte x 
Statement [74] *BORDER_COLOR = BLACK [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 ] { }  ) always clobbers reg byte a 
Statement [75] loop::$11 = *D011 & VIC_RST8 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::$11 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::$11 ] { }  ) always clobbers reg byte a 
Statement [78] *BORDER_COLOR = BLACK [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 ] { }  ) always clobbers reg byte a 
Statement [79] loop::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 loop::plexFreeNextYpos1_return#0 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#5 loop::plexFreeNextYpos1_return#0 ] { }  ) always clobbers reg byte y 
Statement [84] if(loop::i1#1!=PLEX_COUNT-1+1) goto loop::@7 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next loop::angle#1 loop::i1#1 ] { }  ) always clobbers reg byte a 
Statement [85] *BORDER_COLOR = BLACK [ PLEX_SCREEN_PTR loop::angle#1 ] ( main:7::loop:12 [ PLEX_SCREEN_PTR loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } }  ) always clobbers reg byte a 
Statement [99] PLEX_SCREEN_PTR = SCREEN+$3f8 [ PLEX_SCREEN_PTR ] ( main:7::init:10::plexInit:18 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [107] if(mulf_init::sqr1_lo#2!=mulf_sqr1_lo+$200) goto mulf_init::@2 [ mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] { }  ) always clobbers reg byte a 
Statement [109] if(mulf_init::sqr2_lo#2!=mulf_sqr2_lo+$1ff) goto mulf_init::@6 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a 
Statement [110] *(mulf_sqr2_lo+$1ff) = *(mulf_sqr1_lo+$100) [ ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [111] *(mulf_sqr2_hi+$1ff) = *(mulf_sqr1_hi+$100) [ ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR ] { }  ) always clobbers reg byte a 
Statement [113] *mulf_init::sqr2_lo#2 = mulf_sqr1_lo[mulf_init::x_255#2] [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [114] *mulf_init::sqr2_hi#2 = mulf_sqr1_hi[mulf_init::x_255#2] [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [116] mulf_init::x_255#1 = mulf_init::x_255#2 + mulf_init::dir#2 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] { }  ) always clobbers reg byte a 
Statement [122] mulf_init::$1 = mulf_init::c#1 & 1 [ mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] { }  ) always clobbers reg byte a 
Statement [128] *mulf_init::sqr1_lo#2 = mulf_init::$4 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Statement [130] *mulf_init::sqr1_hi#2 = mulf_init::$5 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Statement [132] mulf_init::sqr#1 = mulf_init::sqr#3 + mulf_init::x_2#2 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:7::init:10::mulf_init:37 [ PLEX_SCREEN_PTR mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] { }  ) always clobbers reg byte a 
Statement [136] if(memset::dst#2!=memset::end#0) goto memset::@2 [ memset::dst#2 ] ( main:7::init:10::memset:39 [ PLEX_SCREEN_PTR memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [138] *memset::dst#2 = memset::c#0 [ memset::dst#2 ] ( main:7::init:10::memset:39 [ PLEX_SCREEN_PTR memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [145] mulf8s::return#0 = (signed word)mulf8s_prepared::m#4 [ mulf8s::return#0 ] ( main:7::loop:12::mulf8s:50 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [151] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] { }  ) always clobbers reg byte a 
Statement [154] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] { }  ) always clobbers reg byte a 
Statement [157] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] { }  ) always clobbers reg byte a 
Statement [159] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plexSort::m#2 ] { }  ) always clobbers reg byte a 
Statement [162] plex_show_idx = 0 [ plex_show_idx ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx ] { }  ) always clobbers reg byte a 
Statement [163] plex_sprite_idx = 0 [ plex_show_idx plex_sprite_idx ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx ] { }  ) always clobbers reg byte a 
Statement [164] plex_sprite_msb = 1 [ plex_show_idx plex_sprite_idx plex_sprite_msb ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx plex_sprite_msb ] { }  ) always clobbers reg byte a 
Statement [167] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 [ plex_show_idx plex_sprite_idx plex_sprite_msb plexSort::plexFreePrepare1_s#2 ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx plex_sprite_msb plexSort::plexFreePrepare1_s#2 ] { }  ) always clobbers reg byte a 
Statement [170] plex_free_next = 0 [ plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexSort:72 [ PLEX_SCREEN_PTR loop::angle#6 plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [172] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Statement [173] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte x reg byte y 
Statement [174] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::plexFreeAdd1_ypos#0 ] { }  ) always clobbers reg byte y 
Statement [176] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte y 
Statement [180] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [181] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::xpos_idx#0 ] { }  ) always clobbers reg byte y 
Statement [182] plexShowSprite::$11 = plexShowSprite::xpos_idx#0 << 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] { }  ) always clobbers reg byte a 
Statement [183] plexShowSprite::$2 = < PLEX_XPOS[plexShowSprite::$11] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] { }  ) always clobbers reg byte a 
Statement [184] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::$2 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$11 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$11 ] { }  ) always clobbers reg byte y 
Statement [185] plexShowSprite::$3 = > PLEX_XPOS[plexShowSprite::$11] [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$3 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$3 ] { }  ) always clobbers reg byte a 
Statement [187] plexShowSprite::$9 = $ff ^ plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$9 ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next plexShowSprite::$9 ] { }  ) always clobbers reg byte a 
Statement [188] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$9 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [194] if(plex_sprite_msb!=0) goto plexShowSprite::@return [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [195] plex_sprite_msb = 1 [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement [197] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb [ PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] ( main:7::loop:12::plexShowSprite:82 [ loop::angle#1 loop::i1#5 PLEX_SCREEN_PTR plex_show_idx plex_sprite_idx plex_sprite_msb plex_free_next ] { }  ) always clobbers reg byte a 
Statement asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  } always clobbers reg byte a 
Statement [209] mulf8u_prepared::return#2 = mulf8u_prepared::return#0 [ mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Statement [210] mulf8s_prepared::m#0 = mulf8u_prepared::return#2 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [211] if(*mulf8s_prepared::memA>=0) goto mulf8s_prepared::@1 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [213] mulf8s_prepared::$11 = mulf8s_prepared::$6 - (byte)mulf8s_prepared::b#0 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$11 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$11 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$11 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [218] mulf8s_prepared::$12 = mulf8s_prepared::$9 - (byte)*mulf8s_prepared::memA [ mulf8s_prepared::m#5 mulf8s_prepared::$12 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$12 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [222] *((byte*)CIA1) = *(keyboard_matrix_row_bitmask+keyboard_key_pressed::rowidx#0) [ ] ( main:7::loop:12::keyboard_key_pressed:86::keyboard_matrix_read:199 [ PLEX_SCREEN_PTR loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:7::exit:14::keyboard_key_pressed:93::keyboard_matrix_read:199 [ ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [223] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:7::loop:12::keyboard_key_pressed:86::keyboard_matrix_read:199 [ PLEX_SCREEN_PTR loop::angle#1 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:7::exit:14::keyboard_key_pressed:93::keyboard_matrix_read:199 [ keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  } always clobbers reg byte a reg byte x 
Statement [227] mulf8u_prepared::return#0 = *mulf8u_prepared::memB w= *mulf8u_prepared::resL [ mulf8u_prepared::return#0 ] ( main:7::loop:12::mulf8s:50::mulf8s_prepared:144::mulf8u_prepared:208 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:7::loop:12::mulf8s:60::mulf8s_prepared:144::mulf8u_prepared:208 [ PLEX_SCREEN_PTR loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ init::i#2 init::i#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ init::i1#2 init::i1#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ loop::angle#6 loop::angle#1 ] : zp[1]:4 , 
Potential registers zp[1]:5 [ loop::r#2 loop::r#1 ] : zp[1]:5 , reg byte y , 
Potential registers zp[1]:6 [ loop::a#2 loop::a#1 loop::a#6 ] : zp[1]:6 , reg byte y , 
Potential registers zp[1]:7 [ loop::i#2 loop::i#1 ] : zp[1]:7 , reg byte y , 
Potential registers zp[1]:8 [ loop::i1#5 loop::i1#1 ] : zp[1]:8 , 
Potential registers zp[1]:9 [ plexInit::i#2 plexInit::i#1 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:10 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] : zp[2]:10 , 
Potential registers zp[1]:12 [ mulf_init::c#2 mulf_init::c#1 ] : zp[1]:12 , reg byte x , 
Potential registers zp[2]:13 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] : zp[2]:13 , 
Potential registers zp[1]:15 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] : zp[1]:15 , reg byte x , 
Potential registers zp[2]:16 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] : zp[2]:16 , 
Potential registers zp[1]:18 [ mulf_init::x_255#2 mulf_init::x_255#1 ] : zp[1]:18 , reg byte x , 
Potential registers zp[2]:19 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] : zp[2]:19 , 
Potential registers zp[1]:21 [ mulf_init::dir#2 mulf_init::dir#4 ] : zp[1]:21 , reg byte x , 
Potential registers zp[2]:22 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] : zp[2]:22 , 
Potential registers zp[2]:24 [ memset::dst#2 memset::dst#1 ] : zp[2]:24 , 
Potential registers zp[1]:26 [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:27 [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ] : zp[1]:27 , reg byte x , reg byte y , 
Potential registers zp[1]:28 [ plexSort::m#2 plexSort::m#1 ] : zp[1]:28 , reg byte x , reg byte y , 
Potential registers zp[1]:29 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] : zp[1]:29 , reg byte x , reg byte y , 
Potential registers zp[1]:30 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] : zp[1]:30 , reg byte x , reg byte y , 
Potential registers zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] : zp[2]:31 , 
Potential registers zp[2]:33 [ PLEX_SCREEN_PTR ] : zp[2]:33 , 
Potential registers zp[1]:35 [ plex_show_idx ] : zp[1]:35 , 
Potential registers zp[1]:36 [ plex_sprite_idx ] : zp[1]:36 , 
Potential registers zp[1]:37 [ plex_sprite_msb ] : zp[1]:37 , 
Potential registers zp[1]:38 [ plex_free_next ] : zp[1]:38 , 
Potential registers zp[1]:39 [ init::$10 ] : zp[1]:39 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:40 [ init::$3 ] : zp[1]:40 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:41 [ init::$4 ] : zp[1]:41 , reg byte x , reg byte y , 
Potential registers zp[1]:42 [ init::$9 ] : zp[1]:42 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:43 [ init::$5 ] : zp[1]:43 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:44 [ init::$6 ] : zp[1]:44 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:45 [ mulf8s::return#2 ] : zp[2]:45 , 
Potential registers zp[2]:47 [ loop::$1 ] : zp[2]:47 , 
Potential registers zp[2]:49 [ loop::$2 ] : zp[2]:49 , 
Potential registers zp[2]:51 [ loop::x#0 ] : zp[2]:51 , 
Potential registers zp[1]:53 [ loop::$4 ] : zp[1]:53 , reg byte x , reg byte y , 
Potential registers zp[1]:54 [ loop::$20 ] : zp[1]:54 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:55 [ mulf8s::return#3 ] : zp[2]:55 , 
Potential registers zp[2]:57 [ loop::$5 ] : zp[2]:57 , 
Potential registers zp[2]:59 [ loop::$6 ] : zp[2]:59 , 
Potential registers zp[2]:61 [ loop::y#0 ] : zp[2]:61 , 
Potential registers zp[1]:63 [ loop::$8 ] : zp[1]:63 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:64 [ loop::$11 ] : zp[1]:64 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:65 [ loop::plexFreeNextYpos1_return#0 ] : zp[1]:65 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:66 [ keyboard_key_pressed::return#3 ] : zp[1]:66 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:67 [ loop::$18 ] : zp[1]:67 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:68 [ keyboard_key_pressed::return#2 ] : zp[1]:68 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:69 [ exit::$0 ] : zp[1]:69 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:70 [ mulf_init::$1 ] : zp[1]:70 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:71 [ mulf_init::$4 ] : zp[1]:71 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:72 [ mulf_init::$5 ] : zp[1]:72 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:73 [ mulf8u_prepare::a#0 ] : zp[1]:73 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:74 [ mulf8s_prepared::b#0 ] : zp[1]:74 , reg byte y , 
Potential registers zp[2]:75 [ mulf8s::return#0 ] : zp[2]:75 , 
Potential registers zp[1]:77 [ plexSort::nxt_idx#0 ] : zp[1]:77 , reg byte x , reg byte y , 
Potential registers zp[1]:78 [ plexSort::nxt_y#0 ] : zp[1]:78 , reg byte x , reg byte y , 
Potential registers zp[1]:79 [ plexSort::s#2 ] : zp[1]:79 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ] : zp[1]:80 , 
Potential registers zp[1]:81 [ plexShowSprite::plexFreeAdd1_ypos#0 ] : zp[1]:81 , reg byte a , reg byte x , 
Potential registers zp[1]:82 [ plexShowSprite::plexFreeAdd1_$0 ] : zp[1]:82 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:83 [ plexShowSprite::plexFreeAdd1_$1 ] : zp[1]:83 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:84 [ plexShowSprite::plexFreeAdd1_$2 ] : zp[1]:84 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:85 [ plexShowSprite::xpos_idx#0 ] : zp[1]:85 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:86 [ plexShowSprite::$11 ] : zp[1]:86 , reg byte x , 
Potential registers zp[1]:87 [ plexShowSprite::$2 ] : zp[1]:87 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:88 [ plexShowSprite::$3 ] : zp[1]:88 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:89 [ plexShowSprite::$9 ] : zp[1]:89 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:90 [ plexShowSprite::$5 ] : zp[1]:90 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:91 [ plexShowSprite::$6 ] : zp[1]:91 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:92 [ keyboard_matrix_read::return#2 ] : zp[1]:92 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:93 [ keyboard_key_pressed::$2 ] : zp[1]:93 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:94 [ keyboard_key_pressed::return#0 ] : zp[1]:94 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:95 [ mulf8u_prepared::b#0 ] : zp[1]:95 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:96 [ mulf8u_prepared::return#2 ] : zp[2]:96 , 
Potential registers zp[1]:98 [ mulf8s_prepared::$6 ] : zp[1]:98 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:99 [ mulf8s_prepared::$11 ] : zp[1]:99 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:100 [ mulf8s_prepared::$9 ] : zp[1]:100 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:101 [ mulf8s_prepared::$12 ] : zp[1]:101 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:102 [ keyboard_matrix_read::return#0 ] : zp[1]:102 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:103 [ mulf8u_prepared::return#0 ] : zp[2]:103 , 

REGISTER UPLIFT SCOPES
Uplift Scope [plexSort] 36,166,672.83: zp[1]:29 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] 3,000,003: zp[1]:30 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] 2,000,002: zp[1]:79 [ plexSort::s#2 ] 1,916,668.58: zp[1]:28 [ plexSort::m#2 plexSort::m#1 ] 1,500,000.38: zp[1]:78 [ plexSort::nxt_y#0 ] 300,000.3: zp[1]:77 [ plexSort::nxt_idx#0 ] 
Uplift Scope [mulf8u_prepared] 11,000,002: zp[1]:95 [ mulf8u_prepared::b#0 ] 3,666,667.33: zp[2]:103 [ mulf8u_prepared::return#0 ] 2,000,002: zp[2]:96 [ mulf8u_prepared::return#2 ] 
Uplift Scope [mulf8s_prepared] 6,916,673.58: zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] 2,000,002: zp[1]:98 [ mulf8s_prepared::$6 ] 2,000,002: zp[1]:99 [ mulf8s_prepared::$11 ] 2,000,002: zp[1]:100 [ mulf8s_prepared::$9 ] 2,000,002: zp[1]:101 [ mulf8s_prepared::$12 ] 110,000.2: zp[1]:74 [ mulf8s_prepared::b#0 ] 
Uplift Scope [plexShowSprite] 200,002: zp[1]:82 [ plexShowSprite::plexFreeAdd1_$0 ] 200,002: zp[1]:83 [ plexShowSprite::plexFreeAdd1_$1 ] 200,002: zp[1]:84 [ plexShowSprite::plexFreeAdd1_$2 ] 200,002: zp[1]:85 [ plexShowSprite::xpos_idx#0 ] 200,002: zp[1]:87 [ plexShowSprite::$2 ] 200,002: zp[1]:88 [ plexShowSprite::$3 ] 200,002: zp[1]:89 [ plexShowSprite::$9 ] 200,002: zp[1]:90 [ plexShowSprite::$5 ] 200,002: zp[1]:91 [ plexShowSprite::$6 ] 150,001.5: zp[1]:81 [ plexShowSprite::plexFreeAdd1_ypos#0 ] 100,001: zp[1]:86 [ plexShowSprite::$11 ] 25,000.25: zp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ] 
Uplift Scope [mulf8u_prepare] 1,100,002: zp[1]:73 [ mulf8u_prepare::a#0 ] 
Uplift Scope [loop] 55,001: zp[1]:65 [ loop::plexFreeNextYpos1_return#0 ] 20,002: zp[2]:47 [ loop::$1 ] 20,002: zp[2]:49 [ loop::$2 ] 20,002: zp[2]:51 [ loop::x#0 ] 20,002: zp[1]:54 [ loop::$20 ] 20,002: zp[2]:57 [ loop::$5 ] 20,002: zp[2]:59 [ loop::$6 ] 20,002: zp[2]:61 [ loop::y#0 ] 20,002: zp[1]:63 [ loop::$8 ] 20,002: zp[1]:64 [ loop::$11 ] 18,335.17: zp[1]:8 [ loop::i1#5 loop::i1#1 ] 16,740.8: zp[1]:7 [ loop::i#2 loop::i#1 ] 10,001: zp[1]:53 [ loop::$4 ] 8,955.12: zp[1]:6 [ loop::a#2 loop::a#1 loop::a#6 ] 8,485.7: zp[1]:5 [ loop::r#2 loop::r#1 ] 2,002: zp[1]:67 [ loop::$18 ] 214.64: zp[1]:4 [ loop::angle#6 loop::angle#1 ] 
Uplift Scope [mulf_init] 43,337.67: zp[2]:22 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] 24,446.89: zp[2]:16 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] 22,859.43: zp[2]:10 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] 21,002.1: zp[1]:15 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] 20,002: zp[1]:70 [ mulf_init::$1 ] 20,002: zp[1]:71 [ mulf_init::$4 ] 20,002: zp[1]:72 [ mulf_init::$5 ] 14,001.4: zp[1]:18 [ mulf_init::x_255#2 mulf_init::x_255#1 ] 13,751.38: zp[1]:21 [ mulf_init::dir#2 mulf_init::dir#4 ] 12,308.92: zp[1]:12 [ mulf_init::c#2 mulf_init::c#1 ] 10,834.42: zp[2]:19 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] 9,167.58: zp[2]:13 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] 
Uplift Scope [mulf8s] 80,005: zp[1]:27 [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ] 40,004: zp[1]:26 [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ] 30,000.75: zp[2]:75 [ mulf8s::return#0 ] 20,002: zp[2]:45 [ mulf8s::return#2 ] 20,002: zp[2]:55 [ mulf8s::return#3 ] 
Uplift Scope [keyboard_matrix_read] 36,667.33: zp[1]:102 [ keyboard_matrix_read::return#0 ] 20,002: zp[1]:92 [ keyboard_matrix_read::return#2 ] 
Uplift Scope [] 12,978.91: zp[1]:37 [ plex_sprite_msb ] 10,408.33: zp[1]:35 [ plex_show_idx ] 8,913.2: zp[1]:36 [ plex_sprite_idx ] 8,205.31: zp[1]:38 [ plex_free_next ] 952.87: zp[2]:33 [ PLEX_SCREEN_PTR ] 
Uplift Scope [plexInit] 35,003.5: zp[1]:9 [ plexInit::i#2 plexInit::i#1 ] 
Uplift Scope [memset] 33,336.67: zp[2]:24 [ memset::dst#2 memset::dst#1 ] 
Uplift Scope [keyboard_key_pressed] 20,002: zp[1]:93 [ keyboard_key_pressed::$2 ] 3,000.75: zp[1]:94 [ keyboard_key_pressed::return#0 ] 2,002: zp[1]:66 [ keyboard_key_pressed::return#3 ] 2,002: zp[1]:68 [ keyboard_key_pressed::return#2 ] 
Uplift Scope [init] 3,003: zp[1]:3 [ init::i1#2 init::i1#1 ] 2,302.3: zp[1]:2 [ init::i#2 init::i#1 ] 2,002: zp[1]:39 [ init::$10 ] 2,002: zp[1]:40 [ init::$3 ] 2,002: zp[1]:42 [ init::$9 ] 2,002: zp[1]:43 [ init::$5 ] 2,002: zp[1]:44 [ init::$6 ] 1,001: zp[1]:41 [ init::$4 ] 
Uplift Scope [exit] 2,002: zp[1]:69 [ exit::$0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [main] 
Uplift Scope [__start] 

Uplifting [plexSort] best 105566 combination reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] reg byte x [ plexSort::s#2 ] zp[1]:28 [ plexSort::m#2 plexSort::m#1 ] zp[1]:78 [ plexSort::nxt_y#0 ] zp[1]:77 [ plexSort::nxt_idx#0 ] 
Limited combination testing to 100 combinations of 972 possible.
Uplifting [mulf8u_prepared] best 105560 combination reg byte a [ mulf8u_prepared::b#0 ] zp[2]:103 [ mulf8u_prepared::return#0 ] zp[2]:96 [ mulf8u_prepared::return#2 ] 
Uplifting [mulf8s_prepared] best 105536 combination zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] reg byte a [ mulf8s_prepared::$6 ] reg byte a [ mulf8s_prepared::$11 ] reg byte a [ mulf8s_prepared::$9 ] reg byte a [ mulf8s_prepared::$12 ] zp[1]:74 [ mulf8s_prepared::b#0 ] 
Limited combination testing to 100 combinations of 512 possible.
Uplifting [plexShowSprite] best 105516 combination reg byte a [ plexShowSprite::plexFreeAdd1_$0 ] reg byte a [ plexShowSprite::plexFreeAdd1_$1 ] reg byte a [ plexShowSprite::plexFreeAdd1_$2 ] reg byte a [ plexShowSprite::xpos_idx#0 ] zp[1]:87 [ plexShowSprite::$2 ] zp[1]:88 [ plexShowSprite::$3 ] zp[1]:89 [ plexShowSprite::$9 ] zp[1]:90 [ plexShowSprite::$5 ] zp[1]:91 [ plexShowSprite::$6 ] zp[1]:81 [ plexShowSprite::plexFreeAdd1_ypos#0 ] zp[1]:86 [ plexShowSprite::$11 ] zp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ] 
Limited combination testing to 100 combinations of 1572864 possible.
Uplifting [mulf8u_prepare] best 105510 combination reg byte a [ mulf8u_prepare::a#0 ] 
Uplifting [loop] best 103910 combination zp[1]:65 [ loop::plexFreeNextYpos1_return#0 ] zp[2]:47 [ loop::$1 ] zp[2]:49 [ loop::$2 ] zp[2]:51 [ loop::x#0 ] reg byte a [ loop::$20 ] zp[2]:57 [ loop::$5 ] zp[2]:59 [ loop::$6 ] zp[2]:61 [ loop::y#0 ] reg byte a [ loop::$8 ] reg byte a [ loop::$11 ] zp[1]:8 [ loop::i1#5 loop::i1#1 ] zp[1]:7 [ loop::i#2 loop::i#1 ] zp[1]:53 [ loop::$4 ] zp[1]:6 [ loop::a#2 loop::a#1 loop::a#6 ] zp[1]:5 [ loop::r#2 loop::r#1 ] zp[1]:67 [ loop::$18 ] zp[1]:4 [ loop::angle#6 loop::angle#1 ] 
Limited combination testing to 100 combinations of 24576 possible.
Uplifting [mulf_init] best 103660 combination zp[2]:22 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] zp[2]:16 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] zp[2]:10 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] reg byte x [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] reg byte a [ mulf_init::$1 ] reg byte a [ mulf_init::$4 ] reg byte a [ mulf_init::$5 ] zp[1]:18 [ mulf_init::x_255#2 mulf_init::x_255#1 ] zp[1]:21 [ mulf_init::dir#2 mulf_init::dir#4 ] zp[1]:12 [ mulf_init::c#2 mulf_init::c#1 ] zp[2]:19 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] zp[2]:13 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] 
Limited combination testing to 100 combinations of 1024 possible.
Uplifting [mulf8s] best 102454 combination reg byte x [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ] reg byte a [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ] zp[2]:75 [ mulf8s::return#0 ] zp[2]:45 [ mulf8s::return#2 ] zp[2]:55 [ mulf8s::return#3 ] 
Uplifting [keyboard_matrix_read] best 102442 combination reg byte a [ keyboard_matrix_read::return#0 ] reg byte a [ keyboard_matrix_read::return#2 ] 
Uplifting [] best 102442 combination zp[1]:37 [ plex_sprite_msb ] zp[1]:35 [ plex_show_idx ] zp[1]:36 [ plex_sprite_idx ] zp[1]:38 [ plex_free_next ] zp[2]:33 [ PLEX_SCREEN_PTR ] 
Uplifting [plexInit] best 102322 combination reg byte x [ plexInit::i#2 plexInit::i#1 ] 
Uplifting [memset] best 102322 combination zp[2]:24 [ memset::dst#2 memset::dst#1 ] 
Uplifting [keyboard_key_pressed] best 102133 combination reg byte a [ keyboard_key_pressed::$2 ] reg byte a [ keyboard_key_pressed::return#0 ] reg byte a [ keyboard_key_pressed::return#3 ] reg byte a [ keyboard_key_pressed::return#2 ] 
Limited combination testing to 100 combinations of 256 possible.
Uplifting [init] best 101913 combination reg byte x [ init::i1#2 init::i1#1 ] zp[1]:2 [ init::i#2 init::i#1 ] reg byte a [ init::$10 ] reg byte a [ init::$3 ] zp[1]:42 [ init::$9 ] zp[1]:43 [ init::$5 ] zp[1]:44 [ init::$6 ] zp[1]:41 [ init::$4 ] 
Limited combination testing to 100 combinations of 27648 possible.
Uplifting [exit] best 101853 combination reg byte a [ exit::$0 ] 
Uplifting [MOS6526_CIA] best 101853 combination 
Uplifting [MOS6569_VICII] best 101853 combination 
Uplifting [MOS6581_SID] best 101853 combination 
Uplifting [main] best 101853 combination 
Uplifting [__start] best 101853 combination 
Attempting to uplift remaining variables inzp[1]:28 [ plexSort::m#2 plexSort::m#1 ]
Uplifting [plexSort] best 101853 combination zp[1]:28 [ plexSort::m#2 plexSort::m#1 ] 
Attempting to uplift remaining variables inzp[1]:78 [ plexSort::nxt_y#0 ]
Uplifting [plexSort] best 101853 combination zp[1]:78 [ plexSort::nxt_y#0 ] 
Attempting to uplift remaining variables inzp[1]:77 [ plexSort::nxt_idx#0 ]
Uplifting [plexSort] best 101853 combination zp[1]:77 [ plexSort::nxt_idx#0 ] 
Attempting to uplift remaining variables inzp[1]:87 [ plexShowSprite::$2 ]
Uplifting [plexShowSprite] best 101847 combination reg byte a [ plexShowSprite::$2 ] 
Attempting to uplift remaining variables inzp[1]:88 [ plexShowSprite::$3 ]
Uplifting [plexShowSprite] best 101841 combination reg byte a [ plexShowSprite::$3 ] 
Attempting to uplift remaining variables inzp[1]:89 [ plexShowSprite::$9 ]
Uplifting [plexShowSprite] best 101835 combination reg byte a [ plexShowSprite::$9 ] 
Attempting to uplift remaining variables inzp[1]:90 [ plexShowSprite::$5 ]
Uplifting [plexShowSprite] best 101829 combination reg byte x [ plexShowSprite::$5 ] 
Attempting to uplift remaining variables inzp[1]:91 [ plexShowSprite::$6 ]
Uplifting [plexShowSprite] best 101825 combination reg byte a [ plexShowSprite::$6 ] 
Attempting to uplift remaining variables inzp[1]:81 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Uplifting [plexShowSprite] best 101816 combination reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ] 
Attempting to uplift remaining variables inzp[1]:74 [ mulf8s_prepared::b#0 ]
Uplifting [mulf8s_prepared] best 101816 combination zp[1]:74 [ mulf8s_prepared::b#0 ] 
Attempting to uplift remaining variables inzp[1]:86 [ plexShowSprite::$11 ]
Uplifting [plexShowSprite] best 101809 combination reg byte x [ plexShowSprite::$11 ] 
Attempting to uplift remaining variables inzp[1]:65 [ loop::plexFreeNextYpos1_return#0 ]
Uplifting [loop] best 101809 combination zp[1]:65 [ loop::plexFreeNextYpos1_return#0 ] 
Attempting to uplift remaining variables inzp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ]
Uplifting [plexShowSprite] best 101809 combination zp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ] 
Attempting to uplift remaining variables inzp[1]:8 [ loop::i1#5 loop::i1#1 ]
Uplifting [loop] best 101809 combination zp[1]:8 [ loop::i1#5 loop::i1#1 ] 
Attempting to uplift remaining variables inzp[1]:7 [ loop::i#2 loop::i#1 ]
Uplifting [loop] best 101809 combination zp[1]:7 [ loop::i#2 loop::i#1 ] 
Attempting to uplift remaining variables inzp[1]:18 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Uplifting [mulf_init] best 101669 combination reg byte x [ mulf_init::x_255#2 mulf_init::x_255#1 ] 
Attempting to uplift remaining variables inzp[1]:21 [ mulf_init::dir#2 mulf_init::dir#4 ]
Uplifting [mulf_init] best 101669 combination zp[1]:21 [ mulf_init::dir#2 mulf_init::dir#4 ] 
Attempting to uplift remaining variables inzp[1]:37 [ plex_sprite_msb ]
Uplifting [] best 101669 combination zp[1]:37 [ plex_sprite_msb ] 
Attempting to uplift remaining variables inzp[1]:12 [ mulf_init::c#2 mulf_init::c#1 ]
Uplifting [mulf_init] best 101669 combination zp[1]:12 [ mulf_init::c#2 mulf_init::c#1 ] 
Attempting to uplift remaining variables inzp[1]:35 [ plex_show_idx ]
Uplifting [] best 101669 combination zp[1]:35 [ plex_show_idx ] 
Attempting to uplift remaining variables inzp[1]:53 [ loop::$4 ]
Uplifting [loop] best 101269 combination reg byte x [ loop::$4 ] 
Attempting to uplift remaining variables inzp[1]:6 [ loop::a#2 loop::a#1 loop::a#6 ]
Uplifting [loop] best 101269 combination zp[1]:6 [ loop::a#2 loop::a#1 loop::a#6 ] 
Attempting to uplift remaining variables inzp[1]:36 [ plex_sprite_idx ]
Uplifting [] best 101269 combination zp[1]:36 [ plex_sprite_idx ] 
Attempting to uplift remaining variables inzp[1]:5 [ loop::r#2 loop::r#1 ]
Uplifting [loop] best 101269 combination zp[1]:5 [ loop::r#2 loop::r#1 ] 
Attempting to uplift remaining variables inzp[1]:38 [ plex_free_next ]
Uplifting [] best 101269 combination zp[1]:38 [ plex_free_next ] 
Attempting to uplift remaining variables inzp[1]:2 [ init::i#2 init::i#1 ]
Uplifting [init] best 101269 combination zp[1]:2 [ init::i#2 init::i#1 ] 
Attempting to uplift remaining variables inzp[1]:42 [ init::$9 ]
Uplifting [init] best 101229 combination reg byte a [ init::$9 ] 
Attempting to uplift remaining variables inzp[1]:43 [ init::$5 ]
Uplifting [init] best 101189 combination reg byte a [ init::$5 ] 
Attempting to uplift remaining variables inzp[1]:44 [ init::$6 ]
Uplifting [init] best 101129 combination reg byte a [ init::$6 ] 
Attempting to uplift remaining variables inzp[1]:67 [ loop::$18 ]
Uplifting [loop] best 101069 combination reg byte a [ loop::$18 ] 
Attempting to uplift remaining variables inzp[1]:41 [ init::$4 ]
Uplifting [init] best 101029 combination reg byte x [ init::$4 ] 
Attempting to uplift remaining variables inzp[1]:4 [ loop::angle#6 loop::angle#1 ]
Uplifting [loop] best 101029 combination zp[1]:4 [ loop::angle#6 loop::angle#1 ] 
Coalescing zero page register [ zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] ] with [ zp[2]:75 [ mulf8s::return#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 ] ] with [ zp[2]:96 [ mulf8u_prepared::return#2 ] ] - score: 1
Coalescing zero page register [ zp[2]:45 [ mulf8s::return#2 ] ] with [ zp[2]:47 [ loop::$1 ] ] - score: 1
Coalescing zero page register [ zp[2]:49 [ loop::$2 ] ] with [ zp[2]:51 [ loop::x#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:55 [ mulf8s::return#3 ] ] with [ zp[2]:57 [ loop::$5 ] ] - score: 1
Coalescing zero page register [ zp[2]:59 [ loop::$6 ] ] with [ zp[2]:61 [ loop::y#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 ] ] with [ zp[2]:45 [ mulf8s::return#2 loop::$1 ] ] - score: 1
Coalescing zero page register [ zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 ] ] with [ zp[2]:55 [ mulf8s::return#3 loop::$5 ] ] - score: 1
Coalescing zero page register [ zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 ] ] with [ zp[2]:103 [ mulf8u_prepared::return#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 ] ] with [ zp[2]:49 [ loop::$2 loop::x#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 loop::$2 loop::x#0 ] ] with [ zp[2]:59 [ loop::$6 loop::y#0 ] ] - score: 1
Coalescing zero page register [ zp[1]:4 [ loop::angle#6 loop::angle#1 ] ] with [ zp[1]:2 [ init::i#2 init::i#1 ] ]
Coalescing zero page register [ zp[1]:12 [ mulf_init::c#2 mulf_init::c#1 ] ] with [ zp[1]:5 [ loop::r#2 loop::r#1 ] ]
Coalescing zero page register [ zp[1]:21 [ mulf_init::dir#2 mulf_init::dir#4 ] ] with [ zp[1]:6 [ loop::a#2 loop::a#1 loop::a#6 ] ]
Coalescing zero page register [ zp[2]:24 [ memset::dst#2 memset::dst#1 ] ] with [ zp[2]:10 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] ]
Coalescing zero page register [ zp[2]:31 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 loop::$2 loop::x#0 loop::$6 loop::y#0 ] ] with [ zp[2]:13 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] ]
Coalescing zero page register [ zp[1]:65 [ loop::plexFreeNextYpos1_return#0 ] ] with [ zp[1]:28 [ plexSort::m#2 plexSort::m#1 ] ]
Coalescing zero page register [ zp[1]:77 [ plexSort::nxt_idx#0 ] ] with [ zp[1]:74 [ mulf8s_prepared::b#0 ] ]
Coalescing zero page register [ zp[1]:80 [ plexShowSprite::plex_sprite_idx2#0 ] ] with [ zp[1]:78 [ plexSort::nxt_y#0 ] ]
Allocated (was zp[1]:4) zp[1]:2 [ loop::angle#6 loop::angle#1 init::i#2 init::i#1 ]
Allocated (was zp[1]:7) zp[1]:3 [ loop::i#2 loop::i#1 ]
Allocated (was zp[1]:8) zp[1]:4 [ loop::i1#5 loop::i1#1 ]
Allocated (was zp[1]:12) zp[1]:5 [ mulf_init::c#2 mulf_init::c#1 loop::r#2 loop::r#1 ]
Allocated (was zp[2]:16) zp[2]:6 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
Allocated (was zp[2]:19) zp[2]:8 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
Allocated (was zp[1]:21) zp[1]:10 [ mulf_init::dir#2 mulf_init::dir#4 loop::a#2 loop::a#1 loop::a#6 ]
Allocated (was zp[2]:22) zp[2]:11 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
Allocated (was zp[2]:24) zp[2]:13 [ memset::dst#2 memset::dst#1 mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
Allocated (was zp[2]:31) zp[2]:15 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 loop::$2 loop::x#0 loop::$6 loop::y#0 mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
Allocated (was zp[2]:33) zp[2]:17 [ PLEX_SCREEN_PTR ]
Allocated (was zp[1]:35) zp[1]:19 [ plex_show_idx ]
Allocated (was zp[1]:36) zp[1]:20 [ plex_sprite_idx ]
Allocated (was zp[1]:37) zp[1]:21 [ plex_sprite_msb ]
Allocated (was zp[1]:38) zp[1]:22 [ plex_free_next ]
Allocated (was zp[1]:65) zp[1]:23 [ loop::plexFreeNextYpos1_return#0 plexSort::m#2 plexSort::m#1 ]
Allocated (was zp[1]:77) zp[1]:24 [ plexSort::nxt_idx#0 mulf8s_prepared::b#0 ]
Allocated (was zp[1]:80) zp[1]:25 [ plexShowSprite::plex_sprite_idx2#0 plexSort::nxt_y#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Same animation using a multiplexer
// Commodore 64 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__start)
.pc = $80d "Program"
  // Global Constants & labels
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .const KEY_SPACE = $3c
  // The number of BOBs to render
  .const NUM_BOBS = $10
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label SPRITES_COLOR = $d027
  .label SPRITES_ENABLE = $d015
  .label RASTER = $d012
  .label BORDER_COLOR = $d020
  .label D011 = $d011
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The BASIC screen
  .label SCREEN = $400
  .label COS = SIN+$40
  // The address of the sprite pointers on the current screen (screen+0x3f8).
  .label PLEX_SCREEN_PTR = $11
  // The index in the PLEX tables of the next sprite to show
  .label plex_show_idx = $13
  // The index the next sprite to use for showing (sprites are used round-robin)
  .label plex_sprite_idx = $14
  // The MSB bit of the next sprite to use for showing
  .label plex_sprite_msb = $15
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  .label plex_free_next = $16
  // __start
__start: {
    jmp __init1
    // __start::__init1
  __init1:
    // [1] PLEX_SCREEN_PTR = (byte*)$400+$3f8 -- pbuz1=pbuc1 
    lda #<$400+$3f8
    sta.z PLEX_SCREEN_PTR
    lda #>$400+$3f8
    sta.z PLEX_SCREEN_PTR+1
    // [2] plex_show_idx = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // [3] plex_sprite_idx = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [4] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [5] plex_free_next = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    // [6] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
  __b1_from___init1:
    jmp __b1
    // __start::@1
  __b1:
    // [7] call main 
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [8] return 
    rts
}
  // main
main: {
    // asm { sei  }
    sei
    // [10] call init 
    jsr init
    // [11] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [12] call loop 
    // [41] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from___b1:
    jsr loop
    // [13] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [14] call exit 
    // [91] phi from main::@2 to exit [phi:main::@2->exit]
  exit_from___b2:
    jsr exit
    jmp __b3
    // main::@3
  __b3:
    // asm { cli  }
    cli
    jmp __breturn
    // main::@return
  __breturn:
    // [16] return 
    rts
}
  // init
// Initialize the program
init: {
    .label i = 2
    // [17] *D011 = VIC_DEN|VIC_RSEL|3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // [18] call plexInit 
  // Initialize the multiplexer
    // [98] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
    // [19] phi from init to init::@1 [phi:init->init::@1]
  __b1_from_init:
    // [19] phi init::i#2 = 0 [phi:init->init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
  // Set the sprite pointers & initial positions
    // [19] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  __b1_from___b1:
    // [19] phi init::i#2 = init::i#1 [phi:init::@1->init::@1#0] -- register_copy 
    jmp __b1
    // init::@1
  __b1:
    // [20] PLEX_PTR[init::i#2] = (byte)SPRITE/$40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #$ff&SPRITE/$40
    ldy.z i
    sta PLEX_PTR,y
    // [21] init::$10 = init::i#2 << 2 -- vbuaa=vbuz1_rol_2 
    lda.z i
    asl
    asl
    // [22] init::$3 = init::$10 + init::i#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z i
    // [23] init::$4 = $18 + init::$3 -- vbuxx=vbuc1_plus_vbuaa 
    tax
    axs #-[$18]
    // [24] init::$9 = init::i#2 << 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [25] PLEX_XPOS[init::$9] = init::$4 -- pwuc1_derefidx_vbuaa=vbuxx 
    tay
    txa
    sta PLEX_XPOS,y
    lda #0
    sta PLEX_XPOS+1,y
    // [26] init::$5 = init::i#2 << 3 -- vbuaa=vbuz1_rol_3 
    lda.z i
    asl
    asl
    asl
    // [27] init::$6 = $32 + init::$5 -- vbuaa=vbuc1_plus_vbuaa 
    clc
    adc #$32
    // [28] PLEX_YPOS[init::i#2] = init::$6 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z i
    sta PLEX_YPOS,y
    // [29] init::i#1 = ++ init::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [30] if(init::i#1!=PLEX_COUNT-1+1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i
    bne __b1_from___b1
    jmp __b2
    // init::@2
  __b2:
    // [31] *SPRITES_ENABLE = $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [32] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  __b3_from___b2:
    // [32] phi init::i1#2 = 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b3
    // [32] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  __b3_from___b3:
    // [32] phi init::i1#2 = init::i1#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp __b3
    // init::@3
  __b3:
    // [33] SPRITES_COLOR[init::i1#2] = GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLOR,x
    // [34] init::i1#1 = ++ init::i1#2 -- vbuxx=_inc_vbuxx 
    inx
    // [35] if(init::i1#1!=8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3_from___b3
    // [36] phi from init::@3 to init::@4 [phi:init::@3->init::@4]
  __b4_from___b3:
    jmp __b4
    // init::@4
  __b4:
    // [37] call mulf_init 
    // [105] phi from init::@4 to mulf_init [phi:init::@4->mulf_init]
  mulf_init_from___b4:
    jsr mulf_init
    // [38] phi from init::@4 to init::@5 [phi:init::@4->init::@5]
  __b5_from___b4:
    jmp __b5
    // init::@5
  __b5:
    // [39] call memset 
  // Clear screen
    // [134] phi from init::@5 to memset [phi:init::@5->memset]
  memset_from___b5:
    jsr memset
    jmp __breturn
    // init::@return
  __breturn:
    // [40] return 
    rts
}
  // loop
// The main loop
loop: {
    .label __1 = $f
    .label __2 = $f
    .label __5 = $f
    .label __6 = $f
    .label x = $f
    .label y = $f
    .label a = $a
    .label r = 5
    .label i = 3
    // Render Rotated BOBs
    .label angle = 2
    .label plexFreeNextYpos1_return = $17
    .label i1 = 4
    // [42] phi from loop to loop::@1 [phi:loop->loop::@1]
  __b1_from_loop:
    // [42] phi loop::angle#6 = 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z angle
    jmp __b1
    // loop::@1
  __b1:
    jmp __b2
    // loop::@2
  __b2:
    // [43] if(*RASTER<$d8) goto loop::@2 -- _deref_pbuc1_lt_vbuc2_then_la1 
    lda RASTER
    cmp #$d8
    bcc __b2
    jmp __b3
    // loop::@3
  __b3:
    // [44] *BORDER_COLOR = $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta BORDER_COLOR
    // [45] loop::a#6 = loop::angle#6 -- vbuz1=vbuz2 
    lda.z angle
    sta.z a
    // [46] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  __b4_from___b3:
    // [46] phi loop::i#2 = 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [46] phi loop::a#2 = loop::a#6 [phi:loop::@3->loop::@4#1] -- register_copy 
    // [46] phi loop::r#2 = $1e [phi:loop::@3->loop::@4#2] -- vbsz1=vbsc1 
    lda #$1e
    sta.z r
    jmp __b4
    // [46] phi from loop::@12 to loop::@4 [phi:loop::@12->loop::@4]
  __b4_from___b12:
    // [46] phi loop::i#2 = loop::i#1 [phi:loop::@12->loop::@4#0] -- register_copy 
    // [46] phi loop::a#2 = loop::a#1 [phi:loop::@12->loop::@4#1] -- register_copy 
    // [46] phi loop::r#2 = loop::r#1 [phi:loop::@12->loop::@4#2] -- register_copy 
    jmp __b4
    // loop::@4
  __b4:
    // [47] *BORDER_COLOR = 6 -- _deref_pbuc1=vbuc2 
    //kickasm {{ .break }}
    lda #6
    sta BORDER_COLOR
    // [48] mulf8s::a#0 = loop::r#2 -- vbsaa=vbsz1 
    lda.z r
    // [49] mulf8s::b#0 = COS[loop::a#2] -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy.z a
    ldx COS,y
    // [50] call mulf8s 
    // [140] phi from loop::@4 to mulf8s [phi:loop::@4->mulf8s]
  mulf8s_from___b4:
    // [140] phi mulf8s::b#2 = mulf8s::b#0 [phi:loop::@4->mulf8s#0] -- register_copy 
    // [140] phi mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 [phi:loop::@4->mulf8s#1] -- register_copy 
    jsr mulf8s
    // [51] mulf8s::return#2 = mulf8s::return#0
    jmp __b11
    // loop::@11
  __b11:
    // [52] loop::$1 = mulf8s::return#2
    // [53] loop::$2 = loop::$1 << 1 -- vwsz1=vwsz1_rol_1 
    asl.z __2
    rol.z __2+1
    // [54] loop::x#0 = loop::$2 + (signed word)$7d*$100 -- vwsz1=vwsz1_plus_vwsc1 
    clc
    lda.z x
    adc #<$7d*$100
    sta.z x
    lda.z x+1
    adc #>$7d*$100
    sta.z x+1
    // [55] loop::$4 = > loop::x#0 -- vbuxx=_hi_vwsz1 
    ldx.z x+1
    // [56] loop::$20 = loop::i#2 << 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [57] PLEX_XPOS[loop::$20] = loop::$4 -- pwuc1_derefidx_vbuaa=vbuxx 
    tay
    txa
    sta PLEX_XPOS,y
    lda #0
    sta PLEX_XPOS+1,y
    // [58] mulf8s::a#1 = loop::r#2 -- vbsaa=vbsz1 
    lda.z r
    // [59] mulf8s::b#1 = SIN[loop::a#2] -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy.z a
    ldx SIN,y
    // [60] call mulf8s 
    // [140] phi from loop::@11 to mulf8s [phi:loop::@11->mulf8s]
  mulf8s_from___b11:
    // [140] phi mulf8s::b#2 = mulf8s::b#1 [phi:loop::@11->mulf8s#0] -- register_copy 
    // [140] phi mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 [phi:loop::@11->mulf8s#1] -- register_copy 
    jsr mulf8s
    // [61] mulf8s::return#3 = mulf8s::return#0
    jmp __b12
    // loop::@12
  __b12:
    // [62] loop::$5 = mulf8s::return#3
    // [63] loop::$6 = loop::$5 << 1 -- vwsz1=vwsz1_rol_1 
    asl.z __6
    rol.z __6+1
    // [64] loop::y#0 = loop::$6 + (signed word)$7d*$100 -- vwsz1=vwsz1_plus_vwsc1 
    clc
    lda.z y
    adc #<$7d*$100
    sta.z y
    lda.z y+1
    adc #>$7d*$100
    sta.z y+1
    // [65] loop::$8 = > loop::y#0 -- vbuaa=_hi_vwsz1 
    lda.z y+1
    // [66] PLEX_YPOS[loop::i#2] = loop::$8 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z i
    sta PLEX_YPOS,y
    // [67] loop::a#1 = loop::a#2 + $62 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z a
    axs #-[$62]
    stx.z a
    // [68] loop::r#1 = loop::r#2 + 3 -- vbsz1=vbsz1_plus_vbsc1 
    lax.z r
    axs #-[3]
    stx.z r
    // [69] loop::i#1 = ++ loop::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [70] if(loop::i#1!=NUM_BOBS-1+1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #NUM_BOBS-1+1
    cmp.z i
    bne __b4_from___b12
    jmp __b5
    // loop::@5
  __b5:
    // [71] *BORDER_COLOR = 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta BORDER_COLOR
    // [72] call plexSort 
    // [147] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from___b5:
    jsr plexSort
    jmp __b13
    // loop::@13
  __b13:
    // [73] loop::angle#1 = loop::angle#6 + 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z angle
    axs #-[3]
    stx.z angle
    // [74] *BORDER_COLOR = BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDER_COLOR
    jmp __b6
  // Sort the sprites by y-position
    // loop::@6
  __b6:
    // [75] loop::$11 = *D011 & VIC_RST8 -- vbuaa=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
    // [76] if(loop::$11!=0) goto loop::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b6
    // [77] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
  __b7_from___b6:
    // [77] phi loop::i1#5 = 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i1
    jmp __b7
  // Show the sprites
    // [77] phi from loop::@14 to loop::@7 [phi:loop::@14->loop::@7]
  __b7_from___b14:
    // [77] phi loop::i1#5 = loop::i1#1 [phi:loop::@14->loop::@7#0] -- register_copy 
    jmp __b7
    // loop::@7
  __b7:
    // [78] *BORDER_COLOR = BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDER_COLOR
    jmp plexFreeNextYpos1
    // loop::plexFreeNextYpos1
  plexFreeNextYpos1:
    // [79] loop::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_free_next
    lda PLEX_FREE_YPOS,y
    sta.z plexFreeNextYpos1_return
    jmp __b8
    // loop::@8
  __b8:
    // [80] if(*RASTER<loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z plexFreeNextYpos1_return
    bcc __b8
    jmp __b9
    // loop::@9
  __b9:
    // [81] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // [82] call plexShowSprite 
    jsr plexShowSprite
    jmp __b14
    // loop::@14
  __b14:
    // [83] loop::i1#1 = ++ loop::i1#5 -- vbuz1=_inc_vbuz1 
    inc.z i1
    // [84] if(loop::i1#1!=PLEX_COUNT-1+1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i1
    bne __b7_from___b14
    jmp __b10
    // loop::@10
  __b10:
    // [85] *BORDER_COLOR = BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDER_COLOR
    // [86] call keyboard_key_pressed 
    // [198] phi from loop::@10 to keyboard_key_pressed [phi:loop::@10->keyboard_key_pressed]
  keyboard_key_pressed_from___b10:
    jsr keyboard_key_pressed
    // [87] keyboard_key_pressed::return#3 = keyboard_key_pressed::return#0
    jmp __b15
    // loop::@15
  __b15:
    // [88] loop::$18 = keyboard_key_pressed::return#3
    // [89] if(0!=loop::$18) goto loop::@return -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __breturn
    // [42] phi from loop::@15 to loop::@1 [phi:loop::@15->loop::@1]
  __b1_from___b15:
    // [42] phi loop::angle#6 = loop::angle#1 [phi:loop::@15->loop::@1#0] -- register_copy 
    jmp __b1
    // loop::@return
  __breturn:
    // [90] return 
    rts
}
  // exit
// Exit the program
exit: {
    // [92] phi from exit exit::@2 to exit::@1 [phi:exit/exit::@2->exit::@1]
  __b1_from_exit:
  __b1_from___b2:
    jmp __b1
  // Wait for space release
    // exit::@1
  __b1:
    // [93] call keyboard_key_pressed 
    // [198] phi from exit::@1 to keyboard_key_pressed [phi:exit::@1->keyboard_key_pressed]
  keyboard_key_pressed_from___b1:
    jsr keyboard_key_pressed
    // [94] keyboard_key_pressed::return#2 = keyboard_key_pressed::return#0
    jmp __b2
    // exit::@2
  __b2:
    // [95] exit::$0 = keyboard_key_pressed::return#2
    // [96] if(0!=exit::$0) goto exit::@1 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b1_from___b2
    jmp __breturn
    // exit::@return
  __breturn:
    // [97] return 
    rts
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    jmp plexSetScreen1
    // plexInit::plexSetScreen1
  plexSetScreen1:
    // [99] PLEX_SCREEN_PTR = SCREEN+$3f8 -- pbuz1=pbuc1 
    lda #<SCREEN+$3f8
    sta.z PLEX_SCREEN_PTR
    lda #>SCREEN+$3f8
    sta.z PLEX_SCREEN_PTR+1
    // [100] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  __b1_from_plexSetScreen1:
    // [100] phi plexInit::i#2 = 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [100] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  __b1_from___b1:
    // [100] phi plexInit::i#2 = plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp __b1
    // plexInit::@1
  __b1:
    // [101] PLEX_SORTED_IDX[plexInit::i#2] = plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // [102] plexInit::i#1 = ++ plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [103] if(plexInit::i#1!=PLEX_COUNT-1+1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1_from___b1
    jmp __breturn
    // plexInit::@return
  __breturn:
    // [104] return 
    rts
}
  // mulf_init
// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/4)
mulf_init: {
    // x/2
    .label c = 5
    // Counter used for determining x%2==0
    .label sqr1_hi = $f
    // Fill mulf_sqr1 = f(x) = int(x*x/4): If f(x) = x*x/4 then f(x+1) = f(x) + x/2 + 1/4
    .label sqr = $b
    .label sqr1_lo = $d
    // Decrease or increase x_255 - initially we decrease
    .label sqr2_hi = 8
    .label sqr2_lo = 6
    //Start with g(0)=f(255)
    .label dir = $a
    // [106] phi from mulf_init to mulf_init::@1 [phi:mulf_init->mulf_init::@1]
  __b1_from_mulf_init:
    // [106] phi mulf_init::x_2#3 = 0 [phi:mulf_init->mulf_init::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [106] phi mulf_init::sqr1_hi#2 = mulf_sqr1_hi+1 [phi:mulf_init->mulf_init::@1#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_hi+1
    sta.z sqr1_hi
    lda #>mulf_sqr1_hi+1
    sta.z sqr1_hi+1
    // [106] phi mulf_init::sqr#4 = 0 [phi:mulf_init->mulf_init::@1#2] -- vwuz1=vwuc1 
    lda #<0
    sta.z sqr
    lda #>0
    sta.z sqr+1
    // [106] phi mulf_init::c#2 = 0 [phi:mulf_init->mulf_init::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    // [106] phi mulf_init::sqr1_lo#2 = mulf_sqr1_lo+1 [phi:mulf_init->mulf_init::@1#4] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_lo+1
    sta.z sqr1_lo
    lda #>mulf_sqr1_lo+1
    sta.z sqr1_lo+1
    jmp __b1
    // mulf_init::@1
  __b1:
    // [107] if(mulf_init::sqr1_lo#2!=mulf_sqr1_lo+$200) goto mulf_init::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr1_lo+1
    cmp #>mulf_sqr1_lo+$200
    bne __b2
    lda.z sqr1_lo
    cmp #<mulf_sqr1_lo+$200
    bne __b2
    // [108] phi from mulf_init::@1 to mulf_init::@5 [phi:mulf_init::@1->mulf_init::@5]
  __b5_from___b1:
    // [108] phi mulf_init::dir#2 = $ff [phi:mulf_init::@1->mulf_init::@5#0] -- vbuz1=vbuc1 
    lda #$ff
    sta.z dir
    // [108] phi mulf_init::sqr2_hi#2 = mulf_sqr2_hi [phi:mulf_init::@1->mulf_init::@5#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_hi
    sta.z sqr2_hi
    lda #>mulf_sqr2_hi
    sta.z sqr2_hi+1
    // [108] phi mulf_init::x_255#2 = -1 [phi:mulf_init::@1->mulf_init::@5#2] -- vbuxx=vbuc1 
    ldx #-1
    // [108] phi mulf_init::sqr2_lo#2 = mulf_sqr2_lo [phi:mulf_init::@1->mulf_init::@5#3] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_lo
    sta.z sqr2_lo
    lda #>mulf_sqr2_lo
    sta.z sqr2_lo+1
    jmp __b5
    // mulf_init::@5
  __b5:
    // [109] if(mulf_init::sqr2_lo#2!=mulf_sqr2_lo+$1ff) goto mulf_init::@6 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr2_lo+1
    cmp #>mulf_sqr2_lo+$1ff
    bne __b6
    lda.z sqr2_lo
    cmp #<mulf_sqr2_lo+$1ff
    bne __b6
    jmp __b7
    // mulf_init::@7
  __b7:
    // [110] *(mulf_sqr2_lo+$1ff) = *(mulf_sqr1_lo+$100) -- _deref_pbuc1=_deref_pbuc2 
    // Set the very last value g(511) = f(256)
    lda mulf_sqr1_lo+$100
    sta mulf_sqr2_lo+$1ff
    // [111] *(mulf_sqr2_hi+$1ff) = *(mulf_sqr1_hi+$100) -- _deref_pbuc1=_deref_pbuc2 
    lda mulf_sqr1_hi+$100
    sta mulf_sqr2_hi+$1ff
    jmp __breturn
    // mulf_init::@return
  __breturn:
    // [112] return 
    rts
    // mulf_init::@6
  __b6:
    // [113] *mulf_init::sqr2_lo#2 = mulf_sqr1_lo[mulf_init::x_255#2] -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_lo,x
    ldy #0
    sta (sqr2_lo),y
    // [114] *mulf_init::sqr2_hi#2 = mulf_sqr1_hi[mulf_init::x_255#2] -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_hi,x
    ldy #0
    sta (sqr2_hi),y
    // [115] mulf_init::sqr2_hi#1 = ++ mulf_init::sqr2_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_hi
    bne !+
    inc.z sqr2_hi+1
  !:
    // [116] mulf_init::x_255#1 = mulf_init::x_255#2 + mulf_init::dir#2 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc.z dir
    tax
    // [117] if(mulf_init::x_255#1!=0) goto mulf_init::@9 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b9_from___b6
    // [119] phi from mulf_init::@6 to mulf_init::@8 [phi:mulf_init::@6->mulf_init::@8]
  __b8_from___b6:
    // [119] phi mulf_init::dir#4 = 1 [phi:mulf_init::@6->mulf_init::@8#0] -- vbuz1=vbuc1 
    lda #1
    sta.z dir
    jmp __b8
    // [118] phi from mulf_init::@6 to mulf_init::@9 [phi:mulf_init::@6->mulf_init::@9]
  __b9_from___b6:
    jmp __b9
    // mulf_init::@9
  __b9:
    // [119] phi from mulf_init::@9 to mulf_init::@8 [phi:mulf_init::@9->mulf_init::@8]
  __b8_from___b9:
    // [119] phi mulf_init::dir#4 = mulf_init::dir#2 [phi:mulf_init::@9->mulf_init::@8#0] -- register_copy 
    jmp __b8
    // mulf_init::@8
  __b8:
    // [120] mulf_init::sqr2_lo#1 = ++ mulf_init::sqr2_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_lo
    bne !+
    inc.z sqr2_lo+1
  !:
    // [108] phi from mulf_init::@8 to mulf_init::@5 [phi:mulf_init::@8->mulf_init::@5]
  __b5_from___b8:
    // [108] phi mulf_init::dir#2 = mulf_init::dir#4 [phi:mulf_init::@8->mulf_init::@5#0] -- register_copy 
    // [108] phi mulf_init::sqr2_hi#2 = mulf_init::sqr2_hi#1 [phi:mulf_init::@8->mulf_init::@5#1] -- register_copy 
    // [108] phi mulf_init::x_255#2 = mulf_init::x_255#1 [phi:mulf_init::@8->mulf_init::@5#2] -- register_copy 
    // [108] phi mulf_init::sqr2_lo#2 = mulf_init::sqr2_lo#1 [phi:mulf_init::@8->mulf_init::@5#3] -- register_copy 
    jmp __b5
    // mulf_init::@2
  __b2:
    // [121] mulf_init::c#1 = ++ mulf_init::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [122] mulf_init::$1 = mulf_init::c#1 & 1 -- vbuaa=vbuz1_band_vbuc1 
    lda #1
    and.z c
    // [123] if(mulf_init::$1!=0) goto mulf_init::@3 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b3_from___b2
    jmp __b4
    // mulf_init::@4
  __b4:
    // [124] mulf_init::x_2#1 = ++ mulf_init::x_2#3 -- vbuxx=_inc_vbuxx 
    inx
    // [125] mulf_init::sqr#2 = ++ mulf_init::sqr#4 -- vwuz1=_inc_vwuz1 
    inc.z sqr
    bne !+
    inc.z sqr+1
  !:
    // [126] phi from mulf_init::@2 mulf_init::@4 to mulf_init::@3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3]
  __b3_from___b2:
  __b3_from___b4:
    // [126] phi mulf_init::x_2#2 = mulf_init::x_2#3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#0] -- register_copy 
    // [126] phi mulf_init::sqr#3 = mulf_init::sqr#4 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#1] -- register_copy 
    jmp __b3
    // mulf_init::@3
  __b3:
    // [127] mulf_init::$4 = < mulf_init::sqr#3 -- vbuaa=_lo_vwuz1 
    lda.z sqr
    // [128] *mulf_init::sqr1_lo#2 = mulf_init::$4 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sqr1_lo),y
    // [129] mulf_init::$5 = > mulf_init::sqr#3 -- vbuaa=_hi_vwuz1 
    lda.z sqr+1
    // [130] *mulf_init::sqr1_hi#2 = mulf_init::$5 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sqr1_hi),y
    // [131] mulf_init::sqr1_hi#1 = ++ mulf_init::sqr1_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_hi
    bne !+
    inc.z sqr1_hi+1
  !:
    // [132] mulf_init::sqr#1 = mulf_init::sqr#3 + mulf_init::x_2#2 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z sqr
    sta.z sqr
    bcc !+
    inc.z sqr+1
  !:
    // [133] mulf_init::sqr1_lo#1 = ++ mulf_init::sqr1_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_lo
    bne !+
    inc.z sqr1_lo+1
  !:
    // [106] phi from mulf_init::@3 to mulf_init::@1 [phi:mulf_init::@3->mulf_init::@1]
  __b1_from___b3:
    // [106] phi mulf_init::x_2#3 = mulf_init::x_2#2 [phi:mulf_init::@3->mulf_init::@1#0] -- register_copy 
    // [106] phi mulf_init::sqr1_hi#2 = mulf_init::sqr1_hi#1 [phi:mulf_init::@3->mulf_init::@1#1] -- register_copy 
    // [106] phi mulf_init::sqr#4 = mulf_init::sqr#1 [phi:mulf_init::@3->mulf_init::@1#2] -- register_copy 
    // [106] phi mulf_init::c#2 = mulf_init::c#1 [phi:mulf_init::@3->mulf_init::@1#3] -- register_copy 
    // [106] phi mulf_init::sqr1_lo#2 = mulf_init::sqr1_lo#1 [phi:mulf_init::@3->mulf_init::@1#4] -- register_copy 
    jmp __b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const c = ' '
    .const num = $3e8
    .label str = SCREEN
    .label end = str+num
    .label dst = $d
    // [135] phi from memset to memset::@1 [phi:memset->memset::@1]
  __b1_from_memset:
    // [135] phi memset::dst#2 = (byte*)memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    jmp __b1
    // memset::@1
  __b1:
    // [136] if(memset::dst#2!=memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    jmp __breturn
    // memset::@return
  __breturn:
    // [137] return 
    rts
    // memset::@2
  __b2:
    // [138] *memset::dst#2 = memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // [139] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [135] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
  __b1_from___b2:
    // [135] phi memset::dst#2 = memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // mulf8s
// Fast multiply two signed chars to a unsigned int result
// mulf8s(signed byte register(A) a, signed byte register(X) b)
mulf8s: {
    .label return = $f
    jmp mulf8s_prepare1
    // mulf8s::mulf8s_prepare1
  mulf8s_prepare1:
    // [141] mulf8u_prepare::a#0 = (byte)mulf8s::mulf8s_prepare1_a#0
    // [142] call mulf8u_prepare 
    jsr mulf8u_prepare
    jmp __b1
    // mulf8s::@1
  __b1:
    // [143] mulf8s_prepared::b#0 = mulf8s::b#2 -- vbsz1=vbsxx 
    stx.z mulf8s_prepared.b
    // [144] call mulf8s_prepared 
    jsr mulf8s_prepared
    jmp __b2
    // mulf8s::@2
  __b2:
    // [145] mulf8s::return#0 = (signed word)mulf8s_prepared::m#4
    jmp __breturn
    // mulf8s::@return
  __breturn:
    // [146] return 
    rts
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $18
    .label nxt_y = $19
    .label m = $17
    // [148] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  __b1_from_plexSort:
    // [148] phi plexSort::m#2 = 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    jmp __b1
    // [148] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  __b1_from___b2:
    // [148] phi plexSort::m#2 = plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp __b1
    // plexSort::@1
  __b1:
    // [149] plexSort::nxt_idx#0 = (PLEX_SORTED_IDX+1)[plexSort::m#2] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // [150] plexSort::nxt_y#0 = PLEX_YPOS[plexSort::nxt_idx#0] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z nxt_idx
    lda PLEX_YPOS,y
    sta.z nxt_y
    // [151] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    jmp __b5
    // plexSort::@5
  __b5:
    // [152] plexSort::s#6 = plexSort::m#2 -- vbuxx=vbuz1 
    ldx.z m
    // [153] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
  __b3_from___b5:
  __b3_from___b7:
    // [153] phi plexSort::s#3 = plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
    jmp __b3
    // plexSort::@3
  __b3:
    // [154] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // [155] plexSort::s#1 = -- plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // [156] if(plexSort::s#1==$ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq __b4
    jmp __b7
    // plexSort::@7
  __b7:
    // [157] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3_from___b7
    jmp __b4
    // plexSort::@4
  __b4:
    // [158] plexSort::s#2 = ++ plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // [159] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    jmp __b2
    // plexSort::@2
  __b2:
    // [160] plexSort::m#1 = ++ plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [161] if(plexSort::m#1!=PLEX_COUNT-2+1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1_from___b2
    jmp __b6
    // plexSort::@6
  __b6:
    // [162] plex_show_idx = 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta.z plex_show_idx
    // [163] plex_sprite_idx = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [164] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [165] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
  plexFreePrepare1_from___b6:
    jmp plexFreePrepare1
    // plexSort::plexFreePrepare1
  plexFreePrepare1:
    // [166] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1:
    // [166] phi plexSort::plexFreePrepare1_s#2 = 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp plexFreePrepare1___b1
    // [166] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1___b1:
    // [166] phi plexSort::plexFreePrepare1_s#2 = plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1___b1
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // [167] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // [168] plexSort::plexFreePrepare1_s#1 = ++ plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [169] if(plexSort::plexFreePrepare1_s#1!=8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1___b1_from_plexFreePrepare1___b1
    jmp plexFreePrepare1___b2
    // plexSort::plexFreePrepare1_@2
  plexFreePrepare1___b2:
    // [170] plex_free_next = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    jmp __breturn
    // plexSort::@return
  __breturn:
    // [171] return 
    rts
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = $19
    // [172] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // [173] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // [174] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
    // plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
    // [175] plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#0 + $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
    // [176] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // [177] plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1 -- vbuaa=vbuz1_plus_1 
    lda.z plex_free_next
    clc
    adc #1
    // [178] plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7 -- vbuaa=vbuaa_band_vbuc1 
    and #7
    // [179] plex_free_next = plexShowSprite::plexFreeAdd1_$2 -- vbuz1=vbuaa 
    sta.z plex_free_next
    jmp __b5
    // plexShowSprite::@5
  __b5:
    // [180] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] -- pbuz1_derefidx_vbuz2=pbuc1_derefidx_(pbuc2_derefidx_vbuz3) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldy.z plex_sprite_idx
    sta (PLEX_SCREEN_PTR),y
    // [181] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // [182] plexShowSprite::$11 = plexShowSprite::xpos_idx#0 << 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [183] plexShowSprite::$2 = < PLEX_XPOS[plexShowSprite::$11] -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
    // [184] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // [185] plexShowSprite::$3 = > PLEX_XPOS[plexShowSprite::$11] -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // [186] if(plexShowSprite::$3!=0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b1
    jmp __b3
    // plexShowSprite::@3
  __b3:
    // [187] plexShowSprite::$9 = $ff ^ plex_sprite_msb -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // [188] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    jmp __b2
    // plexShowSprite::@2
  __b2:
    // [189] plexShowSprite::$5 = plex_sprite_idx + 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // [190] plexShowSprite::$6 = plexShowSprite::$5 & 7 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #7
    // [191] plex_sprite_idx = plexShowSprite::$6 -- vbuz1=vbuaa 
    sta.z plex_sprite_idx
    // [192] plex_show_idx = ++ plex_show_idx -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // [193] plex_sprite_msb = plex_sprite_msb << 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // [194] if(plex_sprite_msb!=0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne __breturn
    jmp __b4
    // plexShowSprite::@4
  __b4:
    // [195] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    jmp __breturn
    // plexShowSprite::@return
  __breturn:
    // [196] return 
    rts
    // plexShowSprite::@1
  __b1:
    // [197] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
keyboard_key_pressed: {
    .const colidx = KEY_SPACE&7
    .label rowidx = KEY_SPACE>>3
    // [199] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [200] keyboard_matrix_read::return#2 = keyboard_matrix_read::return#0
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [201] keyboard_key_pressed::$2 = keyboard_matrix_read::return#2
    // [202] keyboard_key_pressed::return#0 = keyboard_key_pressed::$2 & *(keyboard_matrix_col_bitmask+keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band__deref_pbuc1 
    and keyboard_matrix_col_bitmask+colidx
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [203] return 
    rts
}
  // mulf8u_prepare
// Prepare for fast multiply with an unsigned char to a unsigned int result
// mulf8u_prepare(byte register(A) a)
mulf8u_prepare: {
    .label memA = $fd
    // [204] *mulf8u_prepare::memA = mulf8u_prepare::a#0 -- _deref_pbuc1=vbuaa 
    sta memA
    // asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
    lda memA
    sta mulf8u_prepared.sm1+1
    sta mulf8u_prepared.sm3+1
    eor #$ff
    sta mulf8u_prepared.sm2+1
    sta mulf8u_prepared.sm4+1
    jmp __breturn
    // mulf8u_prepare::@return
  __breturn:
    // [206] return 
    rts
}
  // mulf8s_prepared
// Calculate fast multiply with a prepared unsigned char to a unsigned int result
// The prepared number is set by calling mulf8s_prepare(char a)
// mulf8s_prepared(signed byte zp($18) b)
mulf8s_prepared: {
    .label memA = $fd
    .label m = $f
    .label b = $18
    // [207] mulf8u_prepared::b#0 = (byte)mulf8s_prepared::b#0 -- vbuaa=vbuz1 
    lda.z b
    // [208] call mulf8u_prepared 
    jsr mulf8u_prepared
    // [209] mulf8u_prepared::return#2 = mulf8u_prepared::return#0
    jmp __b5
    // mulf8s_prepared::@5
  __b5:
    // [210] mulf8s_prepared::m#0 = mulf8u_prepared::return#2
    // [211] if(*mulf8s_prepared::memA>=0) goto mulf8s_prepared::@1 -- _deref_pbsc1_ge_0_then_la1 
    lda memA
    cmp #0
    bpl __b1_from___b5
    jmp __b3
    // mulf8s_prepared::@3
  __b3:
    // [212] mulf8s_prepared::$6 = > mulf8s_prepared::m#0 -- vbuaa=_hi_vwuz1 
    lda.z m+1
    // [213] mulf8s_prepared::$11 = mulf8s_prepared::$6 - (byte)mulf8s_prepared::b#0 -- vbuaa=vbuaa_minus_vbuz1 
    sec
    sbc.z b
    // [214] mulf8s_prepared::m#1 = mulf8s_prepared::m#0 hi= mulf8s_prepared::$11 -- vwuz1=vwuz1_sethi_vbuaa 
    sta.z m+1
    // [215] phi from mulf8s_prepared::@3 mulf8s_prepared::@5 to mulf8s_prepared::@1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1]
  __b1_from___b3:
  __b1_from___b5:
    // [215] phi mulf8s_prepared::m#5 = mulf8s_prepared::m#1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1#0] -- register_copy 
    jmp __b1
    // mulf8s_prepared::@1
  __b1:
    // [216] if(mulf8s_prepared::b#0>=0) goto mulf8s_prepared::@2 -- vbsz1_ge_0_then_la1 
    lda.z b
    cmp #0
    bpl __b2_from___b1
    jmp __b4
    // mulf8s_prepared::@4
  __b4:
    // [217] mulf8s_prepared::$9 = > mulf8s_prepared::m#5 -- vbuaa=_hi_vwuz1 
    lda.z m+1
    // [218] mulf8s_prepared::$12 = mulf8s_prepared::$9 - (byte)*mulf8s_prepared::memA -- vbuaa=vbuaa_minus__deref_pbuc1 
    sec
    sbc memA
    // [219] mulf8s_prepared::m#2 = mulf8s_prepared::m#5 hi= mulf8s_prepared::$12 -- vwuz1=vwuz1_sethi_vbuaa 
    sta.z m+1
    // [220] phi from mulf8s_prepared::@1 mulf8s_prepared::@4 to mulf8s_prepared::@2 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2]
  __b2_from___b1:
  __b2_from___b4:
    // [220] phi mulf8s_prepared::m#4 = mulf8s_prepared::m#5 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2#0] -- register_copy 
    jmp __b2
    // mulf8s_prepared::@2
  __b2:
    jmp __breturn
    // mulf8s_prepared::@return
  __breturn:
    // [221] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable the normal interrupt or sei/cli around calls to the keyboard matrix reader.
keyboard_matrix_read: {
    // [222] *((byte*)CIA1) = *(keyboard_matrix_row_bitmask+keyboard_key_pressed::rowidx#0) -- _deref_pbuc1=_deref_pbuc2 
    lda keyboard_matrix_row_bitmask+keyboard_key_pressed.rowidx
    sta CIA1
    // [223] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B
    eor #$ff
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [224] return 
    rts
}
  // mulf8u_prepared
// Calculate fast multiply with a prepared unsigned char to a unsigned int result
// The prepared number is set by calling mulf8u_prepare(char a)
// mulf8u_prepared(byte register(A) b)
mulf8u_prepared: {
    .label resL = $fe
    .label memB = $ff
    .label return = $f
    // [225] *mulf8u_prepared::memB = mulf8u_prepared::b#0 -- _deref_pbuc1=vbuaa 
    sta memB
    // asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
    ldx memB
    sec
  sm1:
    lda mulf_sqr1_lo,x
  sm2:
    sbc mulf_sqr2_lo,x
    sta resL
  sm3:
    lda mulf_sqr1_hi,x
  sm4:
    sbc mulf_sqr2_hi,x
    sta memB
    // [227] mulf8u_prepared::return#0 = *mulf8u_prepared::memB w= *mulf8u_prepared::resL -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda resL
    sta.z return
    lda memB
    sta.z return+1
    jmp __breturn
    // mulf8u_prepared::@return
  __breturn:
    // [228] return 
    rts
}
  // File Data
  // The x-positions of the multiplexer sprites (0x000-0x1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // mulf_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
  // <f(x) = <(( x * x )/4)
  .align $100
  mulf_sqr1_lo: .fill $200, 0
  // >f(x) = >(( x * x )/4)
  .align $100
  mulf_sqr1_hi: .fill $200, 0
  // <g(x) =  <((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_lo: .fill $200, 0
  // >g(x) = >((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_hi: .fill $200, 0
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80
  // The BOB sprite
  .align $1000
SPRITE:
.var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)

  // Sine and Cosine tables
  // Angles: $00=0, $80=PI,$100=2*PI
  // Sine/Cosine: signed fixed [-$7f,$7f]
  .align $40
SIN:
.for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __init1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b5
Removing instruction jmp __b13
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp plexFreeNextYpos1
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b14
Removing instruction jmp __b10
Removing instruction jmp __b15
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp plexSetScreen1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __breturn
Removing instruction jmp __b9
Removing instruction jmp __b8
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp mulf8s_prepare1
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b7
Removing instruction jmp __b4
Removing instruction jmp __b2
Removing instruction jmp __b6
Removing instruction jmp plexFreePrepare1
Removing instruction jmp plexFreePrepare1___b1
Removing instruction jmp plexFreePrepare1___b2
Removing instruction jmp __breturn
Removing instruction jmp plexFreeAdd1
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b4
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Replacing instruction lda.z i with TYA
Replacing instruction lda.z i with TYA
Replacing instruction ldx.z x+1 with TAX
Removing instruction lda.z y+1
Replacing instruction lda #<0 with TXA
Removing instruction lda #>0
Removing instruction lda #0
Removing instruction ldy #0
Removing instruction ldy #0
Replacing instruction ldy.z nxt_idx with TAY
Removing instruction lda.z nxt_y
Removing instruction lda #0
Replacing instruction lda.z plex_free_next with TYA
Removing instruction lda memA
Replacing instruction ldx memB with TAX
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b1_from___b1 with __b1
Replacing label __b3_from___b3 with __b3
Replacing label __b4_from___b12 with __b4
Replacing label __b7_from___b14 with __b7
Replacing label __b1 with __b2
Replacing label __b1_from___b1 with __b1
Replacing label __b9_from___b6 with __b8
Replacing label __b3_from___b2 with __b3
Replacing label __b3_from___b7 with __b3
Replacing label __b1_from___b2 with __b1
Replacing label plexFreePrepare1___b1_from_plexFreePrepare1___b1 with plexFreePrepare1___b1
Replacing label __b1_from___b5 with __b1
Replacing label __b2_from___b1 with __b2
Removing instruction __b1_from___init1:
Removing instruction __b1_from_main:
Removing instruction loop_from___b1:
Removing instruction __b2_from___b1:
Removing instruction exit_from___b2:
Removing instruction __b1_from___b1:
Removing instruction __b3_from___b3:
Removing instruction __b4_from___b3:
Removing instruction mulf_init_from___b4:
Removing instruction __b5_from___b4:
Removing instruction __b1:
Removing instruction __b4_from___b12:
Removing instruction __b7_from___b14:
Removing instruction __b1_from_exit:
Removing instruction keyboard_key_pressed_from___b1:
Removing instruction __b1_from___b1:
Removing instruction __b9_from___b6:
Removing instruction __b9:
Removing instruction __b8_from___b9:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b4:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction __b3_from___b5:
Removing instruction __b3_from___b7:
Removing instruction plexFreePrepare1_from___b6:
Removing instruction plexFreePrepare1___b1_from_plexFreePrepare1:
Removing instruction plexFreePrepare1___b1_from_plexFreePrepare1___b1:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __breturn:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __init1:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction plexInit_from_init:
Removing instruction __b1_from_init:
Removing instruction __b2:
Removing instruction __b3_from___b2:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction memset_from___b5:
Removing instruction __breturn:
Removing instruction __b1_from_loop:
Removing instruction __b3:
Removing instruction __b4_from___b3:
Removing instruction mulf8s_from___b4:
Removing instruction __b11:
Removing instruction mulf8s_from___b11:
Removing instruction __b12:
Removing instruction __b5:
Removing instruction plexSort_from___b5:
Removing instruction __b13:
Removing instruction __b7_from___b6:
Removing instruction plexFreeNextYpos1:
Removing instruction __b9:
Removing instruction __b14:
Removing instruction __b10:
Removing instruction keyboard_key_pressed_from___b10:
Removing instruction __b15:
Removing instruction __b1_from___b15:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __breturn:
Removing instruction plexSetScreen1:
Removing instruction __b1_from_plexSetScreen1:
Removing instruction __breturn:
Removing instruction __b1_from_mulf_init:
Removing instruction __b5_from___b1:
Removing instruction __b7:
Removing instruction __breturn:
Removing instruction __b8_from___b6:
Removing instruction __b5_from___b8:
Removing instruction __b4:
Removing instruction __b1_from___b3:
Removing instruction __b1_from_memset:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction mulf8s_prepare1:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b1_from_plexSort:
Removing instruction __b5:
Removing instruction __b7:
Removing instruction __b6:
Removing instruction plexFreePrepare1:
Removing instruction plexFreePrepare1___b2:
Removing instruction __breturn:
Removing instruction plexFreeAdd1:
Removing instruction __b5:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b5:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Relabelling long label __b1_from___b2 to __b1
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b7
Removing instruction jmp __b1
Removing instruction jmp __b8
Removing instruction jmp __b1
Removing instruction jmp plexFreePrepare1___b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldx.z m
Removing instruction lda #0
Removing instruction ldx.z plex_show_idx
Succesful ASM optimization Pass5UnnecesaryLoadElimination

FINAL SYMBOL TABLE
const nomodify byte BLACK = 0
const nomodify byte* BORDER_COLOR = (byte*) 53280
const nomodify struct MOS6526_CIA* CIA1 = (struct MOS6526_CIA*) 56320
const signed byte* COS = SIN+$40
const nomodify byte* D011 = (byte*) 53265
const nomodify byte GREEN = 5
const nomodify byte KEY_SPACE = $3c
const nomodify byte NUM_BOBS = $10
const byte OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
const nomodify byte PLEX_COUNT = $20
const byte* PLEX_FREE_YPOS[8]  = { fill( 8, 0) }
const byte* PLEX_PTR[PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
volatile byte* PLEX_SCREEN_PTR loadstore zp[2]:17 952.8679245283018
const byte* PLEX_SORTED_IDX[PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
const word* PLEX_XPOS[PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
const byte* PLEX_YPOS[PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
const nomodify byte* RASTER = (byte*) 53266
const nomodify byte* SCREEN = (byte*) 1024
const signed byte* SIN[$140]  = kickasm {{ .for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))
 }}
const byte* SPRITE[]  = kickasm {{ .var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
const nomodify byte* SPRITES_COLOR = (byte*) 53287
const nomodify byte* SPRITES_ENABLE = (byte*) 53269
const nomodify byte* SPRITES_XMSB = (byte*) 53264
const nomodify byte* SPRITES_XPOS = (byte*) 53248
const nomodify byte* SPRITES_YPOS = (byte*) 53249
const nomodify byte VIC_DEN = $10
const nomodify byte VIC_RSEL = 8
const nomodify byte VIC_RST8 = $80
void __start()
void exit()
byte~ exit::$0 reg byte a 2002.0
void init()
byte~ init::$10 reg byte a 2002.0
byte~ init::$3 reg byte a 2002.0
byte~ init::$4 reg byte x 1001.0
byte~ init::$5 reg byte a 2002.0
byte~ init::$6 reg byte a 2002.0
byte~ init::$9 reg byte a 2002.0
byte init::i
byte init::i#1 i zp[1]:2 1501.5
byte init::i#2 i zp[1]:2 800.8000000000001
byte init::i1
byte init::i1#1 reg byte x 1501.5
byte init::i1#2 reg byte x 1501.5
byte keyboard_key_pressed(byte keyboard_key_pressed::key)
byte~ keyboard_key_pressed::$2 reg byte a 20002.0
byte keyboard_key_pressed::colidx
const byte keyboard_key_pressed::colidx#0 colidx = KEY_SPACE&7
byte keyboard_key_pressed::key
byte keyboard_key_pressed::return
byte keyboard_key_pressed::return#0 reg byte a 3000.75
byte keyboard_key_pressed::return#2 reg byte a 2002.0
byte keyboard_key_pressed::return#3 reg byte a 2002.0
byte keyboard_key_pressed::rowidx
const byte keyboard_key_pressed::rowidx#0 rowidx = KEY_SPACE>>3
const byte* keyboard_matrix_col_bitmask[8]  = { 1, 2, 4, 8, $10, $20, $40, $80 }
byte keyboard_matrix_read(byte keyboard_matrix_read::rowid)
byte keyboard_matrix_read::return
byte keyboard_matrix_read::return#0 reg byte a 36667.33333333333
byte keyboard_matrix_read::return#2 reg byte a 20002.0
byte keyboard_matrix_read::row_pressed_bits
byte keyboard_matrix_read::rowid
const byte* keyboard_matrix_row_bitmask[8]  = { $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f }
void loop()
signed word~ loop::$1 zp[2]:15 20002.0
byte~ loop::$11 reg byte a 20002.0
byte~ loop::$18 reg byte a 2002.0
signed word~ loop::$2 zp[2]:15 20002.0
byte~ loop::$20 reg byte a 20002.0
byte~ loop::$4 reg byte x 10001.0
signed word~ loop::$5 zp[2]:15 20002.0
signed word~ loop::$6 zp[2]:15 20002.0
byte~ loop::$8 reg byte a 20002.0
byte loop::a
byte loop::a#1 a zp[1]:10 5000.5
byte loop::a#2 a zp[1]:10 1952.6190476190475
byte loop::a#6 a zp[1]:10 2002.0
byte loop::angle
byte loop::angle#1 angle zp[1]:2 117.76470588235294
byte loop::angle#6 angle zp[1]:2 96.87096774193549
byte loop::i
byte loop::i#1 i zp[1]:3 15001.5
byte loop::i#2 i zp[1]:3 1739.304347826087
byte loop::i1
byte loop::i1#1 i1 zp[1]:4 15001.5
byte loop::i1#5 i1 zp[1]:4 3333.6666666666665
byte loop::plexFreeNextYpos1_return
byte loop::plexFreeNextYpos1_return#0 plexFreeNextYpos1_return zp[1]:23 55001.0
signed byte loop::r
signed byte loop::r#1 r zp[1]:5 6667.333333333333
signed byte loop::r#2 r zp[1]:5 1818.3636363636363
byte loop::rasterY
signed word loop::x
signed word loop::x#0 x zp[2]:15 20002.0
signed word loop::y
signed word loop::y#0 y zp[2]:15 20002.0
void main()
void* memset(void* memset::str , byte memset::c , word memset::num)
byte memset::c
const byte memset::c#0 c = ' '
byte* memset::dst
byte* memset::dst#1 dst zp[2]:13 20002.0
byte* memset::dst#2 dst zp[2]:13 13334.666666666666
byte* memset::end
const byte* memset::end#0 end = (byte*)memset::str#0+memset::num#0
word memset::num
const word memset::num#0 num = $3e8
void* memset::return
void* memset::str
const void* memset::str#0 str = (void*)SCREEN
signed word mulf8s(signed byte mulf8s::a , signed byte mulf8s::b)
signed byte mulf8s::a
signed byte mulf8s::a#0 reg byte a 10001.0
signed byte mulf8s::a#1 reg byte a 10001.0
signed byte mulf8s::b
signed byte mulf8s::b#0 reg byte x 20002.0
signed byte mulf8s::b#1 reg byte x 20002.0
signed byte mulf8s::b#2 reg byte x 40001.0
signed byte mulf8s::mulf8s_prepare1_a
signed byte mulf8s::mulf8s_prepare1_a#0 reg byte a 20002.0
signed word mulf8s::return
signed word mulf8s::return#0 return zp[2]:15 30000.75
signed word mulf8s::return#2 return zp[2]:15 20002.0
signed word mulf8s::return#3 return zp[2]:15 20002.0
signed word mulf8s_prepared(signed byte mulf8s_prepared::b)
byte~ mulf8s_prepared::$11 reg byte a 2000002.0
byte~ mulf8s_prepared::$12 reg byte a 2000002.0
byte~ mulf8s_prepared::$6 reg byte a 2000002.0
byte~ mulf8s_prepared::$9 reg byte a 2000002.0
signed byte mulf8s_prepared::b
signed byte mulf8s_prepared::b#0 b zp[1]:24 110000.20000000001
word mulf8s_prepared::m
word mulf8s_prepared::m#0 m zp[2]:15 1000001.0
word mulf8s_prepared::m#1 m zp[2]:15 2000002.0
word mulf8s_prepared::m#2 m zp[2]:15 2000002.0
word mulf8s_prepared::m#4 m zp[2]:15 666667.3333333334
word mulf8s_prepared::m#5 m zp[2]:15 1250001.25
const nomodify signed byte* mulf8s_prepared::memA = (signed byte*) 253
signed word mulf8s_prepared::return
void mulf8u_prepare(byte mulf8u_prepare::a)
byte mulf8u_prepare::a
byte mulf8u_prepare::a#0 reg byte a 1100002.0
const nomodify byte* mulf8u_prepare::memA = (byte*) 253
word mulf8u_prepared(byte mulf8u_prepared::b)
byte mulf8u_prepared::b
byte mulf8u_prepared::b#0 reg byte a 1.1000002E7
const nomodify byte* mulf8u_prepared::memB = (byte*) 255
const nomodify byte* mulf8u_prepared::resL = (byte*) 254
word mulf8u_prepared::return
word mulf8u_prepared::return#0 return zp[2]:15 3666667.333333333
word mulf8u_prepared::return#2 return zp[2]:15 2000002.0
void mulf_init()
byte~ mulf_init::$1 reg byte a 20002.0
byte~ mulf_init::$4 reg byte a 20002.0
byte~ mulf_init::$5 reg byte a 20002.0
byte mulf_init::c
byte mulf_init::c#1 c zp[1]:5 2307.9230769230767
byte mulf_init::c#2 c zp[1]:5 10001.0
byte mulf_init::dir
byte mulf_init::dir#2 dir zp[1]:10 3750.375
byte mulf_init::dir#4 dir zp[1]:10 10001.0
word mulf_init::sqr
word mulf_init::sqr#1 sqr zp[2]:11 10001.0
word mulf_init::sqr#2 sqr zp[2]:11 20002.0
word mulf_init::sqr#3 sqr zp[2]:11 8334.166666666666
word mulf_init::sqr#4 sqr zp[2]:11 5000.5
byte* mulf_init::sqr1_hi
byte* mulf_init::sqr1_hi#1 sqr1_hi zp[2]:15 6667.333333333333
byte* mulf_init::sqr1_hi#2 sqr1_hi zp[2]:15 2500.25
byte* mulf_init::sqr1_lo
byte* mulf_init::sqr1_lo#1 sqr1_lo zp[2]:13 20002.0
byte* mulf_init::sqr1_lo#2 sqr1_lo zp[2]:13 2857.4285714285716
byte* mulf_init::sqr2_hi
byte* mulf_init::sqr2_hi#1 sqr2_hi zp[2]:8 3333.6666666666665
byte* mulf_init::sqr2_hi#2 sqr2_hi zp[2]:8 7500.75
byte* mulf_init::sqr2_lo
byte* mulf_init::sqr2_lo#1 sqr2_lo zp[2]:6 20002.0
byte* mulf_init::sqr2_lo#2 sqr2_lo zp[2]:6 4444.888888888889
byte mulf_init::x_2
byte mulf_init::x_2#1 reg byte x 10001.0
byte mulf_init::x_2#2 reg byte x 5000.5
byte mulf_init::x_2#3 reg byte x 6000.6
byte mulf_init::x_255
byte mulf_init::x_255#1 reg byte x 6000.6
byte mulf_init::x_255#2 reg byte x 8000.8
const byte* mulf_sqr1_hi[$200]  = { fill( $200, 0) }
const byte* mulf_sqr1_lo[$200]  = { fill( $200, 0) }
const byte* mulf_sqr2_hi[$200]  = { fill( $200, 0) }
const byte* mulf_sqr2_lo[$200]  = { fill( $200, 0) }
void plexInit(byte* plexInit::screen)
byte plexInit::i
byte plexInit::i#1 reg byte x 15001.5
byte plexInit::i#2 reg byte x 20002.0
byte* plexInit::plexSetScreen1_screen
byte* plexInit::screen
void plexShowSprite()
byte~ plexShowSprite::$11 reg byte x 100001.0
byte~ plexShowSprite::$2 reg byte a 200002.0
byte~ plexShowSprite::$3 reg byte a 200002.0
byte~ plexShowSprite::$5 reg byte x 200002.0
byte~ plexShowSprite::$6 reg byte a 200002.0
byte~ plexShowSprite::$9 reg byte a 200002.0
byte~ plexShowSprite::plexFreeAdd1_$0 reg byte a 200002.0
byte~ plexShowSprite::plexFreeAdd1_$1 reg byte a 200002.0
byte~ plexShowSprite::plexFreeAdd1_$2 reg byte a 200002.0
byte plexShowSprite::plexFreeAdd1_ypos
byte plexShowSprite::plexFreeAdd1_ypos#0 reg byte a 150001.5
byte plexShowSprite::plex_sprite_idx2
byte plexShowSprite::plex_sprite_idx2#0 plex_sprite_idx2 zp[1]:25 25000.25
byte plexShowSprite::xpos_idx
byte plexShowSprite::xpos_idx#0 reg byte a 200002.0
byte plexShowSprite::ypos
void plexSort()
byte plexSort::m
byte plexSort::m#1 m zp[1]:23 1500001.5
byte plexSort::m#2 m zp[1]:23 416667.0833333334
byte plexSort::nxt_idx
byte plexSort::nxt_idx#0 nxt_idx zp[1]:24 300000.30000000005
byte plexSort::nxt_y
byte plexSort::nxt_y#0 nxt_y zp[1]:25 1500000.375
byte plexSort::plexFreePrepare1_s
byte plexSort::plexFreePrepare1_s#1 reg byte x 1500001.5
byte plexSort::plexFreePrepare1_s#2 reg byte x 1500001.5
byte plexSort::s
byte plexSort::s#1 reg byte x 1.3666668333333332E7
byte plexSort::s#2 reg byte x 2000002.0
byte plexSort::s#3 reg byte x 2.05000025E7
byte plexSort::s#6 reg byte x 2000002.0
volatile byte plex_free_next loadstore zp[1]:22 8205.307692307691
volatile byte plex_show_idx loadstore zp[1]:19 10408.326530612245
volatile byte plex_sprite_idx loadstore zp[1]:20 8913.195652173914
volatile byte plex_sprite_msb loadstore zp[1]:21 12978.91489361702

reg byte x [ init::i1#2 init::i1#1 ]
zp[1]:2 [ loop::angle#6 loop::angle#1 init::i#2 init::i#1 ]
zp[1]:3 [ loop::i#2 loop::i#1 ]
zp[1]:4 [ loop::i1#5 loop::i1#1 ]
reg byte x [ plexInit::i#2 plexInit::i#1 ]
zp[1]:5 [ mulf_init::c#2 mulf_init::c#1 loop::r#2 loop::r#1 ]
reg byte x [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
zp[2]:6 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
reg byte x [ mulf_init::x_255#2 mulf_init::x_255#1 ]
zp[2]:8 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
zp[1]:10 [ mulf_init::dir#2 mulf_init::dir#4 loop::a#2 loop::a#1 loop::a#6 ]
zp[2]:11 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
zp[2]:13 [ memset::dst#2 memset::dst#1 mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
reg byte a [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ]
reg byte x [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
zp[2]:15 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 loop::$2 loop::x#0 loop::$6 loop::y#0 mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
zp[2]:17 [ PLEX_SCREEN_PTR ]
zp[1]:19 [ plex_show_idx ]
zp[1]:20 [ plex_sprite_idx ]
zp[1]:21 [ plex_sprite_msb ]
zp[1]:22 [ plex_free_next ]
reg byte a [ init::$10 ]
reg byte a [ init::$3 ]
reg byte x [ init::$4 ]
reg byte a [ init::$9 ]
reg byte a [ init::$5 ]
reg byte a [ init::$6 ]
reg byte x [ loop::$4 ]
reg byte a [ loop::$20 ]
reg byte a [ loop::$8 ]
reg byte a [ loop::$11 ]
zp[1]:23 [ loop::plexFreeNextYpos1_return#0 plexSort::m#2 plexSort::m#1 ]
reg byte a [ keyboard_key_pressed::return#3 ]
reg byte a [ loop::$18 ]
reg byte a [ keyboard_key_pressed::return#2 ]
reg byte a [ exit::$0 ]
reg byte a [ mulf_init::$1 ]
reg byte a [ mulf_init::$4 ]
reg byte a [ mulf_init::$5 ]
reg byte a [ mulf8u_prepare::a#0 ]
zp[1]:24 [ plexSort::nxt_idx#0 mulf8s_prepared::b#0 ]
reg byte x [ plexSort::s#2 ]
zp[1]:25 [ plexShowSprite::plex_sprite_idx2#0 plexSort::nxt_y#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$1 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$2 ]
reg byte a [ plexShowSprite::xpos_idx#0 ]
reg byte x [ plexShowSprite::$11 ]
reg byte a [ plexShowSprite::$2 ]
reg byte a [ plexShowSprite::$3 ]
reg byte a [ plexShowSprite::$9 ]
reg byte x [ plexShowSprite::$5 ]
reg byte a [ plexShowSprite::$6 ]
reg byte a [ keyboard_matrix_read::return#2 ]
reg byte a [ keyboard_key_pressed::$2 ]
reg byte a [ keyboard_key_pressed::return#0 ]
reg byte a [ mulf8u_prepared::b#0 ]
reg byte a [ mulf8s_prepared::$6 ]
reg byte a [ mulf8s_prepared::$11 ]
reg byte a [ mulf8s_prepared::$9 ]
reg byte a [ mulf8s_prepared::$12 ]
reg byte a [ keyboard_matrix_read::return#0 ]


FINAL ASSEMBLER
Score: 74811

  // File Comments
// Same animation using a multiplexer
// Commodore 64 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__start)
.pc = $80d "Program"
  // Global Constants & labels
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .const KEY_SPACE = $3c
  // The number of BOBs to render
  .const NUM_BOBS = $10
  .const OFFSET_STRUCT_MOS6526_CIA_PORT_B = 1
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label SPRITES_COLOR = $d027
  .label SPRITES_ENABLE = $d015
  .label RASTER = $d012
  .label BORDER_COLOR = $d020
  .label D011 = $d011
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The BASIC screen
  .label SCREEN = $400
  .label COS = SIN+$40
  // The address of the sprite pointers on the current screen (screen+0x3f8).
  .label PLEX_SCREEN_PTR = $11
  // The index in the PLEX tables of the next sprite to show
  .label plex_show_idx = $13
  // The index the next sprite to use for showing (sprites are used round-robin)
  .label plex_sprite_idx = $14
  // The MSB bit of the next sprite to use for showing
  .label plex_sprite_msb = $15
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  .label plex_free_next = $16
  // __start
__start: {
    // __start::__init1
    // PLEX_SCREEN_PTR = 0x400+0x3f8
    // [1] PLEX_SCREEN_PTR = (byte*)$400+$3f8 -- pbuz1=pbuc1 
    lda #<$400+$3f8
    sta.z PLEX_SCREEN_PTR
    lda #>$400+$3f8
    sta.z PLEX_SCREEN_PTR+1
    // plex_show_idx=0
    // [2] plex_show_idx = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // plex_sprite_idx=0
    // [3] plex_sprite_idx = 0 -- vbuz1=vbuc1 
    sta.z plex_sprite_idx
    // plex_sprite_msb=1
    // [4] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // plex_free_next = 0
    // [5] plex_free_next = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    // [6] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
    // __start::@1
    // [7] call main 
    jsr main
    // __start::@return
    // [8] return 
    rts
}
  // main
main: {
    // asm
    // asm { sei  }
    sei
    // init()
    // [10] call init 
    jsr init
    // [11] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // loop()
    // [12] call loop 
    // [41] phi from main::@1 to loop [phi:main::@1->loop]
    jsr loop
    // [13] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // exit()
    // [14] call exit 
    // [91] phi from main::@2 to exit [phi:main::@2->exit]
    jsr exit
    // main::@3
    // asm
    // asm { cli  }
    cli
    // main::@return
    // }
    // [16] return 
    rts
}
  // init
// Initialize the program
init: {
    .label i = 2
    // *D011 = VIC_DEN | VIC_RSEL | 3
    // [17] *D011 = VIC_DEN|VIC_RSEL|3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // plexInit(SCREEN)
    // [18] call plexInit 
  // Initialize the multiplexer
    // [98] phi from init to plexInit [phi:init->plexInit]
    jsr plexInit
    // [19] phi from init to init::@1 [phi:init->init::@1]
    // [19] phi init::i#2 = 0 [phi:init->init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
  // Set the sprite pointers & initial positions
    // [19] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
    // [19] phi init::i#2 = init::i#1 [phi:init::@1->init::@1#0] -- register_copy 
    // init::@1
  __b1:
    // PLEX_PTR[i] = (char)(SPRITE/0x40)
    // [20] PLEX_PTR[init::i#2] = (byte)SPRITE/$40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #$ff&SPRITE/$40
    ldy.z i
    sta PLEX_PTR,y
    // i*5
    // [21] init::$10 = init::i#2 << 2 -- vbuaa=vbuz1_rol_2 
    tya
    asl
    asl
    // [22] init::$3 = init::$10 + init::i#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z i
    // 24+i*5
    // [23] init::$4 = $18 + init::$3 -- vbuxx=vbuc1_plus_vbuaa 
    tax
    axs #-[$18]
    // PLEX_XPOS[i] = 24+i*5
    // [24] init::$9 = init::i#2 << 1 -- vbuaa=vbuz1_rol_1 
    tya
    asl
    // [25] PLEX_XPOS[init::$9] = init::$4 -- pwuc1_derefidx_vbuaa=vbuxx 
    tay
    txa
    sta PLEX_XPOS,y
    lda #0
    sta PLEX_XPOS+1,y
    // i*8
    // [26] init::$5 = init::i#2 << 3 -- vbuaa=vbuz1_rol_3 
    lda.z i
    asl
    asl
    asl
    // 50+i*8
    // [27] init::$6 = $32 + init::$5 -- vbuaa=vbuc1_plus_vbuaa 
    clc
    adc #$32
    // PLEX_YPOS[i] = 50+i*8
    // [28] PLEX_YPOS[init::i#2] = init::$6 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z i
    sta PLEX_YPOS,y
    // for(char i: 0..PLEX_COUNT-1)
    // [29] init::i#1 = ++ init::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [30] if(init::i#1!=PLEX_COUNT-1+1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i
    bne __b1
    // init::@2
    // *SPRITES_ENABLE = 0xff
    // [31] *SPRITES_ENABLE = $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [32] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
    // [32] phi init::i1#2 = 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    // [32] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
    // [32] phi init::i1#2 = init::i1#1 [phi:init::@3->init::@3#0] -- register_copy 
    // init::@3
  __b3:
    // SPRITES_COLOR[i] = GREEN
    // [33] SPRITES_COLOR[init::i1#2] = GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLOR,x
    // for(char i: 0..7)
    // [34] init::i1#1 = ++ init::i1#2 -- vbuxx=_inc_vbuxx 
    inx
    // [35] if(init::i1#1!=8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3
    // [36] phi from init::@3 to init::@4 [phi:init::@3->init::@4]
    // init::@4
    // mulf_init()
    // [37] call mulf_init 
    // [105] phi from init::@4 to mulf_init [phi:init::@4->mulf_init]
    jsr mulf_init
    // [38] phi from init::@4 to init::@5 [phi:init::@4->init::@5]
    // init::@5
    // memset(SCREEN, ' ', 1000)
    // [39] call memset 
  // Clear screen
    // [134] phi from init::@5 to memset [phi:init::@5->memset]
    jsr memset
    // init::@return
    // }
    // [40] return 
    rts
}
  // loop
// The main loop
loop: {
    .label __1 = $f
    .label __2 = $f
    .label __5 = $f
    .label __6 = $f
    .label x = $f
    .label y = $f
    .label a = $a
    .label r = 5
    .label i = 3
    // Render Rotated BOBs
    .label angle = 2
    .label plexFreeNextYpos1_return = $17
    .label i1 = 4
    // [42] phi from loop to loop::@1 [phi:loop->loop::@1]
    // [42] phi loop::angle#6 = 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z angle
    // loop::@1
    // loop::@2
  __b2:
    // while (*RASTER<0xd8)
    // [43] if(*RASTER<$d8) goto loop::@2 -- _deref_pbuc1_lt_vbuc2_then_la1 
    lda RASTER
    cmp #$d8
    bcc __b2
    // loop::@3
    // *BORDER_COLOR = 0xf
    // [44] *BORDER_COLOR = $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta BORDER_COLOR
    // [45] loop::a#6 = loop::angle#6 -- vbuz1=vbuz2 
    lda.z angle
    sta.z a
    // [46] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
    // [46] phi loop::i#2 = 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [46] phi loop::a#2 = loop::a#6 [phi:loop::@3->loop::@4#1] -- register_copy 
    // [46] phi loop::r#2 = $1e [phi:loop::@3->loop::@4#2] -- vbsz1=vbsc1 
    lda #$1e
    sta.z r
    // [46] phi from loop::@12 to loop::@4 [phi:loop::@12->loop::@4]
    // [46] phi loop::i#2 = loop::i#1 [phi:loop::@12->loop::@4#0] -- register_copy 
    // [46] phi loop::a#2 = loop::a#1 [phi:loop::@12->loop::@4#1] -- register_copy 
    // [46] phi loop::r#2 = loop::r#1 [phi:loop::@12->loop::@4#2] -- register_copy 
    // loop::@4
  __b4:
    // *BORDER_COLOR = 6
    // [47] *BORDER_COLOR = 6 -- _deref_pbuc1=vbuc2 
    //kickasm {{ .break }}
    lda #6
    sta BORDER_COLOR
    // mulf8s(r, COS[a])
    // [48] mulf8s::a#0 = loop::r#2 -- vbsaa=vbsz1 
    lda.z r
    // [49] mulf8s::b#0 = COS[loop::a#2] -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy.z a
    ldx COS,y
    // [50] call mulf8s 
    // [140] phi from loop::@4 to mulf8s [phi:loop::@4->mulf8s]
    // [140] phi mulf8s::b#2 = mulf8s::b#0 [phi:loop::@4->mulf8s#0] -- register_copy 
    // [140] phi mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 [phi:loop::@4->mulf8s#1] -- register_copy 
    jsr mulf8s
    // mulf8s(r, COS[a])
    // [51] mulf8s::return#2 = mulf8s::return#0
    // loop::@11
    // [52] loop::$1 = mulf8s::return#2
    // mulf8s(r, COS[a])*2
    // [53] loop::$2 = loop::$1 << 1 -- vwsz1=vwsz1_rol_1 
    asl.z __2
    rol.z __2+1
    // x = mulf8s(r, COS[a])*2 + 125*0x100
    // [54] loop::x#0 = loop::$2 + (signed word)$7d*$100 -- vwsz1=vwsz1_plus_vwsc1 
    clc
    lda.z x
    adc #<$7d*$100
    sta.z x
    lda.z x+1
    adc #>$7d*$100
    sta.z x+1
    // >x
    // [55] loop::$4 = > loop::x#0 -- vbuxx=_hi_vwsz1 
    tax
    // PLEX_XPOS[i] = >x
    // [56] loop::$20 = loop::i#2 << 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [57] PLEX_XPOS[loop::$20] = loop::$4 -- pwuc1_derefidx_vbuaa=vbuxx 
    tay
    txa
    sta PLEX_XPOS,y
    lda #0
    sta PLEX_XPOS+1,y
    // mulf8s(r, SIN[a])
    // [58] mulf8s::a#1 = loop::r#2 -- vbsaa=vbsz1 
    lda.z r
    // [59] mulf8s::b#1 = SIN[loop::a#2] -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy.z a
    ldx SIN,y
    // [60] call mulf8s 
    // [140] phi from loop::@11 to mulf8s [phi:loop::@11->mulf8s]
    // [140] phi mulf8s::b#2 = mulf8s::b#1 [phi:loop::@11->mulf8s#0] -- register_copy 
    // [140] phi mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 [phi:loop::@11->mulf8s#1] -- register_copy 
    jsr mulf8s
    // mulf8s(r, SIN[a])
    // [61] mulf8s::return#3 = mulf8s::return#0
    // loop::@12
    // [62] loop::$5 = mulf8s::return#3
    // mulf8s(r, SIN[a])*2
    // [63] loop::$6 = loop::$5 << 1 -- vwsz1=vwsz1_rol_1 
    asl.z __6
    rol.z __6+1
    // y = mulf8s(r, SIN[a])*2 + 125*0x100
    // [64] loop::y#0 = loop::$6 + (signed word)$7d*$100 -- vwsz1=vwsz1_plus_vwsc1 
    clc
    lda.z y
    adc #<$7d*$100
    sta.z y
    lda.z y+1
    adc #>$7d*$100
    sta.z y+1
    // >y
    // [65] loop::$8 = > loop::y#0 -- vbuaa=_hi_vwsz1 
    // PLEX_YPOS[i] = >y
    // [66] PLEX_YPOS[loop::i#2] = loop::$8 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z i
    sta PLEX_YPOS,y
    // a += 98
    // [67] loop::a#1 = loop::a#2 + $62 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z a
    axs #-[$62]
    stx.z a
    // r += 3
    // [68] loop::r#1 = loop::r#2 + 3 -- vbsz1=vbsz1_plus_vbsc1 
    lax.z r
    axs #-[3]
    stx.z r
    // for(char i: 0..NUM_BOBS-1)
    // [69] loop::i#1 = ++ loop::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [70] if(loop::i#1!=NUM_BOBS-1+1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #NUM_BOBS-1+1
    cmp.z i
    bne __b4
    // loop::@5
    // *BORDER_COLOR = 3
    // [71] *BORDER_COLOR = 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta BORDER_COLOR
    // plexSort()
    // [72] call plexSort 
    // [147] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
    jsr plexSort
    // loop::@13
    // angle += 3
    // [73] loop::angle#1 = loop::angle#6 + 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z angle
    axs #-[3]
    stx.z angle
    // *BORDER_COLOR = BLACK
    // [74] *BORDER_COLOR = BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDER_COLOR
  // Sort the sprites by y-position
    // loop::@6
  __b6:
    // *D011&VIC_RST8
    // [75] loop::$11 = *D011 & VIC_RST8 -- vbuaa=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
    // while((*D011&VIC_RST8)!=0)
    // [76] if(loop::$11!=0) goto loop::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b6
    // [77] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
    // [77] phi loop::i1#5 = 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i1
  // Show the sprites
    // [77] phi from loop::@14 to loop::@7 [phi:loop::@14->loop::@7]
    // [77] phi loop::i1#5 = loop::i1#1 [phi:loop::@14->loop::@7#0] -- register_copy 
    // loop::@7
  __b7:
    // *BORDER_COLOR = BLACK
    // [78] *BORDER_COLOR = BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDER_COLOR
    // loop::plexFreeNextYpos1
    // return PLEX_FREE_YPOS[plex_free_next];
    // [79] loop::plexFreeNextYpos1_return#0 = PLEX_FREE_YPOS[plex_free_next] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_free_next
    lda PLEX_FREE_YPOS,y
    sta.z plexFreeNextYpos1_return
    // loop::@8
  __b8:
    // while(*RASTER<rasterY)
    // [80] if(*RASTER<loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z plexFreeNextYpos1_return
    bcc __b8
    // loop::@9
    // (*BORDER_COLOR)++;
    // [81] *BORDER_COLOR = ++ *BORDER_COLOR -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDER_COLOR
    // plexShowSprite()
    // [82] call plexShowSprite 
    jsr plexShowSprite
    // loop::@14
    // for( char i: 0..PLEX_COUNT-1)
    // [83] loop::i1#1 = ++ loop::i1#5 -- vbuz1=_inc_vbuz1 
    inc.z i1
    // [84] if(loop::i1#1!=PLEX_COUNT-1+1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i1
    bne __b7
    // loop::@10
    // *BORDER_COLOR = BLACK
    // [85] *BORDER_COLOR = BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDER_COLOR
    // keyboard_key_pressed(KEY_SPACE)
    // [86] call keyboard_key_pressed 
    // [198] phi from loop::@10 to keyboard_key_pressed [phi:loop::@10->keyboard_key_pressed]
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_SPACE)
    // [87] keyboard_key_pressed::return#3 = keyboard_key_pressed::return#0
    // loop::@15
    // [88] loop::$18 = keyboard_key_pressed::return#3
    // if(keyboard_key_pressed(KEY_SPACE))
    // [89] if(0!=loop::$18) goto loop::@return -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __breturn
    // [42] phi from loop::@15 to loop::@1 [phi:loop::@15->loop::@1]
    // [42] phi loop::angle#6 = loop::angle#1 [phi:loop::@15->loop::@1#0] -- register_copy 
    jmp __b2
    // loop::@return
  __breturn:
    // }
    // [90] return 
    rts
}
  // exit
// Exit the program
exit: {
    // [92] phi from exit exit::@2 to exit::@1 [phi:exit/exit::@2->exit::@1]
  __b1:
  // Wait for space release
    // exit::@1
    // keyboard_key_pressed(KEY_SPACE)
    // [93] call keyboard_key_pressed 
    // [198] phi from exit::@1 to keyboard_key_pressed [phi:exit::@1->keyboard_key_pressed]
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_SPACE)
    // [94] keyboard_key_pressed::return#2 = keyboard_key_pressed::return#0
    // exit::@2
    // [95] exit::$0 = keyboard_key_pressed::return#2
    // while(keyboard_key_pressed(KEY_SPACE))
    // [96] if(0!=exit::$0) goto exit::@1 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b1
    // exit::@return
    // }
    // [97] return 
    rts
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    // plexInit::plexSetScreen1
    // PLEX_SCREEN_PTR = screen+0x3f8
    // [99] PLEX_SCREEN_PTR = SCREEN+$3f8 -- pbuz1=pbuc1 
    lda #<SCREEN+$3f8
    sta.z PLEX_SCREEN_PTR
    lda #>SCREEN+$3f8
    sta.z PLEX_SCREEN_PTR+1
    // [100] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
    // [100] phi plexInit::i#2 = 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [100] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
    // [100] phi plexInit::i#2 = plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    // plexInit::@1
  __b1:
    // PLEX_SORTED_IDX[i] = i
    // [101] PLEX_SORTED_IDX[plexInit::i#2] = plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // for(char i: 0..PLEX_COUNT-1)
    // [102] plexInit::i#1 = ++ plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [103] if(plexInit::i#1!=PLEX_COUNT-1+1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1
    // plexInit::@return
    // }
    // [104] return 
    rts
}
  // mulf_init
// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/4)
mulf_init: {
    // x/2
    .label c = 5
    // Counter used for determining x%2==0
    .label sqr1_hi = $f
    // Fill mulf_sqr1 = f(x) = int(x*x/4): If f(x) = x*x/4 then f(x+1) = f(x) + x/2 + 1/4
    .label sqr = $b
    .label sqr1_lo = $d
    // Decrease or increase x_255 - initially we decrease
    .label sqr2_hi = 8
    .label sqr2_lo = 6
    //Start with g(0)=f(255)
    .label dir = $a
    // [106] phi from mulf_init to mulf_init::@1 [phi:mulf_init->mulf_init::@1]
    // [106] phi mulf_init::x_2#3 = 0 [phi:mulf_init->mulf_init::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [106] phi mulf_init::sqr1_hi#2 = mulf_sqr1_hi+1 [phi:mulf_init->mulf_init::@1#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_hi+1
    sta.z sqr1_hi
    lda #>mulf_sqr1_hi+1
    sta.z sqr1_hi+1
    // [106] phi mulf_init::sqr#4 = 0 [phi:mulf_init->mulf_init::@1#2] -- vwuz1=vwuc1 
    txa
    sta.z sqr
    sta.z sqr+1
    // [106] phi mulf_init::c#2 = 0 [phi:mulf_init->mulf_init::@1#3] -- vbuz1=vbuc1 
    sta.z c
    // [106] phi mulf_init::sqr1_lo#2 = mulf_sqr1_lo+1 [phi:mulf_init->mulf_init::@1#4] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_lo+1
    sta.z sqr1_lo
    lda #>mulf_sqr1_lo+1
    sta.z sqr1_lo+1
    // mulf_init::@1
  __b1:
    // for(char* sqr1_lo = mulf_sqr1_lo+1; sqr1_lo!=mulf_sqr1_lo+512; sqr1_lo++)
    // [107] if(mulf_init::sqr1_lo#2!=mulf_sqr1_lo+$200) goto mulf_init::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr1_lo+1
    cmp #>mulf_sqr1_lo+$200
    bne __b2
    lda.z sqr1_lo
    cmp #<mulf_sqr1_lo+$200
    bne __b2
    // [108] phi from mulf_init::@1 to mulf_init::@5 [phi:mulf_init::@1->mulf_init::@5]
    // [108] phi mulf_init::dir#2 = $ff [phi:mulf_init::@1->mulf_init::@5#0] -- vbuz1=vbuc1 
    lda #$ff
    sta.z dir
    // [108] phi mulf_init::sqr2_hi#2 = mulf_sqr2_hi [phi:mulf_init::@1->mulf_init::@5#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_hi
    sta.z sqr2_hi
    lda #>mulf_sqr2_hi
    sta.z sqr2_hi+1
    // [108] phi mulf_init::x_255#2 = -1 [phi:mulf_init::@1->mulf_init::@5#2] -- vbuxx=vbuc1 
    ldx #-1
    // [108] phi mulf_init::sqr2_lo#2 = mulf_sqr2_lo [phi:mulf_init::@1->mulf_init::@5#3] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_lo
    sta.z sqr2_lo
    lda #>mulf_sqr2_lo
    sta.z sqr2_lo+1
    // mulf_init::@5
  __b5:
    // for(char* sqr2_lo = mulf_sqr2_lo; sqr2_lo!=mulf_sqr2_lo+511; sqr2_lo++)
    // [109] if(mulf_init::sqr2_lo#2!=mulf_sqr2_lo+$1ff) goto mulf_init::@6 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr2_lo+1
    cmp #>mulf_sqr2_lo+$1ff
    bne __b6
    lda.z sqr2_lo
    cmp #<mulf_sqr2_lo+$1ff
    bne __b6
    // mulf_init::@7
    // *(mulf_sqr2_lo+511) = *(mulf_sqr1_lo+256)
    // [110] *(mulf_sqr2_lo+$1ff) = *(mulf_sqr1_lo+$100) -- _deref_pbuc1=_deref_pbuc2 
    // Set the very last value g(511) = f(256)
    lda mulf_sqr1_lo+$100
    sta mulf_sqr2_lo+$1ff
    // *(mulf_sqr2_hi+511) = *(mulf_sqr1_hi+256)
    // [111] *(mulf_sqr2_hi+$1ff) = *(mulf_sqr1_hi+$100) -- _deref_pbuc1=_deref_pbuc2 
    lda mulf_sqr1_hi+$100
    sta mulf_sqr2_hi+$1ff
    // mulf_init::@return
    // }
    // [112] return 
    rts
    // mulf_init::@6
  __b6:
    // *sqr2_lo = mulf_sqr1_lo[x_255]
    // [113] *mulf_init::sqr2_lo#2 = mulf_sqr1_lo[mulf_init::x_255#2] -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_lo,x
    ldy #0
    sta (sqr2_lo),y
    // *sqr2_hi++ = mulf_sqr1_hi[x_255]
    // [114] *mulf_init::sqr2_hi#2 = mulf_sqr1_hi[mulf_init::x_255#2] -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_hi,x
    sta (sqr2_hi),y
    // *sqr2_hi++ = mulf_sqr1_hi[x_255];
    // [115] mulf_init::sqr2_hi#1 = ++ mulf_init::sqr2_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_hi
    bne !+
    inc.z sqr2_hi+1
  !:
    // x_255 = x_255 + dir
    // [116] mulf_init::x_255#1 = mulf_init::x_255#2 + mulf_init::dir#2 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc.z dir
    tax
    // if(x_255==0)
    // [117] if(mulf_init::x_255#1!=0) goto mulf_init::@9 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b8
    // [119] phi from mulf_init::@6 to mulf_init::@8 [phi:mulf_init::@6->mulf_init::@8]
    // [119] phi mulf_init::dir#4 = 1 [phi:mulf_init::@6->mulf_init::@8#0] -- vbuz1=vbuc1 
    lda #1
    sta.z dir
    // [118] phi from mulf_init::@6 to mulf_init::@9 [phi:mulf_init::@6->mulf_init::@9]
    // mulf_init::@9
    // [119] phi from mulf_init::@9 to mulf_init::@8 [phi:mulf_init::@9->mulf_init::@8]
    // [119] phi mulf_init::dir#4 = mulf_init::dir#2 [phi:mulf_init::@9->mulf_init::@8#0] -- register_copy 
    // mulf_init::@8
  __b8:
    // for(char* sqr2_lo = mulf_sqr2_lo; sqr2_lo!=mulf_sqr2_lo+511; sqr2_lo++)
    // [120] mulf_init::sqr2_lo#1 = ++ mulf_init::sqr2_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_lo
    bne !+
    inc.z sqr2_lo+1
  !:
    // [108] phi from mulf_init::@8 to mulf_init::@5 [phi:mulf_init::@8->mulf_init::@5]
    // [108] phi mulf_init::dir#2 = mulf_init::dir#4 [phi:mulf_init::@8->mulf_init::@5#0] -- register_copy 
    // [108] phi mulf_init::sqr2_hi#2 = mulf_init::sqr2_hi#1 [phi:mulf_init::@8->mulf_init::@5#1] -- register_copy 
    // [108] phi mulf_init::x_255#2 = mulf_init::x_255#1 [phi:mulf_init::@8->mulf_init::@5#2] -- register_copy 
    // [108] phi mulf_init::sqr2_lo#2 = mulf_init::sqr2_lo#1 [phi:mulf_init::@8->mulf_init::@5#3] -- register_copy 
    jmp __b5
    // mulf_init::@2
  __b2:
    // if((++c&1)==0)
    // [121] mulf_init::c#1 = ++ mulf_init::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // ++c&1
    // [122] mulf_init::$1 = mulf_init::c#1 & 1 -- vbuaa=vbuz1_band_vbuc1 
    lda #1
    and.z c
    // if((++c&1)==0)
    // [123] if(mulf_init::$1!=0) goto mulf_init::@3 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b3
    // mulf_init::@4
    // x_2++;
    // [124] mulf_init::x_2#1 = ++ mulf_init::x_2#3 -- vbuxx=_inc_vbuxx 
    inx
    // sqr++;
    // [125] mulf_init::sqr#2 = ++ mulf_init::sqr#4 -- vwuz1=_inc_vwuz1 
    inc.z sqr
    bne !+
    inc.z sqr+1
  !:
    // [126] phi from mulf_init::@2 mulf_init::@4 to mulf_init::@3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3]
    // [126] phi mulf_init::x_2#2 = mulf_init::x_2#3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#0] -- register_copy 
    // [126] phi mulf_init::sqr#3 = mulf_init::sqr#4 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#1] -- register_copy 
    // mulf_init::@3
  __b3:
    // <sqr
    // [127] mulf_init::$4 = < mulf_init::sqr#3 -- vbuaa=_lo_vwuz1 
    lda.z sqr
    // *sqr1_lo = <sqr
    // [128] *mulf_init::sqr1_lo#2 = mulf_init::$4 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sqr1_lo),y
    // >sqr
    // [129] mulf_init::$5 = > mulf_init::sqr#3 -- vbuaa=_hi_vwuz1 
    lda.z sqr+1
    // *sqr1_hi++ = >sqr
    // [130] *mulf_init::sqr1_hi#2 = mulf_init::$5 -- _deref_pbuz1=vbuaa 
    sta (sqr1_hi),y
    // *sqr1_hi++ = >sqr;
    // [131] mulf_init::sqr1_hi#1 = ++ mulf_init::sqr1_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_hi
    bne !+
    inc.z sqr1_hi+1
  !:
    // sqr = sqr + x_2
    // [132] mulf_init::sqr#1 = mulf_init::sqr#3 + mulf_init::x_2#2 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z sqr
    sta.z sqr
    bcc !+
    inc.z sqr+1
  !:
    // for(char* sqr1_lo = mulf_sqr1_lo+1; sqr1_lo!=mulf_sqr1_lo+512; sqr1_lo++)
    // [133] mulf_init::sqr1_lo#1 = ++ mulf_init::sqr1_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_lo
    bne !+
    inc.z sqr1_lo+1
  !:
    // [106] phi from mulf_init::@3 to mulf_init::@1 [phi:mulf_init::@3->mulf_init::@1]
    // [106] phi mulf_init::x_2#3 = mulf_init::x_2#2 [phi:mulf_init::@3->mulf_init::@1#0] -- register_copy 
    // [106] phi mulf_init::sqr1_hi#2 = mulf_init::sqr1_hi#1 [phi:mulf_init::@3->mulf_init::@1#1] -- register_copy 
    // [106] phi mulf_init::sqr#4 = mulf_init::sqr#1 [phi:mulf_init::@3->mulf_init::@1#2] -- register_copy 
    // [106] phi mulf_init::c#2 = mulf_init::c#1 [phi:mulf_init::@3->mulf_init::@1#3] -- register_copy 
    // [106] phi mulf_init::sqr1_lo#2 = mulf_init::sqr1_lo#1 [phi:mulf_init::@3->mulf_init::@1#4] -- register_copy 
    jmp __b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const c = ' '
    .const num = $3e8
    .label str = SCREEN
    .label end = str+num
    .label dst = $d
    // [135] phi from memset to memset::@1 [phi:memset->memset::@1]
    // [135] phi memset::dst#2 = (byte*)memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    // memset::@1
  __b1:
    // for(char* dst = str; dst!=end; dst++)
    // [136] if(memset::dst#2!=memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    // memset::@return
    // }
    // [137] return 
    rts
    // memset::@2
  __b2:
    // *dst = c
    // [138] *memset::dst#2 = memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [139] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [135] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
    // [135] phi memset::dst#2 = memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // mulf8s
// Fast multiply two signed chars to a unsigned int result
// mulf8s(signed byte register(A) a, signed byte register(X) b)
mulf8s: {
    .label return = $f
    // mulf8s::mulf8s_prepare1
    // mulf8u_prepare((char)a)
    // [141] mulf8u_prepare::a#0 = (byte)mulf8s::mulf8s_prepare1_a#0
    // [142] call mulf8u_prepare 
    jsr mulf8u_prepare
    // mulf8s::@1
    // mulf8s_prepared(b)
    // [143] mulf8s_prepared::b#0 = mulf8s::b#2 -- vbsz1=vbsxx 
    stx.z mulf8s_prepared.b
    // [144] call mulf8s_prepared 
    jsr mulf8s_prepared
    // mulf8s::@2
    // [145] mulf8s::return#0 = (signed word)mulf8s_prepared::m#4
    // mulf8s::@return
    // }
    // [146] return 
    rts
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $18
    .label nxt_y = $19
    .label m = $17
    // [148] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
    // [148] phi plexSort::m#2 = 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    // [148] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
    // [148] phi plexSort::m#2 = plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    // plexSort::@1
  __b1:
    // nxt_idx = PLEX_SORTED_IDX[m+1]
    // [149] plexSort::nxt_idx#0 = (PLEX_SORTED_IDX+1)[plexSort::m#2] -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // nxt_y = PLEX_YPOS[nxt_idx]
    // [150] plexSort::nxt_y#0 = PLEX_YPOS[plexSort::nxt_idx#0] -- vbuz1=pbuc1_derefidx_vbuz2 
    tay
    lda PLEX_YPOS,y
    sta.z nxt_y
    // if(nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[m]])
    // [151] if(plexSort::nxt_y#0>=PLEX_YPOS[PLEX_SORTED_IDX[plexSort::m#2]]) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    // plexSort::@5
    // [152] plexSort::s#6 = plexSort::m#2 -- vbuxx=vbuz1 
    // [153] phi from plexSort::@5 plexSort::@7 to plexSort::@3 [phi:plexSort::@5/plexSort::@7->plexSort::@3]
    // [153] phi plexSort::s#3 = plexSort::s#6 [phi:plexSort::@5/plexSort::@7->plexSort::@3#0] -- register_copy 
    // plexSort::@3
  __b3:
    // PLEX_SORTED_IDX[s+1] = PLEX_SORTED_IDX[s]
    // [154] (PLEX_SORTED_IDX+1)[plexSort::s#3] = PLEX_SORTED_IDX[plexSort::s#3] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // s--;
    // [155] plexSort::s#1 = -- plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // while((s!=0xff) && (nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[s]]))
    // [156] if(plexSort::s#1==$ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq __b4
    // plexSort::@7
    // [157] if(plexSort::nxt_y#0<PLEX_YPOS[PLEX_SORTED_IDX[plexSort::s#1]]) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3
    // plexSort::@4
  __b4:
    // s++;
    // [158] plexSort::s#2 = ++ plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // PLEX_SORTED_IDX[s] = nxt_idx
    // [159] PLEX_SORTED_IDX[plexSort::s#2] = plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    // plexSort::@2
  __b2:
    // for(char m: 0..PLEX_COUNT-2)
    // [160] plexSort::m#1 = ++ plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [161] if(plexSort::m#1!=PLEX_COUNT-2+1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1
    // plexSort::@6
    // plex_show_idx = 0
    // [162] plex_show_idx = 0 -- vbuz1=vbuc1 
    // Prepare for showing the sprites
    lda #0
    sta.z plex_show_idx
    // plex_sprite_idx = 0
    // [163] plex_sprite_idx = 0 -- vbuz1=vbuc1 
    sta.z plex_sprite_idx
    // plex_sprite_msb = 1
    // [164] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [165] phi from plexSort::@6 to plexSort::plexFreePrepare1 [phi:plexSort::@6->plexSort::plexFreePrepare1]
    // plexSort::plexFreePrepare1
    // [166] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
    // [166] phi plexSort::plexFreePrepare1_s#2 = 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [166] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
    // [166] phi plexSort::plexFreePrepare1_s#2 = plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // PLEX_FREE_YPOS[s] = 0
    // [167] PLEX_FREE_YPOS[plexSort::plexFreePrepare1_s#2] = 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // for( char s: 0..7)
    // [168] plexSort::plexFreePrepare1_s#1 = ++ plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [169] if(plexSort::plexFreePrepare1_s#1!=8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1___b1
    // plexSort::plexFreePrepare1_@2
    // plex_free_next = 0
    // [170] plex_free_next = 0 -- vbuz1=vbuc1 
    sta.z plex_free_next
    // plexSort::@return
    // }
    // [171] return 
    rts
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = $19
    // plex_sprite_idx2 = plex_sprite_idx*2
    // [172] plexShowSprite::plex_sprite_idx2#0 = plex_sprite_idx << 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // ypos = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]]
    // [173] plexShowSprite::plexFreeAdd1_ypos#0 = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]] -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // SPRITES_YPOS[plex_sprite_idx2] = ypos
    // [174] SPRITES_YPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    // plexShowSprite::plexFreeAdd1
    // ypos+21
    // [175] plexShowSprite::plexFreeAdd1_$0 = plexShowSprite::plexFreeAdd1_ypos#0 + $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
    // PLEX_FREE_YPOS[plex_free_next] =  ypos+21
    // [176] PLEX_FREE_YPOS[plex_free_next] = plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // plex_free_next+1
    // [177] plexShowSprite::plexFreeAdd1_$1 = plex_free_next + 1 -- vbuaa=vbuz1_plus_1 
    tya
    clc
    adc #1
    // (plex_free_next+1)&7
    // [178] plexShowSprite::plexFreeAdd1_$2 = plexShowSprite::plexFreeAdd1_$1 & 7 -- vbuaa=vbuaa_band_vbuc1 
    and #7
    // plex_free_next = (plex_free_next+1)&7
    // [179] plex_free_next = plexShowSprite::plexFreeAdd1_$2 -- vbuz1=vbuaa 
    sta.z plex_free_next
    // plexShowSprite::@5
    // PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]]
    // [180] PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]] -- pbuz1_derefidx_vbuz2=pbuc1_derefidx_(pbuc2_derefidx_vbuz3) 
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldy.z plex_sprite_idx
    sta (PLEX_SCREEN_PTR),y
    // xpos_idx = PLEX_SORTED_IDX[plex_show_idx]
    // [181] plexShowSprite::xpos_idx#0 = PLEX_SORTED_IDX[plex_show_idx] -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // <PLEX_XPOS[xpos_idx]
    // [182] plexShowSprite::$11 = plexShowSprite::xpos_idx#0 << 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [183] plexShowSprite::$2 = < PLEX_XPOS[plexShowSprite::$11] -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
    // SPRITES_XPOS[plex_sprite_idx2] = <PLEX_XPOS[xpos_idx]
    // [184] SPRITES_XPOS[plexShowSprite::plex_sprite_idx2#0] = plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // >PLEX_XPOS[xpos_idx]
    // [185] plexShowSprite::$3 = > PLEX_XPOS[plexShowSprite::$11] -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // if(>PLEX_XPOS[xpos_idx]!=0)
    // [186] if(plexShowSprite::$3!=0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b1
    // plexShowSprite::@3
    // 0xff^plex_sprite_msb
    // [187] plexShowSprite::$9 = $ff ^ plex_sprite_msb -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // *SPRITES_XMSB &= (0xff^plex_sprite_msb)
    // [188] *SPRITES_XMSB = *SPRITES_XMSB & plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    // plexShowSprite::@2
  __b2:
    // plex_sprite_idx+1
    // [189] plexShowSprite::$5 = plex_sprite_idx + 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // (plex_sprite_idx+1)&7
    // [190] plexShowSprite::$6 = plexShowSprite::$5 & 7 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #7
    // plex_sprite_idx = (plex_sprite_idx+1)&7
    // [191] plex_sprite_idx = plexShowSprite::$6 -- vbuz1=vbuaa 
    sta.z plex_sprite_idx
    // plex_show_idx++;
    // [192] plex_show_idx = ++ plex_show_idx -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // plex_sprite_msb <<=1
    // [193] plex_sprite_msb = plex_sprite_msb << 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // if(plex_sprite_msb==0)
    // [194] if(plex_sprite_msb!=0) goto plexShowSprite::@return -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne __breturn
    // plexShowSprite::@4
    // plex_sprite_msb = 1
    // [195] plex_sprite_msb = 1 -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // plexShowSprite::@return
  __breturn:
    // }
    // [196] return 
    rts
    // plexShowSprite::@1
  __b1:
    // *SPRITES_XMSB |= plex_sprite_msb
    // [197] *SPRITES_XMSB = *SPRITES_XMSB | plex_sprite_msb -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
keyboard_key_pressed: {
    .const colidx = KEY_SPACE&7
    .label rowidx = KEY_SPACE>>3
    // keyboard_matrix_read(rowidx)
    // [199] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [200] keyboard_matrix_read::return#2 = keyboard_matrix_read::return#0
    // keyboard_key_pressed::@1
    // [201] keyboard_key_pressed::$2 = keyboard_matrix_read::return#2
    // keyboard_matrix_read(rowidx) & keyboard_matrix_col_bitmask[colidx]
    // [202] keyboard_key_pressed::return#0 = keyboard_key_pressed::$2 & *(keyboard_matrix_col_bitmask+keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band__deref_pbuc1 
    and keyboard_matrix_col_bitmask+colidx
    // keyboard_key_pressed::@return
    // }
    // [203] return 
    rts
}
  // mulf8u_prepare
// Prepare for fast multiply with an unsigned char to a unsigned int result
// mulf8u_prepare(byte register(A) a)
mulf8u_prepare: {
    .label memA = $fd
    // *memA = a
    // [204] *mulf8u_prepare::memA = mulf8u_prepare::a#0 -- _deref_pbuc1=vbuaa 
    sta memA
    // asm
    // asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
    sta mulf8u_prepared.sm1+1
    sta mulf8u_prepared.sm3+1
    eor #$ff
    sta mulf8u_prepared.sm2+1
    sta mulf8u_prepared.sm4+1
    // mulf8u_prepare::@return
    // }
    // [206] return 
    rts
}
  // mulf8s_prepared
// Calculate fast multiply with a prepared unsigned char to a unsigned int result
// The prepared number is set by calling mulf8s_prepare(char a)
// mulf8s_prepared(signed byte zp($18) b)
mulf8s_prepared: {
    .label memA = $fd
    .label m = $f
    .label b = $18
    // mulf8u_prepared((char) b)
    // [207] mulf8u_prepared::b#0 = (byte)mulf8s_prepared::b#0 -- vbuaa=vbuz1 
    lda.z b
    // [208] call mulf8u_prepared 
    jsr mulf8u_prepared
    // [209] mulf8u_prepared::return#2 = mulf8u_prepared::return#0
    // mulf8s_prepared::@5
    // m = mulf8u_prepared((char) b)
    // [210] mulf8s_prepared::m#0 = mulf8u_prepared::return#2
    // if(*memA<0)
    // [211] if(*mulf8s_prepared::memA>=0) goto mulf8s_prepared::@1 -- _deref_pbsc1_ge_0_then_la1 
    lda memA
    cmp #0
    bpl __b1
    // mulf8s_prepared::@3
    // >m
    // [212] mulf8s_prepared::$6 = > mulf8s_prepared::m#0 -- vbuaa=_hi_vwuz1 
    lda.z m+1
    // >m = (>m)-(char)b
    // [213] mulf8s_prepared::$11 = mulf8s_prepared::$6 - (byte)mulf8s_prepared::b#0 -- vbuaa=vbuaa_minus_vbuz1 
    sec
    sbc.z b
    // [214] mulf8s_prepared::m#1 = mulf8s_prepared::m#0 hi= mulf8s_prepared::$11 -- vwuz1=vwuz1_sethi_vbuaa 
    sta.z m+1
    // [215] phi from mulf8s_prepared::@3 mulf8s_prepared::@5 to mulf8s_prepared::@1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1]
    // [215] phi mulf8s_prepared::m#5 = mulf8s_prepared::m#1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1#0] -- register_copy 
    // mulf8s_prepared::@1
  __b1:
    // if(b<0)
    // [216] if(mulf8s_prepared::b#0>=0) goto mulf8s_prepared::@2 -- vbsz1_ge_0_then_la1 
    lda.z b
    cmp #0
    bpl __b2
    // mulf8s_prepared::@4
    // >m
    // [217] mulf8s_prepared::$9 = > mulf8s_prepared::m#5 -- vbuaa=_hi_vwuz1 
    lda.z m+1
    // >m = (>m)-(char)*memA
    // [218] mulf8s_prepared::$12 = mulf8s_prepared::$9 - (byte)*mulf8s_prepared::memA -- vbuaa=vbuaa_minus__deref_pbuc1 
    sec
    sbc memA
    // [219] mulf8s_prepared::m#2 = mulf8s_prepared::m#5 hi= mulf8s_prepared::$12 -- vwuz1=vwuz1_sethi_vbuaa 
    sta.z m+1
    // [220] phi from mulf8s_prepared::@1 mulf8s_prepared::@4 to mulf8s_prepared::@2 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2]
    // [220] phi mulf8s_prepared::m#4 = mulf8s_prepared::m#5 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2#0] -- register_copy 
    // mulf8s_prepared::@2
  __b2:
    // mulf8s_prepared::@return
    // }
    // [221] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable the normal interrupt or sei/cli around calls to the keyboard matrix reader.
keyboard_matrix_read: {
    // CIA1->PORT_A = keyboard_matrix_row_bitmask[rowid]
    // [222] *((byte*)CIA1) = *(keyboard_matrix_row_bitmask+keyboard_key_pressed::rowidx#0) -- _deref_pbuc1=_deref_pbuc2 
    lda keyboard_matrix_row_bitmask+keyboard_key_pressed.rowidx
    sta CIA1
    // ~CIA1->PORT_B
    // [223] keyboard_matrix_read::return#0 = ~ *((byte*)CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1+OFFSET_STRUCT_MOS6526_CIA_PORT_B
    eor #$ff
    // keyboard_matrix_read::@return
    // }
    // [224] return 
    rts
}
  // mulf8u_prepared
// Calculate fast multiply with a prepared unsigned char to a unsigned int result
// The prepared number is set by calling mulf8u_prepare(char a)
// mulf8u_prepared(byte register(A) b)
mulf8u_prepared: {
    .label resL = $fe
    .label memB = $ff
    .label return = $f
    // *memB = b
    // [225] *mulf8u_prepared::memB = mulf8u_prepared::b#0 -- _deref_pbuc1=vbuaa 
    sta memB
    // asm
    // asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
    tax
    sec
  sm1:
    lda mulf_sqr1_lo,x
  sm2:
    sbc mulf_sqr2_lo,x
    sta resL
  sm3:
    lda mulf_sqr1_hi,x
  sm4:
    sbc mulf_sqr2_hi,x
    sta memB
    // return { *memB, *resL };
    // [227] mulf8u_prepared::return#0 = *mulf8u_prepared::memB w= *mulf8u_prepared::resL -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda resL
    sta.z return
    lda memB
    sta.z return+1
    // mulf8u_prepared::@return
    // }
    // [228] return 
    rts
}
  // File Data
  // The x-positions of the multiplexer sprites (0x000-0x1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // mulf_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
  // <f(x) = <(( x * x )/4)
  .align $100
  mulf_sqr1_lo: .fill $200, 0
  // >f(x) = >(( x * x )/4)
  .align $100
  mulf_sqr1_hi: .fill $200, 0
  // <g(x) =  <((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_lo: .fill $200, 0
  // >g(x) = >((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_hi: .fill $200, 0
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80
  // The BOB sprite
  .align $1000
SPRITE:
.var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)

  // Sine and Cosine tables
  // Angles: $00=0, $80=PI,$100=2*PI
  // Sine/Cosine: signed fixed [-$7f,$7f]
  .align $40
SIN:
.for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))


