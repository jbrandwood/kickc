// Interactive Explorer for C64DTV Screen Modes
import "c64dtv.kc"
import "print.kc"
import "keyboard.kc"

void main() {
    asm { sei }  // Disable normal interrupt (prevent keyboard reading glitches)
    *DTV_FEATURE = DTV_FEATURE_ENABLE;
    while(true) {
        menu();
    }
}

byte[] MENU_COLS =
     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@" +
     " nnnnnnn  mmmmmmmm  mmmmmmmm  ooooooooo @" +
     " nnnnnnn  mmmmmmmm  mmmmmmmm  ooooooooo @" +
     " nnnnnnn  mmmmmmmm  mmmmmmmm  ooooooooo @" +
     " nnnnnnn  mmmmmmmm  mmmmmmmm  ooooooooo @" +
     " nnnnnnn  mmmmmmmm  mmmmmmmm  ooooooooo @" +
     " nnnnnnn                      ooooooooo @" +
     " nnnnnnn  nnnnnnnn            ooooooooo @" +
     " nnnnnnn  nnnnnnnn            ooooooooo @" +
     "@" ;
byte[] MENU_TEXT =
     " DTV GfxExplorer MODE 0 8bpp pixel cell @" +
     " CONTROL  PLANE  A  PLANE  B  VIC II    @" +
     " bmm   0  patt  p0  patt  p0  screen s0 @" +
     " mcm   0  start 00  start 00  gfx    g0 @" +
     " ecm   0  step  00  step  00  colors c0 @" +
     " hicol 0  mod   00  mod   00  bgcol0 00 @" +
     " line  0                      bgcol1 00 @" +
     " colof 0  borof  0            bgcol2 00 @" +
     " chunk 0  overs  0            bgcol3 00 @" +
     "@" ;

void menu() {
    const byte* SCREEN = $8000;
    const byte* CHARSET = $9800; // Charset ROM
    // DTV Graphics Bank
    *DTV_GRAPHICS_VIC_BANK = (byte)((dword)CHARSET/$10000);
    // DTV Color Bank
     *DTV_COLOR_BANK_LO = <((word)(DTV_COLOR_BANK_DEFAULT/$400));
     *DTV_COLOR_BANK_HI = >((word)(DTV_COLOR_BANK_DEFAULT/$400));
    // DTV Graphics Mode
    *DTV_CONTROL = 0;
    // VIC Graphics Bank
    *CIA2_PORT_A_DDR = %00000011; // Set VIC Bank bits to output - all others to input
    *CIA2_PORT_A = %00000011 ^ (byte)((word)CHARSET/$4000); // Set VIC Bank
    // VIC Graphics Mode
    *VIC_CONTROL = VIC_DEN|VIC_RSEL|3;
    *VIC_CONTROL2 = VIC_CSEL;
    // VIC Memory Pointers
    *VIC_MEMORY =  (byte)((((word)SCREEN&$3fff)/$40)|(((word)CHARSET&$3fff)/$400));
    // DTV Palette - default
    for(byte i : 0..$f) {
        DTV_PALETTE[i] = DTV_PALETTE_DEFAULT[i];
    }
    // Screen colors
    *BGCOL = 0;
    *BORDERCOL = 0;
    // Menu Colors
    print_set_screen(COLS);
    print_cls();
    print_str_lines(MENU_COLS);
    // Menu Text
    print_set_screen(SCREEN);
    print_cls();
    print_str_lines(MENU_TEXT);
    form_set_screen(SCREEN);
    form_render_values();
   // Allow user to control the form
    while(true) {
        while(*RASTER!=$ff) {}
        form_control();
    }
}


// Table with addresses of the y-lines of the form. The first line contains the address of the form screen.
byte[25] form_line_lo;
byte[25] form_line_hi;
// Current selected field in the form
byte form_field_idx = 0;
// Number of form fields
byte form_fields_cnt = 35;
// Form fields x/y-positions
byte[] form_fields_x   = {  22, 7,  7,  7,  7,  7,  7,  7, 17, 17, 17, 16, 17, 16, 17, 16, 17, 27, 26, 27, 26, 27, 26, 27, 38, 38, 38, 37, 38, 37, 38, 37, 38, 37, 38 };
byte[] form_fields_y   = {  0,  2,  3,  4,  5,  6,  7,  8,  7,  8,  2,  3,  3,  4,  4,  5,  5,  2,  3,  3,  4,  4,  5,  5,  2,  3,  4,  5,  5,  6,  6,  7,  7,  8,  8 };
// Form field max values (all values are in the interval 0..max)
byte[] form_fields_max = { $d,  1,  1,  1,  1,  1,  2,  1,  1,  1, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f, $f };
// Form fields values
byte[] form_fields_val = {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 };

// The number of frames to use for a full blink cycle
const signed byte FORM_CURSOR_BLINK = 40;
// Counts down to blink for form cursor (it is inversed in the lower half)
signed byte form_cursor_count = FORM_CURSOR_BLINK/2;

// Set the screen to use for the form.
// screen is the start address of the screen to use
void form_set_screen(byte* screen) {
    // Calculate the field line table
    byte* line = screen;
    for(byte y: 0..24) {
        form_line_lo[y] = <line;
        form_line_hi[y] = >line;
        line = line + 40;
    }
}

// Get the screen address of a form field
// field_idx is the index of the field to get the screen address for
byte* form_field_ptr(byte field_idx) {
    byte y = form_fields_y[field_idx];
    byte* line = (byte*) { form_line_hi[y], form_line_lo[y] };
    byte x = form_fields_x[field_idx];
    byte* field = line+x;
    return field;
}

// Render all form values from the form_fields_val array
void form_render_values() {
    for( byte idx=0; idx<form_fields_cnt; idx++) {
        byte* field = form_field_ptr(idx);
        *field = print_hextab[form_fields_val[idx]];
    }
}

// Reads keyboard and allows the user to navigate and change the fields of the form
void form_control() {
    byte* field = form_field_ptr(form_field_idx);

    // Blinking cursor
    if(--form_cursor_count < 0) {
        form_cursor_count = FORM_CURSOR_BLINK;
    }
    if(form_cursor_count<FORM_CURSOR_BLINK/2) {
        *field = *field | $80;
    } else {
        *field = *field & $7f;
    }

    // Scan the keyboard
    keyboard_event_scan();
    byte key_event = keyboard_event_get();

    // Navigation using cursor up/down
    if(key_event==KEY_CRSR_DOWN) {
        // Unblink the cursor
        *field = *field & $7f;
        if((keyboard_modifiers&KEY_MODIFIER_SHIFT)==0) {
            // Move to next field
            if(++form_field_idx==form_fields_cnt) {
                form_field_idx = 0;
            }
         } else {
            // Move to previous field
            if(--form_field_idx==$ff) {
                form_field_idx = form_fields_cnt-1;
            }
         }
        // Always blink cursor in new field
        form_cursor_count = FORM_CURSOR_BLINK/2;
        // Return to refresh
        return;
    }

    // Change value with cursor left/right
    if(key_event==KEY_CRSR_RIGHT) {
        if((keyboard_modifiers&KEY_MODIFIER_SHIFT)==0) {
            // Increase value
            if(++form_fields_val[form_field_idx]>form_fields_max[form_field_idx]) {
                form_fields_val[form_field_idx] = 0;
            }
        } else {
            // Decrease value
            if(--form_fields_val[form_field_idx]==$ff) {
                form_fields_val[form_field_idx] = form_fields_max[form_field_idx];
            }
        }
        // Render field value
        *field = print_hextab[form_fields_val[form_field_idx]];
     }

}
