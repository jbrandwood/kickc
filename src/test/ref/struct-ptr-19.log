Setting struct to load/store in variable affected by address-of main::ptr = &main::point
Inlined call call __init
Removing C-classic struct-unwound assignment main::point = struct-unwound {*(&main::point)}

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  idx#16 = phi( __start::@1/idx#17 )
  *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT)
  print::p_x#0 = *((char *)&main::point+OFFSET_STRUCT_POINT_X)
  print::p_y#0 = *((char *)&main::point+OFFSET_STRUCT_POINT_Y)
  call print
  to:main::@1
main::@1: scope:[main]  from main
  idx#9 = phi( main/idx#5 )
  idx#0 = idx#9
  main::$4 = (char *)main::ptr
  main::$2 = main::$4 + OFFSET_STRUCT_POINT_X
  main::$5 = (char *)main::ptr
  main::$3 = main::$5 + OFFSET_STRUCT_POINT_Y
  print::p_x#1 = *main::$2
  print::p_y#1 = *main::$3
  call print
  to:main::@2
main::@2: scope:[main]  from main::@1
  idx#10 = phi( main::@1/idx#5 )
  idx#1 = idx#10
  to:main::@return
main::@return: scope:[main]  from main::@2
  idx#11 = phi( main::@2/idx#1 )
  idx#2 = idx#11
  return 
  to:@return

void print(char p_x , char p_y)
print: scope:[print]  from main main::@1
  print::p_y#2 = phi( main/print::p_y#0, main::@1/print::p_y#1 )
  idx#12 = phi( main/idx#16, main::@1/idx#0 )
  print::p_x#2 = phi( main/print::p_x#0, main::@1/print::p_x#1 )
  SCREEN[idx#12] = print::p_x#2
  idx#3 = ++ idx#12
  SCREEN[idx#3] = print::p_y#2
  idx#4 = ++ idx#3
  to:print::@return
print::@return: scope:[print]  from print
  idx#13 = phi( print/idx#4 )
  idx#5 = idx#13
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  idx#6 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  idx#17 = phi( __start::__init1/idx#6 )
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  idx#14 = phi( __start::@1/idx#2 )
  idx#7 = idx#14
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  idx#15 = phi( __start::@2/idx#7 )
  idx#8 = idx#15
  return 
  to:@return

SYMBOL TABLE SSA
__constant struct Point $0 = { x: 1, y: 2 }
__constant char OFFSET_STRUCT_POINT_X = 0
__constant char OFFSET_STRUCT_POINT_Y = 1
__constant char * const SCREEN = (char *)$400
__constant char SIZEOF_STRUCT_POINT = 2
void __start()
char idx
char idx#0
char idx#1
char idx#10
char idx#11
char idx#12
char idx#13
char idx#14
char idx#15
char idx#16
char idx#17
char idx#2
char idx#3
char idx#4
char idx#5
char idx#6
char idx#7
char idx#8
char idx#9
void main()
char *main::$2
char *main::$3
char *main::$4
char *main::$5
__loadstore volatile struct Point main::point
__constant struct Point *main::ptr = &main::point
void print(char p_x , char p_y)
struct Point print::p
char print::p_x
char print::p_x#0
char print::p_x#1
char print::p_x#2
char print::p_y
char print::p_y#0
char print::p_y#1
char print::p_y#2

Simplifying constant pointer cast (char *) 1024
Successful SSA optimization PassNCastSimplification
Alias idx#0 = idx#9 
Alias idx#1 = idx#10 idx#11 idx#2 
Alias idx#13 = idx#4 idx#5 
Alias idx#17 = idx#6 
Alias idx#14 = idx#7 idx#15 idx#8 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values idx#16 idx#17
Identical Phi Values idx#0 idx#13
Identical Phi Values idx#1 idx#13
Identical Phi Values idx#14 idx#1
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [6] main::$4 = (char *)main::ptr
Constant right-side identified [8] main::$5 = (char *)main::ptr
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::$4 = (char *)main::ptr
Constant main::$5 = (char *)main::ptr
Constant idx#17 = 0
Successful SSA optimization Pass2ConstantIdentification
Converting *(pointer+n) to pointer[n] [10] print::p_x#1 = *main::$2  -- main::$4[OFFSET_STRUCT_POINT_X]
Converting *(pointer+n) to pointer[n] [11] print::p_y#1 = *main::$3  -- main::$5[OFFSET_STRUCT_POINT_Y]
Successful SSA optimization Pass2InlineDerefIdx
Simplifying expression containing zero (char *)&main::point in [2] print::p_x#0 = *((char *)&main::point+OFFSET_STRUCT_POINT_X)
Simplifying expression containing zero main::$4 in [7] main::$2 = main::$4 + OFFSET_STRUCT_POINT_X
Simplifying expression containing zero main::$4 in [10] print::p_x#1 = main::$4[OFFSET_STRUCT_POINT_X]
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable main::$2 and assignment [4] main::$2 = main::$4
Eliminating unused variable main::$3 and assignment [5] main::$3 = main::$5 + OFFSET_STRUCT_POINT_Y
Eliminating unused constant OFFSET_STRUCT_POINT_X
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings idx#17
Constant inlined main::$5 = (char *)main::ptr
Constant inlined idx#17 = 0
Constant inlined main::$4 = (char *)main::ptr
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *((char *)main::ptr+OFFSET_STRUCT_POINT_Y)
Successful SSA optimization Pass2ConstantAdditionElimination
Adding NOP phi() at start of main::@2
CALL GRAPH
Calls in [main] to print:5 print:11 

Created 3 initial phi equivalence classes
Coalesced [3] print::p_x#3 = print::p_x#0
Coalesced [4] print::p_y#3 = print::p_y#0
Coalesced [8] print::p_x#4 = print::p_x#1
Coalesced [9] idx#18 = idx#13
Coalesced [10] print::p_y#4 = print::p_y#1
Coalesced down to 3 phi equivalence classes
Culled Empty Block label main::@2

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT)
  [1] print::p_x#0 = *((char *)&main::point)
  [2] print::p_y#0 = *((char *)&main::point+OFFSET_STRUCT_POINT_Y)
  [3] call print
  to:main::@1
main::@1: scope:[main]  from main
  [4] print::p_x#1 = *((char *)main::ptr)
  [5] print::p_y#1 = *((char *)main::ptr+OFFSET_STRUCT_POINT_Y)
  [6] call print
  to:main::@return
main::@return: scope:[main]  from main::@1
  [7] return 
  to:@return

void print(char p_x , char p_y)
print: scope:[print]  from main main::@1
  [8] print::p_y#2 = phi( main/print::p_y#0, main::@1/print::p_y#1 )
  [8] idx#12 = phi( main/0, main::@1/idx#13 )
  [8] print::p_x#2 = phi( main/print::p_x#0, main::@1/print::p_x#1 )
  [9] SCREEN[idx#12] = print::p_x#2
  [10] idx#3 = ++ idx#12
  [11] SCREEN[idx#3] = print::p_y#2
  [12] idx#13 = ++ idx#3
  to:print::@return
print::@return: scope:[print]  from print
  [13] return 
  to:@return


VARIABLE REGISTER WEIGHTS
char idx
char idx#12 // 12.0
char idx#13 // 2.6
char idx#3 // 16.5
void main()
__loadstore volatile struct Point main::point
void print(char p_x , char p_y)
struct Point print::p
char print::p_x
char print::p_x#0 // 2.0
char print::p_x#1 // 2.0
char print::p_x#2 // 15.0
char print::p_y
char print::p_y#0 // 4.0
char print::p_y#1 // 4.0
char print::p_y#2 // 5.0

Initial phi equivalence classes
[ print::p_x#2 print::p_x#0 print::p_x#1 ]
[ idx#12 idx#13 ]
[ print::p_y#2 print::p_y#0 print::p_y#1 ]
Added variable idx#3 to live range equivalence class [ idx#3 ]
Added variable main::point to live range equivalence class [ main::point ]
Complete equivalence classes
[ print::p_x#2 print::p_x#0 print::p_x#1 ]
[ idx#12 idx#13 ]
[ print::p_y#2 print::p_y#0 print::p_y#1 ]
[ idx#3 ]
[ main::point ]
Allocated zp[1]:2 [ print::p_x#2 print::p_x#0 print::p_x#1 ]
Allocated zp[1]:3 [ idx#3 ]
Allocated zp[1]:4 [ idx#12 idx#13 ]
Allocated zp[1]:5 [ print::p_y#2 print::p_y#0 print::p_y#1 ]
Allocated zp[2]:6 [ main::point ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT) [ main::point ] (  [ main::point ] { { print::p_x#0 = print::p_x#2 } { print::p_y#0 = print::p_y#2 } }  ) always clobbers reg byte a reg byte y 
Potential registers zp[1]:2 [ print::p_x#2 print::p_x#0 print::p_x#1 ] : zp[1]:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ idx#12 idx#13 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ print::p_y#2 print::p_y#0 print::p_y#1 ] : zp[1]:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ idx#3 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:6 [ main::point ] : zp[2]:6 , 

REGISTER UPLIFT SCOPES
Uplift Scope [print] 19: zp[1]:2 [ print::p_x#2 print::p_x#0 print::p_x#1 ] 13: zp[1]:5 [ print::p_y#2 print::p_y#0 print::p_y#1 ] 
Uplift Scope [] 16.5: zp[1]:3 [ idx#3 ] 14.6: zp[1]:4 [ idx#12 idx#13 ] 
Uplift Scope [Point] 
Uplift Scope [main] 0: zp[2]:6 [ main::point ] 

Uplifting [print] best 102 combination reg byte y [ print::p_x#2 print::p_x#0 print::p_x#1 ] reg byte x [ print::p_y#2 print::p_y#0 print::p_y#1 ] 
Uplifting [] best 93 combination reg byte y [ idx#3 ] zp[1]:4 [ idx#12 idx#13 ] 
Uplifting [Point] best 93 combination 
Uplifting [main] best 93 combination zp[2]:6 [ main::point ] 
Attempting to uplift remaining variables inzp[1]:4 [ idx#12 idx#13 ]
Uplifting [] best 93 combination zp[1]:4 [ idx#12 idx#13 ] 
Allocated (was zp[1]:4) zp[1]:2 [ idx#12 idx#13 ]
Allocated (was zp[2]:6) zp[2]:3 [ main::point ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Demonstrates problem with passing struct pointer deref as parameter to call
  // Upstart
  // Commodore 64 PRG executable file
.file [name="struct-ptr-19.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const SIZEOF_STRUCT_POINT = 2
  .const OFFSET_STRUCT_POINT_Y = 1
  .label SCREEN = $400
  .label idx = 2
.segment Code
  // main
main: {
    .label ptr = point
    .label point = 3
    // [0] *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT) -- _deref_pssc1=_deref_pssc2_memcpy_vbuc3 
    ldy #SIZEOF_STRUCT_POINT
  !:
    lda __0-1,y
    sta point-1,y
    dey
    bne !-
    // [1] print::p_x#0 = *((char *)&main::point) -- vbuyy=_deref_pbuc1 
    ldy.z point
    // [2] print::p_y#0 = *((char *)&main::point+OFFSET_STRUCT_POINT_Y) -- vbuxx=_deref_pbuc1 
    ldx.z point+OFFSET_STRUCT_POINT_Y
    // [3] call print
    // [8] phi from main to print [phi:main->print]
  print_from_main:
    // [8] phi print::p_y#2 = print::p_y#0 [phi:main->print#0] -- register_copy 
    // [8] phi idx#12 = 0 [phi:main->print#1] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [8] phi print::p_x#2 = print::p_x#0 [phi:main->print#2] -- call_phi_near 
    jsr print
    jmp __b1
    // main::@1
  __b1:
    // [4] print::p_x#1 = *((char *)main::ptr) -- vbuyy=_deref_pbuc1 
    ldy.z ptr
    // [5] print::p_y#1 = *((char *)main::ptr+OFFSET_STRUCT_POINT_Y) -- vbuxx=_deref_pbuc1 
    ldx.z ptr+OFFSET_STRUCT_POINT_Y
    // [6] call print
    // [8] phi from main::@1 to print [phi:main::@1->print]
  print_from___b1:
    // [8] phi print::p_y#2 = print::p_y#1 [phi:main::@1->print#0] -- register_copy 
    // [8] phi idx#12 = idx#13 [phi:main::@1->print#1] -- register_copy 
    // [8] phi print::p_x#2 = print::p_x#1 [phi:main::@1->print#2] -- call_phi_near 
    jsr print
    jmp __breturn
    // main::@return
  __breturn:
    // [7] return 
    rts
}
  // print
// void print(__register(Y) char p_x, __register(X) char p_y)
print: {
    // [9] SCREEN[idx#12] = print::p_x#2 -- pbuc1_derefidx_vbuz1=vbuyy 
    tya
    ldy.z idx
    sta SCREEN,y
    // [10] idx#3 = ++ idx#12 -- vbuyy=_inc_vbuz1 
    ldy.z idx
    iny
    // [11] SCREEN[idx#3] = print::p_y#2 -- pbuc1_derefidx_vbuyy=vbuxx 
    txa
    sta SCREEN,y
    // [12] idx#13 = ++ idx#3 -- vbuz1=_inc_vbuyy 
    iny
    sty.z idx
    jmp __breturn
    // print::@return
  __breturn:
    // [13] return 
    rts
}
  // File Data
.segment Data
  __0: .byte 1, 2

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy.z idx
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction print_from_main:
Removing instruction __b1:
Removing instruction print_from___b1:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
__constant struct Point $0 = { x: 1, y: 2 }
__constant char OFFSET_STRUCT_POINT_Y = 1
__constant char * const SCREEN = (char *) 1024
__constant char SIZEOF_STRUCT_POINT = 2
char idx
char idx#12 // idx zp[1]:2 12.0
char idx#13 // idx zp[1]:2 2.6
char idx#3 // reg byte y 16.5
void main()
__loadstore volatile struct Point main::point // zp[2]:3
__constant struct Point *main::ptr = &main::point
void print(char p_x , char p_y)
struct Point print::p
char print::p_x
char print::p_x#0 // reg byte y 2.0
char print::p_x#1 // reg byte y 2.0
char print::p_x#2 // reg byte y 15.0
char print::p_y
char print::p_y#0 // reg byte x 4.0
char print::p_y#1 // reg byte x 4.0
char print::p_y#2 // reg byte x 5.0

reg byte y [ print::p_x#2 print::p_x#0 print::p_x#1 ]
zp[1]:2 [ idx#12 idx#13 ]
reg byte x [ print::p_y#2 print::p_y#0 print::p_y#1 ]
reg byte y [ idx#3 ]
zp[2]:3 [ main::point ]


FINAL ASSEMBLER
Score: 81

  // File Comments
// Demonstrates problem with passing struct pointer deref as parameter to call
  // Upstart
  // Commodore 64 PRG executable file
.file [name="struct-ptr-19.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const SIZEOF_STRUCT_POINT = 2
  .const OFFSET_STRUCT_POINT_Y = 1
  .label SCREEN = $400
  .label idx = 2
.segment Code
  // main
main: {
    .label ptr = point
    .label point = 3
    // struct Point point = { 1, 2 }
    // [0] *(&main::point) = memcpy(*(&$0), struct Point, SIZEOF_STRUCT_POINT) -- _deref_pssc1=_deref_pssc2_memcpy_vbuc3 
    ldy #SIZEOF_STRUCT_POINT
  !:
    lda __0-1,y
    sta point-1,y
    dey
    bne !-
    // print(point)
    // [1] print::p_x#0 = *((char *)&main::point) -- vbuyy=_deref_pbuc1 
    ldy.z point
    // [2] print::p_y#0 = *((char *)&main::point+OFFSET_STRUCT_POINT_Y) -- vbuxx=_deref_pbuc1 
    ldx.z point+OFFSET_STRUCT_POINT_Y
    // [3] call print
    // [8] phi from main to print [phi:main->print]
    // [8] phi print::p_y#2 = print::p_y#0 [phi:main->print#0] -- register_copy 
    // [8] phi idx#12 = 0 [phi:main->print#1] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [8] phi print::p_x#2 = print::p_x#0 [phi:main->print#2] -- call_phi_near 
    jsr print
    // main::@1
    // print(*ptr)
    // [4] print::p_x#1 = *((char *)main::ptr) -- vbuyy=_deref_pbuc1 
    ldy.z ptr
    // [5] print::p_y#1 = *((char *)main::ptr+OFFSET_STRUCT_POINT_Y) -- vbuxx=_deref_pbuc1 
    ldx.z ptr+OFFSET_STRUCT_POINT_Y
    // [6] call print
    // [8] phi from main::@1 to print [phi:main::@1->print]
    // [8] phi print::p_y#2 = print::p_y#1 [phi:main::@1->print#0] -- register_copy 
    // [8] phi idx#12 = idx#13 [phi:main::@1->print#1] -- register_copy 
    // [8] phi print::p_x#2 = print::p_x#1 [phi:main::@1->print#2] -- call_phi_near 
    jsr print
    // main::@return
    // }
    // [7] return 
    rts
}
  // print
// void print(__register(Y) char p_x, __register(X) char p_y)
print: {
    // SCREEN[idx++] = p.x
    // [9] SCREEN[idx#12] = print::p_x#2 -- pbuc1_derefidx_vbuz1=vbuyy 
    tya
    ldy.z idx
    sta SCREEN,y
    // SCREEN[idx++] = p.x;
    // [10] idx#3 = ++ idx#12 -- vbuyy=_inc_vbuz1 
    iny
    // SCREEN[idx++] = p.y
    // [11] SCREEN[idx#3] = print::p_y#2 -- pbuc1_derefidx_vbuyy=vbuxx 
    txa
    sta SCREEN,y
    // SCREEN[idx++] = p.y;
    // [12] idx#13 = ++ idx#3 -- vbuz1=_inc_vbuyy 
    iny
    sty.z idx
    // print::@return
    // }
    // [13] return 
    rts
}
  // File Data
.segment Data
  __0: .byte 1, 2

