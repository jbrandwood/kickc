Setting inferred volatile on symbol affected by address-of (word*) main::wp ← &(word) main::w

CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from __start
  (volatile word) main::w ← (word) $4d2
  (void*) main::vp#0 ← ((void*)) (const word*) main::wp
  (byte*) main::bp#0 ← ((byte*)) (void*) main::vp#0
  *((const nomodify byte*) main::SCREEN) ← *((byte*) main::bp#0)
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
(void()) __start()
(label) __start::@1
(label) __start::@return
(void()) main()
(label) main::@return
(const nomodify byte*) main::SCREEN = (byte*)(number) $400
(byte*) main::bp
(byte*) main::bp#0
(void*) main::vp
(void*) main::vp#0
(volatile word) main::w loadstore
(const word*) main::wp = &(volatile word) main::w

Inlining cast (void*) main::vp#0 ← (void*)(const word*) main::wp
Inlining cast (byte*) main::bp#0 ← (byte*)(void*) main::vp#0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Successful SSA optimization PassNCastSimplification
Constant right-side identified [1] (void*) main::vp#0 ← (void*)(const word*) main::wp
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const void*) main::vp#0 = (void*)main::wp
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) main::bp#0 = (byte*)main::vp#0
Successful SSA optimization Pass2ConstantIdentification
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
CALL GRAPH

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] (volatile word) main::w ← (word) $4d2
  [1] *((const nomodify byte*) main::SCREEN) ← *((const byte*) main::bp#0)
  to:main::@return
main::@return: scope:[main]  from main
  [2] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) main()
(byte*) main::bp
(void*) main::vp
(volatile word) main::w loadstore 20.0

Initial phi equivalence classes
Added variable main::w to live range equivalence class [ main::w ]
Complete equivalence classes
[ main::w ]
Allocated zp[2]:2 [ main::w ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Test simple void pointer (conversion without casting)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // main
main: {
    .label SCREEN = $400
    .label wp = w
    .label vp = wp
    .label bp = vp
    .label w = 2
    // [0] (volatile word) main::w ← (word) $4d2 -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z w
    lda #>$4d2
    sta.z w+1
    // [1] *((const nomodify byte*) main::SCREEN) ← *((const byte*) main::bp#0) -- _deref_pbuc1=_deref_pbuc2 
    lda.z bp
    sta SCREEN
    jmp __breturn
    // main::@return
  __breturn:
    // [2] return 
    rts
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] (volatile word) main::w ← (word) $4d2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [1] *((const nomodify byte*) main::SCREEN) ← *((const byte*) main::bp#0) [ ] (  [ ] { }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ main::w ] : zp[2]:2 , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 20: zp[2]:2 [ main::w ] 
Uplift Scope [] 

Uplifting [main] best 26 combination zp[2]:2 [ main::w ] 
Uplifting [] best 26 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test simple void pointer (conversion without casting)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // main
main: {
    .label SCREEN = $400
    .label wp = w
    .label vp = wp
    .label bp = vp
    .label w = 2
    // [0] (volatile word) main::w ← (word) $4d2 -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z w
    lda #>$4d2
    sta.z w+1
    // [1] *((const nomodify byte*) main::SCREEN) ← *((const byte*) main::bp#0) -- _deref_pbuc1=_deref_pbuc2 
    lda.z bp
    sta SCREEN
    jmp __breturn
    // main::@return
  __breturn:
    // [2] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(void()) main()
(label) main::@return
(const nomodify byte*) main::SCREEN = (byte*) 1024
(byte*) main::bp
(const byte*) main::bp#0 bp = (byte*)(const void*) main::vp#0
(void*) main::vp
(const void*) main::vp#0 vp = (void*)(const word*) main::wp
(volatile word) main::w loadstore zp[2]:2 20.0
(const word*) main::wp = &(volatile word) main::w

zp[2]:2 [ main::w ]


FINAL ASSEMBLER
Score: 23

  // File Comments
// Test simple void pointer (conversion without casting)
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // main
main: {
    .label SCREEN = $400
    .label wp = w
    .label vp = wp
    .label bp = vp
    .label w = 2
    // w = 1234
    // [0] (volatile word) main::w ← (word) $4d2 -- vwuz1=vwuc1 
    lda #<$4d2
    sta.z w
    lda #>$4d2
    sta.z w+1
    // *SCREEN = *bp
    // [1] *((const nomodify byte*) main::SCREEN) ← *((const byte*) main::bp#0) -- _deref_pbuc1=_deref_pbuc2 
    lda.z bp
    sta SCREEN
    // main::@return
    // }
    // [2] return 
    rts
}
  // File Data

