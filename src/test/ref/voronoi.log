
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@1

(void()) main()
main: scope:[main]  from @1
  call initscreen 
  to:main::@2
main::@2: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@2 main::@4
  call render 
  to:main::@3
main::@3: scope:[main]  from main::@1
  call animate 
  to:main::@4
main::@4: scope:[main]  from main::@3
  if(true) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return

(void()) animate()
animate: scope:[animate]  from main::@3
  (number~) animate::$0 ← *((const byte*) XPOS + (number) 0) + (number) 1
  *((const byte*) XPOS + (number) 0) ← (number~) animate::$0
  (bool~) animate::$1 ← *((const byte*) XPOS + (number) 0) == (number) $28
  (bool~) animate::$2 ← ! (bool~) animate::$1
  if((bool~) animate::$2) goto animate::@1
  to:animate::@5
animate::@1: scope:[animate]  from animate animate::@5
  (number~) animate::$3 ← *((const byte*) YPOS + (number) 0) + (number) 1
  *((const byte*) YPOS + (number) 0) ← (number~) animate::$3
  (bool~) animate::$4 ← *((const byte*) YPOS + (number) 0) == (number) $19
  (bool~) animate::$5 ← ! (bool~) animate::$4
  if((bool~) animate::$5) goto animate::@2
  to:animate::@6
animate::@5: scope:[animate]  from animate
  *((const byte*) XPOS + (number) 0) ← (number) 0
  to:animate::@1
animate::@2: scope:[animate]  from animate::@1 animate::@6
  (number~) animate::$6 ← *((const byte*) XPOS + (number) 1) - (number) 1
  *((const byte*) XPOS + (number) 1) ← (number~) animate::$6
  (bool~) animate::$7 ← *((const byte*) XPOS + (number) 1) == (number) $ff
  (bool~) animate::$8 ← ! (bool~) animate::$7
  if((bool~) animate::$8) goto animate::@3
  to:animate::@7
animate::@6: scope:[animate]  from animate::@1
  *((const byte*) YPOS + (number) 0) ← (number) 0
  to:animate::@2
animate::@3: scope:[animate]  from animate::@2 animate::@7
  (number~) animate::$9 ← *((const byte*) YPOS + (number) 2) + (number) 1
  *((const byte*) YPOS + (number) 2) ← (number~) animate::$9
  (bool~) animate::$10 ← *((const byte*) YPOS + (number) 2) == (number) $19
  (bool~) animate::$11 ← ! (bool~) animate::$10
  if((bool~) animate::$11) goto animate::@4
  to:animate::@8
animate::@7: scope:[animate]  from animate::@2
  *((const byte*) XPOS + (number) 1) ← (number) $28
  to:animate::@3
animate::@4: scope:[animate]  from animate::@3 animate::@8
  (number~) animate::$12 ← *((const byte*) YPOS + (number) 3) - (number) 1
  *((const byte*) YPOS + (number) 3) ← (number~) animate::$12
  (bool~) animate::$13 ← *((const byte*) YPOS + (number) 3) == (number) $ff
  (bool~) animate::$14 ← ! (bool~) animate::$13
  if((bool~) animate::$14) goto animate::@return
  to:animate::@9
animate::@8: scope:[animate]  from animate::@3
  *((const byte*) YPOS + (number) 2) ← (number) 0
  to:animate::@4
animate::@9: scope:[animate]  from animate::@4
  *((const byte*) YPOS + (number) 3) ← (number) $19
  (number~) animate::$15 ← *((const byte*) XPOS + (number) 3) + (number) 7
  *((const byte*) XPOS + (number) 3) ← (number~) animate::$15
  (bool~) animate::$16 ← *((const byte*) XPOS + (number) 3) >= (number) $28
  (bool~) animate::$17 ← ! (bool~) animate::$16
  if((bool~) animate::$17) goto animate::@return
  to:animate::@10
animate::@10: scope:[animate]  from animate::@9
  (number~) animate::$18 ← *((const byte*) XPOS + (number) 3) - (number) $28
  *((const byte*) XPOS + (number) 3) ← (number~) animate::$18
  to:animate::@return
animate::@return: scope:[animate]  from animate::@10 animate::@4 animate::@9
  return 
  to:@return

(void()) initscreen()
initscreen: scope:[initscreen]  from main
  (byte*) initscreen::screen#0 ← (const byte*) SCREEN
  to:initscreen::@1
initscreen::@1: scope:[initscreen]  from initscreen initscreen::@2
  (byte*) initscreen::screen#2 ← phi( initscreen/(byte*) initscreen::screen#0 initscreen::@2/(byte*) initscreen::screen#1 )
  (byte*~) initscreen::$0 ← (const byte*) SCREEN + (number) $3e8
  (bool~) initscreen::$1 ← (byte*) initscreen::screen#2 < (byte*~) initscreen::$0
  if((bool~) initscreen::$1) goto initscreen::@2
  to:initscreen::@return
initscreen::@2: scope:[initscreen]  from initscreen::@1
  (byte*) initscreen::screen#3 ← phi( initscreen::@1/(byte*) initscreen::screen#2 )
  *((byte*) initscreen::screen#3) ← (const byte) FILL
  (byte*) initscreen::screen#1 ← ++ (byte*) initscreen::screen#3
  to:initscreen::@1
initscreen::@return: scope:[initscreen]  from initscreen::@1
  return 
  to:@return

(void()) render()
render: scope:[render]  from main::@1
  (byte*) render::colline#0 ← (const byte*) COLORS
  (byte) render::y#0 ← (byte) 0
  to:render::@1
render::@1: scope:[render]  from render render::@3
  (byte*) render::colline#5 ← phi( render/(byte*) render::colline#0 render::@3/(byte*) render::colline#1 )
  (byte) render::y#4 ← phi( render/(byte) render::y#0 render::@3/(byte) render::y#1 )
  (byte) render::x#0 ← (byte) 0
  to:render::@2
render::@2: scope:[render]  from render::@1 render::@4
  (byte*) render::colline#4 ← phi( render::@1/(byte*) render::colline#5 render::@4/(byte*) render::colline#2 )
  (byte) render::y#2 ← phi( render::@1/(byte) render::y#4 render::@4/(byte) render::y#5 )
  (byte) render::x#2 ← phi( render::@1/(byte) render::x#0 render::@4/(byte) render::x#1 )
  (byte) findcol::x#0 ← (byte) render::x#2
  (byte) findcol::y#0 ← (byte) render::y#2
  call findcol 
  (byte) findcol::return#0 ← (byte) findcol::return#3
  to:render::@4
render::@4: scope:[render]  from render::@2
  (byte) render::y#5 ← phi( render::@2/(byte) render::y#2 )
  (byte) render::x#3 ← phi( render::@2/(byte) render::x#2 )
  (byte*) render::colline#2 ← phi( render::@2/(byte*) render::colline#4 )
  (byte) findcol::return#4 ← phi( render::@2/(byte) findcol::return#0 )
  (byte~) render::$0 ← (byte) findcol::return#4
  (byte) render::col#0 ← (byte~) render::$0
  *((byte*) render::colline#2 + (byte) render::x#3) ← (byte) render::col#0
  (byte) render::x#1 ← (byte) render::x#3 + rangenext(0,$27)
  (bool~) render::$1 ← (byte) render::x#1 != rangelast(0,$27)
  if((bool~) render::$1) goto render::@2
  to:render::@3
render::@3: scope:[render]  from render::@4
  (byte) render::y#3 ← phi( render::@4/(byte) render::y#5 )
  (byte*) render::colline#3 ← phi( render::@4/(byte*) render::colline#2 )
  (byte*~) render::$2 ← (byte*) render::colline#3 + (number) $28
  (byte*) render::colline#1 ← (byte*~) render::$2
  (byte) render::y#1 ← (byte) render::y#3 + rangenext(0,$18)
  (bool~) render::$3 ← (byte) render::y#1 != rangelast(0,$18)
  if((bool~) render::$3) goto render::@1
  to:render::@return
render::@return: scope:[render]  from render::@3
  return 
  to:@return

(byte()) findcol((byte) findcol::x , (byte) findcol::y)
findcol: scope:[findcol]  from render::@2
  (byte) findcol::y#10 ← phi( render::@2/(byte) findcol::y#0 )
  (byte) findcol::x#7 ← phi( render::@2/(byte) findcol::x#0 )
  (byte) findcol::mindiff#0 ← (byte) $ff
  (byte) findcol::mincol#0 ← (byte) 0
  (byte) findcol::i#0 ← (byte) 0
  to:findcol::@1
findcol::@1: scope:[findcol]  from findcol findcol::@9
  (byte) findcol::mindiff#11 ← phi( findcol/(byte) findcol::mindiff#0 findcol::@9/(byte) findcol::mindiff#12 )
  (byte) findcol::y#8 ← phi( findcol/(byte) findcol::y#10 findcol::@9/(byte) findcol::y#11 )
  (byte) findcol::mincol#3 ← phi( findcol/(byte) findcol::mincol#0 findcol::@9/(byte) findcol::mincol#4 )
  (byte) findcol::x#5 ← phi( findcol/(byte) findcol::x#7 findcol::@9/(byte) findcol::x#8 )
  (byte) findcol::i#2 ← phi( findcol/(byte) findcol::i#0 findcol::@9/(byte) findcol::i#1 )
  (bool~) findcol::$0 ← (byte) findcol::i#2 < (const byte) numpoints
  if((bool~) findcol::$0) goto findcol::@2
  to:findcol::@3
findcol::@2: scope:[findcol]  from findcol::@1
  (byte) findcol::mincol#13 ← phi( findcol::@1/(byte) findcol::mincol#3 )
  (byte) findcol::mindiff#10 ← phi( findcol::@1/(byte) findcol::mindiff#11 )
  (byte) findcol::y#5 ← phi( findcol::@1/(byte) findcol::y#8 )
  (byte) findcol::x#1 ← phi( findcol::@1/(byte) findcol::x#5 )
  (byte) findcol::i#3 ← phi( findcol::@1/(byte) findcol::i#2 )
  (byte) findcol::xp#0 ← *((const byte*) XPOS + (byte) findcol::i#3)
  (byte) findcol::yp#0 ← *((const byte*) YPOS + (byte) findcol::i#3)
  (bool~) findcol::$1 ← (byte) findcol::x#1 == (byte) findcol::xp#0
  (bool~) findcol::$2 ← ! (bool~) findcol::$1
  if((bool~) findcol::$2) goto findcol::@4
  to:findcol::@10
findcol::@3: scope:[findcol]  from findcol::@1
  (byte) findcol::mincol#2 ← phi( findcol::@1/(byte) findcol::mincol#3 )
  (byte) findcol::return#1 ← (byte) findcol::mincol#2
  to:findcol::@return
findcol::@4: scope:[findcol]  from findcol::@10 findcol::@2
  (byte) findcol::mincol#11 ← phi( findcol::@10/(byte) findcol::mincol#12 findcol::@2/(byte) findcol::mincol#13 )
  (byte) findcol::i#12 ← phi( findcol::@10/(byte) findcol::i#13 findcol::@2/(byte) findcol::i#3 )
  (byte) findcol::mindiff#8 ← phi( findcol::@10/(byte) findcol::mindiff#9 findcol::@2/(byte) findcol::mindiff#10 )
  (byte) findcol::yp#7 ← phi( findcol::@10/(byte) findcol::yp#1 findcol::@2/(byte) findcol::yp#0 )
  (byte) findcol::y#9 ← phi( findcol::@10/(byte) findcol::y#1 findcol::@2/(byte) findcol::y#5 )
  (byte) findcol::xp#1 ← phi( findcol::@10/(byte) findcol::xp#4 findcol::@2/(byte) findcol::xp#0 )
  (byte) findcol::x#2 ← phi( findcol::@10/(byte) findcol::x#6 findcol::@2/(byte) findcol::x#1 )
  (byte) findcol::diff#0 ← (byte) 0
  (bool~) findcol::$5 ← (byte) findcol::x#2 < (byte) findcol::xp#1
  if((bool~) findcol::$5) goto findcol::@5
  to:findcol::@12
findcol::@10: scope:[findcol]  from findcol::@2
  (byte) findcol::mincol#12 ← phi( findcol::@2/(byte) findcol::mincol#13 )
  (byte) findcol::i#13 ← phi( findcol::@2/(byte) findcol::i#3 )
  (byte) findcol::mindiff#9 ← phi( findcol::@2/(byte) findcol::mindiff#10 )
  (byte) findcol::xp#4 ← phi( findcol::@2/(byte) findcol::xp#0 )
  (byte) findcol::x#6 ← phi( findcol::@2/(byte) findcol::x#1 )
  (byte) findcol::yp#1 ← phi( findcol::@2/(byte) findcol::yp#0 )
  (byte) findcol::y#1 ← phi( findcol::@2/(byte) findcol::y#5 )
  (bool~) findcol::$3 ← (byte) findcol::y#1 == (byte) findcol::yp#1
  (bool~) findcol::$4 ← ! (bool~) findcol::$3
  if((bool~) findcol::$4) goto findcol::@4
  to:findcol::@11
findcol::@11: scope:[findcol]  from findcol::@10
  (byte) findcol::return#2 ← (number) 0
  to:findcol::@return
findcol::@return: scope:[findcol]  from findcol::@11 findcol::@3
  (byte) findcol::return#5 ← phi( findcol::@11/(byte) findcol::return#2 findcol::@3/(byte) findcol::return#1 )
  (byte) findcol::return#3 ← (byte) findcol::return#5
  return 
  to:@return
findcol::@5: scope:[findcol]  from findcol::@4
  (byte) findcol::mincol#10 ← phi( findcol::@4/(byte) findcol::mincol#11 )
  (byte) findcol::i#11 ← phi( findcol::@4/(byte) findcol::i#12 )
  (byte) findcol::mindiff#7 ← phi( findcol::@4/(byte) findcol::mindiff#8 )
  (byte) findcol::yp#6 ← phi( findcol::@4/(byte) findcol::yp#7 )
  (byte) findcol::y#7 ← phi( findcol::@4/(byte) findcol::y#9 )
  (byte) findcol::x#3 ← phi( findcol::@4/(byte) findcol::x#2 )
  (byte) findcol::xp#2 ← phi( findcol::@4/(byte) findcol::xp#1 )
  (byte~) findcol::$7 ← (byte) findcol::xp#2 - (byte) findcol::x#3
  (byte) findcol::diff#1 ← (byte~) findcol::$7
  to:findcol::@6
findcol::@12: scope:[findcol]  from findcol::@4
  (byte) findcol::mincol#9 ← phi( findcol::@4/(byte) findcol::mincol#11 )
  (byte) findcol::i#10 ← phi( findcol::@4/(byte) findcol::i#12 )
  (byte) findcol::mindiff#6 ← phi( findcol::@4/(byte) findcol::mindiff#8 )
  (byte) findcol::yp#5 ← phi( findcol::@4/(byte) findcol::yp#7 )
  (byte) findcol::y#6 ← phi( findcol::@4/(byte) findcol::y#9 )
  (byte) findcol::xp#3 ← phi( findcol::@4/(byte) findcol::xp#1 )
  (byte) findcol::x#4 ← phi( findcol::@4/(byte) findcol::x#2 )
  (byte~) findcol::$6 ← (byte) findcol::x#4 - (byte) findcol::xp#3
  (byte) findcol::diff#2 ← (byte~) findcol::$6
  to:findcol::@6
findcol::@6: scope:[findcol]  from findcol::@12 findcol::@5
  (byte) findcol::mincol#8 ← phi( findcol::@12/(byte) findcol::mincol#9 findcol::@5/(byte) findcol::mincol#10 )
  (byte) findcol::x#13 ← phi( findcol::@12/(byte) findcol::x#4 findcol::@5/(byte) findcol::x#3 )
  (byte) findcol::i#9 ← phi( findcol::@12/(byte) findcol::i#10 findcol::@5/(byte) findcol::i#11 )
  (byte) findcol::mindiff#5 ← phi( findcol::@12/(byte) findcol::mindiff#6 findcol::@5/(byte) findcol::mindiff#7 )
  (byte) findcol::diff#9 ← phi( findcol::@12/(byte) findcol::diff#2 findcol::@5/(byte) findcol::diff#1 )
  (byte) findcol::yp#2 ← phi( findcol::@12/(byte) findcol::yp#5 findcol::@5/(byte) findcol::yp#6 )
  (byte) findcol::y#2 ← phi( findcol::@12/(byte) findcol::y#6 findcol::@5/(byte) findcol::y#7 )
  (bool~) findcol::$8 ← (byte) findcol::y#2 < (byte) findcol::yp#2
  if((bool~) findcol::$8) goto findcol::@7
  to:findcol::@13
findcol::@7: scope:[findcol]  from findcol::@6
  (byte) findcol::mincol#7 ← phi( findcol::@6/(byte) findcol::mincol#8 )
  (byte) findcol::x#12 ← phi( findcol::@6/(byte) findcol::x#13 )
  (byte) findcol::i#8 ← phi( findcol::@6/(byte) findcol::i#9 )
  (byte) findcol::mindiff#4 ← phi( findcol::@6/(byte) findcol::mindiff#5 )
  (byte) findcol::diff#5 ← phi( findcol::@6/(byte) findcol::diff#9 )
  (byte) findcol::y#3 ← phi( findcol::@6/(byte) findcol::y#2 )
  (byte) findcol::yp#3 ← phi( findcol::@6/(byte) findcol::yp#2 )
  (byte~) findcol::$11 ← (byte) findcol::yp#3 - (byte) findcol::y#3
  (byte~) findcol::$12 ← (byte) findcol::diff#5 + (byte~) findcol::$11
  (byte) findcol::diff#3 ← (byte~) findcol::$12
  to:findcol::@8
findcol::@13: scope:[findcol]  from findcol::@6
  (byte) findcol::mincol#6 ← phi( findcol::@6/(byte) findcol::mincol#8 )
  (byte) findcol::x#11 ← phi( findcol::@6/(byte) findcol::x#13 )
  (byte) findcol::i#7 ← phi( findcol::@6/(byte) findcol::i#9 )
  (byte) findcol::mindiff#3 ← phi( findcol::@6/(byte) findcol::mindiff#5 )
  (byte) findcol::diff#6 ← phi( findcol::@6/(byte) findcol::diff#9 )
  (byte) findcol::yp#4 ← phi( findcol::@6/(byte) findcol::yp#2 )
  (byte) findcol::y#4 ← phi( findcol::@6/(byte) findcol::y#2 )
  (byte~) findcol::$9 ← (byte) findcol::y#4 - (byte) findcol::yp#4
  (byte~) findcol::$10 ← (byte) findcol::diff#6 + (byte~) findcol::$9
  (byte) findcol::diff#4 ← (byte~) findcol::$10
  to:findcol::@8
findcol::@8: scope:[findcol]  from findcol::@13 findcol::@7
  (byte) findcol::y#13 ← phi( findcol::@13/(byte) findcol::y#4 findcol::@7/(byte) findcol::y#3 )
  (byte) findcol::mincol#5 ← phi( findcol::@13/(byte) findcol::mincol#6 findcol::@7/(byte) findcol::mincol#7 )
  (byte) findcol::x#10 ← phi( findcol::@13/(byte) findcol::x#11 findcol::@7/(byte) findcol::x#12 )
  (byte) findcol::i#6 ← phi( findcol::@13/(byte) findcol::i#7 findcol::@7/(byte) findcol::i#8 )
  (byte) findcol::mindiff#2 ← phi( findcol::@13/(byte) findcol::mindiff#3 findcol::@7/(byte) findcol::mindiff#4 )
  (byte) findcol::diff#7 ← phi( findcol::@13/(byte) findcol::diff#4 findcol::@7/(byte) findcol::diff#3 )
  (bool~) findcol::$13 ← (byte) findcol::diff#7 < (byte) findcol::mindiff#2
  (bool~) findcol::$14 ← ! (bool~) findcol::$13
  if((bool~) findcol::$14) goto findcol::@9
  to:findcol::@14
findcol::@9: scope:[findcol]  from findcol::@14 findcol::@8
  (byte) findcol::mindiff#12 ← phi( findcol::@14/(byte) findcol::mindiff#1 findcol::@8/(byte) findcol::mindiff#2 )
  (byte) findcol::y#11 ← phi( findcol::@14/(byte) findcol::y#12 findcol::@8/(byte) findcol::y#13 )
  (byte) findcol::mincol#4 ← phi( findcol::@14/(byte) findcol::mincol#1 findcol::@8/(byte) findcol::mincol#5 )
  (byte) findcol::x#8 ← phi( findcol::@14/(byte) findcol::x#9 findcol::@8/(byte) findcol::x#10 )
  (byte) findcol::i#4 ← phi( findcol::@14/(byte) findcol::i#5 findcol::@8/(byte) findcol::i#6 )
  (byte) findcol::i#1 ← ++ (byte) findcol::i#4
  to:findcol::@1
findcol::@14: scope:[findcol]  from findcol::@8
  (byte) findcol::y#12 ← phi( findcol::@8/(byte) findcol::y#13 )
  (byte) findcol::x#9 ← phi( findcol::@8/(byte) findcol::x#10 )
  (byte) findcol::i#5 ← phi( findcol::@8/(byte) findcol::i#6 )
  (byte) findcol::diff#8 ← phi( findcol::@8/(byte) findcol::diff#7 )
  (byte) findcol::mindiff#1 ← (byte) findcol::diff#8
  (byte) findcol::mincol#1 ← *((const byte*) COLS + (byte) findcol::i#5)
  to:findcol::@9
@1: scope:[]  from @begin
  call main 
  to:@2
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

SYMBOL TABLE SSA
(label) @1
(label) @2
(label) @begin
(label) @end
(const byte*) COLORS = (byte*)(number) $d800
(const byte*) COLS[]  = { (byte) 1, (byte) 2, (byte) 3, (byte) 4, (byte) 5, (byte) 7 }
(const byte) FILL = (byte) $e6
(const byte*) SCREEN = (byte*)(number) $400
(const byte*) XPOS[]  = { (byte) 5, (byte) $f, (byte) 6, (byte) $22, (byte) $15, (byte) $1f }
(const byte*) YPOS[]  = { (byte) 5, (byte) 8, (byte) $e, (byte) 2, (byte) $11, (byte) $16 }
(void()) animate()
(number~) animate::$0
(bool~) animate::$1
(bool~) animate::$10
(bool~) animate::$11
(number~) animate::$12
(bool~) animate::$13
(bool~) animate::$14
(number~) animate::$15
(bool~) animate::$16
(bool~) animate::$17
(number~) animate::$18
(bool~) animate::$2
(number~) animate::$3
(bool~) animate::$4
(bool~) animate::$5
(number~) animate::$6
(bool~) animate::$7
(bool~) animate::$8
(number~) animate::$9
(label) animate::@1
(label) animate::@10
(label) animate::@2
(label) animate::@3
(label) animate::@4
(label) animate::@5
(label) animate::@6
(label) animate::@7
(label) animate::@8
(label) animate::@9
(label) animate::@return
(byte()) findcol((byte) findcol::x , (byte) findcol::y)
(bool~) findcol::$0
(bool~) findcol::$1
(byte~) findcol::$10
(byte~) findcol::$11
(byte~) findcol::$12
(bool~) findcol::$13
(bool~) findcol::$14
(bool~) findcol::$2
(bool~) findcol::$3
(bool~) findcol::$4
(bool~) findcol::$5
(byte~) findcol::$6
(byte~) findcol::$7
(bool~) findcol::$8
(byte~) findcol::$9
(label) findcol::@1
(label) findcol::@10
(label) findcol::@11
(label) findcol::@12
(label) findcol::@13
(label) findcol::@14
(label) findcol::@2
(label) findcol::@3
(label) findcol::@4
(label) findcol::@5
(label) findcol::@6
(label) findcol::@7
(label) findcol::@8
(label) findcol::@9
(label) findcol::@return
(byte) findcol::diff
(byte) findcol::diff#0
(byte) findcol::diff#1
(byte) findcol::diff#2
(byte) findcol::diff#3
(byte) findcol::diff#4
(byte) findcol::diff#5
(byte) findcol::diff#6
(byte) findcol::diff#7
(byte) findcol::diff#8
(byte) findcol::diff#9
(byte) findcol::i
(byte) findcol::i#0
(byte) findcol::i#1
(byte) findcol::i#10
(byte) findcol::i#11
(byte) findcol::i#12
(byte) findcol::i#13
(byte) findcol::i#2
(byte) findcol::i#3
(byte) findcol::i#4
(byte) findcol::i#5
(byte) findcol::i#6
(byte) findcol::i#7
(byte) findcol::i#8
(byte) findcol::i#9
(byte) findcol::mincol
(byte) findcol::mincol#0
(byte) findcol::mincol#1
(byte) findcol::mincol#10
(byte) findcol::mincol#11
(byte) findcol::mincol#12
(byte) findcol::mincol#13
(byte) findcol::mincol#2
(byte) findcol::mincol#3
(byte) findcol::mincol#4
(byte) findcol::mincol#5
(byte) findcol::mincol#6
(byte) findcol::mincol#7
(byte) findcol::mincol#8
(byte) findcol::mincol#9
(byte) findcol::mindiff
(byte) findcol::mindiff#0
(byte) findcol::mindiff#1
(byte) findcol::mindiff#10
(byte) findcol::mindiff#11
(byte) findcol::mindiff#12
(byte) findcol::mindiff#2
(byte) findcol::mindiff#3
(byte) findcol::mindiff#4
(byte) findcol::mindiff#5
(byte) findcol::mindiff#6
(byte) findcol::mindiff#7
(byte) findcol::mindiff#8
(byte) findcol::mindiff#9
(byte) findcol::return
(byte) findcol::return#0
(byte) findcol::return#1
(byte) findcol::return#2
(byte) findcol::return#3
(byte) findcol::return#4
(byte) findcol::return#5
(byte) findcol::x
(byte) findcol::x#0
(byte) findcol::x#1
(byte) findcol::x#10
(byte) findcol::x#11
(byte) findcol::x#12
(byte) findcol::x#13
(byte) findcol::x#2
(byte) findcol::x#3
(byte) findcol::x#4
(byte) findcol::x#5
(byte) findcol::x#6
(byte) findcol::x#7
(byte) findcol::x#8
(byte) findcol::x#9
(byte) findcol::xp
(byte) findcol::xp#0
(byte) findcol::xp#1
(byte) findcol::xp#2
(byte) findcol::xp#3
(byte) findcol::xp#4
(byte) findcol::y
(byte) findcol::y#0
(byte) findcol::y#1
(byte) findcol::y#10
(byte) findcol::y#11
(byte) findcol::y#12
(byte) findcol::y#13
(byte) findcol::y#2
(byte) findcol::y#3
(byte) findcol::y#4
(byte) findcol::y#5
(byte) findcol::y#6
(byte) findcol::y#7
(byte) findcol::y#8
(byte) findcol::y#9
(byte) findcol::yp
(byte) findcol::yp#0
(byte) findcol::yp#1
(byte) findcol::yp#2
(byte) findcol::yp#3
(byte) findcol::yp#4
(byte) findcol::yp#5
(byte) findcol::yp#6
(byte) findcol::yp#7
(void()) initscreen()
(byte*~) initscreen::$0
(bool~) initscreen::$1
(label) initscreen::@1
(label) initscreen::@2
(label) initscreen::@return
(byte*) initscreen::screen
(byte*) initscreen::screen#0
(byte*) initscreen::screen#1
(byte*) initscreen::screen#2
(byte*) initscreen::screen#3
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return
(const byte) numpoints = (byte) 6
(void()) render()
(byte~) render::$0
(bool~) render::$1
(byte*~) render::$2
(bool~) render::$3
(label) render::@1
(label) render::@2
(label) render::@3
(label) render::@4
(label) render::@return
(byte) render::col
(byte) render::col#0
(byte*) render::colline
(byte*) render::colline#0
(byte*) render::colline#1
(byte*) render::colline#2
(byte*) render::colline#3
(byte*) render::colline#4
(byte*) render::colline#5
(byte) render::x
(byte) render::x#0
(byte) render::x#1
(byte) render::x#2
(byte) render::x#3
(byte) render::y
(byte) render::y#0
(byte) render::y#1
(byte) render::y#2
(byte) render::y#3
(byte) render::y#4
(byte) render::y#5

Adding number conversion cast (unumber) 1 in (number~) animate::$0 ← *((const byte*) XPOS + (number) 0) + (number) 1
Adding number conversion cast (unumber) animate::$0 in (number~) animate::$0 ← *((const byte*) XPOS + (number) 0) + (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (unumber~) animate::$0 ← *((const byte*) XPOS + (number) 0) + (unumber)(number) 1
Adding number conversion cast (unumber) 0 in *((const byte*) XPOS + (number) 0) ← (unumber~) animate::$0
Adding number conversion cast (unumber) $28 in (bool~) animate::$1 ← *((const byte*) XPOS + (number) 0) == (number) $28
Adding number conversion cast (unumber) 0 in (bool~) animate::$1 ← *((const byte*) XPOS + (number) 0) == (unumber)(number) $28
Adding number conversion cast (unumber) 1 in (number~) animate::$3 ← *((const byte*) YPOS + (number) 0) + (number) 1
Adding number conversion cast (unumber) animate::$3 in (number~) animate::$3 ← *((const byte*) YPOS + (number) 0) + (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (unumber~) animate::$3 ← *((const byte*) YPOS + (number) 0) + (unumber)(number) 1
Adding number conversion cast (unumber) 0 in *((const byte*) YPOS + (number) 0) ← (unumber~) animate::$3
Adding number conversion cast (unumber) $19 in (bool~) animate::$4 ← *((const byte*) YPOS + (number) 0) == (number) $19
Adding number conversion cast (unumber) 0 in (bool~) animate::$4 ← *((const byte*) YPOS + (number) 0) == (unumber)(number) $19
Adding number conversion cast (unumber) 0 in *((const byte*) XPOS + (number) 0) ← (number) 0
Adding number conversion cast (unumber) 0 in *((const byte*) XPOS + (number) 0) ← ((unumber)) (number) 0
Adding number conversion cast (unumber) 1 in (number~) animate::$6 ← *((const byte*) XPOS + (number) 1) - (number) 1
Adding number conversion cast (unumber) animate::$6 in (number~) animate::$6 ← *((const byte*) XPOS + (number) 1) - (unumber)(number) 1
Adding number conversion cast (unumber) 1 in (unumber~) animate::$6 ← *((const byte*) XPOS + (number) 1) - (unumber)(number) 1
Adding number conversion cast (unumber) 1 in *((const byte*) XPOS + (number) 1) ← (unumber~) animate::$6
Adding number conversion cast (unumber) $ff in (bool~) animate::$7 ← *((const byte*) XPOS + (number) 1) == (number) $ff
Adding number conversion cast (unumber) 1 in (bool~) animate::$7 ← *((const byte*) XPOS + (number) 1) == (unumber)(number) $ff
Adding number conversion cast (unumber) 0 in *((const byte*) YPOS + (number) 0) ← (number) 0
Adding number conversion cast (unumber) 0 in *((const byte*) YPOS + (number) 0) ← ((unumber)) (number) 0
Adding number conversion cast (unumber) 1 in (number~) animate::$9 ← *((const byte*) YPOS + (number) 2) + (number) 1
Adding number conversion cast (unumber) animate::$9 in (number~) animate::$9 ← *((const byte*) YPOS + (number) 2) + (unumber)(number) 1
Adding number conversion cast (unumber) 2 in (unumber~) animate::$9 ← *((const byte*) YPOS + (number) 2) + (unumber)(number) 1
Adding number conversion cast (unumber) 2 in *((const byte*) YPOS + (number) 2) ← (unumber~) animate::$9
Adding number conversion cast (unumber) $19 in (bool~) animate::$10 ← *((const byte*) YPOS + (number) 2) == (number) $19
Adding number conversion cast (unumber) 2 in (bool~) animate::$10 ← *((const byte*) YPOS + (number) 2) == (unumber)(number) $19
Adding number conversion cast (unumber) $28 in *((const byte*) XPOS + (number) 1) ← (number) $28
Adding number conversion cast (unumber) 1 in *((const byte*) XPOS + (number) 1) ← ((unumber)) (number) $28
Adding number conversion cast (unumber) 1 in (number~) animate::$12 ← *((const byte*) YPOS + (number) 3) - (number) 1
Adding number conversion cast (unumber) animate::$12 in (number~) animate::$12 ← *((const byte*) YPOS + (number) 3) - (unumber)(number) 1
Adding number conversion cast (unumber) 3 in (unumber~) animate::$12 ← *((const byte*) YPOS + (number) 3) - (unumber)(number) 1
Adding number conversion cast (unumber) 3 in *((const byte*) YPOS + (number) 3) ← (unumber~) animate::$12
Adding number conversion cast (unumber) $ff in (bool~) animate::$13 ← *((const byte*) YPOS + (number) 3) == (number) $ff
Adding number conversion cast (unumber) 3 in (bool~) animate::$13 ← *((const byte*) YPOS + (number) 3) == (unumber)(number) $ff
Adding number conversion cast (unumber) 0 in *((const byte*) YPOS + (number) 2) ← (number) 0
Adding number conversion cast (unumber) 2 in *((const byte*) YPOS + (number) 2) ← ((unumber)) (number) 0
Adding number conversion cast (unumber) $19 in *((const byte*) YPOS + (number) 3) ← (number) $19
Adding number conversion cast (unumber) 3 in *((const byte*) YPOS + (number) 3) ← ((unumber)) (number) $19
Adding number conversion cast (unumber) 7 in (number~) animate::$15 ← *((const byte*) XPOS + (number) 3) + (number) 7
Adding number conversion cast (unumber) animate::$15 in (number~) animate::$15 ← *((const byte*) XPOS + (number) 3) + (unumber)(number) 7
Adding number conversion cast (unumber) 3 in (unumber~) animate::$15 ← *((const byte*) XPOS + (number) 3) + (unumber)(number) 7
Adding number conversion cast (unumber) 3 in *((const byte*) XPOS + (number) 3) ← (unumber~) animate::$15
Adding number conversion cast (unumber) $28 in (bool~) animate::$16 ← *((const byte*) XPOS + (number) 3) >= (number) $28
Adding number conversion cast (unumber) 3 in (bool~) animate::$16 ← *((const byte*) XPOS + (number) 3) >= (unumber)(number) $28
Adding number conversion cast (unumber) $28 in (number~) animate::$18 ← *((const byte*) XPOS + (number) 3) - (number) $28
Adding number conversion cast (unumber) animate::$18 in (number~) animate::$18 ← *((const byte*) XPOS + (number) 3) - (unumber)(number) $28
Adding number conversion cast (unumber) 3 in (unumber~) animate::$18 ← *((const byte*) XPOS + (number) 3) - (unumber)(number) $28
Adding number conversion cast (unumber) 3 in *((const byte*) XPOS + (number) 3) ← (unumber~) animate::$18
Adding number conversion cast (unumber) $3e8 in (byte*~) initscreen::$0 ← (const byte*) SCREEN + (number) $3e8
Adding number conversion cast (unumber) $28 in (byte*~) render::$2 ← (byte*) render::colline#3 + (number) $28
Adding number conversion cast (unumber) 0 in (byte) findcol::return#2 ← (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((const byte*) XPOS + (unumber)(number) 0) ← (unumber)(number) 0
Inlining cast *((const byte*) YPOS + (unumber)(number) 0) ← (unumber)(number) 0
Inlining cast *((const byte*) XPOS + (unumber)(number) 1) ← (unumber)(number) $28
Inlining cast *((const byte*) YPOS + (unumber)(number) 2) ← (unumber)(number) 0
Inlining cast *((const byte*) YPOS + (unumber)(number) 3) ← (unumber)(number) $19
Inlining cast (byte) findcol::return#2 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 55296
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $19
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast $19
Simplifying constant integer cast $28
Simplifying constant integer cast 1
Simplifying constant integer cast 3
Simplifying constant integer cast 1
Simplifying constant integer cast 3
Simplifying constant integer cast 3
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $19
Simplifying constant integer cast 3
Simplifying constant integer cast 3
Simplifying constant integer cast 7
Simplifying constant integer cast 3
Simplifying constant integer cast 3
Simplifying constant integer cast $28
Simplifying constant integer cast 3
Simplifying constant integer cast $28
Simplifying constant integer cast 3
Simplifying constant integer cast $3e8
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 3
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) animate::$0 ← *((const byte*) XPOS + (byte) 0) + (byte) 1
Inferred type updated to byte in (unumber~) animate::$3 ← *((const byte*) YPOS + (byte) 0) + (byte) 1
Inferred type updated to byte in (unumber~) animate::$6 ← *((const byte*) XPOS + (byte) 1) - (byte) 1
Inferred type updated to byte in (unumber~) animate::$9 ← *((const byte*) YPOS + (byte) 2) + (byte) 1
Inferred type updated to byte in (unumber~) animate::$12 ← *((const byte*) YPOS + (byte) 3) - (byte) 1
Inferred type updated to byte in (unumber~) animate::$15 ← *((const byte*) XPOS + (byte) 3) + (byte) 7
Inferred type updated to byte in (unumber~) animate::$18 ← *((const byte*) XPOS + (byte) 3) - (byte) $28
Inversing boolean not [8] (bool~) animate::$2 ← *((const byte*) XPOS + (byte) 0) != (byte) $28 from [7] (bool~) animate::$1 ← *((const byte*) XPOS + (byte) 0) == (byte) $28
Inversing boolean not [13] (bool~) animate::$5 ← *((const byte*) YPOS + (byte) 0) != (byte) $19 from [12] (bool~) animate::$4 ← *((const byte*) YPOS + (byte) 0) == (byte) $19
Inversing boolean not [19] (bool~) animate::$8 ← *((const byte*) XPOS + (byte) 1) != (byte) $ff from [18] (bool~) animate::$7 ← *((const byte*) XPOS + (byte) 1) == (byte) $ff
Inversing boolean not [25] (bool~) animate::$11 ← *((const byte*) YPOS + (byte) 2) != (byte) $19 from [24] (bool~) animate::$10 ← *((const byte*) YPOS + (byte) 2) == (byte) $19
Inversing boolean not [31] (bool~) animate::$14 ← *((const byte*) YPOS + (byte) 3) != (byte) $ff from [30] (bool~) animate::$13 ← *((const byte*) YPOS + (byte) 3) == (byte) $ff
Inversing boolean not [38] (bool~) animate::$17 ← *((const byte*) XPOS + (byte) 3) < (byte) $28 from [37] (bool~) animate::$16 ← *((const byte*) XPOS + (byte) 3) >= (byte) $28
Inversing boolean not [86] (bool~) findcol::$2 ← (byte) findcol::x#1 != (byte) findcol::xp#0 from [85] (bool~) findcol::$1 ← (byte) findcol::x#1 == (byte) findcol::xp#0
Inversing boolean not [96] (bool~) findcol::$4 ← (byte) findcol::y#1 != (byte) findcol::yp#1 from [95] (bool~) findcol::$3 ← (byte) findcol::y#1 == (byte) findcol::yp#1
Inversing boolean not [121] (bool~) findcol::$14 ← (byte) findcol::diff#7 >= (byte) findcol::mindiff#2 from [120] (bool~) findcol::$13 ← (byte) findcol::diff#7 < (byte) findcol::mindiff#2
Successful SSA optimization Pass2UnaryNotSimplification
Alias initscreen::screen#2 = initscreen::screen#3 
Alias findcol::return#0 = findcol::return#4 
Alias render::colline#2 = render::colline#4 render::colline#3 
Alias render::x#2 = render::x#3 
Alias render::y#2 = render::y#5 render::y#3 
Alias render::col#0 = render::$0 
Alias render::colline#1 = render::$2 
Alias findcol::i#13 = findcol::i#3 findcol::i#2 
Alias findcol::x#1 = findcol::x#5 findcol::x#6 
Alias findcol::y#1 = findcol::y#5 findcol::y#8 
Alias findcol::mindiff#10 = findcol::mindiff#11 findcol::mindiff#9 
Alias findcol::mincol#12 = findcol::mincol#13 findcol::mincol#3 findcol::mincol#2 findcol::return#1 
Alias findcol::yp#0 = findcol::yp#1 
Alias findcol::xp#0 = findcol::xp#4 
Alias findcol::return#3 = findcol::return#5 
Alias findcol::xp#1 = findcol::xp#2 findcol::xp#3 
Alias findcol::x#2 = findcol::x#3 findcol::x#4 
Alias findcol::y#6 = findcol::y#7 findcol::y#9 
Alias findcol::yp#5 = findcol::yp#6 findcol::yp#7 
Alias findcol::mindiff#6 = findcol::mindiff#7 findcol::mindiff#8 
Alias findcol::i#10 = findcol::i#11 findcol::i#12 
Alias findcol::mincol#10 = findcol::mincol#11 findcol::mincol#9 
Alias findcol::diff#1 = findcol::$7 
Alias findcol::diff#2 = findcol::$6 
Alias findcol::yp#2 = findcol::yp#3 findcol::yp#4 
Alias findcol::y#2 = findcol::y#3 findcol::y#4 
Alias findcol::diff#5 = findcol::diff#9 findcol::diff#6 
Alias findcol::mindiff#3 = findcol::mindiff#4 findcol::mindiff#5 
Alias findcol::i#7 = findcol::i#8 findcol::i#9 
Alias findcol::x#11 = findcol::x#12 findcol::x#13 
Alias findcol::mincol#6 = findcol::mincol#7 findcol::mincol#8 
Alias findcol::diff#3 = findcol::$12 
Alias findcol::diff#4 = findcol::$10 
Alias findcol::diff#7 = findcol::diff#8 findcol::mindiff#1 
Alias findcol::i#5 = findcol::i#6 
Alias findcol::x#10 = findcol::x#9 
Alias findcol::y#12 = findcol::y#13 
Successful SSA optimization Pass2AliasElimination
Alias findcol::x#1 = findcol::x#2 findcol::x#11 findcol::x#10 findcol::x#8 
Alias findcol::xp#0 = findcol::xp#1 
Alias findcol::y#1 = findcol::y#6 findcol::y#2 findcol::y#12 findcol::y#11 
Alias findcol::yp#0 = findcol::yp#5 findcol::yp#2 
Alias findcol::mindiff#10 = findcol::mindiff#6 findcol::mindiff#3 findcol::mindiff#2 
Alias findcol::i#10 = findcol::i#13 findcol::i#7 findcol::i#5 findcol::i#4 
Alias findcol::mincol#10 = findcol::mincol#12 findcol::mincol#6 findcol::mincol#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) render::y#2 (byte) render::y#4
Identical Phi Values (byte*) render::colline#2 (byte*) render::colline#5
Identical Phi Values (byte) findcol::x#7 (byte) findcol::x#0
Identical Phi Values (byte) findcol::y#10 (byte) findcol::y#0
Identical Phi Values (byte) findcol::x#1 (byte) findcol::x#7
Identical Phi Values (byte) findcol::y#1 (byte) findcol::y#10
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) animate::$2 [8] if(*((const byte*) XPOS + (byte) 0)!=(byte) $28) goto animate::@1
Simple Condition (bool~) animate::$5 [12] if(*((const byte*) YPOS + (byte) 0)!=(byte) $19) goto animate::@2
Simple Condition (bool~) animate::$8 [17] if(*((const byte*) XPOS + (byte) 1)!=(byte) $ff) goto animate::@3
Simple Condition (bool~) animate::$11 [22] if(*((const byte*) YPOS + (byte) 2)!=(byte) $19) goto animate::@4
Simple Condition (bool~) animate::$14 [27] if(*((const byte*) YPOS + (byte) 3)!=(byte) $ff) goto animate::@return
Simple Condition (bool~) animate::$17 [33] if(*((const byte*) XPOS + (byte) 3)<(byte) $28) goto animate::@return
Simple Condition (bool~) initscreen::$1 [41] if((byte*) initscreen::screen#2<(byte*~) initscreen::$0) goto initscreen::@2
Simple Condition (bool~) render::$1 [58] if((byte) render::x#1!=rangelast(0,$27)) goto render::@2
Simple Condition (bool~) render::$3 [62] if((byte) render::y#1!=rangelast(0,$18)) goto render::@1
Simple Condition (bool~) findcol::$0 [70] if((byte) findcol::i#10<(const byte) numpoints) goto findcol::@2
Simple Condition (bool~) findcol::$2 [74] if((byte) findcol::x#0!=(byte) findcol::xp#0) goto findcol::@4
Simple Condition (bool~) findcol::$5 [77] if((byte) findcol::x#0<(byte) findcol::xp#0) goto findcol::@5
Simple Condition (bool~) findcol::$4 [79] if((byte) findcol::y#0!=(byte) findcol::yp#0) goto findcol::@4
Simple Condition (bool~) findcol::$8 [87] if((byte) findcol::y#0<(byte) findcol::yp#0) goto findcol::@7
Simple Condition (bool~) findcol::$14 [94] if((byte) findcol::diff#7>=(byte) findcol::mindiff#10) goto findcol::@9
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [39] (byte*~) initscreen::$0 ← (const byte*) SCREEN + (word) $3e8
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) initscreen::screen#0 = SCREEN
Constant (const byte*) initscreen::$0 = SCREEN+$3e8
Constant (const byte*) render::colline#0 = COLORS
Constant (const byte) render::y#0 = 0
Constant (const byte) render::x#0 = 0
Constant (const byte) findcol::mindiff#0 = $ff
Constant (const byte) findcol::mincol#0 = 0
Constant (const byte) findcol::i#0 = 0
Constant (const byte) findcol::diff#0 = 0
Constant (const byte) findcol::return#2 = 0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [3] if(true) goto main::@1
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [56] render::x#1 ← ++ render::x#2 to ++
Resolved ranged comparison value [58] if(render::x#1!=rangelast(0,$27)) goto render::@2 to (number) $28
Resolved ranged next value [60] render::y#1 ← ++ render::y#4 to ++
Resolved ranged comparison value [62] if(render::y#1!=rangelast(0,$18)) goto render::@1 to (number) $19
Simplifying expression containing zero XPOS in [5] (byte~) animate::$0 ← *((const byte*) XPOS + (byte) 0) + (byte) 1
Simplifying expression containing zero XPOS in [6] *((const byte*) XPOS + (byte) 0) ← (byte~) animate::$0
Simplifying expression containing zero XPOS in [8] if(*((const byte*) XPOS + (byte) 0)!=(byte) $28) goto animate::@1
Simplifying expression containing zero YPOS in [9] (byte~) animate::$3 ← *((const byte*) YPOS + (byte) 0) + (byte) 1
Simplifying expression containing zero YPOS in [10] *((const byte*) YPOS + (byte) 0) ← (byte~) animate::$3
Simplifying expression containing zero YPOS in [12] if(*((const byte*) YPOS + (byte) 0)!=(byte) $19) goto animate::@2
Simplifying expression containing zero XPOS in [13] *((const byte*) XPOS + (byte) 0) ← (byte) 0
Simplifying expression containing zero YPOS in [18] *((const byte*) YPOS + (byte) 0) ← (byte) 0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) findcol::diff#0
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) $28 in if((byte) render::x#1!=(number) $28) goto render::@2
Adding number conversion cast (unumber) $19 in if((byte) render::y#1!=(number) $19) goto render::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $28
Simplifying constant integer cast $19
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $19
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings (const byte*) initscreen::screen#0
Inlining constant with var siblings (const byte*) render::colline#0
Inlining constant with var siblings (const byte) render::y#0
Inlining constant with var siblings (const byte) render::x#0
Inlining constant with var siblings (const byte) findcol::mindiff#0
Inlining constant with var siblings (const byte) findcol::mincol#0
Inlining constant with var siblings (const byte) findcol::i#0
Inlining constant with var siblings (const byte) findcol::return#2
Constant inlined findcol::i#0 = (byte) 0
Constant inlined findcol::return#2 = (byte) 0
Constant inlined render::colline#0 = (const byte*) COLORS
Constant inlined render::x#0 = (byte) 0
Constant inlined initscreen::screen#0 = (const byte*) SCREEN
Constant inlined render::y#0 = (byte) 0
Constant inlined findcol::mincol#0 = (byte) 0
Constant inlined findcol::mindiff#0 = (byte) $ff
Constant inlined initscreen::$0 = (const byte*) SCREEN+(word) $3e8
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(XPOS+1)
Consolidated array index constant in *(XPOS+1)
Consolidated array index constant in *(XPOS+1)
Consolidated array index constant in *(YPOS+2)
Consolidated array index constant in *(YPOS+2)
Consolidated array index constant in *(YPOS+2)
Consolidated array index constant in *(XPOS+1)
Consolidated array index constant in *(YPOS+3)
Consolidated array index constant in *(YPOS+3)
Consolidated array index constant in *(YPOS+3)
Consolidated array index constant in *(YPOS+2)
Consolidated array index constant in *(YPOS+3)
Consolidated array index constant in *(XPOS+3)
Consolidated array index constant in *(XPOS+3)
Consolidated array index constant in *(XPOS+3)
Consolidated array index constant in *(XPOS+3)
Consolidated array index constant in *(XPOS+3)
Successful SSA optimization Pass2ConstantAdditionElimination
Added new block during phi lifting render::@5(between render::@3 and render::@1)
Added new block during phi lifting render::@6(between render::@4 and render::@2)
Added new block during phi lifting findcol::@15(between findcol::@8 and findcol::@9)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of render
Adding NOP phi() at start of findcol
Adding NOP phi() at start of findcol::@11
Adding NOP phi() at start of initscreen
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to initscreen:6 render:9 animate:11 
Calls in [render] to findcol:44 

Created 12 initial phi equivalence classes
Coalesced [54] render::y#6 ← render::y#1
Coalesced [55] render::colline#6 ← render::colline#1
Coalesced [56] render::x#4 ← render::x#1
Coalesced [60] findcol::return#6 ← findcol::mincol#10
Coalesced [70] findcol::diff#10 ← findcol::diff#2
Coalesced [75] findcol::diff#12 ← findcol::diff#4
Coalesced [79] findcol::mincol#15 ← findcol::mincol#1
Coalesced [80] findcol::mindiff#14 ← findcol::diff#7
Coalesced [83] findcol::i#14 ← findcol::i#1
Coalesced [84] findcol::mincol#14 ← findcol::mincol#4
Not coalescing [85] findcol::mindiff#13 ← findcol::mindiff#12
Coalesced (already) [86] findcol::mincol#16 ← findcol::mincol#10
Not coalescing [87] findcol::mindiff#15 ← findcol::mindiff#10
Coalesced [90] findcol::diff#13 ← findcol::diff#3
Coalesced [92] findcol::diff#11 ← findcol::diff#1
Coalesced [99] initscreen::screen#4 ← initscreen::screen#1
Coalesced down to 9 phi equivalence classes
Culled Empty Block (label) @2
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@4
Culled Empty Block (label) render::@5
Culled Empty Block (label) render::@6
Culled Empty Block (label) findcol::@3
Culled Empty Block (label) findcol::@11
Renumbering block main::@3 to main::@2
Renumbering block findcol::@4 to findcol::@3
Renumbering block findcol::@5 to findcol::@4
Renumbering block findcol::@6 to findcol::@5
Renumbering block findcol::@7 to findcol::@6
Renumbering block findcol::@8 to findcol::@7
Renumbering block findcol::@9 to findcol::@8
Renumbering block findcol::@10 to findcol::@9
Renumbering block findcol::@12 to findcol::@10
Renumbering block findcol::@13 to findcol::@11
Renumbering block findcol::@14 to findcol::@12
Renumbering block findcol::@15 to findcol::@13
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of render
Adding NOP phi() at start of findcol
Adding NOP phi() at start of initscreen

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  [5] call initscreen 
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [6] phi()
  [7] call render 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] phi()
  [9] call animate 
  to:main::@1

(void()) animate()
animate: scope:[animate]  from main::@2
  [10] (byte~) animate::$0 ← *((const byte*) XPOS) + (byte) 1
  [11] *((const byte*) XPOS) ← (byte~) animate::$0
  [12] if(*((const byte*) XPOS)!=(byte) $28) goto animate::@1
  to:animate::@5
animate::@5: scope:[animate]  from animate
  [13] *((const byte*) XPOS) ← (byte) 0
  to:animate::@1
animate::@1: scope:[animate]  from animate animate::@5
  [14] (byte~) animate::$3 ← *((const byte*) YPOS) + (byte) 1
  [15] *((const byte*) YPOS) ← (byte~) animate::$3
  [16] if(*((const byte*) YPOS)!=(byte) $19) goto animate::@2
  to:animate::@6
animate::@6: scope:[animate]  from animate::@1
  [17] *((const byte*) YPOS) ← (byte) 0
  to:animate::@2
animate::@2: scope:[animate]  from animate::@1 animate::@6
  [18] (byte~) animate::$6 ← *((const byte*) XPOS+(byte) 1) - (byte) 1
  [19] *((const byte*) XPOS+(byte) 1) ← (byte~) animate::$6
  [20] if(*((const byte*) XPOS+(byte) 1)!=(byte) $ff) goto animate::@3
  to:animate::@7
animate::@7: scope:[animate]  from animate::@2
  [21] *((const byte*) XPOS+(byte) 1) ← (byte) $28
  to:animate::@3
animate::@3: scope:[animate]  from animate::@2 animate::@7
  [22] (byte~) animate::$9 ← *((const byte*) YPOS+(byte) 2) + (byte) 1
  [23] *((const byte*) YPOS+(byte) 2) ← (byte~) animate::$9
  [24] if(*((const byte*) YPOS+(byte) 2)!=(byte) $19) goto animate::@4
  to:animate::@8
animate::@8: scope:[animate]  from animate::@3
  [25] *((const byte*) YPOS+(byte) 2) ← (byte) 0
  to:animate::@4
animate::@4: scope:[animate]  from animate::@3 animate::@8
  [26] (byte~) animate::$12 ← *((const byte*) YPOS+(byte) 3) - (byte) 1
  [27] *((const byte*) YPOS+(byte) 3) ← (byte~) animate::$12
  [28] if(*((const byte*) YPOS+(byte) 3)!=(byte) $ff) goto animate::@return
  to:animate::@9
animate::@9: scope:[animate]  from animate::@4
  [29] *((const byte*) YPOS+(byte) 3) ← (byte) $19
  [30] (byte~) animate::$15 ← *((const byte*) XPOS+(byte) 3) + (byte) 7
  [31] *((const byte*) XPOS+(byte) 3) ← (byte~) animate::$15
  [32] if(*((const byte*) XPOS+(byte) 3)<(byte) $28) goto animate::@return
  to:animate::@10
animate::@10: scope:[animate]  from animate::@9
  [33] (byte~) animate::$18 ← *((const byte*) XPOS+(byte) 3) - (byte) $28
  [34] *((const byte*) XPOS+(byte) 3) ← (byte~) animate::$18
  to:animate::@return
animate::@return: scope:[animate]  from animate::@10 animate::@4 animate::@9
  [35] return 
  to:@return

(void()) render()
render: scope:[render]  from main::@1
  [36] phi()
  to:render::@1
render::@1: scope:[render]  from render render::@3
  [37] (byte*) render::colline#5 ← phi( render/(const byte*) COLORS render::@3/(byte*) render::colline#1 )
  [37] (byte) render::y#4 ← phi( render/(byte) 0 render::@3/(byte) render::y#1 )
  to:render::@2
render::@2: scope:[render]  from render::@1 render::@4
  [38] (byte) render::x#2 ← phi( render::@1/(byte) 0 render::@4/(byte) render::x#1 )
  [39] (byte) findcol::x#0 ← (byte) render::x#2
  [40] (byte) findcol::y#0 ← (byte) render::y#4
  [41] call findcol 
  [42] (byte) findcol::return#0 ← (byte) findcol::return#3
  to:render::@4
render::@4: scope:[render]  from render::@2
  [43] (byte) render::col#0 ← (byte) findcol::return#0
  [44] *((byte*) render::colline#5 + (byte) render::x#2) ← (byte) render::col#0
  [45] (byte) render::x#1 ← ++ (byte) render::x#2
  [46] if((byte) render::x#1!=(byte) $28) goto render::@2
  to:render::@3
render::@3: scope:[render]  from render::@4
  [47] (byte*) render::colline#1 ← (byte*) render::colline#5 + (byte) $28
  [48] (byte) render::y#1 ← ++ (byte) render::y#4
  [49] if((byte) render::y#1!=(byte) $19) goto render::@1
  to:render::@return
render::@return: scope:[render]  from render::@3
  [50] return 
  to:@return

(byte()) findcol((byte) findcol::x , (byte) findcol::y)
findcol: scope:[findcol]  from render::@2
  [51] phi()
  to:findcol::@1
findcol::@1: scope:[findcol]  from findcol findcol::@8
  [52] (byte) findcol::mindiff#10 ← phi( findcol/(byte) $ff findcol::@8/(byte) findcol::mindiff#13 )
  [52] (byte) findcol::mincol#10 ← phi( findcol/(byte) 0 findcol::@8/(byte) findcol::mincol#4 )
  [52] (byte) findcol::i#10 ← phi( findcol/(byte) 0 findcol::@8/(byte) findcol::i#1 )
  [53] if((byte) findcol::i#10<(const byte) numpoints) goto findcol::@2
  to:findcol::@return
findcol::@return: scope:[findcol]  from findcol::@1 findcol::@9
  [54] (byte) findcol::return#3 ← phi( findcol::@9/(byte) 0 findcol::@1/(byte) findcol::mincol#10 )
  [55] return 
  to:@return
findcol::@2: scope:[findcol]  from findcol::@1
  [56] (byte) findcol::xp#0 ← *((const byte*) XPOS + (byte) findcol::i#10)
  [57] (byte) findcol::yp#0 ← *((const byte*) YPOS + (byte) findcol::i#10)
  [58] if((byte) findcol::x#0!=(byte) findcol::xp#0) goto findcol::@3
  to:findcol::@9
findcol::@9: scope:[findcol]  from findcol::@2
  [59] if((byte) findcol::y#0!=(byte) findcol::yp#0) goto findcol::@3
  to:findcol::@return
findcol::@3: scope:[findcol]  from findcol::@2 findcol::@9
  [60] if((byte) findcol::x#0<(byte) findcol::xp#0) goto findcol::@4
  to:findcol::@10
findcol::@10: scope:[findcol]  from findcol::@3
  [61] (byte) findcol::diff#2 ← (byte) findcol::x#0 - (byte) findcol::xp#0
  to:findcol::@5
findcol::@5: scope:[findcol]  from findcol::@10 findcol::@4
  [62] (byte) findcol::diff#5 ← phi( findcol::@10/(byte) findcol::diff#2 findcol::@4/(byte) findcol::diff#1 )
  [63] if((byte) findcol::y#0<(byte) findcol::yp#0) goto findcol::@6
  to:findcol::@11
findcol::@11: scope:[findcol]  from findcol::@5
  [64] (byte~) findcol::$9 ← (byte) findcol::y#0 - (byte) findcol::yp#0
  [65] (byte) findcol::diff#4 ← (byte) findcol::diff#5 + (byte~) findcol::$9
  to:findcol::@7
findcol::@7: scope:[findcol]  from findcol::@11 findcol::@6
  [66] (byte) findcol::diff#7 ← phi( findcol::@11/(byte) findcol::diff#4 findcol::@6/(byte) findcol::diff#3 )
  [67] if((byte) findcol::diff#7>=(byte) findcol::mindiff#10) goto findcol::@13
  to:findcol::@12
findcol::@12: scope:[findcol]  from findcol::@7
  [68] (byte) findcol::mincol#1 ← *((const byte*) COLS + (byte) findcol::i#10)
  to:findcol::@8
findcol::@8: scope:[findcol]  from findcol::@12 findcol::@13
  [69] (byte) findcol::mindiff#12 ← phi( findcol::@12/(byte) findcol::diff#7 findcol::@13/(byte) findcol::mindiff#15 )
  [69] (byte) findcol::mincol#4 ← phi( findcol::@12/(byte) findcol::mincol#1 findcol::@13/(byte) findcol::mincol#10 )
  [70] (byte) findcol::i#1 ← ++ (byte) findcol::i#10
  [71] (byte) findcol::mindiff#13 ← (byte) findcol::mindiff#12
  to:findcol::@1
findcol::@13: scope:[findcol]  from findcol::@7
  [72] (byte) findcol::mindiff#15 ← (byte) findcol::mindiff#10
  to:findcol::@8
findcol::@6: scope:[findcol]  from findcol::@5
  [73] (byte~) findcol::$11 ← (byte) findcol::yp#0 - (byte) findcol::y#0
  [74] (byte) findcol::diff#3 ← (byte) findcol::diff#5 + (byte~) findcol::$11
  to:findcol::@7
findcol::@4: scope:[findcol]  from findcol::@3
  [75] (byte) findcol::diff#1 ← (byte) findcol::xp#0 - (byte) findcol::x#0
  to:findcol::@5

(void()) initscreen()
initscreen: scope:[initscreen]  from main
  [76] phi()
  to:initscreen::@1
initscreen::@1: scope:[initscreen]  from initscreen initscreen::@2
  [77] (byte*) initscreen::screen#2 ← phi( initscreen/(const byte*) SCREEN initscreen::@2/(byte*) initscreen::screen#1 )
  [78] if((byte*) initscreen::screen#2<(const byte*) SCREEN+(word) $3e8) goto initscreen::@2
  to:initscreen::@return
initscreen::@return: scope:[initscreen]  from initscreen::@1
  [79] return 
  to:@return
initscreen::@2: scope:[initscreen]  from initscreen::@1
  [80] *((byte*) initscreen::screen#2) ← (const byte) FILL
  [81] (byte*) initscreen::screen#1 ← ++ (byte*) initscreen::screen#2
  to:initscreen::@1


VARIABLE REGISTER WEIGHTS
(void()) animate()
(byte~) animate::$0 2002.0
(byte~) animate::$12 2002.0
(byte~) animate::$15 2002.0
(byte~) animate::$18 2002.0
(byte~) animate::$3 2002.0
(byte~) animate::$6 2002.0
(byte~) animate::$9 2002.0
(byte()) findcol((byte) findcol::x , (byte) findcol::y)
(byte~) findcol::$11 2.00000000002E11
(byte~) findcol::$9 2.00000000002E11
(byte) findcol::diff
(byte) findcol::diff#1 2.00000000002E11
(byte) findcol::diff#2 2.00000000002E11
(byte) findcol::diff#3 2.00000000002E11
(byte) findcol::diff#4 2.00000000002E11
(byte) findcol::diff#5 1.00000000001E11
(byte) findcol::diff#7 1.3333333333466667E11
(byte) findcol::i
(byte) findcol::i#1 1.00000000001E11
(byte) findcol::i#10 3.00000000003E10
(byte) findcol::mincol
(byte) findcol::mincol#1 2.00000000002E11
(byte) findcol::mincol#10 1.6666666666833332E10
(byte) findcol::mincol#4 1.00000000001E11
(byte) findcol::mindiff
(byte) findcol::mindiff#10 1.7647058823705883E10
(byte) findcol::mindiff#12 1.500000000015E11
(byte) findcol::mindiff#13 2.00000000002E11
(byte) findcol::mindiff#15 2.00000000002E11
(byte) findcol::return
(byte) findcol::return#0 2000002.0
(byte) findcol::return#3 3.3333666667333336E10
(byte) findcol::x
(byte) findcol::x#0 1.60000400002E10
(byte) findcol::xp
(byte) findcol::xp#0 1.00000000001E11
(byte) findcol::y
(byte) findcol::y#0 1.6666708333541668E10
(byte) findcol::yp
(byte) findcol::yp#0 6.2500000000625E10
(void()) initscreen()
(byte*) initscreen::screen
(byte*) initscreen::screen#1 2002.0
(byte*) initscreen::screen#2 1334.6666666666667
(void()) main()
(void()) render()
(byte) render::col
(byte) render::col#0 2000002.0
(byte*) render::colline
(byte*) render::colline#1 66667.33333333333
(byte*) render::colline#5 120000.30000000002
(byte) render::x
(byte) render::x#1 1500001.5
(byte) render::x#2 571429.1428571428
(byte) render::y
(byte) render::y#1 150001.5
(byte) render::y#4 109091.18181818182

Initial phi equivalence classes
[ render::y#4 render::y#1 ]
[ render::colline#5 render::colline#1 ]
[ render::x#2 render::x#1 ]
[ findcol::i#10 findcol::i#1 ]
[ findcol::mindiff#10 findcol::mindiff#13 ]
[ findcol::return#3 findcol::mincol#10 findcol::mincol#4 findcol::mincol#1 ]
[ findcol::diff#5 findcol::diff#2 findcol::diff#1 ]
[ findcol::mindiff#12 findcol::diff#7 findcol::diff#4 findcol::diff#3 findcol::mindiff#15 ]
[ initscreen::screen#2 initscreen::screen#1 ]
Added variable animate::$0 to live range equivalence class [ animate::$0 ]
Added variable animate::$3 to live range equivalence class [ animate::$3 ]
Added variable animate::$6 to live range equivalence class [ animate::$6 ]
Added variable animate::$9 to live range equivalence class [ animate::$9 ]
Added variable animate::$12 to live range equivalence class [ animate::$12 ]
Added variable animate::$15 to live range equivalence class [ animate::$15 ]
Added variable animate::$18 to live range equivalence class [ animate::$18 ]
Added variable findcol::x#0 to live range equivalence class [ findcol::x#0 ]
Added variable findcol::y#0 to live range equivalence class [ findcol::y#0 ]
Added variable findcol::return#0 to live range equivalence class [ findcol::return#0 ]
Added variable render::col#0 to live range equivalence class [ render::col#0 ]
Added variable findcol::xp#0 to live range equivalence class [ findcol::xp#0 ]
Added variable findcol::yp#0 to live range equivalence class [ findcol::yp#0 ]
Added variable findcol::$9 to live range equivalence class [ findcol::$9 ]
Added variable findcol::$11 to live range equivalence class [ findcol::$11 ]
Complete equivalence classes
[ render::y#4 render::y#1 ]
[ render::colline#5 render::colline#1 ]
[ render::x#2 render::x#1 ]
[ findcol::i#10 findcol::i#1 ]
[ findcol::mindiff#10 findcol::mindiff#13 ]
[ findcol::return#3 findcol::mincol#10 findcol::mincol#4 findcol::mincol#1 ]
[ findcol::diff#5 findcol::diff#2 findcol::diff#1 ]
[ findcol::mindiff#12 findcol::diff#7 findcol::diff#4 findcol::diff#3 findcol::mindiff#15 ]
[ initscreen::screen#2 initscreen::screen#1 ]
[ animate::$0 ]
[ animate::$3 ]
[ animate::$6 ]
[ animate::$9 ]
[ animate::$12 ]
[ animate::$15 ]
[ animate::$18 ]
[ findcol::x#0 ]
[ findcol::y#0 ]
[ findcol::return#0 ]
[ render::col#0 ]
[ findcol::xp#0 ]
[ findcol::yp#0 ]
[ findcol::$9 ]
[ findcol::$11 ]
Allocated zp[1]:2 [ render::y#4 render::y#1 ]
Allocated zp[2]:3 [ render::colline#5 render::colline#1 ]
Allocated zp[1]:5 [ render::x#2 render::x#1 ]
Allocated zp[1]:6 [ findcol::i#10 findcol::i#1 ]
Allocated zp[1]:7 [ findcol::mindiff#10 findcol::mindiff#13 ]
Allocated zp[1]:8 [ findcol::return#3 findcol::mincol#10 findcol::mincol#4 findcol::mincol#1 ]
Allocated zp[1]:9 [ findcol::diff#5 findcol::diff#2 findcol::diff#1 ]
Allocated zp[1]:10 [ findcol::mindiff#12 findcol::diff#7 findcol::diff#4 findcol::diff#3 findcol::mindiff#15 ]
Allocated zp[2]:11 [ initscreen::screen#2 initscreen::screen#1 ]
Allocated zp[1]:13 [ animate::$0 ]
Allocated zp[1]:14 [ animate::$3 ]
Allocated zp[1]:15 [ animate::$6 ]
Allocated zp[1]:16 [ animate::$9 ]
Allocated zp[1]:17 [ animate::$12 ]
Allocated zp[1]:18 [ animate::$15 ]
Allocated zp[1]:19 [ animate::$18 ]
Allocated zp[1]:20 [ findcol::x#0 ]
Allocated zp[1]:21 [ findcol::y#0 ]
Allocated zp[1]:22 [ findcol::return#0 ]
Allocated zp[1]:23 [ render::col#0 ]
Allocated zp[1]:24 [ findcol::xp#0 ]
Allocated zp[1]:25 [ findcol::yp#0 ]
Allocated zp[1]:26 [ findcol::$9 ]
Allocated zp[1]:27 [ findcol::$11 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// The screen
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .const FILL = $e6
  // The total number of voronoi points
  .const numpoints = 6
  .label SCREEN = $400
  .label COLORS = $d800
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // [5] call initscreen 
    // [76] phi from main to initscreen [phi:main->initscreen]
  initscreen_from_main:
    jsr initscreen
    // [6] phi from main main::@2 to main::@1 [phi:main/main::@2->main::@1]
  __b1_from_main:
  __b1_from___b2:
    jmp __b1
    // main::@1
  __b1:
    // [7] call render 
    // [36] phi from main::@1 to render [phi:main::@1->render]
  render_from___b1:
    jsr render
    // [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [9] call animate 
    jsr animate
    jmp __b1_from___b2
}
  // animate
animate: {
    .label __0 = $d
    .label __3 = $e
    .label __6 = $f
    .label __9 = $10
    .label __12 = $11
    .label __15 = $12
    .label __18 = $13
    // [10] (byte~) animate::$0 ← *((const byte*) XPOS) + (byte) 1 -- vbuz1=_deref_pbuc1_plus_1 
    ldy XPOS
    iny
    sty.z __0
    // [11] *((const byte*) XPOS) ← (byte~) animate::$0 -- _deref_pbuc1=vbuz1 
    lda.z __0
    sta XPOS
    // [12] if(*((const byte*) XPOS)!=(byte) $28) goto animate::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$28
    cmp XPOS
    bne __b1
    jmp __b5
    // animate::@5
  __b5:
    // [13] *((const byte*) XPOS) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta XPOS
    jmp __b1
    // animate::@1
  __b1:
    // [14] (byte~) animate::$3 ← *((const byte*) YPOS) + (byte) 1 -- vbuz1=_deref_pbuc1_plus_1 
    ldy YPOS
    iny
    sty.z __3
    // [15] *((const byte*) YPOS) ← (byte~) animate::$3 -- _deref_pbuc1=vbuz1 
    lda.z __3
    sta YPOS
    // [16] if(*((const byte*) YPOS)!=(byte) $19) goto animate::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$19
    cmp YPOS
    bne __b2
    jmp __b6
    // animate::@6
  __b6:
    // [17] *((const byte*) YPOS) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta YPOS
    jmp __b2
    // animate::@2
  __b2:
    // [18] (byte~) animate::$6 ← *((const byte*) XPOS+(byte) 1) - (byte) 1 -- vbuz1=_deref_pbuc1_minus_1 
    ldx XPOS+1
    dex
    stx.z __6
    // [19] *((const byte*) XPOS+(byte) 1) ← (byte~) animate::$6 -- _deref_pbuc1=vbuz1 
    lda.z __6
    sta XPOS+1
    // [20] if(*((const byte*) XPOS+(byte) 1)!=(byte) $ff) goto animate::@3 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp XPOS+1
    bne __b3
    jmp __b7
    // animate::@7
  __b7:
    // [21] *((const byte*) XPOS+(byte) 1) ← (byte) $28 -- _deref_pbuc1=vbuc2 
    lda #$28
    sta XPOS+1
    jmp __b3
    // animate::@3
  __b3:
    // [22] (byte~) animate::$9 ← *((const byte*) YPOS+(byte) 2) + (byte) 1 -- vbuz1=_deref_pbuc1_plus_1 
    ldy YPOS+2
    iny
    sty.z __9
    // [23] *((const byte*) YPOS+(byte) 2) ← (byte~) animate::$9 -- _deref_pbuc1=vbuz1 
    lda.z __9
    sta YPOS+2
    // [24] if(*((const byte*) YPOS+(byte) 2)!=(byte) $19) goto animate::@4 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$19
    cmp YPOS+2
    bne __b4
    jmp __b8
    // animate::@8
  __b8:
    // [25] *((const byte*) YPOS+(byte) 2) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta YPOS+2
    jmp __b4
    // animate::@4
  __b4:
    // [26] (byte~) animate::$12 ← *((const byte*) YPOS+(byte) 3) - (byte) 1 -- vbuz1=_deref_pbuc1_minus_1 
    ldx YPOS+3
    dex
    stx.z __12
    // [27] *((const byte*) YPOS+(byte) 3) ← (byte~) animate::$12 -- _deref_pbuc1=vbuz1 
    lda.z __12
    sta YPOS+3
    // [28] if(*((const byte*) YPOS+(byte) 3)!=(byte) $ff) goto animate::@return -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp YPOS+3
    bne __breturn
    jmp __b9
    // animate::@9
  __b9:
    // [29] *((const byte*) YPOS+(byte) 3) ← (byte) $19 -- _deref_pbuc1=vbuc2 
    lda #$19
    sta YPOS+3
    // [30] (byte~) animate::$15 ← *((const byte*) XPOS+(byte) 3) + (byte) 7 -- vbuz1=_deref_pbuc1_plus_vbuc2 
    lda #7
    clc
    adc XPOS+3
    sta.z __15
    // [31] *((const byte*) XPOS+(byte) 3) ← (byte~) animate::$15 -- _deref_pbuc1=vbuz1 
    lda.z __15
    sta XPOS+3
    // [32] if(*((const byte*) XPOS+(byte) 3)<(byte) $28) goto animate::@return -- _deref_pbuc1_lt_vbuc2_then_la1 
    lda XPOS+3
    cmp #$28
    bcc __breturn
    jmp __b10
    // animate::@10
  __b10:
    // [33] (byte~) animate::$18 ← *((const byte*) XPOS+(byte) 3) - (byte) $28 -- vbuz1=_deref_pbuc1_minus_vbuc2 
    lda XPOS+3
    sec
    sbc #$28
    sta.z __18
    // [34] *((const byte*) XPOS+(byte) 3) ← (byte~) animate::$18 -- _deref_pbuc1=vbuz1 
    lda.z __18
    sta XPOS+3
    jmp __breturn
    // animate::@return
  __breturn:
    // [35] return 
    rts
}
  // render
render: {
    .label col = $17
    .label x = 5
    .label colline = 3
    .label y = 2
    // [37] phi from render to render::@1 [phi:render->render::@1]
  __b1_from_render:
    // [37] phi (byte*) render::colline#5 = (const byte*) COLORS [phi:render->render::@1#0] -- pbuz1=pbuc1 
    lda #<COLORS
    sta.z colline
    lda #>COLORS
    sta.z colline+1
    // [37] phi (byte) render::y#4 = (byte) 0 [phi:render->render::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp __b1
    // [37] phi from render::@3 to render::@1 [phi:render::@3->render::@1]
  __b1_from___b3:
    // [37] phi (byte*) render::colline#5 = (byte*) render::colline#1 [phi:render::@3->render::@1#0] -- register_copy 
    // [37] phi (byte) render::y#4 = (byte) render::y#1 [phi:render::@3->render::@1#1] -- register_copy 
    jmp __b1
    // render::@1
  __b1:
    // [38] phi from render::@1 to render::@2 [phi:render::@1->render::@2]
  __b2_from___b1:
    // [38] phi (byte) render::x#2 = (byte) 0 [phi:render::@1->render::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    jmp __b2
    // [38] phi from render::@4 to render::@2 [phi:render::@4->render::@2]
  __b2_from___b4:
    // [38] phi (byte) render::x#2 = (byte) render::x#1 [phi:render::@4->render::@2#0] -- register_copy 
    jmp __b2
    // render::@2
  __b2:
    // [39] (byte) findcol::x#0 ← (byte) render::x#2 -- vbuz1=vbuz2 
    lda.z x
    sta.z findcol.x
    // [40] (byte) findcol::y#0 ← (byte) render::y#4 -- vbuz1=vbuz2 
    lda.z y
    sta.z findcol.y
    // [41] call findcol 
    // [51] phi from render::@2 to findcol [phi:render::@2->findcol]
  findcol_from___b2:
    jsr findcol
    // [42] (byte) findcol::return#0 ← (byte) findcol::return#3 -- vbuz1=vbuz2 
    lda.z findcol.return_1
    sta.z findcol.return
    jmp __b4
    // render::@4
  __b4:
    // [43] (byte) render::col#0 ← (byte) findcol::return#0 -- vbuz1=vbuz2 
    lda.z findcol.return
    sta.z col
    // [44] *((byte*) render::colline#5 + (byte) render::x#2) ← (byte) render::col#0 -- pbuz1_derefidx_vbuz2=vbuz3 
    lda.z col
    ldy.z x
    sta (colline),y
    // [45] (byte) render::x#1 ← ++ (byte) render::x#2 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [46] if((byte) render::x#1!=(byte) $28) goto render::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp.z x
    bne __b2_from___b4
    jmp __b3
    // render::@3
  __b3:
    // [47] (byte*) render::colline#1 ← (byte*) render::colline#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z colline
    sta.z colline
    bcc !+
    inc.z colline+1
  !:
    // [48] (byte) render::y#1 ← ++ (byte) render::y#4 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [49] if((byte) render::y#1!=(byte) $19) goto render::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b1_from___b3
    jmp __breturn
    // render::@return
  __breturn:
    // [50] return 
    rts
}
  // findcol
// findcol(byte zp($14) x, byte zp($15) y)
findcol: {
    .label __9 = $1a
    .label __11 = $1b
    .label x = $14
    .label y = $15
    .label return = $16
    .label xp = $18
    .label yp = $19
    .label return_1 = 8
    .label diff = 9
    .label diff_1 = $a
    .label i = 6
    .label mincol = 8
    .label mindiff = 7
    .label mindiff_1 = $a
    // [52] phi from findcol to findcol::@1 [phi:findcol->findcol::@1]
  __b1_from_findcol:
    // [52] phi (byte) findcol::mindiff#10 = (byte) $ff [phi:findcol->findcol::@1#0] -- vbuz1=vbuc1 
    lda #$ff
    sta.z mindiff
    // [52] phi (byte) findcol::mincol#10 = (byte) 0 [phi:findcol->findcol::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z mincol
    // [52] phi (byte) findcol::i#10 = (byte) 0 [phi:findcol->findcol::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // findcol::@1
  __b1:
    // [53] if((byte) findcol::i#10<(const byte) numpoints) goto findcol::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #numpoints
    bcc __b2
    // [54] phi from findcol::@1 to findcol::@return [phi:findcol::@1->findcol::@return]
  __breturn_from___b1:
    // [54] phi (byte) findcol::return#3 = (byte) findcol::mincol#10 [phi:findcol::@1->findcol::@return#0] -- register_copy 
    jmp __breturn
    // findcol::@return
  __breturn:
    // [55] return 
    rts
    // findcol::@2
  __b2:
    // [56] (byte) findcol::xp#0 ← *((const byte*) XPOS + (byte) findcol::i#10) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z i
    lda XPOS,y
    sta.z xp
    // [57] (byte) findcol::yp#0 ← *((const byte*) YPOS + (byte) findcol::i#10) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z i
    lda YPOS,y
    sta.z yp
    // [58] if((byte) findcol::x#0!=(byte) findcol::xp#0) goto findcol::@3 -- vbuz1_neq_vbuz2_then_la1 
    lda.z x
    cmp.z xp
    bne __b3
    jmp __b9
    // findcol::@9
  __b9:
    // [59] if((byte) findcol::y#0!=(byte) findcol::yp#0) goto findcol::@3 -- vbuz1_neq_vbuz2_then_la1 
    lda.z y
    cmp.z yp
    bne __b3
    // [54] phi from findcol::@9 to findcol::@return [phi:findcol::@9->findcol::@return]
  __breturn_from___b9:
    // [54] phi (byte) findcol::return#3 = (byte) 0 [phi:findcol::@9->findcol::@return#0] -- vbuz1=vbuc1 
    lda #0
    sta.z return_1
    jmp __breturn
    // findcol::@3
  __b3:
    // [60] if((byte) findcol::x#0<(byte) findcol::xp#0) goto findcol::@4 -- vbuz1_lt_vbuz2_then_la1 
    lda.z x
    cmp.z xp
    bcc __b4
    jmp __b10
    // findcol::@10
  __b10:
    // [61] (byte) findcol::diff#2 ← (byte) findcol::x#0 - (byte) findcol::xp#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z x
    sec
    sbc.z xp
    sta.z diff
    // [62] phi from findcol::@10 findcol::@4 to findcol::@5 [phi:findcol::@10/findcol::@4->findcol::@5]
  __b5_from___b10:
  __b5_from___b4:
    // [62] phi (byte) findcol::diff#5 = (byte) findcol::diff#2 [phi:findcol::@10/findcol::@4->findcol::@5#0] -- register_copy 
    jmp __b5
    // findcol::@5
  __b5:
    // [63] if((byte) findcol::y#0<(byte) findcol::yp#0) goto findcol::@6 -- vbuz1_lt_vbuz2_then_la1 
    lda.z y
    cmp.z yp
    bcc __b6
    jmp __b11
    // findcol::@11
  __b11:
    // [64] (byte~) findcol::$9 ← (byte) findcol::y#0 - (byte) findcol::yp#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z y
    sec
    sbc.z yp
    sta.z __9
    // [65] (byte) findcol::diff#4 ← (byte) findcol::diff#5 + (byte~) findcol::$9 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z diff
    clc
    adc.z __9
    sta.z diff_1
    // [66] phi from findcol::@11 findcol::@6 to findcol::@7 [phi:findcol::@11/findcol::@6->findcol::@7]
  __b7_from___b11:
  __b7_from___b6:
    // [66] phi (byte) findcol::diff#7 = (byte) findcol::diff#4 [phi:findcol::@11/findcol::@6->findcol::@7#0] -- register_copy 
    jmp __b7
    // findcol::@7
  __b7:
    // [67] if((byte) findcol::diff#7>=(byte) findcol::mindiff#10) goto findcol::@13 -- vbuz1_ge_vbuz2_then_la1 
    lda.z diff_1
    cmp.z mindiff
    bcs __b13
    jmp __b12
    // findcol::@12
  __b12:
    // [68] (byte) findcol::mincol#1 ← *((const byte*) COLS + (byte) findcol::i#10) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z i
    lda COLS,y
    sta.z mincol
    // [69] phi from findcol::@12 findcol::@13 to findcol::@8 [phi:findcol::@12/findcol::@13->findcol::@8]
  __b8_from___b12:
  __b8_from___b13:
    // [69] phi (byte) findcol::mindiff#12 = (byte) findcol::diff#7 [phi:findcol::@12/findcol::@13->findcol::@8#0] -- register_copy 
    // [69] phi (byte) findcol::mincol#4 = (byte) findcol::mincol#1 [phi:findcol::@12/findcol::@13->findcol::@8#1] -- register_copy 
    jmp __b8
    // findcol::@8
  __b8:
    // [70] (byte) findcol::i#1 ← ++ (byte) findcol::i#10 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [71] (byte) findcol::mindiff#13 ← (byte) findcol::mindiff#12 -- vbuz1=vbuz2 
    lda.z mindiff_1
    sta.z mindiff
    // [52] phi from findcol::@8 to findcol::@1 [phi:findcol::@8->findcol::@1]
  __b1_from___b8:
    // [52] phi (byte) findcol::mindiff#10 = (byte) findcol::mindiff#13 [phi:findcol::@8->findcol::@1#0] -- register_copy 
    // [52] phi (byte) findcol::mincol#10 = (byte) findcol::mincol#4 [phi:findcol::@8->findcol::@1#1] -- register_copy 
    // [52] phi (byte) findcol::i#10 = (byte) findcol::i#1 [phi:findcol::@8->findcol::@1#2] -- register_copy 
    jmp __b1
    // findcol::@13
  __b13:
    // [72] (byte) findcol::mindiff#15 ← (byte) findcol::mindiff#10 -- vbuz1=vbuz2 
    lda.z mindiff
    sta.z mindiff_1
    jmp __b8_from___b13
    // findcol::@6
  __b6:
    // [73] (byte~) findcol::$11 ← (byte) findcol::yp#0 - (byte) findcol::y#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z yp
    sec
    sbc.z y
    sta.z __11
    // [74] (byte) findcol::diff#3 ← (byte) findcol::diff#5 + (byte~) findcol::$11 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z diff
    clc
    adc.z __11
    sta.z diff_1
    jmp __b7_from___b6
    // findcol::@4
  __b4:
    // [75] (byte) findcol::diff#1 ← (byte) findcol::xp#0 - (byte) findcol::x#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z xp
    sec
    sbc.z x
    sta.z diff
    jmp __b5_from___b4
}
  // initscreen
initscreen: {
    .label screen = $b
    // [77] phi from initscreen to initscreen::@1 [phi:initscreen->initscreen::@1]
  __b1_from_initscreen:
    // [77] phi (byte*) initscreen::screen#2 = (const byte*) SCREEN [phi:initscreen->initscreen::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z screen
    lda #>SCREEN
    sta.z screen+1
    jmp __b1
    // initscreen::@1
  __b1:
    // [78] if((byte*) initscreen::screen#2<(const byte*) SCREEN+(word) $3e8) goto initscreen::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z screen+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z screen
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    jmp __breturn
    // initscreen::@return
  __breturn:
    // [79] return 
    rts
    // initscreen::@2
  __b2:
    // [80] *((byte*) initscreen::screen#2) ← (const byte) FILL -- _deref_pbuz1=vbuc1 
    lda #FILL
    ldy #0
    sta (screen),y
    // [81] (byte*) initscreen::screen#1 ← ++ (byte*) initscreen::screen#2 -- pbuz1=_inc_pbuz1 
    inc.z screen
    bne !+
    inc.z screen+1
  !:
    // [77] phi from initscreen::@2 to initscreen::@1 [phi:initscreen::@2->initscreen::@1]
  __b1_from___b2:
    // [77] phi (byte*) initscreen::screen#2 = (byte*) initscreen::screen#1 [phi:initscreen::@2->initscreen::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
  // Points to create the Voronoi from
  XPOS: .byte 5, $f, 6, $22, $15, $1f
  YPOS: .byte 5, 8, $e, 2, $11, $16
  COLS: .byte 1, 2, 3, 4, 5, 7

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [12] if(*((const byte*) XPOS)!=(byte) $28) goto animate::@1 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [13] *((const byte*) XPOS) ← (byte) 0 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [16] if(*((const byte*) YPOS)!=(byte) $19) goto animate::@2 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [17] *((const byte*) YPOS) ← (byte) 0 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [20] if(*((const byte*) XPOS+(byte) 1)!=(byte) $ff) goto animate::@3 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [21] *((const byte*) XPOS+(byte) 1) ← (byte) $28 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [24] if(*((const byte*) YPOS+(byte) 2)!=(byte) $19) goto animate::@4 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [25] *((const byte*) YPOS+(byte) 2) ← (byte) 0 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [28] if(*((const byte*) YPOS+(byte) 3)!=(byte) $ff) goto animate::@return [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [29] *((const byte*) YPOS+(byte) 3) ← (byte) $19 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [30] (byte~) animate::$15 ← *((const byte*) XPOS+(byte) 3) + (byte) 7 [ animate::$15 ] ( main:2::animate:9 [ animate::$15 ] { }  ) always clobbers reg byte a 
Statement [32] if(*((const byte*) XPOS+(byte) 3)<(byte) $28) goto animate::@return [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [33] (byte~) animate::$18 ← *((const byte*) XPOS+(byte) 3) - (byte) $28 [ animate::$18 ] ( main:2::animate:9 [ animate::$18 ] { }  ) always clobbers reg byte a 
Statement [47] (byte*) render::colline#1 ← (byte*) render::colline#5 + (byte) $28 [ render::y#4 render::colline#1 ] ( main:2::render:7 [ render::y#4 render::colline#1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ render::y#4 render::y#1 ]
Statement [61] (byte) findcol::diff#2 ← (byte) findcol::x#0 - (byte) findcol::xp#0 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::yp#0 findcol::diff#2 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::yp#0 findcol::diff#2 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ render::x#2 render::x#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:20 [ findcol::x#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:21 [ findcol::y#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ findcol::i#10 findcol::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:8 [ findcol::return#3 findcol::mincol#10 findcol::mincol#4 findcol::mincol#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ findcol::mindiff#10 findcol::mindiff#13 ]
Removing always clobbered register reg byte a as potential for zp[1]:25 [ findcol::yp#0 ]
Statement [64] (byte~) findcol::$9 ← (byte) findcol::y#0 - (byte) findcol::yp#0 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#5 findcol::$9 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#5 findcol::$9 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:9 [ findcol::diff#5 findcol::diff#2 findcol::diff#1 ]
Statement [65] (byte) findcol::diff#4 ← (byte) findcol::diff#5 + (byte~) findcol::$9 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#4 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#4 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [73] (byte~) findcol::$11 ← (byte) findcol::yp#0 - (byte) findcol::y#0 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#5 findcol::$11 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#5 findcol::$11 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [74] (byte) findcol::diff#3 ← (byte) findcol::diff#5 + (byte~) findcol::$11 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#3 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#3 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [75] (byte) findcol::diff#1 ← (byte) findcol::xp#0 - (byte) findcol::x#0 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::yp#0 findcol::diff#1 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::yp#0 findcol::diff#1 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [78] if((byte*) initscreen::screen#2<(const byte*) SCREEN+(word) $3e8) goto initscreen::@2 [ initscreen::screen#2 ] ( main:2::initscreen:5 [ initscreen::screen#2 ] { }  ) always clobbers reg byte a 
Statement [80] *((byte*) initscreen::screen#2) ← (const byte) FILL [ initscreen::screen#2 ] ( main:2::initscreen:5 [ initscreen::screen#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [12] if(*((const byte*) XPOS)!=(byte) $28) goto animate::@1 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [13] *((const byte*) XPOS) ← (byte) 0 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [16] if(*((const byte*) YPOS)!=(byte) $19) goto animate::@2 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [17] *((const byte*) YPOS) ← (byte) 0 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [20] if(*((const byte*) XPOS+(byte) 1)!=(byte) $ff) goto animate::@3 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [21] *((const byte*) XPOS+(byte) 1) ← (byte) $28 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [24] if(*((const byte*) YPOS+(byte) 2)!=(byte) $19) goto animate::@4 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [25] *((const byte*) YPOS+(byte) 2) ← (byte) 0 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [28] if(*((const byte*) YPOS+(byte) 3)!=(byte) $ff) goto animate::@return [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [29] *((const byte*) YPOS+(byte) 3) ← (byte) $19 [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [30] (byte~) animate::$15 ← *((const byte*) XPOS+(byte) 3) + (byte) 7 [ animate::$15 ] ( main:2::animate:9 [ animate::$15 ] { }  ) always clobbers reg byte a 
Statement [32] if(*((const byte*) XPOS+(byte) 3)<(byte) $28) goto animate::@return [ ] ( main:2::animate:9 [ ] { }  ) always clobbers reg byte a 
Statement [33] (byte~) animate::$18 ← *((const byte*) XPOS+(byte) 3) - (byte) $28 [ animate::$18 ] ( main:2::animate:9 [ animate::$18 ] { }  ) always clobbers reg byte a 
Statement [47] (byte*) render::colline#1 ← (byte*) render::colline#5 + (byte) $28 [ render::y#4 render::colline#1 ] ( main:2::render:7 [ render::y#4 render::colline#1 ] { }  ) always clobbers reg byte a 
Statement [61] (byte) findcol::diff#2 ← (byte) findcol::x#0 - (byte) findcol::xp#0 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::yp#0 findcol::diff#2 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::yp#0 findcol::diff#2 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [64] (byte~) findcol::$9 ← (byte) findcol::y#0 - (byte) findcol::yp#0 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#5 findcol::$9 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#5 findcol::$9 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [65] (byte) findcol::diff#4 ← (byte) findcol::diff#5 + (byte~) findcol::$9 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#4 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#4 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [73] (byte~) findcol::$11 ← (byte) findcol::yp#0 - (byte) findcol::y#0 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#5 findcol::$11 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#5 findcol::$11 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [74] (byte) findcol::diff#3 ← (byte) findcol::diff#5 + (byte~) findcol::$11 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#3 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::diff#3 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [75] (byte) findcol::diff#1 ← (byte) findcol::xp#0 - (byte) findcol::x#0 [ findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::yp#0 findcol::diff#1 ] ( main:2::render:7::findcol:41 [ render::y#4 render::colline#5 render::x#2 findcol::x#0 findcol::y#0 findcol::i#10 findcol::mincol#10 findcol::mindiff#10 findcol::yp#0 findcol::diff#1 ] { { findcol::x#0 = render::x#2 } { findcol::y#0 = render::y#4 } { findcol::return#0 = findcol::return#3 } }  ) always clobbers reg byte a 
Statement [78] if((byte*) initscreen::screen#2<(const byte*) SCREEN+(word) $3e8) goto initscreen::@2 [ initscreen::screen#2 ] ( main:2::initscreen:5 [ initscreen::screen#2 ] { }  ) always clobbers reg byte a 
Statement [80] *((byte*) initscreen::screen#2) ← (const byte) FILL [ initscreen::screen#2 ] ( main:2::initscreen:5 [ initscreen::screen#2 ] { }  ) always clobbers reg byte a reg byte y 
Potential registers zp[1]:2 [ render::y#4 render::y#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[2]:3 [ render::colline#5 render::colline#1 ] : zp[2]:3 , 
Potential registers zp[1]:5 [ render::x#2 render::x#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ findcol::i#10 findcol::i#1 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ findcol::mindiff#10 findcol::mindiff#13 ] : zp[1]:7 , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ findcol::return#3 findcol::mincol#10 findcol::mincol#4 findcol::mincol#1 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ findcol::diff#5 findcol::diff#2 findcol::diff#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ findcol::mindiff#12 findcol::diff#7 findcol::diff#4 findcol::diff#3 findcol::mindiff#15 ] : zp[1]:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:11 [ initscreen::screen#2 initscreen::screen#1 ] : zp[2]:11 , 
Potential registers zp[1]:13 [ animate::$0 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ animate::$3 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ animate::$6 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:16 [ animate::$9 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:17 [ animate::$12 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:18 [ animate::$15 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:19 [ animate::$18 ] : zp[1]:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:20 [ findcol::x#0 ] : zp[1]:20 , reg byte x , reg byte y , 
Potential registers zp[1]:21 [ findcol::y#0 ] : zp[1]:21 , reg byte x , reg byte y , 
Potential registers zp[1]:22 [ findcol::return#0 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:23 [ render::col#0 ] : zp[1]:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:24 [ findcol::xp#0 ] : zp[1]:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:25 [ findcol::yp#0 ] : zp[1]:25 , reg byte x , reg byte y , 
Potential registers zp[1]:26 [ findcol::$9 ] : zp[1]:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:27 [ findcol::$11 ] : zp[1]:27 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [findcol] 883,333,333,342.17: zp[1]:10 [ findcol::mindiff#12 findcol::diff#7 findcol::diff#4 findcol::diff#3 findcol::mindiff#15 ] 500,000,000,005: zp[1]:9 [ findcol::diff#5 findcol::diff#2 findcol::diff#1 ] 350,000,333,337.17: zp[1]:8 [ findcol::return#3 findcol::mincol#10 findcol::mincol#4 findcol::mincol#1 ] 217,647,058,825.71: zp[1]:7 [ findcol::mindiff#10 findcol::mindiff#13 ] 200,000,000,002: zp[1]:26 [ findcol::$9 ] 200,000,000,002: zp[1]:27 [ findcol::$11 ] 130,000,000,001.3: zp[1]:6 [ findcol::i#10 findcol::i#1 ] 100,000,000,001: zp[1]:24 [ findcol::xp#0 ] 62,500,000,000.62: zp[1]:25 [ findcol::yp#0 ] 16,666,708,333.54: zp[1]:21 [ findcol::y#0 ] 16,000,040,000.2: zp[1]:20 [ findcol::x#0 ] 2,000,002: zp[1]:22 [ findcol::return#0 ] 
Uplift Scope [render] 2,071,430.64: zp[1]:5 [ render::x#2 render::x#1 ] 2,000,002: zp[1]:23 [ render::col#0 ] 259,092.68: zp[1]:2 [ render::y#4 render::y#1 ] 186,667.63: zp[2]:3 [ render::colline#5 render::colline#1 ] 
Uplift Scope [animate] 2,002: zp[1]:13 [ animate::$0 ] 2,002: zp[1]:14 [ animate::$3 ] 2,002: zp[1]:15 [ animate::$6 ] 2,002: zp[1]:16 [ animate::$9 ] 2,002: zp[1]:17 [ animate::$12 ] 2,002: zp[1]:18 [ animate::$15 ] 2,002: zp[1]:19 [ animate::$18 ] 
Uplift Scope [initscreen] 3,336.67: zp[2]:11 [ initscreen::screen#2 initscreen::screen#1 ] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [findcol] best 1973929 combination reg byte a [ findcol::mindiff#12 findcol::diff#7 findcol::diff#4 findcol::diff#3 findcol::mindiff#15 ] reg byte y [ findcol::diff#5 findcol::diff#2 findcol::diff#1 ] reg byte x [ findcol::return#3 findcol::mincol#10 findcol::mincol#4 findcol::mincol#1 ] zp[1]:7 [ findcol::mindiff#10 findcol::mindiff#13 ] zp[1]:26 [ findcol::$9 ] zp[1]:27 [ findcol::$11 ] zp[1]:6 [ findcol::i#10 findcol::i#1 ] zp[1]:24 [ findcol::xp#0 ] zp[1]:25 [ findcol::yp#0 ] zp[1]:21 [ findcol::y#0 ] zp[1]:20 [ findcol::x#0 ] zp[1]:22 [ findcol::return#0 ] 
Limited combination testing to 100 combinations of 2239488 possible.
Uplifting [render] best 1967929 combination zp[1]:5 [ render::x#2 render::x#1 ] reg byte a [ render::col#0 ] zp[1]:2 [ render::y#4 render::y#1 ] zp[2]:3 [ render::colline#5 render::colline#1 ] 
Uplifting [animate] best 1967909 combination reg byte x [ animate::$0 ] reg byte x [ animate::$3 ] reg byte a [ animate::$6 ] reg byte a [ animate::$9 ] zp[1]:17 [ animate::$12 ] zp[1]:18 [ animate::$15 ] zp[1]:19 [ animate::$18 ] 
Limited combination testing to 100 combinations of 16384 possible.
Uplifting [initscreen] best 1967909 combination zp[2]:11 [ initscreen::screen#2 initscreen::screen#1 ] 
Uplifting [main] best 1967909 combination 
Uplifting [] best 1967909 combination 
Attempting to uplift remaining variables inzp[1]:7 [ findcol::mindiff#10 findcol::mindiff#13 ]
Uplifting [findcol] best 1967909 combination zp[1]:7 [ findcol::mindiff#10 findcol::mindiff#13 ] 
Attempting to uplift remaining variables inzp[1]:26 [ findcol::$9 ]
Uplifting [findcol] best 1947909 combination reg byte a [ findcol::$9 ] 
Attempting to uplift remaining variables inzp[1]:27 [ findcol::$11 ]
Uplifting [findcol] best 1927909 combination reg byte a [ findcol::$11 ] 
Attempting to uplift remaining variables inzp[1]:6 [ findcol::i#10 findcol::i#1 ]
Uplifting [findcol] best 1927909 combination zp[1]:6 [ findcol::i#10 findcol::i#1 ] 
Attempting to uplift remaining variables inzp[1]:24 [ findcol::xp#0 ]
Uplifting [findcol] best 1927909 combination zp[1]:24 [ findcol::xp#0 ] 
Attempting to uplift remaining variables inzp[1]:25 [ findcol::yp#0 ]
Uplifting [findcol] best 1927909 combination zp[1]:25 [ findcol::yp#0 ] 
Attempting to uplift remaining variables inzp[1]:21 [ findcol::y#0 ]
Uplifting [findcol] best 1927909 combination zp[1]:21 [ findcol::y#0 ] 
Attempting to uplift remaining variables inzp[1]:20 [ findcol::x#0 ]
Uplifting [findcol] best 1927909 combination zp[1]:20 [ findcol::x#0 ] 
Attempting to uplift remaining variables inzp[1]:5 [ render::x#2 render::x#1 ]
Uplifting [render] best 1927909 combination zp[1]:5 [ render::x#2 render::x#1 ] 
Attempting to uplift remaining variables inzp[1]:22 [ findcol::return#0 ]
Uplifting [findcol] best 1923909 combination reg byte a [ findcol::return#0 ] 
Attempting to uplift remaining variables inzp[1]:2 [ render::y#4 render::y#1 ]
Uplifting [render] best 1923909 combination zp[1]:2 [ render::y#4 render::y#1 ] 
Attempting to uplift remaining variables inzp[1]:17 [ animate::$12 ]
Uplifting [animate] best 1923903 combination reg byte x [ animate::$12 ] 
Attempting to uplift remaining variables inzp[1]:18 [ animate::$15 ]
Uplifting [animate] best 1923897 combination reg byte a [ animate::$15 ] 
Attempting to uplift remaining variables inzp[1]:19 [ animate::$18 ]
Uplifting [animate] best 1923891 combination reg byte a [ animate::$18 ] 
Coalescing zero page register [ zp[1]:2 [ render::y#4 render::y#1 ] ] with [ zp[1]:21 [ findcol::y#0 ] ] - score: 1
Coalescing zero page register [ zp[1]:5 [ render::x#2 render::x#1 ] ] with [ zp[1]:20 [ findcol::x#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:11 [ initscreen::screen#2 initscreen::screen#1 ] ] with [ zp[2]:3 [ render::colline#5 render::colline#1 ] ]
Allocated (was zp[1]:5) zp[1]:3 [ render::x#2 render::x#1 findcol::x#0 ]
Allocated (was zp[1]:6) zp[1]:4 [ findcol::i#10 findcol::i#1 ]
Allocated (was zp[1]:7) zp[1]:5 [ findcol::mindiff#10 findcol::mindiff#13 ]
Allocated (was zp[2]:11) zp[2]:6 [ initscreen::screen#2 initscreen::screen#1 render::colline#5 render::colline#1 ]
Allocated (was zp[1]:24) zp[1]:8 [ findcol::xp#0 ]
Allocated (was zp[1]:25) zp[1]:9 [ findcol::yp#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// The screen
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .const FILL = $e6
  // The total number of voronoi points
  .const numpoints = 6
  .label SCREEN = $400
  .label COLORS = $d800
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // [5] call initscreen 
    // [76] phi from main to initscreen [phi:main->initscreen]
  initscreen_from_main:
    jsr initscreen
    // [6] phi from main main::@2 to main::@1 [phi:main/main::@2->main::@1]
  __b1_from_main:
  __b1_from___b2:
    jmp __b1
    // main::@1
  __b1:
    // [7] call render 
    // [36] phi from main::@1 to render [phi:main::@1->render]
  render_from___b1:
    jsr render
    // [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [9] call animate 
    jsr animate
    jmp __b1_from___b2
}
  // animate
animate: {
    // [10] (byte~) animate::$0 ← *((const byte*) XPOS) + (byte) 1 -- vbuxx=_deref_pbuc1_plus_1 
    ldx XPOS
    inx
    // [11] *((const byte*) XPOS) ← (byte~) animate::$0 -- _deref_pbuc1=vbuxx 
    stx XPOS
    // [12] if(*((const byte*) XPOS)!=(byte) $28) goto animate::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$28
    cmp XPOS
    bne __b1
    jmp __b5
    // animate::@5
  __b5:
    // [13] *((const byte*) XPOS) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta XPOS
    jmp __b1
    // animate::@1
  __b1:
    // [14] (byte~) animate::$3 ← *((const byte*) YPOS) + (byte) 1 -- vbuxx=_deref_pbuc1_plus_1 
    ldx YPOS
    inx
    // [15] *((const byte*) YPOS) ← (byte~) animate::$3 -- _deref_pbuc1=vbuxx 
    stx YPOS
    // [16] if(*((const byte*) YPOS)!=(byte) $19) goto animate::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$19
    cmp YPOS
    bne __b2
    jmp __b6
    // animate::@6
  __b6:
    // [17] *((const byte*) YPOS) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta YPOS
    jmp __b2
    // animate::@2
  __b2:
    // [18] (byte~) animate::$6 ← *((const byte*) XPOS+(byte) 1) - (byte) 1 -- vbuaa=_deref_pbuc1_minus_1 
    lda XPOS+1
    sec
    sbc #1
    // [19] *((const byte*) XPOS+(byte) 1) ← (byte~) animate::$6 -- _deref_pbuc1=vbuaa 
    sta XPOS+1
    // [20] if(*((const byte*) XPOS+(byte) 1)!=(byte) $ff) goto animate::@3 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp XPOS+1
    bne __b3
    jmp __b7
    // animate::@7
  __b7:
    // [21] *((const byte*) XPOS+(byte) 1) ← (byte) $28 -- _deref_pbuc1=vbuc2 
    lda #$28
    sta XPOS+1
    jmp __b3
    // animate::@3
  __b3:
    // [22] (byte~) animate::$9 ← *((const byte*) YPOS+(byte) 2) + (byte) 1 -- vbuaa=_deref_pbuc1_plus_1 
    lda YPOS+2
    clc
    adc #1
    // [23] *((const byte*) YPOS+(byte) 2) ← (byte~) animate::$9 -- _deref_pbuc1=vbuaa 
    sta YPOS+2
    // [24] if(*((const byte*) YPOS+(byte) 2)!=(byte) $19) goto animate::@4 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$19
    cmp YPOS+2
    bne __b4
    jmp __b8
    // animate::@8
  __b8:
    // [25] *((const byte*) YPOS+(byte) 2) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta YPOS+2
    jmp __b4
    // animate::@4
  __b4:
    // [26] (byte~) animate::$12 ← *((const byte*) YPOS+(byte) 3) - (byte) 1 -- vbuxx=_deref_pbuc1_minus_1 
    ldx YPOS+3
    dex
    // [27] *((const byte*) YPOS+(byte) 3) ← (byte~) animate::$12 -- _deref_pbuc1=vbuxx 
    stx YPOS+3
    // [28] if(*((const byte*) YPOS+(byte) 3)!=(byte) $ff) goto animate::@return -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp YPOS+3
    bne __breturn
    jmp __b9
    // animate::@9
  __b9:
    // [29] *((const byte*) YPOS+(byte) 3) ← (byte) $19 -- _deref_pbuc1=vbuc2 
    lda #$19
    sta YPOS+3
    // [30] (byte~) animate::$15 ← *((const byte*) XPOS+(byte) 3) + (byte) 7 -- vbuaa=_deref_pbuc1_plus_vbuc2 
    lda #7
    clc
    adc XPOS+3
    // [31] *((const byte*) XPOS+(byte) 3) ← (byte~) animate::$15 -- _deref_pbuc1=vbuaa 
    sta XPOS+3
    // [32] if(*((const byte*) XPOS+(byte) 3)<(byte) $28) goto animate::@return -- _deref_pbuc1_lt_vbuc2_then_la1 
    lda XPOS+3
    cmp #$28
    bcc __breturn
    jmp __b10
    // animate::@10
  __b10:
    // [33] (byte~) animate::$18 ← *((const byte*) XPOS+(byte) 3) - (byte) $28 -- vbuaa=_deref_pbuc1_minus_vbuc2 
    lda XPOS+3
    sec
    sbc #$28
    // [34] *((const byte*) XPOS+(byte) 3) ← (byte~) animate::$18 -- _deref_pbuc1=vbuaa 
    sta XPOS+3
    jmp __breturn
    // animate::@return
  __breturn:
    // [35] return 
    rts
}
  // render
render: {
    .label x = 3
    .label colline = 6
    .label y = 2
    // [37] phi from render to render::@1 [phi:render->render::@1]
  __b1_from_render:
    // [37] phi (byte*) render::colline#5 = (const byte*) COLORS [phi:render->render::@1#0] -- pbuz1=pbuc1 
    lda #<COLORS
    sta.z colline
    lda #>COLORS
    sta.z colline+1
    // [37] phi (byte) render::y#4 = (byte) 0 [phi:render->render::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp __b1
    // [37] phi from render::@3 to render::@1 [phi:render::@3->render::@1]
  __b1_from___b3:
    // [37] phi (byte*) render::colline#5 = (byte*) render::colline#1 [phi:render::@3->render::@1#0] -- register_copy 
    // [37] phi (byte) render::y#4 = (byte) render::y#1 [phi:render::@3->render::@1#1] -- register_copy 
    jmp __b1
    // render::@1
  __b1:
    // [38] phi from render::@1 to render::@2 [phi:render::@1->render::@2]
  __b2_from___b1:
    // [38] phi (byte) render::x#2 = (byte) 0 [phi:render::@1->render::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    jmp __b2
    // [38] phi from render::@4 to render::@2 [phi:render::@4->render::@2]
  __b2_from___b4:
    // [38] phi (byte) render::x#2 = (byte) render::x#1 [phi:render::@4->render::@2#0] -- register_copy 
    jmp __b2
    // render::@2
  __b2:
    // [39] (byte) findcol::x#0 ← (byte) render::x#2
    // [40] (byte) findcol::y#0 ← (byte) render::y#4
    // [41] call findcol 
    // [51] phi from render::@2 to findcol [phi:render::@2->findcol]
  findcol_from___b2:
    jsr findcol
    // [42] (byte) findcol::return#0 ← (byte) findcol::return#3 -- vbuaa=vbuxx 
    txa
    jmp __b4
    // render::@4
  __b4:
    // [43] (byte) render::col#0 ← (byte) findcol::return#0
    // [44] *((byte*) render::colline#5 + (byte) render::x#2) ← (byte) render::col#0 -- pbuz1_derefidx_vbuz2=vbuaa 
    ldy.z x
    sta (colline),y
    // [45] (byte) render::x#1 ← ++ (byte) render::x#2 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [46] if((byte) render::x#1!=(byte) $28) goto render::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp.z x
    bne __b2_from___b4
    jmp __b3
    // render::@3
  __b3:
    // [47] (byte*) render::colline#1 ← (byte*) render::colline#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z colline
    sta.z colline
    bcc !+
    inc.z colline+1
  !:
    // [48] (byte) render::y#1 ← ++ (byte) render::y#4 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [49] if((byte) render::y#1!=(byte) $19) goto render::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b1_from___b3
    jmp __breturn
    // render::@return
  __breturn:
    // [50] return 
    rts
}
  // findcol
// findcol(byte zp(3) x, byte zp(2) y)
findcol: {
    .label x = 3
    .label y = 2
    .label xp = 8
    .label yp = 9
    .label i = 4
    .label mindiff = 5
    // [52] phi from findcol to findcol::@1 [phi:findcol->findcol::@1]
  __b1_from_findcol:
    // [52] phi (byte) findcol::mindiff#10 = (byte) $ff [phi:findcol->findcol::@1#0] -- vbuz1=vbuc1 
    lda #$ff
    sta.z mindiff
    // [52] phi (byte) findcol::mincol#10 = (byte) 0 [phi:findcol->findcol::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [52] phi (byte) findcol::i#10 = (byte) 0 [phi:findcol->findcol::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // findcol::@1
  __b1:
    // [53] if((byte) findcol::i#10<(const byte) numpoints) goto findcol::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #numpoints
    bcc __b2
    // [54] phi from findcol::@1 to findcol::@return [phi:findcol::@1->findcol::@return]
  __breturn_from___b1:
    // [54] phi (byte) findcol::return#3 = (byte) findcol::mincol#10 [phi:findcol::@1->findcol::@return#0] -- register_copy 
    jmp __breturn
    // findcol::@return
  __breturn:
    // [55] return 
    rts
    // findcol::@2
  __b2:
    // [56] (byte) findcol::xp#0 ← *((const byte*) XPOS + (byte) findcol::i#10) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z i
    lda XPOS,y
    sta.z xp
    // [57] (byte) findcol::yp#0 ← *((const byte*) YPOS + (byte) findcol::i#10) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z i
    lda YPOS,y
    sta.z yp
    // [58] if((byte) findcol::x#0!=(byte) findcol::xp#0) goto findcol::@3 -- vbuz1_neq_vbuz2_then_la1 
    lda.z x
    cmp.z xp
    bne __b3
    jmp __b9
    // findcol::@9
  __b9:
    // [59] if((byte) findcol::y#0!=(byte) findcol::yp#0) goto findcol::@3 -- vbuz1_neq_vbuz2_then_la1 
    lda.z y
    cmp.z yp
    bne __b3
    // [54] phi from findcol::@9 to findcol::@return [phi:findcol::@9->findcol::@return]
  __breturn_from___b9:
    // [54] phi (byte) findcol::return#3 = (byte) 0 [phi:findcol::@9->findcol::@return#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __breturn
    // findcol::@3
  __b3:
    // [60] if((byte) findcol::x#0<(byte) findcol::xp#0) goto findcol::@4 -- vbuz1_lt_vbuz2_then_la1 
    lda.z x
    cmp.z xp
    bcc __b4
    jmp __b10
    // findcol::@10
  __b10:
    // [61] (byte) findcol::diff#2 ← (byte) findcol::x#0 - (byte) findcol::xp#0 -- vbuyy=vbuz1_minus_vbuz2 
    lda.z x
    sec
    sbc.z xp
    tay
    // [62] phi from findcol::@10 findcol::@4 to findcol::@5 [phi:findcol::@10/findcol::@4->findcol::@5]
  __b5_from___b10:
  __b5_from___b4:
    // [62] phi (byte) findcol::diff#5 = (byte) findcol::diff#2 [phi:findcol::@10/findcol::@4->findcol::@5#0] -- register_copy 
    jmp __b5
    // findcol::@5
  __b5:
    // [63] if((byte) findcol::y#0<(byte) findcol::yp#0) goto findcol::@6 -- vbuz1_lt_vbuz2_then_la1 
    lda.z y
    cmp.z yp
    bcc __b6
    jmp __b11
    // findcol::@11
  __b11:
    // [64] (byte~) findcol::$9 ← (byte) findcol::y#0 - (byte) findcol::yp#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z y
    sec
    sbc.z yp
    // [65] (byte) findcol::diff#4 ← (byte) findcol::diff#5 + (byte~) findcol::$9 -- vbuaa=vbuyy_plus_vbuaa 
    sty.z $ff
    clc
    adc.z $ff
    // [66] phi from findcol::@11 findcol::@6 to findcol::@7 [phi:findcol::@11/findcol::@6->findcol::@7]
  __b7_from___b11:
  __b7_from___b6:
    // [66] phi (byte) findcol::diff#7 = (byte) findcol::diff#4 [phi:findcol::@11/findcol::@6->findcol::@7#0] -- register_copy 
    jmp __b7
    // findcol::@7
  __b7:
    // [67] if((byte) findcol::diff#7>=(byte) findcol::mindiff#10) goto findcol::@13 -- vbuaa_ge_vbuz1_then_la1 
    cmp.z mindiff
    bcs __b13
    jmp __b12
    // findcol::@12
  __b12:
    // [68] (byte) findcol::mincol#1 ← *((const byte*) COLS + (byte) findcol::i#10) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z i
    ldx COLS,y
    // [69] phi from findcol::@12 findcol::@13 to findcol::@8 [phi:findcol::@12/findcol::@13->findcol::@8]
  __b8_from___b12:
  __b8_from___b13:
    // [69] phi (byte) findcol::mindiff#12 = (byte) findcol::diff#7 [phi:findcol::@12/findcol::@13->findcol::@8#0] -- register_copy 
    // [69] phi (byte) findcol::mincol#4 = (byte) findcol::mincol#1 [phi:findcol::@12/findcol::@13->findcol::@8#1] -- register_copy 
    jmp __b8
    // findcol::@8
  __b8:
    // [70] (byte) findcol::i#1 ← ++ (byte) findcol::i#10 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [71] (byte) findcol::mindiff#13 ← (byte) findcol::mindiff#12 -- vbuz1=vbuaa 
    sta.z mindiff
    // [52] phi from findcol::@8 to findcol::@1 [phi:findcol::@8->findcol::@1]
  __b1_from___b8:
    // [52] phi (byte) findcol::mindiff#10 = (byte) findcol::mindiff#13 [phi:findcol::@8->findcol::@1#0] -- register_copy 
    // [52] phi (byte) findcol::mincol#10 = (byte) findcol::mincol#4 [phi:findcol::@8->findcol::@1#1] -- register_copy 
    // [52] phi (byte) findcol::i#10 = (byte) findcol::i#1 [phi:findcol::@8->findcol::@1#2] -- register_copy 
    jmp __b1
    // findcol::@13
  __b13:
    // [72] (byte) findcol::mindiff#15 ← (byte) findcol::mindiff#10 -- vbuaa=vbuz1 
    lda.z mindiff
    jmp __b8_from___b13
    // findcol::@6
  __b6:
    // [73] (byte~) findcol::$11 ← (byte) findcol::yp#0 - (byte) findcol::y#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z yp
    sec
    sbc.z y
    // [74] (byte) findcol::diff#3 ← (byte) findcol::diff#5 + (byte~) findcol::$11 -- vbuaa=vbuyy_plus_vbuaa 
    sty.z $ff
    clc
    adc.z $ff
    jmp __b7_from___b6
    // findcol::@4
  __b4:
    // [75] (byte) findcol::diff#1 ← (byte) findcol::xp#0 - (byte) findcol::x#0 -- vbuyy=vbuz1_minus_vbuz2 
    lda.z xp
    sec
    sbc.z x
    tay
    jmp __b5_from___b4
}
  // initscreen
initscreen: {
    .label screen = 6
    // [77] phi from initscreen to initscreen::@1 [phi:initscreen->initscreen::@1]
  __b1_from_initscreen:
    // [77] phi (byte*) initscreen::screen#2 = (const byte*) SCREEN [phi:initscreen->initscreen::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z screen
    lda #>SCREEN
    sta.z screen+1
    jmp __b1
    // initscreen::@1
  __b1:
    // [78] if((byte*) initscreen::screen#2<(const byte*) SCREEN+(word) $3e8) goto initscreen::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z screen+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z screen
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    jmp __breturn
    // initscreen::@return
  __breturn:
    // [79] return 
    rts
    // initscreen::@2
  __b2:
    // [80] *((byte*) initscreen::screen#2) ← (const byte) FILL -- _deref_pbuz1=vbuc1 
    lda #FILL
    ldy #0
    sta (screen),y
    // [81] (byte*) initscreen::screen#1 ← ++ (byte*) initscreen::screen#2 -- pbuz1=_inc_pbuz1 
    inc.z screen
    bne !+
    inc.z screen+1
  !:
    // [77] phi from initscreen::@2 to initscreen::@1 [phi:initscreen::@2->initscreen::@1]
  __b1_from___b2:
    // [77] phi (byte*) initscreen::screen#2 = (byte*) initscreen::screen#1 [phi:initscreen::@2->initscreen::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
  // Points to create the Voronoi from
  XPOS: .byte 5, $f, 6, $22, $15, $1f
  YPOS: .byte 5, 8, $e, 2, $11, $16
  COLS: .byte 1, 2, 3, 4, 5, 7

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b5
Removing instruction jmp __b1
Removing instruction jmp __b6
Removing instruction jmp __b2
Removing instruction jmp __b7
Removing instruction jmp __b3
Removing instruction jmp __b8
Removing instruction jmp __b4
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b9
Removing instruction jmp __b10
Removing instruction jmp __b5
Removing instruction jmp __b11
Removing instruction jmp __b7
Removing instruction jmp __b12
Removing instruction jmp __b8
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda XPOS+3
Replacing instruction lda #0 with TXA
Removing instruction ldy.z i
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b1_from___b2 with __b1
Replacing label __b2_from___b4 with __b2
Replacing label __b1_from___b3 with __b1
Replacing label __b8_from___b13 with __b8
Replacing label __b7_from___b6 with __b7
Replacing label __b5_from___b4 with __b5
Removing instruction __b1_from___bbegin:
Removing instruction __b1:
Removing instruction main_from___b1:
Removing instruction __bend_from___b1:
Removing instruction __b1_from_main:
Removing instruction __b1_from___b2:
Removing instruction render_from___b1:
Removing instruction __b2_from___b1:
Removing instruction __b1_from___b3:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction findcol_from___b2:
Removing instruction __breturn_from___b1:
Removing instruction __b5_from___b10:
Removing instruction __b5_from___b4:
Removing instruction __b7_from___b11:
Removing instruction __b7_from___b6:
Removing instruction __b8_from___b12:
Removing instruction __b8_from___b13:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction initscreen_from_main:
Removing instruction __b2:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b9:
Removing instruction __b10:
Removing instruction __b1_from_render:
Removing instruction __b4:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from_findcol:
Removing instruction __b9:
Removing instruction __breturn_from___b9:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b1_from___b8:
Removing instruction __b1_from_initscreen:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Replacing jump to rts with rts in jmp __breturn
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction jmp __b1
Removing instruction jmp __b2
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda XPOS+3
Removing instruction lda #$28
Removing instruction lda.z x
Removing instruction lda.z y
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __bbegin:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) COLORS = (byte*) 55296
(const byte*) COLS[]  = { (byte) 1, (byte) 2, (byte) 3, (byte) 4, (byte) 5, (byte) 7 }
(const byte) FILL = (byte) $e6
(const byte*) SCREEN = (byte*) 1024
(const byte*) XPOS[]  = { (byte) 5, (byte) $f, (byte) 6, (byte) $22, (byte) $15, (byte) $1f }
(const byte*) YPOS[]  = { (byte) 5, (byte) 8, (byte) $e, (byte) 2, (byte) $11, (byte) $16 }
(void()) animate()
(byte~) animate::$0 reg byte x 2002.0
(byte~) animate::$12 reg byte x 2002.0
(byte~) animate::$15 reg byte a 2002.0
(byte~) animate::$18 reg byte a 2002.0
(byte~) animate::$3 reg byte x 2002.0
(byte~) animate::$6 reg byte a 2002.0
(byte~) animate::$9 reg byte a 2002.0
(label) animate::@1
(label) animate::@10
(label) animate::@2
(label) animate::@3
(label) animate::@4
(label) animate::@5
(label) animate::@6
(label) animate::@7
(label) animate::@8
(label) animate::@9
(label) animate::@return
(byte()) findcol((byte) findcol::x , (byte) findcol::y)
(byte~) findcol::$11 reg byte a 2.00000000002E11
(byte~) findcol::$9 reg byte a 2.00000000002E11
(label) findcol::@1
(label) findcol::@10
(label) findcol::@11
(label) findcol::@12
(label) findcol::@13
(label) findcol::@2
(label) findcol::@3
(label) findcol::@4
(label) findcol::@5
(label) findcol::@6
(label) findcol::@7
(label) findcol::@8
(label) findcol::@9
(label) findcol::@return
(byte) findcol::diff
(byte) findcol::diff#1 reg byte y 2.00000000002E11
(byte) findcol::diff#2 reg byte y 2.00000000002E11
(byte) findcol::diff#3 reg byte a 2.00000000002E11
(byte) findcol::diff#4 reg byte a 2.00000000002E11
(byte) findcol::diff#5 reg byte y 1.00000000001E11
(byte) findcol::diff#7 reg byte a 1.3333333333466667E11
(byte) findcol::i
(byte) findcol::i#1 i zp[1]:4 1.00000000001E11
(byte) findcol::i#10 i zp[1]:4 3.00000000003E10
(byte) findcol::mincol
(byte) findcol::mincol#1 reg byte x 2.00000000002E11
(byte) findcol::mincol#10 reg byte x 1.6666666666833332E10
(byte) findcol::mincol#4 reg byte x 1.00000000001E11
(byte) findcol::mindiff
(byte) findcol::mindiff#10 mindiff zp[1]:5 1.7647058823705883E10
(byte) findcol::mindiff#12 reg byte a 1.500000000015E11
(byte) findcol::mindiff#13 mindiff zp[1]:5 2.00000000002E11
(byte) findcol::mindiff#15 reg byte a 2.00000000002E11
(byte) findcol::return
(byte) findcol::return#0 reg byte a 2000002.0
(byte) findcol::return#3 reg byte x 3.3333666667333336E10
(byte) findcol::x
(byte) findcol::x#0 x zp[1]:3 1.60000400002E10
(byte) findcol::xp
(byte) findcol::xp#0 xp zp[1]:8 1.00000000001E11
(byte) findcol::y
(byte) findcol::y#0 y zp[1]:2 1.6666708333541668E10
(byte) findcol::yp
(byte) findcol::yp#0 yp zp[1]:9 6.2500000000625E10
(void()) initscreen()
(label) initscreen::@1
(label) initscreen::@2
(label) initscreen::@return
(byte*) initscreen::screen
(byte*) initscreen::screen#1 screen zp[2]:6 2002.0
(byte*) initscreen::screen#2 screen zp[2]:6 1334.6666666666667
(void()) main()
(label) main::@1
(label) main::@2
(const byte) numpoints = (byte) 6
(void()) render()
(label) render::@1
(label) render::@2
(label) render::@3
(label) render::@4
(label) render::@return
(byte) render::col
(byte) render::col#0 reg byte a 2000002.0
(byte*) render::colline
(byte*) render::colline#1 colline zp[2]:6 66667.33333333333
(byte*) render::colline#5 colline zp[2]:6 120000.30000000002
(byte) render::x
(byte) render::x#1 x zp[1]:3 1500001.5
(byte) render::x#2 x zp[1]:3 571429.1428571428
(byte) render::y
(byte) render::y#1 y zp[1]:2 150001.5
(byte) render::y#4 y zp[1]:2 109091.18181818182

zp[1]:2 [ render::y#4 render::y#1 findcol::y#0 ]
zp[1]:3 [ render::x#2 render::x#1 findcol::x#0 ]
zp[1]:4 [ findcol::i#10 findcol::i#1 ]
zp[1]:5 [ findcol::mindiff#10 findcol::mindiff#13 ]
reg byte x [ findcol::return#3 findcol::mincol#10 findcol::mincol#4 findcol::mincol#1 ]
reg byte y [ findcol::diff#5 findcol::diff#2 findcol::diff#1 ]
reg byte a [ findcol::mindiff#12 findcol::diff#7 findcol::diff#4 findcol::diff#3 findcol::mindiff#15 ]
zp[2]:6 [ initscreen::screen#2 initscreen::screen#1 render::colline#5 render::colline#1 ]
reg byte x [ animate::$0 ]
reg byte x [ animate::$3 ]
reg byte a [ animate::$6 ]
reg byte a [ animate::$9 ]
reg byte x [ animate::$12 ]
reg byte a [ animate::$15 ]
reg byte a [ animate::$18 ]
reg byte a [ findcol::return#0 ]
reg byte a [ render::col#0 ]
zp[1]:8 [ findcol::xp#0 ]
zp[1]:9 [ findcol::yp#0 ]
reg byte a [ findcol::$9 ]
reg byte a [ findcol::$11 ]


FINAL ASSEMBLER
Score: 1568618

  // File Comments
// The screen
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const FILL = $e6
  // The total number of voronoi points
  .const numpoints = 6
  .label SCREEN = $400
  .label COLORS = $d800
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // initscreen()
    // [5] call initscreen 
    // [76] phi from main to initscreen [phi:main->initscreen]
    jsr initscreen
    // [6] phi from main main::@2 to main::@1 [phi:main/main::@2->main::@1]
    // main::@1
  __b1:
    // render()
    // [7] call render 
    // [36] phi from main::@1 to render [phi:main::@1->render]
    jsr render
    // [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // animate()
    // [9] call animate 
    jsr animate
    jmp __b1
}
  // animate
animate: {
    // XPOS[0]+1
    // [10] (byte~) animate::$0 ← *((const byte*) XPOS) + (byte) 1 -- vbuxx=_deref_pbuc1_plus_1 
    ldx XPOS
    inx
    // XPOS[0] = XPOS[0]+1
    // [11] *((const byte*) XPOS) ← (byte~) animate::$0 -- _deref_pbuc1=vbuxx 
    stx XPOS
    // if(XPOS[0]==40)
    // [12] if(*((const byte*) XPOS)!=(byte) $28) goto animate::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$28
    cmp XPOS
    bne __b1
    // animate::@5
    // XPOS[0] = 0
    // [13] *((const byte*) XPOS) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta XPOS
    // animate::@1
  __b1:
    // YPOS[0]+1
    // [14] (byte~) animate::$3 ← *((const byte*) YPOS) + (byte) 1 -- vbuxx=_deref_pbuc1_plus_1 
    ldx YPOS
    inx
    // YPOS[0] = YPOS[0]+1
    // [15] *((const byte*) YPOS) ← (byte~) animate::$3 -- _deref_pbuc1=vbuxx 
    stx YPOS
    // if(YPOS[0]==25)
    // [16] if(*((const byte*) YPOS)!=(byte) $19) goto animate::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$19
    cmp YPOS
    bne __b2
    // animate::@6
    // YPOS[0] = 0
    // [17] *((const byte*) YPOS) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta YPOS
    // animate::@2
  __b2:
    // XPOS[1]-1
    // [18] (byte~) animate::$6 ← *((const byte*) XPOS+(byte) 1) - (byte) 1 -- vbuaa=_deref_pbuc1_minus_1 
    lda XPOS+1
    sec
    sbc #1
    // XPOS[1] = XPOS[1]-1
    // [19] *((const byte*) XPOS+(byte) 1) ← (byte~) animate::$6 -- _deref_pbuc1=vbuaa 
    sta XPOS+1
    // if(XPOS[1]==255)
    // [20] if(*((const byte*) XPOS+(byte) 1)!=(byte) $ff) goto animate::@3 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp XPOS+1
    bne __b3
    // animate::@7
    // XPOS[1] = 40
    // [21] *((const byte*) XPOS+(byte) 1) ← (byte) $28 -- _deref_pbuc1=vbuc2 
    lda #$28
    sta XPOS+1
    // animate::@3
  __b3:
    // YPOS[2]+1
    // [22] (byte~) animate::$9 ← *((const byte*) YPOS+(byte) 2) + (byte) 1 -- vbuaa=_deref_pbuc1_plus_1 
    lda YPOS+2
    clc
    adc #1
    // YPOS[2] = YPOS[2]+1
    // [23] *((const byte*) YPOS+(byte) 2) ← (byte~) animate::$9 -- _deref_pbuc1=vbuaa 
    sta YPOS+2
    // if(YPOS[2]==25)
    // [24] if(*((const byte*) YPOS+(byte) 2)!=(byte) $19) goto animate::@4 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$19
    cmp YPOS+2
    bne __b4
    // animate::@8
    // YPOS[2] = 0
    // [25] *((const byte*) YPOS+(byte) 2) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta YPOS+2
    // animate::@4
  __b4:
    // YPOS[3]-1
    // [26] (byte~) animate::$12 ← *((const byte*) YPOS+(byte) 3) - (byte) 1 -- vbuxx=_deref_pbuc1_minus_1 
    ldx YPOS+3
    dex
    // YPOS[3] = YPOS[3]-1
    // [27] *((const byte*) YPOS+(byte) 3) ← (byte~) animate::$12 -- _deref_pbuc1=vbuxx 
    stx YPOS+3
    // if(YPOS[3]==255)
    // [28] if(*((const byte*) YPOS+(byte) 3)!=(byte) $ff) goto animate::@return -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp YPOS+3
    bne __breturn
    // animate::@9
    // YPOS[3] = 25
    // [29] *((const byte*) YPOS+(byte) 3) ← (byte) $19 -- _deref_pbuc1=vbuc2 
    lda #$19
    sta YPOS+3
    // XPOS[3]+7
    // [30] (byte~) animate::$15 ← *((const byte*) XPOS+(byte) 3) + (byte) 7 -- vbuaa=_deref_pbuc1_plus_vbuc2 
    lda #7
    clc
    adc XPOS+3
    // XPOS[3] = XPOS[3]+7
    // [31] *((const byte*) XPOS+(byte) 3) ← (byte~) animate::$15 -- _deref_pbuc1=vbuaa 
    sta XPOS+3
    // if(XPOS[3]>=40)
    // [32] if(*((const byte*) XPOS+(byte) 3)<(byte) $28) goto animate::@return -- _deref_pbuc1_lt_vbuc2_then_la1 
    cmp #$28
    bcc __breturn
    // animate::@10
    // XPOS[3]-40
    // [33] (byte~) animate::$18 ← *((const byte*) XPOS+(byte) 3) - (byte) $28 -- vbuaa=_deref_pbuc1_minus_vbuc2 
    sec
    sbc #$28
    // XPOS[3] = XPOS[3]-40
    // [34] *((const byte*) XPOS+(byte) 3) ← (byte~) animate::$18 -- _deref_pbuc1=vbuaa 
    sta XPOS+3
    // animate::@return
  __breturn:
    // }
    // [35] return 
    rts
}
  // render
render: {
    .label x = 3
    .label colline = 6
    .label y = 2
    // [37] phi from render to render::@1 [phi:render->render::@1]
    // [37] phi (byte*) render::colline#5 = (const byte*) COLORS [phi:render->render::@1#0] -- pbuz1=pbuc1 
    lda #<COLORS
    sta.z colline
    lda #>COLORS
    sta.z colline+1
    // [37] phi (byte) render::y#4 = (byte) 0 [phi:render->render::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [37] phi from render::@3 to render::@1 [phi:render::@3->render::@1]
    // [37] phi (byte*) render::colline#5 = (byte*) render::colline#1 [phi:render::@3->render::@1#0] -- register_copy 
    // [37] phi (byte) render::y#4 = (byte) render::y#1 [phi:render::@3->render::@1#1] -- register_copy 
    // render::@1
  __b1:
    // [38] phi from render::@1 to render::@2 [phi:render::@1->render::@2]
    // [38] phi (byte) render::x#2 = (byte) 0 [phi:render::@1->render::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    // [38] phi from render::@4 to render::@2 [phi:render::@4->render::@2]
    // [38] phi (byte) render::x#2 = (byte) render::x#1 [phi:render::@4->render::@2#0] -- register_copy 
    // render::@2
  __b2:
    // findcol(x, y)
    // [39] (byte) findcol::x#0 ← (byte) render::x#2
    // [40] (byte) findcol::y#0 ← (byte) render::y#4
    // [41] call findcol 
    // [51] phi from render::@2 to findcol [phi:render::@2->findcol]
    jsr findcol
    // findcol(x, y)
    // [42] (byte) findcol::return#0 ← (byte) findcol::return#3 -- vbuaa=vbuxx 
    txa
    // render::@4
    // col = findcol(x, y)
    // [43] (byte) render::col#0 ← (byte) findcol::return#0
    // colline[x] = col
    // [44] *((byte*) render::colline#5 + (byte) render::x#2) ← (byte) render::col#0 -- pbuz1_derefidx_vbuz2=vbuaa 
    ldy.z x
    sta (colline),y
    // for( byte x : 0..39)
    // [45] (byte) render::x#1 ← ++ (byte) render::x#2 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [46] if((byte) render::x#1!=(byte) $28) goto render::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp.z x
    bne __b2
    // render::@3
    // colline = colline+40
    // [47] (byte*) render::colline#1 ← (byte*) render::colline#5 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    clc
    adc.z colline
    sta.z colline
    bcc !+
    inc.z colline+1
  !:
    // for( byte y : 0.. 24)
    // [48] (byte) render::y#1 ← ++ (byte) render::y#4 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [49] if((byte) render::y#1!=(byte) $19) goto render::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b1
    // render::@return
    // }
    // [50] return 
    rts
}
  // findcol
// findcol(byte zp(3) x, byte zp(2) y)
findcol: {
    .label x = 3
    .label y = 2
    .label xp = 8
    .label yp = 9
    .label i = 4
    .label mindiff = 5
    // [52] phi from findcol to findcol::@1 [phi:findcol->findcol::@1]
    // [52] phi (byte) findcol::mindiff#10 = (byte) $ff [phi:findcol->findcol::@1#0] -- vbuz1=vbuc1 
    lda #$ff
    sta.z mindiff
    // [52] phi (byte) findcol::mincol#10 = (byte) 0 [phi:findcol->findcol::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [52] phi (byte) findcol::i#10 = (byte) 0 [phi:findcol->findcol::@1#2] -- vbuz1=vbuc1 
    txa
    sta.z i
    // findcol::@1
  __b1:
    // for( byte i=0; i<numpoints; ++i)
    // [53] if((byte) findcol::i#10<(const byte) numpoints) goto findcol::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #numpoints
    bcc __b2
    // [54] phi from findcol::@1 to findcol::@return [phi:findcol::@1->findcol::@return]
    // [54] phi (byte) findcol::return#3 = (byte) findcol::mincol#10 [phi:findcol::@1->findcol::@return#0] -- register_copy 
    // findcol::@return
    // }
    // [55] return 
    rts
    // findcol::@2
  __b2:
    // xp = XPOS[i]
    // [56] (byte) findcol::xp#0 ← *((const byte*) XPOS + (byte) findcol::i#10) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z i
    lda XPOS,y
    sta.z xp
    // yp = YPOS[i]
    // [57] (byte) findcol::yp#0 ← *((const byte*) YPOS + (byte) findcol::i#10) -- vbuz1=pbuc1_derefidx_vbuz2 
    lda YPOS,y
    sta.z yp
    // if(x==xp)
    // [58] if((byte) findcol::x#0!=(byte) findcol::xp#0) goto findcol::@3 -- vbuz1_neq_vbuz2_then_la1 
    lda.z x
    cmp.z xp
    bne __b3
    // findcol::@9
    // if(y==yp)
    // [59] if((byte) findcol::y#0!=(byte) findcol::yp#0) goto findcol::@3 -- vbuz1_neq_vbuz2_then_la1 
    lda.z y
    cmp.z yp
    bne __b3
    // [54] phi from findcol::@9 to findcol::@return [phi:findcol::@9->findcol::@return]
    // [54] phi (byte) findcol::return#3 = (byte) 0 [phi:findcol::@9->findcol::@return#0] -- vbuxx=vbuc1 
    ldx #0
    rts
    // findcol::@3
  __b3:
    // if(x<xp)
    // [60] if((byte) findcol::x#0<(byte) findcol::xp#0) goto findcol::@4 -- vbuz1_lt_vbuz2_then_la1 
    lda.z x
    cmp.z xp
    bcc __b4
    // findcol::@10
    // diff = x-xp
    // [61] (byte) findcol::diff#2 ← (byte) findcol::x#0 - (byte) findcol::xp#0 -- vbuyy=vbuz1_minus_vbuz2 
    sec
    sbc.z xp
    tay
    // [62] phi from findcol::@10 findcol::@4 to findcol::@5 [phi:findcol::@10/findcol::@4->findcol::@5]
    // [62] phi (byte) findcol::diff#5 = (byte) findcol::diff#2 [phi:findcol::@10/findcol::@4->findcol::@5#0] -- register_copy 
    // findcol::@5
  __b5:
    // if(y<yp)
    // [63] if((byte) findcol::y#0<(byte) findcol::yp#0) goto findcol::@6 -- vbuz1_lt_vbuz2_then_la1 
    lda.z y
    cmp.z yp
    bcc __b6
    // findcol::@11
    // y-yp
    // [64] (byte~) findcol::$9 ← (byte) findcol::y#0 - (byte) findcol::yp#0 -- vbuaa=vbuz1_minus_vbuz2 
    sec
    sbc.z yp
    // diff = diff + (y-yp)
    // [65] (byte) findcol::diff#4 ← (byte) findcol::diff#5 + (byte~) findcol::$9 -- vbuaa=vbuyy_plus_vbuaa 
    sty.z $ff
    clc
    adc.z $ff
    // [66] phi from findcol::@11 findcol::@6 to findcol::@7 [phi:findcol::@11/findcol::@6->findcol::@7]
    // [66] phi (byte) findcol::diff#7 = (byte) findcol::diff#4 [phi:findcol::@11/findcol::@6->findcol::@7#0] -- register_copy 
    // findcol::@7
  __b7:
    // if(diff<mindiff)
    // [67] if((byte) findcol::diff#7>=(byte) findcol::mindiff#10) goto findcol::@13 -- vbuaa_ge_vbuz1_then_la1 
    cmp.z mindiff
    bcs __b13
    // findcol::@12
    // mincol = COLS[i]
    // [68] (byte) findcol::mincol#1 ← *((const byte*) COLS + (byte) findcol::i#10) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z i
    ldx COLS,y
    // [69] phi from findcol::@12 findcol::@13 to findcol::@8 [phi:findcol::@12/findcol::@13->findcol::@8]
    // [69] phi (byte) findcol::mindiff#12 = (byte) findcol::diff#7 [phi:findcol::@12/findcol::@13->findcol::@8#0] -- register_copy 
    // [69] phi (byte) findcol::mincol#4 = (byte) findcol::mincol#1 [phi:findcol::@12/findcol::@13->findcol::@8#1] -- register_copy 
    // findcol::@8
  __b8:
    // for( byte i=0; i<numpoints; ++i)
    // [70] (byte) findcol::i#1 ← ++ (byte) findcol::i#10 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [71] (byte) findcol::mindiff#13 ← (byte) findcol::mindiff#12 -- vbuz1=vbuaa 
    sta.z mindiff
    // [52] phi from findcol::@8 to findcol::@1 [phi:findcol::@8->findcol::@1]
    // [52] phi (byte) findcol::mindiff#10 = (byte) findcol::mindiff#13 [phi:findcol::@8->findcol::@1#0] -- register_copy 
    // [52] phi (byte) findcol::mincol#10 = (byte) findcol::mincol#4 [phi:findcol::@8->findcol::@1#1] -- register_copy 
    // [52] phi (byte) findcol::i#10 = (byte) findcol::i#1 [phi:findcol::@8->findcol::@1#2] -- register_copy 
    jmp __b1
    // findcol::@13
  __b13:
    // [72] (byte) findcol::mindiff#15 ← (byte) findcol::mindiff#10 -- vbuaa=vbuz1 
    lda.z mindiff
    jmp __b8
    // findcol::@6
  __b6:
    // yp-y
    // [73] (byte~) findcol::$11 ← (byte) findcol::yp#0 - (byte) findcol::y#0 -- vbuaa=vbuz1_minus_vbuz2 
    lda.z yp
    sec
    sbc.z y
    // diff = diff + (yp-y)
    // [74] (byte) findcol::diff#3 ← (byte) findcol::diff#5 + (byte~) findcol::$11 -- vbuaa=vbuyy_plus_vbuaa 
    sty.z $ff
    clc
    adc.z $ff
    jmp __b7
    // findcol::@4
  __b4:
    // diff = xp-x
    // [75] (byte) findcol::diff#1 ← (byte) findcol::xp#0 - (byte) findcol::x#0 -- vbuyy=vbuz1_minus_vbuz2 
    lda.z xp
    sec
    sbc.z x
    tay
    jmp __b5
}
  // initscreen
initscreen: {
    .label screen = 6
    // [77] phi from initscreen to initscreen::@1 [phi:initscreen->initscreen::@1]
    // [77] phi (byte*) initscreen::screen#2 = (const byte*) SCREEN [phi:initscreen->initscreen::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z screen
    lda #>SCREEN
    sta.z screen+1
    // initscreen::@1
  __b1:
    // for( byte* screen = SCREEN; screen<SCREEN+$03e8; ++screen)
    // [78] if((byte*) initscreen::screen#2<(const byte*) SCREEN+(word) $3e8) goto initscreen::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z screen+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z screen
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // initscreen::@return
    // }
    // [79] return 
    rts
    // initscreen::@2
  __b2:
    // *screen = FILL
    // [80] *((byte*) initscreen::screen#2) ← (const byte) FILL -- _deref_pbuz1=vbuc1 
    lda #FILL
    ldy #0
    sta (screen),y
    // for( byte* screen = SCREEN; screen<SCREEN+$03e8; ++screen)
    // [81] (byte*) initscreen::screen#1 ← ++ (byte*) initscreen::screen#2 -- pbuz1=_inc_pbuz1 
    inc.z screen
    bne !+
    inc.z screen+1
  !:
    // [77] phi from initscreen::@2 to initscreen::@1 [phi:initscreen::@2->initscreen::@1]
    // [77] phi (byte*) initscreen::screen#2 = (byte*) initscreen::screen#1 [phi:initscreen::@2->initscreen::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
  // Points to create the Voronoi from
  XPOS: .byte 5, $f, 6, $22, $15, $1f
  YPOS: .byte 5, 8, $e, 2, $11, $16
  COLS: .byte 1, 2, 3, 4, 5, 7

