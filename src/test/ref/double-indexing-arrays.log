Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) COLS
Culled Empty Block (label) main::@2

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte[$3e8]) MAPDATA ← { fill( $3e8, 0) }
  (byte[$100]) COLORMAP1 ← { fill( $100, 0) }
  (byte[$100]) COLORMAP2 ← { fill( $100, 0) }
  (byte*) SCREEN ← ((byte*)) (number) $400
  (byte*) COLS ← ((byte*)) (number) $d800
  to:@1

(void()) main()
main: scope:[main]  from @1
  (byte) main::x#0 ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@1/(byte) main::x#1 )
  *((byte*) SCREEN + (byte) main::x#2) ← *((byte[$3e8]) MAPDATA + (byte) main::x#2)
  *((byte*) COLS + (byte) main::x#2) ← *((byte[$100]) COLORMAP1 + *((byte[$3e8]) MAPDATA + (byte) main::x#2))
  (number~) main::$0 ← (number) $c8 + (byte) main::x#2
  (number~) main::$1 ← (number) $c8 + (byte) main::x#2
  *((byte*) SCREEN + (number~) main::$0) ← *((byte[$3e8]) MAPDATA + (number~) main::$1)
  (number~) main::$2 ← (number) $c8 + (byte) main::x#2
  (number~) main::$3 ← (number) $c8 + (byte) main::x#2
  *((byte*) COLS + (number~) main::$2) ← *((byte[$100]) COLORMAP1 + *((byte[$3e8]) MAPDATA + (number~) main::$3))
  (number~) main::$4 ← (number) $190 + (byte) main::x#2
  (number~) main::$5 ← (number) $190 + (byte) main::x#2
  *((byte*) SCREEN + (number~) main::$4) ← *((byte[$3e8]) MAPDATA + (number~) main::$5)
  (number~) main::$6 ← (number) $190 + (byte) main::x#2
  (number~) main::$7 ← (number) $190 + (byte) main::x#2
  *((byte*) COLS + (number~) main::$6) ← *((byte[$100]) COLORMAP1 + *((byte[$3e8]) MAPDATA + (number~) main::$7))
  (number~) main::$8 ← (number) $258 + (byte) main::x#2
  (number~) main::$9 ← (number) $258 + (byte) main::x#2
  *((byte*) SCREEN + (number~) main::$8) ← *((byte[$3e8]) MAPDATA + (number~) main::$9)
  (number~) main::$10 ← (number) $258 + (byte) main::x#2
  (number~) main::$11 ← (number) $258 + (byte) main::x#2
  *((byte*) COLS + (number~) main::$10) ← *((byte[$100]) COLORMAP2 + *((byte[$3e8]) MAPDATA + (number~) main::$11))
  (number~) main::$12 ← (number) $320 + (byte) main::x#2
  (number~) main::$13 ← (number) $320 + (byte) main::x#2
  *((byte*) SCREEN + (number~) main::$12) ← *((byte[$3e8]) MAPDATA + (number~) main::$13)
  (number~) main::$14 ← (number) $320 + (byte) main::x#2
  (number~) main::$15 ← (number) $320 + (byte) main::x#2
  *((byte*) COLS + (number~) main::$14) ← *((byte[$100]) COLORMAP2 + *((byte[$3e8]) MAPDATA + (number~) main::$15))
  (byte) main::x#1 ← (byte) main::x#2 + rangenext(0,$c8)
  (bool~) main::$16 ← (byte) main::x#1 != rangelast(0,$c8)
  if((bool~) main::$16) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
@1: scope:[]  from @begin
  call main 
  to:@2
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

SYMBOL TABLE SSA
(label) @1
(label) @2
(label) @begin
(label) @end
(byte[$100]) COLORMAP1
(byte[$100]) COLORMAP2
(byte*) COLS
(byte[$3e8]) MAPDATA
(byte*) SCREEN
(void()) main()
(number~) main::$0
(number~) main::$1
(number~) main::$10
(number~) main::$11
(number~) main::$12
(number~) main::$13
(number~) main::$14
(number~) main::$15
(bool~) main::$16
(number~) main::$2
(number~) main::$3
(number~) main::$4
(number~) main::$5
(number~) main::$6
(number~) main::$7
(number~) main::$8
(number~) main::$9
(label) main::@1
(label) main::@return
(byte) main::x !reg byte y
(byte) main::x#0 !reg byte y
(byte) main::x#1 !reg byte y
(byte) main::x#2 !reg byte y

Adding number conversion cast (unumber) $c8 in (number~) main::$0 ← (number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) main::$0 in (number~) main::$0 ← (unumber)(number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) $c8 in (number~) main::$1 ← (number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) main::$1 in (number~) main::$1 ← (unumber)(number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) $c8 in (number~) main::$2 ← (number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) main::$2 in (number~) main::$2 ← (unumber)(number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) $c8 in (number~) main::$3 ← (number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) main::$3 in (number~) main::$3 ← (unumber)(number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) $190 in (number~) main::$4 ← (number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) main::$4 in (number~) main::$4 ← (unumber)(number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) $190 in (number~) main::$5 ← (number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) main::$5 in (number~) main::$5 ← (unumber)(number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) $190 in (number~) main::$6 ← (number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) main::$6 in (number~) main::$6 ← (unumber)(number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) $190 in (number~) main::$7 ← (number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) main::$7 in (number~) main::$7 ← (unumber)(number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) $258 in (number~) main::$8 ← (number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) main::$8 in (number~) main::$8 ← (unumber)(number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) $258 in (number~) main::$9 ← (number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) main::$9 in (number~) main::$9 ← (unumber)(number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) $258 in (number~) main::$10 ← (number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) main::$10 in (number~) main::$10 ← (unumber)(number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) $258 in (number~) main::$11 ← (number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) main::$11 in (number~) main::$11 ← (unumber)(number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) $320 in (number~) main::$12 ← (number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) main::$12 in (number~) main::$12 ← (unumber)(number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) $320 in (number~) main::$13 ← (number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) main::$13 in (number~) main::$13 ← (unumber)(number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) $320 in (number~) main::$14 ← (number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) main::$14 in (number~) main::$14 ← (unumber)(number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) $320 in (number~) main::$15 ← (number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) main::$15 in (number~) main::$15 ← (unumber)(number) $320 + (byte) main::x#2
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) SCREEN ← (byte*)(number) $400
Inlining cast (byte*) COLS ← (byte*)(number) $d800
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 55296
Simplifying constant integer cast $c8
Simplifying constant integer cast $c8
Simplifying constant integer cast $c8
Simplifying constant integer cast $c8
Simplifying constant integer cast $190
Simplifying constant integer cast $190
Simplifying constant integer cast $190
Simplifying constant integer cast $190
Simplifying constant integer cast $258
Simplifying constant integer cast $258
Simplifying constant integer cast $258
Simplifying constant integer cast $258
Simplifying constant integer cast $320
Simplifying constant integer cast $320
Simplifying constant integer cast $320
Simplifying constant integer cast $320
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (word) $190
Finalized unsigned number type (word) $190
Finalized unsigned number type (word) $190
Finalized unsigned number type (word) $190
Finalized unsigned number type (word) $258
Finalized unsigned number type (word) $258
Finalized unsigned number type (word) $258
Finalized unsigned number type (word) $258
Finalized unsigned number type (word) $320
Finalized unsigned number type (word) $320
Finalized unsigned number type (word) $320
Finalized unsigned number type (word) $320
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) main::$0 ← (byte) $c8 + (byte) main::x#2
Inferred type updated to byte in (unumber~) main::$1 ← (byte) $c8 + (byte) main::x#2
Inferred type updated to byte in (unumber~) main::$2 ← (byte) $c8 + (byte) main::x#2
Inferred type updated to byte in (unumber~) main::$3 ← (byte) $c8 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$4 ← (word) $190 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$5 ← (word) $190 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$6 ← (word) $190 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$7 ← (word) $190 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$8 ← (word) $258 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$9 ← (word) $258 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$10 ← (word) $258 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$11 ← (word) $258 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$12 ← (word) $320 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$13 ← (word) $320 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$14 ← (word) $320 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$15 ← (word) $320 + (byte) main::x#2
Simple Condition (bool~) main::$16 [35] if((byte) main::x#1!=rangelast(0,$c8)) goto main::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [0] (byte[$3e8]) MAPDATA ← { fill( $3e8, 0) }
Constant right-side identified [1] (byte[$100]) COLORMAP1 ← { fill( $100, 0) }
Constant right-side identified [2] (byte[$100]) COLORMAP2 ← { fill( $100, 0) }
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte[$3e8]) MAPDATA = { fill( $3e8, 0) }
Constant (const byte[$100]) COLORMAP1 = { fill( $100, 0) }
Constant (const byte[$100]) COLORMAP2 = { fill( $100, 0) }
Constant (const byte*) SCREEN = (byte*) 1024
Constant (const byte*) COLS = (byte*) 55296
Constant (const byte) main::x#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [33] main::x#1 ← ++ main::x#2 to ++
Resolved ranged comparison value [35] if(main::x#1!=rangelast(0,$c8)) goto main::@1 to (number) $c9
De-inlining pointer[w] to *(pointer+w)   [17] *((const byte*) SCREEN + (word~) main::$4) ← *((const byte[$3e8]) MAPDATA + (word~) main::$5)
De-inlining pointer[w] to *(pointer+w)   [17] *((const byte*) SCREEN + (word~) main::$4) ← *((byte*~) main::$17)
De-inlining pointer[w] to *(pointer+w)   [20] *((const byte*) COLS + (word~) main::$6) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA + (word~) main::$7))
De-inlining pointer[w] to *(pointer+w)   [20] *((const byte*) COLS + (word~) main::$6) ← *((const byte[$100]) COLORMAP1 + *((byte*~) main::$19))
De-inlining pointer[w] to *(pointer+w)   [23] *((const byte*) SCREEN + (word~) main::$8) ← *((const byte[$3e8]) MAPDATA + (word~) main::$9)
De-inlining pointer[w] to *(pointer+w)   [23] *((const byte*) SCREEN + (word~) main::$8) ← *((byte*~) main::$21)
De-inlining pointer[w] to *(pointer+w)   [26] *((const byte*) COLS + (word~) main::$10) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA + (word~) main::$11))
De-inlining pointer[w] to *(pointer+w)   [26] *((const byte*) COLS + (word~) main::$10) ← *((const byte[$100]) COLORMAP2 + *((byte*~) main::$23))
De-inlining pointer[w] to *(pointer+w)   [29] *((const byte*) SCREEN + (word~) main::$12) ← *((const byte[$3e8]) MAPDATA + (word~) main::$13)
De-inlining pointer[w] to *(pointer+w)   [29] *((const byte*) SCREEN + (word~) main::$12) ← *((byte*~) main::$25)
De-inlining pointer[w] to *(pointer+w)   [32] *((const byte*) COLS + (word~) main::$14) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA + (word~) main::$15))
De-inlining pointer[w] to *(pointer+w)   [32] *((const byte*) COLS + (word~) main::$14) ← *((const byte[$100]) COLORMAP2 + *((byte*~) main::$27))
Successful SSA optimization Pass2DeInlineWordDerefIdx
Adding number conversion cast (unumber) $c9 in if((byte) main::x#1!=(number) $c9) goto main::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $c9
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $c9
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings (const byte) main::x#0
Constant inlined main::x#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(MAPDATA+$c8 + main::$1)
Consolidated array index constant in assignment *(SCREEN+$c8 + main::$0)
Consolidated array index constant in assignment *(MAPDATA+$c8 + main::$3)
Consolidated array index constant in assignment *(COLS+$c8 + main::$2)
Consolidated constant in assignment main::$17
Consolidated constant in assignment main::$18
Consolidated constant in assignment main::$19
Consolidated constant in assignment main::$20
Consolidated constant in assignment main::$21
Consolidated constant in assignment main::$22
Consolidated constant in assignment main::$23
Consolidated constant in assignment main::$24
Consolidated constant in assignment main::$25
Consolidated constant in assignment main::$26
Consolidated constant in assignment main::$27
Consolidated constant in assignment main::$28
Successful SSA optimization Pass2ConstantAdditionElimination
Alias (byte) main::x#2 = (byte~) main::$0 (byte~) main::$1 (byte~) main::$2 (byte~) main::$3 (word~) main::$4 (word~) main::$5 (word~) main::$6 (word~) main::$7 (word~) main::$8 (word~) main::$9 (word~) main::$10 (word~) main::$11 (word~) main::$12 (word~) main::$13 (word~) main::$14 (word~) main::$15 
Successful SSA optimization Pass2AliasElimination
Converting *(pointer+n) to pointer[n] [13] *((byte*~) main::$18) ← *((byte*~) main::$17)  -- *(MAPDATA+$190 + main::x#2)
Converting *(pointer+n) to pointer[n] [13] *((byte*~) main::$18) ← *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2)  -- *(SCREEN+$190 + main::x#2)
Converting *(pointer+n) to pointer[n] [18] *((byte*~) main::$20) ← *((const byte[$100]) COLORMAP1 + *((byte*~) main::$19))  -- *(MAPDATA+$190 + main::x#2)
Converting *(pointer+n) to pointer[n] [18] *((byte*~) main::$20) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2))  -- *(COLS+$190 + main::x#2)
Converting *(pointer+n) to pointer[n] [23] *((byte*~) main::$22) ← *((byte*~) main::$21)  -- *(MAPDATA+$258 + main::x#2)
Converting *(pointer+n) to pointer[n] [23] *((byte*~) main::$22) ← *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2)  -- *(SCREEN+$258 + main::x#2)
Converting *(pointer+n) to pointer[n] [28] *((byte*~) main::$24) ← *((const byte[$100]) COLORMAP2 + *((byte*~) main::$23))  -- *(MAPDATA+$258 + main::x#2)
Converting *(pointer+n) to pointer[n] [28] *((byte*~) main::$24) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2))  -- *(COLS+$258 + main::x#2)
Converting *(pointer+n) to pointer[n] [33] *((byte*~) main::$26) ← *((byte*~) main::$25)  -- *(MAPDATA+$320 + main::x#2)
Converting *(pointer+n) to pointer[n] [33] *((byte*~) main::$26) ← *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2)  -- *(SCREEN+$320 + main::x#2)
Converting *(pointer+n) to pointer[n] [38] *((byte*~) main::$28) ← *((const byte[$100]) COLORMAP2 + *((byte*~) main::$27))  -- *(MAPDATA+$320 + main::x#2)
Converting *(pointer+n) to pointer[n] [38] *((byte*~) main::$28) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2))  -- *(COLS+$320 + main::x#2)
Successful SSA optimization Pass2InlineDerefIdx
Eliminating unused variable (byte*~) main::$17 and assignment [5] (byte*~) main::$17 ← (const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$18 and assignment [6] (byte*~) main::$18 ← (const byte*) SCREEN+(word) $190 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$19 and assignment [8] (byte*~) main::$19 ← (const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$20 and assignment [9] (byte*~) main::$20 ← (const byte*) COLS+(word) $190 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$21 and assignment [11] (byte*~) main::$21 ← (const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$22 and assignment [12] (byte*~) main::$22 ← (const byte*) SCREEN+(word) $258 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$23 and assignment [14] (byte*~) main::$23 ← (const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$24 and assignment [15] (byte*~) main::$24 ← (const byte*) COLS+(word) $258 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$25 and assignment [17] (byte*~) main::$25 ← (const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$26 and assignment [18] (byte*~) main::$26 ← (const byte*) SCREEN+(word) $320 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$27 and assignment [20] (byte*~) main::$27 ← (const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$28 and assignment [21] (byte*~) main::$28 ← (const byte*) COLS+(word) $320 + (byte) main::x#2
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting main::@3(between main::@1 and main::@1)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to main:2 

Created 1 initial phi equivalence classes
Coalesced [20] main::x#3 ← main::x#1
Coalesced down to 1 phi equivalence classes
Culled Empty Block (label) @2
Culled Empty Block (label) main::@3
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [5] (byte) main::x#2 ← phi( main/(byte) 0 main::@1/(byte) main::x#1 )
  [6] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA + (byte) main::x#2)
  [7] *((const byte*) COLS + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA + (byte) main::x#2))
  [8] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2)
  [9] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2))
  [10] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2)
  [11] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2))
  [12] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2)
  [13] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2))
  [14] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2)
  [15] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2))
  [16] (byte) main::x#1 ← ++ (byte) main::x#2
  [17] if((byte) main::x#1!=(byte) $c9) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  [18] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) main()
(byte) main::x !reg byte y
(byte) main::x#1 !reg byte y 16.5
(byte) main::x#2 !reg byte y 22.0

Initial phi equivalence classes
[ main::x#2 main::x#1 ]
Complete equivalence classes
[ main::x#2 main::x#1 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Tests that constant offset indexing into arrays is handled correctly
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label COLS = $d800
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    // [5] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    // [5] phi (byte) main::x#2 = (byte) 0 [phi:main->main::@1#0] -- vbuyy=vbuc1 
    ldy #0
    jmp b1
    // [5] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
    // [5] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
    // main::@1
  b1:
    // [6] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA,y
    sta SCREEN,y
    // [7] *((const byte*) COLS + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA,y
    lda COLORMAP1,x
    sta COLS,y
    // [8] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$c8,y
    sta SCREEN+$c8,y
    // [9] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$c8,y
    lda COLORMAP1,x
    sta COLS+$c8,y
    // [10] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$190,y
    sta SCREEN+$190,y
    // [11] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$190,y
    lda COLORMAP1,x
    sta COLS+$190,y
    // [12] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$258,y
    sta SCREEN+$258,y
    // [13] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$258,y
    lda COLORMAP2,x
    sta COLS+$258,y
    // [14] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$320,y
    sta SCREEN+$320,y
    // [15] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$320,y
    lda COLORMAP2,x
    sta COLS+$320,y
    // [16] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuyy=_inc_vbuyy 
    iny
    // [17] if((byte) main::x#1!=(byte) $c9) goto main::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$c9
    bne b1_from_b1
    jmp breturn
    // main::@return
  breturn:
    // [18] return 
    rts
}
  // File Data
  MAPDATA: .fill $3e8, 0
  COLORMAP1: .fill $100, 0
  COLORMAP2: .fill $100, 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [7] *((const byte*) COLS + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [8] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [9] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [10] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [11] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [12] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [13] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [14] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a 
Statement [15] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2)) [ main::x#2 ] ( main:2 [ main::x#2 ] ) always clobbers reg byte a reg byte x 
Statement [16] (byte) main::x#1 ← ++ (byte) main::x#2 [ main::x#1 ] ( main:2 [ main::x#1 ] ) always clobbers reg byte y 
Potential registers reg byte y [ main::x#2 main::x#1 ] : reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 38.5: reg byte y [ main::x#2 main::x#1 ] 
Uplift Scope [] 

Uplifting [main] best 1368 combination reg byte y [ main::x#2 main::x#1 ] 
Uplifting [] best 1368 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests that constant offset indexing into arrays is handled correctly
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label COLS = $d800
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    // [5] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    // [5] phi (byte) main::x#2 = (byte) 0 [phi:main->main::@1#0] -- vbuyy=vbuc1 
    ldy #0
    jmp b1
    // [5] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
    // [5] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
    // main::@1
  b1:
    // [6] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA,y
    sta SCREEN,y
    // [7] *((const byte*) COLS + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA,y
    lda COLORMAP1,x
    sta COLS,y
    // [8] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$c8,y
    sta SCREEN+$c8,y
    // [9] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$c8,y
    lda COLORMAP1,x
    sta COLS+$c8,y
    // [10] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$190,y
    sta SCREEN+$190,y
    // [11] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$190,y
    lda COLORMAP1,x
    sta COLS+$190,y
    // [12] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$258,y
    sta SCREEN+$258,y
    // [13] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$258,y
    lda COLORMAP2,x
    sta COLS+$258,y
    // [14] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$320,y
    sta SCREEN+$320,y
    // [15] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$320,y
    lda COLORMAP2,x
    sta COLS+$320,y
    // [16] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuyy=_inc_vbuyy 
    iny
    // [17] if((byte) main::x#1!=(byte) $c9) goto main::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$c9
    bne b1_from_b1
    jmp breturn
    // main::@return
  breturn:
    // [18] return 
    rts
}
  // File Data
  MAPDATA: .fill $3e8, 0
  COLORMAP1: .fill $100, 0
  COLORMAP2: .fill $100, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label b1_from_b1 with b1
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b1_from_main:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte[$100]) COLORMAP1 COLORMAP1 = { fill( $100, 0) }
(const byte[$100]) COLORMAP2 COLORMAP2 = { fill( $100, 0) }
(const byte*) COLS COLS = (byte*) 55296
(const byte[$3e8]) MAPDATA MAPDATA = { fill( $3e8, 0) }
(const byte*) SCREEN SCREEN = (byte*) 1024
(void()) main()
(label) main::@1
(label) main::@return
(byte) main::x !reg byte y
(byte) main::x#1 !reg byte y 16.5
(byte) main::x#2 !reg byte y 22.0

reg byte y [ main::x#2 main::x#1 ]


FINAL ASSEMBLER
Score: 1266

  // File Comments
// Tests that constant offset indexing into arrays is handled correctly
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label COLS = $d800
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // [5] phi from main to main::@1 [phi:main->main::@1]
    // [5] phi (byte) main::x#2 = (byte) 0 [phi:main->main::@1#0] -- vbuyy=vbuc1 
    ldy #0
    // [5] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
    // [5] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@1->main::@1#0] -- register_copy 
    // main::@1
  b1:
    // SCREEN[x] = MAPDATA[x]
    // [6] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA,y
    sta SCREEN,y
    // COLS[x] = COLORMAP1[MAPDATA[x]]
    // [7] *((const byte*) COLS + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA,y
    lda COLORMAP1,x
    sta COLS,y
    // SCREEN[200+x] = MAPDATA[200+x]
    // [8] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$c8,y
    sta SCREEN+$c8,y
    // COLS[200+x] = COLORMAP1[MAPDATA[200+x]]
    // [9] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(byte) $c8 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$c8,y
    lda COLORMAP1,x
    sta COLS+$c8,y
    // SCREEN[400+x] = MAPDATA[400+x]
    // [10] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$190,y
    sta SCREEN+$190,y
    // COLS[400+x] = COLORMAP1[MAPDATA[400+x]]
    // [11] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP1 + *((const byte[$3e8]) MAPDATA+(word) $190 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$190,y
    lda COLORMAP1,x
    sta COLS+$190,y
    // SCREEN[600+x] = MAPDATA[600+x]
    // [12] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$258,y
    sta SCREEN+$258,y
    // COLS[600+x] = COLORMAP2[MAPDATA[600+x]]
    // [13] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $258 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$258,y
    lda COLORMAP2,x
    sta COLS+$258,y
    // SCREEN[800+x] = MAPDATA[800+x]
    // [14] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MAPDATA+$320,y
    sta SCREEN+$320,y
    // COLS[800+x] = COLORMAP2[MAPDATA[800+x]]
    // [15] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte[$100]) COLORMAP2 + *((const byte[$3e8]) MAPDATA+(word) $320 + (byte) main::x#2)) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_(pbuc3_derefidx_vbuyy) 
    ldx MAPDATA+$320,y
    lda COLORMAP2,x
    sta COLS+$320,y
    // for (byte register(y) x: 0..200)
    // [16] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuyy=_inc_vbuyy 
    iny
    // [17] if((byte) main::x#1!=(byte) $c9) goto main::@1 -- vbuyy_neq_vbuc1_then_la1 
    cpy #$c9
    bne b1
    // main::@return
    // }
    // [18] return 
    rts
}
  // File Data
  MAPDATA: .fill $3e8, 0
  COLORMAP1: .fill $100, 0
  COLORMAP2: .fill $100, 0

