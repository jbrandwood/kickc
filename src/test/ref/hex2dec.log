Fixing pointer array-indexing *((word[]) UTOA10_SUB + (byte) utoa10w::i)
Fixing pointer array-indexing *((word[]) UTOA10_SUB + (byte) utoa10w::i)
Adding pointer type conversion cast (byte*) control in (byte*) control ← (number) $d011
Adding pointer type conversion cast (byte*) raster in (byte*) raster ← (number) $d012
Adding pointer type conversion cast (byte*) bordercol in (byte*) bordercol ← (number) $d020
Adding pointer type conversion cast (byte*) main::screen in (byte*) main::screen ← (number) $400
Adding pointer type conversion cast (byte*) cls::screen in (byte*) cls::screen ← (number) $400
Identified constant variable (byte*) cls::screen
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@10
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@8
Culled Empty Block (label) @1
Culled Empty Block (label) cls::@2
Culled Empty Block (label) utoa10w::@1
Culled Empty Block (label) utoa10w::@5
Culled Empty Block (label) utoa10w::@6
Culled Empty Block (label) utoa10w::@7
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) utoa16n::@5

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) control#0 ← ((byte*)) (number) $d011
  (byte*) raster#0 ← ((byte*)) (number) $d012
  (byte*) bordercol#0 ← ((byte*)) (number) $d020
  to:@2
main: scope:[main]  from @5
  asm { sei  }
  call cls 
  to:main::@11
main::@11: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@11 main::@6
  if(true) goto main::@4
  to:main::@return
main::@4: scope:[main]  from main::@1 main::@4
  (number~) main::$1 ← *((byte*) control#0) & (number) $80
  (byte~) main::$2 ← *((byte*) raster#0) >> (number) 1
  (number~) main::$3 ← (number~) main::$1 | (byte~) main::$2
  (byte) main::rst#0 ← (number~) main::$3
  (bool~) main::$4 ← (byte) main::rst#0 != (number) $30
  if((bool~) main::$4) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@4
  (byte*) main::screen#0 ← ((byte*)) (number) $400
  *((byte*) bordercol#0) ← (number) 1
  (byte) main::time_start#0 ← *((byte*) raster#0)
  (word) utoa16w::value#0 ← (number) 0
  (byte*) utoa16w::dst#0 ← (byte*) main::screen#0
  call utoa16w 
  to:main::@12
main::@12: scope:[main]  from main::@5
  (byte) main::time_start#5 ← phi( main::@5/(byte) main::time_start#0 )
  (byte*) main::screen#5 ← phi( main::@5/(byte*) main::screen#0 )
  *((byte*) bordercol#0) ← ++ *((byte*) bordercol#0)
  (byte*) main::screen#1 ← (byte*) main::screen#5 + (number) $28
  (word) utoa16w::value#1 ← (number) $4d2
  (byte*) utoa16w::dst#1 ← (byte*) main::screen#1
  call utoa16w 
  to:main::@13
main::@13: scope:[main]  from main::@12
  (byte) main::time_start#4 ← phi( main::@12/(byte) main::time_start#5 )
  (byte*) main::screen#6 ← phi( main::@12/(byte*) main::screen#1 )
  *((byte*) bordercol#0) ← ++ *((byte*) bordercol#0)
  (byte*) main::screen#2 ← (byte*) main::screen#6 + (number) $28
  (word) utoa16w::value#2 ← (number) $162e
  (byte*) utoa16w::dst#2 ← (byte*) main::screen#2
  call utoa16w 
  to:main::@14
main::@14: scope:[main]  from main::@13
  (byte) main::time_start#3 ← phi( main::@13/(byte) main::time_start#4 )
  (byte*) main::screen#7 ← phi( main::@13/(byte*) main::screen#2 )
  *((byte*) bordercol#0) ← ++ *((byte*) bordercol#0)
  (byte*) main::screen#3 ← (byte*) main::screen#7 + (number) $28
  (word) utoa16w::value#3 ← (number) $270f
  (byte*) utoa16w::dst#3 ← (byte*) main::screen#3
  call utoa16w 
  to:main::@15
main::@15: scope:[main]  from main::@14
  (byte) main::time_start#2 ← phi( main::@14/(byte) main::time_start#3 )
  (byte*) main::screen#8 ← phi( main::@14/(byte*) main::screen#3 )
  *((byte*) bordercol#0) ← ++ *((byte*) bordercol#0)
  (byte*) main::screen#4 ← (byte*) main::screen#8 + (number) $28
  (word) utoa16w::value#4 ← (number) $e608
  (byte*) utoa16w::dst#4 ← (byte*) main::screen#4
  call utoa16w 
  to:main::@16
main::@16: scope:[main]  from main::@15
  (byte*) main::screen#9 ← phi( main::@15/(byte*) main::screen#4 )
  (byte) main::time_start#1 ← phi( main::@15/(byte) main::time_start#2 )
  (byte) main::time_end#0 ← *((byte*) raster#0)
  *((byte*) bordercol#0) ← (number) 0
  (byte~) main::$10 ← (byte) main::time_end#0 - (byte) main::time_start#1
  (byte) main::time#0 ← (byte~) main::$10
  (word~) main::$11 ← ((word)) (byte) main::time#0
  (byte*~) main::$12 ← (byte*) main::screen#9 + (number) $50
  (word) utoa10w::value#0 ← (word~) main::$11
  (byte*) utoa10w::dst#0 ← (byte*~) main::$12
  call utoa10w 
  to:main::@17
main::@17: scope:[main]  from main::@16
  (byte*) main::screen#11 ← phi( main::@16/(byte*) main::screen#9 )
  (byte[]) main::msg#0 ← (const string) main::$17
  (byte) main::i#0 ← (number) 0
  to:main::@6
main::@6: scope:[main]  from main::@17 main::@6
  (byte) main::i#2 ← phi( main::@17/(byte) main::i#0 main::@6/(byte) main::i#1 )
  (byte*) main::screen#10 ← phi( main::@17/(byte*) main::screen#11 main::@6/(byte*) main::screen#10 )
  (byte*~) main::$14 ← (byte*) main::screen#10 + (number) $50
  (byte*~) main::$15 ← (byte*~) main::$14 + (number) 3
  *((byte*~) main::$15 + (byte) main::i#2) ← *((byte[]) main::msg#0 + (byte) main::i#2)
  (byte) main::i#1 ← ++ (byte) main::i#2
  (bool~) main::$16 ← *((byte[]) main::msg#0 + (byte) main::i#1) != (number) 0
  if((bool~) main::$16) goto main::@6
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return
cls: scope:[cls]  from main
  (byte*) cls::screen#0 ← ((byte*)) (number) $400
  (byte*~) cls::$0 ← (byte*) cls::screen#0 + (number) $3e7
  (byte*) cls::sc#0 ← (byte*) cls::screen#0
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  (byte*) cls::sc#2 ← phi( cls/(byte*) cls::sc#0 cls::@1/(byte*) cls::sc#1 )
  *((byte*) cls::sc#2) ← (byte) ' '
  (byte*) cls::sc#1 ← (byte*) cls::sc#2 + rangenext(cls::screen#0,cls::$0)
  (bool~) cls::$1 ← (byte*) cls::sc#1 != rangelast(cls::screen#0,cls::$0)
  if((bool~) cls::$1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  return 
  to:@return
@2: scope:[]  from @begin
  (byte[]) DIGITS#0 ← (const string) $0
  (word[]) UTOA10_SUB#0 ← { (number) $7530, (number) $2710, (number) $bb8, (number) $3e8, (number) $12c, (number) $64, (number) $1e, (number) $a }
  (byte[]) UTOA10_VAL#0 ← { (number) 3, (number) 1, (number) 3, (number) 1, (number) 3, (number) 1, (number) 3, (number) 1 }
  to:@5
utoa10w: scope:[utoa10w]  from main::@16
  (byte*) utoa10w::dst#10 ← phi( main::@16/(byte*) utoa10w::dst#0 )
  (word) utoa10w::value#5 ← phi( main::@16/(word) utoa10w::value#0 )
  (byte) utoa10w::bStarted#0 ← (number) 0
  (byte) utoa10w::digit#0 ← (number) 0
  (byte) utoa10w::i#0 ← (number) 0
  to:utoa10w::@2
utoa10w::@2: scope:[utoa10w]  from utoa10w utoa10w::@10 utoa10w::@3
  (byte*) utoa10w::dst#9 ← phi( utoa10w/(byte*) utoa10w::dst#10 utoa10w::@10/(byte*) utoa10w::dst#6 utoa10w::@3/(byte*) utoa10w::dst#11 )
  (byte) utoa10w::bStarted#4 ← phi( utoa10w/(byte) utoa10w::bStarted#0 utoa10w::@10/(byte) utoa10w::bStarted#5 utoa10w::@3/(byte) utoa10w::bStarted#1 )
  (byte) utoa10w::digit#5 ← phi( utoa10w/(byte) utoa10w::digit#0 utoa10w::@10/(byte) utoa10w::digit#7 utoa10w::@3/(byte) utoa10w::digit#1 )
  (word) utoa10w::value#2 ← phi( utoa10w/(word) utoa10w::value#5 utoa10w::@10/(word) utoa10w::value#6 utoa10w::@3/(word) utoa10w::value#1 )
  (byte) utoa10w::i#2 ← phi( utoa10w/(byte) utoa10w::i#0 utoa10w::@10/(byte) utoa10w::i#1 utoa10w::@3/(byte) utoa10w::i#3 )
  (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 * (const byte) SIZEOF_WORD
  (bool~) utoa10w::$1 ← (word) utoa10w::value#2 >= *((word[]) UTOA10_SUB#0 + (byte~) utoa10w::$8)
  if((bool~) utoa10w::$1) goto utoa10w::@3
  to:utoa10w::@4
utoa10w::@3: scope:[utoa10w]  from utoa10w::@2
  (byte*) utoa10w::dst#11 ← phi( utoa10w::@2/(byte*) utoa10w::dst#9 )
  (word) utoa10w::value#3 ← phi( utoa10w::@2/(word) utoa10w::value#2 )
  (byte) utoa10w::i#3 ← phi( utoa10w::@2/(byte) utoa10w::i#2 )
  (byte) utoa10w::digit#3 ← phi( utoa10w::@2/(byte) utoa10w::digit#5 )
  (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((byte[]) UTOA10_VAL#0 + (byte) utoa10w::i#3)
  (byte~) utoa10w::$9 ← (byte) utoa10w::i#3 * (const byte) SIZEOF_WORD
  (word) utoa10w::value#1 ← (word) utoa10w::value#3 - *((word[]) UTOA10_SUB#0 + (byte~) utoa10w::$9)
  (byte) utoa10w::bStarted#1 ← (number) 1
  to:utoa10w::@2
utoa10w::@4: scope:[utoa10w]  from utoa10w::@2
  (byte) utoa10w::digit#8 ← phi( utoa10w::@2/(byte) utoa10w::digit#5 )
  (byte*) utoa10w::dst#8 ← phi( utoa10w::@2/(byte*) utoa10w::dst#9 )
  (word) utoa10w::value#8 ← phi( utoa10w::@2/(word) utoa10w::value#2 )
  (byte) utoa10w::bStarted#3 ← phi( utoa10w::@2/(byte) utoa10w::bStarted#4 )
  (byte) utoa10w::i#4 ← phi( utoa10w::@2/(byte) utoa10w::i#2 )
  (number~) utoa10w::$2 ← (byte) utoa10w::i#4 & (number) 1
  (bool~) utoa10w::$3 ← (number~) utoa10w::$2 != (number) 0
  (bool~) utoa10w::$4 ← ! (bool~) utoa10w::$3
  if((bool~) utoa10w::$4) goto utoa10w::@10
  to:utoa10w::@8
utoa10w::@10: scope:[utoa10w]  from utoa10w::@11 utoa10w::@4
  (byte) utoa10w::bStarted#5 ← phi( utoa10w::@11/(byte) utoa10w::bStarted#6 utoa10w::@4/(byte) utoa10w::bStarted#3 )
  (byte) utoa10w::digit#7 ← phi( utoa10w::@11/(byte) utoa10w::digit#2 utoa10w::@4/(byte) utoa10w::digit#8 )
  (byte*) utoa10w::dst#6 ← phi( utoa10w::@11/(byte*) utoa10w::dst#7 utoa10w::@4/(byte*) utoa10w::dst#8 )
  (word) utoa10w::value#6 ← phi( utoa10w::@11/(word) utoa10w::value#7 utoa10w::@4/(word) utoa10w::value#8 )
  (byte) utoa10w::i#5 ← phi( utoa10w::@11/(byte) utoa10w::i#6 utoa10w::@4/(byte) utoa10w::i#4 )
  (byte) utoa10w::i#1 ← (byte) utoa10w::i#5 + rangenext(0,7)
  (bool~) utoa10w::$7 ← (byte) utoa10w::i#1 != rangelast(0,7)
  if((bool~) utoa10w::$7) goto utoa10w::@2
  to:utoa10w::@12
utoa10w::@8: scope:[utoa10w]  from utoa10w::@4
  (word) utoa10w::value#9 ← phi( utoa10w::@4/(word) utoa10w::value#8 )
  (byte) utoa10w::i#7 ← phi( utoa10w::@4/(byte) utoa10w::i#4 )
  (byte*) utoa10w::dst#5 ← phi( utoa10w::@4/(byte*) utoa10w::dst#8 )
  (byte) utoa10w::digit#6 ← phi( utoa10w::@4/(byte) utoa10w::digit#8 )
  (byte) utoa10w::bStarted#2 ← phi( utoa10w::@4/(byte) utoa10w::bStarted#3 )
  (bool~) utoa10w::$5 ← (byte) utoa10w::bStarted#2 != (number) 0
  (bool~) utoa10w::$6 ← ! (bool~) utoa10w::$5
  if((bool~) utoa10w::$6) goto utoa10w::@11
  to:utoa10w::@9
utoa10w::@11: scope:[utoa10w]  from utoa10w::@8 utoa10w::@9
  (byte) utoa10w::bStarted#6 ← phi( utoa10w::@8/(byte) utoa10w::bStarted#2 utoa10w::@9/(byte) utoa10w::bStarted#7 )
  (byte*) utoa10w::dst#7 ← phi( utoa10w::@8/(byte*) utoa10w::dst#5 utoa10w::@9/(byte*) utoa10w::dst#1 )
  (word) utoa10w::value#7 ← phi( utoa10w::@8/(word) utoa10w::value#9 utoa10w::@9/(word) utoa10w::value#10 )
  (byte) utoa10w::i#6 ← phi( utoa10w::@8/(byte) utoa10w::i#7 utoa10w::@9/(byte) utoa10w::i#8 )
  (byte) utoa10w::digit#2 ← (number) 0
  to:utoa10w::@10
utoa10w::@9: scope:[utoa10w]  from utoa10w::@8
  (byte) utoa10w::bStarted#7 ← phi( utoa10w::@8/(byte) utoa10w::bStarted#2 )
  (word) utoa10w::value#10 ← phi( utoa10w::@8/(word) utoa10w::value#9 )
  (byte) utoa10w::i#8 ← phi( utoa10w::@8/(byte) utoa10w::i#7 )
  (byte*) utoa10w::dst#3 ← phi( utoa10w::@8/(byte*) utoa10w::dst#5 )
  (byte) utoa10w::digit#4 ← phi( utoa10w::@8/(byte) utoa10w::digit#6 )
  *((byte*) utoa10w::dst#3) ← *((byte[]) DIGITS#0 + (byte) utoa10w::digit#4)
  (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#3
  to:utoa10w::@11
utoa10w::@12: scope:[utoa10w]  from utoa10w::@10
  (byte*) utoa10w::dst#4 ← phi( utoa10w::@10/(byte*) utoa10w::dst#6 )
  (word) utoa10w::value#4 ← phi( utoa10w::@10/(word) utoa10w::value#6 )
  (byte~) utoa10w::$0 ← ((byte)) (word) utoa10w::value#4
  *((byte*) utoa10w::dst#4) ← *((byte[]) DIGITS#0 + (byte~) utoa10w::$0)
  (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4
  *((byte*) utoa10w::dst#2) ← (number) 0
  to:utoa10w::@return
utoa10w::@return: scope:[utoa10w]  from utoa10w::@12
  return 
  to:@return
utoa16w: scope:[utoa16w]  from main::@12 main::@13 main::@14 main::@15 main::@5
  (byte*) utoa16w::dst#5 ← phi( main::@12/(byte*) utoa16w::dst#1 main::@13/(byte*) utoa16w::dst#2 main::@14/(byte*) utoa16w::dst#3 main::@15/(byte*) utoa16w::dst#4 main::@5/(byte*) utoa16w::dst#0 )
  (word) utoa16w::value#5 ← phi( main::@12/(word) utoa16w::value#1 main::@13/(word) utoa16w::value#2 main::@14/(word) utoa16w::value#3 main::@15/(word) utoa16w::value#4 main::@5/(word) utoa16w::value#0 )
  (byte) utoa16w::started#0 ← (number) 0
  (byte~) utoa16w::$0 ← > (word) utoa16w::value#5
  (byte~) utoa16w::$1 ← (byte~) utoa16w::$0 >> (number) 4
  (byte**~) utoa16w::$2 ← & (byte*) utoa16w::dst#5
  (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$1
  (word**) utoa16n::dst#0 ← (byte**~) utoa16w::$2
  (byte) utoa16n::started#0 ← (byte) utoa16w::started#0
  call utoa16n 
  (byte) utoa16n::return#0 ← (byte) utoa16n::return#5
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  (byte*) utoa16w::dst#6 ← phi( utoa16w/(byte*) utoa16w::dst#5 )
  (word) utoa16w::value#6 ← phi( utoa16w/(word) utoa16w::value#5 )
  (byte) utoa16n::return#6 ← phi( utoa16w/(byte) utoa16n::return#0 )
  (byte~) utoa16w::$3 ← (byte) utoa16n::return#6
  (byte) utoa16w::started#1 ← (byte~) utoa16w::$3
  (byte~) utoa16w::$4 ← > (word) utoa16w::value#6
  (number~) utoa16w::$5 ← (byte~) utoa16w::$4 & (number) $f
  (byte**~) utoa16w::$6 ← & (byte*) utoa16w::dst#6
  (byte) utoa16n::nybble#1 ← (number~) utoa16w::$5
  (word**) utoa16n::dst#1 ← (byte**~) utoa16w::$6
  (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  call utoa16n 
  (byte) utoa16n::return#1 ← (byte) utoa16n::return#5
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  (byte*) utoa16w::dst#7 ← phi( utoa16w::@1/(byte*) utoa16w::dst#6 )
  (word) utoa16w::value#7 ← phi( utoa16w::@1/(word) utoa16w::value#6 )
  (byte) utoa16n::return#7 ← phi( utoa16w::@1/(byte) utoa16n::return#1 )
  (byte~) utoa16w::$7 ← (byte) utoa16n::return#7
  (byte) utoa16w::started#2 ← (byte~) utoa16w::$7
  (byte~) utoa16w::$8 ← < (word) utoa16w::value#7
  (byte~) utoa16w::$9 ← (byte~) utoa16w::$8 >> (number) 4
  (byte**~) utoa16w::$10 ← & (byte*) utoa16w::dst#7
  (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$9
  (word**) utoa16n::dst#2 ← (byte**~) utoa16w::$10
  (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  call utoa16n 
  (byte) utoa16n::return#2 ← (byte) utoa16n::return#5
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  (byte*) utoa16w::dst#8 ← phi( utoa16w::@2/(byte*) utoa16w::dst#7 )
  (word) utoa16w::value#8 ← phi( utoa16w::@2/(word) utoa16w::value#7 )
  (byte) utoa16n::return#8 ← phi( utoa16w::@2/(byte) utoa16n::return#2 )
  (byte~) utoa16w::$11 ← (byte) utoa16n::return#8
  (byte) utoa16w::started#3 ← (byte~) utoa16w::$11
  (byte~) utoa16w::$12 ← < (word) utoa16w::value#8
  (number~) utoa16w::$13 ← (byte~) utoa16w::$12 & (number) $f
  (byte**~) utoa16w::$14 ← & (byte*) utoa16w::dst#8
  (byte) utoa16n::nybble#3 ← (number~) utoa16w::$13
  (word**) utoa16n::dst#3 ← (byte**~) utoa16w::$14
  (byte) utoa16n::started#3 ← (number) 1
  call utoa16n 
  (byte) utoa16n::return#3 ← (byte) utoa16n::return#5
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  (byte*) utoa16w::dst#9 ← phi( utoa16w::@3/(byte*) utoa16w::dst#8 )
  *((byte*) utoa16w::dst#9) ← (number) 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  return 
  to:@return
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  (word**) utoa16n::dst#6 ← phi( utoa16w/(word**) utoa16n::dst#0 utoa16w::@1/(word**) utoa16n::dst#1 utoa16w::@2/(word**) utoa16n::dst#2 utoa16w::@3/(word**) utoa16n::dst#3 )
  (byte) utoa16n::started#7 ← phi( utoa16w/(byte) utoa16n::started#0 utoa16w::@1/(byte) utoa16n::started#1 utoa16w::@2/(byte) utoa16n::started#2 utoa16w::@3/(byte) utoa16n::started#3 )
  (byte) utoa16n::nybble#4 ← phi( utoa16w/(byte) utoa16n::nybble#0 utoa16w::@1/(byte) utoa16n::nybble#1 utoa16w::@2/(byte) utoa16n::nybble#2 utoa16w::@3/(byte) utoa16n::nybble#3 )
  (bool~) utoa16n::$0 ← (byte) utoa16n::nybble#4 != (number) 0
  (bool~) utoa16n::$1 ← ! (bool~) utoa16n::$0
  if((bool~) utoa16n::$1) goto utoa16n::@1
  to:utoa16n::@3
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  (word**) utoa16n::dst#5 ← phi( utoa16n/(word**) utoa16n::dst#6 utoa16n::@3/(word**) utoa16n::dst#7 )
  (byte) utoa16n::nybble#6 ← phi( utoa16n/(byte) utoa16n::nybble#4 utoa16n::@3/(byte) utoa16n::nybble#7 )
  (byte) utoa16n::started#5 ← phi( utoa16n/(byte) utoa16n::started#7 utoa16n::@3/(byte) utoa16n::started#4 )
  (bool~) utoa16n::$2 ← (byte) utoa16n::started#5 != (number) 0
  (bool~) utoa16n::$3 ← ! (bool~) utoa16n::$2
  if((bool~) utoa16n::$3) goto utoa16n::@2
  to:utoa16n::@4
utoa16n::@3: scope:[utoa16n]  from utoa16n
  (word**) utoa16n::dst#7 ← phi( utoa16n/(word**) utoa16n::dst#6 )
  (byte) utoa16n::nybble#7 ← phi( utoa16n/(byte) utoa16n::nybble#4 )
  (byte) utoa16n::started#4 ← (number) 1
  to:utoa16n::@1
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1 utoa16n::@4
  (byte) utoa16n::started#6 ← phi( utoa16n::@1/(byte) utoa16n::started#5 utoa16n::@4/(byte) utoa16n::started#8 )
  (byte) utoa16n::return#4 ← (byte) utoa16n::started#6
  to:utoa16n::@return
utoa16n::@4: scope:[utoa16n]  from utoa16n::@1
  (byte) utoa16n::started#8 ← phi( utoa16n::@1/(byte) utoa16n::started#5 )
  (word**) utoa16n::dst#4 ← phi( utoa16n::@1/(word**) utoa16n::dst#5 )
  (byte) utoa16n::nybble#5 ← phi( utoa16n::@1/(byte) utoa16n::nybble#6 )
  *(*((word**) utoa16n::dst#4)) ← *((byte[]) DIGITS#0 + (byte) utoa16n::nybble#5)
  *((word**) utoa16n::dst#4) ← ++ *((word**) utoa16n::dst#4)
  to:utoa16n::@2
utoa16n::@return: scope:[utoa16n]  from utoa16n::@2
  (byte) utoa16n::return#9 ← phi( utoa16n::@2/(byte) utoa16n::return#4 )
  (byte) utoa16n::return#5 ← (byte) utoa16n::return#9
  return 
  to:@return
@5: scope:[]  from @2
  call main 
  to:@6
@6: scope:[]  from @5
  to:@end
@end: scope:[]  from @6

SYMBOL TABLE SSA
(const string) $0 = (string) "0123456789abcdef@"
(label) @2
(label) @5
(label) @6
(label) @begin
(label) @end
(byte[]) DIGITS
(byte[]) DIGITS#0
(const byte) SIZEOF_WORD = (byte) 2
(word[]) UTOA10_SUB
(word[]) UTOA10_SUB#0
(byte[]) UTOA10_VAL
(byte[]) UTOA10_VAL#0
(byte*) bordercol
(byte*) bordercol#0
(void()) cls()
(byte*~) cls::$0
(bool~) cls::$1
(label) cls::@1
(label) cls::@return
(byte*) cls::sc
(byte*) cls::sc#0
(byte*) cls::sc#1
(byte*) cls::sc#2
(byte*) cls::screen
(byte*) cls::screen#0
(byte*) control
(byte*) control#0
(void()) main()
(number~) main::$1
(byte~) main::$10
(word~) main::$11
(byte*~) main::$12
(byte*~) main::$14
(byte*~) main::$15
(bool~) main::$16
(const string) main::$17 = (string) "raster lines@"
(byte~) main::$2
(number~) main::$3
(bool~) main::$4
(label) main::@1
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@return
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte[]) main::msg
(byte[]) main::msg#0
(byte) main::rst
(byte) main::rst#0
(byte*) main::screen
(byte*) main::screen#0
(byte*) main::screen#1
(byte*) main::screen#10
(byte*) main::screen#11
(byte*) main::screen#2
(byte*) main::screen#3
(byte*) main::screen#4
(byte*) main::screen#5
(byte*) main::screen#6
(byte*) main::screen#7
(byte*) main::screen#8
(byte*) main::screen#9
(byte) main::time
(byte) main::time#0
(byte) main::time_end
(byte) main::time_end#0
(byte) main::time_start
(byte) main::time_start#0
(byte) main::time_start#1
(byte) main::time_start#2
(byte) main::time_start#3
(byte) main::time_start#4
(byte) main::time_start#5
(byte*) raster
(byte*) raster#0
(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
(byte~) utoa10w::$0
(bool~) utoa10w::$1
(number~) utoa10w::$2
(bool~) utoa10w::$3
(bool~) utoa10w::$4
(bool~) utoa10w::$5
(bool~) utoa10w::$6
(bool~) utoa10w::$7
(byte~) utoa10w::$8
(byte~) utoa10w::$9
(label) utoa10w::@10
(label) utoa10w::@11
(label) utoa10w::@12
(label) utoa10w::@2
(label) utoa10w::@3
(label) utoa10w::@4
(label) utoa10w::@8
(label) utoa10w::@9
(label) utoa10w::@return
(byte) utoa10w::bStarted
(byte) utoa10w::bStarted#0
(byte) utoa10w::bStarted#1
(byte) utoa10w::bStarted#2
(byte) utoa10w::bStarted#3
(byte) utoa10w::bStarted#4
(byte) utoa10w::bStarted#5
(byte) utoa10w::bStarted#6
(byte) utoa10w::bStarted#7
(byte) utoa10w::digit
(byte) utoa10w::digit#0
(byte) utoa10w::digit#1
(byte) utoa10w::digit#2
(byte) utoa10w::digit#3
(byte) utoa10w::digit#4
(byte) utoa10w::digit#5
(byte) utoa10w::digit#6
(byte) utoa10w::digit#7
(byte) utoa10w::digit#8
(byte*) utoa10w::dst
(byte*) utoa10w::dst#0
(byte*) utoa10w::dst#1
(byte*) utoa10w::dst#10
(byte*) utoa10w::dst#11
(byte*) utoa10w::dst#2
(byte*) utoa10w::dst#3
(byte*) utoa10w::dst#4
(byte*) utoa10w::dst#5
(byte*) utoa10w::dst#6
(byte*) utoa10w::dst#7
(byte*) utoa10w::dst#8
(byte*) utoa10w::dst#9
(byte) utoa10w::i
(byte) utoa10w::i#0
(byte) utoa10w::i#1
(byte) utoa10w::i#2
(byte) utoa10w::i#3
(byte) utoa10w::i#4
(byte) utoa10w::i#5
(byte) utoa10w::i#6
(byte) utoa10w::i#7
(byte) utoa10w::i#8
(word) utoa10w::value
(word) utoa10w::value#0
(word) utoa10w::value#1
(word) utoa10w::value#10
(word) utoa10w::value#2
(word) utoa10w::value#3
(word) utoa10w::value#4
(word) utoa10w::value#5
(word) utoa10w::value#6
(word) utoa10w::value#7
(word) utoa10w::value#8
(word) utoa10w::value#9
(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
(bool~) utoa16n::$0
(bool~) utoa16n::$1
(bool~) utoa16n::$2
(bool~) utoa16n::$3
(label) utoa16n::@1
(label) utoa16n::@2
(label) utoa16n::@3
(label) utoa16n::@4
(label) utoa16n::@return
(word**) utoa16n::dst
(word**) utoa16n::dst#0
(word**) utoa16n::dst#1
(word**) utoa16n::dst#2
(word**) utoa16n::dst#3
(word**) utoa16n::dst#4
(word**) utoa16n::dst#5
(word**) utoa16n::dst#6
(word**) utoa16n::dst#7
(byte) utoa16n::nybble
(byte) utoa16n::nybble#0
(byte) utoa16n::nybble#1
(byte) utoa16n::nybble#2
(byte) utoa16n::nybble#3
(byte) utoa16n::nybble#4
(byte) utoa16n::nybble#5
(byte) utoa16n::nybble#6
(byte) utoa16n::nybble#7
(byte) utoa16n::return
(byte) utoa16n::return#0
(byte) utoa16n::return#1
(byte) utoa16n::return#2
(byte) utoa16n::return#3
(byte) utoa16n::return#4
(byte) utoa16n::return#5
(byte) utoa16n::return#6
(byte) utoa16n::return#7
(byte) utoa16n::return#8
(byte) utoa16n::return#9
(byte) utoa16n::started
(byte) utoa16n::started#0
(byte) utoa16n::started#1
(byte) utoa16n::started#2
(byte) utoa16n::started#3
(byte) utoa16n::started#4
(byte) utoa16n::started#5
(byte) utoa16n::started#6
(byte) utoa16n::started#7
(byte) utoa16n::started#8
(void()) utoa16w((word) utoa16w::value , (byte*) utoa16w::dst)
(byte~) utoa16w::$0
(byte~) utoa16w::$1
(byte**~) utoa16w::$10
(byte~) utoa16w::$11
(byte~) utoa16w::$12
(number~) utoa16w::$13
(byte**~) utoa16w::$14
(byte**~) utoa16w::$2
(byte~) utoa16w::$3
(byte~) utoa16w::$4
(number~) utoa16w::$5
(byte**~) utoa16w::$6
(byte~) utoa16w::$7
(byte~) utoa16w::$8
(byte~) utoa16w::$9
(label) utoa16w::@1
(label) utoa16w::@2
(label) utoa16w::@3
(label) utoa16w::@4
(label) utoa16w::@return
(byte*) utoa16w::dst
(byte*) utoa16w::dst#0
(byte*) utoa16w::dst#1
(byte*) utoa16w::dst#2
(byte*) utoa16w::dst#3
(byte*) utoa16w::dst#4
(byte*) utoa16w::dst#5
(byte*) utoa16w::dst#6
(byte*) utoa16w::dst#7
(byte*) utoa16w::dst#8
(byte*) utoa16w::dst#9
(byte) utoa16w::started
(byte) utoa16w::started#0
(byte) utoa16w::started#1
(byte) utoa16w::started#2
(byte) utoa16w::started#3
(word) utoa16w::value
(word) utoa16w::value#0
(word) utoa16w::value#1
(word) utoa16w::value#2
(word) utoa16w::value#3
(word) utoa16w::value#4
(word) utoa16w::value#5
(word) utoa16w::value#6
(word) utoa16w::value#7
(word) utoa16w::value#8

Adding number conversion cast (unumber) $80 in (number~) main::$1 ← *((byte*) control#0) & (number) $80
Adding number conversion cast (unumber) main::$1 in (number~) main::$1 ← *((byte*) control#0) & (unumber)(number) $80
Adding number conversion cast (unumber) 1 in (byte~) main::$2 ← *((byte*) raster#0) >> (number) 1
Adding number conversion cast (unumber) main::$3 in (number~) main::$3 ← (unumber~) main::$1 | (byte~) main::$2
Adding number conversion cast (unumber) $30 in (bool~) main::$4 ← (byte) main::rst#0 != (number) $30
Adding number conversion cast (unumber) 1 in *((byte*) bordercol#0) ← (number) 1
Adding number conversion cast (unumber) 0 in (word) utoa16w::value#0 ← (number) 0
Adding number conversion cast (unumber) $28 in (byte*) main::screen#1 ← (byte*) main::screen#5 + (number) $28
Adding number conversion cast (unumber) $4d2 in (word) utoa16w::value#1 ← (number) $4d2
Adding number conversion cast (unumber) $28 in (byte*) main::screen#2 ← (byte*) main::screen#6 + (number) $28
Adding number conversion cast (unumber) $162e in (word) utoa16w::value#2 ← (number) $162e
Adding number conversion cast (unumber) $28 in (byte*) main::screen#3 ← (byte*) main::screen#7 + (number) $28
Adding number conversion cast (unumber) $270f in (word) utoa16w::value#3 ← (number) $270f
Adding number conversion cast (unumber) $28 in (byte*) main::screen#4 ← (byte*) main::screen#8 + (number) $28
Adding number conversion cast (unumber) $e608 in (word) utoa16w::value#4 ← (number) $e608
Adding number conversion cast (unumber) 0 in *((byte*) bordercol#0) ← (number) 0
Adding number conversion cast (unumber) $50 in (byte*~) main::$12 ← (byte*) main::screen#9 + (number) $50
Adding number conversion cast (unumber) 0 in (byte) main::i#0 ← (number) 0
Adding number conversion cast (unumber) $50 in (byte*~) main::$14 ← (byte*) main::screen#10 + (number) $50
Adding number conversion cast (unumber) 3 in (byte*~) main::$15 ← (byte*~) main::$14 + (number) 3
Adding number conversion cast (unumber) 0 in (bool~) main::$16 ← *((byte[]) main::msg#0 + (byte) main::i#1) != (number) 0
Adding number conversion cast (unumber) $3e7 in (byte*~) cls::$0 ← (byte*) cls::screen#0 + (number) $3e7
Adding number conversion cast (unumber) 0 in (byte) utoa10w::bStarted#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa10w::digit#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa10w::i#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) utoa10w::bStarted#1 ← (number) 1
Adding number conversion cast (unumber) 1 in (number~) utoa10w::$2 ← (byte) utoa10w::i#4 & (number) 1
Adding number conversion cast (unumber) utoa10w::$2 in (number~) utoa10w::$2 ← (byte) utoa10w::i#4 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) utoa10w::$3 ← (unumber~) utoa10w::$2 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) utoa10w::$5 ← (byte) utoa10w::bStarted#2 != (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa10w::digit#2 ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*) utoa10w::dst#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa16w::started#0 ← (number) 0
Adding number conversion cast (unumber) 4 in (byte~) utoa16w::$1 ← (byte~) utoa16w::$0 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) utoa16w::$5 ← (byte~) utoa16w::$4 & (number) $f
Adding number conversion cast (unumber) utoa16w::$5 in (number~) utoa16w::$5 ← (byte~) utoa16w::$4 & (unumber)(number) $f
Adding number conversion cast (unumber) 4 in (byte~) utoa16w::$9 ← (byte~) utoa16w::$8 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) utoa16w::$13 ← (byte~) utoa16w::$12 & (number) $f
Adding number conversion cast (unumber) utoa16w::$13 in (number~) utoa16w::$13 ← (byte~) utoa16w::$12 & (unumber)(number) $f
Adding number conversion cast (unumber) 1 in (byte) utoa16n::started#3 ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte*) utoa16w::dst#9) ← (number) 0
Adding number conversion cast (unumber) 0 in (bool~) utoa16n::$0 ← (byte) utoa16n::nybble#4 != (number) 0
Adding number conversion cast (unumber) 0 in (bool~) utoa16n::$2 ← (byte) utoa16n::started#5 != (number) 0
Adding number conversion cast (unumber) 1 in (byte) utoa16n::started#4 ← (number) 1
Successful SSA optimization PassNAddNumberTypeConversions
Adding number conversion cast (word) to elements in (word[]) UTOA10_SUB#0 ← { (word)(number) $7530, (word)(number) $2710, (word)(number) $bb8, (word)(number) $3e8, (word)(number) $12c, (word)(number) $64, (word)(number) $1e, (word)(number) $a }
Adding number conversion cast (byte) to elements in (byte[]) UTOA10_VAL#0 ← { (byte)(number) 3, (byte)(number) 1, (byte)(number) 3, (byte)(number) 1, (byte)(number) 3, (byte)(number) 1, (byte)(number) 3, (byte)(number) 1 }
Successful SSA optimization PassNAddArrayNumberTypeConversions
Inlining cast (byte*) control#0 ← (byte*)(number) $d011
Inlining cast (byte*) raster#0 ← (byte*)(number) $d012
Inlining cast (byte*) bordercol#0 ← (byte*)(number) $d020
Inlining cast (byte*) main::screen#0 ← (byte*)(number) $400
Inlining cast *((byte*) bordercol#0) ← (unumber)(number) 1
Inlining cast (word) utoa16w::value#0 ← (unumber)(number) 0
Inlining cast (word) utoa16w::value#1 ← (unumber)(number) $4d2
Inlining cast (word) utoa16w::value#2 ← (unumber)(number) $162e
Inlining cast (word) utoa16w::value#3 ← (unumber)(number) $270f
Inlining cast (word) utoa16w::value#4 ← (unumber)(number) $e608
Inlining cast *((byte*) bordercol#0) ← (unumber)(number) 0
Inlining cast (word~) main::$11 ← (word)(byte) main::time#0
Inlining cast (byte) main::i#0 ← (unumber)(number) 0
Inlining cast (byte*) cls::screen#0 ← (byte*)(number) $400
Inlining cast (byte) utoa10w::bStarted#0 ← (unumber)(number) 0
Inlining cast (byte) utoa10w::digit#0 ← (unumber)(number) 0
Inlining cast (byte) utoa10w::i#0 ← (unumber)(number) 0
Inlining cast (byte) utoa10w::bStarted#1 ← (unumber)(number) 1
Inlining cast (byte) utoa10w::digit#2 ← (unumber)(number) 0
Inlining cast (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#4
Inlining cast *((byte*) utoa10w::dst#2) ← (unumber)(number) 0
Inlining cast (byte) utoa16w::started#0 ← (unumber)(number) 0
Inlining cast (byte) utoa16n::started#3 ← (unumber)(number) 1
Inlining cast *((byte*) utoa16w::dst#9) ← (unumber)(number) 0
Inlining cast (byte) utoa16n::started#4 ← (unumber)(number) 1
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53280
Simplifying constant integer cast $80
Simplifying constant integer cast 1
Simplifying constant integer cast $30
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast $4d2
Simplifying constant integer cast $28
Simplifying constant integer cast $162e
Simplifying constant integer cast $28
Simplifying constant integer cast $270f
Simplifying constant integer cast $28
Simplifying constant integer cast $e608
Simplifying constant integer cast 0
Simplifying constant integer cast $50
Simplifying constant integer cast 0
Simplifying constant integer cast $50
Simplifying constant integer cast 3
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $3e7
Simplifying constant integer cast $7530
Simplifying constant integer cast $2710
Simplifying constant integer cast $bb8
Simplifying constant integer cast $3e8
Simplifying constant integer cast $12c
Simplifying constant integer cast $64
Simplifying constant integer cast $1e
Simplifying constant integer cast $a
Simplifying constant integer cast 3
Simplifying constant integer cast 1
Simplifying constant integer cast 3
Simplifying constant integer cast 1
Simplifying constant integer cast 3
Simplifying constant integer cast 1
Simplifying constant integer cast 3
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $30
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $4d2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $162e
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $270f
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $e608
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $50
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $50
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3e7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) main::$1 ← *((byte*) control#0) & (byte) $80
Inferred type updated to byte in (unumber~) main::$3 ← (byte~) main::$1 | (byte~) main::$2
Inferred type updated to byte in (unumber~) utoa10w::$2 ← (byte) utoa10w::i#4 & (byte) 1
Inferred type updated to byte in (unumber~) utoa16w::$5 ← (byte~) utoa16w::$4 & (byte) $f
Inferred type updated to byte in (unumber~) utoa16w::$13 ← (byte~) utoa16w::$12 & (byte) $f
Inversing boolean not [91] (bool~) utoa10w::$4 ← (byte~) utoa10w::$2 == (byte) 0 from [90] (bool~) utoa10w::$3 ← (byte~) utoa10w::$2 != (byte) 0
Inversing boolean not [99] (bool~) utoa10w::$6 ← (byte) utoa10w::bStarted#2 == (byte) 0 from [98] (bool~) utoa10w::$5 ← (byte) utoa10w::bStarted#2 != (byte) 0
Inversing boolean not [160] (bool~) utoa16n::$1 ← (byte) utoa16n::nybble#4 == (byte) 0 from [159] (bool~) utoa16n::$0 ← (byte) utoa16n::nybble#4 != (byte) 0
Inversing boolean not [164] (bool~) utoa16n::$3 ← (byte) utoa16n::started#5 == (byte) 0 from [163] (bool~) utoa16n::$2 ← (byte) utoa16n::started#5 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte) main::rst#0 = (byte~) main::$3 
Alias (byte*) main::screen#0 = (byte*) main::screen#5 
Alias (byte) main::time_start#0 = (byte) main::time_start#5 (byte) main::time_start#4 (byte) main::time_start#3 (byte) main::time_start#2 (byte) main::time_start#1 
Alias (byte*) main::screen#1 = (byte*) main::screen#6 
Alias (byte*) main::screen#2 = (byte*) main::screen#7 
Alias (byte*) main::screen#3 = (byte*) main::screen#8 
Alias (byte*) main::screen#11 = (byte*) main::screen#9 (byte*) main::screen#4 
Alias (byte) main::time#0 = (byte~) main::$10 
Alias (word) utoa10w::value#0 = (word~) main::$11 
Alias (byte*) utoa10w::dst#0 = (byte*~) main::$12 
Alias (byte*) cls::screen#0 = (byte*) cls::sc#0 
Alias (byte) utoa10w::digit#3 = (byte) utoa10w::digit#5 (byte) utoa10w::digit#8 (byte) utoa10w::digit#6 (byte) utoa10w::digit#4 
Alias (byte) utoa10w::i#2 = (byte) utoa10w::i#3 (byte) utoa10w::i#4 (byte) utoa10w::i#7 (byte) utoa10w::i#8 
Alias (word) utoa10w::value#10 = (word) utoa10w::value#3 (word) utoa10w::value#2 (word) utoa10w::value#8 (word) utoa10w::value#9 
Alias (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#9 (byte*) utoa10w::dst#8 (byte*) utoa10w::dst#5 (byte*) utoa10w::dst#3 
Alias (byte) utoa10w::bStarted#2 = (byte) utoa10w::bStarted#3 (byte) utoa10w::bStarted#4 (byte) utoa10w::bStarted#7 
Alias (word) utoa10w::value#4 = (word) utoa10w::value#6 
Alias (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#6 
Alias (byte) utoa16n::nybble#0 = (byte~) utoa16w::$1 
Alias (word**) utoa16n::dst#0 = (byte**~) utoa16w::$2 
Alias (byte) utoa16n::return#0 = (byte) utoa16n::return#6 
Alias (word) utoa16w::value#5 = (word) utoa16w::value#6 (word) utoa16w::value#7 (word) utoa16w::value#8 
Alias (byte*) utoa16w::dst#5 = (byte*) utoa16w::dst#6 (byte*) utoa16w::dst#7 (byte*) utoa16w::dst#8 (byte*) utoa16w::dst#9 
Alias (byte) utoa16w::started#1 = (byte~) utoa16w::$3 
Alias (byte) utoa16n::nybble#1 = (byte~) utoa16w::$5 
Alias (word**) utoa16n::dst#1 = (byte**~) utoa16w::$6 
Alias (byte) utoa16n::return#1 = (byte) utoa16n::return#7 
Alias (byte) utoa16w::started#2 = (byte~) utoa16w::$7 
Alias (byte) utoa16n::nybble#2 = (byte~) utoa16w::$9 
Alias (word**) utoa16n::dst#2 = (byte**~) utoa16w::$10 
Alias (byte) utoa16n::return#2 = (byte) utoa16n::return#8 
Alias (byte) utoa16w::started#3 = (byte~) utoa16w::$11 
Alias (byte) utoa16n::nybble#3 = (byte~) utoa16w::$13 
Alias (word**) utoa16n::dst#3 = (byte**~) utoa16w::$14 
Alias (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#7 
Alias (word**) utoa16n::dst#6 = (word**) utoa16n::dst#7 
Alias (byte) utoa16n::return#4 = (byte) utoa16n::started#6 (byte) utoa16n::return#9 (byte) utoa16n::return#5 
Alias (byte) utoa16n::nybble#5 = (byte) utoa16n::nybble#6 
Alias (word**) utoa16n::dst#4 = (word**) utoa16n::dst#5 
Alias (byte) utoa16n::started#5 = (byte) utoa16n::started#8 
Successful SSA optimization Pass2AliasElimination
Alias (byte) utoa10w::i#2 = (byte) utoa10w::i#6 
Alias (word) utoa10w::value#10 = (word) utoa10w::value#7 
Alias (byte) utoa10w::bStarted#2 = (byte) utoa10w::bStarted#6 
Alias (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#5 
Alias (word**) utoa16n::dst#4 = (word**) utoa16n::dst#6 
Alias (byte) utoa16n::return#4 = (byte) utoa16n::started#5 
Successful SSA optimization Pass2AliasElimination
Alias (byte) utoa10w::i#2 = (byte) utoa10w::i#5 
Alias (word) utoa10w::value#10 = (word) utoa10w::value#4 
Alias (byte) utoa10w::bStarted#2 = (byte) utoa10w::bStarted#5 
Successful SSA optimization Pass2AliasElimination
Self Phi Eliminated (byte*) main::screen#10
Self Phi Eliminated (byte) utoa10w::i#2
Self Phi Eliminated (word) utoa10w::value#10
Self Phi Eliminated (byte) utoa10w::bStarted#2
Self Phi Eliminated (byte*) utoa10w::dst#11
Successful SSA optimization Pass2SelfPhiElimination
Identical Phi Values (byte*) main::screen#10 (byte*) main::screen#11
Identical Phi Values (word) utoa10w::value#5 (word) utoa10w::value#0
Identical Phi Values (byte*) utoa10w::dst#10 (byte*) utoa10w::dst#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$4 [11] if((byte) main::rst#0!=(byte) $30) goto main::@4
Simple Condition (bool~) main::$16 [61] if(*((byte[]) main::msg#0 + (byte) main::i#1)!=(byte) 0) goto main::@6
Simple Condition (bool~) cls::$1 [70] if((byte*) cls::sc#1!=rangelast(cls::screen#0,cls::$0)) goto cls::@1
Simple Condition (bool~) utoa10w::$1 [82] if((word) utoa10w::value#10>=*((word[]) UTOA10_SUB#0 + (byte~) utoa10w::$8)) goto utoa10w::@3
Simple Condition (bool~) utoa10w::$4 [92] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@10
Simple Condition (bool~) utoa10w::$7 [96] if((byte) utoa10w::i#1!=rangelast(0,7)) goto utoa10w::@2
Simple Condition (bool~) utoa10w::$6 [100] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@11
Simple Condition (bool~) utoa16n::$1 [161] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@1
Simple Condition (bool~) utoa16n::$3 [165] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [73] (word[]) UTOA10_SUB#0 ← { (word) $7530, (word) $2710, (word) $bb8, (word) $3e8, (word) $12c, (word) $64, (word) $1e, (word) $a }
Constant right-side identified [74] (byte[]) UTOA10_VAL#0 ← { (byte) 3, (byte) 1, (byte) 3, (byte) 1, (byte) 3, (byte) 1, (byte) 3, (byte) 1 }
Constant right-side identified [116] (word**) utoa16n::dst#0 ← & (byte*) utoa16w::dst#5
Constant right-side identified [127] (word**) utoa16n::dst#1 ← & (byte*) utoa16w::dst#5
Constant right-side identified [138] (word**) utoa16n::dst#2 ← & (byte*) utoa16w::dst#5
Constant right-side identified [149] (word**) utoa16n::dst#3 ← & (byte*) utoa16w::dst#5
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) control#0 = (byte*) 53265
Constant (const byte*) raster#0 = (byte*) 53266
Constant (const byte*) bordercol#0 = (byte*) 53280
Constant (const byte*) main::screen#0 = (byte*) 1024
Constant (const word) utoa16w::value#0 = 0
Constant (const word) utoa16w::value#1 = $4d2
Constant (const word) utoa16w::value#2 = $162e
Constant (const word) utoa16w::value#3 = $270f
Constant (const word) utoa16w::value#4 = $e608
Constant (const byte[]) main::msg#0 = main::$17
Constant (const byte) main::i#0 = 0
Constant (const byte*) cls::screen#0 = (byte*) 1024
Constant (const byte[]) DIGITS#0 = $0
Constant (const word[]) UTOA10_SUB#0 = { $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a }
Constant (const byte[]) UTOA10_VAL#0 = { 3, 1, 3, 1, 3, 1, 3, 1 }
Constant (const byte) utoa10w::bStarted#0 = 0
Constant (const byte) utoa10w::digit#0 = 0
Constant (const byte) utoa10w::i#0 = 0
Constant (const byte) utoa10w::bStarted#1 = 1
Constant (const byte) utoa10w::digit#2 = 0
Constant (const byte) utoa16w::started#0 = 0
Constant (const word**) utoa16n::dst#0 = &utoa16w::dst#5
Constant (const word**) utoa16n::dst#1 = &utoa16w::dst#5
Constant (const word**) utoa16n::dst#2 = &utoa16w::dst#5
Constant (const word**) utoa16n::dst#3 = &utoa16w::dst#5
Constant (const byte) utoa16n::started#3 = 1
Constant (const byte) utoa16n::started#4 = 1
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) utoa16w::dst#0 = main::screen#0
Constant (const byte) utoa16n::started#0 = utoa16w::started#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [5] if(true) goto main::@4
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [94] utoa10w::i#1 ← ++ utoa10w::i#2 to ++
Resolved ranged comparison value [96] if(utoa10w::i#1!=rangelast(0,7)) goto utoa10w::@2 to (number) 8
Eliminating unused variable (byte) utoa16w::started#3 and assignment [81] (byte) utoa16w::started#3 ← (byte) utoa16n::return#2
Eliminating unused variable (byte) utoa16n::return#3 and assignment [85] (byte) utoa16n::return#3 ← (byte) utoa16n::return#4
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused variable (byte) utoa16n::return#2 and assignment [80] (byte) utoa16n::return#2 ← (byte) utoa16n::return#4
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 8 in if((byte) utoa10w::i#1!=(number) 8) goto utoa10w::@2
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [10] (byte*) main::screen#1 ← (const byte*) main::screen#0 + (byte) $28
Constant right-side identified [37] (byte*~) cls::$0 ← (const byte*) cls::screen#0 + (word) $3e7
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#1 = main::screen#0+$28
Constant (const byte*) cls::$0 = cls::screen#0+$3e7
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) utoa16w::dst#1 = main::screen#1
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [40] cls::sc#1 ← ++ cls::sc#2 to ++
Resolved ranged comparison value [41] if(cls::sc#1!=rangelast(cls::screen#0,cls::$0)) goto cls::@1 to (byte*)(const byte*) cls::$0+(number) 1
Adding number conversion cast (unumber) 1 in if((byte*) cls::sc#1!=(byte*)(const byte*) cls::$0+(number) 1) goto cls::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const byte*) cls::$0+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [12] (byte*) main::screen#2 ← (const byte*) main::screen#1 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#2 = main::screen#1+$28
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) utoa16w::dst#2 = main::screen#2
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [14] (byte*) main::screen#3 ← (const byte*) main::screen#2 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#3 = main::screen#2+$28
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) utoa16w::dst#3 = main::screen#3
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [16] (byte*) main::screen#11 ← (const byte*) main::screen#3 + (byte) $28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::screen#11 = main::screen#3+$28
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) utoa16w::dst#4 = main::screen#11
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [21] (byte*) utoa10w::dst#0 ← (const byte*) main::screen#11 + (byte) $50
Constant right-side identified [24] (byte*~) main::$14 ← (const byte*) main::screen#11 + (byte) $50
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) utoa10w::dst#0 = main::screen#11+$50
Constant (const byte*) main::$14 = main::screen#11+$50
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [23] (byte*~) main::$15 ← (const byte*) main::$14 + (byte) 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::$15 = main::$14+3
Successful SSA optimization Pass2ConstantIdentification
Rewriting multiplication to use shift [32] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [35] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with different constant siblings (const byte*) main::screen#0
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with different constant siblings (const byte*) main::screen#1
Inlining constant with different constant siblings (const byte*) main::screen#2
Inlining constant with different constant siblings (const byte*) main::screen#3
Inlining constant with different constant siblings (const byte*) main::screen#11
Inlining constant with var siblings (const byte) utoa10w::bStarted#0
Inlining constant with var siblings (const byte) utoa10w::digit#0
Inlining constant with var siblings (const byte) utoa10w::i#0
Inlining constant with var siblings (const byte) utoa10w::bStarted#1
Inlining constant with var siblings (const byte) utoa10w::digit#2
Inlining constant with var siblings (const byte*) utoa10w::dst#0
Inlining constant with var siblings (const word) utoa16w::value#0
Inlining constant with var siblings (const word) utoa16w::value#1
Inlining constant with var siblings (const word) utoa16w::value#2
Inlining constant with var siblings (const word) utoa16w::value#3
Inlining constant with var siblings (const word) utoa16w::value#4
Inlining constant with var siblings (const byte) utoa16w::started#0
Inlining constant with var siblings (const byte*) utoa16w::dst#0
Inlining constant with var siblings (const byte*) utoa16w::dst#1
Inlining constant with var siblings (const byte*) utoa16w::dst#2
Inlining constant with var siblings (const byte*) utoa16w::dst#3
Inlining constant with var siblings (const byte*) utoa16w::dst#4
Inlining constant with var siblings (const word**) utoa16n::dst#0
Inlining constant with var siblings (const word**) utoa16n::dst#1
Inlining constant with var siblings (const word**) utoa16n::dst#2
Inlining constant with var siblings (const word**) utoa16n::dst#3
Inlining constant with var siblings (const byte) utoa16n::started#3
Inlining constant with var siblings (const byte) utoa16n::started#4
Inlining constant with var siblings (const byte) utoa16n::started#0
Constant inlined main::screen#0 = (byte*) 1024
Constant inlined main::screen#1 = (byte*) 1024+(byte) $28
Constant inlined utoa16w::value#2 = (word) $162e
Constant inlined utoa16w::value#1 = (word) $4d2
Constant inlined main::screen#2 = (byte*) 1024+(byte) $28+(byte) $28
Constant inlined utoa16w::value#0 = (byte) 0
Constant inlined main::screen#3 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28
Constant inlined main::$14 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50
Constant inlined main::$15 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3
Constant inlined utoa10w::bStarted#1 = (byte) 1
Constant inlined $0 = (const byte[]) DIGITS#0
Constant inlined utoa10w::bStarted#0 = (byte) 0
Constant inlined main::screen#11 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28
Constant inlined utoa16n::started#0 = (byte) 0
Constant inlined main::$17 = (const byte[]) main::msg#0
Constant inlined main::i#0 = (byte) 0
Constant inlined utoa16n::dst#1 = &(byte*) utoa16w::dst#5
Constant inlined utoa16n::dst#0 = &(byte*) utoa16w::dst#5
Constant inlined utoa16w::dst#3 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28
Constant inlined utoa16w::dst#4 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28
Constant inlined utoa16w::dst#1 = (byte*) 1024+(byte) $28
Constant inlined utoa16w::dst#2 = (byte*) 1024+(byte) $28+(byte) $28
Constant inlined utoa16n::started#3 = (byte) 1
Constant inlined utoa16n::dst#3 = &(byte*) utoa16w::dst#5
Constant inlined utoa16n::started#4 = (byte) 1
Constant inlined utoa16w::dst#0 = (byte*) 1024
Constant inlined utoa16n::dst#2 = &(byte*) utoa16w::dst#5
Constant inlined utoa16w::started#0 = (byte) 0
Constant inlined cls::$0 = (const byte*) cls::screen#0+(word) $3e7
Constant inlined utoa10w::i#0 = (byte) 0
Constant inlined utoa10w::dst#0 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50
Constant inlined utoa10w::digit#0 = (byte) 0
Constant inlined utoa16w::value#4 = (word) $e608
Constant inlined utoa16w::value#3 = (word) $270f
Constant inlined utoa10w::digit#2 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values (word**) utoa16n::dst#4 &(byte*) utoa16w::dst#5
Successful SSA optimization Pass2IdenticalPhiElimination
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting main::@18(between main::@6 and main::@6)
Added new block during phi lifting cls::@3(between cls::@1 and cls::@1)
Added new block during phi lifting utoa10w::@13(between utoa10w::@10 and utoa10w::@2)
Added new block during phi lifting utoa10w::@14(between utoa10w::@4 and utoa10w::@10)
Added new block during phi lifting utoa10w::@15(between utoa10w::@8 and utoa10w::@11)
Added new block during phi lifting utoa16n::@6(between utoa16n and utoa16n::@1)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @5
Adding NOP phi() at start of @6
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@17
Adding NOP phi() at start of utoa16n::@3
Adding NOP phi() at start of utoa16n::@2
Adding NOP phi() at start of cls
CALL GRAPH
Calls in [] to main:3 
Calls in [main] to cls:7 utoa16w:16 utoa16w:18 utoa16w:20 utoa16w:22 utoa16w:24 utoa10w:29 
Calls in [utoa16w] to utoa16n:71 utoa16n:79 utoa16n:87 utoa16n:91 

Created 15 initial phi equivalence classes
Coalesced [35] main::i#3 ← main::i#1
Coalesced [36] utoa10w::value#11 ← utoa10w::value#0
Coalesced [45] utoa10w::dst#16 ← utoa10w::dst#1
Coalesced [47] utoa10w::dst#13 ← utoa10w::dst#7
Coalesced [56] utoa10w::i#9 ← utoa10w::i#1
Coalesced [57] utoa10w::digit#9 ← utoa10w::digit#7
Coalesced [58] utoa10w::dst#12 ← utoa10w::dst#4
Coalesced (already) [59] utoa10w::dst#15 ← utoa10w::dst#11
Coalesced (already) [60] utoa10w::dst#14 ← utoa10w::dst#11
Coalesced (already) [61] utoa10w::digit#11 ← utoa10w::digit#3
Coalesced [65] utoa10w::value#12 ← utoa10w::value#1
Coalesced [66] utoa10w::digit#10 ← utoa10w::digit#1
Coalesced [70] utoa16n::nybble#8 ← utoa16n::nybble#0
Coalesced [77] utoa16n::nybble#9 ← utoa16n::nybble#1
Coalesced [78] utoa16n::started#9 ← utoa16n::started#1
Coalesced [85] utoa16n::nybble#10 ← utoa16n::nybble#2
Coalesced [86] utoa16n::started#10 ← utoa16n::started#2
Coalesced [90] utoa16n::nybble#11 ← utoa16n::nybble#3
Coalesced [103] utoa16n::return#10 ← utoa16n::started#7
Coalesced [110] cls::sc#3 ← cls::sc#1
Coalesced down to 11 phi equivalence classes
Culled Empty Block (label) @2
Culled Empty Block (label) @6
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@1
Culled Empty Block (label) main::@17
Culled Empty Block (label) main::@18
Culled Empty Block (label) utoa10w::@13
Culled Empty Block (label) utoa10w::@15
Culled Empty Block (label) utoa10w::@14
Culled Empty Block (label) utoa16n::@3
Culled Empty Block (label) utoa16n::@2
Culled Empty Block (label) cls::@3
Renumbering block @5 to @1
Renumbering block main::@4 to main::@1
Renumbering block main::@5 to main::@2
Renumbering block main::@6 to main::@3
Renumbering block main::@12 to main::@4
Renumbering block main::@13 to main::@5
Renumbering block main::@14 to main::@6
Renumbering block main::@15 to main::@7
Renumbering block main::@16 to main::@8
Renumbering block utoa10w::@2 to utoa10w::@1
Renumbering block utoa10w::@3 to utoa10w::@2
Renumbering block utoa10w::@4 to utoa10w::@3
Renumbering block utoa10w::@8 to utoa10w::@4
Renumbering block utoa10w::@9 to utoa10w::@5
Renumbering block utoa10w::@10 to utoa10w::@6
Renumbering block utoa10w::@11 to utoa10w::@7
Renumbering block utoa10w::@12 to utoa10w::@8
Renumbering block utoa16n::@4 to utoa16n::@2
Renumbering block utoa16n::@6 to utoa16n::@3
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of utoa10w
Adding NOP phi() at start of utoa16n::@3
Adding NOP phi() at start of cls

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  asm { sei  }
  [5] call cls 
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@3
  [6] (byte~) main::$1 ← *((const byte*) control#0) & (byte) $80
  [7] (byte~) main::$2 ← *((const byte*) raster#0) >> (byte) 1
  [8] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2
  [9] if((byte) main::rst#0!=(byte) $30) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [10] *((const byte*) bordercol#0) ← (byte) 1
  [11] (byte) main::time_start#0 ← *((const byte*) raster#0)
  [12] call utoa16w 
  to:main::@4
main::@4: scope:[main]  from main::@2
  [13] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0)
  [14] call utoa16w 
  to:main::@5
main::@5: scope:[main]  from main::@4
  [15] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0)
  [16] call utoa16w 
  to:main::@6
main::@6: scope:[main]  from main::@5
  [17] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0)
  [18] call utoa16w 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [19] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0)
  [20] call utoa16w 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [21] (byte) main::time_end#0 ← *((const byte*) raster#0)
  [22] *((const byte*) bordercol#0) ← (byte) 0
  [23] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0
  [24] (word) utoa10w::value#0 ← (word)(byte) main::time#0
  [25] call utoa10w 
  to:main::@3
main::@3: scope:[main]  from main::@3 main::@8
  [26] (byte) main::i#2 ← phi( main::@8/(byte) 0 main::@3/(byte) main::i#1 )
  [27] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte[]) main::msg#0 + (byte) main::i#2)
  [28] (byte) main::i#1 ← ++ (byte) main::i#2
  [29] if(*((const byte[]) main::msg#0 + (byte) main::i#1)!=(byte) 0) goto main::@3
  to:main::@1
utoa10w: scope:[utoa10w]  from main::@8
  [30] phi()
  to:utoa10w::@1
utoa10w::@1: scope:[utoa10w]  from utoa10w utoa10w::@2 utoa10w::@6
  [31] (byte*) utoa10w::dst#11 ← phi( utoa10w/(byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 utoa10w::@6/(byte*) utoa10w::dst#4 )
  [31] (byte) utoa10w::bStarted#2 ← phi( utoa10w/(byte) 0 utoa10w::@2/(byte) 1 )
  [31] (byte) utoa10w::digit#3 ← phi( utoa10w/(byte) 0 utoa10w::@6/(byte) utoa10w::digit#7 utoa10w::@2/(byte) utoa10w::digit#1 )
  [31] (word) utoa10w::value#10 ← phi( utoa10w/(word) utoa10w::value#0 utoa10w::@2/(word) utoa10w::value#1 )
  [31] (byte) utoa10w::i#2 ← phi( utoa10w/(byte) 0 utoa10w::@6/(byte) utoa10w::i#1 )
  [32] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1
  [33] if((word) utoa10w::value#10>=*((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$8)) goto utoa10w::@2
  to:utoa10w::@3
utoa10w::@3: scope:[utoa10w]  from utoa10w::@1
  [34] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1
  [35] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@6
  to:utoa10w::@4
utoa10w::@4: scope:[utoa10w]  from utoa10w::@3
  [36] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7
  to:utoa10w::@5
utoa10w::@5: scope:[utoa10w]  from utoa10w::@4
  [37] *((byte*) utoa10w::dst#11) ← *((const byte[]) DIGITS#0 + (byte) utoa10w::digit#3)
  [38] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11
  to:utoa10w::@7
utoa10w::@7: scope:[utoa10w]  from utoa10w::@4 utoa10w::@5
  [39] (byte*) utoa10w::dst#7 ← phi( utoa10w::@4/(byte*) utoa10w::dst#11 utoa10w::@5/(byte*) utoa10w::dst#1 )
  to:utoa10w::@6
utoa10w::@6: scope:[utoa10w]  from utoa10w::@3 utoa10w::@7
  [40] (byte) utoa10w::digit#7 ← phi( utoa10w::@7/(byte) 0 utoa10w::@3/(byte) utoa10w::digit#3 )
  [40] (byte*) utoa10w::dst#4 ← phi( utoa10w::@7/(byte*) utoa10w::dst#7 utoa10w::@3/(byte*) utoa10w::dst#11 )
  [41] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2
  [42] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1
  to:utoa10w::@8
utoa10w::@8: scope:[utoa10w]  from utoa10w::@6
  [43] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10
  [44] *((byte*) utoa10w::dst#4) ← *((const byte[]) DIGITS#0 + (byte~) utoa10w::$0)
  [45] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4
  [46] *((byte*) utoa10w::dst#2) ← (byte) 0
  to:utoa10w::@return
utoa10w::@return: scope:[utoa10w]  from utoa10w::@8
  [47] return 
  to:@return
utoa10w::@2: scope:[utoa10w]  from utoa10w::@1
  [48] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte[]) UTOA10_VAL#0 + (byte) utoa10w::i#2)
  [49] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1
  [50] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$9)
  to:utoa10w::@1
utoa16w: scope:[utoa16w]  from main::@2 main::@4 main::@5 main::@6 main::@7
  [51] (byte*) utoa16w::dst#5 ← phi( main::@4/(byte*) 1024+(byte) $28 main::@5/(byte*) 1024+(byte) $28+(byte) $28 main::@6/(byte*) 1024+(byte) $28+(byte) $28+(byte) $28 main::@7/(byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 main::@2/(byte*) 1024 )
  [51] (word) utoa16w::value#5 ← phi( main::@4/(word) $4d2 main::@5/(word) $162e main::@6/(word) $270f main::@7/(word) $e608 main::@2/(byte) 0 )
  [52] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5
  [53] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4
  [54] call utoa16n 
  [55] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
  to:utoa16w::@1
utoa16w::@1: scope:[utoa16w]  from utoa16w
  [56] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
  [57] (byte~) utoa16w::$4 ← > (word) utoa16w::value#5
  [58] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$4 & (byte) $f
  [59] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  [60] call utoa16n 
  [61] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
  to:utoa16w::@2
utoa16w::@2: scope:[utoa16w]  from utoa16w::@1
  [62] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
  [63] (byte~) utoa16w::$8 ← < (word) utoa16w::value#5
  [64] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$8 >> (byte) 4
  [65] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  [66] call utoa16n 
  to:utoa16w::@3
utoa16w::@3: scope:[utoa16w]  from utoa16w::@2
  [67] (byte~) utoa16w::$12 ← < (word) utoa16w::value#5
  [68] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$12 & (byte) $f
  [69] call utoa16n 
  to:utoa16w::@4
utoa16w::@4: scope:[utoa16w]  from utoa16w::@3
  [70] *((byte*) utoa16w::dst#5) ← (byte) 0
  to:utoa16w::@return
utoa16w::@return: scope:[utoa16w]  from utoa16w::@4
  [71] return 
  to:@return
utoa16n: scope:[utoa16n]  from utoa16w utoa16w::@1 utoa16w::@2 utoa16w::@3
  [72] (byte) utoa16n::started#7 ← phi( utoa16w/(byte) 0 utoa16w::@1/(byte) utoa16n::started#1 utoa16w::@2/(byte) utoa16n::started#2 utoa16w::@3/(byte) 1 )
  [72] (byte) utoa16n::nybble#4 ← phi( utoa16w/(byte) utoa16n::nybble#0 utoa16w::@1/(byte) utoa16n::nybble#1 utoa16w::@2/(byte) utoa16n::nybble#2 utoa16w::@3/(byte) utoa16n::nybble#3 )
  [73] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3
  to:utoa16n::@1
utoa16n::@3: scope:[utoa16n]  from utoa16n
  [74] phi()
  to:utoa16n::@1
utoa16n::@1: scope:[utoa16n]  from utoa16n utoa16n::@3
  [75] (byte) utoa16n::return#4 ← phi( utoa16n::@3/(byte) utoa16n::started#7 utoa16n/(byte) 1 )
  [76] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return
  to:utoa16n::@2
utoa16n::@2: scope:[utoa16n]  from utoa16n::@1
  [77] *(*(&(byte*) utoa16w::dst#5)) ← *((const byte[]) DIGITS#0 + (byte) utoa16n::nybble#4)
  [78] *(&(byte*) utoa16w::dst#5) ← ++ *(&(byte*) utoa16w::dst#5)
  to:utoa16n::@return
utoa16n::@return: scope:[utoa16n]  from utoa16n::@1 utoa16n::@2
  [79] return 
  to:@return
cls: scope:[cls]  from main
  [80] phi()
  to:cls::@1
cls::@1: scope:[cls]  from cls cls::@1
  [81] (byte*) cls::sc#2 ← phi( cls/(const byte*) cls::screen#0 cls::@1/(byte*) cls::sc#1 )
  [82] *((byte*) cls::sc#2) ← (byte) ' '
  [83] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2
  [84] if((byte*) cls::sc#1!=(const byte*) cls::screen#0+(word) $3e7+(byte) 1) goto cls::@1
  to:cls::@return
cls::@return: scope:[cls]  from cls::@1
  [85] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte[]) DIGITS
(word[]) UTOA10_SUB
(byte[]) UTOA10_VAL
(byte*) bordercol
(void()) cls()
(byte*) cls::sc
(byte*) cls::sc#1 16.5
(byte*) cls::sc#2 16.5
(byte*) cls::screen
(byte*) control
(void()) main()
(byte~) main::$1 101.0
(byte~) main::$2 202.0
(byte) main::i
(byte) main::i#1 151.5
(byte) main::i#2 202.0
(byte[]) main::msg
(byte) main::rst
(byte) main::rst#0 202.0
(byte*) main::screen
(byte) main::time
(byte) main::time#0 11.0
(byte) main::time_end
(byte) main::time_end#0 11.0
(byte) main::time_start
(byte) main::time_start#0 1.8333333333333333
(byte*) raster
(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
(byte~) utoa10w::$0 4.0
(byte~) utoa10w::$2 202.0
(byte~) utoa10w::$8 202.0
(byte~) utoa10w::$9 202.0
(byte) utoa10w::bStarted
(byte) utoa10w::bStarted#2 20.2
(byte) utoa10w::digit
(byte) utoa10w::digit#1 67.33333333333333
(byte) utoa10w::digit#3 84.16666666666666
(byte) utoa10w::digit#7 67.33333333333333
(byte*) utoa10w::dst
(byte*) utoa10w::dst#1 202.0
(byte*) utoa10w::dst#11 72.14285714285714
(byte*) utoa10w::dst#2 4.0
(byte*) utoa10w::dst#4 61.39999999999999
(byte*) utoa10w::dst#7 303.0
(byte) utoa10w::i
(byte) utoa10w::i#1 151.5
(byte) utoa10w::i#2 55.090909090909086
(word) utoa10w::value
(word) utoa10w::value#0 6.5
(word) utoa10w::value#1 202.0
(word) utoa10w::value#10 21.78571428571429
(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
(word**) utoa16n::dst
(byte) utoa16n::nybble
(byte) utoa16n::nybble#0 4.0
(byte) utoa16n::nybble#1 2.0
(byte) utoa16n::nybble#2 2.0
(byte) utoa16n::nybble#3 4.0
(byte) utoa16n::nybble#4 2.4
(byte) utoa16n::return
(byte) utoa16n::return#0 4.0
(byte) utoa16n::return#1 4.0
(byte) utoa16n::return#4 1.1428571428571428
(byte) utoa16n::started
(byte) utoa16n::started#1 4.0
(byte) utoa16n::started#2 4.0
(byte) utoa16n::started#7 2.0
(void()) utoa16w((word) utoa16w::value , (byte*) utoa16w::dst)
(byte~) utoa16w::$0 4.0
(byte~) utoa16w::$12 4.0
(byte~) utoa16w::$4 4.0
(byte~) utoa16w::$8 4.0
(byte*) utoa16w::dst
(byte*) utoa16w::dst#5 0.07407407407407407
(byte) utoa16w::started
(byte) utoa16w::started#1 1.3333333333333333
(byte) utoa16w::started#2 1.3333333333333333
(word) utoa16w::value
(word) utoa16w::value#5 0.5

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ utoa10w::i#2 utoa10w::i#1 ]
[ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
[ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
[ utoa10w::bStarted#2 ]
[ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ]
[ utoa16w::value#5 ]
[ utoa16w::dst#5 ]
[ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
[ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
[ cls::sc#2 cls::sc#1 ]
Added variable main::$1 to zero page equivalence class [ main::$1 ]
Added variable main::$2 to zero page equivalence class [ main::$2 ]
Added variable main::rst#0 to zero page equivalence class [ main::rst#0 ]
Added variable main::time_start#0 to zero page equivalence class [ main::time_start#0 ]
Added variable main::time_end#0 to zero page equivalence class [ main::time_end#0 ]
Added variable main::time#0 to zero page equivalence class [ main::time#0 ]
Added variable utoa10w::$8 to zero page equivalence class [ utoa10w::$8 ]
Added variable utoa10w::$2 to zero page equivalence class [ utoa10w::$2 ]
Added variable utoa10w::$0 to zero page equivalence class [ utoa10w::$0 ]
Added variable utoa10w::dst#2 to zero page equivalence class [ utoa10w::dst#2 ]
Added variable utoa10w::$9 to zero page equivalence class [ utoa10w::$9 ]
Added variable utoa16w::$0 to zero page equivalence class [ utoa16w::$0 ]
Added variable utoa16n::return#0 to zero page equivalence class [ utoa16n::return#0 ]
Added variable utoa16w::started#1 to zero page equivalence class [ utoa16w::started#1 ]
Added variable utoa16w::$4 to zero page equivalence class [ utoa16w::$4 ]
Added variable utoa16n::return#1 to zero page equivalence class [ utoa16n::return#1 ]
Added variable utoa16w::started#2 to zero page equivalence class [ utoa16w::started#2 ]
Added variable utoa16w::$8 to zero page equivalence class [ utoa16w::$8 ]
Added variable utoa16w::$12 to zero page equivalence class [ utoa16w::$12 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ utoa10w::i#2 utoa10w::i#1 ]
[ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
[ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
[ utoa10w::bStarted#2 ]
[ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ]
[ utoa16w::value#5 ]
[ utoa16w::dst#5 ]
[ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
[ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
[ cls::sc#2 cls::sc#1 ]
[ main::$1 ]
[ main::$2 ]
[ main::rst#0 ]
[ main::time_start#0 ]
[ main::time_end#0 ]
[ main::time#0 ]
[ utoa10w::$8 ]
[ utoa10w::$2 ]
[ utoa10w::$0 ]
[ utoa10w::dst#2 ]
[ utoa10w::$9 ]
[ utoa16w::$0 ]
[ utoa16n::return#0 ]
[ utoa16w::started#1 ]
[ utoa16w::$4 ]
[ utoa16n::return#1 ]
[ utoa16w::started#2 ]
[ utoa16w::$8 ]
[ utoa16w::$12 ]
Allocated zp ZP_BYTE:2 [ main::i#2 main::i#1 ]
Allocated zp ZP_BYTE:3 [ utoa10w::i#2 utoa10w::i#1 ]
Allocated zp ZP_WORD:4 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
Allocated zp ZP_BYTE:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
Allocated zp ZP_BYTE:7 [ utoa10w::bStarted#2 ]
Allocated zp ZP_WORD:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ]
Allocated zp ZP_WORD:10 [ utoa16w::value#5 ]
Allocated zp ZP_WORD:12 [ utoa16w::dst#5 ]
Allocated zp ZP_BYTE:14 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
Allocated zp ZP_BYTE:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Allocated zp ZP_WORD:16 [ cls::sc#2 cls::sc#1 ]
Allocated zp ZP_BYTE:18 [ main::$1 ]
Allocated zp ZP_BYTE:19 [ main::$2 ]
Allocated zp ZP_BYTE:20 [ main::rst#0 ]
Allocated zp ZP_BYTE:21 [ main::time_start#0 ]
Allocated zp ZP_BYTE:22 [ main::time_end#0 ]
Allocated zp ZP_BYTE:23 [ main::time#0 ]
Allocated zp ZP_BYTE:24 [ utoa10w::$8 ]
Allocated zp ZP_BYTE:25 [ utoa10w::$2 ]
Allocated zp ZP_BYTE:26 [ utoa10w::$0 ]
Allocated zp ZP_WORD:27 [ utoa10w::dst#2 ]
Allocated zp ZP_BYTE:29 [ utoa10w::$9 ]
Allocated zp ZP_BYTE:30 [ utoa16w::$0 ]
Allocated zp ZP_BYTE:31 [ utoa16n::return#0 ]
Allocated zp ZP_BYTE:32 [ utoa16w::started#1 ]
Allocated zp ZP_BYTE:33 [ utoa16w::$4 ]
Allocated zp ZP_BYTE:34 [ utoa16n::return#1 ]
Allocated zp ZP_BYTE:35 [ utoa16w::started#2 ]
Allocated zp ZP_BYTE:36 [ utoa16w::$8 ]
Allocated zp ZP_BYTE:37 [ utoa16w::$12 ]

INITIAL ASM
//SEG0 File Comments
// Testing hex to decimal conversion
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label control = $d011
  .label raster = $d012
  .label bordercol = $d020
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
  jsr main
//SEG7 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
    .label _1 = $12
    .label _2 = $13
    .label rst = $14
    .label time_start = $15
    .label time_end = $16
    .label time = $17
    .label i = 2
  //SEG10 asm { sei  }
    sei
  //SEG11 [5] call cls 
  //SEG12 [80] phi from main to cls [phi:main->cls]
  cls_from_main:
    jsr cls
    jmp b1
  //SEG13 main::@1
  b1:
  //SEG14 [6] (byte~) main::$1 ← *((const byte*) control#0) & (byte) $80 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #$80
    and control
    sta _1
  //SEG15 [7] (byte~) main::$2 ← *((const byte*) raster#0) >> (byte) 1 -- vbuz1=_deref_pbuc1_ror_1 
    lda raster
    lsr
    sta _2
  //SEG16 [8] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2 -- vbuz1=vbuz2_bor_vbuz3 
    lda _1
    ora _2
    sta rst
  //SEG17 [9] if((byte) main::rst#0!=(byte) $30) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$30
    cmp rst
    bne b1
    jmp b2
  //SEG18 main::@2
  b2:
  //SEG19 [10] *((const byte*) bordercol#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta bordercol
  //SEG20 [11] (byte) main::time_start#0 ← *((const byte*) raster#0) -- vbuz1=_deref_pbuc1 
    lda raster
    sta time_start
  //SEG21 [12] call utoa16w 
  //SEG22 [51] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
  utoa16w_from_b2:
  //SEG23 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024 [phi:main::@2->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400
    sta utoa16w.dst
    lda #>$400
    sta utoa16w.dst+1
  //SEG24 [51] phi (word) utoa16w::value#5 = (byte) 0 [phi:main::@2->utoa16w#1] -- vwuz1=vbuc1 
    lda #0
    sta utoa16w.value
    lda #0
    sta utoa16w.value+1
    jsr utoa16w
    jmp b4
  //SEG25 main::@4
  b4:
  //SEG26 [13] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG27 [14] call utoa16w 
  //SEG28 [51] phi from main::@4 to utoa16w [phi:main::@4->utoa16w]
  utoa16w_from_b4:
  //SEG29 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28 [phi:main::@4->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28
    sta utoa16w.dst
    lda #>$400+$28
    sta utoa16w.dst+1
  //SEG30 [51] phi (word) utoa16w::value#5 = (word) $4d2 [phi:main::@4->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$4d2
    sta utoa16w.value
    lda #>$4d2
    sta utoa16w.value+1
    jsr utoa16w
    jmp b5
  //SEG31 main::@5
  b5:
  //SEG32 [15] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG33 [16] call utoa16w 
  //SEG34 [51] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
  utoa16w_from_b5:
  //SEG35 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28+(byte) $28 [phi:main::@5->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta utoa16w.dst
    lda #>$400+$28+$28
    sta utoa16w.dst+1
  //SEG36 [51] phi (word) utoa16w::value#5 = (word) $162e [phi:main::@5->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$162e
    sta utoa16w.value
    lda #>$162e
    sta utoa16w.value+1
    jsr utoa16w
    jmp b6
  //SEG37 main::@6
  b6:
  //SEG38 [17] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG39 [18] call utoa16w 
  //SEG40 [51] phi from main::@6 to utoa16w [phi:main::@6->utoa16w]
  utoa16w_from_b6:
  //SEG41 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 [phi:main::@6->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta utoa16w.dst
    lda #>$400+$28+$28+$28
    sta utoa16w.dst+1
  //SEG42 [51] phi (word) utoa16w::value#5 = (word) $270f [phi:main::@6->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$270f
    sta utoa16w.value
    lda #>$270f
    sta utoa16w.value+1
    jsr utoa16w
    jmp b7
  //SEG43 main::@7
  b7:
  //SEG44 [19] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG45 [20] call utoa16w 
  //SEG46 [51] phi from main::@7 to utoa16w [phi:main::@7->utoa16w]
  utoa16w_from_b7:
  //SEG47 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 [phi:main::@7->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta utoa16w.dst+1
  //SEG48 [51] phi (word) utoa16w::value#5 = (word) $e608 [phi:main::@7->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$e608
    sta utoa16w.value
    lda #>$e608
    sta utoa16w.value+1
    jsr utoa16w
    jmp b8
  //SEG49 main::@8
  b8:
  //SEG50 [21] (byte) main::time_end#0 ← *((const byte*) raster#0) -- vbuz1=_deref_pbuc1 
    lda raster
    sta time_end
  //SEG51 [22] *((const byte*) bordercol#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta bordercol
  //SEG52 [23] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda time_end
    sec
    sbc time_start
    sta time
  //SEG53 [24] (word) utoa10w::value#0 ← (word)(byte) main::time#0 -- vwuz1=_word_vbuz2 
    lda time
    sta utoa10w.value
    lda #0
    sta utoa10w.value+1
  //SEG54 [25] call utoa10w 
  //SEG55 [30] phi from main::@8 to utoa10w [phi:main::@8->utoa10w]
  utoa10w_from_b8:
    jsr utoa10w
  //SEG56 [26] phi from main::@8 to main::@3 [phi:main::@8->main::@3]
  b3_from_b8:
  //SEG57 [26] phi (byte) main::i#2 = (byte) 0 [phi:main::@8->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b3
  //SEG58 [26] phi from main::@3 to main::@3 [phi:main::@3->main::@3]
  b3_from_b3:
  //SEG59 [26] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@3->main::@3#0] -- register_copy 
    jmp b3
  //SEG60 main::@3
  b3:
  //SEG61 [27] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte[]) main::msg#0 + (byte) main::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy i
    lda msg,y
    sta $400+$28+$28+$28+$28+$50+3,y
  //SEG62 [28] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG63 [29] if(*((const byte[]) main::msg#0 + (byte) main::i#1)!=(byte) 0) goto main::@3 -- pbuc1_derefidx_vbuz1_neq_0_then_la1 
    ldy i
    lda msg,y
    cmp #0
    bne b3_from_b3
    jmp b1
    msg: .text "raster lines@"
}
//SEG64 utoa10w
// Decimal utoa() without using multiply or divide
// utoa10w(word zeropage(4) value, byte* zeropage(8) dst)
utoa10w: {
    .label _0 = $1a
    .label _2 = $19
    .label _8 = $18
    .label _9 = $1d
    .label value = 4
    .label digit = 6
    .label i = 3
    .label dst = 8
    .label dst_2 = $1b
    .label bStarted = 7
  //SEG65 [31] phi from utoa10w to utoa10w::@1 [phi:utoa10w->utoa10w::@1]
  b1_from_utoa10w:
  //SEG66 [31] phi (byte*) utoa10w::dst#11 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 [phi:utoa10w->utoa10w::@1#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28+$50
    sta dst
    lda #>$400+$28+$28+$28+$28+$50
    sta dst+1
  //SEG67 [31] phi (byte) utoa10w::bStarted#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta bStarted
  //SEG68 [31] phi (byte) utoa10w::digit#3 = (byte) 0 [phi:utoa10w->utoa10w::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta digit
  //SEG69 [31] phi (word) utoa10w::value#10 = (word) utoa10w::value#0 [phi:utoa10w->utoa10w::@1#3] -- register_copy 
  //SEG70 [31] phi (byte) utoa10w::i#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#4] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b1
  //SEG71 [31] phi from utoa10w::@6 to utoa10w::@1 [phi:utoa10w::@6->utoa10w::@1]
  b1_from_b6:
  //SEG72 [31] phi (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#4 [phi:utoa10w::@6->utoa10w::@1#0] -- register_copy 
  //SEG73 [31] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#7 [phi:utoa10w::@6->utoa10w::@1#1] -- register_copy 
  //SEG74 [31] phi (byte) utoa10w::i#2 = (byte) utoa10w::i#1 [phi:utoa10w::@6->utoa10w::@1#2] -- register_copy 
    jmp b1
  //SEG75 utoa10w::@1
  b1:
  //SEG76 [32] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda i
    asl
    sta _8
  //SEG77 [33] if((word) utoa10w::value#10>=*((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$8)) goto utoa10w::@2 -- vwuz1_ge_pwuc1_derefidx_vbuz2_then_la1 
    ldy _8
    lda UTOA10_SUB+1,y
    cmp value+1
    bne !+
    lda UTOA10_SUB,y
    cmp value
    beq b2
  !:
    bcc b2
    jmp b3
  //SEG78 utoa10w::@3
  b3:
  //SEG79 [34] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and i
    sta _2
  //SEG80 [35] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@6 -- vbuz1_eq_0_then_la1 
    lda _2
    cmp #0
    beq b6_from_b3
    jmp b4
  //SEG81 utoa10w::@4
  b4:
  //SEG82 [36] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7 -- vbuz1_eq_0_then_la1 
    lda bStarted
    cmp #0
    beq b7_from_b4
    jmp b5
  //SEG83 utoa10w::@5
  b5:
  //SEG84 [37] *((byte*) utoa10w::dst#11) ← *((const byte[]) DIGITS#0 + (byte) utoa10w::digit#3) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy digit
    lda DIGITS,y
    ldy #0
    sta (dst),y
  //SEG85 [38] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
  //SEG86 [39] phi from utoa10w::@4 utoa10w::@5 to utoa10w::@7 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7]
  b7_from_b4:
  b7_from_b5:
  //SEG87 [39] phi (byte*) utoa10w::dst#7 = (byte*) utoa10w::dst#11 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7#0] -- register_copy 
    jmp b7
  //SEG88 utoa10w::@7
  b7:
  //SEG89 [40] phi from utoa10w::@7 to utoa10w::@6 [phi:utoa10w::@7->utoa10w::@6]
  b6_from_b7:
  //SEG90 [40] phi (byte) utoa10w::digit#7 = (byte) 0 [phi:utoa10w::@7->utoa10w::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta digit
  //SEG91 [40] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#7 [phi:utoa10w::@7->utoa10w::@6#1] -- register_copy 
    jmp b6
  //SEG92 [40] phi from utoa10w::@3 to utoa10w::@6 [phi:utoa10w::@3->utoa10w::@6]
  b6_from_b3:
  //SEG93 [40] phi (byte) utoa10w::digit#7 = (byte) utoa10w::digit#3 [phi:utoa10w::@3->utoa10w::@6#0] -- register_copy 
  //SEG94 [40] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#11 [phi:utoa10w::@3->utoa10w::@6#1] -- register_copy 
    jmp b6
  //SEG95 utoa10w::@6
  b6:
  //SEG96 [41] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG97 [42] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp i
    bne b1_from_b6
    jmp b8
  //SEG98 utoa10w::@8
  b8:
  //SEG99 [43] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 -- vbuz1=_byte_vwuz2 
    lda value
    sta _0
  //SEG100 [44] *((byte*) utoa10w::dst#4) ← *((const byte[]) DIGITS#0 + (byte~) utoa10w::$0) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy _0
    lda DIGITS,y
    ldy #0
    sta (dst),y
  //SEG101 [45] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 -- pbuz1=_inc_pbuz2 
    lda dst
    clc
    adc #1
    sta dst_2
    lda dst+1
    adc #0
    sta dst_2+1
  //SEG102 [46] *((byte*) utoa10w::dst#2) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst_2),y
    jmp breturn
  //SEG103 utoa10w::@return
  breturn:
  //SEG104 [47] return 
    rts
  //SEG105 utoa10w::@2
  b2:
  //SEG106 [48] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte[]) UTOA10_VAL#0 + (byte) utoa10w::i#2) -- vbuz1=vbuz1_plus_pbuc1_derefidx_vbuz2 
    lda digit
    ldy i
    clc
    adc UTOA10_VAL,y
    sta digit
  //SEG107 [49] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda i
    asl
    sta _9
  //SEG108 [50] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$9) -- vwuz1=vwuz1_minus_pwuc1_derefidx_vbuz2 
    ldy _9
    sec
    lda value
    sbc UTOA10_SUB,y
    sta value
    lda value+1
    sbc UTOA10_SUB+1,y
    sta value+1
  //SEG109 [31] phi from utoa10w::@2 to utoa10w::@1 [phi:utoa10w::@2->utoa10w::@1]
  b1_from_b2:
  //SEG110 [31] phi (byte) utoa10w::bStarted#2 = (byte) 1 [phi:utoa10w::@2->utoa10w::@1#0] -- vbuz1=vbuc1 
    lda #1
    sta bStarted
  //SEG111 [31] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#1 [phi:utoa10w::@2->utoa10w::@1#1] -- register_copy 
  //SEG112 [31] phi (word) utoa10w::value#10 = (word) utoa10w::value#1 [phi:utoa10w::@2->utoa10w::@1#2] -- register_copy 
    jmp b1
}
//SEG113 utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zeropage($a) value, byte* zeropage($c) dst)
utoa16w: {
    .label _0 = $1e
    .label _4 = $21
    .label _8 = $24
    .label _12 = $25
    .label started = $20
    .label started_2 = $23
    .label value = $a
    .label dst = $c
  //SEG114 [52] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 -- vbuz1=_hi_vwuz2 
    lda value+1
    sta _0
  //SEG115 [53] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda _0
    lsr
    lsr
    lsr
    lsr
    sta utoa16n.nybble
  //SEG116 [54] call utoa16n 
  //SEG117 [72] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
  utoa16n_from_utoa16w:
  //SEG118 [72] phi (byte) utoa16n::started#7 = (byte) 0 [phi:utoa16w->utoa16n#0] -- vbuz1=vbuc1 
    lda #0
    sta utoa16n.started
  //SEG119 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
  //SEG120 [55] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4 -- vbuz1=vbuz2 
    lda utoa16n.return_4
    sta utoa16n.return
    jmp b1
  //SEG121 utoa16w::@1
  b1:
  //SEG122 [56] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0 -- vbuz1=vbuz2 
    lda utoa16n.return
    sta started
  //SEG123 [57] (byte~) utoa16w::$4 ← > (word) utoa16w::value#5 -- vbuz1=_hi_vwuz2 
    lda value+1
    sta _4
  //SEG124 [58] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$4 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and _4
    sta utoa16n.nybble
  //SEG125 [59] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1 -- vbuz1=vbuz2 
    lda started
    sta utoa16n.started
  //SEG126 [60] call utoa16n 
  //SEG127 [72] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
  utoa16n_from_b1:
  //SEG128 [72] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
  //SEG129 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
  //SEG130 [61] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4 -- vbuz1=vbuz2 
    lda utoa16n.return_4
    sta utoa16n.return_1
    jmp b2
  //SEG131 utoa16w::@2
  b2:
  //SEG132 [62] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1 -- vbuz1=vbuz2 
    lda utoa16n.return_1
    sta started_2
  //SEG133 [63] (byte~) utoa16w::$8 ← < (word) utoa16w::value#5 -- vbuz1=_lo_vwuz2 
    lda value
    sta _8
  //SEG134 [64] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$8 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda _8
    lsr
    lsr
    lsr
    lsr
    sta utoa16n.nybble
  //SEG135 [65] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2 -- vbuz1=vbuz2 
    lda started_2
    sta utoa16n.started
  //SEG136 [66] call utoa16n 
  //SEG137 [72] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
  utoa16n_from_b2:
  //SEG138 [72] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
  //SEG139 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp b3
  //SEG140 utoa16w::@3
  b3:
  //SEG141 [67] (byte~) utoa16w::$12 ← < (word) utoa16w::value#5 -- vbuz1=_lo_vwuz2 
    lda value
    sta _12
  //SEG142 [68] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$12 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and _12
    sta utoa16n.nybble
  //SEG143 [69] call utoa16n 
  //SEG144 [72] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
  utoa16n_from_b3:
  //SEG145 [72] phi (byte) utoa16n::started#7 = (byte) 1 [phi:utoa16w::@3->utoa16n#0] -- vbuz1=vbuc1 
    lda #1
    sta utoa16n.started
  //SEG146 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp b4
  //SEG147 utoa16w::@4
  b4:
  //SEG148 [70] *((byte*) utoa16w::dst#5) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp breturn
  //SEG149 utoa16w::@return
  breturn:
  //SEG150 [71] return 
    rts
}
//SEG151 utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte zeropage($e) nybble, byte zeropage($f) started)
utoa16n: {
    .label nybble = $e
    .label return = $1f
    .label started = $f
    .label return_1 = $22
    .label return_4 = $f
  //SEG152 [73] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3 -- vbuz1_eq_0_then_la1 
    lda nybble
    cmp #0
    beq b3_from_utoa16n
  //SEG153 [75] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
  b1_from_utoa16n:
  //SEG154 [75] phi (byte) utoa16n::return#4 = (byte) 1 [phi:utoa16n->utoa16n::@1#0] -- vbuz1=vbuc1 
    lda #1
    sta return_4
    jmp b1
  //SEG155 [74] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
  b3_from_utoa16n:
    jmp b3
  //SEG156 utoa16n::@3
  b3:
  //SEG157 [75] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
  b1_from_b3:
  //SEG158 [75] phi (byte) utoa16n::return#4 = (byte) utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    jmp b1
  //SEG159 utoa16n::@1
  b1:
  //SEG160 [76] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return -- vbuz1_eq_0_then_la1 
    lda return_4
    cmp #0
    beq breturn
    jmp b2
  //SEG161 utoa16n::@2
  b2:
  //SEG162 [77] *(*(&(byte*) utoa16w::dst#5)) ← *((const byte[]) DIGITS#0 + (byte) utoa16n::nybble#4) -- _deref__deref_pptc1=pbuc2_derefidx_vbuz1 
    ldy nybble
    lda DIGITS,y
    ldy #0
    sta (utoa16w.dst),y
  //SEG163 [78] *(&(byte*) utoa16w::dst#5) ← ++ *(&(byte*) utoa16w::dst#5) -- _deref_pptc1=_inc__deref_pptc1 
    inc utoa16w.dst
    bne !+
    inc utoa16w.dst+1
  !:
    jmp breturn
  //SEG164 utoa16n::@return
  breturn:
  //SEG165 [79] return 
    rts
}
//SEG166 cls
cls: {
    .label screen = $400
    .label sc = $10
  //SEG167 [81] phi from cls to cls::@1 [phi:cls->cls::@1]
  b1_from_cls:
  //SEG168 [81] phi (byte*) cls::sc#2 = (const byte*) cls::screen#0 [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta sc
    lda #>screen
    sta sc+1
    jmp b1
  //SEG169 [81] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
  b1_from_b1:
  //SEG170 [81] phi (byte*) cls::sc#2 = (byte*) cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    jmp b1
  //SEG171 cls::@1
  b1:
  //SEG172 [82] *((byte*) cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
  //SEG173 [83] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc sc
    bne !+
    inc sc+1
  !:
  //SEG174 [84] if((byte*) cls::sc#1!=(const byte*) cls::screen#0+(word) $3e7+(byte) 1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda sc+1
    cmp #>screen+$3e7+1
    bne b1_from_b1
    lda sc
    cmp #<screen+$3e7+1
    bne b1_from_b1
    jmp breturn
  //SEG175 cls::@return
  breturn:
  //SEG176 [85] return 
    rts
}
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef@"
  // Subtraction values used for decimal utoa()
  UTOA10_SUB: .word $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a
  // Digit addition values used for decimal utoa()
  UTOA10_VAL: .byte 3, 1, 3, 1, 3, 1, 3, 1

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] (byte~) main::$1 ← *((const byte*) control#0) & (byte) $80 [ main::$1 ] ( main:2 [ main::$1 ] ) always clobbers reg byte a 
Statement [7] (byte~) main::$2 ← *((const byte*) raster#0) >> (byte) 1 [ main::$1 main::$2 ] ( main:2 [ main::$1 main::$2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:18 [ main::$1 ]
Statement [10] *((const byte*) bordercol#0) ← (byte) 1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [22] *((const byte*) bordercol#0) ← (byte) 0 [ main::time_start#0 main::time_end#0 ] ( main:2 [ main::time_start#0 main::time_end#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:21 [ main::time_start#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:22 [ main::time_end#0 ]
Statement [23] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 [ main::time#0 ] ( main:2 [ main::time#0 ] ) always clobbers reg byte a 
Statement [24] (word) utoa10w::value#0 ← (word)(byte) main::time#0 [ utoa10w::value#0 ] ( main:2 [ utoa10w::value#0 ] ) always clobbers reg byte a 
Statement [27] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte[]) main::msg#0 + (byte) main::i#2) [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::i#2 main::i#1 ]
Statement [29] if(*((const byte[]) main::msg#0 + (byte) main::i#1)!=(byte) 0) goto main::@3 [ main::i#1 ] ( main:2 [ main::i#1 ] ) always clobbers reg byte a 
Statement [32] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ utoa10w::i#2 utoa10w::i#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ utoa10w::bStarted#2 ]
Statement [33] if((word) utoa10w::value#10>=*((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$8)) goto utoa10w::@2 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 ] ) always clobbers reg byte a 
Statement [34] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$2 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$2 ] ) always clobbers reg byte a 
Statement [37] *((byte*) utoa10w::dst#11) ← *((const byte[]) DIGITS#0 + (byte) utoa10w::digit#3) [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:3 [ utoa10w::i#2 utoa10w::i#1 ]
Statement [43] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 [ utoa10w::dst#4 utoa10w::$0 ] ( main:2::utoa10w:25 [ utoa10w::dst#4 utoa10w::$0 ] ) always clobbers reg byte a 
Statement [44] *((byte*) utoa10w::dst#4) ← *((const byte[]) DIGITS#0 + (byte~) utoa10w::$0) [ utoa10w::dst#4 ] ( main:2::utoa10w:25 [ utoa10w::dst#4 ] ) always clobbers reg byte a reg byte y 
Statement [45] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 [ utoa10w::dst#2 ] ( main:2::utoa10w:25 [ utoa10w::dst#2 ] ) always clobbers reg byte a 
Statement [46] *((byte*) utoa10w::dst#2) ← (byte) 0 [ ] ( main:2::utoa10w:25 [ ] ) always clobbers reg byte a reg byte y 
Statement [48] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte[]) UTOA10_VAL#0 + (byte) utoa10w::i#2) [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#1 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#1 ] ) always clobbers reg byte a 
Statement [49] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 [ utoa10w::value#10 utoa10w::digit#1 utoa10w::$9 ] ( main:2::utoa10w:25 [ utoa10w::value#10 utoa10w::digit#1 utoa10w::$9 ] ) always clobbers reg byte a 
Statement [50] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$9) [ utoa10w::value#1 utoa10w::digit#1 ] ( main:2::utoa10w:25 [ utoa10w::value#1 utoa10w::digit#1 ] ) always clobbers reg byte a 
Statement [52] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 [ utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] ) always clobbers reg byte a 
Statement [53] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 [ utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] ) always clobbers reg byte a 
Statement [57] (byte~) utoa16w::$4 ← > (word) utoa16w::value#5 [ utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:32 [ utoa16w::started#1 ]
Statement [63] (byte~) utoa16w::$8 ← < (word) utoa16w::value#5 [ utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:35 [ utoa16w::started#2 ]
Statement [64] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$8 >> (byte) 4 [ utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] ) always clobbers reg byte a 
Statement [67] (byte~) utoa16w::$12 ← < (word) utoa16w::value#5 [ utoa16w::dst#5 utoa16w::$12 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] ) always clobbers reg byte a 
Statement [70] *((byte*) utoa16w::dst#5) ← (byte) 0 [ ] ( main:2::utoa16w:12 [ main::time_start#0 ] main:2::utoa16w:14 [ main::time_start#0 ] main:2::utoa16w:16 [ main::time_start#0 ] main:2::utoa16w:18 [ main::time_start#0 ] main:2::utoa16w:20 [ main::time_start#0 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:21 [ main::time_start#0 ]
Statement [77] *(*(&(byte*) utoa16w::dst#5)) ← *((const byte[]) DIGITS#0 + (byte) utoa16n::nybble#4) [ utoa16w::dst#5 utoa16n::return#4 ] ( main:2::utoa16w:12::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:14::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:18::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:20::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:12::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:14::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:18::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:20::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:12::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:14::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:18::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:20::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:12::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:14::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:18::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:20::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
Statement [82] *((byte*) cls::sc#2) ← (byte) ' ' [ cls::sc#2 ] ( main:2::cls:5 [ cls::sc#2 ] ) always clobbers reg byte a reg byte y 
Statement [84] if((byte*) cls::sc#1!=(const byte*) cls::screen#0+(word) $3e7+(byte) 1) goto cls::@1 [ cls::sc#1 ] ( main:2::cls:5 [ cls::sc#1 ] ) always clobbers reg byte a 
Statement [6] (byte~) main::$1 ← *((const byte*) control#0) & (byte) $80 [ main::$1 ] ( main:2 [ main::$1 ] ) always clobbers reg byte a 
Statement [7] (byte~) main::$2 ← *((const byte*) raster#0) >> (byte) 1 [ main::$1 main::$2 ] ( main:2 [ main::$1 main::$2 ] ) always clobbers reg byte a 
Statement [10] *((const byte*) bordercol#0) ← (byte) 1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [22] *((const byte*) bordercol#0) ← (byte) 0 [ main::time_start#0 main::time_end#0 ] ( main:2 [ main::time_start#0 main::time_end#0 ] ) always clobbers reg byte a 
Statement [23] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 [ main::time#0 ] ( main:2 [ main::time#0 ] ) always clobbers reg byte a 
Statement [24] (word) utoa10w::value#0 ← (word)(byte) main::time#0 [ utoa10w::value#0 ] ( main:2 [ utoa10w::value#0 ] ) always clobbers reg byte a 
Statement [27] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte[]) main::msg#0 + (byte) main::i#2) [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Statement [29] if(*((const byte[]) main::msg#0 + (byte) main::i#1)!=(byte) 0) goto main::@3 [ main::i#1 ] ( main:2 [ main::i#1 ] ) always clobbers reg byte a 
Statement [32] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$8 ] ) always clobbers reg byte a 
Statement [33] if((word) utoa10w::value#10>=*((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$8)) goto utoa10w::@2 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 ] ) always clobbers reg byte a 
Statement [34] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$2 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#3 utoa10w::bStarted#2 utoa10w::dst#11 utoa10w::$2 ] ) always clobbers reg byte a 
Statement [37] *((byte*) utoa10w::dst#11) ← *((const byte[]) DIGITS#0 + (byte) utoa10w::digit#3) [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::dst#11 ] ) always clobbers reg byte a reg byte y 
Statement [43] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 [ utoa10w::dst#4 utoa10w::$0 ] ( main:2::utoa10w:25 [ utoa10w::dst#4 utoa10w::$0 ] ) always clobbers reg byte a 
Statement [44] *((byte*) utoa10w::dst#4) ← *((const byte[]) DIGITS#0 + (byte~) utoa10w::$0) [ utoa10w::dst#4 ] ( main:2::utoa10w:25 [ utoa10w::dst#4 ] ) always clobbers reg byte a reg byte y 
Statement [45] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 [ utoa10w::dst#2 ] ( main:2::utoa10w:25 [ utoa10w::dst#2 ] ) always clobbers reg byte a 
Statement [46] *((byte*) utoa10w::dst#2) ← (byte) 0 [ ] ( main:2::utoa10w:25 [ ] ) always clobbers reg byte a reg byte y 
Statement [48] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte[]) UTOA10_VAL#0 + (byte) utoa10w::i#2) [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#1 ] ( main:2::utoa10w:25 [ utoa10w::i#2 utoa10w::value#10 utoa10w::digit#1 ] ) always clobbers reg byte a 
Statement [49] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 [ utoa10w::value#10 utoa10w::digit#1 utoa10w::$9 ] ( main:2::utoa10w:25 [ utoa10w::value#10 utoa10w::digit#1 utoa10w::$9 ] ) always clobbers reg byte a 
Statement [50] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$9) [ utoa10w::value#1 utoa10w::digit#1 ] ( main:2::utoa10w:25 [ utoa10w::value#1 utoa10w::digit#1 ] ) always clobbers reg byte a 
Statement [52] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 [ utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::$0 ] ) always clobbers reg byte a 
Statement [53] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 [ utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::nybble#0 ] ) always clobbers reg byte a 
Statement [57] (byte~) utoa16w::$4 ← > (word) utoa16w::value#5 [ utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#1 utoa16w::$4 ] ) always clobbers reg byte a 
Statement [63] (byte~) utoa16w::$8 ← < (word) utoa16w::value#5 [ utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16w::$8 ] ) always clobbers reg byte a 
Statement [64] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$8 >> (byte) 4 [ utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16w::started#2 utoa16n::nybble#2 ] ) always clobbers reg byte a 
Statement [67] (byte~) utoa16w::$12 ← < (word) utoa16w::value#5 [ utoa16w::dst#5 utoa16w::$12 ] ( main:2::utoa16w:12 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] main:2::utoa16w:14 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] main:2::utoa16w:16 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] main:2::utoa16w:18 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] main:2::utoa16w:20 [ main::time_start#0 utoa16w::dst#5 utoa16w::$12 ] ) always clobbers reg byte a 
Statement [70] *((byte*) utoa16w::dst#5) ← (byte) 0 [ ] ( main:2::utoa16w:12 [ main::time_start#0 ] main:2::utoa16w:14 [ main::time_start#0 ] main:2::utoa16w:16 [ main::time_start#0 ] main:2::utoa16w:18 [ main::time_start#0 ] main:2::utoa16w:20 [ main::time_start#0 ] ) always clobbers reg byte a reg byte y 
Statement [77] *(*(&(byte*) utoa16w::dst#5)) ← *((const byte[]) DIGITS#0 + (byte) utoa16n::nybble#4) [ utoa16w::dst#5 utoa16n::return#4 ] ( main:2::utoa16w:12::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:14::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:18::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:20::utoa16n:54 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:12::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:14::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:18::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:20::utoa16n:60 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:12::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:14::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:18::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:20::utoa16n:66 [ main::time_start#0 utoa16w::value#5 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:12::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:14::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:16::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:18::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] main:2::utoa16w:20::utoa16n:69 [ main::time_start#0 utoa16w::dst#5 utoa16n::return#4 ] ) always clobbers reg byte a reg byte y 
Statement [82] *((byte*) cls::sc#2) ← (byte) ' ' [ cls::sc#2 ] ( main:2::cls:5 [ cls::sc#2 ] ) always clobbers reg byte a reg byte y 
Statement [84] if((byte*) cls::sc#1!=(const byte*) cls::screen#0+(word) $3e7+(byte) 1) goto cls::@1 [ cls::sc#1 ] ( main:2::cls:5 [ cls::sc#1 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::i#2 main::i#1 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ utoa10w::i#2 utoa10w::i#1 ] : zp ZP_BYTE:3 , reg byte x , 
Potential registers zp ZP_WORD:4 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] : zp ZP_WORD:4 , 
Potential registers zp ZP_BYTE:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ] : zp ZP_BYTE:6 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ utoa10w::bStarted#2 ] : zp ZP_BYTE:7 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] : zp ZP_WORD:8 , 
Potential registers zp ZP_WORD:10 [ utoa16w::value#5 ] : zp ZP_WORD:10 , 
Potential registers zp ZP_WORD:12 [ utoa16w::dst#5 ] : zp ZP_WORD:12 , 
Potential registers zp ZP_BYTE:14 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] : zp ZP_BYTE:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] : zp ZP_BYTE:15 , reg byte x , 
Potential registers zp ZP_WORD:16 [ cls::sc#2 cls::sc#1 ] : zp ZP_WORD:16 , 
Potential registers zp ZP_BYTE:18 [ main::$1 ] : zp ZP_BYTE:18 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:19 [ main::$2 ] : zp ZP_BYTE:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:20 [ main::rst#0 ] : zp ZP_BYTE:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:21 [ main::time_start#0 ] : zp ZP_BYTE:21 , reg byte x , 
Potential registers zp ZP_BYTE:22 [ main::time_end#0 ] : zp ZP_BYTE:22 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:23 [ main::time#0 ] : zp ZP_BYTE:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:24 [ utoa10w::$8 ] : zp ZP_BYTE:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:25 [ utoa10w::$2 ] : zp ZP_BYTE:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:26 [ utoa10w::$0 ] : zp ZP_BYTE:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:27 [ utoa10w::dst#2 ] : zp ZP_WORD:27 , 
Potential registers zp ZP_BYTE:29 [ utoa10w::$9 ] : zp ZP_BYTE:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:30 [ utoa16w::$0 ] : zp ZP_BYTE:30 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:31 [ utoa16n::return#0 ] : zp ZP_BYTE:31 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:32 [ utoa16w::started#1 ] : zp ZP_BYTE:32 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:33 [ utoa16w::$4 ] : zp ZP_BYTE:33 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:34 [ utoa16n::return#1 ] : zp ZP_BYTE:34 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:35 [ utoa16w::started#2 ] : zp ZP_BYTE:35 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:36 [ utoa16w::$8 ] : zp ZP_BYTE:36 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:37 [ utoa16w::$12 ] : zp ZP_BYTE:37 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [utoa10w] 638.54: zp ZP_WORD:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] 230.29: zp ZP_WORD:4 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] 218.83: zp ZP_BYTE:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ] 206.59: zp ZP_BYTE:3 [ utoa10w::i#2 utoa10w::i#1 ] 202: zp ZP_BYTE:24 [ utoa10w::$8 ] 202: zp ZP_BYTE:25 [ utoa10w::$2 ] 202: zp ZP_BYTE:29 [ utoa10w::$9 ] 20.2: zp ZP_BYTE:7 [ utoa10w::bStarted#2 ] 4: zp ZP_BYTE:26 [ utoa10w::$0 ] 4: zp ZP_WORD:27 [ utoa10w::dst#2 ] 
Uplift Scope [main] 353.5: zp ZP_BYTE:2 [ main::i#2 main::i#1 ] 202: zp ZP_BYTE:19 [ main::$2 ] 202: zp ZP_BYTE:20 [ main::rst#0 ] 101: zp ZP_BYTE:18 [ main::$1 ] 11: zp ZP_BYTE:22 [ main::time_end#0 ] 11: zp ZP_BYTE:23 [ main::time#0 ] 1.83: zp ZP_BYTE:21 [ main::time_start#0 ] 
Uplift Scope [utoa16n] 14.4: zp ZP_BYTE:14 [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] 11.14: zp ZP_BYTE:15 [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] 4: zp ZP_BYTE:31 [ utoa16n::return#0 ] 4: zp ZP_BYTE:34 [ utoa16n::return#1 ] 
Uplift Scope [cls] 33: zp ZP_WORD:16 [ cls::sc#2 cls::sc#1 ] 
Uplift Scope [utoa16w] 4: zp ZP_BYTE:30 [ utoa16w::$0 ] 4: zp ZP_BYTE:33 [ utoa16w::$4 ] 4: zp ZP_BYTE:36 [ utoa16w::$8 ] 4: zp ZP_BYTE:37 [ utoa16w::$12 ] 1.33: zp ZP_BYTE:32 [ utoa16w::started#1 ] 1.33: zp ZP_BYTE:35 [ utoa16w::started#2 ] 0.5: zp ZP_WORD:10 [ utoa16w::value#5 ] 0.07: zp ZP_WORD:12 [ utoa16w::dst#5 ] 
Uplift Scope [] 

Uplifting [utoa10w] best 28511 combination zp ZP_WORD:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] zp ZP_WORD:4 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ] zp ZP_BYTE:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ] reg byte x [ utoa10w::i#2 utoa10w::i#1 ] reg byte a [ utoa10w::$8 ] reg byte a [ utoa10w::$2 ] zp ZP_BYTE:29 [ utoa10w::$9 ] zp ZP_BYTE:7 [ utoa10w::bStarted#2 ] zp ZP_BYTE:26 [ utoa10w::$0 ] zp ZP_WORD:27 [ utoa10w::dst#2 ] 
Limited combination testing to 100 combinations of 4608 possible.
Uplifting [main] best 26111 combination reg byte x [ main::i#2 main::i#1 ] reg byte a [ main::$2 ] reg byte a [ main::rst#0 ] zp ZP_BYTE:18 [ main::$1 ] zp ZP_BYTE:22 [ main::time_end#0 ] zp ZP_BYTE:23 [ main::time#0 ] zp ZP_BYTE:21 [ main::time_start#0 ] 
Limited combination testing to 100 combinations of 3456 possible.
Uplifting [utoa16n] best 26059 combination reg byte a [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ] reg byte x [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ] reg byte x [ utoa16n::return#0 ] reg byte x [ utoa16n::return#1 ] 
Limited combination testing to 100 combinations of 128 possible.
Uplifting [cls] best 26059 combination zp ZP_WORD:16 [ cls::sc#2 cls::sc#1 ] 
Uplifting [utoa16w] best 26035 combination reg byte a [ utoa16w::$0 ] reg byte a [ utoa16w::$4 ] reg byte a [ utoa16w::$8 ] reg byte a [ utoa16w::$12 ] zp ZP_BYTE:32 [ utoa16w::started#1 ] zp ZP_BYTE:35 [ utoa16w::started#2 ] zp ZP_WORD:10 [ utoa16w::value#5 ] zp ZP_WORD:12 [ utoa16w::dst#5 ] 
Limited combination testing to 100 combinations of 2304 possible.
Uplifting [] best 26035 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
Uplifting [utoa10w] best 26035 combination zp ZP_BYTE:6 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:29 [ utoa10w::$9 ]
Uplifting [utoa10w] best 25635 combination reg byte a [ utoa10w::$9 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:18 [ main::$1 ]
Uplifting [main] best 25635 combination zp ZP_BYTE:18 [ main::$1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:7 [ utoa10w::bStarted#2 ]
Uplifting [utoa10w] best 25635 combination zp ZP_BYTE:7 [ utoa10w::bStarted#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:22 [ main::time_end#0 ]
Uplifting [main] best 25595 combination reg byte x [ main::time_end#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:23 [ main::time#0 ]
Uplifting [main] best 25535 combination reg byte a [ main::time#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:26 [ utoa10w::$0 ]
Uplifting [utoa10w] best 25531 combination reg byte a [ utoa10w::$0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:21 [ main::time_start#0 ]
Uplifting [main] best 25531 combination zp ZP_BYTE:21 [ main::time_start#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:32 [ utoa16w::started#1 ]
Uplifting [utoa16w] best 25525 combination reg byte x [ utoa16w::started#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:35 [ utoa16w::started#2 ]
Uplifting [utoa16w] best 25519 combination reg byte x [ utoa16w::started#2 ] 
Coalescing zero page register with common assignment [ zp ZP_WORD:8 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 ] ] with [ zp ZP_WORD:27 [ utoa10w::dst#2 ] ] - score: 1
Allocated (was zp ZP_WORD:4) zp ZP_WORD:2 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
Allocated (was zp ZP_BYTE:6) zp ZP_BYTE:4 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
Allocated (was zp ZP_BYTE:7) zp ZP_BYTE:5 [ utoa10w::bStarted#2 ]
Allocated (was zp ZP_WORD:8) zp ZP_WORD:6 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 utoa10w::dst#2 ]
Allocated (was zp ZP_WORD:10) zp ZP_WORD:8 [ utoa16w::value#5 ]
Allocated (was zp ZP_WORD:12) zp ZP_WORD:10 [ utoa16w::dst#5 ]
Allocated (was zp ZP_WORD:16) zp ZP_WORD:12 [ cls::sc#2 cls::sc#1 ]
Allocated (was zp ZP_BYTE:18) zp ZP_BYTE:14 [ main::$1 ]
Allocated (was zp ZP_BYTE:21) zp ZP_BYTE:15 [ main::time_start#0 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Testing hex to decimal conversion
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label control = $d011
  .label raster = $d012
  .label bordercol = $d020
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
  jsr main
//SEG7 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
    .label _1 = $e
    .label time_start = $f
  //SEG10 asm { sei  }
    sei
  //SEG11 [5] call cls 
  //SEG12 [80] phi from main to cls [phi:main->cls]
  cls_from_main:
    jsr cls
    jmp b1
  //SEG13 main::@1
  b1:
  //SEG14 [6] (byte~) main::$1 ← *((const byte*) control#0) & (byte) $80 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #$80
    and control
    sta _1
  //SEG15 [7] (byte~) main::$2 ← *((const byte*) raster#0) >> (byte) 1 -- vbuaa=_deref_pbuc1_ror_1 
    lda raster
    lsr
  //SEG16 [8] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2 -- vbuaa=vbuz1_bor_vbuaa 
    ora _1
  //SEG17 [9] if((byte) main::rst#0!=(byte) $30) goto main::@1 -- vbuaa_neq_vbuc1_then_la1 
    cmp #$30
    bne b1
    jmp b2
  //SEG18 main::@2
  b2:
  //SEG19 [10] *((const byte*) bordercol#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta bordercol
  //SEG20 [11] (byte) main::time_start#0 ← *((const byte*) raster#0) -- vbuz1=_deref_pbuc1 
    lda raster
    sta time_start
  //SEG21 [12] call utoa16w 
  //SEG22 [51] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
  utoa16w_from_b2:
  //SEG23 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024 [phi:main::@2->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400
    sta utoa16w.dst
    lda #>$400
    sta utoa16w.dst+1
  //SEG24 [51] phi (word) utoa16w::value#5 = (byte) 0 [phi:main::@2->utoa16w#1] -- vwuz1=vbuc1 
    lda #0
    sta utoa16w.value
    lda #0
    sta utoa16w.value+1
    jsr utoa16w
    jmp b4
  //SEG25 main::@4
  b4:
  //SEG26 [13] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG27 [14] call utoa16w 
  //SEG28 [51] phi from main::@4 to utoa16w [phi:main::@4->utoa16w]
  utoa16w_from_b4:
  //SEG29 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28 [phi:main::@4->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28
    sta utoa16w.dst
    lda #>$400+$28
    sta utoa16w.dst+1
  //SEG30 [51] phi (word) utoa16w::value#5 = (word) $4d2 [phi:main::@4->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$4d2
    sta utoa16w.value
    lda #>$4d2
    sta utoa16w.value+1
    jsr utoa16w
    jmp b5
  //SEG31 main::@5
  b5:
  //SEG32 [15] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG33 [16] call utoa16w 
  //SEG34 [51] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
  utoa16w_from_b5:
  //SEG35 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28+(byte) $28 [phi:main::@5->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta utoa16w.dst
    lda #>$400+$28+$28
    sta utoa16w.dst+1
  //SEG36 [51] phi (word) utoa16w::value#5 = (word) $162e [phi:main::@5->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$162e
    sta utoa16w.value
    lda #>$162e
    sta utoa16w.value+1
    jsr utoa16w
    jmp b6
  //SEG37 main::@6
  b6:
  //SEG38 [17] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG39 [18] call utoa16w 
  //SEG40 [51] phi from main::@6 to utoa16w [phi:main::@6->utoa16w]
  utoa16w_from_b6:
  //SEG41 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 [phi:main::@6->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta utoa16w.dst
    lda #>$400+$28+$28+$28
    sta utoa16w.dst+1
  //SEG42 [51] phi (word) utoa16w::value#5 = (word) $270f [phi:main::@6->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$270f
    sta utoa16w.value
    lda #>$270f
    sta utoa16w.value+1
    jsr utoa16w
    jmp b7
  //SEG43 main::@7
  b7:
  //SEG44 [19] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG45 [20] call utoa16w 
  //SEG46 [51] phi from main::@7 to utoa16w [phi:main::@7->utoa16w]
  utoa16w_from_b7:
  //SEG47 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 [phi:main::@7->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta utoa16w.dst+1
  //SEG48 [51] phi (word) utoa16w::value#5 = (word) $e608 [phi:main::@7->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$e608
    sta utoa16w.value
    lda #>$e608
    sta utoa16w.value+1
    jsr utoa16w
    jmp b8
  //SEG49 main::@8
  b8:
  //SEG50 [21] (byte) main::time_end#0 ← *((const byte*) raster#0) -- vbuxx=_deref_pbuc1 
    ldx raster
  //SEG51 [22] *((const byte*) bordercol#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta bordercol
  //SEG52 [23] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 -- vbuaa=vbuxx_minus_vbuz1 
    txa
    sec
    sbc time_start
  //SEG53 [24] (word) utoa10w::value#0 ← (word)(byte) main::time#0 -- vwuz1=_word_vbuaa 
    sta utoa10w.value
    lda #0
    sta utoa10w.value+1
  //SEG54 [25] call utoa10w 
  //SEG55 [30] phi from main::@8 to utoa10w [phi:main::@8->utoa10w]
  utoa10w_from_b8:
    jsr utoa10w
  //SEG56 [26] phi from main::@8 to main::@3 [phi:main::@8->main::@3]
  b3_from_b8:
  //SEG57 [26] phi (byte) main::i#2 = (byte) 0 [phi:main::@8->main::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b3
  //SEG58 [26] phi from main::@3 to main::@3 [phi:main::@3->main::@3]
  b3_from_b3:
  //SEG59 [26] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@3->main::@3#0] -- register_copy 
    jmp b3
  //SEG60 main::@3
  b3:
  //SEG61 [27] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte[]) main::msg#0 + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda msg,x
    sta $400+$28+$28+$28+$28+$50+3,x
  //SEG62 [28] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG63 [29] if(*((const byte[]) main::msg#0 + (byte) main::i#1)!=(byte) 0) goto main::@3 -- pbuc1_derefidx_vbuxx_neq_0_then_la1 
    lda msg,x
    cmp #0
    bne b3_from_b3
    jmp b1
    msg: .text "raster lines@"
}
//SEG64 utoa10w
// Decimal utoa() without using multiply or divide
// utoa10w(word zeropage(2) value, byte* zeropage(6) dst)
utoa10w: {
    .label value = 2
    .label digit = 4
    .label dst = 6
    .label bStarted = 5
  //SEG65 [31] phi from utoa10w to utoa10w::@1 [phi:utoa10w->utoa10w::@1]
  b1_from_utoa10w:
  //SEG66 [31] phi (byte*) utoa10w::dst#11 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 [phi:utoa10w->utoa10w::@1#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28+$50
    sta dst
    lda #>$400+$28+$28+$28+$28+$50
    sta dst+1
  //SEG67 [31] phi (byte) utoa10w::bStarted#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta bStarted
  //SEG68 [31] phi (byte) utoa10w::digit#3 = (byte) 0 [phi:utoa10w->utoa10w::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta digit
  //SEG69 [31] phi (word) utoa10w::value#10 = (word) utoa10w::value#0 [phi:utoa10w->utoa10w::@1#3] -- register_copy 
  //SEG70 [31] phi (byte) utoa10w::i#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#4] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG71 [31] phi from utoa10w::@6 to utoa10w::@1 [phi:utoa10w::@6->utoa10w::@1]
  b1_from_b6:
  //SEG72 [31] phi (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#4 [phi:utoa10w::@6->utoa10w::@1#0] -- register_copy 
  //SEG73 [31] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#7 [phi:utoa10w::@6->utoa10w::@1#1] -- register_copy 
  //SEG74 [31] phi (byte) utoa10w::i#2 = (byte) utoa10w::i#1 [phi:utoa10w::@6->utoa10w::@1#2] -- register_copy 
    jmp b1
  //SEG75 utoa10w::@1
  b1:
  //SEG76 [32] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG77 [33] if((word) utoa10w::value#10>=*((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$8)) goto utoa10w::@2 -- vwuz1_ge_pwuc1_derefidx_vbuaa_then_la1 
    tay
    lda UTOA10_SUB+1,y
    cmp value+1
    bne !+
    lda UTOA10_SUB,y
    cmp value
    beq b2
  !:
    bcc b2
    jmp b3
  //SEG78 utoa10w::@3
  b3:
  //SEG79 [34] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
  //SEG80 [35] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@6 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b6_from_b3
    jmp b4
  //SEG81 utoa10w::@4
  b4:
  //SEG82 [36] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7 -- vbuz1_eq_0_then_la1 
    lda bStarted
    cmp #0
    beq b7_from_b4
    jmp b5
  //SEG83 utoa10w::@5
  b5:
  //SEG84 [37] *((byte*) utoa10w::dst#11) ← *((const byte[]) DIGITS#0 + (byte) utoa10w::digit#3) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy digit
    lda DIGITS,y
    ldy #0
    sta (dst),y
  //SEG85 [38] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
  //SEG86 [39] phi from utoa10w::@4 utoa10w::@5 to utoa10w::@7 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7]
  b7_from_b4:
  b7_from_b5:
  //SEG87 [39] phi (byte*) utoa10w::dst#7 = (byte*) utoa10w::dst#11 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7#0] -- register_copy 
    jmp b7
  //SEG88 utoa10w::@7
  b7:
  //SEG89 [40] phi from utoa10w::@7 to utoa10w::@6 [phi:utoa10w::@7->utoa10w::@6]
  b6_from_b7:
  //SEG90 [40] phi (byte) utoa10w::digit#7 = (byte) 0 [phi:utoa10w::@7->utoa10w::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta digit
  //SEG91 [40] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#7 [phi:utoa10w::@7->utoa10w::@6#1] -- register_copy 
    jmp b6
  //SEG92 [40] phi from utoa10w::@3 to utoa10w::@6 [phi:utoa10w::@3->utoa10w::@6]
  b6_from_b3:
  //SEG93 [40] phi (byte) utoa10w::digit#7 = (byte) utoa10w::digit#3 [phi:utoa10w::@3->utoa10w::@6#0] -- register_copy 
  //SEG94 [40] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#11 [phi:utoa10w::@3->utoa10w::@6#1] -- register_copy 
    jmp b6
  //SEG95 utoa10w::@6
  b6:
  //SEG96 [41] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG97 [42] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b1_from_b6
    jmp b8
  //SEG98 utoa10w::@8
  b8:
  //SEG99 [43] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 -- vbuaa=_byte_vwuz1 
    lda value
  //SEG100 [44] *((byte*) utoa10w::dst#4) ← *((const byte[]) DIGITS#0 + (byte~) utoa10w::$0) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (dst),y
  //SEG101 [45] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
  //SEG102 [46] *((byte*) utoa10w::dst#2) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp breturn
  //SEG103 utoa10w::@return
  breturn:
  //SEG104 [47] return 
    rts
  //SEG105 utoa10w::@2
  b2:
  //SEG106 [48] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte[]) UTOA10_VAL#0 + (byte) utoa10w::i#2) -- vbuz1=vbuz1_plus_pbuc1_derefidx_vbuxx 
    lda UTOA10_VAL,x
    clc
    adc digit
    sta digit
  //SEG107 [49] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG108 [50] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$9) -- vwuz1=vwuz1_minus_pwuc1_derefidx_vbuaa 
    tay
    sec
    lda value
    sbc UTOA10_SUB,y
    sta value
    lda value+1
    sbc UTOA10_SUB+1,y
    sta value+1
  //SEG109 [31] phi from utoa10w::@2 to utoa10w::@1 [phi:utoa10w::@2->utoa10w::@1]
  b1_from_b2:
  //SEG110 [31] phi (byte) utoa10w::bStarted#2 = (byte) 1 [phi:utoa10w::@2->utoa10w::@1#0] -- vbuz1=vbuc1 
    lda #1
    sta bStarted
  //SEG111 [31] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#1 [phi:utoa10w::@2->utoa10w::@1#1] -- register_copy 
  //SEG112 [31] phi (word) utoa10w::value#10 = (word) utoa10w::value#1 [phi:utoa10w::@2->utoa10w::@1#2] -- register_copy 
    jmp b1
}
//SEG113 utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zeropage(8) value, byte* zeropage($a) dst)
utoa16w: {
    .label value = 8
    .label dst = $a
  //SEG114 [52] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda value+1
  //SEG115 [53] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
  //SEG116 [54] call utoa16n 
  //SEG117 [72] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
  utoa16n_from_utoa16w:
  //SEG118 [72] phi (byte) utoa16n::started#7 = (byte) 0 [phi:utoa16w->utoa16n#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG119 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
  //SEG120 [55] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
    jmp b1
  //SEG121 utoa16w::@1
  b1:
  //SEG122 [56] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
  //SEG123 [57] (byte~) utoa16w::$4 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda value+1
  //SEG124 [58] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$4 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
  //SEG125 [59] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  //SEG126 [60] call utoa16n 
  //SEG127 [72] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
  utoa16n_from_b1:
  //SEG128 [72] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
  //SEG129 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
  //SEG130 [61] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
    jmp b2
  //SEG131 utoa16w::@2
  b2:
  //SEG132 [62] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
  //SEG133 [63] (byte~) utoa16w::$8 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda value
  //SEG134 [64] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$8 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
  //SEG135 [65] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  //SEG136 [66] call utoa16n 
  //SEG137 [72] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
  utoa16n_from_b2:
  //SEG138 [72] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
  //SEG139 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp b3
  //SEG140 utoa16w::@3
  b3:
  //SEG141 [67] (byte~) utoa16w::$12 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda value
  //SEG142 [68] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$12 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
  //SEG143 [69] call utoa16n 
  //SEG144 [72] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
  utoa16n_from_b3:
  //SEG145 [72] phi (byte) utoa16n::started#7 = (byte) 1 [phi:utoa16w::@3->utoa16n#0] -- vbuxx=vbuc1 
    ldx #1
  //SEG146 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
    jmp b4
  //SEG147 utoa16w::@4
  b4:
  //SEG148 [70] *((byte*) utoa16w::dst#5) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (dst),y
    jmp breturn
  //SEG149 utoa16w::@return
  breturn:
  //SEG150 [71] return 
    rts
}
//SEG151 utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte register(A) nybble, byte register(X) started)
utoa16n: {
  //SEG152 [73] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b3_from_utoa16n
  //SEG153 [75] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
  b1_from_utoa16n:
  //SEG154 [75] phi (byte) utoa16n::return#4 = (byte) 1 [phi:utoa16n->utoa16n::@1#0] -- vbuxx=vbuc1 
    ldx #1
    jmp b1
  //SEG155 [74] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
  b3_from_utoa16n:
    jmp b3
  //SEG156 utoa16n::@3
  b3:
  //SEG157 [75] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
  b1_from_b3:
  //SEG158 [75] phi (byte) utoa16n::return#4 = (byte) utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
    jmp b1
  //SEG159 utoa16n::@1
  b1:
  //SEG160 [76] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return -- vbuxx_eq_0_then_la1 
    cpx #0
    beq breturn
    jmp b2
  //SEG161 utoa16n::@2
  b2:
  //SEG162 [77] *(*(&(byte*) utoa16w::dst#5)) ← *((const byte[]) DIGITS#0 + (byte) utoa16n::nybble#4) -- _deref__deref_pptc1=pbuc2_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (utoa16w.dst),y
  //SEG163 [78] *(&(byte*) utoa16w::dst#5) ← ++ *(&(byte*) utoa16w::dst#5) -- _deref_pptc1=_inc__deref_pptc1 
    inc utoa16w.dst
    bne !+
    inc utoa16w.dst+1
  !:
    jmp breturn
  //SEG164 utoa16n::@return
  breturn:
  //SEG165 [79] return 
    rts
}
//SEG166 cls
cls: {
    .label screen = $400
    .label sc = $c
  //SEG167 [81] phi from cls to cls::@1 [phi:cls->cls::@1]
  b1_from_cls:
  //SEG168 [81] phi (byte*) cls::sc#2 = (const byte*) cls::screen#0 [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta sc
    lda #>screen
    sta sc+1
    jmp b1
  //SEG169 [81] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
  b1_from_b1:
  //SEG170 [81] phi (byte*) cls::sc#2 = (byte*) cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
    jmp b1
  //SEG171 cls::@1
  b1:
  //SEG172 [82] *((byte*) cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
  //SEG173 [83] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc sc
    bne !+
    inc sc+1
  !:
  //SEG174 [84] if((byte*) cls::sc#1!=(const byte*) cls::screen#0+(word) $3e7+(byte) 1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda sc+1
    cmp #>screen+$3e7+1
    bne b1_from_b1
    lda sc
    cmp #<screen+$3e7+1
    bne b1_from_b1
    jmp breturn
  //SEG175 cls::@return
  breturn:
  //SEG176 [85] return 
    rts
}
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef@"
  // Subtraction values used for decimal utoa()
  UTOA10_SUB: .word $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a
  // Digit addition values used for decimal utoa()
  UTOA10_VAL: .byte 3, 1, 3, 1, 3, 1, 3, 1

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b6
Removing instruction jmp b7
Removing instruction jmp b8
Removing instruction jmp b3
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b7
Removing instruction jmp b6
Removing instruction jmp b8
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp b3
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Replacing instruction ldx #0 with TAX
Replacing instruction ldy #0 with TAY
Replacing instruction ldy #0 with TAY
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b3_from_b3 with b3
Replacing label b6_from_b3 with b6
Replacing label b7_from_b4 with b7
Replacing label b1_from_b6 with b1
Replacing label b3_from_utoa16n with b1
Replacing label b1_from_b1 with b1
Replacing label b1_from_b1 with b1
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction bend_from_b1:
Removing instruction b3_from_b3:
Removing instruction b1_from_b6:
Removing instruction b7_from_b4:
Removing instruction b7_from_b5:
Removing instruction b6_from_b7:
Removing instruction b6_from_b3:
Removing instruction b3_from_utoa16n:
Removing instruction b3:
Removing instruction b1_from_b3:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction cls_from_main:
Removing instruction b2:
Removing instruction utoa16w_from_b2:
Removing instruction b4:
Removing instruction utoa16w_from_b4:
Removing instruction b5:
Removing instruction utoa16w_from_b5:
Removing instruction b6:
Removing instruction utoa16w_from_b6:
Removing instruction b7:
Removing instruction utoa16w_from_b7:
Removing instruction b8:
Removing instruction utoa10w_from_b8:
Removing instruction b3_from_b8:
Removing instruction b1_from_utoa10w:
Removing instruction b3:
Removing instruction b4:
Removing instruction b5:
Removing instruction b8:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction utoa16n_from_utoa16w:
Removing instruction b1:
Removing instruction utoa16n_from_b1:
Removing instruction b2:
Removing instruction utoa16n_from_b2:
Removing instruction b3:
Removing instruction utoa16n_from_b3:
Removing instruction b4:
Removing instruction breturn:
Removing instruction b1_from_utoa16n:
Removing instruction b2:
Removing instruction b1_from_cls:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b3
Removing instruction jmp b1
Removing instruction jmp b6
Removing instruction jmp b1
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte[]) DIGITS
(const byte[]) DIGITS#0 DIGITS = (string) "0123456789abcdef@"
(word[]) UTOA10_SUB
(const word[]) UTOA10_SUB#0 UTOA10_SUB = { (word) $7530, (word) $2710, (word) $bb8, (word) $3e8, (word) $12c, (word) $64, (word) $1e, (word) $a }
(byte[]) UTOA10_VAL
(const byte[]) UTOA10_VAL#0 UTOA10_VAL = { (byte) 3, (byte) 1, (byte) 3, (byte) 1, (byte) 3, (byte) 1, (byte) 3, (byte) 1 }
(byte*) bordercol
(const byte*) bordercol#0 bordercol = (byte*) 53280
(void()) cls()
(label) cls::@1
(label) cls::@return
(byte*) cls::sc
(byte*) cls::sc#1 sc zp ZP_WORD:12 16.5
(byte*) cls::sc#2 sc zp ZP_WORD:12 16.5
(byte*) cls::screen
(const byte*) cls::screen#0 screen = (byte*) 1024
(byte*) control
(const byte*) control#0 control = (byte*) 53265
(void()) main()
(byte~) main::$1 $1 zp ZP_BYTE:14 101.0
(byte~) main::$2 reg byte a 202.0
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(byte) main::i
(byte) main::i#1 reg byte x 151.5
(byte) main::i#2 reg byte x 202.0
(byte[]) main::msg
(const byte[]) main::msg#0 msg = (string) "raster lines@"
(byte) main::rst
(byte) main::rst#0 reg byte a 202.0
(byte*) main::screen
(byte) main::time
(byte) main::time#0 reg byte a 11.0
(byte) main::time_end
(byte) main::time_end#0 reg byte x 11.0
(byte) main::time_start
(byte) main::time_start#0 time_start zp ZP_BYTE:15 1.8333333333333333
(byte*) raster
(const byte*) raster#0 raster = (byte*) 53266
(void()) utoa10w((word) utoa10w::value , (byte*) utoa10w::dst)
(byte~) utoa10w::$0 reg byte a 4.0
(byte~) utoa10w::$2 reg byte a 202.0
(byte~) utoa10w::$8 reg byte a 202.0
(byte~) utoa10w::$9 reg byte a 202.0
(label) utoa10w::@1
(label) utoa10w::@2
(label) utoa10w::@3
(label) utoa10w::@4
(label) utoa10w::@5
(label) utoa10w::@6
(label) utoa10w::@7
(label) utoa10w::@8
(label) utoa10w::@return
(byte) utoa10w::bStarted
(byte) utoa10w::bStarted#2 bStarted zp ZP_BYTE:5 20.2
(byte) utoa10w::digit
(byte) utoa10w::digit#1 digit zp ZP_BYTE:4 67.33333333333333
(byte) utoa10w::digit#3 digit zp ZP_BYTE:4 84.16666666666666
(byte) utoa10w::digit#7 digit zp ZP_BYTE:4 67.33333333333333
(byte*) utoa10w::dst
(byte*) utoa10w::dst#1 dst zp ZP_WORD:6 202.0
(byte*) utoa10w::dst#11 dst zp ZP_WORD:6 72.14285714285714
(byte*) utoa10w::dst#2 dst zp ZP_WORD:6 4.0
(byte*) utoa10w::dst#4 dst zp ZP_WORD:6 61.39999999999999
(byte*) utoa10w::dst#7 dst zp ZP_WORD:6 303.0
(byte) utoa10w::i
(byte) utoa10w::i#1 reg byte x 151.5
(byte) utoa10w::i#2 reg byte x 55.090909090909086
(word) utoa10w::value
(word) utoa10w::value#0 value zp ZP_WORD:2 6.5
(word) utoa10w::value#1 value zp ZP_WORD:2 202.0
(word) utoa10w::value#10 value zp ZP_WORD:2 21.78571428571429
(byte()) utoa16n((byte) utoa16n::nybble , (word**) utoa16n::dst , (byte) utoa16n::started)
(label) utoa16n::@1
(label) utoa16n::@2
(label) utoa16n::@3
(label) utoa16n::@return
(word**) utoa16n::dst
(byte) utoa16n::nybble
(byte) utoa16n::nybble#0 reg byte a 4.0
(byte) utoa16n::nybble#1 reg byte a 2.0
(byte) utoa16n::nybble#2 reg byte a 2.0
(byte) utoa16n::nybble#3 reg byte a 4.0
(byte) utoa16n::nybble#4 reg byte a 2.4
(byte) utoa16n::return
(byte) utoa16n::return#0 reg byte x 4.0
(byte) utoa16n::return#1 reg byte x 4.0
(byte) utoa16n::return#4 reg byte x 1.1428571428571428
(byte) utoa16n::started
(byte) utoa16n::started#1 reg byte x 4.0
(byte) utoa16n::started#2 reg byte x 4.0
(byte) utoa16n::started#7 reg byte x 2.0
(void()) utoa16w((word) utoa16w::value , (byte*) utoa16w::dst)
(byte~) utoa16w::$0 reg byte a 4.0
(byte~) utoa16w::$12 reg byte a 4.0
(byte~) utoa16w::$4 reg byte a 4.0
(byte~) utoa16w::$8 reg byte a 4.0
(label) utoa16w::@1
(label) utoa16w::@2
(label) utoa16w::@3
(label) utoa16w::@4
(label) utoa16w::@return
(byte*) utoa16w::dst
(byte*) utoa16w::dst#5 dst zp ZP_WORD:10 0.07407407407407407
(byte) utoa16w::started
(byte) utoa16w::started#1 reg byte x 1.3333333333333333
(byte) utoa16w::started#2 reg byte x 1.3333333333333333
(word) utoa16w::value
(word) utoa16w::value#5 value zp ZP_WORD:8 0.5

reg byte x [ main::i#2 main::i#1 ]
reg byte x [ utoa10w::i#2 utoa10w::i#1 ]
zp ZP_WORD:2 [ utoa10w::value#10 utoa10w::value#0 utoa10w::value#1 ]
zp ZP_BYTE:4 [ utoa10w::digit#3 utoa10w::digit#7 utoa10w::digit#1 ]
zp ZP_BYTE:5 [ utoa10w::bStarted#2 ]
zp ZP_WORD:6 [ utoa10w::dst#7 utoa10w::dst#11 utoa10w::dst#4 utoa10w::dst#1 utoa10w::dst#2 ]
zp ZP_WORD:8 [ utoa16w::value#5 ]
zp ZP_WORD:10 [ utoa16w::dst#5 ]
reg byte a [ utoa16n::nybble#4 utoa16n::nybble#0 utoa16n::nybble#1 utoa16n::nybble#2 utoa16n::nybble#3 ]
reg byte x [ utoa16n::return#4 utoa16n::started#7 utoa16n::started#1 utoa16n::started#2 ]
zp ZP_WORD:12 [ cls::sc#2 cls::sc#1 ]
zp ZP_BYTE:14 [ main::$1 ]
reg byte a [ main::$2 ]
reg byte a [ main::rst#0 ]
zp ZP_BYTE:15 [ main::time_start#0 ]
reg byte x [ main::time_end#0 ]
reg byte a [ main::time#0 ]
reg byte a [ utoa10w::$8 ]
reg byte a [ utoa10w::$2 ]
reg byte a [ utoa10w::$0 ]
reg byte a [ utoa10w::$9 ]
reg byte a [ utoa16w::$0 ]
reg byte x [ utoa16n::return#0 ]
reg byte x [ utoa16w::started#1 ]
reg byte a [ utoa16w::$4 ]
reg byte x [ utoa16n::return#1 ]
reg byte x [ utoa16w::started#2 ]
reg byte a [ utoa16w::$8 ]
reg byte a [ utoa16w::$12 ]


FINAL ASSEMBLER
Score: 21558

//SEG0 File Comments
// Testing hex to decimal conversion
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label control = $d011
  .label raster = $d012
  .label bordercol = $d020
//SEG3 @begin
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
//SEG5 @1
//SEG6 [2] call main 
//SEG7 [3] phi from @1 to @end [phi:@1->@end]
//SEG8 @end
//SEG9 main
main: {
    .label _1 = $e
    .label time_start = $f
  //SEG10 asm { sei  }
    sei
  //SEG11 [5] call cls 
  //SEG12 [80] phi from main to cls [phi:main->cls]
    jsr cls
  //SEG13 main::@1
  b1:
  //SEG14 [6] (byte~) main::$1 ← *((const byte*) control#0) & (byte) $80 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #$80
    and control
    sta _1
  //SEG15 [7] (byte~) main::$2 ← *((const byte*) raster#0) >> (byte) 1 -- vbuaa=_deref_pbuc1_ror_1 
    lda raster
    lsr
  //SEG16 [8] (byte) main::rst#0 ← (byte~) main::$1 | (byte~) main::$2 -- vbuaa=vbuz1_bor_vbuaa 
    ora _1
  //SEG17 [9] if((byte) main::rst#0!=(byte) $30) goto main::@1 -- vbuaa_neq_vbuc1_then_la1 
    cmp #$30
    bne b1
  //SEG18 main::@2
  //SEG19 [10] *((const byte*) bordercol#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta bordercol
  //SEG20 [11] (byte) main::time_start#0 ← *((const byte*) raster#0) -- vbuz1=_deref_pbuc1 
    lda raster
    sta time_start
  //SEG21 [12] call utoa16w 
  //SEG22 [51] phi from main::@2 to utoa16w [phi:main::@2->utoa16w]
  //SEG23 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024 [phi:main::@2->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400
    sta utoa16w.dst
    lda #>$400
    sta utoa16w.dst+1
  //SEG24 [51] phi (word) utoa16w::value#5 = (byte) 0 [phi:main::@2->utoa16w#1] -- vwuz1=vbuc1 
    lda #0
    sta utoa16w.value
    sta utoa16w.value+1
    jsr utoa16w
  //SEG25 main::@4
  //SEG26 [13] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG27 [14] call utoa16w 
  //SEG28 [51] phi from main::@4 to utoa16w [phi:main::@4->utoa16w]
  //SEG29 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28 [phi:main::@4->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28
    sta utoa16w.dst
    lda #>$400+$28
    sta utoa16w.dst+1
  //SEG30 [51] phi (word) utoa16w::value#5 = (word) $4d2 [phi:main::@4->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$4d2
    sta utoa16w.value
    lda #>$4d2
    sta utoa16w.value+1
    jsr utoa16w
  //SEG31 main::@5
  //SEG32 [15] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG33 [16] call utoa16w 
  //SEG34 [51] phi from main::@5 to utoa16w [phi:main::@5->utoa16w]
  //SEG35 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28+(byte) $28 [phi:main::@5->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28
    sta utoa16w.dst
    lda #>$400+$28+$28
    sta utoa16w.dst+1
  //SEG36 [51] phi (word) utoa16w::value#5 = (word) $162e [phi:main::@5->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$162e
    sta utoa16w.value
    lda #>$162e
    sta utoa16w.value+1
    jsr utoa16w
  //SEG37 main::@6
  //SEG38 [17] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG39 [18] call utoa16w 
  //SEG40 [51] phi from main::@6 to utoa16w [phi:main::@6->utoa16w]
  //SEG41 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28 [phi:main::@6->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28
    sta utoa16w.dst
    lda #>$400+$28+$28+$28
    sta utoa16w.dst+1
  //SEG42 [51] phi (word) utoa16w::value#5 = (word) $270f [phi:main::@6->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$270f
    sta utoa16w.value
    lda #>$270f
    sta utoa16w.value+1
    jsr utoa16w
  //SEG43 main::@7
  //SEG44 [19] *((const byte*) bordercol#0) ← ++ *((const byte*) bordercol#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc bordercol
  //SEG45 [20] call utoa16w 
  //SEG46 [51] phi from main::@7 to utoa16w [phi:main::@7->utoa16w]
  //SEG47 [51] phi (byte*) utoa16w::dst#5 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28 [phi:main::@7->utoa16w#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28
    sta utoa16w.dst
    lda #>$400+$28+$28+$28+$28
    sta utoa16w.dst+1
  //SEG48 [51] phi (word) utoa16w::value#5 = (word) $e608 [phi:main::@7->utoa16w#1] -- vwuz1=vwuc1 
    lda #<$e608
    sta utoa16w.value
    lda #>$e608
    sta utoa16w.value+1
    jsr utoa16w
  //SEG49 main::@8
  //SEG50 [21] (byte) main::time_end#0 ← *((const byte*) raster#0) -- vbuxx=_deref_pbuc1 
    ldx raster
  //SEG51 [22] *((const byte*) bordercol#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta bordercol
  //SEG52 [23] (byte) main::time#0 ← (byte) main::time_end#0 - (byte) main::time_start#0 -- vbuaa=vbuxx_minus_vbuz1 
    txa
    sec
    sbc time_start
  //SEG53 [24] (word) utoa10w::value#0 ← (word)(byte) main::time#0 -- vwuz1=_word_vbuaa 
    sta utoa10w.value
    lda #0
    sta utoa10w.value+1
  //SEG54 [25] call utoa10w 
  //SEG55 [30] phi from main::@8 to utoa10w [phi:main::@8->utoa10w]
    jsr utoa10w
  //SEG56 [26] phi from main::@8 to main::@3 [phi:main::@8->main::@3]
  //SEG57 [26] phi (byte) main::i#2 = (byte) 0 [phi:main::@8->main::@3#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG58 [26] phi from main::@3 to main::@3 [phi:main::@3->main::@3]
  //SEG59 [26] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@3->main::@3#0] -- register_copy 
  //SEG60 main::@3
  b3:
  //SEG61 [27] *((byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50+(byte) 3 + (byte) main::i#2) ← *((const byte[]) main::msg#0 + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda msg,x
    sta $400+$28+$28+$28+$28+$50+3,x
  //SEG62 [28] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG63 [29] if(*((const byte[]) main::msg#0 + (byte) main::i#1)!=(byte) 0) goto main::@3 -- pbuc1_derefidx_vbuxx_neq_0_then_la1 
    lda msg,x
    cmp #0
    bne b3
    jmp b1
    msg: .text "raster lines@"
}
//SEG64 utoa10w
// Decimal utoa() without using multiply or divide
// utoa10w(word zeropage(2) value, byte* zeropage(6) dst)
utoa10w: {
    .label value = 2
    .label digit = 4
    .label dst = 6
    .label bStarted = 5
  //SEG65 [31] phi from utoa10w to utoa10w::@1 [phi:utoa10w->utoa10w::@1]
  //SEG66 [31] phi (byte*) utoa10w::dst#11 = (byte*) 1024+(byte) $28+(byte) $28+(byte) $28+(byte) $28+(byte) $50 [phi:utoa10w->utoa10w::@1#0] -- pbuz1=pbuc1 
    lda #<$400+$28+$28+$28+$28+$50
    sta dst
    lda #>$400+$28+$28+$28+$28+$50
    sta dst+1
  //SEG67 [31] phi (byte) utoa10w::bStarted#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta bStarted
  //SEG68 [31] phi (byte) utoa10w::digit#3 = (byte) 0 [phi:utoa10w->utoa10w::@1#2] -- vbuz1=vbuc1 
    sta digit
  //SEG69 [31] phi (word) utoa10w::value#10 = (word) utoa10w::value#0 [phi:utoa10w->utoa10w::@1#3] -- register_copy 
  //SEG70 [31] phi (byte) utoa10w::i#2 = (byte) 0 [phi:utoa10w->utoa10w::@1#4] -- vbuxx=vbuc1 
    tax
  //SEG71 [31] phi from utoa10w::@6 to utoa10w::@1 [phi:utoa10w::@6->utoa10w::@1]
  //SEG72 [31] phi (byte*) utoa10w::dst#11 = (byte*) utoa10w::dst#4 [phi:utoa10w::@6->utoa10w::@1#0] -- register_copy 
  //SEG73 [31] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#7 [phi:utoa10w::@6->utoa10w::@1#1] -- register_copy 
  //SEG74 [31] phi (byte) utoa10w::i#2 = (byte) utoa10w::i#1 [phi:utoa10w::@6->utoa10w::@1#2] -- register_copy 
  //SEG75 utoa10w::@1
  b1:
  //SEG76 [32] (byte~) utoa10w::$8 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG77 [33] if((word) utoa10w::value#10>=*((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$8)) goto utoa10w::@2 -- vwuz1_ge_pwuc1_derefidx_vbuaa_then_la1 
    tay
    lda UTOA10_SUB+1,y
    cmp value+1
    bne !+
    lda UTOA10_SUB,y
    cmp value
    beq b2
  !:
    bcc b2
  //SEG78 utoa10w::@3
  //SEG79 [34] (byte~) utoa10w::$2 ← (byte) utoa10w::i#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
  //SEG80 [35] if((byte~) utoa10w::$2==(byte) 0) goto utoa10w::@6 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b6
  //SEG81 utoa10w::@4
  //SEG82 [36] if((byte) utoa10w::bStarted#2==(byte) 0) goto utoa10w::@7 -- vbuz1_eq_0_then_la1 
    lda bStarted
    cmp #0
    beq b7
  //SEG83 utoa10w::@5
  //SEG84 [37] *((byte*) utoa10w::dst#11) ← *((const byte[]) DIGITS#0 + (byte) utoa10w::digit#3) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy digit
    lda DIGITS,y
    ldy #0
    sta (dst),y
  //SEG85 [38] (byte*) utoa10w::dst#1 ← ++ (byte*) utoa10w::dst#11 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
  //SEG86 [39] phi from utoa10w::@4 utoa10w::@5 to utoa10w::@7 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7]
  //SEG87 [39] phi (byte*) utoa10w::dst#7 = (byte*) utoa10w::dst#11 [phi:utoa10w::@4/utoa10w::@5->utoa10w::@7#0] -- register_copy 
  //SEG88 utoa10w::@7
  b7:
  //SEG89 [40] phi from utoa10w::@7 to utoa10w::@6 [phi:utoa10w::@7->utoa10w::@6]
  //SEG90 [40] phi (byte) utoa10w::digit#7 = (byte) 0 [phi:utoa10w::@7->utoa10w::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta digit
  //SEG91 [40] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#7 [phi:utoa10w::@7->utoa10w::@6#1] -- register_copy 
  //SEG92 [40] phi from utoa10w::@3 to utoa10w::@6 [phi:utoa10w::@3->utoa10w::@6]
  //SEG93 [40] phi (byte) utoa10w::digit#7 = (byte) utoa10w::digit#3 [phi:utoa10w::@3->utoa10w::@6#0] -- register_copy 
  //SEG94 [40] phi (byte*) utoa10w::dst#4 = (byte*) utoa10w::dst#11 [phi:utoa10w::@3->utoa10w::@6#1] -- register_copy 
  //SEG95 utoa10w::@6
  b6:
  //SEG96 [41] (byte) utoa10w::i#1 ← ++ (byte) utoa10w::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG97 [42] if((byte) utoa10w::i#1!=(byte) 8) goto utoa10w::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b1
  //SEG98 utoa10w::@8
  //SEG99 [43] (byte~) utoa10w::$0 ← (byte)(word) utoa10w::value#10 -- vbuaa=_byte_vwuz1 
    lda value
  //SEG100 [44] *((byte*) utoa10w::dst#4) ← *((const byte[]) DIGITS#0 + (byte~) utoa10w::$0) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (dst),y
  //SEG101 [45] (byte*) utoa10w::dst#2 ← ++ (byte*) utoa10w::dst#4 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
  //SEG102 [46] *((byte*) utoa10w::dst#2) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (dst),y
  //SEG103 utoa10w::@return
  //SEG104 [47] return 
    rts
  //SEG105 utoa10w::@2
  b2:
  //SEG106 [48] (byte) utoa10w::digit#1 ← (byte) utoa10w::digit#3 + *((const byte[]) UTOA10_VAL#0 + (byte) utoa10w::i#2) -- vbuz1=vbuz1_plus_pbuc1_derefidx_vbuxx 
    lda UTOA10_VAL,x
    clc
    adc digit
    sta digit
  //SEG107 [49] (byte~) utoa10w::$9 ← (byte) utoa10w::i#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG108 [50] (word) utoa10w::value#1 ← (word) utoa10w::value#10 - *((const word[]) UTOA10_SUB#0 + (byte~) utoa10w::$9) -- vwuz1=vwuz1_minus_pwuc1_derefidx_vbuaa 
    tay
    sec
    lda value
    sbc UTOA10_SUB,y
    sta value
    lda value+1
    sbc UTOA10_SUB+1,y
    sta value+1
  //SEG109 [31] phi from utoa10w::@2 to utoa10w::@1 [phi:utoa10w::@2->utoa10w::@1]
  //SEG110 [31] phi (byte) utoa10w::bStarted#2 = (byte) 1 [phi:utoa10w::@2->utoa10w::@1#0] -- vbuz1=vbuc1 
    lda #1
    sta bStarted
  //SEG111 [31] phi (byte) utoa10w::digit#3 = (byte) utoa10w::digit#1 [phi:utoa10w::@2->utoa10w::@1#1] -- register_copy 
  //SEG112 [31] phi (word) utoa10w::value#10 = (word) utoa10w::value#1 [phi:utoa10w::@2->utoa10w::@1#2] -- register_copy 
    jmp b1
}
//SEG113 utoa16w
// Hexadecimal utoa() for an unsigned int (16bits)
// utoa16w(word zeropage(8) value, byte* zeropage($a) dst)
utoa16w: {
    .label value = 8
    .label dst = $a
  //SEG114 [52] (byte~) utoa16w::$0 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda value+1
  //SEG115 [53] (byte) utoa16n::nybble#0 ← (byte~) utoa16w::$0 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
  //SEG116 [54] call utoa16n 
  //SEG117 [72] phi from utoa16w to utoa16n [phi:utoa16w->utoa16n]
  //SEG118 [72] phi (byte) utoa16n::started#7 = (byte) 0 [phi:utoa16w->utoa16n#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG119 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#0 [phi:utoa16w->utoa16n#1] -- register_copy 
    jsr utoa16n
  //SEG120 [55] (byte) utoa16n::return#0 ← (byte) utoa16n::return#4
  //SEG121 utoa16w::@1
  //SEG122 [56] (byte) utoa16w::started#1 ← (byte) utoa16n::return#0
  //SEG123 [57] (byte~) utoa16w::$4 ← > (word) utoa16w::value#5 -- vbuaa=_hi_vwuz1 
    lda value+1
  //SEG124 [58] (byte) utoa16n::nybble#1 ← (byte~) utoa16w::$4 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
  //SEG125 [59] (byte) utoa16n::started#1 ← (byte) utoa16w::started#1
  //SEG126 [60] call utoa16n 
  //SEG127 [72] phi from utoa16w::@1 to utoa16n [phi:utoa16w::@1->utoa16n]
  //SEG128 [72] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#1 [phi:utoa16w::@1->utoa16n#0] -- register_copy 
  //SEG129 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#1 [phi:utoa16w::@1->utoa16n#1] -- register_copy 
    jsr utoa16n
  //SEG130 [61] (byte) utoa16n::return#1 ← (byte) utoa16n::return#4
  //SEG131 utoa16w::@2
  //SEG132 [62] (byte) utoa16w::started#2 ← (byte) utoa16n::return#1
  //SEG133 [63] (byte~) utoa16w::$8 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda value
  //SEG134 [64] (byte) utoa16n::nybble#2 ← (byte~) utoa16w::$8 >> (byte) 4 -- vbuaa=vbuaa_ror_4 
    lsr
    lsr
    lsr
    lsr
  //SEG135 [65] (byte) utoa16n::started#2 ← (byte) utoa16w::started#2
  //SEG136 [66] call utoa16n 
  //SEG137 [72] phi from utoa16w::@2 to utoa16n [phi:utoa16w::@2->utoa16n]
  //SEG138 [72] phi (byte) utoa16n::started#7 = (byte) utoa16n::started#2 [phi:utoa16w::@2->utoa16n#0] -- register_copy 
  //SEG139 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#2 [phi:utoa16w::@2->utoa16n#1] -- register_copy 
    jsr utoa16n
  //SEG140 utoa16w::@3
  //SEG141 [67] (byte~) utoa16w::$12 ← < (word) utoa16w::value#5 -- vbuaa=_lo_vwuz1 
    lda value
  //SEG142 [68] (byte) utoa16n::nybble#3 ← (byte~) utoa16w::$12 & (byte) $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
  //SEG143 [69] call utoa16n 
  //SEG144 [72] phi from utoa16w::@3 to utoa16n [phi:utoa16w::@3->utoa16n]
  //SEG145 [72] phi (byte) utoa16n::started#7 = (byte) 1 [phi:utoa16w::@3->utoa16n#0] -- vbuxx=vbuc1 
    ldx #1
  //SEG146 [72] phi (byte) utoa16n::nybble#4 = (byte) utoa16n::nybble#3 [phi:utoa16w::@3->utoa16n#1] -- register_copy 
    jsr utoa16n
  //SEG147 utoa16w::@4
  //SEG148 [70] *((byte*) utoa16w::dst#5) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (dst),y
  //SEG149 utoa16w::@return
  //SEG150 [71] return 
    rts
}
//SEG151 utoa16n
// Hexadecimal utoa() for a single nybble
// utoa16n(byte register(A) nybble, byte register(X) started)
utoa16n: {
  //SEG152 [73] if((byte) utoa16n::nybble#4==(byte) 0) goto utoa16n::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b1
  //SEG153 [75] phi from utoa16n to utoa16n::@1 [phi:utoa16n->utoa16n::@1]
  //SEG154 [75] phi (byte) utoa16n::return#4 = (byte) 1 [phi:utoa16n->utoa16n::@1#0] -- vbuxx=vbuc1 
    ldx #1
  //SEG155 [74] phi from utoa16n to utoa16n::@3 [phi:utoa16n->utoa16n::@3]
  //SEG156 utoa16n::@3
  //SEG157 [75] phi from utoa16n::@3 to utoa16n::@1 [phi:utoa16n::@3->utoa16n::@1]
  //SEG158 [75] phi (byte) utoa16n::return#4 = (byte) utoa16n::started#7 [phi:utoa16n::@3->utoa16n::@1#0] -- register_copy 
  //SEG159 utoa16n::@1
  b1:
  //SEG160 [76] if((byte) utoa16n::return#4==(byte) 0) goto utoa16n::@return -- vbuxx_eq_0_then_la1 
    cpx #0
    beq breturn
  //SEG161 utoa16n::@2
  //SEG162 [77] *(*(&(byte*) utoa16w::dst#5)) ← *((const byte[]) DIGITS#0 + (byte) utoa16n::nybble#4) -- _deref__deref_pptc1=pbuc2_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (utoa16w.dst),y
  //SEG163 [78] *(&(byte*) utoa16w::dst#5) ← ++ *(&(byte*) utoa16w::dst#5) -- _deref_pptc1=_inc__deref_pptc1 
    inc utoa16w.dst
    bne !+
    inc utoa16w.dst+1
  !:
  //SEG164 utoa16n::@return
  breturn:
  //SEG165 [79] return 
    rts
}
//SEG166 cls
cls: {
    .label screen = $400
    .label sc = $c
  //SEG167 [81] phi from cls to cls::@1 [phi:cls->cls::@1]
  //SEG168 [81] phi (byte*) cls::sc#2 = (const byte*) cls::screen#0 [phi:cls->cls::@1#0] -- pbuz1=pbuc1 
    lda #<screen
    sta sc
    lda #>screen
    sta sc+1
  //SEG169 [81] phi from cls::@1 to cls::@1 [phi:cls::@1->cls::@1]
  //SEG170 [81] phi (byte*) cls::sc#2 = (byte*) cls::sc#1 [phi:cls::@1->cls::@1#0] -- register_copy 
  //SEG171 cls::@1
  b1:
  //SEG172 [82] *((byte*) cls::sc#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
  //SEG173 [83] (byte*) cls::sc#1 ← ++ (byte*) cls::sc#2 -- pbuz1=_inc_pbuz1 
    inc sc
    bne !+
    inc sc+1
  !:
  //SEG174 [84] if((byte*) cls::sc#1!=(const byte*) cls::screen#0+(word) $3e7+(byte) 1) goto cls::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda sc+1
    cmp #>screen+$3e7+1
    bne b1
    lda sc
    cmp #<screen+$3e7+1
    bne b1
  //SEG175 cls::@return
  //SEG176 [85] return 
    rts
}
  // Digits used for utoa()
  DIGITS: .text "0123456789abcdef@"
  // Subtraction values used for decimal utoa()
  UTOA10_SUB: .word $7530, $2710, $bb8, $3e8, $12c, $64, $1e, $a
  // Digit addition values used for decimal utoa()
  UTOA10_VAL: .byte 3, 1, 3, 1, 3, 1, 3, 1

