Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) init::sx)
Adding pointer type conversion cast (byte*) PROCPORT_DDR in (byte*) PROCPORT_DDR ← (number) 0
Adding pointer type conversion cast (byte*) PROCPORT in (byte*) PROCPORT ← (number) 1
Adding pointer type conversion cast (byte*) CHARGEN in (byte*) CHARGEN ← (number) $d000
Adding pointer type conversion cast (byte*) SPRITES_XPOS in (byte*) SPRITES_XPOS ← (number) $d000
Adding pointer type conversion cast (byte*) SPRITES_YPOS in (byte*) SPRITES_YPOS ← (number) $d001
Adding pointer type conversion cast (byte*) SPRITES_XMSB in (byte*) SPRITES_XMSB ← (number) $d010
Adding pointer type conversion cast (byte*) RASTER in (byte*) RASTER ← (number) $d012
Adding pointer type conversion cast (byte*) SPRITES_ENABLE in (byte*) SPRITES_ENABLE ← (number) $d015
Adding pointer type conversion cast (byte*) SPRITES_EXPAND_Y in (byte*) SPRITES_EXPAND_Y ← (number) $d017
Adding pointer type conversion cast (byte*) SPRITES_PRIORITY in (byte*) SPRITES_PRIORITY ← (number) $d01b
Adding pointer type conversion cast (byte*) SPRITES_MC in (byte*) SPRITES_MC ← (number) $d01c
Adding pointer type conversion cast (byte*) SPRITES_EXPAND_X in (byte*) SPRITES_EXPAND_X ← (number) $d01d
Adding pointer type conversion cast (byte*) BORDERCOL in (byte*) BORDERCOL ← (number) $d020
Adding pointer type conversion cast (byte*) BGCOL in (byte*) BGCOL ← (number) $d021
Adding pointer type conversion cast (byte*) BGCOL1 in (byte*) BGCOL1 ← (number) $d021
Adding pointer type conversion cast (byte*) BGCOL2 in (byte*) BGCOL2 ← (number) $d022
Adding pointer type conversion cast (byte*) BGCOL3 in (byte*) BGCOL3 ← (number) $d023
Adding pointer type conversion cast (byte*) BGCOL4 in (byte*) BGCOL4 ← (number) $d024
Adding pointer type conversion cast (byte*) SPRITES_MC1 in (byte*) SPRITES_MC1 ← (number) $d025
Adding pointer type conversion cast (byte*) SPRITES_MC2 in (byte*) SPRITES_MC2 ← (number) $d026
Adding pointer type conversion cast (byte*) SPRITES_COLS in (byte*) SPRITES_COLS ← (number) $d027
Adding pointer type conversion cast (byte*) VIC_CONTROL in (byte*) VIC_CONTROL ← (number) $d011
Adding pointer type conversion cast (byte*) D011 in (byte*) D011 ← (number) $d011
Adding pointer type conversion cast (byte*) VIC_CONTROL2 in (byte*) VIC_CONTROL2 ← (number) $d016
Adding pointer type conversion cast (byte*) D016 in (byte*) D016 ← (number) $d016
Adding pointer type conversion cast (byte*) D018 in (byte*) D018 ← (number) $d018
Adding pointer type conversion cast (byte*) VIC_MEMORY in (byte*) VIC_MEMORY ← (number) $d018
Adding pointer type conversion cast (byte*) LIGHTPEN_X in (byte*) LIGHTPEN_X ← (number) $d013
Adding pointer type conversion cast (byte*) LIGHTPEN_Y in (byte*) LIGHTPEN_Y ← (number) $d014
Adding pointer type conversion cast (byte*) IRQ_STATUS in (byte*) IRQ_STATUS ← (number) $d019
Adding pointer type conversion cast (byte*) IRQ_ENABLE in (byte*) IRQ_ENABLE ← (number) $d01a
Adding pointer type conversion cast (byte*) COLS in (byte*) COLS ← (number) $d800
Adding pointer type conversion cast (byte*) CIA1_PORT_A in (byte*) CIA1_PORT_A ← (number) $dc00
Adding pointer type conversion cast (byte*) CIA1_PORT_B in (byte*) CIA1_PORT_B ← (number) $dc01
Adding pointer type conversion cast (byte*) CIA1_PORT_A_DDR in (byte*) CIA1_PORT_A_DDR ← (number) $dc02
Adding pointer type conversion cast (byte*) CIA1_PORT_B_DDR in (byte*) CIA1_PORT_B_DDR ← (number) $dc03
Adding pointer type conversion cast (byte*) CIA1_INTERRUPT in (byte*) CIA1_INTERRUPT ← (number) $dc0d
Adding pointer type conversion cast (byte*) CIA2_PORT_A in (byte*) CIA2_PORT_A ← (number) $dd00
Adding pointer type conversion cast (byte*) CIA2_PORT_B in (byte*) CIA2_PORT_B ← (number) $dd01
Adding pointer type conversion cast (byte*) CIA2_PORT_A_DDR in (byte*) CIA2_PORT_A_DDR ← (number) $dd02
Adding pointer type conversion cast (byte*) CIA2_PORT_B_DDR in (byte*) CIA2_PORT_B_DDR ← (number) $dd03
Adding pointer type conversion cast (byte*) CIA2_INTERRUPT in (byte*) CIA2_INTERRUPT ← (number) $dd0d
Adding pointer type conversion cast (void()**) KERNEL_IRQ in (void()**) KERNEL_IRQ ← (number) $314
Adding pointer type conversion cast (void()**) HARDWARE_IRQ in (void()**) HARDWARE_IRQ ← (number) $fffe
Adding pointer type conversion cast (byte*) PLEX_SCREEN_PTR in (byte*) PLEX_SCREEN_PTR ← (number~) $0
Adding pointer type conversion cast (byte*) SCREEN in (byte*) SCREEN ← (number) $400
Adding pointer type conversion cast (byte*) SPRITE in (byte*) SPRITE ← (number) $2000
Adding pointer type conversion cast (byte*) YSIN in (byte*) YSIN ← (number) $2100
Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) SPRITE
Identified constant variable (byte*) YSIN
Inlined call [105] (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call [118] call plexSetScreen (byte*) plexInit::screen 
Inlined call [153] call plexFreePrepare 
Inlined call [159] call plexFreeAdd (byte) plexShowSprite::ypos 
Inlined call [258] (byte~) loop::$7 ← call plexFreeNextYpos 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) plexInit::plexSetScreen1_@return
Culled Empty Block (label) plexInit::@2
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) plexSort::plexFreePrepare1_@return
Culled Empty Block (label) plexSort::@7
Culled Empty Block (label) @7
Culled Empty Block (label) plexShowSprite::plexFreeAdd1_@return
Culled Empty Block (label) plexShowSprite::@5
Culled Empty Block (label) plexShowSprite::@3
Culled Empty Block (label) @8
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) @13
Culled Empty Block (label) init::@4
Culled Empty Block (label) @14
Culled Empty Block (label) loop::@2
Culled Empty Block (label) loop::@27
Culled Empty Block (label) loop::@3
Culled Empty Block (label) loop::@28
Culled Empty Block (label) loop::@5
Culled Empty Block (label) loop::@7
Culled Empty Block (label) loop::@8
Culled Empty Block (label) loop::@9
Culled Empty Block (label) loop::@13
Culled Empty Block (label) loop::@15
Culled Empty Block (label) loop::@16
Culled Empty Block (label) loop::@17
Culled Empty Block (label) loop::plexFreeNextYpos1_@1
Culled Empty Block (label) loop::@20
Culled Empty Block (label) loop::@22
Culled Empty Block (label) loop::@23
Culled Empty Block (label) loop::@24
Culled Empty Block (label) loop::@26

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) SPRITES_XPOS#0 ← ((byte*)) (number) $d000
  (byte*) SPRITES_YPOS#0 ← ((byte*)) (number) $d001
  (byte*) SPRITES_XMSB#0 ← ((byte*)) (number) $d010
  (byte*) RASTER#0 ← ((byte*)) (number) $d012
  (byte*) SPRITES_ENABLE#0 ← ((byte*)) (number) $d015
  (byte*) BORDERCOL#0 ← ((byte*)) (number) $d020
  (byte*) SPRITES_COLS#0 ← ((byte*)) (number) $d027
  (byte*) D011#0 ← ((byte*)) (number) $d011
  (byte) VIC_RST8#0 ← (number) $80
  (byte) VIC_DEN#0 ← (number) $10
  (byte) VIC_RSEL#0 ← (number) 8
  (byte) BLACK#0 ← (number) 0
  (byte) GREEN#0 ← (number) 5
  to:@4
@4: scope:[]  from @begin
  (byte) PLEX_COUNT#0 ← (number) $20
  (word[PLEX_COUNT#0]) PLEX_XPOS#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte[PLEX_COUNT#0]) PLEX_YPOS#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte[PLEX_COUNT#0]) PLEX_PTR#0 ← { fill( PLEX_COUNT#0, 0) }
  (number~) $0 ← (number) $400 + (number) $3f8
  (byte*) PLEX_SCREEN_PTR#0 ← ((byte*)) (number~) $0
  (byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte) plex_show_idx#0 ← (number) 0
  (byte) plex_sprite_idx#0 ← (number) 0
  (byte) plex_sprite_msb#0 ← (number) 1
  to:@9
plexInit: scope:[plexInit]  from init
  (byte*) plexInit::screen#1 ← phi( init/(byte*) plexInit::screen#0 )
  (byte*) plexInit::plexSetScreen1_screen#0 ← (byte*) plexInit::screen#1
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  (byte*) plexInit::plexSetScreen1_screen#1 ← phi( plexInit/(byte*) plexInit::plexSetScreen1_screen#0 )
  (byte*~) plexInit::plexSetScreen1_$0#0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
  (byte*) PLEX_SCREEN_PTR#1 ← (byte*~) plexInit::plexSetScreen1_$0#0
  to:plexInit::@3
plexInit::@3: scope:[plexInit]  from plexInit::plexSetScreen1
  (byte*) PLEX_SCREEN_PTR#22 ← phi( plexInit::plexSetScreen1/(byte*) PLEX_SCREEN_PTR#1 )
  (number~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) plexInit::i#0 ← (byte) 0
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::@3
  (byte*) PLEX_SCREEN_PTR#15 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 plexInit::@3/(byte*) PLEX_SCREEN_PTR#22 )
  (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::@3/(byte) plexInit::i#0 )
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  (byte) plexInit::i#1 ← (byte) plexInit::i#2 + rangenext(0,plexInit::$1)
  (bool~) plexInit::$2 ← (byte) plexInit::i#1 != rangelast(0,plexInit::$1)
  if((bool~) plexInit::$2) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  (byte*) PLEX_SCREEN_PTR#8 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 )
  (byte*) PLEX_SCREEN_PTR#2 ← (byte*) PLEX_SCREEN_PTR#8
  return 
  to:@return
plexSort: scope:[plexSort]  from loop::@11
  (number~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (number) 2
  (byte) plexSort::m#0 ← (byte) 0
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  (byte) plexSort::m#2 ← phi( plexSort/(byte) plexSort::m#0 plexSort::@2/(byte) plexSort::m#1 )
  (number~) plexSort::$2 ← (byte) plexSort::m#2 + (number) 1
  (byte) plexSort::nxt_idx#0 ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (number~) plexSort::$2)
  (byte) plexSort::nxt_y#0 ← *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0)
  (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))
  (bool~) plexSort::$4 ← ! (bool~) plexSort::$3
  if((bool~) plexSort::$4) goto plexSort::@2
  to:plexSort::@5
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  (byte) plexSort::m#3 ← phi( plexSort::@1/(byte) plexSort::m#2 plexSort::@4/(byte) plexSort::m#5 )
  (byte) plexSort::m#1 ← (byte) plexSort::m#3 + rangenext(0,plexSort::$1)
  (bool~) plexSort::$9 ← (byte) plexSort::m#1 != rangelast(0,plexSort::$1)
  if((bool~) plexSort::$9) goto plexSort::@1
  to:plexSort::@6
plexSort::@5: scope:[plexSort]  from plexSort::@1
  (byte) plexSort::nxt_idx#3 ← phi( plexSort::@1/(byte) plexSort::nxt_idx#0 )
  (byte) plexSort::nxt_y#2 ← phi( plexSort::@1/(byte) plexSort::nxt_y#0 )
  (byte) plexSort::m#4 ← phi( plexSort::@1/(byte) plexSort::m#2 )
  (byte) plexSort::s#0 ← (byte) plexSort::m#4
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@3 plexSort::@5
  (byte) plexSort::m#6 ← phi( plexSort::@3/(byte) plexSort::m#6 plexSort::@5/(byte) plexSort::m#4 )
  (byte) plexSort::nxt_idx#2 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 plexSort::@5/(byte) plexSort::nxt_idx#3 )
  (byte) plexSort::nxt_y#1 ← phi( plexSort::@3/(byte) plexSort::nxt_y#1 plexSort::@5/(byte) plexSort::nxt_y#2 )
  (byte) plexSort::s#3 ← phi( plexSort::@3/(byte) plexSort::s#1 plexSort::@5/(byte) plexSort::s#0 )
  (number~) plexSort::$5 ← (byte) plexSort::s#3 + (number) 1
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (number~) plexSort::$5) ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3)
  (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  (bool~) plexSort::$6 ← (byte) plexSort::s#1 != (number) $ff
  (bool~) plexSort::$7 ← (byte) plexSort::nxt_y#1 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))
  (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
  if((bool~) plexSort::$8) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3
  (byte) plexSort::m#5 ← phi( plexSort::@3/(byte) plexSort::m#6 )
  (byte) plexSort::nxt_idx#1 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 )
  (byte) plexSort::s#4 ← phi( plexSort::@3/(byte) plexSort::s#1 )
  (byte) plexSort::s#2 ← ++ (byte) plexSort::s#4
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#1
  to:plexSort::@2
plexSort::@6: scope:[plexSort]  from plexSort::@2
  (byte) plex_show_idx#1 ← (number) 0
  (byte) plex_sprite_idx#1 ← (number) 0
  (byte) plex_sprite_msb#1 ← (number) 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  (byte) plex_sprite_msb#38 ← phi( plexSort::@6/(byte) plex_sprite_msb#1 )
  (byte) plex_sprite_idx#39 ← phi( plexSort::@6/(byte) plex_sprite_idx#1 )
  (byte) plex_show_idx#39 ← phi( plexSort::@6/(byte) plex_show_idx#1 )
  (byte) plexSort::plexFreePrepare1_s#0 ← (byte) 0
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#30 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_msb#38 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#30 )
  (byte) plex_sprite_idx#32 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_idx#39 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#32 )
  (byte) plex_show_idx#32 ← phi( plexSort::plexFreePrepare1/(byte) plex_show_idx#39 plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#32 )
  (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) plexSort::plexFreePrepare1_s#0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
  (byte) plexSort::plexFreePrepare1_s#1 ← (byte) plexSort::plexFreePrepare1_s#2 + rangenext(0,7)
  (bool~) plexSort::plexFreePrepare1_$0#0 ← (byte) plexSort::plexFreePrepare1_s#1 != rangelast(0,7)
  if((bool~) plexSort::plexFreePrepare1_$0#0) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#23 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#30 )
  (byte) plex_sprite_idx#22 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#32 )
  (byte) plex_show_idx#22 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#32 )
  (byte) plex_free_next#0 ← (number) 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  (byte) plex_free_next#11 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_free_next#0 )
  (byte) plex_sprite_msb#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_msb#23 )
  (byte) plex_sprite_idx#11 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_idx#22 )
  (byte) plex_show_idx#11 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_show_idx#22 )
  (byte) plex_show_idx#2 ← (byte) plex_show_idx#11
  (byte) plex_sprite_idx#2 ← (byte) plex_sprite_idx#11
  (byte) plex_sprite_msb#2 ← (byte) plex_sprite_msb#12
  (byte) plex_free_next#1 ← (byte) plex_free_next#11
  return 
  to:@return
plexShowSprite: scope:[plexShowSprite]  from loop::@21
  (byte) plex_sprite_msb#39 ← phi( loop::@21/(byte) plex_sprite_msb#27 )
  (byte*) PLEX_SCREEN_PTR#23 ← phi( loop::@21/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) plex_free_next#21 ← phi( loop::@21/(byte) plex_free_next#27 )
  (byte) plex_show_idx#12 ← phi( loop::@21/(byte) plex_show_idx#23 )
  (byte) plex_sprite_idx#12 ← phi( loop::@21/(byte) plex_sprite_idx#23 )
  (byte~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 << (number) 1
  (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte~) plexShowSprite::$0
  (byte) plexShowSprite::ypos#0 ← *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#12))
  *((byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::ypos#0
  (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← (byte) plexShowSprite::ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  (byte) plex_sprite_msb#31 ← phi( plexShowSprite/(byte) plex_sprite_msb#39 )
  (byte) plexShowSprite::plex_sprite_idx2#2 ← phi( plexShowSprite/(byte) plexShowSprite::plex_sprite_idx2#0 )
  (byte) plex_sprite_idx#24 ← phi( plexShowSprite/(byte) plex_sprite_idx#12 )
  (byte*) PLEX_SCREEN_PTR#16 ← phi( plexShowSprite/(byte*) PLEX_SCREEN_PTR#23 )
  (byte) plex_show_idx#24 ← phi( plexShowSprite/(byte) plex_show_idx#12 )
  (byte) plex_free_next#12 ← phi( plexShowSprite/(byte) plex_free_next#21 )
  (byte) plexShowSprite::plexFreeAdd1_ypos#1 ← phi( plexShowSprite/(byte) plexShowSprite::plexFreeAdd1_ypos#0 )
  (number~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
  *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#12) ← (number~) plexShowSprite::plexFreeAdd1_$0#0
  (number~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#12 + (number) 1
  (number~) plexShowSprite::plexFreeAdd1_$2#0 ← (number~) plexShowSprite::plexFreeAdd1_$1#0 & (number) 7
  (byte) plex_free_next#2 ← (number~) plexShowSprite::plexFreeAdd1_$2#0
  to:plexShowSprite::@7
plexShowSprite::@7: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  (byte) plex_free_next#39 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_free_next#2 )
  (byte) plex_sprite_msb#24 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_msb#31 )
  (byte) plexShowSprite::plex_sprite_idx2#1 ← phi( plexShowSprite::plexFreeAdd1/(byte) plexShowSprite::plex_sprite_idx2#2 )
  (byte) plex_sprite_idx#13 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_idx#24 )
  (byte*) PLEX_SCREEN_PTR#9 ← phi( plexShowSprite::plexFreeAdd1/(byte*) PLEX_SCREEN_PTR#16 )
  (byte) plex_show_idx#13 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_show_idx#24 )
  *((byte*) PLEX_SCREEN_PTR#9 + (byte) plex_sprite_idx#13) ← *((byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#13))
  (byte) plexShowSprite::xpos_idx#0 ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#13)
  (byte~) plexShowSprite::$10 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$2 ← < *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$10)
  *((byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#1) ← (byte~) plexShowSprite::$2
  (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$3 ← > *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11)
  (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
  if((bool~) plexShowSprite::$4) goto plexShowSprite::@1
  to:plexShowSprite::@4
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#30 ← phi( plexShowSprite::@7/(byte) plex_free_next#39 )
  (byte) plex_show_idx#25 ← phi( plexShowSprite::@7/(byte) plex_show_idx#13 )
  (byte) plex_sprite_idx#25 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#13 )
  (byte) plex_sprite_msb#13 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#24 )
  *((byte*) SPRITES_XMSB#0) ← *((byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#13
  to:plexShowSprite::@2
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#31 ← phi( plexShowSprite::@7/(byte) plex_free_next#39 )
  (byte) plex_show_idx#26 ← phi( plexShowSprite::@7/(byte) plex_show_idx#13 )
  (byte) plex_sprite_idx#26 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#13 )
  (byte) plex_sprite_msb#14 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#24 )
  (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#14
  *((byte*) SPRITES_XMSB#0) ← *((byte*) SPRITES_XMSB#0) & (number~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@4
  (byte) plex_free_next#22 ← phi( plexShowSprite::@1/(byte) plex_free_next#30 plexShowSprite::@4/(byte) plex_free_next#31 )
  (byte) plex_sprite_msb#15 ← phi( plexShowSprite::@1/(byte) plex_sprite_msb#13 plexShowSprite::@4/(byte) plex_sprite_msb#14 )
  (byte) plex_show_idx#14 ← phi( plexShowSprite::@1/(byte) plex_show_idx#25 plexShowSprite::@4/(byte) plex_show_idx#26 )
  (byte) plex_sprite_idx#14 ← phi( plexShowSprite::@1/(byte) plex_sprite_idx#25 plexShowSprite::@4/(byte) plex_sprite_idx#26 )
  (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (number) 1
  (number~) plexShowSprite::$6 ← (number~) plexShowSprite::$5 & (number) 7
  (byte) plex_sprite_idx#3 ← (number~) plexShowSprite::$6
  (byte) plex_show_idx#3 ← ++ (byte) plex_show_idx#14
  (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#15 << (number) 1
  (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
  (bool~) plexShowSprite::$8 ← ! (bool~) plexShowSprite::$7
  if((bool~) plexShowSprite::$8) goto plexShowSprite::@return
  to:plexShowSprite::@6
plexShowSprite::@6: scope:[plexShowSprite]  from plexShowSprite::@2
  (byte) plex_show_idx#27 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 )
  (byte) plex_sprite_idx#27 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 )
  (byte) plex_free_next#23 ← phi( plexShowSprite::@2/(byte) plex_free_next#22 )
  (byte) plex_sprite_msb#4 ← (number) 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@6
  (byte) plex_sprite_msb#16 ← phi( plexShowSprite::@2/(byte) plex_sprite_msb#3 plexShowSprite::@6/(byte) plex_sprite_msb#4 )
  (byte) plex_show_idx#15 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 plexShowSprite::@6/(byte) plex_show_idx#27 )
  (byte) plex_sprite_idx#15 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 plexShowSprite::@6/(byte) plex_sprite_idx#27 )
  (byte) plex_free_next#13 ← phi( plexShowSprite::@2/(byte) plex_free_next#22 plexShowSprite::@6/(byte) plex_free_next#23 )
  (byte) plex_free_next#3 ← (byte) plex_free_next#13
  (byte) plex_sprite_idx#4 ← (byte) plex_sprite_idx#15
  (byte) plex_show_idx#4 ← (byte) plex_show_idx#15
  (byte) plex_sprite_msb#5 ← (byte) plex_sprite_msb#16
  return 
  to:@return
@9: scope:[]  from @4
  (byte) plex_sprite_msb#40 ← phi( @4/(byte) plex_sprite_msb#0 )
  (byte) plex_sprite_idx#40 ← phi( @4/(byte) plex_sprite_idx#0 )
  (byte) plex_show_idx#40 ← phi( @4/(byte) plex_show_idx#0 )
  (byte*) PLEX_SCREEN_PTR#27 ← phi( @4/(byte*) PLEX_SCREEN_PTR#0 )
  (byte[8]) PLEX_FREE_YPOS#0 ← { fill( 8, 0) }
  (byte) plex_free_next#4 ← (number) 0
  to:@12
@12: scope:[]  from @9
  (byte) plex_free_next#38 ← phi( @9/(byte) plex_free_next#4 )
  (byte) plex_sprite_msb#37 ← phi( @9/(byte) plex_sprite_msb#40 )
  (byte) plex_sprite_idx#38 ← phi( @9/(byte) plex_sprite_idx#40 )
  (byte) plex_show_idx#38 ← phi( @9/(byte) plex_show_idx#40 )
  (byte*) PLEX_SCREEN_PTR#25 ← phi( @9/(byte*) PLEX_SCREEN_PTR#27 )
  (byte*) SCREEN#0 ← ((byte*)) (number) $400
  (byte*) SPRITE#0 ← ((byte*)) (number) $2000
  (byte*) YSIN#0 ← ((byte*)) (number) $2100
  kickasm(location (byte*) YSIN#0) {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
  kickasm(location (byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  to:@15
main: scope:[main]  from @15
  (byte) plex_free_next#32 ← phi( @15/(byte) plex_free_next#29 )
  (byte) plex_sprite_msb#32 ← phi( @15/(byte) plex_sprite_msb#29 )
  (byte) plex_sprite_idx#33 ← phi( @15/(byte) plex_sprite_idx#31 )
  (byte) plex_show_idx#33 ← phi( @15/(byte) plex_show_idx#31 )
  (byte*) PLEX_SCREEN_PTR#17 ← phi( @15/(byte*) PLEX_SCREEN_PTR#21 )
  asm { sei  }
  call init 
  to:main::@1
main::@1: scope:[main]  from main
  (byte) plex_free_next#24 ← phi( main/(byte) plex_free_next#32 )
  (byte) plex_sprite_msb#25 ← phi( main/(byte) plex_sprite_msb#32 )
  (byte) plex_sprite_idx#28 ← phi( main/(byte) plex_sprite_idx#33 )
  (byte) plex_show_idx#28 ← phi( main/(byte) plex_show_idx#33 )
  (byte*) PLEX_SCREEN_PTR#10 ← phi( main/(byte*) PLEX_SCREEN_PTR#6 )
  (byte*) PLEX_SCREEN_PTR#3 ← (byte*) PLEX_SCREEN_PTR#10
  call loop 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte*) PLEX_SCREEN_PTR#18 ← phi( main::@1/(byte*) PLEX_SCREEN_PTR#3 )
  (byte) plex_free_next#14 ← phi( main::@1/(byte) plex_free_next#9 )
  (byte) plex_sprite_msb#17 ← phi( main::@1/(byte) plex_sprite_msb#10 )
  (byte) plex_sprite_idx#16 ← phi( main::@1/(byte) plex_sprite_idx#9 )
  (byte) plex_show_idx#16 ← phi( main::@1/(byte) plex_show_idx#9 )
  (byte) plex_show_idx#5 ← (byte) plex_show_idx#16
  (byte) plex_sprite_idx#5 ← (byte) plex_sprite_idx#16
  (byte) plex_sprite_msb#6 ← (byte) plex_sprite_msb#17
  (byte) plex_free_next#5 ← (byte) plex_free_next#14
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) plex_free_next#15 ← phi( main::@2/(byte) plex_free_next#5 )
  (byte) plex_sprite_msb#18 ← phi( main::@2/(byte) plex_sprite_msb#6 )
  (byte) plex_sprite_idx#17 ← phi( main::@2/(byte) plex_sprite_idx#5 )
  (byte) plex_show_idx#17 ← phi( main::@2/(byte) plex_show_idx#5 )
  (byte*) PLEX_SCREEN_PTR#11 ← phi( main::@2/(byte*) PLEX_SCREEN_PTR#18 )
  (byte*) PLEX_SCREEN_PTR#4 ← (byte*) PLEX_SCREEN_PTR#11
  (byte) plex_show_idx#6 ← (byte) plex_show_idx#17
  (byte) plex_sprite_idx#6 ← (byte) plex_sprite_idx#17
  (byte) plex_sprite_msb#7 ← (byte) plex_sprite_msb#18
  (byte) plex_free_next#6 ← (byte) plex_free_next#15
  return 
  to:@return
init: scope:[init]  from main
  (byte*) PLEX_SCREEN_PTR#19 ← phi( main/(byte*) PLEX_SCREEN_PTR#17 )
  (byte~) init::$0 ← (byte) VIC_DEN#0 | (byte) VIC_RSEL#0
  (number~) init::$1 ← (byte~) init::$0 | (number) 3
  *((byte*) D011#0) ← (number~) init::$1
  (byte*) plexInit::screen#0 ← (byte*) SCREEN#0
  call plexInit 
  to:init::@5
init::@5: scope:[init]  from init
  (byte*) PLEX_SCREEN_PTR#12 ← phi( init/(byte*) PLEX_SCREEN_PTR#2 )
  (byte*) PLEX_SCREEN_PTR#5 ← (byte*) PLEX_SCREEN_PTR#12
  (word) init::xp#0 ← (number) $20
  (number~) init::$3 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) init::sx#0 ← (byte) 0
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@5
  (byte*) PLEX_SCREEN_PTR#28 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#28 init::@5/(byte*) PLEX_SCREEN_PTR#5 )
  (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init::@5/(word) init::xp#0 )
  (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init::@5/(byte) init::sx#0 )
  (byte*~) init::$4 ← (byte*) SPRITE#0 / (number) $40
  (byte~) init::$5 ← ((byte)) (byte*~) init::$4
  *((byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte~) init::$5
  (byte~) init::$8 ← (byte) init::sx#2 * (const byte) SIZEOF_WORD
  *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2
  (word) init::xp#1 ← (word) init::xp#2 + (number) 9
  (byte) init::sx#1 ← (byte) init::sx#2 + rangenext(0,init::$3)
  (bool~) init::$6 ← (byte) init::sx#1 != rangelast(0,init::$3)
  if((bool~) init::$6) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  (byte*) PLEX_SCREEN_PTR#24 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#28 )
  *((byte*) SPRITES_ENABLE#0) ← (number) $ff
  (byte) init::ss#0 ← (byte) 0
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  (byte*) PLEX_SCREEN_PTR#20 ← phi( init::@2/(byte*) PLEX_SCREEN_PTR#24 init::@3/(byte*) PLEX_SCREEN_PTR#20 )
  (byte) init::ss#2 ← phi( init::@2/(byte) init::ss#0 init::@3/(byte) init::ss#1 )
  *((byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (byte) GREEN#0
  (byte) init::ss#1 ← (byte) init::ss#2 + rangenext(0,7)
  (bool~) init::$7 ← (byte) init::ss#1 != rangelast(0,7)
  if((bool~) init::$7) goto init::@3
  to:init::@return
init::@return: scope:[init]  from init::@3
  (byte*) PLEX_SCREEN_PTR#13 ← phi( init::@3/(byte*) PLEX_SCREEN_PTR#20 )
  (byte*) PLEX_SCREEN_PTR#6 ← (byte*) PLEX_SCREEN_PTR#13
  return 
  to:@return
loop: scope:[loop]  from main::@1
  (byte*) PLEX_SCREEN_PTR#43 ← phi( main::@1/(byte*) PLEX_SCREEN_PTR#3 )
  (byte) plex_free_next#33 ← phi( main::@1/(byte) plex_free_next#24 )
  (byte) plex_sprite_msb#33 ← phi( main::@1/(byte) plex_sprite_msb#25 )
  (byte) plex_sprite_idx#34 ← phi( main::@1/(byte) plex_sprite_idx#28 )
  (byte) plex_show_idx#34 ← phi( main::@1/(byte) plex_show_idx#28 )
  (byte) loop::sin_idx#0 ← (number) 0
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@25
  (byte*) PLEX_SCREEN_PTR#42 ← phi( loop/(byte*) PLEX_SCREEN_PTR#43 loop::@25/(byte*) PLEX_SCREEN_PTR#44 )
  (byte) loop::sin_idx#6 ← phi( loop/(byte) loop::sin_idx#0 loop::@25/(byte) loop::sin_idx#7 )
  (byte) plex_free_next#28 ← phi( loop/(byte) plex_free_next#33 loop::@25/(byte) plex_free_next#34 )
  (byte) plex_sprite_msb#28 ← phi( loop/(byte) plex_sprite_msb#33 loop::@25/(byte) plex_sprite_msb#34 )
  (byte) plex_sprite_idx#30 ← phi( loop/(byte) plex_sprite_idx#34 loop::@25/(byte) plex_sprite_idx#35 )
  (byte) plex_show_idx#30 ← phi( loop/(byte) plex_show_idx#34 loop::@25/(byte) plex_show_idx#35 )
  if(true) goto loop::@4
  to:loop::@return
loop::@4: scope:[loop]  from loop::@1 loop::@4
  (byte*) PLEX_SCREEN_PTR#41 ← phi( loop::@1/(byte*) PLEX_SCREEN_PTR#42 loop::@4/(byte*) PLEX_SCREEN_PTR#41 )
  (byte) plex_free_next#43 ← phi( loop::@1/(byte) plex_free_next#28 loop::@4/(byte) plex_free_next#43 )
  (byte) plex_sprite_msb#43 ← phi( loop::@1/(byte) plex_sprite_msb#28 loop::@4/(byte) plex_sprite_msb#43 )
  (byte) plex_sprite_idx#43 ← phi( loop::@1/(byte) plex_sprite_idx#30 loop::@4/(byte) plex_sprite_idx#43 )
  (byte) plex_show_idx#43 ← phi( loop::@1/(byte) plex_show_idx#30 loop::@4/(byte) plex_show_idx#43 )
  (byte) loop::sin_idx#4 ← phi( loop::@1/(byte) loop::sin_idx#6 loop::@4/(byte) loop::sin_idx#4 )
  (bool~) loop::$0 ← *((byte*) RASTER#0) != (number) $ff
  if((bool~) loop::$0) goto loop::@4
  to:loop::@6
loop::@6: scope:[loop]  from loop::@4
  (byte*) PLEX_SCREEN_PTR#40 ← phi( loop::@4/(byte*) PLEX_SCREEN_PTR#41 )
  (byte) plex_free_next#40 ← phi( loop::@4/(byte) plex_free_next#43 )
  (byte) plex_sprite_msb#41 ← phi( loop::@4/(byte) plex_sprite_msb#43 )
  (byte) plex_sprite_idx#41 ← phi( loop::@4/(byte) plex_sprite_idx#43 )
  (byte) plex_show_idx#41 ← phi( loop::@4/(byte) plex_show_idx#43 )
  (byte) loop::sin_idx#2 ← phi( loop::@4/(byte) loop::sin_idx#4 )
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  (byte) loop::y_idx#0 ← (byte) loop::sin_idx#2
  (number~) loop::$1 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) loop::sy#0 ← (byte) 0
  to:loop::@10
loop::@10: scope:[loop]  from loop::@10 loop::@6
  (byte*) PLEX_SCREEN_PTR#39 ← phi( loop::@10/(byte*) PLEX_SCREEN_PTR#39 loop::@6/(byte*) PLEX_SCREEN_PTR#40 )
  (byte) plex_free_next#35 ← phi( loop::@10/(byte) plex_free_next#35 loop::@6/(byte) plex_free_next#40 )
  (byte) plex_sprite_msb#35 ← phi( loop::@10/(byte) plex_sprite_msb#35 loop::@6/(byte) plex_sprite_msb#41 )
  (byte) plex_sprite_idx#36 ← phi( loop::@10/(byte) plex_sprite_idx#36 loop::@6/(byte) plex_sprite_idx#41 )
  (byte) plex_show_idx#36 ← phi( loop::@10/(byte) plex_show_idx#36 loop::@6/(byte) plex_show_idx#41 )
  (byte) loop::sin_idx#5 ← phi( loop::@10/(byte) loop::sin_idx#5 loop::@6/(byte) loop::sin_idx#2 )
  (byte) loop::sy#2 ← phi( loop::@10/(byte) loop::sy#1 loop::@6/(byte) loop::sy#0 )
  (byte) loop::y_idx#2 ← phi( loop::@10/(byte) loop::y_idx#1 loop::@6/(byte) loop::y_idx#0 )
  *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((byte*) YSIN#0 + (byte) loop::y_idx#2)
  (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (number) 8
  (byte) loop::sy#1 ← (byte) loop::sy#2 + rangenext(0,loop::$1)
  (bool~) loop::$2 ← (byte) loop::sy#1 != rangelast(0,loop::$1)
  if((bool~) loop::$2) goto loop::@10
  to:loop::@11
loop::@11: scope:[loop]  from loop::@10
  (byte*) PLEX_SCREEN_PTR#38 ← phi( loop::@10/(byte*) PLEX_SCREEN_PTR#39 )
  (byte) plex_free_next#25 ← phi( loop::@10/(byte) plex_free_next#35 )
  (byte) plex_sprite_msb#26 ← phi( loop::@10/(byte) plex_sprite_msb#35 )
  (byte) plex_sprite_idx#29 ← phi( loop::@10/(byte) plex_sprite_idx#36 )
  (byte) plex_show_idx#29 ← phi( loop::@10/(byte) plex_show_idx#36 )
  (byte) loop::sin_idx#3 ← phi( loop::@10/(byte) loop::sin_idx#5 )
  (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#3 + (number) 1
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  call plexSort 
  to:loop::@30
loop::@30: scope:[loop]  from loop::@11
  (byte) loop::sin_idx#17 ← phi( loop::@11/(byte) loop::sin_idx#1 )
  (byte*) PLEX_SCREEN_PTR#37 ← phi( loop::@11/(byte*) PLEX_SCREEN_PTR#38 )
  (byte) plex_free_next#16 ← phi( loop::@11/(byte) plex_free_next#1 )
  (byte) plex_sprite_msb#19 ← phi( loop::@11/(byte) plex_sprite_msb#2 )
  (byte) plex_sprite_idx#18 ← phi( loop::@11/(byte) plex_sprite_idx#2 )
  (byte) plex_show_idx#18 ← phi( loop::@11/(byte) plex_show_idx#2 )
  (byte) plex_show_idx#7 ← (byte) plex_show_idx#18
  (byte) plex_sprite_idx#7 ← (byte) plex_sprite_idx#18
  (byte) plex_sprite_msb#8 ← (byte) plex_sprite_msb#19
  (byte) plex_free_next#7 ← (byte) plex_free_next#16
  *((byte*) BORDERCOL#0) ← (byte) BLACK#0
  to:loop::@12
loop::@12: scope:[loop]  from loop::@12 loop::@30
  (byte) loop::sin_idx#16 ← phi( loop::@12/(byte) loop::sin_idx#16 loop::@30/(byte) loop::sin_idx#17 )
  (byte*) PLEX_SCREEN_PTR#36 ← phi( loop::@12/(byte*) PLEX_SCREEN_PTR#36 loop::@30/(byte*) PLEX_SCREEN_PTR#37 )
  (byte) plex_sprite_msb#48 ← phi( loop::@12/(byte) plex_sprite_msb#48 loop::@30/(byte) plex_sprite_msb#8 )
  (byte) plex_show_idx#48 ← phi( loop::@12/(byte) plex_show_idx#48 loop::@30/(byte) plex_show_idx#7 )
  (byte) plex_sprite_idx#48 ← phi( loop::@12/(byte) plex_sprite_idx#48 loop::@30/(byte) plex_sprite_idx#7 )
  (byte) plex_free_next#41 ← phi( loop::@12/(byte) plex_free_next#41 loop::@30/(byte) plex_free_next#7 )
  (byte~) loop::$4 ← *((byte*) D011#0) & (byte) VIC_RST8#0
  (bool~) loop::$5 ← (byte~) loop::$4 != (number) 0
  if((bool~) loop::$5) goto loop::@12
  to:loop::@14
loop::@14: scope:[loop]  from loop::@12
  (byte) loop::sin_idx#15 ← phi( loop::@12/(byte) loop::sin_idx#16 )
  (byte*) PLEX_SCREEN_PTR#34 ← phi( loop::@12/(byte*) PLEX_SCREEN_PTR#36 )
  (byte) plex_sprite_msb#47 ← phi( loop::@12/(byte) plex_sprite_msb#48 )
  (byte) plex_show_idx#47 ← phi( loop::@12/(byte) plex_show_idx#48 )
  (byte) plex_sprite_idx#47 ← phi( loop::@12/(byte) plex_sprite_idx#48 )
  (byte) plex_free_next#36 ← phi( loop::@12/(byte) plex_free_next#41 )
  (number~) loop::$6 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) loop::ss#0 ← (byte) 0
  to:loop::@18
loop::@18: scope:[loop]  from loop::@14 loop::@31
  (byte) loop::sin_idx#14 ← phi( loop::@14/(byte) loop::sin_idx#15 loop::@31/(byte) loop::sin_idx#8 )
  (byte*) PLEX_SCREEN_PTR#33 ← phi( loop::@14/(byte*) PLEX_SCREEN_PTR#34 loop::@31/(byte*) PLEX_SCREEN_PTR#35 )
  (byte) loop::ss#8 ← phi( loop::@14/(byte) loop::ss#0 loop::@31/(byte) loop::ss#1 )
  (byte) plex_sprite_msb#46 ← phi( loop::@14/(byte) plex_sprite_msb#47 loop::@31/(byte) plex_sprite_msb#9 )
  (byte) plex_show_idx#46 ← phi( loop::@14/(byte) plex_show_idx#47 loop::@31/(byte) plex_show_idx#8 )
  (byte) plex_sprite_idx#46 ← phi( loop::@14/(byte) plex_sprite_idx#47 loop::@31/(byte) plex_sprite_idx#8 )
  (byte) plex_free_next#26 ← phi( loop::@14/(byte) plex_free_next#36 loop::@31/(byte) plex_free_next#8 )
  *((byte*) BORDERCOL#0) ← (byte) BLACK#0
  to:loop::plexFreeNextYpos1
loop::plexFreeNextYpos1: scope:[loop]  from loop::@18
  (byte) loop::sin_idx#13 ← phi( loop::@18/(byte) loop::sin_idx#14 )
  (byte*) PLEX_SCREEN_PTR#32 ← phi( loop::@18/(byte*) PLEX_SCREEN_PTR#33 )
  (byte) loop::ss#7 ← phi( loop::@18/(byte) loop::ss#8 )
  (byte) plex_sprite_msb#45 ← phi( loop::@18/(byte) plex_sprite_msb#46 )
  (byte) plex_show_idx#45 ← phi( loop::@18/(byte) plex_show_idx#46 )
  (byte) plex_sprite_idx#45 ← phi( loop::@18/(byte) plex_sprite_idx#46 )
  (byte) plex_free_next#17 ← phi( loop::@18/(byte) plex_free_next#26 )
  (byte) loop::plexFreeNextYpos1_return#0 ← *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17)
  to:loop::plexFreeNextYpos1_@return
loop::plexFreeNextYpos1_@return: scope:[loop]  from loop::plexFreeNextYpos1
  (byte) loop::sin_idx#12 ← phi( loop::plexFreeNextYpos1/(byte) loop::sin_idx#13 )
  (byte*) PLEX_SCREEN_PTR#31 ← phi( loop::plexFreeNextYpos1/(byte*) PLEX_SCREEN_PTR#32 )
  (byte) loop::ss#6 ← phi( loop::plexFreeNextYpos1/(byte) loop::ss#7 )
  (byte) plex_sprite_msb#44 ← phi( loop::plexFreeNextYpos1/(byte) plex_sprite_msb#45 )
  (byte) plex_free_next#44 ← phi( loop::plexFreeNextYpos1/(byte) plex_free_next#17 )
  (byte) plex_show_idx#44 ← phi( loop::plexFreeNextYpos1/(byte) plex_show_idx#45 )
  (byte) plex_sprite_idx#44 ← phi( loop::plexFreeNextYpos1/(byte) plex_sprite_idx#45 )
  (byte) loop::plexFreeNextYpos1_return#2 ← phi( loop::plexFreeNextYpos1/(byte) loop::plexFreeNextYpos1_return#0 )
  (byte) loop::plexFreeNextYpos1_return#1 ← (byte) loop::plexFreeNextYpos1_return#2
  to:loop::@29
loop::@29: scope:[loop]  from loop::plexFreeNextYpos1_@return
  (byte) loop::sin_idx#11 ← phi( loop::plexFreeNextYpos1_@return/(byte) loop::sin_idx#12 )
  (byte*) PLEX_SCREEN_PTR#30 ← phi( loop::plexFreeNextYpos1_@return/(byte*) PLEX_SCREEN_PTR#31 )
  (byte) loop::ss#5 ← phi( loop::plexFreeNextYpos1_@return/(byte) loop::ss#6 )
  (byte) plex_sprite_msb#42 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_sprite_msb#44 )
  (byte) plex_free_next#42 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_free_next#44 )
  (byte) plex_show_idx#42 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_show_idx#44 )
  (byte) plex_sprite_idx#42 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_sprite_idx#44 )
  (byte) loop::plexFreeNextYpos1_return#3 ← phi( loop::plexFreeNextYpos1_@return/(byte) loop::plexFreeNextYpos1_return#1 )
  (byte~) loop::$7 ← (byte) loop::plexFreeNextYpos1_return#3
  (byte) loop::rasterY#0 ← (byte~) loop::$7
  to:loop::@19
loop::@19: scope:[loop]  from loop::@19 loop::@29
  (byte) loop::sin_idx#10 ← phi( loop::@19/(byte) loop::sin_idx#10 loop::@29/(byte) loop::sin_idx#11 )
  (byte*) PLEX_SCREEN_PTR#29 ← phi( loop::@19/(byte*) PLEX_SCREEN_PTR#29 loop::@29/(byte*) PLEX_SCREEN_PTR#30 )
  (byte) loop::ss#4 ← phi( loop::@19/(byte) loop::ss#4 loop::@29/(byte) loop::ss#5 )
  (byte) plex_sprite_msb#36 ← phi( loop::@19/(byte) plex_sprite_msb#36 loop::@29/(byte) plex_sprite_msb#42 )
  (byte) plex_free_next#37 ← phi( loop::@19/(byte) plex_free_next#37 loop::@29/(byte) plex_free_next#42 )
  (byte) plex_show_idx#37 ← phi( loop::@19/(byte) plex_show_idx#37 loop::@29/(byte) plex_show_idx#42 )
  (byte) plex_sprite_idx#37 ← phi( loop::@19/(byte) plex_sprite_idx#37 loop::@29/(byte) plex_sprite_idx#42 )
  (byte) loop::rasterY#1 ← phi( loop::@19/(byte) loop::rasterY#1 loop::@29/(byte) loop::rasterY#0 )
  (bool~) loop::$8 ← *((byte*) RASTER#0) < (byte) loop::rasterY#1
  if((bool~) loop::$8) goto loop::@19
  to:loop::@21
loop::@21: scope:[loop]  from loop::@19
  (byte) loop::sin_idx#9 ← phi( loop::@19/(byte) loop::sin_idx#10 )
  (byte*) PLEX_SCREEN_PTR#26 ← phi( loop::@19/(byte*) PLEX_SCREEN_PTR#29 )
  (byte) loop::ss#3 ← phi( loop::@19/(byte) loop::ss#4 )
  (byte) plex_sprite_msb#27 ← phi( loop::@19/(byte) plex_sprite_msb#36 )
  (byte) plex_free_next#27 ← phi( loop::@19/(byte) plex_free_next#37 )
  (byte) plex_show_idx#23 ← phi( loop::@19/(byte) plex_show_idx#37 )
  (byte) plex_sprite_idx#23 ← phi( loop::@19/(byte) plex_sprite_idx#37 )
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  call plexShowSprite 
  to:loop::@31
loop::@31: scope:[loop]  from loop::@21
  (byte*) PLEX_SCREEN_PTR#35 ← phi( loop::@21/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) loop::sin_idx#8 ← phi( loop::@21/(byte) loop::sin_idx#9 )
  (byte) loop::ss#2 ← phi( loop::@21/(byte) loop::ss#3 )
  (byte) plex_sprite_msb#20 ← phi( loop::@21/(byte) plex_sprite_msb#5 )
  (byte) plex_show_idx#19 ← phi( loop::@21/(byte) plex_show_idx#4 )
  (byte) plex_sprite_idx#19 ← phi( loop::@21/(byte) plex_sprite_idx#4 )
  (byte) plex_free_next#18 ← phi( loop::@21/(byte) plex_free_next#3 )
  (byte) plex_free_next#8 ← (byte) plex_free_next#18
  (byte) plex_sprite_idx#8 ← (byte) plex_sprite_idx#19
  (byte) plex_show_idx#8 ← (byte) plex_show_idx#19
  (byte) plex_sprite_msb#9 ← (byte) plex_sprite_msb#20
  (byte) loop::ss#1 ← (byte) loop::ss#2 + rangenext(0,loop::$6)
  (bool~) loop::$10 ← (byte) loop::ss#1 != rangelast(0,loop::$6)
  if((bool~) loop::$10) goto loop::@18
  to:loop::@25
loop::@25: scope:[loop]  from loop::@31
  (byte*) PLEX_SCREEN_PTR#44 ← phi( loop::@31/(byte*) PLEX_SCREEN_PTR#35 )
  (byte) loop::sin_idx#7 ← phi( loop::@31/(byte) loop::sin_idx#8 )
  (byte) plex_free_next#34 ← phi( loop::@31/(byte) plex_free_next#8 )
  (byte) plex_sprite_msb#34 ← phi( loop::@31/(byte) plex_sprite_msb#9 )
  (byte) plex_sprite_idx#35 ← phi( loop::@31/(byte) plex_sprite_idx#8 )
  (byte) plex_show_idx#35 ← phi( loop::@31/(byte) plex_show_idx#8 )
  *((byte*) BORDERCOL#0) ← (byte) BLACK#0
  to:loop::@1
loop::@return: scope:[loop]  from loop::@1
  (byte) plex_free_next#19 ← phi( loop::@1/(byte) plex_free_next#28 )
  (byte) plex_sprite_msb#21 ← phi( loop::@1/(byte) plex_sprite_msb#28 )
  (byte) plex_sprite_idx#20 ← phi( loop::@1/(byte) plex_sprite_idx#30 )
  (byte) plex_show_idx#20 ← phi( loop::@1/(byte) plex_show_idx#30 )
  (byte) plex_show_idx#9 ← (byte) plex_show_idx#20
  (byte) plex_sprite_idx#9 ← (byte) plex_sprite_idx#20
  (byte) plex_sprite_msb#10 ← (byte) plex_sprite_msb#21
  (byte) plex_free_next#9 ← (byte) plex_free_next#19
  return 
  to:@return
@15: scope:[]  from @12
  (byte) plex_free_next#29 ← phi( @12/(byte) plex_free_next#38 )
  (byte) plex_sprite_msb#29 ← phi( @12/(byte) plex_sprite_msb#37 )
  (byte) plex_sprite_idx#31 ← phi( @12/(byte) plex_sprite_idx#38 )
  (byte) plex_show_idx#31 ← phi( @12/(byte) plex_show_idx#38 )
  (byte*) PLEX_SCREEN_PTR#21 ← phi( @12/(byte*) PLEX_SCREEN_PTR#25 )
  call main 
  to:@16
@16: scope:[]  from @15
  (byte) plex_free_next#20 ← phi( @15/(byte) plex_free_next#6 )
  (byte) plex_sprite_msb#22 ← phi( @15/(byte) plex_sprite_msb#7 )
  (byte) plex_sprite_idx#21 ← phi( @15/(byte) plex_sprite_idx#6 )
  (byte) plex_show_idx#21 ← phi( @15/(byte) plex_show_idx#6 )
  (byte*) PLEX_SCREEN_PTR#14 ← phi( @15/(byte*) PLEX_SCREEN_PTR#4 )
  (byte*) PLEX_SCREEN_PTR#7 ← (byte*) PLEX_SCREEN_PTR#14
  (byte) plex_show_idx#10 ← (byte) plex_show_idx#21
  (byte) plex_sprite_idx#10 ← (byte) plex_sprite_idx#21
  (byte) plex_sprite_msb#11 ← (byte) plex_sprite_msb#22
  (byte) plex_free_next#10 ← (byte) plex_free_next#20
  to:@end
@end: scope:[]  from @16

SYMBOL TABLE SSA
(number~) $0
(label) @12
(label) @15
(label) @16
(label) @4
(label) @9
(label) @begin
(label) @end
(byte) BLACK
(byte) BLACK#0
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte*) D011
(byte*) D011#0
(byte) GREEN
(byte) GREEN#0
(byte) PLEX_COUNT
(byte) PLEX_COUNT#0
(byte[8]) PLEX_FREE_YPOS
(byte[8]) PLEX_FREE_YPOS#0
(byte[PLEX_COUNT#0]) PLEX_PTR
(byte[PLEX_COUNT#0]) PLEX_PTR#0
(byte*) PLEX_SCREEN_PTR
(byte*) PLEX_SCREEN_PTR#0
(byte*) PLEX_SCREEN_PTR#1
(byte*) PLEX_SCREEN_PTR#10
(byte*) PLEX_SCREEN_PTR#11
(byte*) PLEX_SCREEN_PTR#12
(byte*) PLEX_SCREEN_PTR#13
(byte*) PLEX_SCREEN_PTR#14
(byte*) PLEX_SCREEN_PTR#15
(byte*) PLEX_SCREEN_PTR#16
(byte*) PLEX_SCREEN_PTR#17
(byte*) PLEX_SCREEN_PTR#18
(byte*) PLEX_SCREEN_PTR#19
(byte*) PLEX_SCREEN_PTR#2
(byte*) PLEX_SCREEN_PTR#20
(byte*) PLEX_SCREEN_PTR#21
(byte*) PLEX_SCREEN_PTR#22
(byte*) PLEX_SCREEN_PTR#23
(byte*) PLEX_SCREEN_PTR#24
(byte*) PLEX_SCREEN_PTR#25
(byte*) PLEX_SCREEN_PTR#26
(byte*) PLEX_SCREEN_PTR#27
(byte*) PLEX_SCREEN_PTR#28
(byte*) PLEX_SCREEN_PTR#29
(byte*) PLEX_SCREEN_PTR#3
(byte*) PLEX_SCREEN_PTR#30
(byte*) PLEX_SCREEN_PTR#31
(byte*) PLEX_SCREEN_PTR#32
(byte*) PLEX_SCREEN_PTR#33
(byte*) PLEX_SCREEN_PTR#34
(byte*) PLEX_SCREEN_PTR#35
(byte*) PLEX_SCREEN_PTR#36
(byte*) PLEX_SCREEN_PTR#37
(byte*) PLEX_SCREEN_PTR#38
(byte*) PLEX_SCREEN_PTR#39
(byte*) PLEX_SCREEN_PTR#4
(byte*) PLEX_SCREEN_PTR#40
(byte*) PLEX_SCREEN_PTR#41
(byte*) PLEX_SCREEN_PTR#42
(byte*) PLEX_SCREEN_PTR#43
(byte*) PLEX_SCREEN_PTR#44
(byte*) PLEX_SCREEN_PTR#5
(byte*) PLEX_SCREEN_PTR#6
(byte*) PLEX_SCREEN_PTR#7
(byte*) PLEX_SCREEN_PTR#8
(byte*) PLEX_SCREEN_PTR#9
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0
(word[PLEX_COUNT#0]) PLEX_XPOS
(word[PLEX_COUNT#0]) PLEX_XPOS#0
(byte[PLEX_COUNT#0]) PLEX_YPOS
(byte[PLEX_COUNT#0]) PLEX_YPOS#0
(byte*) RASTER
(byte*) RASTER#0
(byte*) SCREEN
(byte*) SCREEN#0
(const byte) SIZEOF_WORD = (byte) 2
(byte*) SPRITE
(byte*) SPRITE#0
(byte*) SPRITES_COLS
(byte*) SPRITES_COLS#0
(byte*) SPRITES_ENABLE
(byte*) SPRITES_ENABLE#0
(byte*) SPRITES_XMSB
(byte*) SPRITES_XMSB#0
(byte*) SPRITES_XPOS
(byte*) SPRITES_XPOS#0
(byte*) SPRITES_YPOS
(byte*) SPRITES_YPOS#0
(byte) VIC_DEN
(byte) VIC_DEN#0
(byte) VIC_RSEL
(byte) VIC_RSEL#0
(byte) VIC_RST8
(byte) VIC_RST8#0
(byte*) YSIN
(byte*) YSIN#0
(void()) init()
(byte~) init::$0
(number~) init::$1
(number~) init::$3
(byte*~) init::$4
(byte~) init::$5
(bool~) init::$6
(bool~) init::$7
(byte~) init::$8
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@5
(label) init::@return
(byte) init::ss
(byte) init::ss#0
(byte) init::ss#1
(byte) init::ss#2
(byte) init::sx
(byte) init::sx#0
(byte) init::sx#1
(byte) init::sx#2
(word) init::xp
(word) init::xp#0
(word) init::xp#1
(word) init::xp#2
(void()) loop()
(bool~) loop::$0
(number~) loop::$1
(bool~) loop::$10
(bool~) loop::$2
(byte~) loop::$4
(bool~) loop::$5
(number~) loop::$6
(byte~) loop::$7
(bool~) loop::$8
(label) loop::@1
(label) loop::@10
(label) loop::@11
(label) loop::@12
(label) loop::@14
(label) loop::@18
(label) loop::@19
(label) loop::@21
(label) loop::@25
(label) loop::@29
(label) loop::@30
(label) loop::@31
(label) loop::@4
(label) loop::@6
(label) loop::@return
(label) loop::plexFreeNextYpos1
(label) loop::plexFreeNextYpos1_@return
(byte) loop::plexFreeNextYpos1_return
(byte) loop::plexFreeNextYpos1_return#0
(byte) loop::plexFreeNextYpos1_return#1
(byte) loop::plexFreeNextYpos1_return#2
(byte) loop::plexFreeNextYpos1_return#3
(byte) loop::rasterY
(byte) loop::rasterY#0
(byte) loop::rasterY#1
(byte) loop::sin_idx
(byte) loop::sin_idx#0
(byte) loop::sin_idx#1
(byte) loop::sin_idx#10
(byte) loop::sin_idx#11
(byte) loop::sin_idx#12
(byte) loop::sin_idx#13
(byte) loop::sin_idx#14
(byte) loop::sin_idx#15
(byte) loop::sin_idx#16
(byte) loop::sin_idx#17
(byte) loop::sin_idx#2
(byte) loop::sin_idx#3
(byte) loop::sin_idx#4
(byte) loop::sin_idx#5
(byte) loop::sin_idx#6
(byte) loop::sin_idx#7
(byte) loop::sin_idx#8
(byte) loop::sin_idx#9
(byte) loop::ss
(byte) loop::ss#0
(byte) loop::ss#1
(byte) loop::ss#2
(byte) loop::ss#3
(byte) loop::ss#4
(byte) loop::ss#5
(byte) loop::ss#6
(byte) loop::ss#7
(byte) loop::ss#8
(byte) loop::sy
(byte) loop::sy#0
(byte) loop::sy#1
(byte) loop::sy#2
(byte) loop::y_idx
(byte) loop::y_idx#0
(byte) loop::y_idx#1
(byte) loop::y_idx#2
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(number~) plexInit::$1
(bool~) plexInit::$2
(label) plexInit::@1
(label) plexInit::@3
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#0
(byte) plexInit::i#1
(byte) plexInit::i#2
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*~) plexInit::plexSetScreen1_$0#0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::plexSetScreen1_screen#0
(byte*) plexInit::plexSetScreen1_screen#1
(byte*) plexInit::screen
(byte*) plexInit::screen#0
(byte*) plexInit::screen#1
(void()) plexShowSprite()
(byte~) plexShowSprite::$0
(byte~) plexShowSprite::$10
(byte~) plexShowSprite::$11
(byte~) plexShowSprite::$2
(byte~) plexShowSprite::$3
(bool~) plexShowSprite::$4
(number~) plexShowSprite::$5
(number~) plexShowSprite::$6
(bool~) plexShowSprite::$7
(bool~) plexShowSprite::$8
(number~) plexShowSprite::$9
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@4
(label) plexShowSprite::@6
(label) plexShowSprite::@7
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(number~) plexShowSprite::plexFreeAdd1_$0
(number~) plexShowSprite::plexFreeAdd1_$0#0
(number~) plexShowSprite::plexFreeAdd1_$1
(number~) plexShowSprite::plexFreeAdd1_$1#0
(number~) plexShowSprite::plexFreeAdd1_$2
(number~) plexShowSprite::plexFreeAdd1_$2#0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0
(byte) plexShowSprite::plexFreeAdd1_ypos#1
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0
(byte) plexShowSprite::plex_sprite_idx2#1
(byte) plexShowSprite::plex_sprite_idx2#2
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0
(byte) plexShowSprite::ypos
(byte) plexShowSprite::ypos#0
(void()) plexSort()
(number~) plexSort::$1
(number~) plexSort::$2
(bool~) plexSort::$3
(bool~) plexSort::$4
(number~) plexSort::$5
(bool~) plexSort::$6
(bool~) plexSort::$7
(bool~) plexSort::$8
(bool~) plexSort::$9
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#0
(byte) plexSort::m#1
(byte) plexSort::m#2
(byte) plexSort::m#3
(byte) plexSort::m#4
(byte) plexSort::m#5
(byte) plexSort::m#6
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0
(byte) plexSort::nxt_idx#1
(byte) plexSort::nxt_idx#2
(byte) plexSort::nxt_idx#3
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0
(byte) plexSort::nxt_y#1
(byte) plexSort::nxt_y#2
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(bool~) plexSort::plexFreePrepare1_$0#0
(label) plexSort::plexFreePrepare1_@1
(label) plexSort::plexFreePrepare1_@2
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#0
(byte) plexSort::plexFreePrepare1_s#1
(byte) plexSort::plexFreePrepare1_s#2
(byte) plexSort::s
(byte) plexSort::s#0
(byte) plexSort::s#1
(byte) plexSort::s#2
(byte) plexSort::s#3
(byte) plexSort::s#4
(byte) plex_free_next
(byte) plex_free_next#0
(byte) plex_free_next#1
(byte) plex_free_next#10
(byte) plex_free_next#11
(byte) plex_free_next#12
(byte) plex_free_next#13
(byte) plex_free_next#14
(byte) plex_free_next#15
(byte) plex_free_next#16
(byte) plex_free_next#17
(byte) plex_free_next#18
(byte) plex_free_next#19
(byte) plex_free_next#2
(byte) plex_free_next#20
(byte) plex_free_next#21
(byte) plex_free_next#22
(byte) plex_free_next#23
(byte) plex_free_next#24
(byte) plex_free_next#25
(byte) plex_free_next#26
(byte) plex_free_next#27
(byte) plex_free_next#28
(byte) plex_free_next#29
(byte) plex_free_next#3
(byte) plex_free_next#30
(byte) plex_free_next#31
(byte) plex_free_next#32
(byte) plex_free_next#33
(byte) plex_free_next#34
(byte) plex_free_next#35
(byte) plex_free_next#36
(byte) plex_free_next#37
(byte) plex_free_next#38
(byte) plex_free_next#39
(byte) plex_free_next#4
(byte) plex_free_next#40
(byte) plex_free_next#41
(byte) plex_free_next#42
(byte) plex_free_next#43
(byte) plex_free_next#44
(byte) plex_free_next#5
(byte) plex_free_next#6
(byte) plex_free_next#7
(byte) plex_free_next#8
(byte) plex_free_next#9
(byte) plex_show_idx
(byte) plex_show_idx#0
(byte) plex_show_idx#1
(byte) plex_show_idx#10
(byte) plex_show_idx#11
(byte) plex_show_idx#12
(byte) plex_show_idx#13
(byte) plex_show_idx#14
(byte) plex_show_idx#15
(byte) plex_show_idx#16
(byte) plex_show_idx#17
(byte) plex_show_idx#18
(byte) plex_show_idx#19
(byte) plex_show_idx#2
(byte) plex_show_idx#20
(byte) plex_show_idx#21
(byte) plex_show_idx#22
(byte) plex_show_idx#23
(byte) plex_show_idx#24
(byte) plex_show_idx#25
(byte) plex_show_idx#26
(byte) plex_show_idx#27
(byte) plex_show_idx#28
(byte) plex_show_idx#29
(byte) plex_show_idx#3
(byte) plex_show_idx#30
(byte) plex_show_idx#31
(byte) plex_show_idx#32
(byte) plex_show_idx#33
(byte) plex_show_idx#34
(byte) plex_show_idx#35
(byte) plex_show_idx#36
(byte) plex_show_idx#37
(byte) plex_show_idx#38
(byte) plex_show_idx#39
(byte) plex_show_idx#4
(byte) plex_show_idx#40
(byte) plex_show_idx#41
(byte) plex_show_idx#42
(byte) plex_show_idx#43
(byte) plex_show_idx#44
(byte) plex_show_idx#45
(byte) plex_show_idx#46
(byte) plex_show_idx#47
(byte) plex_show_idx#48
(byte) plex_show_idx#5
(byte) plex_show_idx#6
(byte) plex_show_idx#7
(byte) plex_show_idx#8
(byte) plex_show_idx#9
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0
(byte) plex_sprite_idx#1
(byte) plex_sprite_idx#10
(byte) plex_sprite_idx#11
(byte) plex_sprite_idx#12
(byte) plex_sprite_idx#13
(byte) plex_sprite_idx#14
(byte) plex_sprite_idx#15
(byte) plex_sprite_idx#16
(byte) plex_sprite_idx#17
(byte) plex_sprite_idx#18
(byte) plex_sprite_idx#19
(byte) plex_sprite_idx#2
(byte) plex_sprite_idx#20
(byte) plex_sprite_idx#21
(byte) plex_sprite_idx#22
(byte) plex_sprite_idx#23
(byte) plex_sprite_idx#24
(byte) plex_sprite_idx#25
(byte) plex_sprite_idx#26
(byte) plex_sprite_idx#27
(byte) plex_sprite_idx#28
(byte) plex_sprite_idx#29
(byte) plex_sprite_idx#3
(byte) plex_sprite_idx#30
(byte) plex_sprite_idx#31
(byte) plex_sprite_idx#32
(byte) plex_sprite_idx#33
(byte) plex_sprite_idx#34
(byte) plex_sprite_idx#35
(byte) plex_sprite_idx#36
(byte) plex_sprite_idx#37
(byte) plex_sprite_idx#38
(byte) plex_sprite_idx#39
(byte) plex_sprite_idx#4
(byte) plex_sprite_idx#40
(byte) plex_sprite_idx#41
(byte) plex_sprite_idx#42
(byte) plex_sprite_idx#43
(byte) plex_sprite_idx#44
(byte) plex_sprite_idx#45
(byte) plex_sprite_idx#46
(byte) plex_sprite_idx#47
(byte) plex_sprite_idx#48
(byte) plex_sprite_idx#5
(byte) plex_sprite_idx#6
(byte) plex_sprite_idx#7
(byte) plex_sprite_idx#8
(byte) plex_sprite_idx#9
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0
(byte) plex_sprite_msb#1
(byte) plex_sprite_msb#10
(byte) plex_sprite_msb#11
(byte) plex_sprite_msb#12
(byte) plex_sprite_msb#13
(byte) plex_sprite_msb#14
(byte) plex_sprite_msb#15
(byte) plex_sprite_msb#16
(byte) plex_sprite_msb#17
(byte) plex_sprite_msb#18
(byte) plex_sprite_msb#19
(byte) plex_sprite_msb#2
(byte) plex_sprite_msb#20
(byte) plex_sprite_msb#21
(byte) plex_sprite_msb#22
(byte) plex_sprite_msb#23
(byte) plex_sprite_msb#24
(byte) plex_sprite_msb#25
(byte) plex_sprite_msb#26
(byte) plex_sprite_msb#27
(byte) plex_sprite_msb#28
(byte) plex_sprite_msb#29
(byte) plex_sprite_msb#3
(byte) plex_sprite_msb#30
(byte) plex_sprite_msb#31
(byte) plex_sprite_msb#32
(byte) plex_sprite_msb#33
(byte) plex_sprite_msb#34
(byte) plex_sprite_msb#35
(byte) plex_sprite_msb#36
(byte) plex_sprite_msb#37
(byte) plex_sprite_msb#38
(byte) plex_sprite_msb#39
(byte) plex_sprite_msb#4
(byte) plex_sprite_msb#40
(byte) plex_sprite_msb#41
(byte) plex_sprite_msb#42
(byte) plex_sprite_msb#43
(byte) plex_sprite_msb#44
(byte) plex_sprite_msb#45
(byte) plex_sprite_msb#46
(byte) plex_sprite_msb#47
(byte) plex_sprite_msb#48
(byte) plex_sprite_msb#5
(byte) plex_sprite_msb#6
(byte) plex_sprite_msb#7
(byte) plex_sprite_msb#8
(byte) plex_sprite_msb#9

Adding number conversion cast (unumber) $80 in (byte) VIC_RST8#0 ← (number) $80
Adding number conversion cast (unumber) $10 in (byte) VIC_DEN#0 ← (number) $10
Adding number conversion cast (unumber) 8 in (byte) VIC_RSEL#0 ← (number) 8
Adding number conversion cast (unumber) 0 in (byte) BLACK#0 ← (number) 0
Adding number conversion cast (unumber) 5 in (byte) GREEN#0 ← (number) 5
Adding number conversion cast (unumber) $20 in (byte) PLEX_COUNT#0 ← (number) $20
Adding number conversion cast (unumber) 0 in (byte) plex_show_idx#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_sprite_idx#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#0 ← (number) 1
Adding number conversion cast (unumber) $3f8 in (byte*~) plexInit::plexSetScreen1_$0#0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
Adding number conversion cast (unumber) 1 in (number~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) plexInit::$1 in (number~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Adding number conversion cast (unumber) 2 in (number~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (number) 2
Adding number conversion cast (unumber) plexSort::$1 in (number~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (unumber)(number) 2
Adding number conversion cast (unumber) 1 in (number~) plexSort::$2 ← (byte) plexSort::m#2 + (number) 1
Adding number conversion cast (unumber) plexSort::$2 in (number~) plexSort::$2 ← (byte) plexSort::m#2 + (unumber)(number) 1
Adding number conversion cast (unumber) 1 in (number~) plexSort::$5 ← (byte) plexSort::s#3 + (number) 1
Adding number conversion cast (unumber) plexSort::$5 in (number~) plexSort::$5 ← (byte) plexSort::s#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $ff in (bool~) plexSort::$6 ← (byte) plexSort::s#1 != (number) $ff
Adding number conversion cast (unumber) 0 in (byte) plex_show_idx#1 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_sprite_idx#1 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#1 ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_free_next#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 << (number) 1
Adding number conversion cast (unumber) $15 in (number~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$0#0 in (number~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (unumber)(number) $15
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#12 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$1#0 in (number~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#12 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::plexFreeAdd1_$2#0 ← (unumber~) plexShowSprite::plexFreeAdd1_$1#0 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$2#0 in (number~) plexShowSprite::plexFreeAdd1_$2#0 ← (unumber~) plexShowSprite::plexFreeAdd1_$1#0 & (unumber)(number) 7
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
Adding number conversion cast (unumber) $ff in (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#14
Adding number conversion cast (unumber) plexShowSprite::$9 in (number~) plexShowSprite::$9 ← (unumber)(number) $ff ^ (byte) plex_sprite_msb#14
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::$5 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::$6 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (unumber)(number) 7
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#15 << (number) 1
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#4 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) plex_free_next#4 ← (number) 0
Adding number conversion cast (unumber) 3 in (number~) init::$1 ← (byte~) init::$0 | (number) 3
Adding number conversion cast (unumber) init::$1 in (number~) init::$1 ← (byte~) init::$0 | (unumber)(number) 3
Adding number conversion cast (unumber) $20 in (word) init::xp#0 ← (number) $20
Adding number conversion cast (unumber) 1 in (number~) init::$3 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) init::$3 in (number~) init::$3 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Adding number conversion cast (unumber) $40 in (byte*~) init::$4 ← (byte*) SPRITE#0 / (number) $40
Adding number conversion cast (unumber) 9 in (word) init::xp#1 ← (word) init::xp#2 + (number) 9
Adding number conversion cast (unumber) $ff in *((byte*) SPRITES_ENABLE#0) ← (number) $ff
Adding number conversion cast (unumber) 0 in (byte) loop::sin_idx#0 ← (number) 0
Adding number conversion cast (unumber) $ff in (bool~) loop::$0 ← *((byte*) RASTER#0) != (number) $ff
Adding number conversion cast (unumber) 1 in (number~) loop::$1 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) loop::$1 in (number~) loop::$1 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Adding number conversion cast (unumber) 8 in (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (number) 8
Adding number conversion cast (unumber) 1 in (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#3 + (number) 1
Adding number conversion cast (unumber) 0 in (bool~) loop::$5 ← (byte~) loop::$4 != (number) 0
Adding number conversion cast (unumber) 1 in (number~) loop::$6 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) loop::$6 in (number~) loop::$6 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) SPRITES_XPOS#0 ← (byte*)(number) $d000
Inlining cast (byte*) SPRITES_YPOS#0 ← (byte*)(number) $d001
Inlining cast (byte*) SPRITES_XMSB#0 ← (byte*)(number) $d010
Inlining cast (byte*) RASTER#0 ← (byte*)(number) $d012
Inlining cast (byte*) SPRITES_ENABLE#0 ← (byte*)(number) $d015
Inlining cast (byte*) BORDERCOL#0 ← (byte*)(number) $d020
Inlining cast (byte*) SPRITES_COLS#0 ← (byte*)(number) $d027
Inlining cast (byte*) D011#0 ← (byte*)(number) $d011
Inlining cast (byte) VIC_RST8#0 ← (unumber)(number) $80
Inlining cast (byte) VIC_DEN#0 ← (unumber)(number) $10
Inlining cast (byte) VIC_RSEL#0 ← (unumber)(number) 8
Inlining cast (byte) BLACK#0 ← (unumber)(number) 0
Inlining cast (byte) GREEN#0 ← (unumber)(number) 5
Inlining cast (byte) PLEX_COUNT#0 ← (unumber)(number) $20
Inlining cast (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(number~) $0
Inlining cast (byte) plex_show_idx#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_idx#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#0 ← (unumber)(number) 1
Inlining cast (byte) plex_show_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#1 ← (unumber)(number) 1
Inlining cast *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (unumber)(number) 0
Inlining cast (byte) plex_free_next#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#4 ← (unumber)(number) 1
Inlining cast (byte) plex_free_next#4 ← (unumber)(number) 0
Inlining cast (byte*) SCREEN#0 ← (byte*)(number) $400
Inlining cast (byte*) SPRITE#0 ← (byte*)(number) $2000
Inlining cast (byte*) YSIN#0 ← (byte*)(number) $2100
Inlining cast (word) init::xp#0 ← (unumber)(number) $20
Inlining cast (byte~) init::$5 ← (byte)(byte*~) init::$4
Inlining cast *((byte*) SPRITES_ENABLE#0) ← (unumber)(number) $ff
Inlining cast (byte) loop::sin_idx#0 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 53249
Simplifying constant pointer cast (byte*) 53264
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (byte*) 53265
Simplifying constant integer cast $80
Simplifying constant integer cast $10
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Simplifying constant integer cast 5
Simplifying constant integer cast $20
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast $3f8
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast $15
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 8192
Simplifying constant pointer cast (byte*) 8448
Simplifying constant integer cast 3
Simplifying constant integer cast $20
Simplifying constant integer cast 1
Simplifying constant integer cast $40
Simplifying constant integer cast 9
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $3f8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (byte) 1
Inferred type updated to byte in (unumber~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (byte) 2
Inferred type updated to byte in (unumber~) plexSort::$2 ← (byte) plexSort::m#2 + (byte) 1
Inferred type updated to byte in (unumber~) plexSort::$5 ← (byte) plexSort::s#3 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (byte) $15
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#12 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7
Inferred type updated to byte in (unumber~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#14
Inferred type updated to byte in (unumber~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7
Inferred type updated to byte in (unumber~) init::$1 ← (byte~) init::$0 | (byte) 3
Inferred type updated to byte in (unumber~) init::$3 ← (byte) PLEX_COUNT#0 - (byte) 1
Inferred type updated to byte in (unumber~) loop::$1 ← (byte) PLEX_COUNT#0 - (byte) 1
Inferred type updated to byte in (unumber~) loop::$6 ← (byte) PLEX_COUNT#0 - (byte) 1
Inversing boolean not [46] (bool~) plexSort::$4 ← (byte) plexSort::nxt_y#0 >= *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2)) from [45] (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))
Inversing boolean not [117] (bool~) plexShowSprite::$8 ← (byte) plex_sprite_msb#3 != (byte) 0 from [116] (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte*) plexInit::plexSetScreen1_screen#0 = (byte*) plexInit::screen#1 (byte*) plexInit::plexSetScreen1_screen#1 
Alias (byte*) PLEX_SCREEN_PTR#1 = (byte*~) plexInit::plexSetScreen1_$0#0 (byte*) PLEX_SCREEN_PTR#22 
Alias (byte*) PLEX_SCREEN_PTR#15 = (byte*) PLEX_SCREEN_PTR#8 (byte*) PLEX_SCREEN_PTR#2 
Alias (byte) plexSort::m#2 = (byte) plexSort::m#4 (byte) plexSort::s#0 
Alias (byte) plexSort::nxt_y#0 = (byte) plexSort::nxt_y#2 
Alias (byte) plexSort::nxt_idx#0 = (byte) plexSort::nxt_idx#3 
Alias (byte) plexSort::s#1 = (byte) plexSort::s#4 
Alias (byte) plexSort::nxt_idx#1 = (byte) plexSort::nxt_idx#2 
Alias (byte) plexSort::m#5 = (byte) plexSort::m#6 
Alias (byte) plex_show_idx#1 = (byte) plex_show_idx#39 
Alias (byte) plex_sprite_idx#1 = (byte) plex_sprite_idx#39 
Alias (byte) plex_sprite_msb#1 = (byte) plex_sprite_msb#38 
Alias (byte) plex_show_idx#11 = (byte) plex_show_idx#22 (byte) plex_show_idx#32 (byte) plex_show_idx#2 
Alias (byte) plex_sprite_idx#11 = (byte) plex_sprite_idx#22 (byte) plex_sprite_idx#32 (byte) plex_sprite_idx#2 
Alias (byte) plex_sprite_msb#12 = (byte) plex_sprite_msb#23 (byte) plex_sprite_msb#30 (byte) plex_sprite_msb#2 
Alias (byte) plex_free_next#0 = (byte) plex_free_next#11 (byte) plex_free_next#1 
Alias (byte) plexShowSprite::plex_sprite_idx2#0 = (byte~) plexShowSprite::$0 (byte) plexShowSprite::plex_sprite_idx2#2 (byte) plexShowSprite::plex_sprite_idx2#1 
Alias (byte) plexShowSprite::plexFreeAdd1_ypos#0 = (byte) plexShowSprite::ypos#0 (byte) plexShowSprite::plexFreeAdd1_ypos#1 
Alias (byte) plex_free_next#12 = (byte) plex_free_next#21 
Alias (byte) plex_show_idx#12 = (byte) plex_show_idx#24 (byte) plex_show_idx#13 (byte) plex_show_idx#25 (byte) plex_show_idx#26 
Alias (byte*) PLEX_SCREEN_PTR#16 = (byte*) PLEX_SCREEN_PTR#23 (byte*) PLEX_SCREEN_PTR#9 
Alias (byte) plex_sprite_idx#12 = (byte) plex_sprite_idx#24 (byte) plex_sprite_idx#13 (byte) plex_sprite_idx#25 (byte) plex_sprite_idx#26 
Alias (byte) plex_sprite_msb#13 = (byte) plex_sprite_msb#31 (byte) plex_sprite_msb#39 (byte) plex_sprite_msb#24 (byte) plex_sprite_msb#14 
Alias (byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 (byte) plex_free_next#39 (byte) plex_free_next#30 (byte) plex_free_next#31 
Alias (byte) plex_sprite_idx#27 = (byte) plex_sprite_idx#3 (byte~) plexShowSprite::$6 
Alias (byte) plex_free_next#22 = (byte) plex_free_next#23 
Alias (byte) plex_show_idx#27 = (byte) plex_show_idx#3 
Alias (byte) plex_free_next#13 = (byte) plex_free_next#3 
Alias (byte) plex_sprite_idx#15 = (byte) plex_sprite_idx#4 
Alias (byte) plex_show_idx#15 = (byte) plex_show_idx#4 
Alias (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#5 
Alias (byte*) PLEX_SCREEN_PTR#0 = (byte*) PLEX_SCREEN_PTR#27 (byte*) PLEX_SCREEN_PTR#25 (byte*) PLEX_SCREEN_PTR#21 
Alias (byte) plex_show_idx#0 = (byte) plex_show_idx#40 (byte) plex_show_idx#38 (byte) plex_show_idx#31 
Alias (byte) plex_sprite_idx#0 = (byte) plex_sprite_idx#40 (byte) plex_sprite_idx#38 (byte) plex_sprite_idx#31 
Alias (byte) plex_sprite_msb#0 = (byte) plex_sprite_msb#40 (byte) plex_sprite_msb#37 (byte) plex_sprite_msb#29 
Alias (byte) plex_free_next#29 = (byte) plex_free_next#38 (byte) plex_free_next#4 
Alias (byte) plex_show_idx#28 = (byte) plex_show_idx#33 
Alias (byte) plex_sprite_idx#28 = (byte) plex_sprite_idx#33 
Alias (byte) plex_sprite_msb#25 = (byte) plex_sprite_msb#32 
Alias (byte) plex_free_next#24 = (byte) plex_free_next#32 
Alias (byte*) PLEX_SCREEN_PTR#10 = (byte*) PLEX_SCREEN_PTR#3 (byte*) PLEX_SCREEN_PTR#18 (byte*) PLEX_SCREEN_PTR#11 (byte*) PLEX_SCREEN_PTR#4 
Alias (byte) plex_show_idx#16 = (byte) plex_show_idx#5 (byte) plex_show_idx#17 (byte) plex_show_idx#6 
Alias (byte) plex_sprite_idx#16 = (byte) plex_sprite_idx#5 (byte) plex_sprite_idx#17 (byte) plex_sprite_idx#6 
Alias (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#6 (byte) plex_sprite_msb#18 (byte) plex_sprite_msb#7 
Alias (byte) plex_free_next#14 = (byte) plex_free_next#5 (byte) plex_free_next#15 (byte) plex_free_next#6 
Alias (byte*) PLEX_SCREEN_PTR#12 = (byte*) PLEX_SCREEN_PTR#5 
Alias (byte*) PLEX_SCREEN_PTR#24 = (byte*) PLEX_SCREEN_PTR#28 
Alias (byte*) PLEX_SCREEN_PTR#13 = (byte*) PLEX_SCREEN_PTR#20 (byte*) PLEX_SCREEN_PTR#6 
Alias (byte) loop::sin_idx#2 = (byte) loop::sin_idx#4 (byte) loop::y_idx#0 
Alias (byte) plex_show_idx#41 = (byte) plex_show_idx#43 
Alias (byte) plex_sprite_idx#41 = (byte) plex_sprite_idx#43 
Alias (byte) plex_sprite_msb#41 = (byte) plex_sprite_msb#43 
Alias (byte) plex_free_next#40 = (byte) plex_free_next#43 
Alias (byte*) PLEX_SCREEN_PTR#40 = (byte*) PLEX_SCREEN_PTR#41 
Alias (byte) loop::sin_idx#3 = (byte) loop::sin_idx#5 
Alias (byte) plex_show_idx#29 = (byte) plex_show_idx#36 
Alias (byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#36 
Alias (byte) plex_sprite_msb#26 = (byte) plex_sprite_msb#35 
Alias (byte) plex_free_next#25 = (byte) plex_free_next#35 
Alias (byte*) PLEX_SCREEN_PTR#37 = (byte*) PLEX_SCREEN_PTR#38 (byte*) PLEX_SCREEN_PTR#39 
Alias (byte) loop::sin_idx#1 = (byte) loop::sin_idx#17 
Alias (byte) plex_show_idx#18 = (byte) plex_show_idx#7 
Alias (byte) plex_sprite_idx#18 = (byte) plex_sprite_idx#7 
Alias (byte) plex_sprite_msb#19 = (byte) plex_sprite_msb#8 
Alias (byte) plex_free_next#16 = (byte) plex_free_next#7 
Alias (byte) plex_free_next#36 = (byte) plex_free_next#41 
Alias (byte) plex_sprite_idx#47 = (byte) plex_sprite_idx#48 
Alias (byte) plex_show_idx#47 = (byte) plex_show_idx#48 
Alias (byte) plex_sprite_msb#47 = (byte) plex_sprite_msb#48 
Alias (byte*) PLEX_SCREEN_PTR#34 = (byte*) PLEX_SCREEN_PTR#36 
Alias (byte) loop::sin_idx#15 = (byte) loop::sin_idx#16 
Alias (byte) plex_free_next#17 = (byte) plex_free_next#26 (byte) plex_free_next#44 (byte) plex_free_next#42 
Alias (byte) plex_sprite_idx#42 = (byte) plex_sprite_idx#45 (byte) plex_sprite_idx#46 (byte) plex_sprite_idx#44 
Alias (byte) plex_show_idx#42 = (byte) plex_show_idx#45 (byte) plex_show_idx#46 (byte) plex_show_idx#44 
Alias (byte) plex_sprite_msb#42 = (byte) plex_sprite_msb#45 (byte) plex_sprite_msb#46 (byte) plex_sprite_msb#44 
Alias (byte) loop::ss#5 = (byte) loop::ss#7 (byte) loop::ss#8 (byte) loop::ss#6 
Alias (byte*) PLEX_SCREEN_PTR#30 = (byte*) PLEX_SCREEN_PTR#32 (byte*) PLEX_SCREEN_PTR#33 (byte*) PLEX_SCREEN_PTR#31 
Alias (byte) loop::sin_idx#11 = (byte) loop::sin_idx#13 (byte) loop::sin_idx#14 (byte) loop::sin_idx#12 
Alias (byte) loop::plexFreeNextYpos1_return#0 = (byte) loop::plexFreeNextYpos1_return#2 (byte) loop::plexFreeNextYpos1_return#1 (byte) loop::plexFreeNextYpos1_return#3 (byte~) loop::$7 (byte) loop::rasterY#0 
Alias (byte) plex_sprite_idx#23 = (byte) plex_sprite_idx#37 
Alias (byte) plex_show_idx#23 = (byte) plex_show_idx#37 
Alias (byte) plex_free_next#27 = (byte) plex_free_next#37 
Alias (byte) plex_sprite_msb#27 = (byte) plex_sprite_msb#36 
Alias (byte) loop::ss#2 = (byte) loop::ss#3 (byte) loop::ss#4 
Alias (byte*) PLEX_SCREEN_PTR#26 = (byte*) PLEX_SCREEN_PTR#29 (byte*) PLEX_SCREEN_PTR#35 (byte*) PLEX_SCREEN_PTR#44 
Alias (byte) loop::sin_idx#10 = (byte) loop::sin_idx#9 (byte) loop::sin_idx#8 (byte) loop::sin_idx#7 
Alias (byte) plex_free_next#18 = (byte) plex_free_next#8 (byte) plex_free_next#34 
Alias (byte) plex_sprite_idx#19 = (byte) plex_sprite_idx#8 (byte) plex_sprite_idx#35 
Alias (byte) plex_show_idx#19 = (byte) plex_show_idx#8 (byte) plex_show_idx#35 
Alias (byte) plex_sprite_msb#20 = (byte) plex_sprite_msb#9 (byte) plex_sprite_msb#34 
Alias (byte) plex_show_idx#20 = (byte) plex_show_idx#30 (byte) plex_show_idx#9 
Alias (byte) plex_sprite_idx#20 = (byte) plex_sprite_idx#30 (byte) plex_sprite_idx#9 
Alias (byte) plex_sprite_msb#10 = (byte) plex_sprite_msb#21 (byte) plex_sprite_msb#28 
Alias (byte) plex_free_next#19 = (byte) plex_free_next#28 (byte) plex_free_next#9 
Alias (byte*) PLEX_SCREEN_PTR#14 = (byte*) PLEX_SCREEN_PTR#7 
Alias (byte) plex_show_idx#10 = (byte) plex_show_idx#21 
Alias (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#21 
Alias (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#22 
Alias (byte) plex_free_next#10 = (byte) plex_free_next#20 
Successful SSA optimization Pass2AliasElimination
Alias (byte) plex_sprite_idx#12 = (byte) plex_sprite_idx#14 
Alias (byte) plex_show_idx#12 = (byte) plex_show_idx#14 
Alias (byte) plex_sprite_msb#13 = (byte) plex_sprite_msb#15 
Alias (byte) plex_free_next#13 = (byte) plex_free_next#22 (byte) plex_free_next#2 
Alias (byte) plex_sprite_idx#15 = (byte) plex_sprite_idx#27 
Alias (byte) plex_show_idx#15 = (byte) plex_show_idx#27 
Successful SSA optimization Pass2AliasElimination
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#15
Self Phi Eliminated (byte) plexSort::nxt_y#1
Self Phi Eliminated (byte) plexSort::nxt_idx#1
Self Phi Eliminated (byte) plexSort::m#5
Self Phi Eliminated (byte) plex_show_idx#11
Self Phi Eliminated (byte) plex_sprite_idx#11
Self Phi Eliminated (byte) plex_sprite_msb#12
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#24
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#13
Self Phi Eliminated (byte) loop::sin_idx#2
Self Phi Eliminated (byte) plex_show_idx#41
Self Phi Eliminated (byte) plex_sprite_idx#41
Self Phi Eliminated (byte) plex_sprite_msb#41
Self Phi Eliminated (byte) plex_free_next#40
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#40
Self Phi Eliminated (byte) loop::sin_idx#3
Self Phi Eliminated (byte) plex_show_idx#29
Self Phi Eliminated (byte) plex_sprite_idx#29
Self Phi Eliminated (byte) plex_sprite_msb#26
Self Phi Eliminated (byte) plex_free_next#25
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#37
Self Phi Eliminated (byte) plex_free_next#36
Self Phi Eliminated (byte) plex_sprite_idx#47
Self Phi Eliminated (byte) plex_show_idx#47
Self Phi Eliminated (byte) plex_sprite_msb#47
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#34
Self Phi Eliminated (byte) loop::sin_idx#15
Self Phi Eliminated (byte) loop::rasterY#1
Self Phi Eliminated (byte) plex_sprite_idx#23
Self Phi Eliminated (byte) plex_show_idx#23
Self Phi Eliminated (byte) plex_free_next#27
Self Phi Eliminated (byte) plex_sprite_msb#27
Self Phi Eliminated (byte) loop::ss#2
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#26
Self Phi Eliminated (byte) loop::sin_idx#10
Successful SSA optimization Pass2SelfPhiElimination
Identical Phi Values (byte*) plexInit::plexSetScreen1_screen#0 (byte*) plexInit::screen#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#15 (byte*) PLEX_SCREEN_PTR#1
Identical Phi Values (byte) plexSort::nxt_y#1 (byte) plexSort::nxt_y#0
Identical Phi Values (byte) plexSort::nxt_idx#1 (byte) plexSort::nxt_idx#0
Identical Phi Values (byte) plexSort::m#5 (byte) plexSort::m#2
Identical Phi Values (byte) plex_show_idx#11 (byte) plex_show_idx#1
Identical Phi Values (byte) plex_sprite_idx#11 (byte) plex_sprite_idx#1
Identical Phi Values (byte) plex_sprite_msb#12 (byte) plex_sprite_msb#1
Identical Phi Values (byte) plex_sprite_idx#12 (byte) plex_sprite_idx#23
Identical Phi Values (byte) plex_show_idx#12 (byte) plex_show_idx#23
Identical Phi Values (byte) plex_free_next#12 (byte) plex_free_next#27
Identical Phi Values (byte*) PLEX_SCREEN_PTR#16 (byte*) PLEX_SCREEN_PTR#26
Identical Phi Values (byte) plex_sprite_msb#13 (byte) plex_sprite_msb#27
Identical Phi Values (byte*) PLEX_SCREEN_PTR#17 (byte*) PLEX_SCREEN_PTR#0
Identical Phi Values (byte) plex_show_idx#28 (byte) plex_show_idx#0
Identical Phi Values (byte) plex_sprite_idx#28 (byte) plex_sprite_idx#0
Identical Phi Values (byte) plex_sprite_msb#25 (byte) plex_sprite_msb#0
Identical Phi Values (byte) plex_free_next#24 (byte) plex_free_next#29
Identical Phi Values (byte*) PLEX_SCREEN_PTR#10 (byte*) PLEX_SCREEN_PTR#13
Identical Phi Values (byte) plex_show_idx#16 (byte) plex_show_idx#20
Identical Phi Values (byte) plex_sprite_idx#16 (byte) plex_sprite_idx#20
Identical Phi Values (byte) plex_sprite_msb#17 (byte) plex_sprite_msb#10
Identical Phi Values (byte) plex_free_next#14 (byte) plex_free_next#19
Identical Phi Values (byte*) PLEX_SCREEN_PTR#19 (byte*) PLEX_SCREEN_PTR#17
Identical Phi Values (byte*) PLEX_SCREEN_PTR#12 (byte*) PLEX_SCREEN_PTR#15
Identical Phi Values (byte*) PLEX_SCREEN_PTR#24 (byte*) PLEX_SCREEN_PTR#12
Identical Phi Values (byte*) PLEX_SCREEN_PTR#13 (byte*) PLEX_SCREEN_PTR#24
Identical Phi Values (byte) plex_show_idx#34 (byte) plex_show_idx#28
Identical Phi Values (byte) plex_sprite_idx#34 (byte) plex_sprite_idx#28
Identical Phi Values (byte) plex_sprite_msb#33 (byte) plex_sprite_msb#25
Identical Phi Values (byte) plex_free_next#33 (byte) plex_free_next#24
Identical Phi Values (byte*) PLEX_SCREEN_PTR#43 (byte*) PLEX_SCREEN_PTR#10
Identical Phi Values (byte) loop::sin_idx#2 (byte) loop::sin_idx#6
Identical Phi Values (byte) plex_show_idx#41 (byte) plex_show_idx#20
Identical Phi Values (byte) plex_sprite_idx#41 (byte) plex_sprite_idx#20
Identical Phi Values (byte) plex_sprite_msb#41 (byte) plex_sprite_msb#10
Identical Phi Values (byte) plex_free_next#40 (byte) plex_free_next#19
Identical Phi Values (byte*) PLEX_SCREEN_PTR#40 (byte*) PLEX_SCREEN_PTR#42
Identical Phi Values (byte) loop::sin_idx#3 (byte) loop::sin_idx#2
Identical Phi Values (byte) plex_show_idx#29 (byte) plex_show_idx#41
Identical Phi Values (byte) plex_sprite_idx#29 (byte) plex_sprite_idx#41
Identical Phi Values (byte) plex_sprite_msb#26 (byte) plex_sprite_msb#41
Identical Phi Values (byte) plex_free_next#25 (byte) plex_free_next#40
Identical Phi Values (byte*) PLEX_SCREEN_PTR#37 (byte*) PLEX_SCREEN_PTR#40
Identical Phi Values (byte) plex_show_idx#18 (byte) plex_show_idx#11
Identical Phi Values (byte) plex_sprite_idx#18 (byte) plex_sprite_idx#11
Identical Phi Values (byte) plex_sprite_msb#19 (byte) plex_sprite_msb#12
Identical Phi Values (byte) plex_free_next#16 (byte) plex_free_next#0
Identical Phi Values (byte) plex_free_next#36 (byte) plex_free_next#16
Identical Phi Values (byte) plex_sprite_idx#47 (byte) plex_sprite_idx#18
Identical Phi Values (byte) plex_show_idx#47 (byte) plex_show_idx#18
Identical Phi Values (byte) plex_sprite_msb#47 (byte) plex_sprite_msb#19
Identical Phi Values (byte*) PLEX_SCREEN_PTR#34 (byte*) PLEX_SCREEN_PTR#37
Identical Phi Values (byte) loop::sin_idx#15 (byte) loop::sin_idx#1
Identical Phi Values (byte) loop::rasterY#1 (byte) loop::plexFreeNextYpos1_return#0
Identical Phi Values (byte) plex_sprite_idx#23 (byte) plex_sprite_idx#42
Identical Phi Values (byte) plex_show_idx#23 (byte) plex_show_idx#42
Identical Phi Values (byte) plex_free_next#27 (byte) plex_free_next#17
Identical Phi Values (byte) plex_sprite_msb#27 (byte) plex_sprite_msb#42
Identical Phi Values (byte) loop::ss#2 (byte) loop::ss#5
Identical Phi Values (byte*) PLEX_SCREEN_PTR#26 (byte*) PLEX_SCREEN_PTR#30
Identical Phi Values (byte) loop::sin_idx#10 (byte) loop::sin_idx#11
Identical Phi Values (byte) plex_free_next#18 (byte) plex_free_next#13
Identical Phi Values (byte) plex_sprite_idx#19 (byte) plex_sprite_idx#15
Identical Phi Values (byte) plex_show_idx#19 (byte) plex_show_idx#15
Identical Phi Values (byte) plex_sprite_msb#20 (byte) plex_sprite_msb#16
Identical Phi Values (byte*) PLEX_SCREEN_PTR#14 (byte*) PLEX_SCREEN_PTR#10
Identical Phi Values (byte) plex_show_idx#10 (byte) plex_show_idx#16
Identical Phi Values (byte) plex_sprite_idx#10 (byte) plex_sprite_idx#16
Identical Phi Values (byte) plex_sprite_msb#11 (byte) plex_sprite_msb#17
Identical Phi Values (byte) plex_free_next#10 (byte) plex_free_next#14
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte) plexSort::m#3 (byte) plexSort::m#2
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [101] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) plexInit::$2 [35] if((byte) plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1
Simple Condition (bool~) plexSort::$4 [47] if((byte) plexSort::nxt_y#0>=*((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2
Simple Condition (bool~) plexSort::$9 [51] if((byte) plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1
Simple Condition (bool~) plexSort::plexFreePrepare1_$0#0 [74] if((byte) plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1
Simple Condition (bool~) plexShowSprite::$4 [104] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
Simple Condition (bool~) plexShowSprite::$8 [118] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return
Simple Condition (bool~) init::$6 [174] if((byte) init::sx#1!=rangelast(0,init::$3)) goto init::@1
Simple Condition (bool~) init::$7 [182] if((byte) init::ss#1!=rangelast(0,7)) goto init::@3
Simple Condition (bool~) loop::$0 [192] if(*((byte*) RASTER#0)!=(byte) $ff) goto loop::@4
Simple Condition (bool~) loop::$2 [203] if((byte) loop::sy#1!=rangelast(0,loop::$1)) goto loop::@10
Simple Condition (bool~) loop::$5 [217] if((byte~) loop::$4!=(byte) 0) goto loop::@12
Simple Condition (bool~) loop::$8 [232] if(*((byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@19
Simple Condition (bool~) loop::$10 [243] if((byte) loop::ss#1!=rangelast(0,loop::$6)) goto loop::@18
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [60] (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant right-side identified [17] (number~) $0 ← (number) $400 + (number) $3f8
Constant right-side identified [128] (byte[8]) PLEX_FREE_YPOS#0 ← { fill( 8, 0) }
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) SPRITES_XPOS#0 = (byte*) 53248
Constant (const byte*) SPRITES_YPOS#0 = (byte*) 53249
Constant (const byte*) SPRITES_XMSB#0 = (byte*) 53264
Constant (const byte*) RASTER#0 = (byte*) 53266
Constant (const byte*) SPRITES_ENABLE#0 = (byte*) 53269
Constant (const byte*) BORDERCOL#0 = (byte*) 53280
Constant (const byte*) SPRITES_COLS#0 = (byte*) 53287
Constant (const byte*) D011#0 = (byte*) 53265
Constant (const byte) VIC_RST8#0 = $80
Constant (const byte) VIC_DEN#0 = $10
Constant (const byte) VIC_RSEL#0 = 8
Constant (const byte) BLACK#0 = 0
Constant (const byte) GREEN#0 = 5
Constant (const byte) PLEX_COUNT#0 = $20
Constant (const number) $0 = $400+$3f8
Constant (const byte) plex_show_idx#0 = 0
Constant (const byte) plex_sprite_idx#0 = 0
Constant (const byte) plex_sprite_msb#0 = 1
Constant (const byte) plexInit::i#0 = 0
Constant (const byte) plexSort::m#0 = 0
Constant (const byte) plex_show_idx#1 = 0
Constant (const byte) plex_sprite_idx#1 = 0
Constant (const byte) plex_sprite_msb#1 = 1
Constant (const byte) plexSort::plexFreePrepare1_s#0 = 0
Constant (const byte) plex_free_next#0 = 0
Constant (const byte) plex_sprite_msb#4 = 1
Constant (const byte[8]) PLEX_FREE_YPOS#0 = { fill( 8, 0) }
Constant (const byte) plex_free_next#29 = 0
Constant (const byte*) SCREEN#0 = (byte*) 1024
Constant (const byte*) SPRITE#0 = (byte*) 8192
Constant (const byte*) YSIN#0 = (byte*) 8448
Constant (const word) init::xp#0 = $20
Constant (const byte) init::sx#0 = 0
Constant (const byte) init::ss#0 = 0
Constant (const byte) loop::sin_idx#0 = 0
Constant (const byte) loop::sy#0 = 0
Constant (const byte) loop::ss#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) plexInit::screen#0 = SCREEN#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified { fill( PLEX_COUNT#0, 0) } in [14] (word[PLEX_COUNT#0]) PLEX_XPOS#0 ← { fill( PLEX_COUNT#0, 0) }
Constant value identified { fill( PLEX_COUNT#0, 0) } in [15] (byte[PLEX_COUNT#0]) PLEX_YPOS#0 ← { fill( PLEX_COUNT#0, 0) }
Constant value identified { fill( PLEX_COUNT#0, 0) } in [16] (byte[PLEX_COUNT#0]) PLEX_PTR#0 ← { fill( PLEX_COUNT#0, 0) }
Constant value identified (byte*)$0 in [18] (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(const number) $0
Constant value identified { fill( PLEX_COUNT#0, 0) } in [19] (byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 ← { fill( PLEX_COUNT#0, 0) }
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [189] if(true) goto loop::@4
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [72] plexSort::plexFreePrepare1_s#1 ← ++ plexSort::plexFreePrepare1_s#2 to ++
Resolved ranged comparison value [74] if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1 to (number) 8
Resolved ranged next value [180] init::ss#1 ← ++ init::ss#2 to ++
Resolved ranged comparison value [182] if(init::ss#1!=rangelast(0,7)) goto init::@3 to (number) 8
Eliminating unused variable (byte*) PLEX_SCREEN_PTR#0 and assignment [3] (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(const number) $0
Eliminating unused variable - keeping the phi block (byte) plex_show_idx#20
Eliminating unused variable - keeping the phi block (byte) plex_sprite_idx#20
Eliminating unused variable - keeping the phi block (byte) plex_sprite_msb#10
Eliminating unused variable - keeping the phi block (byte) plex_free_next#19
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const number) $0
Eliminating unused constant (const byte) plex_show_idx#0
Eliminating unused constant (const byte) plex_sprite_idx#0
Eliminating unused constant (const byte) plex_sprite_msb#0
Eliminating unused constant (const byte) plex_free_next#29
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block loop::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 8 in if((byte) plexSort::plexFreePrepare1_s#1!=(number) 8) goto plexSort::plexFreePrepare1_@1
Adding number conversion cast (unumber) 8 in if((byte) init::ss#1!=(number) 8) goto init::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias (byte~) plexShowSprite::$11 = (byte~) plexShowSprite::$10 
Successful SSA optimization Pass2AliasElimination
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#30
Self Phi Eliminated (byte) loop::sin_idx#11
Successful SSA optimization Pass2SelfPhiElimination
Identical Phi Values (byte*) PLEX_SCREEN_PTR#30 (byte*) PLEX_SCREEN_PTR#42
Identical Phi Values (byte) loop::sin_idx#11 (byte) loop::sin_idx#1
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) plexSort::$6 [25] if((byte) plexSort::s#1!=(byte) $ff) goto plexSort::@8
Simple Condition (bool~) plexSort::$7 [110] if((byte) plexSort::nxt_y#0<*((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [25] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [4] (byte*) PLEX_SCREEN_PTR#1 ← (const byte*) plexInit::screen#0 + (word) $3f8
Constant right-side identified [5] (byte~) plexInit::$1 ← (const byte) PLEX_COUNT#0 - (byte) 1
Constant right-side identified [11] (byte~) plexSort::$1 ← (const byte) PLEX_COUNT#0 - (byte) 2
Constant right-side identified [64] (byte~) init::$0 ← (const byte) VIC_DEN#0 | (const byte) VIC_RSEL#0
Constant right-side identified [68] (byte~) init::$3 ← (const byte) PLEX_COUNT#0 - (byte) 1
Constant right-side identified [70] (byte*~) init::$4 ← (const byte*) SPRITE#0 / (byte) $40
Constant right-side identified [87] (byte~) loop::$1 ← (const byte) PLEX_COUNT#0 - (byte) 1
Constant right-side identified [99] (byte~) loop::$6 ← (const byte) PLEX_COUNT#0 - (byte) 1
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word[PLEX_COUNT#0]) PLEX_XPOS#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_YPOS#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_PTR#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte*) PLEX_SCREEN_PTR#1 = plexInit::screen#0+$3f8
Constant (const byte) plexInit::$1 = PLEX_COUNT#0-1
Constant (const byte) plexSort::$1 = PLEX_COUNT#0-2
Constant (const byte) init::$0 = VIC_DEN#0|VIC_RSEL#0
Constant (const byte) init::$3 = PLEX_COUNT#0-1
Constant (const byte*) init::$4 = SPRITE#0/$40
Constant (const byte) loop::$1 = PLEX_COUNT#0-1
Constant (const byte) loop::$6 = PLEX_COUNT#0-1
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)init::$4 in [71] (byte~) init::$5 ← (byte)(const byte*) init::$4
Successful SSA optimization Pass2ConstantValues
Resolved ranged next value [8] plexInit::i#1 ← ++ plexInit::i#2 to ++
Resolved ranged comparison value [9] if(plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1 to (const byte) plexInit::$1+(number) 1
Resolved ranged next value [17] plexSort::m#1 ← ++ plexSort::m#2 to ++
Resolved ranged comparison value [18] if(plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1 to (const byte) plexSort::$1+(number) 1
Resolved ranged next value [76] init::sx#1 ← ++ init::sx#2 to ++
Resolved ranged comparison value [77] if(init::sx#1!=rangelast(0,init::$3)) goto init::@1 to (const byte) init::$3+(number) 1
Resolved ranged next value [91] loop::sy#1 ← ++ loop::sy#2 to ++
Resolved ranged comparison value [92] if(loop::sy#1!=rangelast(0,loop::$1)) goto loop::@10 to (const byte) loop::$1+(number) 1
Resolved ranged next value [106] loop::ss#1 ← ++ loop::ss#5 to ++
Resolved ranged comparison value [107] if(loop::ss#1!=rangelast(0,loop::$6)) goto loop::@18 to (const byte) loop::$6+(number) 1
Adding number conversion cast (unumber) plexInit::$1+1 in if((byte) plexInit::i#1!=(const byte) plexInit::$1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) 1 in if((byte) plexInit::i#1!=(unumber)(const byte) plexInit::$1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) plexSort::$1+1 in if((byte) plexSort::m#1!=(const byte) plexSort::$1+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) 1 in if((byte) plexSort::m#1!=(unumber)(const byte) plexSort::$1+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) init::$3+1 in if((byte) init::sx#1!=(const byte) init::$3+(number) 1) goto init::@1
Adding number conversion cast (unumber) 1 in if((byte) init::sx#1!=(unumber)(const byte) init::$3+(number) 1) goto init::@1
Adding number conversion cast (unumber) loop::$1+1 in if((byte) loop::sy#1!=(const byte) loop::$1+(number) 1) goto loop::@10
Adding number conversion cast (unumber) 1 in if((byte) loop::sy#1!=(unumber)(const byte) loop::$1+(number) 1) goto loop::@10
Adding number conversion cast (unumber) loop::$6+1 in if((byte) loop::ss#1!=(const byte) loop::$6+(number) 1) goto loop::@18
Adding number conversion cast (unumber) 1 in if((byte) loop::ss#1!=(unumber)(const byte) loop::$6+(number) 1) goto loop::@18
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const byte) plexInit::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) plexSort::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) init::$3+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) loop::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) loop::$6+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Self Phi Eliminated (byte*) PLEX_SCREEN_PTR#42
Successful SSA optimization Pass2SelfPhiElimination
Identical Phi Values (byte*) PLEX_SCREEN_PTR#42 (const byte*) PLEX_SCREEN_PTR#1
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [54] (byte~) init::$1 ← (const byte) init::$0 | (byte) 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) init::$1 = init::$0|3
Constant (const byte) init::$5 = (byte)init::$4
Successful SSA optimization Pass2ConstantIdentification
Rewriting multiplication to use shift [33] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [58] (byte~) init::$8 ← (byte) init::sx#2 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) plexInit::i#0
Inlining constant with var siblings (const byte) plexSort::m#0
Inlining constant with var siblings (const byte) plexSort::plexFreePrepare1_s#0
Inlining constant with var siblings (const word) init::xp#0
Inlining constant with var siblings (const byte) init::sx#0
Inlining constant with var siblings (const byte) init::ss#0
Inlining constant with var siblings (const byte) loop::sin_idx#0
Inlining constant with var siblings (const byte) loop::sy#0
Inlining constant with var siblings (const byte) loop::ss#0
Inlining constant with var siblings (const byte) plex_show_idx#1
Inlining constant with var siblings (const byte) plex_sprite_idx#1
Inlining constant with var siblings (const byte) plex_sprite_msb#1
Inlining constant with var siblings (const byte) plex_free_next#0
Inlining constant with var siblings (const byte) plex_sprite_msb#4
Constant inlined init::xp#0 = (byte) $20
Constant inlined plexInit::$1 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined plexSort::$1 = (const byte) PLEX_COUNT#0-(byte) 2
Constant inlined plexSort::plexFreePrepare1_s#0 = (byte) 0
Constant inlined init::ss#0 = (byte) 0
Constant inlined plexInit::i#0 = (byte) 0
Constant inlined plexSort::m#0 = (byte) 0
Constant inlined init::$3 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined init::$1 = (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3
Constant inlined loop::sin_idx#0 = (byte) 0
Constant inlined init::$0 = (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0
Constant inlined plexInit::screen#0 = (const byte*) SCREEN#0
Constant inlined plex_sprite_msb#4 = (byte) 1
Constant inlined init::$5 = (byte)(const byte*) SPRITE#0/(byte) $40
Constant inlined plex_show_idx#1 = (byte) 0
Constant inlined plex_sprite_idx#1 = (byte) 0
Constant inlined plex_sprite_msb#1 = (byte) 1
Constant inlined init::$4 = (const byte*) SPRITE#0/(byte) $40
Constant inlined loop::$1 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined loop::sy#0 = (byte) 0
Constant inlined plex_free_next#0 = (byte) 0
Constant inlined loop::$6 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined loop::ss#0 = (byte) 0
Constant inlined init::sx#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(PLEX_SORTED_IDX#0+1 + plexSort::$2)
Consolidated array index constant in assignment *(PLEX_SORTED_IDX#0+1 + plexSort::$5)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias (byte) plexSort::m#2 = (byte~) plexSort::$2 
Alias (byte) plexSort::s#3 = (byte~) plexSort::$5 
Successful SSA optimization Pass2AliasElimination
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting plexInit::@4(between plexInit::@1 and plexInit::@1)
Added new block during phi lifting plexSort::@9(between plexSort::@2 and plexSort::@1)
Added new block during phi lifting plexSort::@10(between plexSort::@8 and plexSort::@3)
Added new block during phi lifting plexSort::@11(between plexSort::plexFreePrepare1_@1 and plexSort::plexFreePrepare1_@1)
Added new block during phi lifting plexShowSprite::@8(between plexShowSprite::@2 and plexShowSprite::@return)
Added new block during phi lifting init::@6(between init::@1 and init::@1)
Added new block during phi lifting init::@7(between init::@3 and init::@3)
Added new block during phi lifting loop::@32(between loop::@10 and loop::@10)
Added new block during phi lifting loop::@33(between loop::@31 and loop::@18)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @9
Adding NOP phi() at start of @15
Adding NOP phi() at start of @16
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of loop
Adding NOP phi() at start of loop::@14
Adding NOP phi() at start of loop::plexFreeNextYpos1_@return
Adding NOP phi() at start of loop::@29
Adding NOP phi() at start of plexShowSprite::@6
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::@6
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of plexSort::plexFreePrepare1_@2
Adding NOP phi() at start of init::@5
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1
Adding NOP phi() at start of plexInit::@3
CALL GRAPH
Calls in [] to main:6 
Calls in [main] to init:10 loop:12 
Calls in [loop] to plexSort:27 plexShowSprite:39 
Calls in [init] to plexInit:104 

Created 16 initial phi equivalence classes
Not coalescing [19] loop::y_idx#4 ← loop::sin_idx#6
Coalesced [43] loop::sin_idx#18 ← loop::sin_idx#1
Coalesced [44] plex_free_next#45 ← plex_free_next#13
Coalesced [45] plex_sprite_idx#49 ← plex_sprite_idx#15
Coalesced [46] plex_show_idx#49 ← plex_show_idx#15
Coalesced [47] plex_sprite_msb#50 ← plex_sprite_msb#16
Coalesced [48] loop::ss#9 ← loop::ss#1
Coalesced [49] loop::y_idx#3 ← loop::y_idx#1
Coalesced [50] loop::sy#3 ← loop::sy#1
Coalesced [75] plex_sprite_msb#49 ← plex_sprite_msb#3
Not coalescing [82] plexSort::s#6 ← plexSort::m#2
Coalesced [100] plexSort::plexFreePrepare1_s#3 ← plexSort::plexFreePrepare1_s#1
Coalesced [101] plexSort::m#7 ← plexSort::m#1
Coalesced [102] plexSort::s#5 ← plexSort::s#1
Coalesced [119] init::ss#3 ← init::ss#1
Coalesced [120] init::sx#3 ← init::sx#1
Coalesced [121] init::xp#3 ← init::xp#1
Coalesced [130] plexInit::i#3 ← plexInit::i#1
Coalesced down to 15 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @9
Culled Empty Block (label) @16
Culled Empty Block (label) main::@2
Culled Empty Block (label) loop::@14
Culled Empty Block (label) loop::plexFreeNextYpos1_@return
Culled Empty Block (label) loop::@29
Culled Empty Block (label) loop::@33
Culled Empty Block (label) loop::@32
Culled Empty Block (label) plexShowSprite::@6
Culled Empty Block (label) plexSort::@6
Culled Empty Block (label) plexSort::plexFreePrepare1_@2
Culled Empty Block (label) plexSort::@11
Culled Empty Block (label) plexSort::@9
Culled Empty Block (label) plexSort::@10
Culled Empty Block (label) init::@5
Culled Empty Block (label) init::@7
Culled Empty Block (label) init::@6
Culled Empty Block (label) plexInit::@3
Culled Empty Block (label) plexInit::@4
Renumbering block @12 to @1
Renumbering block @15 to @2
Renumbering block plexSort::@8 to plexSort::@6
Renumbering block plexShowSprite::@4 to plexShowSprite::@3
Renumbering block plexShowSprite::@7 to plexShowSprite::@4
Renumbering block plexShowSprite::@8 to plexShowSprite::@5
Renumbering block loop::@4 to loop::@2
Renumbering block loop::@6 to loop::@3
Renumbering block loop::@10 to loop::@4
Renumbering block loop::@11 to loop::@5
Renumbering block loop::@12 to loop::@6
Renumbering block loop::@18 to loop::@7
Renumbering block loop::@19 to loop::@8
Renumbering block loop::@21 to loop::@9
Renumbering block loop::@25 to loop::@10
Renumbering block loop::@30 to loop::@11
Renumbering block loop::@31 to loop::@12
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of loop
Adding NOP phi() at start of plexShowSprite::@5
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  kickasm(location (const byte*) YSIN#0) {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
  kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  to:@2
@2: scope:[]  from @1
  [3] phi()
  [4] call main 
  to:@end
@end: scope:[]  from @2
  [5] phi()
main: scope:[main]  from @2
  asm { sei  }
  [7] call init 
  to:main::@1
main::@1: scope:[main]  from main
  [8] phi()
  [9] call loop 
  to:main::@return
main::@return: scope:[main]  from main::@1
  [10] return 
  to:@return
loop: scope:[loop]  from main::@1
  [11] phi()
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@10
  [12] (byte) loop::sin_idx#6 ← phi( loop/(byte) 0 loop::@10/(byte) loop::sin_idx#1 )
  to:loop::@2
loop::@2: scope:[loop]  from loop::@1 loop::@2
  [13] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2
  to:loop::@3
loop::@3: scope:[loop]  from loop::@2
  [14] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  [15] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6
  to:loop::@4
loop::@4: scope:[loop]  from loop::@3 loop::@4
  [16] (byte) loop::sy#2 ← phi( loop::@4/(byte) loop::sy#1 loop::@3/(byte) 0 )
  [16] (byte) loop::y_idx#2 ← phi( loop::@4/(byte) loop::y_idx#1 loop::@3/(byte~) loop::y_idx#4 )
  [17] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2)
  [18] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8
  [19] (byte) loop::sy#1 ← ++ (byte) loop::sy#2
  [20] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  [21] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1
  [22] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  [23] call plexSort 
  to:loop::@11
loop::@11: scope:[loop]  from loop::@5
  [24] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0
  to:loop::@6
loop::@6: scope:[loop]  from loop::@11 loop::@6
  [25] (byte~) loop::$4 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0
  [26] if((byte~) loop::$4!=(byte) 0) goto loop::@6
  to:loop::@7
loop::@7: scope:[loop]  from loop::@12 loop::@6
  [27] (byte) loop::ss#5 ← phi( loop::@6/(byte) 0 loop::@12/(byte) loop::ss#1 )
  [27] (byte) plex_sprite_msb#42 ← phi( loop::@6/(byte) 1 loop::@12/(byte) plex_sprite_msb#16 )
  [27] (byte) plex_show_idx#42 ← phi( loop::@6/(byte) 0 loop::@12/(byte) plex_show_idx#15 )
  [27] (byte) plex_sprite_idx#42 ← phi( loop::@6/(byte) 0 loop::@12/(byte) plex_sprite_idx#15 )
  [27] (byte) plex_free_next#17 ← phi( loop::@6/(byte) 0 loop::@12/(byte) plex_free_next#13 )
  [28] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0
  to:loop::plexFreeNextYpos1
loop::plexFreeNextYpos1: scope:[loop]  from loop::@7
  [29] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17)
  to:loop::@8
loop::@8: scope:[loop]  from loop::@8 loop::plexFreeNextYpos1
  [30] if(*((const byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8
  to:loop::@9
loop::@9: scope:[loop]  from loop::@8
  [31] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  [32] call plexShowSprite 
  to:loop::@12
loop::@12: scope:[loop]  from loop::@9
  [33] (byte) loop::ss#1 ← ++ (byte) loop::ss#5
  [34] if((byte) loop::ss#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@7
  to:loop::@10
loop::@10: scope:[loop]  from loop::@12
  [35] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0
  to:loop::@1
plexShowSprite: scope:[plexShowSprite]  from loop::@9
  [36] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1
  [37] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42))
  [38] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  [39] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15
  [40] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0
  [41] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#17 + (byte) 1
  [42] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  [43] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42))
  [44] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)
  [45] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1
  [46] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11)
  [47] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2
  [48] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11)
  [49] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@4
  [50] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42
  [51] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  [52] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#42 + (byte) 1
  [53] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7
  [54] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#42
  [55] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#42 << (byte) 1
  [56] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5
  to:plexShowSprite::@return
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::@2
  [57] phi()
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@5
  [58] (byte) plex_sprite_msb#16 ← phi( plexShowSprite::@5/(byte) plex_sprite_msb#3 plexShowSprite::@2/(byte) 1 )
  [59] return 
  to:@return
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@4
  [60] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42
  to:plexShowSprite::@2
plexSort: scope:[plexSort]  from loop::@5
  [61] phi()
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  [62] (byte) plexSort::m#2 ← phi( plexSort/(byte) 0 plexSort::@2/(byte) plexSort::m#1 )
  [63] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2)
  [64] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0)
  [65] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2
  to:plexSort::@5
plexSort::@5: scope:[plexSort]  from plexSort::@1
  [66] (byte~) plexSort::s#6 ← (byte) plexSort::m#2
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@5 plexSort::@6
  [67] (byte) plexSort::s#3 ← phi( plexSort::@6/(byte) plexSort::s#1 plexSort::@5/(byte~) plexSort::s#6 )
  [68] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3)
  [69] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  [70] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
  to:plexSort::@6
plexSort::@6: scope:[plexSort]  from plexSort::@3
  [71] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3 plexSort::@6
  [72] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1
  [73] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0
  to:plexSort::@2
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  [74] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2
  [75] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@2
  [76] phi()
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  [77] (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) 0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  [78] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0
  [79] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2
  [80] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  [81] return 
  to:@return
init: scope:[init]  from main
  [82] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3
  [83] call plexInit 
  to:init::@1
init::@1: scope:[init]  from init init::@1
  [84] (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init/(byte) $20 )
  [84] (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init/(byte) 0 )
  [85] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40
  [86] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1
  [87] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2
  [88] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9
  [89] (byte) init::sx#1 ← ++ (byte) init::sx#2
  [90] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  [91] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  [92] (byte) init::ss#2 ← phi( init::@2/(byte) 0 init::@3/(byte) init::ss#1 )
  [93] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0
  [94] (byte) init::ss#1 ← ++ (byte) init::ss#2
  [95] if((byte) init::ss#1!=(byte) 8) goto init::@3
  to:init::@return
init::@return: scope:[init]  from init::@3
  [96] return 
  to:@return
plexInit: scope:[plexInit]  from init
  [97] phi()
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  [98] phi()
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::plexSetScreen1
  [99] (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::plexSetScreen1/(byte) 0 )
  [100] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  [101] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2
  [102] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  [103] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) BLACK
(byte*) BORDERCOL
(byte*) D011
(byte) GREEN
(byte) PLEX_COUNT
(byte[8]) PLEX_FREE_YPOS
(byte[PLEX_COUNT#0]) PLEX_PTR
(byte*) PLEX_SCREEN_PTR
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(word[PLEX_COUNT#0]) PLEX_XPOS
(byte[PLEX_COUNT#0]) PLEX_YPOS
(byte*) RASTER
(byte*) SCREEN
(byte*) SPRITE
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_XMSB
(byte*) SPRITES_XPOS
(byte*) SPRITES_YPOS
(byte) VIC_DEN
(byte) VIC_RSEL
(byte) VIC_RST8
(byte*) YSIN
(void()) init()
(byte~) init::$8 22.0
(byte) init::ss
(byte) init::ss#1 16.5
(byte) init::ss#2 16.5
(byte) init::sx
(byte) init::sx#1 16.5
(byte) init::sx#2 8.8
(word) init::xp
(word) init::xp#1 7.333333333333333
(word) init::xp#2 8.25
(void()) loop()
(byte~) loop::$4 202.0
(byte) loop::plexFreeNextYpos1_return
(byte) loop::plexFreeNextYpos1_return#0 551.0
(byte) loop::rasterY
(byte) loop::sin_idx
(byte) loop::sin_idx#1 1.4666666666666666
(byte) loop::sin_idx#6 3.666666666666667
(byte) loop::ss
(byte) loop::ss#1 151.5
(byte) loop::ss#5 33.666666666666664
(byte) loop::sy
(byte) loop::sy#1 151.5
(byte) loop::sy#2 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 67.33333333333333
(byte) loop::y_idx#2 157.0
(byte~) loop::y_idx#4 22.0
(void()) main()
(void()) plexInit((byte*) plexInit::screen)
(byte) plexInit::i
(byte) plexInit::i#1 16.5
(byte) plexInit::i#2 22.0
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 2.0
(byte~) plexShowSprite::$2 4.0
(byte~) plexShowSprite::$3 4.0
(byte~) plexShowSprite::$5 4.0
(byte~) plexShowSprite::$9 4.0
(number~) plexShowSprite::plexFreeAdd1_$0
(byte~) plexShowSprite::plexFreeAdd1_$0#0 4.0
(number~) plexShowSprite::plexFreeAdd1_$1
(byte~) plexShowSprite::plexFreeAdd1_$1#0 4.0
(number~) plexShowSprite::plexFreeAdd1_$2
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 0.5454545454545454
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 4.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(byte) plexSort::m
(byte) plexSort::m#1 151.5
(byte) plexSort::m#2 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 150.375
(bool~) plexSort::plexFreePrepare1_$0
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 151.5
(byte) plexSort::plexFreePrepare1_s#2 151.5
(byte) plexSort::s
(byte) plexSort::s#1 1368.3333333333335
(byte) plexSort::s#2 202.0
(byte) plexSort::s#3 2052.5
(byte~) plexSort::s#6 202.0
(byte) plex_free_next
(byte) plex_free_next#13 4.681818181818182
(byte) plex_free_next#17 20.599999999999998
(byte) plex_show_idx
(byte) plex_show_idx#15 11.444444444444443
(byte) plex_show_idx#42 4.541666666666665
(byte) plex_sprite_idx
(byte) plex_sprite_idx#15 10.299999999999999
(byte) plex_sprite_idx#42 4.863636363636363
(byte) plex_sprite_msb
(byte) plex_sprite_msb#16 20.599999999999998
(byte) plex_sprite_msb#3 2.0
(byte) plex_sprite_msb#42 4.28

Initial phi equivalence classes
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plex_free_next#17 plex_free_next#13 ]
[ plex_sprite_idx#42 plex_sprite_idx#15 ]
[ plex_show_idx#42 plex_show_idx#15 ]
[ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
[ loop::ss#5 loop::ss#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
Added variable loop::$4 to zero page equivalence class [ loop::$4 ]
Added variable loop::plexFreeNextYpos1_return#0 to zero page equivalence class [ loop::plexFreeNextYpos1_return#0 ]
Added variable plexShowSprite::plex_sprite_idx2#0 to zero page equivalence class [ plexShowSprite::plex_sprite_idx2#0 ]
Added variable plexShowSprite::plexFreeAdd1_ypos#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Added variable plexShowSprite::plexFreeAdd1_$0#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$0#0 ]
Added variable plexShowSprite::plexFreeAdd1_$1#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$1#0 ]
Added variable plexShowSprite::xpos_idx#0 to zero page equivalence class [ plexShowSprite::xpos_idx#0 ]
Added variable plexShowSprite::$11 to zero page equivalence class [ plexShowSprite::$11 ]
Added variable plexShowSprite::$2 to zero page equivalence class [ plexShowSprite::$2 ]
Added variable plexShowSprite::$3 to zero page equivalence class [ plexShowSprite::$3 ]
Added variable plexShowSprite::$9 to zero page equivalence class [ plexShowSprite::$9 ]
Added variable plexShowSprite::$5 to zero page equivalence class [ plexShowSprite::$5 ]
Added variable plexSort::nxt_idx#0 to zero page equivalence class [ plexSort::nxt_idx#0 ]
Added variable plexSort::nxt_y#0 to zero page equivalence class [ plexSort::nxt_y#0 ]
Added variable plexSort::s#2 to zero page equivalence class [ plexSort::s#2 ]
Added variable init::$8 to zero page equivalence class [ init::$8 ]
Complete equivalence classes
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plex_free_next#17 plex_free_next#13 ]
[ plex_sprite_idx#42 plex_sprite_idx#15 ]
[ plex_show_idx#42 plex_show_idx#15 ]
[ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
[ loop::ss#5 loop::ss#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ loop::$4 ]
[ loop::plexFreeNextYpos1_return#0 ]
[ plexShowSprite::plex_sprite_idx2#0 ]
[ plexShowSprite::plexFreeAdd1_ypos#0 ]
[ plexShowSprite::plexFreeAdd1_$0#0 ]
[ plexShowSprite::plexFreeAdd1_$1#0 ]
[ plexShowSprite::xpos_idx#0 ]
[ plexShowSprite::$11 ]
[ plexShowSprite::$2 ]
[ plexShowSprite::$3 ]
[ plexShowSprite::$9 ]
[ plexShowSprite::$5 ]
[ plexSort::nxt_idx#0 ]
[ plexSort::nxt_y#0 ]
[ plexSort::s#2 ]
[ init::$8 ]
Allocated zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Allocated zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Allocated zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ]
Allocated zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ]
Allocated zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ]
Allocated zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ]
Allocated zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
Allocated zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ]
Allocated zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ]
Allocated zp ZP_BYTE:11 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Allocated zp ZP_BYTE:12 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Allocated zp ZP_BYTE:13 [ init::sx#2 init::sx#1 ]
Allocated zp ZP_WORD:14 [ init::xp#2 init::xp#1 ]
Allocated zp ZP_BYTE:16 [ init::ss#2 init::ss#1 ]
Allocated zp ZP_BYTE:17 [ plexInit::i#2 plexInit::i#1 ]
Allocated zp ZP_BYTE:18 [ loop::$4 ]
Allocated zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ]
Allocated zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated zp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Allocated zp ZP_BYTE:22 [ plexShowSprite::plexFreeAdd1_$0#0 ]
Allocated zp ZP_BYTE:23 [ plexShowSprite::plexFreeAdd1_$1#0 ]
Allocated zp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ]
Allocated zp ZP_BYTE:25 [ plexShowSprite::$11 ]
Allocated zp ZP_BYTE:26 [ plexShowSprite::$2 ]
Allocated zp ZP_BYTE:27 [ plexShowSprite::$3 ]
Allocated zp ZP_BYTE:28 [ plexShowSprite::$9 ]
Allocated zp ZP_BYTE:29 [ plexShowSprite::$5 ]
Allocated zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ]
Allocated zp ZP_BYTE:31 [ plexSort::nxt_y#0 ]
Allocated zp ZP_BYTE:32 [ plexSort::s#2 ]
Allocated zp ZP_BYTE:33 [ init::$8 ]

INITIAL ASM
//SEG0 File Comments
// A simple usage of the flexible sprite multiplexer routine
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label D011 = $d011
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  // Location of screen & sprites
  .label SCREEN = $400
  .label SPRITE = $2000
  .label YSIN = $2100
  .label PLEX_SCREEN_PTR = SCREEN+$3f8
  .label plex_sprite_msb = 8
  .label plex_free_next = 5
  .label plex_sprite_idx = 6
  .label plex_show_idx = 7
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 kickasm(location (const byte*) YSIN#0) {{ .var min = 50     .var max = 250-21     .var ampl = max-min;     .for(var i=0;i<256;i++)         .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))  }}
//SEG6 kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
//SEG7 [3] phi from @1 to @2 [phi:@1->@2]
b2_from_b1:
  jmp b2
//SEG8 @2
b2:
//SEG9 [4] call main 
  jsr main
//SEG10 [5] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
//SEG11 @end
bend:
//SEG12 main
main: {
  //SEG13 asm { sei  }
    sei
  //SEG14 [7] call init 
    jsr init
  //SEG15 [8] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG16 main::@1
  b1:
  //SEG17 [9] call loop 
  //SEG18 [11] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from_b1:
    jsr loop
    jmp breturn
  //SEG19 main::@return
  breturn:
  //SEG20 [10] return 
    rts
}
//SEG21 loop
// The raster loop
loop: {
    .label _4 = $12
    .label y_idx = 3
    .label sy = 4
    .label sin_idx = 2
    .label plexFreeNextYpos1_return = $13
    .label ss = 9
  //SEG22 [12] phi from loop to loop::@1 [phi:loop->loop::@1]
  b1_from_loop:
  //SEG23 [12] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta sin_idx
    jmp b1
  //SEG24 loop::@1
  b1:
    jmp b2
  //SEG25 loop::@2
  b2:
  //SEG26 [13] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    jmp b3
  //SEG27 loop::@3
  b3:
  //SEG28 [14] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG29 [15] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuz1=vbuz2 
    lda sin_idx
    sta y_idx
  //SEG30 [16] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  b4_from_b3:
  //SEG31 [16] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta sy
  //SEG32 [16] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp b4
  //SEG33 [16] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  b4_from_b4:
  //SEG34 [16] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
  //SEG35 [16] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp b4
  //SEG36 loop::@4
  b4:
  //SEG37 [17] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz2 
    ldy y_idx
    lda YSIN,y
    ldy sy
    sta PLEX_YPOS,y
  //SEG38 [18] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuz1=vbuz1_plus_vbuc1 
    lax y_idx
    axs #-[8]
    stx y_idx
  //SEG39 [19] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuz1=_inc_vbuz1 
    inc sy
  //SEG40 [20] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp sy
    bne b4_from_b4
    jmp b5
  //SEG41 loop::@5
  b5:
  //SEG42 [21] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc sin_idx
  //SEG43 [22] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG44 [23] call plexSort 
  //SEG45 [61] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from_b5:
    jsr plexSort
    jmp b11
  //SEG46 loop::@11
  b11:
  //SEG47 [24] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp b6
  //SEG48 loop::@6
  b6:
  //SEG49 [25] (byte~) loop::$4 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
    sta _4
  //SEG50 [26] if((byte~) loop::$4!=(byte) 0) goto loop::@6 -- vbuz1_neq_0_then_la1 
    lda _4
    cmp #0
    bne b6
  //SEG51 [27] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
  b7_from_b6:
  //SEG52 [27] phi (byte) loop::ss#5 = (byte) 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta ss
  //SEG53 [27] phi (byte) plex_sprite_msb#42 = (byte) 1 [phi:loop::@6->loop::@7#1] -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG54 [27] phi (byte) plex_show_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#2] -- vbuz1=vbuc1 
    lda #0
    sta plex_show_idx
  //SEG55 [27] phi (byte) plex_sprite_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#3] -- vbuz1=vbuc1 
    lda #0
    sta plex_sprite_idx
  //SEG56 [27] phi (byte) plex_free_next#17 = (byte) 0 [phi:loop::@6->loop::@7#4] -- vbuz1=vbuc1 
    lda #0
    sta plex_free_next
    jmp b7
  // Show the sprites
  //SEG57 [27] phi from loop::@12 to loop::@7 [phi:loop::@12->loop::@7]
  b7_from_b12:
  //SEG58 [27] phi (byte) loop::ss#5 = (byte) loop::ss#1 [phi:loop::@12->loop::@7#0] -- register_copy 
  //SEG59 [27] phi (byte) plex_sprite_msb#42 = (byte) plex_sprite_msb#16 [phi:loop::@12->loop::@7#1] -- register_copy 
  //SEG60 [27] phi (byte) plex_show_idx#42 = (byte) plex_show_idx#15 [phi:loop::@12->loop::@7#2] -- register_copy 
  //SEG61 [27] phi (byte) plex_sprite_idx#42 = (byte) plex_sprite_idx#15 [phi:loop::@12->loop::@7#3] -- register_copy 
  //SEG62 [27] phi (byte) plex_free_next#17 = (byte) plex_free_next#13 [phi:loop::@12->loop::@7#4] -- register_copy 
    jmp b7
  //SEG63 loop::@7
  b7:
  //SEG64 [28] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp plexFreeNextYpos1
  //SEG65 loop::plexFreeNextYpos1
  plexFreeNextYpos1:
  //SEG66 [29] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy plex_free_next
    lda PLEX_FREE_YPOS,y
    sta plexFreeNextYpos1_return
    jmp b8
  //SEG67 loop::@8
  b8:
  //SEG68 [30] if(*((const byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp plexFreeNextYpos1_return
    bcc b8
    jmp b9
  //SEG69 loop::@9
  b9:
  //SEG70 [31] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG71 [32] call plexShowSprite 
    jsr plexShowSprite
    jmp b12
  //SEG72 loop::@12
  b12:
  //SEG73 [33] (byte) loop::ss#1 ← ++ (byte) loop::ss#5 -- vbuz1=_inc_vbuz1 
    inc ss
  //SEG74 [34] if((byte) loop::ss#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp ss
    bne b7_from_b12
    jmp b10
  //SEG75 loop::@10
  b10:
  //SEG76 [35] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG77 [12] phi from loop::@10 to loop::@1 [phi:loop::@10->loop::@1]
  b1_from_b10:
  //SEG78 [12] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@10->loop::@1#0] -- register_copy 
    jmp b1
}
//SEG79 plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label _2 = $1a
    .label _3 = $1b
    .label _5 = $1d
    .label _9 = $1c
    .label _11 = $19
    .label plex_sprite_idx2 = $14
    .label plexFreeAdd1_ypos = $15
    .label plexFreeAdd1__0 = $16
    .label plexFreeAdd1__1 = $17
    .label xpos_idx = $18
  //SEG80 [36] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda plex_sprite_idx
    asl
    sta plex_sprite_idx2
  //SEG81 [37] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- vbuz1=pbuc1_derefidx_pbuc2_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    ldx PLEX_YPOS,y
    stx plexFreeAdd1_ypos
  //SEG82 [38] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda plexFreeAdd1_ypos
    ldy plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
  //SEG83 plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
  //SEG84 [39] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuz1=vbuz2_plus_vbuc1 
    lax plexFreeAdd1_ypos
    axs #-[$15]
    stx plexFreeAdd1__0
  //SEG85 [40] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda plexFreeAdd1__0
    ldy plex_free_next
    sta PLEX_FREE_YPOS,y
  //SEG86 [41] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#17 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy plex_free_next
    iny
    sty plexFreeAdd1__1
  //SEG87 [42] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and plexFreeAdd1__1
    sta plex_free_next
    jmp b4
  //SEG88 plexShowSprite::@4
  b4:
  //SEG89 [43] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_pbuc3_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
  //SEG90 [44] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy plex_show_idx
    lda PLEX_SORTED_IDX,y
    sta xpos_idx
  //SEG91 [45] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda xpos_idx
    asl
    sta _11
  //SEG92 [46] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuz1=_lo_pwuc1_derefidx_vbuz2 
    ldy _11
    lda PLEX_XPOS,y
    sta _2
  //SEG93 [47] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _2
    ldy plex_sprite_idx2
    sta SPRITES_XPOS,y
  //SEG94 [48] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuz1=_hi_pwuc1_derefidx_vbuz2 
    ldy _11
    lda PLEX_XPOS+1,y
    sta _3
  //SEG95 [49] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuz1_neq_0_then_la1 
    lda _3
    cmp #0
    bne b1
    jmp b3
  //SEG96 plexShowSprite::@3
  b3:
  //SEG97 [50] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 -- vbuz1=vbuc1_bxor_vbuz2 
    lda #$ff
    eor plex_sprite_msb
    sta _9
  //SEG98 [51] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuz1 
    lda SPRITES_XMSB
    and _9
    sta SPRITES_XMSB
    jmp b2
  //SEG99 plexShowSprite::@2
  b2:
  //SEG100 [52] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#42 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy plex_sprite_idx
    iny
    sty _5
  //SEG101 [53] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and _5
    sta plex_sprite_idx
  //SEG102 [54] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#42 -- vbuz1=_inc_vbuz1 
    inc plex_show_idx
  //SEG103 [55] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#42 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl plex_sprite_msb
  //SEG104 [56] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5 -- vbuz1_neq_0_then_la1 
    lda plex_sprite_msb
    cmp #0
    bne b5_from_b2
  //SEG105 [58] phi from plexShowSprite::@2 to plexShowSprite::@return [phi:plexShowSprite::@2->plexShowSprite::@return]
  breturn_from_b2:
  //SEG106 [58] phi (byte) plex_sprite_msb#16 = (byte) 1 [phi:plexShowSprite::@2->plexShowSprite::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
    jmp breturn
  //SEG107 [57] phi from plexShowSprite::@2 to plexShowSprite::@5 [phi:plexShowSprite::@2->plexShowSprite::@5]
  b5_from_b2:
    jmp b5
  //SEG108 plexShowSprite::@5
  b5:
  //SEG109 [58] phi from plexShowSprite::@5 to plexShowSprite::@return [phi:plexShowSprite::@5->plexShowSprite::@return]
  breturn_from_b5:
  //SEG110 [58] phi (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@5->plexShowSprite::@return#0] -- register_copy 
    jmp breturn
  //SEG111 plexShowSprite::@return
  breturn:
  //SEG112 [59] return 
    rts
  //SEG113 plexShowSprite::@1
  b1:
  //SEG114 [60] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
//SEG115 plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $1e
    .label nxt_y = $1f
    .label m = $a
    .label s = $b
    .label s_2 = $20
    .label plexFreePrepare1_s = $c
  //SEG116 [62] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  b1_from_plexSort:
  //SEG117 [62] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta m
    jmp b1
  //SEG118 [62] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  b1_from_b2:
  //SEG119 [62] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp b1
  //SEG120 plexSort::@1
  b1:
  //SEG121 [63] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy m
    lda PLEX_SORTED_IDX+1,y
    sta nxt_idx
  //SEG122 [64] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy nxt_idx
    lda PLEX_YPOS,y
    sta nxt_y
  //SEG123 [65] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    lda nxt_y
    ldx m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
    jmp b5
  //SEG124 plexSort::@5
  b5:
  //SEG125 [66] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuz1=vbuz2 
    lda m
    sta s
  //SEG126 [67] phi from plexSort::@5 plexSort::@6 to plexSort::@3 [phi:plexSort::@5/plexSort::@6->plexSort::@3]
  b3_from_b5:
  b3_from_b6:
  //SEG127 [67] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@6->plexSort::@3#0] -- register_copy 
    jmp b3
  //SEG128 plexSort::@3
  b3:
  //SEG129 [68] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy s
    lda PLEX_SORTED_IDX,y
    sta PLEX_SORTED_IDX+1,y
  //SEG130 [69] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuz1=_dec_vbuz1 
    dec s
  //SEG131 [70] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuz1_eq_vbuc1_then_la1 
    lda #$ff
    cmp s
    beq b4
    jmp b6
  //SEG132 plexSort::@6
  b6:
  //SEG133 [71] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    lda nxt_y
    ldx s
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3_from_b6
    jmp b4
  //SEG134 plexSort::@4
  b4:
  //SEG135 [72] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuz1=_inc_vbuz2 
    ldy s
    iny
    sty s_2
  //SEG136 [73] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda nxt_idx
    ldy s_2
    sta PLEX_SORTED_IDX,y
    jmp b2
  //SEG137 plexSort::@2
  b2:
  //SEG138 [74] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG139 [75] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp m
    bne b1_from_b2
  //SEG140 [76] phi from plexSort::@2 to plexSort::plexFreePrepare1 [phi:plexSort::@2->plexSort::plexFreePrepare1]
  plexFreePrepare1_from_b2:
    jmp plexFreePrepare1
  //SEG141 plexSort::plexFreePrepare1
  plexFreePrepare1:
  //SEG142 [77] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1:
  //SEG143 [77] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuz1=vbuc1 
    lda #0
    sta plexFreePrepare1_s
    jmp plexFreePrepare1_b1
  //SEG144 [77] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1_b1:
  //SEG145 [77] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1_b1
  //SEG146 plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
  //SEG147 [78] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #0
    ldy plexFreePrepare1_s
    sta PLEX_FREE_YPOS,y
  //SEG148 [79] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuz1=_inc_vbuz1 
    inc plexFreePrepare1_s
  //SEG149 [80] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp plexFreePrepare1_s
    bne plexFreePrepare1_b1_from_plexFreePrepare1_b1
    jmp breturn
  //SEG150 plexSort::@return
  breturn:
  //SEG151 [81] return 
    rts
}
//SEG152 init
// Initialize the program
init: {
    .label _8 = $21
    .label xp = $e
    .label sx = $d
    .label ss = $10
  //SEG153 [82] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
  //SEG154 [83] call plexInit 
  //SEG155 [97] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
  //SEG156 [84] phi from init to init::@1 [phi:init->init::@1]
  b1_from_init:
  //SEG157 [84] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #$20
    sta xp
    lda #0
    sta xp+1
  //SEG158 [84] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta sx
    jmp b1
  //SEG159 [84] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
  //SEG160 [84] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
  //SEG161 [84] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp b1
  //SEG162 init::@1
  b1:
  //SEG163 [85] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #SPRITE/$40
    ldy sx
    sta PLEX_PTR,y
  //SEG164 [86] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda sx
    asl
    sta _8
  //SEG165 [87] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 -- pwuc1_derefidx_vbuz1=vwuz2 
    ldy _8
    lda xp
    sta PLEX_XPOS,y
    lda xp+1
    sta PLEX_XPOS+1,y
  //SEG166 [88] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc xp
    sta xp
    bcc !+
    inc xp+1
  !:
  //SEG167 [89] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuz1=_inc_vbuz1 
    inc sx
  //SEG168 [90] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp sx
    bne b1_from_b1
    jmp b2
  //SEG169 init::@2
  b2:
  //SEG170 [91] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
  //SEG171 [92] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
  //SEG172 [92] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta ss
    jmp b3
  //SEG173 [92] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  b3_from_b3:
  //SEG174 [92] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp b3
  //SEG175 init::@3
  b3:
  //SEG176 [93] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy ss
    sta SPRITES_COLS,y
  //SEG177 [94] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuz1=_inc_vbuz1 
    inc ss
  //SEG178 [95] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp ss
    bne b3_from_b3
    jmp breturn
  //SEG179 init::@return
  breturn:
  //SEG180 [96] return 
    rts
}
//SEG181 plexInit
// Initialize the multiplexer data structures
plexInit: {
    .label i = $11
  //SEG182 [98] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
  //SEG183 plexInit::plexSetScreen1
  plexSetScreen1:
  //SEG184 [99] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  b1_from_plexSetScreen1:
  //SEG185 [99] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b1
  //SEG186 [99] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  b1_from_b1:
  //SEG187 [99] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp b1
  //SEG188 plexInit::@1
  b1:
  //SEG189 [100] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuz1=vbuz1 
    ldy i
    tya
    sta PLEX_SORTED_IDX,y
  //SEG190 [101] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuz1=_inc_vbuz1 
    inc i
  //SEG191 [102] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp i
    bne b1_from_b1
    jmp breturn
  //SEG192 plexInit::@return
  breturn:
  //SEG193 [103] return 
    rts
}
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = YSIN "YSIN"
  .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [13] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 [ loop::sin_idx#6 ] ( main:4::loop:9 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Statement [17] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:4::loop:9 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ]
Statement [18] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:4::loop:9 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [24] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 ] ( main:4::loop:9 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [25] (byte~) loop::$4 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 [ loop::sin_idx#1 loop::$4 ] ( main:4::loop:9 [ loop::sin_idx#1 loop::$4 ] ) always clobbers reg byte a 
Statement [28] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 loop::ss#5 ] ( main:4::loop:9 [ loop::sin_idx#1 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 loop::ss#5 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ]
Statement [35] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 ] ( main:4::loop:9 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [36] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 [ plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plexShowSprite::plex_sprite_idx2#0 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [43] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [45] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [46] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:25 [ plexShowSprite::$11 ]
Statement [48] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$3 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [50] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$9 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [51] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ) always clobbers reg byte a 
Statement [60] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ) always clobbers reg byte a 
Statement [68] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:4::loop:9::plexSort:23 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:31 [ plexSort::nxt_y#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:11 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Statement [71] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:4::loop:9::plexSort:23 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [73] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:4::loop:9::plexSort:23 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [78] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:4::loop:9::plexSort:23 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:12 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Statement [82] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 [ ] ( main:4::init:7 [ ] ) always clobbers reg byte a 
Statement [85] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:4::init:7 [ init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:13 [ init::sx#2 init::sx#1 ]
Statement [86] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$8 ] ( main:4::init:7 [ init::sx#2 init::xp#2 init::$8 ] ) always clobbers reg byte a 
Statement [87] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:4::init:7 [ init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [88] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:4::init:7 [ init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [91] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:4::init:7 [ ] ) always clobbers reg byte a 
Statement [93] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:4::init:7 [ init::ss#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:16 [ init::ss#2 init::ss#1 ]
Statement [13] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 [ loop::sin_idx#6 ] ( main:4::loop:9 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [17] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:4::loop:9 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Statement [18] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:4::loop:9 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [24] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 ] ( main:4::loop:9 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [25] (byte~) loop::$4 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 [ loop::sin_idx#1 loop::$4 ] ( main:4::loop:9 [ loop::sin_idx#1 loop::$4 ] ) always clobbers reg byte a 
Statement [28] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 loop::ss#5 ] ( main:4::loop:9 [ loop::sin_idx#1 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 loop::ss#5 ] ) always clobbers reg byte a 
Statement [35] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 ] ( main:4::loop:9 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [36] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 [ plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plexShowSprite::plex_sprite_idx2#0 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [43] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [45] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [46] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Statement [48] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$3 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [50] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$9 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [51] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ) always clobbers reg byte a 
Statement [60] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ( main:4::loop:9::plexShowSprite:32 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ) always clobbers reg byte a 
Statement [65] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:4::loop:9::plexSort:23 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ) always clobbers reg byte a 
Statement [68] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:4::loop:9::plexSort:23 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Statement [71] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:4::loop:9::plexSort:23 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [73] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:4::loop:9::plexSort:23 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [78] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:4::loop:9::plexSort:23 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Statement [82] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 [ ] ( main:4::init:7 [ ] ) always clobbers reg byte a 
Statement [85] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:4::init:7 [ init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [86] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$8 ] ( main:4::init:7 [ init::sx#2 init::xp#2 init::$8 ] ) always clobbers reg byte a 
Statement [87] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:4::init:7 [ init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [88] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:4::init:7 [ init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [91] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:4::init:7 [ ] ) always clobbers reg byte a 
Statement [93] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:4::init:7 [ init::ss#2 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] : zp ZP_BYTE:3 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ] : zp ZP_BYTE:5 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ] : zp ZP_BYTE:6 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ] : zp ZP_BYTE:7 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ] : zp ZP_BYTE:8 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ] : zp ZP_BYTE:9 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ] : zp ZP_BYTE:10 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:11 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] : zp ZP_BYTE:11 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:12 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] : zp ZP_BYTE:12 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ init::sx#2 init::sx#1 ] : zp ZP_BYTE:13 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:14 [ init::xp#2 init::xp#1 ] : zp ZP_WORD:14 , 
Potential registers zp ZP_BYTE:16 [ init::ss#2 init::ss#1 ] : zp ZP_BYTE:16 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:17 [ plexInit::i#2 plexInit::i#1 ] : zp ZP_BYTE:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:18 [ loop::$4 ] : zp ZP_BYTE:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ] : zp ZP_BYTE:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ] : zp ZP_BYTE:20 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ] : zp ZP_BYTE:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:22 [ plexShowSprite::plexFreeAdd1_$0#0 ] : zp ZP_BYTE:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:23 [ plexShowSprite::plexFreeAdd1_$1#0 ] : zp ZP_BYTE:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ] : zp ZP_BYTE:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:25 [ plexShowSprite::$11 ] : zp ZP_BYTE:25 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:26 [ plexShowSprite::$2 ] : zp ZP_BYTE:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:27 [ plexShowSprite::$3 ] : zp ZP_BYTE:27 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:28 [ plexShowSprite::$9 ] : zp ZP_BYTE:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:29 [ plexShowSprite::$5 ] : zp ZP_BYTE:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ] : zp ZP_BYTE:30 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:31 [ plexSort::nxt_y#0 ] : zp ZP_BYTE:31 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:32 [ plexSort::s#2 ] : zp ZP_BYTE:32 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:33 [ init::$8 ] : zp ZP_BYTE:33 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [plexSort] 3,622.83: zp ZP_BYTE:11 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] 303: zp ZP_BYTE:12 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] 202: zp ZP_BYTE:32 [ plexSort::s#2 ] 193.58: zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ] 150.38: zp ZP_BYTE:31 [ plexSort::nxt_y#0 ] 30.3: zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ] 
Uplift Scope [loop] 551: zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ] 252.5: zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ] 246.33: zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] 202: zp ZP_BYTE:18 [ loop::$4 ] 185.17: zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ] 5.13: zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Uplift Scope [init] 33: zp ZP_BYTE:16 [ init::ss#2 init::ss#1 ] 25.3: zp ZP_BYTE:13 [ init::sx#2 init::sx#1 ] 22: zp ZP_BYTE:33 [ init::$8 ] 15.58: zp ZP_WORD:14 [ init::xp#2 init::xp#1 ] 
Uplift Scope [] 26.88: zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ] 25.28: zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ] 15.99: zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ] 15.16: zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ] 
Uplift Scope [plexInit] 38.5: zp ZP_BYTE:17 [ plexInit::i#2 plexInit::i#1 ] 
Uplift Scope [plexShowSprite] 4: zp ZP_BYTE:22 [ plexShowSprite::plexFreeAdd1_$0#0 ] 4: zp ZP_BYTE:23 [ plexShowSprite::plexFreeAdd1_$1#0 ] 4: zp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ] 4: zp ZP_BYTE:26 [ plexShowSprite::$2 ] 4: zp ZP_BYTE:27 [ plexShowSprite::$3 ] 4: zp ZP_BYTE:28 [ plexShowSprite::$9 ] 4: zp ZP_BYTE:29 [ plexShowSprite::$5 ] 3: zp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ] 2: zp ZP_BYTE:25 [ plexShowSprite::$11 ] 0.55: zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ] 
Uplift Scope [main] 

Uplifting [plexSort] best 82384 combination reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] zp ZP_BYTE:32 [ plexSort::s#2 ] zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ] zp ZP_BYTE:31 [ plexSort::nxt_y#0 ] zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ] 
Limited combination testing to 10 combinations of 972 possible.
Uplifting [loop] best 81184 combination zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ] reg byte y [ loop::sy#2 loop::sy#1 ] zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] zp ZP_BYTE:18 [ loop::$4 ] zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ] zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Limited combination testing to 10 combinations of 1296 possible.
Uplifting [init] best 80934 combination reg byte x [ init::ss#2 init::ss#1 ] reg byte x [ init::sx#2 init::sx#1 ] zp ZP_BYTE:33 [ init::$8 ] zp ZP_WORD:14 [ init::xp#2 init::xp#1 ] 
Limited combination testing to 10 combinations of 36 possible.
Uplifting [] best 80934 combination zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ] zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ] zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ] zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ] 
Limited combination testing to 10 combinations of 81 possible.
Uplifting [plexInit] best 80814 combination reg byte x [ plexInit::i#2 plexInit::i#1 ] 
Uplifting [plexShowSprite] best 80804 combination reg byte a [ plexShowSprite::plexFreeAdd1_$0#0 ] reg byte x [ plexShowSprite::plexFreeAdd1_$1#0 ] zp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ] zp ZP_BYTE:26 [ plexShowSprite::$2 ] zp ZP_BYTE:27 [ plexShowSprite::$3 ] zp ZP_BYTE:28 [ plexShowSprite::$9 ] zp ZP_BYTE:29 [ plexShowSprite::$5 ] zp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ] zp ZP_BYTE:25 [ plexShowSprite::$11 ] zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ] 
Limited combination testing to 10 combinations of 589824 possible.
Uplifting [main] best 80804 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ]
Uplifting [loop] best 80804 combination zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Uplifting [loop] best 80074 combination reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:18 [ loop::$4 ]
Uplifting [loop] best 79474 combination reg byte a [ loop::$4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:32 [ plexSort::s#2 ]
Uplifting [plexSort] best 78874 combination reg byte x [ plexSort::s#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ]
Uplifting [plexSort] best 78874 combination zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ]
Uplifting [loop] best 78874 combination zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:31 [ plexSort::nxt_y#0 ]
Uplifting [plexSort] best 78874 combination zp ZP_BYTE:31 [ plexSort::nxt_y#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:30 [ plexSort::nxt_idx#0 ]
Uplifting [plexSort] best 78874 combination zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
Uplifting [] best 78874 combination zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ]
Uplifting [] best 78874 combination zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:33 [ init::$8 ]
Uplifting [init] best 78834 combination reg byte a [ init::$8 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ]
Uplifting [] best 78834 combination zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ]
Uplifting [] best 78834 combination zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Uplifting [loop] best 78834 combination zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ]
Uplifting [plexShowSprite] best 78828 combination reg byte a [ plexShowSprite::xpos_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:26 [ plexShowSprite::$2 ]
Uplifting [plexShowSprite] best 78822 combination reg byte a [ plexShowSprite::$2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:27 [ plexShowSprite::$3 ]
Uplifting [plexShowSprite] best 78816 combination reg byte a [ plexShowSprite::$3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:28 [ plexShowSprite::$9 ]
Uplifting [plexShowSprite] best 78810 combination reg byte a [ plexShowSprite::$9 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:29 [ plexShowSprite::$5 ]
Uplifting [plexShowSprite] best 78804 combination reg byte x [ plexShowSprite::$5 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Uplifting [plexShowSprite] best 78795 combination reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:25 [ plexShowSprite::$11 ]
Uplifting [plexShowSprite] best 78788 combination reg byte x [ plexShowSprite::$11 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ]
Uplifting [plexShowSprite] best 78788 combination zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ] 
Allocated (was zp ZP_BYTE:5) zp ZP_BYTE:3 [ plex_free_next#17 plex_free_next#13 ]
Allocated (was zp ZP_BYTE:6) zp ZP_BYTE:4 [ plex_sprite_idx#42 plex_sprite_idx#15 ]
Allocated (was zp ZP_BYTE:7) zp ZP_BYTE:5 [ plex_show_idx#42 plex_show_idx#15 ]
Allocated (was zp ZP_BYTE:8) zp ZP_BYTE:6 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
Allocated (was zp ZP_BYTE:9) zp ZP_BYTE:7 [ loop::ss#5 loop::ss#1 ]
Allocated (was zp ZP_BYTE:10) zp ZP_BYTE:8 [ plexSort::m#2 plexSort::m#1 ]
Allocated (was zp ZP_WORD:14) zp ZP_WORD:9 [ init::xp#2 init::xp#1 ]
Allocated (was zp ZP_BYTE:19) zp ZP_BYTE:11 [ loop::plexFreeNextYpos1_return#0 ]
Allocated (was zp ZP_BYTE:20) zp ZP_BYTE:12 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated (was zp ZP_BYTE:30) zp ZP_BYTE:13 [ plexSort::nxt_idx#0 ]
Allocated (was zp ZP_BYTE:31) zp ZP_BYTE:14 [ plexSort::nxt_y#0 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// A simple usage of the flexible sprite multiplexer routine
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label D011 = $d011
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  // Location of screen & sprites
  .label SCREEN = $400
  .label SPRITE = $2000
  .label YSIN = $2100
  .label PLEX_SCREEN_PTR = SCREEN+$3f8
  .label plex_sprite_msb = 6
  .label plex_free_next = 3
  .label plex_sprite_idx = 4
  .label plex_show_idx = 5
//SEG3 @begin
bbegin:
  jmp b1
//SEG4 @1
b1:
//SEG5 kickasm(location (const byte*) YSIN#0) {{ .var min = 50     .var max = 250-21     .var ampl = max-min;     .for(var i=0;i<256;i++)         .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))  }}
//SEG6 kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
//SEG7 [3] phi from @1 to @2 [phi:@1->@2]
b2_from_b1:
  jmp b2
//SEG8 @2
b2:
//SEG9 [4] call main 
  jsr main
//SEG10 [5] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
//SEG11 @end
bend:
//SEG12 main
main: {
  //SEG13 asm { sei  }
    sei
  //SEG14 [7] call init 
    jsr init
  //SEG15 [8] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG16 main::@1
  b1:
  //SEG17 [9] call loop 
  //SEG18 [11] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from_b1:
    jsr loop
    jmp breturn
  //SEG19 main::@return
  breturn:
  //SEG20 [10] return 
    rts
}
//SEG21 loop
// The raster loop
loop: {
    .label sin_idx = 2
    .label plexFreeNextYpos1_return = $b
    .label ss = 7
  //SEG22 [12] phi from loop to loop::@1 [phi:loop->loop::@1]
  b1_from_loop:
  //SEG23 [12] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta sin_idx
    jmp b1
  //SEG24 loop::@1
  b1:
    jmp b2
  //SEG25 loop::@2
  b2:
  //SEG26 [13] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    jmp b3
  //SEG27 loop::@3
  b3:
  //SEG28 [14] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG29 [15] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx sin_idx
  //SEG30 [16] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  b4_from_b3:
  //SEG31 [16] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
  //SEG32 [16] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp b4
  //SEG33 [16] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  b4_from_b4:
  //SEG34 [16] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
  //SEG35 [16] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp b4
  //SEG36 loop::@4
  b4:
  //SEG37 [17] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
  //SEG38 [18] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
  //SEG39 [19] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG40 [20] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne b4_from_b4
    jmp b5
  //SEG41 loop::@5
  b5:
  //SEG42 [21] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc sin_idx
  //SEG43 [22] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG44 [23] call plexSort 
  //SEG45 [61] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from_b5:
    jsr plexSort
    jmp b11
  //SEG46 loop::@11
  b11:
  //SEG47 [24] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp b6
  //SEG48 loop::@6
  b6:
  //SEG49 [25] (byte~) loop::$4 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 -- vbuaa=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
  //SEG50 [26] if((byte~) loop::$4!=(byte) 0) goto loop::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b6
  //SEG51 [27] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
  b7_from_b6:
  //SEG52 [27] phi (byte) loop::ss#5 = (byte) 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta ss
  //SEG53 [27] phi (byte) plex_sprite_msb#42 = (byte) 1 [phi:loop::@6->loop::@7#1] -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG54 [27] phi (byte) plex_show_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#2] -- vbuz1=vbuc1 
    lda #0
    sta plex_show_idx
  //SEG55 [27] phi (byte) plex_sprite_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#3] -- vbuz1=vbuc1 
    lda #0
    sta plex_sprite_idx
  //SEG56 [27] phi (byte) plex_free_next#17 = (byte) 0 [phi:loop::@6->loop::@7#4] -- vbuz1=vbuc1 
    lda #0
    sta plex_free_next
    jmp b7
  // Show the sprites
  //SEG57 [27] phi from loop::@12 to loop::@7 [phi:loop::@12->loop::@7]
  b7_from_b12:
  //SEG58 [27] phi (byte) loop::ss#5 = (byte) loop::ss#1 [phi:loop::@12->loop::@7#0] -- register_copy 
  //SEG59 [27] phi (byte) plex_sprite_msb#42 = (byte) plex_sprite_msb#16 [phi:loop::@12->loop::@7#1] -- register_copy 
  //SEG60 [27] phi (byte) plex_show_idx#42 = (byte) plex_show_idx#15 [phi:loop::@12->loop::@7#2] -- register_copy 
  //SEG61 [27] phi (byte) plex_sprite_idx#42 = (byte) plex_sprite_idx#15 [phi:loop::@12->loop::@7#3] -- register_copy 
  //SEG62 [27] phi (byte) plex_free_next#17 = (byte) plex_free_next#13 [phi:loop::@12->loop::@7#4] -- register_copy 
    jmp b7
  //SEG63 loop::@7
  b7:
  //SEG64 [28] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp plexFreeNextYpos1
  //SEG65 loop::plexFreeNextYpos1
  plexFreeNextYpos1:
  //SEG66 [29] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy plex_free_next
    lda PLEX_FREE_YPOS,y
    sta plexFreeNextYpos1_return
    jmp b8
  //SEG67 loop::@8
  b8:
  //SEG68 [30] if(*((const byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp plexFreeNextYpos1_return
    bcc b8
    jmp b9
  //SEG69 loop::@9
  b9:
  //SEG70 [31] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG71 [32] call plexShowSprite 
    jsr plexShowSprite
    jmp b12
  //SEG72 loop::@12
  b12:
  //SEG73 [33] (byte) loop::ss#1 ← ++ (byte) loop::ss#5 -- vbuz1=_inc_vbuz1 
    inc ss
  //SEG74 [34] if((byte) loop::ss#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp ss
    bne b7_from_b12
    jmp b10
  //SEG75 loop::@10
  b10:
  //SEG76 [35] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG77 [12] phi from loop::@10 to loop::@1 [phi:loop::@10->loop::@1]
  b1_from_b10:
  //SEG78 [12] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@10->loop::@1#0] -- register_copy 
    jmp b1
}
//SEG79 plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = $c
  //SEG80 [36] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda plex_sprite_idx
    asl
    sta plex_sprite_idx2
  //SEG81 [37] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- vbuaa=pbuc1_derefidx_pbuc2_derefidx_vbuz1 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
  //SEG82 [38] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
  //SEG83 plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
  //SEG84 [39] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
  //SEG85 [40] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_free_next
    sta PLEX_FREE_YPOS,y
  //SEG86 [41] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#17 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_free_next
    inx
  //SEG87 [42] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax plex_free_next
    jmp b4
  //SEG88 plexShowSprite::@4
  b4:
  //SEG89 [43] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_pbuc3_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
  //SEG90 [44] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy plex_show_idx
    lda PLEX_SORTED_IDX,y
  //SEG91 [45] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
  //SEG92 [46] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
  //SEG93 [47] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_XPOS,y
  //SEG94 [48] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
  //SEG95 [49] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b1
    jmp b3
  //SEG96 plexShowSprite::@3
  b3:
  //SEG97 [50] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor plex_sprite_msb
  //SEG98 [51] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    jmp b2
  //SEG99 plexShowSprite::@2
  b2:
  //SEG100 [52] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#42 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_sprite_idx
    inx
  //SEG101 [53] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax plex_sprite_idx
  //SEG102 [54] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#42 -- vbuz1=_inc_vbuz1 
    inc plex_show_idx
  //SEG103 [55] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#42 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl plex_sprite_msb
  //SEG104 [56] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5 -- vbuz1_neq_0_then_la1 
    lda plex_sprite_msb
    cmp #0
    bne b5_from_b2
  //SEG105 [58] phi from plexShowSprite::@2 to plexShowSprite::@return [phi:plexShowSprite::@2->plexShowSprite::@return]
  breturn_from_b2:
  //SEG106 [58] phi (byte) plex_sprite_msb#16 = (byte) 1 [phi:plexShowSprite::@2->plexShowSprite::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
    jmp breturn
  //SEG107 [57] phi from plexShowSprite::@2 to plexShowSprite::@5 [phi:plexShowSprite::@2->plexShowSprite::@5]
  b5_from_b2:
    jmp b5
  //SEG108 plexShowSprite::@5
  b5:
  //SEG109 [58] phi from plexShowSprite::@5 to plexShowSprite::@return [phi:plexShowSprite::@5->plexShowSprite::@return]
  breturn_from_b5:
  //SEG110 [58] phi (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@5->plexShowSprite::@return#0] -- register_copy 
    jmp breturn
  //SEG111 plexShowSprite::@return
  breturn:
  //SEG112 [59] return 
    rts
  //SEG113 plexShowSprite::@1
  b1:
  //SEG114 [60] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
//SEG115 plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $d
    .label nxt_y = $e
    .label m = 8
  //SEG116 [62] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  b1_from_plexSort:
  //SEG117 [62] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta m
    jmp b1
  //SEG118 [62] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  b1_from_b2:
  //SEG119 [62] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp b1
  //SEG120 plexSort::@1
  b1:
  //SEG121 [63] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy m
    lda PLEX_SORTED_IDX+1,y
    sta nxt_idx
  //SEG122 [64] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy nxt_idx
    lda PLEX_YPOS,y
    sta nxt_y
  //SEG123 [65] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    lda nxt_y
    ldx m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
    jmp b5
  //SEG124 plexSort::@5
  b5:
  //SEG125 [66] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
    ldx m
  //SEG126 [67] phi from plexSort::@5 plexSort::@6 to plexSort::@3 [phi:plexSort::@5/plexSort::@6->plexSort::@3]
  b3_from_b5:
  b3_from_b6:
  //SEG127 [67] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@6->plexSort::@3#0] -- register_copy 
    jmp b3
  //SEG128 plexSort::@3
  b3:
  //SEG129 [68] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
  //SEG130 [69] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
  //SEG131 [70] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq b4
    jmp b6
  //SEG132 plexSort::@6
  b6:
  //SEG133 [71] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_pbuc2_derefidx_vbuxx_then_la1 
    lda nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3_from_b6
    jmp b4
  //SEG134 plexSort::@4
  b4:
  //SEG135 [72] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
  //SEG136 [73] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda nxt_idx
    sta PLEX_SORTED_IDX,x
    jmp b2
  //SEG137 plexSort::@2
  b2:
  //SEG138 [74] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG139 [75] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp m
    bne b1_from_b2
  //SEG140 [76] phi from plexSort::@2 to plexSort::plexFreePrepare1 [phi:plexSort::@2->plexSort::plexFreePrepare1]
  plexFreePrepare1_from_b2:
    jmp plexFreePrepare1
  //SEG141 plexSort::plexFreePrepare1
  plexFreePrepare1:
  //SEG142 [77] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1:
  //SEG143 [77] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp plexFreePrepare1_b1
  //SEG144 [77] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1_b1:
  //SEG145 [77] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1_b1
  //SEG146 plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
  //SEG147 [78] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
  //SEG148 [79] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG149 [80] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1_b1_from_plexFreePrepare1_b1
    jmp breturn
  //SEG150 plexSort::@return
  breturn:
  //SEG151 [81] return 
    rts
}
//SEG152 init
// Initialize the program
init: {
    .label xp = 9
  //SEG153 [82] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
  //SEG154 [83] call plexInit 
  //SEG155 [97] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
  //SEG156 [84] phi from init to init::@1 [phi:init->init::@1]
  b1_from_init:
  //SEG157 [84] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #$20
    sta xp
    lda #0
    sta xp+1
  //SEG158 [84] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG159 [84] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
  //SEG160 [84] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
  //SEG161 [84] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp b1
  //SEG162 init::@1
  b1:
  //SEG163 [85] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta PLEX_PTR,x
  //SEG164 [86] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG165 [87] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda xp
    sta PLEX_XPOS,y
    lda xp+1
    sta PLEX_XPOS+1,y
  //SEG166 [88] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc xp
    sta xp
    bcc !+
    inc xp+1
  !:
  //SEG167 [89] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG168 [90] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1_from_b1
    jmp b2
  //SEG169 init::@2
  b2:
  //SEG170 [91] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
  //SEG171 [92] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
  //SEG172 [92] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b3
  //SEG173 [92] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  b3_from_b3:
  //SEG174 [92] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp b3
  //SEG175 init::@3
  b3:
  //SEG176 [93] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
  //SEG177 [94] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG178 [95] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b3_from_b3
    jmp breturn
  //SEG179 init::@return
  breturn:
  //SEG180 [96] return 
    rts
}
//SEG181 plexInit
// Initialize the multiplexer data structures
plexInit: {
  //SEG182 [98] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
  //SEG183 plexInit::plexSetScreen1
  plexSetScreen1:
  //SEG184 [99] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  b1_from_plexSetScreen1:
  //SEG185 [99] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG186 [99] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  b1_from_b1:
  //SEG187 [99] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp b1
  //SEG188 plexInit::@1
  b1:
  //SEG189 [100] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
  //SEG190 [101] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG191 [102] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1_from_b1
    jmp breturn
  //SEG192 plexInit::@return
  breturn:
  //SEG193 [103] return 
    rts
}
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = YSIN "YSIN"
  .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b11
Removing instruction jmp b6
Removing instruction jmp b7
Removing instruction jmp plexFreeNextYpos1
Removing instruction jmp b8
Removing instruction jmp b9
Removing instruction jmp b12
Removing instruction jmp b10
Removing instruction jmp plexFreeAdd1
Removing instruction jmp b4
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp b5
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b6
Removing instruction jmp b4
Removing instruction jmp b2
Removing instruction jmp plexFreePrepare1
Removing instruction jmp plexFreePrepare1_b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp plexSetScreen1
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Replacing instruction ldy nxt_idx with TAY
Removing instruction lda nxt_y
Replacing instruction ldx #0 with TAX
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b4_from_b4 with b4
Replacing label b7_from_b12 with b7
Replacing label b1 with b2
Replacing label b5_from_b2 with b5
Replacing label breturn with b5
Replacing label b3_from_b6 with b3
Replacing label b1_from_b2 with b1
Replacing label plexFreePrepare1_b1_from_plexFreePrepare1_b1 with plexFreePrepare1_b1
Replacing label b1_from_b1 with b1
Replacing label b3_from_b3 with b3
Replacing label b1_from_b1 with b1
Removing instruction b1:
Removing instruction b2_from_b1:
Removing instruction b2:
Removing instruction bend_from_b2:
Removing instruction b1_from_main:
Removing instruction loop_from_b1:
Removing instruction b1:
Removing instruction b4_from_b4:
Removing instruction b7_from_b12:
Removing instruction b5_from_b2:
Removing instruction breturn_from_b5:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction b3_from_b5:
Removing instruction b3_from_b6:
Removing instruction plexFreePrepare1_from_b2:
Removing instruction plexFreePrepare1_b1_from_plexFreePrepare1:
Removing instruction plexFreePrepare1_b1_from_plexFreePrepare1_b1:
Removing instruction b1_from_b1:
Removing instruction b3_from_b3:
Removing instruction plexSetScreen1_from_plexInit:
Removing instruction b1_from_plexSetScreen1:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_loop:
Removing instruction b3:
Removing instruction b4_from_b3:
Removing instruction b5:
Removing instruction plexSort_from_b5:
Removing instruction b11:
Removing instruction b7_from_b6:
Removing instruction plexFreeNextYpos1:
Removing instruction b9:
Removing instruction b12:
Removing instruction b10:
Removing instruction b1_from_b10:
Removing instruction plexFreeAdd1:
Removing instruction b4:
Removing instruction b3:
Removing instruction breturn_from_b2:
Removing instruction b1_from_plexSort:
Removing instruction b5:
Removing instruction b6:
Removing instruction plexFreePrepare1:
Removing instruction breturn:
Removing instruction plexInit_from_init:
Removing instruction b1_from_init:
Removing instruction b2:
Removing instruction b3_from_b2:
Removing instruction breturn:
Removing instruction plexSetScreen1:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Replacing jump to rts with rts in jmp b5
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction jmp b4
Removing instruction jmp b7
Removing instruction jmp b1
Removing instruction jmp plexFreePrepare1_b1
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldx m
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @2
(label) @begin
(label) @end
(byte) BLACK
(const byte) BLACK#0 BLACK = (byte) 0
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = (byte*) 53280
(byte*) D011
(const byte*) D011#0 D011 = (byte*) 53265
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte) 5
(byte) PLEX_COUNT
(const byte) PLEX_COUNT#0 PLEX_COUNT = (byte) $20
(byte[8]) PLEX_FREE_YPOS
(const byte[8]) PLEX_FREE_YPOS#0 PLEX_FREE_YPOS = { fill( 8, 0) }
(byte[PLEX_COUNT#0]) PLEX_PTR
(const byte[PLEX_COUNT#0]) PLEX_PTR#0 PLEX_PTR = { fill( PLEX_COUNT#0, 0) }
(byte*) PLEX_SCREEN_PTR
(const byte*) PLEX_SCREEN_PTR#1 PLEX_SCREEN_PTR = (const byte*) SCREEN#0+(word) $3f8
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 PLEX_SORTED_IDX = { fill( PLEX_COUNT#0, 0) }
(word[PLEX_COUNT#0]) PLEX_XPOS
(const word[PLEX_COUNT#0]) PLEX_XPOS#0 PLEX_XPOS = { fill( PLEX_COUNT#0, 0) }
(byte[PLEX_COUNT#0]) PLEX_YPOS
(const byte[PLEX_COUNT#0]) PLEX_YPOS#0 PLEX_YPOS = { fill( PLEX_COUNT#0, 0) }
(byte*) RASTER
(const byte*) RASTER#0 RASTER = (byte*) 53266
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = (byte*) 1024
(byte*) SPRITE
(const byte*) SPRITE#0 SPRITE = (byte*) 8192
(byte*) SPRITES_COLS
(const byte*) SPRITES_COLS#0 SPRITES_COLS = (byte*) 53287
(byte*) SPRITES_ENABLE
(const byte*) SPRITES_ENABLE#0 SPRITES_ENABLE = (byte*) 53269
(byte*) SPRITES_XMSB
(const byte*) SPRITES_XMSB#0 SPRITES_XMSB = (byte*) 53264
(byte*) SPRITES_XPOS
(const byte*) SPRITES_XPOS#0 SPRITES_XPOS = (byte*) 53248
(byte*) SPRITES_YPOS
(const byte*) SPRITES_YPOS#0 SPRITES_YPOS = (byte*) 53249
(byte) VIC_DEN
(const byte) VIC_DEN#0 VIC_DEN = (byte) $10
(byte) VIC_RSEL
(const byte) VIC_RSEL#0 VIC_RSEL = (byte) 8
(byte) VIC_RST8
(const byte) VIC_RST8#0 VIC_RST8 = (byte) $80
(byte*) YSIN
(const byte*) YSIN#0 YSIN = (byte*) 8448
(void()) init()
(byte~) init::$8 reg byte a 22.0
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@return
(byte) init::ss
(byte) init::ss#1 reg byte x 16.5
(byte) init::ss#2 reg byte x 16.5
(byte) init::sx
(byte) init::sx#1 reg byte x 16.5
(byte) init::sx#2 reg byte x 8.8
(word) init::xp
(word) init::xp#1 xp zp ZP_WORD:9 7.333333333333333
(word) init::xp#2 xp zp ZP_WORD:9 8.25
(void()) loop()
(byte~) loop::$4 reg byte a 202.0
(label) loop::@1
(label) loop::@10
(label) loop::@11
(label) loop::@12
(label) loop::@2
(label) loop::@3
(label) loop::@4
(label) loop::@5
(label) loop::@6
(label) loop::@7
(label) loop::@8
(label) loop::@9
(label) loop::plexFreeNextYpos1
(byte) loop::plexFreeNextYpos1_return
(byte) loop::plexFreeNextYpos1_return#0 plexFreeNextYpos1_return zp ZP_BYTE:11 551.0
(byte) loop::rasterY
(byte) loop::sin_idx
(byte) loop::sin_idx#1 sin_idx zp ZP_BYTE:2 1.4666666666666666
(byte) loop::sin_idx#6 sin_idx zp ZP_BYTE:2 3.666666666666667
(byte) loop::ss
(byte) loop::ss#1 ss zp ZP_BYTE:7 151.5
(byte) loop::ss#5 ss zp ZP_BYTE:7 33.666666666666664
(byte) loop::sy
(byte) loop::sy#1 reg byte y 151.5
(byte) loop::sy#2 reg byte y 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 reg byte x 67.33333333333333
(byte) loop::y_idx#2 reg byte x 157.0
(byte~) loop::y_idx#4 reg byte x 22.0
(void()) main()
(label) main::@1
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(label) plexInit::@1
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#1 reg byte x 16.5
(byte) plexInit::i#2 reg byte x 22.0
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 reg byte x 2.0
(byte~) plexShowSprite::$2 reg byte a 4.0
(byte~) plexShowSprite::$3 reg byte a 4.0
(byte~) plexShowSprite::$5 reg byte x 4.0
(byte~) plexShowSprite::$9 reg byte a 4.0
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@3
(label) plexShowSprite::@4
(label) plexShowSprite::@5
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(number~) plexShowSprite::plexFreeAdd1_$0
(byte~) plexShowSprite::plexFreeAdd1_$0#0 reg byte a 4.0
(number~) plexShowSprite::plexFreeAdd1_$1
(byte~) plexShowSprite::plexFreeAdd1_$1#0 reg byte x 4.0
(number~) plexShowSprite::plexFreeAdd1_$2
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 reg byte a 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 plex_sprite_idx2 zp ZP_BYTE:12 0.5454545454545454
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 reg byte a 4.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#1 m zp ZP_BYTE:8 151.5
(byte) plexSort::m#2 m zp ZP_BYTE:8 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 nxt_idx zp ZP_BYTE:13 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 nxt_y zp ZP_BYTE:14 150.375
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(label) plexSort::plexFreePrepare1_@1
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 reg byte x 151.5
(byte) plexSort::plexFreePrepare1_s#2 reg byte x 151.5
(byte) plexSort::s
(byte) plexSort::s#1 reg byte x 1368.3333333333335
(byte) plexSort::s#2 reg byte x 202.0
(byte) plexSort::s#3 reg byte x 2052.5
(byte~) plexSort::s#6 reg byte x 202.0
(byte) plex_free_next
(byte) plex_free_next#13 plex_free_next zp ZP_BYTE:3 4.681818181818182
(byte) plex_free_next#17 plex_free_next zp ZP_BYTE:3 20.599999999999998
(byte) plex_show_idx
(byte) plex_show_idx#15 plex_show_idx zp ZP_BYTE:5 11.444444444444443
(byte) plex_show_idx#42 plex_show_idx zp ZP_BYTE:5 4.541666666666665
(byte) plex_sprite_idx
(byte) plex_sprite_idx#15 plex_sprite_idx zp ZP_BYTE:4 10.299999999999999
(byte) plex_sprite_idx#42 plex_sprite_idx zp ZP_BYTE:4 4.863636363636363
(byte) plex_sprite_msb
(byte) plex_sprite_msb#16 plex_sprite_msb zp ZP_BYTE:6 20.599999999999998
(byte) plex_sprite_msb#3 plex_sprite_msb zp ZP_BYTE:6 2.0
(byte) plex_sprite_msb#42 plex_sprite_msb zp ZP_BYTE:6 4.28

zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
reg byte y [ loop::sy#2 loop::sy#1 ]
zp ZP_BYTE:3 [ plex_free_next#17 plex_free_next#13 ]
zp ZP_BYTE:4 [ plex_sprite_idx#42 plex_sprite_idx#15 ]
zp ZP_BYTE:5 [ plex_show_idx#42 plex_show_idx#15 ]
zp ZP_BYTE:6 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
zp ZP_BYTE:7 [ loop::ss#5 loop::ss#1 ]
zp ZP_BYTE:8 [ plexSort::m#2 plexSort::m#1 ]
reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
reg byte x [ init::sx#2 init::sx#1 ]
zp ZP_WORD:9 [ init::xp#2 init::xp#1 ]
reg byte x [ init::ss#2 init::ss#1 ]
reg byte x [ plexInit::i#2 plexInit::i#1 ]
reg byte a [ loop::$4 ]
zp ZP_BYTE:11 [ loop::plexFreeNextYpos1_return#0 ]
zp ZP_BYTE:12 [ plexShowSprite::plex_sprite_idx2#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$0#0 ]
reg byte x [ plexShowSprite::plexFreeAdd1_$1#0 ]
reg byte a [ plexShowSprite::xpos_idx#0 ]
reg byte x [ plexShowSprite::$11 ]
reg byte a [ plexShowSprite::$2 ]
reg byte a [ plexShowSprite::$3 ]
reg byte a [ plexShowSprite::$9 ]
reg byte x [ plexShowSprite::$5 ]
zp ZP_BYTE:13 [ plexSort::nxt_idx#0 ]
zp ZP_BYTE:14 [ plexSort::nxt_y#0 ]
reg byte x [ plexSort::s#2 ]
reg byte a [ init::$8 ]


FINAL ASSEMBLER
Score: 60156

//SEG0 File Comments
// A simple usage of the flexible sprite multiplexer routine
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label D011 = $d011
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  // Location of screen & sprites
  .label SCREEN = $400
  .label SPRITE = $2000
  .label YSIN = $2100
  .label PLEX_SCREEN_PTR = SCREEN+$3f8
  .label plex_sprite_msb = 6
  .label plex_free_next = 3
  .label plex_sprite_idx = 4
  .label plex_show_idx = 5
//SEG3 @begin
//SEG4 @1
//SEG5 kickasm(location (const byte*) YSIN#0) {{ .var min = 50     .var max = 250-21     .var ampl = max-min;     .for(var i=0;i<256;i++)         .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))  }}
//SEG6 kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
//SEG7 [3] phi from @1 to @2 [phi:@1->@2]
//SEG8 @2
//SEG9 [4] call main 
//SEG10 [5] phi from @2 to @end [phi:@2->@end]
//SEG11 @end
//SEG12 main
main: {
  //SEG13 asm { sei  }
    sei
  //SEG14 [7] call init 
    jsr init
  //SEG15 [8] phi from main to main::@1 [phi:main->main::@1]
  //SEG16 main::@1
  //SEG17 [9] call loop 
  //SEG18 [11] phi from main::@1 to loop [phi:main::@1->loop]
    jsr loop
  //SEG19 main::@return
  //SEG20 [10] return 
    rts
}
//SEG21 loop
// The raster loop
loop: {
    .label sin_idx = 2
    .label plexFreeNextYpos1_return = $b
    .label ss = 7
  //SEG22 [12] phi from loop to loop::@1 [phi:loop->loop::@1]
  //SEG23 [12] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta sin_idx
  //SEG24 loop::@1
  //SEG25 loop::@2
  b2:
  //SEG26 [13] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
  //SEG27 loop::@3
  //SEG28 [14] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG29 [15] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx sin_idx
  //SEG30 [16] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  //SEG31 [16] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
  //SEG32 [16] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
  //SEG33 [16] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  //SEG34 [16] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
  //SEG35 [16] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
  //SEG36 loop::@4
  b4:
  //SEG37 [17] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte*) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
  //SEG38 [18] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
  //SEG39 [19] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
  //SEG40 [20] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne b4
  //SEG41 loop::@5
  //SEG42 [21] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc sin_idx
  //SEG43 [22] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG44 [23] call plexSort 
  //SEG45 [61] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
    jsr plexSort
  //SEG46 loop::@11
  //SEG47 [24] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG48 loop::@6
  b6:
  //SEG49 [25] (byte~) loop::$4 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 -- vbuaa=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
  //SEG50 [26] if((byte~) loop::$4!=(byte) 0) goto loop::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b6
  //SEG51 [27] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
  //SEG52 [27] phi (byte) loop::ss#5 = (byte) 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta ss
  //SEG53 [27] phi (byte) plex_sprite_msb#42 = (byte) 1 [phi:loop::@6->loop::@7#1] -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
  //SEG54 [27] phi (byte) plex_show_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#2] -- vbuz1=vbuc1 
    lda #0
    sta plex_show_idx
  //SEG55 [27] phi (byte) plex_sprite_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#3] -- vbuz1=vbuc1 
    sta plex_sprite_idx
  //SEG56 [27] phi (byte) plex_free_next#17 = (byte) 0 [phi:loop::@6->loop::@7#4] -- vbuz1=vbuc1 
    sta plex_free_next
  // Show the sprites
  //SEG57 [27] phi from loop::@12 to loop::@7 [phi:loop::@12->loop::@7]
  //SEG58 [27] phi (byte) loop::ss#5 = (byte) loop::ss#1 [phi:loop::@12->loop::@7#0] -- register_copy 
  //SEG59 [27] phi (byte) plex_sprite_msb#42 = (byte) plex_sprite_msb#16 [phi:loop::@12->loop::@7#1] -- register_copy 
  //SEG60 [27] phi (byte) plex_show_idx#42 = (byte) plex_show_idx#15 [phi:loop::@12->loop::@7#2] -- register_copy 
  //SEG61 [27] phi (byte) plex_sprite_idx#42 = (byte) plex_sprite_idx#15 [phi:loop::@12->loop::@7#3] -- register_copy 
  //SEG62 [27] phi (byte) plex_free_next#17 = (byte) plex_free_next#13 [phi:loop::@12->loop::@7#4] -- register_copy 
  //SEG63 loop::@7
  b7:
  //SEG64 [28] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG65 loop::plexFreeNextYpos1
  //SEG66 [29] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy plex_free_next
    lda PLEX_FREE_YPOS,y
    sta plexFreeNextYpos1_return
  //SEG67 loop::@8
  b8:
  //SEG68 [30] if(*((const byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp plexFreeNextYpos1_return
    bcc b8
  //SEG69 loop::@9
  //SEG70 [31] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
  //SEG71 [32] call plexShowSprite 
    jsr plexShowSprite
  //SEG72 loop::@12
  //SEG73 [33] (byte) loop::ss#1 ← ++ (byte) loop::ss#5 -- vbuz1=_inc_vbuz1 
    inc ss
  //SEG74 [34] if((byte) loop::ss#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp ss
    bne b7
  //SEG75 loop::@10
  //SEG76 [35] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG77 [12] phi from loop::@10 to loop::@1 [phi:loop::@10->loop::@1]
  //SEG78 [12] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@10->loop::@1#0] -- register_copy 
    jmp b2
}
//SEG79 plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = $c
  //SEG80 [36] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda plex_sprite_idx
    asl
    sta plex_sprite_idx2
  //SEG81 [37] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- vbuaa=pbuc1_derefidx_pbuc2_derefidx_vbuz1 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
  //SEG82 [38] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_YPOS,y
  //SEG83 plexShowSprite::plexFreeAdd1
  //SEG84 [39] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
  //SEG85 [40] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_free_next
    sta PLEX_FREE_YPOS,y
  //SEG86 [41] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#17 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_free_next
    inx
  //SEG87 [42] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax plex_free_next
  //SEG88 plexShowSprite::@4
  //SEG89 [43] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_pbuc3_derefidx_vbuz2 
    ldx plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
  //SEG90 [44] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy plex_show_idx
    lda PLEX_SORTED_IDX,y
  //SEG91 [45] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
  //SEG92 [46] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
  //SEG93 [47] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy plex_sprite_idx2
    sta SPRITES_XPOS,y
  //SEG94 [48] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
  //SEG95 [49] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b1
  //SEG96 plexShowSprite::@3
  //SEG97 [50] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor plex_sprite_msb
  //SEG98 [51] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
  //SEG99 plexShowSprite::@2
  b2:
  //SEG100 [52] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#42 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx plex_sprite_idx
    inx
  //SEG101 [53] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax plex_sprite_idx
  //SEG102 [54] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#42 -- vbuz1=_inc_vbuz1 
    inc plex_show_idx
  //SEG103 [55] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#42 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl plex_sprite_msb
  //SEG104 [56] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5 -- vbuz1_neq_0_then_la1 
    lda plex_sprite_msb
    cmp #0
    bne b5
  //SEG105 [58] phi from plexShowSprite::@2 to plexShowSprite::@return [phi:plexShowSprite::@2->plexShowSprite::@return]
  //SEG106 [58] phi (byte) plex_sprite_msb#16 = (byte) 1 [phi:plexShowSprite::@2->plexShowSprite::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta plex_sprite_msb
    rts
  //SEG107 [57] phi from plexShowSprite::@2 to plexShowSprite::@5 [phi:plexShowSprite::@2->plexShowSprite::@5]
  //SEG108 plexShowSprite::@5
  b5:
  //SEG109 [58] phi from plexShowSprite::@5 to plexShowSprite::@return [phi:plexShowSprite::@5->plexShowSprite::@return]
  //SEG110 [58] phi (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@5->plexShowSprite::@return#0] -- register_copy 
  //SEG111 plexShowSprite::@return
  //SEG112 [59] return 
    rts
  //SEG113 plexShowSprite::@1
  b1:
  //SEG114 [60] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
//SEG115 plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $d
    .label nxt_y = $e
    .label m = 8
  //SEG116 [62] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  //SEG117 [62] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta m
  //SEG118 [62] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  //SEG119 [62] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
  //SEG120 plexSort::@1
  b1:
  //SEG121 [63] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy m
    lda PLEX_SORTED_IDX+1,y
    sta nxt_idx
  //SEG122 [64] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    tay
    lda PLEX_YPOS,y
    sta nxt_y
  //SEG123 [65] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_pbuc2_derefidx_vbuz2_then_la1 
    ldx m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
  //SEG124 plexSort::@5
  //SEG125 [66] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
  //SEG126 [67] phi from plexSort::@5 plexSort::@6 to plexSort::@3 [phi:plexSort::@5/plexSort::@6->plexSort::@3]
  //SEG127 [67] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@6->plexSort::@3#0] -- register_copy 
  //SEG128 plexSort::@3
  b3:
  //SEG129 [68] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
  //SEG130 [69] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
  //SEG131 [70] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq b4
  //SEG132 plexSort::@6
  //SEG133 [71] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_pbuc2_derefidx_vbuxx_then_la1 
    lda nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3
  //SEG134 plexSort::@4
  b4:
  //SEG135 [72] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
  //SEG136 [73] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda nxt_idx
    sta PLEX_SORTED_IDX,x
  //SEG137 plexSort::@2
  b2:
  //SEG138 [74] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc m
  //SEG139 [75] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp m
    bne b1
  //SEG140 [76] phi from plexSort::@2 to plexSort::plexFreePrepare1 [phi:plexSort::@2->plexSort::plexFreePrepare1]
  //SEG141 plexSort::plexFreePrepare1
  //SEG142 [77] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  //SEG143 [77] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG144 [77] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  //SEG145 [77] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
  //SEG146 plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
  //SEG147 [78] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
  //SEG148 [79] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG149 [80] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1_b1
  //SEG150 plexSort::@return
  //SEG151 [81] return 
    rts
}
//SEG152 init
// Initialize the program
init: {
    .label xp = 9
  //SEG153 [82] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
  //SEG154 [83] call plexInit 
  //SEG155 [97] phi from init to plexInit [phi:init->plexInit]
    jsr plexInit
  //SEG156 [84] phi from init to init::@1 [phi:init->init::@1]
  //SEG157 [84] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #$20
    sta xp
    lda #0
    sta xp+1
  //SEG158 [84] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    tax
  //SEG159 [84] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  //SEG160 [84] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
  //SEG161 [84] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
  //SEG162 init::@1
  b1:
  //SEG163 [85] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta PLEX_PTR,x
  //SEG164 [86] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG165 [87] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda xp
    sta PLEX_XPOS,y
    lda xp+1
    sta PLEX_XPOS+1,y
  //SEG166 [88] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc xp
    sta xp
    bcc !+
    inc xp+1
  !:
  //SEG167 [89] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG168 [90] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1
  //SEG169 init::@2
  //SEG170 [91] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
  //SEG171 [92] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  //SEG172 [92] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG173 [92] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  //SEG174 [92] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
  //SEG175 init::@3
  b3:
  //SEG176 [93] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
  //SEG177 [94] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG178 [95] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b3
  //SEG179 init::@return
  //SEG180 [96] return 
    rts
}
//SEG181 plexInit
// Initialize the multiplexer data structures
plexInit: {
  //SEG182 [98] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  //SEG183 plexInit::plexSetScreen1
  //SEG184 [99] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  //SEG185 [99] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG186 [99] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  //SEG187 [99] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
  //SEG188 plexInit::@1
  b1:
  //SEG189 [100] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
  //SEG190 [101] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
  //SEG191 [102] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1
  //SEG192 plexInit::@return
  //SEG193 [103] return 
    rts
}
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = YSIN "YSIN"
  .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


