
CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start
  main::sc#0 = main::SCREEN
  to:main::@1
main::@1: scope:[main]  from main main::@1
  main::sc#2 = phi( main/main::sc#0, main::@1/main::sc#1 )
  *main::sc#2 = ' '
  main::sc#1 = main::sc#2 + rangenext(main::SCREEN,main::SCREEN+$3e8)
  main::$0 = main::sc#1 != rangelast(main::SCREEN,main::SCREEN+$3e8)
  if(main::$0) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  main::i#0 = 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  main::i#2 = phi( main::@2/main::i#0, main::@4/main::i#1 )
  main::$1 = main::header[main::i#2] != 0
  if(main::$1) goto main::@4
  to:main::@5
main::@4: scope:[main]  from main::@3
  main::i#3 = phi( main::@3/main::i#2 )
  main::SCREEN[main::i#3] = main::header[main::i#3]
  main::i#1 = ++ main::i#3
  to:main::@3
main::@5: scope:[main]  from main::@3
  main::screen#0 = main::SCREEN
  main::i1#0 = 0
  to:main::@6
main::@6: scope:[main]  from main::@12 main::@5
  main::screen#8 = phi( main::@12/main::screen#13, main::@5/main::screen#0 )
  main::i1#2 = phi( main::@12/main::i1#1, main::@5/main::i1#0 )
  main::$2 = main::i1#2 <= 9
  if(main::$2) goto main::@7
  to:main::@return
main::@7: scope:[main]  from main::@6
  main::i1#3 = phi( main::@6/main::i1#2 )
  main::screen#2 = phi( main::@6/main::screen#8 )
  main::screen#1 = main::screen#2 + $28
  main::$3 = '0' + main::i1#3
  main::screen#1[0] = main::$3
  main::$4 = main::i1#3 < 5
  main::$5 = ! main::$4
  if(main::$5) goto main::@8
  to:main::@13
main::@8: scope:[main]  from main::@13 main::@7
  main::screen#9 = phi( main::@13/main::screen#3, main::@7/main::screen#1 )
  main::i1#4 = phi( main::@13/main::i1#9, main::@7/main::i1#3 )
  main::$6 = main::i1#4 <= 5
  main::$7 = ! main::$6
  if(main::$7) goto main::@9
  to:main::@14
main::@13: scope:[main]  from main::@7
  main::i1#9 = phi( main::@7/main::i1#3 )
  main::screen#3 = phi( main::@7/main::screen#1 )
  main::screen#3[2] = '+'
  to:main::@8
main::@9: scope:[main]  from main::@14 main::@8
  main::screen#10 = phi( main::@14/main::screen#4, main::@8/main::screen#9 )
  main::i1#5 = phi( main::@14/main::i1#10, main::@8/main::i1#4 )
  main::$8 = main::i1#5 == 5
  main::$9 = ! main::$8
  if(main::$9) goto main::@10
  to:main::@15
main::@14: scope:[main]  from main::@8
  main::i1#10 = phi( main::@8/main::i1#4 )
  main::screen#4 = phi( main::@8/main::screen#9 )
  main::screen#4[5] = '+'
  to:main::@9
main::@10: scope:[main]  from main::@15 main::@9
  main::screen#11 = phi( main::@15/main::screen#5, main::@9/main::screen#10 )
  main::i1#6 = phi( main::@15/main::i1#11, main::@9/main::i1#5 )
  main::$10 = main::i1#6 >= 5
  main::$11 = ! main::$10
  if(main::$11) goto main::@11
  to:main::@16
main::@15: scope:[main]  from main::@9
  main::i1#11 = phi( main::@9/main::i1#5 )
  main::screen#5 = phi( main::@9/main::screen#10 )
  main::screen#5[8] = '+'
  to:main::@10
main::@11: scope:[main]  from main::@10 main::@16
  main::screen#12 = phi( main::@10/main::screen#11, main::@16/main::screen#6 )
  main::i1#7 = phi( main::@10/main::i1#6, main::@16/main::i1#12 )
  main::$12 = main::i1#7 > 5
  main::$13 = ! main::$12
  if(main::$13) goto main::@12
  to:main::@17
main::@16: scope:[main]  from main::@10
  main::i1#12 = phi( main::@10/main::i1#6 )
  main::screen#6 = phi( main::@10/main::screen#11 )
  main::screen#6[$b] = '+'
  to:main::@11
main::@12: scope:[main]  from main::@11 main::@17
  main::screen#13 = phi( main::@11/main::screen#12, main::@17/main::screen#7 )
  main::i1#8 = phi( main::@11/main::i1#7, main::@17/main::i1#13 )
  main::i1#1 = ++ main::i1#8
  to:main::@6
main::@17: scope:[main]  from main::@11
  main::i1#13 = phi( main::@11/main::i1#7 )
  main::screen#7 = phi( main::@11/main::screen#12 )
  main::screen#7[$e] = '+'
  to:main::@12
main::@return: scope:[main]  from main::@6
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
void __start()
void main()
bool~ main::$0
bool~ main::$1
bool~ main::$10
bool~ main::$11
bool~ main::$12
bool~ main::$13
bool~ main::$2
byte~ main::$3
bool~ main::$4
bool~ main::$5
bool~ main::$6
bool~ main::$7
bool~ main::$8
bool~ main::$9
constant byte* const main::SCREEN = (byte*)$400
constant byte* main::header[]  = "  <  <= == >= >"
byte main::i
byte main::i#0
byte main::i#1
byte main::i#2
byte main::i#3
byte main::i1
byte main::i1#0
byte main::i1#1
byte main::i1#10
byte main::i1#11
byte main::i1#12
byte main::i1#13
byte main::i1#2
byte main::i1#3
byte main::i1#4
byte main::i1#5
byte main::i1#6
byte main::i1#7
byte main::i1#8
byte main::i1#9
byte* main::sc
byte* main::sc#0
byte* main::sc#1
byte* main::sc#2
byte* main::screen
byte* main::screen#0
byte* main::screen#1
byte* main::screen#10
byte* main::screen#11
byte* main::screen#12
byte* main::screen#13
byte* main::screen#2
byte* main::screen#3
byte* main::screen#4
byte* main::screen#5
byte* main::screen#6
byte* main::screen#7
byte* main::screen#8
byte* main::screen#9

Adding number conversion cast (unumber) $3e8 in main::sc#1 = main::sc#2 + rangenext(main::SCREEN,main::SCREEN+$3e8)
Adding number conversion cast (unumber) 0 in main::$1 = main::header[main::i#2] != 0
Adding number conversion cast (unumber) 9 in main::$2 = main::i1#2 <= 9
Adding number conversion cast (unumber) $28 in main::screen#1 = main::screen#2 + $28
Adding number conversion cast (unumber) 0 in main::screen#1[0] = main::$3
Adding number conversion cast (unumber) 5 in main::$4 = main::i1#3 < 5
Adding number conversion cast (unumber) 5 in main::$6 = main::i1#4 <= 5
Adding number conversion cast (unumber) 2 in main::screen#3[2] = '+'
Adding number conversion cast (unumber) 5 in main::$8 = main::i1#5 == 5
Adding number conversion cast (unumber) 5 in main::screen#4[5] = '+'
Adding number conversion cast (unumber) 5 in main::$10 = main::i1#6 >= 5
Adding number conversion cast (unumber) 8 in main::screen#5[8] = '+'
Adding number conversion cast (unumber) 5 in main::$12 = main::i1#7 > 5
Adding number conversion cast (unumber) $b in main::screen#6[$b] = '+'
Adding number conversion cast (unumber) $e in main::screen#7[$e] = '+'
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast 9
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast 5
Simplifying constant integer cast 5
Simplifying constant integer cast 2
Simplifying constant integer cast 5
Simplifying constant integer cast 5
Simplifying constant integer cast 5
Simplifying constant integer cast 8
Simplifying constant integer cast 5
Simplifying constant integer cast $b
Simplifying constant integer cast $e
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $e
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inversing boolean not [23] main::$5 = main::i1#3 >= 5 from [22] main::$4 = main::i1#3 < 5
Inversing boolean not [27] main::$7 = main::i1#4 > 5 from [26] main::$6 = main::i1#4 <= 5
Inversing boolean not [33] main::$9 = main::i1#5 != 5 from [32] main::$8 = main::i1#5 == 5
Inversing boolean not [39] main::$11 = main::i1#6 < 5 from [38] main::$10 = main::i1#6 >= 5
Inversing boolean not [45] main::$13 = main::i1#7 <= 5 from [44] main::$12 = main::i1#7 > 5
Successful SSA optimization Pass2UnaryNotSimplification
Alias main::i#2 = main::i#3 
Alias main::screen#2 = main::screen#8 
Alias main::i1#2 = main::i1#3 main::i1#9 
Alias main::screen#1 = main::screen#3 
Alias main::screen#4 = main::screen#9 
Alias main::i1#10 = main::i1#4 
Alias main::screen#10 = main::screen#5 
Alias main::i1#11 = main::i1#5 
Alias main::screen#11 = main::screen#6 
Alias main::i1#12 = main::i1#6 
Alias main::screen#12 = main::screen#7 
Alias main::i1#13 = main::i1#7 
Successful SSA optimization Pass2AliasElimination
Alias main::i1#10 = main::i1#2 main::i1#11 main::i1#12 main::i1#13 main::i1#8 
Alias main::screen#1 = main::screen#4 main::screen#10 main::screen#11 main::screen#12 main::screen#13 
Successful SSA optimization Pass2AliasElimination
Simple Condition main::$0 [5] if(main::sc#1!=rangelast(main::SCREEN,main::SCREEN+$3e8)) goto main::@1
Simple Condition main::$1 [9] if(main::header[main::i#2]!=0) goto main::@4
Simple Condition main::$2 [16] if(main::i1#10<=9) goto main::@7
Simple Condition main::$5 [21] if(main::i1#10>=5) goto main::@8
Simple Condition main::$7 [23] if(main::i1#10>5) goto main::@9
Simple Condition main::$9 [26] if(main::i1#10!=5) goto main::@10
Simple Condition main::$11 [29] if(main::i1#10<5) goto main::@11
Simple Condition main::$13 [32] if(main::i1#10<=5) goto main::@12
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant main::sc#0 = main::SCREEN
Constant main::i#0 = 0
Constant main::screen#0 = main::SCREEN
Constant main::i1#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [3] main::sc#1 = ++ main::sc#2 to ++
Resolved ranged comparison value [5] if(main::sc#1!=rangelast(main::SCREEN,main::SCREEN+$3e8)) goto main::@1 to (byte*)main::SCREEN+$3e8+1
Rewriting conditional comparison [16] if(main::i1#10<=9) goto main::@7
Rewriting conditional comparison [23] if(main::i1#10>5) goto main::@9
Rewriting conditional comparison [32] if(main::i1#10<=5) goto main::@12
Simplifying expression containing zero main::screen#1 in [19] main::screen#1[0] = main::$3
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) 1 in [3] if(main::sc#1!=(byte*)main::SCREEN+$3e8+1) goto main::@1
Adding number conversion cast (unumber) 9+1 in [9] if(main::i1#10<9+1) goto main::@7
Adding number conversion cast (unumber) 1 in [9] if(main::i1#10<(unumber)9+1) goto main::@7
Adding number conversion cast (unumber) 5+1 in [14] if(main::i1#10>=5+1) goto main::@9
Adding number conversion cast (unumber) 1 in [14] if(main::i1#10>=(unumber)5+1) goto main::@9
Adding number conversion cast (unumber) 5+1 in [20] if(main::i1#10<5+1) goto main::@12
Adding number conversion cast (unumber) 1 in [20] if(main::i1#10<(unumber)5+1) goto main::@12
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast main::SCREEN+$3e8+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast 9+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast 5+(unumber)1
Simplifying constant integer cast 1
Simplifying constant integer cast 5+(unumber)1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings main::sc#0
Inlining constant with var siblings main::i#0
Inlining constant with var siblings main::screen#0
Inlining constant with var siblings main::i1#0
Constant inlined main::screen#0 = main::SCREEN
Constant inlined main::i#0 = 0
Constant inlined main::i1#0 = 0
Constant inlined main::sc#0 = main::SCREEN
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@18(between main::@1 and main::@1)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@5
CALL GRAPH

Created 4 initial phi equivalence classes
Coalesced [26] main::i1#14 = main::i1#1
Coalesced [27] main::screen#14 = main::screen#1
Coalesced [30] main::i#4 = main::i#1
Coalesced [31] main::sc#3 = main::sc#1
Coalesced down to 4 phi equivalence classes
Culled Empty Block label main::@2
Culled Empty Block label main::@5
Culled Empty Block label main::@18
Renumbering block main::@3 to main::@2
Renumbering block main::@4 to main::@3
Renumbering block main::@6 to main::@4
Renumbering block main::@7 to main::@5
Renumbering block main::@8 to main::@6
Renumbering block main::@9 to main::@7
Renumbering block main::@10 to main::@8
Renumbering block main::@11 to main::@9
Renumbering block main::@12 to main::@10
Renumbering block main::@13 to main::@11
Renumbering block main::@14 to main::@12
Renumbering block main::@15 to main::@13
Renumbering block main::@16 to main::@14
Renumbering block main::@17 to main::@15
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [1] main::sc#2 = phi( main/main::SCREEN, main::@1/main::sc#1 )
  [2] *main::sc#2 = ' '
  [3] main::sc#1 = ++ main::sc#2
  [4] if(main::sc#1!=main::SCREEN+$3e8+1) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@3
  [5] main::i#2 = phi( main::@1/0, main::@3/main::i#1 )
  [6] if(main::header[main::i#2]!=0) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@10 main::@2
  [7] main::screen#2 = phi( main::@10/main::screen#1, main::@2/main::SCREEN )
  [7] main::i1#10 = phi( main::@10/main::i1#1, main::@2/0 )
  [8] if(main::i1#10<9+1) goto main::@5
  to:main::@return
main::@return: scope:[main]  from main::@4
  [9] return 
  to:@return
main::@5: scope:[main]  from main::@4
  [10] main::screen#1 = main::screen#2 + $28
  [11] main::$3 = '0' + main::i1#10
  [12] *main::screen#1 = main::$3
  [13] if(main::i1#10>=5) goto main::@6
  to:main::@11
main::@11: scope:[main]  from main::@5
  [14] main::screen#1[2] = '+'
  to:main::@6
main::@6: scope:[main]  from main::@11 main::@5
  [15] if(main::i1#10>=5+1) goto main::@7
  to:main::@12
main::@12: scope:[main]  from main::@6
  [16] main::screen#1[5] = '+'
  to:main::@7
main::@7: scope:[main]  from main::@12 main::@6
  [17] if(main::i1#10!=5) goto main::@8
  to:main::@13
main::@13: scope:[main]  from main::@7
  [18] main::screen#1[8] = '+'
  to:main::@8
main::@8: scope:[main]  from main::@13 main::@7
  [19] if(main::i1#10<5) goto main::@9
  to:main::@14
main::@14: scope:[main]  from main::@8
  [20] main::screen#1[$b] = '+'
  to:main::@9
main::@9: scope:[main]  from main::@14 main::@8
  [21] if(main::i1#10<5+1) goto main::@10
  to:main::@15
main::@15: scope:[main]  from main::@9
  [22] main::screen#1[$e] = '+'
  to:main::@10
main::@10: scope:[main]  from main::@15 main::@9
  [23] main::i1#1 = ++ main::i1#10
  to:main::@4
main::@3: scope:[main]  from main::@2
  [24] main::SCREEN[main::i#2] = main::header[main::i#2]
  [25] main::i#1 = ++ main::i#2
  to:main::@2


VARIABLE REGISTER WEIGHTS
void main()
byte~ main::$3 22.0
byte main::i
byte main::i#1 22.0
byte main::i#2 18.333333333333332
byte main::i1
byte main::i1#1 22.0
byte main::i1#10 6.6
byte* main::sc
byte* main::sc#1 16.5
byte* main::sc#2 16.5
byte* main::screen
byte* main::screen#1 6.285714285714286
byte* main::screen#2 11.0

Initial phi equivalence classes
[ main::sc#2 main::sc#1 ]
[ main::i#2 main::i#1 ]
[ main::i1#10 main::i1#1 ]
[ main::screen#2 main::screen#1 ]
Added variable main::$3 to live range equivalence class [ main::$3 ]
Complete equivalence classes
[ main::sc#2 main::sc#1 ]
[ main::i#2 main::i#1 ]
[ main::i1#10 main::i1#1 ]
[ main::screen#2 main::screen#1 ]
[ main::$3 ]
Allocated zp[2]:2 [ main::sc#2 main::sc#1 ]
Allocated zp[1]:4 [ main::i#2 main::i#1 ]
Allocated zp[1]:5 [ main::i1#10 main::i1#1 ]
Allocated zp[2]:6 [ main::screen#2 main::screen#1 ]
Allocated zp[1]:8 [ main::$3 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] *main::sc#2 = ' ' [ main::sc#2 ] (  [ main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [4] if(main::sc#1!=main::SCREEN+$3e8+1) goto main::@1 [ main::sc#1 ] (  [ main::sc#1 ] { }  ) always clobbers reg byte a 
Statement [6] if(main::header[main::i#2]!=0) goto main::@3 [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ main::i#2 main::i#1 ]
Statement [10] main::screen#1 = main::screen#2 + $28 [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ main::i1#10 main::i1#1 ]
Statement [11] main::$3 = '0' + main::i1#10 [ main::i1#10 main::screen#1 main::$3 ] (  [ main::i1#10 main::screen#1 main::$3 ] { }  ) always clobbers reg byte a 
Statement [12] *main::screen#1 = main::$3 [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:5 [ main::i1#10 main::i1#1 ]
Statement [14] main::screen#1[2] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [16] main::screen#1[5] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [18] main::screen#1[8] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [20] main::screen#1[$b] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [22] main::screen#1[$e] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [24] main::SCREEN[main::i#2] = main::header[main::i#2] [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [2] *main::sc#2 = ' ' [ main::sc#2 ] (  [ main::sc#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [4] if(main::sc#1!=main::SCREEN+$3e8+1) goto main::@1 [ main::sc#1 ] (  [ main::sc#1 ] { }  ) always clobbers reg byte a 
Statement [6] if(main::header[main::i#2]!=0) goto main::@3 [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [10] main::screen#1 = main::screen#2 + $28 [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a 
Statement [11] main::$3 = '0' + main::i1#10 [ main::i1#10 main::screen#1 main::$3 ] (  [ main::i1#10 main::screen#1 main::$3 ] { }  ) always clobbers reg byte a 
Statement [12] *main::screen#1 = main::$3 [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte y 
Statement [14] main::screen#1[2] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [16] main::screen#1[5] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [18] main::screen#1[8] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [20] main::screen#1[$b] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [22] main::screen#1[$e] = '+' [ main::i1#10 main::screen#1 ] (  [ main::i1#10 main::screen#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [24] main::SCREEN[main::i#2] = main::header[main::i#2] [ main::i#2 ] (  [ main::i#2 ] { }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ main::sc#2 main::sc#1 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ main::i#2 main::i#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ main::i1#10 main::i1#1 ] : zp[1]:5 , reg byte x , 
Potential registers zp[2]:6 [ main::screen#2 main::screen#1 ] : zp[2]:6 , 
Potential registers zp[1]:8 [ main::$3 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 40.33: zp[1]:4 [ main::i#2 main::i#1 ] 33: zp[2]:2 [ main::sc#2 main::sc#1 ] 28.6: zp[1]:5 [ main::i1#10 main::i1#1 ] 22: zp[1]:8 [ main::$3 ] 17.29: zp[2]:6 [ main::screen#2 main::screen#1 ] 
Uplift Scope [] 

Uplifting [main] best 2441 combination reg byte x [ main::i#2 main::i#1 ] zp[2]:2 [ main::sc#2 main::sc#1 ] reg byte x [ main::i1#10 main::i1#1 ] reg byte a [ main::$3 ] zp[2]:6 [ main::screen#2 main::screen#1 ] 
Uplifting [] best 2441 combination 
Allocated (was zp[2]:6) zp[2]:4 [ main::screen#2 main::screen#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test rewriting of constant comparisons
  // Upstart
  // Commodore 64 PRG executable file
.file [name="comparison-rewriting.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    .label SCREEN = $400
    .label sc = 2
    .label screen = 4
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi main::sc#2 = main::SCREEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z sc
    lda #>SCREEN
    sta.z sc+1
    jmp __b1
    // [1] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  __b1_from___b1:
    // [1] phi main::sc#2 = main::sc#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [2] *main::sc#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // [3] main::sc#1 = ++ main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [4] if(main::sc#1!=main::SCREEN+$3e8+1) goto main::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>SCREEN+$3e8+1
    bne __b1_from___b1
    lda.z sc
    cmp #<SCREEN+$3e8+1
    bne __b1_from___b1
    // [5] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    // [5] phi main::i#2 = 0 [phi:main::@1->main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b2
    // main::@2
  __b2:
    // [6] if(main::header[main::i#2]!=0) goto main::@3 -- pbuc1_derefidx_vbuxx_neq_0_then_la1 
    lda header,x
    cmp #0
    bne __b3
    // [7] phi from main::@2 to main::@4 [phi:main::@2->main::@4]
  __b4_from___b2:
    // [7] phi main::screen#2 = main::SCREEN [phi:main::@2->main::@4#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z screen
    lda #>SCREEN
    sta.z screen+1
    // [7] phi main::i1#10 = 0 [phi:main::@2->main::@4#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b4
    // main::@4
  __b4:
    // [8] if(main::i1#10<9+1) goto main::@5 -- vbuxx_lt_vbuc1_then_la1 
    cpx #9+1
    bcc __b5
    jmp __breturn
    // main::@return
  __breturn:
    // [9] return 
    rts
    // main::@5
  __b5:
    // [10] main::screen#1 = main::screen#2 + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // [11] main::$3 = '0' + main::i1#10 -- vbuaa=vbuc1_plus_vbuxx 
    txa
    clc
    adc #'0'
    // [12] *main::screen#1 = main::$3 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (screen),y
    // [13] if(main::i1#10>=5) goto main::@6 -- vbuxx_ge_vbuc1_then_la1 
    cpx #5
    bcs __b6
    jmp __b11
    // main::@11
  __b11:
    // [14] main::screen#1[2] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #2
    sta (screen),y
    jmp __b6
    // main::@6
  __b6:
    // [15] if(main::i1#10>=5+1) goto main::@7 -- vbuxx_ge_vbuc1_then_la1 
    cpx #5+1
    bcs __b7
    jmp __b12
    // main::@12
  __b12:
    // [16] main::screen#1[5] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #5
    sta (screen),y
    jmp __b7
    // main::@7
  __b7:
    // [17] if(main::i1#10!=5) goto main::@8 -- vbuxx_neq_vbuc1_then_la1 
    cpx #5
    bne __b8
    jmp __b13
    // main::@13
  __b13:
    // [18] main::screen#1[8] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #8
    sta (screen),y
    jmp __b8
    // main::@8
  __b8:
    // [19] if(main::i1#10<5) goto main::@9 -- vbuxx_lt_vbuc1_then_la1 
    cpx #5
    bcc __b9
    jmp __b14
    // main::@14
  __b14:
    // [20] main::screen#1[$b] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #$b
    sta (screen),y
    jmp __b9
    // main::@9
  __b9:
    // [21] if(main::i1#10<5+1) goto main::@10 -- vbuxx_lt_vbuc1_then_la1 
    cpx #5+1
    bcc __b10
    jmp __b15
    // main::@15
  __b15:
    // [22] main::screen#1[$e] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #$e
    sta (screen),y
    jmp __b10
    // main::@10
  __b10:
    // [23] main::i1#1 = ++ main::i1#10 -- vbuxx=_inc_vbuxx 
    inx
    // [7] phi from main::@10 to main::@4 [phi:main::@10->main::@4]
  __b4_from___b10:
    // [7] phi main::screen#2 = main::screen#1 [phi:main::@10->main::@4#0] -- register_copy 
    // [7] phi main::i1#10 = main::i1#1 [phi:main::@10->main::@4#1] -- register_copy 
    jmp __b4
    // main::@3
  __b3:
    // [24] main::SCREEN[main::i#2] = main::header[main::i#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda header,x
    sta SCREEN,x
    // [25] main::i#1 = ++ main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [5] phi from main::@3 to main::@2 [phi:main::@3->main::@2]
  __b2_from___b3:
    // [5] phi main::i#2 = main::i#1 [phi:main::@3->main::@2#0] -- register_copy 
    jmp __b2
  .segment Data
    header: .text "  <  <= == >= >"
    .byte 0
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __b11
Removing instruction jmp __b6
Removing instruction jmp __b12
Removing instruction jmp __b7
Removing instruction jmp __b13
Removing instruction jmp __b8
Removing instruction jmp __b14
Removing instruction jmp __b9
Removing instruction jmp __b15
Removing instruction jmp __b10
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b1 with __b1
Replacing label __b1_from___b1 with __b1
Removing instruction __b1_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __b2_from___b1:
Removing instruction __b4_from___b2:
Removing instruction __breturn:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b13:
Removing instruction __b14:
Removing instruction __b15:
Removing instruction __b4_from___b10:
Removing instruction __b2_from___b3:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
void main()
byte~ main::$3 reg byte a 22.0
constant byte* const main::SCREEN = (byte*) 1024
constant byte* main::header[]  = "  <  <= == >= >"
byte main::i
byte main::i#1 reg byte x 22.0
byte main::i#2 reg byte x 18.333333333333332
byte main::i1
byte main::i1#1 reg byte x 22.0
byte main::i1#10 reg byte x 6.6
byte* main::sc
byte* main::sc#1 sc zp[2]:2 16.5
byte* main::sc#2 sc zp[2]:2 16.5
byte* main::screen
byte* main::screen#1 screen zp[2]:4 6.285714285714286
byte* main::screen#2 screen zp[2]:4 11.0

zp[2]:2 [ main::sc#2 main::sc#1 ]
reg byte x [ main::i#2 main::i#1 ]
reg byte x [ main::i1#10 main::i1#1 ]
zp[2]:4 [ main::screen#2 main::screen#1 ]
reg byte a [ main::$3 ]


FINAL ASSEMBLER
Score: 1991

  // File Comments
// Test rewriting of constant comparisons
  // Upstart
  // Commodore 64 PRG executable file
.file [name="comparison-rewriting.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
.segment Code
  // main
main: {
    .label SCREEN = $400
    .label sc = 2
    .label screen = 4
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi main::sc#2 = main::SCREEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z sc
    lda #>SCREEN
    sta.z sc+1
    // [1] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
    // [1] phi main::sc#2 = main::sc#1 [phi:main::@1->main::@1#0] -- register_copy 
    // main::@1
  __b1:
    // *sc=' '
    // [2] *main::sc#2 = ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (sc),y
    // for(byte* sc : SCREEN..SCREEN+1000)
    // [3] main::sc#1 = ++ main::sc#2 -- pbuz1=_inc_pbuz1 
    inc.z sc
    bne !+
    inc.z sc+1
  !:
    // [4] if(main::sc#1!=main::SCREEN+$3e8+1) goto main::@1 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sc+1
    cmp #>SCREEN+$3e8+1
    bne __b1
    lda.z sc
    cmp #<SCREEN+$3e8+1
    bne __b1
    // [5] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // [5] phi main::i#2 = 0 [phi:main::@1->main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // main::@2
  __b2:
    // for( byte i=0; header[i]!=0; i++)
    // [6] if(main::header[main::i#2]!=0) goto main::@3 -- pbuc1_derefidx_vbuxx_neq_0_then_la1 
    lda header,x
    cmp #0
    bne __b3
    // [7] phi from main::@2 to main::@4 [phi:main::@2->main::@4]
    // [7] phi main::screen#2 = main::SCREEN [phi:main::@2->main::@4#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z screen
    lda #>SCREEN
    sta.z screen+1
    // [7] phi main::i1#10 = 0 [phi:main::@2->main::@4#1] -- vbuxx=vbuc1 
    ldx #0
    // main::@4
  __b4:
    // for(byte i=0;i<=9;i++)
    // [8] if(main::i1#10<9+1) goto main::@5 -- vbuxx_lt_vbuc1_then_la1 
    cpx #9+1
    bcc __b5
    // main::@return
    // }
    // [9] return 
    rts
    // main::@5
  __b5:
    // screen +=40
    // [10] main::screen#1 = main::screen#2 + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z screen
    sta.z screen
    bcc !+
    inc.z screen+1
  !:
    // '0'+i
    // [11] main::$3 = '0' + main::i1#10 -- vbuaa=vbuc1_plus_vbuxx 
    txa
    clc
    adc #'0'
    // screen[0] = '0'+i
    // [12] *main::screen#1 = main::$3 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (screen),y
    // if(i<5)
    // [13] if(main::i1#10>=5) goto main::@6 -- vbuxx_ge_vbuc1_then_la1 
    cpx #5
    bcs __b6
    // main::@11
    // screen[2] = '+'
    // [14] main::screen#1[2] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #2
    sta (screen),y
    // main::@6
  __b6:
    // if(i<=5)
    // [15] if(main::i1#10>=5+1) goto main::@7 -- vbuxx_ge_vbuc1_then_la1 
    cpx #5+1
    bcs __b7
    // main::@12
    // screen[5] = '+'
    // [16] main::screen#1[5] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #5
    sta (screen),y
    // main::@7
  __b7:
    // if(i==5)
    // [17] if(main::i1#10!=5) goto main::@8 -- vbuxx_neq_vbuc1_then_la1 
    cpx #5
    bne __b8
    // main::@13
    // screen[8] = '+'
    // [18] main::screen#1[8] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #8
    sta (screen),y
    // main::@8
  __b8:
    // if(i>=5)
    // [19] if(main::i1#10<5) goto main::@9 -- vbuxx_lt_vbuc1_then_la1 
    cpx #5
    bcc __b9
    // main::@14
    // screen[11] = '+'
    // [20] main::screen#1[$b] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #$b
    sta (screen),y
    // main::@9
  __b9:
    // if(i>5)
    // [21] if(main::i1#10<5+1) goto main::@10 -- vbuxx_lt_vbuc1_then_la1 
    cpx #5+1
    bcc __b10
    // main::@15
    // screen[14] = '+'
    // [22] main::screen#1[$e] = '+' -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #'+'
    ldy #$e
    sta (screen),y
    // main::@10
  __b10:
    // for(byte i=0;i<=9;i++)
    // [23] main::i1#1 = ++ main::i1#10 -- vbuxx=_inc_vbuxx 
    inx
    // [7] phi from main::@10 to main::@4 [phi:main::@10->main::@4]
    // [7] phi main::screen#2 = main::screen#1 [phi:main::@10->main::@4#0] -- register_copy 
    // [7] phi main::i1#10 = main::i1#1 [phi:main::@10->main::@4#1] -- register_copy 
    jmp __b4
    // main::@3
  __b3:
    // SCREEN[i] = header[i]
    // [24] main::SCREEN[main::i#2] = main::header[main::i#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda header,x
    sta SCREEN,x
    // for( byte i=0; header[i]!=0; i++)
    // [25] main::i#1 = ++ main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [5] phi from main::@3 to main::@2 [phi:main::@3->main::@2]
    // [5] phi main::i#2 = main::i#1 [phi:main::@3->main::@2#0] -- register_copy 
    jmp __b2
  .segment Data
    header: .text "  <  <= == >= >"
    .byte 0
}
  // File Data

