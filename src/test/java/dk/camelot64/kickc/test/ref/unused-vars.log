// used vars
const byte* SCREEN = $0400;
byte b=2>>1;

// unused vars
const byte* BGCOL = $d021;
byte[] msg = "hello world@";
byte[] arr = { 7, 8, 9};
byte c=1;
const byte c2=1;
word d=1000;

void main() {
    // used vars
    byte col=2;
    byte* COLS=$d800;
    // unused vars
    byte e=3+3+3+s(); // The call to s() should survive even when e is eliminated
    word f=2000+2000+d+b++; // b++ should survive even when f is eliminated.
    byte[] g = {4, 5, 6};
    byte[] h = "goodbye sky ";
    for(byte i : 0..100) {
        // the last unused var
        signed byte x = -13;
        COLS[i] = col;
        SCREEN[i] = b;
    }
}

byte s() {
    b++;
    return 2;
}

Adding pre/post-modifier (byte) b ← ++ (byte) b
Adding pre/post-modifier (byte) b ← ++ (byte) b
PROGRAM
  (byte*) SCREEN ← (word/signed word) 1024
  (byte~) $0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  (byte) b ← (byte~) $0
  (byte*) BGCOL ← (word) 53281
  (byte[]) msg ← (string) "hello world@"
  (byte[]) arr ← { (byte/signed byte/word/signed word) 7, (byte/signed byte/word/signed word) 8, (byte/signed byte/word/signed word) 9 }
  (byte) c ← (byte/signed byte/word/signed word) 1
  (byte) c2 ← (byte/signed byte/word/signed word) 1
  (word) d ← (word/signed word) 1000
proc (void()) main()
  (byte) main::col ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS ← (word) 55296
  (byte/signed byte/word/signed word~) main::$0 ← (byte/signed byte/word/signed word) 3 + (byte/signed byte/word/signed word) 3
  (byte/word~) main::$1 ← (byte/signed byte/word/signed word~) main::$0 + (byte/signed byte/word/signed word) 3
  (byte~) main::$2 ← call s 
  (byte/word~) main::$3 ← (byte/word~) main::$1 + (byte~) main::$2
  (byte) main::e ← (byte/word~) main::$3
  (word/signed word~) main::$4 ← (word/signed word) 2000 + (word/signed word) 2000
  (word~) main::$5 ← (word/signed word~) main::$4 + (word) d
  (word~) main::$6 ← (word~) main::$5 + (byte) b
  (word) main::f ← (word~) main::$6
  (byte) b ← ++ (byte) b
  (byte[]) main::g ← { (byte/signed byte/word/signed word) 4, (byte/signed byte/word/signed word) 5, (byte/signed byte/word/signed word) 6 }
  (byte[]) main::h ← (string) "goodbye sky "
  (byte) main::i ← (byte/signed byte/word/signed word) 0
main::@1:
  (signed byte/signed word~) main::$7 ← - (byte/signed byte/word/signed word) 13
  (signed byte) main::x ← (signed byte/signed word~) main::$7
  *((byte*) main::COLS + (byte) main::i) ← (byte) main::col
  *((byte*) SCREEN + (byte) main::i) ← (byte) b
  (byte) main::i ← ++ (byte) main::i
  (boolean~) main::$8 ← (byte) main::i != (byte/signed byte/word/signed word) 101
  if((boolean~) main::$8) goto main::@1
main::@return:
  return 
endproc // main()
proc (byte()) s()
  (byte) b ← ++ (byte) b
  (byte) s::return ← (byte/signed byte/word/signed word) 2
  goto s::@return
s::@return:
  (byte) s::return ← (byte) s::return
  return (byte) s::return
endproc // s()
  call main 

SYMBOLS
(byte~) $0
(byte*) BGCOL
(byte*) SCREEN
(byte[]) arr
(byte) b
(byte) c
(byte) c2
(word) d
(void()) main()
(byte/signed byte/word/signed word~) main::$0
(byte/word~) main::$1
(byte~) main::$2
(byte/word~) main::$3
(word/signed word~) main::$4
(word~) main::$5
(word~) main::$6
(signed byte/signed word~) main::$7
(boolean~) main::$8
(label) main::@1
(label) main::@return
(byte*) main::COLS
(byte) main::col
(byte) main::e
(word) main::f
(byte[]) main::g
(byte[]) main::h
(byte) main::i
(signed byte) main::x
(byte[]) msg
(byte()) s()
(label) s::@return
(byte) s::return

Promoting word/signed word to byte* in SCREEN ← ((byte*)) 1024
Promoting word to byte* in BGCOL ← ((byte*)) 53281
Promoting word to byte* in main::COLS ← ((byte*)) 55296
INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte*) SCREEN ← ((byte*)) (word/signed word) 1024
  (byte~) $0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  (byte) b ← (byte~) $0
  (byte*) BGCOL ← ((byte*)) (word) 53281
  (byte[]) msg ← (string) "hello world@"
  (byte[]) arr ← { (byte/signed byte/word/signed word) 7, (byte/signed byte/word/signed word) 8, (byte/signed byte/word/signed word) 9 }
  (byte) c ← (byte/signed byte/word/signed word) 1
  (byte) c2 ← (byte/signed byte/word/signed word) 1
  (word) d ← (word/signed word) 1000
  to:@1
main: scope:[main]  from
  (byte) main::col ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS ← ((byte*)) (word) 55296
  (byte/signed byte/word/signed word~) main::$0 ← (byte/signed byte/word/signed word) 3 + (byte/signed byte/word/signed word) 3
  (byte/word~) main::$1 ← (byte/signed byte/word/signed word~) main::$0 + (byte/signed byte/word/signed word) 3
  (byte~) main::$2 ← call s 
  (byte/word~) main::$3 ← (byte/word~) main::$1 + (byte~) main::$2
  (byte) main::e ← (byte/word~) main::$3
  (word/signed word~) main::$4 ← (word/signed word) 2000 + (word/signed word) 2000
  (word~) main::$5 ← (word/signed word~) main::$4 + (word) d
  (word~) main::$6 ← (word~) main::$5 + (byte) b
  (word) main::f ← (word~) main::$6
  (byte) b ← ++ (byte) b
  (byte[]) main::g ← { (byte/signed byte/word/signed word) 4, (byte/signed byte/word/signed word) 5, (byte/signed byte/word/signed word) 6 }
  (byte[]) main::h ← (string) "goodbye sky "
  (byte) main::i ← (byte/signed byte/word/signed word) 0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  (signed byte/signed word~) main::$7 ← - (byte/signed byte/word/signed word) 13
  (signed byte) main::x ← (signed byte/signed word~) main::$7
  *((byte*) main::COLS + (byte) main::i) ← (byte) main::col
  *((byte*) SCREEN + (byte) main::i) ← (byte) b
  (byte) main::i ← ++ (byte) main::i
  (boolean~) main::$8 ← (byte) main::i != (byte/signed byte/word/signed word) 101
  if((boolean~) main::$8) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
@1: scope:[]  from @begin
  to:@2
s: scope:[s]  from
  (byte) b ← ++ (byte) b
  (byte) s::return ← (byte/signed byte/word/signed word) 2
  to:s::@return
s::@return: scope:[s]  from s s::@1
  (byte) s::return ← (byte) s::return
  return (byte) s::return
  to:@return
s::@1: scope:[s]  from
  to:s::@return
@2: scope:[]  from @1
  call main 
  to:@end
@end: scope:[]  from @2

Eliminating unused variable (byte*) BGCOL and assignment [3] (byte*) BGCOL ← ((byte*)) (word) 53281
Eliminating unused variable (byte[]) msg and assignment [4] (byte[]) msg ← (string) "hello world@"
Eliminating unused variable (byte[]) arr and assignment [5] (byte[]) arr ← { (byte/signed byte/word/signed word) 7, (byte/signed byte/word/signed word) 8, (byte/signed byte/word/signed word) 9 }
Eliminating unused variable (byte) c and assignment [6] (byte) c ← (byte/signed byte/word/signed word) 1
Eliminating unused variable (byte) c2 and assignment [7] (byte) c2 ← (byte/signed byte/word/signed word) 1
Eliminating unused variable (byte) main::e and assignment [15] (byte) main::e ← (byte/word~) main::$3
Eliminating unused variable (word) main::f and assignment [19] (word) main::f ← (word~) main::$6
Eliminating unused variable (byte[]) main::g and assignment [21] (byte[]) main::g ← { (byte/signed byte/word/signed word) 4, (byte/signed byte/word/signed word) 5, (byte/signed byte/word/signed word) 6 }
Eliminating unused variable (byte[]) main::h and assignment [22] (byte[]) main::h ← (string) "goodbye sky "
Eliminating unused variable (signed byte) main::x and assignment [25] (signed byte) main::x ← (signed byte/signed word~) main::$7
Eliminating unused variable (byte/word~) main::$3 and assignment [9] (byte/word~) main::$3 ← (byte/word~) main::$1 + (byte~) main::$2
Eliminating unused variable (word~) main::$6 and assignment [12] (word~) main::$6 ← (word~) main::$5 + (byte) b
Eliminating unused variable (signed byte/signed word~) main::$7 and assignment [15] (signed byte/signed word~) main::$7 ← - (byte/signed byte/word/signed word) 13
Eliminating unused variable (byte/word~) main::$1 and assignment [7] (byte/word~) main::$1 ← (byte/signed byte/word/signed word~) main::$0 + (byte/signed byte/word/signed word) 3
Eliminating unused variable - keeping the call (byte~) main::$2
Eliminating unused variable (word~) main::$5 and assignment [10] (word~) main::$5 ← (word/signed word~) main::$4 + (word) d
Eliminating unused variable (word) d and assignment [3] (word) d ← (word/signed word) 1000
Eliminating unused variable (byte/signed byte/word/signed word~) main::$0 and assignment [6] (byte/signed byte/word/signed word~) main::$0 ← (byte/signed byte/word/signed word) 3 + (byte/signed byte/word/signed word) 3
Eliminating unused variable (word/signed word~) main::$4 and assignment [8] (word/signed word~) main::$4 ← (word/signed word) 2000 + (word/signed word) 2000
Removing empty block main::@2
Removing empty block @1
Removing empty block s::@1
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte*) SCREEN ← ((byte*)) (word/signed word) 1024
  (byte~) $0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  (byte) b ← (byte~) $0
  to:@2
main: scope:[main]  from
  (byte) main::col ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS ← ((byte*)) (word) 55296
  call s 
  (byte) b ← ++ (byte) b
  (byte) main::i ← (byte/signed byte/word/signed word) 0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  *((byte*) main::COLS + (byte) main::i) ← (byte) main::col
  *((byte*) SCREEN + (byte) main::i) ← (byte) b
  (byte) main::i ← ++ (byte) main::i
  (boolean~) main::$8 ← (byte) main::i != (byte/signed byte/word/signed word) 101
  if((boolean~) main::$8) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from
  (byte) b ← ++ (byte) b
  (byte) s::return ← (byte/signed byte/word/signed word) 2
  to:s::@return
s::@return: scope:[s]  from s
  (byte) s::return ← (byte) s::return
  return (byte) s::return
  to:@return
@2: scope:[]  from @begin
  call main 
  to:@end
@end: scope:[]  from @2

PROCEDURE MODIFY VARIABLE ANALYSIS
main modifies b
s modifies b

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  (byte*) SCREEN ← ((byte*)) (word/signed word) 1024
  (byte~) $0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  (byte) b ← (byte~) $0
  to:@2
main: scope:[main]  from @2
  (byte) main::col ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS ← ((byte*)) (word) 55296
  (byte) s::return ← call s param-assignment
  to:main::@3
main::@3: scope:[main]  from main
  (byte) b ← (byte) b
  (byte) b ← ++ (byte) b
  (byte) main::i ← (byte/signed byte/word/signed word) 0
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  *((byte*) main::COLS + (byte) main::i) ← (byte) main::col
  *((byte*) SCREEN + (byte) main::i) ← (byte) b
  (byte) main::i ← ++ (byte) main::i
  (boolean~) main::$8 ← (byte) main::i != (byte/signed byte/word/signed word) 101
  if((boolean~) main::$8) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  (byte) b ← (byte) b
  return 
  to:@return
s: scope:[s]  from main
  (byte) b ← ++ (byte) b
  (byte) s::return ← (byte/signed byte/word/signed word) 2
  to:s::@return
s::@return: scope:[s]  from s
  (byte) s::return ← (byte) s::return
  (byte) b ← (byte) b
  return (byte) s::return
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) b ← (byte) b
  to:@end
@end: scope:[]  from @3

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word) 1024
  (byte~) $0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  (byte) b#0 ← (byte~) $0
  to:@2
main: scope:[main]  from @2
  (byte) b#13 ← phi( @2/(byte) b#14 )
  (byte) main::col#0 ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS#0 ← ((byte*)) (word) 55296
  (byte) s::return#0 ← call s param-assignment
  to:main::@3
main::@3: scope:[main]  from main
  (byte*) main::COLS#2 ← phi( main/(byte*) main::COLS#0 )
  (byte) main::col#2 ← phi( main/(byte) main::col#0 )
  (byte) b#7 ← phi( main/(byte) b#13 )
  (byte) b#1 ← (byte) b#7
  (byte) b#2 ← ++ (byte) b#1
  (byte) main::i#0 ← (byte/signed byte/word/signed word) 0
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) b#8 ← phi( main::@1/(byte) b#8 main::@3/(byte) b#2 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(byte) main::i#0 )
  (byte*) main::COLS#1 ← phi( main::@1/(byte*) main::COLS#1 main::@3/(byte*) main::COLS#2 )
  (byte) main::col#1 ← phi( main::@1/(byte) main::col#1 main::@3/(byte) main::col#2 )
  *((byte*) main::COLS#1 + (byte) main::i#2) ← (byte) main::col#1
  *((byte*) SCREEN#0 + (byte) main::i#2) ← (byte) b#8
  (byte) main::i#1 ← ++ (byte) main::i#2
  (boolean~) main::$8 ← (byte) main::i#1 != (byte/signed byte/word/signed word) 101
  if((boolean~) main::$8) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  (byte) b#9 ← phi( main::@1/(byte) b#8 )
  (byte) b#3 ← (byte) b#9
  return 
  to:@return
s: scope:[s]  from main
  (byte) b#10 ← phi( main/(byte) b#13 )
  (byte) b#4 ← ++ (byte) b#10
  (byte) s::return#1 ← (byte/signed byte/word/signed word) 2
  to:s::@return
s::@return: scope:[s]  from s
  (byte) b#11 ← phi( s/(byte) b#4 )
  (byte) s::return#3 ← phi( s/(byte) s::return#1 )
  (byte) s::return#2 ← (byte) s::return#3
  (byte) b#5 ← (byte) b#11
  return (byte) s::return#2
  to:@return
@2: scope:[]  from @begin
  (byte) b#14 ← phi( @begin/(byte) b#0 )
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) b#12 ← phi( @2/(byte) b#14 )
  (byte) b#6 ← (byte) b#12
  to:@end
@end: scope:[]  from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word) 1024
  (byte~) $0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  (byte) b#0 ← (byte~) $0
  to:@2
main: scope:[main]  from @2
  (byte) b#13 ← phi( @2/(byte) b#14 )
  (byte) main::col#0 ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS#0 ← ((byte*)) (word) 55296
  call s param-assignment
  (byte) s::return#0 ← (byte) s::return#2
  to:main::@3
main::@3: scope:[main]  from main
  (byte*) main::COLS#2 ← phi( main/(byte*) main::COLS#0 )
  (byte) main::col#2 ← phi( main/(byte) main::col#0 )
  (byte) b#7 ← phi( main/(byte) b#5 )
  (byte) b#1 ← (byte) b#7
  (byte) b#2 ← ++ (byte) b#1
  (byte) main::i#0 ← (byte/signed byte/word/signed word) 0
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) b#8 ← phi( main::@1/(byte) b#8 main::@3/(byte) b#2 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(byte) main::i#0 )
  (byte*) main::COLS#1 ← phi( main::@1/(byte*) main::COLS#1 main::@3/(byte*) main::COLS#2 )
  (byte) main::col#1 ← phi( main::@1/(byte) main::col#1 main::@3/(byte) main::col#2 )
  *((byte*) main::COLS#1 + (byte) main::i#2) ← (byte) main::col#1
  *((byte*) SCREEN#0 + (byte) main::i#2) ← (byte) b#8
  (byte) main::i#1 ← ++ (byte) main::i#2
  (boolean~) main::$8 ← (byte) main::i#1 != (byte/signed byte/word/signed word) 101
  if((boolean~) main::$8) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  (byte) b#9 ← phi( main::@1/(byte) b#8 )
  (byte) b#3 ← (byte) b#9
  return 
  to:@return
s: scope:[s]  from main
  (byte) b#10 ← phi( main/(byte) b#13 )
  (byte) b#4 ← ++ (byte) b#10
  (byte) s::return#1 ← (byte/signed byte/word/signed word) 2
  to:s::@return
s::@return: scope:[s]  from s
  (byte) b#11 ← phi( s/(byte) b#4 )
  (byte) s::return#3 ← phi( s/(byte) s::return#1 )
  (byte) s::return#2 ← (byte) s::return#3
  (byte) b#5 ← (byte) b#11
  return 
  to:@return
@2: scope:[]  from @begin
  (byte) b#14 ← phi( @begin/(byte) b#0 )
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) b#12 ← phi( @2/(byte) b#3 )
  (byte) b#6 ← (byte) b#12
  to:@end
@end: scope:[]  from @3

INITIAL SSA SYMBOL TABLE
(byte~) $0
(label) @2
(label) @3
(label) @begin
(label) @end
(byte*) SCREEN
(byte*) SCREEN#0
(byte) b
(byte) b#0
(byte) b#1
(byte) b#10
(byte) b#11
(byte) b#12
(byte) b#13
(byte) b#14
(byte) b#2
(byte) b#3
(byte) b#4
(byte) b#5
(byte) b#6
(byte) b#7
(byte) b#8
(byte) b#9
(void()) main()
(boolean~) main::$8
(label) main::@1
(label) main::@3
(label) main::@return
(byte*) main::COLS
(byte*) main::COLS#0
(byte*) main::COLS#1
(byte*) main::COLS#2
(byte) main::col
(byte) main::col#0
(byte) main::col#1
(byte) main::col#2
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte()) s()
(label) s::@return
(byte) s::return
(byte) s::return#0
(byte) s::return#1
(byte) s::return#2
(byte) s::return#3

Not aliassing across scopes: b#13 b#14
Not aliassing across scopes: s::return#0 s::return#2
Not aliassing across scopes: b#7 b#5
Not aliassing identity: main::col#1 main::col#1
Not aliassing identity: main::COLS#1 main::COLS#1
Not aliassing identity: b#8 b#8
Not aliassing across scopes: b#10 b#13
Not aliassing across scopes: b#12 b#3
Alias (byte) b#0 = (byte~) $0 (byte) b#14 
Alias (byte) main::col#0 = (byte) main::col#2 
Alias (byte*) main::COLS#0 = (byte*) main::COLS#2 
Alias (byte) b#1 = (byte) b#7 
Alias (byte) b#3 = (byte) b#9 (byte) b#8 
Alias (byte) s::return#1 = (byte) s::return#3 (byte) s::return#2 
Alias (byte) b#11 = (byte) b#4 (byte) b#5 
Alias (byte) b#12 = (byte) b#6 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word) 1024
  (byte) b#0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  to:@2
main: scope:[main]  from @2
  (byte) b#13 ← phi( @2/(byte) b#0 )
  (byte) main::col#0 ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS#0 ← ((byte*)) (word) 55296
  call s param-assignment
  (byte) s::return#0 ← (byte) s::return#1
  to:main::@3
main::@3: scope:[main]  from main
  (byte) b#1 ← phi( main/(byte) b#11 )
  (byte) b#2 ← ++ (byte) b#1
  (byte) main::i#0 ← (byte/signed byte/word/signed word) 0
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) b#3 ← phi( main::@1/(byte) b#3 main::@3/(byte) b#2 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(byte) main::i#0 )
  (byte*) main::COLS#1 ← phi( main::@1/(byte*) main::COLS#1 main::@3/(byte*) main::COLS#0 )
  (byte) main::col#1 ← phi( main::@1/(byte) main::col#1 main::@3/(byte) main::col#0 )
  *((byte*) main::COLS#1 + (byte) main::i#2) ← (byte) main::col#1
  *((byte*) SCREEN#0 + (byte) main::i#2) ← (byte) b#3
  (byte) main::i#1 ← ++ (byte) main::i#2
  (boolean~) main::$8 ← (byte) main::i#1 != (byte/signed byte/word/signed word) 101
  if((boolean~) main::$8) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  (byte) b#10 ← phi( main/(byte) b#13 )
  (byte) b#11 ← ++ (byte) b#10
  (byte) s::return#1 ← (byte/signed byte/word/signed word) 2
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) b#12 ← phi( @2/(byte) b#3 )
  to:@end
@end: scope:[]  from @3

Not aliassing across scopes: b#13 b#0
Not aliassing across scopes: s::return#0 s::return#1
Not aliassing across scopes: b#1 b#11
Not aliassing identity: main::col#1 main::col#1
Not aliassing identity: main::COLS#1 main::COLS#1
Not aliassing identity: b#3 b#3
Not aliassing across scopes: b#10 b#13
Not aliassing across scopes: b#12 b#3
Self Phi Eliminated (byte) main::col#1
Self Phi Eliminated (byte*) main::COLS#1
Self Phi Eliminated (byte) b#3
Succesful SSA optimization Pass2SelfPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word) 1024
  (byte) b#0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  to:@2
main: scope:[main]  from @2
  (byte) b#13 ← phi( @2/(byte) b#0 )
  (byte) main::col#0 ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS#0 ← ((byte*)) (word) 55296
  call s param-assignment
  (byte) s::return#0 ← (byte) s::return#1
  to:main::@3
main::@3: scope:[main]  from main
  (byte) b#1 ← phi( main/(byte) b#11 )
  (byte) b#2 ← ++ (byte) b#1
  (byte) main::i#0 ← (byte/signed byte/word/signed word) 0
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) b#3 ← phi( main::@3/(byte) b#2 )
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(byte) main::i#0 )
  (byte*) main::COLS#1 ← phi( main::@3/(byte*) main::COLS#0 )
  (byte) main::col#1 ← phi( main::@3/(byte) main::col#0 )
  *((byte*) main::COLS#1 + (byte) main::i#2) ← (byte) main::col#1
  *((byte*) SCREEN#0 + (byte) main::i#2) ← (byte) b#3
  (byte) main::i#1 ← ++ (byte) main::i#2
  (boolean~) main::$8 ← (byte) main::i#1 != (byte/signed byte/word/signed word) 101
  if((boolean~) main::$8) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  (byte) b#10 ← phi( main/(byte) b#13 )
  (byte) b#11 ← ++ (byte) b#10
  (byte) s::return#1 ← (byte/signed byte/word/signed word) 2
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) b#12 ← phi( @2/(byte) b#3 )
  to:@end
@end: scope:[]  from @3

Redundant Phi (byte) b#13 (byte) b#0
Redundant Phi (byte) b#1 (byte) b#11
Redundant Phi (byte) main::col#1 (byte) main::col#0
Redundant Phi (byte*) main::COLS#1 (byte*) main::COLS#0
Redundant Phi (byte) b#3 (byte) b#2
Redundant Phi (byte) b#10 (byte) b#13
Redundant Phi (byte) b#12 (byte) b#3
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word) 1024
  (byte) b#0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  to:@2
main: scope:[main]  from @2
  (byte) main::col#0 ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS#0 ← ((byte*)) (word) 55296
  call s param-assignment
  (byte) s::return#0 ← (byte) s::return#1
  to:main::@3
main::@3: scope:[main]  from main
  (byte) b#2 ← ++ (byte) b#11
  (byte) main::i#0 ← (byte/signed byte/word/signed word) 0
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(byte) main::i#0 )
  *((byte*) main::COLS#0 + (byte) main::i#2) ← (byte) main::col#0
  *((byte*) SCREEN#0 + (byte) main::i#2) ← (byte) b#2
  (byte) main::i#1 ← ++ (byte) main::i#2
  (boolean~) main::$8 ← (byte) main::i#1 != (byte/signed byte/word/signed word) 101
  if((boolean~) main::$8) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  (byte) b#11 ← ++ (byte) b#0
  (byte) s::return#1 ← (byte/signed byte/word/signed word) 2
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Simple Condition (boolean~) main::$8 if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1
Succesful SSA optimization Pass2ConditionalJumpSimplification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte*) SCREEN#0 ← ((byte*)) (word/signed word) 1024
  (byte) b#0 ← (byte/signed byte/word/signed word) 2 >> (byte/signed byte/word/signed word) 1
  to:@2
main: scope:[main]  from @2
  (byte) main::col#0 ← (byte/signed byte/word/signed word) 2
  (byte*) main::COLS#0 ← ((byte*)) (word) 55296
  call s param-assignment
  (byte) s::return#0 ← (byte) s::return#1
  to:main::@3
main::@3: scope:[main]  from main
  (byte) b#2 ← ++ (byte) b#11
  (byte) main::i#0 ← (byte/signed byte/word/signed word) 0
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(byte) main::i#0 )
  *((byte*) main::COLS#0 + (byte) main::i#2) ← (byte) main::col#0
  *((byte*) SCREEN#0 + (byte) main::i#2) ← (byte) b#2
  (byte) main::i#1 ← ++ (byte) main::i#2
  if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  (byte) b#11 ← ++ (byte) b#0
  (byte) s::return#1 ← (byte/signed byte/word/signed word) 2
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Constant (const byte*) SCREEN#0 = ((byte*))1024
Constant (const byte) b#0 = 2>>1
Constant (const byte) main::col#0 = 2
Constant (const byte*) main::COLS#0 = ((byte*))55296
Constant (const byte) main::i#0 = 0
Constant (const byte) s::return#1 = 2
Succesful SSA optimization Pass2ConstantIdentification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call s param-assignment
  (byte) s::return#0 ← (const byte) s::return#1
  to:main::@3
main::@3: scope:[main]  from main
  (byte) b#2 ← ++ (byte) b#11
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(const byte) main::i#0 )
  *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0
  *((const byte*) SCREEN#0 + (byte) main::i#2) ← (byte) b#2
  (byte) main::i#1 ← ++ (byte) main::i#2
  if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  (byte) b#11 ← ++ (const byte) b#0
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Constant (const byte) s::return#0 = s::return#1
Constant (const byte) b#11 = ++b#0
Succesful SSA optimization Pass2ConstantIdentification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call s param-assignment
  to:main::@3
main::@3: scope:[main]  from main
  (byte) b#2 ← ++ (const byte) b#11
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(const byte) main::i#0 )
  *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0
  *((const byte*) SCREEN#0 + (byte) main::i#2) ← (byte) b#2
  (byte) main::i#1 ← ++ (byte) main::i#2
  if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Constant (const byte) b#2 = ++b#11
Succesful SSA optimization Pass2ConstantIdentification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call s param-assignment
  to:main::@3
main::@3: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(const byte) main::i#0 )
  *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0
  *((const byte*) SCREEN#0 + (byte) main::i#2) ← (const byte) b#2
  (byte) main::i#1 ← ++ (byte) main::i#2
  if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Eliminating unused constant (const byte) s::return#0
Succesful SSA optimization PassNEliminateUnusedVars
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call s param-assignment
  to:main::@3
main::@3: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(const byte) main::i#0 )
  *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0
  *((const byte*) SCREEN#0 + (byte) main::i#2) ← (const byte) b#2
  (byte) main::i#1 ← ++ (byte) main::i#2
  if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Eliminating unused constant (const byte) s::return#1
Succesful SSA optimization PassNEliminateUnusedVars
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call s param-assignment
  to:main::@3
main::@3: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@3
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main::@3/(const byte) main::i#0 )
  *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0
  *((const byte*) SCREEN#0 + (byte) main::i#2) ← (const byte) b#2
  (byte) main::i#1 ← ++ (byte) main::i#2
  if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

Culled Empty Block (label) main::@3
Culled Empty Block (label) @3
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call s param-assignment
  to:main::@1
main::@1: scope:[main]  from main main::@1
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main/(const byte) main::i#0 )
  *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0
  *((const byte*) SCREEN#0 + (byte) main::i#2) ← (const byte) b#2
  (byte) main::i#1 ← ++ (byte) main::i#2
  if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @2

Inlining constant with var siblings (const byte) main::i#0
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with different constant siblings (const byte) b#0
Inlining constant with different constant siblings (const byte) b#0
Inlining constant with different constant siblings (const byte) b#11
Inlining constant with different constant siblings (const byte) b#11
Inlining constant with different constant siblings (const byte) b#2
Inlining constant with different constant siblings (const byte) b#2
Constant inlined b#2 = ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1
Constant inlined main::i#0 = (byte/signed byte/word/signed word) 0
Constant inlined b#11 = ++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1
Constant inlined b#0 = (byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1
Succesful SSA optimization Pass2ConstantInlining
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@2
main: scope:[main]  from @2
  call s param-assignment
  to:main::@1
main::@1: scope:[main]  from main main::@1
  (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main/(byte/signed byte/word/signed word) 0 )
  *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0
  *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1
  (byte) main::i#1 ← ++ (byte) main::i#2
  if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
s: scope:[s]  from main
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return
@2: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @2

FINAL SYMBOL TABLE
(label) @2
(label) @begin
(label) @end
(byte*) SCREEN
(const byte*) SCREEN#0 = ((byte*))(word/signed word) 1024
(byte) b
(void()) main()
(label) main::@1
(label) main::@return
(byte*) main::COLS
(const byte*) main::COLS#0 = ((byte*))(word) 55296
(byte) main::col
(const byte) main::col#0 = (byte/signed byte/word/signed word) 2
(byte) main::i
(byte) main::i#1
(byte) main::i#2
(byte()) s()
(label) s::@return
(byte) s::return

Block Sequence Planned @begin @2 @end main main::@1 main::@return s s::@return 
Added new block during phi lifting main::@4(between main::@1 and main::@1)
Block Sequence Planned @begin @2 @end main main::@1 main::@return main::@4 s s::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  to:@2
@2: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @2
main: scope:[main]  from @2
  call s param-assignment
  to:main::@1
main::@1: scope:[main]  from main main::@4
  (byte) main::i#2 ← phi( main::@4/(byte~) main::i#3 main/(byte/signed byte/word/signed word) 0 )
  *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0
  *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1
  (byte) main::i#1 ← ++ (byte) main::i#2
  if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@4
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
main::@4: scope:[main]  from main::@1
  (byte~) main::i#3 ← (byte) main::i#1
  to:main::@1
s: scope:[s]  from main
  to:s::@return
s::@return: scope:[s]  from s
  return 
  to:@return

Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of s
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to s:5 

Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES FOUND
@begin: scope:[]  from
  [0] phi() [ ]
  to:@2
@2: scope:[]  from @begin
  [1] phi() [ ]
  [2] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @2
  [3] phi() [ ]
main: scope:[main]  from @2
  [4] phi() [ ]
  [5] call s param-assignment [ ]
  to:main::@1
main::@1: scope:[main]  from main main::@4
  [6] (byte) main::i#2 ← phi( main::@4/(byte~) main::i#3 main/(byte/signed byte/word/signed word) 0 ) [ main::i#2 ]
  [7] *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0 [ main::i#2 ]
  [8] *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1 [ main::i#2 ]
  [9] (byte) main::i#1 ← ++ (byte) main::i#2 [ main::i#1 ]
  [10] if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@4 [ main::i#1 ]
  to:main::@return
main::@return: scope:[main]  from main::@1
  [11] return  [ ]
  to:@return
main::@4: scope:[main]  from main::@1
  [12] (byte~) main::i#3 ← (byte) main::i#1 [ main::i#3 ]
  to:main::@1
s: scope:[s]  from main
  [13] phi() [ ]
  to:s::@return
s::@return: scope:[s]  from s
  [14] return  [ ]
  to:@return

Created 1 initial phi equivalence classes
Coalesced [12] main::i#3 ← main::i#1
Coalesced down to 1 phi equivalence classes
Culled Empty Block (label) main::@4
Block Sequence Planned @begin @2 @end main main::@1 main::@return s s::@return 
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of s
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - BEFORE EFFECTIVE LIVE RANGES
@begin: scope:[]  from
  [0] phi() [ ]
  to:@2
@2: scope:[]  from @begin
  [1] phi() [ ]
  [2] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @2
  [3] phi() [ ]
main: scope:[main]  from @2
  [4] phi() [ ]
  [5] call s param-assignment [ ]
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [6] (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main/(byte/signed byte/word/signed word) 0 ) [ main::i#2 ]
  [7] *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0 [ main::i#2 ]
  [8] *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1 [ main::i#2 ]
  [9] (byte) main::i#1 ← ++ (byte) main::i#2 [ main::i#1 ]
  [10] if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1 [ main::i#1 ]
  to:main::@return
main::@return: scope:[main]  from main::@1
  [11] return  [ ]
  to:@return
s: scope:[s]  from main
  [12] phi() [ ]
  to:s::@return
s::@return: scope:[s]  from s
  [13] return  [ ]
  to:@return

CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  [0] phi() [ ] ( )
  to:@2
@2: scope:[]  from @begin
  [1] phi() [ ] ( )
  [2] call main param-assignment [ ] ( )
  to:@end
@end: scope:[]  from @2
  [3] phi() [ ] ( )
main: scope:[main]  from @2
  [4] phi() [ ] ( main:2 [ ] )
  [5] call s param-assignment [ ] ( main:2 [ ] )
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [6] (byte) main::i#2 ← phi( main::@1/(byte) main::i#1 main/(byte/signed byte/word/signed word) 0 ) [ main::i#2 ] ( main:2 [ main::i#2 ] )
  [7] *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0 [ main::i#2 ] ( main:2 [ main::i#2 ] )
  [8] *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1 [ main::i#2 ] ( main:2 [ main::i#2 ] )
  [9] (byte) main::i#1 ← ++ (byte) main::i#2 [ main::i#1 ] ( main:2 [ main::i#1 ] )
  [10] if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1 [ main::i#1 ] ( main:2 [ main::i#1 ] )
  to:main::@return
main::@return: scope:[main]  from main::@1
  [11] return  [ ] ( main:2 [ ] )
  to:@return
s: scope:[s]  from main
  [12] phi() [ ] ( main:2::s:5 [ ] )
  to:s::@return
s::@return: scope:[s]  from s
  [13] return  [ ] ( main:2::s:5 [ ] )
  to:@return

DOMINATORS
@begin dominated by  @begin 
@2 dominated by  @2 @begin 
@end dominated by  @2 @begin @end 
main dominated by  @2 @begin main 
main::@1 dominated by  @2 @begin main::@1 main 
main::@return dominated by  main::@return @2 @begin main::@1 main 
s dominated by  @2 @begin s main 
s::@return dominated by  @2 @begin s main s::@return 

Found back edge: Loop head: main::@1 tails: main::@1 blocks: null
Populated: Loop head: main::@1 tails: main::@1 blocks: main::@1 
NATURAL LOOPS
Loop head: main::@1 tails: main::@1 blocks: main::@1 

Found 0 loops in scope []
Found 1 loops in scope [main]
  Loop head: main::@1 tails: main::@1 blocks: main::@1 
Found 0 loops in scope [s]
NATURAL LOOPS WITH DEPTH
Loop head: main::@1 tails: main::@1 blocks: main::@1  depth: 1


VARIABLE REGISTER WEIGHTS
(byte*) SCREEN
(byte) b
(void()) main()
(byte*) main::COLS
(byte) main::col
(byte) main::i
(byte) main::i#1 16.5
(byte) main::i#2 14.666666666666666
(byte()) s()
(byte) s::return

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
Allocated zp ZP_BYTE:2 [ main::i#2 main::i#1 ]
INITIAL ASM
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .const SCREEN = $400
//SEG2 @begin
bbegin:
//SEG3 [1] phi from @begin to @2 [phi:@begin->@2]
b2_from_bbegin:
  jmp b2
//SEG4 @2
b2:
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @2 to main [phi:@2->main]
main_from_b2:
  jsr main
//SEG7 [3] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
    .const col = 2
    .const COLS = $d800
    .label i = 2
  //SEG10 [5] call s param-assignment [ ] ( main:2 [ ] )
  //SEG11 [12] phi from main to s [phi:main->s]
  s_from_main:
    jsr s
  //SEG12 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG13 [6] phi (byte) main::i#2 = (byte/signed byte/word/signed word) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    jmp b1
  //SEG14 [6] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
  //SEG15 [6] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
  //SEG16 main::@1
  b1:
  //SEG17 [7] *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0 [ main::i#2 ] ( main:2 [ main::i#2 ] ) -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #col
    ldx i
    sta COLS,x
  //SEG18 [8] *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1 [ main::i#2 ] ( main:2 [ main::i#2 ] ) -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #(2>>1)+1+1
    ldx i
    sta SCREEN,x
  //SEG19 [9] (byte) main::i#1 ← ++ (byte) main::i#2 [ main::i#1 ] ( main:2 [ main::i#1 ] ) -- vbuz1=_inc_vbuz1 
    inc i
  //SEG20 [10] if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1 [ main::i#1 ] ( main:2 [ main::i#1 ] ) -- vbuz1_neq_vbuc1_then_la1 
    lda i
    cmp #$65
    bne b1_from_b1
    jmp breturn
  //SEG21 main::@return
  breturn:
  //SEG22 [11] return  [ ] ( main:2 [ ] )
    rts
}
//SEG23 s
s: {
    jmp breturn
  //SEG24 s::@return
  breturn:
  //SEG25 [13] return  [ ] ( main:2::s:5 [ ] )
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [7] *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0 [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::i#2 main::i#1 ]
Statement [8] *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1 [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Statement [7] *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0 [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Statement [8] *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1 [ main::i#2 ] ( main:2 [ main::i#2 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::i#2 main::i#1 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 31.17: zp ZP_BYTE:2 [ main::i#2 main::i#1 ] 
Uplift Scope [s] 
Uplift Scope [] 

Uplifting [main] best 375 combination reg byte x [ main::i#2 main::i#1 ] 
Uplifting [s] best 375 combination 
Uplifting [] best 375 combination 

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .const SCREEN = $400
//SEG2 @begin
bbegin:
//SEG3 [1] phi from @begin to @2 [phi:@begin->@2]
b2_from_bbegin:
  jmp b2
//SEG4 @2
b2:
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @2 to main [phi:@2->main]
main_from_b2:
  jsr main
//SEG7 [3] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
    .const col = 2
    .const COLS = $d800
  //SEG10 [5] call s param-assignment [ ] ( main:2 [ ] )
  //SEG11 [12] phi from main to s [phi:main->s]
  s_from_main:
    jsr s
  //SEG12 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG13 [6] phi (byte) main::i#2 = (byte/signed byte/word/signed word) 0 [phi:main->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
  //SEG14 [6] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
  //SEG15 [6] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
  //SEG16 main::@1
  b1:
  //SEG17 [7] *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0 [ main::i#2 ] ( main:2 [ main::i#2 ] ) -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #col
    sta COLS,x
  //SEG18 [8] *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1 [ main::i#2 ] ( main:2 [ main::i#2 ] ) -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #(2>>1)+1+1
    sta SCREEN,x
  //SEG19 [9] (byte) main::i#1 ← ++ (byte) main::i#2 [ main::i#1 ] ( main:2 [ main::i#1 ] ) -- vbuxx=_inc_vbuxx 
    inx
  //SEG20 [10] if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1 [ main::i#1 ] ( main:2 [ main::i#1 ] ) -- vbuxx_neq_vbuc1_then_la1 
    cpx #$65
    bne b1_from_b1
    jmp breturn
  //SEG21 main::@return
  breturn:
  //SEG22 [11] return  [ ] ( main:2 [ ] )
    rts
}
//SEG23 s
s: {
    jmp breturn
  //SEG24 s::@return
  breturn:
  //SEG25 [13] return  [ ] ( main:2::s:5 [ ] )
    rts
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b2
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label b1_from_b1 with b1
Removing instruction bbegin:
Removing instruction b2_from_bbegin:
Removing instruction main_from_b2:
Removing instruction bend_from_b2:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b2:
Removing instruction bend:
Removing instruction s_from_main:
Removing instruction b1_from_main:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
(label) @2
(label) @begin
(label) @end
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = ((byte*))(word/signed word) 1024
(byte) b
(void()) main()
(label) main::@1
(label) main::@return
(byte*) main::COLS
(const byte*) main::COLS#0 COLS = ((byte*))(word) 55296
(byte) main::col
(const byte) main::col#0 col = (byte/signed byte/word/signed word) 2
(byte) main::i
(byte) main::i#1 reg byte x 16.5
(byte) main::i#2 reg byte x 14.666666666666666
(byte()) s()
(label) s::@return
(byte) s::return

reg byte x [ main::i#2 main::i#1 ]

FINAL CODE
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .const SCREEN = $400
//SEG2 @begin
//SEG3 [1] phi from @begin to @2 [phi:@begin->@2]
//SEG4 @2
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @2 to main [phi:@2->main]
  jsr main
//SEG7 [3] phi from @2 to @end [phi:@2->@end]
//SEG8 @end
//SEG9 main
main: {
    .const col = 2
    .const COLS = $d800
  //SEG10 [5] call s param-assignment [ ] ( main:2 [ ] )
  //SEG11 [12] phi from main to s [phi:main->s]
    jsr s
  //SEG12 [6] phi from main to main::@1 [phi:main->main::@1]
  //SEG13 [6] phi (byte) main::i#2 = (byte/signed byte/word/signed word) 0 [phi:main->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG14 [6] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  //SEG15 [6] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@1->main::@1#0] -- register_copy 
  //SEG16 main::@1
  b1:
  //SEG17 [7] *((const byte*) main::COLS#0 + (byte) main::i#2) ← (const byte) main::col#0 [ main::i#2 ] ( main:2 [ main::i#2 ] ) -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #col
    sta COLS,x
  //SEG18 [8] *((const byte*) SCREEN#0 + (byte) main::i#2) ← ++++(byte/signed byte/word/signed word) 2>>(byte/signed byte/word/signed word) 1 [ main::i#2 ] ( main:2 [ main::i#2 ] ) -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #(2>>1)+1+1
    sta SCREEN,x
  //SEG19 [9] (byte) main::i#1 ← ++ (byte) main::i#2 [ main::i#1 ] ( main:2 [ main::i#1 ] ) -- vbuxx=_inc_vbuxx 
    inx
  //SEG20 [10] if((byte) main::i#1!=(byte/signed byte/word/signed word) 101) goto main::@1 [ main::i#1 ] ( main:2 [ main::i#1 ] ) -- vbuxx_neq_vbuc1_then_la1 
    cpx #$65
    bne b1
  //SEG21 main::@return
  //SEG22 [11] return  [ ] ( main:2 [ ] )
    rts
}
//SEG23 s
s: {
  //SEG24 s::@return
  //SEG25 [13] return  [ ] ( main:2::s:5 [ ] )
    rts
}

