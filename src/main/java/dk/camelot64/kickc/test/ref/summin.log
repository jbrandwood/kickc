byte s1=sum(1,2);
byte s2=sum(3,4);
byte s3=sum(9,13);
byte s4=s1+s2+s3;
byte sum(byte a, byte b) {
  return a+b;
}

PROGRAM
  (byte~) $0 ← call sum (byte) 1 (byte) 2 
  (byte) s1 ← (byte~) $0
  (byte~) $1 ← call sum (byte) 3 (byte) 4 
  (byte) s2 ← (byte~) $1
  (byte~) $2 ← call sum (byte) 9 (byte) 13 
  (byte) s3 ← (byte~) $2
  (byte~) $3 ← (byte) s1 + (byte) s2
  (byte~) $4 ← (byte~) $3 + (byte) s3
  (byte) s4 ← (byte~) $4
proc (byte()) sum((byte) sum::a , (byte) sum::b)
  (byte~) sum::$0 ← (byte) sum::a + (byte) sum::b
  (byte) sum::return ← (byte~) sum::$0
  goto sum::@return
sum::@return:
  (byte) sum::return ← (byte) sum::return
  return (byte) sum::return
endproc // sum()

SYMBOLS
(byte~) $0
(byte~) $1
(byte~) $2
(byte~) $3
(byte~) $4
(byte) s1
(byte) s2
(byte) s3
(byte) s4
(byte()) sum((byte) sum::a , (byte) sum::b)
(byte~) sum::$0
(label) sum::@return
(byte) sum::a
(byte) sum::b
(byte) sum::return

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte~) $0 ← call sum (byte) 1 (byte) 2 
  (byte) s1 ← (byte~) $0
  (byte~) $1 ← call sum (byte) 3 (byte) 4 
  (byte) s2 ← (byte~) $1
  (byte~) $2 ← call sum (byte) 9 (byte) 13 
  (byte) s3 ← (byte~) $2
  (byte~) $3 ← (byte) s1 + (byte) s2
  (byte~) $4 ← (byte~) $3 + (byte) s3
  (byte) s4 ← (byte~) $4
  to:@1
sum: scope:[sum]  from
  (byte~) sum::$0 ← (byte) sum::a + (byte) sum::b
  (byte) sum::return ← (byte~) sum::$0
  to:sum::@return
sum::@return: scope:[sum]  from sum sum::@1
  (byte) sum::return ← (byte) sum::return
  return (byte) sum::return
  to:@return
sum::@1: scope:[sum]  from
  to:sum::@return
@1: scope:[]  from @begin
  to:@end
@end: scope:[]  from @1

Removing empty block sum::@1
Removing empty block @1
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte~) $0 ← call sum (byte) 1 (byte) 2 
  (byte) s1 ← (byte~) $0
  (byte~) $1 ← call sum (byte) 3 (byte) 4 
  (byte) s2 ← (byte~) $1
  (byte~) $2 ← call sum (byte) 9 (byte) 13 
  (byte) s3 ← (byte~) $2
  (byte~) $3 ← (byte) s1 + (byte) s2
  (byte~) $4 ← (byte~) $3 + (byte) s3
  (byte) s4 ← (byte~) $4
  to:@end
sum: scope:[sum]  from
  (byte~) sum::$0 ← (byte) sum::a + (byte) sum::b
  (byte) sum::return ← (byte~) sum::$0
  to:sum::@return
sum::@return: scope:[sum]  from sum
  (byte) sum::return ← (byte) sum::return
  return (byte) sum::return
  to:@return
@end: scope:[]  from @begin

PROCEDURE MODIFY VARIABLE ANALYSIS

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  (byte) sum::a ← (byte) 1
  (byte) sum::b ← (byte) 2
  (byte) sum::return ← call sum param-assignment
  to:@2
@2: scope:[]  from @begin
  (byte~) $0 ← (byte) sum::return
  (byte) s1 ← (byte~) $0
  (byte) sum::a ← (byte) 3
  (byte) sum::b ← (byte) 4
  (byte) sum::return ← call sum param-assignment
  to:@3
@3: scope:[]  from @2
  (byte~) $1 ← (byte) sum::return
  (byte) s2 ← (byte~) $1
  (byte) sum::a ← (byte) 9
  (byte) sum::b ← (byte) 13
  (byte) sum::return ← call sum param-assignment
  to:@4
@4: scope:[]  from @3
  (byte~) $2 ← (byte) sum::return
  (byte) s3 ← (byte~) $2
  (byte~) $3 ← (byte) s1 + (byte) s2
  (byte~) $4 ← (byte~) $3 + (byte) s3
  (byte) s4 ← (byte~) $4
  to:@end
sum: scope:[sum]  from @2 @3 @begin
  (byte~) sum::$0 ← (byte) sum::a + (byte) sum::b
  (byte) sum::return ← (byte~) sum::$0
  to:sum::@return
sum::@return: scope:[sum]  from sum
  (byte) sum::return ← (byte) sum::return
  return (byte) sum::return
  to:@return
@end: scope:[]  from @4

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) sum::a#0 ← (byte) 1
  (byte) sum::b#0 ← (byte) 2
  (byte) sum::return#0 ← call sum param-assignment
  to:@2
@2: scope:[]  from @begin
  (byte) sum::return#5 ← phi( @begin/(byte) sum::return#0 )
  (byte~) $0 ← (byte) sum::return#5
  (byte) s1#0 ← (byte~) $0
  (byte) sum::a#1 ← (byte) 3
  (byte) sum::b#1 ← (byte) 4
  (byte) sum::return#1 ← call sum param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) s1#2 ← phi( @2/(byte) s1#0 )
  (byte) sum::return#6 ← phi( @2/(byte) sum::return#1 )
  (byte~) $1 ← (byte) sum::return#6
  (byte) s2#0 ← (byte~) $1
  (byte) sum::a#2 ← (byte) 9
  (byte) sum::b#2 ← (byte) 13
  (byte) sum::return#2 ← call sum param-assignment
  to:@4
@4: scope:[]  from @3
  (byte) s2#1 ← phi( @3/(byte) s2#0 )
  (byte) s1#1 ← phi( @3/(byte) s1#2 )
  (byte) sum::return#7 ← phi( @3/(byte) sum::return#2 )
  (byte~) $2 ← (byte) sum::return#7
  (byte) s3#0 ← (byte~) $2
  (byte~) $3 ← (byte) s1#1 + (byte) s2#1
  (byte~) $4 ← (byte~) $3 + (byte) s3#0
  (byte) s4#0 ← (byte~) $4
  to:@end
sum: scope:[sum]  from @2 @3 @begin
  (byte) sum::b#3 ← phi( @2/(byte) sum::b#1 @3/(byte) sum::b#2 @begin/(byte) sum::b#0 )
  (byte) sum::a#3 ← phi( @2/(byte) sum::a#1 @3/(byte) sum::a#2 @begin/(byte) sum::a#0 )
  (byte~) sum::$0 ← (byte) sum::a#3 + (byte) sum::b#3
  (byte) sum::return#3 ← (byte~) sum::$0
  to:sum::@return
sum::@return: scope:[sum]  from sum
  (byte) sum::return#8 ← phi( sum/(byte) sum::return#3 )
  (byte) sum::return#4 ← (byte) sum::return#8
  return (byte) sum::return#4
  to:@return
@end: scope:[]  from @4

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (byte) sum::a#0 ← (byte) 1
  (byte) sum::b#0 ← (byte) 2
  call sum param-assignment
  (byte) sum::return#0 ← (byte) sum::return#4
  to:@2
@2: scope:[]  from @begin
  (byte) sum::return#5 ← phi( @begin/(byte) sum::return#0 )
  (byte~) $0 ← (byte) sum::return#5
  (byte) s1#0 ← (byte~) $0
  (byte) sum::a#1 ← (byte) 3
  (byte) sum::b#1 ← (byte) 4
  call sum param-assignment
  (byte) sum::return#1 ← (byte) sum::return#4
  to:@3
@3: scope:[]  from @2
  (byte) s1#2 ← phi( @2/(byte) s1#0 )
  (byte) sum::return#6 ← phi( @2/(byte) sum::return#1 )
  (byte~) $1 ← (byte) sum::return#6
  (byte) s2#0 ← (byte~) $1
  (byte) sum::a#2 ← (byte) 9
  (byte) sum::b#2 ← (byte) 13
  call sum param-assignment
  (byte) sum::return#2 ← (byte) sum::return#4
  to:@4
@4: scope:[]  from @3
  (byte) s2#1 ← phi( @3/(byte) s2#0 )
  (byte) s1#1 ← phi( @3/(byte) s1#2 )
  (byte) sum::return#7 ← phi( @3/(byte) sum::return#2 )
  (byte~) $2 ← (byte) sum::return#7
  (byte) s3#0 ← (byte~) $2
  (byte~) $3 ← (byte) s1#1 + (byte) s2#1
  (byte~) $4 ← (byte~) $3 + (byte) s3#0
  (byte) s4#0 ← (byte~) $4
  to:@end
sum: scope:[sum]  from @2 @3 @begin
  (byte) sum::b#3 ← phi( @2/(byte) sum::b#1 @3/(byte) sum::b#2 @begin/(byte) sum::b#0 )
  (byte) sum::a#3 ← phi( @2/(byte) sum::a#1 @3/(byte) sum::a#2 @begin/(byte) sum::a#0 )
  (byte~) sum::$0 ← (byte) sum::a#3 + (byte) sum::b#3
  (byte) sum::return#3 ← (byte~) sum::$0
  to:sum::@return
sum::@return: scope:[sum]  from sum
  (byte) sum::return#8 ← phi( sum/(byte) sum::return#3 )
  (byte) sum::return#4 ← (byte) sum::return#8
  return 
  to:@return
@end: scope:[]  from @4

INITIAL SSA SYMBOL TABLE
(byte~) $0
(byte~) $1
(byte~) $2
(byte~) $3
(byte~) $4
(label) @2
(label) @3
(label) @4
(label) @begin
(label) @end
(byte) s1
(byte) s1#0
(byte) s1#1
(byte) s1#2
(byte) s2
(byte) s2#0
(byte) s2#1
(byte) s3
(byte) s3#0
(byte) s4
(byte) s4#0
(byte()) sum((byte) sum::a , (byte) sum::b)
(byte~) sum::$0
(label) sum::@return
(byte) sum::a
(byte) sum::a#0
(byte) sum::a#1
(byte) sum::a#2
(byte) sum::a#3
(byte) sum::b
(byte) sum::b#0
(byte) sum::b#1
(byte) sum::b#2
(byte) sum::b#3
(byte) sum::return
(byte) sum::return#0
(byte) sum::return#1
(byte) sum::return#2
(byte) sum::return#3
(byte) sum::return#4
(byte) sum::return#5
(byte) sum::return#6
(byte) sum::return#7
(byte) sum::return#8

Not aliassing across scopes: $0 sum::return#5
Not aliassing across scopes: $1 sum::return#6
Not aliassing across scopes: $2 sum::return#7
Alias (byte) sum::return#0 = (byte) sum::return#4 (byte) sum::return#5 (byte) sum::return#1 (byte) sum::return#6 (byte) sum::return#2 (byte) sum::return#7 (byte) sum::return#3 (byte~) sum::$0 (byte) sum::return#8 
Alias (byte) s1#0 = (byte~) $0 (byte) s1#2 (byte) s1#1 
Alias (byte) s2#0 = (byte~) $1 (byte) s2#1 
Alias (byte) s3#0 = (byte~) $2 
Alias (byte) s4#0 = (byte~) $4 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) sum::a#0 ← (byte) 1
  (byte) sum::b#0 ← (byte) 2
  call sum param-assignment
  to:@2
@2: scope:[]  from @begin
  (byte) s1#0 ← (byte) sum::return#0
  (byte) sum::a#1 ← (byte) 3
  (byte) sum::b#1 ← (byte) 4
  call sum param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) s2#0 ← (byte) sum::return#0
  (byte) sum::a#2 ← (byte) 9
  (byte) sum::b#2 ← (byte) 13
  call sum param-assignment
  to:@4
@4: scope:[]  from @3
  (byte) s3#0 ← (byte) sum::return#0
  (byte~) $3 ← (byte) s1#0 + (byte) s2#0
  (byte) s4#0 ← (byte~) $3 + (byte) s3#0
  to:@end
sum: scope:[sum]  from @2 @3 @begin
  (byte) sum::b#3 ← phi( @2/(byte) sum::b#1 @3/(byte) sum::b#2 @begin/(byte) sum::b#0 )
  (byte) sum::a#3 ← phi( @2/(byte) sum::a#1 @3/(byte) sum::a#2 @begin/(byte) sum::a#0 )
  (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3
  to:sum::@return
sum::@return: scope:[sum]  from sum
  return 
  to:@return
@end: scope:[]  from @4

Not aliassing across scopes: s1#0 sum::return#0
Not aliassing across scopes: s2#0 sum::return#0
Not aliassing across scopes: s3#0 sum::return#0
Constant (const byte) sum::a#0 = 1
Constant (const byte) sum::b#0 = 2
Constant (const byte) sum::a#1 = 3
Constant (const byte) sum::b#1 = 4
Constant (const byte) sum::a#2 = 9
Constant (const byte) sum::b#2 = 13
Succesful SSA optimization Pass2ConstantIdentification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call sum param-assignment
  to:@2
@2: scope:[]  from @begin
  (byte) s1#0 ← (byte) sum::return#0
  call sum param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) s2#0 ← (byte) sum::return#0
  call sum param-assignment
  to:@4
@4: scope:[]  from @3
  (byte) s3#0 ← (byte) sum::return#0
  (byte~) $3 ← (byte) s1#0 + (byte) s2#0
  (byte) s4#0 ← (byte~) $3 + (byte) s3#0
  to:@end
sum: scope:[sum]  from @2 @3 @begin
  (byte) sum::b#3 ← phi( @2/(const byte) sum::b#1 @3/(const byte) sum::b#2 @begin/(const byte) sum::b#0 )
  (byte) sum::a#3 ← phi( @2/(const byte) sum::a#1 @3/(const byte) sum::a#2 @begin/(const byte) sum::a#0 )
  (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3
  to:sum::@return
sum::@return: scope:[sum]  from sum
  return 
  to:@return
@end: scope:[]  from @4

Not aliassing across scopes: s1#0 sum::return#0
Not aliassing across scopes: s2#0 sum::return#0
Not aliassing across scopes: s3#0 sum::return#0
Constant inlined sum::a#0 = (byte) 1
Constant inlined sum::a#1 = (byte) 3
Constant inlined sum::a#2 = (byte) 9
Constant inlined sum::b#0 = (byte) 2
Constant inlined sum::b#1 = (byte) 4
Constant inlined sum::b#2 = (byte) 13
Succesful SSA optimization Pass2ConstantInlining
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call sum param-assignment
  to:@2
@2: scope:[]  from @begin
  (byte) s1#0 ← (byte) sum::return#0
  call sum param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) s2#0 ← (byte) sum::return#0
  call sum param-assignment
  to:@4
@4: scope:[]  from @3
  (byte) s3#0 ← (byte) sum::return#0
  (byte~) $3 ← (byte) s1#0 + (byte) s2#0
  (byte) s4#0 ← (byte~) $3 + (byte) s3#0
  to:@end
sum: scope:[sum]  from @2 @3 @begin
  (byte) sum::b#3 ← phi( @2/(byte) 4 @3/(byte) 13 @begin/(byte) 2 )
  (byte) sum::a#3 ← phi( @2/(byte) 3 @3/(byte) 9 @begin/(byte) 1 )
  (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3
  to:sum::@return
sum::@return: scope:[sum]  from sum
  return 
  to:@return
@end: scope:[]  from @4

FINAL SYMBOL TABLE
(byte~) $3
(label) @2
(label) @3
(label) @4
(label) @begin
(label) @end
(byte) s1
(byte) s1#0
(byte) s2
(byte) s2#0
(byte) s3
(byte) s3#0
(byte) s4
(byte) s4#0
(byte()) sum((byte) sum::a , (byte) sum::b)
(label) sum::@return
(byte) sum::a
(byte) sum::a#3
(byte) sum::b
(byte) sum::b#3
(byte) sum::return
(byte) sum::return#0

Block Sequence Planned @begin @2 @3 @4 @end sum sum::@return 
Block Sequence Planned @begin @2 @3 @4 @end sum sum::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  call sum param-assignment
  to:@2
@2: scope:[]  from @begin
  (byte) s1#0 ← (byte) sum::return#0
  call sum param-assignment
  to:@3
@3: scope:[]  from @2
  (byte) s2#0 ← (byte) sum::return#0
  call sum param-assignment
  to:@4
@4: scope:[]  from @3
  (byte) s3#0 ← (byte) sum::return#0
  (byte~) $3 ← (byte) s1#0 + (byte) s2#0
  (byte) s4#0 ← (byte~) $3 + (byte) s3#0
  to:@end
@end: scope:[]  from @4
sum: scope:[sum]  from @2 @3 @begin
  (byte) sum::b#3 ← phi( @2/(byte) 4 @3/(byte) 13 @begin/(byte) 2 )
  (byte) sum::a#3 ← phi( @2/(byte) 3 @3/(byte) 9 @begin/(byte) 1 )
  (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3
  to:sum::@return
sum::@return: scope:[sum]  from sum
  return 
  to:@return

CALL GRAPH
Calls in [] to 0:sum 2:sum 4:sum 

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES FOUND
@begin: scope:[]  from
  [0] call sum param-assignment [ sum::return#0 ]
  to:@2
@2: scope:[]  from @begin
  [1] (byte) s1#0 ← (byte) sum::return#0 [ s1#0 ]
  [2] call sum param-assignment [ s1#0 sum::return#0 ]
  to:@3
@3: scope:[]  from @2
  [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ]
  [4] call sum param-assignment [ s1#0 sum::return#0 s2#0 ]
  to:@4
@4: scope:[]  from @3
  [5] (byte) s3#0 ← (byte) sum::return#0 [ s1#0 s2#0 s3#0 ]
  [6] (byte~) $3 ← (byte) s1#0 + (byte) s2#0 [ s3#0 $3 ]
  [7] (byte) s4#0 ← (byte~) $3 + (byte) s3#0 [ ]
  to:@end
@end: scope:[]  from @4
sum: scope:[sum]  from @2 @3 @begin
  [8] (byte) sum::b#3 ← phi( @2/(byte) 4 @3/(byte) 13 @begin/(byte) 2 ) [ sum::a#3 sum::b#3 ]
  [8] (byte) sum::a#3 ← phi( @2/(byte) 3 @3/(byte) 9 @begin/(byte) 1 ) [ sum::a#3 sum::b#3 ]
  [9] (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3 [ sum::return#0 ]
  to:sum::@return
sum::@return: scope:[sum]  from sum
  [10] return  [ sum::return#0 ]
  to:@return

Created 2 initial phi equivalence classes
Coalesced down to 2 phi equivalence classes
Block Sequence Planned @begin @2 @3 @4 @end sum sum::@return 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  [0] call sum param-assignment [ sum::return#0 ]
  to:@2
@2: scope:[]  from @begin
  [1] (byte) s1#0 ← (byte) sum::return#0 [ s1#0 ]
  [2] call sum param-assignment [ s1#0 sum::return#0 ]
  to:@3
@3: scope:[]  from @2
  [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ]
  [4] call sum param-assignment [ s1#0 sum::return#0 s2#0 ]
  to:@4
@4: scope:[]  from @3
  [5] (byte) s3#0 ← (byte) sum::return#0 [ s1#0 s2#0 s3#0 ]
  [6] (byte~) $3 ← (byte) s1#0 + (byte) s2#0 [ s3#0 $3 ]
  [7] (byte) s4#0 ← (byte~) $3 + (byte) s3#0 [ ]
  to:@end
@end: scope:[]  from @4
sum: scope:[sum]  from @2 @3 @begin
  [8] (byte) sum::b#3 ← phi( @2/(byte) 4 @3/(byte) 13 @begin/(byte) 2 ) [ sum::a#3 sum::b#3 ]
  [8] (byte) sum::a#3 ← phi( @2/(byte) 3 @3/(byte) 9 @begin/(byte) 1 ) [ sum::a#3 sum::b#3 ]
  [9] (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3 [ sum::return#0 ]
  to:sum::@return
sum::@return: scope:[sum]  from sum
  [10] return  [ sum::return#0 ]
  to:@return

DOMINATORS
@begin dominated by  @begin 
@2 dominated by  @2 @begin 
@3 dominated by  @2 @3 @begin 
@4 dominated by  @2 @3 @4 @begin 
@end dominated by  @2 @3 @4 @end @begin 
sum dominated by  @begin sum 
sum::@return dominated by  @begin sum::@return sum 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [sum]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(byte~) $3 4.0
(byte) s1
(byte) s1#0 0.8
(byte) s2
(byte) s2#0 1.3333333333333333
(byte) s3
(byte) s3#0 2.0
(byte) s4
(byte) s4#0 20.0
(byte()) sum((byte) sum::a , (byte) sum::b)
(byte) sum::a
(byte) sum::a#3 2.0
(byte) sum::b
(byte) sum::b#3 2.0
(byte) sum::return
(byte) sum::return#0 1.6

Initial phi equivalence classes
[ sum::a#3 ]
[ sum::b#3 ]
Added variable s1#0 to zero page equivalence class [ s1#0 ]
Added variable s2#0 to zero page equivalence class [ s2#0 ]
Added variable s3#0 to zero page equivalence class [ s3#0 ]
Added variable $3 to zero page equivalence class [ $3 ]
Added variable s4#0 to zero page equivalence class [ s4#0 ]
Added variable sum::return#0 to zero page equivalence class [ sum::return#0 ]
Complete equivalence classes
[ sum::a#3 ]
[ sum::b#3 ]
[ s1#0 ]
[ s2#0 ]
[ s3#0 ]
[ $3 ]
[ s4#0 ]
[ sum::return#0 ]
Allocated zp ZP_BYTE:2 [ sum::a#3 ]
Allocated zp ZP_BYTE:3 [ sum::b#3 ]
Allocated zp ZP_BYTE:4 [ s1#0 ]
Allocated zp ZP_BYTE:5 [ s2#0 ]
Allocated zp ZP_BYTE:6 [ s3#0 ]
Allocated zp ZP_BYTE:7 [ $3 ]
Allocated zp ZP_BYTE:8 [ s4#0 ]
Allocated zp ZP_BYTE:9 [ sum::return#0 ]
INITIAL ASM
//SEG0 Global Constants & labels
  .label _3 = 7
  .label s1 = 4
  .label s2 = 5
  .label s3 = 6
  .label s4 = 8
//SEG1 @begin
bbegin:
//SEG2 [0] call sum param-assignment [ sum::return#0 ]
//SEG3 [8] phi from @begin to sum [phi:@begin->sum]
sum_from_bbegin:
//SEG4 [8] phi (byte) sum::b#3 = (byte) 2 [phi:@begin->sum#0] -- zpby1=coby1 
  lda #2
  sta sum.b
//SEG5 [8] phi (byte) sum::a#3 = (byte) 1 [phi:@begin->sum#1] -- zpby1=coby1 
  lda #1
  sta sum.a
  jsr sum
  jmp b2
//SEG6 @2
b2:
//SEG7 [1] (byte) s1#0 ← (byte) sum::return#0 [ s1#0 ] -- zpby1=zpby2 
  lda sum.return
  sta s1
//SEG8 [2] call sum param-assignment [ s1#0 sum::return#0 ]
//SEG9 [8] phi from @2 to sum [phi:@2->sum]
sum_from_b2:
//SEG10 [8] phi (byte) sum::b#3 = (byte) 4 [phi:@2->sum#0] -- zpby1=coby1 
  lda #4
  sta sum.b
//SEG11 [8] phi (byte) sum::a#3 = (byte) 3 [phi:@2->sum#1] -- zpby1=coby1 
  lda #3
  sta sum.a
  jsr sum
  jmp b3
//SEG12 @3
b3:
//SEG13 [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ] -- zpby1=zpby2 
  lda sum.return
  sta s2
//SEG14 [4] call sum param-assignment [ s1#0 sum::return#0 s2#0 ]
//SEG15 [8] phi from @3 to sum [phi:@3->sum]
sum_from_b3:
//SEG16 [8] phi (byte) sum::b#3 = (byte) 13 [phi:@3->sum#0] -- zpby1=coby1 
  lda #$d
  sta sum.b
//SEG17 [8] phi (byte) sum::a#3 = (byte) 9 [phi:@3->sum#1] -- zpby1=coby1 
  lda #9
  sta sum.a
  jsr sum
  jmp b4
//SEG18 @4
b4:
//SEG19 [5] (byte) s3#0 ← (byte) sum::return#0 [ s1#0 s2#0 s3#0 ] -- zpby1=zpby2 
  lda sum.return
  sta s3
//SEG20 [6] (byte~) $3 ← (byte) s1#0 + (byte) s2#0 [ s3#0 $3 ] -- zpby1=zpby2_plus_zpby3 
  lda s1
  clc
  adc s2
  sta _3
//SEG21 [7] (byte) s4#0 ← (byte~) $3 + (byte) s3#0 [ ] -- zpby1=zpby2_plus_zpby3 
  lda _3
  clc
  adc s3
  sta s4
  jmp bend
//SEG22 @end
bend:
//SEG23 sum
sum: {
    .label return = 9
    .label a = 2
    .label b = 3
  //SEG24 [9] (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3 [ sum::return#0 ] -- zpby1=zpby2_plus_zpby3 
    lda a
    clc
    adc b
    sta return
    jmp breturn
  //SEG25 sum::@return
  breturn:
  //SEG26 [10] return  [ sum::return#0 ]
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp ZP_BYTE:2 [ sum::a#3 ] : zp ZP_BYTE:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ sum::b#3 ] : zp ZP_BYTE:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ s1#0 ] : zp ZP_BYTE:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ s2#0 ] : zp ZP_BYTE:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ s3#0 ] : zp ZP_BYTE:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ $3 ] : zp ZP_BYTE:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ s4#0 ] : zp ZP_BYTE:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:9 [ sum::return#0 ] : zp ZP_BYTE:9 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 20: zp ZP_BYTE:8 [ s4#0 ] 4: zp ZP_BYTE:7 [ $3 ] 2: zp ZP_BYTE:6 [ s3#0 ] 1.33: zp ZP_BYTE:5 [ s2#0 ] 0.8: zp ZP_BYTE:4 [ s1#0 ] 
Uplift Scope [sum] 2: zp ZP_BYTE:2 [ sum::a#3 ] 2: zp ZP_BYTE:3 [ sum::b#3 ] 1.6: zp ZP_BYTE:9 [ sum::return#0 ] 

Uplifting [] best 107 combination reg byte a [ s4#0 ] reg byte a [ $3 ] zp ZP_BYTE:6 [ s3#0 ] reg byte x [ s2#0 ] zp ZP_BYTE:4 [ s1#0 ] 
Uplifting [sum] best 79 combination reg byte y [ sum::a#3 ] reg byte a [ sum::b#3 ] reg byte a [ sum::return#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:6 [ s3#0 ]
Uplifting [] best 79 combination zp ZP_BYTE:6 [ s3#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:4 [ s1#0 ]
Uplifting [] best 79 combination zp ZP_BYTE:4 [ s1#0 ] 
Allocated (was zp ZP_BYTE:4) zp ZP_BYTE:2 [ s1#0 ]
Allocated (was zp ZP_BYTE:6) zp ZP_BYTE:3 [ s3#0 ]
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp bend
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 Global Constants & labels
  .label s1 = 2
  .label s3 = 3
//SEG1 @begin
bbegin:
//SEG2 [0] call sum param-assignment [ sum::return#0 ]
//SEG3 [8] phi from @begin to sum [phi:@begin->sum]
sum_from_bbegin:
//SEG4 [8] phi (byte) sum::b#3 = (byte) 2 [phi:@begin->sum#0] -- aby=coby1 
  lda #2
//SEG5 [8] phi (byte) sum::a#3 = (byte) 1 [phi:@begin->sum#1] -- yby=coby1 
  ldy #1
  jsr sum
//SEG6 @2
b2:
//SEG7 [1] (byte) s1#0 ← (byte) sum::return#0 [ s1#0 ] -- zpby1=aby 
  sta s1
//SEG8 [2] call sum param-assignment [ s1#0 sum::return#0 ]
//SEG9 [8] phi from @2 to sum [phi:@2->sum]
sum_from_b2:
//SEG10 [8] phi (byte) sum::b#3 = (byte) 4 [phi:@2->sum#0] -- aby=coby1 
  lda #4
//SEG11 [8] phi (byte) sum::a#3 = (byte) 3 [phi:@2->sum#1] -- yby=coby1 
  ldy #3
  jsr sum
//SEG12 @3
b3:
//SEG13 [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ] -- xby=aby 
  tax
//SEG14 [4] call sum param-assignment [ s1#0 sum::return#0 s2#0 ]
//SEG15 [8] phi from @3 to sum [phi:@3->sum]
sum_from_b3:
//SEG16 [8] phi (byte) sum::b#3 = (byte) 13 [phi:@3->sum#0] -- aby=coby1 
  lda #$d
//SEG17 [8] phi (byte) sum::a#3 = (byte) 9 [phi:@3->sum#1] -- yby=coby1 
  ldy #9
  jsr sum
//SEG18 @4
b4:
//SEG19 [5] (byte) s3#0 ← (byte) sum::return#0 [ s1#0 s2#0 s3#0 ] -- zpby1=aby 
  sta s3
//SEG20 [6] (byte~) $3 ← (byte) s1#0 + (byte) s2#0 [ s3#0 $3 ] -- aby=zpby1_plus_xby 
  txa
  clc
  adc s1
//SEG21 [7] (byte) s4#0 ← (byte~) $3 + (byte) s3#0 [ ] -- aby=aby_plus_zpby1 
  clc
  adc s3
//SEG22 @end
bend:
//SEG23 sum
sum: {
  //SEG24 [9] (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3 [ sum::return#0 ] -- aby=yby_plus_aby 
    sty $ff
    clc
    adc $ff
  //SEG25 sum::@return
  breturn:
  //SEG26 [10] return  [ sum::return#0 ]
    rts
}

Removing instruction sum_from_bbegin:
Succesful ASM optimization Pass5RedundantLabelElimination
ASSEMBLER
//SEG0 Global Constants & labels
  .label s1 = 2
  .label s3 = 3
//SEG1 @begin
bbegin:
//SEG2 [0] call sum param-assignment [ sum::return#0 ]
//SEG3 [8] phi from @begin to sum [phi:@begin->sum]
//SEG4 [8] phi (byte) sum::b#3 = (byte) 2 [phi:@begin->sum#0] -- aby=coby1 
  lda #2
//SEG5 [8] phi (byte) sum::a#3 = (byte) 1 [phi:@begin->sum#1] -- yby=coby1 
  ldy #1
  jsr sum
//SEG6 @2
b2:
//SEG7 [1] (byte) s1#0 ← (byte) sum::return#0 [ s1#0 ] -- zpby1=aby 
  sta s1
//SEG8 [2] call sum param-assignment [ s1#0 sum::return#0 ]
//SEG9 [8] phi from @2 to sum [phi:@2->sum]
sum_from_b2:
//SEG10 [8] phi (byte) sum::b#3 = (byte) 4 [phi:@2->sum#0] -- aby=coby1 
  lda #4
//SEG11 [8] phi (byte) sum::a#3 = (byte) 3 [phi:@2->sum#1] -- yby=coby1 
  ldy #3
  jsr sum
//SEG12 @3
b3:
//SEG13 [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ] -- xby=aby 
  tax
//SEG14 [4] call sum param-assignment [ s1#0 sum::return#0 s2#0 ]
//SEG15 [8] phi from @3 to sum [phi:@3->sum]
sum_from_b3:
//SEG16 [8] phi (byte) sum::b#3 = (byte) 13 [phi:@3->sum#0] -- aby=coby1 
  lda #$d
//SEG17 [8] phi (byte) sum::a#3 = (byte) 9 [phi:@3->sum#1] -- yby=coby1 
  ldy #9
  jsr sum
//SEG18 @4
b4:
//SEG19 [5] (byte) s3#0 ← (byte) sum::return#0 [ s1#0 s2#0 s3#0 ] -- zpby1=aby 
  sta s3
//SEG20 [6] (byte~) $3 ← (byte) s1#0 + (byte) s2#0 [ s3#0 $3 ] -- aby=zpby1_plus_xby 
  txa
  clc
  adc s1
//SEG21 [7] (byte) s4#0 ← (byte~) $3 + (byte) s3#0 [ ] -- aby=aby_plus_zpby1 
  clc
  adc s3
//SEG22 @end
bend:
//SEG23 sum
sum: {
  //SEG24 [9] (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3 [ sum::return#0 ] -- aby=yby_plus_aby 
    sty $ff
    clc
    adc $ff
  //SEG25 sum::@return
  breturn:
  //SEG26 [10] return  [ sum::return#0 ]
    rts
}

Removing instruction bbegin:
Removing instruction b2:
Removing instruction sum_from_b2:
Removing instruction b3:
Removing instruction sum_from_b3:
Removing instruction b4:
Removing instruction bend:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
ASSEMBLER
//SEG0 Global Constants & labels
  .label s1 = 2
  .label s3 = 3
//SEG1 @begin
//SEG2 [0] call sum param-assignment [ sum::return#0 ]
//SEG3 [8] phi from @begin to sum [phi:@begin->sum]
//SEG4 [8] phi (byte) sum::b#3 = (byte) 2 [phi:@begin->sum#0] -- aby=coby1 
  lda #2
//SEG5 [8] phi (byte) sum::a#3 = (byte) 1 [phi:@begin->sum#1] -- yby=coby1 
  ldy #1
  jsr sum
//SEG6 @2
//SEG7 [1] (byte) s1#0 ← (byte) sum::return#0 [ s1#0 ] -- zpby1=aby 
  sta s1
//SEG8 [2] call sum param-assignment [ s1#0 sum::return#0 ]
//SEG9 [8] phi from @2 to sum [phi:@2->sum]
//SEG10 [8] phi (byte) sum::b#3 = (byte) 4 [phi:@2->sum#0] -- aby=coby1 
  lda #4
//SEG11 [8] phi (byte) sum::a#3 = (byte) 3 [phi:@2->sum#1] -- yby=coby1 
  ldy #3
  jsr sum
//SEG12 @3
//SEG13 [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ] -- xby=aby 
  tax
//SEG14 [4] call sum param-assignment [ s1#0 sum::return#0 s2#0 ]
//SEG15 [8] phi from @3 to sum [phi:@3->sum]
//SEG16 [8] phi (byte) sum::b#3 = (byte) 13 [phi:@3->sum#0] -- aby=coby1 
  lda #$d
//SEG17 [8] phi (byte) sum::a#3 = (byte) 9 [phi:@3->sum#1] -- yby=coby1 
  ldy #9
  jsr sum
//SEG18 @4
//SEG19 [5] (byte) s3#0 ← (byte) sum::return#0 [ s1#0 s2#0 s3#0 ] -- zpby1=aby 
  sta s3
//SEG20 [6] (byte~) $3 ← (byte) s1#0 + (byte) s2#0 [ s3#0 $3 ] -- aby=zpby1_plus_xby 
  txa
  clc
  adc s1
//SEG21 [7] (byte) s4#0 ← (byte~) $3 + (byte) s3#0 [ ] -- aby=aby_plus_zpby1 
  clc
  adc s3
//SEG22 @end
//SEG23 sum
sum: {
  //SEG24 [9] (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3 [ sum::return#0 ] -- aby=yby_plus_aby 
    sty $ff
    clc
    adc $ff
  //SEG25 sum::@return
  //SEG26 [10] return  [ sum::return#0 ]
    rts
}

FINAL SYMBOL TABLE
(byte~) $3 reg byte a 4.0
(label) @2
(label) @3
(label) @4
(label) @begin
(label) @end
(byte) s1
(byte) s1#0 s1 zp ZP_BYTE:2 0.8
(byte) s2
(byte) s2#0 reg byte x 1.3333333333333333
(byte) s3
(byte) s3#0 s3 zp ZP_BYTE:3 2.0
(byte) s4
(byte) s4#0 reg byte a 20.0
(byte()) sum((byte) sum::a , (byte) sum::b)
(label) sum::@return
(byte) sum::a
(byte) sum::a#3 reg byte y 2.0
(byte) sum::b
(byte) sum::b#3 reg byte a 2.0
(byte) sum::return
(byte) sum::return#0 reg byte a 1.6

reg byte y [ sum::a#3 ]
reg byte a [ sum::b#3 ]
zp ZP_BYTE:2 [ s1#0 ]
reg byte x [ s2#0 ]
zp ZP_BYTE:3 [ s3#0 ]
reg byte a [ $3 ]
reg byte a [ s4#0 ]
reg byte a [ sum::return#0 ]

FINAL CODE
//SEG0 Global Constants & labels
  .label s1 = 2
  .label s3 = 3
//SEG1 @begin
//SEG2 [0] call sum param-assignment [ sum::return#0 ]
//SEG3 [8] phi from @begin to sum [phi:@begin->sum]
//SEG4 [8] phi (byte) sum::b#3 = (byte) 2 [phi:@begin->sum#0] -- aby=coby1 
  lda #2
//SEG5 [8] phi (byte) sum::a#3 = (byte) 1 [phi:@begin->sum#1] -- yby=coby1 
  ldy #1
  jsr sum
//SEG6 @2
//SEG7 [1] (byte) s1#0 ← (byte) sum::return#0 [ s1#0 ] -- zpby1=aby 
  sta s1
//SEG8 [2] call sum param-assignment [ s1#0 sum::return#0 ]
//SEG9 [8] phi from @2 to sum [phi:@2->sum]
//SEG10 [8] phi (byte) sum::b#3 = (byte) 4 [phi:@2->sum#0] -- aby=coby1 
  lda #4
//SEG11 [8] phi (byte) sum::a#3 = (byte) 3 [phi:@2->sum#1] -- yby=coby1 
  ldy #3
  jsr sum
//SEG12 @3
//SEG13 [3] (byte) s2#0 ← (byte) sum::return#0 [ s1#0 s2#0 ] -- xby=aby 
  tax
//SEG14 [4] call sum param-assignment [ s1#0 sum::return#0 s2#0 ]
//SEG15 [8] phi from @3 to sum [phi:@3->sum]
//SEG16 [8] phi (byte) sum::b#3 = (byte) 13 [phi:@3->sum#0] -- aby=coby1 
  lda #$d
//SEG17 [8] phi (byte) sum::a#3 = (byte) 9 [phi:@3->sum#1] -- yby=coby1 
  ldy #9
  jsr sum
//SEG18 @4
//SEG19 [5] (byte) s3#0 ← (byte) sum::return#0 [ s1#0 s2#0 s3#0 ] -- zpby1=aby 
  sta s3
//SEG20 [6] (byte~) $3 ← (byte) s1#0 + (byte) s2#0 [ s3#0 $3 ] -- aby=zpby1_plus_xby 
  txa
  clc
  adc s1
//SEG21 [7] (byte) s4#0 ← (byte~) $3 + (byte) s3#0 [ ] -- aby=aby_plus_zpby1 
  clc
  adc s3
//SEG22 @end
//SEG23 sum
sum: {
  //SEG24 [9] (byte) sum::return#0 ← (byte) sum::a#3 + (byte) sum::b#3 [ sum::return#0 ] -- aby=yby_plus_aby 
    sty $ff
    clc
    adc $ff
  //SEG25 sum::@return
  //SEG26 [10] return  [ sum::return#0 ]
    rts
}

