Loading link script "mega65_banked.ld"
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command to memcpy_dma_command
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command4 to memcpy_dma_command4
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memcpy_dma_command256 to memcpy_dma_command256
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command to memset_dma_command
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference memset_dma_command256 to memset_dma_command256
Resolved forward reference MUSIC_END to MUSIC_END
Resolved forward reference MUSIC to MUSIC
Resolved forward reference upperCodeData to upperCodeData
Resolved forward reference musicInit to musicInit
Resolved forward reference irq to __interrupt(hardware_clobber) void irq()
Resolved forward reference MUSIC to MUSIC
Resolved forward reference MUSIC to MUSIC
Resolved forward reference MUSIC to MUSIC
Resolved forward reference MUSIC to MUSIC
Resolved forward reference musicPlay to musicPlay
Fixing struct type size struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = byte1 &memcpy_dma_command
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = byte1 &memcpy_dma_command4
Setting struct to load/store in variable affected by address-of *DMA.ADDRMSB = byte1 &memset_dma_command
Setting inferred volatile on symbol affected by address-of: memoryRemap::aVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap::xVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap::yVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap::zVal in asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::lMb in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::uMb in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::aVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::xVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::yVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Setting inferred volatile on symbol affected by address-of: memoryRemap256M::zVal in asm { ldalMb ldx#$0f ldyuMb ldz#$0f map ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
Inlined call vicSelectGfxBank::$0 = call toDd00(vicSelectGfxBank::gfx)
Inlined call call __init
Eliminating unused variable with no statement memoryRemap::$0
Eliminating unused variable with no statement memoryRemap::$4
Eliminating unused variable with no statement memoryRemap::$5
Eliminating unused variable with no statement memoryRemap::$9
Eliminating unused variable with no statement memoryRemapBlock::$0
Eliminating unused variable with no statement memoryRemapBlock::$1
Eliminating unused variable with no statement memoryRemapBlock::$2
Eliminating unused variable with no statement memcpy_dma_command
Eliminating unused variable with no statement memset_dma_command
Calling convention STACK_CALL adding prepare/execute/finalize for call *musicInit 
Calling convention STACK_CALL adding prepare/execute/finalize for call *musicPlay 

CONTROL FLOW GRAPH SSA

void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
memoryRemap: scope:[memoryRemap]  from irq::@1 main main::@1 memoryRemapBlock
  memoryRemap::upperPageOffset#4 = phi( irq::@1/memoryRemap::upperPageOffset#3, main/memoryRemap::upperPageOffset#1, main::@1/memoryRemap::upperPageOffset#2, memoryRemapBlock/memoryRemap::upperPageOffset#0 )
  memoryRemap::remapBlocks#4 = phi( irq::@1/memoryRemap::remapBlocks#3, main/memoryRemap::remapBlocks#1, main::@1/memoryRemap::remapBlocks#2, memoryRemapBlock/memoryRemap::remapBlocks#0 )
  memoryRemap::lowerPageOffset#4 = phi( irq::@1/memoryRemap::lowerPageOffset#3, main/memoryRemap::lowerPageOffset#1, main::@1/memoryRemap::lowerPageOffset#2, memoryRemapBlock/memoryRemap::lowerPageOffset#0 )
  memoryRemap::aVal = byte0  memoryRemap::lowerPageOffset#4
  memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4
  memoryRemap::$2 = byte1  memoryRemap::lowerPageOffset#4
  memoryRemap::$3 = memoryRemap::$2 & $f
  memoryRemap::xVal = memoryRemap::$1 | memoryRemap::$3
  memoryRemap::yVal = byte0  memoryRemap::upperPageOffset#4
  memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0
  memoryRemap::$7 = byte1  memoryRemap::upperPageOffset#4
  memoryRemap::$8 = memoryRemap::$7 & $f
  memoryRemap::zVal = memoryRemap::$6 | memoryRemap::$8
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  return 
  to:@return

void memoryRemapBlock(char blockPage , unsigned int memoryPage)
memoryRemapBlock: scope:[memoryRemapBlock]  from irq main::@6
  memoryRemapBlock::blockPage#2 = phi( irq/memoryRemapBlock::blockPage#1, main::@6/memoryRemapBlock::blockPage#0 )
  memoryRemapBlock::memoryPage#2 = phi( irq/memoryRemapBlock::memoryPage#1, main::@6/memoryRemapBlock::memoryPage#0 )
  memoryRemapBlock::pageOffset#0 = memoryRemapBlock::memoryPage#2 - memoryRemapBlock::blockPage#2
  memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 / $20
  memoryRemapBlock::blockBits#0 = 1 << memoryRemapBlock::block#0
  memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0
  memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
  memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0
  call memoryRemap
  to:memoryRemapBlock::@1
memoryRemapBlock::@1: scope:[memoryRemapBlock]  from memoryRemapBlock
  to:memoryRemapBlock::@return
memoryRemapBlock::@return: scope:[memoryRemapBlock]  from memoryRemapBlock::@1
  return 
  to:@return

void memcpy_dma4(char dest_bank , void *dest , char src_bank , void *src , unsigned int num)
memcpy_dma4: scope:[memcpy_dma4]  from main::@5
  memcpy_dma4::dest#1 = phi( main::@5/memcpy_dma4::dest#0 )
  memcpy_dma4::dest_bank#1 = phi( main::@5/memcpy_dma4::dest_bank#0 )
  memcpy_dma4::src#1 = phi( main::@5/memcpy_dma4::src#0 )
  memcpy_dma4::src_bank#1 = phi( main::@5/memcpy_dma4::src_bank#0 )
  memcpy_dma4::num#1 = phi( main::@5/memcpy_dma4::num#0 )
  memcpy_dma4::dmaMode#0 = *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  *((unsigned int *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#1
  *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#1
  *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = ((char *)) memcpy_dma4::src#1
  *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#1
  *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = ((char *)) memcpy_dma4::dest#1
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memcpy_dma_command4
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) = byte0 &memcpy_dma_command4
  *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma4::dmaMode#0
  to:memcpy_dma4::@return
memcpy_dma4::@return: scope:[memcpy_dma4]  from memcpy_dma4
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  asm { sei  }
  memoryRemap::remapBlocks#1 = 0
  memoryRemap::lowerPageOffset#1 = 0
  memoryRemap::upperPageOffset#1 = 0
  call memoryRemap
  to:main::@5
main::@5: scope:[main]  from main
  *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47
  *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53
  *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40
  *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40
  *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK
  *PROCPORT = PROCPORT_RAM_IO
  *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1
  main::$1 = MUSIC_END - MUSIC
  memcpy_dma4::dest_bank#0 = 1
  memcpy_dma4::dest#0 = (void *)0
  memcpy_dma4::src_bank#0 = 0
  memcpy_dma4::src#0 = (void *)upperCodeData
  memcpy_dma4::num#0 = main::$1
  call memcpy_dma4
  to:main::@6
main::@6: scope:[main]  from main::@5
  memoryRemapBlock::blockPage#0 = $40
  memoryRemapBlock::memoryPage#0 = $100
  call memoryRemapBlock
  to:main::@7
main::@7: scope:[main]  from main::@6
  asm { lda#0  }
  callexecute *musicInit 
  to:main::@1
main::@1: scope:[main]  from main::@7
  memoryRemap::remapBlocks#2 = 0
  memoryRemap::lowerPageOffset#2 = 0
  memoryRemap::upperPageOffset#2 = 0
  call memoryRemap
  to:main::@8
main::@8: scope:[main]  from main::@1
  *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR
  *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff
  *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f
  *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER
  *HARDWARE_IRQ = &irq
  asm { cli  }
  main::mem_destroy_i#0 = 0
  to:main::@2
main::@2: scope:[main]  from main::@3 main::@8
  main::mem_destroy_i#2 = phi( main::@3/main::mem_destroy_i#3, main::@8/main::mem_destroy_i#0 )
  MUSIC[main::mem_destroy_i#2] = ++ MUSIC[main::mem_destroy_i#2]
  main::mem_destroy_i#1 = ++ main::mem_destroy_i#2
  main::i#0 = 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  main::mem_destroy_i#3 = phi( main::@2/main::mem_destroy_i#1, main::@4/main::mem_destroy_i#4 )
  main::i#2 = phi( main::@2/main::i#0, main::@4/main::i#1 )
  main::$7 = main::i#2 < $f0
  if(main::$7) goto main::@4
  to:main::@2
main::@4: scope:[main]  from main::@3
  main::mem_destroy_i#4 = phi( main::@3/main::mem_destroy_i#3 )
  main::i#3 = phi( main::@3/main::i#2 )
  DEFAULT_SCREEN[main::i#3] = MUSIC[main::i#3]
  main::i#1 = ++ main::i#3
  to:main::@3
main::@return: scope:[main]  from
  return 
  to:@return

__interrupt(hardware_clobber) void irq()
irq: scope:[irq]  from
  *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER
  *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = ++ *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR)
  memoryRemapBlock::blockPage#1 = $40
  memoryRemapBlock::memoryPage#1 = $100
  call memoryRemapBlock
  to:irq::@4
irq::@4: scope:[irq]  from irq
  callexecute *musicPlay 
  to:irq::@1
irq::@1: scope:[irq]  from irq::@4
  memoryRemap::remapBlocks#3 = 0
  memoryRemap::lowerPageOffset#3 = 0
  memoryRemap::upperPageOffset#3 = 0
  call memoryRemap
  to:irq::@5
irq::@5: scope:[irq]  from irq::@1
  irq::raster#0 = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)
  to:irq::@2
irq::@2: scope:[irq]  from irq::@2 irq::@5
  irq::raster#1 = phi( irq::@2/irq::raster#1, irq::@5/irq::raster#0 )
  irq::$5 = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) == irq::raster#1
  if(irq::$5) goto irq::@2
  to:irq::@3
irq::@3: scope:[irq]  from irq::@2
  *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = -- *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR)
  to:irq::@return
irq::@return: scope:[irq]  from irq::@3
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
__constant struct MOS6526_CIA * const CIA1 = (struct MOS6526_CIA *)$dc00
__constant const char CIA_INTERRUPT_CLEAR = $7f
__constant char * const DEFAULT_SCREEN = (char *)$800
__constant struct F018_DMAGIC * const DMA = (struct F018_DMAGIC *)$d700
__constant const char DMA_COMMAND_COPY = 0
__constant void (** const HARDWARE_IRQ)() = (void (**)())$fffe
__constant const char IRQ_RASTER = 1
__constant char MUSIC[] = kickasm {{ .const music = LoadSid("Cybernoid_II_4000.sid")
    .fill music.size, music.getData(i)
 }}
__constant char * const MUSIC_END = (char *)$5200
__constant char OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
__constant char OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
__constant char OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
__constant char OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
__constant char OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG = 0
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
__constant char OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
__constant char OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
__constant char OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
__constant char OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
__constant char OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
__constant char OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
__constant char OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
__constant char OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
__constant char OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
__constant char OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
__constant char OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
__constant char * const PROCPORT = (char *)1
__constant char * const PROCPORT_DDR = (char *)0
__constant const char PROCPORT_DDR_MEMORY_MASK = 7
__constant const char PROCPORT_RAM_IO = 5
__constant struct MOS6569_VICII * const VICII = (struct MOS6569_VICII *)$d000
__constant struct MOS4569_VICIII * const VICIII = (struct MOS4569_VICIII *)$d000
__constant struct MEGA65_VICIV * const VICIV = (struct MEGA65_VICIV *)$d000
void __start()
__interrupt(hardware_clobber) void irq()
bool irq::$5
char irq::raster
char irq::raster#0
char irq::raster#1
void main()
unsigned int main::$1
bool main::$7
char main::i
char main::i#0
char main::i#1
char main::i#2
char main::i#3
char main::mem_destroy_i
char main::mem_destroy_i#0
char main::mem_destroy_i#1
char main::mem_destroy_i#2
char main::mem_destroy_i#3
char main::mem_destroy_i#4
void memcpy_dma4(char dest_bank , void *dest , char src_bank , void *src , unsigned int num)
void *memcpy_dma4::dest
void *memcpy_dma4::dest#0
void *memcpy_dma4::dest#1
char memcpy_dma4::dest_bank
char memcpy_dma4::dest_bank#0
char memcpy_dma4::dest_bank#1
char memcpy_dma4::dmaMode
char memcpy_dma4::dmaMode#0
unsigned int memcpy_dma4::num
unsigned int memcpy_dma4::num#0
unsigned int memcpy_dma4::num#1
void *memcpy_dma4::src
void *memcpy_dma4::src#0
void *memcpy_dma4::src#1
char memcpy_dma4::src_bank
char memcpy_dma4::src_bank#0
char memcpy_dma4::src_bank#1
__loadstore volatile struct DMA_LIST_F018B memcpy_dma_command4 = { command: DMA_COMMAND_COPY, count: 0, src: 0, src_bank: 0, dest: 0, dest_bank: 0, sub_command: 0, modulo: 0 }
void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
char memoryRemap::$1
char memoryRemap::$2
number memoryRemap::$3
number memoryRemap::$6
char memoryRemap::$7
number memoryRemap::$8
__loadstore volatile char memoryRemap::aVal
unsigned int memoryRemap::lowerPageOffset
unsigned int memoryRemap::lowerPageOffset#0
unsigned int memoryRemap::lowerPageOffset#1
unsigned int memoryRemap::lowerPageOffset#2
unsigned int memoryRemap::lowerPageOffset#3
unsigned int memoryRemap::lowerPageOffset#4
char memoryRemap::remapBlocks
char memoryRemap::remapBlocks#0
char memoryRemap::remapBlocks#1
char memoryRemap::remapBlocks#2
char memoryRemap::remapBlocks#3
char memoryRemap::remapBlocks#4
unsigned int memoryRemap::upperPageOffset
unsigned int memoryRemap::upperPageOffset#0
unsigned int memoryRemap::upperPageOffset#1
unsigned int memoryRemap::upperPageOffset#2
unsigned int memoryRemap::upperPageOffset#3
unsigned int memoryRemap::upperPageOffset#4
__loadstore volatile char memoryRemap::xVal
__loadstore volatile char memoryRemap::yVal
__loadstore volatile char memoryRemap::zVal
void memoryRemapBlock(char blockPage , unsigned int memoryPage)
char memoryRemapBlock::block
char memoryRemapBlock::block#0
char memoryRemapBlock::blockBits
char memoryRemapBlock::blockBits#0
char memoryRemapBlock::blockPage
char memoryRemapBlock::blockPage#0
char memoryRemapBlock::blockPage#1
char memoryRemapBlock::blockPage#2
unsigned int memoryRemapBlock::memoryPage
unsigned int memoryRemapBlock::memoryPage#0
unsigned int memoryRemapBlock::memoryPage#1
unsigned int memoryRemapBlock::memoryPage#2
unsigned int memoryRemapBlock::pageOffset
unsigned int memoryRemapBlock::pageOffset#0
__constant void (*musicInit)() = (void (*)())MUSIC
__constant void (*musicPlay)() = (void (*)())MUSIC+3
__constant char upperCodeData[] = kickasm {{ .segmentout [segments="Banked"]
 }}

Adding number conversion cast (unumber) 3 in 
Adding number conversion cast (unumber) 4 in memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4
Adding number conversion cast (unumber) $f in memoryRemap::$3 = memoryRemap::$2 & $f
Adding number conversion cast (unumber) memoryRemap::$3 in memoryRemap::$3 = memoryRemap::$2 & (unumber)$f
Adding number conversion cast (unumber) $f0 in memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0
Adding number conversion cast (unumber) memoryRemap::$6 in memoryRemap::$6 = memoryRemap::remapBlocks#4 & (unumber)$f0
Adding number conversion cast (unumber) $f in memoryRemap::$8 = memoryRemap::$7 & $f
Adding number conversion cast (unumber) memoryRemap::$8 in memoryRemap::$8 = memoryRemap::$7 & (unumber)$f
Adding number conversion cast (unumber) $20 in memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 / $20
Adding number conversion cast (unumber) 1 in memoryRemapBlock::blockBits#0 = 1 << memoryRemapBlock::block#0
Adding number conversion cast (unumber) 1 in *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
Adding number conversion cast (unumber) 0 in *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
Adding number conversion cast (unumber) 0 in *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
Adding number conversion cast (unumber) 0 in memoryRemap::remapBlocks#1 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::lowerPageOffset#1 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::upperPageOffset#1 = 0
Adding number conversion cast (unumber) $47 in *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47
Adding number conversion cast (unumber) $53 in *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53
Adding number conversion cast (unumber) $40 in *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40
Adding number conversion cast (unumber) $40 in *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40
Adding number conversion cast (unumber) 1 in *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1
Adding number conversion cast (unumber) 1 in memcpy_dma4::dest_bank#0 = 1
Adding number conversion cast (unumber) 0 in memcpy_dma4::src_bank#0 = 0
Adding number conversion cast (unumber) $40 in memoryRemapBlock::blockPage#0 = $40
Adding number conversion cast (unumber) $100 in memoryRemapBlock::memoryPage#0 = $100
Adding number conversion cast (unumber) 0 in memoryRemap::remapBlocks#2 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::lowerPageOffset#2 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::upperPageOffset#2 = 0
Adding number conversion cast (unumber) $ff in *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff
Adding number conversion cast (unumber) $7f in *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f
Adding number conversion cast (unumber) $f0 in main::$7 = main::i#2 < $f0
Adding number conversion cast (unumber) $40 in memoryRemapBlock::blockPage#1 = $40
Adding number conversion cast (unumber) $100 in memoryRemapBlock::memoryPage#1 = $100
Adding number conversion cast (unumber) 0 in memoryRemap::remapBlocks#3 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::lowerPageOffset#3 = 0
Adding number conversion cast (unumber) 0 in memoryRemap::upperPageOffset#3 = 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma4::src#1
Inlining cast *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma4::dest#1
Inlining cast *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = (unumber)1
Inlining cast *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = (unumber)0
Inlining cast *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = (unumber)0
Inlining cast memoryRemap::remapBlocks#1 = (unumber)0
Inlining cast memoryRemap::lowerPageOffset#1 = (unumber)0
Inlining cast memoryRemap::upperPageOffset#1 = (unumber)0
Inlining cast *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = (unumber)$47
Inlining cast *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = (unumber)$53
Inlining cast *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = (unumber)1
Inlining cast memcpy_dma4::dest_bank#0 = (unumber)1
Inlining cast memcpy_dma4::src_bank#0 = (unumber)0
Inlining cast memoryRemapBlock::blockPage#0 = (unumber)$40
Inlining cast memoryRemapBlock::memoryPage#0 = (unumber)$100
Inlining cast memoryRemap::remapBlocks#2 = (unumber)0
Inlining cast memoryRemap::lowerPageOffset#2 = (unumber)0
Inlining cast memoryRemap::upperPageOffset#2 = (unumber)0
Inlining cast *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = (unumber)$ff
Inlining cast memoryRemapBlock::blockPage#1 = (unumber)$40
Inlining cast memoryRemapBlock::memoryPage#1 = (unumber)$100
Inlining cast memoryRemap::remapBlocks#3 = (unumber)0
Inlining cast memoryRemap::lowerPageOffset#3 = (unumber)0
Inlining cast memoryRemap::upperPageOffset#3 = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (char *) 0
Simplifying constant pointer cast (char *) 1
Simplifying constant pointer cast (struct MOS6569_VICII *) 53248
Simplifying constant pointer cast (struct MOS4569_VICIII *) 53248
Simplifying constant pointer cast (struct MEGA65_VICIV *) 53248
Simplifying constant pointer cast (struct F018_DMAGIC *) 55040
Simplifying constant pointer cast (char *) 2048
Simplifying constant pointer cast (struct MOS6526_CIA *) 56320
Simplifying constant pointer cast (void (**)()) 65534
Simplifying constant pointer cast (char *) 20992
Simplifying constant integer cast 3
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Simplifying constant integer cast $20
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $47
Simplifying constant integer cast $53
Simplifying constant integer cast $40
Simplifying constant integer cast $40
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant pointer cast (void *) 0
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast $100
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast $7f
Simplifying constant integer cast $f0
Simplifying constant integer cast $40
Simplifying constant integer cast $100
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 3
Finalized unsigned number type (char) 4
Finalized unsigned number type (char) $f
Finalized unsigned number type (char) $f0
Finalized unsigned number type (char) $f
Finalized unsigned number type (char) $20
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $47
Finalized unsigned number type (char) $53
Finalized unsigned number type (char) $40
Finalized unsigned number type (char) $40
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 1
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $40
Finalized unsigned number type (unsigned int) $100
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $ff
Finalized unsigned number type (char) $7f
Finalized unsigned number type (char) $f0
Finalized unsigned number type (char) $40
Finalized unsigned number type (unsigned int) $100
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to char in memoryRemap::$3 = memoryRemap::$2 & $f
Inferred type updated to char in memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0
Inferred type updated to char in memoryRemap::$8 = memoryRemap::$7 & $f
Alias memcpy_dma4::num#0 = main::$1 
Alias main::i#2 = main::i#3 
Alias main::mem_destroy_i#3 = main::mem_destroy_i#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values memcpy_dma4::num#1 memcpy_dma4::num#0
Identical Phi Values memcpy_dma4::src_bank#1 memcpy_dma4::src_bank#0
Identical Phi Values memcpy_dma4::src#1 memcpy_dma4::src#0
Identical Phi Values memcpy_dma4::dest_bank#1 memcpy_dma4::dest_bank#0
Identical Phi Values memcpy_dma4::dest#1 memcpy_dma4::dest#0
Identical Phi Values main::mem_destroy_i#3 main::mem_destroy_i#1
Identical Phi Values irq::raster#1 irq::raster#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$7 [76] if(main::i#2<$f0) goto main::@4
Simple Condition irq::$5 [93] if(*((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)==irq::raster#0) goto irq::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [48] memcpy_dma4::num#0 = MUSIC_END - MUSIC
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemap::remapBlocks#1 = 0
Constant memoryRemap::lowerPageOffset#1 = 0
Constant memoryRemap::upperPageOffset#1 = 0
Constant memcpy_dma4::num#0 = MUSIC_END-MUSIC
Constant memcpy_dma4::dest_bank#0 = 1
Constant memcpy_dma4::dest#0 = (void *) 0
Constant memcpy_dma4::src_bank#0 = 0
Constant memcpy_dma4::src#0 = (void *)upperCodeData
Constant memoryRemapBlock::blockPage#0 = $40
Constant memoryRemapBlock::memoryPage#0 = $100
Constant memoryRemap::remapBlocks#2 = 0
Constant memoryRemap::lowerPageOffset#2 = 0
Constant memoryRemap::upperPageOffset#2 = 0
Constant main::mem_destroy_i#0 = 0
Constant main::i#0 = 0
Constant memoryRemapBlock::blockPage#1 = $40
Constant memoryRemapBlock::memoryPage#1 = $100
Constant memoryRemap::remapBlocks#3 = 0
Constant memoryRemap::lowerPageOffset#3 = 0
Constant memoryRemap::upperPageOffset#3 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (char *)memcpy_dma4::src#0 in [26] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma4::src#0
Constant value identified (char *)memcpy_dma4::dest#0 in [28] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma4::dest#0
Successful SSA optimization Pass2ConstantValues
Simplifying expression containing zero (char *)DMA in [33] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) = byte0 &memcpy_dma_command4
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused constant OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Rewriting division to use shift [15] memoryRemapBlock::block#0 = memoryRemapBlock::blockPage#2 / $20
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings memoryRemap::remapBlocks#1
Inlining constant with var siblings memoryRemap::lowerPageOffset#1
Inlining constant with var siblings memoryRemap::upperPageOffset#1
Inlining constant with var siblings memoryRemap::remapBlocks#2
Inlining constant with var siblings memoryRemap::lowerPageOffset#2
Inlining constant with var siblings memoryRemap::upperPageOffset#2
Inlining constant with var siblings memoryRemap::remapBlocks#3
Inlining constant with var siblings memoryRemap::lowerPageOffset#3
Inlining constant with var siblings memoryRemap::upperPageOffset#3
Inlining constant with var siblings memoryRemapBlock::blockPage#0
Inlining constant with var siblings memoryRemapBlock::memoryPage#0
Inlining constant with var siblings memoryRemapBlock::blockPage#1
Inlining constant with var siblings memoryRemapBlock::memoryPage#1
Inlining constant with var siblings main::mem_destroy_i#0
Inlining constant with var siblings main::i#0
Constant inlined main::mem_destroy_i#0 = 0
Constant inlined memoryRemap::remapBlocks#1 = 0
Constant inlined memoryRemapBlock::blockPage#1 = $40
Constant inlined memoryRemapBlock::blockPage#0 = $40
Constant inlined memoryRemap::remapBlocks#3 = 0
Constant inlined memoryRemap::upperPageOffset#3 = 0
Constant inlined memoryRemap::remapBlocks#2 = 0
Constant inlined memoryRemap::upperPageOffset#1 = 0
Constant inlined memoryRemapBlock::memoryPage#1 = $100
Constant inlined memoryRemap::upperPageOffset#2 = 0
Constant inlined memoryRemapBlock::memoryPage#0 = $100
Constant inlined memoryRemap::lowerPageOffset#3 = 0
Constant inlined memoryRemap::lowerPageOffset#2 = 0
Constant inlined memoryRemap::lowerPageOffset#1 = 0
Constant inlined main::i#0 = 0
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values memoryRemapBlock::memoryPage#2 $100
Identical Phi Values memoryRemapBlock::blockPage#2 $40
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [14] memoryRemapBlock::pageOffset#0 = $100 - $40
Constant right-side identified [15] memoryRemapBlock::block#0 = $40 >> 5
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemapBlock::pageOffset#0 = $100-$40
Constant memoryRemapBlock::block#0 = $40>>5
Successful SSA optimization Pass2ConstantIdentification
Constant memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
Constant memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings memoryRemap::lowerPageOffset#0
Inlining constant with var siblings memoryRemap::upperPageOffset#0
Constant inlined memoryRemap::lowerPageOffset#0 = memoryRemapBlock::pageOffset#0
Constant inlined memoryRemap::upperPageOffset#0 = memoryRemapBlock::pageOffset#0
Successful SSA optimization Pass2ConstantInlining
Constant right-side identified [13] memoryRemapBlock::blockBits#0 = 1 << memoryRemapBlock::block#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memoryRemapBlock::blockBits#0 = 1<<memoryRemapBlock::block#0
Successful SSA optimization Pass2ConstantIdentification
Constant memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings memoryRemap::remapBlocks#0
Constant inlined memoryRemap::remapBlocks#0 = memoryRemapBlock::blockBits#0
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) 8
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (unsigned int) $4000
Successful SSA optimization PassNFinalizeNumberTypeConversions
Added new block during phi lifting main::@9(between main::@3 and main::@2)
Adding NOP phi() at start of irq::@4
Adding NOP phi() at start of irq::@1
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of memoryRemapBlock
Adding NOP phi() at start of memoryRemapBlock::@1
CALL GRAPH
Calls in [irq] to memoryRemapBlock:2 null:4 memoryRemap:6 
Calls in [main] to memoryRemap:12 memcpy_dma4:20 memoryRemapBlock:22 null:24 memoryRemap:26 
Calls in [memoryRemapBlock] to memoryRemap:43 

Created 5 initial phi equivalence classes
Coalesced [38] main::mem_destroy_i#5 = main::mem_destroy_i#1
Coalesced [41] main::i#4 = main::i#1
Coalesced down to 5 phi equivalence classes
Culled Empty Block label main::@9
Culled Empty Block label memoryRemapBlock::@1
Adding NOP phi() at start of irq::@4
Adding NOP phi() at start of irq::@1
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of memoryRemapBlock

FINAL CONTROL FLOW GRAPH

__interrupt(hardware_clobber) void irq()
irq: scope:[irq]  from
  [0] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER
  [1] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = ++ *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR)
  [2] call memoryRemapBlock
  to:irq::@4
irq::@4: scope:[irq]  from irq
  [3] phi()
  [4] callexecute *musicPlay 
  to:irq::@1
irq::@1: scope:[irq]  from irq::@4
  [5] phi()
  [6] call memoryRemap
  to:irq::@5
irq::@5: scope:[irq]  from irq::@1
  [7] irq::raster#0 = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)
  to:irq::@2
irq::@2: scope:[irq]  from irq::@2 irq::@5
  [8] if(*((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)==irq::raster#0) goto irq::@2
  to:irq::@3
irq::@3: scope:[irq]  from irq::@2
  [9] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = -- *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR)
  to:irq::@return
irq::@return: scope:[irq]  from irq::@3
  [10] return 
  to:@return

void main()
main: scope:[main]  from
  asm { sei  }
  [12] call memoryRemap
  to:main::@5
main::@5: scope:[main]  from main
  [13] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47
  [14] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53
  [15] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40
  [16] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40
  [17] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK
  [18] *PROCPORT = PROCPORT_RAM_IO
  [19] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1
  [20] call memcpy_dma4
  to:main::@6
main::@6: scope:[main]  from main::@5
  [21] phi()
  [22] call memoryRemapBlock
  to:main::@7
main::@7: scope:[main]  from main::@6
  asm { lda#0  }
  [24] callexecute *musicInit 
  to:main::@1
main::@1: scope:[main]  from main::@7
  [25] phi()
  [26] call memoryRemap
  to:main::@8
main::@8: scope:[main]  from main::@1
  [27] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR
  [28] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff
  [29] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f
  [30] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER
  [31] *HARDWARE_IRQ = &irq
  asm { cli  }
  to:main::@2
main::@2: scope:[main]  from main::@3 main::@8
  [33] main::mem_destroy_i#2 = phi( main::@3/main::mem_destroy_i#1, main::@8/0 )
  [34] MUSIC[main::mem_destroy_i#2] = ++ MUSIC[main::mem_destroy_i#2]
  [35] main::mem_destroy_i#1 = ++ main::mem_destroy_i#2
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  [36] main::i#2 = phi( main::@2/0, main::@4/main::i#1 )
  [37] if(main::i#2<$f0) goto main::@4
  to:main::@2
main::@4: scope:[main]  from main::@3
  [38] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2]
  [39] main::i#1 = ++ main::i#2
  to:main::@3

void memoryRemapBlock(char blockPage , unsigned int memoryPage)
memoryRemapBlock: scope:[memoryRemapBlock]  from irq main::@6
  [40] phi()
  [41] call memoryRemap
  to:memoryRemapBlock::@return
memoryRemapBlock::@return: scope:[memoryRemapBlock]  from memoryRemapBlock
  [42] return 
  to:@return

void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
memoryRemap: scope:[memoryRemap]  from irq::@1 main main::@1 memoryRemapBlock
  [43] memoryRemap::upperPageOffset#4 = phi( irq::@1/0, main/0, main::@1/0, memoryRemapBlock/memoryRemapBlock::pageOffset#0 )
  [43] memoryRemap::remapBlocks#4 = phi( irq::@1/0, main/0, main::@1/0, memoryRemapBlock/memoryRemapBlock::blockBits#0 )
  [43] memoryRemap::lowerPageOffset#4 = phi( irq::@1/0, main/0, main::@1/0, memoryRemapBlock/memoryRemapBlock::pageOffset#0 )
  [44] memoryRemap::aVal = byte0  memoryRemap::lowerPageOffset#4
  [45] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4
  [46] memoryRemap::$2 = byte1  memoryRemap::lowerPageOffset#4
  [47] memoryRemap::$3 = memoryRemap::$2 & $f
  [48] memoryRemap::xVal = memoryRemap::$1 | memoryRemap::$3
  [49] memoryRemap::yVal = byte0  memoryRemap::upperPageOffset#4
  [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0
  [51] memoryRemap::$7 = byte1  memoryRemap::upperPageOffset#4
  [52] memoryRemap::$8 = memoryRemap::$7 & $f
  [53] memoryRemap::zVal = memoryRemap::$6 | memoryRemap::$8
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  [55] return 
  to:@return

void memcpy_dma4(char dest_bank , void *dest , char src_bank , void *src , unsigned int num)
memcpy_dma4: scope:[memcpy_dma4]  from main::@5
  [56] memcpy_dma4::dmaMode#0 = *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B)
  [57] *((unsigned int *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0
  [58] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0
  [59] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma4::src#0
  [60] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0
  [61] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma4::dest#0
  [62] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1
  [63] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0
  [64] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0
  [65] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memcpy_dma_command4
  [66] *((char *)DMA) = byte0 &memcpy_dma_command4
  [67] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma4::dmaMode#0
  to:memcpy_dma4::@return
memcpy_dma4::@return: scope:[memcpy_dma4]  from memcpy_dma4
  [68] return 
  to:@return


VARIABLE REGISTER WEIGHTS
__interrupt(hardware_clobber) void irq()
char irq::raster
char irq::raster#0 // 6.5
void main()
char main::i
char main::i#1 // 202.0
char main::i#2 // 168.33333333333331
char main::mem_destroy_i
char main::mem_destroy_i#1 // 22.4
char main::mem_destroy_i#2 // 67.0
void memcpy_dma4(char dest_bank , void *dest , char src_bank , void *src , unsigned int num)
void *memcpy_dma4::dest
char memcpy_dma4::dest_bank
char memcpy_dma4::dmaMode
char memcpy_dma4::dmaMode#0 // 2.0
unsigned int memcpy_dma4::num
void *memcpy_dma4::src
char memcpy_dma4::src_bank
__loadstore volatile struct DMA_LIST_F018B memcpy_dma_command4 = { command: DMA_COMMAND_COPY, count: 0, src: 0, src_bank: 0, dest: 0, dest_bank: 0, sub_command: 0, modulo: 0 }
void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
char memoryRemap::$1 // 67.33333333333333
char memoryRemap::$2 // 202.0
char memoryRemap::$3 // 202.0
char memoryRemap::$6 // 67.33333333333333
char memoryRemap::$7 // 202.0
char memoryRemap::$8 // 202.0
__loadstore volatile char memoryRemap::aVal // 10.1
unsigned int memoryRemap::lowerPageOffset
unsigned int memoryRemap::lowerPageOffset#4 // 67.33333333333333
char memoryRemap::remapBlocks
char memoryRemap::remapBlocks#4 // 28.857142857142858
unsigned int memoryRemap::upperPageOffset
unsigned int memoryRemap::upperPageOffset#4 // 25.25
__loadstore volatile char memoryRemap::xVal // 16.833333333333332
__loadstore volatile char memoryRemap::yVal // 20.2
__loadstore volatile char memoryRemap::zVal // 101.0
void memoryRemapBlock(char blockPage , unsigned int memoryPage)
char memoryRemapBlock::block
char memoryRemapBlock::blockBits
char memoryRemapBlock::blockPage
unsigned int memoryRemapBlock::memoryPage
unsigned int memoryRemapBlock::pageOffset

Initial phi equivalence classes
[ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
[ main::i#2 main::i#1 ]
[ memoryRemap::lowerPageOffset#4 ]
[ memoryRemap::remapBlocks#4 ]
[ memoryRemap::upperPageOffset#4 ]
Added variable irq::raster#0 to live range equivalence class [ irq::raster#0 ]
Added variable memoryRemap::aVal to live range equivalence class [ memoryRemap::aVal ]
Added variable memoryRemap::$1 to live range equivalence class [ memoryRemap::$1 ]
Added variable memoryRemap::$2 to live range equivalence class [ memoryRemap::$2 ]
Added variable memoryRemap::$3 to live range equivalence class [ memoryRemap::$3 ]
Added variable memoryRemap::xVal to live range equivalence class [ memoryRemap::xVal ]
Added variable memoryRemap::yVal to live range equivalence class [ memoryRemap::yVal ]
Added variable memoryRemap::$6 to live range equivalence class [ memoryRemap::$6 ]
Added variable memoryRemap::$7 to live range equivalence class [ memoryRemap::$7 ]
Added variable memoryRemap::$8 to live range equivalence class [ memoryRemap::$8 ]
Added variable memoryRemap::zVal to live range equivalence class [ memoryRemap::zVal ]
Added variable memcpy_dma4::dmaMode#0 to live range equivalence class [ memcpy_dma4::dmaMode#0 ]
Added variable memcpy_dma_command4 to live range equivalence class [ memcpy_dma_command4 ]
Complete equivalence classes
[ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
[ main::i#2 main::i#1 ]
[ memoryRemap::lowerPageOffset#4 ]
[ memoryRemap::remapBlocks#4 ]
[ memoryRemap::upperPageOffset#4 ]
[ irq::raster#0 ]
[ memoryRemap::aVal ]
[ memoryRemap::$1 ]
[ memoryRemap::$2 ]
[ memoryRemap::$3 ]
[ memoryRemap::xVal ]
[ memoryRemap::yVal ]
[ memoryRemap::$6 ]
[ memoryRemap::$7 ]
[ memoryRemap::$8 ]
[ memoryRemap::zVal ]
[ memcpy_dma4::dmaMode#0 ]
[ memcpy_dma_command4 ]
Allocated zp[1]:2 [ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
Allocated zp[1]:3 [ main::i#2 main::i#1 ]
Allocated zp[2]:4 [ memoryRemap::lowerPageOffset#4 ]
Allocated zp[1]:6 [ memoryRemap::remapBlocks#4 ]
Allocated zp[2]:7 [ memoryRemap::upperPageOffset#4 ]
Allocated zp[1]:9 [ irq::raster#0 ]
Allocated zp[1]:10 [ memoryRemap::aVal ]
Allocated zp[1]:11 [ memoryRemap::$1 ]
Allocated zp[1]:12 [ memoryRemap::$2 ]
Allocated zp[1]:13 [ memoryRemap::$3 ]
Allocated zp[1]:14 [ memoryRemap::xVal ]
Allocated zp[1]:15 [ memoryRemap::yVal ]
Allocated zp[1]:16 [ memoryRemap::$6 ]
Allocated zp[1]:17 [ memoryRemap::$7 ]
Allocated zp[1]:18 [ memoryRemap::$8 ]
Allocated zp[1]:19 [ memoryRemap::zVal ]
Allocated zp[1]:20 [ memcpy_dma4::dmaMode#0 ]
Allocated mem[12] [ memcpy_dma_command4 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] callexecute *musicPlay  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [10] return  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [13] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [14] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [15] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [16] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [17] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [18] *PROCPORT = PROCPORT_RAM_IO [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [19] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement asm { lda#0  } always clobbers reg byte a 
Statement [24] callexecute *musicInit  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [27] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [28] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [29] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [30] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [31] *HARDWARE_IRQ = &irq [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [38] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2] [ main::mem_destroy_i#1 main::i#2 ] (  [ main::mem_destroy_i#1 main::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ main::i#2 main::i#1 ]
Statement [44] memoryRemap::aVal = byte0  memoryRemap::lowerPageOffset#4 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] ( memoryRemap:6 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  memoryRemap:26 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:6 [ memoryRemap::remapBlocks#4 ]
Statement [45] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] ( memoryRemap:6 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  memoryRemap:26 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  ) always clobbers reg byte a 
Statement [47] memoryRemap::$3 = memoryRemap::$2 & $f [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] ( memoryRemap:6 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemap:26 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:11 [ memoryRemap::$1 ]
Statement [49] memoryRemap::yVal = byte0  memoryRemap::upperPageOffset#4 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] ( memoryRemap:6 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  memoryRemap:26 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  ) always clobbers reg byte a 
Statement [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] ( memoryRemap:6 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  memoryRemap:26 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  ) always clobbers reg byte a 
Statement [52] memoryRemap::$8 = memoryRemap::$7 & $f [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] ( memoryRemap:6 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemap:26 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:16 [ memoryRemap::$6 ]
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [57] *((unsigned int *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:20 [ memcpy_dma4::dmaMode#0 ]
Statement [58] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [59] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma4::src#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [60] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [61] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma4::dest#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [62] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [63] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [64] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [65] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memcpy_dma_command4 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [66] *((char *)DMA) = byte0 &memcpy_dma_command4 [ memcpy_dma4::dmaMode#0 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [0] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] callexecute *musicPlay  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [10] return  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [13] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [14] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [15] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [16] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [17] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [18] *PROCPORT = PROCPORT_RAM_IO [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [19] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1 [ memcpy_dma_command4 ] (  [ memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement asm { lda#0  } always clobbers reg byte a 
Statement [24] callexecute *musicInit  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [27] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [28] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [29] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [30] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [31] *HARDWARE_IRQ = &irq [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [38] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2] [ main::mem_destroy_i#1 main::i#2 ] (  [ main::mem_destroy_i#1 main::i#2 ] { }  ) always clobbers reg byte a 
Statement [44] memoryRemap::aVal = byte0  memoryRemap::lowerPageOffset#4 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] ( memoryRemap:6 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  memoryRemap:26 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal ] { }  ) always clobbers reg byte a 
Statement [45] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] ( memoryRemap:6 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  memoryRemap:26 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::lowerPageOffset#4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 ] { }  ) always clobbers reg byte a 
Statement [47] memoryRemap::$3 = memoryRemap::$2 & $f [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] ( memoryRemap:6 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemap:26 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::$1 memoryRemap::$3 ] { }  ) always clobbers reg byte a 
Statement [49] memoryRemap::yVal = byte0  memoryRemap::upperPageOffset#4 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] ( memoryRemap:6 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  memoryRemap:26 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::remapBlocks#4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal ] { }  ) always clobbers reg byte a 
Statement [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] ( memoryRemap:6 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  memoryRemap:26 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::upperPageOffset#4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 ] { }  ) always clobbers reg byte a 
Statement [52] memoryRemap::$8 = memoryRemap::$7 & $f [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] ( memoryRemap:6 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemap:12 [ memcpy_dma_command4 memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemap:26 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:2::memoryRemap:41 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  memoryRemapBlock:22::memoryRemap:41 [ memoryRemap::aVal memoryRemap::xVal memoryRemap::yVal memoryRemap::$6 memoryRemap::$8 ] { }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [57] *((unsigned int *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [58] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [59] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma4::src#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [60] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [61] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma4::dest#0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [62] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [63] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [64] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [65] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memcpy_dma_command4 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 memcpy_dma_command4 ] { }  ) always clobbers reg byte a 
Statement [66] *((char *)DMA) = byte0 &memcpy_dma_command4 [ memcpy_dma4::dmaMode#0 ] ( memcpy_dma4:20 [ memcpy_dma4::dmaMode#0 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::mem_destroy_i#2 main::mem_destroy_i#1 ] : zp[1]:2 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:3 [ main::i#2 main::i#1 ] : zp[1]:3 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:4 [ memoryRemap::lowerPageOffset#4 ] : zp[2]:4 , 
Potential registers zp[1]:6 [ memoryRemap::remapBlocks#4 ] : zp[1]:6 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:7 [ memoryRemap::upperPageOffset#4 ] : zp[2]:7 , 
Potential registers zp[1]:9 [ irq::raster#0 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:10 [ memoryRemap::aVal ] : zp[1]:10 , 
Potential registers zp[1]:11 [ memoryRemap::$1 ] : zp[1]:11 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:12 [ memoryRemap::$2 ] : zp[1]:12 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:13 [ memoryRemap::$3 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:14 [ memoryRemap::xVal ] : zp[1]:14 , 
Potential registers zp[1]:15 [ memoryRemap::yVal ] : zp[1]:15 , 
Potential registers zp[1]:16 [ memoryRemap::$6 ] : zp[1]:16 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:17 [ memoryRemap::$7 ] : zp[1]:17 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:18 [ memoryRemap::$8 ] : zp[1]:18 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:19 [ memoryRemap::zVal ] : zp[1]:19 , 
Potential registers zp[1]:20 [ memcpy_dma4::dmaMode#0 ] : zp[1]:20 , reg byte x , reg byte y , reg byte z , 
Potential registers mem[12] [ memcpy_dma_command4 ] : mem[12] , 

REGISTER UPLIFT SCOPES
Uplift Scope [memoryRemap] 202: zp[1]:12 [ memoryRemap::$2 ] 202: zp[1]:13 [ memoryRemap::$3 ] 202: zp[1]:17 [ memoryRemap::$7 ] 202: zp[1]:18 [ memoryRemap::$8 ] 101: zp[1]:19 [ memoryRemap::zVal ] 67.33: zp[2]:4 [ memoryRemap::lowerPageOffset#4 ] 67.33: zp[1]:11 [ memoryRemap::$1 ] 67.33: zp[1]:16 [ memoryRemap::$6 ] 28.86: zp[1]:6 [ memoryRemap::remapBlocks#4 ] 25.25: zp[2]:7 [ memoryRemap::upperPageOffset#4 ] 20.2: zp[1]:15 [ memoryRemap::yVal ] 16.83: zp[1]:14 [ memoryRemap::xVal ] 10.1: zp[1]:10 [ memoryRemap::aVal ] 
Uplift Scope [main] 370.33: zp[1]:3 [ main::i#2 main::i#1 ] 89.4: zp[1]:2 [ main::mem_destroy_i#2 main::mem_destroy_i#1 ] 
Uplift Scope [irq] 6.5: zp[1]:9 [ irq::raster#0 ] 
Uplift Scope [memcpy_dma4] 2: zp[1]:20 [ memcpy_dma4::dmaMode#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [MOS4569_VICIII] 
Uplift Scope [MEGA65_VICIV] 
Uplift Scope [memoryRemapBlock] 
Uplift Scope [F018_DMAGIC] 
Uplift Scope [DMA_LIST_F018A] 
Uplift Scope [DMA_LIST_F018B] 
Uplift Scope [] 0: mem[12] [ memcpy_dma_command4 ] 

Uplifting [memoryRemap] best 4820 combination reg byte a [ memoryRemap::$2 ] reg byte a [ memoryRemap::$3 ] reg byte a [ memoryRemap::$7 ] zp[1]:18 [ memoryRemap::$8 ] zp[1]:19 [ memoryRemap::zVal ] zp[2]:4 [ memoryRemap::lowerPageOffset#4 ] zp[1]:11 [ memoryRemap::$1 ] zp[1]:16 [ memoryRemap::$6 ] zp[1]:6 [ memoryRemap::remapBlocks#4 ] zp[2]:7 [ memoryRemap::upperPageOffset#4 ] zp[1]:15 [ memoryRemap::yVal ] zp[1]:14 [ memoryRemap::xVal ] zp[1]:10 [ memoryRemap::aVal ] 
Limited combination testing to 100 combinations of 40000 possible.
Uplifting [main] best 3530 combination reg byte y [ main::i#2 main::i#1 ] reg byte x [ main::mem_destroy_i#2 main::mem_destroy_i#1 ] 
Uplifting [irq] best 3497 combination reg byte a [ irq::raster#0 ] 
Uplifting [memcpy_dma4] best 3491 combination reg byte x [ memcpy_dma4::dmaMode#0 ] 
Uplifting [MOS6526_CIA] best 3491 combination 
Uplifting [MOS6569_VICII] best 3491 combination 
Uplifting [MOS6581_SID] best 3491 combination 
Uplifting [MOS4569_VICIII] best 3491 combination 
Uplifting [MEGA65_VICIV] best 3491 combination 
Uplifting [memoryRemapBlock] best 3491 combination 
Uplifting [F018_DMAGIC] best 3491 combination 
Uplifting [DMA_LIST_F018A] best 3491 combination 
Uplifting [DMA_LIST_F018B] best 3491 combination 
Uplifting [] best 3491 combination mem[12] [ memcpy_dma_command4 ] 
Attempting to uplift remaining variables inzp[1]:18 [ memoryRemap::$8 ]
Uplifting [memoryRemap] best 3485 combination reg byte a [ memoryRemap::$8 ] 
Attempting to uplift remaining variables inzp[1]:19 [ memoryRemap::zVal ]
Uplifting [memoryRemap] best 3485 combination zp[1]:19 [ memoryRemap::zVal ] 
Attempting to uplift remaining variables inzp[1]:11 [ memoryRemap::$1 ]
Uplifting [memoryRemap] best 3485 combination zp[1]:11 [ memoryRemap::$1 ] 
Attempting to uplift remaining variables inzp[1]:16 [ memoryRemap::$6 ]
Uplifting [memoryRemap] best 3485 combination zp[1]:16 [ memoryRemap::$6 ] 
Attempting to uplift remaining variables inzp[1]:6 [ memoryRemap::remapBlocks#4 ]
Uplifting [memoryRemap] best 3469 combination reg byte z [ memoryRemap::remapBlocks#4 ] 
Attempting to uplift remaining variables inzp[1]:15 [ memoryRemap::yVal ]
Uplifting [memoryRemap] best 3469 combination zp[1]:15 [ memoryRemap::yVal ] 
Attempting to uplift remaining variables inzp[1]:14 [ memoryRemap::xVal ]
Uplifting [memoryRemap] best 3469 combination zp[1]:14 [ memoryRemap::xVal ] 
Attempting to uplift remaining variables inzp[1]:10 [ memoryRemap::aVal ]
Uplifting [memoryRemap] best 3469 combination zp[1]:10 [ memoryRemap::aVal ] 
Allocated (was zp[2]:4) zp[2]:2 [ memoryRemap::lowerPageOffset#4 ]
Allocated (was zp[2]:7) zp[2]:4 [ memoryRemap::upperPageOffset#4 ]
Allocated (was zp[1]:10) zp[1]:6 [ memoryRemap::aVal ]
Allocated (was zp[1]:11) zp[1]:7 [ memoryRemap::$1 ]
Allocated (was zp[1]:14) zp[1]:8 [ memoryRemap::xVal ]
Allocated (was zp[1]:15) zp[1]:9 [ memoryRemap::yVal ]
Allocated (was zp[1]:16) zp[1]:10 [ memoryRemap::$6 ]
Allocated (was zp[1]:19) zp[1]:11 [ memoryRemap::zVal ]
Interrupt procedure irq clobbers AXYZcnzvidePSB

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// SID music located in another bank being played in a raster IRQ using memory mapping on the MEGA65
// Music is Cybernoid II by Jeroen Tel released in 1988 by Hewson https://csdb.dk/sid/?id=28140
// SID relocated using http://www.linusakesson.net/software/sidreloc/index.php
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable with banked code and data starting in MEGA65 mode.
.file [name="banked-music.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segmentdef Banked [segments="CodeBanked, DataBanked"]
.segmentdef CodeBanked [start=$4000]
.segmentdef DataBanked [startAfter="CodeBanked"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  /// Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  /// VICII IRQ Status/Enable Raster
  // @see #IRQ_ENABLE #IRQ_STATUS
  ///  0 | RST| Reaching a certain raster line. The line is specified by writing
  ///    |    | to register 0xd012 and bit 7 of $d011 and internally stored by
  ///    |    | the VIC for the raster compare. The test for reaching the
  ///    |    | interrupt raster line is done in cycle 0 of every line (for line
  ///    |    | 0, in cycle 1).
  .const IRQ_RASTER = 1
  /// DMA command copy
  .const DMA_COMMAND_COPY = 0
  /// Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  /// RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
  .const OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
  /// Processor port data direction register
  .label PROCPORT_DDR = 0
  /// Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  /// The VIC-II MOS 6567/6569
  .label VICII = $d000
  /// The VIC III MOS 4567/4569
  .label VICIII = $d000
  /// The VIC IV
  .label VICIV = $d000
  /// DMAgic F018 Controller
  .label DMA = $d700
  /// Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
  /// The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  /// The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Address after the end of the music
  .label MUSIC_END = $5200
  // Pointer to the music init routine
  .label musicInit = MUSIC
  // Pointer to the music play routine
  .label musicPlay = MUSIC+3
.segment Code
  // irq
// Raster IRQ routine
irq: {
    // interrupt(isr_hardware_clobber_entry) -- isr_hardware_all_entry 
    pha
    phx
    phy
    phz
    // [0] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // [1] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = ++ *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // [2] call memoryRemapBlock
  // Remap memory to put music at $4000
    // [40] phi from irq to memoryRemapBlock [phi:irq->memoryRemapBlock]
  memoryRemapBlock_from_irq:
    jsr memoryRemapBlock
    // [3] phi from irq to irq::@4 [phi:irq->irq::@4]
  __b4_from_irq:
    jmp __b4
    // irq::@4
  __b4:
    // [4] callexecute *musicPlay  -- call__deref_pprc1 
    // Play remapped SID
    jsr musicPlay
    // [5] phi from irq::@4 to irq::@1 [phi:irq::@4->irq::@1]
  __b1_from___b4:
    jmp __b1
    // irq::@1
  __b1:
    // [6] call memoryRemap
  // Reset memory mapping
    // [43] phi from irq::@1 to memoryRemap [phi:irq::@1->memoryRemap]
  memoryRemap_from___b1:
    // [43] phi memoryRemap::upperPageOffset#4 = 0 [phi:irq::@1->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    lda #>0
    sta.z memoryRemap.upperPageOffset+1
    // [43] phi memoryRemap::remapBlocks#4 = 0 [phi:irq::@1->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [43] phi memoryRemap::lowerPageOffset#4 = 0 [phi:irq::@1->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.lowerPageOffset
    lda #>0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __b5
    // irq::@5
  __b5:
    // [7] irq::raster#0 = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) -- vbuaa=_deref_pbuc1 
    // Wait for the next raster line
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    jmp __b2
    // irq::@2
  __b2:
    // [8] if(*((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)==irq::raster#0) goto irq::@2 -- _deref_pbuc1_eq_vbuaa_then_la1 
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    beq __b2
    jmp __b3
    // irq::@3
  __b3:
    // [9] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = -- *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    jmp __breturn
    // irq::@return
  __breturn:
    // [10] return 
    // interrupt(isr_hardware_clobber_exit) -- isr_hardware_all_exit 
    plz
    ply
    plx
    pla
    rti
}
  // main
main: {
    // asm { sei  }
    // Stop IRQ's
    sei
    // [12] call memoryRemap
  // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    // [43] phi from main to memoryRemap [phi:main->memoryRemap]
  memoryRemap_from_main:
    // [43] phi memoryRemap::upperPageOffset#4 = 0 [phi:main->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    lda #>0
    sta.z memoryRemap.upperPageOffset+1
    // [43] phi memoryRemap::remapBlocks#4 = 0 [phi:main->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [43] phi memoryRemap::lowerPageOffset#4 = 0 [phi:main->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.lowerPageOffset
    lda #>0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __b5
    // main::@5
  __b5:
    // [13] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47 -- _deref_pbuc1=vbuc2 
    // Enable MEGA65 features
    lda #$47
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // [14] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53 -- _deref_pbuc1=vbuc2 
    lda #$53
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // [15] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable 48MHz fast mode
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // [16] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // [17] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // no kernal or BASIC rom visible
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // [18] *PROCPORT = PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // [19] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1 -- _deref_pbuc1=vbuc2 
    // open sideborder
    lda #1
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO
    // [20] call memcpy_dma4
    // Transfer banked code/data to upper memory ($10000)
    jsr memcpy_dma4
    // [21] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    jmp __b6
    // main::@6
  __b6:
    // [22] call memoryRemapBlock
  // Remap [$4000-$5fff] to point to [$10000-$11fff]
    // [40] phi from main::@6 to memoryRemapBlock [phi:main::@6->memoryRemapBlock]
  memoryRemapBlock_from___b6:
    jsr memoryRemapBlock
    jmp __b7
    // main::@7
  __b7:
    // asm { lda#0  }
    // Initialize SID 
    lda #0
    // [24] callexecute *musicInit  -- call__deref_pprc1 
    jsr musicInit
    // [25] phi from main::@7 to main::@1 [phi:main::@7->main::@1]
  __b1_from___b7:
    jmp __b1
    // main::@1
  __b1:
    // [26] call memoryRemap
  // Reset memory mapping
    // [43] phi from main::@1 to memoryRemap [phi:main::@1->memoryRemap]
  memoryRemap_from___b1:
    // [43] phi memoryRemap::upperPageOffset#4 = 0 [phi:main::@1->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    lda #>0
    sta.z memoryRemap.upperPageOffset+1
    // [43] phi memoryRemap::remapBlocks#4 = 0 [phi:main::@1->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [43] phi memoryRemap::lowerPageOffset#4 = 0 [phi:main::@1->memoryRemap#2] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.lowerPageOffset
    lda #>0
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __b8
    // main::@8
  __b8:
    // [27] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Set up raster interrupts C64 style
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // [28] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff -- _deref_pbuc1=vbuc2 
    // Set raster line to 0xff
    lda #$ff
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [29] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // [30] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // [31] *HARDWARE_IRQ = &irq -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta HARDWARE_IRQ
    lda #>irq
    sta HARDWARE_IRQ+1
    // asm { cli  }
    // Enable IRQ
    cli
    // [33] phi from main::@8 to main::@2 [phi:main::@8->main::@2]
  __b2_from___b8:
    // [33] phi main::mem_destroy_i#2 = 0 [phi:main::@8->main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b2
    // main::@2
  __b2:
    // [34] MUSIC[main::mem_destroy_i#2] = ++ MUSIC[main::mem_destroy_i#2] -- pbuc1_derefidx_vbuxx=_inc_pbuc1_derefidx_vbuxx 
    inc MUSIC,x
    // [35] main::mem_destroy_i#1 = ++ main::mem_destroy_i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [36] phi main::i#2 = 0 [phi:main::@2->main::@3#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b3
  // Show unmapped MUSIC memory
    // main::@3
  __b3:
    // [37] if(main::i#2<$f0) goto main::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$f0
    bcc __b4
    // [33] phi from main::@3 to main::@2 [phi:main::@3->main::@2]
  __b2_from___b3:
    // [33] phi main::mem_destroy_i#2 = main::mem_destroy_i#1 [phi:main::@3->main::@2#0] -- register_copy 
    jmp __b2
    // main::@4
  __b4:
    // [38] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2] -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MUSIC,y
    sta DEFAULT_SCREEN,y
    // [39] main::i#1 = ++ main::i#2 -- vbuyy=_inc_vbuyy 
    iny
    // [36] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [36] phi main::i#2 = main::i#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
}
  // memoryRemapBlock
// Remap a single 8K memory block in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// All the other 8K memory blocks will not be mapped and will point to their own address in the lowest 64K of the MEGA65 memory.
// blockPage: Page address of the 8K memory block to remap (ie. the block that is remapped is $100 * the passed page address.)
// memoryPage: Page address of the memory that the block should point to in the 1MB memory space of the MEGA65.
// Ie. the memory that will be pointed to is $100 * the passed page address. Only the lower 12bits of the passed value is used.
// void memoryRemapBlock(char blockPage, unsigned int memoryPage)
memoryRemapBlock: {
    // Find the page offset (the number of pages to offset the block)
    .const pageOffset = $100-$40
    // Which block is being remapped? (0-7)
    .const block = $40>>5
    .const blockBits = 1<<block
    // [41] call memoryRemap
    // [43] phi from memoryRemapBlock to memoryRemap [phi:memoryRemapBlock->memoryRemap]
  memoryRemap_from_memoryRemapBlock:
    // [43] phi memoryRemap::upperPageOffset#4 = memoryRemapBlock::pageOffset#0 [phi:memoryRemapBlock->memoryRemap#0] -- vwuz1=vwuc1 
    lda #<pageOffset
    sta.z memoryRemap.upperPageOffset
    lda #>pageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [43] phi memoryRemap::remapBlocks#4 = memoryRemapBlock::blockBits#0 [phi:memoryRemapBlock->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #blockBits
    // [43] phi memoryRemap::lowerPageOffset#4 = memoryRemapBlock::pageOffset#0 [phi:memoryRemapBlock->memoryRemap#2] -- vwuz1=vwuc1 
    lda #<pageOffset
    sta.z memoryRemap.lowerPageOffset
    lda #>pageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    jmp __breturn
    // memoryRemapBlock::@return
  __breturn:
    // [42] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// void memoryRemap(__register(Z) char remapBlocks, __zp(2) unsigned int lowerPageOffset, __zp(4) unsigned int upperPageOffset)
memoryRemap: {
    .label aVal = 6
    .label xVal = 8
    .label __1 = 7
    .label yVal = 9
    .label zVal = $b
    .label __6 = $a
    .label lowerPageOffset = 2
    .label upperPageOffset = 4
    // [44] memoryRemap::aVal = byte0  memoryRemap::lowerPageOffset#4 -- vbuz1=_byte0_vwuz2 
    // lower blocks offset page low
    lda.z lowerPageOffset
    sta.z aVal
    // [45] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __1
    // [46] memoryRemap::$2 = byte1  memoryRemap::lowerPageOffset#4 -- vbuaa=_byte1_vwuz1 
    lda.z lowerPageOffset+1
    // [47] memoryRemap::$3 = memoryRemap::$2 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [48] memoryRemap::xVal = memoryRemap::$1 | memoryRemap::$3 -- vbuz1=vbuz2_bor_vbuaa 
    // lower blocks to map + lower blocks offset high nibble
    ora.z __1
    sta.z xVal
    // [49] memoryRemap::yVal = byte0  memoryRemap::upperPageOffset#4 -- vbuz1=_byte0_vwuz2 
    // upper blocks offset page
    lda.z upperPageOffset
    sta.z yVal
    // [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0 -- vbuz1=vbuzz_band_vbuc1 
    tza
    and #$f0
    sta.z __6
    // [51] memoryRemap::$7 = byte1  memoryRemap::upperPageOffset#4 -- vbuaa=_byte1_vwuz1 
    lda.z upperPageOffset+1
    // [52] memoryRemap::$8 = memoryRemap::$7 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // [53] memoryRemap::zVal = memoryRemap::$6 | memoryRemap::$8 -- vbuz1=vbuz2_bor_vbuaa 
    // upper blocks to map + upper blocks offset page high nibble
    ora.z __6
    sta.z zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [55] return 
    rts
}
  // memcpy_dma4
// Copy a memory block anywhere in first 4MB memory space using MEGA65 DMagic DMA
// Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination.
// - dest_bank The 64KB bank for the destination (0-63)
// - dest The destination address (within the MB and bank)
// - src_bank The 64KB bank for the source (0-63)
// - src The source address (within the MB and bank)
// - num The number of bytes to copy
// void memcpy_dma4(char dest_bank, void *dest, char src_bank, void *src, unsigned int num)
memcpy_dma4: {
    .const num = MUSIC_END-MUSIC
    .const dest_bank = 1
    .const src_bank = 0
    .label dest = 0
    .label src = upperCodeData
    // [56] memcpy_dma4::dmaMode#0 = *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [57] *((unsigned int *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0 -- _deref_pwuc1=vwuc2 
    // Set up command
    lda #<num
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // [58] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0 -- _deref_pbuc1=vbuc2 
    lda #src_bank
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK
    // [59] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma4::src#0 -- _deref_qbuc1=pbuc2 
    lda #<src
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>src
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // [60] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0 -- _deref_pbuc1=vbuc2 
    lda #dest_bank
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
    // [61] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma4::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // [62] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [63] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // [64] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // [65] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memcpy_dma_command4 -- _deref_pbuc1=vbuc2 
    lda #>memcpy_dma_command4
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // [66] *((char *)DMA) = byte0 &memcpy_dma_command4 -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<memcpy_dma_command4
    sta DMA
    // [67] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma4::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    jmp __breturn
    // memcpy_dma4::@return
  __breturn:
    // [68] return 
    rts
}
  // File Data
.segment Data
  // Array containing the banked upper memory code/data to be transferred to upper memory before execution
upperCodeData:
.segmentout [segments="Banked"]

  // DMA list entry for copying data in the 1MB memory space
  memcpy_dma_command4: .byte DMA_COMMAND_COPY
  .word 0, 0
  .byte 0
  .word 0
  .byte 0, 0
  .word 0
.segment DataBanked
.pc = $4000 "MUSIC"
// SID tune at an absolute address
MUSIC:
.const music = LoadSid("Cybernoid_II_4000.sid")
    .fill music.size, music.getData(i)


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b4
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b1
Removing instruction jmp __b8
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #>0
Removing instruction lda #<0
Removing instruction lda #>0
Removing instruction lda #>0
Removing instruction lda #<0
Removing instruction lda #>0
Removing instruction lda #>0
Removing instruction lda #<0
Removing instruction lda #>0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b4_from_irq:
Removing instruction __b1_from___b4:
Removing instruction __b6_from___b5:
Removing instruction __b1_from___b7:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction memoryRemapBlock_from_irq:
Removing instruction __b4:
Removing instruction __b1:
Removing instruction memoryRemap_from___b1:
Removing instruction __b5:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction memoryRemap_from_main:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction memoryRemapBlock_from___b6:
Removing instruction __b7:
Removing instruction __b1:
Removing instruction memoryRemap_from___b1:
Removing instruction __b8:
Removing instruction __b2_from___b8:
Removing instruction __b3_from___b2:
Removing instruction __b2_from___b3:
Removing instruction __b3_from___b4:
Removing instruction memoryRemap_from_memoryRemapBlock:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
__constant struct MOS6526_CIA * const CIA1 = (struct MOS6526_CIA *) 56320
__constant const char CIA_INTERRUPT_CLEAR = $7f
__constant char * const DEFAULT_SCREEN = (char *) 2048
__constant struct F018_DMAGIC * const DMA = (struct F018_DMAGIC *) 55040
__constant const char DMA_COMMAND_COPY = 0
__constant void (** const HARDWARE_IRQ)() = (void (**)()) 65534
__constant const char IRQ_RASTER = 1
__constant char MUSIC[] = kickasm {{ .const music = LoadSid("Cybernoid_II_4000.sid")
    .fill music.size, music.getData(i)
 }}
__constant char * const MUSIC_END = (char *) 20992
__constant char OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
__constant char OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
__constant char OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
__constant char OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
__constant char OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
__constant char OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
__constant char OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
__constant char OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
__constant char OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
__constant char OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
__constant char OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
__constant char OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
__constant char OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
__constant char OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
__constant char OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
__constant char OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
__constant char OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
__constant char * const PROCPORT = (char *) 1
__constant char * const PROCPORT_DDR = (char *) 0
__constant const char PROCPORT_DDR_MEMORY_MASK = 7
__constant const char PROCPORT_RAM_IO = 5
__constant struct MOS6569_VICII * const VICII = (struct MOS6569_VICII *) 53248
__constant struct MOS4569_VICIII * const VICIII = (struct MOS4569_VICIII *) 53248
__constant struct MEGA65_VICIV * const VICIV = (struct MEGA65_VICIV *) 53248
__interrupt(hardware_clobber) void irq()
char irq::raster
char irq::raster#0 // reg byte a 6.5
void main()
char main::i
char main::i#1 // reg byte y 202.0
char main::i#2 // reg byte y 168.33333333333331
char main::mem_destroy_i
char main::mem_destroy_i#1 // reg byte x 22.4
char main::mem_destroy_i#2 // reg byte x 67.0
void memcpy_dma4(char dest_bank , void *dest , char src_bank , void *src , unsigned int num)
void *memcpy_dma4::dest
__constant void *memcpy_dma4::dest#0 = (void *) 0 // dest
char memcpy_dma4::dest_bank
__constant char memcpy_dma4::dest_bank#0 = 1 // dest_bank
char memcpy_dma4::dmaMode
char memcpy_dma4::dmaMode#0 // reg byte x 2.0
unsigned int memcpy_dma4::num
__constant unsigned int memcpy_dma4::num#0 = MUSIC_END-MUSIC // num
void *memcpy_dma4::src
__constant void *memcpy_dma4::src#0 = (void *)upperCodeData // src
char memcpy_dma4::src_bank
__constant char memcpy_dma4::src_bank#0 = 0 // src_bank
__loadstore volatile struct DMA_LIST_F018B memcpy_dma_command4 = { command: DMA_COMMAND_COPY, count: 0, src: 0, src_bank: 0, dest: 0, dest_bank: 0, sub_command: 0, modulo: 0 } // mem[12]
void memoryRemap(char remapBlocks , unsigned int lowerPageOffset , unsigned int upperPageOffset)
char memoryRemap::$1 // zp[1]:7 67.33333333333333
char memoryRemap::$2 // reg byte a 202.0
char memoryRemap::$3 // reg byte a 202.0
char memoryRemap::$6 // zp[1]:10 67.33333333333333
char memoryRemap::$7 // reg byte a 202.0
char memoryRemap::$8 // reg byte a 202.0
__loadstore volatile char memoryRemap::aVal // zp[1]:6 10.1
unsigned int memoryRemap::lowerPageOffset
unsigned int memoryRemap::lowerPageOffset#4 // lowerPageOffset zp[2]:2 67.33333333333333
char memoryRemap::remapBlocks
char memoryRemap::remapBlocks#4 // reg byte z 28.857142857142858
unsigned int memoryRemap::upperPageOffset
unsigned int memoryRemap::upperPageOffset#4 // upperPageOffset zp[2]:4 25.25
__loadstore volatile char memoryRemap::xVal // zp[1]:8 16.833333333333332
__loadstore volatile char memoryRemap::yVal // zp[1]:9 20.2
__loadstore volatile char memoryRemap::zVal // zp[1]:11 101.0
void memoryRemapBlock(char blockPage , unsigned int memoryPage)
char memoryRemapBlock::block
__constant char memoryRemapBlock::block#0 = $40>>5 // block
char memoryRemapBlock::blockBits
__constant char memoryRemapBlock::blockBits#0 = 1<<memoryRemapBlock::block#0 // blockBits
char memoryRemapBlock::blockPage
unsigned int memoryRemapBlock::memoryPage
unsigned int memoryRemapBlock::pageOffset
__constant unsigned int memoryRemapBlock::pageOffset#0 = $100-$40 // pageOffset
__constant void (*musicInit)() = (void (*)())MUSIC
__constant void (*musicPlay)() = (void (*)())MUSIC+3
__constant char upperCodeData[] = kickasm {{ .segmentout [segments="Banked"]
 }}

reg byte x [ main::mem_destroy_i#2 main::mem_destroy_i#1 ]
reg byte y [ main::i#2 main::i#1 ]
zp[2]:2 [ memoryRemap::lowerPageOffset#4 ]
reg byte z [ memoryRemap::remapBlocks#4 ]
zp[2]:4 [ memoryRemap::upperPageOffset#4 ]
reg byte a [ irq::raster#0 ]
zp[1]:6 [ memoryRemap::aVal ]
zp[1]:7 [ memoryRemap::$1 ]
reg byte a [ memoryRemap::$2 ]
reg byte a [ memoryRemap::$3 ]
zp[1]:8 [ memoryRemap::xVal ]
zp[1]:9 [ memoryRemap::yVal ]
zp[1]:10 [ memoryRemap::$6 ]
reg byte a [ memoryRemap::$7 ]
reg byte a [ memoryRemap::$8 ]
zp[1]:11 [ memoryRemap::zVal ]
reg byte x [ memcpy_dma4::dmaMode#0 ]
mem[12] [ memcpy_dma_command4 ]


FINAL ASSEMBLER
Score: 3050

  // File Comments
// SID music located in another bank being played in a raster IRQ using memory mapping on the MEGA65
// Music is Cybernoid II by Jeroen Tel released in 1988 by Hewson https://csdb.dk/sid/?id=28140
// SID relocated using http://www.linusakesson.net/software/sidreloc/index.php
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable with banked code and data starting in MEGA65 mode.
.file [name="banked-music.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segmentdef Banked [segments="CodeBanked, DataBanked"]
.segmentdef CodeBanked [start=$4000]
.segmentdef DataBanked [startAfter="CodeBanked"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  /// Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  /// VICII IRQ Status/Enable Raster
  // @see #IRQ_ENABLE #IRQ_STATUS
  ///  0 | RST| Reaching a certain raster line. The line is specified by writing
  ///    |    | to register 0xd012 and bit 7 of $d011 and internally stored by
  ///    |    | the VIC for the raster compare. The test for reaching the
  ///    |    | interrupt raster line is done in cycle 0 of every line (for line
  ///    |    | 0, in cycle 1).
  .const IRQ_RASTER = 1
  /// DMA command copy
  .const DMA_COMMAND_COPY = 0
  /// Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  /// RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK = 5
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK = 8
  .const OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR = $20
  /// Processor port data direction register
  .label PROCPORT_DDR = 0
  /// Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  /// The VIC-II MOS 6567/6569
  .label VICII = $d000
  /// The VIC III MOS 4567/4569
  .label VICIII = $d000
  /// The VIC IV
  .label VICIV = $d000
  /// DMAgic F018 Controller
  .label DMA = $d700
  /// Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
  /// The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  /// The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Address after the end of the music
  .label MUSIC_END = $5200
  // Pointer to the music init routine
  .label musicInit = MUSIC
  // Pointer to the music play routine
  .label musicPlay = MUSIC+3
.segment Code
  // irq
// Raster IRQ routine
irq: {
    // interrupt(isr_hardware_clobber_entry) -- isr_hardware_all_entry 
    pha
    phx
    phy
    phz
    // VICII->IRQ_STATUS = IRQ_RASTER
    // [0] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // (VICII->BORDER_COLOR)++;
    // [1] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = ++ *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // memoryRemapBlock(0x40, 0x100)
    // [2] call memoryRemapBlock
  // Remap memory to put music at $4000
    // [40] phi from irq to memoryRemapBlock [phi:irq->memoryRemapBlock]
    jsr memoryRemapBlock
    // [3] phi from irq to irq::@4 [phi:irq->irq::@4]
    // irq::@4
    // (*musicPlay)()
    // [4] callexecute *musicPlay  -- call__deref_pprc1 
    // Play remapped SID
    jsr musicPlay
    // [5] phi from irq::@4 to irq::@1 [phi:irq::@4->irq::@1]
    // irq::@1
    // memoryRemap(0,0,0)
    // [6] call memoryRemap
  // Reset memory mapping
    // [43] phi from irq::@1 to memoryRemap [phi:irq::@1->memoryRemap]
    // [43] phi memoryRemap::upperPageOffset#4 = 0 [phi:irq::@1->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [43] phi memoryRemap::remapBlocks#4 = 0 [phi:irq::@1->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [43] phi memoryRemap::lowerPageOffset#4 = 0 [phi:irq::@1->memoryRemap#2] -- vwuz1=vbuc1 
    sta.z memoryRemap.lowerPageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // irq::@5
    // char raster = VICII->RASTER
    // [7] irq::raster#0 = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) -- vbuaa=_deref_pbuc1 
    // Wait for the next raster line
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // irq::@2
  __b2:
    // while(VICII->RASTER==raster)
    // [8] if(*((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER)==irq::raster#0) goto irq::@2 -- _deref_pbuc1_eq_vbuaa_then_la1 
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    beq __b2
    // irq::@3
    // (VICII->BORDER_COLOR)--;
    // [9] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = -- *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR
    // irq::@return
    // }
    // [10] return 
    // interrupt(isr_hardware_clobber_exit) -- isr_hardware_all_exit 
    plz
    ply
    plx
    pla
    rti
}
  // main
main: {
    // asm
    // asm { sei  }
    // Stop IRQ's
    sei
    // memoryRemap(0,0,0)
    // [12] call memoryRemap
  // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    // [43] phi from main to memoryRemap [phi:main->memoryRemap]
    // [43] phi memoryRemap::upperPageOffset#4 = 0 [phi:main->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [43] phi memoryRemap::remapBlocks#4 = 0 [phi:main->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [43] phi memoryRemap::lowerPageOffset#4 = 0 [phi:main->memoryRemap#2] -- vwuz1=vbuc1 
    sta.z memoryRemap.lowerPageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // main::@5
    // VICIII->KEY = 0x47
    // [13] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $47 -- _deref_pbuc1=vbuc2 
    // Enable MEGA65 features
    lda #$47
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // VICIII->KEY = 0x53
    // [14] *((char *)VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY) = $53 -- _deref_pbuc1=vbuc2 
    lda #$53
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // VICIV->CONTROLB |= 0x40
    // [15] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable 48MHz fast mode
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // VICIV->CONTROLC |= 0x40
    // [16] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) = *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK
    // [17] *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // no kernal or BASIC rom visible
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // *PROCPORT = PROCPORT_RAM_IO
    // [18] *PROCPORT = PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // VICIV->SIDBDRWD_LO = 1
    // [19] *((char *)VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) = 1 -- _deref_pbuc1=vbuc2 
    // open sideborder
    lda #1
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO
    // memcpy_dma4(1, (void*)0x0000, 0, upperCodeData, MUSIC_END-MUSIC)
    // [20] call memcpy_dma4
    // Transfer banked code/data to upper memory ($10000)
    jsr memcpy_dma4
    // [21] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // main::@6
    // memoryRemapBlock(0x40, 0x100)
    // [22] call memoryRemapBlock
  // Remap [$4000-$5fff] to point to [$10000-$11fff]
    // [40] phi from main::@6 to memoryRemapBlock [phi:main::@6->memoryRemapBlock]
    jsr memoryRemapBlock
    // main::@7
    // asm
    // asm { lda#0  }
    // Initialize SID 
    lda #0
    // (*musicInit)()
    // [24] callexecute *musicInit  -- call__deref_pprc1 
    jsr musicInit
    // [25] phi from main::@7 to main::@1 [phi:main::@7->main::@1]
    // main::@1
    // memoryRemap(0,0,0)
    // [26] call memoryRemap
  // Reset memory mapping
    // [43] phi from main::@1 to memoryRemap [phi:main::@1->memoryRemap]
    // [43] phi memoryRemap::upperPageOffset#4 = 0 [phi:main::@1->memoryRemap#0] -- vwuz1=vbuc1 
    lda #<0
    sta.z memoryRemap.upperPageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [43] phi memoryRemap::remapBlocks#4 = 0 [phi:main::@1->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #0
    // [43] phi memoryRemap::lowerPageOffset#4 = 0 [phi:main::@1->memoryRemap#2] -- vwuz1=vbuc1 
    sta.z memoryRemap.lowerPageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // main::@8
    // CIA1->INTERRUPT = CIA_INTERRUPT_CLEAR
    // [27] *((char *)CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) = CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Set up raster interrupts C64 style
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // VICII->RASTER = 0xff
    // [28] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER) = $ff -- _deref_pbuc1=vbuc2 
    // Set raster line to 0xff
    lda #$ff
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // VICII->CONTROL1 &= 0x7f
    // [29] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) = *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // VICII->IRQ_ENABLE = IRQ_RASTER
    // [30] *((char *)VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) = IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // *HARDWARE_IRQ = &irq
    // [31] *HARDWARE_IRQ = &irq -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta HARDWARE_IRQ
    lda #>irq
    sta HARDWARE_IRQ+1
    // asm
    // asm { cli  }
    // Enable IRQ
    cli
    // [33] phi from main::@8 to main::@2 [phi:main::@8->main::@2]
    // [33] phi main::mem_destroy_i#2 = 0 [phi:main::@8->main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // main::@2
  __b2:
    // MUSIC[mem_destroy_i++]++;
    // [34] MUSIC[main::mem_destroy_i#2] = ++ MUSIC[main::mem_destroy_i#2] -- pbuc1_derefidx_vbuxx=_inc_pbuc1_derefidx_vbuxx 
    inc MUSIC,x
    // [35] main::mem_destroy_i#1 = ++ main::mem_destroy_i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // [36] phi main::i#2 = 0 [phi:main::@2->main::@3#0] -- vbuyy=vbuc1 
    ldy #0
  // Show unmapped MUSIC memory
    // main::@3
  __b3:
    // for(char i=0;i<240;i++)
    // [37] if(main::i#2<$f0) goto main::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$f0
    bcc __b4
    // [33] phi from main::@3 to main::@2 [phi:main::@3->main::@2]
    // [33] phi main::mem_destroy_i#2 = main::mem_destroy_i#1 [phi:main::@3->main::@2#0] -- register_copy 
    jmp __b2
    // main::@4
  __b4:
    // DEFAULT_SCREEN[i] = MUSIC[i]
    // [38] DEFAULT_SCREEN[main::i#2] = MUSIC[main::i#2] -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuyy 
    lda MUSIC,y
    sta DEFAULT_SCREEN,y
    // for(char i=0;i<240;i++)
    // [39] main::i#1 = ++ main::i#2 -- vbuyy=_inc_vbuyy 
    iny
    // [36] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
    // [36] phi main::i#2 = main::i#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
}
  // memoryRemapBlock
// Remap a single 8K memory block in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// All the other 8K memory blocks will not be mapped and will point to their own address in the lowest 64K of the MEGA65 memory.
// blockPage: Page address of the 8K memory block to remap (ie. the block that is remapped is $100 * the passed page address.)
// memoryPage: Page address of the memory that the block should point to in the 1MB memory space of the MEGA65.
// Ie. the memory that will be pointed to is $100 * the passed page address. Only the lower 12bits of the passed value is used.
// void memoryRemapBlock(char blockPage, unsigned int memoryPage)
memoryRemapBlock: {
    // Find the page offset (the number of pages to offset the block)
    .const pageOffset = $100-$40
    // Which block is being remapped? (0-7)
    .const block = $40>>5
    .const blockBits = 1<<block
    // memoryRemap(blockBits, pageOffset, pageOffset)
    // [41] call memoryRemap
    // [43] phi from memoryRemapBlock to memoryRemap [phi:memoryRemapBlock->memoryRemap]
    // [43] phi memoryRemap::upperPageOffset#4 = memoryRemapBlock::pageOffset#0 [phi:memoryRemapBlock->memoryRemap#0] -- vwuz1=vwuc1 
    lda #<pageOffset
    sta.z memoryRemap.upperPageOffset
    lda #>pageOffset
    sta.z memoryRemap.upperPageOffset+1
    // [43] phi memoryRemap::remapBlocks#4 = memoryRemapBlock::blockBits#0 [phi:memoryRemapBlock->memoryRemap#1] -- vbuzz=vbuc1 
    ldz #blockBits
    // [43] phi memoryRemap::lowerPageOffset#4 = memoryRemapBlock::pageOffset#0 [phi:memoryRemapBlock->memoryRemap#2] -- vwuz1=vwuc1 
    lda #<pageOffset
    sta.z memoryRemap.lowerPageOffset
    lda #>pageOffset
    sta.z memoryRemap.lowerPageOffset+1
    jsr memoryRemap
    // memoryRemapBlock::@return
    // }
    // [42] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
// void memoryRemap(__register(Z) char remapBlocks, __zp(2) unsigned int lowerPageOffset, __zp(4) unsigned int upperPageOffset)
memoryRemap: {
    .label aVal = 6
    .label xVal = 8
    .label __1 = 7
    .label yVal = 9
    .label zVal = $b
    .label __6 = $a
    .label lowerPageOffset = 2
    .label upperPageOffset = 4
    // char aVal = BYTE0(lowerPageOffset)
    // [44] memoryRemap::aVal = byte0  memoryRemap::lowerPageOffset#4 -- vbuz1=_byte0_vwuz2 
    // lower blocks offset page low
    lda.z lowerPageOffset
    sta.z aVal
    // remapBlocks << 4
    // [45] memoryRemap::$1 = memoryRemap::remapBlocks#4 << 4 -- vbuz1=vbuzz_rol_4 
    tza
    asl
    asl
    asl
    asl
    sta.z __1
    // BYTE1(lowerPageOffset)
    // [46] memoryRemap::$2 = byte1  memoryRemap::lowerPageOffset#4 -- vbuaa=_byte1_vwuz1 
    lda.z lowerPageOffset+1
    // BYTE1(lowerPageOffset) & 0xf
    // [47] memoryRemap::$3 = memoryRemap::$2 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // char xVal = (remapBlocks << 4)   | (BYTE1(lowerPageOffset) & 0xf)
    // [48] memoryRemap::xVal = memoryRemap::$1 | memoryRemap::$3 -- vbuz1=vbuz2_bor_vbuaa 
    // lower blocks to map + lower blocks offset high nibble
    ora.z __1
    sta.z xVal
    // char yVal = BYTE0(upperPageOffset)
    // [49] memoryRemap::yVal = byte0  memoryRemap::upperPageOffset#4 -- vbuz1=_byte0_vwuz2 
    // upper blocks offset page
    lda.z upperPageOffset
    sta.z yVal
    // remapBlocks & 0xf0
    // [50] memoryRemap::$6 = memoryRemap::remapBlocks#4 & $f0 -- vbuz1=vbuzz_band_vbuc1 
    tza
    and #$f0
    sta.z __6
    // BYTE1(upperPageOffset)
    // [51] memoryRemap::$7 = byte1  memoryRemap::upperPageOffset#4 -- vbuaa=_byte1_vwuz1 
    lda.z upperPageOffset+1
    // BYTE1(upperPageOffset) & 0xf
    // [52] memoryRemap::$8 = memoryRemap::$7 & $f -- vbuaa=vbuaa_band_vbuc1 
    and #$f
    // char zVal = (remapBlocks & 0xf0) | (BYTE1(upperPageOffset) & 0xf)
    // [53] memoryRemap::zVal = memoryRemap::$6 | memoryRemap::$8 -- vbuz1=vbuz2_bor_vbuaa 
    // upper blocks to map + upper blocks offset page high nibble
    ora.z __6
    sta.z zVal
    // asm
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap::@return
    // }
    // [55] return 
    rts
}
  // memcpy_dma4
// Copy a memory block anywhere in first 4MB memory space using MEGA65 DMagic DMA
// Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination.
// - dest_bank The 64KB bank for the destination (0-63)
// - dest The destination address (within the MB and bank)
// - src_bank The 64KB bank for the source (0-63)
// - src The source address (within the MB and bank)
// - num The number of bytes to copy
// void memcpy_dma4(char dest_bank, void *dest, char src_bank, void *src, unsigned int num)
memcpy_dma4: {
    .const num = MUSIC_END-MUSIC
    .const dest_bank = 1
    .const src_bank = 0
    .label dest = 0
    .label src = upperCodeData
    // char dmaMode = DMA->EN018B
    // [56] memcpy_dma4::dmaMode#0 = *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memcpy_dma_command4.count = num
    // [57] *((unsigned int *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT) = memcpy_dma4::num#0 -- _deref_pwuc1=vwuc2 
    // Set up command
    lda #<num
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // memcpy_dma_command4.src_bank = src_bank
    // [58] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK) = memcpy_dma4::src_bank#0 -- _deref_pbuc1=vbuc2 
    lda #src_bank
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC_BANK
    // memcpy_dma_command4.src = src
    // [59] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC) = (char *)memcpy_dma4::src#0 -- _deref_qbuc1=pbuc2 
    lda #<src
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>src
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // memcpy_dma_command4.dest_bank = dest_bank
    // [60] *((char *)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK) = memcpy_dma4::dest_bank#0 -- _deref_pbuc1=vbuc2 
    lda #dest_bank
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST_BANK
    // memcpy_dma_command4.dest = dest
    // [61] *((char **)&memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST) = (char *)memcpy_dma4::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta memcpy_dma_command4+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // DMA->EN018B = 1
    // [62] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // DMA->ADDRMB = 0
    // [63] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB) = 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // DMA->ADDRBANK = 0
    // [64] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) = 0 -- _deref_pbuc1=vbuc2 
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // DMA-> ADDRMSB = BYTE1(&memcpy_dma_command4)
    // [65] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) = byte1 &memcpy_dma_command4 -- _deref_pbuc1=vbuc2 
    lda #>memcpy_dma_command4
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // DMA-> ADDRLSBTRIG = BYTE0(&memcpy_dma_command4)
    // [66] *((char *)DMA) = byte0 &memcpy_dma_command4 -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<memcpy_dma_command4
    sta DMA
    // DMA->EN018B = dmaMode
    // [67] *((char *)DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B) = memcpy_dma4::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memcpy_dma4::@return
    // }
    // [68] return 
    rts
}
  // File Data
.segment Data
  // Array containing the banked upper memory code/data to be transferred to upper memory before execution
upperCodeData:
.segmentout [segments="Banked"]

  // DMA list entry for copying data in the 1MB memory space
  memcpy_dma_command4: .byte DMA_COMMAND_COPY
  .word 0, 0
  .byte 0
  .word 0
  .byte 0, 0
  .word 0
.segment DataBanked
.pc = $4000 "MUSIC"
// SID tune at an absolute address
MUSIC:
.const music = LoadSid("Cybernoid_II_4000.sid")
    .fill music.size, music.getData(i)


