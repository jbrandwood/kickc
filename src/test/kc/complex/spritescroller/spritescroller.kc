// Put a 2x2 font into sprites and show it on screen
import "c64"
import "multiplexer-irq"

char * const CHARSET_DEFAULT = 0x1000;
char * const FONT = 0x2000;
char * const SPRITES = 0x3000;
char * const SCREEN =  0x0400;
char * const SCREEN_SPRITES = SCREEN + SPRITE_PTRS;

// Show raster time used
const char DEBUG = 0;

//kickasm(pc FONT, resource "elefont.bin") {{
//	.import binary "elefont.bin"
//}}

char align(0x100) YSIN[0x100] = kickasm {{
    .fill $100, round(142+89.5*sin(toRadians(360*i/256)))
}};

void main() {

    // Create 2x2 font from CHARGEN
    asm { sei }
    *PROCPORT = PROCPORT_RAM_CHARROM;
    font_2x2(CHARGEN, FONT);
    *PROCPORT = PROCPORT_BASIC_KERNEL_IO;
    asm { cli }

    // Convert font to sprites
    font_2x2_to_sprites(FONT, SPRITES, 64);

    // Initialize the multiplexer
    plexInit(SCREEN);

    // Show screen
    *D018 = toD018(SCREEN, CHARSET_DEFAULT);

    // Set the x-positions & pointers
    unsigned int xp = 24;
    char sprite = toSpritePtr(SPRITES);
    for(char s: 0..PLEX_COUNT-1) {
        PLEX_PTR[s] = sprite++;
        PLEX_XPOS[s] = xp;
        xp += 10;
    }
    // Enable & initialize sprites
    *SPRITES_ENABLE = 0xff;
    for(char s: 0..7) {
        SPRITES_COLS[s] = WHITE;
    }

    // Move the sprites
    plexSine();
    // Sort the sprites by y-position
    plexSort();

    // Enable the plex IRQ
    asm { sei }
    // Disable CIA 1 Timer IRQ
    *CIA1_INTERRUPT = CIA_INTERRUPT_CLEAR;
    // Set raster line to 0x00
    *VIC_CONTROL &=0x7f;
    *RASTER = 0x28;
    // Enable Raster Interrupt
    *IRQ_ENABLE = IRQ_RASTER;
    // Acknowledge any IRQ
    *IRQ_STATUS = IRQ_RASTER;
    // Set the IRQ routine
    *KERNEL_IRQ = &plex_irq;
    asm { cli }

    // Move & Sort - when needed!
    while(true) {
        while(!framedone) {
        }
        //*BORDERCOL = RED;
        // Move the sprites
        plexSine();
        // Sort the sprites by y-position
        plexSort();
        //*BORDERCOL = GREEN;
        framedone = false;
    }
}

// Y-sine index
char sin_idx = 0;

// Move the plex sprites in an Y-sine
void plexSine() {
        // Assign sinus positions
        char y_idx = sin_idx;
        for(char sy: 0..PLEX_COUNT-1) {
            PLEX_YPOS[sy] = YSIN[y_idx];
            y_idx += 8;
        }
        sin_idx +=1;
}

volatile bool framedone = false;

// Show sprites from the multiplexer, rescheduling the IRQ as many times as needed
interrupt(kernel_min) void plex_irq() {
    asm { sei }
    //*BORDERCOL = WHITE;
    // Show sprites until finding one that should not be shown until a few raster lines later
    char rasterY;
    do {
        plexShowSprite();
        rasterY = plexFreeNextYpos();
    } while (plex_show_idx < PLEX_COUNT && rasterY < *RASTER+3);

    if (plex_show_idx<PLEX_COUNT) {
        // Set raster IRQ line to the next sprite Y-position
        *RASTER = rasterY;
    } else {
        // Reset the raster IRQ to the top of the screen
        *RASTER = 0x28;
        framedone = true;
    }
    // Acknowledge the IRQ
    *IRQ_STATUS = IRQ_RASTER;
    //*BORDERCOL = 0;
    asm { cli }
}

// Convert a 2x2-font to sprites
// - font_2x2 The source 2x2-font
// - sprites The destination sprites
// - num_chars The number of chars to convert
void font_2x2_to_sprites(char* font_2x2, char* sprites, char num_chars) {
    char * char_current = font_2x2;
    char * sprite = sprites;
    for(char c=0;c<num_chars;c++) {
        // Upper char
        char * char_left = char_current;
        char * char_right = char_current + 0x40*8;
        char sprite_idx = 0;
        for(char i: 0..20) {
            sprite[sprite_idx++] = char_left[i&7];
            sprite[sprite_idx++] = char_right[i&7];
            sprite[sprite_idx++] = 0x00;
            if(i==7) {
                // Lower char
                char_left = char_current + 0x80*8;
                char_right = char_current + 0xc0*8;
            } else if(i==15) {
                // Empty char
                char_left = font_2x2+' '*8;
                char_right = font_2x2+' '*8;
            }
        }
        char_current += 8;
        sprite += 0x40;
    }
}

// Create a 2x2-font by doubling all pixels of the 64 first chars
// The font layout is:
// - 0x00 - 0x3f Upper left glyphs
// - 0x40 - 0x7f Upper right glyphs
// - 0x80 - 0xbf Lower left glyphs
// - 0xc0 - 0xff Lower right glyphs
void font_2x2(char* font_original, char* font_2x2) {
    char* next_original = font_original;
    char* next_2x2 = font_2x2;
    for(char c: 0..0x3f) {
        char* next_2x2_left = next_2x2;
        char* next_2x2_right = next_2x2 + 0x40*8;
        char l2 = 0;
        for(char l: 0..7) {
            char glyph_bits = next_original[l];
            unsigned int glyph_bits_2x2 = 0;
            for(char b: 0..7) {
                // Find the bit
                char glyph_bit = (glyph_bits&0x80)?1uc:0uc;
                // Roll the bit into the current char twice
                glyph_bits_2x2 = glyph_bits_2x2<<1|glyph_bit;
                glyph_bits_2x2 = glyph_bits_2x2<<1|glyph_bit;
                // Move to next bit
                glyph_bits <<= 1;
            }
            // Put the generated 2x2-line into the 2x2-font twice
            next_2x2_left[l2] = >glyph_bits_2x2;
            next_2x2_left[l2+1] = >glyph_bits_2x2;
            next_2x2_right[l2] = <glyph_bits_2x2;
            next_2x2_right[l2+1] = <glyph_bits_2x2;
            l2 += 2;
            if(l2==8) {
                // Move to bottom chars
                next_2x2_left = next_2x2 + 0x80*8;
                next_2x2_right = next_2x2 + 0xc0*8;
                l2 = 0;
            }
        }
        next_2x2 += 8;
        next_original += 8;
    }
}
