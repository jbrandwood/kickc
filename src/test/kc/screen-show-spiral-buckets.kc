// Fill screen using a spiral based on distance-to-center / angle-to-center
// Utilizes a bucket sort for identifying the minimum angle/distance

import "c64"
import "stdlib"
import "sqr"
import "atan2"

// Screen containing distance to center
const byte[1000] SCREEN_DIST; // = malloc(1000);
// Screen containing angle to center
const byte[1000] SCREEN_ANGLE; // = malloc(1000);
// Screen containing angle to center
const byte* SCREEN_FILL = 0x0400;

// Char to fill with
const byte FILL_CHAR = '@';

void main() {
    init_dist_screen(SCREEN_DIST);
    init_angle_screen(SCREEN_ANGLE);
    init_buckets();

    // Test buckets by animating them
    byte bucket_idx = 0;
    while(true) {
        do { } while (*RASTER!=0xfe);
        do { } while (*RASTER!=0xff);
        (*BORDERCOL)++;
        {
            // First clear the current bucket
            byte bucket_size = BUCKET_SIZES[bucket_idx];
            if(bucket_size>0) {
                word* bucket = BUCKETS[bucket_idx];
                for( byte i=0;i<bucket_size;i++) {
                    byte* sc = SCREEN_FILL+bucket[i];
                    *sc = ' ';
                }
            }
        }
        // Increase bucket index
        bucket_idx++;
        if(bucket_idx==NUM_BUCKETS) {
            bucket_idx = 0;
        }
        {
            // Plot char in the bucket
            byte bucket_size = BUCKET_SIZES[bucket_idx];
            if(bucket_size>0) {
                word* bucket = BUCKETS[bucket_idx];
                for( byte i=0;i<bucket_size;i++) {
                    byte* sc = SCREEN_FILL+bucket[i];
                    *sc = '*';
                }
            }
        }
        (*BORDERCOL)--;
    }

/*
    while(true) {
        // Find the minimum dist/angle that is not already filled
        byte* dist = SCREEN_DIST;
        byte* angle = SCREEN_ANGLE;
        byte* fill = SCREEN_FILL;
        word min_dist_angle = 0xffff;
        byte* min_fill = SCREEN_FILL;
        do {
            if(*fill!=FILL_CHAR) {
                word dist_angle = { *dist, *angle };
                if(dist_angle<min_dist_angle) {
                    min_fill = fill;
                    min_dist_angle = dist_angle;
                }
            }
            dist++;
            angle++;
            fill++;
        } while (fill<SCREEN_FILL+1000);
        // Break if not found (means we are done)
        if(min_dist_angle==0xffff)
            break;
        // Fill the found location
        *min_fill = FILL_CHAR;
    }
    */
}

// The number of buckets in our bucket sort
const byte NUM_BUCKETS = 0x30;

// Array containing the bucket size for each of the distance buckets
const byte[NUM_BUCKETS] BUCKET_SIZES; // = malloc(NUM_BUCKETS*sizeof(byte));

// Buckets containing screen indices for each distance from the center.
// BUCKETS[dist] is an array of words containing screen indices.
// The size of the array BUCKETS[dist] is BUCKET_SIZES[dist]
const word*[NUM_BUCKETS] BUCKETS; // = malloc(NUM_BUCKETS*sizeof(word*));

// Current index into each bucket. Used while populating the buckets. (After population the end the values will be equal to the bucket sizes)
const byte[NUM_BUCKETS] BUCKET_IDX; // = malloc(NUM_BUCKETS*sizeof(byte));

// Initialize buckets containing indices of chars on the screen with specific distances to the center.
void init_buckets() {
    // Init bucket sizes to 0
    for(byte i:0..NUM_BUCKETS-1) BUCKET_SIZES[i]=0;
    // first find bucket sizes - by counting number of chars with each distance value
    byte* dist = SCREEN_DIST;
    for( word i:0..999) {
        BUCKET_SIZES[*dist]++;
        dist++;
    }
    // Allocate the buckets
    for( byte i:0..NUM_BUCKETS-1) {
        BUCKETS[i] = malloc(BUCKET_SIZES[i]*sizeof(byte*));
    }
    // Iterate all distances and fill the buckets with indices into the screens
    for(byte i:0..NUM_BUCKETS-1) BUCKET_IDX[i]=0;
    dist = SCREEN_DIST;
    for(word i:0..999) {
        byte distance = *dist;
        word* bucket = BUCKETS[distance];
        bucket[BUCKET_IDX[distance]] = dist-SCREEN_DIST;
        BUCKET_IDX[distance]++;
        *dist++;
    }
}

// Populates 1000 bytes (a screen) with values representing the angle to the center.
// Utilizes symmetry around the center
void init_angle_screen(byte* screen) {
    byte* screen_topline = screen+40*12;
    byte *screen_bottomline = screen+40*12;
    for(byte y: 0..12) {
        for( byte x=0,xb=39; x<=19; x++, xb--) {
            signed word xw = (signed word)(word){ 39-x*2, 0 };
            signed word yw = (signed word)(word){ y*2, 0 };
            word angle_w = atan2_16(xw, yw);
            byte ang_w = >(angle_w+0x0080);
            screen_bottomline[xb] = ang_w;
            screen_topline[xb] = -ang_w;
            screen_topline[x] = 0x80+ang_w;
            screen_bottomline[x] = 0x80-ang_w;
        }
        screen_topline -= 40;
        screen_bottomline += 40;
    }
}

// Populates 1000 bytes (a screen) with values representing the distance to the center.
// The actual value stored is distance*2 to increase precision
// Utilizes symmetry around the center
void init_dist_screen(byte* screen) {
    NUM_SQUARES = 0x30;
    init_squares();
    byte* screen_topline = screen;
    byte *screen_bottomline = screen+40*24;
    for(byte y: 0..12) {
        byte y2 = y*2;
        byte yd = (y2>=24)?(y2-24):(24-y2);
        word yds = sqr(yd);
        for( byte x=0,xb=39; x<=19; x++, xb--) {
            byte x2 = x*2;
            byte xd = (x2>=39)?(x2-39):(39-x2);
            word xds = sqr(xd);
            word ds = xds+yds;
            byte d = sqrt(ds);
            screen_topline[x] = d;
            screen_bottomline[x] = d;
            screen_topline[xb] = d;
            screen_bottomline[xb] = d;
        }
        screen_topline += 40;
        screen_bottomline -= 40;
    }
}