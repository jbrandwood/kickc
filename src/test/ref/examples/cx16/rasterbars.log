Resolved forward reference irq_line to void irq_line()
Inlined call call SEI 
Inlined call call CLI 
Inlined call call __init 

CONTROL FLOW GRAPH SSA

void* memset(void* memset::str , byte memset::c , word memset::num)
memset: scope:[memset]  from irq_line::@1
  memset::c#4 = phi( irq_line::@1/memset::c#0 )
  memset::str#3 = phi( irq_line::@1/memset::str#0 )
  memset::num#1 = phi( irq_line::@1/memset::num#0 )
  memset::$0 = memset::num#1 > 0
  memset::$1 = ! memset::$0
  if(memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@3
  memset::str#1 = phi( memset/memset::str#3, memset::@3/memset::str#4 )
  memset::return#0 = memset::str#1
  to:memset::@return
memset::@2: scope:[memset]  from memset
  memset::c#3 = phi( memset/memset::c#4 )
  memset::num#2 = phi( memset/memset::num#1 )
  memset::str#2 = phi( memset/memset::str#3 )
  memset::$4 = (byte*)memset::str#2
  memset::$2 = memset::$4 + memset::num#2
  memset::end#0 = memset::$2
  memset::dst#0 = ((byte*)) memset::str#2
  to:memset::@3
memset::@3: scope:[memset]  from memset::@2 memset::@4
  memset::c#2 = phi( memset::@2/memset::c#3, memset::@4/memset::c#1 )
  memset::str#4 = phi( memset::@2/memset::str#2, memset::@4/memset::str#5 )
  memset::end#1 = phi( memset::@2/memset::end#0, memset::@4/memset::end#2 )
  memset::dst#2 = phi( memset::@2/memset::dst#0, memset::@4/memset::dst#1 )
  memset::$3 = memset::dst#2 != memset::end#1
  if(memset::$3) goto memset::@4
  to:memset::@1
memset::@4: scope:[memset]  from memset::@3
  memset::str#5 = phi( memset::@3/memset::str#4 )
  memset::end#2 = phi( memset::@3/memset::end#1 )
  memset::dst#3 = phi( memset::@3/memset::dst#2 )
  memset::c#1 = phi( memset::@3/memset::c#2 )
  *memset::dst#3 = memset::c#1
  memset::dst#1 = ++ memset::dst#3
  to:memset::@3
memset::@return: scope:[memset]  from memset::@1
  memset::return#3 = phi( memset::@1/memset::return#0 )
  memset::return#1 = memset::return#3
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  to:main::SEI1
main::SEI1: scope:[main]  from main
  asm { sei  }
  to:main::@2
main::@2: scope:[main]  from main::SEI1
  *KERNEL_IRQ = &irq_line
  *VERA_IEN = VERA_LINE
  *VERA_IRQLINE_L = 5
  to:main::CLI1
main::CLI1: scope:[main]  from main::@2
  asm { cli  }
  to:main::@1
main::@1: scope:[main]  from main::@1 main::CLI1
  to:main::@1
main::@return: scope:[main]  from
  return 
  to:@return

void irq_line()
irq_line: scope:[irq_line]  from
  *VERA_CTRL = *VERA_CTRL | VERA_DCSEL
  *VERA_DC_HSTART = hstart
  *VERA_DC_HSTOP = hstop
  *VERA_DC_VSTART = vstart
  *VERA_DC_VSTOP = vstop
  *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL
  irq_line::l#0 = 0
  to:irq_line::@2
irq_line::@2: scope:[irq_line]  from irq_line irq_line::@10
  irq_line::l#2 = phi( irq_line/irq_line::l#0, irq_line::@10/irq_line::l#1 )
  irq_line::$4 = irq_line::l#2 != $e6
  if(irq_line::$4) goto irq_line::@3
  to:irq_line::@4
irq_line::@3: scope:[irq_line]  from irq_line::@2
  irq_line::l#3 = phi( irq_line::@2/irq_line::l#2 )
  *VERA_DC_BORDER = BARS[irq_line::l#3]
  irq_line::i#0 = 0
  to:irq_line::@5
irq_line::@4: scope:[irq_line]  from irq_line::@2
  cnt = -- cnt
  irq_line::$0 = cnt == 0
  irq_line::$1 = ! irq_line::$0
  if(irq_line::$1) goto irq_line::@1
  to:irq_line::@11
irq_line::@5: scope:[irq_line]  from irq_line::@3 irq_line::@6
  irq_line::l#8 = phi( irq_line::@3/irq_line::l#3, irq_line::@6/irq_line::l#9 )
  irq_line::i#2 = phi( irq_line::@3/irq_line::i#0, irq_line::@6/irq_line::i#1 )
  irq_line::$5 = irq_line::i#2 < $18
  if(irq_line::$5) goto irq_line::@6
  to:irq_line::@7
irq_line::@6: scope:[irq_line]  from irq_line::@5
  irq_line::l#9 = phi( irq_line::@5/irq_line::l#8 )
  irq_line::i#3 = phi( irq_line::@5/irq_line::i#2 )
  irq_line::i#1 = ++ irq_line::i#3
  to:irq_line::@5
irq_line::@7: scope:[irq_line]  from irq_line::@5
  irq_line::l#6 = phi( irq_line::@5/irq_line::l#8 )
  *VERA_DC_BORDER = 0
  irq_line::i1#0 = 0
  to:irq_line::@8
irq_line::@8: scope:[irq_line]  from irq_line::@7 irq_line::@9
  irq_line::l#5 = phi( irq_line::@7/irq_line::l#6, irq_line::@9/irq_line::l#7 )
  irq_line::i1#2 = phi( irq_line::@7/irq_line::i1#0, irq_line::@9/irq_line::i1#1 )
  irq_line::$6 = irq_line::i1#2 < $17
  if(irq_line::$6) goto irq_line::@9
  to:irq_line::@10
irq_line::@9: scope:[irq_line]  from irq_line::@8
  irq_line::l#7 = phi( irq_line::@8/irq_line::l#5 )
  irq_line::i1#3 = phi( irq_line::@8/irq_line::i1#2 )
  irq_line::i1#1 = ++ irq_line::i1#3
  to:irq_line::@8
irq_line::@10: scope:[irq_line]  from irq_line::@8
  irq_line::l#4 = phi( irq_line::@8/irq_line::l#5 )
  asm { nop nop  }
  irq_line::l#1 = ++ irq_line::l#4
  to:irq_line::@2
irq_line::@1: scope:[irq_line]  from irq_line::@11 irq_line::@12 irq_line::@4
  irq_line::$2 = sizeof  BARS
  memset::str#0 = (void*)BARS
  memset::c#0 = 0
  memset::num#0 = irq_line::$2
  call memset 
  memset::return#2 = memset::return#1
  to:irq_line::@19
irq_line::@19: scope:[irq_line]  from irq_line::@1
  irq_line::idx#0 = sin_idx
  sin_idx = -- sin_idx
  irq_line::b#0 = 0
  to:irq_line::@13
irq_line::@11: scope:[irq_line]  from irq_line::@4
  cnt = 2
  irq_line::$7 = hstart <= $140/4
  irq_line::$8 = ! irq_line::$7
  if(irq_line::$8) goto irq_line::@1
  to:irq_line::@12
irq_line::@12: scope:[irq_line]  from irq_line::@11
  hstart = ++ hstart
  hstop = -- hstop
  vstart = ++ vstart
  vstop = -- vstop
  to:irq_line::@1
irq_line::@13: scope:[irq_line]  from irq_line::@18 irq_line::@19
  irq_line::idx#4 = phi( irq_line::@18/irq_line::idx#1, irq_line::@19/irq_line::idx#0 )
  irq_line::b#2 = phi( irq_line::@18/irq_line::b#1, irq_line::@19/irq_line::b#0 )
  irq_line::$9 = irq_line::b#2 < 8
  if(irq_line::$9) goto irq_line::@14
  to:irq_line::@15
irq_line::@14: scope:[irq_line]  from irq_line::@13
  irq_line::b#5 = phi( irq_line::@13/irq_line::b#2 )
  irq_line::idx#2 = phi( irq_line::@13/irq_line::idx#4 )
  irq_line::$10 = BARS + SIN[irq_line::idx#2]
  irq_line::bar#0 = irq_line::$10
  irq_line::i2#0 = 0
  to:irq_line::@16
irq_line::@15: scope:[irq_line]  from irq_line::@13
  *VERA_ISR = VERA_LINE
  asm { ply plx pla rti  }
  to:irq_line::@return
irq_line::@16: scope:[irq_line]  from irq_line::@14 irq_line::@17
  irq_line::b#4 = phi( irq_line::@14/irq_line::b#5, irq_line::@17/irq_line::b#6 )
  irq_line::idx#5 = phi( irq_line::@14/irq_line::idx#2, irq_line::@17/irq_line::idx#6 )
  irq_line::bar#2 = phi( irq_line::@14/irq_line::bar#0, irq_line::@17/irq_line::bar#1 )
  irq_line::i2#2 = phi( irq_line::@14/irq_line::i2#0, irq_line::@17/irq_line::i2#1 )
  irq_line::$11 = sizeof  BAR
  irq_line::$12 = irq_line::i2#2 < irq_line::$11
  if(irq_line::$12) goto irq_line::@17
  to:irq_line::@18
irq_line::@17: scope:[irq_line]  from irq_line::@16
  irq_line::b#6 = phi( irq_line::@16/irq_line::b#4 )
  irq_line::idx#6 = phi( irq_line::@16/irq_line::idx#5 )
  irq_line::bar#1 = phi( irq_line::@16/irq_line::bar#2 )
  irq_line::i2#3 = phi( irq_line::@16/irq_line::i2#2 )
  irq_line::bar#1[irq_line::i2#3] = BAR[irq_line::i2#3]
  irq_line::i2#1 = ++ irq_line::i2#3
  to:irq_line::@16
irq_line::@18: scope:[irq_line]  from irq_line::@16
  irq_line::b#3 = phi( irq_line::@16/irq_line::b#4 )
  irq_line::idx#3 = phi( irq_line::@16/irq_line::idx#5 )
  irq_line::idx#1 = irq_line::idx#3 + $d
  irq_line::b#1 = ++ irq_line::b#3
  to:irq_line::@13
irq_line::@return: scope:[irq_line]  from irq_line::@15
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  hstart = (byte)0/4
  hstop = (byte)$280/4
  vstart = (byte)0/2
  vstop = (byte)$1e0/2
  cnt = 2
  sin_idx = $64
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
const byte* BAR[$20]  = { $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1a, $1b, $1c, $1d, $1e, $1f, $1f, $1e, $1d, $1c, $1b, $1a, $19, $18, $17, $16, $15, $14, $13, $12, $11, $10 }
const byte* BARS[$e6]  = { fill( $e6, 0) }
const nomodify void()** KERNEL_IRQ = (void()**)$314
const byte* SIN[$100]  = kickasm {{ .fill 256, 99+99*sin(i*2*PI/256)
 }}
const nomodify byte* VERA_CTRL = (byte*)$9f25
const nomodify byte VERA_DCSEL = 2
const nomodify byte* VERA_DC_BORDER = (byte*)$9f2c
const nomodify byte* VERA_DC_HSTART = (byte*)$9f29
const nomodify byte* VERA_DC_HSTOP = (byte*)$9f2a
const nomodify byte* VERA_DC_VSTART = (byte*)$9f2b
const nomodify byte* VERA_DC_VSTOP = (byte*)$9f2c
const nomodify byte* VERA_IEN = (byte*)$9f26
const nomodify byte* VERA_IRQLINE_L = (byte*)$9f28
const nomodify byte* VERA_ISR = (byte*)$9f27
const nomodify byte VERA_LINE = 2
void __start()
volatile byte cnt loadstore
volatile byte hstart loadstore
volatile byte hstop loadstore
void irq_line()
bool~ irq_line::$0
bool~ irq_line::$1
byte*~ irq_line::$10
byte~ irq_line::$11
bool~ irq_line::$12
byte~ irq_line::$2
bool~ irq_line::$4
bool~ irq_line::$5
bool~ irq_line::$6
bool~ irq_line::$7
bool~ irq_line::$8
bool~ irq_line::$9
byte irq_line::b
byte irq_line::b#0
byte irq_line::b#1
byte irq_line::b#2
byte irq_line::b#3
byte irq_line::b#4
byte irq_line::b#5
byte irq_line::b#6
byte* irq_line::bar
byte* irq_line::bar#0
byte* irq_line::bar#1
byte* irq_line::bar#2
byte irq_line::i
byte irq_line::i#0
byte irq_line::i#1
byte irq_line::i#2
byte irq_line::i#3
byte irq_line::i1
byte irq_line::i1#0
byte irq_line::i1#1
byte irq_line::i1#2
byte irq_line::i1#3
byte irq_line::i2
byte irq_line::i2#0
byte irq_line::i2#1
byte irq_line::i2#2
byte irq_line::i2#3
byte irq_line::idx
byte irq_line::idx#0
byte irq_line::idx#1
byte irq_line::idx#2
byte irq_line::idx#3
byte irq_line::idx#4
byte irq_line::idx#5
byte irq_line::idx#6
byte irq_line::l
byte irq_line::l#0
byte irq_line::l#1
byte irq_line::l#2
byte irq_line::l#3
byte irq_line::l#4
byte irq_line::l#5
byte irq_line::l#6
byte irq_line::l#7
byte irq_line::l#8
byte irq_line::l#9
void main()
void* memset(void* memset::str , byte memset::c , word memset::num)
bool~ memset::$0
bool~ memset::$1
byte*~ memset::$2
bool~ memset::$3
byte*~ memset::$4
byte memset::c
byte memset::c#0
byte memset::c#1
byte memset::c#2
byte memset::c#3
byte memset::c#4
byte* memset::dst
byte* memset::dst#0
byte* memset::dst#1
byte* memset::dst#2
byte* memset::dst#3
byte* memset::end
byte* memset::end#0
byte* memset::end#1
byte* memset::end#2
word memset::num
word memset::num#0
word memset::num#1
word memset::num#2
void* memset::return
void* memset::return#0
void* memset::return#1
void* memset::return#2
void* memset::return#3
void* memset::str
void* memset::str#0
void* memset::str#1
void* memset::str#2
void* memset::str#3
void* memset::str#4
void* memset::str#5
volatile byte sin_idx loadstore
volatile byte vstart loadstore
volatile byte vstop loadstore

Adding number conversion cast (unumber) 0 in memset::$0 = memset::num#1 > 0
Adding number conversion cast (unumber) 5 in *VERA_IRQLINE_L = 5
Adding number conversion cast (unumber) $e6 in irq_line::$4 = irq_line::l#2 != $e6
Adding number conversion cast (unumber) 0 in irq_line::$0 = cnt == 0
Adding number conversion cast (unumber) $18 in irq_line::$5 = irq_line::i#2 < $18
Adding number conversion cast (unumber) 0 in *VERA_DC_BORDER = 0
Adding number conversion cast (unumber) $17 in irq_line::$6 = irq_line::i1#2 < $17
Adding number conversion cast (unumber) 0 in memset::c#0 = 0
Adding number conversion cast (unumber) 2 in cnt = 2
Adding number conversion cast (unumber) $140/4 in irq_line::$7 = hstart <= $140/4
Adding number conversion cast (unumber) 8 in irq_line::$9 = irq_line::b#2 < 8
Adding number conversion cast (unumber) $d in irq_line::idx#1 = irq_line::idx#3 + $d
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast memset::dst#0 = (byte*)memset::str#2
Inlining cast *VERA_IRQLINE_L = (unumber)5
Inlining cast *VERA_DC_BORDER = (unumber)0
Inlining cast memset::c#0 = (unumber)0
Inlining cast cnt = (unumber)2
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 40741
Simplifying constant pointer cast (byte*) 40742
Simplifying constant pointer cast (byte*) 40743
Simplifying constant pointer cast (byte*) 40744
Simplifying constant pointer cast (byte*) 40748
Simplifying constant pointer cast (byte*) 40745
Simplifying constant pointer cast (byte*) 40746
Simplifying constant pointer cast (byte*) 40747
Simplifying constant pointer cast (byte*) 40748
Simplifying constant pointer cast (void()**) 788
Simplifying constant integer cast 0
Simplifying constant integer cast 5
Simplifying constant integer cast $e6
Simplifying constant integer cast 0
Simplifying constant integer cast $18
Simplifying constant integer cast 0
Simplifying constant integer cast $17
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 8
Simplifying constant integer cast $d
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $e6
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $17
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $d
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inversing boolean not [2] memset::$1 = memset::num#1 <= 0 from [1] memset::$0 = memset::num#1 > 0
Inversing boolean not [41] irq_line::$1 = cnt != 0 from [40] irq_line::$0 = cnt == 0
Inversing boolean not [70] irq_line::$8 = hstart > (byte)$140/4 from [69] irq_line::$7 = hstart <= (byte)$140/4
Successful SSA optimization Pass2UnaryNotSimplification
Alias memset::return#0 = memset::str#1 memset::return#3 memset::return#1 
Alias memset::str#2 = memset::str#3 
Alias memset::num#1 = memset::num#2 
Alias memset::c#3 = memset::c#4 
Alias memset::end#0 = memset::$2 
Alias memset::c#1 = memset::c#2 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#4 = memset::str#5 
Alias irq_line::l#2 = irq_line::l#3 
Alias irq_line::i#2 = irq_line::i#3 
Alias irq_line::l#6 = irq_line::l#9 irq_line::l#8 
Alias irq_line::i1#2 = irq_line::i1#3 
Alias irq_line::l#4 = irq_line::l#7 irq_line::l#5 
Alias memset::num#0 = irq_line::$2 
Alias irq_line::idx#2 = irq_line::idx#4 
Alias irq_line::b#2 = irq_line::b#5 
Alias irq_line::bar#0 = irq_line::$10 
Alias irq_line::i2#2 = irq_line::i2#3 
Alias irq_line::bar#1 = irq_line::bar#2 
Alias irq_line::idx#3 = irq_line::idx#6 irq_line::idx#5 
Alias irq_line::b#3 = irq_line::b#6 irq_line::b#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values memset::num#1 memset::num#0
Identical Phi Values memset::str#2 memset::str#0
Identical Phi Values memset::c#3 memset::c#0
Identical Phi Values memset::end#1 memset::end#0
Identical Phi Values memset::str#4 memset::str#2
Identical Phi Values memset::c#1 memset::c#3
Identical Phi Values irq_line::l#6 irq_line::l#2
Identical Phi Values irq_line::l#4 irq_line::l#6
Identical Phi Values irq_line::bar#1 irq_line::bar#0
Identical Phi Values irq_line::idx#3 irq_line::idx#2
Identical Phi Values irq_line::b#3 irq_line::b#2
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values memset::return#0 memset::str#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition memset::$1 [2] if(memset::num#0<=0) goto memset::@1
Simple Condition memset::$3 [9] if(memset::dst#2!=memset::end#0) goto memset::@4
Simple Condition irq_line::$4 [28] if(irq_line::l#2!=$e6) goto irq_line::@3
Simple Condition irq_line::$1 [33] if(cnt!=0) goto irq_line::@1
Simple Condition irq_line::$5 [36] if(irq_line::i#2<$18) goto irq_line::@6
Simple Condition irq_line::$6 [42] if(irq_line::i1#2<$17) goto irq_line::@9
Simple Condition irq_line::$8 [56] if(hstart>(byte)$140/4) goto irq_line::@1
Simple Condition irq_line::$9 [63] if(irq_line::b#2<8) goto irq_line::@14
Simple Condition irq_line::$12 [71] if(irq_line::i2#2<irq_line::$11) goto irq_line::@17
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [46] memset::num#0 = sizeof  BARS
Constant right-side identified [69] irq_line::$11 = sizeof  BAR
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant irq_line::l#0 = 0
Constant irq_line::i#0 = 0
Constant irq_line::i1#0 = 0
Constant memset::num#0 = sizeof BARS
Constant memset::str#0 = (void*)BARS
Constant memset::c#0 = 0
Constant irq_line::b#0 = 0
Constant irq_line::i2#0 = 0
Constant irq_line::$11 = sizeof BAR
Successful SSA optimization Pass2ConstantIdentification
Constant memset::$4 = (byte*)memset::str#0
Constant memset::dst#0 = (byte*)memset::str#0
Constant memset::return#2 = memset::str#0
Successful SSA optimization Pass2ConstantIdentification
Rewriting conditional comparison [56] if(hstart>(byte)$140/4) goto irq_line::@1
Simplifying constant evaluating to zero (byte)0/4 in [77] hstart = (byte)0/4
Simplifying constant evaluating to zero (byte)0/2 in [79] vstart = (byte)0/2
Successful SSA optimization PassNSimplifyConstantZero
Eliminating unused constant memset::return#2
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) (byte)$140/4+1 in if(hstart>=(byte)$140/4+1) goto irq_line::@1
Adding number conversion cast (unumber) 1 in if(hstart>=(unumber)(byte)$140/4+1) goto irq_line::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (byte)$140/4+(unumber)1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Resolving array sizeof() sizeof BARS
Resolving array sizeof() sizeof BAR
Successful SSA optimization PassNSizeOfSimplification
Constant right-side identified [1] memset::end#0 = memset::$4 + memset::num#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant memset::end#0 = memset::$4+memset::num#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always false - eliminating [0] if(memset::num#0<=0) goto memset::@1
Successful SSA optimization Pass2ConstantIfs
Adding number conversion cast (unumber) $e6 in 
Adding number conversion cast (unumber) $20 in 
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $e6
Simplifying constant integer cast $20
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $e6
Finalized unsigned number type (byte) $20
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings memset::dst#0
Inlining constant with var siblings irq_line::l#0
Inlining constant with var siblings irq_line::i#0
Inlining constant with var siblings irq_line::i1#0
Inlining constant with var siblings irq_line::b#0
Inlining constant with var siblings irq_line::i2#0
Constant inlined irq_line::i#0 = 0
Constant inlined irq_line::$11 = $20*SIZEOF_BYTE
Constant inlined memset::$4 = (byte*)memset::str#0
Constant inlined irq_line::l#0 = 0
Constant inlined irq_line::i2#0 = 0
Constant inlined irq_line::i1#0 = 0
Constant inlined memset::dst#0 = (byte*)memset::str#0
Constant inlined irq_line::b#0 = 0
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (word) $100
Finalized unsigned number type (byte) $e6
Finalized unsigned number type (byte) $e6
Finalized unsigned number type (byte) $20
Finalized unsigned number type (word) $140
Finalized unsigned number type (byte) 4
Finalized unsigned number type (word) $280
Finalized unsigned number type (byte) 4
Finalized unsigned number type (word) $1e0
Finalized unsigned number type (byte) 2
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of __start::@2
Adding NOP phi() at start of irq_line::@1
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of memset
Adding NOP phi() at start of memset::@2
Adding NOP phi() at start of memset::@1
CALL GRAPH
Calls in [__start] to main:8 
Calls in [irq_line] to memset:28 

Created 7 initial phi equivalence classes
Coalesced [31] irq_line::idx#8 = irq_line::idx#0
Coalesced [42] irq_line::b#7 = irq_line::b#1
Coalesced [43] irq_line::idx#7 = irq_line::idx#1
Coalesced [46] irq_line::i2#4 = irq_line::i2#1
Coalesced [55] irq_line::l#10 = irq_line::l#1
Coalesced [57] irq_line::i1#4 = irq_line::i1#1
Coalesced [59] irq_line::i#4 = irq_line::i#1
Coalesced [75] memset::dst#4 = memset::dst#1
Coalesced down to 7 phi equivalence classes
Culled Empty Block label __start::@2
Culled Empty Block label memset::@2
Culled Empty Block label memset::@1
Renumbering block memset::@3 to memset::@1
Renumbering block memset::@4 to memset::@2
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of irq_line::@1
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of memset

FINAL CONTROL FLOW GRAPH

void __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] hstart = 0
  [2] hstop = (byte)$280/4
  [3] vstart = 0
  [4] vstop = (byte)$1e0/2
  [5] cnt = 2
  [6] sin_idx = $64
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [7] phi()
  [8] call main 
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [9] return 
  to:@return

void irq_line()
irq_line: scope:[irq_line]  from
  [10] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL
  [11] *VERA_DC_HSTART = hstart
  [12] *VERA_DC_HSTOP = hstop
  [13] *VERA_DC_VSTART = vstart
  [14] *VERA_DC_VSTOP = vstop
  [15] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL
  to:irq_line::@2
irq_line::@2: scope:[irq_line]  from irq_line irq_line::@10
  [16] irq_line::l#2 = phi( irq_line/0, irq_line::@10/irq_line::l#1 )
  [17] if(irq_line::l#2!=$e6) goto irq_line::@3
  to:irq_line::@4
irq_line::@4: scope:[irq_line]  from irq_line::@2
  [18] cnt = -- cnt
  [19] if(cnt!=0) goto irq_line::@1
  to:irq_line::@11
irq_line::@11: scope:[irq_line]  from irq_line::@4
  [20] cnt = 2
  [21] if(hstart>=(byte)$140/4+1) goto irq_line::@1
  to:irq_line::@12
irq_line::@12: scope:[irq_line]  from irq_line::@11
  [22] hstart = ++ hstart
  [23] hstop = -- hstop
  [24] vstart = ++ vstart
  [25] vstop = -- vstop
  to:irq_line::@1
irq_line::@1: scope:[irq_line]  from irq_line::@11 irq_line::@12 irq_line::@4
  [26] phi()
  [27] call memset 
  to:irq_line::@19
irq_line::@19: scope:[irq_line]  from irq_line::@1
  [28] irq_line::idx#0 = sin_idx
  [29] sin_idx = -- sin_idx
  to:irq_line::@13
irq_line::@13: scope:[irq_line]  from irq_line::@18 irq_line::@19
  [30] irq_line::idx#2 = phi( irq_line::@18/irq_line::idx#1, irq_line::@19/irq_line::idx#0 )
  [30] irq_line::b#2 = phi( irq_line::@18/irq_line::b#1, irq_line::@19/0 )
  [31] if(irq_line::b#2<8) goto irq_line::@14
  to:irq_line::@15
irq_line::@15: scope:[irq_line]  from irq_line::@13
  [32] *VERA_ISR = VERA_LINE
  asm { ply plx pla rti  }
  to:irq_line::@return
irq_line::@return: scope:[irq_line]  from irq_line::@15
  [34] return 
  to:@return
irq_line::@14: scope:[irq_line]  from irq_line::@13
  [35] irq_line::bar#0 = BARS + SIN[irq_line::idx#2]
  to:irq_line::@16
irq_line::@16: scope:[irq_line]  from irq_line::@14 irq_line::@17
  [36] irq_line::i2#2 = phi( irq_line::@14/0, irq_line::@17/irq_line::i2#1 )
  [37] if(irq_line::i2#2<$20*SIZEOF_BYTE) goto irq_line::@17
  to:irq_line::@18
irq_line::@18: scope:[irq_line]  from irq_line::@16
  [38] irq_line::idx#1 = irq_line::idx#2 + $d
  [39] irq_line::b#1 = ++ irq_line::b#2
  to:irq_line::@13
irq_line::@17: scope:[irq_line]  from irq_line::@16
  [40] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2]
  [41] irq_line::i2#1 = ++ irq_line::i2#2
  to:irq_line::@16
irq_line::@3: scope:[irq_line]  from irq_line::@2
  [42] *VERA_DC_BORDER = BARS[irq_line::l#2]
  to:irq_line::@5
irq_line::@5: scope:[irq_line]  from irq_line::@3 irq_line::@6
  [43] irq_line::i#2 = phi( irq_line::@3/0, irq_line::@6/irq_line::i#1 )
  [44] if(irq_line::i#2<$18) goto irq_line::@6
  to:irq_line::@7
irq_line::@7: scope:[irq_line]  from irq_line::@5
  [45] *VERA_DC_BORDER = 0
  to:irq_line::@8
irq_line::@8: scope:[irq_line]  from irq_line::@7 irq_line::@9
  [46] irq_line::i1#2 = phi( irq_line::@7/0, irq_line::@9/irq_line::i1#1 )
  [47] if(irq_line::i1#2<$17) goto irq_line::@9
  to:irq_line::@10
irq_line::@10: scope:[irq_line]  from irq_line::@8
  asm { nop nop  }
  [49] irq_line::l#1 = ++ irq_line::l#2
  to:irq_line::@2
irq_line::@9: scope:[irq_line]  from irq_line::@8
  [50] irq_line::i1#1 = ++ irq_line::i1#2
  to:irq_line::@8
irq_line::@6: scope:[irq_line]  from irq_line::@5
  [51] irq_line::i#1 = ++ irq_line::i#2
  to:irq_line::@5

void main()
main: scope:[main]  from __start::@1
  [52] phi()
  to:main::SEI1
main::SEI1: scope:[main]  from main
  asm { sei  }
  to:main::@2
main::@2: scope:[main]  from main::SEI1
  [54] *KERNEL_IRQ = &irq_line
  [55] *VERA_IEN = VERA_LINE
  [56] *VERA_IRQLINE_L = 5
  to:main::CLI1
main::CLI1: scope:[main]  from main::@2
  asm { cli  }
  to:main::@1
main::@1: scope:[main]  from main::@1 main::CLI1
  [58] phi()
  to:main::@1

void* memset(void* memset::str , byte memset::c , word memset::num)
memset: scope:[memset]  from irq_line::@1
  [59] phi()
  to:memset::@1
memset::@1: scope:[memset]  from memset memset::@2
  [60] memset::dst#2 = phi( memset/(byte*)memset::str#0, memset::@2/memset::dst#1 )
  [61] if(memset::dst#2!=memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset::@1
  [62] return 
  to:@return
memset::@2: scope:[memset]  from memset::@1
  [63] *memset::dst#2 = memset::c#0
  [64] memset::dst#1 = ++ memset::dst#2
  to:memset::@1


VARIABLE REGISTER WEIGHTS
void __start()
volatile byte cnt loadstore 0.5263157894736842
volatile byte hstart loadstore 0.4545454545454546
volatile byte hstop loadstore 0.34782608695652173
void irq_line()
byte irq_line::b
byte irq_line::b#1 22.0
byte irq_line::b#2 4.125
byte* irq_line::bar
byte* irq_line::bar#0 22.4
byte irq_line::i
byte irq_line::i#1 202.0
byte irq_line::i#2 151.5
byte irq_line::i1
byte irq_line::i1#1 202.0
byte irq_line::i1#2 151.5
byte irq_line::i2
byte irq_line::i2#1 202.0
byte irq_line::i2#2 168.33333333333331
byte irq_line::idx
byte irq_line::idx#0 2.0
byte irq_line::idx#1 11.0
byte irq_line::idx#2 5.0
byte irq_line::l
byte irq_line::l#1 22.0
byte irq_line::l#2 4.0
void main()
void* memset(void* memset::str , byte memset::c , word memset::num)
byte memset::c
byte* memset::dst
byte* memset::dst#1 202.0
byte* memset::dst#2 134.66666666666666
byte* memset::end
word memset::num
void* memset::return
void* memset::str
volatile byte sin_idx loadstore 0.27586206896551724
volatile byte vstart loadstore 0.3333333333333333
volatile byte vstop loadstore 0.32

Initial phi equivalence classes
[ irq_line::l#2 irq_line::l#1 ]
[ irq_line::b#2 irq_line::b#1 ]
[ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
[ irq_line::i2#2 irq_line::i2#1 ]
[ irq_line::i#2 irq_line::i#1 ]
[ irq_line::i1#2 irq_line::i1#1 ]
[ memset::dst#2 memset::dst#1 ]
Added variable hstart to live range equivalence class [ hstart ]
Added variable hstop to live range equivalence class [ hstop ]
Added variable vstart to live range equivalence class [ vstart ]
Added variable vstop to live range equivalence class [ vstop ]
Added variable cnt to live range equivalence class [ cnt ]
Added variable sin_idx to live range equivalence class [ sin_idx ]
Added variable irq_line::bar#0 to live range equivalence class [ irq_line::bar#0 ]
Complete equivalence classes
[ irq_line::l#2 irq_line::l#1 ]
[ irq_line::b#2 irq_line::b#1 ]
[ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
[ irq_line::i2#2 irq_line::i2#1 ]
[ irq_line::i#2 irq_line::i#1 ]
[ irq_line::i1#2 irq_line::i1#1 ]
[ memset::dst#2 memset::dst#1 ]
[ hstart ]
[ hstop ]
[ vstart ]
[ vstop ]
[ cnt ]
[ sin_idx ]
[ irq_line::bar#0 ]
Allocated zp[1]:2 [ irq_line::l#2 irq_line::l#1 ]
Allocated zp[1]:3 [ irq_line::b#2 irq_line::b#1 ]
Allocated zp[1]:4 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
Allocated zp[1]:5 [ irq_line::i2#2 irq_line::i2#1 ]
Allocated zp[1]:6 [ irq_line::i#2 irq_line::i#1 ]
Allocated zp[1]:7 [ irq_line::i1#2 irq_line::i1#1 ]
Allocated zp[2]:8 [ memset::dst#2 memset::dst#1 ]
Allocated zp[1]:10 [ hstart ]
Allocated zp[1]:11 [ hstop ]
Allocated zp[1]:12 [ vstart ]
Allocated zp[1]:13 [ vstop ]
Allocated zp[1]:14 [ cnt ]
Allocated zp[1]:15 [ sin_idx ]
Allocated zp[2]:16 [ irq_line::bar#0 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] hstart = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] hstop = (byte)$280/4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] vstart = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] vstop = (byte)$1e0/2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] cnt = 2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] sin_idx = $64 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [10] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [11] *VERA_DC_HSTART = hstart [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [12] *VERA_DC_HSTOP = hstop [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [13] *VERA_DC_VSTART = vstart [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [14] *VERA_DC_VSTOP = vstop [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [15] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [19] if(cnt!=0) goto irq_line::@1 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [20] cnt = 2 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [21] if(hstart>=(byte)$140/4+1) goto irq_line::@1 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [32] *VERA_ISR = VERA_LINE [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement asm { ply plx pla rti  } always clobbers reg byte a reg byte x reg byte y 
Statement [35] irq_line::bar#0 = BARS + SIN[irq_line::idx#2] [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 ] (  [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:3 [ irq_line::b#2 irq_line::b#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:4 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
Statement [38] irq_line::idx#1 = irq_line::idx#2 + $d [ irq_line::b#2 irq_line::idx#1 ] (  [ irq_line::b#2 irq_line::idx#1 ] { }  ) always clobbers reg byte a 
Statement [40] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2] [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 irq_line::i2#2 ] (  [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 irq_line::i2#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ irq_line::i2#2 irq_line::i2#1 ]
Statement [42] *VERA_DC_BORDER = BARS[irq_line::l#2] [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] (  [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ irq_line::l#2 irq_line::l#1 ]
Statement [45] *VERA_DC_BORDER = 0 [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] (  [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] { }  ) always clobbers reg byte a 
Statement [54] *KERNEL_IRQ = &irq_line [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [55] *VERA_IEN = VERA_LINE [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [56] *VERA_IRQLINE_L = 5 [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [61] if(memset::dst#2!=memset::end#0) goto memset::@2 [ memset::dst#2 ] ( memset:27 [ sin_idx memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [63] *memset::dst#2 = memset::c#0 [ memset::dst#2 ] ( memset:27 [ sin_idx memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [1] hstart = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] hstop = (byte)$280/4 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] vstart = 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] vstop = (byte)$1e0/2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] cnt = 2 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] sin_idx = $64 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [10] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [11] *VERA_DC_HSTART = hstart [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [12] *VERA_DC_HSTOP = hstop [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [13] *VERA_DC_VSTART = vstart [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [14] *VERA_DC_VSTOP = vstop [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [15] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL [ hstart hstop vstart vstop cnt sin_idx ] (  [ hstart hstop vstart vstop cnt sin_idx ] { }  ) always clobbers reg byte a 
Statement [19] if(cnt!=0) goto irq_line::@1 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [20] cnt = 2 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [21] if(hstart>=(byte)$140/4+1) goto irq_line::@1 [ hstart hstop vstart vstop sin_idx ] (  [ hstart hstop vstart vstop sin_idx ] { }  ) always clobbers reg byte a 
Statement [32] *VERA_ISR = VERA_LINE [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement asm { ply plx pla rti  } always clobbers reg byte a reg byte x reg byte y 
Statement [35] irq_line::bar#0 = BARS + SIN[irq_line::idx#2] [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 ] (  [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 ] { }  ) always clobbers reg byte a 
Statement [38] irq_line::idx#1 = irq_line::idx#2 + $d [ irq_line::b#2 irq_line::idx#1 ] (  [ irq_line::b#2 irq_line::idx#1 ] { }  ) always clobbers reg byte a 
Statement [40] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2] [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 irq_line::i2#2 ] (  [ irq_line::b#2 irq_line::idx#2 irq_line::bar#0 irq_line::i2#2 ] { }  ) always clobbers reg byte a 
Statement [42] *VERA_DC_BORDER = BARS[irq_line::l#2] [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] (  [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] { }  ) always clobbers reg byte a 
Statement [45] *VERA_DC_BORDER = 0 [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] (  [ hstart hstop vstart vstop cnt sin_idx irq_line::l#2 ] { }  ) always clobbers reg byte a 
Statement [54] *KERNEL_IRQ = &irq_line [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [55] *VERA_IEN = VERA_LINE [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [56] *VERA_IRQLINE_L = 5 [ ] ( main:8 [ ] { }  ) always clobbers reg byte a 
Statement [61] if(memset::dst#2!=memset::end#0) goto memset::@2 [ memset::dst#2 ] ( memset:27 [ sin_idx memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [63] *memset::dst#2 = memset::c#0 [ memset::dst#2 ] ( memset:27 [ sin_idx memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Potential registers zp[1]:2 [ irq_line::l#2 irq_line::l#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ irq_line::b#2 irq_line::b#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ irq_line::i2#2 irq_line::i2#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ irq_line::i#2 irq_line::i#1 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ irq_line::i1#2 irq_line::i1#1 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:8 [ memset::dst#2 memset::dst#1 ] : zp[2]:8 , 
Potential registers zp[1]:10 [ hstart ] : zp[1]:10 , 
Potential registers zp[1]:11 [ hstop ] : zp[1]:11 , 
Potential registers zp[1]:12 [ vstart ] : zp[1]:12 , 
Potential registers zp[1]:13 [ vstop ] : zp[1]:13 , 
Potential registers zp[1]:14 [ cnt ] : zp[1]:14 , 
Potential registers zp[1]:15 [ sin_idx ] : zp[1]:15 , 
Potential registers zp[2]:16 [ irq_line::bar#0 ] : zp[2]:16 , 

REGISTER UPLIFT SCOPES
Uplift Scope [irq_line] 370.33: zp[1]:5 [ irq_line::i2#2 irq_line::i2#1 ] 353.5: zp[1]:6 [ irq_line::i#2 irq_line::i#1 ] 353.5: zp[1]:7 [ irq_line::i1#2 irq_line::i1#1 ] 26.12: zp[1]:3 [ irq_line::b#2 irq_line::b#1 ] 26: zp[1]:2 [ irq_line::l#2 irq_line::l#1 ] 22.4: zp[2]:16 [ irq_line::bar#0 ] 18: zp[1]:4 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ] 
Uplift Scope [memset] 336.67: zp[2]:8 [ memset::dst#2 memset::dst#1 ] 
Uplift Scope [] 0.53: zp[1]:14 [ cnt ] 0.45: zp[1]:10 [ hstart ] 0.35: zp[1]:11 [ hstop ] 0.33: zp[1]:12 [ vstart ] 0.32: zp[1]:13 [ vstop ] 0.28: zp[1]:15 [ sin_idx ] 
Uplift Scope [VERA_SPRITE] 
Uplift Scope [MOS6522_VIA] 
Uplift Scope [main] 
Uplift Scope [__start] 

Uplifting [irq_line] best 8197 combination reg byte y [ irq_line::i2#2 irq_line::i2#1 ] reg byte a [ irq_line::i#2 irq_line::i#1 ] reg byte a [ irq_line::i1#2 irq_line::i1#1 ] reg byte x [ irq_line::b#2 irq_line::b#1 ] zp[1]:2 [ irq_line::l#2 irq_line::l#1 ] zp[2]:16 [ irq_line::bar#0 ] zp[1]:4 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ] 
Limited combination testing to 100 combinations of 1296 possible.
Uplifting [memset] best 8197 combination zp[2]:8 [ memset::dst#2 memset::dst#1 ] 
Uplifting [] best 8197 combination zp[1]:14 [ cnt ] zp[1]:10 [ hstart ] zp[1]:11 [ hstop ] zp[1]:12 [ vstart ] zp[1]:13 [ vstop ] zp[1]:15 [ sin_idx ] 
Uplifting [VERA_SPRITE] best 8197 combination 
Uplifting [MOS6522_VIA] best 8197 combination 
Uplifting [main] best 8197 combination 
Uplifting [__start] best 8197 combination 
Attempting to uplift remaining variables inzp[1]:2 [ irq_line::l#2 irq_line::l#1 ]
Uplifting [irq_line] best 8077 combination reg byte x [ irq_line::l#2 irq_line::l#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
Uplifting [irq_line] best 8077 combination zp[1]:4 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ] 
Attempting to uplift remaining variables inzp[1]:14 [ cnt ]
Uplifting [] best 8077 combination zp[1]:14 [ cnt ] 
Attempting to uplift remaining variables inzp[1]:10 [ hstart ]
Uplifting [] best 8077 combination zp[1]:10 [ hstart ] 
Attempting to uplift remaining variables inzp[1]:11 [ hstop ]
Uplifting [] best 8077 combination zp[1]:11 [ hstop ] 
Attempting to uplift remaining variables inzp[1]:12 [ vstart ]
Uplifting [] best 8077 combination zp[1]:12 [ vstart ] 
Attempting to uplift remaining variables inzp[1]:13 [ vstop ]
Uplifting [] best 8077 combination zp[1]:13 [ vstop ] 
Attempting to uplift remaining variables inzp[1]:15 [ sin_idx ]
Uplifting [] best 8077 combination zp[1]:15 [ sin_idx ] 
Coalescing zero page register [ zp[2]:16 [ irq_line::bar#0 ] ] with [ zp[2]:8 [ memset::dst#2 memset::dst#1 ] ]
Allocated (was zp[1]:4) zp[1]:2 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
Allocated (was zp[1]:10) zp[1]:3 [ hstart ]
Allocated (was zp[1]:11) zp[1]:4 [ hstop ]
Allocated (was zp[1]:12) zp[1]:5 [ vstart ]
Allocated (was zp[1]:13) zp[1]:6 [ vstop ]
Allocated (was zp[1]:14) zp[1]:7 [ cnt ]
Allocated (was zp[1]:15) zp[1]:8 [ sin_idx ]
Allocated (was zp[2]:16) zp[2]:9 [ irq_line::bar#0 memset::dst#2 memset::dst#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Example program for the Commander X16
// Displays raster bars in the border
  // Upstart
.cpu _65c02
  // Commodore 64 PRG executable file
.file [name="rasterbars.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
.segment Code


  // Global Constants & labels
  .const VERA_DCSEL = 2
  .const VERA_LINE = 2
  .const SIZEOF_BYTE = 1
  // $9F25	CTRL Control
  // Bit 7: Reset
  // Bit 1: DCSEL
  // Bit 2: ADDRSEL
  .label VERA_CTRL = $9f25
  // $9F26	IEN		Interrupt Enable
  // Bit 7: IRQ line (8)
  // Bit 3: AFLOW
  // Bit 2: SPRCOL
  // Bit 1: LINE
  // Bit 0: VSYNC
  .label VERA_IEN = $9f26
  // $9F27	ISR     Interrupt Status
  // Interrupts will be generated for the interrupt sources set in the lower 4 bits of IEN. ISR will indicate the interrupts that have occurred.
  // Writing a 1 to one of the lower 3 bits in ISR will clear that interrupt status. AFLOW can only be cleared by filling the audio FIFO for at least 1/4.
  // Bit 4-7: Sprite Collisions. This field indicates which groups of sprites have collided.
  // Bit 3: AFLOW
  // Bit 2: SPRCOL
  // Bit 1: LINE
  // Bit 0: VSYNC
  .label VERA_ISR = $9f27
  // $9F28	IRQLINE_L	IRQ line (7:0)
  // IRQ_LINE specifies at which line the LINE interrupt will be generated.
  // Note that bit 8 of this value is present in the IEN register.
  // For interlaced modes the interrupt will be generated each field and the bit 0 of IRQ_LINE is ignored.
  .label VERA_IRQLINE_L = $9f28
  // $9F2C	DC_BORDER (DCSEL=0)	Border Color
  .label VERA_DC_BORDER = $9f2c
  // $9F29	DC_HSTART (DCSEL=1)	Active Display H-Start (9:2)
  .label VERA_DC_HSTART = $9f29
  // $9F2A	DC_HSTOP (DCSEL=1)	Active Display H-Stop (9:2)
  .label VERA_DC_HSTOP = $9f2a
  // $9F2B	DC_VSTART (DCSEL=1)	Active Display V-Start (8:1)
  .label VERA_DC_VSTART = $9f2b
  // $9F2C	DC_VSTOP (DCSEL=1)	Active Display V-Stop (8:1)
  .label VERA_DC_VSTOP = $9f2c
  // $0314	(RAM) IRQ vector - The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  // The horizontal start
  .label hstart = 3
  // The horizontal stop
  .label hstop = 4
  // The vertical start
  .label vstart = 5
  // The vertical stop
  .label vstop = 6
  // The countdown
  .label cnt = 7
  // The sin idx
  .label sin_idx = 8
.segment Code
  // __start
__start: {
    jmp __init1
    // __start::__init1
  __init1:
    // [1] hstart = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z hstart
    // [2] hstop = (byte)$280/4 -- vbuz1=vbuc1 
    lda #$280/4
    sta.z hstop
    // [3] vstart = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z vstart
    // [4] vstop = (byte)$1e0/2 -- vbuz1=vbuc1 
    lda #$1e0/2
    sta.z vstop
    // [5] cnt = 2 -- vbuz1=vbuc1 
    lda #2
    sta.z cnt
    // [6] sin_idx = $64 -- vbuz1=vbuc1 
    lda #$64
    sta.z sin_idx
    // [7] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
  __b1_from___init1:
    jmp __b1
    // __start::@1
  __b1:
    // [8] call main 
    // [52] phi from __start::@1 to main [phi:__start::@1->main]
  main_from___b1:
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [9] return 
    rts
}
  // irq_line
// LINE Interrupt Routine
irq_line: {
    .label idx = 2
    .label bar = 9
    // [10] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Update the border
    lda #VERA_DCSEL
    ora VERA_CTRL
    sta VERA_CTRL
    // [11] *VERA_DC_HSTART = hstart -- _deref_pbuc1=vbuz1 
    lda.z hstart
    sta VERA_DC_HSTART
    // [12] *VERA_DC_HSTOP = hstop -- _deref_pbuc1=vbuz1 
    lda.z hstop
    sta VERA_DC_HSTOP
    // [13] *VERA_DC_VSTART = vstart -- _deref_pbuc1=vbuz1 
    lda.z vstart
    sta VERA_DC_VSTART
    // [14] *VERA_DC_VSTOP = vstop -- _deref_pbuc1=vbuz1 
    lda.z vstop
    sta VERA_DC_VSTOP
    // [15] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Show color raster bars in the border
    lda #VERA_DCSEL^$ff
    and VERA_CTRL
    sta VERA_CTRL
    // [16] phi from irq_line to irq_line::@2 [phi:irq_line->irq_line::@2]
  __b2_from_irq_line:
    // [16] phi irq_line::l#2 = 0 [phi:irq_line->irq_line::@2#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b2
    // irq_line::@2
  __b2:
    // [17] if(irq_line::l#2!=$e6) goto irq_line::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$e6
    bne __b3
    jmp __b4
    // irq_line::@4
  __b4:
    // [18] cnt = -- cnt -- vbuz1=_dec_vbuz1 
    dec.z cnt
    // [19] if(cnt!=0) goto irq_line::@1 -- vbuz1_neq_0_then_la1 
    lda.z cnt
    cmp #0
    bne __b1_from___b4
    jmp __b11
    // irq_line::@11
  __b11:
    // [20] cnt = 2 -- vbuz1=vbuc1 
    lda #2
    sta.z cnt
    // [21] if(hstart>=(byte)$140/4+1) goto irq_line::@1 -- vbuz1_ge_vbuc1_then_la1 
    lda.z hstart
    cmp #$140/4+1
    bcs __b1_from___b11
    jmp __b12
    // irq_line::@12
  __b12:
    // [22] hstart = ++ hstart -- vbuz1=_inc_vbuz1 
    inc.z hstart
    // [23] hstop = -- hstop -- vbuz1=_dec_vbuz1 
    dec.z hstop
    // [24] vstart = ++ vstart -- vbuz1=_inc_vbuz1 
    inc.z vstart
    // [25] vstop = -- vstop -- vbuz1=_dec_vbuz1 
    dec.z vstop
    // [26] phi from irq_line::@11 irq_line::@12 irq_line::@4 to irq_line::@1 [phi:irq_line::@11/irq_line::@12/irq_line::@4->irq_line::@1]
  __b1_from___b11:
  __b1_from___b12:
  __b1_from___b4:
    jmp __b1
    // irq_line::@1
  __b1:
    // [27] call memset 
  // Animate the bars
    // [59] phi from irq_line::@1 to memset [phi:irq_line::@1->memset]
  memset_from___b1:
    jsr memset
    jmp __b19
    // irq_line::@19
  __b19:
    // [28] irq_line::idx#0 = sin_idx -- vbuz1=vbuz2 
    lda.z sin_idx
    sta.z idx
    // [29] sin_idx = -- sin_idx -- vbuz1=_dec_vbuz1 
    dec.z sin_idx
    // [30] phi from irq_line::@19 to irq_line::@13 [phi:irq_line::@19->irq_line::@13]
  __b13_from___b19:
    // [30] phi irq_line::idx#2 = irq_line::idx#0 [phi:irq_line::@19->irq_line::@13#0] -- register_copy 
    // [30] phi irq_line::b#2 = 0 [phi:irq_line::@19->irq_line::@13#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b13
    // irq_line::@13
  __b13:
    // [31] if(irq_line::b#2<8) goto irq_line::@14 -- vbuxx_lt_vbuc1_then_la1 
    cpx #8
    bcc __b14
    jmp __b15
    // irq_line::@15
  __b15:
    // [32] *VERA_ISR = VERA_LINE -- _deref_pbuc1=vbuc2 
    // Reset the LINE interrupt
    lda #VERA_LINE
    sta VERA_ISR
    // asm { ply plx pla rti  }
    // Exit CX16 KERNAL IRQ
    ply
    plx
    pla
    rti
    jmp __breturn
    // irq_line::@return
  __breturn:
    // [34] return 
    rts
    // irq_line::@14
  __b14:
    // [35] irq_line::bar#0 = BARS + SIN[irq_line::idx#2] -- pbuz1=pbuc1_plus_pbuc2_derefidx_vbuz2 
    ldy.z idx
    lda SIN,y
    clc
    adc #<BARS
    sta.z bar
    lda #>BARS
    adc #0
    sta.z bar+1
    // [36] phi from irq_line::@14 to irq_line::@16 [phi:irq_line::@14->irq_line::@16]
  __b16_from___b14:
    // [36] phi irq_line::i2#2 = 0 [phi:irq_line::@14->irq_line::@16#0] -- vbuyy=vbuc1 
    ldy #0
    jmp __b16
    // irq_line::@16
  __b16:
    // [37] if(irq_line::i2#2<$20*SIZEOF_BYTE) goto irq_line::@17 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$20*SIZEOF_BYTE
    bcc __b17
    jmp __b18
    // irq_line::@18
  __b18:
    // [38] irq_line::idx#1 = irq_line::idx#2 + $d -- vbuz1=vbuz1_plus_vbuc1 
    lda #$d
    clc
    adc.z idx
    sta.z idx
    // [39] irq_line::b#1 = ++ irq_line::b#2 -- vbuxx=_inc_vbuxx 
    inx
    // [30] phi from irq_line::@18 to irq_line::@13 [phi:irq_line::@18->irq_line::@13]
  __b13_from___b18:
    // [30] phi irq_line::idx#2 = irq_line::idx#1 [phi:irq_line::@18->irq_line::@13#0] -- register_copy 
    // [30] phi irq_line::b#2 = irq_line::b#1 [phi:irq_line::@18->irq_line::@13#1] -- register_copy 
    jmp __b13
    // irq_line::@17
  __b17:
    // [40] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2] -- pbuz1_derefidx_vbuyy=pbuc1_derefidx_vbuyy 
    lda BAR,y
    sta (bar),y
    // [41] irq_line::i2#1 = ++ irq_line::i2#2 -- vbuyy=_inc_vbuyy 
    iny
    // [36] phi from irq_line::@17 to irq_line::@16 [phi:irq_line::@17->irq_line::@16]
  __b16_from___b17:
    // [36] phi irq_line::i2#2 = irq_line::i2#1 [phi:irq_line::@17->irq_line::@16#0] -- register_copy 
    jmp __b16
    // irq_line::@3
  __b3:
    // [42] *VERA_DC_BORDER = BARS[irq_line::l#2] -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda BARS,x
    sta VERA_DC_BORDER
    // [43] phi from irq_line::@3 to irq_line::@5 [phi:irq_line::@3->irq_line::@5]
  __b5_from___b3:
    // [43] phi irq_line::i#2 = 0 [phi:irq_line::@3->irq_line::@5#0] -- vbuaa=vbuc1 
    lda #0
    jmp __b5
    // irq_line::@5
  __b5:
    // [44] if(irq_line::i#2<$18) goto irq_line::@6 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$18
    bcc __b6
    jmp __b7
    // irq_line::@7
  __b7:
    // [45] *VERA_DC_BORDER = 0 -- _deref_pbuc1=vbuc2 
    // Wait exactly long enought to go to the next raster line
    lda #0
    sta VERA_DC_BORDER
    // [46] phi from irq_line::@7 to irq_line::@8 [phi:irq_line::@7->irq_line::@8]
  __b8_from___b7:
    // [46] phi irq_line::i1#2 = 0 [phi:irq_line::@7->irq_line::@8#0] -- vbuaa=vbuc1 
    lda #0
    jmp __b8
    // irq_line::@8
  __b8:
    // [47] if(irq_line::i1#2<$17) goto irq_line::@9 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$17
    bcc __b9
    jmp __b10
    // irq_line::@10
  __b10:
    // asm { nop nop  }
    // Wait exactly long enought to go to the next raster line
    nop
    nop
    // [49] irq_line::l#1 = ++ irq_line::l#2 -- vbuxx=_inc_vbuxx 
    inx
    // [16] phi from irq_line::@10 to irq_line::@2 [phi:irq_line::@10->irq_line::@2]
  __b2_from___b10:
    // [16] phi irq_line::l#2 = irq_line::l#1 [phi:irq_line::@10->irq_line::@2#0] -- register_copy 
    jmp __b2
    // irq_line::@9
  __b9:
    // [50] irq_line::i1#1 = ++ irq_line::i1#2 -- vbuaa=_inc_vbuaa 
    inc
    // [46] phi from irq_line::@9 to irq_line::@8 [phi:irq_line::@9->irq_line::@8]
  __b8_from___b9:
    // [46] phi irq_line::i1#2 = irq_line::i1#1 [phi:irq_line::@9->irq_line::@8#0] -- register_copy 
    jmp __b8
    // irq_line::@6
  __b6:
    // [51] irq_line::i#1 = ++ irq_line::i#2 -- vbuaa=_inc_vbuaa 
    inc
    // [43] phi from irq_line::@6 to irq_line::@5 [phi:irq_line::@6->irq_line::@5]
  __b5_from___b6:
    // [43] phi irq_line::i#2 = irq_line::i#1 [phi:irq_line::@6->irq_line::@5#0] -- register_copy 
    jmp __b5
}
  // main
main: {
    jmp SEI1
    // main::SEI1
  SEI1:
    // asm { sei  }
    sei
    jmp __b2
    // main::@2
  __b2:
    // [54] *KERNEL_IRQ = &irq_line -- _deref_qprc1=pprc2 
    lda #<irq_line
    sta KERNEL_IRQ
    lda #>irq_line
    sta KERNEL_IRQ+1
    // [55] *VERA_IEN = VERA_LINE -- _deref_pbuc1=vbuc2 
    lda #VERA_LINE
    sta VERA_IEN
    // [56] *VERA_IRQLINE_L = 5 -- _deref_pbuc1=vbuc2 
    lda #5
    sta VERA_IRQLINE_L
    jmp CLI1
    // main::CLI1
  CLI1:
    // asm { cli  }
    cli
    // [58] phi from main::@1 main::CLI1 to main::@1 [phi:main::@1/main::CLI1->main::@1]
  __b1_from___b1:
  __b1_from_CLI1:
    jmp __b1
    // main::@1
  __b1:
    jmp __b1_from___b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const num = $e6*SIZEOF_BYTE
    .const c = 0
    .label str = BARS
    .label end = str+num
    .label dst = 9
    // [60] phi from memset to memset::@1 [phi:memset->memset::@1]
  __b1_from_memset:
    // [60] phi memset::dst#2 = (byte*)memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    jmp __b1
    // memset::@1
  __b1:
    // [61] if(memset::dst#2!=memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    jmp __breturn
    // memset::@return
  __breturn:
    // [62] return 
    rts
    // memset::@2
  __b2:
    // [63] *memset::dst#2 = memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // [64] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [60] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
  __b1_from___b2:
    // [60] phi memset::dst#2 = memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
.segment Data
  .align $100
SIN:
.fill 256, 99+99*sin(i*2*PI/256)

  .align $100
  BARS: .fill $e6, 0
  .align $100
  BAR: .byte $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1a, $1b, $1c, $1d, $1e, $1f, $1f, $1e, $1d, $1c, $1b, $1a, $19, $18, $17, $16, $15, $14, $13, $12, $11, $10

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __init1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b1
Removing instruction jmp __b19
Removing instruction jmp __b13
Removing instruction jmp __b15
Removing instruction jmp __breturn
Removing instruction jmp __b16
Removing instruction jmp __b18
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b10
Removing instruction jmp SEI1
Removing instruction jmp __b2
Removing instruction jmp CLI1
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b4 with __b1
Replacing label __b1_from___b11 with __b1
Replacing label __b1_from___b1 with __b1
Removing instruction __b1_from___init1:
Removing instruction main_from___b1:
Removing instruction __b1_from___b11:
Removing instruction __b1_from___b12:
Removing instruction __b1_from___b4:
Removing instruction __b1_from___b1:
Removing instruction __b1_from_CLI1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __init1:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b2_from_irq_line:
Removing instruction __b4:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction memset_from___b1:
Removing instruction __b19:
Removing instruction __b13_from___b19:
Removing instruction __b15:
Removing instruction __breturn:
Removing instruction __b16_from___b14:
Removing instruction __b18:
Removing instruction __b13_from___b18:
Removing instruction __b16_from___b17:
Removing instruction __b5_from___b3:
Removing instruction __b7:
Removing instruction __b8_from___b7:
Removing instruction __b10:
Removing instruction __b2_from___b10:
Removing instruction __b8_from___b9:
Removing instruction __b5_from___b6:
Removing instruction SEI1:
Removing instruction __b2:
Removing instruction CLI1:
Removing instruction __b1_from_memset:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination

FINAL SYMBOL TABLE
const byte* BAR[$20]  = { $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1a, $1b, $1c, $1d, $1e, $1f, $1f, $1e, $1d, $1c, $1b, $1a, $19, $18, $17, $16, $15, $14, $13, $12, $11, $10 }
const byte* BARS[$e6]  = { fill( $e6, 0) }
const nomodify void()** KERNEL_IRQ = (void()**) 788
const byte* SIN[$100]  = kickasm {{ .fill 256, 99+99*sin(i*2*PI/256)
 }}
const byte SIZEOF_BYTE = 1
const nomodify byte* VERA_CTRL = (byte*) 40741
const nomodify byte VERA_DCSEL = 2
const nomodify byte* VERA_DC_BORDER = (byte*) 40748
const nomodify byte* VERA_DC_HSTART = (byte*) 40745
const nomodify byte* VERA_DC_HSTOP = (byte*) 40746
const nomodify byte* VERA_DC_VSTART = (byte*) 40747
const nomodify byte* VERA_DC_VSTOP = (byte*) 40748
const nomodify byte* VERA_IEN = (byte*) 40742
const nomodify byte* VERA_IRQLINE_L = (byte*) 40744
const nomodify byte* VERA_ISR = (byte*) 40743
const nomodify byte VERA_LINE = 2
void __start()
volatile byte cnt loadstore zp[1]:7 0.5263157894736842
volatile byte hstart loadstore zp[1]:3 0.4545454545454546
volatile byte hstop loadstore zp[1]:4 0.34782608695652173
void irq_line()
byte irq_line::b
byte irq_line::b#1 reg byte x 22.0
byte irq_line::b#2 reg byte x 4.125
byte* irq_line::bar
byte* irq_line::bar#0 bar zp[2]:9 22.4
byte irq_line::i
byte irq_line::i#1 reg byte a 202.0
byte irq_line::i#2 reg byte a 151.5
byte irq_line::i1
byte irq_line::i1#1 reg byte a 202.0
byte irq_line::i1#2 reg byte a 151.5
byte irq_line::i2
byte irq_line::i2#1 reg byte y 202.0
byte irq_line::i2#2 reg byte y 168.33333333333331
byte irq_line::idx
byte irq_line::idx#0 idx zp[1]:2 2.0
byte irq_line::idx#1 idx zp[1]:2 11.0
byte irq_line::idx#2 idx zp[1]:2 5.0
byte irq_line::l
byte irq_line::l#1 reg byte x 22.0
byte irq_line::l#2 reg byte x 4.0
void main()
void* memset(void* memset::str , byte memset::c , word memset::num)
byte memset::c
const byte memset::c#0 c = 0
byte* memset::dst
byte* memset::dst#1 dst zp[2]:9 202.0
byte* memset::dst#2 dst zp[2]:9 134.66666666666666
byte* memset::end
const byte* memset::end#0 end = (byte*)memset::str#0+memset::num#0
word memset::num
const word memset::num#0 num = $e6*SIZEOF_BYTE
void* memset::return
void* memset::str
const void* memset::str#0 str = (void*)BARS
volatile byte sin_idx loadstore zp[1]:8 0.27586206896551724
volatile byte vstart loadstore zp[1]:5 0.3333333333333333
volatile byte vstop loadstore zp[1]:6 0.32

reg byte x [ irq_line::l#2 irq_line::l#1 ]
reg byte x [ irq_line::b#2 irq_line::b#1 ]
zp[1]:2 [ irq_line::idx#2 irq_line::idx#1 irq_line::idx#0 ]
reg byte y [ irq_line::i2#2 irq_line::i2#1 ]
reg byte a [ irq_line::i#2 irq_line::i#1 ]
reg byte a [ irq_line::i1#2 irq_line::i1#1 ]
zp[1]:3 [ hstart ]
zp[1]:4 [ hstop ]
zp[1]:5 [ vstart ]
zp[1]:6 [ vstop ]
zp[1]:7 [ cnt ]
zp[1]:8 [ sin_idx ]
zp[2]:9 [ irq_line::bar#0 memset::dst#2 memset::dst#1 ]


FINAL ASSEMBLER
Score: 5780

  // File Comments
// Example program for the Commander X16
// Displays raster bars in the border
  // Upstart
.cpu _65c02
  // Commodore 64 PRG executable file
.file [name="rasterbars.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
.segment Code


  // Global Constants & labels
  .const VERA_DCSEL = 2
  .const VERA_LINE = 2
  .const SIZEOF_BYTE = 1
  // $9F25	CTRL Control
  // Bit 7: Reset
  // Bit 1: DCSEL
  // Bit 2: ADDRSEL
  .label VERA_CTRL = $9f25
  // $9F26	IEN		Interrupt Enable
  // Bit 7: IRQ line (8)
  // Bit 3: AFLOW
  // Bit 2: SPRCOL
  // Bit 1: LINE
  // Bit 0: VSYNC
  .label VERA_IEN = $9f26
  // $9F27	ISR     Interrupt Status
  // Interrupts will be generated for the interrupt sources set in the lower 4 bits of IEN. ISR will indicate the interrupts that have occurred.
  // Writing a 1 to one of the lower 3 bits in ISR will clear that interrupt status. AFLOW can only be cleared by filling the audio FIFO for at least 1/4.
  // Bit 4-7: Sprite Collisions. This field indicates which groups of sprites have collided.
  // Bit 3: AFLOW
  // Bit 2: SPRCOL
  // Bit 1: LINE
  // Bit 0: VSYNC
  .label VERA_ISR = $9f27
  // $9F28	IRQLINE_L	IRQ line (7:0)
  // IRQ_LINE specifies at which line the LINE interrupt will be generated.
  // Note that bit 8 of this value is present in the IEN register.
  // For interlaced modes the interrupt will be generated each field and the bit 0 of IRQ_LINE is ignored.
  .label VERA_IRQLINE_L = $9f28
  // $9F2C	DC_BORDER (DCSEL=0)	Border Color
  .label VERA_DC_BORDER = $9f2c
  // $9F29	DC_HSTART (DCSEL=1)	Active Display H-Start (9:2)
  .label VERA_DC_HSTART = $9f29
  // $9F2A	DC_HSTOP (DCSEL=1)	Active Display H-Stop (9:2)
  .label VERA_DC_HSTOP = $9f2a
  // $9F2B	DC_VSTART (DCSEL=1)	Active Display V-Start (8:1)
  .label VERA_DC_VSTART = $9f2b
  // $9F2C	DC_VSTOP (DCSEL=1)	Active Display V-Stop (8:1)
  .label VERA_DC_VSTOP = $9f2c
  // $0314	(RAM) IRQ vector - The vector used when the KERNAL serves IRQ interrupts
  .label KERNEL_IRQ = $314
  // The horizontal start
  .label hstart = 3
  // The horizontal stop
  .label hstop = 4
  // The vertical start
  .label vstart = 5
  // The vertical stop
  .label vstop = 6
  // The countdown
  .label cnt = 7
  // The sin idx
  .label sin_idx = 8
.segment Code
  // __start
__start: {
    // __start::__init1
    // hstart = 0/4
    // [1] hstart = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z hstart
    // hstop = 640/4
    // [2] hstop = (byte)$280/4 -- vbuz1=vbuc1 
    lda #$280/4
    sta.z hstop
    // vstart = 0/2
    // [3] vstart = 0 -- vbuz1=vbuc1 
    lda #0
    sta.z vstart
    // vstop = 480/2
    // [4] vstop = (byte)$1e0/2 -- vbuz1=vbuc1 
    lda #$1e0/2
    sta.z vstop
    // cnt = 2
    // [5] cnt = 2 -- vbuz1=vbuc1 
    lda #2
    sta.z cnt
    // sin_idx = 100
    // [6] sin_idx = $64 -- vbuz1=vbuc1 
    lda #$64
    sta.z sin_idx
    // [7] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
    // __start::@1
    // [8] call main 
    // [52] phi from __start::@1 to main [phi:__start::@1->main]
    jsr main
    // __start::@return
    // [9] return 
    rts
}
  // irq_line
// LINE Interrupt Routine
irq_line: {
    .label idx = 2
    .label bar = 9
    // *VERA_CTRL |= VERA_DCSEL
    // [10] *VERA_CTRL = *VERA_CTRL | VERA_DCSEL -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Update the border
    lda #VERA_DCSEL
    ora VERA_CTRL
    sta VERA_CTRL
    // *VERA_DC_HSTART = hstart
    // [11] *VERA_DC_HSTART = hstart -- _deref_pbuc1=vbuz1 
    lda.z hstart
    sta VERA_DC_HSTART
    // *VERA_DC_HSTOP = hstop
    // [12] *VERA_DC_HSTOP = hstop -- _deref_pbuc1=vbuz1 
    lda.z hstop
    sta VERA_DC_HSTOP
    // *VERA_DC_VSTART = vstart
    // [13] *VERA_DC_VSTART = vstart -- _deref_pbuc1=vbuz1 
    lda.z vstart
    sta VERA_DC_VSTART
    // *VERA_DC_VSTOP = vstop
    // [14] *VERA_DC_VSTOP = vstop -- _deref_pbuc1=vbuz1 
    lda.z vstop
    sta VERA_DC_VSTOP
    // *VERA_CTRL &= ~VERA_DCSEL
    // [15] *VERA_CTRL = *VERA_CTRL & ~VERA_DCSEL -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    // Show color raster bars in the border
    lda #VERA_DCSEL^$ff
    and VERA_CTRL
    sta VERA_CTRL
    // [16] phi from irq_line to irq_line::@2 [phi:irq_line->irq_line::@2]
    // [16] phi irq_line::l#2 = 0 [phi:irq_line->irq_line::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // irq_line::@2
  __b2:
    // for(char l=0;l!=230;l++)
    // [17] if(irq_line::l#2!=$e6) goto irq_line::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$e6
    bne __b3
    // irq_line::@4
    // if(--cnt==0)
    // [18] cnt = -- cnt -- vbuz1=_dec_vbuz1 
    dec.z cnt
    // [19] if(cnt!=0) goto irq_line::@1 -- vbuz1_neq_0_then_la1 
    lda.z cnt
    cmp #0
    bne __b1
    // irq_line::@11
    // cnt = 2
    // [20] cnt = 2 -- vbuz1=vbuc1 
    lda #2
    sta.z cnt
    // if(hstart<=320/4)
    // [21] if(hstart>=(byte)$140/4+1) goto irq_line::@1 -- vbuz1_ge_vbuc1_then_la1 
    lda.z hstart
    cmp #$140/4+1
    bcs __b1
    // irq_line::@12
    // hstart++;
    // [22] hstart = ++ hstart -- vbuz1=_inc_vbuz1 
    inc.z hstart
    // hstop--;
    // [23] hstop = -- hstop -- vbuz1=_dec_vbuz1 
    dec.z hstop
    // vstart++;
    // [24] vstart = ++ vstart -- vbuz1=_inc_vbuz1 
    inc.z vstart
    // vstop--;
    // [25] vstop = -- vstop -- vbuz1=_dec_vbuz1 
    dec.z vstop
    // [26] phi from irq_line::@11 irq_line::@12 irq_line::@4 to irq_line::@1 [phi:irq_line::@11/irq_line::@12/irq_line::@4->irq_line::@1]
    // irq_line::@1
  __b1:
    // memset(BARS, 0, sizeof(BARS))
    // [27] call memset 
  // Animate the bars
    // [59] phi from irq_line::@1 to memset [phi:irq_line::@1->memset]
    jsr memset
    // irq_line::@19
    // idx = sin_idx--
    // [28] irq_line::idx#0 = sin_idx -- vbuz1=vbuz2 
    lda.z sin_idx
    sta.z idx
    // [29] sin_idx = -- sin_idx -- vbuz1=_dec_vbuz1 
    dec.z sin_idx
    // [30] phi from irq_line::@19 to irq_line::@13 [phi:irq_line::@19->irq_line::@13]
    // [30] phi irq_line::idx#2 = irq_line::idx#0 [phi:irq_line::@19->irq_line::@13#0] -- register_copy 
    // [30] phi irq_line::b#2 = 0 [phi:irq_line::@19->irq_line::@13#1] -- vbuxx=vbuc1 
    ldx #0
    // irq_line::@13
  __b13:
    // for(char b=0;b<8;b++)
    // [31] if(irq_line::b#2<8) goto irq_line::@14 -- vbuxx_lt_vbuc1_then_la1 
    cpx #8
    bcc __b14
    // irq_line::@15
    // *VERA_ISR = VERA_LINE
    // [32] *VERA_ISR = VERA_LINE -- _deref_pbuc1=vbuc2 
    // Reset the LINE interrupt
    lda #VERA_LINE
    sta VERA_ISR
    // asm
    // asm { ply plx pla rti  }
    // Exit CX16 KERNAL IRQ
    ply
    plx
    pla
    rti
    // irq_line::@return
    // }
    // [34] return 
    rts
    // irq_line::@14
  __b14:
    // bar = BARS + SIN[idx]
    // [35] irq_line::bar#0 = BARS + SIN[irq_line::idx#2] -- pbuz1=pbuc1_plus_pbuc2_derefidx_vbuz2 
    ldy.z idx
    lda SIN,y
    clc
    adc #<BARS
    sta.z bar
    lda #>BARS
    adc #0
    sta.z bar+1
    // [36] phi from irq_line::@14 to irq_line::@16 [phi:irq_line::@14->irq_line::@16]
    // [36] phi irq_line::i2#2 = 0 [phi:irq_line::@14->irq_line::@16#0] -- vbuyy=vbuc1 
    ldy #0
    // irq_line::@16
  __b16:
    // for(char i=0;i<sizeof(BAR);i++)
    // [37] if(irq_line::i2#2<$20*SIZEOF_BYTE) goto irq_line::@17 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$20*SIZEOF_BYTE
    bcc __b17
    // irq_line::@18
    // idx += 13
    // [38] irq_line::idx#1 = irq_line::idx#2 + $d -- vbuz1=vbuz1_plus_vbuc1 
    lda #$d
    clc
    adc.z idx
    sta.z idx
    // for(char b=0;b<8;b++)
    // [39] irq_line::b#1 = ++ irq_line::b#2 -- vbuxx=_inc_vbuxx 
    inx
    // [30] phi from irq_line::@18 to irq_line::@13 [phi:irq_line::@18->irq_line::@13]
    // [30] phi irq_line::idx#2 = irq_line::idx#1 [phi:irq_line::@18->irq_line::@13#0] -- register_copy 
    // [30] phi irq_line::b#2 = irq_line::b#1 [phi:irq_line::@18->irq_line::@13#1] -- register_copy 
    jmp __b13
    // irq_line::@17
  __b17:
    // bar[i] = BAR[i]
    // [40] irq_line::bar#0[irq_line::i2#2] = BAR[irq_line::i2#2] -- pbuz1_derefidx_vbuyy=pbuc1_derefidx_vbuyy 
    lda BAR,y
    sta (bar),y
    // for(char i=0;i<sizeof(BAR);i++)
    // [41] irq_line::i2#1 = ++ irq_line::i2#2 -- vbuyy=_inc_vbuyy 
    iny
    // [36] phi from irq_line::@17 to irq_line::@16 [phi:irq_line::@17->irq_line::@16]
    // [36] phi irq_line::i2#2 = irq_line::i2#1 [phi:irq_line::@17->irq_line::@16#0] -- register_copy 
    jmp __b16
    // irq_line::@3
  __b3:
    // *VERA_DC_BORDER = BARS[l]
    // [42] *VERA_DC_BORDER = BARS[irq_line::l#2] -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    lda BARS,x
    sta VERA_DC_BORDER
    // [43] phi from irq_line::@3 to irq_line::@5 [phi:irq_line::@3->irq_line::@5]
    // [43] phi irq_line::i#2 = 0 [phi:irq_line::@3->irq_line::@5#0] -- vbuaa=vbuc1 
    lda #0
    // irq_line::@5
  __b5:
    // for(char i=0;i<24;i++)
    // [44] if(irq_line::i#2<$18) goto irq_line::@6 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$18
    bcc __b6
    // irq_line::@7
    // *VERA_DC_BORDER = 0
    // [45] *VERA_DC_BORDER = 0 -- _deref_pbuc1=vbuc2 
    // Wait exactly long enought to go to the next raster line
    lda #0
    sta VERA_DC_BORDER
    // [46] phi from irq_line::@7 to irq_line::@8 [phi:irq_line::@7->irq_line::@8]
    // [46] phi irq_line::i1#2 = 0 [phi:irq_line::@7->irq_line::@8#0] -- vbuaa=vbuc1 
    // irq_line::@8
  __b8:
    // for(char i=0;i<23;i++)
    // [47] if(irq_line::i1#2<$17) goto irq_line::@9 -- vbuaa_lt_vbuc1_then_la1 
    cmp #$17
    bcc __b9
    // irq_line::@10
    // asm
    // asm { nop nop  }
    // Wait exactly long enought to go to the next raster line
    nop
    nop
    // for(char l=0;l!=230;l++)
    // [49] irq_line::l#1 = ++ irq_line::l#2 -- vbuxx=_inc_vbuxx 
    inx
    // [16] phi from irq_line::@10 to irq_line::@2 [phi:irq_line::@10->irq_line::@2]
    // [16] phi irq_line::l#2 = irq_line::l#1 [phi:irq_line::@10->irq_line::@2#0] -- register_copy 
    jmp __b2
    // irq_line::@9
  __b9:
    // for(char i=0;i<23;i++)
    // [50] irq_line::i1#1 = ++ irq_line::i1#2 -- vbuaa=_inc_vbuaa 
    inc
    // [46] phi from irq_line::@9 to irq_line::@8 [phi:irq_line::@9->irq_line::@8]
    // [46] phi irq_line::i1#2 = irq_line::i1#1 [phi:irq_line::@9->irq_line::@8#0] -- register_copy 
    jmp __b8
    // irq_line::@6
  __b6:
    // for(char i=0;i<24;i++)
    // [51] irq_line::i#1 = ++ irq_line::i#2 -- vbuaa=_inc_vbuaa 
    inc
    // [43] phi from irq_line::@6 to irq_line::@5 [phi:irq_line::@6->irq_line::@5]
    // [43] phi irq_line::i#2 = irq_line::i#1 [phi:irq_line::@6->irq_line::@5#0] -- register_copy 
    jmp __b5
}
  // main
main: {
    // main::SEI1
    // asm
    // asm { sei  }
    sei
    // main::@2
    // *KERNEL_IRQ = &irq_line
    // [54] *KERNEL_IRQ = &irq_line -- _deref_qprc1=pprc2 
    lda #<irq_line
    sta KERNEL_IRQ
    lda #>irq_line
    sta KERNEL_IRQ+1
    // *VERA_IEN = VERA_LINE
    // [55] *VERA_IEN = VERA_LINE -- _deref_pbuc1=vbuc2 
    lda #VERA_LINE
    sta VERA_IEN
    // *VERA_IRQLINE_L = 5
    // [56] *VERA_IRQLINE_L = 5 -- _deref_pbuc1=vbuc2 
    lda #5
    sta VERA_IRQLINE_L
    // main::CLI1
    // asm
    // asm { cli  }
    cli
    // [58] phi from main::@1 main::CLI1 to main::@1 [phi:main::@1/main::CLI1->main::@1]
    // main::@1
  __b1:
    jmp __b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const num = $e6*SIZEOF_BYTE
    .const c = 0
    .label str = BARS
    .label end = str+num
    .label dst = 9
    // [60] phi from memset to memset::@1 [phi:memset->memset::@1]
    // [60] phi memset::dst#2 = (byte*)memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    // memset::@1
  __b1:
    // for(char* dst = str; dst!=end; dst++)
    // [61] if(memset::dst#2!=memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    // memset::@return
    // }
    // [62] return 
    rts
    // memset::@2
  __b2:
    // *dst = c
    // [63] *memset::dst#2 = memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [64] memset::dst#1 = ++ memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [60] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
    // [60] phi memset::dst#2 = memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
.segment Data
  .align $100
SIN:
.fill 256, 99+99*sin(i*2*PI/256)

  .align $100
  BARS: .fill $e6, 0
  .align $100
  BAR: .byte $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1a, $1b, $1c, $1d, $1e, $1f, $1f, $1e, $1d, $1c, $1b, $1a, $19, $18, $17, $16, $15, $14, $13, $12, $11, $10

