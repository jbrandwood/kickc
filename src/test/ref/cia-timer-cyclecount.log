Inlined call vicSelectGfxBank::$0 = call toDd00 vicSelectGfxBank::gfx 
Inlined call call __init 

CONTROL FLOW GRAPH SSA

dword clock()
clock: scope:[clock]  from main::@3
  clock::$0 = $ffffffff - *CIA2_TIMER_AB
  clock::return#0 = clock::$0
  to:clock::@return
clock::@return: scope:[clock]  from clock
  clock::return#3 = phi( clock/clock::return#0 )
  clock::return#1 = clock::return#3
  return 
  to:@return

void clock_start()
clock_start: scope:[clock_start]  from main::@2
  *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_STOP|CIA_TIMER_CONTROL_CONTINUOUS|CIA_TIMER_CONTROL_A_COUNT_CYCLES
  *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_STOP|CIA_TIMER_CONTROL_CONTINUOUS|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  *CIA2_TIMER_AB = $ffffffff
  *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_CONTINUOUS|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_CONTINUOUS|CIA_TIMER_CONTROL_A_COUNT_CYCLES
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  return 
  to:@return

void print_uint_at(word print_uint_at::w , byte* print_uint_at::at)
print_uint_at: scope:[print_uint_at]  from print_ulong_at print_ulong_at::@1
  print_uint_at::at#2 = phi( print_ulong_at/print_uint_at::at#0, print_ulong_at::@1/print_uint_at::at#1 )
  print_uint_at::w#2 = phi( print_ulong_at/print_uint_at::w#0, print_ulong_at::@1/print_uint_at::w#1 )
  print_uint_at::$0 = > print_uint_at::w#2
  print_uchar_at::b#0 = print_uint_at::$0
  print_uchar_at::at#0 = print_uint_at::at#2
  call print_uchar_at 
  to:print_uint_at::@1
print_uint_at::@1: scope:[print_uint_at]  from print_uint_at
  print_uint_at::at#3 = phi( print_uint_at/print_uint_at::at#2 )
  print_uint_at::w#3 = phi( print_uint_at/print_uint_at::w#2 )
  print_uint_at::$2 = < print_uint_at::w#3
  print_uint_at::$3 = print_uint_at::at#3 + 2
  print_uchar_at::b#1 = print_uint_at::$2
  print_uchar_at::at#1 = print_uint_at::$3
  call print_uchar_at 
  to:print_uint_at::@2
print_uint_at::@2: scope:[print_uint_at]  from print_uint_at::@1
  to:print_uint_at::@return
print_uint_at::@return: scope:[print_uint_at]  from print_uint_at::@2
  return 
  to:@return

void print_ulong_at(dword print_ulong_at::dw , byte* print_ulong_at::at)
print_ulong_at: scope:[print_ulong_at]  from main::@4
  print_ulong_at::at#1 = phi( main::@4/print_ulong_at::at#0 )
  print_ulong_at::dw#1 = phi( main::@4/print_ulong_at::dw#0 )
  print_ulong_at::$0 = > print_ulong_at::dw#1
  print_uint_at::w#0 = print_ulong_at::$0
  print_uint_at::at#0 = print_ulong_at::at#1
  call print_uint_at 
  to:print_ulong_at::@1
print_ulong_at::@1: scope:[print_ulong_at]  from print_ulong_at
  print_ulong_at::at#2 = phi( print_ulong_at/print_ulong_at::at#1 )
  print_ulong_at::dw#2 = phi( print_ulong_at/print_ulong_at::dw#1 )
  print_ulong_at::$2 = < print_ulong_at::dw#2
  print_ulong_at::$3 = print_ulong_at::at#2 + 4
  print_uint_at::w#1 = print_ulong_at::$2
  print_uint_at::at#1 = print_ulong_at::$3
  call print_uint_at 
  to:print_ulong_at::@2
print_ulong_at::@2: scope:[print_ulong_at]  from print_ulong_at::@1
  to:print_ulong_at::@return
print_ulong_at::@return: scope:[print_ulong_at]  from print_ulong_at::@2
  return 
  to:@return

void print_uchar_at(byte print_uchar_at::b , byte* print_uchar_at::at)
print_uchar_at: scope:[print_uchar_at]  from print_uint_at print_uint_at::@1
  print_uchar_at::at#2 = phi( print_uint_at/print_uchar_at::at#0, print_uint_at::@1/print_uchar_at::at#1 )
  print_uchar_at::b#2 = phi( print_uint_at/print_uchar_at::b#0, print_uint_at::@1/print_uchar_at::b#1 )
  print_uchar_at::$0 = print_uchar_at::b#2 >> 4
  print_char_at::ch#0 = print_hextab[print_uchar_at::$0]
  print_char_at::at#0 = print_uchar_at::at#2
  call print_char_at 
  to:print_uchar_at::@1
print_uchar_at::@1: scope:[print_uchar_at]  from print_uchar_at
  print_uchar_at::at#3 = phi( print_uchar_at/print_uchar_at::at#2 )
  print_uchar_at::b#3 = phi( print_uchar_at/print_uchar_at::b#2 )
  print_uchar_at::$2 = print_uchar_at::b#3 & $f
  print_uchar_at::$3 = print_uchar_at::at#3 + 1
  print_char_at::ch#1 = print_hextab[print_uchar_at::$2]
  print_char_at::at#1 = print_uchar_at::$3
  call print_char_at 
  to:print_uchar_at::@2
print_uchar_at::@2: scope:[print_uchar_at]  from print_uchar_at::@1
  to:print_uchar_at::@return
print_uchar_at::@return: scope:[print_uchar_at]  from print_uchar_at::@2
  return 
  to:@return

void print_char_at(byte print_char_at::ch , byte* print_char_at::at)
print_char_at: scope:[print_char_at]  from print_uchar_at print_uchar_at::@1
  print_char_at::at#2 = phi( print_uchar_at/print_char_at::at#0, print_uchar_at::@1/print_char_at::at#1 )
  print_char_at::ch#2 = phi( print_uchar_at/print_char_at::ch#0, print_uchar_at::@1/print_char_at::ch#1 )
  *print_char_at::at#2 = print_char_at::ch#2
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  to:main::@1
main::@1: scope:[main]  from main main::@5
  if(true) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  call clock_start 
  to:main::@3
main::@3: scope:[main]  from main::@2
  asm { nop  }
  call clock 
  clock::return#2 = clock::return#1
  to:main::@4
main::@4: scope:[main]  from main::@3
  clock::return#4 = phi( main::@3/clock::return#2 )
  main::$1 = clock::return#4
  main::$2 = main::$1 - CLOCKS_PER_INIT
  main::cyclecount#0 = main::$2
  print_ulong_at::dw#0 = main::cyclecount#0
  print_ulong_at::at#0 = SCREEN
  call print_ulong_at 
  to:main::@5
main::@5: scope:[main]  from main::@4
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
constant struct MOS6526_CIA* const CIA2 = (struct MOS6526_CIA*)$dd00
constant dword* const CIA2_TIMER_AB = (dword*)$dd04
constant const byte CIA_TIMER_CONTROL_A_COUNT_CYCLES = 0
constant const byte CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
constant const byte CIA_TIMER_CONTROL_CONTINUOUS = 0
constant const byte CIA_TIMER_CONTROL_START = 1
constant const byte CIA_TIMER_CONTROL_STOP = 0
constant const dword CLOCKS_PER_INIT = $12
constant byte OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
constant byte OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
constant byte RADIX::BINARY = 2
constant byte RADIX::DECIMAL = $a
constant byte RADIX::HEXADECIMAL = $10
constant byte RADIX::OCTAL = 8
constant byte* const SCREEN = (byte*)$400
void __start()
dword clock()
number~ clock::$0
dword clock::return
dword clock::return#0
dword clock::return#1
dword clock::return#2
dword clock::return#3
dword clock::return#4
void clock_start()
void main()
dword~ main::$1
dword~ main::$2
dword main::cyclecount
dword main::cyclecount#0
void print_char_at(byte print_char_at::ch , byte* print_char_at::at)
byte* print_char_at::at
byte* print_char_at::at#0
byte* print_char_at::at#1
byte* print_char_at::at#2
byte print_char_at::ch
byte print_char_at::ch#0
byte print_char_at::ch#1
byte print_char_at::ch#2
constant const byte* print_hextab[]  = "0123456789abcdef"z
void print_uchar_at(byte print_uchar_at::b , byte* print_uchar_at::at)
byte~ print_uchar_at::$0
number~ print_uchar_at::$2
byte*~ print_uchar_at::$3
byte* print_uchar_at::at
byte* print_uchar_at::at#0
byte* print_uchar_at::at#1
byte* print_uchar_at::at#2
byte* print_uchar_at::at#3
byte print_uchar_at::b
byte print_uchar_at::b#0
byte print_uchar_at::b#1
byte print_uchar_at::b#2
byte print_uchar_at::b#3
void print_uint_at(word print_uint_at::w , byte* print_uint_at::at)
byte~ print_uint_at::$0
byte~ print_uint_at::$2
byte*~ print_uint_at::$3
byte* print_uint_at::at
byte* print_uint_at::at#0
byte* print_uint_at::at#1
byte* print_uint_at::at#2
byte* print_uint_at::at#3
word print_uint_at::w
word print_uint_at::w#0
word print_uint_at::w#1
word print_uint_at::w#2
word print_uint_at::w#3
void print_ulong_at(dword print_ulong_at::dw , byte* print_ulong_at::at)
word~ print_ulong_at::$0
word~ print_ulong_at::$2
byte*~ print_ulong_at::$3
byte* print_ulong_at::at
byte* print_ulong_at::at#0
byte* print_ulong_at::at#1
byte* print_ulong_at::at#2
dword print_ulong_at::dw
dword print_ulong_at::dw#0
dword print_ulong_at::dw#1
dword print_ulong_at::dw#2

Adding number conversion cast (unumber) $ffffffff in clock::$0 = $ffffffff - *CIA2_TIMER_AB
Adding number conversion cast (unumber) clock::$0 in clock::$0 = (unumber)$ffffffff - *CIA2_TIMER_AB
Adding number conversion cast (unumber) $ffffffff in *CIA2_TIMER_AB = $ffffffff
Adding number conversion cast (unumber) 2 in print_uint_at::$3 = print_uint_at::at#3 + 2
Adding number conversion cast (unumber) 4 in print_ulong_at::$3 = print_ulong_at::at#2 + 4
Adding number conversion cast (unumber) 4 in print_uchar_at::$0 = print_uchar_at::b#2 >> 4
Adding number conversion cast (unumber) $f in print_uchar_at::$2 = print_uchar_at::b#3 & $f
Adding number conversion cast (unumber) print_uchar_at::$2 in print_uchar_at::$2 = print_uchar_at::b#3 & (unumber)$f
Adding number conversion cast (unumber) 1 in print_uchar_at::$3 = print_uchar_at::at#3 + 1
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *CIA2_TIMER_AB = (unumber)$ffffffff
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (struct MOS6526_CIA*) 56576
Simplifying constant pointer cast (dword*) 56580
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast 2
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to dword in clock::$0 = $ffffffff - *CIA2_TIMER_AB
Inferred type updated to byte in print_uchar_at::$2 = print_uchar_at::b#3 & $f
Alias clock::return#0 = clock::$0 clock::return#3 clock::return#1 
Alias print_uchar_at::b#0 = print_uint_at::$0 
Alias print_uint_at::w#2 = print_uint_at::w#3 
Alias print_uint_at::at#2 = print_uint_at::at#3 
Alias print_uchar_at::b#1 = print_uint_at::$2 
Alias print_uchar_at::at#1 = print_uint_at::$3 
Alias print_uint_at::w#0 = print_ulong_at::$0 
Alias print_ulong_at::dw#1 = print_ulong_at::dw#2 
Alias print_ulong_at::at#1 = print_ulong_at::at#2 
Alias print_uint_at::w#1 = print_ulong_at::$2 
Alias print_uint_at::at#1 = print_ulong_at::$3 
Alias print_uchar_at::b#2 = print_uchar_at::b#3 
Alias print_uchar_at::at#2 = print_uchar_at::at#3 
Alias print_char_at::at#1 = print_uchar_at::$3 
Alias clock::return#2 = clock::return#4 
Alias main::cyclecount#0 = main::$2 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values print_ulong_at::dw#1 print_ulong_at::dw#0
Identical Phi Values print_ulong_at::at#1 print_ulong_at::at#0
Successful SSA optimization Pass2IdenticalPhiElimination
Constant print_ulong_at::at#0 = SCREEN
Successful SSA optimization Pass2ConstantIdentification
Constant print_uint_at::at#0 = print_ulong_at::at#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [37] if(true) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Simplifying constant evaluating to zero CIA_TIMER_CONTROL_STOP|CIA_TIMER_CONTROL_CONTINUOUS|CIA_TIMER_CONTROL_A_COUNT_CYCLES in [2] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_STOP|CIA_TIMER_CONTROL_CONTINUOUS|CIA_TIMER_CONTROL_A_COUNT_CYCLES
Simplifying constant evaluating to zero CIA_TIMER_CONTROL_STOP|CIA_TIMER_CONTROL_CONTINUOUS in [3] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_STOP|CIA_TIMER_CONTROL_CONTINUOUS|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A in [3] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = 0|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Simplifying expression containing zero CIA_TIMER_CONTROL_START in [5] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_CONTINUOUS|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
Simplifying expression containing zero CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_CONTINUOUS in [6] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_CONTINUOUS|CIA_TIMER_CONTROL_A_COUNT_CYCLES
Successful SSA optimization PassNSimplifyExpressionWithZero
Simplifying expression containing zero CIA_TIMER_CONTROL_START in [6] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_CONTINUOUS
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused constant CIA_TIMER_CONTROL_STOP
Eliminating unused constant CIA_TIMER_CONTROL_CONTINUOUS
Eliminating unused constant CIA_TIMER_CONTROL_A_COUNT_CYCLES
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Constant right-side identified [19] print_uint_at::at#1 = print_ulong_at::at#0 + 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant print_uint_at::at#1 = print_ulong_at::at#0+4
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings print_uint_at::at#0
Inlining constant with var siblings print_uint_at::at#1
Constant inlined print_ulong_at::at#0 = SCREEN
Constant inlined print_uint_at::at#1 = SCREEN+4
Constant inlined print_uint_at::at#0 = SCREEN
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) $10
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of print_ulong_at::@2
Adding NOP phi() at start of print_uint_at::@2
Adding NOP phi() at start of print_uchar_at::@2
CALL GRAPH
Calls in [main] to clock_start:3 clock:5 print_ulong_at:10 
Calls in [print_ulong_at] to print_uint_at:22 print_uint_at:25 
Calls in [print_uint_at] to print_uchar_at:33 print_uchar_at:38 
Calls in [print_uchar_at] to print_char_at:47 print_char_at:53 

Created 6 initial phi equivalence classes
Coalesced [21] print_uint_at::w#4 = print_uint_at::w#0
Coalesced [24] print_uint_at::w#5 = print_uint_at::w#1
Coalesced [31] print_uchar_at::b#4 = print_uchar_at::b#0
Coalesced [32] print_uchar_at::at#4 = print_uchar_at::at#0
Coalesced [36] print_uchar_at::b#5 = print_uchar_at::b#1
Coalesced [37] print_uchar_at::at#5 = print_uchar_at::at#1
Coalesced [45] print_char_at::ch#3 = print_char_at::ch#0
Coalesced [46] print_char_at::at#3 = print_char_at::at#0
Coalesced [51] print_char_at::ch#4 = print_char_at::ch#1
Coalesced [52] print_char_at::at#4 = print_char_at::at#1
Coalesced down to 6 phi equivalence classes
Culled Empty Block label main::@1
Culled Empty Block label main::@5
Culled Empty Block label print_ulong_at::@2
Culled Empty Block label print_uint_at::@2
Culled Empty Block label print_uchar_at::@2
Renumbering block main::@2 to main::@1
Renumbering block main::@3 to main::@2
Renumbering block main::@4 to main::@3
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@3
  [1] phi()
  [2] call clock_start 
  to:main::@2
main::@2: scope:[main]  from main::@1
  asm { nop  }
  [4] call clock 
  [5] clock::return#2 = clock::return#0
  to:main::@3
main::@3: scope:[main]  from main::@2
  [6] main::$1 = clock::return#2
  [7] main::cyclecount#0 = main::$1 - CLOCKS_PER_INIT
  [8] print_ulong_at::dw#0 = main::cyclecount#0
  [9] call print_ulong_at 
  to:main::@1

void clock_start()
clock_start: scope:[clock_start]  from main::@1
  [10] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = 0
  [11] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  [12] *CIA2_TIMER_AB = $ffffffff
  [13] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
  [14] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_START
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  [15] return 
  to:@return

dword clock()
clock: scope:[clock]  from main::@2
  [16] clock::return#0 = $ffffffff - *CIA2_TIMER_AB
  to:clock::@return
clock::@return: scope:[clock]  from clock
  [17] return 
  to:@return

void print_ulong_at(dword print_ulong_at::dw , byte* print_ulong_at::at)
print_ulong_at: scope:[print_ulong_at]  from main::@3
  [18] print_uint_at::w#0 = > print_ulong_at::dw#0
  [19] call print_uint_at 
  to:print_ulong_at::@1
print_ulong_at::@1: scope:[print_ulong_at]  from print_ulong_at
  [20] print_uint_at::w#1 = < print_ulong_at::dw#0
  [21] call print_uint_at 
  to:print_ulong_at::@return
print_ulong_at::@return: scope:[print_ulong_at]  from print_ulong_at::@1
  [22] return 
  to:@return

void print_uint_at(word print_uint_at::w , byte* print_uint_at::at)
print_uint_at: scope:[print_uint_at]  from print_ulong_at print_ulong_at::@1
  [23] print_uint_at::at#2 = phi( print_ulong_at/SCREEN, print_ulong_at::@1/SCREEN+4 )
  [23] print_uint_at::w#2 = phi( print_ulong_at/print_uint_at::w#0, print_ulong_at::@1/print_uint_at::w#1 )
  [24] print_uchar_at::b#0 = > print_uint_at::w#2
  [25] print_uchar_at::at#0 = print_uint_at::at#2
  [26] call print_uchar_at 
  to:print_uint_at::@1
print_uint_at::@1: scope:[print_uint_at]  from print_uint_at
  [27] print_uchar_at::b#1 = < print_uint_at::w#2
  [28] print_uchar_at::at#1 = print_uint_at::at#2 + 2
  [29] call print_uchar_at 
  to:print_uint_at::@return
print_uint_at::@return: scope:[print_uint_at]  from print_uint_at::@1
  [30] return 
  to:@return

void print_uchar_at(byte print_uchar_at::b , byte* print_uchar_at::at)
print_uchar_at: scope:[print_uchar_at]  from print_uint_at print_uint_at::@1
  [31] print_uchar_at::at#2 = phi( print_uint_at/print_uchar_at::at#0, print_uint_at::@1/print_uchar_at::at#1 )
  [31] print_uchar_at::b#2 = phi( print_uint_at/print_uchar_at::b#0, print_uint_at::@1/print_uchar_at::b#1 )
  [32] print_uchar_at::$0 = print_uchar_at::b#2 >> 4
  [33] print_char_at::ch#0 = print_hextab[print_uchar_at::$0]
  [34] print_char_at::at#0 = print_uchar_at::at#2
  [35] call print_char_at 
  to:print_uchar_at::@1
print_uchar_at::@1: scope:[print_uchar_at]  from print_uchar_at
  [36] print_uchar_at::$2 = print_uchar_at::b#2 & $f
  [37] print_char_at::at#1 = print_uchar_at::at#2 + 1
  [38] print_char_at::ch#1 = print_hextab[print_uchar_at::$2]
  [39] call print_char_at 
  to:print_uchar_at::@return
print_uchar_at::@return: scope:[print_uchar_at]  from print_uchar_at::@1
  [40] return 
  to:@return

void print_char_at(byte print_char_at::ch , byte* print_char_at::at)
print_char_at: scope:[print_char_at]  from print_uchar_at print_uchar_at::@1
  [41] print_char_at::at#2 = phi( print_uchar_at/print_char_at::at#0, print_uchar_at::@1/print_char_at::at#1 )
  [41] print_char_at::ch#2 = phi( print_uchar_at/print_char_at::ch#0, print_uchar_at::@1/print_char_at::ch#1 )
  [42] *print_char_at::at#2 = print_char_at::ch#2
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  [43] return 
  to:@return


VARIABLE REGISTER WEIGHTS
dword clock()
dword clock::return
dword clock::return#0 37.33333333333333
dword clock::return#2 22.0
void clock_start()
void main()
dword~ main::$1 22.0
dword main::cyclecount
dword main::cyclecount#0 22.0
void print_char_at(byte print_char_at::ch , byte* print_char_at::at)
byte* print_char_at::at
byte* print_char_at::at#0 20002.0
byte* print_char_at::at#1 10001.0
byte* print_char_at::at#2 120003.0
byte print_char_at::ch
byte print_char_at::ch#0 10001.0
byte print_char_at::ch#1 20002.0
byte print_char_at::ch#2 120003.0
void print_uchar_at(byte print_uchar_at::b , byte* print_uchar_at::at)
byte~ print_uchar_at::$0 20002.0
byte~ print_uchar_at::$2 10001.0
byte* print_uchar_at::at
byte* print_uchar_at::at#0 2002.0
byte* print_uchar_at::at#1 2002.0
byte* print_uchar_at::at#2 3667.333333333333
byte print_uchar_at::b
byte print_uchar_at::b#0 1001.0
byte print_uchar_at::b#1 1001.0
byte print_uchar_at::b#2 4400.8
void print_uint_at(word print_uint_at::w , byte* print_uint_at::at)
byte* print_uint_at::at
byte* print_uint_at::at#2 400.4
word print_uint_at::w
word print_uint_at::w#0 202.0
word print_uint_at::w#1 202.0
word print_uint_at::w#2 551.0
void print_ulong_at(dword print_ulong_at::dw , byte* print_ulong_at::at)
byte* print_ulong_at::at
dword print_ulong_at::dw
dword print_ulong_at::dw#0 71.0

Initial phi equivalence classes
[ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ]
[ print_uint_at::at#2 ]
[ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
[ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ]
[ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
[ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
Added variable clock::return#2 to live range equivalence class [ clock::return#2 ]
Added variable main::$1 to live range equivalence class [ main::$1 ]
Added variable main::cyclecount#0 to live range equivalence class [ main::cyclecount#0 ]
Added variable print_ulong_at::dw#0 to live range equivalence class [ print_ulong_at::dw#0 ]
Added variable clock::return#0 to live range equivalence class [ clock::return#0 ]
Added variable print_uchar_at::$0 to live range equivalence class [ print_uchar_at::$0 ]
Added variable print_uchar_at::$2 to live range equivalence class [ print_uchar_at::$2 ]
Complete equivalence classes
[ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ]
[ print_uint_at::at#2 ]
[ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
[ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ]
[ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
[ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
[ clock::return#2 ]
[ main::$1 ]
[ main::cyclecount#0 ]
[ print_ulong_at::dw#0 ]
[ clock::return#0 ]
[ print_uchar_at::$0 ]
[ print_uchar_at::$2 ]
Allocated zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ]
Allocated zp[2]:4 [ print_uint_at::at#2 ]
Allocated zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
Allocated zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ]
Allocated zp[1]:9 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
Allocated zp[2]:10 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
Allocated zp[4]:12 [ clock::return#2 ]
Allocated zp[4]:16 [ main::$1 ]
Allocated zp[4]:20 [ main::cyclecount#0 ]
Allocated zp[4]:24 [ print_ulong_at::dw#0 ]
Allocated zp[4]:28 [ clock::return#0 ]
Allocated zp[1]:32 [ print_uchar_at::$0 ]
Allocated zp[1]:33 [ print_uchar_at::$2 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [5] clock::return#2 = clock::return#0 [ clock::return#2 ] (  [ clock::return#2 ] { { clock::return#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [6] main::$1 = clock::return#2 [ main::$1 ] (  [ main::$1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } }  ) always clobbers reg byte a 
Statement [7] main::cyclecount#0 = main::$1 - CLOCKS_PER_INIT [ main::cyclecount#0 ] (  [ main::cyclecount#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } }  ) always clobbers reg byte a 
Statement [8] print_ulong_at::dw#0 = main::cyclecount#0 [ print_ulong_at::dw#0 ] (  [ print_ulong_at::dw#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } }  ) always clobbers reg byte a 
Statement [10] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = 0 [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [11] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [12] *CIA2_TIMER_AB = $ffffffff [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [13] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [14] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_START [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [16] clock::return#0 = $ffffffff - *CIA2_TIMER_AB [ clock::return#0 ] ( clock:4 [ clock::return#0 ] { { clock::return#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [18] print_uint_at::w#0 = > print_ulong_at::dw#0 [ print_ulong_at::dw#0 print_uint_at::w#0 ] ( print_ulong_at:9 [ print_ulong_at::dw#0 print_uint_at::w#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } }  ) always clobbers reg byte a 
Statement [20] print_uint_at::w#1 = < print_ulong_at::dw#0 [ print_uint_at::w#1 ] ( print_ulong_at:9 [ print_uint_at::w#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } }  ) always clobbers reg byte a 
Statement [25] print_uchar_at::at#0 = print_uint_at::at#2 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] ( print_ulong_at:9::print_uint_at:19 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:21 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
Statement [28] print_uchar_at::at#1 = print_uint_at::at#2 + 2 [ print_uchar_at::b#1 print_uchar_at::at#1 ] ( print_ulong_at:9::print_uint_at:19 [ print_ulong_at::dw#0 print_uchar_at::b#1 print_uchar_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } }  print_ulong_at:9::print_uint_at:21 [ print_uchar_at::b#1 print_uchar_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } }  ) always clobbers reg byte a 
Statement [32] print_uchar_at::$0 = print_uchar_at::b#2 >> 4 [ print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29 [ print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  ) always clobbers reg byte a 
Statement [34] print_char_at::at#0 = print_uchar_at::at#2 [ print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29 [ print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:9 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
Statement [36] print_uchar_at::$2 = print_uchar_at::b#2 & $f [ print_uchar_at::at#2 print_uchar_at::$2 ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29 [ print_ulong_at::dw#0 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29 [ print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a 
Statement [37] print_char_at::at#1 = print_uchar_at::at#2 + 1 [ print_uchar_at::$2 print_char_at::at#1 ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29 [ print_ulong_at::dw#0 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29 [ print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:33 [ print_uchar_at::$2 ]
Statement [42] *print_char_at::at#2 = print_char_at::ch#2 [ ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26::print_char_at:35 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26::print_char_at:35 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29::print_char_at:35 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29::print_char_at:35 [ print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:26::print_char_at:39 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26::print_char_at:39 [ print_uint_at::w#2 print_uint_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29::print_char_at:39 [ print_ulong_at::dw#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29::print_char_at:39 [ ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
Statement [5] clock::return#2 = clock::return#0 [ clock::return#2 ] (  [ clock::return#2 ] { { clock::return#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [6] main::$1 = clock::return#2 [ main::$1 ] (  [ main::$1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } }  ) always clobbers reg byte a 
Statement [7] main::cyclecount#0 = main::$1 - CLOCKS_PER_INIT [ main::cyclecount#0 ] (  [ main::cyclecount#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } }  ) always clobbers reg byte a 
Statement [8] print_ulong_at::dw#0 = main::cyclecount#0 [ print_ulong_at::dw#0 ] (  [ print_ulong_at::dw#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } }  ) always clobbers reg byte a 
Statement [10] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = 0 [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [11] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [12] *CIA2_TIMER_AB = $ffffffff [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [13] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [14] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_START [ ] ( clock_start:2 [ ] { }  ) always clobbers reg byte a 
Statement [16] clock::return#0 = $ffffffff - *CIA2_TIMER_AB [ clock::return#0 ] ( clock:4 [ clock::return#0 ] { { clock::return#0 = clock::return#2 } }  ) always clobbers reg byte a 
Statement [18] print_uint_at::w#0 = > print_ulong_at::dw#0 [ print_ulong_at::dw#0 print_uint_at::w#0 ] ( print_ulong_at:9 [ print_ulong_at::dw#0 print_uint_at::w#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } }  ) always clobbers reg byte a 
Statement [20] print_uint_at::w#1 = < print_ulong_at::dw#0 [ print_uint_at::w#1 ] ( print_ulong_at:9 [ print_uint_at::w#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } }  ) always clobbers reg byte a 
Statement [25] print_uchar_at::at#0 = print_uint_at::at#2 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] ( print_ulong_at:9::print_uint_at:19 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:21 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#0 print_uchar_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } }  ) always clobbers reg byte a 
Statement [28] print_uchar_at::at#1 = print_uint_at::at#2 + 2 [ print_uchar_at::b#1 print_uchar_at::at#1 ] ( print_ulong_at:9::print_uint_at:19 [ print_ulong_at::dw#0 print_uchar_at::b#1 print_uchar_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } }  print_ulong_at:9::print_uint_at:21 [ print_uchar_at::b#1 print_uchar_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } }  ) always clobbers reg byte a 
Statement [32] print_uchar_at::$0 = print_uchar_at::b#2 >> 4 [ print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29 [ print_uchar_at::b#2 print_uchar_at::at#2 print_uchar_at::$0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  ) always clobbers reg byte a 
Statement [34] print_char_at::at#0 = print_uchar_at::at#2 [ print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29 [ print_uchar_at::b#2 print_uchar_at::at#2 print_char_at::ch#0 print_char_at::at#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  ) always clobbers reg byte a 
Statement [36] print_uchar_at::$2 = print_uchar_at::b#2 & $f [ print_uchar_at::at#2 print_uchar_at::$2 ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29 [ print_ulong_at::dw#0 print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29 [ print_uchar_at::at#2 print_uchar_at::$2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a 
Statement [37] print_char_at::at#1 = print_uchar_at::at#2 + 1 [ print_uchar_at::$2 print_char_at::at#1 ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29 [ print_ulong_at::dw#0 print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29 [ print_uchar_at::$2 print_char_at::at#1 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a 
Statement [42] *print_char_at::at#2 = print_char_at::ch#2 [ ] ( print_ulong_at:9::print_uint_at:19::print_uchar_at:26::print_char_at:35 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26::print_char_at:35 [ print_uint_at::w#2 print_uint_at::at#2 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uint_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29::print_char_at:35 [ print_ulong_at::dw#0 print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29::print_char_at:35 [ print_uchar_at::b#2 print_uchar_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_char_at::ch#0 = print_char_at::ch#2 } { print_char_at::at#0 = print_char_at::at#2 print_uchar_at::at#2 print_uchar_at::at#1 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:26::print_char_at:39 [ print_ulong_at::dw#0 print_uint_at::w#2 print_uint_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:26::print_char_at:39 [ print_uint_at::w#2 print_uint_at::at#2 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#0 = print_uchar_at::b#2 } { print_uchar_at::at#0 = print_uchar_at::at#2 print_uint_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:19::print_uchar_at:29::print_char_at:39 [ print_ulong_at::dw#0 ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#0 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  print_ulong_at:9::print_uint_at:21::print_uchar_at:29::print_char_at:39 [ ] { { print_ulong_at::dw#0 = main::cyclecount#0 } { print_uint_at::w#1 = print_uint_at::w#2 } { print_uchar_at::b#1 = print_uchar_at::b#2 } { print_uchar_at::at#1 = print_uchar_at::at#2 } { print_char_at::ch#1 = print_char_at::ch#2 } { print_char_at::at#1 = print_char_at::at#2 } }  ) always clobbers reg byte a reg byte y 
Potential registers zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ] : zp[2]:2 , 
Potential registers zp[2]:4 [ print_uint_at::at#2 ] : zp[2]:4 , 
Potential registers zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ] : zp[1]:6 , reg byte x , 
Potential registers zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ] : zp[2]:7 , 
Potential registers zp[1]:9 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[2]:10 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] : zp[2]:10 , 
Potential registers zp[4]:12 [ clock::return#2 ] : zp[4]:12 , 
Potential registers zp[4]:16 [ main::$1 ] : zp[4]:16 , 
Potential registers zp[4]:20 [ main::cyclecount#0 ] : zp[4]:20 , 
Potential registers zp[4]:24 [ print_ulong_at::dw#0 ] : zp[4]:24 , 
Potential registers zp[4]:28 [ clock::return#0 ] : zp[4]:28 , 
Potential registers zp[1]:32 [ print_uchar_at::$0 ] : zp[1]:32 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:33 [ print_uchar_at::$2 ] : zp[1]:33 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [print_char_at] 150,006: zp[1]:9 [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ] 150,006: zp[2]:10 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] 
Uplift Scope [print_uchar_at] 20,002: zp[1]:32 [ print_uchar_at::$0 ] 10,001: zp[1]:33 [ print_uchar_at::$2 ] 7,671.33: zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ] 6,402.8: zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ] 
Uplift Scope [print_uint_at] 955: zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ] 400.4: zp[2]:4 [ print_uint_at::at#2 ] 
Uplift Scope [print_ulong_at] 71: zp[4]:24 [ print_ulong_at::dw#0 ] 
Uplift Scope [clock] 37.33: zp[4]:28 [ clock::return#0 ] 22: zp[4]:12 [ clock::return#2 ] 
Uplift Scope [main] 22: zp[4]:16 [ main::$1 ] 22: zp[4]:20 [ main::cyclecount#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [clock_start] 
Uplift Scope [RADIX] 
Uplift Scope [] 

Uplifting [print_char_at] best 1727 combination reg byte x [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ] zp[2]:10 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ] 
Uplifting [print_uchar_at] best 1719 combination reg byte a [ print_uchar_at::$0 ] reg byte y [ print_uchar_at::$2 ] zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ] zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ] 
Uplifting [print_uint_at] best 1719 combination zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ] zp[2]:4 [ print_uint_at::at#2 ] 
Uplifting [print_ulong_at] best 1719 combination zp[4]:24 [ print_ulong_at::dw#0 ] 
Uplifting [clock] best 1719 combination zp[4]:28 [ clock::return#0 ] zp[4]:12 [ clock::return#2 ] 
Uplifting [main] best 1719 combination zp[4]:16 [ main::$1 ] zp[4]:20 [ main::cyclecount#0 ] 
Uplifting [MOS6526_CIA] best 1719 combination 
Uplifting [MOS6569_VICII] best 1719 combination 
Uplifting [MOS6581_SID] best 1719 combination 
Uplifting [clock_start] best 1719 combination 
Uplifting [RADIX] best 1719 combination 
Uplifting [] best 1719 combination 
Attempting to uplift remaining variables inzp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
Uplifting [print_uchar_at] best 1719 combination zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ] 
Coalescing zero page register [ zp[2]:4 [ print_uint_at::at#2 ] ] with [ zp[2]:7 [ print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ] ] - score: 2
Coalescing zero page register [ zp[4]:12 [ clock::return#2 ] ] with [ zp[4]:16 [ main::$1 ] ] - score: 1
Coalescing zero page register [ zp[4]:12 [ clock::return#2 main::$1 ] ] with [ zp[4]:28 [ clock::return#0 ] ] - score: 1
Coalescing zero page register [ zp[4]:20 [ main::cyclecount#0 ] ] with [ zp[4]:24 [ print_ulong_at::dw#0 ] ] - score: 1
Coalescing zero page register [ zp[4]:12 [ clock::return#2 main::$1 clock::return#0 ] ] with [ zp[4]:20 [ main::cyclecount#0 print_ulong_at::dw#0 ] ] - score: 1
Allocated (was zp[2]:10) zp[2]:7 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
Allocated (was zp[4]:12) zp[4]:9 [ clock::return#2 main::$1 clock::return#0 main::cyclecount#0 print_ulong_at::dw#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Counting cycles using a CIA timer
  // Upstart
  // Commodore 64 PRG executable file
.file [name="cia-timer-cyclecount.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#2 timer A&B as one single 32-bit value
  .label CIA2_TIMER_AB = $dd04
  .label SCREEN = $400
.segment Code
  // main
main: {
    .label __1 = 9
    .label cyclecount = 9
    // [1] phi from main main::@3 to main::@1 [phi:main/main::@3->main::@1]
  __b1_from_main:
  __b1_from___b3:
    jmp __b1
    // main::@1
  __b1:
    // [2] call clock_start 
    // Reset & start the CIA#2 timer A+B
    jsr clock_start
    jmp __b2
    // main::@2
  __b2:
    // asm { nop  }
    nop
    // [4] call clock 
    jsr clock
    // [5] clock::return#2 = clock::return#0
    jmp __b3
    // main::@3
  __b3:
    // [6] main::$1 = clock::return#2
    // [7] main::cyclecount#0 = main::$1 - CLOCKS_PER_INIT -- vduz1=vduz1_minus_vduc1 
    lda.z cyclecount
    sec
    sbc #<CLOCKS_PER_INIT
    sta.z cyclecount
    lda.z cyclecount+1
    sbc #>CLOCKS_PER_INIT
    sta.z cyclecount+1
    lda.z cyclecount+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta.z cyclecount+2
    lda.z cyclecount+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta.z cyclecount+3
    // [8] print_ulong_at::dw#0 = main::cyclecount#0
    // [9] call print_ulong_at 
    // Print cycle count
    jsr print_ulong_at
    jmp __b1_from___b3
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [10] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = 0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #0
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // [11] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [12] *CIA2_TIMER_AB = $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [13] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // [14] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    jmp __breturn
    // clock_start::@return
  __breturn:
    // [15] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = 9
    // [16] clock::return#0 = $ffffffff - *CIA2_TIMER_AB -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta.z return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta.z return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta.z return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta.z return+3
    jmp __breturn
    // clock::@return
  __breturn:
    // [17] return 
    rts
}
  // print_ulong_at
// Print a unsigned long as HEX at a specific position
// print_ulong_at(dword zp(9) dw)
print_ulong_at: {
    .label dw = 9
    // [18] print_uint_at::w#0 = > print_ulong_at::dw#0 -- vwuz1=_hi_vduz2 
    lda.z dw+2
    sta.z print_uint_at.w
    lda.z dw+3
    sta.z print_uint_at.w+1
    // [19] call print_uint_at 
    // [23] phi from print_ulong_at to print_uint_at [phi:print_ulong_at->print_uint_at]
  print_uint_at_from_print_ulong_at:
    // [23] phi print_uint_at::at#2 = SCREEN [phi:print_ulong_at->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z print_uint_at.at
    lda #>SCREEN
    sta.z print_uint_at.at+1
    // [23] phi print_uint_at::w#2 = print_uint_at::w#0 [phi:print_ulong_at->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    jmp __b1
    // print_ulong_at::@1
  __b1:
    // [20] print_uint_at::w#1 = < print_ulong_at::dw#0 -- vwuz1=_lo_vduz2 
    lda.z dw
    sta.z print_uint_at.w
    lda.z dw+1
    sta.z print_uint_at.w+1
    // [21] call print_uint_at 
    // [23] phi from print_ulong_at::@1 to print_uint_at [phi:print_ulong_at::@1->print_uint_at]
  print_uint_at_from___b1:
    // [23] phi print_uint_at::at#2 = SCREEN+4 [phi:print_ulong_at::@1->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN+4
    sta.z print_uint_at.at
    lda #>SCREEN+4
    sta.z print_uint_at.at+1
    // [23] phi print_uint_at::w#2 = print_uint_at::w#1 [phi:print_ulong_at::@1->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    jmp __breturn
    // print_ulong_at::@return
  __breturn:
    // [22] return 
    rts
}
  // print_uint_at
// Print a unsigned int as HEX at a specific position
// print_uint_at(word zp(2) w, byte* zp(4) at)
print_uint_at: {
    .label w = 2
    .label at = 4
    // [24] print_uchar_at::b#0 = > print_uint_at::w#2 -- vbuz1=_hi_vwuz2 
    lda.z w+1
    sta.z print_uchar_at.b
    // [25] print_uchar_at::at#0 = print_uint_at::at#2
    // [26] call print_uchar_at 
    // [31] phi from print_uint_at to print_uchar_at [phi:print_uint_at->print_uchar_at]
  print_uchar_at_from_print_uint_at:
    // [31] phi print_uchar_at::at#2 = print_uchar_at::at#0 [phi:print_uint_at->print_uchar_at#0] -- register_copy 
    // [31] phi print_uchar_at::b#2 = print_uchar_at::b#0 [phi:print_uint_at->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    jmp __b1
    // print_uint_at::@1
  __b1:
    // [27] print_uchar_at::b#1 = < print_uint_at::w#2 -- vbuz1=_lo_vwuz2 
    lda.z w
    sta.z print_uchar_at.b
    // [28] print_uchar_at::at#1 = print_uint_at::at#2 + 2 -- pbuz1=pbuz1_plus_vbuc1 
    lda #2
    clc
    adc.z print_uchar_at.at
    sta.z print_uchar_at.at
    bcc !+
    inc.z print_uchar_at.at+1
  !:
    // [29] call print_uchar_at 
    // [31] phi from print_uint_at::@1 to print_uchar_at [phi:print_uint_at::@1->print_uchar_at]
  print_uchar_at_from___b1:
    // [31] phi print_uchar_at::at#2 = print_uchar_at::at#1 [phi:print_uint_at::@1->print_uchar_at#0] -- register_copy 
    // [31] phi print_uchar_at::b#2 = print_uchar_at::b#1 [phi:print_uint_at::@1->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    jmp __breturn
    // print_uint_at::@return
  __breturn:
    // [30] return 
    rts
}
  // print_uchar_at
// Print a char as HEX at a specific position
// print_uchar_at(byte zp(6) b, byte* zp(4) at)
print_uchar_at: {
    .label b = 6
    .label at = 4
    // [32] print_uchar_at::$0 = print_uchar_at::b#2 >> 4 -- vbuaa=vbuz1_ror_4 
    lda.z b
    lsr
    lsr
    lsr
    lsr
    // [33] print_char_at::ch#0 = print_hextab[print_uchar_at::$0] -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx print_hextab,y
    // [34] print_char_at::at#0 = print_uchar_at::at#2 -- pbuz1=pbuz2 
    lda.z at
    sta.z print_char_at.at
    lda.z at+1
    sta.z print_char_at.at+1
    // [35] call print_char_at 
  // Table of hexadecimal digits
    // [41] phi from print_uchar_at to print_char_at [phi:print_uchar_at->print_char_at]
  print_char_at_from_print_uchar_at:
    // [41] phi print_char_at::at#2 = print_char_at::at#0 [phi:print_uchar_at->print_char_at#0] -- register_copy 
    // [41] phi print_char_at::ch#2 = print_char_at::ch#0 [phi:print_uchar_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp __b1
    // print_uchar_at::@1
  __b1:
    // [36] print_uchar_at::$2 = print_uchar_at::b#2 & $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and.z b
    tay
    // [37] print_char_at::at#1 = print_uchar_at::at#2 + 1 -- pbuz1=pbuz2_plus_1 
    clc
    lda.z at
    adc #1
    sta.z print_char_at.at
    lda.z at+1
    adc #0
    sta.z print_char_at.at+1
    // [38] print_char_at::ch#1 = print_hextab[print_uchar_at::$2] -- vbuxx=pbuc1_derefidx_vbuyy 
    ldx print_hextab,y
    // [39] call print_char_at 
    // [41] phi from print_uchar_at::@1 to print_char_at [phi:print_uchar_at::@1->print_char_at]
  print_char_at_from___b1:
    // [41] phi print_char_at::at#2 = print_char_at::at#1 [phi:print_uchar_at::@1->print_char_at#0] -- register_copy 
    // [41] phi print_char_at::ch#2 = print_char_at::ch#1 [phi:print_uchar_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp __breturn
    // print_uchar_at::@return
  __breturn:
    // [40] return 
    rts
}
  // print_char_at
// Print a single char
// print_char_at(byte register(X) ch, byte* zp(7) at)
print_char_at: {
    .label at = 7
    // [42] *print_char_at::at#2 = print_char_at::ch#2 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (at),y
    jmp __breturn
    // print_char_at::@return
  __breturn:
    // [43] return 
    rts
}
  // File Data
.segment Data
  print_hextab: .text "0123456789abcdef"

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b3 with __b1
Removing instruction __b1_from_main:
Removing instruction __b1_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction print_uint_at_from_print_ulong_at:
Removing instruction __b1:
Removing instruction print_uint_at_from___b1:
Removing instruction __breturn:
Removing instruction print_uchar_at_from_print_uint_at:
Removing instruction __b1:
Removing instruction print_uchar_at_from___b1:
Removing instruction __breturn:
Removing instruction print_char_at_from_print_uchar_at:
Removing instruction __b1:
Removing instruction print_char_at_from___b1:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
constant struct MOS6526_CIA* const CIA2 = (struct MOS6526_CIA*) 56576
constant dword* const CIA2_TIMER_AB = (dword*) 56580
constant const byte CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
constant const byte CIA_TIMER_CONTROL_START = 1
constant const dword CLOCKS_PER_INIT = $12
constant byte OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
constant byte OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
constant byte RADIX::BINARY = 2
constant byte RADIX::DECIMAL = $a
constant byte RADIX::HEXADECIMAL = $10
constant byte RADIX::OCTAL = 8
constant byte* const SCREEN = (byte*) 1024
dword clock()
dword clock::return
dword clock::return#0 return zp[4]:9 37.33333333333333
dword clock::return#2 return zp[4]:9 22.0
void clock_start()
void main()
dword~ main::$1 zp[4]:9 22.0
dword main::cyclecount
dword main::cyclecount#0 cyclecount zp[4]:9 22.0
void print_char_at(byte print_char_at::ch , byte* print_char_at::at)
byte* print_char_at::at
byte* print_char_at::at#0 at zp[2]:7 20002.0
byte* print_char_at::at#1 at zp[2]:7 10001.0
byte* print_char_at::at#2 at zp[2]:7 120003.0
byte print_char_at::ch
byte print_char_at::ch#0 reg byte x 10001.0
byte print_char_at::ch#1 reg byte x 20002.0
byte print_char_at::ch#2 reg byte x 120003.0
constant const byte* print_hextab[]  = "0123456789abcdef"z
void print_uchar_at(byte print_uchar_at::b , byte* print_uchar_at::at)
byte~ print_uchar_at::$0 reg byte a 20002.0
byte~ print_uchar_at::$2 reg byte y 10001.0
byte* print_uchar_at::at
byte* print_uchar_at::at#0 at zp[2]:4 2002.0
byte* print_uchar_at::at#1 at zp[2]:4 2002.0
byte* print_uchar_at::at#2 at zp[2]:4 3667.333333333333
byte print_uchar_at::b
byte print_uchar_at::b#0 b zp[1]:6 1001.0
byte print_uchar_at::b#1 b zp[1]:6 1001.0
byte print_uchar_at::b#2 b zp[1]:6 4400.8
void print_uint_at(word print_uint_at::w , byte* print_uint_at::at)
byte* print_uint_at::at
byte* print_uint_at::at#2 at zp[2]:4 400.4
word print_uint_at::w
word print_uint_at::w#0 w zp[2]:2 202.0
word print_uint_at::w#1 w zp[2]:2 202.0
word print_uint_at::w#2 w zp[2]:2 551.0
void print_ulong_at(dword print_ulong_at::dw , byte* print_ulong_at::at)
byte* print_ulong_at::at
dword print_ulong_at::dw
dword print_ulong_at::dw#0 dw zp[4]:9 71.0

zp[2]:2 [ print_uint_at::w#2 print_uint_at::w#0 print_uint_at::w#1 ]
zp[2]:4 [ print_uint_at::at#2 print_uchar_at::at#2 print_uchar_at::at#0 print_uchar_at::at#1 ]
zp[1]:6 [ print_uchar_at::b#2 print_uchar_at::b#0 print_uchar_at::b#1 ]
reg byte x [ print_char_at::ch#2 print_char_at::ch#0 print_char_at::ch#1 ]
zp[2]:7 [ print_char_at::at#2 print_char_at::at#0 print_char_at::at#1 ]
zp[4]:9 [ clock::return#2 main::$1 clock::return#0 main::cyclecount#0 print_ulong_at::dw#0 ]
reg byte a [ print_uchar_at::$0 ]
reg byte y [ print_uchar_at::$2 ]


FINAL ASSEMBLER
Score: 869

  // File Comments
// Counting cycles using a CIA timer
  // Upstart
  // Commodore 64 PRG executable file
.file [name="cia-timer-cyclecount.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL = $e
  .const OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL = $f
  // The CIA#2: Serial bus, RS-232, VIC memory bank
  .label CIA2 = $dd00
  // CIA#2 timer A&B as one single 32-bit value
  .label CIA2_TIMER_AB = $dd04
  .label SCREEN = $400
.segment Code
  // main
main: {
    .label __1 = 9
    .label cyclecount = 9
    // [1] phi from main main::@3 to main::@1 [phi:main/main::@3->main::@1]
    // main::@1
  __b1:
    // clock_start()
    // [2] call clock_start 
    // Reset & start the CIA#2 timer A+B
    jsr clock_start
    // main::@2
    // asm
    // asm { nop  }
    nop
    // clock()
    // [4] call clock 
    jsr clock
    // [5] clock::return#2 = clock::return#0
    // main::@3
    // [6] main::$1 = clock::return#2
    // dword cyclecount = clock()-CLOCKS_PER_INIT
    // [7] main::cyclecount#0 = main::$1 - CLOCKS_PER_INIT -- vduz1=vduz1_minus_vduc1 
    lda.z cyclecount
    sec
    sbc #<CLOCKS_PER_INIT
    sta.z cyclecount
    lda.z cyclecount+1
    sbc #>CLOCKS_PER_INIT
    sta.z cyclecount+1
    lda.z cyclecount+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta.z cyclecount+2
    lda.z cyclecount+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta.z cyclecount+3
    // print_ulong_at(cyclecount, SCREEN)
    // [8] print_ulong_at::dw#0 = main::cyclecount#0
    // [9] call print_ulong_at 
    // Print cycle count
    jsr print_ulong_at
    jmp __b1
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // CIA2->TIMER_A_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [10] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = 0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #0
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // CIA2->TIMER_B_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [11] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // *CIA2_TIMER_AB = 0xffffffff
    // [12] *CIA2_TIMER_AB = $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // CIA2->TIMER_B_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [13] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL) = CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_B_CONTROL
    // CIA2->TIMER_A_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [14] *((byte*)CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL) = CIA_TIMER_CONTROL_START -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2+OFFSET_STRUCT_MOS6526_CIA_TIMER_A_CONTROL
    // clock_start::@return
    // }
    // [15] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = 9
    // 0xffffffff - *CIA2_TIMER_AB
    // [16] clock::return#0 = $ffffffff - *CIA2_TIMER_AB -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta.z return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta.z return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta.z return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta.z return+3
    // clock::@return
    // }
    // [17] return 
    rts
}
  // print_ulong_at
// Print a unsigned long as HEX at a specific position
// print_ulong_at(dword zp(9) dw)
print_ulong_at: {
    .label dw = 9
    // print_uint_at(>dw, at)
    // [18] print_uint_at::w#0 = > print_ulong_at::dw#0 -- vwuz1=_hi_vduz2 
    lda.z dw+2
    sta.z print_uint_at.w
    lda.z dw+3
    sta.z print_uint_at.w+1
    // [19] call print_uint_at 
    // [23] phi from print_ulong_at to print_uint_at [phi:print_ulong_at->print_uint_at]
    // [23] phi print_uint_at::at#2 = SCREEN [phi:print_ulong_at->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z print_uint_at.at
    lda #>SCREEN
    sta.z print_uint_at.at+1
    // [23] phi print_uint_at::w#2 = print_uint_at::w#0 [phi:print_ulong_at->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    // print_ulong_at::@1
    // print_uint_at(<dw, at+4)
    // [20] print_uint_at::w#1 = < print_ulong_at::dw#0 -- vwuz1=_lo_vduz2 
    lda.z dw
    sta.z print_uint_at.w
    lda.z dw+1
    sta.z print_uint_at.w+1
    // [21] call print_uint_at 
    // [23] phi from print_ulong_at::@1 to print_uint_at [phi:print_ulong_at::@1->print_uint_at]
    // [23] phi print_uint_at::at#2 = SCREEN+4 [phi:print_ulong_at::@1->print_uint_at#0] -- pbuz1=pbuc1 
    lda #<SCREEN+4
    sta.z print_uint_at.at
    lda #>SCREEN+4
    sta.z print_uint_at.at+1
    // [23] phi print_uint_at::w#2 = print_uint_at::w#1 [phi:print_ulong_at::@1->print_uint_at#1] -- register_copy 
    jsr print_uint_at
    // print_ulong_at::@return
    // }
    // [22] return 
    rts
}
  // print_uint_at
// Print a unsigned int as HEX at a specific position
// print_uint_at(word zp(2) w, byte* zp(4) at)
print_uint_at: {
    .label w = 2
    .label at = 4
    // print_uchar_at(>w, at)
    // [24] print_uchar_at::b#0 = > print_uint_at::w#2 -- vbuz1=_hi_vwuz2 
    lda.z w+1
    sta.z print_uchar_at.b
    // [25] print_uchar_at::at#0 = print_uint_at::at#2
    // [26] call print_uchar_at 
    // [31] phi from print_uint_at to print_uchar_at [phi:print_uint_at->print_uchar_at]
    // [31] phi print_uchar_at::at#2 = print_uchar_at::at#0 [phi:print_uint_at->print_uchar_at#0] -- register_copy 
    // [31] phi print_uchar_at::b#2 = print_uchar_at::b#0 [phi:print_uint_at->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    // print_uint_at::@1
    // print_uchar_at(<w, at+2)
    // [27] print_uchar_at::b#1 = < print_uint_at::w#2 -- vbuz1=_lo_vwuz2 
    lda.z w
    sta.z print_uchar_at.b
    // [28] print_uchar_at::at#1 = print_uint_at::at#2 + 2 -- pbuz1=pbuz1_plus_vbuc1 
    lda #2
    clc
    adc.z print_uchar_at.at
    sta.z print_uchar_at.at
    bcc !+
    inc.z print_uchar_at.at+1
  !:
    // [29] call print_uchar_at 
    // [31] phi from print_uint_at::@1 to print_uchar_at [phi:print_uint_at::@1->print_uchar_at]
    // [31] phi print_uchar_at::at#2 = print_uchar_at::at#1 [phi:print_uint_at::@1->print_uchar_at#0] -- register_copy 
    // [31] phi print_uchar_at::b#2 = print_uchar_at::b#1 [phi:print_uint_at::@1->print_uchar_at#1] -- register_copy 
    jsr print_uchar_at
    // print_uint_at::@return
    // }
    // [30] return 
    rts
}
  // print_uchar_at
// Print a char as HEX at a specific position
// print_uchar_at(byte zp(6) b, byte* zp(4) at)
print_uchar_at: {
    .label b = 6
    .label at = 4
    // b>>4
    // [32] print_uchar_at::$0 = print_uchar_at::b#2 >> 4 -- vbuaa=vbuz1_ror_4 
    lda.z b
    lsr
    lsr
    lsr
    lsr
    // print_char_at(print_hextab[b>>4], at)
    // [33] print_char_at::ch#0 = print_hextab[print_uchar_at::$0] -- vbuxx=pbuc1_derefidx_vbuaa 
    tay
    ldx print_hextab,y
    // [34] print_char_at::at#0 = print_uchar_at::at#2 -- pbuz1=pbuz2 
    lda.z at
    sta.z print_char_at.at
    lda.z at+1
    sta.z print_char_at.at+1
    // [35] call print_char_at 
  // Table of hexadecimal digits
    // [41] phi from print_uchar_at to print_char_at [phi:print_uchar_at->print_char_at]
    // [41] phi print_char_at::at#2 = print_char_at::at#0 [phi:print_uchar_at->print_char_at#0] -- register_copy 
    // [41] phi print_char_at::ch#2 = print_char_at::ch#0 [phi:print_uchar_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    // print_uchar_at::@1
    // b&$f
    // [36] print_uchar_at::$2 = print_uchar_at::b#2 & $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and.z b
    tay
    // print_char_at(print_hextab[b&$f], at+1)
    // [37] print_char_at::at#1 = print_uchar_at::at#2 + 1 -- pbuz1=pbuz2_plus_1 
    clc
    lda.z at
    adc #1
    sta.z print_char_at.at
    lda.z at+1
    adc #0
    sta.z print_char_at.at+1
    // [38] print_char_at::ch#1 = print_hextab[print_uchar_at::$2] -- vbuxx=pbuc1_derefidx_vbuyy 
    ldx print_hextab,y
    // [39] call print_char_at 
    // [41] phi from print_uchar_at::@1 to print_char_at [phi:print_uchar_at::@1->print_char_at]
    // [41] phi print_char_at::at#2 = print_char_at::at#1 [phi:print_uchar_at::@1->print_char_at#0] -- register_copy 
    // [41] phi print_char_at::ch#2 = print_char_at::ch#1 [phi:print_uchar_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    // print_uchar_at::@return
    // }
    // [40] return 
    rts
}
  // print_char_at
// Print a single char
// print_char_at(byte register(X) ch, byte* zp(7) at)
print_char_at: {
    .label at = 7
    // *(at) = ch
    // [42] *print_char_at::at#2 = print_char_at::ch#2 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (at),y
    // print_char_at::@return
    // }
    // [43] return 
    rts
}
  // File Data
.segment Data
  print_hextab: .text "0123456789abcdef"

