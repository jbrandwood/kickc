Adding pointer type conversion cast (byte*) PROCPORT_DDR in (byte*) PROCPORT_DDR ← (number) 0
Adding pointer type conversion cast (byte*) PROCPORT in (byte*) PROCPORT ← (number) 1
Adding pointer type conversion cast (byte*) CHARGEN in (byte*) CHARGEN ← (number) $d000
Adding pointer type conversion cast (byte*) SPRITES_XPOS in (byte*) SPRITES_XPOS ← (number) $d000
Adding pointer type conversion cast (byte*) SPRITES_YPOS in (byte*) SPRITES_YPOS ← (number) $d001
Adding pointer type conversion cast (byte*) SPRITES_XMSB in (byte*) SPRITES_XMSB ← (number) $d010
Adding pointer type conversion cast (byte*) RASTER in (byte*) RASTER ← (number) $d012
Adding pointer type conversion cast (byte*) SPRITES_ENABLE in (byte*) SPRITES_ENABLE ← (number) $d015
Adding pointer type conversion cast (byte*) SPRITES_EXPAND_Y in (byte*) SPRITES_EXPAND_Y ← (number) $d017
Adding pointer type conversion cast (byte*) SPRITES_PRIORITY in (byte*) SPRITES_PRIORITY ← (number) $d01b
Adding pointer type conversion cast (byte*) SPRITES_MC in (byte*) SPRITES_MC ← (number) $d01c
Adding pointer type conversion cast (byte*) SPRITES_EXPAND_X in (byte*) SPRITES_EXPAND_X ← (number) $d01d
Adding pointer type conversion cast (byte*) BORDERCOL in (byte*) BORDERCOL ← (number) $d020
Adding pointer type conversion cast (byte*) BGCOL in (byte*) BGCOL ← (number) $d021
Adding pointer type conversion cast (byte*) BGCOL1 in (byte*) BGCOL1 ← (number) $d021
Adding pointer type conversion cast (byte*) BGCOL2 in (byte*) BGCOL2 ← (number) $d022
Adding pointer type conversion cast (byte*) BGCOL3 in (byte*) BGCOL3 ← (number) $d023
Adding pointer type conversion cast (byte*) BGCOL4 in (byte*) BGCOL4 ← (number) $d024
Adding pointer type conversion cast (byte*) SPRITES_MC1 in (byte*) SPRITES_MC1 ← (number) $d025
Adding pointer type conversion cast (byte*) SPRITES_MC2 in (byte*) SPRITES_MC2 ← (number) $d026
Adding pointer type conversion cast (byte*) SPRITES_COLS in (byte*) SPRITES_COLS ← (number) $d027
Adding pointer type conversion cast (byte*) VIC_CONTROL in (byte*) VIC_CONTROL ← (number) $d011
Adding pointer type conversion cast (byte*) D011 in (byte*) D011 ← (number) $d011
Adding pointer type conversion cast (byte*) VIC_CONTROL2 in (byte*) VIC_CONTROL2 ← (number) $d016
Adding pointer type conversion cast (byte*) D016 in (byte*) D016 ← (number) $d016
Adding pointer type conversion cast (byte*) D018 in (byte*) D018 ← (number) $d018
Adding pointer type conversion cast (byte*) VIC_MEMORY in (byte*) VIC_MEMORY ← (number) $d018
Adding pointer type conversion cast (byte*) LIGHTPEN_X in (byte*) LIGHTPEN_X ← (number) $d013
Adding pointer type conversion cast (byte*) LIGHTPEN_Y in (byte*) LIGHTPEN_Y ← (number) $d014
Adding pointer type conversion cast (byte*) IRQ_STATUS in (byte*) IRQ_STATUS ← (number) $d019
Adding pointer type conversion cast (byte*) IRQ_ENABLE in (byte*) IRQ_ENABLE ← (number) $d01a
Adding pointer type conversion cast (byte*) COLS in (byte*) COLS ← (number) $d800
Adding pointer type conversion cast (byte*) CIA1_PORT_A in (byte*) CIA1_PORT_A ← (number) $dc00
Adding pointer type conversion cast (byte*) CIA1_PORT_B in (byte*) CIA1_PORT_B ← (number) $dc01
Adding pointer type conversion cast (byte*) CIA1_PORT_A_DDR in (byte*) CIA1_PORT_A_DDR ← (number) $dc02
Adding pointer type conversion cast (byte*) CIA1_PORT_B_DDR in (byte*) CIA1_PORT_B_DDR ← (number) $dc03
Adding pointer type conversion cast (byte*) CIA1_INTERRUPT in (byte*) CIA1_INTERRUPT ← (number) $dc0d
Adding pointer type conversion cast (byte*) CIA2_PORT_A in (byte*) CIA2_PORT_A ← (number) $dd00
Adding pointer type conversion cast (byte*) CIA2_PORT_B in (byte*) CIA2_PORT_B ← (number) $dd01
Adding pointer type conversion cast (byte*) CIA2_PORT_A_DDR in (byte*) CIA2_PORT_A_DDR ← (number) $dd02
Adding pointer type conversion cast (byte*) CIA2_PORT_B_DDR in (byte*) CIA2_PORT_B_DDR ← (number) $dd03
Adding pointer type conversion cast (byte*) CIA2_INTERRUPT in (byte*) CIA2_INTERRUPT ← (number) $dd0d
Adding pointer type conversion cast (void()**) KERNEL_IRQ in (void()**) KERNEL_IRQ ← (number) $314
Adding pointer type conversion cast (void()**) HARDWARE_IRQ in (void()**) HARDWARE_IRQ ← (number) $fffe
Adding pointer type conversion cast (byte*) screen in (byte*) screen ← (number) $400
Adding pointer type conversion cast (byte*) charset in (byte*) charset ← (number) $2000
Adding pointer type conversion cast (byte*) tileset in (byte*) tileset ← (number) $2800
Adding pointer type conversion cast (byte*) colors in (byte*) colors ← (number) $d800
Adding pointer type conversion cast (byte*) level_address in (byte*) level_address ← (number) $3000
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call (byte~) init::$3 ← call toD018 (byte*) screen (byte*) charset 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) @7
Culled Empty Block (label) @8
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) fill::@2
Culled Empty Block (label) @12
Culled Empty Block (label) mul8u::@5
Culled Empty Block (label) mul8u::@6
Culled Empty Block (label) mul8u::@8
Culled Empty Block (label) mul8u::@9
Culled Empty Block (label) @13
Culled Empty Block (label) @14
Culled Empty Block (label) @15
Culled Empty Block (label) @16
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@6
Culled Empty Block (label) @18
Culled Empty Block (label) init::toD0181_@1
Culled Empty Block (label) @19
Culled Empty Block (label) @20

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) SPRITES_XMSB#0 ← ((byte*)) (number) $d010
  (byte*) SPRITES_ENABLE#0 ← ((byte*)) (number) $d015
  (byte*) SPRITES_EXPAND_Y#0 ← ((byte*)) (number) $d017
  (byte*) SPRITES_MC#0 ← ((byte*)) (number) $d01c
  (byte*) SPRITES_EXPAND_X#0 ← ((byte*)) (number) $d01d
  (byte*) BORDERCOL#0 ← ((byte*)) (number) $d020
  (byte*) BGCOL1#0 ← ((byte*)) (number) $d021
  (byte*) BGCOL2#0 ← ((byte*)) (number) $d022
  (byte*) BGCOL3#0 ← ((byte*)) (number) $d023
  (byte*) BGCOL4#0 ← ((byte*)) (number) $d024
  (byte*) SPRITES_COLS#0 ← ((byte*)) (number) $d027
  (byte*) D018#0 ← ((byte*)) (number) $d018
  (byte) BLACK#0 ← (number) 0
  (byte) WHITE#0 ← (number) 1
  (byte) RED#0 ← (number) 2
  (byte) GREEN#0 ← (number) 5
  (byte) BLUE#0 ← (number) 6
  (byte) YELLOW#0 ← (number) 7
  to:@17
fill: scope:[fill]  from init::@2 init::@3
  (byte) fill::val#3 ← phi( init::@2/(byte) fill::val#0 init::@3/(byte) fill::val#1 )
  (word) fill::size#2 ← phi( init::@2/(word) fill::size#0 init::@3/(word) fill::size#1 )
  (byte*) fill::start#2 ← phi( init::@2/(byte*) fill::start#0 init::@3/(byte*) fill::start#1 )
  (byte*~) fill::$0 ← (byte*) fill::start#2 + (word) fill::size#2
  (byte*) fill::end#0 ← (byte*~) fill::$0
  (byte*) fill::addr#0 ← (byte*) fill::start#2
  to:fill::@1
fill::@1: scope:[fill]  from fill fill::@1
  (byte*) fill::end#1 ← phi( fill/(byte*) fill::end#0 fill::@1/(byte*) fill::end#1 )
  (byte*) fill::addr#2 ← phi( fill/(byte*) fill::addr#0 fill::@1/(byte*) fill::addr#1 )
  (byte) fill::val#2 ← phi( fill/(byte) fill::val#3 fill::@1/(byte) fill::val#2 )
  *((byte*) fill::addr#2) ← (byte) fill::val#2
  (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2
  (bool~) fill::$1 ← (byte*) fill::addr#1 != (byte*) fill::end#1
  if((bool~) fill::$1) goto fill::@1
  to:fill::@return
fill::@return: scope:[fill]  from fill::@1
  return 
  to:@return
mul8u: scope:[mul8u]  from draw_block
  (byte) mul8u::a#5 ← phi( draw_block/(byte) mul8u::a#1 )
  (byte) mul8u::b#1 ← phi( draw_block/(byte) mul8u::b#0 )
  (word) mul8u::res#0 ← (number) 0
  (word) mul8u::mb#0 ← (byte) mul8u::b#1
  to:mul8u::@1
mul8u::@1: scope:[mul8u]  from mul8u mul8u::@4
  (word) mul8u::mb#5 ← phi( mul8u/(word) mul8u::mb#0 mul8u::@4/(word) mul8u::mb#1 )
  (word) mul8u::res#4 ← phi( mul8u/(word) mul8u::res#0 mul8u::@4/(word) mul8u::res#6 )
  (byte) mul8u::a#2 ← phi( mul8u/(byte) mul8u::a#5 mul8u::@4/(byte) mul8u::a#0 )
  (bool~) mul8u::$0 ← (byte) mul8u::a#2 != (number) 0
  if((bool~) mul8u::$0) goto mul8u::@2
  to:mul8u::@3
mul8u::@2: scope:[mul8u]  from mul8u::@1
  (word) mul8u::res#5 ← phi( mul8u::@1/(word) mul8u::res#4 )
  (word) mul8u::mb#4 ← phi( mul8u::@1/(word) mul8u::mb#5 )
  (byte) mul8u::a#3 ← phi( mul8u::@1/(byte) mul8u::a#2 )
  (number~) mul8u::$1 ← (byte) mul8u::a#3 & (number) 1
  (bool~) mul8u::$2 ← (number~) mul8u::$1 != (number) 0
  (bool~) mul8u::$3 ← ! (bool~) mul8u::$2
  if((bool~) mul8u::$3) goto mul8u::@4
  to:mul8u::@7
mul8u::@3: scope:[mul8u]  from mul8u::@1
  (word) mul8u::res#2 ← phi( mul8u::@1/(word) mul8u::res#4 )
  (word) mul8u::return#0 ← (word) mul8u::res#2
  to:mul8u::@return
mul8u::@4: scope:[mul8u]  from mul8u::@2 mul8u::@7
  (word) mul8u::res#6 ← phi( mul8u::@2/(word) mul8u::res#5 mul8u::@7/(word) mul8u::res#1 )
  (word) mul8u::mb#2 ← phi( mul8u::@2/(word) mul8u::mb#4 mul8u::@7/(word) mul8u::mb#3 )
  (byte) mul8u::a#4 ← phi( mul8u::@2/(byte) mul8u::a#3 mul8u::@7/(byte) mul8u::a#6 )
  (byte~) mul8u::$5 ← (byte) mul8u::a#4 >> (number) 1
  (byte) mul8u::a#0 ← (byte~) mul8u::$5
  (word~) mul8u::$6 ← (word) mul8u::mb#2 << (number) 1
  (word) mul8u::mb#1 ← (word~) mul8u::$6
  to:mul8u::@1
mul8u::@7: scope:[mul8u]  from mul8u::@2
  (byte) mul8u::a#6 ← phi( mul8u::@2/(byte) mul8u::a#3 )
  (word) mul8u::mb#3 ← phi( mul8u::@2/(word) mul8u::mb#4 )
  (word) mul8u::res#3 ← phi( mul8u::@2/(word) mul8u::res#5 )
  (word~) mul8u::$4 ← (word) mul8u::res#3 + (word) mul8u::mb#3
  (word) mul8u::res#1 ← (word~) mul8u::$4
  to:mul8u::@4
mul8u::@return: scope:[mul8u]  from mul8u::@3
  (word) mul8u::return#3 ← phi( mul8u::@3/(word) mul8u::return#0 )
  (word) mul8u::return#1 ← (word) mul8u::return#3
  return 
  to:@return
@17: scope:[]  from @begin
  (byte*) screen#0 ← ((byte*)) (number) $400
  (byte*) charset#0 ← ((byte*)) (number) $2000
  (byte*) tileset#0 ← ((byte*)) (number) $2800
  (byte*) colors#0 ← ((byte*)) (number) $d800
  (byte*) level_address#0 ← ((byte*)) (number) $3000
  to:@21
main: scope:[main]  from @21
  call init 
  to:main::@7
main::@7: scope:[main]  from main
  (byte) main::x#0 ← (number) 0
  to:main::@1
main::@1: scope:[main]  from main::@3 main::@7
  (byte) main::x#4 ← phi( main::@3/(byte) main::x#1 main::@7/(byte) main::x#0 )
  (byte) main::y#0 ← (number) 0
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@8
  (byte) main::y#2 ← phi( main::@1/(byte) main::y#0 main::@8/(byte) main::y#1 )
  (byte) main::x#2 ← phi( main::@1/(byte) main::x#4 main::@8/(byte) main::x#5 )
  (byte~) main::$1 ← (byte) main::x#2 + (byte) main::y#2
  (byte) main::z#0 ← (byte~) main::$1
  (byte) main::tile#0 ← *((byte*) level_address#0 + (byte) main::z#0)
  (byte) draw_block::tileno#0 ← (byte) main::tile#0
  (byte) draw_block::x#0 ← (byte) main::x#2
  (byte) draw_block::y#0 ← (byte) main::y#2
  (byte) draw_block::color#0 ← (byte) YELLOW#0
  call draw_block 
  to:main::@8
main::@8: scope:[main]  from main::@2
  (byte) main::x#5 ← phi( main::@2/(byte) main::x#2 )
  (byte) main::y#3 ← phi( main::@2/(byte) main::y#2 )
  (byte) main::y#1 ← ++ (byte) main::y#3
  (bool~) main::$3 ← (byte) main::y#1 < (number) 9
  if((bool~) main::$3) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@8
  (byte) main::x#3 ← phi( main::@8/(byte) main::x#5 )
  (byte) main::x#1 ← ++ (byte) main::x#3
  (bool~) main::$4 ← (byte) main::x#1 < (number) $10
  if((bool~) main::$4) goto main::@1
  to:main::@5
main::@5: scope:[main]  from main::@3 main::@5
  if(true) goto main::@5
  to:main::@return
main::@return: scope:[main]  from main::@5
  return 
  to:@return
init: scope:[init]  from main
  call init_sprites 
  to:init::@2
init::@2: scope:[init]  from init
  (byte*) fill::start#0 ← (byte*) screen#0
  (word) fill::size#0 ← (number) $3e8
  (byte) fill::val#0 ← (number) 0
  call fill 
  to:init::@3
init::@3: scope:[init]  from init::@2
  (byte*) fill::start#1 ← (byte*) colors#0
  (word) fill::size#1 ← (number) $3e8
  (byte) fill::val#1 ← (byte) BLACK#0
  call fill 
  to:init::@4
init::@4: scope:[init]  from init::@3
  (byte*) init::toD0181_screen#0 ← (byte*) screen#0
  (byte*) init::toD0181_gfx#0 ← (byte*) charset#0
  to:init::toD0181
init::toD0181: scope:[init]  from init::@4
  (byte*) init::toD0181_gfx#1 ← phi( init::@4/(byte*) init::toD0181_gfx#0 )
  (byte*) init::toD0181_screen#1 ← phi( init::@4/(byte*) init::toD0181_screen#0 )
  (word~) init::toD0181_$0#0 ← ((word)) (byte*) init::toD0181_screen#1
  (number~) init::toD0181_$1#0 ← (word~) init::toD0181_$0#0 & (number) $3fff
  (number~) init::toD0181_$2#0 ← (number~) init::toD0181_$1#0 * (number) 4
  (number~) init::toD0181_$3#0 ← > (number~) init::toD0181_$2#0
  (word~) init::toD0181_$4#0 ← ((word)) (byte*) init::toD0181_gfx#1
  (byte~) init::toD0181_$5#0 ← > (word~) init::toD0181_$4#0
  (number~) init::toD0181_$6#0 ← (byte~) init::toD0181_$5#0 / (number) 4
  (number~) init::toD0181_$7#0 ← (number~) init::toD0181_$6#0 & (number) $f
  (number~) init::toD0181_$8#0 ← (number~) init::toD0181_$3#0 | (number~) init::toD0181_$7#0
  (byte) init::toD0181_return#0 ← (number~) init::toD0181_$8#0
  to:init::toD0181_@return
init::toD0181_@return: scope:[init]  from init::toD0181
  (byte) init::toD0181_return#2 ← phi( init::toD0181/(byte) init::toD0181_return#0 )
  (byte) init::toD0181_return#1 ← (byte) init::toD0181_return#2
  to:init::@1
init::@1: scope:[init]  from init::toD0181_@return
  (byte) init::toD0181_return#3 ← phi( init::toD0181_@return/(byte) init::toD0181_return#1 )
  (byte~) init::$3 ← (byte) init::toD0181_return#3
  *((byte*) D018#0) ← (byte~) init::$3
  asm { lda#$5b sta$d011  }
  *((byte*) BORDERCOL#0) ← (byte) BLACK#0
  *((byte*) BGCOL1#0) ← (byte) BLACK#0
  *((byte*) BGCOL2#0) ← (byte) RED#0
  *((byte*) BGCOL3#0) ← (byte) BLUE#0
  *((byte*) BGCOL4#0) ← (byte) GREEN#0
  to:init::@return
init::@return: scope:[init]  from init::@1
  return 
  to:@return
init_sprites: scope:[init_sprites]  from init
  *((byte*) SPRITES_ENABLE#0) ← (number) 1
  *((byte*) SPRITES_EXPAND_X#0) ← (number) 0
  *((byte*) SPRITES_EXPAND_Y#0) ← (number) 0
  *((byte*) SPRITES_XMSB#0) ← (number) 0
  *((byte*) SPRITES_COLS#0) ← (byte) WHITE#0
  *((byte*) SPRITES_MC#0) ← (number) 0
  to:init_sprites::@return
init_sprites::@return: scope:[init_sprites]  from init_sprites
  return 
  to:@return
draw_block: scope:[draw_block]  from main::@2
  (byte) draw_block::y#2 ← phi( main::@2/(byte) draw_block::y#0 )
  (byte) draw_block::x#1 ← phi( main::@2/(byte) draw_block::x#0 )
  (byte) draw_block::tileno#2 ← phi( main::@2/(byte) draw_block::tileno#0 )
  (byte~) draw_block::$0 ← (byte) draw_block::tileno#2 << (number) 2
  (byte) draw_block::tileno#1 ← (byte~) draw_block::$0
  (byte~) draw_block::$1 ← (byte) draw_block::x#1 << (number) 1
  (word) draw_block::x1#0 ← (byte~) draw_block::$1
  (byte~) draw_block::$2 ← (byte) draw_block::y#2 << (number) 1
  (byte) draw_block::y#1 ← (byte~) draw_block::$2
  (byte) mul8u::a#1 ← (byte) draw_block::y#1
  (byte) mul8u::b#0 ← (number) $28
  call mul8u 
  (word) mul8u::return#2 ← (word) mul8u::return#1
  to:draw_block::@1
draw_block::@1: scope:[draw_block]  from draw_block
  (byte) draw_block::tileno#3 ← phi( draw_block/(byte) draw_block::tileno#1 )
  (word) draw_block::x1#1 ← phi( draw_block/(word) draw_block::x1#0 )
  (word) mul8u::return#4 ← phi( draw_block/(word) mul8u::return#2 )
  (word~) draw_block::$3 ← (word) mul8u::return#4
  (word) draw_block::z#0 ← (word~) draw_block::$3
  (word~) draw_block::$4 ← (word) draw_block::z#0 + (word) draw_block::x1#1
  (word) draw_block::z#1 ← (word~) draw_block::$4
  (byte) draw_block::drawtile#0 ← *((byte*) tileset#0 + (byte) draw_block::tileno#3)
  *((byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0
  *((byte*) colors#0 + (word) draw_block::z#1) ← (byte) YELLOW#0
  (number~) draw_block::$5 ← (word) draw_block::z#1 + (number) 1
  *((byte*) screen#0 + (number~) draw_block::$5) ← (number) 1
  (number~) draw_block::$6 ← (word) draw_block::z#1 + (number) 1
  *((byte*) colors#0 + (number~) draw_block::$6) ← (byte) YELLOW#0
  (number~) draw_block::$7 ← (word) draw_block::z#1 + (number) $28
  *((byte*) screen#0 + (number~) draw_block::$7) ← (number) 2
  (number~) draw_block::$8 ← (word) draw_block::z#1 + (number) $28
  *((byte*) colors#0 + (number~) draw_block::$8) ← (byte) YELLOW#0
  (number~) draw_block::$9 ← (word) draw_block::z#1 + (number) $29
  *((byte*) screen#0 + (number~) draw_block::$9) ← (number) 3
  (number~) draw_block::$10 ← (word) draw_block::z#1 + (number) $29
  *((byte*) colors#0 + (number~) draw_block::$10) ← (byte) YELLOW#0
  to:draw_block::@return
draw_block::@return: scope:[draw_block]  from draw_block::@1
  return 
  to:@return
@21: scope:[]  from @17
  call main 
  to:@22
@22: scope:[]  from @21
  to:@end
@end: scope:[]  from @22

SYMBOL TABLE SSA
(label) @17
(label) @21
(label) @22
(label) @begin
(label) @end
(byte*) BGCOL1
(byte*) BGCOL1#0
(byte*) BGCOL2
(byte*) BGCOL2#0
(byte*) BGCOL3
(byte*) BGCOL3#0
(byte*) BGCOL4
(byte*) BGCOL4#0
(byte) BLACK
(byte) BLACK#0
(byte) BLUE
(byte) BLUE#0
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte*) D018
(byte*) D018#0
(byte) GREEN
(byte) GREEN#0
(byte) RED
(byte) RED#0
(byte*) SPRITES_COLS
(byte*) SPRITES_COLS#0
(byte*) SPRITES_ENABLE
(byte*) SPRITES_ENABLE#0
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_X#0
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_EXPAND_Y#0
(byte*) SPRITES_MC
(byte*) SPRITES_MC#0
(byte*) SPRITES_XMSB
(byte*) SPRITES_XMSB#0
(byte) WHITE
(byte) WHITE#0
(byte) YELLOW
(byte) YELLOW#0
(byte*) charset
(byte*) charset#0
(byte*) colors
(byte*) colors#0
(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
(byte~) draw_block::$0
(byte~) draw_block::$1
(number~) draw_block::$10
(byte~) draw_block::$2
(word~) draw_block::$3
(word~) draw_block::$4
(number~) draw_block::$5
(number~) draw_block::$6
(number~) draw_block::$7
(number~) draw_block::$8
(number~) draw_block::$9
(label) draw_block::@1
(label) draw_block::@return
(byte) draw_block::color
(byte) draw_block::color#0
(byte) draw_block::drawtile
(byte) draw_block::drawtile#0
(byte) draw_block::tileno
(byte) draw_block::tileno#0
(byte) draw_block::tileno#1
(byte) draw_block::tileno#2
(byte) draw_block::tileno#3
(byte) draw_block::x
(byte) draw_block::x#0
(byte) draw_block::x#1
(word) draw_block::x1
(word) draw_block::x1#0
(word) draw_block::x1#1
(byte) draw_block::y
(byte) draw_block::y#0
(byte) draw_block::y#1
(byte) draw_block::y#2
(word) draw_block::z
(word) draw_block::z#0
(word) draw_block::z#1
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(byte*~) fill::$0
(bool~) fill::$1
(label) fill::@1
(label) fill::@return
(byte*) fill::addr
(byte*) fill::addr#0
(byte*) fill::addr#1
(byte*) fill::addr#2
(byte*) fill::end
(byte*) fill::end#0
(byte*) fill::end#1
(word) fill::size
(word) fill::size#0
(word) fill::size#1
(word) fill::size#2
(byte*) fill::start
(byte*) fill::start#0
(byte*) fill::start#1
(byte*) fill::start#2
(byte) fill::val
(byte) fill::val#0
(byte) fill::val#1
(byte) fill::val#2
(byte) fill::val#3
(void()) init()
(byte~) init::$3
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@return
(label) init::toD0181
(word~) init::toD0181_$0
(word~) init::toD0181_$0#0
(number~) init::toD0181_$1
(number~) init::toD0181_$1#0
(number~) init::toD0181_$2
(number~) init::toD0181_$2#0
(number~) init::toD0181_$3
(number~) init::toD0181_$3#0
(word~) init::toD0181_$4
(word~) init::toD0181_$4#0
(byte~) init::toD0181_$5
(byte~) init::toD0181_$5#0
(number~) init::toD0181_$6
(number~) init::toD0181_$6#0
(number~) init::toD0181_$7
(number~) init::toD0181_$7#0
(number~) init::toD0181_$8
(number~) init::toD0181_$8#0
(label) init::toD0181_@return
(byte*) init::toD0181_gfx
(byte*) init::toD0181_gfx#0
(byte*) init::toD0181_gfx#1
(byte) init::toD0181_return
(byte) init::toD0181_return#0
(byte) init::toD0181_return#1
(byte) init::toD0181_return#2
(byte) init::toD0181_return#3
(byte*) init::toD0181_screen
(byte*) init::toD0181_screen#0
(byte*) init::toD0181_screen#1
(void()) init_sprites()
(label) init_sprites::@return
(byte*) level_address
(byte*) level_address#0
(void()) main()
(byte~) main::$1
(bool~) main::$3
(bool~) main::$4
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@5
(label) main::@7
(label) main::@8
(label) main::@return
(byte) main::tile
(byte) main::tile#0
(byte) main::x
(byte) main::x#0
(byte) main::x#1
(byte) main::x#2
(byte) main::x#3
(byte) main::x#4
(byte) main::x#5
(byte) main::y
(byte) main::y#0
(byte) main::y#1
(byte) main::y#2
(byte) main::y#3
(byte) main::z
(byte) main::z#0
(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
(bool~) mul8u::$0
(number~) mul8u::$1
(bool~) mul8u::$2
(bool~) mul8u::$3
(word~) mul8u::$4
(byte~) mul8u::$5
(word~) mul8u::$6
(label) mul8u::@1
(label) mul8u::@2
(label) mul8u::@3
(label) mul8u::@4
(label) mul8u::@7
(label) mul8u::@return
(byte) mul8u::a
(byte) mul8u::a#0
(byte) mul8u::a#1
(byte) mul8u::a#2
(byte) mul8u::a#3
(byte) mul8u::a#4
(byte) mul8u::a#5
(byte) mul8u::a#6
(byte) mul8u::b
(byte) mul8u::b#0
(byte) mul8u::b#1
(word) mul8u::mb
(word) mul8u::mb#0
(word) mul8u::mb#1
(word) mul8u::mb#2
(word) mul8u::mb#3
(word) mul8u::mb#4
(word) mul8u::mb#5
(word) mul8u::res
(word) mul8u::res#0
(word) mul8u::res#1
(word) mul8u::res#2
(word) mul8u::res#3
(word) mul8u::res#4
(word) mul8u::res#5
(word) mul8u::res#6
(word) mul8u::return
(word) mul8u::return#0
(word) mul8u::return#1
(word) mul8u::return#2
(word) mul8u::return#3
(word) mul8u::return#4
(byte*) screen
(byte*) screen#0
(byte*) tileset
(byte*) tileset#0

Adding number conversion cast (unumber) 0 in (byte) BLACK#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) WHITE#0 ← (number) 1
Adding number conversion cast (unumber) 2 in (byte) RED#0 ← (number) 2
Adding number conversion cast (unumber) 5 in (byte) GREEN#0 ← (number) 5
Adding number conversion cast (unumber) 6 in (byte) BLUE#0 ← (number) 6
Adding number conversion cast (unumber) 7 in (byte) YELLOW#0 ← (number) 7
Adding number conversion cast (unumber) 0 in (word) mul8u::res#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (bool~) mul8u::$0 ← (byte) mul8u::a#2 != (number) 0
Adding number conversion cast (unumber) 1 in (number~) mul8u::$1 ← (byte) mul8u::a#3 & (number) 1
Adding number conversion cast (unumber) mul8u::$1 in (number~) mul8u::$1 ← (byte) mul8u::a#3 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) mul8u::$2 ← (unumber~) mul8u::$1 != (number) 0
Adding number conversion cast (unumber) 1 in (byte~) mul8u::$5 ← (byte) mul8u::a#4 >> (number) 1
Adding number conversion cast (unumber) 1 in (word~) mul8u::$6 ← (word) mul8u::mb#2 << (number) 1
Adding number conversion cast (unumber) 0 in (byte) main::x#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) main::y#0 ← (number) 0
Adding number conversion cast (unumber) 9 in (bool~) main::$3 ← (byte) main::y#1 < (number) 9
Adding number conversion cast (unumber) $10 in (bool~) main::$4 ← (byte) main::x#1 < (number) $10
Adding number conversion cast (unumber) $3e8 in (word) fill::size#0 ← (number) $3e8
Adding number conversion cast (unumber) 0 in (byte) fill::val#0 ← (number) 0
Adding number conversion cast (unumber) $3e8 in (word) fill::size#1 ← (number) $3e8
Adding number conversion cast (unumber) $3fff in (number~) init::toD0181_$1#0 ← (word~) init::toD0181_$0#0 & (number) $3fff
Adding number conversion cast (unumber) init::toD0181_$1#0 in (number~) init::toD0181_$1#0 ← (word~) init::toD0181_$0#0 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) init::toD0181_$2#0 ← (unumber~) init::toD0181_$1#0 * (number) 4
Adding number conversion cast (unumber) init::toD0181_$2#0 in (number~) init::toD0181_$2#0 ← (unumber~) init::toD0181_$1#0 * (unumber)(number) 4
Adding number conversion cast (unumber) init::toD0181_$3#0 in (number~) init::toD0181_$3#0 ← > (unumber~) init::toD0181_$2#0
Adding number conversion cast (unumber) 4 in (number~) init::toD0181_$6#0 ← (byte~) init::toD0181_$5#0 / (number) 4
Adding number conversion cast (unumber) init::toD0181_$6#0 in (number~) init::toD0181_$6#0 ← (byte~) init::toD0181_$5#0 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) init::toD0181_$7#0 ← (unumber~) init::toD0181_$6#0 & (number) $f
Adding number conversion cast (unumber) init::toD0181_$7#0 in (number~) init::toD0181_$7#0 ← (unumber~) init::toD0181_$6#0 & (unumber)(number) $f
Adding number conversion cast (unumber) init::toD0181_$8#0 in (number~) init::toD0181_$8#0 ← (unumber~) init::toD0181_$3#0 | (unumber~) init::toD0181_$7#0
Adding number conversion cast (unumber) 1 in *((byte*) SPRITES_ENABLE#0) ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte*) SPRITES_EXPAND_X#0) ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*) SPRITES_EXPAND_Y#0) ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*) SPRITES_XMSB#0) ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*) SPRITES_MC#0) ← (number) 0
Adding number conversion cast (unumber) 2 in (byte~) draw_block::$0 ← (byte) draw_block::tileno#2 << (number) 2
Adding number conversion cast (unumber) 1 in (byte~) draw_block::$1 ← (byte) draw_block::x#1 << (number) 1
Adding number conversion cast (unumber) 1 in (byte~) draw_block::$2 ← (byte) draw_block::y#2 << (number) 1
Adding number conversion cast (unumber) $28 in (byte) mul8u::b#0 ← (number) $28
Adding number conversion cast (unumber) 1 in (number~) draw_block::$5 ← (word) draw_block::z#1 + (number) 1
Adding number conversion cast (unumber) draw_block::$5 in (number~) draw_block::$5 ← (word) draw_block::z#1 + (unumber)(number) 1
Adding number conversion cast (unumber) 1 in *((byte*) screen#0 + (unumber~) draw_block::$5) ← (number) 1
Adding number conversion cast (unumber) 1 in (number~) draw_block::$6 ← (word) draw_block::z#1 + (number) 1
Adding number conversion cast (unumber) draw_block::$6 in (number~) draw_block::$6 ← (word) draw_block::z#1 + (unumber)(number) 1
Adding number conversion cast (unumber) $28 in (number~) draw_block::$7 ← (word) draw_block::z#1 + (number) $28
Adding number conversion cast (unumber) draw_block::$7 in (number~) draw_block::$7 ← (word) draw_block::z#1 + (unumber)(number) $28
Adding number conversion cast (unumber) 2 in *((byte*) screen#0 + (unumber~) draw_block::$7) ← (number) 2
Adding number conversion cast (unumber) $28 in (number~) draw_block::$8 ← (word) draw_block::z#1 + (number) $28
Adding number conversion cast (unumber) draw_block::$8 in (number~) draw_block::$8 ← (word) draw_block::z#1 + (unumber)(number) $28
Adding number conversion cast (unumber) $29 in (number~) draw_block::$9 ← (word) draw_block::z#1 + (number) $29
Adding number conversion cast (unumber) draw_block::$9 in (number~) draw_block::$9 ← (word) draw_block::z#1 + (unumber)(number) $29
Adding number conversion cast (unumber) 3 in *((byte*) screen#0 + (unumber~) draw_block::$9) ← (number) 3
Adding number conversion cast (unumber) $29 in (number~) draw_block::$10 ← (word) draw_block::z#1 + (number) $29
Adding number conversion cast (unumber) draw_block::$10 in (number~) draw_block::$10 ← (word) draw_block::z#1 + (unumber)(number) $29
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) SPRITES_XMSB#0 ← (byte*)(number) $d010
Inlining cast (byte*) SPRITES_ENABLE#0 ← (byte*)(number) $d015
Inlining cast (byte*) SPRITES_EXPAND_Y#0 ← (byte*)(number) $d017
Inlining cast (byte*) SPRITES_MC#0 ← (byte*)(number) $d01c
Inlining cast (byte*) SPRITES_EXPAND_X#0 ← (byte*)(number) $d01d
Inlining cast (byte*) BORDERCOL#0 ← (byte*)(number) $d020
Inlining cast (byte*) BGCOL1#0 ← (byte*)(number) $d021
Inlining cast (byte*) BGCOL2#0 ← (byte*)(number) $d022
Inlining cast (byte*) BGCOL3#0 ← (byte*)(number) $d023
Inlining cast (byte*) BGCOL4#0 ← (byte*)(number) $d024
Inlining cast (byte*) SPRITES_COLS#0 ← (byte*)(number) $d027
Inlining cast (byte*) D018#0 ← (byte*)(number) $d018
Inlining cast (byte) BLACK#0 ← (unumber)(number) 0
Inlining cast (byte) WHITE#0 ← (unumber)(number) 1
Inlining cast (byte) RED#0 ← (unumber)(number) 2
Inlining cast (byte) GREEN#0 ← (unumber)(number) 5
Inlining cast (byte) BLUE#0 ← (unumber)(number) 6
Inlining cast (byte) YELLOW#0 ← (unumber)(number) 7
Inlining cast (word) mul8u::res#0 ← (unumber)(number) 0
Inlining cast (byte*) screen#0 ← (byte*)(number) $400
Inlining cast (byte*) charset#0 ← (byte*)(number) $2000
Inlining cast (byte*) tileset#0 ← (byte*)(number) $2800
Inlining cast (byte*) colors#0 ← (byte*)(number) $d800
Inlining cast (byte*) level_address#0 ← (byte*)(number) $3000
Inlining cast (byte) main::x#0 ← (unumber)(number) 0
Inlining cast (byte) main::y#0 ← (unumber)(number) 0
Inlining cast (word) fill::size#0 ← (unumber)(number) $3e8
Inlining cast (byte) fill::val#0 ← (unumber)(number) 0
Inlining cast (word) fill::size#1 ← (unumber)(number) $3e8
Inlining cast (word~) init::toD0181_$0#0 ← (word)(byte*) init::toD0181_screen#1
Inlining cast (word~) init::toD0181_$4#0 ← (word)(byte*) init::toD0181_gfx#1
Inlining cast *((byte*) SPRITES_ENABLE#0) ← (unumber)(number) 1
Inlining cast *((byte*) SPRITES_EXPAND_X#0) ← (unumber)(number) 0
Inlining cast *((byte*) SPRITES_EXPAND_Y#0) ← (unumber)(number) 0
Inlining cast *((byte*) SPRITES_XMSB#0) ← (unumber)(number) 0
Inlining cast *((byte*) SPRITES_MC#0) ← (unumber)(number) 0
Inlining cast (byte) mul8u::b#0 ← (unumber)(number) $28
Inlining cast *((byte*) screen#0 + (unumber~) draw_block::$5) ← (unumber)(number) 1
Inlining cast *((byte*) screen#0 + (unumber~) draw_block::$7) ← (unumber)(number) 2
Inlining cast *((byte*) screen#0 + (unumber~) draw_block::$9) ← (unumber)(number) 3
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53264
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53271
Simplifying constant pointer cast (byte*) 53276
Simplifying constant pointer cast (byte*) 53277
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53281
Simplifying constant pointer cast (byte*) 53282
Simplifying constant pointer cast (byte*) 53283
Simplifying constant pointer cast (byte*) 53284
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (byte*) 53272
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 5
Simplifying constant integer cast 6
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 8192
Simplifying constant pointer cast (byte*) 10240
Simplifying constant pointer cast (byte*) 55296
Simplifying constant pointer cast (byte*) 12288
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 9
Simplifying constant integer cast $10
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast $3e8
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $28
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $28
Simplifying constant integer cast 2
Simplifying constant integer cast $28
Simplifying constant integer cast $29
Simplifying constant integer cast 3
Simplifying constant integer cast $29
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $10
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $29
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $29
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) mul8u::$1 ← (byte) mul8u::a#3 & (byte) 1
Inferred type updated to word in (unumber~) init::toD0181_$1#0 ← (word~) init::toD0181_$0#0 & (word) $3fff
Inferred type updated to word in (unumber~) init::toD0181_$2#0 ← (word~) init::toD0181_$1#0 * (byte) 4
Inferred type updated to byte in (unumber~) init::toD0181_$3#0 ← > (word~) init::toD0181_$2#0
Inferred type updated to byte in (unumber~) init::toD0181_$6#0 ← (byte~) init::toD0181_$5#0 / (byte) 4
Inferred type updated to byte in (unumber~) init::toD0181_$7#0 ← (byte~) init::toD0181_$6#0 & (byte) $f
Inferred type updated to byte in (unumber~) init::toD0181_$8#0 ← (byte~) init::toD0181_$3#0 | (byte~) init::toD0181_$7#0
Inferred type updated to word in (unumber~) draw_block::$5 ← (word) draw_block::z#1 + (byte) 1
Inferred type updated to word in (unumber~) draw_block::$6 ← (word) draw_block::z#1 + (byte) 1
Inferred type updated to word in (unumber~) draw_block::$7 ← (word) draw_block::z#1 + (byte) $28
Inferred type updated to word in (unumber~) draw_block::$8 ← (word) draw_block::z#1 + (byte) $28
Inferred type updated to word in (unumber~) draw_block::$9 ← (word) draw_block::z#1 + (byte) $29
Inferred type updated to word in (unumber~) draw_block::$10 ← (word) draw_block::z#1 + (byte) $29
Inversing boolean not [37] (bool~) mul8u::$3 ← (byte~) mul8u::$1 == (byte) 0 from [36] (bool~) mul8u::$2 ← (byte~) mul8u::$1 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte*) fill::end#0 = (byte*~) fill::$0 
Alias (byte*) fill::addr#0 = (byte*) fill::start#2 
Alias (word) mul8u::mb#0 = (byte) mul8u::b#1 
Alias (byte) mul8u::a#2 = (byte) mul8u::a#3 (byte) mul8u::a#6 
Alias (word) mul8u::mb#3 = (word) mul8u::mb#4 (word) mul8u::mb#5 
Alias (word) mul8u::res#2 = (word) mul8u::res#5 (word) mul8u::res#4 (word) mul8u::return#0 (word) mul8u::res#3 (word) mul8u::return#3 (word) mul8u::return#1 
Alias (byte) mul8u::a#0 = (byte~) mul8u::$5 
Alias (word) mul8u::mb#1 = (word~) mul8u::$6 
Alias (word) mul8u::res#1 = (word~) mul8u::$4 
Alias (byte) main::z#0 = (byte~) main::$1 
Alias (byte) main::y#2 = (byte) main::y#3 
Alias (byte) main::x#2 = (byte) main::x#5 (byte) main::x#3 
Alias (byte*) init::toD0181_screen#0 = (byte*) init::toD0181_screen#1 
Alias (byte*) init::toD0181_gfx#0 = (byte*) init::toD0181_gfx#1 
Alias (byte) init::toD0181_return#0 = (byte~) init::toD0181_$8#0 (byte) init::toD0181_return#2 (byte) init::toD0181_return#1 (byte) init::toD0181_return#3 (byte~) init::$3 
Alias (byte) draw_block::tileno#1 = (byte~) draw_block::$0 (byte) draw_block::tileno#3 
Alias (word) draw_block::x1#0 = (byte~) draw_block::$1 (word) draw_block::x1#1 
Alias (byte) draw_block::y#1 = (byte~) draw_block::$2 
Alias (word) mul8u::return#2 = (word) mul8u::return#4 
Alias (word) draw_block::z#0 = (word~) draw_block::$3 
Alias (word) draw_block::z#1 = (word~) draw_block::$4 
Successful SSA optimization Pass2AliasElimination
Alias (byte) mul8u::a#2 = (byte) mul8u::a#4 
Alias (word) mul8u::mb#2 = (word) mul8u::mb#3 
Successful SSA optimization Pass2AliasElimination
Self Phi Eliminated (byte) fill::val#2
Self Phi Eliminated (byte*) fill::end#1
Self Phi Eliminated (byte) main::x#2
Successful SSA optimization Pass2SelfPhiElimination
Identical Phi Values (byte) fill::val#2 (byte) fill::val#3
Identical Phi Values (byte*) fill::end#1 (byte*) fill::end#0
Identical Phi Values (word) mul8u::mb#0 (byte) mul8u::b#0
Identical Phi Values (byte) mul8u::a#5 (byte) mul8u::a#1
Identical Phi Values (byte) main::x#2 (byte) main::x#4
Identical Phi Values (byte) draw_block::tileno#2 (byte) draw_block::tileno#0
Identical Phi Values (byte) draw_block::x#1 (byte) draw_block::x#0
Identical Phi Values (byte) draw_block::y#2 (byte) draw_block::y#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) fill::$1 [26] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1
Simple Condition (bool~) mul8u::$0 [33] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2
Simple Condition (bool~) mul8u::$3 [38] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@4
Simple Condition (bool~) main::$3 [73] if((byte) main::y#1<(byte) 9) goto main::@2
Simple Condition (bool~) main::$4 [77] if((byte) main::x#1<(byte) $10) goto main::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) SPRITES_XMSB#0 = (byte*) 53264
Constant (const byte*) SPRITES_ENABLE#0 = (byte*) 53269
Constant (const byte*) SPRITES_EXPAND_Y#0 = (byte*) 53271
Constant (const byte*) SPRITES_MC#0 = (byte*) 53276
Constant (const byte*) SPRITES_EXPAND_X#0 = (byte*) 53277
Constant (const byte*) BORDERCOL#0 = (byte*) 53280
Constant (const byte*) BGCOL1#0 = (byte*) 53281
Constant (const byte*) BGCOL2#0 = (byte*) 53282
Constant (const byte*) BGCOL3#0 = (byte*) 53283
Constant (const byte*) BGCOL4#0 = (byte*) 53284
Constant (const byte*) SPRITES_COLS#0 = (byte*) 53287
Constant (const byte*) D018#0 = (byte*) 53272
Constant (const byte) BLACK#0 = 0
Constant (const byte) WHITE#0 = 1
Constant (const byte) RED#0 = 2
Constant (const byte) GREEN#0 = 5
Constant (const byte) BLUE#0 = 6
Constant (const byte) YELLOW#0 = 7
Constant (const word) mul8u::res#0 = 0
Constant (const byte*) screen#0 = (byte*) 1024
Constant (const byte*) charset#0 = (byte*) 8192
Constant (const byte*) tileset#0 = (byte*) 10240
Constant (const byte*) colors#0 = (byte*) 55296
Constant (const byte*) level_address#0 = (byte*) 12288
Constant (const byte) main::x#0 = 0
Constant (const byte) main::y#0 = 0
Constant (const word) fill::size#0 = $3e8
Constant (const byte) fill::val#0 = 0
Constant (const word) fill::size#1 = $3e8
Constant (const byte) mul8u::b#0 = $28
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) draw_block::color#0 = YELLOW#0
Constant (const byte*) fill::start#0 = screen#0
Constant (const byte*) fill::start#1 = colors#0
Constant (const byte) fill::val#1 = BLACK#0
Constant (const byte*) init::toD0181_screen#0 = screen#0
Constant (const byte*) init::toD0181_gfx#0 = charset#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)init::toD0181_screen#0 in [92] (word~) init::toD0181_$0#0 ← (word)(const byte*) init::toD0181_screen#0
Constant value identified (word)init::toD0181_gfx#0 in [96] (word~) init::toD0181_$4#0 ← (word)(const byte*) init::toD0181_gfx#0
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [78] if(true) goto main::@5
Successful SSA optimization Pass2ConstantIfs
De-inlining pointer[w] to *(pointer+w)   [138] *((const byte*) screen#0 + (word) draw_block::z#1) ← (byte) draw_block::drawtile#0
De-inlining pointer[w] to *(pointer+w)   [139] *((const byte*) colors#0 + (word) draw_block::z#1) ← (const byte) YELLOW#0
De-inlining pointer[w] to *(pointer+w)   [141] *((const byte*) screen#0 + (word~) draw_block::$5) ← (byte) 1
De-inlining pointer[w] to *(pointer+w)   [143] *((const byte*) colors#0 + (word~) draw_block::$6) ← (const byte) YELLOW#0
De-inlining pointer[w] to *(pointer+w)   [145] *((const byte*) screen#0 + (word~) draw_block::$7) ← (byte) 2
De-inlining pointer[w] to *(pointer+w)   [147] *((const byte*) colors#0 + (word~) draw_block::$8) ← (const byte) YELLOW#0
De-inlining pointer[w] to *(pointer+w)   [149] *((const byte*) screen#0 + (word~) draw_block::$9) ← (byte) 3
De-inlining pointer[w] to *(pointer+w)   [151] *((const byte*) colors#0 + (word~) draw_block::$10) ← (const byte) YELLOW#0
Successful SSA optimization Pass2DeInlineWordDerefIdx
Eliminating unused constant (const byte) draw_block::color#0
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Constant (const word) init::toD0181_$0#0 = (word)init::toD0181_screen#0
Constant (const word) init::toD0181_$4#0 = (word)init::toD0181_gfx#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [32] (word~) init::toD0181_$1#0 ← (const word) init::toD0181_$0#0 & (word) $3fff
Constant right-side identified [35] (byte~) init::toD0181_$5#0 ← > (const word) init::toD0181_$4#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) init::toD0181_$1#0 = init::toD0181_$0#0&$3fff
Constant (const byte) init::toD0181_$5#0 = >init::toD0181_$4#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [32] (word~) init::toD0181_$2#0 ← (const word) init::toD0181_$1#0 * (byte) 4
Constant right-side identified [34] (byte~) init::toD0181_$6#0 ← (const byte) init::toD0181_$5#0 / (byte) 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) init::toD0181_$2#0 = init::toD0181_$1#0*4
Constant (const byte) init::toD0181_$6#0 = init::toD0181_$5#0/4
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [32] (byte~) init::toD0181_$3#0 ← > (const word) init::toD0181_$2#0
Constant right-side identified [33] (byte~) init::toD0181_$7#0 ← (const byte) init::toD0181_$6#0 & (byte) $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) init::toD0181_$3#0 = >init::toD0181_$2#0
Constant (const byte) init::toD0181_$7#0 = init::toD0181_$6#0&$f
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [32] (byte) init::toD0181_return#0 ← (const byte) init::toD0181_$3#0 | (const byte) init::toD0181_$7#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) init::toD0181_return#0 = init::toD0181_$3#0|init::toD0181_$7#0
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings (const word) fill::size#0
Inlining constant with var siblings (const byte) fill::val#0
Inlining constant with var siblings (const word) fill::size#1
Inlining constant with var siblings (const byte) fill::val#1
Inlining constant with var siblings (const word) mul8u::res#0
Inlining constant with var siblings (const byte) main::x#0
Inlining constant with var siblings (const byte) main::y#0
Constant inlined init::toD0181_gfx#0 = (const byte*) charset#0
Constant inlined fill::val#0 = (byte) 0
Constant inlined init::toD0181_$0#0 = (word)(const byte*) screen#0
Constant inlined init::toD0181_$2#0 = (word)(const byte*) screen#0&(word) $3fff*(byte) 4
Constant inlined fill::val#1 = (const byte) BLACK#0
Constant inlined init::toD0181_$1#0 = (word)(const byte*) screen#0&(word) $3fff
Constant inlined init::toD0181_$4#0 = (word)(const byte*) charset#0
Constant inlined init::toD0181_$3#0 = >(word)(const byte*) screen#0&(word) $3fff*(byte) 4
Constant inlined fill::size#1 = (word) $3e8
Constant inlined init::toD0181_$6#0 = >(word)(const byte*) charset#0/(byte) 4
Constant inlined fill::size#0 = (word) $3e8
Constant inlined main::x#0 = (byte) 0
Constant inlined init::toD0181_$5#0 = >(word)(const byte*) charset#0
Constant inlined main::y#0 = (byte) 0
Constant inlined init::toD0181_$7#0 = >(word)(const byte*) charset#0/(byte) 4&(byte) $f
Constant inlined mul8u::res#0 = (byte) 0
Constant inlined fill::start#1 = (const byte*) colors#0
Constant inlined fill::start#0 = (const byte*) screen#0
Constant inlined init::toD0181_screen#0 = (const byte*) screen#0
Successful SSA optimization Pass2ConstantInlining
Consolidated constant in assignment draw_block::$13
Consolidated constant in assignment draw_block::$14
Consolidated constant in assignment draw_block::$15
Consolidated constant in assignment draw_block::$16
Consolidated constant in assignment draw_block::$17
Consolidated constant in assignment draw_block::$18
Successful SSA optimization Pass2ConstantAdditionElimination
Alias (word) draw_block::z#1 = (word~) draw_block::$5 (word~) draw_block::$6 (word~) draw_block::$7 (word~) draw_block::$8 (word~) draw_block::$9 (word~) draw_block::$10 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (word) fill::size#2 (word) $3e8
Successful SSA optimization Pass2IdenticalPhiElimination
Added new block during phi lifting fill::@3(between fill::@1 and fill::@1)
Added new block during phi lifting mul8u::@10(between mul8u::@2 and mul8u::@4)
Added new block during phi lifting main::@9(between main::@3 and main::@1)
Added new block during phi lifting main::@10(between main::@8 and main::@2)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @17
Adding NOP phi() at start of @21
Adding NOP phi() at start of @22
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of mul8u::@3
Adding NOP phi() at start of init
Adding NOP phi() at start of init::@2
Adding NOP phi() at start of init::@3
Adding NOP phi() at start of init::@4
Adding NOP phi() at start of init::toD0181
Adding NOP phi() at start of init::toD0181_@return
CALL GRAPH
Calls in [] to main:3 
Calls in [main] to init:7 draw_block:16 
Calls in [draw_block] to mul8u:28 
Calls in [init] to init_sprites:67 fill:69 fill:71 

Created 9 initial phi equivalence classes
Coalesced [22] main::x#6 ← main::x#1
Coalesced [23] main::y#4 ← main::y#1
Coalesced [50] mul8u::a#7 ← mul8u::a#1
Coalesced [58] mul8u::res#9 ← mul8u::res#1
Coalesced [62] mul8u::a#8 ← mul8u::a#0
Coalesced [63] mul8u::res#7 ← mul8u::res#6
Coalesced [64] mul8u::mb#6 ← mul8u::mb#1
Coalesced (already) [65] mul8u::res#8 ← mul8u::res#2
Coalesced [85] fill::addr#3 ← fill::addr#0
Coalesced [91] fill::addr#4 ← fill::addr#1
Coalesced down to 7 phi equivalence classes
Culled Empty Block (label) @17
Culled Empty Block (label) @22
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@10
Culled Empty Block (label) mul8u::@3
Culled Empty Block (label) mul8u::@10
Culled Empty Block (label) init::@4
Culled Empty Block (label) init::toD0181_@return
Culled Empty Block (label) fill::@3
Renumbering block @21 to @1
Renumbering block mul8u::@4 to mul8u::@3
Renumbering block mul8u::@7 to mul8u::@4
Renumbering block main::@5 to main::@4
Renumbering block main::@8 to main::@5
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of mul8u
Adding NOP phi() at start of init
Adding NOP phi() at start of init::@2
Adding NOP phi() at start of init::@3
Adding NOP phi() at start of init::toD0181

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  [5] call init 
  to:main::@1
main::@1: scope:[main]  from main main::@3
  [6] (byte) main::x#4 ← phi( main::@3/(byte) main::x#1 main/(byte) 0 )
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@5
  [7] (byte) main::y#2 ← phi( main::@1/(byte) 0 main::@5/(byte) main::y#1 )
  [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2
  [9] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0)
  [10] (byte) draw_block::tileno#0 ← (byte) main::tile#0
  [11] (byte) draw_block::x#0 ← (byte) main::x#4
  [12] (byte) draw_block::y#0 ← (byte) main::y#2
  [13] call draw_block 
  to:main::@5
main::@5: scope:[main]  from main::@2
  [14] (byte) main::y#1 ← ++ (byte) main::y#2
  [15] if((byte) main::y#1<(byte) 9) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@5
  [16] (byte) main::x#1 ← ++ (byte) main::x#4
  [17] if((byte) main::x#1<(byte) $10) goto main::@1
  to:main::@4
main::@4: scope:[main]  from main::@3 main::@4
  [18] phi()
  to:main::@4
draw_block: scope:[draw_block]  from main::@2
  [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2
  [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1
  [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1
  [22] (byte) mul8u::a#1 ← (byte) draw_block::y#1
  [23] call mul8u 
  [24] (word) mul8u::return#2 ← (word) mul8u::res#2
  to:draw_block::@1
draw_block::@1: scope:[draw_block]  from draw_block
  [25] (word) draw_block::z#0 ← (word) mul8u::return#2
  [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0
  [27] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1)
  [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1
  [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0
  [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1
  [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0
  [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1
  [33] *((byte*~) draw_block::$13) ← (byte) 1
  [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1
  [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0
  [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1
  [37] *((byte*~) draw_block::$15) ← (byte) 2
  [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1
  [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0
  [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1
  [41] *((byte*~) draw_block::$17) ← (byte) 3
  [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1
  [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0
  to:draw_block::@return
draw_block::@return: scope:[draw_block]  from draw_block::@1
  [44] return 
  to:@return
mul8u: scope:[mul8u]  from draw_block
  [45] phi()
  to:mul8u::@1
mul8u::@1: scope:[mul8u]  from mul8u mul8u::@3
  [46] (word) mul8u::mb#2 ← phi( mul8u/(const byte) mul8u::b#0 mul8u::@3/(word) mul8u::mb#1 )
  [46] (word) mul8u::res#2 ← phi( mul8u/(byte) 0 mul8u::@3/(word) mul8u::res#6 )
  [46] (byte) mul8u::a#2 ← phi( mul8u/(byte) mul8u::a#1 mul8u::@3/(byte) mul8u::a#0 )
  [47] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2
  to:mul8u::@return
mul8u::@return: scope:[mul8u]  from mul8u::@1
  [48] return 
  to:@return
mul8u::@2: scope:[mul8u]  from mul8u::@1
  [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1
  [50] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@3
  to:mul8u::@4
mul8u::@4: scope:[mul8u]  from mul8u::@2
  [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2
  to:mul8u::@3
mul8u::@3: scope:[mul8u]  from mul8u::@2 mul8u::@4
  [52] (word) mul8u::res#6 ← phi( mul8u::@2/(word) mul8u::res#2 mul8u::@4/(word) mul8u::res#1 )
  [53] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte) 1
  [54] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte) 1
  to:mul8u::@1
init: scope:[init]  from main
  [55] phi()
  [56] call init_sprites 
  to:init::@2
init::@2: scope:[init]  from init
  [57] phi()
  [58] call fill 
  to:init::@3
init::@3: scope:[init]  from init::@2
  [59] phi()
  [60] call fill 
  to:init::toD0181
init::toD0181: scope:[init]  from init::@3
  [61] phi()
  to:init::@1
init::@1: scope:[init]  from init::toD0181
  [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0
  asm { lda#$5b sta$d011  }
  [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0
  [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0
  [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0
  [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0
  [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0
  to:init::@return
init::@return: scope:[init]  from init::@1
  [69] return 
  to:@return
fill: scope:[fill]  from init::@2 init::@3
  [70] (byte) fill::val#3 ← phi( init::@2/(byte) 0 init::@3/(const byte) BLACK#0 )
  [70] (byte*) fill::addr#0 ← phi( init::@2/(const byte*) screen#0 init::@3/(const byte*) colors#0 )
  [71] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) $3e8
  to:fill::@1
fill::@1: scope:[fill]  from fill fill::@1
  [72] (byte*) fill::addr#2 ← phi( fill/(byte*) fill::addr#0 fill::@1/(byte*) fill::addr#1 )
  [73] *((byte*) fill::addr#2) ← (byte) fill::val#3
  [74] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2
  [75] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1
  to:fill::@return
fill::@return: scope:[fill]  from fill::@1
  [76] return 
  to:@return
init_sprites: scope:[init_sprites]  from init
  [77] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1
  [78] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0
  [79] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0
  [80] *((const byte*) SPRITES_XMSB#0) ← (byte) 0
  [81] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0
  [82] *((const byte*) SPRITES_MC#0) ← (byte) 0
  to:init_sprites::@return
init_sprites::@return: scope:[init_sprites]  from init_sprites
  [83] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte*) BGCOL1
(byte*) BGCOL2
(byte*) BGCOL3
(byte*) BGCOL4
(byte) BLACK
(byte) BLUE
(byte*) BORDERCOL
(byte*) D018
(byte) GREEN
(byte) RED
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_EXPAND_X
(byte*) SPRITES_EXPAND_Y
(byte*) SPRITES_MC
(byte*) SPRITES_XMSB
(byte) WHITE
(byte) YELLOW
(byte*) charset
(byte*) colors
(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
(byte*~) draw_block::$11 4.0
(byte*~) draw_block::$12 4.0
(byte*~) draw_block::$13 4.0
(byte*~) draw_block::$14 4.0
(byte*~) draw_block::$15 4.0
(byte*~) draw_block::$16 4.0
(byte*~) draw_block::$17 4.0
(byte*~) draw_block::$18 4.0
(byte) draw_block::color
(byte) draw_block::drawtile
(byte) draw_block::drawtile#0 2.0
(byte) draw_block::tileno
(byte) draw_block::tileno#0 34.33333333333333
(byte) draw_block::tileno#1 0.5
(byte) draw_block::x
(byte) draw_block::x#0 34.33333333333333
(word) draw_block::x1
(word) draw_block::x1#0 0.6666666666666666
(byte) draw_block::y
(byte) draw_block::y#0 34.33333333333333
(byte) draw_block::y#1 4.0
(word) draw_block::z
(word) draw_block::z#0 4.0
(word) draw_block::z#1 1.125
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(byte*) fill::addr
(byte*) fill::addr#0 2.0
(byte*) fill::addr#1 16.5
(byte*) fill::addr#2 17.5
(byte*) fill::end
(byte*) fill::end#0 2.6
(word) fill::size
(byte*) fill::start
(byte) fill::val
(byte) fill::val#3 1.8333333333333333
(void()) init()
(word~) init::toD0181_$0
(number~) init::toD0181_$1
(number~) init::toD0181_$2
(number~) init::toD0181_$3
(word~) init::toD0181_$4
(byte~) init::toD0181_$5
(number~) init::toD0181_$6
(number~) init::toD0181_$7
(number~) init::toD0181_$8
(byte*) init::toD0181_gfx
(byte) init::toD0181_return
(byte*) init::toD0181_screen
(void()) init_sprites()
(byte*) level_address
(void()) main()
(byte) main::tile
(byte) main::tile#0 202.0
(byte) main::x
(byte) main::x#1 16.5
(byte) main::x#4 22.4
(byte) main::y
(byte) main::y#1 151.5
(byte) main::y#2 57.714285714285715
(byte) main::z
(byte) main::z#0 202.0
(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
(byte~) mul8u::$1 2002.0
(byte) mul8u::a
(byte) mul8u::a#0 1001.0
(byte) mul8u::a#1 2.0
(byte) mul8u::a#2 667.6666666666667
(byte) mul8u::b
(word) mul8u::mb
(word) mul8u::mb#1 2002.0
(word) mul8u::mb#2 429.0
(word) mul8u::res
(word) mul8u::res#1 2002.0
(word) mul8u::res#2 500.83333333333337
(word) mul8u::res#6 1001.0
(word) mul8u::return
(word) mul8u::return#2 4.0
(byte*) screen
(byte*) tileset

Initial phi equivalence classes
[ main::x#4 main::x#1 ]
[ main::y#2 main::y#1 ]
[ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
[ mul8u::res#2 mul8u::res#6 mul8u::res#1 ]
[ mul8u::mb#2 mul8u::mb#1 ]
[ fill::val#3 ]
[ fill::addr#2 fill::addr#0 fill::addr#1 ]
Added variable main::z#0 to zero page equivalence class [ main::z#0 ]
Added variable main::tile#0 to zero page equivalence class [ main::tile#0 ]
Added variable draw_block::tileno#0 to zero page equivalence class [ draw_block::tileno#0 ]
Added variable draw_block::x#0 to zero page equivalence class [ draw_block::x#0 ]
Added variable draw_block::y#0 to zero page equivalence class [ draw_block::y#0 ]
Added variable draw_block::tileno#1 to zero page equivalence class [ draw_block::tileno#1 ]
Added variable draw_block::x1#0 to zero page equivalence class [ draw_block::x1#0 ]
Added variable draw_block::y#1 to zero page equivalence class [ draw_block::y#1 ]
Added variable mul8u::return#2 to zero page equivalence class [ mul8u::return#2 ]
Added variable draw_block::z#0 to zero page equivalence class [ draw_block::z#0 ]
Added variable draw_block::z#1 to zero page equivalence class [ draw_block::z#1 ]
Added variable draw_block::drawtile#0 to zero page equivalence class [ draw_block::drawtile#0 ]
Added variable draw_block::$11 to zero page equivalence class [ draw_block::$11 ]
Added variable draw_block::$12 to zero page equivalence class [ draw_block::$12 ]
Added variable draw_block::$13 to zero page equivalence class [ draw_block::$13 ]
Added variable draw_block::$14 to zero page equivalence class [ draw_block::$14 ]
Added variable draw_block::$15 to zero page equivalence class [ draw_block::$15 ]
Added variable draw_block::$16 to zero page equivalence class [ draw_block::$16 ]
Added variable draw_block::$17 to zero page equivalence class [ draw_block::$17 ]
Added variable draw_block::$18 to zero page equivalence class [ draw_block::$18 ]
Added variable mul8u::$1 to zero page equivalence class [ mul8u::$1 ]
Added variable fill::end#0 to zero page equivalence class [ fill::end#0 ]
Complete equivalence classes
[ main::x#4 main::x#1 ]
[ main::y#2 main::y#1 ]
[ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
[ mul8u::res#2 mul8u::res#6 mul8u::res#1 ]
[ mul8u::mb#2 mul8u::mb#1 ]
[ fill::val#3 ]
[ fill::addr#2 fill::addr#0 fill::addr#1 ]
[ main::z#0 ]
[ main::tile#0 ]
[ draw_block::tileno#0 ]
[ draw_block::x#0 ]
[ draw_block::y#0 ]
[ draw_block::tileno#1 ]
[ draw_block::x1#0 ]
[ draw_block::y#1 ]
[ mul8u::return#2 ]
[ draw_block::z#0 ]
[ draw_block::z#1 ]
[ draw_block::drawtile#0 ]
[ draw_block::$11 ]
[ draw_block::$12 ]
[ draw_block::$13 ]
[ draw_block::$14 ]
[ draw_block::$15 ]
[ draw_block::$16 ]
[ draw_block::$17 ]
[ draw_block::$18 ]
[ mul8u::$1 ]
[ fill::end#0 ]
Allocated zp ZP_BYTE:2 [ main::x#4 main::x#1 ]
Allocated zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Allocated zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
Allocated zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ]
Allocated zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ]
Allocated zp ZP_BYTE:9 [ fill::val#3 ]
Allocated zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ]
Allocated zp ZP_BYTE:12 [ main::z#0 ]
Allocated zp ZP_BYTE:13 [ main::tile#0 ]
Allocated zp ZP_BYTE:14 [ draw_block::tileno#0 ]
Allocated zp ZP_BYTE:15 [ draw_block::x#0 ]
Allocated zp ZP_BYTE:16 [ draw_block::y#0 ]
Allocated zp ZP_BYTE:17 [ draw_block::tileno#1 ]
Allocated zp ZP_WORD:18 [ draw_block::x1#0 ]
Allocated zp ZP_BYTE:20 [ draw_block::y#1 ]
Allocated zp ZP_WORD:21 [ mul8u::return#2 ]
Allocated zp ZP_WORD:23 [ draw_block::z#0 ]
Allocated zp ZP_WORD:25 [ draw_block::z#1 ]
Allocated zp ZP_BYTE:27 [ draw_block::drawtile#0 ]
Allocated zp ZP_WORD:28 [ draw_block::$11 ]
Allocated zp ZP_WORD:30 [ draw_block::$12 ]
Allocated zp ZP_WORD:32 [ draw_block::$13 ]
Allocated zp ZP_WORD:34 [ draw_block::$14 ]
Allocated zp ZP_WORD:36 [ draw_block::$15 ]
Allocated zp ZP_WORD:38 [ draw_block::$16 ]
Allocated zp ZP_WORD:40 [ draw_block::$17 ]
Allocated zp ZP_WORD:42 [ draw_block::$18 ]
Allocated zp ZP_BYTE:44 [ mul8u::$1 ]
Allocated zp ZP_WORD:45 [ fill::end#0 ]

INITIAL ASM
//SEG0 File Comments
// Illustrates a problem with a missing fragment - pbuc1_derefidx_vwuz1=vbuz2
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XMSB = $d010
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label BORDERCOL = $d020
  .label BGCOL1 = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label BGCOL4 = $d024
  .label SPRITES_COLS = $d027
  .label D018 = $d018
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  .const BLUE = 6
  .const YELLOW = 7
  .label screen = $400
  .label charset = $2000
  .label tileset = $2800
  .label colors = $d800
  .label level_address = $3000
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
    .label z = $c
    .label tile = $d
    .label y = 3
    .label x = 2
  //SEG11 [5] call init 
  //SEG12 [55] phi from main to init [phi:main->init]
  init_from_main:
    jsr init
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG14 [6] phi (byte) main::x#4 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x
    jmp b1
  //SEG15 [6] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  b1_from_b3:
  //SEG16 [6] phi (byte) main::x#4 = (byte) main::x#1 [phi:main::@3->main::@1#0] -- register_copy 
    jmp b1
  //SEG17 main::@1
  b1:
  //SEG18 [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
  //SEG19 [7] phi (byte) main::y#2 = (byte) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    jmp b2
  //SEG20 [7] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  b2_from_b5:
  //SEG21 [7] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@5->main::@2#0] -- register_copy 
    jmp b2
  //SEG22 main::@2
  b2:
  //SEG23 [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 -- vbuz1=vbuz2_plus_vbuz3 
    lda x
    clc
    adc y
    sta z
  //SEG24 [9] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy z
    lda level_address,y
    sta tile
  //SEG25 [10] (byte) draw_block::tileno#0 ← (byte) main::tile#0 -- vbuz1=vbuz2 
    lda tile
    sta draw_block.tileno
  //SEG26 [11] (byte) draw_block::x#0 ← (byte) main::x#4 -- vbuz1=vbuz2 
    lda x
    sta draw_block.x
  //SEG27 [12] (byte) draw_block::y#0 ← (byte) main::y#2 -- vbuz1=vbuz2 
    lda y
    sta draw_block.y
  //SEG28 [13] call draw_block 
    jsr draw_block
    jmp b5
  //SEG29 main::@5
  b5:
  //SEG30 [14] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc y
  //SEG31 [15] if((byte) main::y#1<(byte) 9) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda y
    cmp #9
    bcc b2_from_b5
    jmp b3
  //SEG32 main::@3
  b3:
  //SEG33 [16] (byte) main::x#1 ← ++ (byte) main::x#4 -- vbuz1=_inc_vbuz1 
    inc x
  //SEG34 [17] if((byte) main::x#1<(byte) $10) goto main::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda x
    cmp #$10
    bcc b1_from_b3
  //SEG35 [18] phi from main::@3 main::@4 to main::@4 [phi:main::@3/main::@4->main::@4]
  b4_from_b3:
  b4_from_b4:
    jmp b4
  //SEG36 main::@4
  b4:
    jmp b4_from_b4
}
//SEG37 draw_block
// draw_block(byte zeropage($e) tileno, byte zeropage($f) x, byte zeropage($10) y)
draw_block: {
    .label tileno = $e
    .label x = $f
    .label y = $10
    .label tileno_1 = $11
    .label x1 = $12
    .label y_1 = $14
    .label z = $17
    .label z_1 = $19
    .label drawtile = $1b
    .label _11 = $1c
    .label _12 = $1e
    .label _13 = $20
    .label _14 = $22
    .label _15 = $24
    .label _16 = $26
    .label _17 = $28
    .label _18 = $2a
  //SEG38 [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 -- vbuz1=vbuz2_rol_2 
    lda tileno
    asl
    asl
    sta tileno_1
  //SEG39 [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 -- vwuz1=vbuz2_rol_1 
    lda x
    asl
    sta x1
    lda #0
    rol
    sta x1+1
  //SEG40 [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda y
    asl
    sta y_1
  //SEG41 [22] (byte) mul8u::a#1 ← (byte) draw_block::y#1 -- vbuz1=vbuz2 
    lda y_1
    sta mul8u.a
  //SEG42 [23] call mul8u 
  //SEG43 [45] phi from draw_block to mul8u [phi:draw_block->mul8u]
  mul8u_from_draw_block:
    jsr mul8u
  //SEG44 [24] (word) mul8u::return#2 ← (word) mul8u::res#2 -- vwuz1=vwuz2 
    lda mul8u.res
    sta mul8u.return
    lda mul8u.res+1
    sta mul8u.return+1
    jmp b1
  //SEG45 draw_block::@1
  b1:
  //SEG46 [25] (word) draw_block::z#0 ← (word) mul8u::return#2 -- vwuz1=vwuz2 
    lda mul8u.return
    sta z
    lda mul8u.return+1
    sta z+1
  //SEG47 [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 -- vwuz1=vwuz2_plus_vwuz3 
    lda z
    clc
    adc x1
    sta z_1
    lda z+1
    adc x1+1
    sta z_1+1
  //SEG48 [27] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy tileno_1
    lda tileset,y
    sta drawtile
  //SEG49 [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen
    sta _11
    lda z_1+1
    adc #>screen
    sta _11+1
  //SEG50 [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 -- _deref_pbuz1=vbuz2 
    lda drawtile
    ldy #0
    sta (_11),y
  //SEG51 [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors
    sta _12
    lda z_1+1
    adc #>colors
    sta _12+1
  //SEG52 [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_12),y
  //SEG53 [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen+1
    sta _13
    lda z_1+1
    adc #>screen+1
    sta _13+1
  //SEG54 [33] *((byte*~) draw_block::$13) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (_13),y
  //SEG55 [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors+1
    sta _14
    lda z_1+1
    adc #>colors+1
    sta _14+1
  //SEG56 [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_14),y
  //SEG57 [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen+$28
    sta _15
    lda z_1+1
    adc #>screen+$28
    sta _15+1
  //SEG58 [37] *((byte*~) draw_block::$15) ← (byte) 2 -- _deref_pbuz1=vbuc1 
    lda #2
    ldy #0
    sta (_15),y
  //SEG59 [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors+$28
    sta _16
    lda z_1+1
    adc #>colors+$28
    sta _16+1
  //SEG60 [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_16),y
  //SEG61 [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen+$29
    sta _17
    lda z_1+1
    adc #>screen+$29
    sta _17+1
  //SEG62 [41] *((byte*~) draw_block::$17) ← (byte) 3 -- _deref_pbuz1=vbuc1 
    lda #3
    ldy #0
    sta (_17),y
  //SEG63 [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors+$29
    sta _18
    lda z_1+1
    adc #>colors+$29
    sta _18+1
  //SEG64 [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_18),y
    jmp breturn
  //SEG65 draw_block::@return
  breturn:
  //SEG66 [44] return 
    rts
}
//SEG67 mul8u
// Perform binary multiplication of two unsigned 8-bit bytes into a 16-bit unsigned word
// mul8u(byte zeropage(4) a)
mul8u: {
    .const b = $28
    .label _1 = $2c
    .label a = 4
    .label mb = 7
    .label res = 5
    .label return = $15
  //SEG68 [46] phi from mul8u to mul8u::@1 [phi:mul8u->mul8u::@1]
  b1_from_mul8u:
  //SEG69 [46] phi (word) mul8u::mb#2 = (const byte) mul8u::b#0 [phi:mul8u->mul8u::@1#0] -- vwuz1=vbuc1 
    lda #b
    sta mb
    lda #0
    sta mb+1
  //SEG70 [46] phi (word) mul8u::res#2 = (byte) 0 [phi:mul8u->mul8u::@1#1] -- vwuz1=vbuc1 
    lda #0
    sta res
    lda #0
    sta res+1
  //SEG71 [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#1 [phi:mul8u->mul8u::@1#2] -- register_copy 
    jmp b1
  //SEG72 mul8u::@1
  b1:
  //SEG73 [47] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2 -- vbuz1_neq_0_then_la1 
    lda a
    cmp #0
    bne b2
    jmp breturn
  //SEG74 mul8u::@return
  breturn:
  //SEG75 [48] return 
    rts
  //SEG76 mul8u::@2
  b2:
  //SEG77 [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and a
    sta _1
  //SEG78 [50] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@3 -- vbuz1_eq_0_then_la1 
    lda _1
    cmp #0
    beq b3_from_b2
    jmp b4
  //SEG79 mul8u::@4
  b4:
  //SEG80 [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 -- vwuz1=vwuz1_plus_vwuz2 
    lda res
    clc
    adc mb
    sta res
    lda res+1
    adc mb+1
    sta res+1
  //SEG81 [52] phi from mul8u::@2 mul8u::@4 to mul8u::@3 [phi:mul8u::@2/mul8u::@4->mul8u::@3]
  b3_from_b2:
  b3_from_b4:
  //SEG82 [52] phi (word) mul8u::res#6 = (word) mul8u::res#2 [phi:mul8u::@2/mul8u::@4->mul8u::@3#0] -- register_copy 
    jmp b3
  //SEG83 mul8u::@3
  b3:
  //SEG84 [53] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr a
  //SEG85 [54] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl mb
    rol mb+1
  //SEG86 [46] phi from mul8u::@3 to mul8u::@1 [phi:mul8u::@3->mul8u::@1]
  b1_from_b3:
  //SEG87 [46] phi (word) mul8u::mb#2 = (word) mul8u::mb#1 [phi:mul8u::@3->mul8u::@1#0] -- register_copy 
  //SEG88 [46] phi (word) mul8u::res#2 = (word) mul8u::res#6 [phi:mul8u::@3->mul8u::@1#1] -- register_copy 
  //SEG89 [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#0 [phi:mul8u::@3->mul8u::@1#2] -- register_copy 
    jmp b1
}
//SEG90 init
init: {
    .const toD0181_return = (>(screen&$3fff)*4)|(>charset)/4&$f
  //SEG91 [56] call init_sprites 
    jsr init_sprites
  //SEG92 [57] phi from init to init::@2 [phi:init->init::@2]
  b2_from_init:
    jmp b2
  //SEG93 init::@2
  b2:
  //SEG94 [58] call fill 
  //SEG95 [70] phi from init::@2 to fill [phi:init::@2->fill]
  fill_from_b2:
  //SEG96 [70] phi (byte) fill::val#3 = (byte) 0 [phi:init::@2->fill#0] -- vbuz1=vbuc1 
    lda #0
    sta fill.val
  //SEG97 [70] phi (byte*) fill::addr#0 = (const byte*) screen#0 [phi:init::@2->fill#1] -- pbuz1=pbuc1 
    lda #<screen
    sta fill.addr
    lda #>screen
    sta fill.addr+1
    jsr fill
  //SEG98 [59] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
    jmp b3
  //SEG99 init::@3
  b3:
  //SEG100 [60] call fill 
  //SEG101 [70] phi from init::@3 to fill [phi:init::@3->fill]
  fill_from_b3:
  //SEG102 [70] phi (byte) fill::val#3 = (const byte) BLACK#0 [phi:init::@3->fill#0] -- vbuz1=vbuc1 
    lda #BLACK
    sta fill.val
  //SEG103 [70] phi (byte*) fill::addr#0 = (const byte*) colors#0 [phi:init::@3->fill#1] -- pbuz1=pbuc1 
    lda #<colors
    sta fill.addr
    lda #>colors
    sta fill.addr+1
    jsr fill
  //SEG104 [61] phi from init::@3 to init::toD0181 [phi:init::@3->init::toD0181]
  toD0181_from_b3:
    jmp toD0181
  //SEG105 init::toD0181
  toD0181:
    jmp b1
  //SEG106 init::@1
  b1:
  //SEG107 [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG108 asm { lda#$5b sta$d011  }
    lda #$5b
    sta $d011
  //SEG109 [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG110 [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BGCOL1
  //SEG111 [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BGCOL2
  //SEG112 [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL3
  //SEG113 [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL4
    jmp breturn
  //SEG114 init::@return
  breturn:
  //SEG115 [69] return 
    rts
}
//SEG116 fill
// Fill some memory with a value
// fill(byte zeropage(9) val)
fill: {
    .label end = $2d
    .label addr = $a
    .label val = 9
  //SEG117 [71] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda addr
    clc
    adc #<$3e8
    sta end
    lda addr+1
    adc #>$3e8
    sta end+1
  //SEG118 [72] phi from fill fill::@1 to fill::@1 [phi:fill/fill::@1->fill::@1]
  b1_from_fill:
  b1_from_b1:
  //SEG119 [72] phi (byte*) fill::addr#2 = (byte*) fill::addr#0 [phi:fill/fill::@1->fill::@1#0] -- register_copy 
    jmp b1
  //SEG120 fill::@1
  b1:
  //SEG121 [73] *((byte*) fill::addr#2) ← (byte) fill::val#3 -- _deref_pbuz1=vbuz2 
    lda val
    ldy #0
    sta (addr),y
  //SEG122 [74] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 -- pbuz1=_inc_pbuz1 
    inc addr
    bne !+
    inc addr+1
  !:
  //SEG123 [75] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 -- pbuz1_neq_pbuz2_then_la1 
    lda addr+1
    cmp end+1
    bne b1_from_b1
    lda addr
    cmp end
    bne b1_from_b1
    jmp breturn
  //SEG124 fill::@return
  breturn:
  //SEG125 [76] return 
    rts
}
//SEG126 init_sprites
init_sprites: {
  //SEG127 [77] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta SPRITES_ENABLE
  //SEG128 [78] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // one sprite enabled
    lda #0
    sta SPRITES_EXPAND_X
  //SEG129 [79] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_EXPAND_Y
  //SEG130 [80] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_XMSB
  //SEG131 [81] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta SPRITES_COLS
  //SEG132 [82] *((const byte*) SPRITES_MC#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    jmp breturn
  //SEG133 init_sprites::@return
  breturn:
  //SEG134 [83] return 
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 [ main::x#4 main::y#2 main::z#0 ] ( main:2 [ main::x#4 main::y#2 main::z#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::x#4 main::x#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Statement [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 [ draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:15 [ draw_block::x#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:16 [ draw_block::y#0 ]
Statement [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 [ draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:17 [ draw_block::tileno#1 ]
Statement [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 [ draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ) always clobbers reg byte a 
Statement [24] (word) mul8u::return#2 ← (word) mul8u::res#2 [ draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ) always clobbers reg byte a 
Statement [25] (word) draw_block::z#0 ← (word) mul8u::return#2 [ draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ) always clobbers reg byte a 
Statement [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 [ draw_block::tileno#1 draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::drawtile#0 draw_block::$11 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::drawtile#0 draw_block::$11 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:27 [ draw_block::drawtile#0 ]
Statement [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:2 [ main::x#4 main::x#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Statement [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$12 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$12 ] ) always clobbers reg byte a 
Statement [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$13 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$13 ] ) always clobbers reg byte a 
Statement [33] *((byte*~) draw_block::$13) ← (byte) 1 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$14 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$14 ] ) always clobbers reg byte a 
Statement [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$15 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$15 ] ) always clobbers reg byte a 
Statement [37] *((byte*~) draw_block::$15) ← (byte) 2 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$16 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$16 ] ) always clobbers reg byte a 
Statement [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$17 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$17 ] ) always clobbers reg byte a 
Statement [41] *((byte*~) draw_block::$17) ← (byte) 3 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 [ draw_block::$18 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::$18 ] ) always clobbers reg byte a 
Statement [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 [ ] ( main:2::draw_block:13 [ main::x#4 main::y#2 ] ) always clobbers reg byte a reg byte y 
Statement [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 [ mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ( main:2::draw_block:13::mul8u:23 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
Statement [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement asm { lda#$5b sta$d011  } always clobbers reg byte a 
Statement [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [71] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) $3e8 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::init:5::fill:58 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::init:5::fill:60 [ fill::addr#0 fill::val#3 fill::end#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ fill::val#3 ]
Statement [73] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::init:5::fill:58 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::init:5::fill:60 [ fill::val#3 fill::end#0 fill::addr#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:9 [ fill::val#3 ]
Statement [75] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::init:5::fill:58 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::init:5::fill:60 [ fill::val#3 fill::end#0 fill::addr#1 ] ) always clobbers reg byte a 
Statement [77] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [78] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [79] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [80] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [81] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [82] *((const byte*) SPRITES_MC#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 [ main::x#4 main::y#2 main::z#0 ] ( main:2 [ main::x#4 main::y#2 main::z#0 ] ) always clobbers reg byte a 
Statement [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 [ draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::x#0 draw_block::y#0 draw_block::tileno#1 ] ) always clobbers reg byte a 
Statement [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 [ draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::y#0 draw_block::tileno#1 draw_block::x1#0 ] ) always clobbers reg byte a 
Statement [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 [ draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::y#1 ] ) always clobbers reg byte a 
Statement [24] (word) mul8u::return#2 ← (word) mul8u::res#2 [ draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::return#2 ] ) always clobbers reg byte a 
Statement [25] (word) draw_block::z#0 ← (word) mul8u::return#2 [ draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 draw_block::z#0 ] ) always clobbers reg byte a 
Statement [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 [ draw_block::tileno#1 draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::z#1 ] ) always clobbers reg byte a 
Statement [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::drawtile#0 draw_block::$11 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::drawtile#0 draw_block::$11 ] ) always clobbers reg byte a 
Statement [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$12 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$12 ] ) always clobbers reg byte a 
Statement [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$13 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$13 ] ) always clobbers reg byte a 
Statement [33] *((byte*~) draw_block::$13) ← (byte) 1 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$14 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$14 ] ) always clobbers reg byte a 
Statement [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$15 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$15 ] ) always clobbers reg byte a 
Statement [37] *((byte*~) draw_block::$15) ← (byte) 2 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$16 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$16 ] ) always clobbers reg byte a 
Statement [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 [ draw_block::z#1 draw_block::$17 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 draw_block::$17 ] ) always clobbers reg byte a 
Statement [41] *((byte*~) draw_block::$17) ← (byte) 3 [ draw_block::z#1 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::z#1 ] ) always clobbers reg byte a reg byte y 
Statement [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 [ draw_block::$18 ] ( main:2::draw_block:13 [ main::x#4 main::y#2 draw_block::$18 ] ) always clobbers reg byte a 
Statement [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 [ ] ( main:2::draw_block:13 [ main::x#4 main::y#2 ] ) always clobbers reg byte a reg byte y 
Statement [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1 [ mul8u::res#2 mul8u::a#2 mul8u::mb#2 mul8u::$1 ] ( main:2::draw_block:13::mul8u:23 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::res#2 mul8u::a#2 mul8u::mb#2 mul8u::$1 ] ) always clobbers reg byte a 
Statement [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 [ mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ( main:2::draw_block:13::mul8u:23 [ main::x#4 main::y#2 draw_block::tileno#1 draw_block::x1#0 mul8u::a#2 mul8u::mb#2 mul8u::res#1 ] ) always clobbers reg byte a 
Statement [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement asm { lda#$5b sta$d011  } always clobbers reg byte a 
Statement [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 [ ] ( main:2::init:5 [ ] ) always clobbers reg byte a 
Statement [71] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) $3e8 [ fill::addr#0 fill::val#3 fill::end#0 ] ( main:2::init:5::fill:58 [ fill::addr#0 fill::val#3 fill::end#0 ] main:2::init:5::fill:60 [ fill::addr#0 fill::val#3 fill::end#0 ] ) always clobbers reg byte a 
Statement [73] *((byte*) fill::addr#2) ← (byte) fill::val#3 [ fill::val#3 fill::end#0 fill::addr#2 ] ( main:2::init:5::fill:58 [ fill::val#3 fill::end#0 fill::addr#2 ] main:2::init:5::fill:60 [ fill::val#3 fill::end#0 fill::addr#2 ] ) always clobbers reg byte a reg byte y 
Statement [75] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 [ fill::val#3 fill::end#0 fill::addr#1 ] ( main:2::init:5::fill:58 [ fill::val#3 fill::end#0 fill::addr#1 ] main:2::init:5::fill:60 [ fill::val#3 fill::end#0 fill::addr#1 ] ) always clobbers reg byte a 
Statement [77] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [78] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [79] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [80] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [81] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Statement [82] *((const byte*) SPRITES_MC#0) ← (byte) 0 [ ] ( main:2::init:5::init_sprites:56 [ ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::x#4 main::x#1 ] : zp ZP_BYTE:2 , reg byte x , 
Potential registers zp ZP_BYTE:3 [ main::y#2 main::y#1 ] : zp ZP_BYTE:3 , reg byte x , 
Potential registers zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] : zp ZP_WORD:5 , 
Potential registers zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] : zp ZP_WORD:7 , 
Potential registers zp ZP_BYTE:9 [ fill::val#3 ] : zp ZP_BYTE:9 , reg byte x , 
Potential registers zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ] : zp ZP_WORD:10 , 
Potential registers zp ZP_BYTE:12 [ main::z#0 ] : zp ZP_BYTE:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ main::tile#0 ] : zp ZP_BYTE:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:14 [ draw_block::tileno#0 ] : zp ZP_BYTE:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:15 [ draw_block::x#0 ] : zp ZP_BYTE:15 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:16 [ draw_block::y#0 ] : zp ZP_BYTE:16 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:17 [ draw_block::tileno#1 ] : zp ZP_BYTE:17 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:18 [ draw_block::x1#0 ] : zp ZP_WORD:18 , 
Potential registers zp ZP_BYTE:20 [ draw_block::y#1 ] : zp ZP_BYTE:20 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:21 [ mul8u::return#2 ] : zp ZP_WORD:21 , 
Potential registers zp ZP_WORD:23 [ draw_block::z#0 ] : zp ZP_WORD:23 , 
Potential registers zp ZP_WORD:25 [ draw_block::z#1 ] : zp ZP_WORD:25 , 
Potential registers zp ZP_BYTE:27 [ draw_block::drawtile#0 ] : zp ZP_BYTE:27 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:28 [ draw_block::$11 ] : zp ZP_WORD:28 , 
Potential registers zp ZP_WORD:30 [ draw_block::$12 ] : zp ZP_WORD:30 , 
Potential registers zp ZP_WORD:32 [ draw_block::$13 ] : zp ZP_WORD:32 , 
Potential registers zp ZP_WORD:34 [ draw_block::$14 ] : zp ZP_WORD:34 , 
Potential registers zp ZP_WORD:36 [ draw_block::$15 ] : zp ZP_WORD:36 , 
Potential registers zp ZP_WORD:38 [ draw_block::$16 ] : zp ZP_WORD:38 , 
Potential registers zp ZP_WORD:40 [ draw_block::$17 ] : zp ZP_WORD:40 , 
Potential registers zp ZP_WORD:42 [ draw_block::$18 ] : zp ZP_WORD:42 , 
Potential registers zp ZP_BYTE:44 [ mul8u::$1 ] : zp ZP_BYTE:44 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:45 [ fill::end#0 ] : zp ZP_WORD:45 , 

REGISTER UPLIFT SCOPES
Uplift Scope [mul8u] 3,503.83: zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] 2,431: zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] 2,002: zp ZP_BYTE:44 [ mul8u::$1 ] 1,670.67: zp ZP_BYTE:4 [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ] 4: zp ZP_WORD:21 [ mul8u::return#2 ] 
Uplift Scope [main] 209.21: zp ZP_BYTE:3 [ main::y#2 main::y#1 ] 202: zp ZP_BYTE:12 [ main::z#0 ] 202: zp ZP_BYTE:13 [ main::tile#0 ] 38.9: zp ZP_BYTE:2 [ main::x#4 main::x#1 ] 
Uplift Scope [draw_block] 34.33: zp ZP_BYTE:14 [ draw_block::tileno#0 ] 34.33: zp ZP_BYTE:15 [ draw_block::x#0 ] 34.33: zp ZP_BYTE:16 [ draw_block::y#0 ] 4: zp ZP_BYTE:20 [ draw_block::y#1 ] 4: zp ZP_WORD:23 [ draw_block::z#0 ] 4: zp ZP_WORD:28 [ draw_block::$11 ] 4: zp ZP_WORD:30 [ draw_block::$12 ] 4: zp ZP_WORD:32 [ draw_block::$13 ] 4: zp ZP_WORD:34 [ draw_block::$14 ] 4: zp ZP_WORD:36 [ draw_block::$15 ] 4: zp ZP_WORD:38 [ draw_block::$16 ] 4: zp ZP_WORD:40 [ draw_block::$17 ] 4: zp ZP_WORD:42 [ draw_block::$18 ] 2: zp ZP_BYTE:27 [ draw_block::drawtile#0 ] 1.12: zp ZP_WORD:25 [ draw_block::z#1 ] 0.67: zp ZP_WORD:18 [ draw_block::x1#0 ] 0.5: zp ZP_BYTE:17 [ draw_block::tileno#1 ] 
Uplift Scope [fill] 36: zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ] 2.6: zp ZP_WORD:45 [ fill::end#0 ] 1.83: zp ZP_BYTE:9 [ fill::val#3 ] 
Uplift Scope [init] 
Uplift Scope [init_sprites] 
Uplift Scope [] 

Uplifting [mul8u] best 92824 combination zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] reg byte a [ mul8u::$1 ] reg byte x [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ] zp ZP_WORD:21 [ mul8u::return#2 ] 
Uplifting [main] best 91824 combination zp ZP_BYTE:3 [ main::y#2 main::y#1 ] reg byte a [ main::z#0 ] reg byte a [ main::tile#0 ] zp ZP_BYTE:2 [ main::x#4 main::x#1 ] 
Uplifting [draw_block] best 90915 combination reg byte a [ draw_block::tileno#0 ] reg byte y [ draw_block::x#0 ] reg byte x [ draw_block::y#0 ] reg byte a [ draw_block::y#1 ] zp ZP_WORD:23 [ draw_block::z#0 ] zp ZP_WORD:28 [ draw_block::$11 ] zp ZP_WORD:30 [ draw_block::$12 ] zp ZP_WORD:32 [ draw_block::$13 ] zp ZP_WORD:34 [ draw_block::$14 ] zp ZP_WORD:36 [ draw_block::$15 ] zp ZP_WORD:38 [ draw_block::$16 ] zp ZP_WORD:40 [ draw_block::$17 ] zp ZP_WORD:42 [ draw_block::$18 ] zp ZP_BYTE:27 [ draw_block::drawtile#0 ] zp ZP_WORD:25 [ draw_block::z#1 ] zp ZP_WORD:18 [ draw_block::x1#0 ] zp ZP_BYTE:17 [ draw_block::tileno#1 ] 
Limited combination testing to 100 combinations of 1296 possible.
Uplifting [fill] best 90899 combination zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ] zp ZP_WORD:45 [ fill::end#0 ] reg byte x [ fill::val#3 ] 
Uplifting [init] best 90899 combination 
Uplifting [init_sprites] best 90899 combination 
Uplifting [] best 90899 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ main::y#2 main::y#1 ]
Uplifting [main] best 90899 combination zp ZP_BYTE:3 [ main::y#2 main::y#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ main::x#4 main::x#1 ]
Uplifting [main] best 90899 combination zp ZP_BYTE:2 [ main::x#4 main::x#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:27 [ draw_block::drawtile#0 ]
Uplifting [draw_block] best 90895 combination reg byte x [ draw_block::drawtile#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:17 [ draw_block::tileno#1 ]
Uplifting [draw_block] best 90895 combination zp ZP_BYTE:17 [ draw_block::tileno#1 ] 
Coalescing zero page register with common assignment [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 ] ] with [ zp ZP_WORD:21 [ mul8u::return#2 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:18 [ draw_block::x1#0 ] ] with [ zp ZP_WORD:25 [ draw_block::z#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 ] ] with [ zp ZP_WORD:23 [ draw_block::z#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:18 [ draw_block::x1#0 draw_block::z#1 ] ] with [ zp ZP_WORD:42 [ draw_block::$18 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 ] ] with [ zp ZP_WORD:10 [ fill::addr#2 fill::addr#0 fill::addr#1 ] ]
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 ] ] with [ zp ZP_WORD:28 [ draw_block::$11 ] ]
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 draw_block::$11 ] ] with [ zp ZP_WORD:30 [ draw_block::$12 ] ]
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 draw_block::$11 draw_block::$12 ] ] with [ zp ZP_WORD:32 [ draw_block::$13 ] ]
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 draw_block::$11 draw_block::$12 draw_block::$13 ] ] with [ zp ZP_WORD:34 [ draw_block::$14 ] ]
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 draw_block::$11 draw_block::$12 draw_block::$13 draw_block::$14 ] ] with [ zp ZP_WORD:36 [ draw_block::$15 ] ]
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 draw_block::$11 draw_block::$12 draw_block::$13 draw_block::$14 draw_block::$15 ] ] with [ zp ZP_WORD:38 [ draw_block::$16 ] ]
Coalescing zero page register [ zp ZP_WORD:5 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 draw_block::$11 draw_block::$12 draw_block::$13 draw_block::$14 draw_block::$15 draw_block::$16 ] ] with [ zp ZP_WORD:40 [ draw_block::$17 ] ]
Coalescing zero page register [ zp ZP_WORD:7 [ mul8u::mb#2 mul8u::mb#1 ] ] with [ zp ZP_WORD:45 [ fill::end#0 ] ]
Allocated (was zp ZP_WORD:5) zp ZP_WORD:4 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 draw_block::$11 draw_block::$12 draw_block::$13 draw_block::$14 draw_block::$15 draw_block::$16 draw_block::$17 ]
Allocated (was zp ZP_WORD:7) zp ZP_WORD:6 [ mul8u::mb#2 mul8u::mb#1 fill::end#0 ]
Allocated (was zp ZP_BYTE:17) zp ZP_BYTE:8 [ draw_block::tileno#1 ]
Allocated (was zp ZP_WORD:18) zp ZP_WORD:9 [ draw_block::x1#0 draw_block::z#1 draw_block::$18 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Illustrates a problem with a missing fragment - pbuc1_derefidx_vwuz1=vbuz2
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XMSB = $d010
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label BORDERCOL = $d020
  .label BGCOL1 = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label BGCOL4 = $d024
  .label SPRITES_COLS = $d027
  .label D018 = $d018
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  .const BLUE = 6
  .const YELLOW = 7
  .label screen = $400
  .label charset = $2000
  .label tileset = $2800
  .label colors = $d800
  .label level_address = $3000
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
    .label y = 3
    .label x = 2
  //SEG11 [5] call init 
  //SEG12 [55] phi from main to init [phi:main->init]
  init_from_main:
    jsr init
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG14 [6] phi (byte) main::x#4 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x
    jmp b1
  //SEG15 [6] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  b1_from_b3:
  //SEG16 [6] phi (byte) main::x#4 = (byte) main::x#1 [phi:main::@3->main::@1#0] -- register_copy 
    jmp b1
  //SEG17 main::@1
  b1:
  //SEG18 [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
  //SEG19 [7] phi (byte) main::y#2 = (byte) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta y
    jmp b2
  //SEG20 [7] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  b2_from_b5:
  //SEG21 [7] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@5->main::@2#0] -- register_copy 
    jmp b2
  //SEG22 main::@2
  b2:
  //SEG23 [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 -- vbuaa=vbuz1_plus_vbuz2 
    lda x
    clc
    adc y
  //SEG24 [9] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0) -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda level_address,y
  //SEG25 [10] (byte) draw_block::tileno#0 ← (byte) main::tile#0
  //SEG26 [11] (byte) draw_block::x#0 ← (byte) main::x#4 -- vbuyy=vbuz1 
    ldy x
  //SEG27 [12] (byte) draw_block::y#0 ← (byte) main::y#2 -- vbuxx=vbuz1 
    ldx y
  //SEG28 [13] call draw_block 
    jsr draw_block
    jmp b5
  //SEG29 main::@5
  b5:
  //SEG30 [14] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc y
  //SEG31 [15] if((byte) main::y#1<(byte) 9) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda y
    cmp #9
    bcc b2_from_b5
    jmp b3
  //SEG32 main::@3
  b3:
  //SEG33 [16] (byte) main::x#1 ← ++ (byte) main::x#4 -- vbuz1=_inc_vbuz1 
    inc x
  //SEG34 [17] if((byte) main::x#1<(byte) $10) goto main::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda x
    cmp #$10
    bcc b1_from_b3
  //SEG35 [18] phi from main::@3 main::@4 to main::@4 [phi:main::@3/main::@4->main::@4]
  b4_from_b3:
  b4_from_b4:
    jmp b4
  //SEG36 main::@4
  b4:
    jmp b4_from_b4
}
//SEG37 draw_block
// draw_block(byte register(A) tileno, byte register(Y) x, byte register(X) y)
draw_block: {
    .label tileno = 8
    .label x1 = 9
    .label z = 4
    .label z_1 = 9
    .label _11 = 4
    .label _12 = 4
    .label _13 = 4
    .label _14 = 4
    .label _15 = 4
    .label _16 = 4
    .label _17 = 4
    .label _18 = 9
  //SEG38 [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 -- vbuz1=vbuaa_rol_2 
    asl
    asl
    sta tileno
  //SEG39 [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 -- vwuz1=vbuyy_rol_1 
    tya
    asl
    sta x1
    lda #0
    rol
    sta x1+1
  //SEG40 [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG41 [22] (byte) mul8u::a#1 ← (byte) draw_block::y#1 -- vbuxx=vbuaa 
    tax
  //SEG42 [23] call mul8u 
  //SEG43 [45] phi from draw_block to mul8u [phi:draw_block->mul8u]
  mul8u_from_draw_block:
    jsr mul8u
  //SEG44 [24] (word) mul8u::return#2 ← (word) mul8u::res#2
    jmp b1
  //SEG45 draw_block::@1
  b1:
  //SEG46 [25] (word) draw_block::z#0 ← (word) mul8u::return#2
  //SEG47 [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 -- vwuz1=vwuz2_plus_vwuz1 
    lda z_1
    clc
    adc z
    sta z_1
    lda z_1+1
    adc z+1
    sta z_1+1
  //SEG48 [27] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy tileno
    ldx tileset,y
  //SEG49 [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen
    sta _11
    lda z_1+1
    adc #>screen
    sta _11+1
  //SEG50 [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (_11),y
  //SEG51 [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors
    sta _12
    lda z_1+1
    adc #>colors
    sta _12+1
  //SEG52 [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_12),y
  //SEG53 [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen+1
    sta _13
    lda z_1+1
    adc #>screen+1
    sta _13+1
  //SEG54 [33] *((byte*~) draw_block::$13) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (_13),y
  //SEG55 [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors+1
    sta _14
    lda z_1+1
    adc #>colors+1
    sta _14+1
  //SEG56 [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_14),y
  //SEG57 [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen+$28
    sta _15
    lda z_1+1
    adc #>screen+$28
    sta _15+1
  //SEG58 [37] *((byte*~) draw_block::$15) ← (byte) 2 -- _deref_pbuz1=vbuc1 
    lda #2
    ldy #0
    sta (_15),y
  //SEG59 [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors+$28
    sta _16
    lda z_1+1
    adc #>colors+$28
    sta _16+1
  //SEG60 [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_16),y
  //SEG61 [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen+$29
    sta _17
    lda z_1+1
    adc #>screen+$29
    sta _17+1
  //SEG62 [41] *((byte*~) draw_block::$17) ← (byte) 3 -- _deref_pbuz1=vbuc1 
    lda #3
    ldy #0
    sta (_17),y
  //SEG63 [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda _18
    adc #<colors+$29
    sta _18
    lda _18+1
    adc #>colors+$29
    sta _18+1
  //SEG64 [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    ldy #0
    sta (_18),y
    jmp breturn
  //SEG65 draw_block::@return
  breturn:
  //SEG66 [44] return 
    rts
}
//SEG67 mul8u
// Perform binary multiplication of two unsigned 8-bit bytes into a 16-bit unsigned word
// mul8u(byte register(X) a)
mul8u: {
    .const b = $28
    .label mb = 6
    .label res = 4
    .label return = 4
  //SEG68 [46] phi from mul8u to mul8u::@1 [phi:mul8u->mul8u::@1]
  b1_from_mul8u:
  //SEG69 [46] phi (word) mul8u::mb#2 = (const byte) mul8u::b#0 [phi:mul8u->mul8u::@1#0] -- vwuz1=vbuc1 
    lda #b
    sta mb
    lda #0
    sta mb+1
  //SEG70 [46] phi (word) mul8u::res#2 = (byte) 0 [phi:mul8u->mul8u::@1#1] -- vwuz1=vbuc1 
    lda #0
    sta res
    lda #0
    sta res+1
  //SEG71 [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#1 [phi:mul8u->mul8u::@1#2] -- register_copy 
    jmp b1
  //SEG72 mul8u::@1
  b1:
  //SEG73 [47] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b2
    jmp breturn
  //SEG74 mul8u::@return
  breturn:
  //SEG75 [48] return 
    rts
  //SEG76 mul8u::@2
  b2:
  //SEG77 [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
  //SEG78 [50] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b3_from_b2
    jmp b4
  //SEG79 mul8u::@4
  b4:
  //SEG80 [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 -- vwuz1=vwuz1_plus_vwuz2 
    lda res
    clc
    adc mb
    sta res
    lda res+1
    adc mb+1
    sta res+1
  //SEG81 [52] phi from mul8u::@2 mul8u::@4 to mul8u::@3 [phi:mul8u::@2/mul8u::@4->mul8u::@3]
  b3_from_b2:
  b3_from_b4:
  //SEG82 [52] phi (word) mul8u::res#6 = (word) mul8u::res#2 [phi:mul8u::@2/mul8u::@4->mul8u::@3#0] -- register_copy 
    jmp b3
  //SEG83 mul8u::@3
  b3:
  //SEG84 [53] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte) 1 -- vbuxx=vbuxx_ror_1 
    txa
    lsr
    tax
  //SEG85 [54] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl mb
    rol mb+1
  //SEG86 [46] phi from mul8u::@3 to mul8u::@1 [phi:mul8u::@3->mul8u::@1]
  b1_from_b3:
  //SEG87 [46] phi (word) mul8u::mb#2 = (word) mul8u::mb#1 [phi:mul8u::@3->mul8u::@1#0] -- register_copy 
  //SEG88 [46] phi (word) mul8u::res#2 = (word) mul8u::res#6 [phi:mul8u::@3->mul8u::@1#1] -- register_copy 
  //SEG89 [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#0 [phi:mul8u::@3->mul8u::@1#2] -- register_copy 
    jmp b1
}
//SEG90 init
init: {
    .const toD0181_return = (>(screen&$3fff)*4)|(>charset)/4&$f
  //SEG91 [56] call init_sprites 
    jsr init_sprites
  //SEG92 [57] phi from init to init::@2 [phi:init->init::@2]
  b2_from_init:
    jmp b2
  //SEG93 init::@2
  b2:
  //SEG94 [58] call fill 
  //SEG95 [70] phi from init::@2 to fill [phi:init::@2->fill]
  fill_from_b2:
  //SEG96 [70] phi (byte) fill::val#3 = (byte) 0 [phi:init::@2->fill#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG97 [70] phi (byte*) fill::addr#0 = (const byte*) screen#0 [phi:init::@2->fill#1] -- pbuz1=pbuc1 
    lda #<screen
    sta fill.addr
    lda #>screen
    sta fill.addr+1
    jsr fill
  //SEG98 [59] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
    jmp b3
  //SEG99 init::@3
  b3:
  //SEG100 [60] call fill 
  //SEG101 [70] phi from init::@3 to fill [phi:init::@3->fill]
  fill_from_b3:
  //SEG102 [70] phi (byte) fill::val#3 = (const byte) BLACK#0 [phi:init::@3->fill#0] -- vbuxx=vbuc1 
    ldx #BLACK
  //SEG103 [70] phi (byte*) fill::addr#0 = (const byte*) colors#0 [phi:init::@3->fill#1] -- pbuz1=pbuc1 
    lda #<colors
    sta fill.addr
    lda #>colors
    sta fill.addr+1
    jsr fill
  //SEG104 [61] phi from init::@3 to init::toD0181 [phi:init::@3->init::toD0181]
  toD0181_from_b3:
    jmp toD0181
  //SEG105 init::toD0181
  toD0181:
    jmp b1
  //SEG106 init::@1
  b1:
  //SEG107 [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG108 asm { lda#$5b sta$d011  }
    lda #$5b
    sta $d011
  //SEG109 [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG110 [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BGCOL1
  //SEG111 [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BGCOL2
  //SEG112 [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL3
  //SEG113 [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL4
    jmp breturn
  //SEG114 init::@return
  breturn:
  //SEG115 [69] return 
    rts
}
//SEG116 fill
// Fill some memory with a value
// fill(byte register(X) val)
fill: {
    .label end = 6
    .label addr = 4
  //SEG117 [71] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda addr
    clc
    adc #<$3e8
    sta end
    lda addr+1
    adc #>$3e8
    sta end+1
  //SEG118 [72] phi from fill fill::@1 to fill::@1 [phi:fill/fill::@1->fill::@1]
  b1_from_fill:
  b1_from_b1:
  //SEG119 [72] phi (byte*) fill::addr#2 = (byte*) fill::addr#0 [phi:fill/fill::@1->fill::@1#0] -- register_copy 
    jmp b1
  //SEG120 fill::@1
  b1:
  //SEG121 [73] *((byte*) fill::addr#2) ← (byte) fill::val#3 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (addr),y
  //SEG122 [74] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 -- pbuz1=_inc_pbuz1 
    inc addr
    bne !+
    inc addr+1
  !:
  //SEG123 [75] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 -- pbuz1_neq_pbuz2_then_la1 
    lda addr+1
    cmp end+1
    bne b1_from_b1
    lda addr
    cmp end
    bne b1_from_b1
    jmp breturn
  //SEG124 fill::@return
  breturn:
  //SEG125 [76] return 
    rts
}
//SEG126 init_sprites
init_sprites: {
  //SEG127 [77] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta SPRITES_ENABLE
  //SEG128 [78] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // one sprite enabled
    lda #0
    sta SPRITES_EXPAND_X
  //SEG129 [79] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_EXPAND_Y
  //SEG130 [80] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_XMSB
  //SEG131 [81] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta SPRITES_COLS
  //SEG132 [82] *((const byte*) SPRITES_MC#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
    jmp breturn
  //SEG133 init_sprites::@return
  breturn:
  //SEG134 [83] return 
    rts
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b4
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp toD0181
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #BLACK
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b2_from_b5 with b2
Replacing label b1_from_b3 with b1
Replacing label b4_from_b4 with b4
Replacing label b3_from_b2 with b3
Replacing label b1_from_b1 with b1
Replacing label b1_from_b1 with b1
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_b3:
Removing instruction b2_from_b1:
Removing instruction b2_from_b5:
Removing instruction b4_from_b3:
Removing instruction b4_from_b4:
Removing instruction b3_from_b2:
Removing instruction b3_from_b4:
Removing instruction b2_from_init:
Removing instruction fill_from_b2:
Removing instruction b3_from_b2:
Removing instruction fill_from_b3:
Removing instruction toD0181_from_b3:
Removing instruction toD0181:
Removing instruction b1_from_fill:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction init_from_main:
Removing instruction b1_from_main:
Removing instruction b5:
Removing instruction b3:
Removing instruction mul8u_from_draw_block:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_mul8u:
Removing instruction breturn:
Removing instruction b4:
Removing instruction b1_from_b3:
Removing instruction b2:
Removing instruction b3:
Removing instruction b1:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Removing instruction jmp b2
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) BGCOL1
(const byte*) BGCOL1#0 BGCOL1 = (byte*) 53281
(byte*) BGCOL2
(const byte*) BGCOL2#0 BGCOL2 = (byte*) 53282
(byte*) BGCOL3
(const byte*) BGCOL3#0 BGCOL3 = (byte*) 53283
(byte*) BGCOL4
(const byte*) BGCOL4#0 BGCOL4 = (byte*) 53284
(byte) BLACK
(const byte) BLACK#0 BLACK = (byte) 0
(byte) BLUE
(const byte) BLUE#0 BLUE = (byte) 6
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = (byte*) 53280
(byte*) D018
(const byte*) D018#0 D018 = (byte*) 53272
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte) 5
(byte) RED
(const byte) RED#0 RED = (byte) 2
(byte*) SPRITES_COLS
(const byte*) SPRITES_COLS#0 SPRITES_COLS = (byte*) 53287
(byte*) SPRITES_ENABLE
(const byte*) SPRITES_ENABLE#0 SPRITES_ENABLE = (byte*) 53269
(byte*) SPRITES_EXPAND_X
(const byte*) SPRITES_EXPAND_X#0 SPRITES_EXPAND_X = (byte*) 53277
(byte*) SPRITES_EXPAND_Y
(const byte*) SPRITES_EXPAND_Y#0 SPRITES_EXPAND_Y = (byte*) 53271
(byte*) SPRITES_MC
(const byte*) SPRITES_MC#0 SPRITES_MC = (byte*) 53276
(byte*) SPRITES_XMSB
(const byte*) SPRITES_XMSB#0 SPRITES_XMSB = (byte*) 53264
(byte) WHITE
(const byte) WHITE#0 WHITE = (byte) 1
(byte) YELLOW
(const byte) YELLOW#0 YELLOW = (byte) 7
(byte*) charset
(const byte*) charset#0 charset = (byte*) 8192
(byte*) colors
(const byte*) colors#0 colors = (byte*) 55296
(void()) draw_block((byte) draw_block::tileno , (byte) draw_block::x , (byte) draw_block::y , (byte) draw_block::color)
(byte*~) draw_block::$11 $11 zp ZP_WORD:4 4.0
(byte*~) draw_block::$12 $12 zp ZP_WORD:4 4.0
(byte*~) draw_block::$13 $13 zp ZP_WORD:4 4.0
(byte*~) draw_block::$14 $14 zp ZP_WORD:4 4.0
(byte*~) draw_block::$15 $15 zp ZP_WORD:4 4.0
(byte*~) draw_block::$16 $16 zp ZP_WORD:4 4.0
(byte*~) draw_block::$17 $17 zp ZP_WORD:4 4.0
(byte*~) draw_block::$18 $18 zp ZP_WORD:9 4.0
(label) draw_block::@1
(label) draw_block::@return
(byte) draw_block::color
(byte) draw_block::drawtile
(byte) draw_block::drawtile#0 reg byte x 2.0
(byte) draw_block::tileno
(byte) draw_block::tileno#0 reg byte a 34.33333333333333
(byte) draw_block::tileno#1 tileno zp ZP_BYTE:8 0.5
(byte) draw_block::x
(byte) draw_block::x#0 reg byte y 34.33333333333333
(word) draw_block::x1
(word) draw_block::x1#0 x1 zp ZP_WORD:9 0.6666666666666666
(byte) draw_block::y
(byte) draw_block::y#0 reg byte x 34.33333333333333
(byte) draw_block::y#1 reg byte a 4.0
(word) draw_block::z
(word) draw_block::z#0 z zp ZP_WORD:4 4.0
(word) draw_block::z#1 z#1 zp ZP_WORD:9 1.125
(void()) fill((byte*) fill::start , (word) fill::size , (byte) fill::val)
(label) fill::@1
(label) fill::@return
(byte*) fill::addr
(byte*) fill::addr#0 addr zp ZP_WORD:4 2.0
(byte*) fill::addr#1 addr zp ZP_WORD:4 16.5
(byte*) fill::addr#2 addr zp ZP_WORD:4 17.5
(byte*) fill::end
(byte*) fill::end#0 end zp ZP_WORD:6 2.6
(word) fill::size
(byte*) fill::start
(byte) fill::val
(byte) fill::val#3 reg byte x 1.8333333333333333
(void()) init()
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@return
(label) init::toD0181
(word~) init::toD0181_$0
(number~) init::toD0181_$1
(number~) init::toD0181_$2
(number~) init::toD0181_$3
(word~) init::toD0181_$4
(byte~) init::toD0181_$5
(number~) init::toD0181_$6
(number~) init::toD0181_$7
(number~) init::toD0181_$8
(byte*) init::toD0181_gfx
(byte) init::toD0181_return
(const byte) init::toD0181_return#0 toD0181_return = >(word)(const byte*) screen#0&(word) $3fff*(byte) 4|>(word)(const byte*) charset#0/(byte) 4&(byte) $f
(byte*) init::toD0181_screen
(void()) init_sprites()
(label) init_sprites::@return
(byte*) level_address
(const byte*) level_address#0 level_address = (byte*) 12288
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(byte) main::tile
(byte) main::tile#0 reg byte a 202.0
(byte) main::x
(byte) main::x#1 x zp ZP_BYTE:2 16.5
(byte) main::x#4 x zp ZP_BYTE:2 22.4
(byte) main::y
(byte) main::y#1 y zp ZP_BYTE:3 151.5
(byte) main::y#2 y zp ZP_BYTE:3 57.714285714285715
(byte) main::z
(byte) main::z#0 reg byte a 202.0
(word()) mul8u((byte) mul8u::a , (byte) mul8u::b)
(byte~) mul8u::$1 reg byte a 2002.0
(label) mul8u::@1
(label) mul8u::@2
(label) mul8u::@3
(label) mul8u::@4
(label) mul8u::@return
(byte) mul8u::a
(byte) mul8u::a#0 reg byte x 1001.0
(byte) mul8u::a#1 reg byte x 2.0
(byte) mul8u::a#2 reg byte x 667.6666666666667
(byte) mul8u::b
(const byte) mul8u::b#0 b = (byte) $28
(word) mul8u::mb
(word) mul8u::mb#1 mb zp ZP_WORD:6 2002.0
(word) mul8u::mb#2 mb zp ZP_WORD:6 429.0
(word) mul8u::res
(word) mul8u::res#1 res zp ZP_WORD:4 2002.0
(word) mul8u::res#2 res zp ZP_WORD:4 500.83333333333337
(word) mul8u::res#6 res zp ZP_WORD:4 1001.0
(word) mul8u::return
(word) mul8u::return#2 return zp ZP_WORD:4 4.0
(byte*) screen
(const byte*) screen#0 screen = (byte*) 1024
(byte*) tileset
(const byte*) tileset#0 tileset = (byte*) 10240

zp ZP_BYTE:2 [ main::x#4 main::x#1 ]
zp ZP_BYTE:3 [ main::y#2 main::y#1 ]
reg byte x [ mul8u::a#2 mul8u::a#1 mul8u::a#0 ]
zp ZP_WORD:4 [ mul8u::res#2 mul8u::res#6 mul8u::res#1 mul8u::return#2 draw_block::z#0 fill::addr#2 fill::addr#0 fill::addr#1 draw_block::$11 draw_block::$12 draw_block::$13 draw_block::$14 draw_block::$15 draw_block::$16 draw_block::$17 ]
zp ZP_WORD:6 [ mul8u::mb#2 mul8u::mb#1 fill::end#0 ]
reg byte x [ fill::val#3 ]
reg byte a [ main::z#0 ]
reg byte a [ main::tile#0 ]
reg byte a [ draw_block::tileno#0 ]
reg byte y [ draw_block::x#0 ]
reg byte x [ draw_block::y#0 ]
zp ZP_BYTE:8 [ draw_block::tileno#1 ]
zp ZP_WORD:9 [ draw_block::x1#0 draw_block::z#1 draw_block::$18 ]
reg byte a [ draw_block::y#1 ]
reg byte x [ draw_block::drawtile#0 ]
reg byte a [ mul8u::$1 ]


FINAL ASSEMBLER
Score: 73438

//SEG0 File Comments
// Illustrates a problem with a missing fragment - pbuc1_derefidx_vwuz1=vbuz2
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .label SPRITES_XMSB = $d010
  .label SPRITES_ENABLE = $d015
  .label SPRITES_EXPAND_Y = $d017
  .label SPRITES_MC = $d01c
  .label SPRITES_EXPAND_X = $d01d
  .label BORDERCOL = $d020
  .label BGCOL1 = $d021
  .label BGCOL2 = $d022
  .label BGCOL3 = $d023
  .label BGCOL4 = $d024
  .label SPRITES_COLS = $d027
  .label D018 = $d018
  // The colors of the C64
  .const BLACK = 0
  .const WHITE = 1
  .const RED = 2
  .const GREEN = 5
  .const BLUE = 6
  .const YELLOW = 7
  .label screen = $400
  .label charset = $2000
  .label tileset = $2800
  .label colors = $d800
  .label level_address = $3000
//SEG3 @begin
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
//SEG5 @1
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
//SEG9 @end
//SEG10 main
main: {
    .label y = 3
    .label x = 2
  //SEG11 [5] call init 
  //SEG12 [55] phi from main to init [phi:main->init]
    jsr init
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  //SEG14 [6] phi (byte) main::x#4 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta x
  //SEG15 [6] phi from main::@3 to main::@1 [phi:main::@3->main::@1]
  //SEG16 [6] phi (byte) main::x#4 = (byte) main::x#1 [phi:main::@3->main::@1#0] -- register_copy 
  //SEG17 main::@1
  b1:
  //SEG18 [7] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  //SEG19 [7] phi (byte) main::y#2 = (byte) 0 [phi:main::@1->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta y
  //SEG20 [7] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  //SEG21 [7] phi (byte) main::y#2 = (byte) main::y#1 [phi:main::@5->main::@2#0] -- register_copy 
  //SEG22 main::@2
  b2:
  //SEG23 [8] (byte) main::z#0 ← (byte) main::x#4 + (byte) main::y#2 -- vbuaa=vbuz1_plus_vbuz2 
    lda x
    clc
    adc y
  //SEG24 [9] (byte) main::tile#0 ← *((const byte*) level_address#0 + (byte) main::z#0) -- vbuaa=pbuc1_derefidx_vbuaa 
    tay
    lda level_address,y
  //SEG25 [10] (byte) draw_block::tileno#0 ← (byte) main::tile#0
  //SEG26 [11] (byte) draw_block::x#0 ← (byte) main::x#4 -- vbuyy=vbuz1 
    ldy x
  //SEG27 [12] (byte) draw_block::y#0 ← (byte) main::y#2 -- vbuxx=vbuz1 
    ldx y
  //SEG28 [13] call draw_block 
    jsr draw_block
  //SEG29 main::@5
  //SEG30 [14] (byte) main::y#1 ← ++ (byte) main::y#2 -- vbuz1=_inc_vbuz1 
    inc y
  //SEG31 [15] if((byte) main::y#1<(byte) 9) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda y
    cmp #9
    bcc b2
  //SEG32 main::@3
  //SEG33 [16] (byte) main::x#1 ← ++ (byte) main::x#4 -- vbuz1=_inc_vbuz1 
    inc x
  //SEG34 [17] if((byte) main::x#1<(byte) $10) goto main::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda x
    cmp #$10
    bcc b1
  //SEG35 [18] phi from main::@3 main::@4 to main::@4 [phi:main::@3/main::@4->main::@4]
  //SEG36 main::@4
  b4:
    jmp b4
}
//SEG37 draw_block
// draw_block(byte register(A) tileno, byte register(Y) x, byte register(X) y)
draw_block: {
    .label tileno = 8
    .label x1 = 9
    .label z = 4
    .label z_1 = 9
    .label _11 = 4
    .label _12 = 4
    .label _13 = 4
    .label _14 = 4
    .label _15 = 4
    .label _16 = 4
    .label _17 = 4
    .label _18 = 9
  //SEG38 [19] (byte) draw_block::tileno#1 ← (byte) draw_block::tileno#0 << (byte) 2 -- vbuz1=vbuaa_rol_2 
    asl
    asl
    sta tileno
  //SEG39 [20] (word) draw_block::x1#0 ← (byte) draw_block::x#0 << (byte) 1 -- vwuz1=vbuyy_rol_1 
    tya
    asl
    sta x1
    lda #0
    rol
    sta x1+1
  //SEG40 [21] (byte) draw_block::y#1 ← (byte) draw_block::y#0 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
  //SEG41 [22] (byte) mul8u::a#1 ← (byte) draw_block::y#1 -- vbuxx=vbuaa 
    tax
  //SEG42 [23] call mul8u 
  //SEG43 [45] phi from draw_block to mul8u [phi:draw_block->mul8u]
    jsr mul8u
  //SEG44 [24] (word) mul8u::return#2 ← (word) mul8u::res#2
  //SEG45 draw_block::@1
  //SEG46 [25] (word) draw_block::z#0 ← (word) mul8u::return#2
  //SEG47 [26] (word) draw_block::z#1 ← (word) draw_block::z#0 + (word) draw_block::x1#0 -- vwuz1=vwuz2_plus_vwuz1 
    lda z_1
    clc
    adc z
    sta z_1
    lda z_1+1
    adc z+1
    sta z_1+1
  //SEG48 [27] (byte) draw_block::drawtile#0 ← *((const byte*) tileset#0 + (byte) draw_block::tileno#1) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy tileno
    ldx tileset,y
  //SEG49 [28] (byte*~) draw_block::$11 ← (const byte*) screen#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen
    sta _11
    lda z_1+1
    adc #>screen
    sta _11+1
  //SEG50 [29] *((byte*~) draw_block::$11) ← (byte) draw_block::drawtile#0 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (_11),y
  //SEG51 [30] (byte*~) draw_block::$12 ← (const byte*) colors#0 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors
    sta _12
    lda z_1+1
    adc #>colors
    sta _12+1
  //SEG52 [31] *((byte*~) draw_block::$12) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    sta (_12),y
  //SEG53 [32] (byte*~) draw_block::$13 ← (const byte*) screen#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen+1
    sta _13
    lda z_1+1
    adc #>screen+1
    sta _13+1
  //SEG54 [33] *((byte*~) draw_block::$13) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    sta (_13),y
  //SEG55 [34] (byte*~) draw_block::$14 ← (const byte*) colors#0+(byte) 1 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors+1
    sta _14
    lda z_1+1
    adc #>colors+1
    sta _14+1
  //SEG56 [35] *((byte*~) draw_block::$14) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    sta (_14),y
  //SEG57 [36] (byte*~) draw_block::$15 ← (const byte*) screen#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen+$28
    sta _15
    lda z_1+1
    adc #>screen+$28
    sta _15+1
  //SEG58 [37] *((byte*~) draw_block::$15) ← (byte) 2 -- _deref_pbuz1=vbuc1 
    lda #2
    sta (_15),y
  //SEG59 [38] (byte*~) draw_block::$16 ← (const byte*) colors#0+(byte) $28 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<colors+$28
    sta _16
    lda z_1+1
    adc #>colors+$28
    sta _16+1
  //SEG60 [39] *((byte*~) draw_block::$16) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    sta (_16),y
  //SEG61 [40] (byte*~) draw_block::$17 ← (const byte*) screen#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz2 
    lda z_1
    clc
    adc #<screen+$29
    sta _17
    lda z_1+1
    adc #>screen+$29
    sta _17+1
  //SEG62 [41] *((byte*~) draw_block::$17) ← (byte) 3 -- _deref_pbuz1=vbuc1 
    lda #3
    sta (_17),y
  //SEG63 [42] (byte*~) draw_block::$18 ← (const byte*) colors#0+(byte) $29 + (word) draw_block::z#1 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda _18
    adc #<colors+$29
    sta _18
    lda _18+1
    adc #>colors+$29
    sta _18+1
  //SEG64 [43] *((byte*~) draw_block::$18) ← (const byte) YELLOW#0 -- _deref_pbuz1=vbuc1 
    lda #YELLOW
    sta (_18),y
  //SEG65 draw_block::@return
  //SEG66 [44] return 
    rts
}
//SEG67 mul8u
// Perform binary multiplication of two unsigned 8-bit bytes into a 16-bit unsigned word
// mul8u(byte register(X) a)
mul8u: {
    .const b = $28
    .label mb = 6
    .label res = 4
    .label return = 4
  //SEG68 [46] phi from mul8u to mul8u::@1 [phi:mul8u->mul8u::@1]
  //SEG69 [46] phi (word) mul8u::mb#2 = (const byte) mul8u::b#0 [phi:mul8u->mul8u::@1#0] -- vwuz1=vbuc1 
    lda #b
    sta mb
    lda #0
    sta mb+1
  //SEG70 [46] phi (word) mul8u::res#2 = (byte) 0 [phi:mul8u->mul8u::@1#1] -- vwuz1=vbuc1 
    sta res
    sta res+1
  //SEG71 [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#1 [phi:mul8u->mul8u::@1#2] -- register_copy 
  //SEG72 mul8u::@1
  b1:
  //SEG73 [47] if((byte) mul8u::a#2!=(byte) 0) goto mul8u::@2 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne b2
  //SEG74 mul8u::@return
  //SEG75 [48] return 
    rts
  //SEG76 mul8u::@2
  b2:
  //SEG77 [49] (byte~) mul8u::$1 ← (byte) mul8u::a#2 & (byte) 1 -- vbuaa=vbuxx_band_vbuc1 
    txa
    and #1
  //SEG78 [50] if((byte~) mul8u::$1==(byte) 0) goto mul8u::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b3
  //SEG79 mul8u::@4
  //SEG80 [51] (word) mul8u::res#1 ← (word) mul8u::res#2 + (word) mul8u::mb#2 -- vwuz1=vwuz1_plus_vwuz2 
    lda res
    clc
    adc mb
    sta res
    lda res+1
    adc mb+1
    sta res+1
  //SEG81 [52] phi from mul8u::@2 mul8u::@4 to mul8u::@3 [phi:mul8u::@2/mul8u::@4->mul8u::@3]
  //SEG82 [52] phi (word) mul8u::res#6 = (word) mul8u::res#2 [phi:mul8u::@2/mul8u::@4->mul8u::@3#0] -- register_copy 
  //SEG83 mul8u::@3
  b3:
  //SEG84 [53] (byte) mul8u::a#0 ← (byte) mul8u::a#2 >> (byte) 1 -- vbuxx=vbuxx_ror_1 
    txa
    lsr
    tax
  //SEG85 [54] (word) mul8u::mb#1 ← (word) mul8u::mb#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl mb
    rol mb+1
  //SEG86 [46] phi from mul8u::@3 to mul8u::@1 [phi:mul8u::@3->mul8u::@1]
  //SEG87 [46] phi (word) mul8u::mb#2 = (word) mul8u::mb#1 [phi:mul8u::@3->mul8u::@1#0] -- register_copy 
  //SEG88 [46] phi (word) mul8u::res#2 = (word) mul8u::res#6 [phi:mul8u::@3->mul8u::@1#1] -- register_copy 
  //SEG89 [46] phi (byte) mul8u::a#2 = (byte) mul8u::a#0 [phi:mul8u::@3->mul8u::@1#2] -- register_copy 
    jmp b1
}
//SEG90 init
init: {
    .const toD0181_return = (>(screen&$3fff)*4)|(>charset)/4&$f
  //SEG91 [56] call init_sprites 
    jsr init_sprites
  //SEG92 [57] phi from init to init::@2 [phi:init->init::@2]
  //SEG93 init::@2
  //SEG94 [58] call fill 
  //SEG95 [70] phi from init::@2 to fill [phi:init::@2->fill]
  //SEG96 [70] phi (byte) fill::val#3 = (byte) 0 [phi:init::@2->fill#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG97 [70] phi (byte*) fill::addr#0 = (const byte*) screen#0 [phi:init::@2->fill#1] -- pbuz1=pbuc1 
    lda #<screen
    sta fill.addr
    lda #>screen
    sta fill.addr+1
    jsr fill
  //SEG98 [59] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  //SEG99 init::@3
  //SEG100 [60] call fill 
  //SEG101 [70] phi from init::@3 to fill [phi:init::@3->fill]
  //SEG102 [70] phi (byte) fill::val#3 = (const byte) BLACK#0 [phi:init::@3->fill#0] -- vbuxx=vbuc1 
    ldx #BLACK
  //SEG103 [70] phi (byte*) fill::addr#0 = (const byte*) colors#0 [phi:init::@3->fill#1] -- pbuz1=pbuc1 
    lda #<colors
    sta fill.addr
    lda #>colors
    sta fill.addr+1
    jsr fill
  //SEG104 [61] phi from init::@3 to init::toD0181 [phi:init::@3->init::toD0181]
  //SEG105 init::toD0181
  //SEG106 init::@1
  //SEG107 [62] *((const byte*) D018#0) ← (const byte) init::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    lda #toD0181_return
    sta D018
  //SEG108 asm { lda#$5b sta$d011  }
    lda #$5b
    sta $d011
  //SEG109 [64] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  //SEG110 [65] *((const byte*) BGCOL1#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    sta BGCOL1
  //SEG111 [66] *((const byte*) BGCOL2#0) ← (const byte) RED#0 -- _deref_pbuc1=vbuc2 
    lda #RED
    sta BGCOL2
  //SEG112 [67] *((const byte*) BGCOL3#0) ← (const byte) BLUE#0 -- _deref_pbuc1=vbuc2 
    lda #BLUE
    sta BGCOL3
  //SEG113 [68] *((const byte*) BGCOL4#0) ← (const byte) GREEN#0 -- _deref_pbuc1=vbuc2 
    lda #GREEN
    sta BGCOL4
  //SEG114 init::@return
  //SEG115 [69] return 
    rts
}
//SEG116 fill
// Fill some memory with a value
// fill(byte register(X) val)
fill: {
    .label end = 6
    .label addr = 4
  //SEG117 [71] (byte*) fill::end#0 ← (byte*) fill::addr#0 + (word) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda addr
    clc
    adc #<$3e8
    sta end
    lda addr+1
    adc #>$3e8
    sta end+1
  //SEG118 [72] phi from fill fill::@1 to fill::@1 [phi:fill/fill::@1->fill::@1]
  //SEG119 [72] phi (byte*) fill::addr#2 = (byte*) fill::addr#0 [phi:fill/fill::@1->fill::@1#0] -- register_copy 
  //SEG120 fill::@1
  b1:
  //SEG121 [73] *((byte*) fill::addr#2) ← (byte) fill::val#3 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (addr),y
  //SEG122 [74] (byte*) fill::addr#1 ← ++ (byte*) fill::addr#2 -- pbuz1=_inc_pbuz1 
    inc addr
    bne !+
    inc addr+1
  !:
  //SEG123 [75] if((byte*) fill::addr#1!=(byte*) fill::end#0) goto fill::@1 -- pbuz1_neq_pbuz2_then_la1 
    lda addr+1
    cmp end+1
    bne b1
    lda addr
    cmp end
    bne b1
  //SEG124 fill::@return
  //SEG125 [76] return 
    rts
}
//SEG126 init_sprites
init_sprites: {
  //SEG127 [77] *((const byte*) SPRITES_ENABLE#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta SPRITES_ENABLE
  //SEG128 [78] *((const byte*) SPRITES_EXPAND_X#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // one sprite enabled
    lda #0
    sta SPRITES_EXPAND_X
  //SEG129 [79] *((const byte*) SPRITES_EXPAND_Y#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    sta SPRITES_EXPAND_Y
  //SEG130 [80] *((const byte*) SPRITES_XMSB#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    sta SPRITES_XMSB
  //SEG131 [81] *((const byte*) SPRITES_COLS#0) ← (const byte) WHITE#0 -- _deref_pbuc1=vbuc2 
    lda #WHITE
    sta SPRITES_COLS
  //SEG132 [82] *((const byte*) SPRITES_MC#0) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta SPRITES_MC
  //SEG133 init_sprites::@return
  //SEG134 [83] return 
    rts
}

