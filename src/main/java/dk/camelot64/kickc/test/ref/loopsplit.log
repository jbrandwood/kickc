main();

void main() {
  byte i=100;
  byte s=0;
  while(--i>0) {
      if(i>50) {
         s++;
      } else {
         s--;
      }
  }
}

Adding pre/post-modifier (byte) main::i ← -- (byte) main::i
Adding pre/post-modifier (byte) main::s ← ++ (byte) main::s
Adding pre/post-modifier (byte) main::s ← -- (byte) main::s
PROGRAM
  (void~) $0 ← call main 
  proc (void()) main()
  (byte) main::i ← (byte) 100
  (byte) main::s ← (byte) 0
main::@1:
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$0 ← (byte) main::i > (byte) 0
  if((boolean~) main::$0) goto main::@2
  goto main::@3
main::@2:
  (boolean~) main::$1 ← (byte) main::i > (byte) 50
  if((boolean~) main::$1) goto main::@4
  goto main::@5
main::@4:
  (byte) main::s ← ++ (byte) main::s
  goto main::@6
main::@5:
  (byte) main::s ← -- (byte) main::s
main::@6:
  goto main::@1
main::@3:
main::@return:
  return 
  endproc // main()

SYMBOLS
(void~) $0
(void()) main()
(boolean~) main::$0
(boolean~) main::$1
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@return
(byte) main::i
(byte) main::s

INITIAL CONTROL FLOW GRAPH
@BEGIN: from
  (void~) $0 ← call main 
  to:@1
main: from
  (byte) main::i ← (byte) 100
  (byte) main::s ← (byte) 0
  to:main::@1
main::@1: from main main::@6
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$0 ← (byte) main::i > (byte) 0
  if((boolean~) main::$0) goto main::@2
  to:main::@7
main::@2: from main::@1 main::@8
  (boolean~) main::$1 ← (byte) main::i > (byte) 50
  if((boolean~) main::$1) goto main::@4
  to:main::@9
main::@7: from main::@1
  to:main::@3
main::@3: from main::@12 main::@7
  to:main::@return
main::@8: from
  to:main::@2
main::@4: from main::@10 main::@2
  (byte) main::s ← ++ (byte) main::s
  to:main::@6
main::@9: from main::@2
  to:main::@5
main::@5: from main::@11 main::@9
  (byte) main::s ← -- (byte) main::s
  to:main::@6
main::@10: from
  to:main::@4
main::@6: from main::@4 main::@5
  to:main::@1
main::@11: from
  to:main::@5
main::@12: from
  to:main::@3
main::@return: from main::@3
  return 
  to:@RETURN
@1: from @BEGIN
  to:@END
@END: from @1

Removing empty block main::@7
Removing empty block main::@3
Removing empty block main::@8
Removing empty block main::@9
Removing empty block main::@10
Removing empty block main::@6
Removing empty block main::@11
Removing empty block main::@12
Removing empty block @1
CONTROL FLOW GRAPH
@BEGIN: from
  (void~) $0 ← call main 
  to:@END
main: from
  (byte) main::i ← (byte) 100
  (byte) main::s ← (byte) 0
  to:main::@1
main::@1: from main main::@4 main::@5
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$0 ← (byte) main::i > (byte) 0
  if((boolean~) main::$0) goto main::@2
  to:main::@return
main::@2: from main::@1
  (boolean~) main::$1 ← (byte) main::i > (byte) 50
  if((boolean~) main::$1) goto main::@4
  to:main::@5
main::@4: from main::@2
  (byte) main::s ← ++ (byte) main::s
  to:main::@1
main::@5: from main::@2
  (byte) main::s ← -- (byte) main::s
  to:main::@1
main::@return: from main::@1
  return 
  to:@RETURN
@END: from @BEGIN

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@BEGIN: from
  call main param-assignment
  to:@2
@2: from @BEGIN
  to:@END
main: from @BEGIN
  (byte) main::i ← (byte) 100
  (byte) main::s ← (byte) 0
  to:main::@1
main::@1: from main main::@4 main::@5
  (byte) main::i ← -- (byte) main::i
  (boolean~) main::$0 ← (byte) main::i > (byte) 0
  if((boolean~) main::$0) goto main::@2
  to:main::@return
main::@2: from main::@1
  (boolean~) main::$1 ← (byte) main::i > (byte) 50
  if((boolean~) main::$1) goto main::@4
  to:main::@5
main::@4: from main::@2
  (byte) main::s ← ++ (byte) main::s
  to:main::@1
main::@5: from main::@2
  (byte) main::s ← -- (byte) main::s
  to:main::@1
main::@return: from main::@1
  return 
  to:@RETURN
@END: from @2

Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@BEGIN: from
  call main param-assignment
  to:@2
@2: from @BEGIN
  to:@END
main: from @BEGIN
  (byte) main::i#0 ← (byte) 100
  (byte) main::s#0 ← (byte) 0
  to:main::@1
main::@1: from main main::@4 main::@5
  (byte) main::s#6 ← phi( main/(byte) main::s#0 main::@4/(byte) main::s#1 main::@5/(byte) main::s#2 )
  (byte) main::i#2 ← phi( main/(byte) main::i#0 main::@4/(byte) main::i#4 main::@5/(byte) main::i#5 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$0 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$0) goto main::@2
  to:main::@return
main::@2: from main::@1
  (byte) main::s#5 ← phi( main::@1/(byte) main::s#6 )
  (byte) main::i#3 ← phi( main::@1/(byte) main::i#1 )
  (boolean~) main::$1 ← (byte) main::i#3 > (byte) 50
  if((boolean~) main::$1) goto main::@4
  to:main::@5
main::@4: from main::@2
  (byte) main::i#4 ← phi( main::@2/(byte) main::i#3 )
  (byte) main::s#3 ← phi( main::@2/(byte) main::s#5 )
  (byte) main::s#1 ← ++ (byte) main::s#3
  to:main::@1
main::@5: from main::@2
  (byte) main::i#5 ← phi( main::@2/(byte) main::i#3 )
  (byte) main::s#4 ← phi( main::@2/(byte) main::s#5 )
  (byte) main::s#2 ← -- (byte) main::s#4
  to:main::@1
main::@return: from main::@1
  return 
  to:@RETURN
@END: from @2

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@BEGIN: from
  call main param-assignment
  to:@2
@2: from @BEGIN
  to:@END
main: from @BEGIN
  (byte) main::i#0 ← (byte) 100
  (byte) main::s#0 ← (byte) 0
  to:main::@1
main::@1: from main main::@4 main::@5
  (byte) main::s#6 ← phi( main/(byte) main::s#0 main::@4/(byte) main::s#1 main::@5/(byte) main::s#2 )
  (byte) main::i#2 ← phi( main/(byte) main::i#0 main::@4/(byte) main::i#4 main::@5/(byte) main::i#5 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$0 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$0) goto main::@2
  to:main::@return
main::@2: from main::@1
  (byte) main::s#5 ← phi( main::@1/(byte) main::s#6 )
  (byte) main::i#3 ← phi( main::@1/(byte) main::i#1 )
  (boolean~) main::$1 ← (byte) main::i#3 > (byte) 50
  if((boolean~) main::$1) goto main::@4
  to:main::@5
main::@4: from main::@2
  (byte) main::i#4 ← phi( main::@2/(byte) main::i#3 )
  (byte) main::s#3 ← phi( main::@2/(byte) main::s#5 )
  (byte) main::s#1 ← ++ (byte) main::s#3
  to:main::@1
main::@5: from main::@2
  (byte) main::i#5 ← phi( main::@2/(byte) main::i#3 )
  (byte) main::s#4 ← phi( main::@2/(byte) main::s#5 )
  (byte) main::s#2 ← -- (byte) main::s#4
  to:main::@1
main::@return: from main::@1
  return 
  to:@RETURN
@END: from @2

Culled Empty Block (label) @2
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  (byte) main::i#0 ← (byte) 100
  (byte) main::s#0 ← (byte) 0
  to:main::@1
main::@1: from main main::@4 main::@5
  (byte) main::s#6 ← phi( main/(byte) main::s#0 main::@4/(byte) main::s#1 main::@5/(byte) main::s#2 )
  (byte) main::i#2 ← phi( main/(byte) main::i#0 main::@4/(byte) main::i#4 main::@5/(byte) main::i#5 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$0 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$0) goto main::@2
  to:main::@return
main::@2: from main::@1
  (byte) main::s#5 ← phi( main::@1/(byte) main::s#6 )
  (byte) main::i#3 ← phi( main::@1/(byte) main::i#1 )
  (boolean~) main::$1 ← (byte) main::i#3 > (byte) 50
  if((boolean~) main::$1) goto main::@4
  to:main::@5
main::@4: from main::@2
  (byte) main::i#4 ← phi( main::@2/(byte) main::i#3 )
  (byte) main::s#3 ← phi( main::@2/(byte) main::s#5 )
  (byte) main::s#1 ← ++ (byte) main::s#3
  to:main::@1
main::@5: from main::@2
  (byte) main::i#5 ← phi( main::@2/(byte) main::i#3 )
  (byte) main::s#4 ← phi( main::@2/(byte) main::s#5 )
  (byte) main::s#2 ← -- (byte) main::s#4
  to:main::@1
main::@return: from main::@1
  return 
  to:@RETURN
@END: from @BEGIN

Constant (byte) main::i#0 (byte) 100
Constant (byte) main::s#0 (byte) 0
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@4 main::@5
  (byte) main::s#6 ← phi( main/(byte) 0 main::@4/(byte) main::s#1 main::@5/(byte) main::s#2 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@4/(byte) main::i#4 main::@5/(byte) main::i#5 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$0 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$0) goto main::@2
  to:main::@return
main::@2: from main::@1
  (byte) main::s#5 ← phi( main::@1/(byte) main::s#6 )
  (byte) main::i#3 ← phi( main::@1/(byte) main::i#1 )
  (boolean~) main::$1 ← (byte) main::i#3 > (byte) 50
  if((boolean~) main::$1) goto main::@4
  to:main::@5
main::@4: from main::@2
  (byte) main::i#4 ← phi( main::@2/(byte) main::i#3 )
  (byte) main::s#3 ← phi( main::@2/(byte) main::s#5 )
  (byte) main::s#1 ← ++ (byte) main::s#3
  to:main::@1
main::@5: from main::@2
  (byte) main::i#5 ← phi( main::@2/(byte) main::i#3 )
  (byte) main::s#4 ← phi( main::@2/(byte) main::s#5 )
  (byte) main::s#2 ← -- (byte) main::s#4
  to:main::@1
main::@return: from main::@1
  return 
  to:@RETURN
@END: from @BEGIN

Alias (byte) main::i#1 = (byte) main::i#3 (byte) main::i#4 (byte) main::i#5 
Alias (byte) main::s#3 = (byte) main::s#5 (byte) main::s#6 (byte) main::s#4 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@4 main::@5
  (byte) main::s#3 ← phi( main/(byte) 0 main::@4/(byte) main::s#1 main::@5/(byte) main::s#2 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@4/(byte) main::i#1 main::@5/(byte) main::i#1 )
  (byte) main::i#1 ← -- (byte) main::i#2
  (boolean~) main::$0 ← (byte) main::i#1 > (byte) 0
  if((boolean~) main::$0) goto main::@2
  to:main::@return
main::@2: from main::@1
  (boolean~) main::$1 ← (byte) main::i#1 > (byte) 50
  if((boolean~) main::$1) goto main::@4
  to:main::@5
main::@4: from main::@2
  (byte) main::s#1 ← ++ (byte) main::s#3
  to:main::@1
main::@5: from main::@2
  (byte) main::s#2 ← -- (byte) main::s#3
  to:main::@1
main::@return: from main::@1
  return 
  to:@RETURN
@END: from @BEGIN

Simple Condition (boolean~) main::$0 if((byte) main::i#1>(byte) 0) goto main::@2
Simple Condition (boolean~) main::$1 if((byte) main::i#1>(byte) 50) goto main::@4
Succesful SSA optimization Pass2ConditionalJumpSimplification
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  to:main::@1
main::@1: from main main::@4 main::@5
  (byte) main::s#3 ← phi( main/(byte) 0 main::@4/(byte) main::s#1 main::@5/(byte) main::s#2 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@4/(byte) main::i#1 main::@5/(byte) main::i#1 )
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@2
  to:main::@return
main::@2: from main::@1
  if((byte) main::i#1>(byte) 50) goto main::@4
  to:main::@5
main::@4: from main::@2
  (byte) main::s#1 ← ++ (byte) main::s#3
  to:main::@1
main::@5: from main::@2
  (byte) main::s#2 ← -- (byte) main::s#3
  to:main::@1
main::@return: from main::@1
  return 
  to:@RETURN
@END: from @BEGIN

Block Sequence Planned @BEGIN @END main main::@1 main::@return main::@2 main::@5 main::@4 
Block Sequence Planned @BEGIN @END main main::@1 main::@return main::@2 main::@5 main::@4 
CONTROL FLOW GRAPH - PHI LIFTED
@BEGIN: from
  call main param-assignment
  to:@END
@END: from @BEGIN
main: from @BEGIN
  to:main::@1
main::@1: from main main::@4 main::@5
  (byte) main::s#3 ← phi( main/(byte) 0 main::@4/(byte~) main::s#7 main::@5/(byte~) main::s#8 )
  (byte) main::i#2 ← phi( main/(byte) 100 main::@4/(byte~) main::i#6 main::@5/(byte~) main::i#7 )
  (byte) main::i#1 ← -- (byte) main::i#2
  if((byte) main::i#1>(byte) 0) goto main::@2
  to:main::@return
main::@return: from main::@1
  return 
  to:@RETURN
main::@2: from main::@1
  if((byte) main::i#1>(byte) 50) goto main::@4
  to:main::@5
main::@5: from main::@2
  (byte) main::s#2 ← -- (byte) main::s#3
  (byte~) main::i#7 ← (byte) main::i#1
  (byte~) main::s#8 ← (byte) main::s#2
  to:main::@1
main::@4: from main::@2
  (byte) main::s#1 ← ++ (byte) main::s#3
  (byte~) main::i#6 ← (byte) main::i#1
  (byte~) main::s#7 ← (byte) main::s#1
  to:main::@1

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@BEGIN: from
  [0] call main param-assignment [ ]
  to:@END
@END: from @BEGIN
main: from @BEGIN
  to:main::@1
main::@1: from main main::@4 main::@5
  [1] (byte) main::s#3 ← phi( main/(byte) 0 main::@4/(byte~) main::s#7 main::@5/(byte~) main::s#8 ) [ main::i#2 main::s#3 ]
  [1] (byte) main::i#2 ← phi( main/(byte) 100 main::@4/(byte~) main::i#6 main::@5/(byte~) main::i#7 ) [ main::i#2 main::s#3 ]
  [2] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 main::s#3 ]
  [3] if((byte) main::i#1>(byte) 0) goto main::@2 [ main::i#1 main::s#3 ]
  to:main::@return
main::@return: from main::@1
  [4] return  [ ]
  to:@RETURN
main::@2: from main::@1
  [5] if((byte) main::i#1>(byte) 50) goto main::@4 [ main::i#1 main::s#3 ]
  to:main::@5
main::@5: from main::@2
  [6] (byte) main::s#2 ← -- (byte) main::s#3 [ main::i#1 main::s#2 ]
  [7] (byte~) main::i#7 ← (byte) main::i#1 [ main::i#7 main::s#2 ]
  [8] (byte~) main::s#8 ← (byte) main::s#2 [ main::i#7 main::s#8 ]
  to:main::@1
main::@4: from main::@2
  [9] (byte) main::s#1 ← ++ (byte) main::s#3 [ main::i#1 main::s#1 ]
  [10] (byte~) main::i#6 ← (byte) main::i#1 [ main::i#6 main::s#1 ]
  [11] (byte~) main::s#7 ← (byte) main::s#1 [ main::i#6 main::s#7 ]
  to:main::@1

Created 2 initial phi equivalence classes
Coalesced [7] main::i#7 ← main::i#1
Coalesced [8] main::s#8 ← main::s#2
Coalesced (already) [10] main::i#6 ← main::i#1
Coalesced [11] main::s#7 ← main::s#1
Coalesced down to 2 phi equivalence classes
Block Sequence Planned @BEGIN @END main main::@1 main::@return main::@2 main::@5 main::@4 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@BEGIN: from
  [0] call main param-assignment [ ]
  to:@END
@END: from @BEGIN
main: from @BEGIN
  to:main::@1
main::@1: from main main::@4 main::@5
  [1] (byte) main::s#3 ← phi( main/(byte) 0 main::@4/(byte) main::s#1 main::@5/(byte) main::s#2 ) [ main::i#2 main::s#3 ]
  [1] (byte) main::i#2 ← phi( main/(byte) 100 main::@4/(byte) main::i#1 main::@5/(byte) main::i#1 ) [ main::i#2 main::s#3 ]
  [2] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 main::s#3 ]
  [3] if((byte) main::i#1>(byte) 0) goto main::@2 [ main::i#1 main::s#3 ]
  to:main::@return
main::@return: from main::@1
  [4] return  [ ]
  to:@RETURN
main::@2: from main::@1
  [5] if((byte) main::i#1>(byte) 50) goto main::@4 [ main::i#1 main::s#3 ]
  to:main::@5
main::@5: from main::@2
  [6] (byte) main::s#2 ← -- (byte) main::s#3 [ main::i#1 main::s#2 ]
  to:main::@1
main::@4: from main::@2
  [7] (byte) main::s#1 ← ++ (byte) main::s#3 [ main::i#1 main::s#1 ]
  to:main::@1

CALL GRAPH
Calls in [] to 0:main 

DOMINATORS
@BEGIN dominated by  @BEGIN 
@END dominated by  @BEGIN @END 
main dominated by  @BEGIN main 
main::@1 dominated by  @BEGIN main::@1 main 
main::@return dominated by  @BEGIN main::@return main::@1 main 
main::@2 dominated by  @BEGIN main::@2 main::@1 main 
main::@5 dominated by  @BEGIN main::@2 main::@1 main::@5 main 
main::@4 dominated by  @BEGIN main::@2 main::@1 main::@4 main 

Found back edge: Loop head: main::@1 tails: main::@5 blocks: null
Found back edge: Loop head: main::@1 tails: main::@4 blocks: null
Populated: Loop head: main::@1 tails: main::@5 blocks: main::@5 main::@2 main::@1 
Populated: Loop head: main::@1 tails: main::@4 blocks: main::@4 main::@2 main::@1 
Coalesced: Loop head: main::@1 tails: main::@5 main::@4 blocks: main::@5 main::@2 main::@1 main::@4 
NATURAL LOOPS
Loop head: main::@1 tails: main::@5 main::@4 blocks: main::@5 main::@2 main::@1 main::@4 

Found 0 loops in scope []
Found 1 loops in scope [main]
  Loop head: main::@1 tails: main::@5 main::@4 blocks: main::@5 main::@2 main::@1 main::@4 
NATURAL LOOPS WITH DEPTH
Loop head: main::@1 tails: main::@5 main::@4 blocks: main::@5 main::@2 main::@1 main::@4  depth: 1

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ main::s#3 main::s#1 main::s#2 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ main::s#3 main::s#1 main::s#2 ]
Allocated zp byte:2 to zp byte:2 [ main::i#2 main::i#1 ]
Allocated zp byte:3 to zp byte:3 [ main::s#3 main::s#1 main::s#2 ]

VARIABLE REGISTER WEIGHTS
(void()) main()
(byte) main::i
(byte) main::i#1 11.0
(byte) main::i#2 33.0
(byte) main::s
(byte) main::s#1 22.0
(byte) main::s#2 22.0
(byte) main::s#3 11.0

zp byte:2 [ main::i#2 main::i#1 ]
zp byte:3 [ main::s#3 main::s#1 main::s#2 ]

Uplifting max weight 55.0 live range equivalence class zp byte:3 [ main::s#3 main::s#1 main::s#2 ]
Uplift to reg byte a resulted in clobber.
Register Cycles: reg byte x 24
Uplift to reg byte x succesfull.
Register Cycles: reg byte y 24
Uplift to reg byte y succesfull.
REGISTER UPLIFTING
(void()) main()
(byte) main::i
(byte) main::i#1 zp byte:2 11.0
(byte) main::i#2 zp byte:2 33.0
(byte) main::s
(byte) main::s#1 zp byte:3 22.0
(byte) main::s#2 zp byte:3 22.0
(byte) main::s#3 zp byte:3 11.0

zp byte:2 [ main::i#2 main::i#1 ]
zp byte:3 [ main::s#3 main::s#1 main::s#2 ]

INITIAL ASM
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
  jmp BEND
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] phi from main to main::@1
main__B1_from_main:
//SEG5 [1] phi (byte) main::s#3 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 3
//SEG6 [1] phi (byte) main::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 2
  jmp main__B1
//SEG7 main::@1
main__B1:
//SEG8 [2] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 main::s#3 ] -- zpby1=_dec_zpby1 
  dec 2
//SEG9 [3] if((byte) main::i#1>(byte) 0) goto main::@2 [ main::i#1 main::s#3 ] -- zpby1_gt_0_then_la1 
  lda 2
  bne main__B2
  jmp main__Breturn
//SEG10 main::@return
main__Breturn:
//SEG11 [4] return  [ ]
  rts
//SEG12 main::@2
main__B2:
//SEG13 [5] if((byte) main::i#1>(byte) 50) goto main::@4 [ main::i#1 main::s#3 ] -- zpby1_gt_coby1_then_la1 
  lda 2
  cmp #50
  beq !+
  bcs main__B4
!:
  jmp main__B5
//SEG14 main::@5
main__B5:
//SEG15 [6] (byte) main::s#2 ← -- (byte) main::s#3 [ main::i#1 main::s#2 ] -- zpby1=_dec_zpby1 
  dec 3
//SEG16 [1] phi from main::@5 to main::@1
main__B1_from_B5:
//SEG17 [1] phi (byte) main::s#3 = (byte) main::s#2 -- register_copy 
//SEG18 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
  jmp main__B1
//SEG19 main::@4
main__B4:
//SEG20 [7] (byte) main::s#1 ← ++ (byte) main::s#3 [ main::i#1 main::s#1 ] -- zpby1=_inc_zpby1 
  inc 3
//SEG21 [1] phi from main::@4 to main::@1
main__B1_from_B4:
//SEG22 [1] phi (byte) main::s#3 = (byte) main::s#1 -- register_copy 
//SEG23 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
  jmp main__B1

Removing instruction jmp BEND
Removing instruction jmp main__B1
Removing instruction jmp main__Breturn
Removing instruction jmp main__B5
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] phi from main to main::@1
main__B1_from_main:
//SEG5 [1] phi (byte) main::s#3 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 3
//SEG6 [1] phi (byte) main::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 2
//SEG7 main::@1
main__B1:
//SEG8 [2] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 main::s#3 ] -- zpby1=_dec_zpby1 
  dec 2
//SEG9 [3] if((byte) main::i#1>(byte) 0) goto main::@2 [ main::i#1 main::s#3 ] -- zpby1_gt_0_then_la1 
  lda 2
  bne main__B2
//SEG10 main::@return
main__Breturn:
//SEG11 [4] return  [ ]
  rts
//SEG12 main::@2
main__B2:
//SEG13 [5] if((byte) main::i#1>(byte) 50) goto main::@4 [ main::i#1 main::s#3 ] -- zpby1_gt_coby1_then_la1 
  lda 2
  cmp #50
  beq !+
  bcs main__B4
!:
//SEG14 main::@5
main__B5:
//SEG15 [6] (byte) main::s#2 ← -- (byte) main::s#3 [ main::i#1 main::s#2 ] -- zpby1=_dec_zpby1 
  dec 3
//SEG16 [1] phi from main::@5 to main::@1
main__B1_from_B5:
//SEG17 [1] phi (byte) main::s#3 = (byte) main::s#2 -- register_copy 
//SEG18 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
  jmp main__B1
//SEG19 main::@4
main__B4:
//SEG20 [7] (byte) main::s#1 ← ++ (byte) main::s#3 [ main::i#1 main::s#1 ] -- zpby1=_inc_zpby1 
  inc 3
//SEG21 [1] phi from main::@4 to main::@1
main__B1_from_B4:
//SEG22 [1] phi (byte) main::s#3 = (byte) main::s#1 -- register_copy 
//SEG23 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
  jmp main__B1

FINAL SYMBOL TABLE
(label) @BEGIN
(label) @END
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@4
(label) main::@5
(label) main::@return
(byte) main::i
(byte) main::i#1 zp byte:2 11.0
(byte) main::i#2 zp byte:2 33.0
(byte) main::s
(byte) main::s#1 zp byte:3 22.0
(byte) main::s#2 zp byte:3 22.0
(byte) main::s#3 zp byte:3 11.0

zp byte:2 [ main::i#2 main::i#1 ]
zp byte:3 [ main::s#3 main::s#1 main::s#2 ]

FINAL CODE
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] phi from main to main::@1
main__B1_from_main:
//SEG5 [1] phi (byte) main::s#3 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 3
//SEG6 [1] phi (byte) main::i#2 = (byte) 100 -- zpby1=coby1 
  lda #100
  sta 2
//SEG7 main::@1
main__B1:
//SEG8 [2] (byte) main::i#1 ← -- (byte) main::i#2 [ main::i#1 main::s#3 ] -- zpby1=_dec_zpby1 
  dec 2
//SEG9 [3] if((byte) main::i#1>(byte) 0) goto main::@2 [ main::i#1 main::s#3 ] -- zpby1_gt_0_then_la1 
  lda 2
  bne main__B2
//SEG10 main::@return
main__Breturn:
//SEG11 [4] return  [ ]
  rts
//SEG12 main::@2
main__B2:
//SEG13 [5] if((byte) main::i#1>(byte) 50) goto main::@4 [ main::i#1 main::s#3 ] -- zpby1_gt_coby1_then_la1 
  lda 2
  cmp #50
  beq !+
  bcs main__B4
!:
//SEG14 main::@5
main__B5:
//SEG15 [6] (byte) main::s#2 ← -- (byte) main::s#3 [ main::i#1 main::s#2 ] -- zpby1=_dec_zpby1 
  dec 3
//SEG16 [1] phi from main::@5 to main::@1
main__B1_from_B5:
//SEG17 [1] phi (byte) main::s#3 = (byte) main::s#2 -- register_copy 
//SEG18 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
  jmp main__B1
//SEG19 main::@4
main__B4:
//SEG20 [7] (byte) main::s#1 ← ++ (byte) main::s#3 [ main::i#1 main::s#1 ] -- zpby1=_inc_zpby1 
  inc 3
//SEG21 [1] phi from main::@4 to main::@1
main__B1_from_B4:
//SEG22 [1] phi (byte) main::s#3 = (byte) main::s#1 -- register_copy 
//SEG23 [1] phi (byte) main::i#2 = (byte) main::i#1 -- register_copy 
  jmp main__B1

